id,quality_attribute,keyword,matched_word,match_idx,sentence,source,filename,author,repo,version,wiki,url
https://qutip.org/docs/4.7/guide/dynamics/dynamics-master.html:2915,Security,access,accessible,2915,"ses it is useful to expand the PDE in a set of basis functions that span the Hilbert space of the Hamiltonian, and to write the equation in matrix and vector form. \[i\hbar\frac{d}{dt}\left|\psi\right> = H \left|\psi\right>\]; where \(\left|\psi\right>\) is the state vector and \(H\) is the matrix representation of the Hamiltonian. This matrix equation can, in principle, be solved by diagonalizing the Hamiltonian matrix \(H\). In practice, however, it is difficult to perform this diagonalization unless the size of the Hilbert space (dimension of the matrix \(H\)) is small. Analytically, it is a formidable task to calculate the dynamics for systems with more than two states. If, in addition, we consider dissipation due to the inevitable interaction with a surrounding environment, the computational complexity grows even larger, and we have to resort to numerical calculations in all realistic situations. This illustrates the importance of numerical calculations in describing the dynamics of open quantum systems, and the need for efficient and accessible tools for this task.; The Schrödinger equation, which governs the time-evolution of closed quantum systems, is defined by its Hamiltonian and state vector. In the previous section, Using Tensor Products and Partial Traces, we showed how Hamiltonians and state vectors are constructed in QuTiP. Given a Hamiltonian, we can calculate the unitary (non-dissipative) time-evolution of an arbitrary state vector \(\left|\psi_0\right>\) (psi0) using the QuTiP function qutip.sesolve. It evolves the state vector and evaluates the expectation values for a set of operators expt_ops at the points in time in the list times, using an ordinary differential equation solver.; For example, the time evolution of a quantum spin-1/2 system with tunneling rate 0.1 that initially is in the up state is calculated, and the expectation values of the \(\sigma_z\) operator evaluated, with the following code; >>> H = 2*np.pi * 0.1 * sigmax(); >>> psi0 =",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-master.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-master.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-monte.html:7997,Availability,error,errors,7997," are on the order of a couple of hundred states or smaller.; Like the master equation solver qutip.mesolve, the Monte Carlo solver returns a qutip.solver.Result object consisting of expectation values, if the user has defined expectation value operators in the 5th argument to mcsolve, or state vectors if no expectation value operators are given. If state vectors are returned, then the qutip.solver.Result returned by qutip.mcsolve will be an array of length ntraj, with each element containing an array of ket-type qobjs with the same number of elements as times. Furthermore, the output qutip.solver.Result object will also contain a list of times at which collapse occurred, and which collapse operators did the collapse, in the col_times and col_which properties, respectively. Changing the Number of Trajectories¶; As mentioned earlier, by default, the mcsolve function runs 500 trajectories. This value was chosen because it gives good accuracy, Monte Carlo errors scale as \(1/n\) where \(n\) is the number of trajectories, and simultaneously does not take an excessive amount of time to run. However, like many other options in QuTiP you are free to change the number of trajectories to fit your needs. If we want to run 1000 trajectories in the above example, we can simply modify the call to mcsolve like:; data = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm], ntraj=1000). where we have added the keyword argument ntraj=1000 at the end of the inputs. Now, the Monte Carlo solver will calculate expectation values for both operators, a.dag() * a, sm.dag() * sm averaging over 1000 trajectories. Sometimes one is also interested in seeing how the Monte Carlo trajectories converge to the master equation solution by calculating expectation values over a range of trajectory numbers. If, for example, we want to average over 1, 10, 100, and 1000 trajectories, then we can input this into the solver using:; ntraj = [1, 10, 100, 1000]. Keep in mind that the input ",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-monte.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-monte.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-monte.html:9637,Availability,avail,available,9637,"er 1000 trajectories. Sometimes one is also interested in seeing how the Monte Carlo trajectories converge to the master equation solution by calculating expectation values over a range of trajectory numbers. If, for example, we want to average over 1, 10, 100, and 1000 trajectories, then we can input this into the solver using:; ntraj = [1, 10, 100, 1000]. Keep in mind that the input list must be in ascending order since the total number of trajectories run by mcsolve will be calculated using the last element of ntraj. In this case, we need to use an extra index when getting the expectation values from the qutip.solver.Result object returned by mcsolve. In the above example using:; data = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm], ntraj=[1, 10, 100, 1000]). we can extract the relevant expectation values using:; expt1 = data.expect[0]; expt10 = data.expect[1]; expt100 = data.expect[2]; expt1000 = data.expect[3]. The Monte Carlo solver also has many available options that can be set using the qutip.solver.Options class as discussed in Setting Options for the Dynamics Solvers. Reusing Hamiltonian Data¶. Note; This section covers a specialized topic and may be skipped if you are new to QuTiP. In order to solve a given simulation as fast as possible, the solvers in QuTiP take the given input operators and break them down into simpler components before passing them on to the ODE solvers. Although these operations are reasonably fast, the time spent organizing data can become appreciable when repeatedly solving a system over, for example, many different initial conditions. In cases such as this, the Hamiltonian and other operators may be reused after the initial configuration, thus speeding up calculations. Note that, unless you are planning to reuse the data many times, this functionality will not be very useful.; To turn on the “reuse” functionality we must set the rhs_reuse=True flag in the qutip.solver.Options:; options = Options(rhs_reu",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-monte.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-monte.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-monte.html:10008,Availability,down,down,10008," = [1, 10, 100, 1000]. Keep in mind that the input list must be in ascending order since the total number of trajectories run by mcsolve will be calculated using the last element of ntraj. In this case, we need to use an extra index when getting the expectation values from the qutip.solver.Result object returned by mcsolve. In the above example using:; data = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm], ntraj=[1, 10, 100, 1000]). we can extract the relevant expectation values using:; expt1 = data.expect[0]; expt10 = data.expect[1]; expt100 = data.expect[2]; expt1000 = data.expect[3]. The Monte Carlo solver also has many available options that can be set using the qutip.solver.Options class as discussed in Setting Options for the Dynamics Solvers. Reusing Hamiltonian Data¶. Note; This section covers a specialized topic and may be skipped if you are new to QuTiP. In order to solve a given simulation as fast as possible, the solvers in QuTiP take the given input operators and break them down into simpler components before passing them on to the ODE solvers. Although these operations are reasonably fast, the time spent organizing data can become appreciable when repeatedly solving a system over, for example, many different initial conditions. In cases such as this, the Hamiltonian and other operators may be reused after the initial configuration, thus speeding up calculations. Note that, unless you are planning to reuse the data many times, this functionality will not be very useful.; To turn on the “reuse” functionality we must set the rhs_reuse=True flag in the qutip.solver.Options:; options = Options(rhs_reuse=True). A full account of this feature is given in Setting Options for the Dynamics Solvers. Using the previous example, we will calculate the dynamics for two different initial states, with the Hamiltonian data being reused on the second call; times = np.linspace(0.0, 10.0, 200); psi0 = tensor(fock(2, 0), fock(10, 5)); a = tensor(qey",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-monte.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-monte.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-monte.html:1653,Deployability,continuous,continuously,1653,"ions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Monte Carlo Solver. Monte Carlo Solver¶. Introduction¶; Where as the density matrix formalism describes the ensemble average over many identical realizations of a quantum system, the Monte Carlo (MC), or quantum-jump approach to wave function evolution, allows for simulating an individual realization of the system dynamics. Here, the environment is continuously monitored, resulting in a series of quantum jumps in the system wave function, conditioned on the increase in information gained about the state of the system via the environmental measurements. In general, this evolution is governed by the Schrödinger equation with a non-Hermitian effective Hamiltonian. (1)¶\[H_{\rm eff}=H_{\rm sys}-\frac{i\hbar}{2}\sum_{i}C^{+}_{n}C_{n},\]; where again, the \(C_{n}\) are collapse operators, each corresponding to a separate irreversible process with rate \(\gamma_{n}\). Here, the strictly negative non-Hermitian portion of Eq. (1) gives rise to a reduction in the norm of the wave function, that to first-order in a small time \(\delta t\), is given by \(\left<\psi(t+\delta t)|\psi(t+\delta t)\right>=1-\delta p\) where. (2)¶\[\delta p =\delta t \sum_{n}\left<\psi(t)|C^{+}_{n}C_{n}|\psi(t)\right>,\]; and \(\delta t\) is such that \(\delta p \ll 1\). With a probability of remaining in the state \(\left|\psi(t+\delta t)\right>\) given by \(1-\delta p\), the corresponding quantum jump probability is thus Eq. (2). If the environmental ",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-monte.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-monte.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-monte.html:10359,Deployability,configurat,configuration,10359,"data = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm], ntraj=[1, 10, 100, 1000]). we can extract the relevant expectation values using:; expt1 = data.expect[0]; expt10 = data.expect[1]; expt100 = data.expect[2]; expt1000 = data.expect[3]. The Monte Carlo solver also has many available options that can be set using the qutip.solver.Options class as discussed in Setting Options for the Dynamics Solvers. Reusing Hamiltonian Data¶. Note; This section covers a specialized topic and may be skipped if you are new to QuTiP. In order to solve a given simulation as fast as possible, the solvers in QuTiP take the given input operators and break them down into simpler components before passing them on to the ODE solvers. Although these operations are reasonably fast, the time spent organizing data can become appreciable when repeatedly solving a system over, for example, many different initial conditions. In cases such as this, the Hamiltonian and other operators may be reused after the initial configuration, thus speeding up calculations. Note that, unless you are planning to reuse the data many times, this functionality will not be very useful.; To turn on the “reuse” functionality we must set the rhs_reuse=True flag in the qutip.solver.Options:; options = Options(rhs_reuse=True). A full account of this feature is given in Setting Options for the Dynamics Solvers. Using the previous example, we will calculate the dynamics for two different initial states, with the Hamiltonian data being reused on the second call; times = np.linspace(0.0, 10.0, 200); psi0 = tensor(fock(2, 0), fock(10, 5)); a = tensor(qeye(2), destroy(10)); sm = tensor(destroy(2), qeye(10)). H = 2*np.pi*a.dag()*a + 2*np.pi*sm.dag()*sm + 2*np.pi*0.25*(sm*a.dag() + sm.dag()*a); data1 = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm]); psi1 = tensor(fock(2, 0), coherent(10, 2 - 1j)); opts = Options(rhs_reuse=True) # Run a second time, reusing RHS; data2 = mcsolve(H",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-monte.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-monte.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-monte.html:12169,Deployability,update,updated,12169," cases such as this, the Hamiltonian and other operators may be reused after the initial configuration, thus speeding up calculations. Note that, unless you are planning to reuse the data many times, this functionality will not be very useful.; To turn on the “reuse” functionality we must set the rhs_reuse=True flag in the qutip.solver.Options:; options = Options(rhs_reuse=True). A full account of this feature is given in Setting Options for the Dynamics Solvers. Using the previous example, we will calculate the dynamics for two different initial states, with the Hamiltonian data being reused on the second call; times = np.linspace(0.0, 10.0, 200); psi0 = tensor(fock(2, 0), fock(10, 5)); a = tensor(qeye(2), destroy(10)); sm = tensor(destroy(2), qeye(10)). H = 2*np.pi*a.dag()*a + 2*np.pi*sm.dag()*sm + 2*np.pi*0.25*(sm*a.dag() + sm.dag()*a); data1 = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm]); psi1 = tensor(fock(2, 0), coherent(10, 2 - 1j)); opts = Options(rhs_reuse=True) # Run a second time, reusing RHS; data2 = mcsolve(H, psi1, times, [np.sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm], options=opts). plt.figure(); plt.plot(times, data1.expect[0], times, data1.expect[1], lw=2); plt.plot(times, data2.expect[0], '--', times, data2.expect[1], '--', lw=2); plt.title('Monte Carlo time evolution'); plt.xlabel('Time', fontsize=14); plt.ylabel('Expectation values', fontsize=14); plt.legend((""cavity photon number"", ""atom excitation probability"")); plt.show(). In addition to the initial state, one may reuse the Hamiltonian data when changing the number of trajectories ntraj or simulation times times. The reusing of Hamiltonian data is also supported for time-dependent Hamiltonians. See Solving Problems with Time-dependent Hamiltonians for further details. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-monte.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-monte.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-monte.html:1666,Energy Efficiency,monitor,monitored,1666,"ions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Monte Carlo Solver. Monte Carlo Solver¶. Introduction¶; Where as the density matrix formalism describes the ensemble average over many identical realizations of a quantum system, the Monte Carlo (MC), or quantum-jump approach to wave function evolution, allows for simulating an individual realization of the system dynamics. Here, the environment is continuously monitored, resulting in a series of quantum jumps in the system wave function, conditioned on the increase in information gained about the state of the system via the environmental measurements. In general, this evolution is governed by the Schrödinger equation with a non-Hermitian effective Hamiltonian. (1)¶\[H_{\rm eff}=H_{\rm sys}-\frac{i\hbar}{2}\sum_{i}C^{+}_{n}C_{n},\]; where again, the \(C_{n}\) are collapse operators, each corresponding to a separate irreversible process with rate \(\gamma_{n}\). Here, the strictly negative non-Hermitian portion of Eq. (1) gives rise to a reduction in the norm of the wave function, that to first-order in a small time \(\delta t\), is given by \(\left<\psi(t+\delta t)|\psi(t+\delta t)\right>=1-\delta p\) where. (2)¶\[\delta p =\delta t \sum_{n}\left<\psi(t)|C^{+}_{n}C_{n}|\psi(t)\right>,\]; and \(\delta t\) is such that \(\delta p \ll 1\). With a probability of remaining in the state \(\left|\psi(t+\delta t)\right>\) given by \(1-\delta p\), the corresponding quantum jump probability is thus Eq. (2). If the environmental ",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-monte.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-monte.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-monte.html:6997,Energy Efficiency,efficient,efficient,6997,"how(). The advantage of the Monte Carlo method over the master equation approach is that only the state vector is required to be kept in the computers memory, as opposed to the entire density matrix. For large quantum system this becomes a significant advantage, and the Monte Carlo solver is therefore generally recommended for such systems. For example, simulating a Heisenberg spin-chain consisting of 10 spins with random parameters and initial states takes almost 7 times longer using the master equation rather than Monte Carlo approach with the default number of trajectories running on a quad-CPU machine. Furthermore, it takes about 7 times the memory as well. However, for small systems, the added overhead of averaging a large number of stochastic trajectories to obtain the open system dynamics, as well as starting the multiprocessing functionality, outweighs the benefit of the minor (in this case) memory saving. Master equation methods are therefore generally more efficient when Hilbert space sizes are on the order of a couple of hundred states or smaller.; Like the master equation solver qutip.mesolve, the Monte Carlo solver returns a qutip.solver.Result object consisting of expectation values, if the user has defined expectation value operators in the 5th argument to mcsolve, or state vectors if no expectation value operators are given. If state vectors are returned, then the qutip.solver.Result returned by qutip.mcsolve will be an array of length ntraj, with each element containing an array of ket-type qobjs with the same number of elements as times. Furthermore, the output qutip.solver.Result object will also contain a list of times at which collapse occurred, and which collapse operators did the collapse, in the col_times and col_which properties, respectively. Changing the Number of Trajectories¶; As mentioned earlier, by default, the mcsolve function runs 500 trajectories. This value was chosen because it gives good accuracy, Monte Carlo errors scale as \(1/",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-monte.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-monte.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-monte.html:536,Integrability,depend,dependent,536,". Monte Carlo Solver — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Introduction; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Introduction; Monte Carlo in QuTiP. Krylov Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Monte Carlo Solver. Monte Carlo Solver¶. Introduction¶; Where as the density matrix formalism describes the ensemble average over many identical realizations of a quantum system, the Monte Carlo (MC), or quantum-jump approach to wave function evolution, allows for simulating an individual realization of the system dynamics. Here, the environment is continuously monitored, resulting in a series of quantum jumps in the system wave function, conditioned on the increase in information gained about the state of the system via the environmental measurements. In general, this evolution is governed by the Schrödinger equation with a non-Hermitian effective Hamiltonian. (1)¶\[H_{\rm eff}=H_{\rm sys}",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-monte.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-monte.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-monte.html:11974,Integrability,depend,dependent,11974," cases such as this, the Hamiltonian and other operators may be reused after the initial configuration, thus speeding up calculations. Note that, unless you are planning to reuse the data many times, this functionality will not be very useful.; To turn on the “reuse” functionality we must set the rhs_reuse=True flag in the qutip.solver.Options:; options = Options(rhs_reuse=True). A full account of this feature is given in Setting Options for the Dynamics Solvers. Using the previous example, we will calculate the dynamics for two different initial states, with the Hamiltonian data being reused on the second call; times = np.linspace(0.0, 10.0, 200); psi0 = tensor(fock(2, 0), fock(10, 5)); a = tensor(qeye(2), destroy(10)); sm = tensor(destroy(2), qeye(10)). H = 2*np.pi*a.dag()*a + 2*np.pi*sm.dag()*sm + 2*np.pi*0.25*(sm*a.dag() + sm.dag()*a); data1 = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm]); psi1 = tensor(fock(2, 0), coherent(10, 2 - 1j)); opts = Options(rhs_reuse=True) # Run a second time, reusing RHS; data2 = mcsolve(H, psi1, times, [np.sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm], options=opts). plt.figure(); plt.plot(times, data1.expect[0], times, data1.expect[1], lw=2); plt.plot(times, data2.expect[0], '--', times, data2.expect[1], '--', lw=2); plt.title('Monte Carlo time evolution'); plt.xlabel('Time', fontsize=14); plt.ylabel('Expectation values', fontsize=14); plt.legend((""cavity photon number"", ""atom excitation probability"")); plt.show(). In addition to the initial state, one may reuse the Hamiltonian data when changing the number of trajectories ntraj or simulation times times. The reusing of Hamiltonian data is also supported for time-dependent Hamiltonians. See Solving Problems with Time-dependent Hamiltonians for further details. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-monte.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-monte.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-monte.html:12029,Integrability,depend,dependent,12029," cases such as this, the Hamiltonian and other operators may be reused after the initial configuration, thus speeding up calculations. Note that, unless you are planning to reuse the data many times, this functionality will not be very useful.; To turn on the “reuse” functionality we must set the rhs_reuse=True flag in the qutip.solver.Options:; options = Options(rhs_reuse=True). A full account of this feature is given in Setting Options for the Dynamics Solvers. Using the previous example, we will calculate the dynamics for two different initial states, with the Hamiltonian data being reused on the second call; times = np.linspace(0.0, 10.0, 200); psi0 = tensor(fock(2, 0), fock(10, 5)); a = tensor(qeye(2), destroy(10)); sm = tensor(destroy(2), qeye(10)). H = 2*np.pi*a.dag()*a + 2*np.pi*sm.dag()*sm + 2*np.pi*0.25*(sm*a.dag() + sm.dag()*a); data1 = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm]); psi1 = tensor(fock(2, 0), coherent(10, 2 - 1j)); opts = Options(rhs_reuse=True) # Run a second time, reusing RHS; data2 = mcsolve(H, psi1, times, [np.sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm], options=opts). plt.figure(); plt.plot(times, data1.expect[0], times, data1.expect[1], lw=2); plt.plot(times, data2.expect[0], '--', times, data2.expect[1], '--', lw=2); plt.title('Monte Carlo time evolution'); plt.xlabel('Time', fontsize=14); plt.ylabel('Expectation values', fontsize=14); plt.legend((""cavity photon number"", ""atom excitation probability"")); plt.show(). In addition to the initial state, one may reuse the Hamiltonian data when changing the number of trajectories ntraj or simulation times times. The reusing of Hamiltonian data is also supported for time-dependent Hamiltonians. See Solving Problems with Time-dependent Hamiltonians for further details. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-monte.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-monte.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-monte.html:10359,Modifiability,config,configuration,10359,"data = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm], ntraj=[1, 10, 100, 1000]). we can extract the relevant expectation values using:; expt1 = data.expect[0]; expt10 = data.expect[1]; expt100 = data.expect[2]; expt1000 = data.expect[3]. The Monte Carlo solver also has many available options that can be set using the qutip.solver.Options class as discussed in Setting Options for the Dynamics Solvers. Reusing Hamiltonian Data¶. Note; This section covers a specialized topic and may be skipped if you are new to QuTiP. In order to solve a given simulation as fast as possible, the solvers in QuTiP take the given input operators and break them down into simpler components before passing them on to the ODE solvers. Although these operations are reasonably fast, the time spent organizing data can become appreciable when repeatedly solving a system over, for example, many different initial conditions. In cases such as this, the Hamiltonian and other operators may be reused after the initial configuration, thus speeding up calculations. Note that, unless you are planning to reuse the data many times, this functionality will not be very useful.; To turn on the “reuse” functionality we must set the rhs_reuse=True flag in the qutip.solver.Options:; options = Options(rhs_reuse=True). A full account of this feature is given in Setting Options for the Dynamics Solvers. Using the previous example, we will calculate the dynamics for two different initial states, with the Hamiltonian data being reused on the second call; times = np.linspace(0.0, 10.0, 200); psi0 = tensor(fock(2, 0), fock(10, 5)); a = tensor(qeye(2), destroy(10)); sm = tensor(destroy(2), qeye(10)). H = 2*np.pi*a.dag()*a + 2*np.pi*sm.dag()*sm + 2*np.pi*0.25*(sm*a.dag() + sm.dag()*a); data1 = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm]); psi1 = tensor(fock(2, 0), coherent(10, 2 - 1j)); opts = Options(rhs_reuse=True) # Run a second time, reusing RHS; data2 = mcsolve(H",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-monte.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-monte.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-monte.html:5156,Performance,perform,performed,5156,"ystem at time \(\tau\) into one of the renormalized states given by Eq. (3). The corresponding collapse operator \(C_{n}\) is chosen such that \(n\) is the smallest integer satisfying:. (5)¶\[\sum_{i=1}^{n} P_{n}(\tau) \ge r_2\]; where the individual \(P_{n}\) are given by Eq. (4). Note that the left hand side of Eq. (5) is, by definition, normalized to unity. IV: Using the renormalized state from step III as the new initial condition at time \(\tau\), draw a new random number, and repeat the above procedure until the final simulation time is reached. Monte Carlo in QuTiP¶; In QuTiP, Monte Carlo evolution is implemented with the qutip.mcsolve function. It takes nearly the same arguments as the qutip.mesolve; function for master-equation evolution, except that the initial state must be a ket vector, as oppose to a density matrix, and there is an optional keyword parameter ntraj that defines the number of stochastic trajectories to be simulated. By default, ntraj=500 indicating that 500 Monte Carlo trajectories will be performed.; To illustrate the use of the Monte Carlo evolution of quantum systems in QuTiP, let’s again consider the case of a two-level atom coupled to a leaky cavity. The only differences to the master-equation treatment is that in this case we invoke the qutip.mcsolve function instead of qutip.mesolve; times = np.linspace(0.0, 10.0, 200); psi0 = tensor(fock(2, 0), fock(10, 5)); a = tensor(qeye(2), destroy(10)); sm = tensor(destroy(2), qeye(10)); H = 2*np.pi*a.dag()*a + 2*np.pi*sm.dag()*sm + 2*np.pi*0.25*(sm*a.dag() + sm.dag()*a); data = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm]). plt.figure(); plt.plot(times, data.expect[0], times, data.expect[1]); plt.title('Monte Carlo time evolution'); plt.xlabel('Time'); plt.ylabel('Expectation values'); plt.legend((""cavity photon number"", ""atom excitation probability"")); plt.show(). The advantage of the Monte Carlo method over the master equation approach is that only the state vec",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-monte.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-monte.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-monte.html:8309,Usability,simpl,simply,8309,"e, or state vectors if no expectation value operators are given. If state vectors are returned, then the qutip.solver.Result returned by qutip.mcsolve will be an array of length ntraj, with each element containing an array of ket-type qobjs with the same number of elements as times. Furthermore, the output qutip.solver.Result object will also contain a list of times at which collapse occurred, and which collapse operators did the collapse, in the col_times and col_which properties, respectively. Changing the Number of Trajectories¶; As mentioned earlier, by default, the mcsolve function runs 500 trajectories. This value was chosen because it gives good accuracy, Monte Carlo errors scale as \(1/n\) where \(n\) is the number of trajectories, and simultaneously does not take an excessive amount of time to run. However, like many other options in QuTiP you are free to change the number of trajectories to fit your needs. If we want to run 1000 trajectories in the above example, we can simply modify the call to mcsolve like:; data = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm], ntraj=1000). where we have added the keyword argument ntraj=1000 at the end of the inputs. Now, the Monte Carlo solver will calculate expectation values for both operators, a.dag() * a, sm.dag() * sm averaging over 1000 trajectories. Sometimes one is also interested in seeing how the Monte Carlo trajectories converge to the master equation solution by calculating expectation values over a range of trajectory numbers. If, for example, we want to average over 1, 10, 100, and 1000 trajectories, then we can input this into the solver using:; ntraj = [1, 10, 100, 1000]. Keep in mind that the input list must be in ascending order since the total number of trajectories run by mcsolve will be calculated using the last element of ntraj. In this case, we need to use an extra index when getting the expectation values from the qutip.solver.Result object returned by mcsolve. In the a",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-monte.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-monte.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-monte.html:10018,Usability,simpl,simpler,10018," = [1, 10, 100, 1000]. Keep in mind that the input list must be in ascending order since the total number of trajectories run by mcsolve will be calculated using the last element of ntraj. In this case, we need to use an extra index when getting the expectation values from the qutip.solver.Result object returned by mcsolve. In the above example using:; data = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm], ntraj=[1, 10, 100, 1000]). we can extract the relevant expectation values using:; expt1 = data.expect[0]; expt10 = data.expect[1]; expt100 = data.expect[2]; expt1000 = data.expect[3]. The Monte Carlo solver also has many available options that can be set using the qutip.solver.Options class as discussed in Setting Options for the Dynamics Solvers. Reusing Hamiltonian Data¶. Note; This section covers a specialized topic and may be skipped if you are new to QuTiP. In order to solve a given simulation as fast as possible, the solvers in QuTiP take the given input operators and break them down into simpler components before passing them on to the ODE solvers. Although these operations are reasonably fast, the time spent organizing data can become appreciable when repeatedly solving a system over, for example, many different initial conditions. In cases such as this, the Hamiltonian and other operators may be reused after the initial configuration, thus speeding up calculations. Note that, unless you are planning to reuse the data many times, this functionality will not be very useful.; To turn on the “reuse” functionality we must set the rhs_reuse=True flag in the qutip.solver.Options:; options = Options(rhs_reuse=True). A full account of this feature is given in Setting Options for the Dynamics Solvers. Using the previous example, we will calculate the dynamics for two different initial states, with the Hamiltonian data being reused on the second call; times = np.linspace(0.0, 10.0, 200); psi0 = tensor(fock(2, 0), fock(10, 5)); a = tensor(qey",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-monte.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-monte.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-options.html:2276,Availability,toler,tolerance,2276,ystem Dynamics »; Setting Options for the Dynamics Solvers. Setting Options for the Dynamics Solvers¶; Occasionally it is necessary to change the built in parameters of the dynamics solvers used by for example the qutip.mesolve and qutip.mcsolve functions. The options for all dynamics solvers may be changed by using the Options class qutip.solver.Options.; options = Options(). the properties and default values of this class can be view via the print function:; print(options). Output:; Options:; -----------; atol: 1e-08; rtol: 1e-06; method: adams; order: 12; nsteps: 1000; first_step: 0; min_step: 0; max_step: 0; tidy: True; num_cpus: 2; norm_tol: 0.001; norm_steps: 5; rhs_filename: None; rhs_reuse: False; seeds: 0; rhs_with_state: False; average_expect: True; average_states: False; ntraj: 500; store_states: False; store_final_state: False. These properties are detailed in the following table. Assuming options = Options():. Property; Default setting; Description. options.atol; 1e-8; Absolute tolerance. options.rtol; 1e-6; Relative tolerance. options.method; ‘adams’; Solver method. Can be ‘adams’ (non-stiff) or ‘bdf’ (stiff). options.order; 12; Order of solver. Must be <=12 for ‘adams’ and <=5 for ‘bdf’. options.nsteps; 1000; Max. number of steps to take for each interval. options.first_step; 0; Size of initial step. 0 = determined automatically by solver. options.min_step; 0; Minimum step size. 0 = determined automatically by solver. options.max_step; 0; Maximum step size. 0 = determined automatically by solver. options.tidy; True; Whether to run tidyup function on time-independent Hamiltonian. options.store_final_state; False; Whether or not to store the final state of the evolution. options.store_states; False; Whether or not to store the state vectors or density matrices. options.rhs_filename; None; RHS filename when using compiled time-dependent Hamiltonians. options.rhs_reuse; False; Reuse compiled RHS function. Useful for repetitive tasks. options.rhs_with_state,MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-options.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-options.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-options.html:2316,Availability,toler,tolerance,2316,e Dynamics Solvers. Setting Options for the Dynamics Solvers¶; Occasionally it is necessary to change the built in parameters of the dynamics solvers used by for example the qutip.mesolve and qutip.mcsolve functions. The options for all dynamics solvers may be changed by using the Options class qutip.solver.Options.; options = Options(). the properties and default values of this class can be view via the print function:; print(options). Output:; Options:; -----------; atol: 1e-08; rtol: 1e-06; method: adams; order: 12; nsteps: 1000; first_step: 0; min_step: 0; max_step: 0; tidy: True; num_cpus: 2; norm_tol: 0.001; norm_steps: 5; rhs_filename: None; rhs_reuse: False; seeds: 0; rhs_with_state: False; average_expect: True; average_states: False; ntraj: 500; store_states: False; store_final_state: False. These properties are detailed in the following table. Assuming options = Options():. Property; Default setting; Description. options.atol; 1e-8; Absolute tolerance. options.rtol; 1e-6; Relative tolerance. options.method; ‘adams’; Solver method. Can be ‘adams’ (non-stiff) or ‘bdf’ (stiff). options.order; 12; Order of solver. Must be <=12 for ‘adams’ and <=5 for ‘bdf’. options.nsteps; 1000; Max. number of steps to take for each interval. options.first_step; 0; Size of initial step. 0 = determined automatically by solver. options.min_step; 0; Minimum step size. 0 = determined automatically by solver. options.max_step; 0; Maximum step size. 0 = determined automatically by solver. options.tidy; True; Whether to run tidyup function on time-independent Hamiltonian. options.store_final_state; False; Whether or not to store the final state of the evolution. options.store_states; False; Whether or not to store the state vectors or density matrices. options.rhs_filename; None; RHS filename when using compiled time-dependent Hamiltonians. options.rhs_reuse; False; Reuse compiled RHS function. Useful for repetitive tasks. options.rhs_with_state; False; Whether or not to include the s,MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-options.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-options.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-options.html:4303,Availability,toler,tolerance,4303,"options.rhs_with_state; False; Whether or not to include the state in the Hamiltonian; function callback signature. options.num_cpus; installed num; of processors; Integer number of cpus used by mcsolve. options.seeds; None; Array containing random number seeds for mcsolver. options.norm_tol; 1e-6; Tolerance used when finding wavefunction norm in mcsolve. options.norm_steps; 5; Max. number of steps used to find wavefunction’s norm to within; norm_tol in mcsolve. options.steady_state_average; False; Include an estimation of the steady state in mcsolve. options.ntraj; 500; Number of trajectories in stochastic solvers. options.average_expect; True; Average expectation values over trajectories. options.average_states; False; Average of the states over trajectories. options.openmp_threads; installed num; of processors; Number of OPENMP threads to use. options.use_openmp; None; Use OPENMP for sparse matrix vector multiplication. As an example, let us consider changing the number of processors used, turn the GUI off, and strengthen the absolute tolerance. There are two equivalent ways to do this using the Options class. First way,; options = Options(); options.num_cpus = 3; options.atol = 1e-10. or one can use an inline method,; options = Options(num_cpus=4, atol=1e-10). Note that the order in which you input the options does not matter. Using either method, the resulting options variable is now:; print(options). Output:; Options:; -----------; atol: 1e-10; rtol: 1e-06; method: adams; order: 12; nsteps: 1000; first_step: 0; min_step: 0; max_step: 0; tidy: True; num_cpus: 4; norm_tol: 0.001; norm_steps: 5; rhs_filename: None; rhs_reuse: False; seeds: 0; rhs_with_state: False; average_expect: True; average_states: False; ntraj: 500; store_states: False; store_final_state: False. To use these new settings we can use the keyword argument options in either the func:qutip.mesolve and qutip.mcsolve function. We can modify the last example as:; >>> mesolve(H0, psi0, tlist, c_op_li",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-options.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-options.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-options.html:3383,Deployability,install,installed,3383,"options.order; 12; Order of solver. Must be <=12 for ‘adams’ and <=5 for ‘bdf’. options.nsteps; 1000; Max. number of steps to take for each interval. options.first_step; 0; Size of initial step. 0 = determined automatically by solver. options.min_step; 0; Minimum step size. 0 = determined automatically by solver. options.max_step; 0; Maximum step size. 0 = determined automatically by solver. options.tidy; True; Whether to run tidyup function on time-independent Hamiltonian. options.store_final_state; False; Whether or not to store the final state of the evolution. options.store_states; False; Whether or not to store the state vectors or density matrices. options.rhs_filename; None; RHS filename when using compiled time-dependent Hamiltonians. options.rhs_reuse; False; Reuse compiled RHS function. Useful for repetitive tasks. options.rhs_with_state; False; Whether or not to include the state in the Hamiltonian; function callback signature. options.num_cpus; installed num; of processors; Integer number of cpus used by mcsolve. options.seeds; None; Array containing random number seeds for mcsolver. options.norm_tol; 1e-6; Tolerance used when finding wavefunction norm in mcsolve. options.norm_steps; 5; Max. number of steps used to find wavefunction’s norm to within; norm_tol in mcsolve. options.steady_state_average; False; Include an estimation of the steady state in mcsolve. options.ntraj; 500; Number of trajectories in stochastic solvers. options.average_expect; True; Average expectation values over trajectories. options.average_states; False; Average of the states over trajectories. options.openmp_threads; installed num; of processors; Number of OPENMP threads to use. options.use_openmp; None; Use OPENMP for sparse matrix vector multiplication. As an example, let us consider changing the number of processors used, turn the GUI off, and strengthen the absolute tolerance. There are two equivalent ways to do this using the Options class. First way,; options = Options(); ",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-options.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-options.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-options.html:4045,Deployability,install,installed,4045,"rices. options.rhs_filename; None; RHS filename when using compiled time-dependent Hamiltonians. options.rhs_reuse; False; Reuse compiled RHS function. Useful for repetitive tasks. options.rhs_with_state; False; Whether or not to include the state in the Hamiltonian; function callback signature. options.num_cpus; installed num; of processors; Integer number of cpus used by mcsolve. options.seeds; None; Array containing random number seeds for mcsolver. options.norm_tol; 1e-6; Tolerance used when finding wavefunction norm in mcsolve. options.norm_steps; 5; Max. number of steps used to find wavefunction’s norm to within; norm_tol in mcsolve. options.steady_state_average; False; Include an estimation of the steady state in mcsolve. options.ntraj; 500; Number of trajectories in stochastic solvers. options.average_expect; True; Average expectation values over trajectories. options.average_states; False; Average of the states over trajectories. options.openmp_threads; installed num; of processors; Number of OPENMP threads to use. options.use_openmp; None; Use OPENMP for sparse matrix vector multiplication. As an example, let us consider changing the number of processors used, turn the GUI off, and strengthen the absolute tolerance. There are two equivalent ways to do this using the Options class. First way,; options = Options(); options.num_cpus = 3; options.atol = 1e-10. or one can use an inline method,; options = Options(num_cpus=4, atol=1e-10). Note that the order in which you input the options does not matter. Using either method, the resulting options variable is now:; print(options). Output:; Options:; -----------; atol: 1e-10; rtol: 1e-06; method: adams; order: 12; nsteps: 1000; first_step: 0; min_step: 0; max_step: 0; tidy: True; num_cpus: 4; norm_tol: 0.001; norm_steps: 5; rhs_filename: None; rhs_reuse: False; seeds: 0; rhs_with_state: False; average_expect: True; average_states: False; ntraj: 500; store_states: False; store_final_state: False. To use these new s",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-options.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-options.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-options.html:5645,Deployability,update,updated,5645,"False; Include an estimation of the steady state in mcsolve. options.ntraj; 500; Number of trajectories in stochastic solvers. options.average_expect; True; Average expectation values over trajectories. options.average_states; False; Average of the states over trajectories. options.openmp_threads; installed num; of processors; Number of OPENMP threads to use. options.use_openmp; None; Use OPENMP for sparse matrix vector multiplication. As an example, let us consider changing the number of processors used, turn the GUI off, and strengthen the absolute tolerance. There are two equivalent ways to do this using the Options class. First way,; options = Options(); options.num_cpus = 3; options.atol = 1e-10. or one can use an inline method,; options = Options(num_cpus=4, atol=1e-10). Note that the order in which you input the options does not matter. Using either method, the resulting options variable is now:; print(options). Output:; Options:; -----------; atol: 1e-10; rtol: 1e-06; method: adams; order: 12; nsteps: 1000; first_step: 0; min_step: 0; max_step: 0; tidy: True; num_cpus: 4; norm_tol: 0.001; norm_steps: 5; rhs_filename: None; rhs_reuse: False; seeds: 0; rhs_with_state: False; average_expect: True; average_states: False; ntraj: 500; store_states: False; store_final_state: False. To use these new settings we can use the keyword argument options in either the func:qutip.mesolve and qutip.mcsolve function. We can modify the last example as:; >>> mesolve(H0, psi0, tlist, c_op_list, [sigmaz()], options=options); >>> mesolve(hamiltonian_t, psi0, tlist, c_op_list, [sigmaz()], H_args, options=options). or:; >>> mcsolve(H0, psi0, tlist, ntraj,c_op_list, [sigmaz()], options=options); >>> mcsolve(hamiltonian_t, psi0, tlist, ntraj, c_op_list, [sigmaz()], H_args, options=options). Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-options.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-options.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-options.html:522,Integrability,depend,dependent,522,. Setting Options for the Dynamics Solvers — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Introduction; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Krylov Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Setting Options for the Dynamics Solvers. Setting Options for the Dynamics Solvers¶; Occasionally it is necessary to change the built in parameters of the dynamics solvers used by for example the qutip.mesolve and qutip.mcsolve functions. The options for all dynamics solvers may be changed by using the Options class qutip.solver.Options.; options = Options(). the properties and default values of this class can be view via the print function:; print(options). Output:; Options:; -----------; atol: 1e-08; rtol: 1e-06; method: adams; order: 12; nsteps: 1000; first_step: 0; min_step: 0; max_step: 0; tidy: True; num_cpus: 2; norm_tol: 0.001; norm_steps: 5; rhs_filename: None; rhs_reuse: False; seeds: 0; rhs_wi,MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-options.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-options.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-options.html:3141,Integrability,depend,dependent,3141,hese properties are detailed in the following table. Assuming options = Options():. Property; Default setting; Description. options.atol; 1e-8; Absolute tolerance. options.rtol; 1e-6; Relative tolerance. options.method; ‘adams’; Solver method. Can be ‘adams’ (non-stiff) or ‘bdf’ (stiff). options.order; 12; Order of solver. Must be <=12 for ‘adams’ and <=5 for ‘bdf’. options.nsteps; 1000; Max. number of steps to take for each interval. options.first_step; 0; Size of initial step. 0 = determined automatically by solver. options.min_step; 0; Minimum step size. 0 = determined automatically by solver. options.max_step; 0; Maximum step size. 0 = determined automatically by solver. options.tidy; True; Whether to run tidyup function on time-independent Hamiltonian. options.store_final_state; False; Whether or not to store the final state of the evolution. options.store_states; False; Whether or not to store the state vectors or density matrices. options.rhs_filename; None; RHS filename when using compiled time-dependent Hamiltonians. options.rhs_reuse; False; Reuse compiled RHS function. Useful for repetitive tasks. options.rhs_with_state; False; Whether or not to include the state in the Hamiltonian; function callback signature. options.num_cpus; installed num; of processors; Integer number of cpus used by mcsolve. options.seeds; None; Array containing random number seeds for mcsolver. options.norm_tol; 1e-6; Tolerance used when finding wavefunction norm in mcsolve. options.norm_steps; 5; Max. number of steps used to find wavefunction’s norm to within; norm_tol in mcsolve. options.steady_state_average; False; Include an estimation of the steady state in mcsolve. options.ntraj; 500; Number of trajectories in stochastic solvers. options.average_expect; True; Average expectation values over trajectories. options.average_states; False; Average of the states over trajectories. options.openmp_threads; installed num; of processors; Number of OPENMP threads to use. options.use_open,MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-options.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-options.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-options.html:4645,Modifiability,variab,variable,4645,"er of steps used to find wavefunction’s norm to within; norm_tol in mcsolve. options.steady_state_average; False; Include an estimation of the steady state in mcsolve. options.ntraj; 500; Number of trajectories in stochastic solvers. options.average_expect; True; Average expectation values over trajectories. options.average_states; False; Average of the states over trajectories. options.openmp_threads; installed num; of processors; Number of OPENMP threads to use. options.use_openmp; None; Use OPENMP for sparse matrix vector multiplication. As an example, let us consider changing the number of processors used, turn the GUI off, and strengthen the absolute tolerance. There are two equivalent ways to do this using the Options class. First way,; options = Options(); options.num_cpus = 3; options.atol = 1e-10. or one can use an inline method,; options = Options(num_cpus=4, atol=1e-10). Note that the order in which you input the options does not matter. Using either method, the resulting options variable is now:; print(options). Output:; Options:; -----------; atol: 1e-10; rtol: 1e-06; method: adams; order: 12; nsteps: 1000; first_step: 0; min_step: 0; max_step: 0; tidy: True; num_cpus: 4; norm_tol: 0.001; norm_steps: 5; rhs_filename: None; rhs_reuse: False; seeds: 0; rhs_with_state: False; average_expect: True; average_states: False; ntraj: 500; store_states: False; store_final_state: False. To use these new settings we can use the keyword argument options in either the func:qutip.mesolve and qutip.mcsolve function. We can modify the last example as:; >>> mesolve(H0, psi0, tlist, c_op_list, [sigmaz()], options=options); >>> mesolve(hamiltonian_t, psi0, tlist, c_op_list, [sigmaz()], H_args, options=options). or:; >>> mcsolve(H0, psi0, tlist, ntraj,c_op_list, [sigmaz()], options=options); >>> mcsolve(hamiltonian_t, psi0, tlist, ntraj, c_op_list, [sigmaz()], H_args, options=options). Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; ",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-options.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-options.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-photocurrent.html:1502,Deployability,continuous,continuous,1502," Stochastic Solver - Photocurrent; Closed system; Open system. Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Stochastic Solver - Photocurrent. Stochastic Solver - Photocurrent¶; Photocurrent method, like monte-carlo method, allows for simulating an; individual realization of the system evolution under continuous measurement. Closed system¶; Photocurrent evolution have the state evolve deterministically between quantum jumps.; During the deterministic part, the system evolve by schrodinger equation with a; non-hermitian, norm conserving effective Hamiltonian. (1)¶\[H_{\rm eff}=H_{\rm sys}+; \frac{i\hbar}{2}\left( -\sum_{n}C^{+}_{n}C_{n}+ |C_{n} \psi |^2\right).\]; With \(C_{n}\), the collapse operators.; This effective Hamiltonian is equivalent to the monte-carlo effective; Hamiltonian with an extra term to keep the state normalized.; At each time step of \(\delta t\), the wave function has a probability. (2)¶\[\delta p_{n} = \left<\psi(t)|C_{n}^{+}C_{n}|\psi(t)\right> \delta t\]; of making a quantum jump. \(\delta t\) must be chosen small enough to keep; that probability small \(\delta p << 1\). If multiple jumps happen at the; same time step, the state become unphysical.; Each jump result in a sharp variation of t",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-photocurrent.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-photocurrent.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-photocurrent.html:2573,Deployability,integrat,integrates,2573," system¶; Photocurrent evolution have the state evolve deterministically between quantum jumps.; During the deterministic part, the system evolve by schrodinger equation with a; non-hermitian, norm conserving effective Hamiltonian. (1)¶\[H_{\rm eff}=H_{\rm sys}+; \frac{i\hbar}{2}\left( -\sum_{n}C^{+}_{n}C_{n}+ |C_{n} \psi |^2\right).\]; With \(C_{n}\), the collapse operators.; This effective Hamiltonian is equivalent to the monte-carlo effective; Hamiltonian with an extra term to keep the state normalized.; At each time step of \(\delta t\), the wave function has a probability. (2)¶\[\delta p_{n} = \left<\psi(t)|C_{n}^{+}C_{n}|\psi(t)\right> \delta t\]; of making a quantum jump. \(\delta t\) must be chosen small enough to keep; that probability small \(\delta p << 1\). If multiple jumps happen at the; same time step, the state become unphysical.; Each jump result in a sharp variation of the state by,. (3)¶\[\delta \psi = \left( \frac{C_n \psi} {\left| C_n \psi \right|} - \psi \right)\]; The basic photocurrent method directly integrates these equations to the first-order.; Starting from a state \(\left|\psi(0)\right>\), it evolves the state according to. (4)¶\[\delta \psi(t) = - i H_{\rm sys} \psi(t) \delta t + \sum_n \left(; -\frac{C_n^{+} C_n}{2} \psi(t) \delta t; + \frac{ \left| C_n \psi \right| ^2}{2} \delta t; + \delta N_n \left( \frac{C_n \psi}; {\left| C_n \psi \right|} - \psi \right)\right),\]; for each time-step.; Here \(\delta N = 1\) with a probability of \(\delta \omega\) and; \(\delta N_n = 0\) with a probability of \(1-\delta \omega\).; Trajectories obtained with this algorithm are equivalent to those obtained with; monte-carlo evolution (up to \(O(\delta t^2)\)).; In most cases, qutip.mcsolve is more efficient than; qutip.stochastic.photocurrent_sesolve. Open system¶; Photocurrent approach allows to obtain trajectories for a system with; both measured and dissipative interaction with the bath.; The system evolves according to the master equation between",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-photocurrent.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-photocurrent.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-photocurrent.html:4310,Deployability,update,updated,4310,"a sharp variation of the state by,. (3)¶\[\delta \psi = \left( \frac{C_n \psi} {\left| C_n \psi \right|} - \psi \right)\]; The basic photocurrent method directly integrates these equations to the first-order.; Starting from a state \(\left|\psi(0)\right>\), it evolves the state according to. (4)¶\[\delta \psi(t) = - i H_{\rm sys} \psi(t) \delta t + \sum_n \left(; -\frac{C_n^{+} C_n}{2} \psi(t) \delta t; + \frac{ \left| C_n \psi \right| ^2}{2} \delta t; + \delta N_n \left( \frac{C_n \psi}; {\left| C_n \psi \right|} - \psi \right)\right),\]; for each time-step.; Here \(\delta N = 1\) with a probability of \(\delta \omega\) and; \(\delta N_n = 0\) with a probability of \(1-\delta \omega\).; Trajectories obtained with this algorithm are equivalent to those obtained with; monte-carlo evolution (up to \(O(\delta t^2)\)).; In most cases, qutip.mcsolve is more efficient than; qutip.stochastic.photocurrent_sesolve. Open system¶; Photocurrent approach allows to obtain trajectories for a system with; both measured and dissipative interaction with the bath.; The system evolves according to the master equation between jumps with a modified; liouvillian. (5)¶\[L_{\rm eff}(\rho(t)) = L_{\rm sys}(\rho(t)) +; \sum_{n}\left(; \rm{tr} \left(C_{n}^{+}C_{n} \rho C_{n}^{+}C_{n} \right); - C_{n}^{+}C_{n} \rho C_{n}^{+}C_{n} \right),\]; with the probability of jumps in a time step \(\delta t\) given by. (6)¶\[\delta p = \rm{tr} \left( C \rho C^{+} \right) \delta t.\]; After a jump, the density matrix become. \[\rho' = \frac{C \rho C^{+}}{\rm{tr} \left( C \rho C^{+} \right)}.\]; The evolution of the system at each time step if thus given by. (7)¶\[\rho(t + \delta t) = \rho(t) + L_{\rm eff}(\rho) \delta t + \delta N; \left(\frac{C \rho C^{+}}{\rm{tr} \left( C \rho C^{+} \right)} - \rho \right).\]. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-photocurrent.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-photocurrent.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-photocurrent.html:3276,Energy Efficiency,efficient,efficient,3276,"ability small \(\delta p << 1\). If multiple jumps happen at the; same time step, the state become unphysical.; Each jump result in a sharp variation of the state by,. (3)¶\[\delta \psi = \left( \frac{C_n \psi} {\left| C_n \psi \right|} - \psi \right)\]; The basic photocurrent method directly integrates these equations to the first-order.; Starting from a state \(\left|\psi(0)\right>\), it evolves the state according to. (4)¶\[\delta \psi(t) = - i H_{\rm sys} \psi(t) \delta t + \sum_n \left(; -\frac{C_n^{+} C_n}{2} \psi(t) \delta t; + \frac{ \left| C_n \psi \right| ^2}{2} \delta t; + \delta N_n \left( \frac{C_n \psi}; {\left| C_n \psi \right|} - \psi \right)\right),\]; for each time-step.; Here \(\delta N = 1\) with a probability of \(\delta \omega\) and; \(\delta N_n = 0\) with a probability of \(1-\delta \omega\).; Trajectories obtained with this algorithm are equivalent to those obtained with; monte-carlo evolution (up to \(O(\delta t^2)\)).; In most cases, qutip.mcsolve is more efficient than; qutip.stochastic.photocurrent_sesolve. Open system¶; Photocurrent approach allows to obtain trajectories for a system with; both measured and dissipative interaction with the bath.; The system evolves according to the master equation between jumps with a modified; liouvillian. (5)¶\[L_{\rm eff}(\rho(t)) = L_{\rm sys}(\rho(t)) +; \sum_{n}\left(; \rm{tr} \left(C_{n}^{+}C_{n} \rho C_{n}^{+}C_{n} \right); - C_{n}^{+}C_{n} \rho C_{n}^{+}C_{n} \right),\]; with the probability of jumps in a time step \(\delta t\) given by. (6)¶\[\delta p = \rm{tr} \left( C \rho C^{+} \right) \delta t.\]; After a jump, the density matrix become. \[\rho' = \frac{C \rho C^{+}}{\rm{tr} \left( C \rho C^{+} \right)}.\]; The evolution of the system at each time step if thus given by. (7)¶\[\rho(t + \delta t) = \rho(t) + L_{\rm eff}(\rho) \delta t + \delta N; \left(\frac{C \rho C^{+}}{\rm{tr} \left( C \rho C^{+} \right)} - \rho \right).\]. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP develo",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-photocurrent.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-photocurrent.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-photocurrent.html:542,Integrability,depend,dependent,542,". Stochastic Solver - Photocurrent — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Introduction; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Krylov Solver; Stochastic Solver - Photocurrent; Closed system; Open system. Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Stochastic Solver - Photocurrent. Stochastic Solver - Photocurrent¶; Photocurrent method, like monte-carlo method, allows for simulating an; individual realization of the system evolution under continuous measurement. Closed system¶; Photocurrent evolution have the state evolve deterministically between quantum jumps.; During the deterministic part, the system evolve by schrodinger equation with a; non-hermitian, norm conserving effective Hamiltonian. (1)¶\[H_{\rm eff}=H_{\rm sys}+; \frac{i\hbar}{2}\left( -\sum_{n}C^{+}_{n}C_{n}+ |C_{n} \psi |^2\right).\]; With \(C_{n}\), the collapse operators.; This effective Hamiltonian is equivalent to the monte-carlo effective; Hamiltonian with a",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-photocurrent.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-photocurrent.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-photocurrent.html:2573,Integrability,integrat,integrates,2573," system¶; Photocurrent evolution have the state evolve deterministically between quantum jumps.; During the deterministic part, the system evolve by schrodinger equation with a; non-hermitian, norm conserving effective Hamiltonian. (1)¶\[H_{\rm eff}=H_{\rm sys}+; \frac{i\hbar}{2}\left( -\sum_{n}C^{+}_{n}C_{n}+ |C_{n} \psi |^2\right).\]; With \(C_{n}\), the collapse operators.; This effective Hamiltonian is equivalent to the monte-carlo effective; Hamiltonian with an extra term to keep the state normalized.; At each time step of \(\delta t\), the wave function has a probability. (2)¶\[\delta p_{n} = \left<\psi(t)|C_{n}^{+}C_{n}|\psi(t)\right> \delta t\]; of making a quantum jump. \(\delta t\) must be chosen small enough to keep; that probability small \(\delta p << 1\). If multiple jumps happen at the; same time step, the state become unphysical.; Each jump result in a sharp variation of the state by,. (3)¶\[\delta \psi = \left( \frac{C_n \psi} {\left| C_n \psi \right|} - \psi \right)\]; The basic photocurrent method directly integrates these equations to the first-order.; Starting from a state \(\left|\psi(0)\right>\), it evolves the state according to. (4)¶\[\delta \psi(t) = - i H_{\rm sys} \psi(t) \delta t + \sum_n \left(; -\frac{C_n^{+} C_n}{2} \psi(t) \delta t; + \frac{ \left| C_n \psi \right| ^2}{2} \delta t; + \delta N_n \left( \frac{C_n \psi}; {\left| C_n \psi \right|} - \psi \right)\right),\]; for each time-step.; Here \(\delta N = 1\) with a probability of \(\delta \omega\) and; \(\delta N_n = 0\) with a probability of \(1-\delta \omega\).; Trajectories obtained with this algorithm are equivalent to those obtained with; monte-carlo evolution (up to \(O(\delta t^2)\)).; In most cases, qutip.mcsolve is more efficient than; qutip.stochastic.photocurrent_sesolve. Open system¶; Photocurrent approach allows to obtain trajectories for a system with; both measured and dissipative interaction with the bath.; The system evolves according to the master equation between",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-photocurrent.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-photocurrent.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-photocurrent.html:1580,Modifiability,evolve,evolve,1580,"ield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Stochastic Solver - Photocurrent. Stochastic Solver - Photocurrent¶; Photocurrent method, like monte-carlo method, allows for simulating an; individual realization of the system evolution under continuous measurement. Closed system¶; Photocurrent evolution have the state evolve deterministically between quantum jumps.; During the deterministic part, the system evolve by schrodinger equation with a; non-hermitian, norm conserving effective Hamiltonian. (1)¶\[H_{\rm eff}=H_{\rm sys}+; \frac{i\hbar}{2}\left( -\sum_{n}C^{+}_{n}C_{n}+ |C_{n} \psi |^2\right).\]; With \(C_{n}\), the collapse operators.; This effective Hamiltonian is equivalent to the monte-carlo effective; Hamiltonian with an extra term to keep the state normalized.; At each time step of \(\delta t\), the wave function has a probability. (2)¶\[\delta p_{n} = \left<\psi(t)|C_{n}^{+}C_{n}|\psi(t)\right> \delta t\]; of making a quantum jump. \(\delta t\) must be chosen small enough to keep; that probability small \(\delta p << 1\). If multiple jumps happen at the; same time step, the state become unphysical.; Each jump result in a sharp variation of the state by,. (3)¶\[\delta \psi = \left( \frac{C_n \psi} {\left| C_n \psi \right|} - \psi \right)\]; The basic photocurrent method directly int",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-photocurrent.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-photocurrent.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-photocurrent.html:1671,Modifiability,evolve,evolve,1671,"al Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Stochastic Solver - Photocurrent. Stochastic Solver - Photocurrent¶; Photocurrent method, like monte-carlo method, allows for simulating an; individual realization of the system evolution under continuous measurement. Closed system¶; Photocurrent evolution have the state evolve deterministically between quantum jumps.; During the deterministic part, the system evolve by schrodinger equation with a; non-hermitian, norm conserving effective Hamiltonian. (1)¶\[H_{\rm eff}=H_{\rm sys}+; \frac{i\hbar}{2}\left( -\sum_{n}C^{+}_{n}C_{n}+ |C_{n} \psi |^2\right).\]; With \(C_{n}\), the collapse operators.; This effective Hamiltonian is equivalent to the monte-carlo effective; Hamiltonian with an extra term to keep the state normalized.; At each time step of \(\delta t\), the wave function has a probability. (2)¶\[\delta p_{n} = \left<\psi(t)|C_{n}^{+}C_{n}|\psi(t)\right> \delta t\]; of making a quantum jump. \(\delta t\) must be chosen small enough to keep; that probability small \(\delta p << 1\). If multiple jumps happen at the; same time step, the state become unphysical.; Each jump result in a sharp variation of the state by,. (3)¶\[\delta \psi = \left( \frac{C_n \psi} {\left| C_n \psi \right|} - \psi \right)\]; The basic photocurrent method directly integrates these equations to the first-order.; Starting from a state \(\left|\psi(0)\right>\), it evolves the state accor",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-photocurrent.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-photocurrent.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-photocurrent.html:2672,Modifiability,evolve,evolves,2672,"he system evolve by schrodinger equation with a; non-hermitian, norm conserving effective Hamiltonian. (1)¶\[H_{\rm eff}=H_{\rm sys}+; \frac{i\hbar}{2}\left( -\sum_{n}C^{+}_{n}C_{n}+ |C_{n} \psi |^2\right).\]; With \(C_{n}\), the collapse operators.; This effective Hamiltonian is equivalent to the monte-carlo effective; Hamiltonian with an extra term to keep the state normalized.; At each time step of \(\delta t\), the wave function has a probability. (2)¶\[\delta p_{n} = \left<\psi(t)|C_{n}^{+}C_{n}|\psi(t)\right> \delta t\]; of making a quantum jump. \(\delta t\) must be chosen small enough to keep; that probability small \(\delta p << 1\). If multiple jumps happen at the; same time step, the state become unphysical.; Each jump result in a sharp variation of the state by,. (3)¶\[\delta \psi = \left( \frac{C_n \psi} {\left| C_n \psi \right|} - \psi \right)\]; The basic photocurrent method directly integrates these equations to the first-order.; Starting from a state \(\left|\psi(0)\right>\), it evolves the state according to. (4)¶\[\delta \psi(t) = - i H_{\rm sys} \psi(t) \delta t + \sum_n \left(; -\frac{C_n^{+} C_n}{2} \psi(t) \delta t; + \frac{ \left| C_n \psi \right| ^2}{2} \delta t; + \delta N_n \left( \frac{C_n \psi}; {\left| C_n \psi \right|} - \psi \right)\right),\]; for each time-step.; Here \(\delta N = 1\) with a probability of \(\delta \omega\) and; \(\delta N_n = 0\) with a probability of \(1-\delta \omega\).; Trajectories obtained with this algorithm are equivalent to those obtained with; monte-carlo evolution (up to \(O(\delta t^2)\)).; In most cases, qutip.mcsolve is more efficient than; qutip.stochastic.photocurrent_sesolve. Open system¶; Photocurrent approach allows to obtain trajectories for a system with; both measured and dissipative interaction with the bath.; The system evolves according to the master equation between jumps with a modified; liouvillian. (5)¶\[L_{\rm eff}(\rho(t)) = L_{\rm sys}(\rho(t)) +; \sum_{n}\left(; \rm{tr} \left(C_{n}^{+",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-photocurrent.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-photocurrent.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-photocurrent.html:3485,Modifiability,evolve,evolves,3485,"a sharp variation of the state by,. (3)¶\[\delta \psi = \left( \frac{C_n \psi} {\left| C_n \psi \right|} - \psi \right)\]; The basic photocurrent method directly integrates these equations to the first-order.; Starting from a state \(\left|\psi(0)\right>\), it evolves the state according to. (4)¶\[\delta \psi(t) = - i H_{\rm sys} \psi(t) \delta t + \sum_n \left(; -\frac{C_n^{+} C_n}{2} \psi(t) \delta t; + \frac{ \left| C_n \psi \right| ^2}{2} \delta t; + \delta N_n \left( \frac{C_n \psi}; {\left| C_n \psi \right|} - \psi \right)\right),\]; for each time-step.; Here \(\delta N = 1\) with a probability of \(\delta \omega\) and; \(\delta N_n = 0\) with a probability of \(1-\delta \omega\).; Trajectories obtained with this algorithm are equivalent to those obtained with; monte-carlo evolution (up to \(O(\delta t^2)\)).; In most cases, qutip.mcsolve is more efficient than; qutip.stochastic.photocurrent_sesolve. Open system¶; Photocurrent approach allows to obtain trajectories for a system with; both measured and dissipative interaction with the bath.; The system evolves according to the master equation between jumps with a modified; liouvillian. (5)¶\[L_{\rm eff}(\rho(t)) = L_{\rm sys}(\rho(t)) +; \sum_{n}\left(; \rm{tr} \left(C_{n}^{+}C_{n} \rho C_{n}^{+}C_{n} \right); - C_{n}^{+}C_{n} \rho C_{n}^{+}C_{n} \right),\]; with the probability of jumps in a time step \(\delta t\) given by. (6)¶\[\delta p = \rm{tr} \left( C \rho C^{+} \right) \delta t.\]; After a jump, the density matrix become. \[\rho' = \frac{C \rho C^{+}}{\rm{tr} \left( C \rho C^{+} \right)}.\]; The evolution of the system at each time step if thus given by. (7)¶\[\rho(t + \delta t) = \rho(t) + L_{\rm eff}(\rho) \delta t + \delta N; \left(\frac{C \rho C^{+}}{\rm{tr} \left( C \rho C^{+} \right)} - \rho \right).\]. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-photocurrent.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-photocurrent.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-piqs.html:7712,Deployability,update,updated,7712,"ke basis; ground(N); The ground state in the Dicke basis. GHZ-state density matrix in the Dicke basis; ghz(N); The GHZ-state density matrix in the Dicke (default) basis for N number of TLS. Collapse operators of the ensemble; Dicke.c_ops(); The collapse operators for the ensemble can be called by the c_ops method of the Dicke class. Note that the mathematical object representing the density matrix of the full system that is manipulated (or obtained from steadystate) in the Dicke-basis formalism used here is a representative of the density matrix. This representative object is of linear size N^2, whereas the full density matrix is defined over a 2^N Hilbert space. In order to calculate nonlinear functions of such density matrix, such as the Von Neumann entropy or the purity, it is necessary to take into account the degeneracy of each block of such block-diagonal density matrix. Note that as long as one calculates expected values of operators, being Tr[A*rho] a linear function of rho, the representative density matrix give straightforwardly the correct result. When a nonlinear function of the density matrix needs to be calculated, one needs to weigh each degenerate block correctly; this is taken care by the dicke_function_trace in qutip.piqs, and the user can use it to define general nonlinear functions that can be described as the trace of a Taylor expandable function. Two nonlinear functions that use dicke_function_trace and are already implemented are purity_dicke, to calculate the purity of a density matrix in the Dicke basis, and entropy_vn_dicke, which can be used to calculate the Von Neumann entropy.; More functions relative to the qutip.piqs module can be found at API documentation. Attributes to the qutip.piqs.Dicke and qutip.piqs.Pim class can also be found there. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-piqs.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-piqs.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-piqs.html:507,Integrability,depend,dependent,507,"﻿. Permutational Invariance — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Introduction; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Krylov Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Permutational Invariant Quantum Solver (PIQS). Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Permutational Invariance. Permutational Invariance¶. Permutational Invariant Quantum Solver (PIQS)¶; The Permutational Invariant Quantum Solver (PIQS) is a QuTiP module that allows to study the dynamics of an open quantum system consisting of an ensemble of identical qubits that can dissipate through local and collective baths according to a Lindblad master equation.; The Liouvillian of an ensemble of \(N\) qubits, or two-level systems (TLSs), \(\mathcal{D}_{TLS}(\rho)\), can be built using only polynomial – instead of exponential – resources.; This has many applications for the study of realistic quantum optics models of many TLSs and in general as a tool in cavity QED.; ",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-piqs.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-piqs.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-piqs.html:3277,Usability,simpl,simply,3277,"{2}\mathcal{L}_{J_{+}}[\rho]\\+\sum_{n=1}^{N}\left(; \frac{\gamma_\text{E}}{2}\mathcal{L}_{J_{-,n}}[\rho]; +\frac{\gamma_\text{D}}{2}\mathcal{L}_{J_{z,n}}[\rho]; +\frac{\gamma_\text{P}}{2}\mathcal{L}_{J_{+,n}}[\rho]\right)\end{aligned}\end{align} \]; where \(J_{\alpha,n}=\frac{1}{2}\sigma_{\alpha,n}\) are SU(2) Pauli spin operators, with \({\alpha=x,y,z}\) and \(J_{\pm,n}=\sigma_{\pm,n}\). The collective spin operators are \(J_{\alpha} = \sum_{n}J_{\alpha,n}\) . The Lindblad super-operators are \(\mathcal{L}_{A} = 2A\rho A^\dagger - A^\dagger A \rho - \rho A^\dagger A\).; The inclusion of local processes in the dynamics lead to using a Liouvillian space of dimension \(4^N\). By exploiting the permutational invariance of identical particles [2-8], the Liouvillian \(\mathcal{D}_\text{TLS}(\rho)\) can be built as a block-diagonal matrix in the basis of Dicke states \(|j, m \rangle\).; The system under study is defined by creating an object of the; Dicke class, e.g. simply named; system, whose first attribute is. system.N, the number of TLSs of the system \(N\). The rates for collective and local processes are simply defined as. collective_emission defines \(\gamma_\text{CE}\), collective (superradiant) emission; collective_dephasing defines \(\gamma_\text{CD}\), collective dephasing; collective_pumping defines \(\gamma_\text{CP}\), collective pumping.; emission defines \(\gamma_\text{E}\), incoherent emission (losses); dephasing defines \(\gamma_\text{D}\), local dephasing; pumping defines \(\gamma_\text{P}\), incoherent pumping. Then the system.lindbladian() creates the total TLS Lindbladian superoperator matrix. Similarly, system.hamiltonian defines the TLS hamiltonian of the system \(H_\text{TLS}\).; The system’s Liouvillian can be built using system.liouvillian(). The properties of a Piqs object can be visualized by simply calling; system. We give two basic examples on the use of PIQS. In the first example the incoherent emission of N driven TLSs is considered.; fr",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-piqs.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-piqs.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-piqs.html:3424,Usability,simpl,simply,3424,"\frac{\gamma_\text{D}}{2}\mathcal{L}_{J_{z,n}}[\rho]; +\frac{\gamma_\text{P}}{2}\mathcal{L}_{J_{+,n}}[\rho]\right)\end{aligned}\end{align} \]; where \(J_{\alpha,n}=\frac{1}{2}\sigma_{\alpha,n}\) are SU(2) Pauli spin operators, with \({\alpha=x,y,z}\) and \(J_{\pm,n}=\sigma_{\pm,n}\). The collective spin operators are \(J_{\alpha} = \sum_{n}J_{\alpha,n}\) . The Lindblad super-operators are \(\mathcal{L}_{A} = 2A\rho A^\dagger - A^\dagger A \rho - \rho A^\dagger A\).; The inclusion of local processes in the dynamics lead to using a Liouvillian space of dimension \(4^N\). By exploiting the permutational invariance of identical particles [2-8], the Liouvillian \(\mathcal{D}_\text{TLS}(\rho)\) can be built as a block-diagonal matrix in the basis of Dicke states \(|j, m \rangle\).; The system under study is defined by creating an object of the; Dicke class, e.g. simply named; system, whose first attribute is. system.N, the number of TLSs of the system \(N\). The rates for collective and local processes are simply defined as. collective_emission defines \(\gamma_\text{CE}\), collective (superradiant) emission; collective_dephasing defines \(\gamma_\text{CD}\), collective dephasing; collective_pumping defines \(\gamma_\text{CP}\), collective pumping.; emission defines \(\gamma_\text{E}\), incoherent emission (losses); dephasing defines \(\gamma_\text{D}\), local dephasing; pumping defines \(\gamma_\text{P}\), incoherent pumping. Then the system.lindbladian() creates the total TLS Lindbladian superoperator matrix. Similarly, system.hamiltonian defines the TLS hamiltonian of the system \(H_\text{TLS}\).; The system’s Liouvillian can be built using system.liouvillian(). The properties of a Piqs object can be visualized by simply calling; system. We give two basic examples on the use of PIQS. In the first example the incoherent emission of N driven TLSs is considered.; from piqs import Dicke; from qutip import steadystate; N = 10; system = Dicke(N, emission = 1, pumping = 2); L",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-piqs.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-piqs.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-piqs.html:4149,Usability,simpl,simply,4149,"gonal matrix in the basis of Dicke states \(|j, m \rangle\).; The system under study is defined by creating an object of the; Dicke class, e.g. simply named; system, whose first attribute is. system.N, the number of TLSs of the system \(N\). The rates for collective and local processes are simply defined as. collective_emission defines \(\gamma_\text{CE}\), collective (superradiant) emission; collective_dephasing defines \(\gamma_\text{CD}\), collective dephasing; collective_pumping defines \(\gamma_\text{CP}\), collective pumping.; emission defines \(\gamma_\text{E}\), incoherent emission (losses); dephasing defines \(\gamma_\text{D}\), local dephasing; pumping defines \(\gamma_\text{P}\), incoherent pumping. Then the system.lindbladian() creates the total TLS Lindbladian superoperator matrix. Similarly, system.hamiltonian defines the TLS hamiltonian of the system \(H_\text{TLS}\).; The system’s Liouvillian can be built using system.liouvillian(). The properties of a Piqs object can be visualized by simply calling; system. We give two basic examples on the use of PIQS. In the first example the incoherent emission of N driven TLSs is considered.; from piqs import Dicke; from qutip import steadystate; N = 10; system = Dicke(N, emission = 1, pumping = 2); L = system.liouvillian(); steady = steadystate(L). For more example of use, see the “Permutational Invariant Lindblad Dynamics” section in the tutorials section of the website, https://qutip.org/tutorials.html. Useful PIQS functions.¶. Operators; Command; Description. Collective spin algebra \(J_x,\ J_y,\ J_z\); jspin(N); The collective spin algebra \(J_x,\ J_y,\ J_z\) for \(N\) TLSs. Collective spin \(J_x\); jspin(N, ""x""); The collective spin operator \(Jx\). Requires \(N\) number of TLSs. Collective spin \(J_y\); jspin(N, ""y""); The collective spin operator \(J_y\). Requires \(N\) number of TLSs. Collective spin \(J_z\); jspin(N, ""z""); The collective spin operator \(J_z\). Requires \(N\) number of TLSs. Collective sp",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-piqs.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-piqs.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-stochastic.html:5419,Availability,avail,available,5419,"re monitored operators. The deterministic part of the evolution, described by the \(d_1\) in Equation (1), takes into account all operators \(C_i\) and \(S_n\):. (9)¶\[d_1 = - i[H(t),\rho(t)]; + \sum_i D[C_i]\rho; + \sum_n D[S_n]\rho,\]; The stochastic part, \(d_{2,n}\), is given solely by the operators \(S_n\). (10)¶\[d_{2,n} = S_n \rho(t) + \rho(t) S_n^\dagger - \tr \left(S_n \rho (t); + \rho(t) S_n^\dagger \right)\rho(t).\]; As in the stochastic Schrodinger equation, the detection method can be specified using the method argument. Example¶; Below, we solve the dynamics for an optical cavity at 0K whose output is monitored using homodyne detection. The cavity decay rate is given by \(\kappa\) and the \(\Delta\) is the cavity detuning with respect to the driving field. The measurement operators can be passed using the option m_ops. The homodyne current \(J_x\) is calculated using. (11)¶\[J_x = \langle x \rangle + dW,\]; where \(x\) is the operator passed using m_ops. The results are available in result.measurements.; import numpy as np; import matplotlib.pyplot as plt; import qutip as qt. # parameters; DIM = 20 # Hilbert space dimension; DELTA = 5*2*np.pi # cavity detuning; KAPPA = 2 # cavity decay rate; INTENSITY = 4 # intensity of initial state; NUMBER_OF_TRAJECTORIES = 500. # operators; a = qt.destroy(DIM); x = a + a.dag(); H = DELTA*a.dag()* a. rho_0 = qt.coherent(DIM, np.sqrt(INTENSITY)); times = np.arange(0, 1, 0.0025). stoc_solution = qt.smesolve(H, rho_0, times,; c_ops=[],; sc_ops=[np.sqrt(KAPPA) * a],; e_ops=[x],; ntraj=NUMBER_OF_TRAJECTORIES,; nsubsteps=2,; store_measurement=True,; dW_factors=[1],; method='homodyne'). fig, ax = plt.subplots(); ax.set_title('Stochastic Master Equation - Homodyne Detection'); ax.plot(times, np.array(stoc_solution.measurement).mean(axis=0)[:].real,; 'r', lw=2, label=r'$J_x$'); ax.plot(times, stoc_solution.expect[0], 'k', lw=2,; label=r'$\langle x \rangle$'); ax.set_xlabel('Time'); ax.legend(). For other examples on qutip.stoc",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-stochastic.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-stochastic.html:6493,Availability,avail,available,6493,"left(S_n \rho (t); + \rho(t) S_n^\dagger \right)\rho(t).\]; As in the stochastic Schrodinger equation, the detection method can be specified using the method argument. Example¶; Below, we solve the dynamics for an optical cavity at 0K whose output is monitored using homodyne detection. The cavity decay rate is given by \(\kappa\) and the \(\Delta\) is the cavity detuning with respect to the driving field. The measurement operators can be passed using the option m_ops. The homodyne current \(J_x\) is calculated using. (11)¶\[J_x = \langle x \rangle + dW,\]; where \(x\) is the operator passed using m_ops. The results are available in result.measurements.; import numpy as np; import matplotlib.pyplot as plt; import qutip as qt. # parameters; DIM = 20 # Hilbert space dimension; DELTA = 5*2*np.pi # cavity detuning; KAPPA = 2 # cavity decay rate; INTENSITY = 4 # intensity of initial state; NUMBER_OF_TRAJECTORIES = 500. # operators; a = qt.destroy(DIM); x = a + a.dag(); H = DELTA*a.dag()* a. rho_0 = qt.coherent(DIM, np.sqrt(INTENSITY)); times = np.arange(0, 1, 0.0025). stoc_solution = qt.smesolve(H, rho_0, times,; c_ops=[],; sc_ops=[np.sqrt(KAPPA) * a],; e_ops=[x],; ntraj=NUMBER_OF_TRAJECTORIES,; nsubsteps=2,; store_measurement=True,; dW_factors=[1],; method='homodyne'). fig, ax = plt.subplots(); ax.set_title('Stochastic Master Equation - Homodyne Detection'); ax.plot(times, np.array(stoc_solution.measurement).mean(axis=0)[:].real,; 'r', lw=2, label=r'$J_x$'); ax.plot(times, stoc_solution.expect[0], 'k', lw=2,; label=r'$\langle x \rangle$'); ax.set_xlabel('Time'); ax.legend(). For other examples on qutip.stochastic.smesolve, see the following notebook, as well as these notebooks available at QuTiP Tutorials page: heterodyne detection, inneficient detection, and feedback control. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-stochastic.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-stochastic.html:1404,Deployability,continuous,continuous,1404,"stic Solver; Stochastic Schrodinger Equation; Stochastic Master Equation. Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Stochastic Solver. Stochastic Solver¶; When a quantum system is subjected to continuous measurement, through homodyne detection for example, it is possible to simulate the conditional quantum state using stochastic Schrodinger and master equations. The solution of these stochastic equations are quantum trajectories, which represent the conditioned evolution of the system given a specific measurement record.; In general, the stochastic evolution of a quantum state is calculated in; QuTiP by solving the general equation. (1)¶\[d \rho (t) = d_1 \rho dt + \sum_n d_{2,n} \rho dW_n,\]; where \(dW_n\) is a Wiener increment, which has the expectation values \(E[dW] = 0\) and \(E[dW^2] = dt\). Stochastic evolution is implemented with the qutip.stochastic.general_stochastic function. Stochastic Schrodinger Equation¶; The stochastic Schrodinger equation is given by (see section 4.4, [Wis09]). (2)¶\[d \psi(t) = - i H \psi(t) dt; - \sum_n \left( \frac{S_n^\dagger S_n}{2} -\frac{e_n}{2} S_n; + \frac{e_n^2}{8} \right) \psi(t) dt; + \sum_n \left( S_n - \frac{e_n}{2} \right) \psi(t) dW_n,\]; where \(H\) is the Hamiltonian, \(S_n\) a",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-stochastic.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-stochastic.html:6691,Deployability,update,updated,6691,"left(S_n \rho (t); + \rho(t) S_n^\dagger \right)\rho(t).\]; As in the stochastic Schrodinger equation, the detection method can be specified using the method argument. Example¶; Below, we solve the dynamics for an optical cavity at 0K whose output is monitored using homodyne detection. The cavity decay rate is given by \(\kappa\) and the \(\Delta\) is the cavity detuning with respect to the driving field. The measurement operators can be passed using the option m_ops. The homodyne current \(J_x\) is calculated using. (11)¶\[J_x = \langle x \rangle + dW,\]; where \(x\) is the operator passed using m_ops. The results are available in result.measurements.; import numpy as np; import matplotlib.pyplot as plt; import qutip as qt. # parameters; DIM = 20 # Hilbert space dimension; DELTA = 5*2*np.pi # cavity detuning; KAPPA = 2 # cavity decay rate; INTENSITY = 4 # intensity of initial state; NUMBER_OF_TRAJECTORIES = 500. # operators; a = qt.destroy(DIM); x = a + a.dag(); H = DELTA*a.dag()* a. rho_0 = qt.coherent(DIM, np.sqrt(INTENSITY)); times = np.arange(0, 1, 0.0025). stoc_solution = qt.smesolve(H, rho_0, times,; c_ops=[],; sc_ops=[np.sqrt(KAPPA) * a],; e_ops=[x],; ntraj=NUMBER_OF_TRAJECTORIES,; nsubsteps=2,; store_measurement=True,; dW_factors=[1],; method='homodyne'). fig, ax = plt.subplots(); ax.set_title('Stochastic Master Equation - Homodyne Detection'); ax.plot(times, np.array(stoc_solution.measurement).mean(axis=0)[:].real,; 'r', lw=2, label=r'$J_x$'); ax.plot(times, stoc_solution.expect[0], 'k', lw=2,; label=r'$\langle x \rangle$'); ax.set_xlabel('Time'); ax.legend(). For other examples on qutip.stochastic.smesolve, see the following notebook, as well as these notebooks available at QuTiP Tutorials page: heterodyne detection, inneficient detection, and feedback control. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-stochastic.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-stochastic.html:4423,Energy Efficiency,monitor,monitored,4423,"mulated by passing the arguments method='homodyne' or method='heterodyne' to qutip.stochastic.ssesolve.; Examples of how to solve the stochastic Schrodinger equation using QuTiP can be found in this development notebook. Stochastic Master Equation¶; When the initial state of the system is a density matrix \(\rho\), the stochastic master equation solver qutip.stochastic.smesolve must be used. The stochastic master equation is given by (see section 4.4, [Wis09]). (6)¶\[ d \rho (t) = -i[H, \rho(t)] dt + D[A]\rho(t) dt + \mathcal{H}[A]\rho dW(t)\]; where. (7)¶\[D[A] \rho = \frac{1}{2} \left[2 A \rho A^\dagger; - \rho A^\dagger A - A^\dagger A \rho \right],\]; and. (8)¶\[\mathcal{H}[A]\rho = A\rho(t) + \rho(t) A^\dagger - \tr[A\rho(t) + \rho(t) A^\dagger].\]; In QuTiP, solutions for the stochastic master equation are obtained using the solver qutip.stochastic.smesolve. The implementation takes into account 2 types of collapse operators. \(C_i\) (c_ops) represent the dissipation in the environment, while \(S_n\) (sc_ops) are monitored operators. The deterministic part of the evolution, described by the \(d_1\) in Equation (1), takes into account all operators \(C_i\) and \(S_n\):. (9)¶\[d_1 = - i[H(t),\rho(t)]; + \sum_i D[C_i]\rho; + \sum_n D[S_n]\rho,\]; The stochastic part, \(d_{2,n}\), is given solely by the operators \(S_n\). (10)¶\[d_{2,n} = S_n \rho(t) + \rho(t) S_n^\dagger - \tr \left(S_n \rho (t); + \rho(t) S_n^\dagger \right)\rho(t).\]; As in the stochastic Schrodinger equation, the detection method can be specified using the method argument. Example¶; Below, we solve the dynamics for an optical cavity at 0K whose output is monitored using homodyne detection. The cavity decay rate is given by \(\kappa\) and the \(\Delta\) is the cavity detuning with respect to the driving field. The measurement operators can be passed using the option m_ops. The homodyne current \(J_x\) is calculated using. (11)¶\[J_x = \langle x \rangle + dW,\]; where \(x\) is the operator passe",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-stochastic.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-stochastic.html:5043,Energy Efficiency,monitor,monitored,5043," A - A^\dagger A \rho \right],\]; and. (8)¶\[\mathcal{H}[A]\rho = A\rho(t) + \rho(t) A^\dagger - \tr[A\rho(t) + \rho(t) A^\dagger].\]; In QuTiP, solutions for the stochastic master equation are obtained using the solver qutip.stochastic.smesolve. The implementation takes into account 2 types of collapse operators. \(C_i\) (c_ops) represent the dissipation in the environment, while \(S_n\) (sc_ops) are monitored operators. The deterministic part of the evolution, described by the \(d_1\) in Equation (1), takes into account all operators \(C_i\) and \(S_n\):. (9)¶\[d_1 = - i[H(t),\rho(t)]; + \sum_i D[C_i]\rho; + \sum_n D[S_n]\rho,\]; The stochastic part, \(d_{2,n}\), is given solely by the operators \(S_n\). (10)¶\[d_{2,n} = S_n \rho(t) + \rho(t) S_n^\dagger - \tr \left(S_n \rho (t); + \rho(t) S_n^\dagger \right)\rho(t).\]; As in the stochastic Schrodinger equation, the detection method can be specified using the method argument. Example¶; Below, we solve the dynamics for an optical cavity at 0K whose output is monitored using homodyne detection. The cavity decay rate is given by \(\kappa\) and the \(\Delta\) is the cavity detuning with respect to the driving field. The measurement operators can be passed using the option m_ops. The homodyne current \(J_x\) is calculated using. (11)¶\[J_x = \langle x \rangle + dW,\]; where \(x\) is the operator passed using m_ops. The results are available in result.measurements.; import numpy as np; import matplotlib.pyplot as plt; import qutip as qt. # parameters; DIM = 20 # Hilbert space dimension; DELTA = 5*2*np.pi # cavity detuning; KAPPA = 2 # cavity decay rate; INTENSITY = 4 # intensity of initial state; NUMBER_OF_TRAJECTORIES = 500. # operators; a = qt.destroy(DIM); x = a + a.dag(); H = DELTA*a.dag()* a. rho_0 = qt.coherent(DIM, np.sqrt(INTENSITY)); times = np.arange(0, 1, 0.0025). stoc_solution = qt.smesolve(H, rho_0, times,; c_ops=[],; sc_ops=[np.sqrt(KAPPA) * a],; e_ops=[x],; ntraj=NUMBER_OF_TRAJECTORIES,; nsubsteps=2,; stor",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-stochastic.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-stochastic.html:561,Integrability,depend,dependent,561,"﻿. Stochastic Solver — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Introduction; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Krylov Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Stochastic Schrodinger Equation; Stochastic Master Equation. Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Stochastic Solver. Stochastic Solver¶; When a quantum system is subjected to continuous measurement, through homodyne detection for example, it is possible to simulate the conditional quantum state using stochastic Schrodinger and master equations. The solution of these stochastic equations are quantum trajectories, which represent the conditioned evolution of the system given a specific measurement record.; In general, the stochastic evolution of a quantum state is calculated in; QuTiP by solving the general equation. (1)¶\[d \rho (t) = d_1 \rho dt + \sum_n d_{2,n} \rho dW_n,\]; where \(dW_n\) is a Wiener increment, which has the expectation values \(E[dW] = 0\) an",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-stochastic.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-stochastic.html:1445,Safety,detect,detection,1445,"stic Solver; Stochastic Schrodinger Equation; Stochastic Master Equation. Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Stochastic Solver. Stochastic Solver¶; When a quantum system is subjected to continuous measurement, through homodyne detection for example, it is possible to simulate the conditional quantum state using stochastic Schrodinger and master equations. The solution of these stochastic equations are quantum trajectories, which represent the conditioned evolution of the system given a specific measurement record.; In general, the stochastic evolution of a quantum state is calculated in; QuTiP by solving the general equation. (1)¶\[d \rho (t) = d_1 \rho dt + \sum_n d_{2,n} \rho dW_n,\]; where \(dW_n\) is a Wiener increment, which has the expectation values \(E[dW] = 0\) and \(E[dW^2] = dt\). Stochastic evolution is implemented with the qutip.stochastic.general_stochastic function. Stochastic Schrodinger Equation¶; The stochastic Schrodinger equation is given by (see section 4.4, [Wis09]). (2)¶\[d \psi(t) = - i H \psi(t) dt; - \sum_n \left( \frac{S_n^\dagger S_n}{2} -\frac{e_n}{2} S_n; + \frac{e_n^2}{8} \right) \psi(t) dt; + \sum_n \left( S_n - \frac{e_n}{2} \right) \psi(t) dW_n,\]; where \(H\) is the Hamiltonian, \(S_n\) a",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-stochastic.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-stochastic.html:3361,Safety,detect,detections,3361,"ight) \psi(t) dW_n,\]; where \(H\) is the Hamiltonian, \(S_n\) are the stochastic collapse operators, and \(e_n\) is. (3)¶\[e_n = \left<\psi(t)|S_n + S_n^\dagger|\psi(t)\right>\]; In QuTiP, this equation can be solved using the function qutip.stochastic.ssesolve, which is implemented by defining \(d_1\) and \(d_{2,n}\) from Equation (1) as. (4)¶\[d_1 = -iH - \frac{1}{2} \sum_n \left(S_n^\dagger S_n - e_n S_n + \frac{e_i^2}{4} \right),\]; and. (5)¶\[d_{2, n} = S_n - \frac{e_n}{2}.\]; The solver qutip.stochastic.ssesolve will construct the operators \(d_1\) and \(d_{2,n}\) once the user passes the Hamiltonian (H) and the stochastic operator list (sc_ops). As with the qutip.mcsolve, the number of trajectories and the seed for the noise realisation can be fixed using the arguments: ntraj and noise, respectively. If the user also requires the measurement output, the argument store_measurement=True should be included.; Additionally, homodyne and heterodyne detections can be easily simulated by passing the arguments method='homodyne' or method='heterodyne' to qutip.stochastic.ssesolve.; Examples of how to solve the stochastic Schrodinger equation using QuTiP can be found in this development notebook. Stochastic Master Equation¶; When the initial state of the system is a density matrix \(\rho\), the stochastic master equation solver qutip.stochastic.smesolve must be used. The stochastic master equation is given by (see section 4.4, [Wis09]). (6)¶\[ d \rho (t) = -i[H, \rho(t)] dt + D[A]\rho(t) dt + \mathcal{H}[A]\rho dW(t)\]; where. (7)¶\[D[A] \rho = \frac{1}{2} \left[2 A \rho A^\dagger; - \rho A^\dagger A - A^\dagger A \rho \right],\]; and. (8)¶\[\mathcal{H}[A]\rho = A\rho(t) + \rho(t) A^\dagger - \tr[A\rho(t) + \rho(t) A^\dagger].\]; In QuTiP, solutions for the stochastic master equation are obtained using the solver qutip.stochastic.smesolve. The implementation takes into account 2 types of collapse operators. \(C_i\) (c_ops) represent the dissipation in the environment, ",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-stochastic.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-stochastic.html:4899,Safety,detect,detection,4899,"t) dt + \mathcal{H}[A]\rho dW(t)\]; where. (7)¶\[D[A] \rho = \frac{1}{2} \left[2 A \rho A^\dagger; - \rho A^\dagger A - A^\dagger A \rho \right],\]; and. (8)¶\[\mathcal{H}[A]\rho = A\rho(t) + \rho(t) A^\dagger - \tr[A\rho(t) + \rho(t) A^\dagger].\]; In QuTiP, solutions for the stochastic master equation are obtained using the solver qutip.stochastic.smesolve. The implementation takes into account 2 types of collapse operators. \(C_i\) (c_ops) represent the dissipation in the environment, while \(S_n\) (sc_ops) are monitored operators. The deterministic part of the evolution, described by the \(d_1\) in Equation (1), takes into account all operators \(C_i\) and \(S_n\):. (9)¶\[d_1 = - i[H(t),\rho(t)]; + \sum_i D[C_i]\rho; + \sum_n D[S_n]\rho,\]; The stochastic part, \(d_{2,n}\), is given solely by the operators \(S_n\). (10)¶\[d_{2,n} = S_n \rho(t) + \rho(t) S_n^\dagger - \tr \left(S_n \rho (t); + \rho(t) S_n^\dagger \right)\rho(t).\]; As in the stochastic Schrodinger equation, the detection method can be specified using the method argument. Example¶; Below, we solve the dynamics for an optical cavity at 0K whose output is monitored using homodyne detection. The cavity decay rate is given by \(\kappa\) and the \(\Delta\) is the cavity detuning with respect to the driving field. The measurement operators can be passed using the option m_ops. The homodyne current \(J_x\) is calculated using. (11)¶\[J_x = \langle x \rangle + dW,\]; where \(x\) is the operator passed using m_ops. The results are available in result.measurements.; import numpy as np; import matplotlib.pyplot as plt; import qutip as qt. # parameters; DIM = 20 # Hilbert space dimension; DELTA = 5*2*np.pi # cavity detuning; KAPPA = 2 # cavity decay rate; INTENSITY = 4 # intensity of initial state; NUMBER_OF_TRAJECTORIES = 500. # operators; a = qt.destroy(DIM); x = a + a.dag(); H = DELTA*a.dag()* a. rho_0 = qt.coherent(DIM, np.sqrt(INTENSITY)); times = np.arange(0, 1, 0.0025). stoc_solution = qt.smesolve(H, rh",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-stochastic.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-stochastic.html:5068,Safety,detect,detection,5068," A - A^\dagger A \rho \right],\]; and. (8)¶\[\mathcal{H}[A]\rho = A\rho(t) + \rho(t) A^\dagger - \tr[A\rho(t) + \rho(t) A^\dagger].\]; In QuTiP, solutions for the stochastic master equation are obtained using the solver qutip.stochastic.smesolve. The implementation takes into account 2 types of collapse operators. \(C_i\) (c_ops) represent the dissipation in the environment, while \(S_n\) (sc_ops) are monitored operators. The deterministic part of the evolution, described by the \(d_1\) in Equation (1), takes into account all operators \(C_i\) and \(S_n\):. (9)¶\[d_1 = - i[H(t),\rho(t)]; + \sum_i D[C_i]\rho; + \sum_n D[S_n]\rho,\]; The stochastic part, \(d_{2,n}\), is given solely by the operators \(S_n\). (10)¶\[d_{2,n} = S_n \rho(t) + \rho(t) S_n^\dagger - \tr \left(S_n \rho (t); + \rho(t) S_n^\dagger \right)\rho(t).\]; As in the stochastic Schrodinger equation, the detection method can be specified using the method argument. Example¶; Below, we solve the dynamics for an optical cavity at 0K whose output is monitored using homodyne detection. The cavity decay rate is given by \(\kappa\) and the \(\Delta\) is the cavity detuning with respect to the driving field. The measurement operators can be passed using the option m_ops. The homodyne current \(J_x\) is calculated using. (11)¶\[J_x = \langle x \rangle + dW,\]; where \(x\) is the operator passed using m_ops. The results are available in result.measurements.; import numpy as np; import matplotlib.pyplot as plt; import qutip as qt. # parameters; DIM = 20 # Hilbert space dimension; DELTA = 5*2*np.pi # cavity detuning; KAPPA = 2 # cavity decay rate; INTENSITY = 4 # intensity of initial state; NUMBER_OF_TRAJECTORIES = 500. # operators; a = qt.destroy(DIM); x = a + a.dag(); H = DELTA*a.dag()* a. rho_0 = qt.coherent(DIM, np.sqrt(INTENSITY)); times = np.arange(0, 1, 0.0025). stoc_solution = qt.smesolve(H, rho_0, times,; c_ops=[],; sc_ops=[np.sqrt(KAPPA) * a],; e_ops=[x],; ntraj=NUMBER_OF_TRAJECTORIES,; nsubsteps=2,; stor",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-stochastic.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-stochastic.html:6539,Safety,detect,detection,6539,"left(S_n \rho (t); + \rho(t) S_n^\dagger \right)\rho(t).\]; As in the stochastic Schrodinger equation, the detection method can be specified using the method argument. Example¶; Below, we solve the dynamics for an optical cavity at 0K whose output is monitored using homodyne detection. The cavity decay rate is given by \(\kappa\) and the \(\Delta\) is the cavity detuning with respect to the driving field. The measurement operators can be passed using the option m_ops. The homodyne current \(J_x\) is calculated using. (11)¶\[J_x = \langle x \rangle + dW,\]; where \(x\) is the operator passed using m_ops. The results are available in result.measurements.; import numpy as np; import matplotlib.pyplot as plt; import qutip as qt. # parameters; DIM = 20 # Hilbert space dimension; DELTA = 5*2*np.pi # cavity detuning; KAPPA = 2 # cavity decay rate; INTENSITY = 4 # intensity of initial state; NUMBER_OF_TRAJECTORIES = 500. # operators; a = qt.destroy(DIM); x = a + a.dag(); H = DELTA*a.dag()* a. rho_0 = qt.coherent(DIM, np.sqrt(INTENSITY)); times = np.arange(0, 1, 0.0025). stoc_solution = qt.smesolve(H, rho_0, times,; c_ops=[],; sc_ops=[np.sqrt(KAPPA) * a],; e_ops=[x],; ntraj=NUMBER_OF_TRAJECTORIES,; nsubsteps=2,; store_measurement=True,; dW_factors=[1],; method='homodyne'). fig, ax = plt.subplots(); ax.set_title('Stochastic Master Equation - Homodyne Detection'); ax.plot(times, np.array(stoc_solution.measurement).mean(axis=0)[:].real,; 'r', lw=2, label=r'$J_x$'); ax.plot(times, stoc_solution.expect[0], 'k', lw=2,; label=r'$\langle x \rangle$'); ax.set_xlabel('Time'); ax.legend(). For other examples on qutip.stochastic.smesolve, see the following notebook, as well as these notebooks available at QuTiP Tutorials page: heterodyne detection, inneficient detection, and feedback control. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-stochastic.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-stochastic.html:6562,Safety,detect,detection,6562,"left(S_n \rho (t); + \rho(t) S_n^\dagger \right)\rho(t).\]; As in the stochastic Schrodinger equation, the detection method can be specified using the method argument. Example¶; Below, we solve the dynamics for an optical cavity at 0K whose output is monitored using homodyne detection. The cavity decay rate is given by \(\kappa\) and the \(\Delta\) is the cavity detuning with respect to the driving field. The measurement operators can be passed using the option m_ops. The homodyne current \(J_x\) is calculated using. (11)¶\[J_x = \langle x \rangle + dW,\]; where \(x\) is the operator passed using m_ops. The results are available in result.measurements.; import numpy as np; import matplotlib.pyplot as plt; import qutip as qt. # parameters; DIM = 20 # Hilbert space dimension; DELTA = 5*2*np.pi # cavity detuning; KAPPA = 2 # cavity decay rate; INTENSITY = 4 # intensity of initial state; NUMBER_OF_TRAJECTORIES = 500. # operators; a = qt.destroy(DIM); x = a + a.dag(); H = DELTA*a.dag()* a. rho_0 = qt.coherent(DIM, np.sqrt(INTENSITY)); times = np.arange(0, 1, 0.0025). stoc_solution = qt.smesolve(H, rho_0, times,; c_ops=[],; sc_ops=[np.sqrt(KAPPA) * a],; e_ops=[x],; ntraj=NUMBER_OF_TRAJECTORIES,; nsubsteps=2,; store_measurement=True,; dW_factors=[1],; method='homodyne'). fig, ax = plt.subplots(); ax.set_title('Stochastic Master Equation - Homodyne Detection'); ax.plot(times, np.array(stoc_solution.measurement).mean(axis=0)[:].real,; 'r', lw=2, label=r'$J_x$'); ax.plot(times, stoc_solution.expect[0], 'k', lw=2,; label=r'$\langle x \rangle$'); ax.set_xlabel('Time'); ax.legend(). For other examples on qutip.stochastic.smesolve, see the following notebook, as well as these notebooks available at QuTiP Tutorials page: heterodyne detection, inneficient detection, and feedback control. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-stochastic.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-stochastic.html:6577,Usability,feedback,feedback,6577,"left(S_n \rho (t); + \rho(t) S_n^\dagger \right)\rho(t).\]; As in the stochastic Schrodinger equation, the detection method can be specified using the method argument. Example¶; Below, we solve the dynamics for an optical cavity at 0K whose output is monitored using homodyne detection. The cavity decay rate is given by \(\kappa\) and the \(\Delta\) is the cavity detuning with respect to the driving field. The measurement operators can be passed using the option m_ops. The homodyne current \(J_x\) is calculated using. (11)¶\[J_x = \langle x \rangle + dW,\]; where \(x\) is the operator passed using m_ops. The results are available in result.measurements.; import numpy as np; import matplotlib.pyplot as plt; import qutip as qt. # parameters; DIM = 20 # Hilbert space dimension; DELTA = 5*2*np.pi # cavity detuning; KAPPA = 2 # cavity decay rate; INTENSITY = 4 # intensity of initial state; NUMBER_OF_TRAJECTORIES = 500. # operators; a = qt.destroy(DIM); x = a + a.dag(); H = DELTA*a.dag()* a. rho_0 = qt.coherent(DIM, np.sqrt(INTENSITY)); times = np.arange(0, 1, 0.0025). stoc_solution = qt.smesolve(H, rho_0, times,; c_ops=[],; sc_ops=[np.sqrt(KAPPA) * a],; e_ops=[x],; ntraj=NUMBER_OF_TRAJECTORIES,; nsubsteps=2,; store_measurement=True,; dW_factors=[1],; method='homodyne'). fig, ax = plt.subplots(); ax.set_title('Stochastic Master Equation - Homodyne Detection'); ax.plot(times, np.array(stoc_solution.measurement).mean(axis=0)[:].real,; 'r', lw=2, label=r'$J_x$'); ax.plot(times, stoc_solution.expect[0], 'k', lw=2,; label=r'$\langle x \rangle$'); ax.set_xlabel('Time'); ax.legend(). For other examples on qutip.stochastic.smesolve, see the following notebook, as well as these notebooks available at QuTiP Tutorials page: heterodyne detection, inneficient detection, and feedback control. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-stochastic.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:14044,Availability,error,errors,14044,"efine initial state; state_GG = tensor(basis(N, 1), ground) # Define states onto which to project; sigma_GG = state_GG * state_GG.dag(); state_UU = tensor(basis(N, 0), ustate); sigma_UU = state_UU * state_UU.dag(). g = 5 # coupling strength; H0 = -g * (sigma_ge.dag() * a + a.dag() * sigma_ge) # time-independent term; H1 = (sigma_ue.dag() + sigma_ue) # time-dependent term. H = [H0, [H1, '9 * exp(-(t / 5) ** 2)']]. Notice that this is a valid Hamiltonian for the string-based format as exp is included in the above list of suitable functions. Calling the solvers is the same as before:; output = mesolve(H, psi0, t, c_ops, [a.dag() * a]). We can also use the args variable in the same manner as before, however we must rewrite our string term to read: 'A * exp(-(t / sig) ** 2)'; H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]; args = {'A': 9, 'sig': 5}; output = mesolve(H, psi0, times, c_ops, [a.dag()*a], args=args). Important; Naming your args variables exp, sin, pi etc. will cause errors when using the string-based format. Collapse operators are handled in the exact same way. Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions¶; Sometimes it is necessary to model a system where the time-dependent parameters are non-analytic functions, or are derived from experimental data (i.e. a collection of data points). In these situations, one can use interpolating functions as an approximate functional form for input into a time-dependent solver. QuTiP includes its own custom cubic spline interpolation class qutip.interpolate.Cubic_Spline to provide this functionality. To see how this works, lets first generate some noisy data:; t = np.linspace(-15, 15, 100); func = lambda t: 9*np.exp(-(t / 5)** 2); noisy_func = lambda t: func(t)+(0.05*func(t))*np.random.randn(t.shape[0]); noisy_data = noisy_func(t). plt.figure(); plt.plot(t, func(t)); plt.plot(t, noisy_data, 'o'); plt.show(). To turn these data points into a function we call the QuTiP qutip.",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:16443,Availability,avail,available,16443,"d. This cubic spline class S can now be pasted to any of the mesolve, mcsolve, or sesolve functions where one would normally input a time-dependent function or string-representation. Taking the problem from the previous section as an example. We would make the replacement:; H = [H0, [H1, '9 * exp(-(t / 5) ** 2)']]. to; H = [H0, [H1, S]]. When combining interpolating functions with other Python functions or strings, the interpolating class will automatically pick the appropriate method for calling the class. That is to say that, if for example, you have other time-dependent terms that are given in the string-format, then the cubic spline representation will also be passed in a string-compatible format. In the string-format, the interpolation function is compiled into c-code, and thus is quite fast. This is the default method if no other time-dependent terms are present. Accesing the state from solver¶; New in QuTiP 4.4; The state of the system, the ket vector or the density matrix,; is available to time-dependent Hamiltonian and collapse operators in args.; Some keys of the argument dictionary are understood by the solver to be values; to be updated with the evolution of the system.; The state can be obtained in 3 forms: Qobj, vector (1d np.array), matrix (2d np.array),; expectation values and collapse can also be obtained. Preparation; usage; Notes. state as Qobj; name+""=Qobj"":psi0; psi_t=args[name]; The ket or density matrix as a Qobj with psi0’s dimensions. state as matrix; name+""=mat"":psi0; mat_t=args[name]; The state as a matrix, equivalent to state.full(). state as vector; name+""=vec"":psi0; vec_t=args[name]; The state as a vector, equivalent to state.full().ravel('F'). expectation value; name+""=expect"":O; e=args[name]; Expectation value of the operator O, either; \(\left<\psi(t)|O|\psi(t)\right>\); or \(\rm{tr}\left(O \rho(t)\right)\). collpases; name+""=collapse"":[]; col=args[name]; List of collapse,; each collapse is a tuple of the pair (time, which); which bei",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:11376,Deployability,install,installed,11376,"se of the args variable; def H1_coeff(t, args):; return args['A'] * np.exp(-(t/args['sigma'])**2). or equivalently,; def H1_coeff(t, args):; A = args['A']; sig = args['sigma']; return A * np.exp(-(t / sig) ** 2). where args is a Python dictionary of key: value pairs args = {'A': a, 'sigma': b} where a and b are the two parameters for the amplitude and width, respectively. Of course, we can always hardcode the values in the dictionary as well args = {'A': 9, 'sigma': 5}, but there is much more flexibility by using variables in args. To let the solvers know that we have a set of args to pass we append the args to the end of the solver input:; output = mesolve(H, psi0, times, c_ops, [a.dag() * a], args={'A': 9, 'sigma': 5}). or to keep things looking pretty; args = {'A': 9, 'sigma': 5}; output = mesolve(H, psi0, times, c_ops, [a.dag() * a], args=args). Once again, the Monte Carlo solver qutip.mcsolve works in an identical manner. String Format Method¶. Note; You must have Cython installed on your computer to use this format. See Installation for instructions on installing Cython. The string-based time-dependent format works in a similar manner as the previously discussed Python function method. That being said, the underlying code does something completely different. When using this format, the strings used to represent the time-dependent coefficients, as well as Hamiltonian and collapse operators, are rewritten as Cython code using a code generator class and then compiled into C code. The details of this meta-programming will be published in due course. However, in short, this can lead to a substantial reduction in time for complex time-dependent problems, or when simulating over long intervals.; Like the previous method, the string-based format uses a list pair format [Op, str] where str is now a string representing the time-dependent coefficient. For our first example, this string would be '9 * exp(-(t / 5.) ** 2)'. The Hamiltonian in this format would take the form",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:11460,Deployability,install,installing,11460," * np.exp(-(t/args['sigma'])**2). or equivalently,; def H1_coeff(t, args):; A = args['A']; sig = args['sigma']; return A * np.exp(-(t / sig) ** 2). where args is a Python dictionary of key: value pairs args = {'A': a, 'sigma': b} where a and b are the two parameters for the amplitude and width, respectively. Of course, we can always hardcode the values in the dictionary as well args = {'A': 9, 'sigma': 5}, but there is much more flexibility by using variables in args. To let the solvers know that we have a set of args to pass we append the args to the end of the solver input:; output = mesolve(H, psi0, times, c_ops, [a.dag() * a], args={'A': 9, 'sigma': 5}). or to keep things looking pretty; args = {'A': 9, 'sigma': 5}; output = mesolve(H, psi0, times, c_ops, [a.dag() * a], args=args). Once again, the Monte Carlo solver qutip.mcsolve works in an identical manner. String Format Method¶. Note; You must have Cython installed on your computer to use this format. See Installation for instructions on installing Cython. The string-based time-dependent format works in a similar manner as the previously discussed Python function method. That being said, the underlying code does something completely different. When using this format, the strings used to represent the time-dependent coefficients, as well as Hamiltonian and collapse operators, are rewritten as Cython code using a code generator class and then compiled into C code. The details of this meta-programming will be published in due course. However, in short, this can lead to a substantial reduction in time for complex time-dependent problems, or when simulating over long intervals.; Like the previous method, the string-based format uses a list pair format [Op, str] where str is now a string representing the time-dependent coefficient. For our first example, this string would be '9 * exp(-(t / 5.) ** 2)'. The Hamiltonian in this format would take the form:; ustate = basis(3, 0); excited = basis(3, 1); ground = basis(3,",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:16602,Deployability,update,updated,16602,"me-dependent function or string-representation. Taking the problem from the previous section as an example. We would make the replacement:; H = [H0, [H1, '9 * exp(-(t / 5) ** 2)']]. to; H = [H0, [H1, S]]. When combining interpolating functions with other Python functions or strings, the interpolating class will automatically pick the appropriate method for calling the class. That is to say that, if for example, you have other time-dependent terms that are given in the string-format, then the cubic spline representation will also be passed in a string-compatible format. In the string-format, the interpolation function is compiled into c-code, and thus is quite fast. This is the default method if no other time-dependent terms are present. Accesing the state from solver¶; New in QuTiP 4.4; The state of the system, the ket vector or the density matrix,; is available to time-dependent Hamiltonian and collapse operators in args.; Some keys of the argument dictionary are understood by the solver to be values; to be updated with the evolution of the system.; The state can be obtained in 3 forms: Qobj, vector (1d np.array), matrix (2d np.array),; expectation values and collapse can also be obtained. Preparation; usage; Notes. state as Qobj; name+""=Qobj"":psi0; psi_t=args[name]; The ket or density matrix as a Qobj with psi0’s dimensions. state as matrix; name+""=mat"":psi0; mat_t=args[name]; The state as a matrix, equivalent to state.full(). state as vector; name+""=vec"":psi0; vec_t=args[name]; The state as a vector, equivalent to state.full().ravel('F'). expectation value; name+""=expect"":O; e=args[name]; Expectation value of the operator O, either; \(\left<\psi(t)|O|\psi(t)\right>\); or \(\rm{tr}\left(O \rho(t)\right)\). collpases; name+""=collapse"":[]; col=args[name]; List of collapse,; each collapse is a tuple of the pair (time, which); which being the indice of the collapse operator.; mcsolve only. Here psi0 is the initial value used for tests before the evolution begins.; quti",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:18968,Deployability,update,updated,18968,"_t=args[name]; The state as a vector, equivalent to state.full().ravel('F'). expectation value; name+""=expect"":O; e=args[name]; Expectation value of the operator O, either; \(\left<\psi(t)|O|\psi(t)\right>\); or \(\rm{tr}\left(O \rho(t)\right)\). collpases; name+""=collapse"":[]; col=args[name]; List of collapse,; each collapse is a tuple of the pair (time, which); which being the indice of the collapse operator.; mcsolve only. Here psi0 is the initial value used for tests before the evolution begins.; qutip.bloch_redfield.brmesolve does not support these arguments. Reusing Time-Dependent Hamiltonian Data¶. Note; This section covers a specialized topic and may be skipped if you are new to QuTiP. When repeatedly simulating a system where only the time-dependent variables, or initial state change, it is possible to reuse the Hamiltonian data stored in QuTiP and there by avoid spending time needlessly preparing the Hamiltonian and collapse terms for simulation. To turn on the the reuse features, we must pass a qutip.solver.Options object with the rhs_reuse flag turned on. Instructions on setting flags are found in Setting Options for the Dynamics Solvers. For example, we can do; H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]; args = {'A': 9, 'sig': 5}; output = mcsolve(H, psi0, times, c_ops, [a.dag()*a], args=args); opts = Options(rhs_reuse=True); args = {'A': 10, 'sig': 3}; output = mcsolve(H, psi0, times, c_ops, [a.dag()*a], args=args, options=opts). The second call to qutip.mcsolve does not reorganize the data, and in the case of the string format, does not recompile the Cython code. For the small system here, the savings in computation time is quite small, however, if you need to call the solvers many times for different parameters, this savings will obviously start to add up. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:3795,Energy Efficiency,efficient,efficient,3795,"ing] pairs, where the time-dependent coefficients are represented as strings. The resulting Hamiltonian is then compiled into C code using Cython and executed.; Array Based: The Hamiltonian and/or collapse operators are expressed as a list of [qobj, np.array] pairs. The arrays are 1 dimensional and dtype are complex or float. They must contain one value for each time in the tlist given to the solver. Cubic spline interpolation will be used between the given times.; Hamiltonian function (outdated): The Hamiltonian is itself a Python function with time-dependence. Collapse operators must be time independent using this input format. Given the multiple choices of input style, the first question that arrises is which option to choose?; In short, the function based method (option #1) is the most general,; allowing for essentially arbitrary coefficients expressed via user-defined functions.; However, by automatically compiling your system into C++ code,; the second option (string based) tends to be more efficient and will run faster; [This is also the only format that is supported in the qutip.bloch_redfield.brmesolve solver].; Of course, for small system sizes and evolution times, the difference will be minor.; Although this method does not support all time-dependent coefficients that one can think of,; it does support essentially all problems that one would typically encounter.; Time-dependent coefficients using any of the following functions,; or combinations thereof (including constants) can be compiled directly into C++-code:; 'abs', 'acos', 'acosh', 'arg', 'asin', 'asinh', 'atan', 'atanh', 'conj',; 'cos', 'cosh','exp', 'erf', 'zerf', 'imag', 'log', 'log10', 'norm', 'pi',; 'proj', 'real', 'sin', 'sinh', 'sqrt', 'tan', 'tanh'. In addition, QuTiP supports cubic spline based interpolation functions [Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions].; If you require mathematical functions other than those listed above,; it ",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:5234,Energy Efficiency,efficient,efficient,5234,"ons,; or combinations thereof (including constants) can be compiled directly into C++-code:; 'abs', 'acos', 'acosh', 'arg', 'asin', 'asinh', 'atan', 'atanh', 'conj',; 'cos', 'cosh','exp', 'erf', 'zerf', 'imag', 'log', 'log10', 'norm', 'pi',; 'proj', 'real', 'sin', 'sinh', 'sqrt', 'tan', 'tanh'. In addition, QuTiP supports cubic spline based interpolation functions [Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions].; If you require mathematical functions other than those listed above,; it is possible to call any of the functions in the NumPy library using the prefix np.; before the function name in the string, i.e. 'np.sin(t)' and scipy.special imported as spe.; This includes a wide range of functionality, but comes with a small overhead created by going from C++->Python->C++.; Finally option #4, expressing the Hamiltonian as a Python function,; is the original method for time dependence in QuTiP 1.x.; This method is somewhat less efficient then the previously mentioned ones.; However, in contrast to the other options; this method can be used in implementing time-dependent Hamiltonians that cannot be; expressed as a function of constant operators with time-dependent coefficients.; A collection of examples demonstrating the simulation of time-dependent problems can be found on the tutorials web page. Function Based Time Dependence¶; A very general way to write a time-dependent Hamiltonian or collapse operator is by using Python functions as the time-dependent coefficients. To accomplish this, we need to write a Python function that returns the time-dependent coefficient. Additionally, we need to tell QuTiP that a given Hamiltonian or collapse operator should be associated with a given Python function. To do this, one needs to specify operator-function pairs in list format: [Op, py_coeff], where Op is a given Hamiltonian or collapse operator and py_coeff is the name of the Python function representing the coefficient. Wi",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:30,Integrability,depend,dependent,30,"﻿. Solving Problems with Time-dependent Hamiltonians — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Introduction; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Krylov Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Methods for Writing Time-Dependent Operators; Function Based Time Dependence; String Format Method; Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions; Accesing the state from solver; Reusing Time-Dependent Hamiltonian Data. Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Solving Problems with Time-dependent Hamiltonians. Solving Problems with Time-dependent Hamiltonians¶. Methods for Writing Time-Dependent Operators¶; In the previous examples of quantum evolution,; we assumed that the systems under consideration were described by time-independent Hamiltonians.; However, many systems have explicit time dependence in either the Hamiltonian,; or the collapse operators describing coupling to the en",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:532,Integrability,depend,dependent,532,"﻿. Solving Problems with Time-dependent Hamiltonians — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Introduction; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Krylov Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Methods for Writing Time-Dependent Operators; Function Based Time Dependence; String Format Method; Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions; Accesing the state from solver; Reusing Time-Dependent Hamiltonian Data. Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Solving Problems with Time-dependent Hamiltonians. Solving Problems with Time-dependent Hamiltonians¶. Methods for Writing Time-Dependent Operators¶; In the previous examples of quantum evolution,; we assumed that the systems under consideration were described by time-independent Hamiltonians.; However, many systems have explicit time dependence in either the Hamiltonian,; or the collapse operators describing coupling to the en",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:1597,Integrability,depend,dependent,1597,"s for Writing Time-Dependent Operators; Function Based Time Dependence; String Format Method; Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions; Accesing the state from solver; Reusing Time-Dependent Hamiltonian Data. Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Solving Problems with Time-dependent Hamiltonians. Solving Problems with Time-dependent Hamiltonians¶. Methods for Writing Time-Dependent Operators¶; In the previous examples of quantum evolution,; we assumed that the systems under consideration were described by time-independent Hamiltonians.; However, many systems have explicit time dependence in either the Hamiltonian,; or the collapse operators describing coupling to the environment, and sometimes both components might depend on time.; The time-evolutions solvers; qutip.mesolve, qutip.mcsolve, qutip.sesolve, qutip.bloch_redfield.brmesolve; qutip.stochastic.ssesolve, qutip.stochastic.photocurrent_sesolve, qutip.stochastic.smesolve, and qutip.stochastic.photocurrent_mesolve; are all capable of handling time-dependent Hamiltonians and collapse terms.; There are, in general, three different ways to implement time-dependent problems in QuTiP:. Function based: Hamiltonian / collapse operators expressed using [qobj, func] pairs, wh",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:1648,Integrability,depend,dependent,1648,"t Method; Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions; Accesing the state from solver; Reusing Time-Dependent Hamiltonian Data. Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Solving Problems with Time-dependent Hamiltonians. Solving Problems with Time-dependent Hamiltonians¶. Methods for Writing Time-Dependent Operators¶; In the previous examples of quantum evolution,; we assumed that the systems under consideration were described by time-independent Hamiltonians.; However, many systems have explicit time dependence in either the Hamiltonian,; or the collapse operators describing coupling to the environment, and sometimes both components might depend on time.; The time-evolutions solvers; qutip.mesolve, qutip.mcsolve, qutip.sesolve, qutip.bloch_redfield.brmesolve; qutip.stochastic.ssesolve, qutip.stochastic.photocurrent_sesolve, qutip.stochastic.smesolve, and qutip.stochastic.photocurrent_mesolve; are all capable of handling time-dependent Hamiltonians and collapse terms.; There are, in general, three different ways to implement time-dependent problems in QuTiP:. Function based: Hamiltonian / collapse operators expressed using [qobj, func] pairs, where the time-dependent coefficients of the Hamiltonian (or collapse operators) are ",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:1907,Integrability,depend,dependence,1907,"ations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Solving Problems with Time-dependent Hamiltonians. Solving Problems with Time-dependent Hamiltonians¶. Methods for Writing Time-Dependent Operators¶; In the previous examples of quantum evolution,; we assumed that the systems under consideration were described by time-independent Hamiltonians.; However, many systems have explicit time dependence in either the Hamiltonian,; or the collapse operators describing coupling to the environment, and sometimes both components might depend on time.; The time-evolutions solvers; qutip.mesolve, qutip.mcsolve, qutip.sesolve, qutip.bloch_redfield.brmesolve; qutip.stochastic.ssesolve, qutip.stochastic.photocurrent_sesolve, qutip.stochastic.smesolve, and qutip.stochastic.photocurrent_mesolve; are all capable of handling time-dependent Hamiltonians and collapse terms.; There are, in general, three different ways to implement time-dependent problems in QuTiP:. Function based: Hamiltonian / collapse operators expressed using [qobj, func] pairs, where the time-dependent coefficients of the Hamiltonian (or collapse operators) are expressed using Python functions.; String (Cython) based: The Hamiltonian and/or collapse operators are expressed as a list of [qobj, string] pairs, where the time-dependent coefficients are represented as strings. The resulting Hamiltonian is then compiled into C code using Cython and executed.; Array Based: The Ham",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:2048,Integrability,depend,depend,2048,"ations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Solving Problems with Time-dependent Hamiltonians. Solving Problems with Time-dependent Hamiltonians¶. Methods for Writing Time-Dependent Operators¶; In the previous examples of quantum evolution,; we assumed that the systems under consideration were described by time-independent Hamiltonians.; However, many systems have explicit time dependence in either the Hamiltonian,; or the collapse operators describing coupling to the environment, and sometimes both components might depend on time.; The time-evolutions solvers; qutip.mesolve, qutip.mcsolve, qutip.sesolve, qutip.bloch_redfield.brmesolve; qutip.stochastic.ssesolve, qutip.stochastic.photocurrent_sesolve, qutip.stochastic.smesolve, and qutip.stochastic.photocurrent_mesolve; are all capable of handling time-dependent Hamiltonians and collapse terms.; There are, in general, three different ways to implement time-dependent problems in QuTiP:. Function based: Hamiltonian / collapse operators expressed using [qobj, func] pairs, where the time-dependent coefficients of the Hamiltonian (or collapse operators) are expressed using Python functions.; String (Cython) based: The Hamiltonian and/or collapse operators are expressed as a list of [qobj, string] pairs, where the time-dependent coefficients are represented as strings. The resulting Hamiltonian is then compiled into C code using Cython and executed.; Array Based: The Ham",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:2340,Integrability,depend,dependent,2340," of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Solving Problems with Time-dependent Hamiltonians. Solving Problems with Time-dependent Hamiltonians¶. Methods for Writing Time-Dependent Operators¶; In the previous examples of quantum evolution,; we assumed that the systems under consideration were described by time-independent Hamiltonians.; However, many systems have explicit time dependence in either the Hamiltonian,; or the collapse operators describing coupling to the environment, and sometimes both components might depend on time.; The time-evolutions solvers; qutip.mesolve, qutip.mcsolve, qutip.sesolve, qutip.bloch_redfield.brmesolve; qutip.stochastic.ssesolve, qutip.stochastic.photocurrent_sesolve, qutip.stochastic.smesolve, and qutip.stochastic.photocurrent_mesolve; are all capable of handling time-dependent Hamiltonians and collapse terms.; There are, in general, three different ways to implement time-dependent problems in QuTiP:. Function based: Hamiltonian / collapse operators expressed using [qobj, func] pairs, where the time-dependent coefficients of the Hamiltonian (or collapse operators) are expressed using Python functions.; String (Cython) based: The Hamiltonian and/or collapse operators are expressed as a list of [qobj, string] pairs, where the time-dependent coefficients are represented as strings. The resulting Hamiltonian is then compiled into C code using Cython and executed.; Array Based: The Hamiltonian and/or collapse operators are expressed as a list of [qobj, np.array] pairs. The arrays are 1 dimensional and dtype are complex or float. They must contain one value for each time in the tlist given to the solver. Cubic spline interpolation will be used between the given times.; Hamiltonian function (outdated): The Hamiltonian is itself a Python function with",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:2446,Integrability,depend,dependent,2446,"ion; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Solving Problems with Time-dependent Hamiltonians. Solving Problems with Time-dependent Hamiltonians¶. Methods for Writing Time-Dependent Operators¶; In the previous examples of quantum evolution,; we assumed that the systems under consideration were described by time-independent Hamiltonians.; However, many systems have explicit time dependence in either the Hamiltonian,; or the collapse operators describing coupling to the environment, and sometimes both components might depend on time.; The time-evolutions solvers; qutip.mesolve, qutip.mcsolve, qutip.sesolve, qutip.bloch_redfield.brmesolve; qutip.stochastic.ssesolve, qutip.stochastic.photocurrent_sesolve, qutip.stochastic.smesolve, and qutip.stochastic.photocurrent_mesolve; are all capable of handling time-dependent Hamiltonians and collapse terms.; There are, in general, three different ways to implement time-dependent problems in QuTiP:. Function based: Hamiltonian / collapse operators expressed using [qobj, func] pairs, where the time-dependent coefficients of the Hamiltonian (or collapse operators) are expressed using Python functions.; String (Cython) based: The Hamiltonian and/or collapse operators are expressed as a list of [qobj, string] pairs, where the time-dependent coefficients are represented as strings. The resulting Hamiltonian is then compiled into C code using Cython and executed.; Array Based: The Hamiltonian and/or collapse operators are expressed as a list of [qobj, np.array] pairs. The arrays are 1 dimensional and dtype are complex or float. They must contain one value for each time in the tlist given to the solver. Cubic spline interpolation will be used between the given times.; Hamiltonian function (outdated): The Hamiltonian is itself a Python function with time-dependence. Collapse operators must be time independent using this input format. Given th",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:2576,Integrability,depend,dependent,2576," Problems with Time-dependent Hamiltonians. Solving Problems with Time-dependent Hamiltonians¶. Methods for Writing Time-Dependent Operators¶; In the previous examples of quantum evolution,; we assumed that the systems under consideration were described by time-independent Hamiltonians.; However, many systems have explicit time dependence in either the Hamiltonian,; or the collapse operators describing coupling to the environment, and sometimes both components might depend on time.; The time-evolutions solvers; qutip.mesolve, qutip.mcsolve, qutip.sesolve, qutip.bloch_redfield.brmesolve; qutip.stochastic.ssesolve, qutip.stochastic.photocurrent_sesolve, qutip.stochastic.smesolve, and qutip.stochastic.photocurrent_mesolve; are all capable of handling time-dependent Hamiltonians and collapse terms.; There are, in general, three different ways to implement time-dependent problems in QuTiP:. Function based: Hamiltonian / collapse operators expressed using [qobj, func] pairs, where the time-dependent coefficients of the Hamiltonian (or collapse operators) are expressed using Python functions.; String (Cython) based: The Hamiltonian and/or collapse operators are expressed as a list of [qobj, string] pairs, where the time-dependent coefficients are represented as strings. The resulting Hamiltonian is then compiled into C code using Cython and executed.; Array Based: The Hamiltonian and/or collapse operators are expressed as a list of [qobj, np.array] pairs. The arrays are 1 dimensional and dtype are complex or float. They must contain one value for each time in the tlist given to the solver. Cubic spline interpolation will be used between the given times.; Hamiltonian function (outdated): The Hamiltonian is itself a Python function with time-dependence. Collapse operators must be time independent using this input format. Given the multiple choices of input style, the first question that arrises is which option to choose?; In short, the function based method (option #1) is th",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:2810,Integrability,depend,dependent,2810,"e assumed that the systems under consideration were described by time-independent Hamiltonians.; However, many systems have explicit time dependence in either the Hamiltonian,; or the collapse operators describing coupling to the environment, and sometimes both components might depend on time.; The time-evolutions solvers; qutip.mesolve, qutip.mcsolve, qutip.sesolve, qutip.bloch_redfield.brmesolve; qutip.stochastic.ssesolve, qutip.stochastic.photocurrent_sesolve, qutip.stochastic.smesolve, and qutip.stochastic.photocurrent_mesolve; are all capable of handling time-dependent Hamiltonians and collapse terms.; There are, in general, three different ways to implement time-dependent problems in QuTiP:. Function based: Hamiltonian / collapse operators expressed using [qobj, func] pairs, where the time-dependent coefficients of the Hamiltonian (or collapse operators) are expressed using Python functions.; String (Cython) based: The Hamiltonian and/or collapse operators are expressed as a list of [qobj, string] pairs, where the time-dependent coefficients are represented as strings. The resulting Hamiltonian is then compiled into C code using Cython and executed.; Array Based: The Hamiltonian and/or collapse operators are expressed as a list of [qobj, np.array] pairs. The arrays are 1 dimensional and dtype are complex or float. They must contain one value for each time in the tlist given to the solver. Cubic spline interpolation will be used between the given times.; Hamiltonian function (outdated): The Hamiltonian is itself a Python function with time-dependence. Collapse operators must be time independent using this input format. Given the multiple choices of input style, the first question that arrises is which option to choose?; In short, the function based method (option #1) is the most general,; allowing for essentially arbitrary coefficients expressed via user-defined functions.; However, by automatically compiling your system into C++ code,; the second option (string",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:3340,Integrability,depend,dependence,3340,"olve; are all capable of handling time-dependent Hamiltonians and collapse terms.; There are, in general, three different ways to implement time-dependent problems in QuTiP:. Function based: Hamiltonian / collapse operators expressed using [qobj, func] pairs, where the time-dependent coefficients of the Hamiltonian (or collapse operators) are expressed using Python functions.; String (Cython) based: The Hamiltonian and/or collapse operators are expressed as a list of [qobj, string] pairs, where the time-dependent coefficients are represented as strings. The resulting Hamiltonian is then compiled into C code using Cython and executed.; Array Based: The Hamiltonian and/or collapse operators are expressed as a list of [qobj, np.array] pairs. The arrays are 1 dimensional and dtype are complex or float. They must contain one value for each time in the tlist given to the solver. Cubic spline interpolation will be used between the given times.; Hamiltonian function (outdated): The Hamiltonian is itself a Python function with time-dependence. Collapse operators must be time independent using this input format. Given the multiple choices of input style, the first question that arrises is which option to choose?; In short, the function based method (option #1) is the most general,; allowing for essentially arbitrary coefficients expressed via user-defined functions.; However, by automatically compiling your system into C++ code,; the second option (string based) tends to be more efficient and will run faster; [This is also the only format that is supported in the qutip.bloch_redfield.brmesolve solver].; Of course, for small system sizes and evolution times, the difference will be minor.; Although this method does not support all time-dependent coefficients that one can think of,; it does support essentially all problems that one would typically encounter.; Time-dependent coefficients using any of the following functions,; or combinations thereof (including constants) can be c",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:4055,Integrability,depend,dependent,4055," complex or float. They must contain one value for each time in the tlist given to the solver. Cubic spline interpolation will be used between the given times.; Hamiltonian function (outdated): The Hamiltonian is itself a Python function with time-dependence. Collapse operators must be time independent using this input format. Given the multiple choices of input style, the first question that arrises is which option to choose?; In short, the function based method (option #1) is the most general,; allowing for essentially arbitrary coefficients expressed via user-defined functions.; However, by automatically compiling your system into C++ code,; the second option (string based) tends to be more efficient and will run faster; [This is also the only format that is supported in the qutip.bloch_redfield.brmesolve solver].; Of course, for small system sizes and evolution times, the difference will be minor.; Although this method does not support all time-dependent coefficients that one can think of,; it does support essentially all problems that one would typically encounter.; Time-dependent coefficients using any of the following functions,; or combinations thereof (including constants) can be compiled directly into C++-code:; 'abs', 'acos', 'acosh', 'arg', 'asin', 'asinh', 'atan', 'atanh', 'conj',; 'cos', 'cosh','exp', 'erf', 'zerf', 'imag', 'log', 'log10', 'norm', 'pi',; 'proj', 'real', 'sin', 'sinh', 'sqrt', 'tan', 'tanh'. In addition, QuTiP supports cubic spline based interpolation functions [Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions].; If you require mathematical functions other than those listed above,; it is possible to call any of the functions in the NumPy library using the prefix np.; before the function name in the string, i.e. 'np.sin(t)' and scipy.special imported as spe.; This includes a wide range of functionality, but comes with a small overhead created by going from C++->Python->C++.; Finally option",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:4185,Integrability,depend,dependent,4185,"pse operators must be time independent using this input format. Given the multiple choices of input style, the first question that arrises is which option to choose?; In short, the function based method (option #1) is the most general,; allowing for essentially arbitrary coefficients expressed via user-defined functions.; However, by automatically compiling your system into C++ code,; the second option (string based) tends to be more efficient and will run faster; [This is also the only format that is supported in the qutip.bloch_redfield.brmesolve solver].; Of course, for small system sizes and evolution times, the difference will be minor.; Although this method does not support all time-dependent coefficients that one can think of,; it does support essentially all problems that one would typically encounter.; Time-dependent coefficients using any of the following functions,; or combinations thereof (including constants) can be compiled directly into C++-code:; 'abs', 'acos', 'acosh', 'arg', 'asin', 'asinh', 'atan', 'atanh', 'conj',; 'cos', 'cosh','exp', 'erf', 'zerf', 'imag', 'log', 'log10', 'norm', 'pi',; 'proj', 'real', 'sin', 'sinh', 'sqrt', 'tan', 'tanh'. In addition, QuTiP supports cubic spline based interpolation functions [Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions].; If you require mathematical functions other than those listed above,; it is possible to call any of the functions in the NumPy library using the prefix np.; before the function name in the string, i.e. 'np.sin(t)' and scipy.special imported as spe.; This includes a wide range of functionality, but comes with a small overhead created by going from C++->Python->C++.; Finally option #4, expressing the Hamiltonian as a Python function,; is the original method for time dependence in QuTiP 1.x.; This method is somewhat less efficient then the previously mentioned ones.; However, in contrast to the other options; this method can be used in implem",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:5179,Integrability,depend,dependence,5179,"lems that one would typically encounter.; Time-dependent coefficients using any of the following functions,; or combinations thereof (including constants) can be compiled directly into C++-code:; 'abs', 'acos', 'acosh', 'arg', 'asin', 'asinh', 'atan', 'atanh', 'conj',; 'cos', 'cosh','exp', 'erf', 'zerf', 'imag', 'log', 'log10', 'norm', 'pi',; 'proj', 'real', 'sin', 'sinh', 'sqrt', 'tan', 'tanh'. In addition, QuTiP supports cubic spline based interpolation functions [Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions].; If you require mathematical functions other than those listed above,; it is possible to call any of the functions in the NumPy library using the prefix np.; before the function name in the string, i.e. 'np.sin(t)' and scipy.special imported as spe.; This includes a wide range of functionality, but comes with a small overhead created by going from C++->Python->C++.; Finally option #4, expressing the Hamiltonian as a Python function,; is the original method for time dependence in QuTiP 1.x.; This method is somewhat less efficient then the previously mentioned ones.; However, in contrast to the other options; this method can be used in implementing time-dependent Hamiltonians that cannot be; expressed as a function of constant operators with time-dependent coefficients.; A collection of examples demonstrating the simulation of time-dependent problems can be found on the tutorials web page. Function Based Time Dependence¶; A very general way to write a time-dependent Hamiltonian or collapse operator is by using Python functions as the time-dependent coefficients. To accomplish this, we need to write a Python function that returns the time-dependent coefficient. Additionally, we need to tell QuTiP that a given Hamiltonian or collapse operator should be associated with a given Python function. To do this, one needs to specify operator-function pairs in list format: [Op, py_coeff], where Op is a given Hamiltonian",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:5369,Integrability,depend,dependent,5369,"atan', 'atanh', 'conj',; 'cos', 'cosh','exp', 'erf', 'zerf', 'imag', 'log', 'log10', 'norm', 'pi',; 'proj', 'real', 'sin', 'sinh', 'sqrt', 'tan', 'tanh'. In addition, QuTiP supports cubic spline based interpolation functions [Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions].; If you require mathematical functions other than those listed above,; it is possible to call any of the functions in the NumPy library using the prefix np.; before the function name in the string, i.e. 'np.sin(t)' and scipy.special imported as spe.; This includes a wide range of functionality, but comes with a small overhead created by going from C++->Python->C++.; Finally option #4, expressing the Hamiltonian as a Python function,; is the original method for time dependence in QuTiP 1.x.; This method is somewhat less efficient then the previously mentioned ones.; However, in contrast to the other options; this method can be used in implementing time-dependent Hamiltonians that cannot be; expressed as a function of constant operators with time-dependent coefficients.; A collection of examples demonstrating the simulation of time-dependent problems can be found on the tutorials web page. Function Based Time Dependence¶; A very general way to write a time-dependent Hamiltonian or collapse operator is by using Python functions as the time-dependent coefficients. To accomplish this, we need to write a Python function that returns the time-dependent coefficient. Additionally, we need to tell QuTiP that a given Hamiltonian or collapse operator should be associated with a given Python function. To do this, one needs to specify operator-function pairs in list format: [Op, py_coeff], where Op is a given Hamiltonian or collapse operator and py_coeff is the name of the Python function representing the coefficient. With this format, the form of the Hamiltonian for both mesolve and mcsolve is:; >>> H = [H0, [H1, py_coeff1], [H2, py_coeff2], ...] . where H0 i",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:5464,Integrability,depend,dependent,5464,"atan', 'atanh', 'conj',; 'cos', 'cosh','exp', 'erf', 'zerf', 'imag', 'log', 'log10', 'norm', 'pi',; 'proj', 'real', 'sin', 'sinh', 'sqrt', 'tan', 'tanh'. In addition, QuTiP supports cubic spline based interpolation functions [Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions].; If you require mathematical functions other than those listed above,; it is possible to call any of the functions in the NumPy library using the prefix np.; before the function name in the string, i.e. 'np.sin(t)' and scipy.special imported as spe.; This includes a wide range of functionality, but comes with a small overhead created by going from C++->Python->C++.; Finally option #4, expressing the Hamiltonian as a Python function,; is the original method for time dependence in QuTiP 1.x.; This method is somewhat less efficient then the previously mentioned ones.; However, in contrast to the other options; this method can be used in implementing time-dependent Hamiltonians that cannot be; expressed as a function of constant operators with time-dependent coefficients.; A collection of examples demonstrating the simulation of time-dependent problems can be found on the tutorials web page. Function Based Time Dependence¶; A very general way to write a time-dependent Hamiltonian or collapse operator is by using Python functions as the time-dependent coefficients. To accomplish this, we need to write a Python function that returns the time-dependent coefficient. Additionally, we need to tell QuTiP that a given Hamiltonian or collapse operator should be associated with a given Python function. To do this, one needs to specify operator-function pairs in list format: [Op, py_coeff], where Op is a given Hamiltonian or collapse operator and py_coeff is the name of the Python function representing the coefficient. With this format, the form of the Hamiltonian for both mesolve and mcsolve is:; >>> H = [H0, [H1, py_coeff1], [H2, py_coeff2], ...] . where H0 i",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:5551,Integrability,depend,dependent,5551,", QuTiP supports cubic spline based interpolation functions [Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions].; If you require mathematical functions other than those listed above,; it is possible to call any of the functions in the NumPy library using the prefix np.; before the function name in the string, i.e. 'np.sin(t)' and scipy.special imported as spe.; This includes a wide range of functionality, but comes with a small overhead created by going from C++->Python->C++.; Finally option #4, expressing the Hamiltonian as a Python function,; is the original method for time dependence in QuTiP 1.x.; This method is somewhat less efficient then the previously mentioned ones.; However, in contrast to the other options; this method can be used in implementing time-dependent Hamiltonians that cannot be; expressed as a function of constant operators with time-dependent coefficients.; A collection of examples demonstrating the simulation of time-dependent problems can be found on the tutorials web page. Function Based Time Dependence¶; A very general way to write a time-dependent Hamiltonian or collapse operator is by using Python functions as the time-dependent coefficients. To accomplish this, we need to write a Python function that returns the time-dependent coefficient. Additionally, we need to tell QuTiP that a given Hamiltonian or collapse operator should be associated with a given Python function. To do this, one needs to specify operator-function pairs in list format: [Op, py_coeff], where Op is a given Hamiltonian or collapse operator and py_coeff is the name of the Python function representing the coefficient. With this format, the form of the Hamiltonian for both mesolve and mcsolve is:; >>> H = [H0, [H1, py_coeff1], [H2, py_coeff2], ...] . where H0 is a time-independent Hamiltonian, while H1 and H2 are time-dependent. The same format can be used for collapse operators:; >>> c_ops = [[C0, py_coeff0], C1, [C2, py_",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:5678,Integrability,depend,dependent,5678,"Functions].; If you require mathematical functions other than those listed above,; it is possible to call any of the functions in the NumPy library using the prefix np.; before the function name in the string, i.e. 'np.sin(t)' and scipy.special imported as spe.; This includes a wide range of functionality, but comes with a small overhead created by going from C++->Python->C++.; Finally option #4, expressing the Hamiltonian as a Python function,; is the original method for time dependence in QuTiP 1.x.; This method is somewhat less efficient then the previously mentioned ones.; However, in contrast to the other options; this method can be used in implementing time-dependent Hamiltonians that cannot be; expressed as a function of constant operators with time-dependent coefficients.; A collection of examples demonstrating the simulation of time-dependent problems can be found on the tutorials web page. Function Based Time Dependence¶; A very general way to write a time-dependent Hamiltonian or collapse operator is by using Python functions as the time-dependent coefficients. To accomplish this, we need to write a Python function that returns the time-dependent coefficient. Additionally, we need to tell QuTiP that a given Hamiltonian or collapse operator should be associated with a given Python function. To do this, one needs to specify operator-function pairs in list format: [Op, py_coeff], where Op is a given Hamiltonian or collapse operator and py_coeff is the name of the Python function representing the coefficient. With this format, the form of the Hamiltonian for both mesolve and mcsolve is:; >>> H = [H0, [H1, py_coeff1], [H2, py_coeff2], ...] . where H0 is a time-independent Hamiltonian, while H1 and H2 are time-dependent. The same format can be used for collapse operators:; >>> c_ops = [[C0, py_coeff0], C1, [C2, py_coeff2], ...] . Here we have demonstrated that the ordering of time-dependent and time-independent terms does not matter. In addition, any or all of ",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:5762,Integrability,depend,dependent,5762,"Functions].; If you require mathematical functions other than those listed above,; it is possible to call any of the functions in the NumPy library using the prefix np.; before the function name in the string, i.e. 'np.sin(t)' and scipy.special imported as spe.; This includes a wide range of functionality, but comes with a small overhead created by going from C++->Python->C++.; Finally option #4, expressing the Hamiltonian as a Python function,; is the original method for time dependence in QuTiP 1.x.; This method is somewhat less efficient then the previously mentioned ones.; However, in contrast to the other options; this method can be used in implementing time-dependent Hamiltonians that cannot be; expressed as a function of constant operators with time-dependent coefficients.; A collection of examples demonstrating the simulation of time-dependent problems can be found on the tutorials web page. Function Based Time Dependence¶; A very general way to write a time-dependent Hamiltonian or collapse operator is by using Python functions as the time-dependent coefficients. To accomplish this, we need to write a Python function that returns the time-dependent coefficient. Additionally, we need to tell QuTiP that a given Hamiltonian or collapse operator should be associated with a given Python function. To do this, one needs to specify operator-function pairs in list format: [Op, py_coeff], where Op is a given Hamiltonian or collapse operator and py_coeff is the name of the Python function representing the coefficient. With this format, the form of the Hamiltonian for both mesolve and mcsolve is:; >>> H = [H0, [H1, py_coeff1], [H2, py_coeff2], ...] . where H0 is a time-independent Hamiltonian, while H1 and H2 are time-dependent. The same format can be used for collapse operators:; >>> c_ops = [[C0, py_coeff0], C1, [C2, py_coeff2], ...] . Here we have demonstrated that the ordering of time-dependent and time-independent terms does not matter. In addition, any or all of ",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:5863,Integrability,depend,dependent,5863,"y library using the prefix np.; before the function name in the string, i.e. 'np.sin(t)' and scipy.special imported as spe.; This includes a wide range of functionality, but comes with a small overhead created by going from C++->Python->C++.; Finally option #4, expressing the Hamiltonian as a Python function,; is the original method for time dependence in QuTiP 1.x.; This method is somewhat less efficient then the previously mentioned ones.; However, in contrast to the other options; this method can be used in implementing time-dependent Hamiltonians that cannot be; expressed as a function of constant operators with time-dependent coefficients.; A collection of examples demonstrating the simulation of time-dependent problems can be found on the tutorials web page. Function Based Time Dependence¶; A very general way to write a time-dependent Hamiltonian or collapse operator is by using Python functions as the time-dependent coefficients. To accomplish this, we need to write a Python function that returns the time-dependent coefficient. Additionally, we need to tell QuTiP that a given Hamiltonian or collapse operator should be associated with a given Python function. To do this, one needs to specify operator-function pairs in list format: [Op, py_coeff], where Op is a given Hamiltonian or collapse operator and py_coeff is the name of the Python function representing the coefficient. With this format, the form of the Hamiltonian for both mesolve and mcsolve is:; >>> H = [H0, [H1, py_coeff1], [H2, py_coeff2], ...] . where H0 is a time-independent Hamiltonian, while H1 and H2 are time-dependent. The same format can be used for collapse operators:; >>> c_ops = [[C0, py_coeff0], C1, [C2, py_coeff2], ...] . Here we have demonstrated that the ordering of time-dependent and time-independent terms does not matter. In addition, any or all of the collapse operators may be time-dependent. Note; While, in general, you can arrange time-dependent and time-independent terms in any or",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:6442,Integrability,depend,dependent,6442,"essed as a function of constant operators with time-dependent coefficients.; A collection of examples demonstrating the simulation of time-dependent problems can be found on the tutorials web page. Function Based Time Dependence¶; A very general way to write a time-dependent Hamiltonian or collapse operator is by using Python functions as the time-dependent coefficients. To accomplish this, we need to write a Python function that returns the time-dependent coefficient. Additionally, we need to tell QuTiP that a given Hamiltonian or collapse operator should be associated with a given Python function. To do this, one needs to specify operator-function pairs in list format: [Op, py_coeff], where Op is a given Hamiltonian or collapse operator and py_coeff is the name of the Python function representing the coefficient. With this format, the form of the Hamiltonian for both mesolve and mcsolve is:; >>> H = [H0, [H1, py_coeff1], [H2, py_coeff2], ...] . where H0 is a time-independent Hamiltonian, while H1 and H2 are time-dependent. The same format can be used for collapse operators:; >>> c_ops = [[C0, py_coeff0], C1, [C2, py_coeff2], ...] . Here we have demonstrated that the ordering of time-dependent and time-independent terms does not matter. In addition, any or all of the collapse operators may be time-dependent. Note; While, in general, you can arrange time-dependent and time-independent terms in any order you like, it is best to place all time-independent terms first. As an example, we will look at an example that has a time-dependent Hamiltonian of the form \(H=H_{0}-f(t)H_{1}\) where \(f(t)\) is the time-dependent driving strength given as \(f(t)=A\exp\left[-\left( t/\sigma \right)^{2}\right]\). The following code sets up the problem; ustate = basis(3, 0); excited = basis(3, 1); ground = basis(3, 2). N = 2 # Set where to truncate Fock state for cavity; sigma_ge = tensor(qeye(N), ground * excited.dag()) # |g><e|; sigma_ue = tensor(qeye(N), ustate * excited.dag()) # |",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:6616,Integrability,depend,dependent,6616,"on Based Time Dependence¶; A very general way to write a time-dependent Hamiltonian or collapse operator is by using Python functions as the time-dependent coefficients. To accomplish this, we need to write a Python function that returns the time-dependent coefficient. Additionally, we need to tell QuTiP that a given Hamiltonian or collapse operator should be associated with a given Python function. To do this, one needs to specify operator-function pairs in list format: [Op, py_coeff], where Op is a given Hamiltonian or collapse operator and py_coeff is the name of the Python function representing the coefficient. With this format, the form of the Hamiltonian for both mesolve and mcsolve is:; >>> H = [H0, [H1, py_coeff1], [H2, py_coeff2], ...] . where H0 is a time-independent Hamiltonian, while H1 and H2 are time-dependent. The same format can be used for collapse operators:; >>> c_ops = [[C0, py_coeff0], C1, [C2, py_coeff2], ...] . Here we have demonstrated that the ordering of time-dependent and time-independent terms does not matter. In addition, any or all of the collapse operators may be time-dependent. Note; While, in general, you can arrange time-dependent and time-independent terms in any order you like, it is best to place all time-independent terms first. As an example, we will look at an example that has a time-dependent Hamiltonian of the form \(H=H_{0}-f(t)H_{1}\) where \(f(t)\) is the time-dependent driving strength given as \(f(t)=A\exp\left[-\left( t/\sigma \right)^{2}\right]\). The following code sets up the problem; ustate = basis(3, 0); excited = basis(3, 1); ground = basis(3, 2). N = 2 # Set where to truncate Fock state for cavity; sigma_ge = tensor(qeye(N), ground * excited.dag()) # |g><e|; sigma_ue = tensor(qeye(N), ustate * excited.dag()) # |u><e|; a = tensor(destroy(N), qeye(3)); ada = tensor(num(N), qeye(3)). c_ops = [] # Build collapse operators; kappa = 1.5 # Cavity decay rate; c_ops.append(np.sqrt(kappa) * a); gamma = 6 # Atomic decay ra",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:6732,Integrability,depend,dependent,6732,"llapse operator is by using Python functions as the time-dependent coefficients. To accomplish this, we need to write a Python function that returns the time-dependent coefficient. Additionally, we need to tell QuTiP that a given Hamiltonian or collapse operator should be associated with a given Python function. To do this, one needs to specify operator-function pairs in list format: [Op, py_coeff], where Op is a given Hamiltonian or collapse operator and py_coeff is the name of the Python function representing the coefficient. With this format, the form of the Hamiltonian for both mesolve and mcsolve is:; >>> H = [H0, [H1, py_coeff1], [H2, py_coeff2], ...] . where H0 is a time-independent Hamiltonian, while H1 and H2 are time-dependent. The same format can be used for collapse operators:; >>> c_ops = [[C0, py_coeff0], C1, [C2, py_coeff2], ...] . Here we have demonstrated that the ordering of time-dependent and time-independent terms does not matter. In addition, any or all of the collapse operators may be time-dependent. Note; While, in general, you can arrange time-dependent and time-independent terms in any order you like, it is best to place all time-independent terms first. As an example, we will look at an example that has a time-dependent Hamiltonian of the form \(H=H_{0}-f(t)H_{1}\) where \(f(t)\) is the time-dependent driving strength given as \(f(t)=A\exp\left[-\left( t/\sigma \right)^{2}\right]\). The following code sets up the problem; ustate = basis(3, 0); excited = basis(3, 1); ground = basis(3, 2). N = 2 # Set where to truncate Fock state for cavity; sigma_ge = tensor(qeye(N), ground * excited.dag()) # |g><e|; sigma_ue = tensor(qeye(N), ustate * excited.dag()) # |u><e|; a = tensor(destroy(N), qeye(3)); ada = tensor(num(N), qeye(3)). c_ops = [] # Build collapse operators; kappa = 1.5 # Cavity decay rate; c_ops.append(np.sqrt(kappa) * a); gamma = 6 # Atomic decay rate; c_ops.append(np.sqrt(5*gamma/9) * sigma_ue) # Use Rb branching ratio of 5/9 e->u; c_op",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:6789,Integrability,depend,dependent,6789," a Python function that returns the time-dependent coefficient. Additionally, we need to tell QuTiP that a given Hamiltonian or collapse operator should be associated with a given Python function. To do this, one needs to specify operator-function pairs in list format: [Op, py_coeff], where Op is a given Hamiltonian or collapse operator and py_coeff is the name of the Python function representing the coefficient. With this format, the form of the Hamiltonian for both mesolve and mcsolve is:; >>> H = [H0, [H1, py_coeff1], [H2, py_coeff2], ...] . where H0 is a time-independent Hamiltonian, while H1 and H2 are time-dependent. The same format can be used for collapse operators:; >>> c_ops = [[C0, py_coeff0], C1, [C2, py_coeff2], ...] . Here we have demonstrated that the ordering of time-dependent and time-independent terms does not matter. In addition, any or all of the collapse operators may be time-dependent. Note; While, in general, you can arrange time-dependent and time-independent terms in any order you like, it is best to place all time-independent terms first. As an example, we will look at an example that has a time-dependent Hamiltonian of the form \(H=H_{0}-f(t)H_{1}\) where \(f(t)\) is the time-dependent driving strength given as \(f(t)=A\exp\left[-\left( t/\sigma \right)^{2}\right]\). The following code sets up the problem; ustate = basis(3, 0); excited = basis(3, 1); ground = basis(3, 2). N = 2 # Set where to truncate Fock state for cavity; sigma_ge = tensor(qeye(N), ground * excited.dag()) # |g><e|; sigma_ue = tensor(qeye(N), ustate * excited.dag()) # |u><e|; a = tensor(destroy(N), qeye(3)); ada = tensor(num(N), qeye(3)). c_ops = [] # Build collapse operators; kappa = 1.5 # Cavity decay rate; c_ops.append(np.sqrt(kappa) * a); gamma = 6 # Atomic decay rate; c_ops.append(np.sqrt(5*gamma/9) * sigma_ue) # Use Rb branching ratio of 5/9 e->u; c_ops.append(np.sqrt(4*gamma/9) * sigma_ge) # 4/9 e->g. t = np.linspace(-15, 15, 100) # Define time vector; psi0 = tenso",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:6961,Integrability,depend,dependent,6961,"To do this, one needs to specify operator-function pairs in list format: [Op, py_coeff], where Op is a given Hamiltonian or collapse operator and py_coeff is the name of the Python function representing the coefficient. With this format, the form of the Hamiltonian for both mesolve and mcsolve is:; >>> H = [H0, [H1, py_coeff1], [H2, py_coeff2], ...] . where H0 is a time-independent Hamiltonian, while H1 and H2 are time-dependent. The same format can be used for collapse operators:; >>> c_ops = [[C0, py_coeff0], C1, [C2, py_coeff2], ...] . Here we have demonstrated that the ordering of time-dependent and time-independent terms does not matter. In addition, any or all of the collapse operators may be time-dependent. Note; While, in general, you can arrange time-dependent and time-independent terms in any order you like, it is best to place all time-independent terms first. As an example, we will look at an example that has a time-dependent Hamiltonian of the form \(H=H_{0}-f(t)H_{1}\) where \(f(t)\) is the time-dependent driving strength given as \(f(t)=A\exp\left[-\left( t/\sigma \right)^{2}\right]\). The following code sets up the problem; ustate = basis(3, 0); excited = basis(3, 1); ground = basis(3, 2). N = 2 # Set where to truncate Fock state for cavity; sigma_ge = tensor(qeye(N), ground * excited.dag()) # |g><e|; sigma_ue = tensor(qeye(N), ustate * excited.dag()) # |u><e|; a = tensor(destroy(N), qeye(3)); ada = tensor(num(N), qeye(3)). c_ops = [] # Build collapse operators; kappa = 1.5 # Cavity decay rate; c_ops.append(np.sqrt(kappa) * a); gamma = 6 # Atomic decay rate; c_ops.append(np.sqrt(5*gamma/9) * sigma_ue) # Use Rb branching ratio of 5/9 e->u; c_ops.append(np.sqrt(4*gamma/9) * sigma_ge) # 4/9 e->g. t = np.linspace(-15, 15, 100) # Define time vector; psi0 = tensor(basis(N, 0), ustate) # Define initial state. state_GG = tensor(basis(N, 1), ground) # Define states onto which to project; sigma_GG = state_GG * state_GG.dag(); state_UU = tensor(basis(N, 0), ust",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:7044,Integrability,depend,dependent,7044,"To do this, one needs to specify operator-function pairs in list format: [Op, py_coeff], where Op is a given Hamiltonian or collapse operator and py_coeff is the name of the Python function representing the coefficient. With this format, the form of the Hamiltonian for both mesolve and mcsolve is:; >>> H = [H0, [H1, py_coeff1], [H2, py_coeff2], ...] . where H0 is a time-independent Hamiltonian, while H1 and H2 are time-dependent. The same format can be used for collapse operators:; >>> c_ops = [[C0, py_coeff0], C1, [C2, py_coeff2], ...] . Here we have demonstrated that the ordering of time-dependent and time-independent terms does not matter. In addition, any or all of the collapse operators may be time-dependent. Note; While, in general, you can arrange time-dependent and time-independent terms in any order you like, it is best to place all time-independent terms first. As an example, we will look at an example that has a time-dependent Hamiltonian of the form \(H=H_{0}-f(t)H_{1}\) where \(f(t)\) is the time-dependent driving strength given as \(f(t)=A\exp\left[-\left( t/\sigma \right)^{2}\right]\). The following code sets up the problem; ustate = basis(3, 0); excited = basis(3, 1); ground = basis(3, 2). N = 2 # Set where to truncate Fock state for cavity; sigma_ge = tensor(qeye(N), ground * excited.dag()) # |g><e|; sigma_ue = tensor(qeye(N), ustate * excited.dag()) # |u><e|; a = tensor(destroy(N), qeye(3)); ada = tensor(num(N), qeye(3)). c_ops = [] # Build collapse operators; kappa = 1.5 # Cavity decay rate; c_ops.append(np.sqrt(kappa) * a); gamma = 6 # Atomic decay rate; c_ops.append(np.sqrt(5*gamma/9) * sigma_ue) # Use Rb branching ratio of 5/9 e->u; c_ops.append(np.sqrt(4*gamma/9) * sigma_ge) # 4/9 e->g. t = np.linspace(-15, 15, 100) # Define time vector; psi0 = tensor(basis(N, 0), ustate) # Define initial state. state_GG = tensor(basis(N, 1), ground) # Define states onto which to project; sigma_GG = state_GG * state_GG.dag(); state_UU = tensor(basis(N, 0), ust",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:8207,Integrability,depend,dependent,8207,"ited = basis(3, 1); ground = basis(3, 2). N = 2 # Set where to truncate Fock state for cavity; sigma_ge = tensor(qeye(N), ground * excited.dag()) # |g><e|; sigma_ue = tensor(qeye(N), ustate * excited.dag()) # |u><e|; a = tensor(destroy(N), qeye(3)); ada = tensor(num(N), qeye(3)). c_ops = [] # Build collapse operators; kappa = 1.5 # Cavity decay rate; c_ops.append(np.sqrt(kappa) * a); gamma = 6 # Atomic decay rate; c_ops.append(np.sqrt(5*gamma/9) * sigma_ue) # Use Rb branching ratio of 5/9 e->u; c_ops.append(np.sqrt(4*gamma/9) * sigma_ge) # 4/9 e->g. t = np.linspace(-15, 15, 100) # Define time vector; psi0 = tensor(basis(N, 0), ustate) # Define initial state. state_GG = tensor(basis(N, 1), ground) # Define states onto which to project; sigma_GG = state_GG * state_GG.dag(); state_UU = tensor(basis(N, 0), ustate); sigma_UU = state_UU * state_UU.dag(). g = 5 # coupling strength; H0 = -g * (sigma_ge.dag() * a + a.dag() * sigma_ge) # time-independent term; H1 = (sigma_ue.dag() + sigma_ue) # time-dependent term. Given that we have a single time-dependent Hamiltonian term, and constant collapse terms, we need to specify a single Python function for the coefficient \(f(t)\). In this case, one can simply do; def H1_coeff(t, args):; return 9 * np.exp(-(t / 5.) ** 2). In this case, the return value depends only on time. However, when specifying Python functions for coefficients, the function must have (t,args) as the input variables, in that order. Having specified our coefficient function, we can now specify the Hamiltonian in list format and call the solver (in this case qutip.mesolve); H = [H0,[H1, H1_coeff]]; output = mesolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). We can call the Monte Carlo solver in the exact same way (if using the default ntraj=500):; output = mcsolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). The output from the master equation solver is identical to that shown in the examples, the Monte Carlo however will be noticeably off, suggesting we sh",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:8256,Integrability,depend,dependent,8256,"e = tensor(qeye(N), ground * excited.dag()) # |g><e|; sigma_ue = tensor(qeye(N), ustate * excited.dag()) # |u><e|; a = tensor(destroy(N), qeye(3)); ada = tensor(num(N), qeye(3)). c_ops = [] # Build collapse operators; kappa = 1.5 # Cavity decay rate; c_ops.append(np.sqrt(kappa) * a); gamma = 6 # Atomic decay rate; c_ops.append(np.sqrt(5*gamma/9) * sigma_ue) # Use Rb branching ratio of 5/9 e->u; c_ops.append(np.sqrt(4*gamma/9) * sigma_ge) # 4/9 e->g. t = np.linspace(-15, 15, 100) # Define time vector; psi0 = tensor(basis(N, 0), ustate) # Define initial state. state_GG = tensor(basis(N, 1), ground) # Define states onto which to project; sigma_GG = state_GG * state_GG.dag(); state_UU = tensor(basis(N, 0), ustate); sigma_UU = state_UU * state_UU.dag(). g = 5 # coupling strength; H0 = -g * (sigma_ge.dag() * a + a.dag() * sigma_ge) # time-independent term; H1 = (sigma_ue.dag() + sigma_ue) # time-dependent term. Given that we have a single time-dependent Hamiltonian term, and constant collapse terms, we need to specify a single Python function for the coefficient \(f(t)\). In this case, one can simply do; def H1_coeff(t, args):; return 9 * np.exp(-(t / 5.) ** 2). In this case, the return value depends only on time. However, when specifying Python functions for coefficients, the function must have (t,args) as the input variables, in that order. Having specified our coefficient function, we can now specify the Hamiltonian in list format and call the solver (in this case qutip.mesolve); H = [H0,[H1, H1_coeff]]; output = mesolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). We can call the Monte Carlo solver in the exact same way (if using the default ntraj=500):; output = mcsolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). The output from the master equation solver is identical to that shown in the examples, the Monte Carlo however will be noticeably off, suggesting we should increase the number of trajectories for this example. In addition, we can also consider the decay",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:8510,Integrability,depend,depends,8510,"llapse operators; kappa = 1.5 # Cavity decay rate; c_ops.append(np.sqrt(kappa) * a); gamma = 6 # Atomic decay rate; c_ops.append(np.sqrt(5*gamma/9) * sigma_ue) # Use Rb branching ratio of 5/9 e->u; c_ops.append(np.sqrt(4*gamma/9) * sigma_ge) # 4/9 e->g. t = np.linspace(-15, 15, 100) # Define time vector; psi0 = tensor(basis(N, 0), ustate) # Define initial state. state_GG = tensor(basis(N, 1), ground) # Define states onto which to project; sigma_GG = state_GG * state_GG.dag(); state_UU = tensor(basis(N, 0), ustate); sigma_UU = state_UU * state_UU.dag(). g = 5 # coupling strength; H0 = -g * (sigma_ge.dag() * a + a.dag() * sigma_ge) # time-independent term; H1 = (sigma_ue.dag() + sigma_ue) # time-dependent term. Given that we have a single time-dependent Hamiltonian term, and constant collapse terms, we need to specify a single Python function for the coefficient \(f(t)\). In this case, one can simply do; def H1_coeff(t, args):; return 9 * np.exp(-(t / 5.) ** 2). In this case, the return value depends only on time. However, when specifying Python functions for coefficients, the function must have (t,args) as the input variables, in that order. Having specified our coefficient function, we can now specify the Hamiltonian in list format and call the solver (in this case qutip.mesolve); H = [H0,[H1, H1_coeff]]; output = mesolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). We can call the Monte Carlo solver in the exact same way (if using the default ntraj=500):; output = mcsolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). The output from the master equation solver is identical to that shown in the examples, the Monte Carlo however will be noticeably off, suggesting we should increase the number of trajectories for this example. In addition, we can also consider the decay of a simple Harmonic oscillator with time-varying decay rate; kappa = 0.5. def col_coeff(t, args): # coefficient function; return np.sqrt(kappa * np.exp(-t)). N = 10 # number of basis states; a = dest",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:9610,Integrability,depend,dependent,9610,"ficients, the function must have (t,args) as the input variables, in that order. Having specified our coefficient function, we can now specify the Hamiltonian in list format and call the solver (in this case qutip.mesolve); H = [H0,[H1, H1_coeff]]; output = mesolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). We can call the Monte Carlo solver in the exact same way (if using the default ntraj=500):; output = mcsolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). The output from the master equation solver is identical to that shown in the examples, the Monte Carlo however will be noticeably off, suggesting we should increase the number of trajectories for this example. In addition, we can also consider the decay of a simple Harmonic oscillator with time-varying decay rate; kappa = 0.5. def col_coeff(t, args): # coefficient function; return np.sqrt(kappa * np.exp(-t)). N = 10 # number of basis states; a = destroy(N); H = a.dag() * a # simple HO; psi0 = basis(N, 9) # initial state; c_ops = [[a, col_coeff]] # time-dependent collapse term; times = np.linspace(0, 10, 100); output = mesolve(H, psi0, times, c_ops, [a.dag() * a]). Using the args variable¶; In the previous example we hardcoded all of the variables, driving amplitude \(A\) and width \(\sigma\), with their numerical values. This is fine for problems that are specialized, or that we only want to run once. However, in many cases, we would like to change the parameters of the problem in only one location (usually at the top of the script), and not have to worry about manually changing the values on each run. QuTiP allows you to accomplish this using the keyword args as an input to the solvers. For instance, instead of explicitly writing 9 for the amplitude and 5 for the width of the gaussian driving term, we can make use of the args variable; def H1_coeff(t, args):; return args['A'] * np.exp(-(t/args['sigma'])**2). or equivalently,; def H1_coeff(t, args):; A = args['A']; sig = args['sigma']; return A * np.exp(-(t",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:11501,Integrability,depend,dependent,11501,"A']; sig = args['sigma']; return A * np.exp(-(t / sig) ** 2). where args is a Python dictionary of key: value pairs args = {'A': a, 'sigma': b} where a and b are the two parameters for the amplitude and width, respectively. Of course, we can always hardcode the values in the dictionary as well args = {'A': 9, 'sigma': 5}, but there is much more flexibility by using variables in args. To let the solvers know that we have a set of args to pass we append the args to the end of the solver input:; output = mesolve(H, psi0, times, c_ops, [a.dag() * a], args={'A': 9, 'sigma': 5}). or to keep things looking pretty; args = {'A': 9, 'sigma': 5}; output = mesolve(H, psi0, times, c_ops, [a.dag() * a], args=args). Once again, the Monte Carlo solver qutip.mcsolve works in an identical manner. String Format Method¶. Note; You must have Cython installed on your computer to use this format. See Installation for instructions on installing Cython. The string-based time-dependent format works in a similar manner as the previously discussed Python function method. That being said, the underlying code does something completely different. When using this format, the strings used to represent the time-dependent coefficients, as well as Hamiltonian and collapse operators, are rewritten as Cython code using a code generator class and then compiled into C code. The details of this meta-programming will be published in due course. However, in short, this can lead to a substantial reduction in time for complex time-dependent problems, or when simulating over long intervals.; Like the previous method, the string-based format uses a list pair format [Op, str] where str is now a string representing the time-dependent coefficient. For our first example, this string would be '9 * exp(-(t / 5.) ** 2)'. The Hamiltonian in this format would take the form:; ustate = basis(3, 0); excited = basis(3, 1); ground = basis(3, 2). N = 2 # Set where to truncate Fock state for cavity. sigma_ge = tensor(qeye(N), gr",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:11733,Integrability,depend,dependent,11733,"ways hardcode the values in the dictionary as well args = {'A': 9, 'sigma': 5}, but there is much more flexibility by using variables in args. To let the solvers know that we have a set of args to pass we append the args to the end of the solver input:; output = mesolve(H, psi0, times, c_ops, [a.dag() * a], args={'A': 9, 'sigma': 5}). or to keep things looking pretty; args = {'A': 9, 'sigma': 5}; output = mesolve(H, psi0, times, c_ops, [a.dag() * a], args=args). Once again, the Monte Carlo solver qutip.mcsolve works in an identical manner. String Format Method¶. Note; You must have Cython installed on your computer to use this format. See Installation for instructions on installing Cython. The string-based time-dependent format works in a similar manner as the previously discussed Python function method. That being said, the underlying code does something completely different. When using this format, the strings used to represent the time-dependent coefficients, as well as Hamiltonian and collapse operators, are rewritten as Cython code using a code generator class and then compiled into C code. The details of this meta-programming will be published in due course. However, in short, this can lead to a substantial reduction in time for complex time-dependent problems, or when simulating over long intervals.; Like the previous method, the string-based format uses a list pair format [Op, str] where str is now a string representing the time-dependent coefficient. For our first example, this string would be '9 * exp(-(t / 5.) ** 2)'. The Hamiltonian in this format would take the form:; ustate = basis(3, 0); excited = basis(3, 1); ground = basis(3, 2). N = 2 # Set where to truncate Fock state for cavity. sigma_ge = tensor(qeye(N), ground * excited.dag()) # |g><e|; sigma_ue = tensor(qeye(N), ustate * excited.dag()) # |u><e|; a = tensor(destroy(N), qeye(3)); ada = tensor(num(N), qeye(3)). c_ops = [] # Build collapse operators; kappa = 1.5 # Cavity decay rate; c_ops.append(np",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:12048,Integrability,depend,dependent,12048,"output = mesolve(H, psi0, times, c_ops, [a.dag() * a], args={'A': 9, 'sigma': 5}). or to keep things looking pretty; args = {'A': 9, 'sigma': 5}; output = mesolve(H, psi0, times, c_ops, [a.dag() * a], args=args). Once again, the Monte Carlo solver qutip.mcsolve works in an identical manner. String Format Method¶. Note; You must have Cython installed on your computer to use this format. See Installation for instructions on installing Cython. The string-based time-dependent format works in a similar manner as the previously discussed Python function method. That being said, the underlying code does something completely different. When using this format, the strings used to represent the time-dependent coefficients, as well as Hamiltonian and collapse operators, are rewritten as Cython code using a code generator class and then compiled into C code. The details of this meta-programming will be published in due course. However, in short, this can lead to a substantial reduction in time for complex time-dependent problems, or when simulating over long intervals.; Like the previous method, the string-based format uses a list pair format [Op, str] where str is now a string representing the time-dependent coefficient. For our first example, this string would be '9 * exp(-(t / 5.) ** 2)'. The Hamiltonian in this format would take the form:; ustate = basis(3, 0); excited = basis(3, 1); ground = basis(3, 2). N = 2 # Set where to truncate Fock state for cavity. sigma_ge = tensor(qeye(N), ground * excited.dag()) # |g><e|; sigma_ue = tensor(qeye(N), ustate * excited.dag()) # |u><e|; a = tensor(destroy(N), qeye(3)); ada = tensor(num(N), qeye(3)). c_ops = [] # Build collapse operators; kappa = 1.5 # Cavity decay rate; c_ops.append(np.sqrt(kappa) * a); gamma = 6 # Atomic decay rate; c_ops.append(np.sqrt(5*gamma/9) * sigma_ue) # Use Rb branching ratio of 5/9 e->u; c_ops.append(np.sqrt(4*gamma/9) * sigma_ge) # 4/9 e->g. t = np.linspace(-15, 15, 100) # Define time vector; psi0 = tensor(",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:12241,Integrability,depend,dependent,12241,"t = mesolve(H, psi0, times, c_ops, [a.dag() * a], args=args). Once again, the Monte Carlo solver qutip.mcsolve works in an identical manner. String Format Method¶. Note; You must have Cython installed on your computer to use this format. See Installation for instructions on installing Cython. The string-based time-dependent format works in a similar manner as the previously discussed Python function method. That being said, the underlying code does something completely different. When using this format, the strings used to represent the time-dependent coefficients, as well as Hamiltonian and collapse operators, are rewritten as Cython code using a code generator class and then compiled into C code. The details of this meta-programming will be published in due course. However, in short, this can lead to a substantial reduction in time for complex time-dependent problems, or when simulating over long intervals.; Like the previous method, the string-based format uses a list pair format [Op, str] where str is now a string representing the time-dependent coefficient. For our first example, this string would be '9 * exp(-(t / 5.) ** 2)'. The Hamiltonian in this format would take the form:; ustate = basis(3, 0); excited = basis(3, 1); ground = basis(3, 2). N = 2 # Set where to truncate Fock state for cavity. sigma_ge = tensor(qeye(N), ground * excited.dag()) # |g><e|; sigma_ue = tensor(qeye(N), ustate * excited.dag()) # |u><e|; a = tensor(destroy(N), qeye(3)); ada = tensor(num(N), qeye(3)). c_ops = [] # Build collapse operators; kappa = 1.5 # Cavity decay rate; c_ops.append(np.sqrt(kappa) * a); gamma = 6 # Atomic decay rate; c_ops.append(np.sqrt(5*gamma/9) * sigma_ue) # Use Rb branching ratio of 5/9 e->u; c_ops.append(np.sqrt(4*gamma/9) * sigma_ge) # 4/9 e->g. t = np.linspace(-15, 15, 100) # Define time vector; psi0 = tensor(basis(N, 0), ustate) # Define initial state; state_GG = tensor(basis(N, 1), ground) # Define states onto which to project; sigma_GG = state_GG * state",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:13418,Integrability,depend,dependent,13418,"ited = basis(3, 1); ground = basis(3, 2). N = 2 # Set where to truncate Fock state for cavity. sigma_ge = tensor(qeye(N), ground * excited.dag()) # |g><e|; sigma_ue = tensor(qeye(N), ustate * excited.dag()) # |u><e|; a = tensor(destroy(N), qeye(3)); ada = tensor(num(N), qeye(3)). c_ops = [] # Build collapse operators; kappa = 1.5 # Cavity decay rate; c_ops.append(np.sqrt(kappa) * a); gamma = 6 # Atomic decay rate; c_ops.append(np.sqrt(5*gamma/9) * sigma_ue) # Use Rb branching ratio of 5/9 e->u; c_ops.append(np.sqrt(4*gamma/9) * sigma_ge) # 4/9 e->g. t = np.linspace(-15, 15, 100) # Define time vector; psi0 = tensor(basis(N, 0), ustate) # Define initial state; state_GG = tensor(basis(N, 1), ground) # Define states onto which to project; sigma_GG = state_GG * state_GG.dag(); state_UU = tensor(basis(N, 0), ustate); sigma_UU = state_UU * state_UU.dag(). g = 5 # coupling strength; H0 = -g * (sigma_ge.dag() * a + a.dag() * sigma_ge) # time-independent term; H1 = (sigma_ue.dag() + sigma_ue) # time-dependent term. H = [H0, [H1, '9 * exp(-(t / 5) ** 2)']]. Notice that this is a valid Hamiltonian for the string-based format as exp is included in the above list of suitable functions. Calling the solvers is the same as before:; output = mesolve(H, psi0, t, c_ops, [a.dag() * a]). We can also use the args variable in the same manner as before, however we must rewrite our string term to read: 'A * exp(-(t / sig) ** 2)'; H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]; args = {'A': 9, 'sig': 5}; output = mesolve(H, psi0, times, c_ops, [a.dag()*a], args=args). Important; Naming your args variables exp, sin, pi etc. will cause errors when using the string-based format. Collapse operators are handled in the exact same way. Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions¶; Sometimes it is necessary to model a system where the time-dependent parameters are non-analytic functions, or are derived from experimental data (i.e. a collection of data",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:14300,Integrability,depend,dependent,14300,"U.dag(). g = 5 # coupling strength; H0 = -g * (sigma_ge.dag() * a + a.dag() * sigma_ge) # time-independent term; H1 = (sigma_ue.dag() + sigma_ue) # time-dependent term. H = [H0, [H1, '9 * exp(-(t / 5) ** 2)']]. Notice that this is a valid Hamiltonian for the string-based format as exp is included in the above list of suitable functions. Calling the solvers is the same as before:; output = mesolve(H, psi0, t, c_ops, [a.dag() * a]). We can also use the args variable in the same manner as before, however we must rewrite our string term to read: 'A * exp(-(t / sig) ** 2)'; H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]; args = {'A': 9, 'sig': 5}; output = mesolve(H, psi0, times, c_ops, [a.dag()*a], args=args). Important; Naming your args variables exp, sin, pi etc. will cause errors when using the string-based format. Collapse operators are handled in the exact same way. Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions¶; Sometimes it is necessary to model a system where the time-dependent parameters are non-analytic functions, or are derived from experimental data (i.e. a collection of data points). In these situations, one can use interpolating functions as an approximate functional form for input into a time-dependent solver. QuTiP includes its own custom cubic spline interpolation class qutip.interpolate.Cubic_Spline to provide this functionality. To see how this works, lets first generate some noisy data:; t = np.linspace(-15, 15, 100); func = lambda t: 9*np.exp(-(t / 5)** 2); noisy_func = lambda t: func(t)+(0.05*func(t))*np.random.randn(t.shape[0]); noisy_data = noisy_func(t). plt.figure(); plt.plot(t, func(t)); plt.plot(t, noisy_data, 'o'); plt.show(). To turn these data points into a function we call the QuTiP qutip.interpolate.Cubic_Spline class using the first and last domain time points, t[0] and t[-1], respectively, as well as the entire array of data points:; S = Cubic_Spline(t[0], t[-1], noisy_data). plt.figure()",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:14536,Integrability,depend,dependent,14536," this is a valid Hamiltonian for the string-based format as exp is included in the above list of suitable functions. Calling the solvers is the same as before:; output = mesolve(H, psi0, t, c_ops, [a.dag() * a]). We can also use the args variable in the same manner as before, however we must rewrite our string term to read: 'A * exp(-(t / sig) ** 2)'; H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]; args = {'A': 9, 'sig': 5}; output = mesolve(H, psi0, times, c_ops, [a.dag()*a], args=args). Important; Naming your args variables exp, sin, pi etc. will cause errors when using the string-based format. Collapse operators are handled in the exact same way. Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions¶; Sometimes it is necessary to model a system where the time-dependent parameters are non-analytic functions, or are derived from experimental data (i.e. a collection of data points). In these situations, one can use interpolating functions as an approximate functional form for input into a time-dependent solver. QuTiP includes its own custom cubic spline interpolation class qutip.interpolate.Cubic_Spline to provide this functionality. To see how this works, lets first generate some noisy data:; t = np.linspace(-15, 15, 100); func = lambda t: 9*np.exp(-(t / 5)** 2); noisy_func = lambda t: func(t)+(0.05*func(t))*np.random.randn(t.shape[0]); noisy_data = noisy_func(t). plt.figure(); plt.plot(t, func(t)); plt.plot(t, noisy_data, 'o'); plt.show(). To turn these data points into a function we call the QuTiP qutip.interpolate.Cubic_Spline class using the first and last domain time points, t[0] and t[-1], respectively, as well as the entire array of data points:; S = Cubic_Spline(t[0], t[-1], noisy_data). plt.figure(); plt.plot(t, func(t)); plt.plot(t, noisy_data, 'o'); plt.plot(t, S(t), lw=2); plt.show(). Note that, at present, only equally spaced real or complex data sets can be accommodated. This cubic spline class S can now be paste",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:15581,Integrability,depend,dependent,15581,"-dependent solver. QuTiP includes its own custom cubic spline interpolation class qutip.interpolate.Cubic_Spline to provide this functionality. To see how this works, lets first generate some noisy data:; t = np.linspace(-15, 15, 100); func = lambda t: 9*np.exp(-(t / 5)** 2); noisy_func = lambda t: func(t)+(0.05*func(t))*np.random.randn(t.shape[0]); noisy_data = noisy_func(t). plt.figure(); plt.plot(t, func(t)); plt.plot(t, noisy_data, 'o'); plt.show(). To turn these data points into a function we call the QuTiP qutip.interpolate.Cubic_Spline class using the first and last domain time points, t[0] and t[-1], respectively, as well as the entire array of data points:; S = Cubic_Spline(t[0], t[-1], noisy_data). plt.figure(); plt.plot(t, func(t)); plt.plot(t, noisy_data, 'o'); plt.plot(t, S(t), lw=2); plt.show(). Note that, at present, only equally spaced real or complex data sets can be accommodated. This cubic spline class S can now be pasted to any of the mesolve, mcsolve, or sesolve functions where one would normally input a time-dependent function or string-representation. Taking the problem from the previous section as an example. We would make the replacement:; H = [H0, [H1, '9 * exp(-(t / 5) ** 2)']]. to; H = [H0, [H1, S]]. When combining interpolating functions with other Python functions or strings, the interpolating class will automatically pick the appropriate method for calling the class. That is to say that, if for example, you have other time-dependent terms that are given in the string-format, then the cubic spline representation will also be passed in a string-compatible format. In the string-format, the interpolation function is compiled into c-code, and thus is quite fast. This is the default method if no other time-dependent terms are present. Accesing the state from solver¶; New in QuTiP 4.4; The state of the system, the ket vector or the density matrix,; is available to time-dependent Hamiltonian and collapse operators in args.; Some keys of the ar",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:16013,Integrability,depend,dependent,16013,"utip.interpolate.Cubic_Spline class using the first and last domain time points, t[0] and t[-1], respectively, as well as the entire array of data points:; S = Cubic_Spline(t[0], t[-1], noisy_data). plt.figure(); plt.plot(t, func(t)); plt.plot(t, noisy_data, 'o'); plt.plot(t, S(t), lw=2); plt.show(). Note that, at present, only equally spaced real or complex data sets can be accommodated. This cubic spline class S can now be pasted to any of the mesolve, mcsolve, or sesolve functions where one would normally input a time-dependent function or string-representation. Taking the problem from the previous section as an example. We would make the replacement:; H = [H0, [H1, '9 * exp(-(t / 5) ** 2)']]. to; H = [H0, [H1, S]]. When combining interpolating functions with other Python functions or strings, the interpolating class will automatically pick the appropriate method for calling the class. That is to say that, if for example, you have other time-dependent terms that are given in the string-format, then the cubic spline representation will also be passed in a string-compatible format. In the string-format, the interpolation function is compiled into c-code, and thus is quite fast. This is the default method if no other time-dependent terms are present. Accesing the state from solver¶; New in QuTiP 4.4; The state of the system, the ket vector or the density matrix,; is available to time-dependent Hamiltonian and collapse operators in args.; Some keys of the argument dictionary are understood by the solver to be values; to be updated with the evolution of the system.; The state can be obtained in 3 forms: Qobj, vector (1d np.array), matrix (2d np.array),; expectation values and collapse can also be obtained. Preparation; usage; Notes. state as Qobj; name+""=Qobj"":psi0; psi_t=args[name]; The ket or density matrix as a Qobj with psi0’s dimensions. state as matrix; name+""=mat"":psi0; mat_t=args[name]; The state as a matrix, equivalent to state.full(). state as vector; name+""",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:16296,Integrability,depend,dependent,16296,"; plt.plot(t, noisy_data, 'o'); plt.plot(t, S(t), lw=2); plt.show(). Note that, at present, only equally spaced real or complex data sets can be accommodated. This cubic spline class S can now be pasted to any of the mesolve, mcsolve, or sesolve functions where one would normally input a time-dependent function or string-representation. Taking the problem from the previous section as an example. We would make the replacement:; H = [H0, [H1, '9 * exp(-(t / 5) ** 2)']]. to; H = [H0, [H1, S]]. When combining interpolating functions with other Python functions or strings, the interpolating class will automatically pick the appropriate method for calling the class. That is to say that, if for example, you have other time-dependent terms that are given in the string-format, then the cubic spline representation will also be passed in a string-compatible format. In the string-format, the interpolation function is compiled into c-code, and thus is quite fast. This is the default method if no other time-dependent terms are present. Accesing the state from solver¶; New in QuTiP 4.4; The state of the system, the ket vector or the density matrix,; is available to time-dependent Hamiltonian and collapse operators in args.; Some keys of the argument dictionary are understood by the solver to be values; to be updated with the evolution of the system.; The state can be obtained in 3 forms: Qobj, vector (1d np.array), matrix (2d np.array),; expectation values and collapse can also be obtained. Preparation; usage; Notes. state as Qobj; name+""=Qobj"":psi0; psi_t=args[name]; The ket or density matrix as a Qobj with psi0’s dimensions. state as matrix; name+""=mat"":psi0; mat_t=args[name]; The state as a matrix, equivalent to state.full(). state as vector; name+""=vec"":psi0; vec_t=args[name]; The state as a vector, equivalent to state.full().ravel('F'). expectation value; name+""=expect"":O; e=args[name]; Expectation value of the operator O, either; \(\left<\psi(t)|O|\psi(t)\right>\); or \(\rm{t",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:16461,Integrability,depend,dependent,16461,"d. This cubic spline class S can now be pasted to any of the mesolve, mcsolve, or sesolve functions where one would normally input a time-dependent function or string-representation. Taking the problem from the previous section as an example. We would make the replacement:; H = [H0, [H1, '9 * exp(-(t / 5) ** 2)']]. to; H = [H0, [H1, S]]. When combining interpolating functions with other Python functions or strings, the interpolating class will automatically pick the appropriate method for calling the class. That is to say that, if for example, you have other time-dependent terms that are given in the string-format, then the cubic spline representation will also be passed in a string-compatible format. In the string-format, the interpolation function is compiled into c-code, and thus is quite fast. This is the default method if no other time-dependent terms are present. Accesing the state from solver¶; New in QuTiP 4.4; The state of the system, the ket vector or the density matrix,; is available to time-dependent Hamiltonian and collapse operators in args.; Some keys of the argument dictionary are understood by the solver to be values; to be updated with the evolution of the system.; The state can be obtained in 3 forms: Qobj, vector (1d np.array), matrix (2d np.array),; expectation values and collapse can also be obtained. Preparation; usage; Notes. state as Qobj; name+""=Qobj"":psi0; psi_t=args[name]; The ket or density matrix as a Qobj with psi0’s dimensions. state as matrix; name+""=mat"":psi0; mat_t=args[name]; The state as a matrix, equivalent to state.full(). state as vector; name+""=vec"":psi0; vec_t=args[name]; The state as a vector, equivalent to state.full().ravel('F'). expectation value; name+""=expect"":O; e=args[name]; Expectation value of the operator O, either; \(\left<\psi(t)|O|\psi(t)\right>\); or \(\rm{tr}\left(O \rho(t)\right)\). collpases; name+""=collapse"":[]; col=args[name]; List of collapse,; each collapse is a tuple of the pair (time, which); which bei",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:17828,Integrability,depend,dependent,17828,"th psi0’s dimensions. state as matrix; name+""=mat"":psi0; mat_t=args[name]; The state as a matrix, equivalent to state.full(). state as vector; name+""=vec"":psi0; vec_t=args[name]; The state as a vector, equivalent to state.full().ravel('F'). expectation value; name+""=expect"":O; e=args[name]; Expectation value of the operator O, either; \(\left<\psi(t)|O|\psi(t)\right>\); or \(\rm{tr}\left(O \rho(t)\right)\). collpases; name+""=collapse"":[]; col=args[name]; List of collapse,; each collapse is a tuple of the pair (time, which); which being the indice of the collapse operator.; mcsolve only. Here psi0 is the initial value used for tests before the evolution begins.; qutip.bloch_redfield.brmesolve does not support these arguments. Reusing Time-Dependent Hamiltonian Data¶. Note; This section covers a specialized topic and may be skipped if you are new to QuTiP. When repeatedly simulating a system where only the time-dependent variables, or initial state change, it is possible to reuse the Hamiltonian data stored in QuTiP and there by avoid spending time needlessly preparing the Hamiltonian and collapse terms for simulation. To turn on the the reuse features, we must pass a qutip.solver.Options object with the rhs_reuse flag turned on. Instructions on setting flags are found in Setting Options for the Dynamics Solvers. For example, we can do; H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]; args = {'A': 9, 'sig': 5}; output = mcsolve(H, psi0, times, c_ops, [a.dag()*a], args=args); opts = Options(rhs_reuse=True); args = {'A': 10, 'sig': 3}; output = mcsolve(H, psi0, times, c_ops, [a.dag()*a], args=args, options=opts). The second call to qutip.mcsolve does not reorganize the data, and in the case of the string format, does not recompile the Cython code. For the small system here, the savings in computation time is quite small, however, if you need to call the solvers many times for different parameters, this savings will obviously start to add up. Next ; Previous. © Copyright 2011",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:1983,Modifiability,coupling,coupling,1983,"ations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Solving Problems with Time-dependent Hamiltonians. Solving Problems with Time-dependent Hamiltonians¶. Methods for Writing Time-Dependent Operators¶; In the previous examples of quantum evolution,; we assumed that the systems under consideration were described by time-independent Hamiltonians.; However, many systems have explicit time dependence in either the Hamiltonian,; or the collapse operators describing coupling to the environment, and sometimes both components might depend on time.; The time-evolutions solvers; qutip.mesolve, qutip.mcsolve, qutip.sesolve, qutip.bloch_redfield.brmesolve; qutip.stochastic.ssesolve, qutip.stochastic.photocurrent_sesolve, qutip.stochastic.smesolve, and qutip.stochastic.photocurrent_mesolve; are all capable of handling time-dependent Hamiltonians and collapse terms.; There are, in general, three different ways to implement time-dependent problems in QuTiP:. Function based: Hamiltonian / collapse operators expressed using [qobj, func] pairs, where the time-dependent coefficients of the Hamiltonian (or collapse operators) are expressed using Python functions.; String (Cython) based: The Hamiltonian and/or collapse operators are expressed as a list of [qobj, string] pairs, where the time-dependent coefficients are represented as strings. The resulting Hamiltonian is then compiled into C code using Cython and executed.; Array Based: The Ham",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:8071,Modifiability,coupling,coupling,8071,"=A\exp\left[-\left( t/\sigma \right)^{2}\right]\). The following code sets up the problem; ustate = basis(3, 0); excited = basis(3, 1); ground = basis(3, 2). N = 2 # Set where to truncate Fock state for cavity; sigma_ge = tensor(qeye(N), ground * excited.dag()) # |g><e|; sigma_ue = tensor(qeye(N), ustate * excited.dag()) # |u><e|; a = tensor(destroy(N), qeye(3)); ada = tensor(num(N), qeye(3)). c_ops = [] # Build collapse operators; kappa = 1.5 # Cavity decay rate; c_ops.append(np.sqrt(kappa) * a); gamma = 6 # Atomic decay rate; c_ops.append(np.sqrt(5*gamma/9) * sigma_ue) # Use Rb branching ratio of 5/9 e->u; c_ops.append(np.sqrt(4*gamma/9) * sigma_ge) # 4/9 e->g. t = np.linspace(-15, 15, 100) # Define time vector; psi0 = tensor(basis(N, 0), ustate) # Define initial state. state_GG = tensor(basis(N, 1), ground) # Define states onto which to project; sigma_GG = state_GG * state_GG.dag(); state_UU = tensor(basis(N, 0), ustate); sigma_UU = state_UU * state_UU.dag(). g = 5 # coupling strength; H0 = -g * (sigma_ge.dag() * a + a.dag() * sigma_ge) # time-independent term; H1 = (sigma_ue.dag() + sigma_ue) # time-dependent term. Given that we have a single time-dependent Hamiltonian term, and constant collapse terms, we need to specify a single Python function for the coefficient \(f(t)\). In this case, one can simply do; def H1_coeff(t, args):; return 9 * np.exp(-(t / 5.) ** 2). In this case, the return value depends only on time. However, when specifying Python functions for coefficients, the function must have (t,args) as the input variables, in that order. Having specified our coefficient function, we can now specify the Hamiltonian in list format and call the solver (in this case qutip.mesolve); H = [H0,[H1, H1_coeff]]; output = mesolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). We can call the Monte Carlo solver in the exact same way (if using the default ntraj=500):; output = mcsolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). The output from the master equation",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:8637,Modifiability,variab,variables,8637," 6 # Atomic decay rate; c_ops.append(np.sqrt(5*gamma/9) * sigma_ue) # Use Rb branching ratio of 5/9 e->u; c_ops.append(np.sqrt(4*gamma/9) * sigma_ge) # 4/9 e->g. t = np.linspace(-15, 15, 100) # Define time vector; psi0 = tensor(basis(N, 0), ustate) # Define initial state. state_GG = tensor(basis(N, 1), ground) # Define states onto which to project; sigma_GG = state_GG * state_GG.dag(); state_UU = tensor(basis(N, 0), ustate); sigma_UU = state_UU * state_UU.dag(). g = 5 # coupling strength; H0 = -g * (sigma_ge.dag() * a + a.dag() * sigma_ge) # time-independent term; H1 = (sigma_ue.dag() + sigma_ue) # time-dependent term. Given that we have a single time-dependent Hamiltonian term, and constant collapse terms, we need to specify a single Python function for the coefficient \(f(t)\). In this case, one can simply do; def H1_coeff(t, args):; return 9 * np.exp(-(t / 5.) ** 2). In this case, the return value depends only on time. However, when specifying Python functions for coefficients, the function must have (t,args) as the input variables, in that order. Having specified our coefficient function, we can now specify the Hamiltonian in list format and call the solver (in this case qutip.mesolve); H = [H0,[H1, H1_coeff]]; output = mesolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). We can call the Monte Carlo solver in the exact same way (if using the default ntraj=500):; output = mcsolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). The output from the master equation solver is identical to that shown in the examples, the Monte Carlo however will be noticeably off, suggesting we should increase the number of trajectories for this example. In addition, we can also consider the decay of a simple Harmonic oscillator with time-varying decay rate; kappa = 0.5. def col_coeff(t, args): # coefficient function; return np.sqrt(kappa * np.exp(-t)). N = 10 # number of basis states; a = destroy(N); H = a.dag() * a # simple HO; psi0 = basis(N, 9) # initial state; c_ops = [[a, col_co",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:9739,Modifiability,variab,variable,9739,"); H = [H0,[H1, H1_coeff]]; output = mesolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). We can call the Monte Carlo solver in the exact same way (if using the default ntraj=500):; output = mcsolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). The output from the master equation solver is identical to that shown in the examples, the Monte Carlo however will be noticeably off, suggesting we should increase the number of trajectories for this example. In addition, we can also consider the decay of a simple Harmonic oscillator with time-varying decay rate; kappa = 0.5. def col_coeff(t, args): # coefficient function; return np.sqrt(kappa * np.exp(-t)). N = 10 # number of basis states; a = destroy(N); H = a.dag() * a # simple HO; psi0 = basis(N, 9) # initial state; c_ops = [[a, col_coeff]] # time-dependent collapse term; times = np.linspace(0, 10, 100); output = mesolve(H, psi0, times, c_ops, [a.dag() * a]). Using the args variable¶; In the previous example we hardcoded all of the variables, driving amplitude \(A\) and width \(\sigma\), with their numerical values. This is fine for problems that are specialized, or that we only want to run once. However, in many cases, we would like to change the parameters of the problem in only one location (usually at the top of the script), and not have to worry about manually changing the values on each run. QuTiP allows you to accomplish this using the keyword args as an input to the solvers. For instance, instead of explicitly writing 9 for the amplitude and 5 for the width of the gaussian driving term, we can make use of the args variable; def H1_coeff(t, args):; return args['A'] * np.exp(-(t/args['sigma'])**2). or equivalently,; def H1_coeff(t, args):; A = args['A']; sig = args['sigma']; return A * np.exp(-(t / sig) ** 2). where args is a Python dictionary of key: value pairs args = {'A': a, 'sigma': b} where a and b are the two parameters for the amplitude and width, respectively. Of course, we can always hardcode the value",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:9798,Modifiability,variab,variables,9798,"); H = [H0,[H1, H1_coeff]]; output = mesolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). We can call the Monte Carlo solver in the exact same way (if using the default ntraj=500):; output = mcsolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). The output from the master equation solver is identical to that shown in the examples, the Monte Carlo however will be noticeably off, suggesting we should increase the number of trajectories for this example. In addition, we can also consider the decay of a simple Harmonic oscillator with time-varying decay rate; kappa = 0.5. def col_coeff(t, args): # coefficient function; return np.sqrt(kappa * np.exp(-t)). N = 10 # number of basis states; a = destroy(N); H = a.dag() * a # simple HO; psi0 = basis(N, 9) # initial state; c_ops = [[a, col_coeff]] # time-dependent collapse term; times = np.linspace(0, 10, 100); output = mesolve(H, psi0, times, c_ops, [a.dag() * a]). Using the args variable¶; In the previous example we hardcoded all of the variables, driving amplitude \(A\) and width \(\sigma\), with their numerical values. This is fine for problems that are specialized, or that we only want to run once. However, in many cases, we would like to change the parameters of the problem in only one location (usually at the top of the script), and not have to worry about manually changing the values on each run. QuTiP allows you to accomplish this using the keyword args as an input to the solvers. For instance, instead of explicitly writing 9 for the amplitude and 5 for the width of the gaussian driving term, we can make use of the args variable; def H1_coeff(t, args):; return args['A'] * np.exp(-(t/args['sigma'])**2). or equivalently,; def H1_coeff(t, args):; A = args['A']; sig = args['sigma']; return A * np.exp(-(t / sig) ** 2). where args is a Python dictionary of key: value pairs args = {'A': a, 'sigma': b} where a and b are the two parameters for the amplitude and width, respectively. Of course, we can always hardcode the value",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:10400,Modifiability,variab,variable,10400,"ecay rate; kappa = 0.5. def col_coeff(t, args): # coefficient function; return np.sqrt(kappa * np.exp(-t)). N = 10 # number of basis states; a = destroy(N); H = a.dag() * a # simple HO; psi0 = basis(N, 9) # initial state; c_ops = [[a, col_coeff]] # time-dependent collapse term; times = np.linspace(0, 10, 100); output = mesolve(H, psi0, times, c_ops, [a.dag() * a]). Using the args variable¶; In the previous example we hardcoded all of the variables, driving amplitude \(A\) and width \(\sigma\), with their numerical values. This is fine for problems that are specialized, or that we only want to run once. However, in many cases, we would like to change the parameters of the problem in only one location (usually at the top of the script), and not have to worry about manually changing the values on each run. QuTiP allows you to accomplish this using the keyword args as an input to the solvers. For instance, instead of explicitly writing 9 for the amplitude and 5 for the width of the gaussian driving term, we can make use of the args variable; def H1_coeff(t, args):; return args['A'] * np.exp(-(t/args['sigma'])**2). or equivalently,; def H1_coeff(t, args):; A = args['A']; sig = args['sigma']; return A * np.exp(-(t / sig) ** 2). where args is a Python dictionary of key: value pairs args = {'A': a, 'sigma': b} where a and b are the two parameters for the amplitude and width, respectively. Of course, we can always hardcode the values in the dictionary as well args = {'A': 9, 'sigma': 5}, but there is much more flexibility by using variables in args. To let the solvers know that we have a set of args to pass we append the args to the end of the solver input:; output = mesolve(H, psi0, times, c_ops, [a.dag() * a], args={'A': 9, 'sigma': 5}). or to keep things looking pretty; args = {'A': 9, 'sigma': 5}; output = mesolve(H, psi0, times, c_ops, [a.dag() * a], args=args). Once again, the Monte Carlo solver qutip.mcsolve works in an identical manner. String Format Method¶. Note; Yo",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:10904,Modifiability,variab,variables,10904,"th \(\sigma\), with their numerical values. This is fine for problems that are specialized, or that we only want to run once. However, in many cases, we would like to change the parameters of the problem in only one location (usually at the top of the script), and not have to worry about manually changing the values on each run. QuTiP allows you to accomplish this using the keyword args as an input to the solvers. For instance, instead of explicitly writing 9 for the amplitude and 5 for the width of the gaussian driving term, we can make use of the args variable; def H1_coeff(t, args):; return args['A'] * np.exp(-(t/args['sigma'])**2). or equivalently,; def H1_coeff(t, args):; A = args['A']; sig = args['sigma']; return A * np.exp(-(t / sig) ** 2). where args is a Python dictionary of key: value pairs args = {'A': a, 'sigma': b} where a and b are the two parameters for the amplitude and width, respectively. Of course, we can always hardcode the values in the dictionary as well args = {'A': 9, 'sigma': 5}, but there is much more flexibility by using variables in args. To let the solvers know that we have a set of args to pass we append the args to the end of the solver input:; output = mesolve(H, psi0, times, c_ops, [a.dag() * a], args={'A': 9, 'sigma': 5}). or to keep things looking pretty; args = {'A': 9, 'sigma': 5}; output = mesolve(H, psi0, times, c_ops, [a.dag() * a], args=args). Once again, the Monte Carlo solver qutip.mcsolve works in an identical manner. String Format Method¶. Note; You must have Cython installed on your computer to use this format. See Installation for instructions on installing Cython. The string-based time-dependent format works in a similar manner as the previously discussed Python function method. That being said, the underlying code does something completely different. When using this format, the strings used to represent the time-dependent coefficients, as well as Hamiltonian and collapse operators, are rewritten as Cython code using a ",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:13282,Modifiability,coupling,coupling,13282,"g would be '9 * exp(-(t / 5.) ** 2)'. The Hamiltonian in this format would take the form:; ustate = basis(3, 0); excited = basis(3, 1); ground = basis(3, 2). N = 2 # Set where to truncate Fock state for cavity. sigma_ge = tensor(qeye(N), ground * excited.dag()) # |g><e|; sigma_ue = tensor(qeye(N), ustate * excited.dag()) # |u><e|; a = tensor(destroy(N), qeye(3)); ada = tensor(num(N), qeye(3)). c_ops = [] # Build collapse operators; kappa = 1.5 # Cavity decay rate; c_ops.append(np.sqrt(kappa) * a); gamma = 6 # Atomic decay rate; c_ops.append(np.sqrt(5*gamma/9) * sigma_ue) # Use Rb branching ratio of 5/9 e->u; c_ops.append(np.sqrt(4*gamma/9) * sigma_ge) # 4/9 e->g. t = np.linspace(-15, 15, 100) # Define time vector; psi0 = tensor(basis(N, 0), ustate) # Define initial state; state_GG = tensor(basis(N, 1), ground) # Define states onto which to project; sigma_GG = state_GG * state_GG.dag(); state_UU = tensor(basis(N, 0), ustate); sigma_UU = state_UU * state_UU.dag(). g = 5 # coupling strength; H0 = -g * (sigma_ge.dag() * a + a.dag() * sigma_ge) # time-independent term; H1 = (sigma_ue.dag() + sigma_ue) # time-dependent term. H = [H0, [H1, '9 * exp(-(t / 5) ** 2)']]. Notice that this is a valid Hamiltonian for the string-based format as exp is included in the above list of suitable functions. Calling the solvers is the same as before:; output = mesolve(H, psi0, t, c_ops, [a.dag() * a]). We can also use the args variable in the same manner as before, however we must rewrite our string term to read: 'A * exp(-(t / sig) ** 2)'; H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]; args = {'A': 9, 'sig': 5}; output = mesolve(H, psi0, times, c_ops, [a.dag()*a], args=args). Important; Naming your args variables exp, sin, pi etc. will cause errors when using the string-based format. Collapse operators are handled in the exact same way. Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions¶; Sometimes it is necessary to model a system where the ti",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:13725,Modifiability,variab,variable,13725,"te; c_ops.append(np.sqrt(5*gamma/9) * sigma_ue) # Use Rb branching ratio of 5/9 e->u; c_ops.append(np.sqrt(4*gamma/9) * sigma_ge) # 4/9 e->g. t = np.linspace(-15, 15, 100) # Define time vector; psi0 = tensor(basis(N, 0), ustate) # Define initial state; state_GG = tensor(basis(N, 1), ground) # Define states onto which to project; sigma_GG = state_GG * state_GG.dag(); state_UU = tensor(basis(N, 0), ustate); sigma_UU = state_UU * state_UU.dag(). g = 5 # coupling strength; H0 = -g * (sigma_ge.dag() * a + a.dag() * sigma_ge) # time-independent term; H1 = (sigma_ue.dag() + sigma_ue) # time-dependent term. H = [H0, [H1, '9 * exp(-(t / 5) ** 2)']]. Notice that this is a valid Hamiltonian for the string-based format as exp is included in the above list of suitable functions. Calling the solvers is the same as before:; output = mesolve(H, psi0, t, c_ops, [a.dag() * a]). We can also use the args variable in the same manner as before, however we must rewrite our string term to read: 'A * exp(-(t / sig) ** 2)'; H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]; args = {'A': 9, 'sig': 5}; output = mesolve(H, psi0, times, c_ops, [a.dag()*a], args=args). Important; Naming your args variables exp, sin, pi etc. will cause errors when using the string-based format. Collapse operators are handled in the exact same way. Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions¶; Sometimes it is necessary to model a system where the time-dependent parameters are non-analytic functions, or are derived from experimental data (i.e. a collection of data points). In these situations, one can use interpolating functions as an approximate functional form for input into a time-dependent solver. QuTiP includes its own custom cubic spline interpolation class qutip.interpolate.Cubic_Spline to provide this functionality. To see how this works, lets first generate some noisy data:; t = np.linspace(-15, 15, 100); func = lambda t: 9*np.exp(-(t / 5)** 2); noisy_func = la",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:13780,Modifiability,rewrite,rewrite,13780,"te; c_ops.append(np.sqrt(5*gamma/9) * sigma_ue) # Use Rb branching ratio of 5/9 e->u; c_ops.append(np.sqrt(4*gamma/9) * sigma_ge) # 4/9 e->g. t = np.linspace(-15, 15, 100) # Define time vector; psi0 = tensor(basis(N, 0), ustate) # Define initial state; state_GG = tensor(basis(N, 1), ground) # Define states onto which to project; sigma_GG = state_GG * state_GG.dag(); state_UU = tensor(basis(N, 0), ustate); sigma_UU = state_UU * state_UU.dag(). g = 5 # coupling strength; H0 = -g * (sigma_ge.dag() * a + a.dag() * sigma_ge) # time-independent term; H1 = (sigma_ue.dag() + sigma_ue) # time-dependent term. H = [H0, [H1, '9 * exp(-(t / 5) ** 2)']]. Notice that this is a valid Hamiltonian for the string-based format as exp is included in the above list of suitable functions. Calling the solvers is the same as before:; output = mesolve(H, psi0, t, c_ops, [a.dag() * a]). We can also use the args variable in the same manner as before, however we must rewrite our string term to read: 'A * exp(-(t / sig) ** 2)'; H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]; args = {'A': 9, 'sig': 5}; output = mesolve(H, psi0, times, c_ops, [a.dag()*a], args=args). Important; Naming your args variables exp, sin, pi etc. will cause errors when using the string-based format. Collapse operators are handled in the exact same way. Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions¶; Sometimes it is necessary to model a system where the time-dependent parameters are non-analytic functions, or are derived from experimental data (i.e. a collection of data points). In these situations, one can use interpolating functions as an approximate functional form for input into a time-dependent solver. QuTiP includes its own custom cubic spline interpolation class qutip.interpolate.Cubic_Spline to provide this functionality. To see how this works, lets first generate some noisy data:; t = np.linspace(-15, 15, 100); func = lambda t: 9*np.exp(-(t / 5)** 2); noisy_func = la",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:14005,Modifiability,variab,variables,14005,"ine time vector; psi0 = tensor(basis(N, 0), ustate) # Define initial state; state_GG = tensor(basis(N, 1), ground) # Define states onto which to project; sigma_GG = state_GG * state_GG.dag(); state_UU = tensor(basis(N, 0), ustate); sigma_UU = state_UU * state_UU.dag(). g = 5 # coupling strength; H0 = -g * (sigma_ge.dag() * a + a.dag() * sigma_ge) # time-independent term; H1 = (sigma_ue.dag() + sigma_ue) # time-dependent term. H = [H0, [H1, '9 * exp(-(t / 5) ** 2)']]. Notice that this is a valid Hamiltonian for the string-based format as exp is included in the above list of suitable functions. Calling the solvers is the same as before:; output = mesolve(H, psi0, t, c_ops, [a.dag() * a]). We can also use the args variable in the same manner as before, however we must rewrite our string term to read: 'A * exp(-(t / sig) ** 2)'; H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]; args = {'A': 9, 'sig': 5}; output = mesolve(H, psi0, times, c_ops, [a.dag()*a], args=args). Important; Naming your args variables exp, sin, pi etc. will cause errors when using the string-based format. Collapse operators are handled in the exact same way. Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions¶; Sometimes it is necessary to model a system where the time-dependent parameters are non-analytic functions, or are derived from experimental data (i.e. a collection of data points). In these situations, one can use interpolating functions as an approximate functional form for input into a time-dependent solver. QuTiP includes its own custom cubic spline interpolation class qutip.interpolate.Cubic_Spline to provide this functionality. To see how this works, lets first generate some noisy data:; t = np.linspace(-15, 15, 100); func = lambda t: 9*np.exp(-(t / 5)** 2); noisy_func = lambda t: func(t)+(0.05*func(t))*np.random.randn(t.shape[0]); noisy_data = noisy_func(t). plt.figure(); plt.plot(t, func(t)); plt.plot(t, noisy_data, 'o'); plt.show(). To turn the",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:17838,Modifiability,variab,variables,17838,"th psi0’s dimensions. state as matrix; name+""=mat"":psi0; mat_t=args[name]; The state as a matrix, equivalent to state.full(). state as vector; name+""=vec"":psi0; vec_t=args[name]; The state as a vector, equivalent to state.full().ravel('F'). expectation value; name+""=expect"":O; e=args[name]; Expectation value of the operator O, either; \(\left<\psi(t)|O|\psi(t)\right>\); or \(\rm{tr}\left(O \rho(t)\right)\). collpases; name+""=collapse"":[]; col=args[name]; List of collapse,; each collapse is a tuple of the pair (time, which); which being the indice of the collapse operator.; mcsolve only. Here psi0 is the initial value used for tests before the evolution begins.; qutip.bloch_redfield.brmesolve does not support these arguments. Reusing Time-Dependent Hamiltonian Data¶. Note; This section covers a specialized topic and may be skipped if you are new to QuTiP. When repeatedly simulating a system where only the time-dependent variables, or initial state change, it is possible to reuse the Hamiltonian data stored in QuTiP and there by avoid spending time needlessly preparing the Hamiltonian and collapse terms for simulation. To turn on the the reuse features, we must pass a qutip.solver.Options object with the rhs_reuse flag turned on. Instructions on setting flags are found in Setting Options for the Dynamics Solvers. For example, we can do; H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]; args = {'A': 9, 'sig': 5}; output = mcsolve(H, psi0, times, c_ops, [a.dag()*a], args=args); opts = Options(rhs_reuse=True); args = {'A': 10, 'sig': 3}; output = mcsolve(H, psi0, times, c_ops, [a.dag()*a], args=args, options=opts). The second call to qutip.mcsolve does not reorganize the data, and in the case of the string format, does not recompile the Cython code. For the small system here, the savings in computation time is quite small, however, if you need to call the solvers many times for different parameters, this savings will obviously start to add up. Next ; Previous. © Copyright 2011",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:17948,Safety,avoid,avoid,17948,"th psi0’s dimensions. state as matrix; name+""=mat"":psi0; mat_t=args[name]; The state as a matrix, equivalent to state.full(). state as vector; name+""=vec"":psi0; vec_t=args[name]; The state as a vector, equivalent to state.full().ravel('F'). expectation value; name+""=expect"":O; e=args[name]; Expectation value of the operator O, either; \(\left<\psi(t)|O|\psi(t)\right>\); or \(\rm{tr}\left(O \rho(t)\right)\). collpases; name+""=collapse"":[]; col=args[name]; List of collapse,; each collapse is a tuple of the pair (time, which); which being the indice of the collapse operator.; mcsolve only. Here psi0 is the initial value used for tests before the evolution begins.; qutip.bloch_redfield.brmesolve does not support these arguments. Reusing Time-Dependent Hamiltonian Data¶. Note; This section covers a specialized topic and may be skipped if you are new to QuTiP. When repeatedly simulating a system where only the time-dependent variables, or initial state change, it is possible to reuse the Hamiltonian data stored in QuTiP and there by avoid spending time needlessly preparing the Hamiltonian and collapse terms for simulation. To turn on the the reuse features, we must pass a qutip.solver.Options object with the rhs_reuse flag turned on. Instructions on setting flags are found in Setting Options for the Dynamics Solvers. For example, we can do; H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]; args = {'A': 9, 'sig': 5}; output = mcsolve(H, psi0, times, c_ops, [a.dag()*a], args=args); opts = Options(rhs_reuse=True); args = {'A': 10, 'sig': 3}; output = mcsolve(H, psi0, times, c_ops, [a.dag()*a], args=args, options=opts). The second call to qutip.mcsolve does not reorganize the data, and in the case of the string format, does not recompile the Cython code. For the small system here, the savings in computation time is quite small, however, if you need to call the solvers many times for different parameters, this savings will obviously start to add up. Next ; Previous. © Copyright 2011",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:4453,Testability,log,log,4453,"pse operators must be time independent using this input format. Given the multiple choices of input style, the first question that arrises is which option to choose?; In short, the function based method (option #1) is the most general,; allowing for essentially arbitrary coefficients expressed via user-defined functions.; However, by automatically compiling your system into C++ code,; the second option (string based) tends to be more efficient and will run faster; [This is also the only format that is supported in the qutip.bloch_redfield.brmesolve solver].; Of course, for small system sizes and evolution times, the difference will be minor.; Although this method does not support all time-dependent coefficients that one can think of,; it does support essentially all problems that one would typically encounter.; Time-dependent coefficients using any of the following functions,; or combinations thereof (including constants) can be compiled directly into C++-code:; 'abs', 'acos', 'acosh', 'arg', 'asin', 'asinh', 'atan', 'atanh', 'conj',; 'cos', 'cosh','exp', 'erf', 'zerf', 'imag', 'log', 'log10', 'norm', 'pi',; 'proj', 'real', 'sin', 'sinh', 'sqrt', 'tan', 'tanh'. In addition, QuTiP supports cubic spline based interpolation functions [Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions].; If you require mathematical functions other than those listed above,; it is possible to call any of the functions in the NumPy library using the prefix np.; before the function name in the string, i.e. 'np.sin(t)' and scipy.special imported as spe.; This includes a wide range of functionality, but comes with a small overhead created by going from C++->Python->C++.; Finally option #4, expressing the Hamiltonian as a Python function,; is the original method for time dependence in QuTiP 1.x.; This method is somewhat less efficient then the previously mentioned ones.; However, in contrast to the other options; this method can be used in implem",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:17539,Testability,test,tests,17539,"gument dictionary are understood by the solver to be values; to be updated with the evolution of the system.; The state can be obtained in 3 forms: Qobj, vector (1d np.array), matrix (2d np.array),; expectation values and collapse can also be obtained. Preparation; usage; Notes. state as Qobj; name+""=Qobj"":psi0; psi_t=args[name]; The ket or density matrix as a Qobj with psi0’s dimensions. state as matrix; name+""=mat"":psi0; mat_t=args[name]; The state as a matrix, equivalent to state.full(). state as vector; name+""=vec"":psi0; vec_t=args[name]; The state as a vector, equivalent to state.full().ravel('F'). expectation value; name+""=expect"":O; e=args[name]; Expectation value of the operator O, either; \(\left<\psi(t)|O|\psi(t)\right>\); or \(\rm{tr}\left(O \rho(t)\right)\). collpases; name+""=collapse"":[]; col=args[name]; List of collapse,; each collapse is a tuple of the pair (time, which); which being the indice of the collapse operator.; mcsolve only. Here psi0 is the initial value used for tests before the evolution begins.; qutip.bloch_redfield.brmesolve does not support these arguments. Reusing Time-Dependent Hamiltonian Data¶. Note; This section covers a specialized topic and may be skipped if you are new to QuTiP. When repeatedly simulating a system where only the time-dependent variables, or initial state change, it is possible to reuse the Hamiltonian data stored in QuTiP and there by avoid spending time needlessly preparing the Hamiltonian and collapse terms for simulation. To turn on the the reuse features, we must pass a qutip.solver.Options object with the rhs_reuse flag turned on. Instructions on setting flags are found in Setting Options for the Dynamics Solvers. For example, we can do; H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]; args = {'A': 9, 'sig': 5}; output = mcsolve(H, psi0, times, c_ops, [a.dag()*a], args=args); opts = Options(rhs_reuse=True); args = {'A': 10, 'sig': 3}; output = mcsolve(H, psi0, times, c_ops, [a.dag()*a], args=args, options=opts).",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:8409,Usability,simpl,simply,8409," tensor(destroy(N), qeye(3)); ada = tensor(num(N), qeye(3)). c_ops = [] # Build collapse operators; kappa = 1.5 # Cavity decay rate; c_ops.append(np.sqrt(kappa) * a); gamma = 6 # Atomic decay rate; c_ops.append(np.sqrt(5*gamma/9) * sigma_ue) # Use Rb branching ratio of 5/9 e->u; c_ops.append(np.sqrt(4*gamma/9) * sigma_ge) # 4/9 e->g. t = np.linspace(-15, 15, 100) # Define time vector; psi0 = tensor(basis(N, 0), ustate) # Define initial state. state_GG = tensor(basis(N, 1), ground) # Define states onto which to project; sigma_GG = state_GG * state_GG.dag(); state_UU = tensor(basis(N, 0), ustate); sigma_UU = state_UU * state_UU.dag(). g = 5 # coupling strength; H0 = -g * (sigma_ge.dag() * a + a.dag() * sigma_ge) # time-independent term; H1 = (sigma_ue.dag() + sigma_ue) # time-dependent term. Given that we have a single time-dependent Hamiltonian term, and constant collapse terms, we need to specify a single Python function for the coefficient \(f(t)\). In this case, one can simply do; def H1_coeff(t, args):; return 9 * np.exp(-(t / 5.) ** 2). In this case, the return value depends only on time. However, when specifying Python functions for coefficients, the function must have (t,args) as the input variables, in that order. Having specified our coefficient function, we can now specify the Hamiltonian in list format and call the solver (in this case qutip.mesolve); H = [H0,[H1, H1_coeff]]; output = mesolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). We can call the Monte Carlo solver in the exact same way (if using the default ntraj=500):; output = mcsolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). The output from the master equation solver is identical to that shown in the examples, the Monte Carlo however will be noticeably off, suggesting we should increase the number of trajectories for this example. In addition, we can also consider the decay of a simple Harmonic oscillator with time-varying decay rate; kappa = 0.5. def col_coeff(t, args): # coefficient func",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:9310,Usability,simpl,simple,9310,"ed to specify a single Python function for the coefficient \(f(t)\). In this case, one can simply do; def H1_coeff(t, args):; return 9 * np.exp(-(t / 5.) ** 2). In this case, the return value depends only on time. However, when specifying Python functions for coefficients, the function must have (t,args) as the input variables, in that order. Having specified our coefficient function, we can now specify the Hamiltonian in list format and call the solver (in this case qutip.mesolve); H = [H0,[H1, H1_coeff]]; output = mesolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). We can call the Monte Carlo solver in the exact same way (if using the default ntraj=500):; output = mcsolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). The output from the master equation solver is identical to that shown in the examples, the Monte Carlo however will be noticeably off, suggesting we should increase the number of trajectories for this example. In addition, we can also consider the decay of a simple Harmonic oscillator with time-varying decay rate; kappa = 0.5. def col_coeff(t, args): # coefficient function; return np.sqrt(kappa * np.exp(-t)). N = 10 # number of basis states; a = destroy(N); H = a.dag() * a # simple HO; psi0 = basis(N, 9) # initial state; c_ops = [[a, col_coeff]] # time-dependent collapse term; times = np.linspace(0, 10, 100); output = mesolve(H, psi0, times, c_ops, [a.dag() * a]). Using the args variable¶; In the previous example we hardcoded all of the variables, driving amplitude \(A\) and width \(\sigma\), with their numerical values. This is fine for problems that are specialized, or that we only want to run once. However, in many cases, we would like to change the parameters of the problem in only one location (usually at the top of the script), and not have to worry about manually changing the values on each run. QuTiP allows you to accomplish this using the keyword args as an input to the solvers. For instance, instead of explicitly writing 9 for the amplitu",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:9531,Usability,simpl,simple,9531,"ficients, the function must have (t,args) as the input variables, in that order. Having specified our coefficient function, we can now specify the Hamiltonian in list format and call the solver (in this case qutip.mesolve); H = [H0,[H1, H1_coeff]]; output = mesolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). We can call the Monte Carlo solver in the exact same way (if using the default ntraj=500):; output = mcsolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). The output from the master equation solver is identical to that shown in the examples, the Monte Carlo however will be noticeably off, suggesting we should increase the number of trajectories for this example. In addition, we can also consider the decay of a simple Harmonic oscillator with time-varying decay rate; kappa = 0.5. def col_coeff(t, args): # coefficient function; return np.sqrt(kappa * np.exp(-t)). N = 10 # number of basis states; a = destroy(N); H = a.dag() * a # simple HO; psi0 = basis(N, 9) # initial state; c_ops = [[a, col_coeff]] # time-dependent collapse term; times = np.linspace(0, 10, 100); output = mesolve(H, psi0, times, c_ops, [a.dag() * a]). Using the args variable¶; In the previous example we hardcoded all of the variables, driving amplitude \(A\) and width \(\sigma\), with their numerical values. This is fine for problems that are specialized, or that we only want to run once. However, in many cases, we would like to change the parameters of the problem in only one location (usually at the top of the script), and not have to worry about manually changing the values on each run. QuTiP allows you to accomplish this using the keyword args as an input to the solvers. For instance, instead of explicitly writing 9 for the amplitude and 5 for the width of the gaussian driving term, we can make use of the args variable; def H1_coeff(t, args):; return args['A'] * np.exp(-(t/args['sigma'])**2). or equivalently,; def H1_coeff(t, args):; A = args['A']; sig = args['sigma']; return A * np.exp(-(t",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/heom/bosonic.html:5481,Availability,avail,available,5481," of Feynman Diagrams (both classify terms by increasing number; of interactions).; The result is a standard QuTiP results object with the attributes:. times: the times at which the state was evaluated (i.e. tlist); states: the system states at each time; expect: the values of each e_ops at each time; ado_states: see below (an instance of; HierarchyADOsState). If ado_return=True is passed to .run(...) the full set of auxilliary; density operators (ADOs) that make up the hierarchy at each time will be; returned as .ado_states. We will describe how to use these to determine; other properties, such as system-bath currents, later in the fermionic guide; (see Determining currents).; If one has a full set of ADOs from a previous call of .run(...) you may; supply it as the initial state of the solver by calling; .run(result.ado_states[-1], tlist, ado_init=True).; As with other QuTiP solvers, if expectation operators or functions are supplied; using .run(..., e_ops=[...]) the expectation values are available in; result.expect.; Below we run the solver again, but use e_ops to store the expectation; values of the population of the system states and the coherence:; # Define the operators that measure the populations of the two; # system states:; P11p = basis(2,0) * basis(2,0).dag(); P22p = basis(2,1) * basis(2,1).dag(). # Define the operator that measures the 0, 1 element of density matrix; # (corresonding to coherence):; P12p = basis(2,0) * basis(2,1).dag(). # Run the solver:; tlist = np.linspace(0, 20, 101); result = solver.run(rho0, tlist, e_ops={""11"": P11p, ""22"": P22p, ""12"": P12p}). # Plot the results:; fig, axes = plt.subplots(1, 1, sharex=True, figsize=(8,8)); axes.plot(result.times, result.expect[""11""], 'b', linewidth=2, label=""P11""); axes.plot(result.times, result.expect[""12""], 'r', linewidth=2, label=""P12""); axes.set_xlabel(r't', fontsize=28); axes.legend(loc=0, fontsize=12). Steady-state¶; Using the same solver, we can also determine the steady state of the; combined s",MatchSource.WIKI,docs/4.7/guide/heom/bosonic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/heom/bosonic.html
https://qutip.org/docs/4.7/guide/heom/bosonic.html:12732,Deployability,update,updated,12732," separate bath. Such; an arrangement can model, for example, the Fenna–Matthews–Olson (FMO); pigment-protein complex which plays an important role in photosynthesis (; for a full FMO example see the notebook; https://github.com/tehruhn/bofin/blob/main/examples/example-2-FMO-example.ipynb; ).; For each bath expansion, we also include the terminator in the system; Liouvillian.; At the end, we plot the populations of the system states as a function of; time, and show the long-time beating of quantum state coherence that; occurs:; # The size of the system:; N_sys = 3. def proj(i, j):; """""" A helper function for creating an interaction operator. """"""; return basis(N_sys, i) * basis(N_sys, j).dag(). # Construct one bath for each system state:; baths = []; for i in range(N_sys):; Q = proj(i, i); baths.append(DrudeLorentzBath(Q, lam, gamma, T, Nk)). # Construct the system Liouvillian from the system Hamiltonian and; # bath expansion terminators:; H_sys = sum((i + 0.5) * eps * proj(i, i) for i in range(N_sys)); H_sys += sum(; (i + j + 0.5) * Del * proj(i, j); for i in range(N_sys) for j in range(N_sys); if i != j; ); HL = liouvillian(H_sys) + sum(bath.terminator()[1] for bath in baths). # Construct the solver (pass a list of baths):; solver = HEOMSolver(HL, baths, max_depth=max_depth, options=options). # Run the solver:; rho0 = basis(N_sys, 0) * basis(N_sys, 0).dag(); tlist = np.linspace(0, 5, 200); e_ops = {; f""P{i}"": proj(i, i); for i in range(N_sys); }; result = solver.run(rho0, tlist, e_ops=e_ops). # Plot populations:; fig, axes = plt.subplots(1, 1, sharex=True, figsize=(8,8)); for label, values in result.expect.items():; axes.plot(result.times, values, label=label); axes.set_xlabel(r't', fontsize=28); axes.set_ylabel(r""Population"", fontsize=28); axes.legend(loc=0, fontsize=12). Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/heom/bosonic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/heom/bosonic.html
https://qutip.org/docs/4.7/guide/heom/bosonic.html:2803,Energy Efficiency,energy,energy,2803,"; First we will do this in the simplest way, using the built-in implementations of; the two bath expansions, DrudeLorentzBath and; DrudeLorentzPadeBath. We will do this both with a; truncated expansion and show how to include an approximation to all of the; remaining terms in the bath expansion.; Afterwards, we will show how to calculate the bath expansion coefficients and to; use those coefficients to construct your own bath description so that you can; implement your own bosonic baths.; Finally, we will demonstrate how to simulate a system coupled to multiple; independent baths, as occurs, for example, in certain photosynthesis processes.; A notebook containing a complete example similar to this one implemented in; BoFiN can be found in; example notebook 1a. Describing the system and bath¶; First, let us construct the system Hamiltonian, \(H_{sys}\), and the initial; system state, rho0:; from qutip import basis, sigmax, sigmaz. # The system Hamiltonian:; eps = 0.5 # energy of the 2-level system; Del = 1.0 # tunnelling term; H_sys = 0.5 * eps * sigmaz() + 0.5 * Del * sigmax(). # Initial state of the system:; rho0 = basis(2,0) * basis(2,0).dag(). Now let us describe the bath properties:; # Bath properties:; gamma = 0.5 # cut off frequency; lam = 0.1 # coupling strength; T = 0.5 # temperature. # System-bath coupling operator:; Q = sigmaz(). where \(\gamma\) (gamma), \(\lambda\) (lam) and \(T\) are; the parameters of a Drude-Lorentz bath, and Q is the coupling operator; between the system and the bath.; We may the pass these parameters to either; DrudeLorentzBath or; DrudeLorentzPadeBath to construct an expansion of; the bath correlations:; from qutip.nonmarkov.heom import DrudeLorentzBath; from qutip.nonmarkov.heom import DrudeLorentzPadeBath. # Number of expansion terms to retain:; Nk = 2. # Matsubara expansion:; bath = DrudeLorentzBath(Q, lam, gamma, T, Nk). # Padé expansion:; bath = DrudeLorentzPadeBath(Q, lam, gamma, T, Nk). Where Nk is the number of terms to ret",MatchSource.WIKI,docs/4.7/guide/heom/bosonic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/heom/bosonic.html
https://qutip.org/docs/4.7/guide/heom/bosonic.html:1754,Modifiability,evolve,evolve,1754,"y-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Hierarchical Equations of Motion »; Bosonic Environments. Bosonic Environments¶; In this section we consider a simple two-level system coupled to a; Drude-Lorentz bosonic bath. The system Hamiltonian, \(H_{sys}\), and the bath; spectral density, \(J_D\), are. \[ \begin{align}\begin{aligned}H_{sys} &= \frac{\epsilon \sigma_z}{2} + \frac{\Delta \sigma_x}{2}\\J_D &= \frac{2\lambda \gamma \omega}{(\gamma^2 + \omega^2)},\end{aligned}\end{align} \]; We will demonstrate how to describe the bath using two different expansions; of the spectral density correlation function (Matsubara’s expansion and; a Padé expansion), how to evolve the system in time, and how to calculate; the steady state.; First we will do this in the simplest way, using the built-in implementations of; the two bath expansions, DrudeLorentzBath and; DrudeLorentzPadeBath. We will do this both with a; truncated expansion and show how to include an approximation to all of the; remaining terms in the bath expansion.; Afterwards, we will show how to calculate the bath expansion coefficients and to; use those coefficients to construct your own bath description so that you can; implement your own bosonic baths.; Finally, we will demonstrate how to simulate a system coupled to multiple; independent baths, as occurs, for example, in certain photosynthesis processes.; A notebook containing a complete example similar to this one implemented in; BoFiN can be found in; example notebook 1a. Describing the",MatchSource.WIKI,docs/4.7/guide/heom/bosonic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/heom/bosonic.html
https://qutip.org/docs/4.7/guide/heom/bosonic.html:3092,Modifiability,coupling,coupling,3092,"ath expansion.; Afterwards, we will show how to calculate the bath expansion coefficients and to; use those coefficients to construct your own bath description so that you can; implement your own bosonic baths.; Finally, we will demonstrate how to simulate a system coupled to multiple; independent baths, as occurs, for example, in certain photosynthesis processes.; A notebook containing a complete example similar to this one implemented in; BoFiN can be found in; example notebook 1a. Describing the system and bath¶; First, let us construct the system Hamiltonian, \(H_{sys}\), and the initial; system state, rho0:; from qutip import basis, sigmax, sigmaz. # The system Hamiltonian:; eps = 0.5 # energy of the 2-level system; Del = 1.0 # tunnelling term; H_sys = 0.5 * eps * sigmaz() + 0.5 * Del * sigmax(). # Initial state of the system:; rho0 = basis(2,0) * basis(2,0).dag(). Now let us describe the bath properties:; # Bath properties:; gamma = 0.5 # cut off frequency; lam = 0.1 # coupling strength; T = 0.5 # temperature. # System-bath coupling operator:; Q = sigmaz(). where \(\gamma\) (gamma), \(\lambda\) (lam) and \(T\) are; the parameters of a Drude-Lorentz bath, and Q is the coupling operator; between the system and the bath.; We may the pass these parameters to either; DrudeLorentzBath or; DrudeLorentzPadeBath to construct an expansion of; the bath correlations:; from qutip.nonmarkov.heom import DrudeLorentzBath; from qutip.nonmarkov.heom import DrudeLorentzPadeBath. # Number of expansion terms to retain:; Nk = 2. # Matsubara expansion:; bath = DrudeLorentzBath(Q, lam, gamma, T, Nk). # Padé expansion:; bath = DrudeLorentzPadeBath(Q, lam, gamma, T, Nk). Where Nk is the number of terms to retain within the expansion of the; bath. System and bath dynamics¶; Now we are ready to construct a solver:; from qutip.nonmarkov.heom import HEOMSolver; from qutip import Options. max_depth = 5 # maximum hierarchy depth to retain; options = Options(nsteps=15_000). solver = HEOMSolver",MatchSource.WIKI,docs/4.7/guide/heom/bosonic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/heom/bosonic.html
https://qutip.org/docs/4.7/guide/heom/bosonic.html:3148,Modifiability,coupling,coupling,3148,"te the bath expansion coefficients and to; use those coefficients to construct your own bath description so that you can; implement your own bosonic baths.; Finally, we will demonstrate how to simulate a system coupled to multiple; independent baths, as occurs, for example, in certain photosynthesis processes.; A notebook containing a complete example similar to this one implemented in; BoFiN can be found in; example notebook 1a. Describing the system and bath¶; First, let us construct the system Hamiltonian, \(H_{sys}\), and the initial; system state, rho0:; from qutip import basis, sigmax, sigmaz. # The system Hamiltonian:; eps = 0.5 # energy of the 2-level system; Del = 1.0 # tunnelling term; H_sys = 0.5 * eps * sigmaz() + 0.5 * Del * sigmax(). # Initial state of the system:; rho0 = basis(2,0) * basis(2,0).dag(). Now let us describe the bath properties:; # Bath properties:; gamma = 0.5 # cut off frequency; lam = 0.1 # coupling strength; T = 0.5 # temperature. # System-bath coupling operator:; Q = sigmaz(). where \(\gamma\) (gamma), \(\lambda\) (lam) and \(T\) are; the parameters of a Drude-Lorentz bath, and Q is the coupling operator; between the system and the bath.; We may the pass these parameters to either; DrudeLorentzBath or; DrudeLorentzPadeBath to construct an expansion of; the bath correlations:; from qutip.nonmarkov.heom import DrudeLorentzBath; from qutip.nonmarkov.heom import DrudeLorentzPadeBath. # Number of expansion terms to retain:; Nk = 2. # Matsubara expansion:; bath = DrudeLorentzBath(Q, lam, gamma, T, Nk). # Padé expansion:; bath = DrudeLorentzPadeBath(Q, lam, gamma, T, Nk). Where Nk is the number of terms to retain within the expansion of the; bath. System and bath dynamics¶; Now we are ready to construct a solver:; from qutip.nonmarkov.heom import HEOMSolver; from qutip import Options. max_depth = 5 # maximum hierarchy depth to retain; options = Options(nsteps=15_000). solver = HEOMSolver(H_sys, bath, max_depth=max_depth, options=options). a",MatchSource.WIKI,docs/4.7/guide/heom/bosonic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/heom/bosonic.html
https://qutip.org/docs/4.7/guide/heom/bosonic.html:3294,Modifiability,coupling,coupling,3294,"o that you can; implement your own bosonic baths.; Finally, we will demonstrate how to simulate a system coupled to multiple; independent baths, as occurs, for example, in certain photosynthesis processes.; A notebook containing a complete example similar to this one implemented in; BoFiN can be found in; example notebook 1a. Describing the system and bath¶; First, let us construct the system Hamiltonian, \(H_{sys}\), and the initial; system state, rho0:; from qutip import basis, sigmax, sigmaz. # The system Hamiltonian:; eps = 0.5 # energy of the 2-level system; Del = 1.0 # tunnelling term; H_sys = 0.5 * eps * sigmaz() + 0.5 * Del * sigmax(). # Initial state of the system:; rho0 = basis(2,0) * basis(2,0).dag(). Now let us describe the bath properties:; # Bath properties:; gamma = 0.5 # cut off frequency; lam = 0.1 # coupling strength; T = 0.5 # temperature. # System-bath coupling operator:; Q = sigmaz(). where \(\gamma\) (gamma), \(\lambda\) (lam) and \(T\) are; the parameters of a Drude-Lorentz bath, and Q is the coupling operator; between the system and the bath.; We may the pass these parameters to either; DrudeLorentzBath or; DrudeLorentzPadeBath to construct an expansion of; the bath correlations:; from qutip.nonmarkov.heom import DrudeLorentzBath; from qutip.nonmarkov.heom import DrudeLorentzPadeBath. # Number of expansion terms to retain:; Nk = 2. # Matsubara expansion:; bath = DrudeLorentzBath(Q, lam, gamma, T, Nk). # Padé expansion:; bath = DrudeLorentzPadeBath(Q, lam, gamma, T, Nk). Where Nk is the number of terms to retain within the expansion of the; bath. System and bath dynamics¶; Now we are ready to construct a solver:; from qutip.nonmarkov.heom import HEOMSolver; from qutip import Options. max_depth = 5 # maximum hierarchy depth to retain; options = Options(nsteps=15_000). solver = HEOMSolver(H_sys, bath, max_depth=max_depth, options=options). and to calculate the system evolution as a function of time:; tlist = [0, 10, 20] # times to evaluate the s",MatchSource.WIKI,docs/4.7/guide/heom/bosonic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/heom/bosonic.html
https://qutip.org/docs/4.7/guide/heom/bosonic.html:6919,Modifiability,coupling,coupling,6919,"s={""11"": P11p, ""22"": P22p, ""12"": P12p}). # Plot the results:; fig, axes = plt.subplots(1, 1, sharex=True, figsize=(8,8)); axes.plot(result.times, result.expect[""11""], 'b', linewidth=2, label=""P11""); axes.plot(result.times, result.expect[""12""], 'r', linewidth=2, label=""P12""); axes.set_xlabel(r't', fontsize=28); axes.legend(loc=0, fontsize=12). Steady-state¶; Using the same solver, we can also determine the steady state of the; combined system and bath using:; steady_state, steady_ados = solver.steady_state(). where steady_state is the steady state of the system and steady_ados; if the steady state of the full hierarchy. The ADO states are; described more fully in Determining currents and; HierarchyADOsState. Matsubara Terminator¶; When constructing the Drude-Lorentz bath we have truncated the expansion at; Nk = 2 terms and ignore the remaining terms.; However, since the coupling to these higher order terms is comparatively weak,; we may consider the interaction with them to be Markovian, and construct an; additional Lindbladian term that captures their interaction with the system and; the lower order terms in the expansion.; This additional term is called the terminator because it terminates the; expansion.; The DrudeLorentzBath and; DrudeLorentzPadeBath both provide a means of; calculating the terminator for a given expansion:; # Matsubara expansion:; bath = DrudeLorentzBath(Q, lam, gamma, T, Nk). # Padé expansion:; bath = DrudeLorentzPadeBath(Q, lam, gamma, T, Nk). # Add terminator to the system Liouvillian:; delta, terminator = bath.terminator(); HL = liouvillian(H_sys) + terminator. # Construct solver:; solver = HEOMSolver(HL, bath, max_depth=max_depth, options=options). This captures the Markovian effect of the remaining terms in the expansion; without having to fully model many more terms.; The value delta is an approximation to the strength of the effect of; the remaining terms in the expansion (i.e. how strongly the terminator is; coupled to the rest of the sy",MatchSource.WIKI,docs/4.7/guide/heom/bosonic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/heom/bosonic.html
https://qutip.org/docs/4.7/guide/heom/bosonic.html:9882,Modifiability,extend,extend,9882,", \(C_{real}(t)\):. \[ \begin{align}\begin{aligned}\begin{split}\nu_{k,real} &= \begin{cases}; \gamma & k = 0\\; {2 \pi k} / {\beta } & k \geq 1\\; \end{cases}\end{split}\\\begin{split}c_{k,real} &= \begin{cases}; \lambda \gamma [\cot(\beta \gamma / 2) - i] & k = 0\\; \frac{4 \lambda \gamma \nu_k }{ (\nu_k^2 - \gamma^2)\beta} & k \geq 1\\; \end{cases}\end{split}\end{aligned}\end{align} \]; and the imaginary part, \(C_{imag}(t)\):. \[ \begin{align}\begin{aligned}\begin{split}\nu_{k,imag} &= \begin{cases}; \gamma & k = 0\\; 0 & k \geq 1\\; \end{cases}\end{split}\\\begin{split}c_{k,imag} &= \begin{cases}; - \lambda \gamma & k = 0\\; 0 & k \geq 1\\; \end{cases}\end{split}\end{aligned}\end{align} \]; And now the same numbers calculated in Python:; # Convenience functions and parameters:. def cot(x):; return 1. / np.tan(x). beta = 1. / T. # Number of expansion terms to calculate:; Nk = 2. # C_real expansion terms:; ck_real = [lam * gamma / np.tan(gamma / (2 * T))]; ck_real.extend([; (8 * lam * gamma * T * np.pi * k * T /; ((2 * np.pi * k * T)**2 - gamma**2)); for k in range(1, Nk + 1); ]); vk_real = [gamma]; vk_real.extend([2 * np.pi * k * T for k in range(1, Nk + 1)]). # C_imag expansion terms (this is the full expansion):; ck_imag = [lam * gamma * (-1.0)]; vk_imag = [gamma]. After all that, constructing the bath is very straight forward:; from qutip.nonmarkov.heom import BosonicBath. bath = BosonicBath(Q, ck_real, vk_real, ck_imag, vk_imag). And we’re done!; The BosonicBath can be used with the; HEOMSolver in exactly the same way as the baths; we constructed previously using the built-in Drude-Lorentz bath expansions. Multiple baths¶; The HEOMSolver supports having a system interact; with multiple environments. All that is needed is to supply a list of baths; instead of a single bath.; In the example below we calculate the evolution of a small system where; each basis state of the system interacts with a separate bath. Such; an arrangement can model, for example, the Fe",MatchSource.WIKI,docs/4.7/guide/heom/bosonic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/heom/bosonic.html
https://qutip.org/docs/4.7/guide/heom/bosonic.html:10028,Modifiability,extend,extend,10028," k \geq 1\\; \end{cases}\end{split}\\\begin{split}c_{k,real} &= \begin{cases}; \lambda \gamma [\cot(\beta \gamma / 2) - i] & k = 0\\; \frac{4 \lambda \gamma \nu_k }{ (\nu_k^2 - \gamma^2)\beta} & k \geq 1\\; \end{cases}\end{split}\end{aligned}\end{align} \]; and the imaginary part, \(C_{imag}(t)\):. \[ \begin{align}\begin{aligned}\begin{split}\nu_{k,imag} &= \begin{cases}; \gamma & k = 0\\; 0 & k \geq 1\\; \end{cases}\end{split}\\\begin{split}c_{k,imag} &= \begin{cases}; - \lambda \gamma & k = 0\\; 0 & k \geq 1\\; \end{cases}\end{split}\end{aligned}\end{align} \]; And now the same numbers calculated in Python:; # Convenience functions and parameters:. def cot(x):; return 1. / np.tan(x). beta = 1. / T. # Number of expansion terms to calculate:; Nk = 2. # C_real expansion terms:; ck_real = [lam * gamma / np.tan(gamma / (2 * T))]; ck_real.extend([; (8 * lam * gamma * T * np.pi * k * T /; ((2 * np.pi * k * T)**2 - gamma**2)); for k in range(1, Nk + 1); ]); vk_real = [gamma]; vk_real.extend([2 * np.pi * k * T for k in range(1, Nk + 1)]). # C_imag expansion terms (this is the full expansion):; ck_imag = [lam * gamma * (-1.0)]; vk_imag = [gamma]. After all that, constructing the bath is very straight forward:; from qutip.nonmarkov.heom import BosonicBath. bath = BosonicBath(Q, ck_real, vk_real, ck_imag, vk_imag). And we’re done!; The BosonicBath can be used with the; HEOMSolver in exactly the same way as the baths; we constructed previously using the built-in Drude-Lorentz bath expansions. Multiple baths¶; The HEOMSolver supports having a system interact; with multiple environments. All that is needed is to supply a list of baths; instead of a single bath.; In the example below we calculate the evolution of a small system where; each basis state of the system interacts with a separate bath. Such; an arrangement can model, for example, the Fenna–Matthews–Olson (FMO); pigment-protein complex which plays an important role in photosynthesis (; for a full FMO example see the note",MatchSource.WIKI,docs/4.7/guide/heom/bosonic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/heom/bosonic.html
https://qutip.org/docs/4.7/guide/heom/bosonic.html:1241,Usability,simpl,simple,1241," and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Introduction; Bosonic Environments; Describing the system and bath; System and bath dynamics; Steady-state; Matsubara Terminator; Matsubara expansion coefficients; Multiple baths. Fermionic Environments; Previous implementations; References. Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Hierarchical Equations of Motion »; Bosonic Environments. Bosonic Environments¶; In this section we consider a simple two-level system coupled to a; Drude-Lorentz bosonic bath. The system Hamiltonian, \(H_{sys}\), and the bath; spectral density, \(J_D\), are. \[ \begin{align}\begin{aligned}H_{sys} &= \frac{\epsilon \sigma_z}{2} + \frac{\Delta \sigma_x}{2}\\J_D &= \frac{2\lambda \gamma \omega}{(\gamma^2 + \omega^2)},\end{aligned}\end{align} \]; We will demonstrate how to describe the bath using two different expansions; of the spectral density correlation function (Matsubara’s expansion and; a Padé expansion), how to evolve the system in time, and how to calculate; the steady state.; First we will do this in the simplest way, using the built-in implementations of; the two bath expansions, DrudeLorentzBath and; DrudeLorentzPadeBath. We will do this both with a; truncated expansion and show how to include an approximation to all of the; remaining terms in the bath expansion.; Afterwards, we will show how to calculate the bath expansion coefficients and to; use those coefficients to construct your own ba",MatchSource.WIKI,docs/4.7/guide/heom/bosonic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/heom/bosonic.html
https://qutip.org/docs/4.7/guide/heom/bosonic.html:1851,Usability,simpl,simplest,1851,"Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Hierarchical Equations of Motion »; Bosonic Environments. Bosonic Environments¶; In this section we consider a simple two-level system coupled to a; Drude-Lorentz bosonic bath. The system Hamiltonian, \(H_{sys}\), and the bath; spectral density, \(J_D\), are. \[ \begin{align}\begin{aligned}H_{sys} &= \frac{\epsilon \sigma_z}{2} + \frac{\Delta \sigma_x}{2}\\J_D &= \frac{2\lambda \gamma \omega}{(\gamma^2 + \omega^2)},\end{aligned}\end{align} \]; We will demonstrate how to describe the bath using two different expansions; of the spectral density correlation function (Matsubara’s expansion and; a Padé expansion), how to evolve the system in time, and how to calculate; the steady state.; First we will do this in the simplest way, using the built-in implementations of; the two bath expansions, DrudeLorentzBath and; DrudeLorentzPadeBath. We will do this both with a; truncated expansion and show how to include an approximation to all of the; remaining terms in the bath expansion.; Afterwards, we will show how to calculate the bath expansion coefficients and to; use those coefficients to construct your own bath description so that you can; implement your own bosonic baths.; Finally, we will demonstrate how to simulate a system coupled to multiple; independent baths, as occurs, for example, in certain photosynthesis processes.; A notebook containing a complete example similar to this one implemented in; BoFiN can be found in; example notebook 1a. Describing the system and bath¶; First, let us construct the system Hamiltonian, \(H_{sys}\), and the initial; system state, rho0:; from qutip import basis, sigmax, sigmaz. # The system Hamiltonian:; eps = 0.5 # energy of the 2-level system; Del = 1.0 # tunnelling term; H_sys = 0.5 * eps * sigmaz() + 0.5",MatchSource.WIKI,docs/4.7/guide/heom/bosonic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/heom/bosonic.html
https://qutip.org/docs/4.7/guide/heom/bosonic.html:5126,Usability,guid,guide,5126," solver = HEOMSolver(H_sys, bath, max_depth=max_depth, options=options). and to calculate the system evolution as a function of time:; tlist = [0, 10, 20] # times to evaluate the system state at; result = solver.run(rho0, tlist). The max_depth parameter determines how many levels of the hierarchy to; retain. As a first approximation hierarchy depth may be thought of as similar; to the order of Feynman Diagrams (both classify terms by increasing number; of interactions).; The result is a standard QuTiP results object with the attributes:. times: the times at which the state was evaluated (i.e. tlist); states: the system states at each time; expect: the values of each e_ops at each time; ado_states: see below (an instance of; HierarchyADOsState). If ado_return=True is passed to .run(...) the full set of auxilliary; density operators (ADOs) that make up the hierarchy at each time will be; returned as .ado_states. We will describe how to use these to determine; other properties, such as system-bath currents, later in the fermionic guide; (see Determining currents).; If one has a full set of ADOs from a previous call of .run(...) you may; supply it as the initial state of the solver by calling; .run(result.ado_states[-1], tlist, ado_init=True).; As with other QuTiP solvers, if expectation operators or functions are supplied; using .run(..., e_ops=[...]) the expectation values are available in; result.expect.; Below we run the solver again, but use e_ops to store the expectation; values of the population of the system states and the coherence:; # Define the operators that measure the populations of the two; # system states:; P11p = basis(2,0) * basis(2,0).dag(); P22p = basis(2,1) * basis(2,1).dag(). # Define the operator that measures the 0, 1 element of density matrix; # (corresonding to coherence):; P12p = basis(2,0) * basis(2,1).dag(). # Run the solver:; tlist = np.linspace(0, 20, 101); result = solver.run(rho0, tlist, e_ops={""11"": P11p, ""22"": P22p, ""12"": P12p}). # Plo",MatchSource.WIKI,docs/4.7/guide/heom/bosonic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/heom/bosonic.html
https://qutip.org/docs/4.7/guide/heom/fermionic.html:12804,Availability,down,down,12804,"nsion.; Evaluating the integral for the correlation functions gives:. \[C^{\sigma}(t) \approx \sum_{l=0}^{Nk} \eta^{\sigma,l} e^{-\gamma_{\sigma,l}t}\]; where:. \[ \begin{align}\begin{aligned}\begin{split}\eta_{\sigma, l} &= \begin{cases}; \frac{\Gamma W}{2} f_F^{approx}(i\beta W) & l = 0\\; -i\cdot \frac{k_l}{\beta} \cdot \frac{\Gamma W^2}{-\frac{\epsilon^2_l}{\beta^2} + W^2} & l \neq 0\\; \end{cases}\end{split}\\\begin{split}\gamma_{\sigma,l} &= \begin{cases}; W - \sigma i\mu & l = 0\\; \frac{\epsilon_l}{\beta} - \sigma i \mu & l \neq 0\\; \end{cases}\end{split}\end{aligned}\end{align} \]; and \(\beta = \frac{1}{T}\).; And now we calculate the same numbers in Python:; # Imports; from numpy.linalg import eigvalsh. # Convenience functions and parameters:; def deltafun(j, k):; """""" Kronecker delta function. """"""; return 1.0 if j == k else 0. def f_approx(x, Nk):; """""" Padé approxmation to Fermi distribution. """"""; f = 0.5; for ll in range(1, Nk + 1):; # kappa and epsilon are calculated further down; f = f - 2 * kappa[ll] * x / (x**2 + epsilon[ll]**2); return f. def kappa_epsilon(Nk):; """""" Calculate kappa and epsilon coefficients. """""". alpha = np.zeros((2 * Nk, 2 * Nk)); for j in range(2 * Nk):; for k in range(2 * Nk):; alpha[j][k] = (; (deltafun(j, k + 1) + deltafun(j, k - 1)); / np.sqrt((2 * (j + 1) - 1) * (2 * (k + 1) - 1)); ). eps = [-2. / val for val in eigvalsh(alpha)[:Nk]]. alpha_p = np.zeros((2 * Nk - 1, 2 * Nk - 1)); for j in range(2 * Nk - 1):; for k in range(2 * Nk - 1):; alpha_p[j][k] = (; (deltafun(j, k + 1) + deltafun(j, k - 1)); / np.sqrt((2 * (j + 1) + 1) * (2 * (k + 1) + 1)); ). chi = [-2. / val for val in eigvalsh(alpha_p)[:Nk - 1]]. eta_list = [; 0.5 * Nk * (2 * (Nk + 1) - 1) * (; np.prod([chi[k]**2 - eps[j]**2 for k in range(Nk - 1)]) /; np.prod([; eps[k]**2 - eps[j]**2 + deltafun(j, k) for k in range(Nk); ]); ); for j in range(Nk); ]. kappa = [0] + eta_list; epsilon = [0] + eps. return kappa, epsilon. kappa, epsilon = kappa_epsilon(Nk). # Phew, we made",MatchSource.WIKI,docs/4.7/guide/heom/fermionic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/heom/fermionic.html
https://qutip.org/docs/4.7/guide/heom/fermionic.html:15055,Deployability,update,updated,15055,". / val for val in eigvalsh(alpha)[:Nk]]. alpha_p = np.zeros((2 * Nk - 1, 2 * Nk - 1)); for j in range(2 * Nk - 1):; for k in range(2 * Nk - 1):; alpha_p[j][k] = (; (deltafun(j, k + 1) + deltafun(j, k - 1)); / np.sqrt((2 * (j + 1) + 1) * (2 * (k + 1) + 1)); ). chi = [-2. / val for val in eigvalsh(alpha_p)[:Nk - 1]]. eta_list = [; 0.5 * Nk * (2 * (Nk + 1) - 1) * (; np.prod([chi[k]**2 - eps[j]**2 for k in range(Nk - 1)]) /; np.prod([; eps[k]**2 - eps[j]**2 + deltafun(j, k) for k in range(Nk); ]); ); for j in range(Nk); ]. kappa = [0] + eta_list; epsilon = [0] + eps. return kappa, epsilon. kappa, epsilon = kappa_epsilon(Nk). # Phew, we made it to function that calculates the coefficients for the; # correlation function expansions:. def C(sigma, mu, Nk):; """""" Calculate the expansion coefficients for C_\sigma. """"""; beta = 1. / T; ck = [0.5 * gamma * W * f_approx(1.0j * beta * W, Nk)]; vk = [W - sigma * 1.0j * mu]; for ll in range(1, Nk + 1):; ck.append(; -1.0j * (kappa[ll] / beta) * gamma * W**2; / (-(epsilon[ll]**2 / beta**2) + W**2); ); vk.append(epsilon[ll] / beta - sigma * 1.0j * mu); return ck, vk. ck_plus_L, vk_plus_L = C(1.0, mu_L, Nk) # C_+, left bath; ck_minus_L, vk_minus_L = C(-1.0, mu_L, Nk) # C_-, left bath. ck_plus_R, vk_plus_R = C(1.0, mu_R, Nk) # C_+, right bath; ck_minus_R, vk_minus_R = C(-1.0, mu_R, Nk) # C_-, right bath. Finally we are ready to construct the; FermionicBath:; from qutip.nonmarkov.heom import FermionicBath. # Padé expansion:; bath_L = FermionicBath(Q, ck_plus_L, vk_plus_L, ck_minus_L, vk_minus_L); bath_R = FermionicBath(Q, ck_plus_R, vk_plus_R, ck_minus_R, vk_minus_R). And we’re done!; The FermionicBath can be used with the; HEOMSolver in exactly the same way as the baths; we constructed previously using the built-in Lorentzian bath expansions. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/heom/fermionic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/heom/fermionic.html
https://qutip.org/docs/4.7/guide/heom/fermionic.html:2989,Energy Efficiency,energy,energy,2989,"ch bath will have a different chemical; potential \(\mu\) which we will label \(\mu_L\) and \(\mu_R\).; First we will do this using the built-in implementations of the bath expansions,; LorentzianBath and; LorentzianPadeBath.; Afterwards, we will show how to calculate the bath expansion coefficients and to; use those coefficients to construct your own bath description so that you can; implement your own fermionic baths.; Our implementation of fermionic baths primarily follows the definitions used by; Christian Schinabeck in his dissertation (; https://opus4.kobv.de/opus4-fau/files/10984/DissertationChristianSchinabeck.pdf; ) and related publications.; A notebook containing a complete example similar to this one implemented in; BoFiN can be found in example notebook 4b. Describing the system and bath¶; First, let us construct the system Hamiltonian, \(H_{sys}\), and the initial; system state, rho0:; from qutip import basis, destroy. # The system Hamiltonian:; e1 = 1. # site energy; H_sys = e1 * destroy(2).dag() * destroy(2). # Initial state of the system:; rho0 = basis(2,0) * basis(2,0).dag(). Now let us describe the bath properties:; # Shared bath properties:; gamma = 0.01 # coupling strength; W = 1.0 # cut-off; T = 0.025851991 # temperature; beta = 1. / T. # Chemical potentials for the two baths:; mu_L = 1.; mu_R = -1. # System-bath coupling operator:; Q = destroy(2). where \(\Gamma\) (gamma), \(W\) and \(T\) are the parameters of; an Lorentzian bath, \(\mu_L\) (mu_L) and \(\mu_R\) (mu_R) are; the chemical potentials of the left and right baths, and Q is the coupling; operator between the system and the baths.; We may the pass these parameters to either LorentzianBath or; LorentzianPadeBath to construct an expansion of the bath correlations:; from qutip.nonmarkov.heom import LorentzianBath; from qutip.nonmarkov.heom import LorentzianPadeBath. # Number of expansion terms to retain:; Nk = 2. # Matsubara expansion:; bath_L = LorentzianBath(Q, gamma, W, mu_L, T, Nk, ta",MatchSource.WIKI,docs/4.7/guide/heom/fermionic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/heom/fermionic.html
https://qutip.org/docs/4.7/guide/heom/fermionic.html:1746,Modifiability,evolve,evolve,1746,"relation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Hierarchical Equations of Motion »; Fermionic Environments. Fermionic Environments¶; Here we model a single fermion coupled to two electronic leads or reservoirs; (e.g., this can describe a single quantum dot, a molecular transistor, etc).; The system hamiltonian, \(H_{sys}\), and bath spectral density, \(J_D\),; are. \[ \begin{align}\begin{aligned}H_{sys} &= c^{\dagger} c\\J_D &= \frac{\Gamma W^2}{(w - \mu)^2 + W^2},\end{aligned}\end{align} \]; We will demonstrate how to describe the bath using two different expansions; of the spectral density correlation function (Matsubara’s expansion and; a Padé expansion), how to evolve the system in time, and how to calculate; the steady state.; Since our fermion is coupled to two reservoirs, we will construct two baths –; one for each reservoir or lead – and call them the left (\(L\)) and right; (\(R\)) baths for convenience. Each bath will have a different chemical; potential \(\mu\) which we will label \(\mu_L\) and \(\mu_R\).; First we will do this using the built-in implementations of the bath expansions,; LorentzianBath and; LorentzianPadeBath.; Afterwards, we will show how to calculate the bath expansion coefficients and to; use those coefficients to construct your own bath description so that you can; implement your own fermionic baths.; Our implementation of fermionic baths primarily follows the definitions used by; Christian Schinabeck in his dissertation (; https://opus4.kobv.de/opus4-fau/files/10984/DissertationChristianSchinabeck",MatchSource.WIKI,docs/4.7/guide/heom/fermionic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/heom/fermionic.html
https://qutip.org/docs/4.7/guide/heom/fermionic.html:3195,Modifiability,coupling,coupling,3195,"; LorentzianPadeBath.; Afterwards, we will show how to calculate the bath expansion coefficients and to; use those coefficients to construct your own bath description so that you can; implement your own fermionic baths.; Our implementation of fermionic baths primarily follows the definitions used by; Christian Schinabeck in his dissertation (; https://opus4.kobv.de/opus4-fau/files/10984/DissertationChristianSchinabeck.pdf; ) and related publications.; A notebook containing a complete example similar to this one implemented in; BoFiN can be found in example notebook 4b. Describing the system and bath¶; First, let us construct the system Hamiltonian, \(H_{sys}\), and the initial; system state, rho0:; from qutip import basis, destroy. # The system Hamiltonian:; e1 = 1. # site energy; H_sys = e1 * destroy(2).dag() * destroy(2). # Initial state of the system:; rho0 = basis(2,0) * basis(2,0).dag(). Now let us describe the bath properties:; # Shared bath properties:; gamma = 0.01 # coupling strength; W = 1.0 # cut-off; T = 0.025851991 # temperature; beta = 1. / T. # Chemical potentials for the two baths:; mu_L = 1.; mu_R = -1. # System-bath coupling operator:; Q = destroy(2). where \(\Gamma\) (gamma), \(W\) and \(T\) are the parameters of; an Lorentzian bath, \(\mu_L\) (mu_L) and \(\mu_R\) (mu_R) are; the chemical potentials of the left and right baths, and Q is the coupling; operator between the system and the baths.; We may the pass these parameters to either LorentzianBath or; LorentzianPadeBath to construct an expansion of the bath correlations:; from qutip.nonmarkov.heom import LorentzianBath; from qutip.nonmarkov.heom import LorentzianPadeBath. # Number of expansion terms to retain:; Nk = 2. # Matsubara expansion:; bath_L = LorentzianBath(Q, gamma, W, mu_L, T, Nk, tag=""L""); bath_R = LorentzianBath(Q, gamma, W, mu_R, T, Nk, tag=""R""). # Padé expansion:; bath_L = LorentzianPadeBath(Q, gamma, W, mu_L, T, Nk, tag=""L""); bath_R = LorentzianPadeBath(Q, gamma, W, mu_R, T, Nk,",MatchSource.WIKI,docs/4.7/guide/heom/fermionic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/heom/fermionic.html
https://qutip.org/docs/4.7/guide/heom/fermionic.html:3357,Modifiability,coupling,coupling,3357,"tion so that you can; implement your own fermionic baths.; Our implementation of fermionic baths primarily follows the definitions used by; Christian Schinabeck in his dissertation (; https://opus4.kobv.de/opus4-fau/files/10984/DissertationChristianSchinabeck.pdf; ) and related publications.; A notebook containing a complete example similar to this one implemented in; BoFiN can be found in example notebook 4b. Describing the system and bath¶; First, let us construct the system Hamiltonian, \(H_{sys}\), and the initial; system state, rho0:; from qutip import basis, destroy. # The system Hamiltonian:; e1 = 1. # site energy; H_sys = e1 * destroy(2).dag() * destroy(2). # Initial state of the system:; rho0 = basis(2,0) * basis(2,0).dag(). Now let us describe the bath properties:; # Shared bath properties:; gamma = 0.01 # coupling strength; W = 1.0 # cut-off; T = 0.025851991 # temperature; beta = 1. / T. # Chemical potentials for the two baths:; mu_L = 1.; mu_R = -1. # System-bath coupling operator:; Q = destroy(2). where \(\Gamma\) (gamma), \(W\) and \(T\) are the parameters of; an Lorentzian bath, \(\mu_L\) (mu_L) and \(\mu_R\) (mu_R) are; the chemical potentials of the left and right baths, and Q is the coupling; operator between the system and the baths.; We may the pass these parameters to either LorentzianBath or; LorentzianPadeBath to construct an expansion of the bath correlations:; from qutip.nonmarkov.heom import LorentzianBath; from qutip.nonmarkov.heom import LorentzianPadeBath. # Number of expansion terms to retain:; Nk = 2. # Matsubara expansion:; bath_L = LorentzianBath(Q, gamma, W, mu_L, T, Nk, tag=""L""); bath_R = LorentzianBath(Q, gamma, W, mu_R, T, Nk, tag=""R""). # Padé expansion:; bath_L = LorentzianPadeBath(Q, gamma, W, mu_L, T, Nk, tag=""L""); bath_R = LorentzianPadeBath(Q, gamma, W, mu_R, T, Nk, tag=""R""). Where Nk is the number of terms to retain within the expansion of the; bath.; Note that we haved labelled each bath with a tag (either “L” or “R”) so t",MatchSource.WIKI,docs/4.7/guide/heom/fermionic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/heom/fermionic.html
https://qutip.org/docs/4.7/guide/heom/fermionic.html:3587,Modifiability,coupling,coupling,3587,"n Schinabeck in his dissertation (; https://opus4.kobv.de/opus4-fau/files/10984/DissertationChristianSchinabeck.pdf; ) and related publications.; A notebook containing a complete example similar to this one implemented in; BoFiN can be found in example notebook 4b. Describing the system and bath¶; First, let us construct the system Hamiltonian, \(H_{sys}\), and the initial; system state, rho0:; from qutip import basis, destroy. # The system Hamiltonian:; e1 = 1. # site energy; H_sys = e1 * destroy(2).dag() * destroy(2). # Initial state of the system:; rho0 = basis(2,0) * basis(2,0).dag(). Now let us describe the bath properties:; # Shared bath properties:; gamma = 0.01 # coupling strength; W = 1.0 # cut-off; T = 0.025851991 # temperature; beta = 1. / T. # Chemical potentials for the two baths:; mu_L = 1.; mu_R = -1. # System-bath coupling operator:; Q = destroy(2). where \(\Gamma\) (gamma), \(W\) and \(T\) are the parameters of; an Lorentzian bath, \(\mu_L\) (mu_L) and \(\mu_R\) (mu_R) are; the chemical potentials of the left and right baths, and Q is the coupling; operator between the system and the baths.; We may the pass these parameters to either LorentzianBath or; LorentzianPadeBath to construct an expansion of the bath correlations:; from qutip.nonmarkov.heom import LorentzianBath; from qutip.nonmarkov.heom import LorentzianPadeBath. # Number of expansion terms to retain:; Nk = 2. # Matsubara expansion:; bath_L = LorentzianBath(Q, gamma, W, mu_L, T, Nk, tag=""L""); bath_R = LorentzianBath(Q, gamma, W, mu_R, T, Nk, tag=""R""). # Padé expansion:; bath_L = LorentzianPadeBath(Q, gamma, W, mu_L, T, Nk, tag=""L""); bath_R = LorentzianPadeBath(Q, gamma, W, mu_R, T, Nk, tag=""R""). Where Nk is the number of terms to retain within the expansion of the; bath.; Note that we haved labelled each bath with a tag (either “L” or “R”) so that; we can identify the exponents from individual baths later when calculating; the currents between the system and the bath. System and bath dynami",MatchSource.WIKI,docs/4.7/guide/heom/fermionic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/heom/fermionic.html
https://qutip.org/docs/4.7/guide/heom/fermionic.html:6956,Security,access,access,6956,"legend(loc=0, fontsize=12). The plot above is not very exciting. What we would really like to see in; this case are the currents between the system and the two baths. We will plot; these in the next section using the auxiliary density operators (ADOs); returned by the solver. Determining currents¶; The currents between the system and a fermionic bath may be calculated from the; first level auxiliary density operators (ADOs) associated with the exponents; of that bath.; The contribution to the current into a given bath from each exponent in that; bath is:. \[\mathrm{Contribution from Exponent} = \pm i \mathrm{Tr}(Q^\pm \cdot A)\]; where the \(\pm\) sign is the sign of the exponent (see the; description later in Padé expansion coefficients) and; \(Q^\pm\) is \(Q\) for + exponents and \(Q^{\dagger}\) for; - exponents.; The first-level exponents for the left bath are retrieved by calling; .filter(tags=[""L""]) on ado_state which is an instance of; HierarchyADOsState and also provides access to; the methods of HierarchyADOs which describes the; structure of the hierarchy for a given problem.; Here the tag “L” matches the tag passed when constructing bath_L earlier; in this example.; Similarly, we may calculate the current to the right bath from the exponents; tagged with “R”.; def exp_current(aux, exp):; """""" Calculate the current for a single exponent. """"""; sign = 1 if exp.type == exp.types[""+""] else -1; op = exp.Q if exp.type == exp.types[""+""] else exp.Q.dag(); return 1j * sign * (op * aux).tr(). def heom_current(tag, ado_state):; """""" Calculate the current between the system and the given bath. """"""; level_1_ados = [; (ado_state.extract(label), ado_state.exps(label)[0]); for label in ado_state.filter(tags=[tag]); ]; return np.real(sum(exp_current(aux, exp) for aux, exp in level_1_ados)). heom_left_current = lambda t, ado_state: heom_current(""L"", ado_state); heom_right_current = lambda t, ado_state: heom_current(""R"", ado_state). Once we have defined functions for retrieving",MatchSource.WIKI,docs/4.7/guide/heom/fermionic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/heom/fermionic.html
https://qutip.org/docs/4.7/guide/heom/history.html:1374,Availability,avail,available,1374,"rchical Equations of Motion; Introduction; Bosonic Environments; Fermionic Environments; Previous implementations; HSolverDL; BoFiN-HEOM; Current implementation. References. Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Hierarchical Equations of Motion »; Previous implementations. Previous implementations¶; The current HEOM implementation in QuTiP is the latest in a succession of HEOM; implementations by various contributors:. HSolverDL¶; The original HEOM solver was implemented by Neill Lambert, Anubhav Vardhan,; and Alexander Pitchford and is still available as; qutip.nonmarkov.dlheom_solver.HSolverDL and only directly provided; support for the Drude-Lorentz bath although there was the possibility of; sub-classing the solver to implement other baths.; A compatible interface using the current implementation is available under the; same name in qutip.nonmarkov.heom.HSolverDL. BoFiN-HEOM¶; BoFiN-HEOM (the bosonic and fermionic HEOM solver) was a much more; flexible re-write of the original QuTiP HSolverDL that added support for; both bosonic and fermionic baths and for baths to be specified directly via; their correlation function expansion coefficients. Its authors were; Neill Lambert, Tarun Raheja, Shahnawaz Ahmed, and Alexander Pitchford.; BoFiN was written outside of QuTiP and is can still be found in its original; repository at https://github.com/tehruhn/bofin.; The construction of the right-hand side matrix for BoFiN was slow, so; BoFiN-fast, a hybrid C++ and Python implemen",MatchSource.WIKI,docs/4.7/guide/heom/history.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/heom/history.html
https://qutip.org/docs/4.7/guide/heom/history.html:1640,Availability,avail,available,1640,"n of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Hierarchical Equations of Motion »; Previous implementations. Previous implementations¶; The current HEOM implementation in QuTiP is the latest in a succession of HEOM; implementations by various contributors:. HSolverDL¶; The original HEOM solver was implemented by Neill Lambert, Anubhav Vardhan,; and Alexander Pitchford and is still available as; qutip.nonmarkov.dlheom_solver.HSolverDL and only directly provided; support for the Drude-Lorentz bath although there was the possibility of; sub-classing the solver to implement other baths.; A compatible interface using the current implementation is available under the; same name in qutip.nonmarkov.heom.HSolverDL. BoFiN-HEOM¶; BoFiN-HEOM (the bosonic and fermionic HEOM solver) was a much more; flexible re-write of the original QuTiP HSolverDL that added support for; both bosonic and fermionic baths and for baths to be specified directly via; their correlation function expansion coefficients. Its authors were; Neill Lambert, Tarun Raheja, Shahnawaz Ahmed, and Alexander Pitchford.; BoFiN was written outside of QuTiP and is can still be found in its original; repository at https://github.com/tehruhn/bofin.; The construction of the right-hand side matrix for BoFiN was slow, so; BoFiN-fast, a hybrid C++ and Python implementation, was written that performed; the right-hand side construction in C++. It was otherwise identical to the; pure Python version. BoFiN-fast can be found at; https://github.com/tehruhn/bofin_fast.; BoFiN also came with an extensive set of example notebooks that are available; at https://github.com/tehruhn",MatchSource.WIKI,docs/4.7/guide/heom/history.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/heom/history.html
https://qutip.org/docs/4.7/guide/heom/history.html:2590,Availability,avail,available,2590," for the Drude-Lorentz bath although there was the possibility of; sub-classing the solver to implement other baths.; A compatible interface using the current implementation is available under the; same name in qutip.nonmarkov.heom.HSolverDL. BoFiN-HEOM¶; BoFiN-HEOM (the bosonic and fermionic HEOM solver) was a much more; flexible re-write of the original QuTiP HSolverDL that added support for; both bosonic and fermionic baths and for baths to be specified directly via; their correlation function expansion coefficients. Its authors were; Neill Lambert, Tarun Raheja, Shahnawaz Ahmed, and Alexander Pitchford.; BoFiN was written outside of QuTiP and is can still be found in its original; repository at https://github.com/tehruhn/bofin.; The construction of the right-hand side matrix for BoFiN was slow, so; BoFiN-fast, a hybrid C++ and Python implementation, was written that performed; the right-hand side construction in C++. It was otherwise identical to the; pure Python version. BoFiN-fast can be found at; https://github.com/tehruhn/bofin_fast.; BoFiN also came with an extensive set of example notebooks that are available; at https://github.com/tehruhn/bofin/tree/main/examples. Current implementation¶; The current implementation is a rewrite of BoFiN in pure Python. It’s; right-hand side construction has similar speed to BoFiN-fast, but is written; in pure Python. Built-in implementations of a variety of different baths; are provided, and a single solver is used for both fermionic and bosonic baths.; Multiple baths of the same kind (either fermionic or bosonic) may be; specified in a single problem, and there is good support for working with; the auxiliary density operator (ADO) state and extracting information from it.; The code was written by Neill Lambert and Simon Cross. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/heom/history.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/heom/history.html
https://qutip.org/docs/4.7/guide/heom/history.html:3362,Deployability,update,updated,3362," for the Drude-Lorentz bath although there was the possibility of; sub-classing the solver to implement other baths.; A compatible interface using the current implementation is available under the; same name in qutip.nonmarkov.heom.HSolverDL. BoFiN-HEOM¶; BoFiN-HEOM (the bosonic and fermionic HEOM solver) was a much more; flexible re-write of the original QuTiP HSolverDL that added support for; both bosonic and fermionic baths and for baths to be specified directly via; their correlation function expansion coefficients. Its authors were; Neill Lambert, Tarun Raheja, Shahnawaz Ahmed, and Alexander Pitchford.; BoFiN was written outside of QuTiP and is can still be found in its original; repository at https://github.com/tehruhn/bofin.; The construction of the right-hand side matrix for BoFiN was slow, so; BoFiN-fast, a hybrid C++ and Python implementation, was written that performed; the right-hand side construction in C++. It was otherwise identical to the; pure Python version. BoFiN-fast can be found at; https://github.com/tehruhn/bofin_fast.; BoFiN also came with an extensive set of example notebooks that are available; at https://github.com/tehruhn/bofin/tree/main/examples. Current implementation¶; The current implementation is a rewrite of BoFiN in pure Python. It’s; right-hand side construction has similar speed to BoFiN-fast, but is written; in pure Python. Built-in implementations of a variety of different baths; are provided, and a single solver is used for both fermionic and bosonic baths.; Multiple baths of the same kind (either fermionic or bosonic) may be; specified in a single problem, and there is good support for working with; the auxiliary density operator (ADO) state and extracting information from it.; The code was written by Neill Lambert and Simon Cross. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/heom/history.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/heom/history.html
https://qutip.org/docs/4.7/guide/heom/history.html:1594,Integrability,interface,interface,1594,"n of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Hierarchical Equations of Motion »; Previous implementations. Previous implementations¶; The current HEOM implementation in QuTiP is the latest in a succession of HEOM; implementations by various contributors:. HSolverDL¶; The original HEOM solver was implemented by Neill Lambert, Anubhav Vardhan,; and Alexander Pitchford and is still available as; qutip.nonmarkov.dlheom_solver.HSolverDL and only directly provided; support for the Drude-Lorentz bath although there was the possibility of; sub-classing the solver to implement other baths.; A compatible interface using the current implementation is available under the; same name in qutip.nonmarkov.heom.HSolverDL. BoFiN-HEOM¶; BoFiN-HEOM (the bosonic and fermionic HEOM solver) was a much more; flexible re-write of the original QuTiP HSolverDL that added support for; both bosonic and fermionic baths and for baths to be specified directly via; their correlation function expansion coefficients. Its authors were; Neill Lambert, Tarun Raheja, Shahnawaz Ahmed, and Alexander Pitchford.; BoFiN was written outside of QuTiP and is can still be found in its original; repository at https://github.com/tehruhn/bofin.; The construction of the right-hand side matrix for BoFiN was slow, so; BoFiN-fast, a hybrid C++ and Python implementation, was written that performed; the right-hand side construction in C++. It was otherwise identical to the; pure Python version. BoFiN-fast can be found at; https://github.com/tehruhn/bofin_fast.; BoFiN also came with an extensive set of example notebooks that are available; at https://github.com/tehruhn",MatchSource.WIKI,docs/4.7/guide/heom/history.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/heom/history.html
https://qutip.org/docs/4.7/guide/heom/history.html:1787,Modifiability,flexible,flexible,1787," of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Hierarchical Equations of Motion »; Previous implementations. Previous implementations¶; The current HEOM implementation in QuTiP is the latest in a succession of HEOM; implementations by various contributors:. HSolverDL¶; The original HEOM solver was implemented by Neill Lambert, Anubhav Vardhan,; and Alexander Pitchford and is still available as; qutip.nonmarkov.dlheom_solver.HSolverDL and only directly provided; support for the Drude-Lorentz bath although there was the possibility of; sub-classing the solver to implement other baths.; A compatible interface using the current implementation is available under the; same name in qutip.nonmarkov.heom.HSolverDL. BoFiN-HEOM¶; BoFiN-HEOM (the bosonic and fermionic HEOM solver) was a much more; flexible re-write of the original QuTiP HSolverDL that added support for; both bosonic and fermionic baths and for baths to be specified directly via; their correlation function expansion coefficients. Its authors were; Neill Lambert, Tarun Raheja, Shahnawaz Ahmed, and Alexander Pitchford.; BoFiN was written outside of QuTiP and is can still be found in its original; repository at https://github.com/tehruhn/bofin.; The construction of the right-hand side matrix for BoFiN was slow, so; BoFiN-fast, a hybrid C++ and Python implementation, was written that performed; the right-hand side construction in C++. It was otherwise identical to the; pure Python version. BoFiN-fast can be found at; https://github.com/tehruhn/bofin_fast.; BoFiN also came with an extensive set of example notebooks that are available; at https://github.com/tehruhn/bofin/tree/main/examples. Current implementation¶; The current implementation is a rewrite of BoFiN in pure Python. It’s; right-hand side construction has similar speed to BoFiN-fast, but is written; in pure Python. ",MatchSource.WIKI,docs/4.7/guide/heom/history.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/heom/history.html
https://qutip.org/docs/4.7/guide/heom/history.html:2714,Modifiability,rewrite,rewrite,2714," for the Drude-Lorentz bath although there was the possibility of; sub-classing the solver to implement other baths.; A compatible interface using the current implementation is available under the; same name in qutip.nonmarkov.heom.HSolverDL. BoFiN-HEOM¶; BoFiN-HEOM (the bosonic and fermionic HEOM solver) was a much more; flexible re-write of the original QuTiP HSolverDL that added support for; both bosonic and fermionic baths and for baths to be specified directly via; their correlation function expansion coefficients. Its authors were; Neill Lambert, Tarun Raheja, Shahnawaz Ahmed, and Alexander Pitchford.; BoFiN was written outside of QuTiP and is can still be found in its original; repository at https://github.com/tehruhn/bofin.; The construction of the right-hand side matrix for BoFiN was slow, so; BoFiN-fast, a hybrid C++ and Python implementation, was written that performed; the right-hand side construction in C++. It was otherwise identical to the; pure Python version. BoFiN-fast can be found at; https://github.com/tehruhn/bofin_fast.; BoFiN also came with an extensive set of example notebooks that are available; at https://github.com/tehruhn/bofin/tree/main/examples. Current implementation¶; The current implementation is a rewrite of BoFiN in pure Python. It’s; right-hand side construction has similar speed to BoFiN-fast, but is written; in pure Python. Built-in implementations of a variety of different baths; are provided, and a single solver is used for both fermionic and bosonic baths.; Multiple baths of the same kind (either fermionic or bosonic) may be; specified in a single problem, and there is good support for working with; the auxiliary density operator (ADO) state and extracting information from it.; The code was written by Neill Lambert and Simon Cross. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/heom/history.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/heom/history.html
https://qutip.org/docs/4.7/guide/heom/history.html:2346,Performance,perform,performed,2346," by Neill Lambert, Anubhav Vardhan,; and Alexander Pitchford and is still available as; qutip.nonmarkov.dlheom_solver.HSolverDL and only directly provided; support for the Drude-Lorentz bath although there was the possibility of; sub-classing the solver to implement other baths.; A compatible interface using the current implementation is available under the; same name in qutip.nonmarkov.heom.HSolverDL. BoFiN-HEOM¶; BoFiN-HEOM (the bosonic and fermionic HEOM solver) was a much more; flexible re-write of the original QuTiP HSolverDL that added support for; both bosonic and fermionic baths and for baths to be specified directly via; their correlation function expansion coefficients. Its authors were; Neill Lambert, Tarun Raheja, Shahnawaz Ahmed, and Alexander Pitchford.; BoFiN was written outside of QuTiP and is can still be found in its original; repository at https://github.com/tehruhn/bofin.; The construction of the right-hand side matrix for BoFiN was slow, so; BoFiN-fast, a hybrid C++ and Python implementation, was written that performed; the right-hand side construction in C++. It was otherwise identical to the; pure Python version. BoFiN-fast can be found at; https://github.com/tehruhn/bofin_fast.; BoFiN also came with an extensive set of example notebooks that are available; at https://github.com/tehruhn/bofin/tree/main/examples. Current implementation¶; The current implementation is a rewrite of BoFiN in pure Python. It’s; right-hand side construction has similar speed to BoFiN-fast, but is written; in pure Python. Built-in implementations of a variety of different baths; are provided, and a single solver is used for both fermionic and bosonic baths.; Multiple baths of the same kind (either fermionic or bosonic) may be; specified in a single problem, and there is good support for working with; the auxiliary density operator (ADO) state and extracting information from it.; The code was written by Neill Lambert and Simon Cross. Next ; Previous. © Copyright 2011 t",MatchSource.WIKI,docs/4.7/guide/heom/history.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/heom/history.html
https://qutip.org/docs/4.7/guide/heom/intro.html:2534,Deployability,update,updated,2534,"uTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Hierarchical Equations of Motion »; Introduction. Introduction¶; The Hierarchical Equations of Motion (HEOM) method was originally developed by; Tanimura and Kubo [TK89] in the context of physical chemistry to; ‘’exactly’’ solve a quantum system in contact with a bosonic environment,; encapsulated in the Hamiltonian:. \[H = H_s + \sum_k \omega_k a_k^{\dagger}a_k + \hat{Q} \sum_k g_k \left(a_k + a_k^{\dagger}\right).\]; As in other solutions to this problem, the properties of the bath are; encapsulated by its temperature and its spectral density,. \[J(\omega) = \pi \sum_k g_k^2 \delta(\omega-\omega_k).\]; In the HEOM, for bosonic baths, one typically chooses a Drude-Lorentz spectral; density:. \[J_D = \frac{2\lambda \gamma \omega}{(\gamma^2 + \omega^2)},\]; or an under-damped Brownian motion spectral density:. \[J_U = \frac{\alpha^2 \Gamma \omega}{[(\omega_c^2 - \omega^2)^2 + \Gamma^2 \omega^2]}.\]; Given the spectral density, the HEOM requires a decomposition of the bath; correlation functions in terms of exponentials. In Bosonic Environments we describe; how this is done with code examples, and how these expansions are passed to the; solver.; In addition to support for bosonic environments, QuTiP also provides support for; feriomic environments which is described in Fermionic Environments.; Both bosonic and fermionic environments are supported via a single solver,; HEOMSolver, that supports solving for both dynamics and steady-states. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/heom/intro.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/heom/intro.html
https://qutip.org/docs/4.7/guide/heom/references.html:1793,Deployability,update,updated,1793,". References — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Introduction; Bosonic Environments; Fermionic Environments; Previous implementations; References. Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Hierarchical Equations of Motion »; References. References¶. LACN19; Neill Lambert, Shahnawaz Ahmed, Mauro Cirio, and Franco Nori. Virtual excitations in the ultra-strongly-coupled spin-boson model: physical results from unphysical modes. arXiv preprint arXiv:1903.05892, 2019. Tan20; Yoshitaka Tanimura. Numerically “exact” approach to open quantum dynamics: the hierarchical equations of motion (heom). The Journal of Chemical Physics, 153(2):020901, 2020. URL: https://doi.org/10.1063/5.0011599, doi:10.1063/5.0011599. TK89; Yoshitaka Tanimura and Ryogo Kubo. Time evolution of a quantum system in contact with a nearly gaussian-markoffian noise bath. J. Phys. Soc. Jpn., 58(1):101–114, 1989. doi:10.1143/jpsj.58.101. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/heom/references.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/heom/references.html
https://qutip.org/docs/4.7/guide/qip/qip-basics.html:1984,Availability,avail,available,1984," Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Quantum Information Processing »; Quantum Information Processing. Quantum Information Processing¶. Introduction¶; The Quantum Information Processing (QIP) module aims at providing basic tools for quantum computing simulation both for simple quantum algorithm design and for experimental realization. It offers two different approaches, one with QubitCircuit calculating unitary evolution under quantum gates by matrix product, another called Processor using open system solvers in QuTiP to simulate noisy quantum device. Quantum Circuit¶; The most common model for quantum computing is the quantum circuit model.; In QuTiP, we use QubitCircuit to represent a quantum circuit.; The circuit is characterized by registers and gates:. Registers: The argument N specifies the number of qubit registers in the circuit; and the argument num_cbits (optional) specifies the number of classical bits available for measurement; and control.; Gates: Each quantum gate is saved as a class object Gate; with information such as gate name, target qubits and arguments.; Gates can also be controlled on a classical bit by specifying the register number; with the argument classical_controls.; Measurements: We can also carry out measurements on individual qubit (both in the middle and at the end of the circuit).; Each measurement is saved as a class object Measurement with parameters such as targets,; the target qubit on which the measurement will be carried out, and classical_store,; the index of the classical register which stores the result of the measurement. A circuit with the various gates and registers available is demonstrated below:; from qutip.qip.circuit import QubitCircuit, Gate; from qutip import tensor, basis. qc = QubitCircuit(N=2, num_cbits=1); swap_gate = Gate(name=""SWAP"", targets=[0, 1]). qc.add_gate(swap_gate); qc.a",MatchSource.WIKI,docs/4.7/guide/qip/qip-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-basics.html
https://qutip.org/docs/4.7/guide/qip/qip-basics.html:2695,Availability,avail,available,2695,"ircuit model.; In QuTiP, we use QubitCircuit to represent a quantum circuit.; The circuit is characterized by registers and gates:. Registers: The argument N specifies the number of qubit registers in the circuit; and the argument num_cbits (optional) specifies the number of classical bits available for measurement; and control.; Gates: Each quantum gate is saved as a class object Gate; with information such as gate name, target qubits and arguments.; Gates can also be controlled on a classical bit by specifying the register number; with the argument classical_controls.; Measurements: We can also carry out measurements on individual qubit (both in the middle and at the end of the circuit).; Each measurement is saved as a class object Measurement with parameters such as targets,; the target qubit on which the measurement will be carried out, and classical_store,; the index of the classical register which stores the result of the measurement. A circuit with the various gates and registers available is demonstrated below:; from qutip.qip.circuit import QubitCircuit, Gate; from qutip import tensor, basis. qc = QubitCircuit(N=2, num_cbits=1); swap_gate = Gate(name=""SWAP"", targets=[0, 1]). qc.add_gate(swap_gate); qc.add_measurement(""M0"", targets=[1], classical_store=0) # measurement gate; qc.add_gate(""CNOT"", controls=0, targets=1); qc.add_gate(""X"", targets=0, classical_controls=[0]) # classically controlled gate; qc.add_gate(swap_gate). print(qc.gates). Output:; [Gate(SWAP, targets=[0, 1], controls=None, classical controls=None, control_value=None),; Measurement(M0, target=[1], classical_store=0),; Gate(CNOT, targets=[1], controls=[0], classical controls=None, control_value=None),; Gate(X, targets=[0], controls=None, classical controls=[0], control_value=None),; Gate(SWAP, targets=[0, 1], controls=None, classical controls=None, control_value=None)]. Unitaries¶; There are a few useful functions associated with the circuit object. For example,; the propagators method returns",MatchSource.WIKI,docs/4.7/guide/qip/qip-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-basics.html
https://qutip.org/docs/4.7/guide/qip/qip-basics.html:9543,Availability,down,download,9543,"+0.j 0. -0.70710678j 0. +0.j; 0.70710678+0.j ]]. print(props[2]). Output:; Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = False; Qobj data =; [[1.+0.j 0.+0.j 0.+0.j 0.+0.j]; [0.+0.j 0.+1.j 0.+0.j 0.+0.j]; [0.+0.j 0.+0.j 1.+0.j 0.+0.j]; [0.+0.j 0.+0.j 0.+0.j 0.+1.j]]. Plotting a Quantum Circuit¶; A quantum circuit (described above) can directly be plotted using the QCircuit library (https://github.com/CQuIC/qcircuit).; QCiruit is a quantum circuit drawing application and is implemented directly into QuTiP.; The circuit image visualization requires LaTeX and ImageMagick for display.; The module automatically generates the LaTeX code for plotting the circuit,; produces the pdf and converts it to the png format. On Mac and Linux,; ImageMagick can be easily installed with the command conda install imagemagick if you have conda installed.; Otherwise, please follow the installation instructions on the ImageMagick documentation.; On windows, you need to download and install ImageMagick installer.; In addition, you also need perl (for pdfcrop) and; Ghostscript (additional dependency of ImageMagick for png conversion).; If you want to check whether all dependencies are installed,; see if the following three commands work correctly:; pdflatex, pdfcrop and magick anypdf.pdf anypdf.png,; where anypdf.pdf is any pdf file you have.; An example code for plotting the example quantum circuit from above is given:; from qutip.qip.circuit import QubitCircuit, Gate; # create the quantum circuit; qc = QubitCircuit(2, num_cbits=1); qc.add_gate(""CNOT"", controls=0, targets=1); qc.add_gate(""H"", targets=1); qc.add_gate(""ISWAP"", targets=[0,1]); qc.add_measurement(""M0"", targets=1, classical_store=0); # plot the quantum circuit; qc.png. Circuit simulation¶; There are two different ways to simulate the action of quantum circuits using QuTiP:. The first method utilizes unitary application through matrix products on the input states.; This method simulates circuits exa",MatchSource.WIKI,docs/4.7/guide/qip/qip-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-basics.html
https://qutip.org/docs/4.7/guide/qip/qip-basics.html:9346,Deployability,install,installed,9346,"shape = (4, 4), type = oper, isherm = False; Qobj data =; [[1. +0.j 0. +0.j 0. +0.j; 0. +0.j ]; [0. +0.j 0.70710678+0.j 0. +0.j; 0. -0.70710678j]; [0. +0.j 0. +0.j 1. +0.j; 0. +0.j ]; [0. +0.j 0. -0.70710678j 0. +0.j; 0.70710678+0.j ]]. print(props[2]). Output:; Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = False; Qobj data =; [[1.+0.j 0.+0.j 0.+0.j 0.+0.j]; [0.+0.j 0.+1.j 0.+0.j 0.+0.j]; [0.+0.j 0.+0.j 1.+0.j 0.+0.j]; [0.+0.j 0.+0.j 0.+0.j 0.+1.j]]. Plotting a Quantum Circuit¶; A quantum circuit (described above) can directly be plotted using the QCircuit library (https://github.com/CQuIC/qcircuit).; QCiruit is a quantum circuit drawing application and is implemented directly into QuTiP.; The circuit image visualization requires LaTeX and ImageMagick for display.; The module automatically generates the LaTeX code for plotting the circuit,; produces the pdf and converts it to the png format. On Mac and Linux,; ImageMagick can be easily installed with the command conda install imagemagick if you have conda installed.; Otherwise, please follow the installation instructions on the ImageMagick documentation.; On windows, you need to download and install ImageMagick installer.; In addition, you also need perl (for pdfcrop) and; Ghostscript (additional dependency of ImageMagick for png conversion).; If you want to check whether all dependencies are installed,; see if the following three commands work correctly:; pdflatex, pdfcrop and magick anypdf.pdf anypdf.png,; where anypdf.pdf is any pdf file you have.; An example code for plotting the example quantum circuit from above is given:; from qutip.qip.circuit import QubitCircuit, Gate; # create the quantum circuit; qc = QubitCircuit(2, num_cbits=1); qc.add_gate(""CNOT"", controls=0, targets=1); qc.add_gate(""H"", targets=1); qc.add_gate(""ISWAP"", targets=[0,1]); qc.add_measurement(""M0"", targets=1, classical_store=0); # plot the quantum circuit; qc.png. Circuit simulation¶; There are two different ",MatchSource.WIKI,docs/4.7/guide/qip/qip-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-basics.html
https://qutip.org/docs/4.7/guide/qip/qip-basics.html:9379,Deployability,install,install,9379,"shape = (4, 4), type = oper, isherm = False; Qobj data =; [[1. +0.j 0. +0.j 0. +0.j; 0. +0.j ]; [0. +0.j 0.70710678+0.j 0. +0.j; 0. -0.70710678j]; [0. +0.j 0. +0.j 1. +0.j; 0. +0.j ]; [0. +0.j 0. -0.70710678j 0. +0.j; 0.70710678+0.j ]]. print(props[2]). Output:; Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = False; Qobj data =; [[1.+0.j 0.+0.j 0.+0.j 0.+0.j]; [0.+0.j 0.+1.j 0.+0.j 0.+0.j]; [0.+0.j 0.+0.j 1.+0.j 0.+0.j]; [0.+0.j 0.+0.j 0.+0.j 0.+1.j]]. Plotting a Quantum Circuit¶; A quantum circuit (described above) can directly be plotted using the QCircuit library (https://github.com/CQuIC/qcircuit).; QCiruit is a quantum circuit drawing application and is implemented directly into QuTiP.; The circuit image visualization requires LaTeX and ImageMagick for display.; The module automatically generates the LaTeX code for plotting the circuit,; produces the pdf and converts it to the png format. On Mac and Linux,; ImageMagick can be easily installed with the command conda install imagemagick if you have conda installed.; Otherwise, please follow the installation instructions on the ImageMagick documentation.; On windows, you need to download and install ImageMagick installer.; In addition, you also need perl (for pdfcrop) and; Ghostscript (additional dependency of ImageMagick for png conversion).; If you want to check whether all dependencies are installed,; see if the following three commands work correctly:; pdflatex, pdfcrop and magick anypdf.pdf anypdf.png,; where anypdf.pdf is any pdf file you have.; An example code for plotting the example quantum circuit from above is given:; from qutip.qip.circuit import QubitCircuit, Gate; # create the quantum circuit; qc = QubitCircuit(2, num_cbits=1); qc.add_gate(""CNOT"", controls=0, targets=1); qc.add_gate(""H"", targets=1); qc.add_gate(""ISWAP"", targets=[0,1]); qc.add_measurement(""M0"", targets=1, classical_store=0); # plot the quantum circuit; qc.png. Circuit simulation¶; There are two different ",MatchSource.WIKI,docs/4.7/guide/qip/qip-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-basics.html
https://qutip.org/docs/4.7/guide/qip/qip-basics.html:9417,Deployability,install,installed,9417,"shape = (4, 4), type = oper, isherm = False; Qobj data =; [[1. +0.j 0. +0.j 0. +0.j; 0. +0.j ]; [0. +0.j 0.70710678+0.j 0. +0.j; 0. -0.70710678j]; [0. +0.j 0. +0.j 1. +0.j; 0. +0.j ]; [0. +0.j 0. -0.70710678j 0. +0.j; 0.70710678+0.j ]]. print(props[2]). Output:; Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = False; Qobj data =; [[1.+0.j 0.+0.j 0.+0.j 0.+0.j]; [0.+0.j 0.+1.j 0.+0.j 0.+0.j]; [0.+0.j 0.+0.j 1.+0.j 0.+0.j]; [0.+0.j 0.+0.j 0.+0.j 0.+1.j]]. Plotting a Quantum Circuit¶; A quantum circuit (described above) can directly be plotted using the QCircuit library (https://github.com/CQuIC/qcircuit).; QCiruit is a quantum circuit drawing application and is implemented directly into QuTiP.; The circuit image visualization requires LaTeX and ImageMagick for display.; The module automatically generates the LaTeX code for plotting the circuit,; produces the pdf and converts it to the png format. On Mac and Linux,; ImageMagick can be easily installed with the command conda install imagemagick if you have conda installed.; Otherwise, please follow the installation instructions on the ImageMagick documentation.; On windows, you need to download and install ImageMagick installer.; In addition, you also need perl (for pdfcrop) and; Ghostscript (additional dependency of ImageMagick for png conversion).; If you want to check whether all dependencies are installed,; see if the following three commands work correctly:; pdflatex, pdfcrop and magick anypdf.pdf anypdf.png,; where anypdf.pdf is any pdf file you have.; An example code for plotting the example quantum circuit from above is given:; from qutip.qip.circuit import QubitCircuit, Gate; # create the quantum circuit; qc = QubitCircuit(2, num_cbits=1); qc.add_gate(""CNOT"", controls=0, targets=1); qc.add_gate(""H"", targets=1); qc.add_gate(""ISWAP"", targets=[0,1]); qc.add_measurement(""M0"", targets=1, classical_store=0); # plot the quantum circuit; qc.png. Circuit simulation¶; There are two different ",MatchSource.WIKI,docs/4.7/guide/qip/qip-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-basics.html
https://qutip.org/docs/4.7/guide/qip/qip-basics.html:9458,Deployability,install,installation,9458,"710678+0.j 0. +0.j; 0. -0.70710678j]; [0. +0.j 0. +0.j 1. +0.j; 0. +0.j ]; [0. +0.j 0. -0.70710678j 0. +0.j; 0.70710678+0.j ]]. print(props[2]). Output:; Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = False; Qobj data =; [[1.+0.j 0.+0.j 0.+0.j 0.+0.j]; [0.+0.j 0.+1.j 0.+0.j 0.+0.j]; [0.+0.j 0.+0.j 1.+0.j 0.+0.j]; [0.+0.j 0.+0.j 0.+0.j 0.+1.j]]. Plotting a Quantum Circuit¶; A quantum circuit (described above) can directly be plotted using the QCircuit library (https://github.com/CQuIC/qcircuit).; QCiruit is a quantum circuit drawing application and is implemented directly into QuTiP.; The circuit image visualization requires LaTeX and ImageMagick for display.; The module automatically generates the LaTeX code for plotting the circuit,; produces the pdf and converts it to the png format. On Mac and Linux,; ImageMagick can be easily installed with the command conda install imagemagick if you have conda installed.; Otherwise, please follow the installation instructions on the ImageMagick documentation.; On windows, you need to download and install ImageMagick installer.; In addition, you also need perl (for pdfcrop) and; Ghostscript (additional dependency of ImageMagick for png conversion).; If you want to check whether all dependencies are installed,; see if the following three commands work correctly:; pdflatex, pdfcrop and magick anypdf.pdf anypdf.png,; where anypdf.pdf is any pdf file you have.; An example code for plotting the example quantum circuit from above is given:; from qutip.qip.circuit import QubitCircuit, Gate; # create the quantum circuit; qc = QubitCircuit(2, num_cbits=1); qc.add_gate(""CNOT"", controls=0, targets=1); qc.add_gate(""H"", targets=1); qc.add_gate(""ISWAP"", targets=[0,1]); qc.add_measurement(""M0"", targets=1, classical_store=0); # plot the quantum circuit; qc.png. Circuit simulation¶; There are two different ways to simulate the action of quantum circuits using QuTiP:. The first method utilizes unitary application ",MatchSource.WIKI,docs/4.7/guide/qip/qip-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-basics.html
https://qutip.org/docs/4.7/guide/qip/qip-basics.html:9556,Deployability,install,install,9556,"+0.j 0. -0.70710678j 0. +0.j; 0.70710678+0.j ]]. print(props[2]). Output:; Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = False; Qobj data =; [[1.+0.j 0.+0.j 0.+0.j 0.+0.j]; [0.+0.j 0.+1.j 0.+0.j 0.+0.j]; [0.+0.j 0.+0.j 1.+0.j 0.+0.j]; [0.+0.j 0.+0.j 0.+0.j 0.+1.j]]. Plotting a Quantum Circuit¶; A quantum circuit (described above) can directly be plotted using the QCircuit library (https://github.com/CQuIC/qcircuit).; QCiruit is a quantum circuit drawing application and is implemented directly into QuTiP.; The circuit image visualization requires LaTeX and ImageMagick for display.; The module automatically generates the LaTeX code for plotting the circuit,; produces the pdf and converts it to the png format. On Mac and Linux,; ImageMagick can be easily installed with the command conda install imagemagick if you have conda installed.; Otherwise, please follow the installation instructions on the ImageMagick documentation.; On windows, you need to download and install ImageMagick installer.; In addition, you also need perl (for pdfcrop) and; Ghostscript (additional dependency of ImageMagick for png conversion).; If you want to check whether all dependencies are installed,; see if the following three commands work correctly:; pdflatex, pdfcrop and magick anypdf.pdf anypdf.png,; where anypdf.pdf is any pdf file you have.; An example code for plotting the example quantum circuit from above is given:; from qutip.qip.circuit import QubitCircuit, Gate; # create the quantum circuit; qc = QubitCircuit(2, num_cbits=1); qc.add_gate(""CNOT"", controls=0, targets=1); qc.add_gate(""H"", targets=1); qc.add_gate(""ISWAP"", targets=[0,1]); qc.add_measurement(""M0"", targets=1, classical_store=0); # plot the quantum circuit; qc.png. Circuit simulation¶; There are two different ways to simulate the action of quantum circuits using QuTiP:. The first method utilizes unitary application through matrix products on the input states.; This method simulates circuits exa",MatchSource.WIKI,docs/4.7/guide/qip/qip-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-basics.html
https://qutip.org/docs/4.7/guide/qip/qip-basics.html:9576,Deployability,install,installer,9576,"+0.j 0. -0.70710678j 0. +0.j; 0.70710678+0.j ]]. print(props[2]). Output:; Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = False; Qobj data =; [[1.+0.j 0.+0.j 0.+0.j 0.+0.j]; [0.+0.j 0.+1.j 0.+0.j 0.+0.j]; [0.+0.j 0.+0.j 1.+0.j 0.+0.j]; [0.+0.j 0.+0.j 0.+0.j 0.+1.j]]. Plotting a Quantum Circuit¶; A quantum circuit (described above) can directly be plotted using the QCircuit library (https://github.com/CQuIC/qcircuit).; QCiruit is a quantum circuit drawing application and is implemented directly into QuTiP.; The circuit image visualization requires LaTeX and ImageMagick for display.; The module automatically generates the LaTeX code for plotting the circuit,; produces the pdf and converts it to the png format. On Mac and Linux,; ImageMagick can be easily installed with the command conda install imagemagick if you have conda installed.; Otherwise, please follow the installation instructions on the ImageMagick documentation.; On windows, you need to download and install ImageMagick installer.; In addition, you also need perl (for pdfcrop) and; Ghostscript (additional dependency of ImageMagick for png conversion).; If you want to check whether all dependencies are installed,; see if the following three commands work correctly:; pdflatex, pdfcrop and magick anypdf.pdf anypdf.png,; where anypdf.pdf is any pdf file you have.; An example code for plotting the example quantum circuit from above is given:; from qutip.qip.circuit import QubitCircuit, Gate; # create the quantum circuit; qc = QubitCircuit(2, num_cbits=1); qc.add_gate(""CNOT"", controls=0, targets=1); qc.add_gate(""H"", targets=1); qc.add_gate(""ISWAP"", targets=[0,1]); qc.add_measurement(""M0"", targets=1, classical_store=0); # plot the quantum circuit; qc.png. Circuit simulation¶; There are two different ways to simulate the action of quantum circuits using QuTiP:. The first method utilizes unitary application through matrix products on the input states.; This method simulates circuits exa",MatchSource.WIKI,docs/4.7/guide/qip/qip-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-basics.html
https://qutip.org/docs/4.7/guide/qip/qip-basics.html:9761,Deployability,install,installed,9761,"]; [0.+0.j 0.+0.j 1.+0.j 0.+0.j]; [0.+0.j 0.+0.j 0.+0.j 0.+1.j]]. Plotting a Quantum Circuit¶; A quantum circuit (described above) can directly be plotted using the QCircuit library (https://github.com/CQuIC/qcircuit).; QCiruit is a quantum circuit drawing application and is implemented directly into QuTiP.; The circuit image visualization requires LaTeX and ImageMagick for display.; The module automatically generates the LaTeX code for plotting the circuit,; produces the pdf and converts it to the png format. On Mac and Linux,; ImageMagick can be easily installed with the command conda install imagemagick if you have conda installed.; Otherwise, please follow the installation instructions on the ImageMagick documentation.; On windows, you need to download and install ImageMagick installer.; In addition, you also need perl (for pdfcrop) and; Ghostscript (additional dependency of ImageMagick for png conversion).; If you want to check whether all dependencies are installed,; see if the following three commands work correctly:; pdflatex, pdfcrop and magick anypdf.pdf anypdf.png,; where anypdf.pdf is any pdf file you have.; An example code for plotting the example quantum circuit from above is given:; from qutip.qip.circuit import QubitCircuit, Gate; # create the quantum circuit; qc = QubitCircuit(2, num_cbits=1); qc.add_gate(""CNOT"", controls=0, targets=1); qc.add_gate(""H"", targets=1); qc.add_gate(""ISWAP"", targets=[0,1]); qc.add_measurement(""M0"", targets=1, classical_store=0); # plot the quantum circuit; qc.png. Circuit simulation¶; There are two different ways to simulate the action of quantum circuits using QuTiP:. The first method utilizes unitary application through matrix products on the input states.; This method simulates circuits exactly in a deterministic manner. This is achieved through; CircuitSimulator. A short guide to exact simulation can be; found at Operator-level circuit simulation. The teleportation notebook is also useful as an example.; A different me",MatchSource.WIKI,docs/4.7/guide/qip/qip-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-basics.html
https://qutip.org/docs/4.7/guide/qip/qip-basics.html:11169,Deployability,update,updated,11169,"converts it to the png format. On Mac and Linux,; ImageMagick can be easily installed with the command conda install imagemagick if you have conda installed.; Otherwise, please follow the installation instructions on the ImageMagick documentation.; On windows, you need to download and install ImageMagick installer.; In addition, you also need perl (for pdfcrop) and; Ghostscript (additional dependency of ImageMagick for png conversion).; If you want to check whether all dependencies are installed,; see if the following three commands work correctly:; pdflatex, pdfcrop and magick anypdf.pdf anypdf.png,; where anypdf.pdf is any pdf file you have.; An example code for plotting the example quantum circuit from above is given:; from qutip.qip.circuit import QubitCircuit, Gate; # create the quantum circuit; qc = QubitCircuit(2, num_cbits=1); qc.add_gate(""CNOT"", controls=0, targets=1); qc.add_gate(""H"", targets=1); qc.add_gate(""ISWAP"", targets=[0,1]); qc.add_measurement(""M0"", targets=1, classical_store=0); # plot the quantum circuit; qc.png. Circuit simulation¶; There are two different ways to simulate the action of quantum circuits using QuTiP:. The first method utilizes unitary application through matrix products on the input states.; This method simulates circuits exactly in a deterministic manner. This is achieved through; CircuitSimulator. A short guide to exact simulation can be; found at Operator-level circuit simulation. The teleportation notebook is also useful as an example.; A different method of circuit simulation employs driving Hamiltonians with the ability to; simulate circuits in the presence of noise. This can be achieved through the various classes; in qutip.qip.device. A short guide to processors for QIP simulation can be found at Pulse-level circuit simulation. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/qip/qip-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-basics.html
https://qutip.org/docs/4.7/guide/qip/qip-basics.html:6825,Energy Efficiency,reduce,reduced,6825,"tation around x axis. “CRY”; Controlled rotation around y axis. “CRZ”; Controlled rotation around z axis. “CX”; Controlled X gate. “CY”; Controlled Y gate. “CZ”; Controlled Z gate. “CS”; Controlled S gate. “CT”; Controlled T gate. “CPHASE”; Controlled phase gate. “CNOT”; Controlled NOT gate. “CSIGN”; Same as CPHASE. “QASMU”; U rotation gate used as a primitive in the QASM standard. “BERKELEY”; Berkeley gate. “SWAPalpha”; SWAPalpha gate. “SWAP”; Swap the states of two qubits. “ISWAP”; Swap gate with additional phase for 01 and 10 states. “SQRTSWAP”; Square root of the SWAP gate. “SQRTISWAP”; Square root of the ISWAP gate. “FREDKIN”; Fredkin gate. “TOFFOLI”; Toffoli gate. “GLOBALPHASE”; Global phase. For some of the gates listed above, QubitCircuit also has a primitive resolve_gates method that decomposes them into elementary gate sets such as CNOT or SWAP with single-qubit gates (RX, RY and RZ). However, this method is not fully optimized. It is very likely that the depth of the circuit can be further reduced by merging quantum gates. It is required that the gate resolution be carried out before the measurements to the circuit are added.; Custom Gates; In addition to these pre-defined gates, QuTiP also allows the user to define their own gate.; The following example shows how to define a customized gate.; The key step is to define a; gate function returning a qutip.Qobj and save it in the attribute user_gates.; from qutip.qip.circuit import Gate; from qutip.qip.operations import rx. def user_gate1(arg_value):; # controlled rotation X; mat = np.zeros((4, 4), dtype=np.complex); mat[0, 0] = mat[1, 1] = 1.; mat[2:4, 2:4] = rx(arg_value); return Qobj(mat, dims=[[2, 2], [2, 2]]). def user_gate2():; # S gate; mat = np.array([[1., 0],; [0., 1.j]]); return Qobj(mat, dims=[[2], [2]]). qc = QubitCircuit(2); qc.user_gates = {""CTRLRX"": user_gate1,; ""S"" : user_gate2}. # qubit 0 controls qubit 1; qc.add_gate(""CTRLRX"", targets=[0,1], arg_value=np.pi/2). # qubit 1 controls qubit 0; qc",MatchSource.WIKI,docs/4.7/guide/qip/qip-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-basics.html
https://qutip.org/docs/4.7/guide/qip/qip-basics.html:9663,Integrability,depend,dependency,9663,"= [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = False; Qobj data =; [[1.+0.j 0.+0.j 0.+0.j 0.+0.j]; [0.+0.j 0.+1.j 0.+0.j 0.+0.j]; [0.+0.j 0.+0.j 1.+0.j 0.+0.j]; [0.+0.j 0.+0.j 0.+0.j 0.+1.j]]. Plotting a Quantum Circuit¶; A quantum circuit (described above) can directly be plotted using the QCircuit library (https://github.com/CQuIC/qcircuit).; QCiruit is a quantum circuit drawing application and is implemented directly into QuTiP.; The circuit image visualization requires LaTeX and ImageMagick for display.; The module automatically generates the LaTeX code for plotting the circuit,; produces the pdf and converts it to the png format. On Mac and Linux,; ImageMagick can be easily installed with the command conda install imagemagick if you have conda installed.; Otherwise, please follow the installation instructions on the ImageMagick documentation.; On windows, you need to download and install ImageMagick installer.; In addition, you also need perl (for pdfcrop) and; Ghostscript (additional dependency of ImageMagick for png conversion).; If you want to check whether all dependencies are installed,; see if the following three commands work correctly:; pdflatex, pdfcrop and magick anypdf.pdf anypdf.png,; where anypdf.pdf is any pdf file you have.; An example code for plotting the example quantum circuit from above is given:; from qutip.qip.circuit import QubitCircuit, Gate; # create the quantum circuit; qc = QubitCircuit(2, num_cbits=1); qc.add_gate(""CNOT"", controls=0, targets=1); qc.add_gate(""H"", targets=1); qc.add_gate(""ISWAP"", targets=[0,1]); qc.add_measurement(""M0"", targets=1, classical_store=0); # plot the quantum circuit; qc.png. Circuit simulation¶; There are two different ways to simulate the action of quantum circuits using QuTiP:. The first method utilizes unitary application through matrix products on the input states.; This method simulates circuits exactly in a deterministic manner. This is achieved through; CircuitSimulator. A short guide to exa",MatchSource.WIKI,docs/4.7/guide/qip/qip-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-basics.html
https://qutip.org/docs/4.7/guide/qip/qip-basics.html:9744,Integrability,depend,dependencies,9744,"]; [0.+0.j 0.+0.j 1.+0.j 0.+0.j]; [0.+0.j 0.+0.j 0.+0.j 0.+1.j]]. Plotting a Quantum Circuit¶; A quantum circuit (described above) can directly be plotted using the QCircuit library (https://github.com/CQuIC/qcircuit).; QCiruit is a quantum circuit drawing application and is implemented directly into QuTiP.; The circuit image visualization requires LaTeX and ImageMagick for display.; The module automatically generates the LaTeX code for plotting the circuit,; produces the pdf and converts it to the png format. On Mac and Linux,; ImageMagick can be easily installed with the command conda install imagemagick if you have conda installed.; Otherwise, please follow the installation instructions on the ImageMagick documentation.; On windows, you need to download and install ImageMagick installer.; In addition, you also need perl (for pdfcrop) and; Ghostscript (additional dependency of ImageMagick for png conversion).; If you want to check whether all dependencies are installed,; see if the following three commands work correctly:; pdflatex, pdfcrop and magick anypdf.pdf anypdf.png,; where anypdf.pdf is any pdf file you have.; An example code for plotting the example quantum circuit from above is given:; from qutip.qip.circuit import QubitCircuit, Gate; # create the quantum circuit; qc = QubitCircuit(2, num_cbits=1); qc.add_gate(""CNOT"", controls=0, targets=1); qc.add_gate(""H"", targets=1); qc.add_gate(""ISWAP"", targets=[0,1]); qc.add_measurement(""M0"", targets=1, classical_store=0); # plot the quantum circuit; qc.png. Circuit simulation¶; There are two different ways to simulate the action of quantum circuits using QuTiP:. The first method utilizes unitary application through matrix products on the input states.; This method simulates circuits exactly in a deterministic manner. This is achieved through; CircuitSimulator. A short guide to exact simulation can be; found at Operator-level circuit simulation. The teleportation notebook is also useful as an example.; A different me",MatchSource.WIKI,docs/4.7/guide/qip/qip-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-basics.html
https://qutip.org/docs/4.7/guide/qip/qip-basics.html:6751,Performance,optimiz,optimized,6751,"rd gate. “PHASEGATE”; Add a phase one the state 1. “CRX”; Controlled rotation around x axis. “CRY”; Controlled rotation around y axis. “CRZ”; Controlled rotation around z axis. “CX”; Controlled X gate. “CY”; Controlled Y gate. “CZ”; Controlled Z gate. “CS”; Controlled S gate. “CT”; Controlled T gate. “CPHASE”; Controlled phase gate. “CNOT”; Controlled NOT gate. “CSIGN”; Same as CPHASE. “QASMU”; U rotation gate used as a primitive in the QASM standard. “BERKELEY”; Berkeley gate. “SWAPalpha”; SWAPalpha gate. “SWAP”; Swap the states of two qubits. “ISWAP”; Swap gate with additional phase for 01 and 10 states. “SQRTSWAP”; Square root of the SWAP gate. “SQRTISWAP”; Square root of the ISWAP gate. “FREDKIN”; Fredkin gate. “TOFFOLI”; Toffoli gate. “GLOBALPHASE”; Global phase. For some of the gates listed above, QubitCircuit also has a primitive resolve_gates method that decomposes them into elementary gate sets such as CNOT or SWAP with single-qubit gates (RX, RY and RZ). However, this method is not fully optimized. It is very likely that the depth of the circuit can be further reduced by merging quantum gates. It is required that the gate resolution be carried out before the measurements to the circuit are added.; Custom Gates; In addition to these pre-defined gates, QuTiP also allows the user to define their own gate.; The following example shows how to define a customized gate.; The key step is to define a; gate function returning a qutip.Qobj and save it in the attribute user_gates.; from qutip.qip.circuit import Gate; from qutip.qip.operations import rx. def user_gate1(arg_value):; # controlled rotation X; mat = np.zeros((4, 4), dtype=np.complex); mat[0, 0] = mat[1, 1] = 1.; mat[2:4, 2:4] = rx(arg_value); return Qobj(mat, dims=[[2, 2], [2, 2]]). def user_gate2():; # S gate; mat = np.array([[1., 0],; [0., 1.j]]); return Qobj(mat, dims=[[2], [2]]). qc = QubitCircuit(2); qc.user_gates = {""CTRLRX"": user_gate1,; ""S"" : user_gate2}. # qubit 0 controls qubit 1; qc.add_gate(""CTR",MatchSource.WIKI,docs/4.7/guide/qip/qip-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-basics.html
https://qutip.org/docs/4.7/guide/qip/qip-basics.html:1328,Usability,simpl,simple,1328,"and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Quantum Information Processing; Introduction; Quantum Circuit; Unitaries; Gates; Plotting a Quantum Circuit; Circuit simulation. Operator-level circuit simulation; Pulse-level circuit simulation. Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Quantum Information Processing »; Quantum Information Processing. Quantum Information Processing¶. Introduction¶; The Quantum Information Processing (QIP) module aims at providing basic tools for quantum computing simulation both for simple quantum algorithm design and for experimental realization. It offers two different approaches, one with QubitCircuit calculating unitary evolution under quantum gates by matrix product, another called Processor using open system solvers in QuTiP to simulate noisy quantum device. Quantum Circuit¶; The most common model for quantum computing is the quantum circuit model.; In QuTiP, we use QubitCircuit to represent a quantum circuit.; The circuit is characterized by registers and gates:. Registers: The argument N specifies the number of qubit registers in the circuit; and the argument num_cbits (optional) specifies the number of classical bits available for measurement; and control.; Gates: Each quantum gate is saved as a class object Gate; with information such as gate name, target qubits and arguments.; Gates can also be controlled on a classical bit by specifying the register number; with the argument classical_controls.; Measurements: We can a",MatchSource.WIKI,docs/4.7/guide/qip/qip-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-basics.html
https://qutip.org/docs/4.7/guide/qip/qip-basics.html:10636,Usability,guid,guide,10636,"converts it to the png format. On Mac and Linux,; ImageMagick can be easily installed with the command conda install imagemagick if you have conda installed.; Otherwise, please follow the installation instructions on the ImageMagick documentation.; On windows, you need to download and install ImageMagick installer.; In addition, you also need perl (for pdfcrop) and; Ghostscript (additional dependency of ImageMagick for png conversion).; If you want to check whether all dependencies are installed,; see if the following three commands work correctly:; pdflatex, pdfcrop and magick anypdf.pdf anypdf.png,; where anypdf.pdf is any pdf file you have.; An example code for plotting the example quantum circuit from above is given:; from qutip.qip.circuit import QubitCircuit, Gate; # create the quantum circuit; qc = QubitCircuit(2, num_cbits=1); qc.add_gate(""CNOT"", controls=0, targets=1); qc.add_gate(""H"", targets=1); qc.add_gate(""ISWAP"", targets=[0,1]); qc.add_measurement(""M0"", targets=1, classical_store=0); # plot the quantum circuit; qc.png. Circuit simulation¶; There are two different ways to simulate the action of quantum circuits using QuTiP:. The first method utilizes unitary application through matrix products on the input states.; This method simulates circuits exactly in a deterministic manner. This is achieved through; CircuitSimulator. A short guide to exact simulation can be; found at Operator-level circuit simulation. The teleportation notebook is also useful as an example.; A different method of circuit simulation employs driving Hamiltonians with the ability to; simulate circuits in the presence of noise. This can be achieved through the various classes; in qutip.qip.device. A short guide to processors for QIP simulation can be found at Pulse-level circuit simulation. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/qip/qip-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-basics.html
https://qutip.org/docs/4.7/guide/qip/qip-basics.html:10986,Usability,guid,guide,10986,"converts it to the png format. On Mac and Linux,; ImageMagick can be easily installed with the command conda install imagemagick if you have conda installed.; Otherwise, please follow the installation instructions on the ImageMagick documentation.; On windows, you need to download and install ImageMagick installer.; In addition, you also need perl (for pdfcrop) and; Ghostscript (additional dependency of ImageMagick for png conversion).; If you want to check whether all dependencies are installed,; see if the following three commands work correctly:; pdflatex, pdfcrop and magick anypdf.pdf anypdf.png,; where anypdf.pdf is any pdf file you have.; An example code for plotting the example quantum circuit from above is given:; from qutip.qip.circuit import QubitCircuit, Gate; # create the quantum circuit; qc = QubitCircuit(2, num_cbits=1); qc.add_gate(""CNOT"", controls=0, targets=1); qc.add_gate(""H"", targets=1); qc.add_gate(""ISWAP"", targets=[0,1]); qc.add_measurement(""M0"", targets=1, classical_store=0); # plot the quantum circuit; qc.png. Circuit simulation¶; There are two different ways to simulate the action of quantum circuits using QuTiP:. The first method utilizes unitary application through matrix products on the input states.; This method simulates circuits exactly in a deterministic manner. This is achieved through; CircuitSimulator. A short guide to exact simulation can be; found at Operator-level circuit simulation. The teleportation notebook is also useful as an example.; A different method of circuit simulation employs driving Hamiltonians with the ability to; simulate circuits in the presence of noise. This can be achieved through the various classes; in qutip.qip.device. A short guide to processors for QIP simulation can be found at Pulse-level circuit simulation. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/qip/qip-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-basics.html
https://qutip.org/docs/4.7/guide/qip/qip-processor.html:4627,Availability,avail,available,4627,"ferent physical realizations. They differ mainly in how to find the control pulse for a quantum circuit, which gives birth to different sub-classes:. Processor; ├── ModelProcessor; │ ├── DispersiveCavityQED; │ └── SpinChain; └── OptPulseProcessor. In general, there are two ways to find the control pulses. The first one, ModelProcessor, is more experiment-oriented and based on physical models. A universal set of; gates is defined in the processor as well as the pulse implementing them in this particular physical model. This is usually the case where control pulses realizing those gates are well known and can be concatenated to realize the whole quantum circuits. Two realizations have already been implemented: the spin chain and the Cavity QED model for quantum computing. In those models, the driving Hamiltonians are predefined. Another approach, based on the optimal control module in QuTiP (see Quantum Optimal Control), is called OptPulseProcessor. In this subclass, one only defines the available Hamiltonians in their system. The processor then uses algorithms to find the optimal control pulses that realize the desired unitary evolution.; Despite this difference, the logic behind all processors is the same:. One defines a processor by a list of available Hamiltonians and, as explained later, hardware-dependent noise. In model based processors, the Hamiltonians are predefined and one only needs to give the device parameters like frequency and interaction strength.; The control pulse coefficients and time slices are either specified by the user or calculated by the method load_circuit, which takes a QubitCircuit and find the control pulse for this evolution.; The processor calculates the evolution using the QuTiP solvers. Collapse operators can be added to simulate decoherence. The method run_state returns a object qutip.solver.Result. It is also possible to calculate the evolution analytically with matrix exponentiation by setting analytical=True. A list of the matrice",MatchSource.WIKI,docs/4.7/guide/qip/qip-processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-processor.html
https://qutip.org/docs/4.7/guide/qip/qip-processor.html:4890,Availability,avail,available,4890," find the control pulses. The first one, ModelProcessor, is more experiment-oriented and based on physical models. A universal set of; gates is defined in the processor as well as the pulse implementing them in this particular physical model. This is usually the case where control pulses realizing those gates are well known and can be concatenated to realize the whole quantum circuits. Two realizations have already been implemented: the spin chain and the Cavity QED model for quantum computing. In those models, the driving Hamiltonians are predefined. Another approach, based on the optimal control module in QuTiP (see Quantum Optimal Control), is called OptPulseProcessor. In this subclass, one only defines the available Hamiltonians in their system. The processor then uses algorithms to find the optimal control pulses that realize the desired unitary evolution.; Despite this difference, the logic behind all processors is the same:. One defines a processor by a list of available Hamiltonians and, as explained later, hardware-dependent noise. In model based processors, the Hamiltonians are predefined and one only needs to give the device parameters like frequency and interaction strength.; The control pulse coefficients and time slices are either specified by the user or calculated by the method load_circuit, which takes a QubitCircuit and find the control pulse for this evolution.; The processor calculates the evolution using the QuTiP solvers. Collapse operators can be added to simulate decoherence. The method run_state returns a object qutip.solver.Result. It is also possible to calculate the evolution analytically with matrix exponentiation by setting analytical=True. A list of the matrices representing the gates is returned just like for propagators. However, this does not consider the collapse operators or other noise. As the system size gets larger, this approach will become very inefficient.; In the following we describe the predefined subclasses for Processor:",MatchSource.WIKI,docs/4.7/guide/qip/qip-processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-processor.html
https://qutip.org/docs/4.7/guide/qip/qip-processor.html:8593,Availability,avail,available,8593,"e device parameters including the cavity frequency, qubits frequency, detuning and interaction strength etc. Note; The run_state method of DispersiveCavityQED; returns the full simulation result of the solver,; hence including the cavity.; To obtain the circuit result, one needs to first trace out the cavity state. OptPulseProcessor; The OptPulseProcessor uses the function in optimize_pulse_unitary in the optimal control module to find the control pulses. The Hamiltonian includes a drift part and a control part and only the control part will be optimized. The unitary evolution follows. \[U(\Delta t)=\exp(\rm{i} \cdot \Delta t [H_d + \sum_j u_j H_j] )\]; To let it find the optimal pulses, we need to give the parameters for optimize_pulse_unitary as keyword arguments to load_circuit. Usually, the minimal requirements are the evolution time evo_time and the number of time slices num_tslots for each gate. Other parameters can also be given in the keyword arguments. For available choices, see optimize_pulse_unitary. It is also possible to specify different parameters for different gates, as shown in the following example:; from qutip.qip.device import OptPulseProcessor; from qutip.operators import sigmaz, sigmax, sigmay; from qutip.tensor import tensor. # Same parameter for all the gates; qc = QubitCircuit(N=1); qc.add_gate(""SNOT"", 0). num_tslots = 10; evo_time = 10; processor = OptPulseProcessor(N=1, drift=sigmaz()); processor.add_control(sigmax()); # num_tslots and evo_time are two keyword arguments; tlist, coeffs = processor.load_circuit(; qc, num_tslots=num_tslots, evo_time=evo_time). # Different parameters for different gates; qc = QubitCircuit(N=2); qc.add_gate(""SNOT"", 0); qc.add_gate(""SWAP"", targets=[0, 1]); qc.add_gate('CNOT', controls=1, targets=[0]). processor = OptPulseProcessor(N=2, drift=tensor([sigmaz()]*2)); processor.add_control(sigmax(), cyclic_permutation=True); processor.add_control(sigmay(), cyclic_permutation=True); processor.add_control(tensor([sigma",MatchSource.WIKI,docs/4.7/guide/qip/qip-processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-processor.html
https://qutip.org/docs/4.7/guide/qip/qip-processor.html:13922,Availability,error,errors,13922,"and; repeats the scheduling a few times to get a better result.; from qutip.qip.circuit import QubitCircuit; from qutip.qip.compiler import Scheduler; circuit = QubitCircuit(7); circuit.add_gate(""SNOT"", 3) # gate0; circuit.add_gate(""CZ"", 5, 3) # gate1; circuit.add_gate(""CZ"", 4, 3) # gate2; circuit.add_gate(""CZ"", 2, 3) # gate3; circuit.add_gate(""CZ"", 6, 5) # gate4; circuit.add_gate(""CZ"", 2, 6) # gate5; circuit.add_gate(""ISWAP"", [0, 2]) # gate6; scheduler = Scheduler(""ASAP""); result = scheduler.schedule(circuit, gates_schedule=True); print(result). Output; [0, 1, 3, 2, 2, 3, 4]. The result shows the scheduling order of each gate in the original circuit.; For pulse schedule, or scheduling gates with different duration,; one will need to wrap the qutip.qip.Gate object with qutip.qip.compiler.Instruction object,; with a parameter duration.; The result will then be the start time of each instruction. Noise Simulation¶; In the common way of QIP simulation, where evolution is carried out by gate matrix product, the noise is usually simulated with bit flipping and sign flipping errors.; The typical approaches are either applying bit/sign flipping gate probabilistically; or applying Kraus operators representing different noisy channels (e.g. amplitude damping, dephasing) after each unitary gate evolution. In the case of a single qubit, they have the same effect and the parameters in the Kraus operators are exactly the probability of a flipping error happens during the gate operation time.; Since the processor simulates the state evolution at the level of the driving Hamiltonian, there is no way to apply an error operator to the continuous-time evolution. Instead, the error is added to the pulses (coherent control error) or the collapse operators (Lindblad error) contributing to the evolution. Mathematically, this is no different from adding error channel probabilistically (it is actually how qutip.mcsolve works internally). The collapse operator for single-qubit amplitude dam",MatchSource.WIKI,docs/4.7/guide/qip/qip-processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-processor.html
https://qutip.org/docs/4.7/guide/qip/qip-processor.html:14294,Availability,error,error,14294,"uit.add_gate(""ISWAP"", [0, 2]) # gate6; scheduler = Scheduler(""ASAP""); result = scheduler.schedule(circuit, gates_schedule=True); print(result). Output; [0, 1, 3, 2, 2, 3, 4]. The result shows the scheduling order of each gate in the original circuit.; For pulse schedule, or scheduling gates with different duration,; one will need to wrap the qutip.qip.Gate object with qutip.qip.compiler.Instruction object,; with a parameter duration.; The result will then be the start time of each instruction. Noise Simulation¶; In the common way of QIP simulation, where evolution is carried out by gate matrix product, the noise is usually simulated with bit flipping and sign flipping errors.; The typical approaches are either applying bit/sign flipping gate probabilistically; or applying Kraus operators representing different noisy channels (e.g. amplitude damping, dephasing) after each unitary gate evolution. In the case of a single qubit, they have the same effect and the parameters in the Kraus operators are exactly the probability of a flipping error happens during the gate operation time.; Since the processor simulates the state evolution at the level of the driving Hamiltonian, there is no way to apply an error operator to the continuous-time evolution. Instead, the error is added to the pulses (coherent control error) or the collapse operators (Lindblad error) contributing to the evolution. Mathematically, this is no different from adding error channel probabilistically (it is actually how qutip.mcsolve works internally). The collapse operator for single-qubit amplitude damping and dephasing are exactly the destroying operator and the sign-flipping operator. One just needs to choose the correct coefficients for them to simulate the noise, e.g. the relaxation time T1 and dephasing time T2. Because it is based on the open system evolution instead of abstract operators, this simulation is closer to the physical implementation and requires less pre-analysis of the system.; Compar",MatchSource.WIKI,docs/4.7/guide/qip/qip-processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-processor.html
https://qutip.org/docs/4.7/guide/qip/qip-processor.html:14460,Availability,error,error,14460," result shows the scheduling order of each gate in the original circuit.; For pulse schedule, or scheduling gates with different duration,; one will need to wrap the qutip.qip.Gate object with qutip.qip.compiler.Instruction object,; with a parameter duration.; The result will then be the start time of each instruction. Noise Simulation¶; In the common way of QIP simulation, where evolution is carried out by gate matrix product, the noise is usually simulated with bit flipping and sign flipping errors.; The typical approaches are either applying bit/sign flipping gate probabilistically; or applying Kraus operators representing different noisy channels (e.g. amplitude damping, dephasing) after each unitary gate evolution. In the case of a single qubit, they have the same effect and the parameters in the Kraus operators are exactly the probability of a flipping error happens during the gate operation time.; Since the processor simulates the state evolution at the level of the driving Hamiltonian, there is no way to apply an error operator to the continuous-time evolution. Instead, the error is added to the pulses (coherent control error) or the collapse operators (Lindblad error) contributing to the evolution. Mathematically, this is no different from adding error channel probabilistically (it is actually how qutip.mcsolve works internally). The collapse operator for single-qubit amplitude damping and dephasing are exactly the destroying operator and the sign-flipping operator. One just needs to choose the correct coefficients for them to simulate the noise, e.g. the relaxation time T1 and dephasing time T2. Because it is based on the open system evolution instead of abstract operators, this simulation is closer to the physical implementation and requires less pre-analysis of the system.; Compared to the approach of Kraus operators, this way of simulating noise is more computationally expensive. If you only want to simulate the decoherence of single-qubit relaxation and",MatchSource.WIKI,docs/4.7/guide/qip/qip-processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-processor.html
https://qutip.org/docs/4.7/guide/qip/qip-processor.html:14522,Availability,error,error,14522,"o wrap the qutip.qip.Gate object with qutip.qip.compiler.Instruction object,; with a parameter duration.; The result will then be the start time of each instruction. Noise Simulation¶; In the common way of QIP simulation, where evolution is carried out by gate matrix product, the noise is usually simulated with bit flipping and sign flipping errors.; The typical approaches are either applying bit/sign flipping gate probabilistically; or applying Kraus operators representing different noisy channels (e.g. amplitude damping, dephasing) after each unitary gate evolution. In the case of a single qubit, they have the same effect and the parameters in the Kraus operators are exactly the probability of a flipping error happens during the gate operation time.; Since the processor simulates the state evolution at the level of the driving Hamiltonian, there is no way to apply an error operator to the continuous-time evolution. Instead, the error is added to the pulses (coherent control error) or the collapse operators (Lindblad error) contributing to the evolution. Mathematically, this is no different from adding error channel probabilistically (it is actually how qutip.mcsolve works internally). The collapse operator for single-qubit amplitude damping and dephasing are exactly the destroying operator and the sign-flipping operator. One just needs to choose the correct coefficients for them to simulate the noise, e.g. the relaxation time T1 and dephasing time T2. Because it is based on the open system evolution instead of abstract operators, this simulation is closer to the physical implementation and requires less pre-analysis of the system.; Compared to the approach of Kraus operators, this way of simulating noise is more computationally expensive. If you only want to simulate the decoherence of single-qubit relaxation and the relaxation time is much longer than the gate duration, there is no need to go through all the calculations. However, this simulator is closer to the r",MatchSource.WIKI,docs/4.7/guide/qip/qip-processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-processor.html
https://qutip.org/docs/4.7/guide/qip/qip-processor.html:14569,Availability,error,error,14569,"o wrap the qutip.qip.Gate object with qutip.qip.compiler.Instruction object,; with a parameter duration.; The result will then be the start time of each instruction. Noise Simulation¶; In the common way of QIP simulation, where evolution is carried out by gate matrix product, the noise is usually simulated with bit flipping and sign flipping errors.; The typical approaches are either applying bit/sign flipping gate probabilistically; or applying Kraus operators representing different noisy channels (e.g. amplitude damping, dephasing) after each unitary gate evolution. In the case of a single qubit, they have the same effect and the parameters in the Kraus operators are exactly the probability of a flipping error happens during the gate operation time.; Since the processor simulates the state evolution at the level of the driving Hamiltonian, there is no way to apply an error operator to the continuous-time evolution. Instead, the error is added to the pulses (coherent control error) or the collapse operators (Lindblad error) contributing to the evolution. Mathematically, this is no different from adding error channel probabilistically (it is actually how qutip.mcsolve works internally). The collapse operator for single-qubit amplitude damping and dephasing are exactly the destroying operator and the sign-flipping operator. One just needs to choose the correct coefficients for them to simulate the noise, e.g. the relaxation time T1 and dephasing time T2. Because it is based on the open system evolution instead of abstract operators, this simulation is closer to the physical implementation and requires less pre-analysis of the system.; Compared to the approach of Kraus operators, this way of simulating noise is more computationally expensive. If you only want to simulate the decoherence of single-qubit relaxation and the relaxation time is much longer than the gate duration, there is no need to go through all the calculations. However, this simulator is closer to the r",MatchSource.WIKI,docs/4.7/guide/qip/qip-processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-processor.html
https://qutip.org/docs/4.7/guide/qip/qip-processor.html:14612,Availability,error,error,14612,"o wrap the qutip.qip.Gate object with qutip.qip.compiler.Instruction object,; with a parameter duration.; The result will then be the start time of each instruction. Noise Simulation¶; In the common way of QIP simulation, where evolution is carried out by gate matrix product, the noise is usually simulated with bit flipping and sign flipping errors.; The typical approaches are either applying bit/sign flipping gate probabilistically; or applying Kraus operators representing different noisy channels (e.g. amplitude damping, dephasing) after each unitary gate evolution. In the case of a single qubit, they have the same effect and the parameters in the Kraus operators are exactly the probability of a flipping error happens during the gate operation time.; Since the processor simulates the state evolution at the level of the driving Hamiltonian, there is no way to apply an error operator to the continuous-time evolution. Instead, the error is added to the pulses (coherent control error) or the collapse operators (Lindblad error) contributing to the evolution. Mathematically, this is no different from adding error channel probabilistically (it is actually how qutip.mcsolve works internally). The collapse operator for single-qubit amplitude damping and dephasing are exactly the destroying operator and the sign-flipping operator. One just needs to choose the correct coefficients for them to simulate the noise, e.g. the relaxation time T1 and dephasing time T2. Because it is based on the open system evolution instead of abstract operators, this simulation is closer to the physical implementation and requires less pre-analysis of the system.; Compared to the approach of Kraus operators, this way of simulating noise is more computationally expensive. If you only want to simulate the decoherence of single-qubit relaxation and the relaxation time is much longer than the gate duration, there is no need to go through all the calculations. However, this simulator is closer to the r",MatchSource.WIKI,docs/4.7/guide/qip/qip-processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-processor.html
https://qutip.org/docs/4.7/guide/qip/qip-processor.html:14699,Availability,error,error,14699,"n be the start time of each instruction. Noise Simulation¶; In the common way of QIP simulation, where evolution is carried out by gate matrix product, the noise is usually simulated with bit flipping and sign flipping errors.; The typical approaches are either applying bit/sign flipping gate probabilistically; or applying Kraus operators representing different noisy channels (e.g. amplitude damping, dephasing) after each unitary gate evolution. In the case of a single qubit, they have the same effect and the parameters in the Kraus operators are exactly the probability of a flipping error happens during the gate operation time.; Since the processor simulates the state evolution at the level of the driving Hamiltonian, there is no way to apply an error operator to the continuous-time evolution. Instead, the error is added to the pulses (coherent control error) or the collapse operators (Lindblad error) contributing to the evolution. Mathematically, this is no different from adding error channel probabilistically (it is actually how qutip.mcsolve works internally). The collapse operator for single-qubit amplitude damping and dephasing are exactly the destroying operator and the sign-flipping operator. One just needs to choose the correct coefficients for them to simulate the noise, e.g. the relaxation time T1 and dephasing time T2. Because it is based on the open system evolution instead of abstract operators, this simulation is closer to the physical implementation and requires less pre-analysis of the system.; Compared to the approach of Kraus operators, this way of simulating noise is more computationally expensive. If you only want to simulate the decoherence of single-qubit relaxation and the relaxation time is much longer than the gate duration, there is no need to go through all the calculations. However, this simulator is closer to the real experiment and, therefore, more convenient in some cases, such as when coherent noise or correlated noise exist. For ins",MatchSource.WIKI,docs/4.7/guide/qip/qip-processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-processor.html
https://qutip.org/docs/4.7/guide/qip/qip-processor.html:3217,Deployability,continuous,continuous,3217,"nction or with cubic spline. For step function, tlist specifies the start and the end of each pulse and thus is one element longer the coeffs. One example of defining the control pulse coefficients and the time array is as follows:; import numpy as np; from qutip import sigmaz; from qutip.qip.device import Processor. processor = Processor(2); processor.add_control(sigmaz(), cyclic_permutation=True) # sigmaz for all qubits; processor.pulses[0].coeffs = np.array([[1.0, 1.5, 2.0], [1.8, 1.3, 0.8]]); processor.pulses[0].tlist = np.array([0.1, 0.2, 0.4, 0.5]). It defines a \(\sigma_z\) operator on both qubits and a pulse that acts on the first qubit.; An equivalent approach is using the add_pulse method.; from qutip.qip.pulse import Pulse. processor = Processor(2); coeff=np.array([0.1, 0.2, 0.4, 0.5]); tlist=np.array([[1.0, 1.5, 2.0], [1.8, 1.3, 0.8]]); pulse = Pulse(sigmaz(), targets=0, coeff=coeff, tlist=tlist); processor.add_pulse(pulse). One can also use choose the pulse_mode attribute of Processor; between ""discrete"" and ""continuous"". Note; If the coefficients represent dicrete pulse, the length of each array is 1 element shorter than tlist. If it is supposed to be a continuous function, the length should be the same as tlist. The above example shows the framework and the most essential part of the simulator’s API. So far, it looks like just a wrapper for the open system solvers. However, based on this, we can implement different physical realizations. They differ mainly in how to find the control pulse for a quantum circuit, which gives birth to different sub-classes:. Processor; ├── ModelProcessor; │ ├── DispersiveCavityQED; │ └── SpinChain; └── OptPulseProcessor. In general, there are two ways to find the control pulses. The first one, ModelProcessor, is more experiment-oriented and based on physical models. A universal set of; gates is defined in the processor as well as the pulse implementing them in this particular physical model. This is usually the case wher",MatchSource.WIKI,docs/4.7/guide/qip/qip-processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-processor.html
https://qutip.org/docs/4.7/guide/qip/qip-processor.html:3365,Deployability,continuous,continuous,3365,"the time array is as follows:; import numpy as np; from qutip import sigmaz; from qutip.qip.device import Processor. processor = Processor(2); processor.add_control(sigmaz(), cyclic_permutation=True) # sigmaz for all qubits; processor.pulses[0].coeffs = np.array([[1.0, 1.5, 2.0], [1.8, 1.3, 0.8]]); processor.pulses[0].tlist = np.array([0.1, 0.2, 0.4, 0.5]). It defines a \(\sigma_z\) operator on both qubits and a pulse that acts on the first qubit.; An equivalent approach is using the add_pulse method.; from qutip.qip.pulse import Pulse. processor = Processor(2); coeff=np.array([0.1, 0.2, 0.4, 0.5]); tlist=np.array([[1.0, 1.5, 2.0], [1.8, 1.3, 0.8]]); pulse = Pulse(sigmaz(), targets=0, coeff=coeff, tlist=tlist); processor.add_pulse(pulse). One can also use choose the pulse_mode attribute of Processor; between ""discrete"" and ""continuous"". Note; If the coefficients represent dicrete pulse, the length of each array is 1 element shorter than tlist. If it is supposed to be a continuous function, the length should be the same as tlist. The above example shows the framework and the most essential part of the simulator’s API. So far, it looks like just a wrapper for the open system solvers. However, based on this, we can implement different physical realizations. They differ mainly in how to find the control pulse for a quantum circuit, which gives birth to different sub-classes:. Processor; ├── ModelProcessor; │ ├── DispersiveCavityQED; │ └── SpinChain; └── OptPulseProcessor. In general, there are two ways to find the control pulses. The first one, ModelProcessor, is more experiment-oriented and based on physical models. A universal set of; gates is defined in the processor as well as the pulse implementing them in this particular physical model. This is usually the case where control pulses realizing those gates are well known and can be concatenated to realize the whole quantum circuits. Two realizations have already been implemented: the spin chain and the Cavity QED mode",MatchSource.WIKI,docs/4.7/guide/qip/qip-processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-processor.html
https://qutip.org/docs/4.7/guide/qip/qip-processor.html:14482,Deployability,continuous,continuous-time,14482," result shows the scheduling order of each gate in the original circuit.; For pulse schedule, or scheduling gates with different duration,; one will need to wrap the qutip.qip.Gate object with qutip.qip.compiler.Instruction object,; with a parameter duration.; The result will then be the start time of each instruction. Noise Simulation¶; In the common way of QIP simulation, where evolution is carried out by gate matrix product, the noise is usually simulated with bit flipping and sign flipping errors.; The typical approaches are either applying bit/sign flipping gate probabilistically; or applying Kraus operators representing different noisy channels (e.g. amplitude damping, dephasing) after each unitary gate evolution. In the case of a single qubit, they have the same effect and the parameters in the Kraus operators are exactly the probability of a flipping error happens during the gate operation time.; Since the processor simulates the state evolution at the level of the driving Hamiltonian, there is no way to apply an error operator to the continuous-time evolution. Instead, the error is added to the pulses (coherent control error) or the collapse operators (Lindblad error) contributing to the evolution. Mathematically, this is no different from adding error channel probabilistically (it is actually how qutip.mcsolve works internally). The collapse operator for single-qubit amplitude damping and dephasing are exactly the destroying operator and the sign-flipping operator. One just needs to choose the correct coefficients for them to simulate the noise, e.g. the relaxation time T1 and dephasing time T2. Because it is based on the open system evolution instead of abstract operators, this simulation is closer to the physical implementation and requires less pre-analysis of the system.; Compared to the approach of Kraus operators, this way of simulating noise is more computationally expensive. If you only want to simulate the decoherence of single-qubit relaxation and",MatchSource.WIKI,docs/4.7/guide/qip/qip-processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-processor.html
https://qutip.org/docs/4.7/guide/qip/qip-processor.html:20724,Deployability,update,updated,20724,".pi/2., 2*np.pi/2, 3*np.pi/2])). # define noise, loc and scale are keyword arguments for np.random.normal; gaussnoise = RandomNoise(; dt=0.01, rand_gen=np.random.normal, loc=0.00, scale=0.02); processor.add_noise(gaussnoise). # Plot the ideal pulse; fig1, axis1 = processor.plot_pulses(title=""Original control amplitude"", figsize=(5,3)). # Plot the noisy pulse; qobjevo, _ = processor.get_qobjevo(noisy=True); noisy_coeff = qobjevo.to_list()[1][1] + qobjevo.to_list()[2][1]; fig2, axis2 = processor.plot_pulses(title=""Noisy control amplitude"", figsize=(5,3)); axis2[0].step(qobjevo.tlist, noisy_coeff). Customize the simulator¶; The number of predefined physical models and compilers are limited.; However, it is designed for easy customization and one can easily build customized model and compiling routines.; For guide and examples, please refer to the tutorial notebooks; at https://qutip.org/tutorials.html. The workflow of the simulator¶; The following plot demonstrates the workflow of the simulator. The core of the simulator is Processor,; which characterizes the quantum hardware of interest,; containing the information such as the non-controllable drift Hamiltonian and; the control Hamiltonian.; Apart from the ideal system representing the qubits, one can also define; hardware-dependent or pulse-dependent noise in Noise.; It describes how noisy terms such as imperfect control; and decoherence can be added once the ideal control pulse is defined.; When loading a quantum circuit, a GateCompiler compiles the circuit into a sequence of control pulse signals and schedule the pulse for parallel execution.; For each control Hamiltonian, a Pulse instance is created that including the ideal evolution and associated noise.; They will then be sent to the QuTiP solvers for the computation. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/qip/qip-processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-processor.html
https://qutip.org/docs/4.7/guide/qip/qip-processor.html:852,Energy Efficiency,schedul,scheduler,852,"﻿. Pulse-level circuit simulation — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Quantum Information Processing; Operator-level circuit simulation; Pulse-level circuit simulation; Modelling quantum hardware with Processor; Compiler and scheduler; Noise Simulation; Customize the simulator; The workflow of the simulator. Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Quantum Information Processing »; Pulse-level circuit simulation. Pulse-level circuit simulation¶. Modelling quantum hardware with Processor¶; Based on the open system solver, Processor in the qutip.qip module simulates quantum circuits at the level of time evolution. One can consider the processor as a simulator of a quantum device, on which the quantum circuit is to be implemented.; The procedure is illustrated in the figure below.; It first compiles circuit into a Hamiltonian model, adds noisy dynamics and then uses the QuTiP open time evolution solvers to simulation the evolution. Like a real quantum device, the processor is determined by a list of Hamiltonians, i.e. the control pulses driving the evolution. Given the intensity of the control pulses and the corresponding time slices for each pulse, the evolution is then computed. A control pulse ",MatchSource.WIKI,docs/4.7/guide/qip/qip-processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-processor.html
https://qutip.org/docs/4.7/guide/qip/qip-processor.html:9885,Energy Efficiency,schedul,scheduler,9885," Same parameter for all the gates; qc = QubitCircuit(N=1); qc.add_gate(""SNOT"", 0). num_tslots = 10; evo_time = 10; processor = OptPulseProcessor(N=1, drift=sigmaz()); processor.add_control(sigmax()); # num_tslots and evo_time are two keyword arguments; tlist, coeffs = processor.load_circuit(; qc, num_tslots=num_tslots, evo_time=evo_time). # Different parameters for different gates; qc = QubitCircuit(N=2); qc.add_gate(""SNOT"", 0); qc.add_gate(""SWAP"", targets=[0, 1]); qc.add_gate('CNOT', controls=1, targets=[0]). processor = OptPulseProcessor(N=2, drift=tensor([sigmaz()]*2)); processor.add_control(sigmax(), cyclic_permutation=True); processor.add_control(sigmay(), cyclic_permutation=True); processor.add_control(tensor([sigmay(), sigmay()])). setting_args = {""SNOT"": {""num_tslots"": 10, ""evo_time"": 1},; ""SWAP"": {""num_tslots"": 30, ""evo_time"": 3},; ""CNOT"": {""num_tslots"": 30, ""evo_time"": 3}}. tlist, coeffs = processor.load_circuit(; qc, setting_args=setting_args, merge_gates=False). Compiler and scheduler¶. Note; New in QuTiP 4.6. In order to simulate quantum circuits at the level of time evolution.; We need to first compile the circuit into the Hamiltonian model, i.e.; the control pulses.; Hence each Processor has a corresponding; GateCompiler class.; The compiler takes a QubitCircuit; and returns the compiled tlist and coeffs.; It is called implicitly when calling the method; run_state.; from qutip.qip.compiler import SpinChainCompiler; qc = QubitCircuit(2); qc.add_gate(""X"", targets=0); qc.add_gate(""X"", targets=1). processor = LinearSpinChain(2); compiler = SpinChainCompiler(; 2, params=processor.params, pulse_dict=processor.pulse_dict); resolved_qc = qc.resolve_gates([""RX"", ""RZ"", ""ISWAP""]); tlists, coeffs = compiler.compile(resolved_qc); print(tlists); print(coeffs). Output; [array([0., 1.]), array([0., 1., 2.]), None, None, None]; [array([1.57079633]), array([0. , 1.57079633]), None, None, None]. Here we first use resolve_gates; to decompose the X gate to its natural gate",MatchSource.WIKI,docs/4.7/guide/qip/qip-processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-processor.html
https://qutip.org/docs/4.7/guide/qip/qip-processor.html:11508,Energy Efficiency,schedul,scheduler,11508,"ompiler(; 2, params=processor.params, pulse_dict=processor.pulse_dict); resolved_qc = qc.resolve_gates([""RX"", ""RZ"", ""ISWAP""]); tlists, coeffs = compiler.compile(resolved_qc); print(tlists); print(coeffs). Output; [array([0., 1.]), array([0., 1., 2.]), None, None, None]; [array([1.57079633]), array([0. , 1.57079633]), None, None, None]. Here we first use resolve_gates; to decompose the X gate to its natural gate on Spin Chain model,; the rotation over X-axis.; We pass the hardware parameters of the SpinChain model, processor.params, as well as a map between the pulse name and pulse index pulse_dict to the compiler.; The later one allows one to address the pulse more conveniently in the compiler.; The compiler returns a list of tlist and coeff, corresponding to each pulse.; The first pulse starts from t=0 and ends at t=1, with the strengh \(\pi/2\).; The second one is turned on from t=1 to t=2 with the same strength.; The compiled pulse here is different from what is shown in the plot; in the previous subsection because the scheduler is turned off by default.; The scheduler is implemented in the class Scheduler,; based on the idea of https://doi.org/10.1117/12.666419.; It schedules the order of quantum gates and instructions for the; shortest execution time.; It works not only for quantum gates but also for pulse implementation of gates; (Instruction) with varying pulse duration.; The scheduler first generates a quantum gates dependency graph,; containing information about which gates have to be executed before some other gates.; The graph preserves the mobility of the gates,; i.e. commuting gates are not dependent on each other, even if they use the same qubits.; Next, it computes the longest distance of each node to the start and end nodes.; The distance for each dependency arrow is defined by the execution time of the instruction; (By default, it is 1 for all gates).; This is used as a priority measure in the next step.; The gate with a longer distance to the end no",MatchSource.WIKI,docs/4.7/guide/qip/qip-processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-processor.html
https://qutip.org/docs/4.7/guide/qip/qip-processor.html:11549,Energy Efficiency,schedul,scheduler,11549,"ISWAP""]); tlists, coeffs = compiler.compile(resolved_qc); print(tlists); print(coeffs). Output; [array([0., 1.]), array([0., 1., 2.]), None, None, None]; [array([1.57079633]), array([0. , 1.57079633]), None, None, None]. Here we first use resolve_gates; to decompose the X gate to its natural gate on Spin Chain model,; the rotation over X-axis.; We pass the hardware parameters of the SpinChain model, processor.params, as well as a map between the pulse name and pulse index pulse_dict to the compiler.; The later one allows one to address the pulse more conveniently in the compiler.; The compiler returns a list of tlist and coeff, corresponding to each pulse.; The first pulse starts from t=0 and ends at t=1, with the strengh \(\pi/2\).; The second one is turned on from t=1 to t=2 with the same strength.; The compiled pulse here is different from what is shown in the plot; in the previous subsection because the scheduler is turned off by default.; The scheduler is implemented in the class Scheduler,; based on the idea of https://doi.org/10.1117/12.666419.; It schedules the order of quantum gates and instructions for the; shortest execution time.; It works not only for quantum gates but also for pulse implementation of gates; (Instruction) with varying pulse duration.; The scheduler first generates a quantum gates dependency graph,; containing information about which gates have to be executed before some other gates.; The graph preserves the mobility of the gates,; i.e. commuting gates are not dependent on each other, even if they use the same qubits.; Next, it computes the longest distance of each node to the start and end nodes.; The distance for each dependency arrow is defined by the execution time of the instruction; (By default, it is 1 for all gates).; This is used as a priority measure in the next step.; The gate with a longer distance to the end node and a shorter distance to the start node has higher priority.; In the last step, it uses a list-schedule algorithm",MatchSource.WIKI,docs/4.7/guide/qip/qip-processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-processor.html
https://qutip.org/docs/4.7/guide/qip/qip-processor.html:11659,Energy Efficiency,schedul,schedules,11659," array([0., 1., 2.]), None, None, None]; [array([1.57079633]), array([0. , 1.57079633]), None, None, None]. Here we first use resolve_gates; to decompose the X gate to its natural gate on Spin Chain model,; the rotation over X-axis.; We pass the hardware parameters of the SpinChain model, processor.params, as well as a map between the pulse name and pulse index pulse_dict to the compiler.; The later one allows one to address the pulse more conveniently in the compiler.; The compiler returns a list of tlist and coeff, corresponding to each pulse.; The first pulse starts from t=0 and ends at t=1, with the strengh \(\pi/2\).; The second one is turned on from t=1 to t=2 with the same strength.; The compiled pulse here is different from what is shown in the plot; in the previous subsection because the scheduler is turned off by default.; The scheduler is implemented in the class Scheduler,; based on the idea of https://doi.org/10.1117/12.666419.; It schedules the order of quantum gates and instructions for the; shortest execution time.; It works not only for quantum gates but also for pulse implementation of gates; (Instruction) with varying pulse duration.; The scheduler first generates a quantum gates dependency graph,; containing information about which gates have to be executed before some other gates.; The graph preserves the mobility of the gates,; i.e. commuting gates are not dependent on each other, even if they use the same qubits.; Next, it computes the longest distance of each node to the start and end nodes.; The distance for each dependency arrow is defined by the execution time of the instruction; (By default, it is 1 for all gates).; This is used as a priority measure in the next step.; The gate with a longer distance to the end node and a shorter distance to the start node has higher priority.; In the last step, it uses a list-schedule algorithm with hardware constraint and; priority and returns a list of cycles for gates/instructions.; Since the algorith",MatchSource.WIKI,docs/4.7/guide/qip/qip-processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-processor.html
https://qutip.org/docs/4.7/guide/qip/qip-processor.html:11876,Energy Efficiency,schedul,scheduler,11876,"hardware parameters of the SpinChain model, processor.params, as well as a map between the pulse name and pulse index pulse_dict to the compiler.; The later one allows one to address the pulse more conveniently in the compiler.; The compiler returns a list of tlist and coeff, corresponding to each pulse.; The first pulse starts from t=0 and ends at t=1, with the strengh \(\pi/2\).; The second one is turned on from t=1 to t=2 with the same strength.; The compiled pulse here is different from what is shown in the plot; in the previous subsection because the scheduler is turned off by default.; The scheduler is implemented in the class Scheduler,; based on the idea of https://doi.org/10.1117/12.666419.; It schedules the order of quantum gates and instructions for the; shortest execution time.; It works not only for quantum gates but also for pulse implementation of gates; (Instruction) with varying pulse duration.; The scheduler first generates a quantum gates dependency graph,; containing information about which gates have to be executed before some other gates.; The graph preserves the mobility of the gates,; i.e. commuting gates are not dependent on each other, even if they use the same qubits.; Next, it computes the longest distance of each node to the start and end nodes.; The distance for each dependency arrow is defined by the execution time of the instruction; (By default, it is 1 for all gates).; This is used as a priority measure in the next step.; The gate with a longer distance to the end node and a shorter distance to the start node has higher priority.; In the last step, it uses a list-schedule algorithm with hardware constraint and; priority and returns a list of cycles for gates/instructions.; Since the algorithm is heuristics, sometimes it does not find the optimal solution.; Hence, we offer an option that randomly shuffles the commuting gates and; repeats the scheduling a few times to get a better result.; from qutip.qip.circuit import QubitCircuit; f",MatchSource.WIKI,docs/4.7/guide/qip/qip-processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-processor.html
https://qutip.org/docs/4.7/guide/qip/qip-processor.html:12570,Energy Efficiency,schedul,schedule,12570," the idea of https://doi.org/10.1117/12.666419.; It schedules the order of quantum gates and instructions for the; shortest execution time.; It works not only for quantum gates but also for pulse implementation of gates; (Instruction) with varying pulse duration.; The scheduler first generates a quantum gates dependency graph,; containing information about which gates have to be executed before some other gates.; The graph preserves the mobility of the gates,; i.e. commuting gates are not dependent on each other, even if they use the same qubits.; Next, it computes the longest distance of each node to the start and end nodes.; The distance for each dependency arrow is defined by the execution time of the instruction; (By default, it is 1 for all gates).; This is used as a priority measure in the next step.; The gate with a longer distance to the end node and a shorter distance to the start node has higher priority.; In the last step, it uses a list-schedule algorithm with hardware constraint and; priority and returns a list of cycles for gates/instructions.; Since the algorithm is heuristics, sometimes it does not find the optimal solution.; Hence, we offer an option that randomly shuffles the commuting gates and; repeats the scheduling a few times to get a better result.; from qutip.qip.circuit import QubitCircuit; from qutip.qip.compiler import Scheduler; circuit = QubitCircuit(7); circuit.add_gate(""SNOT"", 3) # gate0; circuit.add_gate(""CZ"", 5, 3) # gate1; circuit.add_gate(""CZ"", 4, 3) # gate2; circuit.add_gate(""CZ"", 2, 3) # gate3; circuit.add_gate(""CZ"", 6, 5) # gate4; circuit.add_gate(""CZ"", 2, 6) # gate5; circuit.add_gate(""ISWAP"", [0, 2]) # gate6; scheduler = Scheduler(""ASAP""); result = scheduler.schedule(circuit, gates_schedule=True); print(result). Output; [0, 1, 3, 2, 2, 3, 4]. The result shows the scheduling order of each gate in the original circuit.; For pulse schedule, or scheduling gates with different duration,; one will need to wrap the qutip.qip.Gate obje",MatchSource.WIKI,docs/4.7/guide/qip/qip-processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-processor.html
https://qutip.org/docs/4.7/guide/qip/qip-processor.html:12853,Energy Efficiency,schedul,scheduling,12853,"truction) with varying pulse duration.; The scheduler first generates a quantum gates dependency graph,; containing information about which gates have to be executed before some other gates.; The graph preserves the mobility of the gates,; i.e. commuting gates are not dependent on each other, even if they use the same qubits.; Next, it computes the longest distance of each node to the start and end nodes.; The distance for each dependency arrow is defined by the execution time of the instruction; (By default, it is 1 for all gates).; This is used as a priority measure in the next step.; The gate with a longer distance to the end node and a shorter distance to the start node has higher priority.; In the last step, it uses a list-schedule algorithm with hardware constraint and; priority and returns a list of cycles for gates/instructions.; Since the algorithm is heuristics, sometimes it does not find the optimal solution.; Hence, we offer an option that randomly shuffles the commuting gates and; repeats the scheduling a few times to get a better result.; from qutip.qip.circuit import QubitCircuit; from qutip.qip.compiler import Scheduler; circuit = QubitCircuit(7); circuit.add_gate(""SNOT"", 3) # gate0; circuit.add_gate(""CZ"", 5, 3) # gate1; circuit.add_gate(""CZ"", 4, 3) # gate2; circuit.add_gate(""CZ"", 2, 3) # gate3; circuit.add_gate(""CZ"", 6, 5) # gate4; circuit.add_gate(""CZ"", 2, 6) # gate5; circuit.add_gate(""ISWAP"", [0, 2]) # gate6; scheduler = Scheduler(""ASAP""); result = scheduler.schedule(circuit, gates_schedule=True); print(result). Output; [0, 1, 3, 2, 2, 3, 4]. The result shows the scheduling order of each gate in the original circuit.; For pulse schedule, or scheduling gates with different duration,; one will need to wrap the qutip.qip.Gate object with qutip.qip.compiler.Instruction object,; with a parameter duration.; The result will then be the start time of each instruction. Noise Simulation¶; In the common way of QIP simulation, where evolution is carried out b",MatchSource.WIKI,docs/4.7/guide/qip/qip-processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-processor.html
https://qutip.org/docs/4.7/guide/qip/qip-processor.html:13284,Energy Efficiency,schedul,scheduler,13284," by the execution time of the instruction; (By default, it is 1 for all gates).; This is used as a priority measure in the next step.; The gate with a longer distance to the end node and a shorter distance to the start node has higher priority.; In the last step, it uses a list-schedule algorithm with hardware constraint and; priority and returns a list of cycles for gates/instructions.; Since the algorithm is heuristics, sometimes it does not find the optimal solution.; Hence, we offer an option that randomly shuffles the commuting gates and; repeats the scheduling a few times to get a better result.; from qutip.qip.circuit import QubitCircuit; from qutip.qip.compiler import Scheduler; circuit = QubitCircuit(7); circuit.add_gate(""SNOT"", 3) # gate0; circuit.add_gate(""CZ"", 5, 3) # gate1; circuit.add_gate(""CZ"", 4, 3) # gate2; circuit.add_gate(""CZ"", 2, 3) # gate3; circuit.add_gate(""CZ"", 6, 5) # gate4; circuit.add_gate(""CZ"", 2, 6) # gate5; circuit.add_gate(""ISWAP"", [0, 2]) # gate6; scheduler = Scheduler(""ASAP""); result = scheduler.schedule(circuit, gates_schedule=True); print(result). Output; [0, 1, 3, 2, 2, 3, 4]. The result shows the scheduling order of each gate in the original circuit.; For pulse schedule, or scheduling gates with different duration,; one will need to wrap the qutip.qip.Gate object with qutip.qip.compiler.Instruction object,; with a parameter duration.; The result will then be the start time of each instruction. Noise Simulation¶; In the common way of QIP simulation, where evolution is carried out by gate matrix product, the noise is usually simulated with bit flipping and sign flipping errors.; The typical approaches are either applying bit/sign flipping gate probabilistically; or applying Kraus operators representing different noisy channels (e.g. amplitude damping, dephasing) after each unitary gate evolution. In the case of a single qubit, they have the same effect and the parameters in the Kraus operators are exactly the probability of a flippin",MatchSource.WIKI,docs/4.7/guide/qip/qip-processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-processor.html
https://qutip.org/docs/4.7/guide/qip/qip-processor.html:13324,Energy Efficiency,schedul,scheduler,13324," by the execution time of the instruction; (By default, it is 1 for all gates).; This is used as a priority measure in the next step.; The gate with a longer distance to the end node and a shorter distance to the start node has higher priority.; In the last step, it uses a list-schedule algorithm with hardware constraint and; priority and returns a list of cycles for gates/instructions.; Since the algorithm is heuristics, sometimes it does not find the optimal solution.; Hence, we offer an option that randomly shuffles the commuting gates and; repeats the scheduling a few times to get a better result.; from qutip.qip.circuit import QubitCircuit; from qutip.qip.compiler import Scheduler; circuit = QubitCircuit(7); circuit.add_gate(""SNOT"", 3) # gate0; circuit.add_gate(""CZ"", 5, 3) # gate1; circuit.add_gate(""CZ"", 4, 3) # gate2; circuit.add_gate(""CZ"", 2, 3) # gate3; circuit.add_gate(""CZ"", 6, 5) # gate4; circuit.add_gate(""CZ"", 2, 6) # gate5; circuit.add_gate(""ISWAP"", [0, 2]) # gate6; scheduler = Scheduler(""ASAP""); result = scheduler.schedule(circuit, gates_schedule=True); print(result). Output; [0, 1, 3, 2, 2, 3, 4]. The result shows the scheduling order of each gate in the original circuit.; For pulse schedule, or scheduling gates with different duration,; one will need to wrap the qutip.qip.Gate object with qutip.qip.compiler.Instruction object,; with a parameter duration.; The result will then be the start time of each instruction. Noise Simulation¶; In the common way of QIP simulation, where evolution is carried out by gate matrix product, the noise is usually simulated with bit flipping and sign flipping errors.; The typical approaches are either applying bit/sign flipping gate probabilistically; or applying Kraus operators representing different noisy channels (e.g. amplitude damping, dephasing) after each unitary gate evolution. In the case of a single qubit, they have the same effect and the parameters in the Kraus operators are exactly the probability of a flippin",MatchSource.WIKI,docs/4.7/guide/qip/qip-processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-processor.html
https://qutip.org/docs/4.7/guide/qip/qip-processor.html:13334,Energy Efficiency,schedul,schedule,13334,"l gates).; This is used as a priority measure in the next step.; The gate with a longer distance to the end node and a shorter distance to the start node has higher priority.; In the last step, it uses a list-schedule algorithm with hardware constraint and; priority and returns a list of cycles for gates/instructions.; Since the algorithm is heuristics, sometimes it does not find the optimal solution.; Hence, we offer an option that randomly shuffles the commuting gates and; repeats the scheduling a few times to get a better result.; from qutip.qip.circuit import QubitCircuit; from qutip.qip.compiler import Scheduler; circuit = QubitCircuit(7); circuit.add_gate(""SNOT"", 3) # gate0; circuit.add_gate(""CZ"", 5, 3) # gate1; circuit.add_gate(""CZ"", 4, 3) # gate2; circuit.add_gate(""CZ"", 2, 3) # gate3; circuit.add_gate(""CZ"", 6, 5) # gate4; circuit.add_gate(""CZ"", 2, 6) # gate5; circuit.add_gate(""ISWAP"", [0, 2]) # gate6; scheduler = Scheduler(""ASAP""); result = scheduler.schedule(circuit, gates_schedule=True); print(result). Output; [0, 1, 3, 2, 2, 3, 4]. The result shows the scheduling order of each gate in the original circuit.; For pulse schedule, or scheduling gates with different duration,; one will need to wrap the qutip.qip.Gate object with qutip.qip.compiler.Instruction object,; with a parameter duration.; The result will then be the start time of each instruction. Noise Simulation¶; In the common way of QIP simulation, where evolution is carried out by gate matrix product, the noise is usually simulated with bit flipping and sign flipping errors.; The typical approaches are either applying bit/sign flipping gate probabilistically; or applying Kraus operators representing different noisy channels (e.g. amplitude damping, dephasing) after each unitary gate evolution. In the case of a single qubit, they have the same effect and the parameters in the Kraus operators are exactly the probability of a flipping error happens during the gate operation time.; Since the processor ",MatchSource.WIKI,docs/4.7/guide/qip/qip-processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-processor.html
https://qutip.org/docs/4.7/guide/qip/qip-processor.html:13441,Energy Efficiency,schedul,scheduling,13441," to the end node and a shorter distance to the start node has higher priority.; In the last step, it uses a list-schedule algorithm with hardware constraint and; priority and returns a list of cycles for gates/instructions.; Since the algorithm is heuristics, sometimes it does not find the optimal solution.; Hence, we offer an option that randomly shuffles the commuting gates and; repeats the scheduling a few times to get a better result.; from qutip.qip.circuit import QubitCircuit; from qutip.qip.compiler import Scheduler; circuit = QubitCircuit(7); circuit.add_gate(""SNOT"", 3) # gate0; circuit.add_gate(""CZ"", 5, 3) # gate1; circuit.add_gate(""CZ"", 4, 3) # gate2; circuit.add_gate(""CZ"", 2, 3) # gate3; circuit.add_gate(""CZ"", 6, 5) # gate4; circuit.add_gate(""CZ"", 2, 6) # gate5; circuit.add_gate(""ISWAP"", [0, 2]) # gate6; scheduler = Scheduler(""ASAP""); result = scheduler.schedule(circuit, gates_schedule=True); print(result). Output; [0, 1, 3, 2, 2, 3, 4]. The result shows the scheduling order of each gate in the original circuit.; For pulse schedule, or scheduling gates with different duration,; one will need to wrap the qutip.qip.Gate object with qutip.qip.compiler.Instruction object,; with a parameter duration.; The result will then be the start time of each instruction. Noise Simulation¶; In the common way of QIP simulation, where evolution is carried out by gate matrix product, the noise is usually simulated with bit flipping and sign flipping errors.; The typical approaches are either applying bit/sign flipping gate probabilistically; or applying Kraus operators representing different noisy channels (e.g. amplitude damping, dephasing) after each unitary gate evolution. In the case of a single qubit, they have the same effect and the parameters in the Kraus operators are exactly the probability of a flipping error happens during the gate operation time.; Since the processor simulates the state evolution at the level of the driving Hamiltonian, there is no way to apply ",MatchSource.WIKI,docs/4.7/guide/qip/qip-processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-processor.html
https://qutip.org/docs/4.7/guide/qip/qip-processor.html:13507,Energy Efficiency,schedul,schedule,13507,"ast step, it uses a list-schedule algorithm with hardware constraint and; priority and returns a list of cycles for gates/instructions.; Since the algorithm is heuristics, sometimes it does not find the optimal solution.; Hence, we offer an option that randomly shuffles the commuting gates and; repeats the scheduling a few times to get a better result.; from qutip.qip.circuit import QubitCircuit; from qutip.qip.compiler import Scheduler; circuit = QubitCircuit(7); circuit.add_gate(""SNOT"", 3) # gate0; circuit.add_gate(""CZ"", 5, 3) # gate1; circuit.add_gate(""CZ"", 4, 3) # gate2; circuit.add_gate(""CZ"", 2, 3) # gate3; circuit.add_gate(""CZ"", 6, 5) # gate4; circuit.add_gate(""CZ"", 2, 6) # gate5; circuit.add_gate(""ISWAP"", [0, 2]) # gate6; scheduler = Scheduler(""ASAP""); result = scheduler.schedule(circuit, gates_schedule=True); print(result). Output; [0, 1, 3, 2, 2, 3, 4]. The result shows the scheduling order of each gate in the original circuit.; For pulse schedule, or scheduling gates with different duration,; one will need to wrap the qutip.qip.Gate object with qutip.qip.compiler.Instruction object,; with a parameter duration.; The result will then be the start time of each instruction. Noise Simulation¶; In the common way of QIP simulation, where evolution is carried out by gate matrix product, the noise is usually simulated with bit flipping and sign flipping errors.; The typical approaches are either applying bit/sign flipping gate probabilistically; or applying Kraus operators representing different noisy channels (e.g. amplitude damping, dephasing) after each unitary gate evolution. In the case of a single qubit, they have the same effect and the parameters in the Kraus operators are exactly the probability of a flipping error happens during the gate operation time.; Since the processor simulates the state evolution at the level of the driving Hamiltonian, there is no way to apply an error operator to the continuous-time evolution. Instead, the error is added to the p",MatchSource.WIKI,docs/4.7/guide/qip/qip-processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-processor.html
https://qutip.org/docs/4.7/guide/qip/qip-processor.html:13520,Energy Efficiency,schedul,scheduling,13520,"ast step, it uses a list-schedule algorithm with hardware constraint and; priority and returns a list of cycles for gates/instructions.; Since the algorithm is heuristics, sometimes it does not find the optimal solution.; Hence, we offer an option that randomly shuffles the commuting gates and; repeats the scheduling a few times to get a better result.; from qutip.qip.circuit import QubitCircuit; from qutip.qip.compiler import Scheduler; circuit = QubitCircuit(7); circuit.add_gate(""SNOT"", 3) # gate0; circuit.add_gate(""CZ"", 5, 3) # gate1; circuit.add_gate(""CZ"", 4, 3) # gate2; circuit.add_gate(""CZ"", 2, 3) # gate3; circuit.add_gate(""CZ"", 6, 5) # gate4; circuit.add_gate(""CZ"", 2, 6) # gate5; circuit.add_gate(""ISWAP"", [0, 2]) # gate6; scheduler = Scheduler(""ASAP""); result = scheduler.schedule(circuit, gates_schedule=True); print(result). Output; [0, 1, 3, 2, 2, 3, 4]. The result shows the scheduling order of each gate in the original circuit.; For pulse schedule, or scheduling gates with different duration,; one will need to wrap the qutip.qip.Gate object with qutip.qip.compiler.Instruction object,; with a parameter duration.; The result will then be the start time of each instruction. Noise Simulation¶; In the common way of QIP simulation, where evolution is carried out by gate matrix product, the noise is usually simulated with bit flipping and sign flipping errors.; The typical approaches are either applying bit/sign flipping gate probabilistically; or applying Kraus operators representing different noisy channels (e.g. amplitude damping, dephasing) after each unitary gate evolution. In the case of a single qubit, they have the same effect and the parameters in the Kraus operators are exactly the probability of a flipping error happens during the gate operation time.; Since the processor simulates the state evolution at the level of the driving Hamiltonian, there is no way to apply an error operator to the continuous-time evolution. Instead, the error is added to the p",MatchSource.WIKI,docs/4.7/guide/qip/qip-processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-processor.html
https://qutip.org/docs/4.7/guide/qip/qip-processor.html:20403,Energy Efficiency,schedul,schedule,20403,".pi/2., 2*np.pi/2, 3*np.pi/2])). # define noise, loc and scale are keyword arguments for np.random.normal; gaussnoise = RandomNoise(; dt=0.01, rand_gen=np.random.normal, loc=0.00, scale=0.02); processor.add_noise(gaussnoise). # Plot the ideal pulse; fig1, axis1 = processor.plot_pulses(title=""Original control amplitude"", figsize=(5,3)). # Plot the noisy pulse; qobjevo, _ = processor.get_qobjevo(noisy=True); noisy_coeff = qobjevo.to_list()[1][1] + qobjevo.to_list()[2][1]; fig2, axis2 = processor.plot_pulses(title=""Noisy control amplitude"", figsize=(5,3)); axis2[0].step(qobjevo.tlist, noisy_coeff). Customize the simulator¶; The number of predefined physical models and compilers are limited.; However, it is designed for easy customization and one can easily build customized model and compiling routines.; For guide and examples, please refer to the tutorial notebooks; at https://qutip.org/tutorials.html. The workflow of the simulator¶; The following plot demonstrates the workflow of the simulator. The core of the simulator is Processor,; which characterizes the quantum hardware of interest,; containing the information such as the non-controllable drift Hamiltonian and; the control Hamiltonian.; Apart from the ideal system representing the qubits, one can also define; hardware-dependent or pulse-dependent noise in Noise.; It describes how noisy terms such as imperfect control; and decoherence can be added once the ideal control pulse is defined.; When loading a quantum circuit, a GateCompiler compiles the circuit into a sequence of control pulse signals and schedule the pulse for parallel execution.; For each control Hamiltonian, a Pulse instance is created that including the ideal evolution and associated noise.; They will then be sent to the QuTiP solvers for the computation. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/qip/qip-processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-processor.html
https://qutip.org/docs/4.7/guide/qip/qip-processor.html:3545,Integrability,wrap,wrapper,3545,"gmaz(), cyclic_permutation=True) # sigmaz for all qubits; processor.pulses[0].coeffs = np.array([[1.0, 1.5, 2.0], [1.8, 1.3, 0.8]]); processor.pulses[0].tlist = np.array([0.1, 0.2, 0.4, 0.5]). It defines a \(\sigma_z\) operator on both qubits and a pulse that acts on the first qubit.; An equivalent approach is using the add_pulse method.; from qutip.qip.pulse import Pulse. processor = Processor(2); coeff=np.array([0.1, 0.2, 0.4, 0.5]); tlist=np.array([[1.0, 1.5, 2.0], [1.8, 1.3, 0.8]]); pulse = Pulse(sigmaz(), targets=0, coeff=coeff, tlist=tlist); processor.add_pulse(pulse). One can also use choose the pulse_mode attribute of Processor; between ""discrete"" and ""continuous"". Note; If the coefficients represent dicrete pulse, the length of each array is 1 element shorter than tlist. If it is supposed to be a continuous function, the length should be the same as tlist. The above example shows the framework and the most essential part of the simulator’s API. So far, it looks like just a wrapper for the open system solvers. However, based on this, we can implement different physical realizations. They differ mainly in how to find the control pulse for a quantum circuit, which gives birth to different sub-classes:. Processor; ├── ModelProcessor; │ ├── DispersiveCavityQED; │ └── SpinChain; └── OptPulseProcessor. In general, there are two ways to find the control pulses. The first one, ModelProcessor, is more experiment-oriented and based on physical models. A universal set of; gates is defined in the processor as well as the pulse implementing them in this particular physical model. This is usually the case where control pulses realizing those gates are well known and can be concatenated to realize the whole quantum circuits. Two realizations have already been implemented: the spin chain and the Cavity QED model for quantum computing. In those models, the driving Hamiltonians are predefined. Another approach, based on the optimal control module in QuTiP (see Quantum Optimal",MatchSource.WIKI,docs/4.7/guide/qip/qip-processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-processor.html
https://qutip.org/docs/4.7/guide/qip/qip-processor.html:4947,Integrability,depend,dependent,4947," find the control pulses. The first one, ModelProcessor, is more experiment-oriented and based on physical models. A universal set of; gates is defined in the processor as well as the pulse implementing them in this particular physical model. This is usually the case where control pulses realizing those gates are well known and can be concatenated to realize the whole quantum circuits. Two realizations have already been implemented: the spin chain and the Cavity QED model for quantum computing. In those models, the driving Hamiltonians are predefined. Another approach, based on the optimal control module in QuTiP (see Quantum Optimal Control), is called OptPulseProcessor. In this subclass, one only defines the available Hamiltonians in their system. The processor then uses algorithms to find the optimal control pulses that realize the desired unitary evolution.; Despite this difference, the logic behind all processors is the same:. One defines a processor by a list of available Hamiltonians and, as explained later, hardware-dependent noise. In model based processors, the Hamiltonians are predefined and one only needs to give the device parameters like frequency and interaction strength.; The control pulse coefficients and time slices are either specified by the user or calculated by the method load_circuit, which takes a QubitCircuit and find the control pulse for this evolution.; The processor calculates the evolution using the QuTiP solvers. Collapse operators can be added to simulate decoherence. The method run_state returns a object qutip.solver.Result. It is also possible to calculate the evolution analytically with matrix exponentiation by setting analytical=True. A list of the matrices representing the gates is returned just like for propagators. However, this does not consider the collapse operators or other noise. As the system size gets larger, this approach will become very inefficient.; In the following we describe the predefined subclasses for Processor:",MatchSource.WIKI,docs/4.7/guide/qip/qip-processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-processor.html
https://qutip.org/docs/4.7/guide/qip/qip-processor.html:11918,Integrability,depend,dependency,11918,"hardware parameters of the SpinChain model, processor.params, as well as a map between the pulse name and pulse index pulse_dict to the compiler.; The later one allows one to address the pulse more conveniently in the compiler.; The compiler returns a list of tlist and coeff, corresponding to each pulse.; The first pulse starts from t=0 and ends at t=1, with the strengh \(\pi/2\).; The second one is turned on from t=1 to t=2 with the same strength.; The compiled pulse here is different from what is shown in the plot; in the previous subsection because the scheduler is turned off by default.; The scheduler is implemented in the class Scheduler,; based on the idea of https://doi.org/10.1117/12.666419.; It schedules the order of quantum gates and instructions for the; shortest execution time.; It works not only for quantum gates but also for pulse implementation of gates; (Instruction) with varying pulse duration.; The scheduler first generates a quantum gates dependency graph,; containing information about which gates have to be executed before some other gates.; The graph preserves the mobility of the gates,; i.e. commuting gates are not dependent on each other, even if they use the same qubits.; Next, it computes the longest distance of each node to the start and end nodes.; The distance for each dependency arrow is defined by the execution time of the instruction; (By default, it is 1 for all gates).; This is used as a priority measure in the next step.; The gate with a longer distance to the end node and a shorter distance to the start node has higher priority.; In the last step, it uses a list-schedule algorithm with hardware constraint and; priority and returns a list of cycles for gates/instructions.; Since the algorithm is heuristics, sometimes it does not find the optimal solution.; Hence, we offer an option that randomly shuffles the commuting gates and; repeats the scheduling a few times to get a better result.; from qutip.qip.circuit import QubitCircuit; f",MatchSource.WIKI,docs/4.7/guide/qip/qip-processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-processor.html
https://qutip.org/docs/4.7/guide/qip/qip-processor.html:12101,Integrability,depend,dependent,12101," to address the pulse more conveniently in the compiler.; The compiler returns a list of tlist and coeff, corresponding to each pulse.; The first pulse starts from t=0 and ends at t=1, with the strengh \(\pi/2\).; The second one is turned on from t=1 to t=2 with the same strength.; The compiled pulse here is different from what is shown in the plot; in the previous subsection because the scheduler is turned off by default.; The scheduler is implemented in the class Scheduler,; based on the idea of https://doi.org/10.1117/12.666419.; It schedules the order of quantum gates and instructions for the; shortest execution time.; It works not only for quantum gates but also for pulse implementation of gates; (Instruction) with varying pulse duration.; The scheduler first generates a quantum gates dependency graph,; containing information about which gates have to be executed before some other gates.; The graph preserves the mobility of the gates,; i.e. commuting gates are not dependent on each other, even if they use the same qubits.; Next, it computes the longest distance of each node to the start and end nodes.; The distance for each dependency arrow is defined by the execution time of the instruction; (By default, it is 1 for all gates).; This is used as a priority measure in the next step.; The gate with a longer distance to the end node and a shorter distance to the start node has higher priority.; In the last step, it uses a list-schedule algorithm with hardware constraint and; priority and returns a list of cycles for gates/instructions.; Since the algorithm is heuristics, sometimes it does not find the optimal solution.; Hence, we offer an option that randomly shuffles the commuting gates and; repeats the scheduling a few times to get a better result.; from qutip.qip.circuit import QubitCircuit; from qutip.qip.compiler import Scheduler; circuit = QubitCircuit(7); circuit.add_gate(""SNOT"", 3) # gate0; circuit.add_gate(""CZ"", 5, 3) # gate1; circuit.add_gate(""CZ"", 4, 3) ",MatchSource.WIKI,docs/4.7/guide/qip/qip-processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-processor.html
https://qutip.org/docs/4.7/guide/qip/qip-processor.html:12264,Integrability,depend,dependency,12264,"h the strengh \(\pi/2\).; The second one is turned on from t=1 to t=2 with the same strength.; The compiled pulse here is different from what is shown in the plot; in the previous subsection because the scheduler is turned off by default.; The scheduler is implemented in the class Scheduler,; based on the idea of https://doi.org/10.1117/12.666419.; It schedules the order of quantum gates and instructions for the; shortest execution time.; It works not only for quantum gates but also for pulse implementation of gates; (Instruction) with varying pulse duration.; The scheduler first generates a quantum gates dependency graph,; containing information about which gates have to be executed before some other gates.; The graph preserves the mobility of the gates,; i.e. commuting gates are not dependent on each other, even if they use the same qubits.; Next, it computes the longest distance of each node to the start and end nodes.; The distance for each dependency arrow is defined by the execution time of the instruction; (By default, it is 1 for all gates).; This is used as a priority measure in the next step.; The gate with a longer distance to the end node and a shorter distance to the start node has higher priority.; In the last step, it uses a list-schedule algorithm with hardware constraint and; priority and returns a list of cycles for gates/instructions.; Since the algorithm is heuristics, sometimes it does not find the optimal solution.; Hence, we offer an option that randomly shuffles the commuting gates and; repeats the scheduling a few times to get a better result.; from qutip.qip.circuit import QubitCircuit; from qutip.qip.compiler import Scheduler; circuit = QubitCircuit(7); circuit.add_gate(""SNOT"", 3) # gate0; circuit.add_gate(""CZ"", 5, 3) # gate1; circuit.add_gate(""CZ"", 4, 3) # gate2; circuit.add_gate(""CZ"", 2, 3) # gate3; circuit.add_gate(""CZ"", 6, 5) # gate4; circuit.add_gate(""CZ"", 2, 6) # gate5; circuit.add_gate(""ISWAP"", [0, 2]) # gate6; scheduler = Scheduler",MatchSource.WIKI,docs/4.7/guide/qip/qip-processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-processor.html
https://qutip.org/docs/4.7/guide/qip/qip-processor.html:13580,Integrability,wrap,wrap,13580,"ast step, it uses a list-schedule algorithm with hardware constraint and; priority and returns a list of cycles for gates/instructions.; Since the algorithm is heuristics, sometimes it does not find the optimal solution.; Hence, we offer an option that randomly shuffles the commuting gates and; repeats the scheduling a few times to get a better result.; from qutip.qip.circuit import QubitCircuit; from qutip.qip.compiler import Scheduler; circuit = QubitCircuit(7); circuit.add_gate(""SNOT"", 3) # gate0; circuit.add_gate(""CZ"", 5, 3) # gate1; circuit.add_gate(""CZ"", 4, 3) # gate2; circuit.add_gate(""CZ"", 2, 3) # gate3; circuit.add_gate(""CZ"", 6, 5) # gate4; circuit.add_gate(""CZ"", 2, 6) # gate5; circuit.add_gate(""ISWAP"", [0, 2]) # gate6; scheduler = Scheduler(""ASAP""); result = scheduler.schedule(circuit, gates_schedule=True); print(result). Output; [0, 1, 3, 2, 2, 3, 4]. The result shows the scheduling order of each gate in the original circuit.; For pulse schedule, or scheduling gates with different duration,; one will need to wrap the qutip.qip.Gate object with qutip.qip.compiler.Instruction object,; with a parameter duration.; The result will then be the start time of each instruction. Noise Simulation¶; In the common way of QIP simulation, where evolution is carried out by gate matrix product, the noise is usually simulated with bit flipping and sign flipping errors.; The typical approaches are either applying bit/sign flipping gate probabilistically; or applying Kraus operators representing different noisy channels (e.g. amplitude damping, dephasing) after each unitary gate evolution. In the case of a single qubit, they have the same effect and the parameters in the Kraus operators are exactly the probability of a flipping error happens during the gate operation time.; Since the processor simulates the state evolution at the level of the driving Hamiltonian, there is no way to apply an error operator to the continuous-time evolution. Instead, the error is added to the p",MatchSource.WIKI,docs/4.7/guide/qip/qip-processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-processor.html
https://qutip.org/docs/4.7/guide/qip/qip-processor.html:19626,Integrability,rout,routines,19626,"add control Hamiltonians; processor = Processor(N=1); processor.add_control(sigmaz(), targets=0). # define pulse coefficients and tlist for all pulses; processor.pulses[0].coeff = np.array([0.3, 0.5, 0. ]); processor.set_all_tlist(np.array([0., np.pi/2., 2*np.pi/2, 3*np.pi/2])). # define noise, loc and scale are keyword arguments for np.random.normal; gaussnoise = RandomNoise(; dt=0.01, rand_gen=np.random.normal, loc=0.00, scale=0.02); processor.add_noise(gaussnoise). # Plot the ideal pulse; fig1, axis1 = processor.plot_pulses(title=""Original control amplitude"", figsize=(5,3)). # Plot the noisy pulse; qobjevo, _ = processor.get_qobjevo(noisy=True); noisy_coeff = qobjevo.to_list()[1][1] + qobjevo.to_list()[2][1]; fig2, axis2 = processor.plot_pulses(title=""Noisy control amplitude"", figsize=(5,3)); axis2[0].step(qobjevo.tlist, noisy_coeff). Customize the simulator¶; The number of predefined physical models and compilers are limited.; However, it is designed for easy customization and one can easily build customized model and compiling routines.; For guide and examples, please refer to the tutorial notebooks; at https://qutip.org/tutorials.html. The workflow of the simulator¶; The following plot demonstrates the workflow of the simulator. The core of the simulator is Processor,; which characterizes the quantum hardware of interest,; containing the information such as the non-controllable drift Hamiltonian and; the control Hamiltonian.; Apart from the ideal system representing the qubits, one can also define; hardware-dependent or pulse-dependent noise in Noise.; It describes how noisy terms such as imperfect control; and decoherence can be added once the ideal control pulse is defined.; When loading a quantum circuit, a GateCompiler compiles the circuit into a sequence of control pulse signals and schedule the pulse for parallel execution.; For each control Hamiltonian, a Pulse instance is created that including the ideal evolution and associated noise.; They will then ",MatchSource.WIKI,docs/4.7/guide/qip/qip-processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-processor.html
https://qutip.org/docs/4.7/guide/qip/qip-processor.html:20117,Integrability,depend,dependent,20117,".pi/2., 2*np.pi/2, 3*np.pi/2])). # define noise, loc and scale are keyword arguments for np.random.normal; gaussnoise = RandomNoise(; dt=0.01, rand_gen=np.random.normal, loc=0.00, scale=0.02); processor.add_noise(gaussnoise). # Plot the ideal pulse; fig1, axis1 = processor.plot_pulses(title=""Original control amplitude"", figsize=(5,3)). # Plot the noisy pulse; qobjevo, _ = processor.get_qobjevo(noisy=True); noisy_coeff = qobjevo.to_list()[1][1] + qobjevo.to_list()[2][1]; fig2, axis2 = processor.plot_pulses(title=""Noisy control amplitude"", figsize=(5,3)); axis2[0].step(qobjevo.tlist, noisy_coeff). Customize the simulator¶; The number of predefined physical models and compilers are limited.; However, it is designed for easy customization and one can easily build customized model and compiling routines.; For guide and examples, please refer to the tutorial notebooks; at https://qutip.org/tutorials.html. The workflow of the simulator¶; The following plot demonstrates the workflow of the simulator. The core of the simulator is Processor,; which characterizes the quantum hardware of interest,; containing the information such as the non-controllable drift Hamiltonian and; the control Hamiltonian.; Apart from the ideal system representing the qubits, one can also define; hardware-dependent or pulse-dependent noise in Noise.; It describes how noisy terms such as imperfect control; and decoherence can be added once the ideal control pulse is defined.; When loading a quantum circuit, a GateCompiler compiles the circuit into a sequence of control pulse signals and schedule the pulse for parallel execution.; For each control Hamiltonian, a Pulse instance is created that including the ideal evolution and associated noise.; They will then be sent to the QuTiP solvers for the computation. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/qip/qip-processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-processor.html
https://qutip.org/docs/4.7/guide/qip/qip-processor.html:20136,Integrability,depend,dependent,20136,".pi/2., 2*np.pi/2, 3*np.pi/2])). # define noise, loc and scale are keyword arguments for np.random.normal; gaussnoise = RandomNoise(; dt=0.01, rand_gen=np.random.normal, loc=0.00, scale=0.02); processor.add_noise(gaussnoise). # Plot the ideal pulse; fig1, axis1 = processor.plot_pulses(title=""Original control amplitude"", figsize=(5,3)). # Plot the noisy pulse; qobjevo, _ = processor.get_qobjevo(noisy=True); noisy_coeff = qobjevo.to_list()[1][1] + qobjevo.to_list()[2][1]; fig2, axis2 = processor.plot_pulses(title=""Noisy control amplitude"", figsize=(5,3)); axis2[0].step(qobjevo.tlist, noisy_coeff). Customize the simulator¶; The number of predefined physical models and compilers are limited.; However, it is designed for easy customization and one can easily build customized model and compiling routines.; For guide and examples, please refer to the tutorial notebooks; at https://qutip.org/tutorials.html. The workflow of the simulator¶; The following plot demonstrates the workflow of the simulator. The core of the simulator is Processor,; which characterizes the quantum hardware of interest,; containing the information such as the non-controllable drift Hamiltonian and; the control Hamiltonian.; Apart from the ideal system representing the qubits, one can also define; hardware-dependent or pulse-dependent noise in Noise.; It describes how noisy terms such as imperfect control; and decoherence can be added once the ideal control pulse is defined.; When loading a quantum circuit, a GateCompiler compiles the circuit into a sequence of control pulse signals and schedule the pulse for parallel execution.; For each control Hamiltonian, a Pulse instance is created that including the ideal evolution and associated noise.; They will then be sent to the QuTiP solvers for the computation. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/qip/qip-processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-processor.html
https://qutip.org/docs/4.7/guide/qip/qip-processor.html:8164,Performance,optimiz,optimized,8164,"= LinearSpinChain(2); processor.load_circuit(qc); fig, axis = processor.plot_pulses(); fig.show(). DispersiveCavityQED; Same as above, DispersiveCavityQED is a simulator based on Cavity Quantum Electrodynamics. The workflow is similar to the one for the spin chain, except that the component systems are a multi-level cavity and a qubits system. The control Hamiltonians are the single-qubit rotation together with the qubits-cavity interaction \(a^{\dagger} \sigma^{-} + a \sigma^{+}\). The device parameters including the cavity frequency, qubits frequency, detuning and interaction strength etc. Note; The run_state method of DispersiveCavityQED; returns the full simulation result of the solver,; hence including the cavity.; To obtain the circuit result, one needs to first trace out the cavity state. OptPulseProcessor; The OptPulseProcessor uses the function in optimize_pulse_unitary in the optimal control module to find the control pulses. The Hamiltonian includes a drift part and a control part and only the control part will be optimized. The unitary evolution follows. \[U(\Delta t)=\exp(\rm{i} \cdot \Delta t [H_d + \sum_j u_j H_j] )\]; To let it find the optimal pulses, we need to give the parameters for optimize_pulse_unitary as keyword arguments to load_circuit. Usually, the minimal requirements are the evolution time evo_time and the number of time slices num_tslots for each gate. Other parameters can also be given in the keyword arguments. For available choices, see optimize_pulse_unitary. It is also possible to specify different parameters for different gates, as shown in the following example:; from qutip.qip.device import OptPulseProcessor; from qutip.operators import sigmaz, sigmax, sigmay; from qutip.tensor import tensor. # Same parameter for all the gates; qc = QubitCircuit(N=1); qc.add_gate(""SNOT"", 0). num_tslots = 10; evo_time = 10; processor = OptPulseProcessor(N=1, drift=sigmaz()); processor.add_control(sigmax()); # num_tslots and evo_time are two keywor",MatchSource.WIKI,docs/4.7/guide/qip/qip-processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-processor.html
https://qutip.org/docs/4.7/guide/qip/qip-processor.html:20295,Performance,load,loading,20295,".pi/2., 2*np.pi/2, 3*np.pi/2])). # define noise, loc and scale are keyword arguments for np.random.normal; gaussnoise = RandomNoise(; dt=0.01, rand_gen=np.random.normal, loc=0.00, scale=0.02); processor.add_noise(gaussnoise). # Plot the ideal pulse; fig1, axis1 = processor.plot_pulses(title=""Original control amplitude"", figsize=(5,3)). # Plot the noisy pulse; qobjevo, _ = processor.get_qobjevo(noisy=True); noisy_coeff = qobjevo.to_list()[1][1] + qobjevo.to_list()[2][1]; fig2, axis2 = processor.plot_pulses(title=""Noisy control amplitude"", figsize=(5,3)); axis2[0].step(qobjevo.tlist, noisy_coeff). Customize the simulator¶; The number of predefined physical models and compilers are limited.; However, it is designed for easy customization and one can easily build customized model and compiling routines.; For guide and examples, please refer to the tutorial notebooks; at https://qutip.org/tutorials.html. The workflow of the simulator¶; The following plot demonstrates the workflow of the simulator. The core of the simulator is Processor,; which characterizes the quantum hardware of interest,; containing the information such as the non-controllable drift Hamiltonian and; the control Hamiltonian.; Apart from the ideal system representing the qubits, one can also define; hardware-dependent or pulse-dependent noise in Noise.; It describes how noisy terms such as imperfect control; and decoherence can be added once the ideal control pulse is defined.; When loading a quantum circuit, a GateCompiler compiles the circuit into a sequence of control pulse signals and schedule the pulse for parallel execution.; For each control Hamiltonian, a Pulse instance is created that including the ideal evolution and associated noise.; They will then be sent to the QuTiP solvers for the computation. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/qip/qip-processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-processor.html
https://qutip.org/docs/4.7/guide/qip/qip-processor.html:4811,Testability,log,logic,4811,"persiveCavityQED; │ └── SpinChain; └── OptPulseProcessor. In general, there are two ways to find the control pulses. The first one, ModelProcessor, is more experiment-oriented and based on physical models. A universal set of; gates is defined in the processor as well as the pulse implementing them in this particular physical model. This is usually the case where control pulses realizing those gates are well known and can be concatenated to realize the whole quantum circuits. Two realizations have already been implemented: the spin chain and the Cavity QED model for quantum computing. In those models, the driving Hamiltonians are predefined. Another approach, based on the optimal control module in QuTiP (see Quantum Optimal Control), is called OptPulseProcessor. In this subclass, one only defines the available Hamiltonians in their system. The processor then uses algorithms to find the optimal control pulses that realize the desired unitary evolution.; Despite this difference, the logic behind all processors is the same:. One defines a processor by a list of available Hamiltonians and, as explained later, hardware-dependent noise. In model based processors, the Hamiltonians are predefined and one only needs to give the device parameters like frequency and interaction strength.; The control pulse coefficients and time slices are either specified by the user or calculated by the method load_circuit, which takes a QubitCircuit and find the control pulse for this evolution.; The processor calculates the evolution using the QuTiP solvers. Collapse operators can be added to simulate decoherence. The method run_state returns a object qutip.solver.Result. It is also possible to calculate the evolution analytically with matrix exponentiation by setting analytical=True. A list of the matrices representing the gates is returned just like for propagators. However, this does not consider the collapse operators or other noise. As the system size gets larger, this approach will bec",MatchSource.WIKI,docs/4.7/guide/qip/qip-processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-processor.html
https://qutip.org/docs/4.7/guide/qip/qip-processor.html:6366,Usability,simpl,simple,6366,"perators can be added to simulate decoherence. The method run_state returns a object qutip.solver.Result. It is also possible to calculate the evolution analytically with matrix exponentiation by setting analytical=True. A list of the matrices representing the gates is returned just like for propagators. However, this does not consider the collapse operators or other noise. As the system size gets larger, this approach will become very inefficient.; In the following we describe the predefined subclasses for Processor:; SpinChain; LinearSpinChain and CircularSpinChain are quantum computing models base on the spin chain realization. The control Hamiltonians are \(\sigma_x\), \(\sigma_z\) and \(\sigma_x \sigma_x + \sigma_y \sigma_y\). This processor will first decompose the gate into the universal gate set with ISWAP or SQRTISWAP as two-qubit gates, resolve them into quantum gates of adjacent qubits and then calculate the pulse coefficients.; An example of simulating a simple circuit is shown below:; from qutip import basis; from qutip.qip.circuit import QubitCircuit; from qutip.qip.device import LinearSpinChain. qc = QubitCircuit(2); qc.add_gate(""X"", targets=0); qc.add_gate(""X"", targets=1); processor = LinearSpinChain(2); processor.load_circuit(qc); result = processor.run_state(basis([2,2], [0,0])); print(result.states[-1].tidyup(1.0e-6)). Quantum object: dims = [[2, 2], [1, 1]], shape = (4, 1), type = ket; Qobj data =; [[ 0.]; [ 0.]; [ 0.]; [-1.]]. We can also visualize the pulses implementing this circuit:; from qutip import basis; from qutip.qip.circuit import QubitCircuit; from qutip.qip.device import LinearSpinChain. qc = QubitCircuit(2); qc.add_gate(""X"", targets=0); qc.add_gate(""X"", targets=1); processor = LinearSpinChain(2); processor.load_circuit(qc); fig, axis = processor.plot_pulses(); fig.show(). DispersiveCavityQED; Same as above, DispersiveCavityQED is a simulator based on Cavity Quantum Electrodynamics. The workflow is similar to the one for the spin chai",MatchSource.WIKI,docs/4.7/guide/qip/qip-processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-processor.html
https://qutip.org/docs/4.7/guide/qip/qip-processor.html:16787,Usability,simpl,simplest,16787,"ecrease. It is not always easy or even possible to define a noisy gate matrix. In our simulator, it can be done by defining a ControlAmpNoise (Control Amplitude Noise).; In the simulation, noise can be added to the processor at different levels:. The decoherence time T1 and T2 can be defined for the processor or for each qubit. When calculating the evolution, the corresponding collapse operators will be added automatically to the solver.; The noise of the physical parameters (e.g. detuned frequency) can be simulated by changing the parameters in the model, e.g. laser frequency in cavity QED. (This can only be time-independent since QuTiP open system solver only allows varying coefficients, not varying Hamiltonian operators.); The noise of the pulse intensity can be simulated by modifying the coefficients of the Hamiltonian operators or even adding new Hamiltonians. To add noise to a processor, one needs to first define a noise object Noise. The simplest relaxation noise can be defined directly in the processor with relaxation time. Other pre-defined noise can be found as subclasses of Noise. We can add noise to the simulator with the method add_noise.; Below, we show two examples.; The first example is a processor with one qubit under rotation around the z-axis and relaxation time \(T_2=5\). We measure the population of the \(\left| + \right\rangle\) state and observe the Ramsey signal:; import numpy as np; import matplotlib.pyplot as plt; from qutip import sigmaz, destroy, basis; from qutip.qip.device import Processor; from qutip.qip.operations import snot. a = destroy(2); Hadamard = snot(); plus_state = (basis(2,1) + basis(2,0)).unit(); tlist = np.arange(0.00, 20.2, 0.2). T2 = 5; processor = Processor(1, t2=T2); processor.add_control(sigmaz()); processor.pulses[0].coeff = np.ones(len(tlist)); processor.pulses[0].tlist = tlist; result = processor.run_state(; plus_state, e_ops=[a.dag()*a, Hadamard*a.dag()*a*Hadamard]). fig, ax = plt.subplots(); # detail about length ",MatchSource.WIKI,docs/4.7/guide/qip/qip-processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-processor.html
https://qutip.org/docs/4.7/guide/qip/qip-processor.html:19641,Usability,guid,guide,19641,"# define pulse coefficients and tlist for all pulses; processor.pulses[0].coeff = np.array([0.3, 0.5, 0. ]); processor.set_all_tlist(np.array([0., np.pi/2., 2*np.pi/2, 3*np.pi/2])). # define noise, loc and scale are keyword arguments for np.random.normal; gaussnoise = RandomNoise(; dt=0.01, rand_gen=np.random.normal, loc=0.00, scale=0.02); processor.add_noise(gaussnoise). # Plot the ideal pulse; fig1, axis1 = processor.plot_pulses(title=""Original control amplitude"", figsize=(5,3)). # Plot the noisy pulse; qobjevo, _ = processor.get_qobjevo(noisy=True); noisy_coeff = qobjevo.to_list()[1][1] + qobjevo.to_list()[2][1]; fig2, axis2 = processor.plot_pulses(title=""Noisy control amplitude"", figsize=(5,3)); axis2[0].step(qobjevo.tlist, noisy_coeff). Customize the simulator¶; The number of predefined physical models and compilers are limited.; However, it is designed for easy customization and one can easily build customized model and compiling routines.; For guide and examples, please refer to the tutorial notebooks; at https://qutip.org/tutorials.html. The workflow of the simulator¶; The following plot demonstrates the workflow of the simulator. The core of the simulator is Processor,; which characterizes the quantum hardware of interest,; containing the information such as the non-controllable drift Hamiltonian and; the control Hamiltonian.; Apart from the ideal system representing the qubits, one can also define; hardware-dependent or pulse-dependent noise in Noise.; It describes how noisy terms such as imperfect control; and decoherence can be added once the ideal control pulse is defined.; When loading a quantum circuit, a GateCompiler compiles the circuit into a sequence of control pulse signals and schedule the pulse for parallel execution.; For each control Hamiltonian, a Pulse instance is created that including the ideal evolution and associated noise.; They will then be sent to the QuTiP solvers for the computation. Next ; Previous. © Copyright 2011 to 2021 inclusi",MatchSource.WIKI,docs/4.7/guide/qip/qip-processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-processor.html
https://qutip.org/docs/4.7/guide/qip/qip-simulator.html:10223,Deployability,update,updated,10223,"bit:; qc = QubitCircuit(N=3, num_cbits=3); qc.user_gates = {""cH"": controlled_hadamard}; qc.add_gate(""QASMU"", targets=[0], arg_value=[1.91063, 0, 0]); qc.add_gate(""cH"", targets=[0,1]); qc.add_gate(""TOFFOLI"", targets=[2], controls=[0, 1]); qc.add_gate(""X"", targets=[0]); qc.add_gate(""X"", targets=[1]); qc.add_gate(""CNOT"", targets=[1], controls=0); qc.add_measurement(""M0"", targets=[0], classical_store=0); qc.add_measurement(""M0"", targets=[1], classical_store=0); qc.add_measurement(""M0"", targets=[2], classical_store=0); sim = CircuitSimulator(qc, mode=""density_matrix_simulator""); print(sim.run(zero_state).get_final_states()[0]). Quantum object: dims = [[2, 2, 2], [2, 2, 2]], shape = (8, 8), type = oper, isherm = True; Qobj data =; [[0. 0. 0. 0. 0. 0.; 0. 0. ]; [0. 0.33333257 0. 0. 0. 0.; 0. 0. ]; [0. 0. 0.33333257 0. 0. 0.; 0. 0. ]; [0. 0. 0. 0. 0. 0.; 0. 0. ]; [0. 0. 0. 0. 0.33333486 0.; 0. 0. ]; [0. 0. 0. 0. 0. 0.; 0. 0. ]; [0. 0. 0. 0. 0. 0.; 0. 0. ]; [0. 0. 0. 0. 0. 0.; 0. 0. ]]. We are left with a mixed state. Import and export quantum circuits¶; QuTiP supports importation and exportation of quantum circuit in the OpenQASM 2 format; through the functions read_qasm and save_qasm.; We demonstrate this using the w-state generation circuit.; The following code is in OpenQASM format:; // Name of Experiment: W-state v1. OPENQASM 2.0;; include ""qelib1.inc"";. qreg q[4];; creg c[3];; gate cH a,b {; h b;; sdg b;; cx a,b;; h b;; t b;; cx a,b;; t b;; h b;; s b;; x b;; s a;; }. u3(1.91063,0,0) q[0];; cH q[0],q[1];; ccx q[0],q[1],q[2];; x q[0];; x q[1];; cx q[0],q[1];. measure q[0] -> c[0];; measure q[1] -> c[1];; measure q[2] -> c[2];. One can save it in a .qasm file and import it using the following code:; from qutip.qip.qasm import read_qasm; qc = read_qasm(""guide/qip/w-state.qasm""). Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/qip/qip-simulator.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-simulator.html
https://qutip.org/docs/4.7/guide/qip/qip-simulator.html:7368,Energy Efficiency,efficient,efficient,7368,"y=True). print(sim.ops). [Quantum object: dims = [[2, 2, 2], [2, 2, 2]], shape = (8, 8), type = oper, isherm = False; Qobj data =; [[ 0. 0.57734961 0. -0.57734961 0. 0.40824922; 0. -0.40824922]; [ 0.57734961 0. -0.57734961 0. 0.40824922 0.; -0.40824922 0. ]; [ 0.57734961 0. 0.57734961 0. 0.40824922 0.; 0.40824922 0. ]; [ 0. 0.57734961 0. 0.57734961 0. 0.40824922; 0. 0.40824922]; [ 0.57735159 0. 0. 0. -0.81649565 0.; 0. 0. ]; [ 0. 0.57735159 0. 0. 0. -0.81649565; 0. 0. ]; [ 0. 0. 0.57735159 0. 0. 0.; -0.81649565 0. ]; [ 0. 0. 0. 0.57735159 0. 0.; 0. -0.81649565]],; Measurement(M0, target=[0], classical_store=0),; Measurement(M1, target=[1], classical_store=1),; Measurement(M2, target=[2], classical_store=2)]. Here, sim.ops stores all the circuit operations that are going to be applied during; state evolution. As observed above, all the unitaries of the circuit are compressed into; a single unitary product with the precompute optimization enabled.; This is more efficient if one runs the same circuit one multiple initial states.; However, as the number of qubits increases, this will consume more and more memory; and become unfeasible. Density Matrix Simulation¶; By default, the state evolution is carried out in the “state_vector_simulator” mode; (specified by the mode argument) as described before.; In the “density_matrix_simulator” mode, the input state can be either a ket or a density; matrix. If it is a ket, it is converted into a density matrix before the evolution is; carried out. Unlike the “state_vector_simulator” mode, upon measurement, the state; does not collapse to one of the post-measurement states. Rather, the new state is now; the density matrix representing the ensemble of post-measurement states.; In this sense, we measure the qubits and forget all the results.; To demonstrate this consider the original W-state preparation circuit which is followed; just by measurement on the first qubit:; qc = QubitCircuit(N=3, num_cbits=3); qc.user_gates = {""cH"": cont",MatchSource.WIKI,docs/4.7/guide/qip/qip-simulator.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-simulator.html
https://qutip.org/docs/4.7/guide/qip/qip-simulator.html:7332,Performance,optimiz,optimization,7332,"putes the product of the unitaries (in between the measurements):; sim = CircuitSimulator(qc, precompute_unitary=True). print(sim.ops). [Quantum object: dims = [[2, 2, 2], [2, 2, 2]], shape = (8, 8), type = oper, isherm = False; Qobj data =; [[ 0. 0.57734961 0. -0.57734961 0. 0.40824922; 0. -0.40824922]; [ 0.57734961 0. -0.57734961 0. 0.40824922 0.; -0.40824922 0. ]; [ 0.57734961 0. 0.57734961 0. 0.40824922 0.; 0.40824922 0. ]; [ 0. 0.57734961 0. 0.57734961 0. 0.40824922; 0. 0.40824922]; [ 0.57735159 0. 0. 0. -0.81649565 0.; 0. 0. ]; [ 0. 0.57735159 0. 0. 0. -0.81649565; 0. 0. ]; [ 0. 0. 0.57735159 0. 0. 0.; -0.81649565 0. ]; [ 0. 0. 0. 0.57735159 0. 0.; 0. -0.81649565]],; Measurement(M0, target=[0], classical_store=0),; Measurement(M1, target=[1], classical_store=1),; Measurement(M2, target=[2], classical_store=2)]. Here, sim.ops stores all the circuit operations that are going to be applied during; state evolution. As observed above, all the unitaries of the circuit are compressed into; a single unitary product with the precompute optimization enabled.; This is more efficient if one runs the same circuit one multiple initial states.; However, as the number of qubits increases, this will consume more and more memory; and become unfeasible. Density Matrix Simulation¶; By default, the state evolution is carried out in the “state_vector_simulator” mode; (specified by the mode argument) as described before.; In the “density_matrix_simulator” mode, the input state can be either a ket or a density; matrix. If it is a ket, it is converted into a density matrix before the evolution is; carried out. Unlike the “state_vector_simulator” mode, upon measurement, the state; does not collapse to one of the post-measurement states. Rather, the new state is now; the density matrix representing the ensemble of post-measurement states.; In this sense, we measure the qubits and forget all the results.; To demonstrate this consider the original W-state preparation circuit which is foll",MatchSource.WIKI,docs/4.7/guide/qip/qip-simulator.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-simulator.html
https://qutip.org/docs/4.7/guide/qip/qip-simulator.html:1314,Usability,simpl,simple,1314,"erarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Quantum Information Processing; Operator-level circuit simulation; Run a quantum circuit; Circuit simulator; Precomputing the unitary; Density Matrix Simulation; Import and export quantum circuits. Pulse-level circuit simulation. Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Quantum Information Processing »; Operator-level circuit simulation. Operator-level circuit simulation¶. Note; New in QuTiP 4.6. Run a quantum circuit¶; Let’s start off by defining a simple circuit which we use to demonstrate a few; examples of circuit evolution.; We take a circuit from OpenQASM 2; from qutip.qip.circuit import QubitCircuit, Gate; from qutip.qip.operations import controlled_gate, hadamard_transform; def controlled_hadamard():; # Controlled Hadamard; return controlled_gate(; hadamard_transform(1), 2, control=0, target=1, control_value=1); qc = QubitCircuit(N=3, num_cbits=3); qc.user_gates = {""cH"": controlled_hadamard}; qc.add_gate(""QASMU"", targets=[0], arg_value=[1.91063, 0, 0]); qc.add_gate(""cH"", targets=[0,1]); qc.add_gate(""TOFFOLI"", targets=[2], controls=[0, 1]); qc.add_gate(""X"", targets=[0]); qc.add_gate(""X"", targets=[1]); qc.add_gate(""CNOT"", targets=[1], controls=0). It corresponds to the following circuit:. We will add the measurement gates later. This circuit prepares the W-state \((\ket{001} + \ket{010} + \ket{100})/\sqrt{3}\).; The simplest way to carry out state evolution through a quantum circuit is; providing a input state to the run; method.; from q",MatchSource.WIKI,docs/4.7/guide/qip/qip-simulator.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-simulator.html
https://qutip.org/docs/4.7/guide/qip/qip-simulator.html:2204,Usability,simpl,simplest,2204,". Run a quantum circuit¶; Let’s start off by defining a simple circuit which we use to demonstrate a few; examples of circuit evolution.; We take a circuit from OpenQASM 2; from qutip.qip.circuit import QubitCircuit, Gate; from qutip.qip.operations import controlled_gate, hadamard_transform; def controlled_hadamard():; # Controlled Hadamard; return controlled_gate(; hadamard_transform(1), 2, control=0, target=1, control_value=1); qc = QubitCircuit(N=3, num_cbits=3); qc.user_gates = {""cH"": controlled_hadamard}; qc.add_gate(""QASMU"", targets=[0], arg_value=[1.91063, 0, 0]); qc.add_gate(""cH"", targets=[0,1]); qc.add_gate(""TOFFOLI"", targets=[2], controls=[0, 1]); qc.add_gate(""X"", targets=[0]); qc.add_gate(""X"", targets=[1]); qc.add_gate(""CNOT"", targets=[1], controls=0). It corresponds to the following circuit:. We will add the measurement gates later. This circuit prepares the W-state \((\ket{001} + \ket{010} + \ket{100})/\sqrt{3}\).; The simplest way to carry out state evolution through a quantum circuit is; providing a input state to the run; method.; from qutip import tensor; zero_state = tensor(basis(2, 0), basis(2, 0), basis(2, 0)); result = qc.run(state=zero_state); wstate = result. print(wstate). Output:; Quantum object: dims = [[2, 2, 2], [1, 1, 1]], shape = (8, 1), type = ket; Qobj data =; [[0. ]; [0.57734961]; [0.57734961]; [0. ]; [0.57735159]; [0. ]; [0. ]; [0. ]]. As expected, the state returned is indeed the required W-state.; As soon as we introduce measurements into the circuit, it can lead to multiple outcomes; with associated probabilities. We can also carry out circuit evolution in a manner such that it returns all the possible state; outputs along with their corresponding probabilities. Suppose, in the previous circuit,; we measure each of the three qubits at the end.; qc.add_measurement(""M0"", targets=[0], classical_store=0); qc.add_measurement(""M1"", targets=[1], classical_store=1); qc.add_measurement(""M2"", targets=[2], classical_store=2). To get all the ",MatchSource.WIKI,docs/4.7/guide/qip/qip-simulator.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-simulator.html
https://qutip.org/docs/4.7/guide/qip/qip-simulator.html:10101,Usability,guid,guide,10101,"bit:; qc = QubitCircuit(N=3, num_cbits=3); qc.user_gates = {""cH"": controlled_hadamard}; qc.add_gate(""QASMU"", targets=[0], arg_value=[1.91063, 0, 0]); qc.add_gate(""cH"", targets=[0,1]); qc.add_gate(""TOFFOLI"", targets=[2], controls=[0, 1]); qc.add_gate(""X"", targets=[0]); qc.add_gate(""X"", targets=[1]); qc.add_gate(""CNOT"", targets=[1], controls=0); qc.add_measurement(""M0"", targets=[0], classical_store=0); qc.add_measurement(""M0"", targets=[1], classical_store=0); qc.add_measurement(""M0"", targets=[2], classical_store=0); sim = CircuitSimulator(qc, mode=""density_matrix_simulator""); print(sim.run(zero_state).get_final_states()[0]). Quantum object: dims = [[2, 2, 2], [2, 2, 2]], shape = (8, 8), type = oper, isherm = True; Qobj data =; [[0. 0. 0. 0. 0. 0.; 0. 0. ]; [0. 0.33333257 0. 0. 0. 0.; 0. 0. ]; [0. 0. 0.33333257 0. 0. 0.; 0. 0. ]; [0. 0. 0. 0. 0. 0.; 0. 0. ]; [0. 0. 0. 0. 0.33333486 0.; 0. 0. ]; [0. 0. 0. 0. 0. 0.; 0. 0. ]; [0. 0. 0. 0. 0. 0.; 0. 0. ]; [0. 0. 0. 0. 0. 0.; 0. 0. ]]. We are left with a mixed state. Import and export quantum circuits¶; QuTiP supports importation and exportation of quantum circuit in the OpenQASM 2 format; through the functions read_qasm and save_qasm.; We demonstrate this using the w-state generation circuit.; The following code is in OpenQASM format:; // Name of Experiment: W-state v1. OPENQASM 2.0;; include ""qelib1.inc"";. qreg q[4];; creg c[3];; gate cH a,b {; h b;; sdg b;; cx a,b;; h b;; t b;; cx a,b;; t b;; h b;; s b;; x b;; s a;; }. u3(1.91063,0,0) q[0];; cH q[0],q[1];; ccx q[0],q[1],q[2];; x q[0];; x q[1];; cx q[0],q[1];. measure q[0] -> c[0];; measure q[1] -> c[1];; measure q[2] -> c[2];. One can save it in a .qasm file and import it using the following code:; from qutip.qip.qasm import read_qasm; qc = read_qasm(""guide/qip/w-state.qasm""). Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/qip/qip-simulator.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-simulator.html
https://qutip.org/docs/4.7/modules/qutip/about.html:2682,Deployability,update,updated,2682,"nt(""================================""); print(""Copyright (c) QuTiP team 2011 and later.""); print(; ""Current admin team: Alexander Pitchford, ""; ""Nathan Shammah, Shahnawaz Ahmed, Neill Lambert, Eric Giguère, ""; ""Boxi Li, Jake Lishman, Simon Cross and Asier Galicia.""; ); print(; ""Board members: Daniel Burgarth, Robert Johansson, Anton F. Kockum, ""; ""Franco Nori and Will Zeng.""; ); print(""Original developers: R. J. Johansson & P. D. Nation.""); print(""Previous lead developers: Chris Granade & A. Grimsmo.""); print(""Currently developed through wide collaboration. ""; ""See https://github.com/qutip for details.""); print(""""); print(""QuTiP Version: %s"" % qutip.__version__); print(""Numpy Version: %s"" % numpy.__version__); print(""Scipy Version: %s"" % scipy.__version__); try:; import Cython; cython_ver = Cython.__version__; except ImportError:; cython_ver = 'None'; print(""Cython Version: %s"" % cython_ver); try:; import matplotlib; matplotlib_ver = matplotlib.__version__; except ImportError:; matplotlib_ver = 'None'; print(""Matplotlib Version: %s"" % matplotlib_ver); print(""Python Version: %d.%d.%d"" % sys.version_info[0:3]); print(""Number of CPUs: %s"" % available_cpu_count()); print(""BLAS Info: %s"" % _blas_info()); print(""OPENMP Installed: %s"" % str(qutip.settings.has_openmp)); print(""INTEL MKL Ext: %s"" % str(qutip.settings.has_mkl)); print(""Platform Info: %s (%s)"" % (platform.system(),; platform.machine())); qutip_install_path = os.path.dirname(inspect.getsourcefile(qutip)); print(""Installation path: %s"" % qutip_install_path). # citation; longbar = ""="" * 80; cite_msg = ""For your convenience a bibtex reference can be easily""; cite_msg += "" generated using `qutip.cite()`""; print(longbar); print(""Please cite QuTiP in your publication.""); print(longbar); print(cite_msg). if __name__ == ""__main__"":; about(). © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/modules/qutip/about.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/about.html
https://qutip.org/docs/4.7/modules/qutip/about.html:393,Integrability,depend,dependencies,393,". qutip.about — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.about. Source code for qutip.about; """"""; Command line output of information on QuTiP and dependencies.; """"""; __all__ = ['about']. import sys; import os; import platform; import numpy; import scipy; import inspect; from qutip.utilities import _blas_info, available_cpu_count; import qutip.settings. [docs]def about():; """"""; About box for QuTiP. Gives version numbers for QuTiP, NumPy, SciPy, Cython,; and MatPlotLib.; """"""; print(""""); print(""QuTiP: Quantum Toolbox in Python""); print(""================================""); print(""Copyright (c) QuTiP team 2011 and later.""); print(; ""Current admin team: Alexander Pitchford, ""; ""Nathan Shammah, Shahnawaz Ahmed, Neill Lambert, Eric Giguère, ""; ""Boxi Li, Jake Lishman, Simon Cross and Asier Galicia.""; ); print(; ""Board members: Daniel Burgarth, Robert Johansson, Anton F. Kockum, ""; ""Franco Nori and Will Zeng.""; ); print(""Original developers: R. J. Johansson & P. D. Nation.""); print(""Previous lead developers: Chris Granade & A. Grimsmo.""); print(""Currently developed through wide collaboration. ""; ""See https://github.com/qutip for details.""); print(""""); print(""QuTiP Version: %s"" % qutip.__version__); print(""Numpy Version: %s"" % numpy.__version__); print(""Scipy Version: %s"" % scipy.__version__); try:; import Cython; cython_ver = Cython.__version__; except ImportError:; cython_ver = 'None'; print(""Cython Version: %s"" % cython_ver); try:; import matplotlib; matplotlib_ver = matplotlib.__version__; except ImportError:; matplotlib_ver = 'None'; print(""Matplotlib Version: %s"" % matplotlib_ver); print(""Python Version: %d.%d.%d"" % sys.version_info[0:3]); print(""Number of CPUs: %s"" % available_cpu_count()); print(""BLAS Info: %s"" % _blas_info());",MatchSource.WIKI,docs/4.7/modules/qutip/about.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/about.html
https://qutip.org/docs/4.7/modules/qutip/bloch.html:794,Deployability,patch,patches,794,". qutip.bloch — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.bloch. Source code for qutip.bloch; __all__ = ['Bloch']. import os. from numpy import (ndarray, array, linspace, pi, outer, cos, sin, ones, size,; sqrt, real, mod, append, ceil, arange); import numpy as np. from packaging.version import parse as parse_version. from qutip.qobj import Qobj; from qutip.expect import expect; from qutip.operators import sigmax, sigmay, sigmaz. try:; import matplotlib; import matplotlib.pyplot as plt; from mpl_toolkits.mplot3d import Axes3D; from matplotlib.patches import FancyArrowPatch; from mpl_toolkits.mplot3d import proj3d. # Define a custom _axes3D function based on the matplotlib version.; # The auto_add_to_figure keyword is new for matplotlib>=3.4.; if parse_version(matplotlib.__version__) >= parse_version('3.4'):; def _axes3D(fig, *args, **kwargs):; ax = Axes3D(fig, *args, auto_add_to_figure=False, **kwargs); return fig.add_axes(ax); else:; def _axes3D(*args, **kwargs):; return Axes3D(*args, **kwargs). class Arrow3D(FancyArrowPatch):; def __init__(self, xs, ys, zs, *args, **kwargs):; FancyArrowPatch.__init__(self, (0, 0), (0, 0), *args, **kwargs). self._verts3d = xs, ys, zs. def draw(self, renderer):; xs3d, ys3d, zs3d = self._verts3d; xs, ys, zs = proj3d.proj_transform(xs3d, ys3d, zs3d, self.axes.M). self.set_positions((xs[0], ys[0]), (xs[1], ys[1])); FancyArrowPatch.draw(self, renderer). def do_3d_projection(self, renderer=None):; # only called by matplotlib >= 3.5; xs3d, ys3d, zs3d = self._verts3d; xs, ys, zs = proj3d.proj_transform(xs3d, ys3d, zs3d, self.axes.M); self.set_positions((xs[0], ys[0]), (xs[1], ys[1])); return np.min(zs); except ImportError:; pass. try:; from IPython.display import display; except ImportError:; pass. [",MatchSource.WIKI,docs/4.7/modules/qutip/bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch.html
https://qutip.org/docs/4.7/modules/qutip/bloch.html:19847,Deployability,update,update,19847,"if self.axes is None:; self.axes = _axes3D(self.fig, azim=self.view[0], elev=self.view[1]). # Clearing the axes is horrifically slow and loses a lot of the; # axes state, but matplotlib doesn't seem to provide a better way; # to redraw Axes3D. :/; self.axes.clear(); self.axes.grid(False); if self.background:; self.axes.set_xlim3d(-1.3, 1.3); self.axes.set_ylim3d(-1.3, 1.3); self.axes.set_zlim3d(-1.3, 1.3); else:; self.axes.set_axis_off(); self.axes.set_xlim3d(-0.7, 0.7); self.axes.set_ylim3d(-0.7, 0.7); self.axes.set_zlim3d(-0.7, 0.7); # Manually set aspect ratio to fit a square bounding box.; # Matplotlib did this stretching for < 3.3.0, but not above.; if parse_version(matplotlib.__version__) >= parse_version('3.3'):; self.axes.set_box_aspect((1, 1, 1)); if not self.background:; self.plot_axes(). self.plot_back(); self.plot_points(); self.plot_vectors(); self.plot_lines(); self.plot_arcs(); self.plot_front(); self.plot_axes_labels(); self.plot_annotations(); # Trigger an update of the Bloch sphere if it is already shown:; self.fig.canvas.draw(). def plot_back(self):; # back half of sphere; u = linspace(0, pi, 25); v = linspace(0, pi, 25); x = outer(cos(u), sin(v)); y = outer(sin(u), sin(v)); z = outer(ones(size(u)), cos(v)); self.axes.plot_surface(x, y, z, rstride=2, cstride=2,; color=self.sphere_color, linewidth=0,; alpha=self.sphere_alpha); # wireframe; self.axes.plot_wireframe(x, y, z, rstride=5, cstride=5,; color=self.frame_color,; alpha=self.frame_alpha); # equator; self.axes.plot(1.0 * cos(u), 1.0 * sin(u), zs=0, zdir='z',; lw=self.frame_width, color=self.frame_color); self.axes.plot(1.0 * cos(u), 1.0 * sin(u), zs=0, zdir='x',; lw=self.frame_width, color=self.frame_color). def plot_front(self):; # front half of sphere; u = linspace(-pi, 0, 25); v = linspace(0, pi, 25); x = outer(cos(u), sin(v)); y = outer(sin(u), sin(v)); z = outer(ones(size(u)), cos(v)); self.axes.plot_surface(x, y, z, rstride=2, cstride=2,; color=self.sphere_color, linewidth=0,; alpha=self",MatchSource.WIKI,docs/4.7/modules/qutip/bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch.html
https://qutip.org/docs/4.7/modules/qutip/bloch.html:25122,Deployability,update,update,25122,"int_color *; int(ceil(num / float(; len(self.point_color))))). pnt_colors = pnt_colors[0:num]; pnt_colors = list(pnt_colors[indperm]); marker = self.point_marker[mod(k, len(self.point_marker))]; s = self.point_size[mod(k, len(self.point_size))]; self.axes.scatter(real(self.points[k][1][indperm]),; -real(self.points[k][0][indperm]),; real(self.points[k][2][indperm]),; s=s, alpha=self.point_alpha[k],; edgecolor=None, zdir='z',; color=pnt_colors, marker=marker). elif self.point_style[k] == 'l':; color = self.point_color[mod(k, len(self.point_color))]; self.axes.plot(real(self.points[k][1]),; -real(self.points[k][0]),; real(self.points[k][2]),; alpha=self.point_alpha[k],; zdir='z', color=color). def plot_annotations(self):; # -X and Y data are switched for plotting purposes; for annotation in self.annotations:; vec = annotation['position']; opts = {'fontsize': self.font_size,; 'color': self.font_color,; 'horizontalalignment': 'center',; 'verticalalignment': 'center'}; opts.update(annotation['opts']); self.axes.text(vec[1], -vec[0], vec[2],; annotation['text'], **opts). def plot_lines(self):; for line, fmt, kw in self._lines:; self.axes.plot(line[0], line[1], line[2], fmt, **kw). def plot_arcs(self):; for arc, fmt, kw in self._arcs:; self.axes.plot(arc[1, :], -arc[0, :], arc[2, :], fmt, **kw). [docs] def show(self):; """"""; Display Bloch sphere and corresponding data sets. Notes; -----. When using inline plotting in Jupyter notebooks, any figure created; in a notebook cell is displayed after the cell executes. Thus if you; create a figure yourself and use it create a Bloch sphere with; ``b = Bloch(..., fig=fig)`` and then call ``b.show()`` in the same; cell, then the figure will be displayed twice. If you do create your; own figure, the simplest solution to this is to not call ``.show()``; in the cell you create the figure in.; """"""; self.render(); if self.run_from_ipython():; display(self.fig); else:; self.fig.show(). [docs] def save(self, name=None, format='png', dirc=None",MatchSource.WIKI,docs/4.7/modules/qutip/bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch.html
https://qutip.org/docs/4.7/modules/qutip/bloch.html:27532,Deployability,update,updated,27532,"isplayed after the cell executes. Thus if you; create a figure yourself and use it create a Bloch sphere with; ``b = Bloch(..., fig=fig)`` and then call ``b.show()`` in the same; cell, then the figure will be displayed twice. If you do create your; own figure, the simplest solution to this is to not call ``.show()``; in the cell you create the figure in.; """"""; self.render(); if self.run_from_ipython():; display(self.fig); else:; self.fig.show(). [docs] def save(self, name=None, format='png', dirc=None, dpin=None):; """"""Saves Bloch sphere to file of type ``format`` in directory ``dirc``. Parameters; ----------. name : str; Name of saved image. Must include path and format as well.; i.e. '/Users/Paul/Desktop/bloch.png'; This overrides the 'format' and 'dirc' arguments.; format : str; Format of output image.; dirc : str; Directory for output images. Defaults to current working directory.; dpin : int; Resolution in dots per inch. Returns; -------; File containing plot of Bloch sphere. """"""; self.render(); # Conditional variable for first argument to savefig; # that is set in subsequent if-elses; complete_path = """"; if dirc:; if not os.path.isdir(os.getcwd() + ""/"" + str(dirc)):; os.makedirs(os.getcwd() + ""/"" + str(dirc)); if name is None:; if dirc:; complete_path = os.getcwd() + ""/"" + str(dirc) + '/bloch_' \; + str(self.savenum) + '.' + format; else:; complete_path = os.getcwd() + '/bloch_' + \; str(self.savenum) + '.' + format; else:; complete_path = name. if dpin:; self.fig.savefig(complete_path, dpi=dpin); else:; self.fig.savefig(complete_path); self.savenum += 1; if self.fig:; plt.close(self.fig). def _hide_tick_lines_and_labels(axis):; '''; Set visible property of ticklines and ticklabels of an axis to False; '''; for a in axis.get_ticklines() + axis.get_ticklabels():; a.set_visible(False). © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/modules/qutip/bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch.html
https://qutip.org/docs/4.7/modules/qutip/bloch.html:26662,Modifiability,variab,variable,26662,"isplayed after the cell executes. Thus if you; create a figure yourself and use it create a Bloch sphere with; ``b = Bloch(..., fig=fig)`` and then call ``b.show()`` in the same; cell, then the figure will be displayed twice. If you do create your; own figure, the simplest solution to this is to not call ``.show()``; in the cell you create the figure in.; """"""; self.render(); if self.run_from_ipython():; display(self.fig); else:; self.fig.show(). [docs] def save(self, name=None, format='png', dirc=None, dpin=None):; """"""Saves Bloch sphere to file of type ``format`` in directory ``dirc``. Parameters; ----------. name : str; Name of saved image. Must include path and format as well.; i.e. '/Users/Paul/Desktop/bloch.png'; This overrides the 'format' and 'dirc' arguments.; format : str; Format of output image.; dirc : str; Directory for output images. Defaults to current working directory.; dpin : int; Resolution in dots per inch. Returns; -------; File containing plot of Bloch sphere. """"""; self.render(); # Conditional variable for first argument to savefig; # that is set in subsequent if-elses; complete_path = """"; if dirc:; if not os.path.isdir(os.getcwd() + ""/"" + str(dirc)):; os.makedirs(os.getcwd() + ""/"" + str(dirc)); if name is None:; if dirc:; complete_path = os.getcwd() + ""/"" + str(dirc) + '/bloch_' \; + str(self.savenum) + '.' + format; else:; complete_path = os.getcwd() + '/bloch_' + \; str(self.savenum) + '.' + format; else:; complete_path = name. if dpin:; self.fig.savefig(complete_path, dpi=dpin); else:; self.fig.savefig(complete_path); self.savenum += 1; if self.fig:; plt.close(self.fig). def _hide_tick_lines_and_labels(axis):; '''; Set visible property of ticklines and ticklabels of an axis to False; '''; for a in axis.get_ticklines() + axis.get_ticklabels():; a.set_visible(False). © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/modules/qutip/bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch.html
https://qutip.org/docs/4.7/modules/qutip/bloch.html:18772,Safety,avoid,avoid,18772,"rror:; return False. def _is_inline_backend(self):; backend = matplotlib.get_backend(); return backend == ""module://matplotlib_inline.backend_inline"". [docs] def render(self):; """"""; Render the Bloch sphere and its data sets in on given figure and axes.; """"""; if not self._ext_fig and not self._is_inline_backend():; # If no external figure was supplied, we check to see if the; # figure we created in a previous call to .render() has been; # closed, and re-create if has been. This has the unfortunate; # side effect of losing any modifications made to the axes or; # figure, but the alternative is to crash the matplotlib backend.; #; # The inline backend used by, e.g. jupyter notebooks, is happy to; # use closed figures so we leave those figures intact.; if (; self.fig is not None and; not plt.fignum_exists(self.fig.number); ):; self.fig = None; self.axes = None. if self.fig is None:; self.fig = plt.figure(figsize=self.figsize); if self._is_inline_backend():; # We immediately close the inline figure do avoid displaying; # the figure twice when .show() calls display.; plt.close(self.fig). if self.axes is None:; self.axes = _axes3D(self.fig, azim=self.view[0], elev=self.view[1]). # Clearing the axes is horrifically slow and loses a lot of the; # axes state, but matplotlib doesn't seem to provide a better way; # to redraw Axes3D. :/; self.axes.clear(); self.axes.grid(False); if self.background:; self.axes.set_xlim3d(-1.3, 1.3); self.axes.set_ylim3d(-1.3, 1.3); self.axes.set_zlim3d(-1.3, 1.3); else:; self.axes.set_axis_off(); self.axes.set_xlim3d(-0.7, 0.7); self.axes.set_ylim3d(-0.7, 0.7); self.axes.set_zlim3d(-0.7, 0.7); # Manually set aspect ratio to fit a square bounding box.; # Matplotlib did this stretching for < 3.3.0, but not above.; if parse_version(matplotlib.__version__) >= parse_version('3.3'):; self.axes.set_box_aspect((1, 1, 1)); if not self.background:; self.plot_axes(). self.plot_back(); self.plot_points(); self.plot_vectors(); self.plot_lines(); self.plot_arc",MatchSource.WIKI,docs/4.7/modules/qutip/bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch.html
https://qutip.org/docs/4.7/modules/qutip/bloch.html:6102,Usability,simpl,simple,6102,"1; self.frame_width = 1; # Transparency of wireframe, default = 0.2; self.frame_alpha = 0.2; # Labels for x-axis (in LaTex), default = ['$x$', '']; self.xlabel = ['$x$', '']; # Position of x-axis labels, default = [1.2, -1.2]; self.xlpos = [1.2, -1.2]; # Labels for y-axis (in LaTex), default = ['$y$', '']; self.ylabel = ['$y$', '']; # Position of y-axis labels, default = [1.1, -1.1]; self.ylpos = [1.2, -1.2]; # Labels for z-axis (in LaTex),; # default = [r'$\left\|0\right>$', r'$\left|1\right>$']; self.zlabel = [r'$\left|0\right>$', r'$\left|1\right>$']; # Position of z-axis labels, default = [1.2, -1.2]; self.zlpos = [1.2, -1.2]; # ---font options---; # Color of fonts, default = 'black'; self.font_color = 'black'; # Size of fonts, default = 20; self.font_size = 20. # ---vector options---; # List of colors for Bloch vectors, default = ['b','g','r','y']; self.vector_color = ['g', '#CC6600', 'b', 'r']; #: Width of Bloch vectors, default = 5; self.vector_width = 3; #: Style of Bloch vectors, default = '-\|>' (or 'simple'); self.vector_style = '-|>'; #: Sets the width of the vectors arrowhead; self.vector_mutation = 20. # ---point options---; # List of colors for Bloch point markers, default = ['b','g','r','y']; self.point_color = ['b', 'r', 'g', '#CC6600']; # Size of point markers, default = 25; self.point_size = [25, 32, 35, 45]; # Shape of point markers, default = ['o','^','d','s']; self.point_marker = ['o', 's', 'd', '^']. # ---data lists---; # Data for point markers; self.points = []; # Data for Bloch vectors; self.vectors = []; # Transparency of vectors, alpha value from 0 to 1; self.vector_alpha = []; # Data for annotations; self.annotations = []; # Number of times sphere has been saved; self.savenum = 0; # Style of points, 'm' for multiple colors, 's' for single color; self.point_style = []; # Transparency of points, alpha value from 0 to 1; self.point_alpha = []; # Data for line segment; self._lines = []; # Data for arcs and arc style; self._arcs = []. [docs] d",MatchSource.WIKI,docs/4.7/modules/qutip/bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch.html
https://qutip.org/docs/4.7/modules/qutip/bloch.html:10591,Usability,clear,clear,10591,"n""; s += ""sphere_color: "" + str(self.sphere_color) + ""\n""; s += ""figsize: "" + str(self.figsize) + ""\n""; s += ""vector_color: "" + str(self.vector_color) + ""\n""; s += ""vector_width: "" + str(self.vector_width) + ""\n""; s += ""vector_style: "" + str(self.vector_style) + ""\n""; s += ""vector_mutation: "" + str(self.vector_mutation) + ""\n""; s += ""view: "" + str(self.view) + ""\n""; s += ""xlabel: "" + str(self.xlabel) + ""\n""; s += ""xlpos: "" + str(self.xlpos) + ""\n""; s += ""ylabel: "" + str(self.ylabel) + ""\n""; s += ""ylpos: "" + str(self.ylpos) + ""\n""; s += ""zlabel: "" + str(self.zlabel) + ""\n""; s += ""zlpos: "" + str(self.zlpos) + ""\n""; return s. def _repr_png_(self):; from IPython.core.pylabtools import print_figure; self.render(); fig_data = print_figure(self.fig, 'png'); plt.close(self.fig); return fig_data. def _repr_svg_(self):; from IPython.core.pylabtools import print_figure; self.render(); fig_data = print_figure(self.fig, 'svg'); plt.close(self.fig); return fig_data. [docs] def clear(self):; """"""Resets Bloch sphere data sets to empty.; """"""; self.points = []; self.vectors = []; self.point_style = []; self.point_alpha = []; self.vector_alpha = []; self.annotations = []; self._lines = []; self._arcs = []. [docs] def add_points(self, points, meth='s', alpha=1.0):; """"""Add a list of data points to bloch sphere. Parameters; ----------; points : array_like; Collection of data points. meth : {'s', 'm', 'l'}; Type of points to plot, use 'm' for multicolored, 'l' for points; connected with a line. alpha : float, default=1.; Transparency value for the vectors. Values between 0 and 1. .. note::. When using ``meth=l`` in QuTiP 4.6, the line transparency defaulted; to ``0.75`` and there was no way to alter it.; When the ``alpha`` parameter was added in QuTiP 4.7, the default; became ``alpha=1.0`` for values of ``meth``.; """"""; if not isinstance(points[0], (list, tuple, ndarray)):; points = [[points[0]], [points[1]], [points[2]]]; points = array(points); if meth == 's':; if len(points[0]) == 1:; pn",MatchSource.WIKI,docs/4.7/modules/qutip/bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch.html
https://qutip.org/docs/4.7/modules/qutip/bloch.html:19117,Usability,clear,clear,19117,"o see if the; # figure we created in a previous call to .render() has been; # closed, and re-create if has been. This has the unfortunate; # side effect of losing any modifications made to the axes or; # figure, but the alternative is to crash the matplotlib backend.; #; # The inline backend used by, e.g. jupyter notebooks, is happy to; # use closed figures so we leave those figures intact.; if (; self.fig is not None and; not plt.fignum_exists(self.fig.number); ):; self.fig = None; self.axes = None. if self.fig is None:; self.fig = plt.figure(figsize=self.figsize); if self._is_inline_backend():; # We immediately close the inline figure do avoid displaying; # the figure twice when .show() calls display.; plt.close(self.fig). if self.axes is None:; self.axes = _axes3D(self.fig, azim=self.view[0], elev=self.view[1]). # Clearing the axes is horrifically slow and loses a lot of the; # axes state, but matplotlib doesn't seem to provide a better way; # to redraw Axes3D. :/; self.axes.clear(); self.axes.grid(False); if self.background:; self.axes.set_xlim3d(-1.3, 1.3); self.axes.set_ylim3d(-1.3, 1.3); self.axes.set_zlim3d(-1.3, 1.3); else:; self.axes.set_axis_off(); self.axes.set_xlim3d(-0.7, 0.7); self.axes.set_ylim3d(-0.7, 0.7); self.axes.set_zlim3d(-0.7, 0.7); # Manually set aspect ratio to fit a square bounding box.; # Matplotlib did this stretching for < 3.3.0, but not above.; if parse_version(matplotlib.__version__) >= parse_version('3.3'):; self.axes.set_box_aspect((1, 1, 1)); if not self.background:; self.plot_axes(). self.plot_back(); self.plot_points(); self.plot_vectors(); self.plot_lines(); self.plot_arcs(); self.plot_front(); self.plot_axes_labels(); self.plot_annotations(); # Trigger an update of the Bloch sphere if it is already shown:; self.fig.canvas.draw(). def plot_back(self):; # back half of sphere; u = linspace(0, pi, 25); v = linspace(0, pi, 25); x = outer(cos(u), sin(v)); y = outer(sin(u), sin(v)); z = outer(ones(size(u)), cos(v)); self.axes.plot_sur",MatchSource.WIKI,docs/4.7/modules/qutip/bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch.html
https://qutip.org/docs/4.7/modules/qutip/bloch.html:22810,Usability,simpl,simple,22810,"f.xlabel[0], **opts); self.axes.text(0, -self.xlpos[1], 0, self.xlabel[1], **opts). self.axes.text(self.ylpos[0], 0, 0, self.ylabel[0], **opts); self.axes.text(self.ylpos[1], 0, 0, self.ylabel[1], **opts). self.axes.text(0, 0, self.zlpos[0], self.zlabel[0], **opts); self.axes.text(0, 0, self.zlpos[1], self.zlabel[1], **opts). for a in (self.axes.xaxis.get_ticklines() +; self.axes.xaxis.get_ticklabels()):; a.set_visible(False); for a in (self.axes.yaxis.get_ticklines() +; self.axes.yaxis.get_ticklabels()):; a.set_visible(False); for a in (self.axes.zaxis.get_ticklines() +; self.axes.zaxis.get_ticklabels()):; a.set_visible(False). def plot_vectors(self):; # -X and Y data are switched for plotting purposes; for k in range(len(self.vectors)):. xs3d = self.vectors[k][1] * array([0, 1]); ys3d = -self.vectors[k][0] * array([0, 1]); zs3d = self.vectors[k][2] * array([0, 1]). color = self.vector_color[mod(k, len(self.vector_color))]; alpha = self.vector_alpha[k]. if self.vector_style == '':; # simple line style; self.axes.plot(xs3d, ys3d, zs3d,; zs=0, zdir='z', label='Z',; lw=self.vector_width, color=color,; alpha=alpha); else:; # decorated style, with arrow heads; a = Arrow3D(xs3d, ys3d, zs3d,; mutation_scale=self.vector_mutation,; lw=self.vector_width,; arrowstyle=self.vector_style,; color=color, alpha=alpha). self.axes.add_artist(a). def plot_points(self):; # -X and Y data are switched for plotting purposes; for k in range(len(self.points)):; num = len(self.points[k][0]); dist = [sqrt(self.points[k][0][j] ** 2 +; self.points[k][1][j] ** 2 +; self.points[k][2][j] ** 2) for j in range(num)]; if any(abs(dist - dist[0]) / dist[0] > 1e-12):; # combine arrays so that they can be sorted together; zipped = list(zip(dist, range(num))); zipped.sort() # sort rates from lowest to highest; dist, indperm = zip(*zipped); indperm = array(indperm); else:; indperm = arange(num); if self.point_style[k] == 's':; self.axes.scatter(; real(self.points[k][1][indperm]),; - real(self.points[k][0][i",MatchSource.WIKI,docs/4.7/modules/qutip/bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch.html
https://qutip.org/docs/4.7/modules/qutip/bloch.html:25898,Usability,simpl,simplest,25898," plotting purposes; for annotation in self.annotations:; vec = annotation['position']; opts = {'fontsize': self.font_size,; 'color': self.font_color,; 'horizontalalignment': 'center',; 'verticalalignment': 'center'}; opts.update(annotation['opts']); self.axes.text(vec[1], -vec[0], vec[2],; annotation['text'], **opts). def plot_lines(self):; for line, fmt, kw in self._lines:; self.axes.plot(line[0], line[1], line[2], fmt, **kw). def plot_arcs(self):; for arc, fmt, kw in self._arcs:; self.axes.plot(arc[1, :], -arc[0, :], arc[2, :], fmt, **kw). [docs] def show(self):; """"""; Display Bloch sphere and corresponding data sets. Notes; -----. When using inline plotting in Jupyter notebooks, any figure created; in a notebook cell is displayed after the cell executes. Thus if you; create a figure yourself and use it create a Bloch sphere with; ``b = Bloch(..., fig=fig)`` and then call ``b.show()`` in the same; cell, then the figure will be displayed twice. If you do create your; own figure, the simplest solution to this is to not call ``.show()``; in the cell you create the figure in.; """"""; self.render(); if self.run_from_ipython():; display(self.fig); else:; self.fig.show(). [docs] def save(self, name=None, format='png', dirc=None, dpin=None):; """"""Saves Bloch sphere to file of type ``format`` in directory ``dirc``. Parameters; ----------. name : str; Name of saved image. Must include path and format as well.; i.e. '/Users/Paul/Desktop/bloch.png'; This overrides the 'format' and 'dirc' arguments.; format : str; Format of output image.; dirc : str; Directory for output images. Defaults to current working directory.; dpin : int; Resolution in dots per inch. Returns; -------; File containing plot of Bloch sphere. """"""; self.render(); # Conditional variable for first argument to savefig; # that is set in subsequent if-elses; complete_path = """"; if dirc:; if not os.path.isdir(os.getcwd() + ""/"" + str(dirc)):; os.makedirs(os.getcwd() + ""/"" + str(dirc)); if name is None:; if dirc:; comp",MatchSource.WIKI,docs/4.7/modules/qutip/bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch.html
https://qutip.org/docs/4.7/modules/qutip/bloch3d.html:16413,Deployability,update,updated,16413,"b(self.font_color),; scale=self.font_scale); mlab.text3d(self.xlpos[0], 0, 0, self.xlabel[0],; color=colors.colorConverter.to_rgb(self.font_color),; scale=self.font_scale); mlab.text3d(self.xlpos[1], 0, 0, self.xlabel[1],; color=colors.colorConverter.to_rgb(self.font_color),; scale=self.font_scale); mlab.text3d(0, self.ylpos[0], 0, self.ylabel[0],; color=colors.colorConverter.to_rgb(self.font_color),; scale=self.font_scale); mlab.text3d(0, self.ylpos[1], 0, self.ylabel[1],; color=colors.colorConverter.to_rgb(self.font_color),; scale=self.font_scale). [docs] def show(self):; """"""; Display the Bloch sphere and corresponding data sets.; """"""; from mayavi import mlab; self.make_sphere(); mlab.view(azimuth=self.view[0], elevation=self.view[1], distance=5); if self.fig:; mlab.show(). [docs] def save(self, name=None, format='png', dirc=None):; """"""Saves Bloch sphere to file of type ``format`` in directory ``dirc``. Parameters; ----------; name : str; Name of saved image. Must include path and format as well.; i.e. '/Users/Paul/Desktop/bloch.png'; This overrides the 'format' and 'dirc' arguments.; format : str; Format of output image. Default is 'png'.; dirc : str; Directory for output images. Defaults to current working directory. Returns; -------; File containing plot of Bloch sphere. """"""; from mayavi import mlab; import os; self.make_sphere(); mlab.view(azimuth=self.view[0], elevation=self.view[1], distance=5); if dirc:; if not os.path.isdir(os.getcwd() + ""/"" + str(dirc)):; os.makedirs(os.getcwd() + ""/"" + str(dirc)); if name is None:; if dirc:; mlab.savefig(os.getcwd() + ""/"" + str(dirc) + '/bloch_' +; str(self.savenum) + '.' + format); else:; mlab.savefig(os.getcwd() + '/bloch_' + str(self.savenum) +; '.' + format); else:; mlab.savefig(name); self.savenum += 1; if self.fig:; mlab.close(self.fig). © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/modules/qutip/bloch3d.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch3d.html
https://qutip.org/docs/4.7/modules/qutip/bloch3d.html:7641,Usability,clear,clear,7641,"or) + ""\n""; s += ""frame_num: "" + str(self.frame_num) + ""\n""; s += ""frame_radius: "" + str(self.frame_radius) + ""\n""; s += ""point_color: "" + str(self.point_color) + ""\n""; s += ""point_mode: "" + str(self.point_mode) + ""\n""; s += ""point_size: "" + str(self.point_size) + ""\n""; s += ""sphere_alpha: "" + str(self.sphere_alpha) + ""\n""; s += ""sphere_color: "" + str(self.sphere_color) + ""\n""; s += ""size: "" + str(self.size) + ""\n""; s += ""vector_color: "" + str(self.vector_color) + ""\n""; s += ""vector_width: "" + str(self.vector_width) + ""\n""; s += ""vector_head_height: "" + str(self.vector_head_height) + ""\n""; s += ""vector_head_radius: "" + str(self.vector_head_radius) + ""\n""; s += ""view: "" + str(self.view) + ""\n""; s += ""xlabel: "" + str(self.xlabel) + ""\n""; s += ""xlpos: "" + str(self.xlpos) + ""\n""; s += ""ylabel: "" + str(self.ylabel) + ""\n""; s += ""ylpos: "" + str(self.ylpos) + ""\n""; s += ""zlabel: "" + str(self.zlabel) + ""\n""; s += ""zlpos: "" + str(self.zlpos) + ""\n""; return s. [docs] def clear(self):; """"""Resets the Bloch sphere data sets to empty.; """"""; self.points = []; self.vectors = []; self.point_style = []. [docs] def add_points(self, points, meth='s', alpha=1.0):; """"""Add a list of data points to bloch sphere. Parameters; ----------; points : array/list; Collection of data points. meth : str {'s','m'}; Type of points to plot, use 'm' for multicolored. alpha : float, default=1.; Transparency value for the vectors. Values between 0 and 1. """"""; if not isinstance(points[0], (list, np.ndarray)):; points = [[points[0]], [points[1]], [points[2]]]; points = np.array(points); if meth == 's':; if len(points[0]) == 1:; pnts = np.array(; [[points[0][0]], [points[1][0]], [points[2][0]]]); pnts = np.append(pnts, points, axis=1); else:; pnts = points; self.points.append(pnts); self.point_style.append('s'); else:; self.points.append(points); self.point_style.append('m'); self.point_alpha.append(alpha). [docs] def add_states(self, state, kind='vector', alpha=1.0):; """"""Add a state vector Qobj to Bloch sph",MatchSource.WIKI,docs/4.7/modules/qutip/bloch3d.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch3d.html
https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html:8960,Availability,error,error,8960,"list = []. #; # transform the initial density matrix and the e_ops opterators to the; # eigenbasis; #; rho_eb = rho0.transform(ekets); e_eb_ops = [e.transform(ekets) for e in e_ops]. for e_eb in e_eb_ops:; if e_eb.isherm:; result_list.append(np.zeros(n_tsteps, dtype=float)); else:; result_list.append(np.zeros(n_tsteps, dtype=complex)). #; # setup integrator; #; initial_vector = mat2vec(rho_eb.full()); r = scipy.integrate.ode(cy_ode_rhs); r.set_f_params(R.data.data, R.data.indices, R.data.indptr); r.set_integrator('zvode', method=options.method, order=options.order,; atol=options.atol, rtol=options.rtol,; nsteps=options.nsteps, first_step=options.first_step,; min_step=options.min_step, max_step=options.max_step); r.set_initial_value(initial_vector, tlist[0]). #; # start evolution; #; dt = np.diff(tlist); progress_bar.start(n_tsteps); for t_idx, _ in enumerate(tlist):; progress_bar.update(t_idx); if not r.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""). rho_eb.data = dense2D_to_fastcsr_fmode(vec2mat(r.y), rho0.shape[0], rho0.shape[1]). # calculate all the expectation values, or output rho_eb if no; # expectation value operators are given; if e_ops:; rho_eb_tmp = Qobj(rho_eb); for m, e in enumerate(e_eb_ops):; result_list[m][t_idx] = expect(e, rho_eb_tmp); else:; result_list.append(rho_eb.transform(ekets, True)). if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]); progress_bar.finished(); return result_list. def _td_brmesolve(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[], args={},; use_secular=True, sec_cutoff=0.1,; tol=qset.atol, options=None,; progress_bar=None,_safe_mode=True,; verbose=False,; _prep_time=0):. if isket(psi0):; rho0 = ket2dm(psi0); else:; rho0 = psi0; nrows = rho0.shape[0]. H_terms = []; H_td_terms = []; H_obj = []; A_terms = []; A_td_terms = []; C_terms = []; C_td_terms = []; CA_obj = []; spline_count = [0,0]; coupled_ops = []; ",MatchSource.WIKI,docs/4.7/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html:15183,Availability,error,error,15183,"t(); output.solver = ""brmesolve""; output.times = tlist. if options.store_states:; output.states = []. if isinstance(e_ops, types.FunctionType):; n_expt_op = 0; expt_callback = True. elif isinstance(e_ops, list):; n_expt_op = len(e_ops); expt_callback = False. if n_expt_op == 0:; # fall back on storing states; output.states = []; options.store_states = True; else:; output.expect = []; output.num_expect = n_expt_op; for op in e_ops:; e_sops_data.append(spre(op).data); if op.isherm:; output.expect.append(np.zeros(n_tsteps)); else:; output.expect.append(np.zeros(n_tsteps, dtype=complex)). else:; raise TypeError(""Expectation parameter must be a list or a function""). #; # start evolution; #; if type(progress_bar)==BaseProgressBar and verbose:; _run_time = time.time(). progress_bar.start(n_tsteps). rho = Qobj(rho0). dt = np.diff(tlist); for t_idx, t in enumerate(tlist):; progress_bar.update(t_idx). if not _ode.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""). if options.store_states or expt_callback:; rho.data = dense2D_to_fastcsr_fmode(vec2mat(_ode.y), rho.shape[0], rho.shape[1]). if options.store_states:; output.states.append(Qobj(rho, isherm=True)). if expt_callback:; # use callback method; e_ops(t, rho). for m in range(n_expt_op):; if output.expect[m].dtype == complex:; output.expect[m][t_idx] = expect_rho_vec(e_sops_data[m],; _ode.y, 0); else:; output.expect[m][t_idx] = expect_rho_vec(e_sops_data[m],; _ode.y, 1). if t_idx < n_tsteps - 1:; _ode.integrate(_ode.t + dt[t_idx]). progress_bar.finished(). if type(progress_bar)==BaseProgressBar and verbose:; print('BR runtime:', time.time()-_run_time). if (not options.rhs_reuse) and (config.tdname is not None):; _cython_build_cleanup(config.tdname). if options.store_final_state:; rho.data = dense2D_to_fastcsr_fmode(vec2mat(_ode.y), rho.shape[0], rho.shape[1]); output.final_state = Qobj(rho, dims=rho0.dims, i",MatchSource.WIKI,docs/4.7/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html:504,Deployability,integrat,integrate,504,". qutip.bloch_redfield — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.bloch_redfield. Source code for qutip.bloch_redfield; __all__ = ['brmesolve', 'bloch_redfield_solve']. import numpy as np; import os; import time; import types; import warnings; import scipy.integrate; from qutip.qobj import Qobj, isket; from qutip.states import ket2dm; from qutip.superoperator import spre, spost, vec2mat, mat2vec; from qutip.expect import expect; from qutip.solver import Options, Result, config, _solver_safety_check; from qutip.cy.spmatfuncs import cy_ode_rhs; from qutip.cy.spconvert import dense2D_to_fastcsr_fmode; from qutip.interpolate import Cubic_Spline; from qutip.cy.br_codegen import BR_Codegen; from qutip.ui.progressbar import BaseProgressBar, TextProgressBar; from qutip.cy.utilities import _cython_build_cleanup; from qutip.expect import expect_rho_vec; from qutip.rhs_generate import _td_format_check; from qutip.cy.openmp.utilities import check_use_openmp; import qutip.settings as qset; from qutip.cy.br_tensor import bloch_redfield_tensor. # -----------------------------------------------------------------------------; # Solve the Bloch-Redfield master equation; #; [docs]def brmesolve(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[],; args={}, use_secular=True, sec_cutoff = 0.1,; tol=qset.atol,; spectra_cb=None, options=None,; progress_bar=None, _safe_mode=True, verbose=False):; """"""; Solves for the dynamics of a system using the Bloch-Redfield master equation,; given an input Hamiltonian, Hermitian bath-coupling terms and their associated; spectrum functions, as well as possible Lindblad collapse operators. For time-independent systems, the Hamiltonian must be given as a Qobj,; whereas the bath-coupling terms (a_ops), must be written as a",MatchSource.WIKI,docs/4.7/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html:8344,Deployability,integrat,integrator,8344,"lver. Returns; -------. output: :class:`qutip.solver.Result`. An instance of the class :class:`qutip.solver.Result`, which contains either; an *array* of expectation values for the times specified by `tlist`. """""". if options is None:; options = Options(). if options.tidy:; R.tidyup(). if progress_bar is None:; progress_bar = BaseProgressBar(); elif progress_bar is True:; progress_bar = TextProgressBar(). #; # check initial state; #; if isket(rho0):; # Got a wave function as initial state: convert to density matrix.; rho0 = rho0 * rho0.dag(). #; # prepare output array; #; n_tsteps = len(tlist); dt = tlist[1] - tlist[0]; result_list = []. #; # transform the initial density matrix and the e_ops opterators to the; # eigenbasis; #; rho_eb = rho0.transform(ekets); e_eb_ops = [e.transform(ekets) for e in e_ops]. for e_eb in e_eb_ops:; if e_eb.isherm:; result_list.append(np.zeros(n_tsteps, dtype=float)); else:; result_list.append(np.zeros(n_tsteps, dtype=complex)). #; # setup integrator; #; initial_vector = mat2vec(rho_eb.full()); r = scipy.integrate.ode(cy_ode_rhs); r.set_f_params(R.data.data, R.data.indices, R.data.indptr); r.set_integrator('zvode', method=options.method, order=options.order,; atol=options.atol, rtol=options.rtol,; nsteps=options.nsteps, first_step=options.first_step,; min_step=options.min_step, max_step=options.max_step); r.set_initial_value(initial_vector, tlist[0]). #; # start evolution; #; dt = np.diff(tlist); progress_bar.start(n_tsteps); for t_idx, _ in enumerate(tlist):; progress_bar.update(t_idx); if not r.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""). rho_eb.data = dense2D_to_fastcsr_fmode(vec2mat(r.y), rho0.shape[0], rho0.shape[1]). # calculate all the expectation values, or output rho_eb if no; # expectation value operators are given; if e_ops:; rho_eb_tmp = Qobj(rho_eb); for m, e in enumerate(e_eb_ops):; result_list[m][t_id",MatchSource.WIKI,docs/4.7/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html:8410,Deployability,integrat,integrate,8410,"esult`. An instance of the class :class:`qutip.solver.Result`, which contains either; an *array* of expectation values for the times specified by `tlist`. """""". if options is None:; options = Options(). if options.tidy:; R.tidyup(). if progress_bar is None:; progress_bar = BaseProgressBar(); elif progress_bar is True:; progress_bar = TextProgressBar(). #; # check initial state; #; if isket(rho0):; # Got a wave function as initial state: convert to density matrix.; rho0 = rho0 * rho0.dag(). #; # prepare output array; #; n_tsteps = len(tlist); dt = tlist[1] - tlist[0]; result_list = []. #; # transform the initial density matrix and the e_ops opterators to the; # eigenbasis; #; rho_eb = rho0.transform(ekets); e_eb_ops = [e.transform(ekets) for e in e_ops]. for e_eb in e_eb_ops:; if e_eb.isherm:; result_list.append(np.zeros(n_tsteps, dtype=float)); else:; result_list.append(np.zeros(n_tsteps, dtype=complex)). #; # setup integrator; #; initial_vector = mat2vec(rho_eb.full()); r = scipy.integrate.ode(cy_ode_rhs); r.set_f_params(R.data.data, R.data.indices, R.data.indptr); r.set_integrator('zvode', method=options.method, order=options.order,; atol=options.atol, rtol=options.rtol,; nsteps=options.nsteps, first_step=options.first_step,; min_step=options.min_step, max_step=options.max_step); r.set_initial_value(initial_vector, tlist[0]). #; # start evolution; #; dt = np.diff(tlist); progress_bar.start(n_tsteps); for t_idx, _ in enumerate(tlist):; progress_bar.update(t_idx); if not r.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""). rho_eb.data = dense2D_to_fastcsr_fmode(vec2mat(r.y), rho0.shape[0], rho0.shape[1]). # calculate all the expectation values, or output rho_eb if no; # expectation value operators are given; if e_ops:; rho_eb_tmp = Qobj(rho_eb); for m, e in enumerate(e_eb_ops):; result_list[m][t_idx] = expect(e, rho_eb_tmp); else:; result_list.append",MatchSource.WIKI,docs/4.7/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html:8888,Deployability,update,update,8888,"0.dag(). #; # prepare output array; #; n_tsteps = len(tlist); dt = tlist[1] - tlist[0]; result_list = []. #; # transform the initial density matrix and the e_ops opterators to the; # eigenbasis; #; rho_eb = rho0.transform(ekets); e_eb_ops = [e.transform(ekets) for e in e_ops]. for e_eb in e_eb_ops:; if e_eb.isherm:; result_list.append(np.zeros(n_tsteps, dtype=float)); else:; result_list.append(np.zeros(n_tsteps, dtype=complex)). #; # setup integrator; #; initial_vector = mat2vec(rho_eb.full()); r = scipy.integrate.ode(cy_ode_rhs); r.set_f_params(R.data.data, R.data.indices, R.data.indptr); r.set_integrator('zvode', method=options.method, order=options.order,; atol=options.atol, rtol=options.rtol,; nsteps=options.nsteps, first_step=options.first_step,; min_step=options.min_step, max_step=options.max_step); r.set_initial_value(initial_vector, tlist[0]). #; # start evolution; #; dt = np.diff(tlist); progress_bar.start(n_tsteps); for t_idx, _ in enumerate(tlist):; progress_bar.update(t_idx); if not r.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""). rho_eb.data = dense2D_to_fastcsr_fmode(vec2mat(r.y), rho0.shape[0], rho0.shape[1]). # calculate all the expectation values, or output rho_eb if no; # expectation value operators are given; if e_ops:; rho_eb_tmp = Qobj(rho_eb); for m, e in enumerate(e_eb_ops):; result_list[m][t_idx] = expect(e, rho_eb_tmp); else:; result_list.append(rho_eb.transform(ekets, True)). if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]); progress_bar.finished(); return result_list. def _td_brmesolve(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[], args={},; use_secular=True, sec_cutoff=0.1,; tol=qset.atol, options=None,; progress_bar=None,_safe_mode=True,; verbose=False,; _prep_time=0):. if isket(psi0):; rho0 = ket2dm(psi0); else:; rho0 = psi0; nrows = rho0.shape[0]. H_terms = []; H_td_terms = []; H_obj = []; A_terms = []; A_td_t",MatchSource.WIKI,docs/4.7/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html:8948,Deployability,integrat,integration,8948,"list = []. #; # transform the initial density matrix and the e_ops opterators to the; # eigenbasis; #; rho_eb = rho0.transform(ekets); e_eb_ops = [e.transform(ekets) for e in e_ops]. for e_eb in e_eb_ops:; if e_eb.isherm:; result_list.append(np.zeros(n_tsteps, dtype=float)); else:; result_list.append(np.zeros(n_tsteps, dtype=complex)). #; # setup integrator; #; initial_vector = mat2vec(rho_eb.full()); r = scipy.integrate.ode(cy_ode_rhs); r.set_f_params(R.data.data, R.data.indices, R.data.indptr); r.set_integrator('zvode', method=options.method, order=options.order,; atol=options.atol, rtol=options.rtol,; nsteps=options.nsteps, first_step=options.first_step,; min_step=options.min_step, max_step=options.max_step); r.set_initial_value(initial_vector, tlist[0]). #; # start evolution; #; dt = np.diff(tlist); progress_bar.start(n_tsteps); for t_idx, _ in enumerate(tlist):; progress_bar.update(t_idx); if not r.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""). rho_eb.data = dense2D_to_fastcsr_fmode(vec2mat(r.y), rho0.shape[0], rho0.shape[1]). # calculate all the expectation values, or output rho_eb if no; # expectation value operators are given; if e_ops:; rho_eb_tmp = Qobj(rho_eb); for m, e in enumerate(e_eb_ops):; result_list[m][t_idx] = expect(e, rho_eb_tmp); else:; result_list.append(rho_eb.transform(ekets, True)). if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]); progress_bar.finished(); return result_list. def _td_brmesolve(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[], args={},; use_secular=True, sec_cutoff=0.1,; tol=qset.atol, options=None,; progress_bar=None,_safe_mode=True,; verbose=False,; _prep_time=0):. if isket(psi0):; rho0 = ket2dm(psi0); else:; rho0 = psi0; nrows = rho0.shape[0]. H_terms = []; H_td_terms = []; H_obj = []; A_terms = []; A_td_terms = []; C_terms = []; C_td_terms = []; CA_obj = []; spline_count = [0,0]; coupled_ops = []; ",MatchSource.WIKI,docs/4.7/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html:9476,Deployability,integrat,integrate,9476,".data.indptr); r.set_integrator('zvode', method=options.method, order=options.order,; atol=options.atol, rtol=options.rtol,; nsteps=options.nsteps, first_step=options.first_step,; min_step=options.min_step, max_step=options.max_step); r.set_initial_value(initial_vector, tlist[0]). #; # start evolution; #; dt = np.diff(tlist); progress_bar.start(n_tsteps); for t_idx, _ in enumerate(tlist):; progress_bar.update(t_idx); if not r.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""). rho_eb.data = dense2D_to_fastcsr_fmode(vec2mat(r.y), rho0.shape[0], rho0.shape[1]). # calculate all the expectation values, or output rho_eb if no; # expectation value operators are given; if e_ops:; rho_eb_tmp = Qobj(rho_eb); for m, e in enumerate(e_eb_ops):; result_list[m][t_idx] = expect(e, rho_eb_tmp); else:; result_list.append(rho_eb.transform(ekets, True)). if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]); progress_bar.finished(); return result_list. def _td_brmesolve(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[], args={},; use_secular=True, sec_cutoff=0.1,; tol=qset.atol, options=None,; progress_bar=None,_safe_mode=True,; verbose=False,; _prep_time=0):. if isket(psi0):; rho0 = ket2dm(psi0); else:; rho0 = psi0; nrows = rho0.shape[0]. H_terms = []; H_td_terms = []; H_obj = []; A_terms = []; A_td_terms = []; C_terms = []; C_td_terms = []; CA_obj = []; spline_count = [0,0]; coupled_ops = []; coupled_lengths = []; coupled_spectra = []. if isinstance(H, Qobj):; H_terms.append(H.full('f')); H_td_terms.append('1'); else:; for kk, h in enumerate(H):; if isinstance(h, Qobj):; H_terms.append(h.full('f')); H_td_terms.append('1'); elif isinstance(h, list):; H_terms.append(h[0].full('f')); if isinstance(h[1], Cubic_Spline):; H_obj.append(h[1].coeffs); spline_count[0] += 1; H_td_terms.append(h[1]); else:; raise Exception('Invalid Hamiltonian specification.'). for kk, c in enumerat",MatchSource.WIKI,docs/4.7/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html:13722,Deployability,integrat,integrate,13722,"name is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; if verbose:; _st = time.time(); cgen = BR_Codegen(h_terms=len(H_terms),; h_td_terms=H_td_terms, h_obj=H_obj,; c_terms=len(C_terms),; c_td_terms=C_td_terms, c_obj=CA_obj,; a_terms=len(A_terms), a_td_terms=A_td_terms,; spline_count=spline_count,; coupled_ops = coupled_ops,; coupled_lengths = coupled_lengths,; coupled_spectra = coupled_spectra,; config=config, sparse=False,; use_secular = use_secular,; sec_cutoff = sec_cutoff,; args=args,; use_openmp=options.use_openmp,; omp_thresh=qset.openmp_thresh if qset.has_openmp else None,; omp_threads=options.num_cpus,; atol=tol). cgen.generate(config.tdname + "".pyx""); code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs; if verbose:; print('BR compile time:', time.time()-_st); initial_vector = mat2vec(rho0.full()).ravel(). _ode = scipy.integrate.ode(config.tdfunc); code = compile('_ode.set_f_params(' + parameter_string + ')',; '<string>', 'exec'); _ode.set_integrator('zvode', method=options.method,; order=options.order, atol=options.atol,; rtol=options.rtol, nsteps=options.nsteps,; first_step=options.first_step,; min_step=options.min_step,; max_step=options.max_step); _ode.set_initial_value(initial_vector, tlist[0]); exec(code, locals()). #; # prepare output array; #; n_tsteps = len(tlist); e_sops_data = []. output = Result(); output.solver = ""brmesolve""; output.times = tlist. if options.store_states:; output.states = []. if isinstance(e_ops, types.FunctionType):; n_expt_op = 0; expt_callback = True. elif isinstance(e_ops, list):; n_expt_op = len(e_ops); expt_callback = False. if n_expt_op == 0:; # fall back on storing states; output.states = []; options.store_states = True; else:; output.expect = []; output.num_expect = n_expt_op; for op in e_ops:; e_sops_data.append(spre(op).data); if op.isherm:; output.expect.append(np",MatchSource.WIKI,docs/4.7/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html:15108,Deployability,update,update,15108,"(code, locals()). #; # prepare output array; #; n_tsteps = len(tlist); e_sops_data = []. output = Result(); output.solver = ""brmesolve""; output.times = tlist. if options.store_states:; output.states = []. if isinstance(e_ops, types.FunctionType):; n_expt_op = 0; expt_callback = True. elif isinstance(e_ops, list):; n_expt_op = len(e_ops); expt_callback = False. if n_expt_op == 0:; # fall back on storing states; output.states = []; options.store_states = True; else:; output.expect = []; output.num_expect = n_expt_op; for op in e_ops:; e_sops_data.append(spre(op).data); if op.isherm:; output.expect.append(np.zeros(n_tsteps)); else:; output.expect.append(np.zeros(n_tsteps, dtype=complex)). else:; raise TypeError(""Expectation parameter must be a list or a function""). #; # start evolution; #; if type(progress_bar)==BaseProgressBar and verbose:; _run_time = time.time(). progress_bar.start(n_tsteps). rho = Qobj(rho0). dt = np.diff(tlist); for t_idx, t in enumerate(tlist):; progress_bar.update(t_idx). if not _ode.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""). if options.store_states or expt_callback:; rho.data = dense2D_to_fastcsr_fmode(vec2mat(_ode.y), rho.shape[0], rho.shape[1]). if options.store_states:; output.states.append(Qobj(rho, isherm=True)). if expt_callback:; # use callback method; e_ops(t, rho). for m in range(n_expt_op):; if output.expect[m].dtype == complex:; output.expect[m][t_idx] = expect_rho_vec(e_sops_data[m],; _ode.y, 0); else:; output.expect[m][t_idx] = expect_rho_vec(e_sops_data[m],; _ode.y, 1). if t_idx < n_tsteps - 1:; _ode.integrate(_ode.t + dt[t_idx]). progress_bar.finished(). if type(progress_bar)==BaseProgressBar and verbose:; print('BR runtime:', time.time()-_run_time). if (not options.rhs_reuse) and (config.tdname is not None):; _cython_build_cleanup(config.tdname). if options.store_final_state:; rho.data = dense2D_to_fastc",MatchSource.WIKI,docs/4.7/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html:15171,Deployability,integrat,integration,15171,"t(); output.solver = ""brmesolve""; output.times = tlist. if options.store_states:; output.states = []. if isinstance(e_ops, types.FunctionType):; n_expt_op = 0; expt_callback = True. elif isinstance(e_ops, list):; n_expt_op = len(e_ops); expt_callback = False. if n_expt_op == 0:; # fall back on storing states; output.states = []; options.store_states = True; else:; output.expect = []; output.num_expect = n_expt_op; for op in e_ops:; e_sops_data.append(spre(op).data); if op.isherm:; output.expect.append(np.zeros(n_tsteps)); else:; output.expect.append(np.zeros(n_tsteps, dtype=complex)). else:; raise TypeError(""Expectation parameter must be a list or a function""). #; # start evolution; #; if type(progress_bar)==BaseProgressBar and verbose:; _run_time = time.time(). progress_bar.start(n_tsteps). rho = Qobj(rho0). dt = np.diff(tlist); for t_idx, t in enumerate(tlist):; progress_bar.update(t_idx). if not _ode.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""). if options.store_states or expt_callback:; rho.data = dense2D_to_fastcsr_fmode(vec2mat(_ode.y), rho.shape[0], rho.shape[1]). if options.store_states:; output.states.append(Qobj(rho, isherm=True)). if expt_callback:; # use callback method; e_ops(t, rho). for m in range(n_expt_op):; if output.expect[m].dtype == complex:; output.expect[m][t_idx] = expect_rho_vec(e_sops_data[m],; _ode.y, 0); else:; output.expect[m][t_idx] = expect_rho_vec(e_sops_data[m],; _ode.y, 1). if t_idx < n_tsteps - 1:; _ode.integrate(_ode.t + dt[t_idx]). progress_bar.finished(). if type(progress_bar)==BaseProgressBar and verbose:; print('BR runtime:', time.time()-_run_time). if (not options.rhs_reuse) and (config.tdname is not None):; _cython_build_cleanup(config.tdname). if options.store_final_state:; rho.data = dense2D_to_fastcsr_fmode(vec2mat(_ode.y), rho.shape[0], rho.shape[1]); output.final_state = Qobj(rho, dims=rho0.dims, i",MatchSource.WIKI,docs/4.7/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html:15804,Deployability,integrat,integrate,15804,"t):; n_expt_op = len(e_ops); expt_callback = False. if n_expt_op == 0:; # fall back on storing states; output.states = []; options.store_states = True; else:; output.expect = []; output.num_expect = n_expt_op; for op in e_ops:; e_sops_data.append(spre(op).data); if op.isherm:; output.expect.append(np.zeros(n_tsteps)); else:; output.expect.append(np.zeros(n_tsteps, dtype=complex)). else:; raise TypeError(""Expectation parameter must be a list or a function""). #; # start evolution; #; if type(progress_bar)==BaseProgressBar and verbose:; _run_time = time.time(). progress_bar.start(n_tsteps). rho = Qobj(rho0). dt = np.diff(tlist); for t_idx, t in enumerate(tlist):; progress_bar.update(t_idx). if not _ode.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""). if options.store_states or expt_callback:; rho.data = dense2D_to_fastcsr_fmode(vec2mat(_ode.y), rho.shape[0], rho.shape[1]). if options.store_states:; output.states.append(Qobj(rho, isherm=True)). if expt_callback:; # use callback method; e_ops(t, rho). for m in range(n_expt_op):; if output.expect[m].dtype == complex:; output.expect[m][t_idx] = expect_rho_vec(e_sops_data[m],; _ode.y, 0); else:; output.expect[m][t_idx] = expect_rho_vec(e_sops_data[m],; _ode.y, 1). if t_idx < n_tsteps - 1:; _ode.integrate(_ode.t + dt[t_idx]). progress_bar.finished(). if type(progress_bar)==BaseProgressBar and verbose:; print('BR runtime:', time.time()-_run_time). if (not options.rhs_reuse) and (config.tdname is not None):; _cython_build_cleanup(config.tdname). if options.store_final_state:; rho.data = dense2D_to_fastcsr_fmode(vec2mat(_ode.y), rho.shape[0], rho.shape[1]); output.final_state = Qobj(rho, dims=rho0.dims, isherm=True). return output. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html:16325,Deployability,update,updated,16325,"t):; n_expt_op = len(e_ops); expt_callback = False. if n_expt_op == 0:; # fall back on storing states; output.states = []; options.store_states = True; else:; output.expect = []; output.num_expect = n_expt_op; for op in e_ops:; e_sops_data.append(spre(op).data); if op.isherm:; output.expect.append(np.zeros(n_tsteps)); else:; output.expect.append(np.zeros(n_tsteps, dtype=complex)). else:; raise TypeError(""Expectation parameter must be a list or a function""). #; # start evolution; #; if type(progress_bar)==BaseProgressBar and verbose:; _run_time = time.time(). progress_bar.start(n_tsteps). rho = Qobj(rho0). dt = np.diff(tlist); for t_idx, t in enumerate(tlist):; progress_bar.update(t_idx). if not _ode.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""). if options.store_states or expt_callback:; rho.data = dense2D_to_fastcsr_fmode(vec2mat(_ode.y), rho.shape[0], rho.shape[1]). if options.store_states:; output.states.append(Qobj(rho, isherm=True)). if expt_callback:; # use callback method; e_ops(t, rho). for m in range(n_expt_op):; if output.expect[m].dtype == complex:; output.expect[m][t_idx] = expect_rho_vec(e_sops_data[m],; _ode.y, 0); else:; output.expect[m][t_idx] = expect_rho_vec(e_sops_data[m],; _ode.y, 1). if t_idx < n_tsteps - 1:; _ode.integrate(_ode.t + dt[t_idx]). progress_bar.finished(). if type(progress_bar)==BaseProgressBar and verbose:; print('BR runtime:', time.time()-_run_time). if (not options.rhs_reuse) and (config.tdname is not None):; _cython_build_cleanup(config.tdname). if options.store_final_state:; rho.data = dense2D_to_fastcsr_fmode(vec2mat(_ode.y), rho.shape[0], rho.shape[1]); output.final_state = Qobj(rho, dims=rho0.dims, isherm=True). return output. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html:504,Integrability,integrat,integrate,504,". qutip.bloch_redfield — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.bloch_redfield. Source code for qutip.bloch_redfield; __all__ = ['brmesolve', 'bloch_redfield_solve']. import numpy as np; import os; import time; import types; import warnings; import scipy.integrate; from qutip.qobj import Qobj, isket; from qutip.states import ket2dm; from qutip.superoperator import spre, spost, vec2mat, mat2vec; from qutip.expect import expect; from qutip.solver import Options, Result, config, _solver_safety_check; from qutip.cy.spmatfuncs import cy_ode_rhs; from qutip.cy.spconvert import dense2D_to_fastcsr_fmode; from qutip.interpolate import Cubic_Spline; from qutip.cy.br_codegen import BR_Codegen; from qutip.ui.progressbar import BaseProgressBar, TextProgressBar; from qutip.cy.utilities import _cython_build_cleanup; from qutip.expect import expect_rho_vec; from qutip.rhs_generate import _td_format_check; from qutip.cy.openmp.utilities import check_use_openmp; import qutip.settings as qset; from qutip.cy.br_tensor import bloch_redfield_tensor. # -----------------------------------------------------------------------------; # Solve the Bloch-Redfield master equation; #; [docs]def brmesolve(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[],; args={}, use_secular=True, sec_cutoff = 0.1,; tol=qset.atol,; spectra_cb=None, options=None,; progress_bar=None, _safe_mode=True, verbose=False):; """"""; Solves for the dynamics of a system using the Bloch-Redfield master equation,; given an input Hamiltonian, Hermitian bath-coupling terms and their associated; spectrum functions, as well as possible Lindblad collapse operators. For time-independent systems, the Hamiltonian must be given as a Qobj,; whereas the bath-coupling terms (a_ops), must be written as a",MatchSource.WIKI,docs/4.7/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html:2173,Integrability,depend,dependent,2173," qutip.cy.br_tensor import bloch_redfield_tensor. # -----------------------------------------------------------------------------; # Solve the Bloch-Redfield master equation; #; [docs]def brmesolve(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[],; args={}, use_secular=True, sec_cutoff = 0.1,; tol=qset.atol,; spectra_cb=None, options=None,; progress_bar=None, _safe_mode=True, verbose=False):; """"""; Solves for the dynamics of a system using the Bloch-Redfield master equation,; given an input Hamiltonian, Hermitian bath-coupling terms and their associated; spectrum functions, as well as possible Lindblad collapse operators. For time-independent systems, the Hamiltonian must be given as a Qobj,; whereas the bath-coupling terms (a_ops), must be written as a nested list; of operator - spectrum function pairs, where the frequency is specified by; the `w` variable. *Example*. a_ops = [[a+a.dag(),lambda w: 0.2*(w>=0)]]. For time-dependent systems, the Hamiltonian, a_ops, and Lindblad collapse; operators (c_ops), can be specified in the QuTiP string-based time-dependent; format. For the a_op spectra, the frequency variable must be `w`, and the; string cannot contain any other variables other than the possibility of having; a time-dependence through the time variable `t`:. *Example*. a_ops = [[a+a.dag(), '0.2*exp(-t)*(w>=0)']]. It is also possible to use Cubic_Spline objects for time-dependence. In; the case of a_ops, Cubic_Splines must be passed as a tuple:. *Example*. a_ops = [ [a+a.dag(), ( f(w), g(t)] ]. where f(w) and g(t) are strings or Cubic_spline objects for the bath; spectrum and time-dependence, respectively. Finally, if one has bath-couplimg terms of the form; H = f(t)*a + conj[f(t)]*a.dag(), then the correct input format is. *Example*. a_ops = [ [(a,a.dag()), (f(w), g1(t), g2(t))],... ]. where f(w) is the spectrum of the operators while g1(t) and g2(t); are the time-dependence of the operators `a` and `a.dag()`, respectively. Parameters; ----------; H : Qobj / list; Sy",MatchSource.WIKI,docs/4.7/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html:2306,Integrability,depend,dependent,2306," qutip.cy.br_tensor import bloch_redfield_tensor. # -----------------------------------------------------------------------------; # Solve the Bloch-Redfield master equation; #; [docs]def brmesolve(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[],; args={}, use_secular=True, sec_cutoff = 0.1,; tol=qset.atol,; spectra_cb=None, options=None,; progress_bar=None, _safe_mode=True, verbose=False):; """"""; Solves for the dynamics of a system using the Bloch-Redfield master equation,; given an input Hamiltonian, Hermitian bath-coupling terms and their associated; spectrum functions, as well as possible Lindblad collapse operators. For time-independent systems, the Hamiltonian must be given as a Qobj,; whereas the bath-coupling terms (a_ops), must be written as a nested list; of operator - spectrum function pairs, where the frequency is specified by; the `w` variable. *Example*. a_ops = [[a+a.dag(),lambda w: 0.2*(w>=0)]]. For time-dependent systems, the Hamiltonian, a_ops, and Lindblad collapse; operators (c_ops), can be specified in the QuTiP string-based time-dependent; format. For the a_op spectra, the frequency variable must be `w`, and the; string cannot contain any other variables other than the possibility of having; a time-dependence through the time variable `t`:. *Example*. a_ops = [[a+a.dag(), '0.2*exp(-t)*(w>=0)']]. It is also possible to use Cubic_Spline objects for time-dependence. In; the case of a_ops, Cubic_Splines must be passed as a tuple:. *Example*. a_ops = [ [a+a.dag(), ( f(w), g(t)] ]. where f(w) and g(t) are strings or Cubic_spline objects for the bath; spectrum and time-dependence, respectively. Finally, if one has bath-couplimg terms of the form; H = f(t)*a + conj[f(t)]*a.dag(), then the correct input format is. *Example*. a_ops = [ [(a,a.dag()), (f(w), g1(t), g2(t))],... ]. where f(w) is the spectrum of the operators while g1(t) and g2(t); are the time-dependence of the operators `a` and `a.dag()`, respectively. Parameters; ----------; H : Qobj / list; Sy",MatchSource.WIKI,docs/4.7/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html:2479,Integrability,depend,dependence,2479,"docs]def brmesolve(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[],; args={}, use_secular=True, sec_cutoff = 0.1,; tol=qset.atol,; spectra_cb=None, options=None,; progress_bar=None, _safe_mode=True, verbose=False):; """"""; Solves for the dynamics of a system using the Bloch-Redfield master equation,; given an input Hamiltonian, Hermitian bath-coupling terms and their associated; spectrum functions, as well as possible Lindblad collapse operators. For time-independent systems, the Hamiltonian must be given as a Qobj,; whereas the bath-coupling terms (a_ops), must be written as a nested list; of operator - spectrum function pairs, where the frequency is specified by; the `w` variable. *Example*. a_ops = [[a+a.dag(),lambda w: 0.2*(w>=0)]]. For time-dependent systems, the Hamiltonian, a_ops, and Lindblad collapse; operators (c_ops), can be specified in the QuTiP string-based time-dependent; format. For the a_op spectra, the frequency variable must be `w`, and the; string cannot contain any other variables other than the possibility of having; a time-dependence through the time variable `t`:. *Example*. a_ops = [[a+a.dag(), '0.2*exp(-t)*(w>=0)']]. It is also possible to use Cubic_Spline objects for time-dependence. In; the case of a_ops, Cubic_Splines must be passed as a tuple:. *Example*. a_ops = [ [a+a.dag(), ( f(w), g(t)] ]. where f(w) and g(t) are strings or Cubic_spline objects for the bath; spectrum and time-dependence, respectively. Finally, if one has bath-couplimg terms of the form; H = f(t)*a + conj[f(t)]*a.dag(), then the correct input format is. *Example*. a_ops = [ [(a,a.dag()), (f(w), g1(t), g2(t))],... ]. where f(w) is the spectrum of the operators while g1(t) and g2(t); are the time-dependence of the operators `a` and `a.dag()`, respectively. Parameters; ----------; H : Qobj / list; System Hamiltonian given as a Qobj or; nested list in string-based format. psi0: Qobj; Initial density matrix or state vector (ket). tlist : array_like; List of times for evaluating",MatchSource.WIKI,docs/4.7/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html:2635,Integrability,depend,dependence,2635,"=True, verbose=False):; """"""; Solves for the dynamics of a system using the Bloch-Redfield master equation,; given an input Hamiltonian, Hermitian bath-coupling terms and their associated; spectrum functions, as well as possible Lindblad collapse operators. For time-independent systems, the Hamiltonian must be given as a Qobj,; whereas the bath-coupling terms (a_ops), must be written as a nested list; of operator - spectrum function pairs, where the frequency is specified by; the `w` variable. *Example*. a_ops = [[a+a.dag(),lambda w: 0.2*(w>=0)]]. For time-dependent systems, the Hamiltonian, a_ops, and Lindblad collapse; operators (c_ops), can be specified in the QuTiP string-based time-dependent; format. For the a_op spectra, the frequency variable must be `w`, and the; string cannot contain any other variables other than the possibility of having; a time-dependence through the time variable `t`:. *Example*. a_ops = [[a+a.dag(), '0.2*exp(-t)*(w>=0)']]. It is also possible to use Cubic_Spline objects for time-dependence. In; the case of a_ops, Cubic_Splines must be passed as a tuple:. *Example*. a_ops = [ [a+a.dag(), ( f(w), g(t)] ]. where f(w) and g(t) are strings or Cubic_spline objects for the bath; spectrum and time-dependence, respectively. Finally, if one has bath-couplimg terms of the form; H = f(t)*a + conj[f(t)]*a.dag(), then the correct input format is. *Example*. a_ops = [ [(a,a.dag()), (f(w), g1(t), g2(t))],... ]. where f(w) is the spectrum of the operators while g1(t) and g2(t); are the time-dependence of the operators `a` and `a.dag()`, respectively. Parameters; ----------; H : Qobj / list; System Hamiltonian given as a Qobj or; nested list in string-based format. psi0: Qobj; Initial density matrix or state vector (ket). tlist : array_like; List of times for evaluating evolution. a_ops : list; Nested list of Hermitian system operators that couple to; the bath degrees of freedom, along with their associated; spectra. e_ops : list; List of operators for wh",MatchSource.WIKI,docs/4.7/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html:2850,Integrability,depend,dependence,2850," as well as possible Lindblad collapse operators. For time-independent systems, the Hamiltonian must be given as a Qobj,; whereas the bath-coupling terms (a_ops), must be written as a nested list; of operator - spectrum function pairs, where the frequency is specified by; the `w` variable. *Example*. a_ops = [[a+a.dag(),lambda w: 0.2*(w>=0)]]. For time-dependent systems, the Hamiltonian, a_ops, and Lindblad collapse; operators (c_ops), can be specified in the QuTiP string-based time-dependent; format. For the a_op spectra, the frequency variable must be `w`, and the; string cannot contain any other variables other than the possibility of having; a time-dependence through the time variable `t`:. *Example*. a_ops = [[a+a.dag(), '0.2*exp(-t)*(w>=0)']]. It is also possible to use Cubic_Spline objects for time-dependence. In; the case of a_ops, Cubic_Splines must be passed as a tuple:. *Example*. a_ops = [ [a+a.dag(), ( f(w), g(t)] ]. where f(w) and g(t) are strings or Cubic_spline objects for the bath; spectrum and time-dependence, respectively. Finally, if one has bath-couplimg terms of the form; H = f(t)*a + conj[f(t)]*a.dag(), then the correct input format is. *Example*. a_ops = [ [(a,a.dag()), (f(w), g1(t), g2(t))],... ]. where f(w) is the spectrum of the operators while g1(t) and g2(t); are the time-dependence of the operators `a` and `a.dag()`, respectively. Parameters; ----------; H : Qobj / list; System Hamiltonian given as a Qobj or; nested list in string-based format. psi0: Qobj; Initial density matrix or state vector (ket). tlist : array_like; List of times for evaluating evolution. a_ops : list; Nested list of Hermitian system operators that couple to; the bath degrees of freedom, along with their associated; spectra. e_ops : list; List of operators for which to evaluate expectation values. c_ops : list; List of system collapse operators, or nested list in; string-based format. args : dict; Placeholder for future implementation, kept for API consistency. use",MatchSource.WIKI,docs/4.7/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html:3140,Integrability,depend,dependence,3140," a_ops = [[a+a.dag(),lambda w: 0.2*(w>=0)]]. For time-dependent systems, the Hamiltonian, a_ops, and Lindblad collapse; operators (c_ops), can be specified in the QuTiP string-based time-dependent; format. For the a_op spectra, the frequency variable must be `w`, and the; string cannot contain any other variables other than the possibility of having; a time-dependence through the time variable `t`:. *Example*. a_ops = [[a+a.dag(), '0.2*exp(-t)*(w>=0)']]. It is also possible to use Cubic_Spline objects for time-dependence. In; the case of a_ops, Cubic_Splines must be passed as a tuple:. *Example*. a_ops = [ [a+a.dag(), ( f(w), g(t)] ]. where f(w) and g(t) are strings or Cubic_spline objects for the bath; spectrum and time-dependence, respectively. Finally, if one has bath-couplimg terms of the form; H = f(t)*a + conj[f(t)]*a.dag(), then the correct input format is. *Example*. a_ops = [ [(a,a.dag()), (f(w), g1(t), g2(t))],... ]. where f(w) is the spectrum of the operators while g1(t) and g2(t); are the time-dependence of the operators `a` and `a.dag()`, respectively. Parameters; ----------; H : Qobj / list; System Hamiltonian given as a Qobj or; nested list in string-based format. psi0: Qobj; Initial density matrix or state vector (ket). tlist : array_like; List of times for evaluating evolution. a_ops : list; Nested list of Hermitian system operators that couple to; the bath degrees of freedom, along with their associated; spectra. e_ops : list; List of operators for which to evaluate expectation values. c_ops : list; List of system collapse operators, or nested list in; string-based format. args : dict; Placeholder for future implementation, kept for API consistency. use_secular : bool {True}; Use secular approximation when evaluating bath-coupling terms. sec_cutoff : float {0.1}; Cutoff for secular approximation. tol : float {qutip.setttings.atol}; Tolerance used for removing small values after; basis transformation. spectra_cb : list; DEPRECIATED. Do not use. opti",MatchSource.WIKI,docs/4.7/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html:5280,Integrability,depend,dependent,5280,"s of the simulation. Returns; -------; result: :class:`qutip.solver.Result`. An instance of the class :class:`qutip.solver.Result`, which contains; either an array of expectation values, for operators given in e_ops,; or a list of states for the times specified by `tlist`.; """"""; _prep_time = time.time(); #This allows for passing a list of time-independent Qobj; #as allowed by mesolve; if isinstance(H, list):; if np.all([isinstance(h,Qobj) for h in H]):; H = sum(H). if isinstance(c_ops, Qobj):; c_ops = [c_ops]. if isinstance(e_ops, Qobj):; e_ops = [e_ops]. if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None. if not (spectra_cb is None):; warnings.warn(""The use of spectra_cb is depreciated."", DeprecationWarning); _a_ops = []; for kk, a in enumerate(a_ops):; _a_ops.append([a,spectra_cb[kk]]); a_ops = _a_ops. if _safe_mode:; _solver_safety_check(H, psi0, a_ops+c_ops, e_ops, args). # check for type (if any) of time-dependent inputs; _, n_func, n_str = _td_format_check(H, a_ops+c_ops). if progress_bar is None:; progress_bar = BaseProgressBar(); elif progress_bar is True:; progress_bar = TextProgressBar(). if options is None:; options = Options(). if (not options.rhs_reuse) or (not config.tdfunc):; # reset config collapse and time-dependence flags to default values; config.reset(). #check if should use OPENMP; check_use_openmp(options). if n_str == 0:. R, ekets = bloch_redfield_tensor(H, a_ops, spectra_cb=None, c_ops=c_ops,; use_secular=use_secular, sec_cutoff=sec_cutoff). output = Result(); output.solver = ""brmesolve""; output.times = tlist. results = bloch_redfield_solve(R, ekets, psi0, tlist, e_ops, options,; progress_bar=progress_bar). if e_ops:; output.expect = results; else:; output.states = results. return output. elif n_str != 0 and n_func == 0:; output = _td_brmesolve(H, psi0, tlist, a_ops=a_ops, e_ops=e_ops,; c_ops=c_ops, args=args, use_secular=use_secular,; sec_cutoff=sec_cutoff,; tol=tol, options=options,",MatchSource.WIKI,docs/4.7/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html:5600,Integrability,depend,dependence,5600,"); #This allows for passing a list of time-independent Qobj; #as allowed by mesolve; if isinstance(H, list):; if np.all([isinstance(h,Qobj) for h in H]):; H = sum(H). if isinstance(c_ops, Qobj):; c_ops = [c_ops]. if isinstance(e_ops, Qobj):; e_ops = [e_ops]. if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None. if not (spectra_cb is None):; warnings.warn(""The use of spectra_cb is depreciated."", DeprecationWarning); _a_ops = []; for kk, a in enumerate(a_ops):; _a_ops.append([a,spectra_cb[kk]]); a_ops = _a_ops. if _safe_mode:; _solver_safety_check(H, psi0, a_ops+c_ops, e_ops, args). # check for type (if any) of time-dependent inputs; _, n_func, n_str = _td_format_check(H, a_ops+c_ops). if progress_bar is None:; progress_bar = BaseProgressBar(); elif progress_bar is True:; progress_bar = TextProgressBar(). if options is None:; options = Options(). if (not options.rhs_reuse) or (not config.tdfunc):; # reset config collapse and time-dependence flags to default values; config.reset(). #check if should use OPENMP; check_use_openmp(options). if n_str == 0:. R, ekets = bloch_redfield_tensor(H, a_ops, spectra_cb=None, c_ops=c_ops,; use_secular=use_secular, sec_cutoff=sec_cutoff). output = Result(); output.solver = ""brmesolve""; output.times = tlist. results = bloch_redfield_solve(R, ekets, psi0, tlist, e_ops, options,; progress_bar=progress_bar). if e_ops:; output.expect = results; else:; output.states = results. return output. elif n_str != 0 and n_func == 0:; output = _td_brmesolve(H, psi0, tlist, a_ops=a_ops, e_ops=e_ops,; c_ops=c_ops, args=args, use_secular=use_secular,; sec_cutoff=sec_cutoff,; tol=tol, options=options,; progress_bar=progress_bar,; _safe_mode=_safe_mode, verbose=verbose,; _prep_time=_prep_time). return output. else:; raise Exception('Cannot mix func and str formats.'). # -----------------------------------------------------------------------------; # Evolution of the Bloch-Redfield master equation g",MatchSource.WIKI,docs/4.7/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html:8344,Integrability,integrat,integrator,8344,"lver. Returns; -------. output: :class:`qutip.solver.Result`. An instance of the class :class:`qutip.solver.Result`, which contains either; an *array* of expectation values for the times specified by `tlist`. """""". if options is None:; options = Options(). if options.tidy:; R.tidyup(). if progress_bar is None:; progress_bar = BaseProgressBar(); elif progress_bar is True:; progress_bar = TextProgressBar(). #; # check initial state; #; if isket(rho0):; # Got a wave function as initial state: convert to density matrix.; rho0 = rho0 * rho0.dag(). #; # prepare output array; #; n_tsteps = len(tlist); dt = tlist[1] - tlist[0]; result_list = []. #; # transform the initial density matrix and the e_ops opterators to the; # eigenbasis; #; rho_eb = rho0.transform(ekets); e_eb_ops = [e.transform(ekets) for e in e_ops]. for e_eb in e_eb_ops:; if e_eb.isherm:; result_list.append(np.zeros(n_tsteps, dtype=float)); else:; result_list.append(np.zeros(n_tsteps, dtype=complex)). #; # setup integrator; #; initial_vector = mat2vec(rho_eb.full()); r = scipy.integrate.ode(cy_ode_rhs); r.set_f_params(R.data.data, R.data.indices, R.data.indptr); r.set_integrator('zvode', method=options.method, order=options.order,; atol=options.atol, rtol=options.rtol,; nsteps=options.nsteps, first_step=options.first_step,; min_step=options.min_step, max_step=options.max_step); r.set_initial_value(initial_vector, tlist[0]). #; # start evolution; #; dt = np.diff(tlist); progress_bar.start(n_tsteps); for t_idx, _ in enumerate(tlist):; progress_bar.update(t_idx); if not r.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""). rho_eb.data = dense2D_to_fastcsr_fmode(vec2mat(r.y), rho0.shape[0], rho0.shape[1]). # calculate all the expectation values, or output rho_eb if no; # expectation value operators are given; if e_ops:; rho_eb_tmp = Qobj(rho_eb); for m, e in enumerate(e_eb_ops):; result_list[m][t_id",MatchSource.WIKI,docs/4.7/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html:8410,Integrability,integrat,integrate,8410,"esult`. An instance of the class :class:`qutip.solver.Result`, which contains either; an *array* of expectation values for the times specified by `tlist`. """""". if options is None:; options = Options(). if options.tidy:; R.tidyup(). if progress_bar is None:; progress_bar = BaseProgressBar(); elif progress_bar is True:; progress_bar = TextProgressBar(). #; # check initial state; #; if isket(rho0):; # Got a wave function as initial state: convert to density matrix.; rho0 = rho0 * rho0.dag(). #; # prepare output array; #; n_tsteps = len(tlist); dt = tlist[1] - tlist[0]; result_list = []. #; # transform the initial density matrix and the e_ops opterators to the; # eigenbasis; #; rho_eb = rho0.transform(ekets); e_eb_ops = [e.transform(ekets) for e in e_ops]. for e_eb in e_eb_ops:; if e_eb.isherm:; result_list.append(np.zeros(n_tsteps, dtype=float)); else:; result_list.append(np.zeros(n_tsteps, dtype=complex)). #; # setup integrator; #; initial_vector = mat2vec(rho_eb.full()); r = scipy.integrate.ode(cy_ode_rhs); r.set_f_params(R.data.data, R.data.indices, R.data.indptr); r.set_integrator('zvode', method=options.method, order=options.order,; atol=options.atol, rtol=options.rtol,; nsteps=options.nsteps, first_step=options.first_step,; min_step=options.min_step, max_step=options.max_step); r.set_initial_value(initial_vector, tlist[0]). #; # start evolution; #; dt = np.diff(tlist); progress_bar.start(n_tsteps); for t_idx, _ in enumerate(tlist):; progress_bar.update(t_idx); if not r.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""). rho_eb.data = dense2D_to_fastcsr_fmode(vec2mat(r.y), rho0.shape[0], rho0.shape[1]). # calculate all the expectation values, or output rho_eb if no; # expectation value operators are given; if e_ops:; rho_eb_tmp = Qobj(rho_eb); for m, e in enumerate(e_eb_ops):; result_list[m][t_idx] = expect(e, rho_eb_tmp); else:; result_list.append",MatchSource.WIKI,docs/4.7/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html:8948,Integrability,integrat,integration,8948,"list = []. #; # transform the initial density matrix and the e_ops opterators to the; # eigenbasis; #; rho_eb = rho0.transform(ekets); e_eb_ops = [e.transform(ekets) for e in e_ops]. for e_eb in e_eb_ops:; if e_eb.isherm:; result_list.append(np.zeros(n_tsteps, dtype=float)); else:; result_list.append(np.zeros(n_tsteps, dtype=complex)). #; # setup integrator; #; initial_vector = mat2vec(rho_eb.full()); r = scipy.integrate.ode(cy_ode_rhs); r.set_f_params(R.data.data, R.data.indices, R.data.indptr); r.set_integrator('zvode', method=options.method, order=options.order,; atol=options.atol, rtol=options.rtol,; nsteps=options.nsteps, first_step=options.first_step,; min_step=options.min_step, max_step=options.max_step); r.set_initial_value(initial_vector, tlist[0]). #; # start evolution; #; dt = np.diff(tlist); progress_bar.start(n_tsteps); for t_idx, _ in enumerate(tlist):; progress_bar.update(t_idx); if not r.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""). rho_eb.data = dense2D_to_fastcsr_fmode(vec2mat(r.y), rho0.shape[0], rho0.shape[1]). # calculate all the expectation values, or output rho_eb if no; # expectation value operators are given; if e_ops:; rho_eb_tmp = Qobj(rho_eb); for m, e in enumerate(e_eb_ops):; result_list[m][t_idx] = expect(e, rho_eb_tmp); else:; result_list.append(rho_eb.transform(ekets, True)). if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]); progress_bar.finished(); return result_list. def _td_brmesolve(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[], args={},; use_secular=True, sec_cutoff=0.1,; tol=qset.atol, options=None,; progress_bar=None,_safe_mode=True,; verbose=False,; _prep_time=0):. if isket(psi0):; rho0 = ket2dm(psi0); else:; rho0 = psi0; nrows = rho0.shape[0]. H_terms = []; H_td_terms = []; H_obj = []; A_terms = []; A_td_terms = []; C_terms = []; C_td_terms = []; CA_obj = []; spline_count = [0,0]; coupled_ops = []; ",MatchSource.WIKI,docs/4.7/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html:9476,Integrability,integrat,integrate,9476,".data.indptr); r.set_integrator('zvode', method=options.method, order=options.order,; atol=options.atol, rtol=options.rtol,; nsteps=options.nsteps, first_step=options.first_step,; min_step=options.min_step, max_step=options.max_step); r.set_initial_value(initial_vector, tlist[0]). #; # start evolution; #; dt = np.diff(tlist); progress_bar.start(n_tsteps); for t_idx, _ in enumerate(tlist):; progress_bar.update(t_idx); if not r.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""). rho_eb.data = dense2D_to_fastcsr_fmode(vec2mat(r.y), rho0.shape[0], rho0.shape[1]). # calculate all the expectation values, or output rho_eb if no; # expectation value operators are given; if e_ops:; rho_eb_tmp = Qobj(rho_eb); for m, e in enumerate(e_eb_ops):; result_list[m][t_idx] = expect(e, rho_eb_tmp); else:; result_list.append(rho_eb.transform(ekets, True)). if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]); progress_bar.finished(); return result_list. def _td_brmesolve(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[], args={},; use_secular=True, sec_cutoff=0.1,; tol=qset.atol, options=None,; progress_bar=None,_safe_mode=True,; verbose=False,; _prep_time=0):. if isket(psi0):; rho0 = ket2dm(psi0); else:; rho0 = psi0; nrows = rho0.shape[0]. H_terms = []; H_td_terms = []; H_obj = []; A_terms = []; A_td_terms = []; C_terms = []; C_td_terms = []; CA_obj = []; spline_count = [0,0]; coupled_ops = []; coupled_lengths = []; coupled_spectra = []. if isinstance(H, Qobj):; H_terms.append(H.full('f')); H_td_terms.append('1'); else:; for kk, h in enumerate(H):; if isinstance(h, Qobj):; H_terms.append(h.full('f')); H_td_terms.append('1'); elif isinstance(h, list):; H_terms.append(h[0].full('f')); if isinstance(h[1], Cubic_Spline):; H_obj.append(h[1].coeffs); spline_count[0] += 1; H_td_terms.append(h[1]); else:; raise Exception('Invalid Hamiltonian specification.'). for kk, c in enumerat",MatchSource.WIKI,docs/4.7/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html:13722,Integrability,integrat,integrate,13722,"name is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; if verbose:; _st = time.time(); cgen = BR_Codegen(h_terms=len(H_terms),; h_td_terms=H_td_terms, h_obj=H_obj,; c_terms=len(C_terms),; c_td_terms=C_td_terms, c_obj=CA_obj,; a_terms=len(A_terms), a_td_terms=A_td_terms,; spline_count=spline_count,; coupled_ops = coupled_ops,; coupled_lengths = coupled_lengths,; coupled_spectra = coupled_spectra,; config=config, sparse=False,; use_secular = use_secular,; sec_cutoff = sec_cutoff,; args=args,; use_openmp=options.use_openmp,; omp_thresh=qset.openmp_thresh if qset.has_openmp else None,; omp_threads=options.num_cpus,; atol=tol). cgen.generate(config.tdname + "".pyx""); code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs; if verbose:; print('BR compile time:', time.time()-_st); initial_vector = mat2vec(rho0.full()).ravel(). _ode = scipy.integrate.ode(config.tdfunc); code = compile('_ode.set_f_params(' + parameter_string + ')',; '<string>', 'exec'); _ode.set_integrator('zvode', method=options.method,; order=options.order, atol=options.atol,; rtol=options.rtol, nsteps=options.nsteps,; first_step=options.first_step,; min_step=options.min_step,; max_step=options.max_step); _ode.set_initial_value(initial_vector, tlist[0]); exec(code, locals()). #; # prepare output array; #; n_tsteps = len(tlist); e_sops_data = []. output = Result(); output.solver = ""brmesolve""; output.times = tlist. if options.store_states:; output.states = []. if isinstance(e_ops, types.FunctionType):; n_expt_op = 0; expt_callback = True. elif isinstance(e_ops, list):; n_expt_op = len(e_ops); expt_callback = False. if n_expt_op == 0:; # fall back on storing states; output.states = []; options.store_states = True; else:; output.expect = []; output.num_expect = n_expt_op; for op in e_ops:; e_sops_data.append(spre(op).data); if op.isherm:; output.expect.append(np",MatchSource.WIKI,docs/4.7/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html:15171,Integrability,integrat,integration,15171,"t(); output.solver = ""brmesolve""; output.times = tlist. if options.store_states:; output.states = []. if isinstance(e_ops, types.FunctionType):; n_expt_op = 0; expt_callback = True. elif isinstance(e_ops, list):; n_expt_op = len(e_ops); expt_callback = False. if n_expt_op == 0:; # fall back on storing states; output.states = []; options.store_states = True; else:; output.expect = []; output.num_expect = n_expt_op; for op in e_ops:; e_sops_data.append(spre(op).data); if op.isherm:; output.expect.append(np.zeros(n_tsteps)); else:; output.expect.append(np.zeros(n_tsteps, dtype=complex)). else:; raise TypeError(""Expectation parameter must be a list or a function""). #; # start evolution; #; if type(progress_bar)==BaseProgressBar and verbose:; _run_time = time.time(). progress_bar.start(n_tsteps). rho = Qobj(rho0). dt = np.diff(tlist); for t_idx, t in enumerate(tlist):; progress_bar.update(t_idx). if not _ode.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""). if options.store_states or expt_callback:; rho.data = dense2D_to_fastcsr_fmode(vec2mat(_ode.y), rho.shape[0], rho.shape[1]). if options.store_states:; output.states.append(Qobj(rho, isherm=True)). if expt_callback:; # use callback method; e_ops(t, rho). for m in range(n_expt_op):; if output.expect[m].dtype == complex:; output.expect[m][t_idx] = expect_rho_vec(e_sops_data[m],; _ode.y, 0); else:; output.expect[m][t_idx] = expect_rho_vec(e_sops_data[m],; _ode.y, 1). if t_idx < n_tsteps - 1:; _ode.integrate(_ode.t + dt[t_idx]). progress_bar.finished(). if type(progress_bar)==BaseProgressBar and verbose:; print('BR runtime:', time.time()-_run_time). if (not options.rhs_reuse) and (config.tdname is not None):; _cython_build_cleanup(config.tdname). if options.store_final_state:; rho.data = dense2D_to_fastcsr_fmode(vec2mat(_ode.y), rho.shape[0], rho.shape[1]); output.final_state = Qobj(rho, dims=rho0.dims, i",MatchSource.WIKI,docs/4.7/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html:15804,Integrability,integrat,integrate,15804,"t):; n_expt_op = len(e_ops); expt_callback = False. if n_expt_op == 0:; # fall back on storing states; output.states = []; options.store_states = True; else:; output.expect = []; output.num_expect = n_expt_op; for op in e_ops:; e_sops_data.append(spre(op).data); if op.isherm:; output.expect.append(np.zeros(n_tsteps)); else:; output.expect.append(np.zeros(n_tsteps, dtype=complex)). else:; raise TypeError(""Expectation parameter must be a list or a function""). #; # start evolution; #; if type(progress_bar)==BaseProgressBar and verbose:; _run_time = time.time(). progress_bar.start(n_tsteps). rho = Qobj(rho0). dt = np.diff(tlist); for t_idx, t in enumerate(tlist):; progress_bar.update(t_idx). if not _ode.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""). if options.store_states or expt_callback:; rho.data = dense2D_to_fastcsr_fmode(vec2mat(_ode.y), rho.shape[0], rho.shape[1]). if options.store_states:; output.states.append(Qobj(rho, isherm=True)). if expt_callback:; # use callback method; e_ops(t, rho). for m in range(n_expt_op):; if output.expect[m].dtype == complex:; output.expect[m][t_idx] = expect_rho_vec(e_sops_data[m],; _ode.y, 0); else:; output.expect[m][t_idx] = expect_rho_vec(e_sops_data[m],; _ode.y, 1). if t_idx < n_tsteps - 1:; _ode.integrate(_ode.t + dt[t_idx]). progress_bar.finished(). if type(progress_bar)==BaseProgressBar and verbose:; print('BR runtime:', time.time()-_run_time). if (not options.rhs_reuse) and (config.tdname is not None):; _cython_build_cleanup(config.tdname). if options.store_final_state:; rho.data = dense2D_to_fastcsr_fmode(vec2mat(_ode.y), rho.shape[0], rho.shape[1]); output.final_state = Qobj(rho, dims=rho0.dims, isherm=True). return output. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html:722,Modifiability,config,config,722,". qutip.bloch_redfield — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.bloch_redfield. Source code for qutip.bloch_redfield; __all__ = ['brmesolve', 'bloch_redfield_solve']. import numpy as np; import os; import time; import types; import warnings; import scipy.integrate; from qutip.qobj import Qobj, isket; from qutip.states import ket2dm; from qutip.superoperator import spre, spost, vec2mat, mat2vec; from qutip.expect import expect; from qutip.solver import Options, Result, config, _solver_safety_check; from qutip.cy.spmatfuncs import cy_ode_rhs; from qutip.cy.spconvert import dense2D_to_fastcsr_fmode; from qutip.interpolate import Cubic_Spline; from qutip.cy.br_codegen import BR_Codegen; from qutip.ui.progressbar import BaseProgressBar, TextProgressBar; from qutip.cy.utilities import _cython_build_cleanup; from qutip.expect import expect_rho_vec; from qutip.rhs_generate import _td_format_check; from qutip.cy.openmp.utilities import check_use_openmp; import qutip.settings as qset; from qutip.cy.br_tensor import bloch_redfield_tensor. # -----------------------------------------------------------------------------; # Solve the Bloch-Redfield master equation; #; [docs]def brmesolve(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[],; args={}, use_secular=True, sec_cutoff = 0.1,; tol=qset.atol,; spectra_cb=None, options=None,; progress_bar=None, _safe_mode=True, verbose=False):; """"""; Solves for the dynamics of a system using the Bloch-Redfield master equation,; given an input Hamiltonian, Hermitian bath-coupling terms and their associated; spectrum functions, as well as possible Lindblad collapse operators. For time-independent systems, the Hamiltonian must be given as a Qobj,; whereas the bath-coupling terms (a_ops), must be written as a",MatchSource.WIKI,docs/4.7/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html:1762,Modifiability,coupling,coupling,1762,"Options, Result, config, _solver_safety_check; from qutip.cy.spmatfuncs import cy_ode_rhs; from qutip.cy.spconvert import dense2D_to_fastcsr_fmode; from qutip.interpolate import Cubic_Spline; from qutip.cy.br_codegen import BR_Codegen; from qutip.ui.progressbar import BaseProgressBar, TextProgressBar; from qutip.cy.utilities import _cython_build_cleanup; from qutip.expect import expect_rho_vec; from qutip.rhs_generate import _td_format_check; from qutip.cy.openmp.utilities import check_use_openmp; import qutip.settings as qset; from qutip.cy.br_tensor import bloch_redfield_tensor. # -----------------------------------------------------------------------------; # Solve the Bloch-Redfield master equation; #; [docs]def brmesolve(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[],; args={}, use_secular=True, sec_cutoff = 0.1,; tol=qset.atol,; spectra_cb=None, options=None,; progress_bar=None, _safe_mode=True, verbose=False):; """"""; Solves for the dynamics of a system using the Bloch-Redfield master equation,; given an input Hamiltonian, Hermitian bath-coupling terms and their associated; spectrum functions, as well as possible Lindblad collapse operators. For time-independent systems, the Hamiltonian must be given as a Qobj,; whereas the bath-coupling terms (a_ops), must be written as a nested list; of operator - spectrum function pairs, where the frequency is specified by; the `w` variable. *Example*. a_ops = [[a+a.dag(),lambda w: 0.2*(w>=0)]]. For time-dependent systems, the Hamiltonian, a_ops, and Lindblad collapse; operators (c_ops), can be specified in the QuTiP string-based time-dependent; format. For the a_op spectra, the frequency variable must be `w`, and the; string cannot contain any other variables other than the possibility of having; a time-dependence through the time variable `t`:. *Example*. a_ops = [[a+a.dag(), '0.2*exp(-t)*(w>=0)']]. It is also possible to use Cubic_Spline objects for time-dependence. In; the case of a_ops, Cubic_Splines must be passed as a t",MatchSource.WIKI,docs/4.7/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html:1957,Modifiability,coupling,coupling,1957,"ar, TextProgressBar; from qutip.cy.utilities import _cython_build_cleanup; from qutip.expect import expect_rho_vec; from qutip.rhs_generate import _td_format_check; from qutip.cy.openmp.utilities import check_use_openmp; import qutip.settings as qset; from qutip.cy.br_tensor import bloch_redfield_tensor. # -----------------------------------------------------------------------------; # Solve the Bloch-Redfield master equation; #; [docs]def brmesolve(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[],; args={}, use_secular=True, sec_cutoff = 0.1,; tol=qset.atol,; spectra_cb=None, options=None,; progress_bar=None, _safe_mode=True, verbose=False):; """"""; Solves for the dynamics of a system using the Bloch-Redfield master equation,; given an input Hamiltonian, Hermitian bath-coupling terms and their associated; spectrum functions, as well as possible Lindblad collapse operators. For time-independent systems, the Hamiltonian must be given as a Qobj,; whereas the bath-coupling terms (a_ops), must be written as a nested list; of operator - spectrum function pairs, where the frequency is specified by; the `w` variable. *Example*. a_ops = [[a+a.dag(),lambda w: 0.2*(w>=0)]]. For time-dependent systems, the Hamiltonian, a_ops, and Lindblad collapse; operators (c_ops), can be specified in the QuTiP string-based time-dependent; format. For the a_op spectra, the frequency variable must be `w`, and the; string cannot contain any other variables other than the possibility of having; a time-dependence through the time variable `t`:. *Example*. a_ops = [[a+a.dag(), '0.2*exp(-t)*(w>=0)']]. It is also possible to use Cubic_Spline objects for time-dependence. In; the case of a_ops, Cubic_Splines must be passed as a tuple:. *Example*. a_ops = [ [a+a.dag(), ( f(w), g(t)] ]. where f(w) and g(t) are strings or Cubic_spline objects for the bath; spectrum and time-dependence, respectively. Finally, if one has bath-couplimg terms of the form; H = f(t)*a + conj[f(t)]*a.dag(), then the correct input for",MatchSource.WIKI,docs/4.7/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html:2099,Modifiability,variab,variable,2099,"ar, TextProgressBar; from qutip.cy.utilities import _cython_build_cleanup; from qutip.expect import expect_rho_vec; from qutip.rhs_generate import _td_format_check; from qutip.cy.openmp.utilities import check_use_openmp; import qutip.settings as qset; from qutip.cy.br_tensor import bloch_redfield_tensor. # -----------------------------------------------------------------------------; # Solve the Bloch-Redfield master equation; #; [docs]def brmesolve(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[],; args={}, use_secular=True, sec_cutoff = 0.1,; tol=qset.atol,; spectra_cb=None, options=None,; progress_bar=None, _safe_mode=True, verbose=False):; """"""; Solves for the dynamics of a system using the Bloch-Redfield master equation,; given an input Hamiltonian, Hermitian bath-coupling terms and their associated; spectrum functions, as well as possible Lindblad collapse operators. For time-independent systems, the Hamiltonian must be given as a Qobj,; whereas the bath-coupling terms (a_ops), must be written as a nested list; of operator - spectrum function pairs, where the frequency is specified by; the `w` variable. *Example*. a_ops = [[a+a.dag(),lambda w: 0.2*(w>=0)]]. For time-dependent systems, the Hamiltonian, a_ops, and Lindblad collapse; operators (c_ops), can be specified in the QuTiP string-based time-dependent; format. For the a_op spectra, the frequency variable must be `w`, and the; string cannot contain any other variables other than the possibility of having; a time-dependence through the time variable `t`:. *Example*. a_ops = [[a+a.dag(), '0.2*exp(-t)*(w>=0)']]. It is also possible to use Cubic_Spline objects for time-dependence. In; the case of a_ops, Cubic_Splines must be passed as a tuple:. *Example*. a_ops = [ [a+a.dag(), ( f(w), g(t)] ]. where f(w) and g(t) are strings or Cubic_spline objects for the bath; spectrum and time-dependence, respectively. Finally, if one has bath-couplimg terms of the form; H = f(t)*a + conj[f(t)]*a.dag(), then the correct input for",MatchSource.WIKI,docs/4.7/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html:2361,Modifiability,variab,variable,2361,"docs]def brmesolve(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[],; args={}, use_secular=True, sec_cutoff = 0.1,; tol=qset.atol,; spectra_cb=None, options=None,; progress_bar=None, _safe_mode=True, verbose=False):; """"""; Solves for the dynamics of a system using the Bloch-Redfield master equation,; given an input Hamiltonian, Hermitian bath-coupling terms and their associated; spectrum functions, as well as possible Lindblad collapse operators. For time-independent systems, the Hamiltonian must be given as a Qobj,; whereas the bath-coupling terms (a_ops), must be written as a nested list; of operator - spectrum function pairs, where the frequency is specified by; the `w` variable. *Example*. a_ops = [[a+a.dag(),lambda w: 0.2*(w>=0)]]. For time-dependent systems, the Hamiltonian, a_ops, and Lindblad collapse; operators (c_ops), can be specified in the QuTiP string-based time-dependent; format. For the a_op spectra, the frequency variable must be `w`, and the; string cannot contain any other variables other than the possibility of having; a time-dependence through the time variable `t`:. *Example*. a_ops = [[a+a.dag(), '0.2*exp(-t)*(w>=0)']]. It is also possible to use Cubic_Spline objects for time-dependence. In; the case of a_ops, Cubic_Splines must be passed as a tuple:. *Example*. a_ops = [ [a+a.dag(), ( f(w), g(t)] ]. where f(w) and g(t) are strings or Cubic_spline objects for the bath; spectrum and time-dependence, respectively. Finally, if one has bath-couplimg terms of the form; H = f(t)*a + conj[f(t)]*a.dag(), then the correct input format is. *Example*. a_ops = [ [(a,a.dag()), (f(w), g1(t), g2(t))],... ]. where f(w) is the spectrum of the operators while g1(t) and g2(t); are the time-dependence of the operators `a` and `a.dag()`, respectively. Parameters; ----------; H : Qobj / list; System Hamiltonian given as a Qobj or; nested list in string-based format. psi0: Qobj; Initial density matrix or state vector (ket). tlist : array_like; List of times for evaluating",MatchSource.WIKI,docs/4.7/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html:2424,Modifiability,variab,variables,2424,"docs]def brmesolve(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[],; args={}, use_secular=True, sec_cutoff = 0.1,; tol=qset.atol,; spectra_cb=None, options=None,; progress_bar=None, _safe_mode=True, verbose=False):; """"""; Solves for the dynamics of a system using the Bloch-Redfield master equation,; given an input Hamiltonian, Hermitian bath-coupling terms and their associated; spectrum functions, as well as possible Lindblad collapse operators. For time-independent systems, the Hamiltonian must be given as a Qobj,; whereas the bath-coupling terms (a_ops), must be written as a nested list; of operator - spectrum function pairs, where the frequency is specified by; the `w` variable. *Example*. a_ops = [[a+a.dag(),lambda w: 0.2*(w>=0)]]. For time-dependent systems, the Hamiltonian, a_ops, and Lindblad collapse; operators (c_ops), can be specified in the QuTiP string-based time-dependent; format. For the a_op spectra, the frequency variable must be `w`, and the; string cannot contain any other variables other than the possibility of having; a time-dependence through the time variable `t`:. *Example*. a_ops = [[a+a.dag(), '0.2*exp(-t)*(w>=0)']]. It is also possible to use Cubic_Spline objects for time-dependence. In; the case of a_ops, Cubic_Splines must be passed as a tuple:. *Example*. a_ops = [ [a+a.dag(), ( f(w), g(t)] ]. where f(w) and g(t) are strings or Cubic_spline objects for the bath; spectrum and time-dependence, respectively. Finally, if one has bath-couplimg terms of the form; H = f(t)*a + conj[f(t)]*a.dag(), then the correct input format is. *Example*. a_ops = [ [(a,a.dag()), (f(w), g1(t), g2(t))],... ]. where f(w) is the spectrum of the operators while g1(t) and g2(t); are the time-dependence of the operators `a` and `a.dag()`, respectively. Parameters; ----------; H : Qobj / list; System Hamiltonian given as a Qobj or; nested list in string-based format. psi0: Qobj; Initial density matrix or state vector (ket). tlist : array_like; List of times for evaluating",MatchSource.WIKI,docs/4.7/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html:2507,Modifiability,variab,variable,2507,"docs]def brmesolve(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[],; args={}, use_secular=True, sec_cutoff = 0.1,; tol=qset.atol,; spectra_cb=None, options=None,; progress_bar=None, _safe_mode=True, verbose=False):; """"""; Solves for the dynamics of a system using the Bloch-Redfield master equation,; given an input Hamiltonian, Hermitian bath-coupling terms and their associated; spectrum functions, as well as possible Lindblad collapse operators. For time-independent systems, the Hamiltonian must be given as a Qobj,; whereas the bath-coupling terms (a_ops), must be written as a nested list; of operator - spectrum function pairs, where the frequency is specified by; the `w` variable. *Example*. a_ops = [[a+a.dag(),lambda w: 0.2*(w>=0)]]. For time-dependent systems, the Hamiltonian, a_ops, and Lindblad collapse; operators (c_ops), can be specified in the QuTiP string-based time-dependent; format. For the a_op spectra, the frequency variable must be `w`, and the; string cannot contain any other variables other than the possibility of having; a time-dependence through the time variable `t`:. *Example*. a_ops = [[a+a.dag(), '0.2*exp(-t)*(w>=0)']]. It is also possible to use Cubic_Spline objects for time-dependence. In; the case of a_ops, Cubic_Splines must be passed as a tuple:. *Example*. a_ops = [ [a+a.dag(), ( f(w), g(t)] ]. where f(w) and g(t) are strings or Cubic_spline objects for the bath; spectrum and time-dependence, respectively. Finally, if one has bath-couplimg terms of the form; H = f(t)*a + conj[f(t)]*a.dag(), then the correct input format is. *Example*. a_ops = [ [(a,a.dag()), (f(w), g1(t), g2(t))],... ]. where f(w) is the spectrum of the operators while g1(t) and g2(t); are the time-dependence of the operators `a` and `a.dag()`, respectively. Parameters; ----------; H : Qobj / list; System Hamiltonian given as a Qobj or; nested list in string-based format. psi0: Qobj; Initial density matrix or state vector (ket). tlist : array_like; List of times for evaluating",MatchSource.WIKI,docs/4.7/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html:3889,Modifiability,coupling,coupling,3889,"e, respectively. Finally, if one has bath-couplimg terms of the form; H = f(t)*a + conj[f(t)]*a.dag(), then the correct input format is. *Example*. a_ops = [ [(a,a.dag()), (f(w), g1(t), g2(t))],... ]. where f(w) is the spectrum of the operators while g1(t) and g2(t); are the time-dependence of the operators `a` and `a.dag()`, respectively. Parameters; ----------; H : Qobj / list; System Hamiltonian given as a Qobj or; nested list in string-based format. psi0: Qobj; Initial density matrix or state vector (ket). tlist : array_like; List of times for evaluating evolution. a_ops : list; Nested list of Hermitian system operators that couple to; the bath degrees of freedom, along with their associated; spectra. e_ops : list; List of operators for which to evaluate expectation values. c_ops : list; List of system collapse operators, or nested list in; string-based format. args : dict; Placeholder for future implementation, kept for API consistency. use_secular : bool {True}; Use secular approximation when evaluating bath-coupling terms. sec_cutoff : float {0.1}; Cutoff for secular approximation. tol : float {qutip.setttings.atol}; Tolerance used for removing small values after; basis transformation. spectra_cb : list; DEPRECIATED. Do not use. options : :class:`qutip.solver.Options`; Options for the solver. progress_bar : BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. Returns; -------; result: :class:`qutip.solver.Result`. An instance of the class :class:`qutip.solver.Result`, which contains; either an array of expectation values, for operators given in e_ops,; or a list of states for the times specified by `tlist`.; """"""; _prep_time = time.time(); #This allows for passing a list of time-independent Qobj; #as allowed by mesolve; if isinstance(H, list):; if np.all([isinstance(h,Qobj) for h in H]):; H = sum(H). if isinstance(c_ops, Qobj):; c_ops = [c_ops]. if isinstance(e_ops, Qobj):; e_ops = [e_ops]. ",MatchSource.WIKI,docs/4.7/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html:5550,Modifiability,config,config,5550,"imes specified by `tlist`.; """"""; _prep_time = time.time(); #This allows for passing a list of time-independent Qobj; #as allowed by mesolve; if isinstance(H, list):; if np.all([isinstance(h,Qobj) for h in H]):; H = sum(H). if isinstance(c_ops, Qobj):; c_ops = [c_ops]. if isinstance(e_ops, Qobj):; e_ops = [e_ops]. if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None. if not (spectra_cb is None):; warnings.warn(""The use of spectra_cb is depreciated."", DeprecationWarning); _a_ops = []; for kk, a in enumerate(a_ops):; _a_ops.append([a,spectra_cb[kk]]); a_ops = _a_ops. if _safe_mode:; _solver_safety_check(H, psi0, a_ops+c_ops, e_ops, args). # check for type (if any) of time-dependent inputs; _, n_func, n_str = _td_format_check(H, a_ops+c_ops). if progress_bar is None:; progress_bar = BaseProgressBar(); elif progress_bar is True:; progress_bar = TextProgressBar(). if options is None:; options = Options(). if (not options.rhs_reuse) or (not config.tdfunc):; # reset config collapse and time-dependence flags to default values; config.reset(). #check if should use OPENMP; check_use_openmp(options). if n_str == 0:. R, ekets = bloch_redfield_tensor(H, a_ops, spectra_cb=None, c_ops=c_ops,; use_secular=use_secular, sec_cutoff=sec_cutoff). output = Result(); output.solver = ""brmesolve""; output.times = tlist. results = bloch_redfield_solve(R, ekets, psi0, tlist, e_ops, options,; progress_bar=progress_bar). if e_ops:; output.expect = results; else:; output.states = results. return output. elif n_str != 0 and n_func == 0:; output = _td_brmesolve(H, psi0, tlist, a_ops=a_ops, e_ops=e_ops,; c_ops=c_ops, args=args, use_secular=use_secular,; sec_cutoff=sec_cutoff,; tol=tol, options=options,; progress_bar=progress_bar,; _safe_mode=_safe_mode, verbose=verbose,; _prep_time=_prep_time). return output. else:; raise Exception('Cannot mix func and str formats.'). # --------------------------------------------------------------------------",MatchSource.WIKI,docs/4.7/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html:5575,Modifiability,config,config,5575,"); #This allows for passing a list of time-independent Qobj; #as allowed by mesolve; if isinstance(H, list):; if np.all([isinstance(h,Qobj) for h in H]):; H = sum(H). if isinstance(c_ops, Qobj):; c_ops = [c_ops]. if isinstance(e_ops, Qobj):; e_ops = [e_ops]. if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None. if not (spectra_cb is None):; warnings.warn(""The use of spectra_cb is depreciated."", DeprecationWarning); _a_ops = []; for kk, a in enumerate(a_ops):; _a_ops.append([a,spectra_cb[kk]]); a_ops = _a_ops. if _safe_mode:; _solver_safety_check(H, psi0, a_ops+c_ops, e_ops, args). # check for type (if any) of time-dependent inputs; _, n_func, n_str = _td_format_check(H, a_ops+c_ops). if progress_bar is None:; progress_bar = BaseProgressBar(); elif progress_bar is True:; progress_bar = TextProgressBar(). if options is None:; options = Options(). if (not options.rhs_reuse) or (not config.tdfunc):; # reset config collapse and time-dependence flags to default values; config.reset(). #check if should use OPENMP; check_use_openmp(options). if n_str == 0:. R, ekets = bloch_redfield_tensor(H, a_ops, spectra_cb=None, c_ops=c_ops,; use_secular=use_secular, sec_cutoff=sec_cutoff). output = Result(); output.solver = ""brmesolve""; output.times = tlist. results = bloch_redfield_solve(R, ekets, psi0, tlist, e_ops, options,; progress_bar=progress_bar). if e_ops:; output.expect = results; else:; output.states = results. return output. elif n_str != 0 and n_func == 0:; output = _td_brmesolve(H, psi0, tlist, a_ops=a_ops, e_ops=e_ops,; c_ops=c_ops, args=args, use_secular=use_secular,; sec_cutoff=sec_cutoff,; tol=tol, options=options,; progress_bar=progress_bar,; _safe_mode=_safe_mode, verbose=verbose,; _prep_time=_prep_time). return output. else:; raise Exception('Cannot mix func and str formats.'). # -----------------------------------------------------------------------------; # Evolution of the Bloch-Redfield master equation g",MatchSource.WIKI,docs/4.7/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html:5636,Modifiability,config,config,5636,"); #This allows for passing a list of time-independent Qobj; #as allowed by mesolve; if isinstance(H, list):; if np.all([isinstance(h,Qobj) for h in H]):; H = sum(H). if isinstance(c_ops, Qobj):; c_ops = [c_ops]. if isinstance(e_ops, Qobj):; e_ops = [e_ops]. if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None. if not (spectra_cb is None):; warnings.warn(""The use of spectra_cb is depreciated."", DeprecationWarning); _a_ops = []; for kk, a in enumerate(a_ops):; _a_ops.append([a,spectra_cb[kk]]); a_ops = _a_ops. if _safe_mode:; _solver_safety_check(H, psi0, a_ops+c_ops, e_ops, args). # check for type (if any) of time-dependent inputs; _, n_func, n_str = _td_format_check(H, a_ops+c_ops). if progress_bar is None:; progress_bar = BaseProgressBar(); elif progress_bar is True:; progress_bar = TextProgressBar(). if options is None:; options = Options(). if (not options.rhs_reuse) or (not config.tdfunc):; # reset config collapse and time-dependence flags to default values; config.reset(). #check if should use OPENMP; check_use_openmp(options). if n_str == 0:. R, ekets = bloch_redfield_tensor(H, a_ops, spectra_cb=None, c_ops=c_ops,; use_secular=use_secular, sec_cutoff=sec_cutoff). output = Result(); output.solver = ""brmesolve""; output.times = tlist. results = bloch_redfield_solve(R, ekets, psi0, tlist, e_ops, options,; progress_bar=progress_bar). if e_ops:; output.expect = results; else:; output.states = results. return output. elif n_str != 0 and n_func == 0:; output = _td_brmesolve(H, psi0, tlist, a_ops=a_ops, e_ops=e_ops,; c_ops=c_ops, args=args, use_secular=use_secular,; sec_cutoff=sec_cutoff,; tol=tol, options=options,; progress_bar=progress_bar,; _safe_mode=_safe_mode, verbose=verbose,; _prep_time=_prep_time). return output. else:; raise Exception('Cannot mix func and str formats.'). # -----------------------------------------------------------------------------; # Evolution of the Bloch-Redfield master equation g",MatchSource.WIKI,docs/4.7/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html:11277,Modifiability,coupling,coupling,11277,"terms.append(h.full('f')); H_td_terms.append('1'); elif isinstance(h, list):; H_terms.append(h[0].full('f')); if isinstance(h[1], Cubic_Spline):; H_obj.append(h[1].coeffs); spline_count[0] += 1; H_td_terms.append(h[1]); else:; raise Exception('Invalid Hamiltonian specification.'). for kk, c in enumerate(c_ops):; if isinstance(c, Qobj):; C_terms.append(c.full('f')); C_td_terms.append('1'); elif isinstance(c, list):; C_terms.append(c[0].full('f')); if isinstance(c[1], Cubic_Spline):; CA_obj.append(c[1].coeffs); spline_count[0] += 1; C_td_terms.append(c[1]); else:; raise Exception('Invalid collapse operator specification.'). coupled_offset = 0; for kk, a in enumerate(a_ops):; if isinstance(a, list):; if isinstance(a[0], Qobj):; A_terms.append(a[0].full('f')); A_td_terms.append(a[1]); if isinstance(a[1], tuple):; if not len(a[1])==2:; raise Exception('Tuple must be len=2.'); if isinstance(a[1][0],Cubic_Spline):; spline_count[1] += 1; if isinstance(a[1][1],Cubic_Spline):; spline_count[1] += 1; elif isinstance(a[0], tuple):; if not isinstance(a[1], tuple):; raise Exception('Invalid bath-coupling specification.'); if (len(a[0])+1) != len(a[1]):; raise Exception('BR a_ops tuple lengths not compatible.'). coupled_ops.append(kk+coupled_offset); coupled_lengths.append(len(a[0])); coupled_spectra.append(a[1][0]); coupled_offset += len(a[0])-1; if isinstance(a[1][0],Cubic_Spline):; spline_count[1] += 1. for nn, _a in enumerate(a[0]):; A_terms.append(_a.full('f')); A_td_terms.append(a[1][nn+1]); if isinstance(a[1][nn+1],Cubic_Spline):; CA_obj.append(a[1][nn+1].coeffs); spline_count[1] += 1. else:; raise Exception('Invalid bath-coupling specification.'). string_list = []; for kk,_ in enumerate(H_td_terms):; string_list.append(""H_terms[{0}]"".format(kk)); for kk,_ in enumerate(H_obj):; string_list.append(""H_obj[{0}]"".format(kk)); for kk,_ in enumerate(C_td_terms):; string_list.append(""C_terms[{0}]"".format(kk)); for kk,_ in enumerate(CA_obj):; string_list.append(""CA_obj[{0}]"".format(k",MatchSource.WIKI,docs/4.7/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html:11820,Modifiability,coupling,coupling,11820,"pled_offset = 0; for kk, a in enumerate(a_ops):; if isinstance(a, list):; if isinstance(a[0], Qobj):; A_terms.append(a[0].full('f')); A_td_terms.append(a[1]); if isinstance(a[1], tuple):; if not len(a[1])==2:; raise Exception('Tuple must be len=2.'); if isinstance(a[1][0],Cubic_Spline):; spline_count[1] += 1; if isinstance(a[1][1],Cubic_Spline):; spline_count[1] += 1; elif isinstance(a[0], tuple):; if not isinstance(a[1], tuple):; raise Exception('Invalid bath-coupling specification.'); if (len(a[0])+1) != len(a[1]):; raise Exception('BR a_ops tuple lengths not compatible.'). coupled_ops.append(kk+coupled_offset); coupled_lengths.append(len(a[0])); coupled_spectra.append(a[1][0]); coupled_offset += len(a[0])-1; if isinstance(a[1][0],Cubic_Spline):; spline_count[1] += 1. for nn, _a in enumerate(a[0]):; A_terms.append(_a.full('f')); A_td_terms.append(a[1][nn+1]); if isinstance(a[1][nn+1],Cubic_Spline):; CA_obj.append(a[1][nn+1].coeffs); spline_count[1] += 1. else:; raise Exception('Invalid bath-coupling specification.'). string_list = []; for kk,_ in enumerate(H_td_terms):; string_list.append(""H_terms[{0}]"".format(kk)); for kk,_ in enumerate(H_obj):; string_list.append(""H_obj[{0}]"".format(kk)); for kk,_ in enumerate(C_td_terms):; string_list.append(""C_terms[{0}]"".format(kk)); for kk,_ in enumerate(CA_obj):; string_list.append(""CA_obj[{0}]"".format(kk)); for kk,_ in enumerate(A_td_terms):; string_list.append(""A_terms[{0}]"".format(kk)); #Add nrows to parameters; string_list.append('nrows'); for name, value in args.items():; if isinstance(value, np.ndarray):; raise TypeError('NumPy arrays not valid args for BR solver.'); else:; string_list.append(str(value)); parameter_string = "","".join(string_list). if verbose:; print('BR prep time:', time.time()-_prep_time); #; # generate and compile new cython code if necessary; #; if not options.rhs_reuse or config.tdfunc is None:; if options.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:;",MatchSource.WIKI,docs/4.7/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html:12684,Modifiability,config,config,12684,"1]); if isinstance(a[1][nn+1],Cubic_Spline):; CA_obj.append(a[1][nn+1].coeffs); spline_count[1] += 1. else:; raise Exception('Invalid bath-coupling specification.'). string_list = []; for kk,_ in enumerate(H_td_terms):; string_list.append(""H_terms[{0}]"".format(kk)); for kk,_ in enumerate(H_obj):; string_list.append(""H_obj[{0}]"".format(kk)); for kk,_ in enumerate(C_td_terms):; string_list.append(""C_terms[{0}]"".format(kk)); for kk,_ in enumerate(CA_obj):; string_list.append(""CA_obj[{0}]"".format(kk)); for kk,_ in enumerate(A_td_terms):; string_list.append(""A_terms[{0}]"".format(kk)); #Add nrows to parameters; string_list.append('nrows'); for name, value in args.items():; if isinstance(value, np.ndarray):; raise TypeError('NumPy arrays not valid args for BR solver.'); else:; string_list.append(str(value)); parameter_string = "","".join(string_list). if verbose:; print('BR prep time:', time.time()-_prep_time); #; # generate and compile new cython code if necessary; #; if not options.rhs_reuse or config.tdfunc is None:; if options.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; if verbose:; _st = time.time(); cgen = BR_Codegen(h_terms=len(H_terms),; h_td_terms=H_td_terms, h_obj=H_obj,; c_terms=len(C_terms),; c_td_terms=C_td_terms, c_obj=CA_obj,; a_terms=len(A_terms), a_td_terms=A_td_terms,; spline_count=spline_count,; coupled_ops = coupled_ops,; coupled_lengths = coupled_lengths,; coupled_spectra = coupled_spectra,; config=config, sparse=False,; use_secular = use_secular,; sec_cutoff = sec_cutoff,; args=args,; use_openmp=options.use_openmp,; omp_thresh=qset.openmp_thresh if qset.has_openmp else None,; omp_threads=options.num_cpus,; atol=tol). cgen.generate(config.tdname + "".pyx""); code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs; if verbose:; print('BR compile time:', time.time()-_st); initial_vector = ma",MatchSource.WIKI,docs/4.7/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html:12742,Modifiability,config,config,12742,"append(a[1][nn+1].coeffs); spline_count[1] += 1. else:; raise Exception('Invalid bath-coupling specification.'). string_list = []; for kk,_ in enumerate(H_td_terms):; string_list.append(""H_terms[{0}]"".format(kk)); for kk,_ in enumerate(H_obj):; string_list.append(""H_obj[{0}]"".format(kk)); for kk,_ in enumerate(C_td_terms):; string_list.append(""C_terms[{0}]"".format(kk)); for kk,_ in enumerate(CA_obj):; string_list.append(""CA_obj[{0}]"".format(kk)); for kk,_ in enumerate(A_td_terms):; string_list.append(""A_terms[{0}]"".format(kk)); #Add nrows to parameters; string_list.append('nrows'); for name, value in args.items():; if isinstance(value, np.ndarray):; raise TypeError('NumPy arrays not valid args for BR solver.'); else:; string_list.append(str(value)); parameter_string = "","".join(string_list). if verbose:; print('BR prep time:', time.time()-_prep_time); #; # generate and compile new cython code if necessary; #; if not options.rhs_reuse or config.tdfunc is None:; if options.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; if verbose:; _st = time.time(); cgen = BR_Codegen(h_terms=len(H_terms),; h_td_terms=H_td_terms, h_obj=H_obj,; c_terms=len(C_terms),; c_td_terms=C_td_terms, c_obj=CA_obj,; a_terms=len(A_terms), a_td_terms=A_td_terms,; spline_count=spline_count,; coupled_ops = coupled_ops,; coupled_lengths = coupled_lengths,; coupled_spectra = coupled_spectra,; config=config, sparse=False,; use_secular = use_secular,; sec_cutoff = sec_cutoff,; args=args,; use_openmp=options.use_openmp,; omp_thresh=qset.openmp_thresh if qset.has_openmp else None,; omp_threads=options.num_cpus,; atol=tol). cgen.generate(config.tdname + "".pyx""); code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs; if verbose:; print('BR compile time:', time.time()-_st); initial_vector = mat2vec(rho0.full()).ravel(). _ode = scipy.integrate.od",MatchSource.WIKI,docs/4.7/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html:12789,Modifiability,config,config,12789,"lse:; raise Exception('Invalid bath-coupling specification.'). string_list = []; for kk,_ in enumerate(H_td_terms):; string_list.append(""H_terms[{0}]"".format(kk)); for kk,_ in enumerate(H_obj):; string_list.append(""H_obj[{0}]"".format(kk)); for kk,_ in enumerate(C_td_terms):; string_list.append(""C_terms[{0}]"".format(kk)); for kk,_ in enumerate(CA_obj):; string_list.append(""CA_obj[{0}]"".format(kk)); for kk,_ in enumerate(A_td_terms):; string_list.append(""A_terms[{0}]"".format(kk)); #Add nrows to parameters; string_list.append('nrows'); for name, value in args.items():; if isinstance(value, np.ndarray):; raise TypeError('NumPy arrays not valid args for BR solver.'); else:; string_list.append(str(value)); parameter_string = "","".join(string_list). if verbose:; print('BR prep time:', time.time()-_prep_time); #; # generate and compile new cython code if necessary; #; if not options.rhs_reuse or config.tdfunc is None:; if options.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; if verbose:; _st = time.time(); cgen = BR_Codegen(h_terms=len(H_terms),; h_td_terms=H_td_terms, h_obj=H_obj,; c_terms=len(C_terms),; c_td_terms=C_td_terms, c_obj=CA_obj,; a_terms=len(A_terms), a_td_terms=A_td_terms,; spline_count=spline_count,; coupled_ops = coupled_ops,; coupled_lengths = coupled_lengths,; coupled_spectra = coupled_spectra,; config=config, sparse=False,; use_secular = use_secular,; sec_cutoff = sec_cutoff,; args=args,; use_openmp=options.use_openmp,; omp_thresh=qset.openmp_thresh if qset.has_openmp else None,; omp_threads=options.num_cpus,; atol=tol). cgen.generate(config.tdname + "".pyx""); code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs; if verbose:; print('BR compile time:', time.time()-_st); initial_vector = mat2vec(rho0.full()).ravel(). _ode = scipy.integrate.ode(config.tdfunc); code = compile('_ode.set_f_params",MatchSource.WIKI,docs/4.7/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html:12814,Modifiability,config,config,12814,"nvalid bath-coupling specification.'). string_list = []; for kk,_ in enumerate(H_td_terms):; string_list.append(""H_terms[{0}]"".format(kk)); for kk,_ in enumerate(H_obj):; string_list.append(""H_obj[{0}]"".format(kk)); for kk,_ in enumerate(C_td_terms):; string_list.append(""C_terms[{0}]"".format(kk)); for kk,_ in enumerate(CA_obj):; string_list.append(""CA_obj[{0}]"".format(kk)); for kk,_ in enumerate(A_td_terms):; string_list.append(""A_terms[{0}]"".format(kk)); #Add nrows to parameters; string_list.append('nrows'); for name, value in args.items():; if isinstance(value, np.ndarray):; raise TypeError('NumPy arrays not valid args for BR solver.'); else:; string_list.append(str(value)); parameter_string = "","".join(string_list). if verbose:; print('BR prep time:', time.time()-_prep_time); #; # generate and compile new cython code if necessary; #; if not options.rhs_reuse or config.tdfunc is None:; if options.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; if verbose:; _st = time.time(); cgen = BR_Codegen(h_terms=len(H_terms),; h_td_terms=H_td_terms, h_obj=H_obj,; c_terms=len(C_terms),; c_td_terms=C_td_terms, c_obj=CA_obj,; a_terms=len(A_terms), a_td_terms=A_td_terms,; spline_count=spline_count,; coupled_ops = coupled_ops,; coupled_lengths = coupled_lengths,; coupled_spectra = coupled_spectra,; config=config, sparse=False,; use_secular = use_secular,; sec_cutoff = sec_cutoff,; args=args,; use_openmp=options.use_openmp,; omp_thresh=qset.openmp_thresh if qset.has_openmp else None,; omp_threads=options.num_cpus,; atol=tol). cgen.generate(config.tdname + "".pyx""); code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs; if verbose:; print('BR compile time:', time.time()-_st); initial_vector = mat2vec(rho0.full()).ravel(). _ode = scipy.integrate.ode(config.tdfunc); code = compile('_ode.set_f_params(' + parameter_string + ",MatchSource.WIKI,docs/4.7/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html:13193,Modifiability,config,config,13193,"}]"".format(kk)); for kk,_ in enumerate(CA_obj):; string_list.append(""CA_obj[{0}]"".format(kk)); for kk,_ in enumerate(A_td_terms):; string_list.append(""A_terms[{0}]"".format(kk)); #Add nrows to parameters; string_list.append('nrows'); for name, value in args.items():; if isinstance(value, np.ndarray):; raise TypeError('NumPy arrays not valid args for BR solver.'); else:; string_list.append(str(value)); parameter_string = "","".join(string_list). if verbose:; print('BR prep time:', time.time()-_prep_time); #; # generate and compile new cython code if necessary; #; if not options.rhs_reuse or config.tdfunc is None:; if options.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; if verbose:; _st = time.time(); cgen = BR_Codegen(h_terms=len(H_terms),; h_td_terms=H_td_terms, h_obj=H_obj,; c_terms=len(C_terms),; c_td_terms=C_td_terms, c_obj=CA_obj,; a_terms=len(A_terms), a_td_terms=A_td_terms,; spline_count=spline_count,; coupled_ops = coupled_ops,; coupled_lengths = coupled_lengths,; coupled_spectra = coupled_spectra,; config=config, sparse=False,; use_secular = use_secular,; sec_cutoff = sec_cutoff,; args=args,; use_openmp=options.use_openmp,; omp_thresh=qset.openmp_thresh if qset.has_openmp else None,; omp_threads=options.num_cpus,; atol=tol). cgen.generate(config.tdname + "".pyx""); code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs; if verbose:; print('BR compile time:', time.time()-_st); initial_vector = mat2vec(rho0.full()).ravel(). _ode = scipy.integrate.ode(config.tdfunc); code = compile('_ode.set_f_params(' + parameter_string + ')',; '<string>', 'exec'); _ode.set_integrator('zvode', method=options.method,; order=options.order, atol=options.atol,; rtol=options.rtol, nsteps=options.nsteps,; first_step=options.first_step,; min_step=options.min_step,; max_step=options.max_step); _ode.set_initial_value(initia",MatchSource.WIKI,docs/4.7/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html:13200,Modifiability,config,config,13200,"}]"".format(kk)); for kk,_ in enumerate(CA_obj):; string_list.append(""CA_obj[{0}]"".format(kk)); for kk,_ in enumerate(A_td_terms):; string_list.append(""A_terms[{0}]"".format(kk)); #Add nrows to parameters; string_list.append('nrows'); for name, value in args.items():; if isinstance(value, np.ndarray):; raise TypeError('NumPy arrays not valid args for BR solver.'); else:; string_list.append(str(value)); parameter_string = "","".join(string_list). if verbose:; print('BR prep time:', time.time()-_prep_time); #; # generate and compile new cython code if necessary; #; if not options.rhs_reuse or config.tdfunc is None:; if options.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; if verbose:; _st = time.time(); cgen = BR_Codegen(h_terms=len(H_terms),; h_td_terms=H_td_terms, h_obj=H_obj,; c_terms=len(C_terms),; c_td_terms=C_td_terms, c_obj=CA_obj,; a_terms=len(A_terms), a_td_terms=A_td_terms,; spline_count=spline_count,; coupled_ops = coupled_ops,; coupled_lengths = coupled_lengths,; coupled_spectra = coupled_spectra,; config=config, sparse=False,; use_secular = use_secular,; sec_cutoff = sec_cutoff,; args=args,; use_openmp=options.use_openmp,; omp_thresh=qset.openmp_thresh if qset.has_openmp else None,; omp_threads=options.num_cpus,; atol=tol). cgen.generate(config.tdname + "".pyx""); code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs; if verbose:; print('BR compile time:', time.time()-_st); initial_vector = mat2vec(rho0.full()).ravel(). _ode = scipy.integrate.ode(config.tdfunc); code = compile('_ode.set_f_params(' + parameter_string + ')',; '<string>', 'exec'); _ode.set_integrator('zvode', method=options.method,; order=options.order, atol=options.atol,; rtol=options.rtol, nsteps=options.nsteps,; first_step=options.first_step,; min_step=options.min_step,; max_step=options.max_step); _ode.set_initial_value(initia",MatchSource.WIKI,docs/4.7/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html:13438,Modifiability,config,config,13438,"for BR solver.'); else:; string_list.append(str(value)); parameter_string = "","".join(string_list). if verbose:; print('BR prep time:', time.time()-_prep_time); #; # generate and compile new cython code if necessary; #; if not options.rhs_reuse or config.tdfunc is None:; if options.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; if verbose:; _st = time.time(); cgen = BR_Codegen(h_terms=len(H_terms),; h_td_terms=H_td_terms, h_obj=H_obj,; c_terms=len(C_terms),; c_td_terms=C_td_terms, c_obj=CA_obj,; a_terms=len(A_terms), a_td_terms=A_td_terms,; spline_count=spline_count,; coupled_ops = coupled_ops,; coupled_lengths = coupled_lengths,; coupled_spectra = coupled_spectra,; config=config, sparse=False,; use_secular = use_secular,; sec_cutoff = sec_cutoff,; args=args,; use_openmp=options.use_openmp,; omp_thresh=qset.openmp_thresh if qset.has_openmp else None,; omp_threads=options.num_cpus,; atol=tol). cgen.generate(config.tdname + "".pyx""); code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs; if verbose:; print('BR compile time:', time.time()-_st); initial_vector = mat2vec(rho0.full()).ravel(). _ode = scipy.integrate.ode(config.tdfunc); code = compile('_ode.set_f_params(' + parameter_string + ')',; '<string>', 'exec'); _ode.set_integrator('zvode', method=options.method,; order=options.order, atol=options.atol,; rtol=options.rtol, nsteps=options.nsteps,; first_step=options.first_step,; min_step=options.min_step,; max_step=options.max_step); _ode.set_initial_value(initial_vector, tlist[0]); exec(code, locals()). #; # prepare output array; #; n_tsteps = len(tlist); e_sops_data = []. output = Result(); output.solver = ""brmesolve""; output.times = tlist. if options.store_states:; output.states = []. if isinstance(e_ops, types.FunctionType):; n_expt_op = 0; expt_callback = True. elif isinstance(e_ops, list):; n_expt",MatchSource.WIKI,docs/4.7/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html:13488,Modifiability,config,config,13488,"ppend(str(value)); parameter_string = "","".join(string_list). if verbose:; print('BR prep time:', time.time()-_prep_time); #; # generate and compile new cython code if necessary; #; if not options.rhs_reuse or config.tdfunc is None:; if options.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; if verbose:; _st = time.time(); cgen = BR_Codegen(h_terms=len(H_terms),; h_td_terms=H_td_terms, h_obj=H_obj,; c_terms=len(C_terms),; c_td_terms=C_td_terms, c_obj=CA_obj,; a_terms=len(A_terms), a_td_terms=A_td_terms,; spline_count=spline_count,; coupled_ops = coupled_ops,; coupled_lengths = coupled_lengths,; coupled_spectra = coupled_spectra,; config=config, sparse=False,; use_secular = use_secular,; sec_cutoff = sec_cutoff,; args=args,; use_openmp=options.use_openmp,; omp_thresh=qset.openmp_thresh if qset.has_openmp else None,; omp_threads=options.num_cpus,; atol=tol). cgen.generate(config.tdname + "".pyx""); code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs; if verbose:; print('BR compile time:', time.time()-_st); initial_vector = mat2vec(rho0.full()).ravel(). _ode = scipy.integrate.ode(config.tdfunc); code = compile('_ode.set_f_params(' + parameter_string + ')',; '<string>', 'exec'); _ode.set_integrator('zvode', method=options.method,; order=options.order, atol=options.atol,; rtol=options.rtol, nsteps=options.nsteps,; first_step=options.first_step,; min_step=options.min_step,; max_step=options.max_step); _ode.set_initial_value(initial_vector, tlist[0]); exec(code, locals()). #; # prepare output array; #; n_tsteps = len(tlist); e_sops_data = []. output = Result(); output.solver = ""brmesolve""; output.times = tlist. if options.store_states:; output.states = []. if isinstance(e_ops, types.FunctionType):; n_expt_op = 0; expt_callback = True. elif isinstance(e_ops, list):; n_expt_op = len(e_ops); expt_callback = False",MatchSource.WIKI,docs/4.7/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html:13574,Modifiability,config,config,13574," verbose:; print('BR prep time:', time.time()-_prep_time); #; # generate and compile new cython code if necessary; #; if not options.rhs_reuse or config.tdfunc is None:; if options.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; if verbose:; _st = time.time(); cgen = BR_Codegen(h_terms=len(H_terms),; h_td_terms=H_td_terms, h_obj=H_obj,; c_terms=len(C_terms),; c_td_terms=C_td_terms, c_obj=CA_obj,; a_terms=len(A_terms), a_td_terms=A_td_terms,; spline_count=spline_count,; coupled_ops = coupled_ops,; coupled_lengths = coupled_lengths,; coupled_spectra = coupled_spectra,; config=config, sparse=False,; use_secular = use_secular,; sec_cutoff = sec_cutoff,; args=args,; use_openmp=options.use_openmp,; omp_thresh=qset.openmp_thresh if qset.has_openmp else None,; omp_threads=options.num_cpus,; atol=tol). cgen.generate(config.tdname + "".pyx""); code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs; if verbose:; print('BR compile time:', time.time()-_st); initial_vector = mat2vec(rho0.full()).ravel(). _ode = scipy.integrate.ode(config.tdfunc); code = compile('_ode.set_f_params(' + parameter_string + ')',; '<string>', 'exec'); _ode.set_integrator('zvode', method=options.method,; order=options.order, atol=options.atol,; rtol=options.rtol, nsteps=options.nsteps,; first_step=options.first_step,; min_step=options.min_step,; max_step=options.max_step); _ode.set_initial_value(initial_vector, tlist[0]); exec(code, locals()). #; # prepare output array; #; n_tsteps = len(tlist); e_sops_data = []. output = Result(); output.solver = ""brmesolve""; output.times = tlist. if options.store_states:; output.states = []. if isinstance(e_ops, types.FunctionType):; n_expt_op = 0; expt_callback = True. elif isinstance(e_ops, list):; n_expt_op = len(e_ops); expt_callback = False. if n_expt_op == 0:; # fall back on storing states; output.st",MatchSource.WIKI,docs/4.7/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html:13736,Modifiability,config,config,13736,"ne:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; if verbose:; _st = time.time(); cgen = BR_Codegen(h_terms=len(H_terms),; h_td_terms=H_td_terms, h_obj=H_obj,; c_terms=len(C_terms),; c_td_terms=C_td_terms, c_obj=CA_obj,; a_terms=len(A_terms), a_td_terms=A_td_terms,; spline_count=spline_count,; coupled_ops = coupled_ops,; coupled_lengths = coupled_lengths,; coupled_spectra = coupled_spectra,; config=config, sparse=False,; use_secular = use_secular,; sec_cutoff = sec_cutoff,; args=args,; use_openmp=options.use_openmp,; omp_thresh=qset.openmp_thresh if qset.has_openmp else None,; omp_threads=options.num_cpus,; atol=tol). cgen.generate(config.tdname + "".pyx""); code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs; if verbose:; print('BR compile time:', time.time()-_st); initial_vector = mat2vec(rho0.full()).ravel(). _ode = scipy.integrate.ode(config.tdfunc); code = compile('_ode.set_f_params(' + parameter_string + ')',; '<string>', 'exec'); _ode.set_integrator('zvode', method=options.method,; order=options.order, atol=options.atol,; rtol=options.rtol, nsteps=options.nsteps,; first_step=options.first_step,; min_step=options.min_step,; max_step=options.max_step); _ode.set_initial_value(initial_vector, tlist[0]); exec(code, locals()). #; # prepare output array; #; n_tsteps = len(tlist); e_sops_data = []. output = Result(); output.solver = ""brmesolve""; output.times = tlist. if options.store_states:; output.states = []. if isinstance(e_ops, types.FunctionType):; n_expt_op = 0; expt_callback = True. elif isinstance(e_ops, list):; n_expt_op = len(e_ops); expt_callback = False. if n_expt_op == 0:; # fall back on storing states; output.states = []; options.store_states = True; else:; output.expect = []; output.num_expect = n_expt_op; for op in e_ops:; e_sops_data.append(spre(op).data); if op.isherm:; output.expect.append(np.zeros(n_ts",MatchSource.WIKI,docs/4.7/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html:15990,Modifiability,config,config,15990,"t):; n_expt_op = len(e_ops); expt_callback = False. if n_expt_op == 0:; # fall back on storing states; output.states = []; options.store_states = True; else:; output.expect = []; output.num_expect = n_expt_op; for op in e_ops:; e_sops_data.append(spre(op).data); if op.isherm:; output.expect.append(np.zeros(n_tsteps)); else:; output.expect.append(np.zeros(n_tsteps, dtype=complex)). else:; raise TypeError(""Expectation parameter must be a list or a function""). #; # start evolution; #; if type(progress_bar)==BaseProgressBar and verbose:; _run_time = time.time(). progress_bar.start(n_tsteps). rho = Qobj(rho0). dt = np.diff(tlist); for t_idx, t in enumerate(tlist):; progress_bar.update(t_idx). if not _ode.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""). if options.store_states or expt_callback:; rho.data = dense2D_to_fastcsr_fmode(vec2mat(_ode.y), rho.shape[0], rho.shape[1]). if options.store_states:; output.states.append(Qobj(rho, isherm=True)). if expt_callback:; # use callback method; e_ops(t, rho). for m in range(n_expt_op):; if output.expect[m].dtype == complex:; output.expect[m][t_idx] = expect_rho_vec(e_sops_data[m],; _ode.y, 0); else:; output.expect[m][t_idx] = expect_rho_vec(e_sops_data[m],; _ode.y, 1). if t_idx < n_tsteps - 1:; _ode.integrate(_ode.t + dt[t_idx]). progress_bar.finished(). if type(progress_bar)==BaseProgressBar and verbose:; print('BR runtime:', time.time()-_run_time). if (not options.rhs_reuse) and (config.tdname is not None):; _cython_build_cleanup(config.tdname). if options.store_final_state:; rho.data = dense2D_to_fastcsr_fmode(vec2mat(_ode.y), rho.shape[0], rho.shape[1]); output.final_state = Qobj(rho, dims=rho0.dims, isherm=True). return output. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html:16041,Modifiability,config,config,16041,"t):; n_expt_op = len(e_ops); expt_callback = False. if n_expt_op == 0:; # fall back on storing states; output.states = []; options.store_states = True; else:; output.expect = []; output.num_expect = n_expt_op; for op in e_ops:; e_sops_data.append(spre(op).data); if op.isherm:; output.expect.append(np.zeros(n_tsteps)); else:; output.expect.append(np.zeros(n_tsteps, dtype=complex)). else:; raise TypeError(""Expectation parameter must be a list or a function""). #; # start evolution; #; if type(progress_bar)==BaseProgressBar and verbose:; _run_time = time.time(). progress_bar.start(n_tsteps). rho = Qobj(rho0). dt = np.diff(tlist); for t_idx, t in enumerate(tlist):; progress_bar.update(t_idx). if not _ode.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""). if options.store_states or expt_callback:; rho.data = dense2D_to_fastcsr_fmode(vec2mat(_ode.y), rho.shape[0], rho.shape[1]). if options.store_states:; output.states.append(Qobj(rho, isherm=True)). if expt_callback:; # use callback method; e_ops(t, rho). for m in range(n_expt_op):; if output.expect[m].dtype == complex:; output.expect[m][t_idx] = expect_rho_vec(e_sops_data[m],; _ode.y, 0); else:; output.expect[m][t_idx] = expect_rho_vec(e_sops_data[m],; _ode.y, 1). if t_idx < n_tsteps - 1:; _ode.integrate(_ode.t + dt[t_idx]). progress_bar.finished(). if type(progress_bar)==BaseProgressBar and verbose:; print('BR runtime:', time.time()-_run_time). if (not options.rhs_reuse) and (config.tdname is not None):; _cython_build_cleanup(config.tdname). if options.store_final_state:; rho.data = dense2D_to_fastcsr_fmode(vec2mat(_ode.y), rho.shape[0], rho.shape[1]); output.final_state = Qobj(rho, dims=rho0.dims, isherm=True). return output. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.7/modules/qutip/continuous_variables.html:450,Deployability,continuous,continuous,450,". qutip.continuous_variables — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.continuous_variables. Source code for qutip.continuous_variables; """"""; This module contains a collection functions for calculating continuous variable; quantities from fock-basis representation of the state of multi-mode fields.; """""". __all__ = ['correlation_matrix', 'covariance_matrix',; 'correlation_matrix_field', 'correlation_matrix_quadrature',; 'wigner_covariance_matrix', 'logarithmic_negativity']. from qutip.expect import expect; import numpy as np. [docs]def correlation_matrix(basis, rho=None):; r""""""; Given a basis set of operators :math:`\{a\}_n`, calculate the correlation; matrix:. .. math::. C_{mn} = \langle a_m a_n \rangle. Parameters; ----------; basis : list; List of operators that defines the basis for the correlation matrix.; rho : Qobj; Density matrix for which to calculate the correlation matrix. If; `rho` is `None`, then a matrix of correlation matrix operators is; returned instead of expectation values of those operators. Returns; -------; corr_mat : ndarray; A 2-dimensional *array* of correlation values or operators. """"""; if rho is None:; # return array of operators; out = np.empty((len(basis), len(basis)), dtype=object); for i, op2 in enumerate(basis):; out[i, :] = [op1 * op2 for op1 in basis]; return out; else:; # return array of expectation values; return np.array([[expect(op1 * op2, rho); for op1 in basis] for op2 in basis]). [docs]def covariance_matrix(basis, rho, symmetrized=True):; r""""""; Given a basis set of operators :math:`\{a\}_n`, calculate the covariance; matrix:. .. math::. V_{mn} = \frac{1}{2}\langle a_m a_n + a_n a_m \rangle -; \langle a_m \rangle \langle a_n\rangle. or, if of the optional argument `symmetrized=False`,.",MatchSource.WIKI,docs/4.7/modules/qutip/continuous_variables.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/continuous_variables.html
https://qutip.org/docs/4.7/modules/qutip/continuous_variables.html:7641,Deployability,update,updated,7641,"lues. """"""; if R is not None:; if rho is None:; return np.array([[0.5 * np.real(R[i, j] + R[j, i]); for i in range(4)]; for j in range(4)], dtype=np.float64); else:; return np.array([[0.5 * np.real(expect(R[i, j] + R[j, i], rho)); for i in range(4)]; for j in range(4)], dtype=np.float64); elif a1 is not None and a2 is not None:; if rho is not None:; x1 = (a1 + a1.dag()) / g; p1 = -1j * (a1 - a1.dag()) / g; x2 = (a2 + a2.dag()) / g; p2 = -1j * (a2 - a2.dag()) / g; return covariance_matrix([x1, p1, x2, p2], rho); else:; raise ValueError(""Must give rho if using field operators "" +; ""(a1 and a2)""); else:; raise ValueError(""Must give either field operators (a1 and a2) "" +; ""or a precomputed correlation matrix (R)""). [docs]def logarithmic_negativity(V, g=np.sqrt(2)):; """"""; Calculates the logarithmic negativity given a symmetrized covariance; matrix, see :func:`qutip.continuous_variables.covariance_matrix`. Note that; the two-mode field state that is described by `V` must be Gaussian for this; function to applicable. Parameters; ----------. V : *2d array*; The covariance matrix. g : float; Scaling factor for `a = 0.5 * g * (x + iy)`, default `g = sqrt(2)`.; The value of `g` is related to the value of `hbar` in the commutation ; relation `[x, y] = i * hbar` via `hbar=2/g ** 2` giving the default ; value `hbar=1`. . Returns; -------. N : float ; The logarithmic negativity for the two-mode Gaussian state; that is described by the the Wigner covariance matrix V. """"""; A = 0.5 * V[0:2, 0:2] * g ** 2; B = 0.5 * V[2:4, 2:4] * g ** 2; C = 0.5 * V[0:2, 2:4] * g ** 2; sigma = np.linalg.det(A) + np.linalg.det(B) - 2 * np.linalg.det(C); nu_ = sigma / 2 - np.sqrt(sigma ** 2 - 4 * np.linalg.det(V)) / 2; if nu_ < 0.0:; return 0.0; nu = np.sqrt(nu_); lognu = -np.log(2 * nu); logneg = max(0, lognu); return logneg. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/modules/qutip/continuous_variables.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/continuous_variables.html
https://qutip.org/docs/4.7/modules/qutip/continuous_variables.html:461,Modifiability,variab,variable,461,". qutip.continuous_variables — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.continuous_variables. Source code for qutip.continuous_variables; """"""; This module contains a collection functions for calculating continuous variable; quantities from fock-basis representation of the state of multi-mode fields.; """""". __all__ = ['correlation_matrix', 'covariance_matrix',; 'correlation_matrix_field', 'correlation_matrix_quadrature',; 'wigner_covariance_matrix', 'logarithmic_negativity']. from qutip.expect import expect; import numpy as np. [docs]def correlation_matrix(basis, rho=None):; r""""""; Given a basis set of operators :math:`\{a\}_n`, calculate the correlation; matrix:. .. math::. C_{mn} = \langle a_m a_n \rangle. Parameters; ----------; basis : list; List of operators that defines the basis for the correlation matrix.; rho : Qobj; Density matrix for which to calculate the correlation matrix. If; `rho` is `None`, then a matrix of correlation matrix operators is; returned instead of expectation values of those operators. Returns; -------; corr_mat : ndarray; A 2-dimensional *array* of correlation values or operators. """"""; if rho is None:; # return array of operators; out = np.empty((len(basis), len(basis)), dtype=object); for i, op2 in enumerate(basis):; out[i, :] = [op1 * op2 for op1 in basis]; return out; else:; # return array of expectation values; return np.array([[expect(op1 * op2, rho); for op1 in basis] for op2 in basis]). [docs]def covariance_matrix(basis, rho, symmetrized=True):; r""""""; Given a basis set of operators :math:`\{a\}_n`, calculate the covariance; matrix:. .. math::. V_{mn} = \frac{1}{2}\langle a_m a_n + a_n a_m \rangle -; \langle a_m \rangle \langle a_n\rangle. or, if of the optional argument `symmetrized=False`,.",MatchSource.WIKI,docs/4.7/modules/qutip/continuous_variables.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/continuous_variables.html
https://qutip.org/docs/4.7/modules/qutip/continuous_variables.html:6534,Testability,log,logarithmic,6534,"in the commutation ; relation `[x, y] = i * hbar` via `hbar=2/g ** 2` giving the default ; value `hbar=1`. . Returns; -------; cov_mat : ndarray; A 2-dimensional array of covariance values. """"""; if R is not None:; if rho is None:; return np.array([[0.5 * np.real(R[i, j] + R[j, i]); for i in range(4)]; for j in range(4)], dtype=np.float64); else:; return np.array([[0.5 * np.real(expect(R[i, j] + R[j, i], rho)); for i in range(4)]; for j in range(4)], dtype=np.float64); elif a1 is not None and a2 is not None:; if rho is not None:; x1 = (a1 + a1.dag()) / g; p1 = -1j * (a1 - a1.dag()) / g; x2 = (a2 + a2.dag()) / g; p2 = -1j * (a2 - a2.dag()) / g; return covariance_matrix([x1, p1, x2, p2], rho); else:; raise ValueError(""Must give rho if using field operators "" +; ""(a1 and a2)""); else:; raise ValueError(""Must give either field operators (a1 and a2) "" +; ""or a precomputed correlation matrix (R)""). [docs]def logarithmic_negativity(V, g=np.sqrt(2)):; """"""; Calculates the logarithmic negativity given a symmetrized covariance; matrix, see :func:`qutip.continuous_variables.covariance_matrix`. Note that; the two-mode field state that is described by `V` must be Gaussian for this; function to applicable. Parameters; ----------. V : *2d array*; The covariance matrix. g : float; Scaling factor for `a = 0.5 * g * (x + iy)`, default `g = sqrt(2)`.; The value of `g` is related to the value of `hbar` in the commutation ; relation `[x, y] = i * hbar` via `hbar=2/g ** 2` giving the default ; value `hbar=1`. . Returns; -------. N : float ; The logarithmic negativity for the two-mode Gaussian state; that is described by the the Wigner covariance matrix V. """"""; A = 0.5 * V[0:2, 0:2] * g ** 2; B = 0.5 * V[2:4, 2:4] * g ** 2; C = 0.5 * V[0:2, 2:4] * g ** 2; sigma = np.linalg.det(A) + np.linalg.det(B) - 2 * np.linalg.det(C); nu_ = sigma / 2 - np.sqrt(sigma ** 2 - 4 * np.linalg.det(V)) / 2; if nu_ < 0.0:; return 0.0; nu = np.sqrt(nu_); lognu = -np.log(2 * nu); logneg = max(0, lognu); return logne",MatchSource.WIKI,docs/4.7/modules/qutip/continuous_variables.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/continuous_variables.html
https://qutip.org/docs/4.7/modules/qutip/continuous_variables.html:7104,Testability,log,logarithmic,7104,"lues. """"""; if R is not None:; if rho is None:; return np.array([[0.5 * np.real(R[i, j] + R[j, i]); for i in range(4)]; for j in range(4)], dtype=np.float64); else:; return np.array([[0.5 * np.real(expect(R[i, j] + R[j, i], rho)); for i in range(4)]; for j in range(4)], dtype=np.float64); elif a1 is not None and a2 is not None:; if rho is not None:; x1 = (a1 + a1.dag()) / g; p1 = -1j * (a1 - a1.dag()) / g; x2 = (a2 + a2.dag()) / g; p2 = -1j * (a2 - a2.dag()) / g; return covariance_matrix([x1, p1, x2, p2], rho); else:; raise ValueError(""Must give rho if using field operators "" +; ""(a1 and a2)""); else:; raise ValueError(""Must give either field operators (a1 and a2) "" +; ""or a precomputed correlation matrix (R)""). [docs]def logarithmic_negativity(V, g=np.sqrt(2)):; """"""; Calculates the logarithmic negativity given a symmetrized covariance; matrix, see :func:`qutip.continuous_variables.covariance_matrix`. Note that; the two-mode field state that is described by `V` must be Gaussian for this; function to applicable. Parameters; ----------. V : *2d array*; The covariance matrix. g : float; Scaling factor for `a = 0.5 * g * (x + iy)`, default `g = sqrt(2)`.; The value of `g` is related to the value of `hbar` in the commutation ; relation `[x, y] = i * hbar` via `hbar=2/g ** 2` giving the default ; value `hbar=1`. . Returns; -------. N : float ; The logarithmic negativity for the two-mode Gaussian state; that is described by the the Wigner covariance matrix V. """"""; A = 0.5 * V[0:2, 0:2] * g ** 2; B = 0.5 * V[2:4, 2:4] * g ** 2; C = 0.5 * V[0:2, 2:4] * g ** 2; sigma = np.linalg.det(A) + np.linalg.det(B) - 2 * np.linalg.det(C); nu_ = sigma / 2 - np.sqrt(sigma ** 2 - 4 * np.linalg.det(V)) / 2; if nu_ < 0.0:; return 0.0; nu = np.sqrt(nu_); lognu = -np.log(2 * nu); logneg = max(0, lognu); return logneg. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/modules/qutip/continuous_variables.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/continuous_variables.html
https://qutip.org/docs/4.7/modules/qutip/continuous_variables.html:7498,Testability,log,lognu,7498,"lues. """"""; if R is not None:; if rho is None:; return np.array([[0.5 * np.real(R[i, j] + R[j, i]); for i in range(4)]; for j in range(4)], dtype=np.float64); else:; return np.array([[0.5 * np.real(expect(R[i, j] + R[j, i], rho)); for i in range(4)]; for j in range(4)], dtype=np.float64); elif a1 is not None and a2 is not None:; if rho is not None:; x1 = (a1 + a1.dag()) / g; p1 = -1j * (a1 - a1.dag()) / g; x2 = (a2 + a2.dag()) / g; p2 = -1j * (a2 - a2.dag()) / g; return covariance_matrix([x1, p1, x2, p2], rho); else:; raise ValueError(""Must give rho if using field operators "" +; ""(a1 and a2)""); else:; raise ValueError(""Must give either field operators (a1 and a2) "" +; ""or a precomputed correlation matrix (R)""). [docs]def logarithmic_negativity(V, g=np.sqrt(2)):; """"""; Calculates the logarithmic negativity given a symmetrized covariance; matrix, see :func:`qutip.continuous_variables.covariance_matrix`. Note that; the two-mode field state that is described by `V` must be Gaussian for this; function to applicable. Parameters; ----------. V : *2d array*; The covariance matrix. g : float; Scaling factor for `a = 0.5 * g * (x + iy)`, default `g = sqrt(2)`.; The value of `g` is related to the value of `hbar` in the commutation ; relation `[x, y] = i * hbar` via `hbar=2/g ** 2` giving the default ; value `hbar=1`. . Returns; -------. N : float ; The logarithmic negativity for the two-mode Gaussian state; that is described by the the Wigner covariance matrix V. """"""; A = 0.5 * V[0:2, 0:2] * g ** 2; B = 0.5 * V[2:4, 2:4] * g ** 2; C = 0.5 * V[0:2, 2:4] * g ** 2; sigma = np.linalg.det(A) + np.linalg.det(B) - 2 * np.linalg.det(C); nu_ = sigma / 2 - np.sqrt(sigma ** 2 - 4 * np.linalg.det(V)) / 2; if nu_ < 0.0:; return 0.0; nu = np.sqrt(nu_); lognu = -np.log(2 * nu); logneg = max(0, lognu); return logneg. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/modules/qutip/continuous_variables.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/continuous_variables.html
https://qutip.org/docs/4.7/modules/qutip/continuous_variables.html:7510,Testability,log,log,7510,"lues. """"""; if R is not None:; if rho is None:; return np.array([[0.5 * np.real(R[i, j] + R[j, i]); for i in range(4)]; for j in range(4)], dtype=np.float64); else:; return np.array([[0.5 * np.real(expect(R[i, j] + R[j, i], rho)); for i in range(4)]; for j in range(4)], dtype=np.float64); elif a1 is not None and a2 is not None:; if rho is not None:; x1 = (a1 + a1.dag()) / g; p1 = -1j * (a1 - a1.dag()) / g; x2 = (a2 + a2.dag()) / g; p2 = -1j * (a2 - a2.dag()) / g; return covariance_matrix([x1, p1, x2, p2], rho); else:; raise ValueError(""Must give rho if using field operators "" +; ""(a1 and a2)""); else:; raise ValueError(""Must give either field operators (a1 and a2) "" +; ""or a precomputed correlation matrix (R)""). [docs]def logarithmic_negativity(V, g=np.sqrt(2)):; """"""; Calculates the logarithmic negativity given a symmetrized covariance; matrix, see :func:`qutip.continuous_variables.covariance_matrix`. Note that; the two-mode field state that is described by `V` must be Gaussian for this; function to applicable. Parameters; ----------. V : *2d array*; The covariance matrix. g : float; Scaling factor for `a = 0.5 * g * (x + iy)`, default `g = sqrt(2)`.; The value of `g` is related to the value of `hbar` in the commutation ; relation `[x, y] = i * hbar` via `hbar=2/g ** 2` giving the default ; value `hbar=1`. . Returns; -------. N : float ; The logarithmic negativity for the two-mode Gaussian state; that is described by the the Wigner covariance matrix V. """"""; A = 0.5 * V[0:2, 0:2] * g ** 2; B = 0.5 * V[2:4, 2:4] * g ** 2; C = 0.5 * V[0:2, 2:4] * g ** 2; sigma = np.linalg.det(A) + np.linalg.det(B) - 2 * np.linalg.det(C); nu_ = sigma / 2 - np.sqrt(sigma ** 2 - 4 * np.linalg.det(V)) / 2; if nu_ < 0.0:; return 0.0; nu = np.sqrt(nu_); lognu = -np.log(2 * nu); logneg = max(0, lognu); return logneg. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/modules/qutip/continuous_variables.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/continuous_variables.html
https://qutip.org/docs/4.7/modules/qutip/continuous_variables.html:7523,Testability,log,logneg,7523,"lues. """"""; if R is not None:; if rho is None:; return np.array([[0.5 * np.real(R[i, j] + R[j, i]); for i in range(4)]; for j in range(4)], dtype=np.float64); else:; return np.array([[0.5 * np.real(expect(R[i, j] + R[j, i], rho)); for i in range(4)]; for j in range(4)], dtype=np.float64); elif a1 is not None and a2 is not None:; if rho is not None:; x1 = (a1 + a1.dag()) / g; p1 = -1j * (a1 - a1.dag()) / g; x2 = (a2 + a2.dag()) / g; p2 = -1j * (a2 - a2.dag()) / g; return covariance_matrix([x1, p1, x2, p2], rho); else:; raise ValueError(""Must give rho if using field operators "" +; ""(a1 and a2)""); else:; raise ValueError(""Must give either field operators (a1 and a2) "" +; ""or a precomputed correlation matrix (R)""). [docs]def logarithmic_negativity(V, g=np.sqrt(2)):; """"""; Calculates the logarithmic negativity given a symmetrized covariance; matrix, see :func:`qutip.continuous_variables.covariance_matrix`. Note that; the two-mode field state that is described by `V` must be Gaussian for this; function to applicable. Parameters; ----------. V : *2d array*; The covariance matrix. g : float; Scaling factor for `a = 0.5 * g * (x + iy)`, default `g = sqrt(2)`.; The value of `g` is related to the value of `hbar` in the commutation ; relation `[x, y] = i * hbar` via `hbar=2/g ** 2` giving the default ; value `hbar=1`. . Returns; -------. N : float ; The logarithmic negativity for the two-mode Gaussian state; that is described by the the Wigner covariance matrix V. """"""; A = 0.5 * V[0:2, 0:2] * g ** 2; B = 0.5 * V[2:4, 2:4] * g ** 2; C = 0.5 * V[0:2, 2:4] * g ** 2; sigma = np.linalg.det(A) + np.linalg.det(B) - 2 * np.linalg.det(C); nu_ = sigma / 2 - np.sqrt(sigma ** 2 - 4 * np.linalg.det(V)) / 2; if nu_ < 0.0:; return 0.0; nu = np.sqrt(nu_); lognu = -np.log(2 * nu); logneg = max(0, lognu); return logneg. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/modules/qutip/continuous_variables.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/continuous_variables.html
https://qutip.org/docs/4.7/modules/qutip/continuous_variables.html:7539,Testability,log,lognu,7539,"lues. """"""; if R is not None:; if rho is None:; return np.array([[0.5 * np.real(R[i, j] + R[j, i]); for i in range(4)]; for j in range(4)], dtype=np.float64); else:; return np.array([[0.5 * np.real(expect(R[i, j] + R[j, i], rho)); for i in range(4)]; for j in range(4)], dtype=np.float64); elif a1 is not None and a2 is not None:; if rho is not None:; x1 = (a1 + a1.dag()) / g; p1 = -1j * (a1 - a1.dag()) / g; x2 = (a2 + a2.dag()) / g; p2 = -1j * (a2 - a2.dag()) / g; return covariance_matrix([x1, p1, x2, p2], rho); else:; raise ValueError(""Must give rho if using field operators "" +; ""(a1 and a2)""); else:; raise ValueError(""Must give either field operators (a1 and a2) "" +; ""or a precomputed correlation matrix (R)""). [docs]def logarithmic_negativity(V, g=np.sqrt(2)):; """"""; Calculates the logarithmic negativity given a symmetrized covariance; matrix, see :func:`qutip.continuous_variables.covariance_matrix`. Note that; the two-mode field state that is described by `V` must be Gaussian for this; function to applicable. Parameters; ----------. V : *2d array*; The covariance matrix. g : float; Scaling factor for `a = 0.5 * g * (x + iy)`, default `g = sqrt(2)`.; The value of `g` is related to the value of `hbar` in the commutation ; relation `[x, y] = i * hbar` via `hbar=2/g ** 2` giving the default ; value `hbar=1`. . Returns; -------. N : float ; The logarithmic negativity for the two-mode Gaussian state; that is described by the the Wigner covariance matrix V. """"""; A = 0.5 * V[0:2, 0:2] * g ** 2; B = 0.5 * V[2:4, 2:4] * g ** 2; C = 0.5 * V[0:2, 2:4] * g ** 2; sigma = np.linalg.det(A) + np.linalg.det(B) - 2 * np.linalg.det(C); nu_ = sigma / 2 - np.sqrt(sigma ** 2 - 4 * np.linalg.det(V)) / 2; if nu_ < 0.0:; return 0.0; nu = np.sqrt(nu_); lognu = -np.log(2 * nu); logneg = max(0, lognu); return logneg. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/modules/qutip/continuous_variables.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/continuous_variables.html
https://qutip.org/docs/4.7/modules/qutip/continuous_variables.html:7554,Testability,log,logneg,7554,"lues. """"""; if R is not None:; if rho is None:; return np.array([[0.5 * np.real(R[i, j] + R[j, i]); for i in range(4)]; for j in range(4)], dtype=np.float64); else:; return np.array([[0.5 * np.real(expect(R[i, j] + R[j, i], rho)); for i in range(4)]; for j in range(4)], dtype=np.float64); elif a1 is not None and a2 is not None:; if rho is not None:; x1 = (a1 + a1.dag()) / g; p1 = -1j * (a1 - a1.dag()) / g; x2 = (a2 + a2.dag()) / g; p2 = -1j * (a2 - a2.dag()) / g; return covariance_matrix([x1, p1, x2, p2], rho); else:; raise ValueError(""Must give rho if using field operators "" +; ""(a1 and a2)""); else:; raise ValueError(""Must give either field operators (a1 and a2) "" +; ""or a precomputed correlation matrix (R)""). [docs]def logarithmic_negativity(V, g=np.sqrt(2)):; """"""; Calculates the logarithmic negativity given a symmetrized covariance; matrix, see :func:`qutip.continuous_variables.covariance_matrix`. Note that; the two-mode field state that is described by `V` must be Gaussian for this; function to applicable. Parameters; ----------. V : *2d array*; The covariance matrix. g : float; Scaling factor for `a = 0.5 * g * (x + iy)`, default `g = sqrt(2)`.; The value of `g` is related to the value of `hbar` in the commutation ; relation `[x, y] = i * hbar` via `hbar=2/g ** 2` giving the default ; value `hbar=1`. . Returns; -------. N : float ; The logarithmic negativity for the two-mode Gaussian state; that is described by the the Wigner covariance matrix V. """"""; A = 0.5 * V[0:2, 0:2] * g ** 2; B = 0.5 * V[2:4, 2:4] * g ** 2; C = 0.5 * V[0:2, 2:4] * g ** 2; sigma = np.linalg.det(A) + np.linalg.det(B) - 2 * np.linalg.det(C); nu_ = sigma / 2 - np.sqrt(sigma ** 2 - 4 * np.linalg.det(V)) / 2; if nu_ < 0.0:; return 0.0; nu = np.sqrt(nu_); lognu = -np.log(2 * nu); logneg = max(0, lognu); return logneg. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/modules/qutip/continuous_variables.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/continuous_variables.html
https://qutip.org/docs/4.7/modules/qutip/correlation.html:3131,Availability,error,errors,3131," : Qobj; Initial state density matrix :math:`\rho(t_0)` or state vector; :math:`\psi(t_0)`. If 'state0' is 'None', then the steady state will; be used as the initial state. The 'steady-state' is only implemented; for the `me` and `es` solvers.; taulist : array_like; list of times for :math:`\tau`. taulist must be positive and contain; the element `0`.; c_ops : list; list of collapse operators, may be time-dependent for solver choice of; `me` or `mc`.; a_op : Qobj; operator A.; b_op : Qobj; operator B.; reverse : bool {False, True}; If `True`, calculate :math:`\left<A(t)B(t+\tau)\right>` instead of; :math:`\left<A(t+\tau)B(t)\right>`.; solver : str {'me', 'mc', 'es'}; choice of solver (`me` for master-equation, `mc` for Monte Carlo, and; `es` for exponential series).; options : Options; Solver options class. `ntraj` is taken as a two-element list because; the `mc` correlator calls `mcsolve()` recursively; by default,; `ntraj=[20, 100]`. `mc_corr_eps` prevents divide-by-zero errors in; the `mc` correlator; by default, `mc_corr_eps=1e-10`. Returns; -------; corr_vec : ndarray; An array of correlation values for the times specified by `taulist`. References; ----------; See, Gardiner, Quantum Noise, Section 5.2. """""". if debug:; print(inspect.stack()[0][3]). if reverse:; A_op = a_op; B_op = b_op; C_op = 1; else:; A_op = 1; B_op = a_op; C_op = b_op. return _correlation_2t(H, state0, [0], taulist, c_ops, A_op, B_op, C_op,; solver=solver, args=args, options=options)[0]. [docs]def correlation_2op_2t(H, state0, tlist, taulist, c_ops, a_op, b_op,; solver=""me"", reverse=False, args={},; options=Options(ntraj=[20, 100])):; r""""""; Calculate the two-operator two-time correlation function:; :math:`\left<A(t+\tau)B(t)\right>`; along two time axes using the quantum regression theorem and the; evolution solver indicated by the `solver` parameter. Parameters; ----------; H : Qobj; system Hamiltonian, may be time-dependent for solver choice of `me` or; `mc`.; state0 : Qobj; Initial state de",MatchSource.WIKI,docs/4.7/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/correlation.html
https://qutip.org/docs/4.7/modules/qutip/correlation.html:5355,Availability,error,errors,5355,"rray_like; list of times for :math:`t`. tlist must be positive and contain the; element `0`. When taking steady-steady correlations only one tlist; value is necessary, i.e. when :math:`t \rightarrow \infty`; here; tlist is automatically set, ignoring user input.; taulist : array_like; list of times for :math:`\tau`. taulist must be positive and contain; the element `0`.; c_ops : list; list of collapse operators, may be time-dependent for solver choice of; `me` or `mc`.; a_op : Qobj; operator A.; b_op : Qobj; operator B.; reverse : bool {False, True}; If `True`, calculate :math:`\left<A(t)B(t+\tau)\right>` instead of; :math:`\left<A(t+\tau)B(t)\right>`.; solver : str; choice of solver (`me` for master-equation, `mc` for Monte Carlo, and; `es` for exponential series).; options : Options; solver options class. `ntraj` is taken as a two-element list because; the `mc` correlator calls `mcsolve()` recursively; by default,; `ntraj=[20, 100]`. `mc_corr_eps` prevents divide-by-zero errors in; the `mc` correlator; by default, `mc_corr_eps=1e-10`. Returns; -------; corr_mat : ndarray; An 2-dimensional array (matrix) of correlation values for the times; specified by `tlist` (first index) and `taulist` (second index). If; `tlist` is `None`, then a 1-dimensional array of correlation values; is returned instead. References; ----------; See, Gardiner, Quantum Noise, Section 5.2. """""". if debug:; print(inspect.stack()[0][3]). if tlist is None:; return correlation_2op_1t(H, state0, taulist, c_ops, a_op, b_op,; solver=solver, reverse=reverse, args=args,; options=options); else:; if reverse:; A_op = a_op; B_op = b_op; C_op = 1; else:; A_op = 1; B_op = a_op; C_op = b_op. return _correlation_2t(H, state0, tlist, taulist,; c_ops, A_op, B_op, C_op,; solver=solver, args=args, options=options). [docs]def correlation_3op_1t(H, state0, taulist, c_ops, a_op, b_op, c_op,; solver=""me"", args={},; options=Options(ntraj=[20, 100])):; r""""""; Calculate the three-operator two-time correlation function:; :",MatchSource.WIKI,docs/4.7/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/correlation.html
https://qutip.org/docs/4.7/modules/qutip/correlation.html:7614,Availability,error,errors,7614,":`\tau<0`. Parameters; ----------; H : Qobj; system Hamiltonian, may be time-dependent for solver choice of `me` or; `mc`.; rho0 : Qobj; Initial state density matrix :math:`\rho(t_0)` or state vector; :math:`\psi(t_0)`. If 'state0' is 'None', then the steady state will; be used as the initial state. The 'steady-state' is only implemented; for the `me` and `es` solvers.; taulist : array_like; list of times for :math:`\tau`. taulist must be positive and contain; the element `0`.; c_ops : list; list of collapse operators, may be time-dependent for solver choice of; `me` or `mc`.; a_op : Qobj; operator A.; b_op : Qobj; operator B.; c_op : Qobj; operator C.; solver : str; choice of solver (`me` for master-equation, `mc` for Monte Carlo, and; `es` for exponential series).; options : Options; solver options class. `ntraj` is taken as a two-element list because; the `mc` correlator calls `mcsolve()` recursively; by default,; `ntraj=[20, 100]`. `mc_corr_eps` prevents divide-by-zero errors in; the `mc` correlator; by default, `mc_corr_eps=1e-10`. Returns; -------; corr_vec : array; An array of correlation values for the times specified by `taulist`. References; ----------; See, Gardiner, Quantum Noise, Section 5.2. """""". if debug:; print(inspect.stack()[0][3]). return _correlation_2t(H, state0, [0], taulist, c_ops, a_op, b_op, c_op,; solver=solver, args=args, options=options)[0]. [docs]def correlation_3op_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, c_op,; solver=""me"", args={},; options=Options(ntraj=[20, 100])):; r""""""; Calculate the three-operator two-time correlation function:; :math:`\left<A(t)B(t+\tau)C(t)\right>`; along two time axes using the quantum regression theorem and the; evolution solver indicated by the `solver` parameter. Note: it is not possibly to calculate a physically meaningful correlation; of this form where :math:`\tau<0`. Parameters; ----------; H : Qobj; system Hamiltonian, may be time-dependent for solver choice of `me` or; `mc`.; rho0 : Qobj; Initi",MatchSource.WIKI,docs/4.7/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/correlation.html
https://qutip.org/docs/4.7/modules/qutip/correlation.html:9740,Availability,error,errors,9740," used as the initial state. The 'steady-state' is only implemented; for the `me` and `es` solvers.; tlist : array_like; list of times for :math:`t`. tlist must be positive and contain the; element `0`. When taking steady-steady correlations only one tlist; value is necessary, i.e. when :math:`t \rightarrow \infty`; here; tlist is automatically set, ignoring user input.; taulist : array_like; list of times for :math:`\tau`. taulist must be positive and contain; the element `0`.; c_ops : list; list of collapse operators, may be time-dependent for solver choice of; `me` or `mc`.; a_op : Qobj; operator A.; b_op : Qobj; operator B.; c_op : Qobj; operator C.; solver : str; choice of solver (`me` for master-equation, `mc` for Monte Carlo, and; `es` for exponential series).; options : Options; solver options class. `ntraj` is taken as a two-element list because; the `mc` correlator calls `mcsolve()` recursively; by default,; `ntraj=[20, 100]`. `mc_corr_eps` prevents divide-by-zero errors in; the `mc` correlator; by default, `mc_corr_eps=1e-10`. Returns; -------; corr_mat : array; An 2-dimensional array (matrix) of correlation values for the times; specified by `tlist` (first index) and `taulist` (second index). If; `tlist` is `None`, then a 1-dimensional array of correlation values; is returned instead. References; ----------. See, Gardiner, Quantum Noise, Section 5.2. """""". if debug:; print(inspect.stack()[0][3]). if tlist is None:; return correlation_3op_1t(H, state0, taulist, c_ops, a_op, b_op, c_op,; solver=solver, args=args, options=options); else:; return _correlation_2t(H, state0, tlist, taulist,; c_ops, a_op, b_op, c_op,; solver=solver, args=args, options=options). # high level correlation. [docs]def coherence_function_g1(H, state0, taulist, c_ops, a_op, solver=""me"",; args={}, options=Options(ntraj=[20, 100])):; r""""""; Calculate the normalized first-order quantum coherence function:. .. math::. g^{(1)}(\tau) =; \frac{\langle A^\dagger(\tau)A(0)\rangle}; {\sqrt{\langle ",MatchSource.WIKI,docs/4.7/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/correlation.html
https://qutip.org/docs/4.7/modules/qutip/correlation.html:11823,Availability,error,errors,11823,"m regression theorem and the evolution solver indicated by; the `solver` parameter. Parameters; ----------; H : Qobj; system Hamiltonian, may be time-dependent for solver choice of `me` or; `mc`.; state0 : Qobj; Initial state density matrix :math:`\rho(t_0)` or state vector; :math:`\psi(t_0)`. If 'state0' is 'None', then the steady state will; be used as the initial state. The 'steady-state' is only implemented; for the `me` and `es` solvers.; taulist : array_like; list of times for :math:`\tau`. taulist must be positive and contain; the element `0`.; c_ops : list; list of collapse operators, may be time-dependent for solver choice of; `me` or `mc`.; a_op : Qobj; operator A.; solver : str; choice of solver (`me` for master-equation and; `es` for exponential series).; options : Options; solver options class. `ntraj` is taken as a two-element list because; the `mc` correlator calls `mcsolve()` recursively; by default,; `ntraj=[20, 100]`. `mc_corr_eps` prevents divide-by-zero errors in; the `mc` correlator; by default, `mc_corr_eps=1e-10`. Returns; -------; g1, G1 : tuple; The normalized and unnormalized second-order coherence function. """""". # first calculate the photon number; if state0 is None:; state0 = steadystate(H, c_ops); n = np.array([expect(state0, a_op.dag() * a_op)]); else:; n = mesolve(H, state0, taulist, c_ops, [a_op.dag() * a_op],; options=options).expect[0]. # calculate the correlation function G1 and normalize with n to obtain g1; G1 = correlation_2op_1t(H, state0, taulist, c_ops, a_op.dag(), a_op,; solver=solver, args=args, options=options); g1 = G1 / np.sqrt(n[0] * n). return g1, G1. [docs]def coherence_function_g2(H, state0, taulist, c_ops, a_op, solver=""me"", args={},; options=Options(ntraj=[20, 100])):; r""""""; Calculate the normalized second-order quantum coherence function:. .. math::. g^{(2)}(\tau) =; \frac{\langle A^\dagger(0)A^\dagger(\tau)A(\tau)A(0)\rangle}; {\langle A^\dagger(\tau)A(\tau)\rangle; \langle A^\dagger(0)A(0)\rangle}. using the quan",MatchSource.WIKI,docs/4.7/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/correlation.html
https://qutip.org/docs/4.7/modules/qutip/correlation.html:13888,Availability,error,errors,13888,"e `solver` parameter. Parameters; ----------; H : Qobj; system Hamiltonian, may be time-dependent for solver choice of `me` or; `mc`.; state0 : Qobj; Initial state density matrix :math:`\rho(t_0)` or state vector; :math:`\psi(t_0)`. If 'state0' is 'None', then the steady state will; be used as the initial state. The 'steady-state' is only implemented; for the `me` and `es` solvers.; taulist : array_like; list of times for :math:`\tau`. taulist must be positive and contain; the element `0`.; c_ops : list; list of collapse operators, may be time-dependent for solver choice of; `me` or `mc`.; a_op : Qobj; operator A.; args : dict; Dictionary of arguments to be passed to solver.; solver : str; choice of solver (`me` for master-equation and; `es` for exponential series).; options : Options; solver options class. `ntraj` is taken as a two-element list because; the `mc` correlator calls `mcsolve()` recursively; by default,; `ntraj=[20, 100]`. `mc_corr_eps` prevents divide-by-zero errors in; the `mc` correlator; by default, `mc_corr_eps=1e-10`. Returns; -------; g2, G2 : tuple; The normalized and unnormalized second-order coherence function. """""". # first calculate the photon number; if state0 is None:; state0 = steadystate(H, c_ops); n = np.array([expect(state0, a_op.dag() * a_op)]); else:; n = mesolve(H, state0, taulist, c_ops, [a_op.dag() * a_op], args=args).expect[0]. # calculate the correlation function G2 and normalize with n to obtain g2; G2 = correlation_3op_1t(H, state0, taulist, c_ops,; a_op.dag(), a_op.dag()*a_op, a_op,; solver=solver, args=args, options=options); g2 = G2 / (n[0] * n). return g2, G2. # spectrum. [docs]def spectrum(H, wlist, c_ops, a_op, b_op, solver=""es"", use_pinv=False):; r""""""; Calculate the spectrum of the correlation function; :math:`\lim_{t \to \infty} \left<A(t+\tau)B(t)\right>`,; i.e., the Fourier transform of the correlation function:. .. math::. S(\omega) = \int_{-\infty}^{\infty}; \lim_{t \to \infty} \left<A(t+\tau)B(t)\right>; e^{-i\omega",MatchSource.WIKI,docs/4.7/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/correlation.html
https://qutip.org/docs/4.7/modules/qutip/correlation.html:18495,Availability,error,errors,18495,"he two-operator two-time correlation function:. .. math::. \lim_{t \to \infty} \left<A(t+\tau)B(t)\right>. along one time axis (given steady-state initial conditions) using the; quantum regression theorem and the evolution solver indicated by the; `solver` parameter. Parameters; ----------. H : Qobj; system Hamiltonian. taulist : array_like; list of times for :math:`\tau`. taulist must be positive and contain; the element `0`. c_ops : list; list of collapse operators. a_op : Qobj; operator A. b_op : Qobj; operator B. reverse : *bool*; If `True`, calculate; :math:`\lim_{t \to \infty} \left<A(t)B(t+\tau)\right>` instead of; :math:`\lim_{t \to \infty} \left<A(t+\tau)B(t)\right>`. solver : str; choice of solver (`me` for master-equation and; `es` for exponential series). options : Options; solver options class. `ntraj` is taken as a two-element list because; the `mc` correlator calls `mcsolve()` recursively; by default,; `ntraj=[20, 100]`. `mc_corr_eps` prevents divide-by-zero errors in; the `mc` correlator; by default, `mc_corr_eps=1e-10`. Returns; -------. corr_vec : array; An array of correlation values for the times specified by `tlist`. References; ----------. See, Gardiner, Quantum Noise, Section 5.2. """""". warn(""correlation_ss() now legacy, please use correlation_2op_1t() with"" +; ""initial state as None"", FutureWarning). if debug:; print(inspect.stack()[0][3]). return correlation_2op_1t(H, None, taulist, c_ops, a_op, b_op,; solver=solver, reverse=reverse, args=args,; options=options). [docs]def correlation(H, state0, tlist, taulist, c_ops, a_op, b_op,; solver=""me"", reverse=False, args={},; options=Options(ntraj=[20, 100])):; r""""""; Calculate the two-operator two-time correlation function:; :math:`\left<A(t+\tau)B(t)\right>`; along two time axes using the quantum regression theorem and the; evolution solver indicated by the `solver` parameter. Parameters; ----------. H : Qobj; system Hamiltonian, may be time-dependent for solver choice of `me` or; `mc`. state0 : Qobj",MatchSource.WIKI,docs/4.7/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/correlation.html
https://qutip.org/docs/4.7/modules/qutip/correlation.html:20723,Availability,error,errors,20723," solvers. tlist : array_like; list of times for :math:`t`. tlist must be positive and contain the; element `0`. When taking steady-steady correlations only one tlist; value is necessary, i.e. when :math:`t \rightarrow \infty`; here; tlist is automatically set, ignoring user input. taulist : array_like; list of times for :math:`\tau`. taulist must be positive and contain; the element `0`. c_ops : list; list of collapse operators, may be time-dependent for solver choice of; `me` or `mc`. a_op : Qobj; operator A. b_op : Qobj; operator B. reverse : *bool*; If `True`, calculate :math:`\left<A(t)B(t+\tau)\right>` instead of; :math:`\left<A(t+\tau)B(t)\right>`. solver : str; choice of solver (`me` for master-equation, `mc` for Monte Carlo, and; `es` for exponential series). options : Options; solver options class. `ntraj` is taken as a two-element list because; the `mc` correlator calls `mcsolve()` recursively; by default,; `ntraj=[20, 100]`. `mc_corr_eps` prevents divide-by-zero errors in; the `mc` correlator; by default, `mc_corr_eps=1e-10`. Returns; -------. corr_mat : array; An 2-dimensional array (matrix) of correlation values for the times; specified by `tlist` (first index) and `taulist` (second index). If; `tlist` is `None`, then a 1-dimensional array of correlation values; is returned instead. References; ----------. See, Gardiner, Quantum Noise, Section 5.2. """""". warn(""correlation() now legacy, please use correlation_2op_2t()"",; FutureWarning). if debug:; print(inspect.stack()[0][3]). return correlation_2op_2t(H, state0, tlist, taulist, c_ops, a_op, b_op,; solver=solver, reverse=reverse, args=args,; options=options). [docs]def correlation_4op_1t(H, state0, taulist, c_ops, a_op, b_op, c_op, d_op,; solver=""me"", args={},; options=Options(ntraj=[20, 100])):; r""""""; Calculate the four-operator two-time correlation function:; :math:`\left<A(t)B(t+\tau)C(t+\tau)D(t)\right>`; along one time axis using the quantum regression theorem and the; evolution solver indicated by th",MatchSource.WIKI,docs/4.7/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/correlation.html
https://qutip.org/docs/4.7/modules/qutip/correlation.html:22865,Availability,error,errors,22865,"s; ----------; H : Qobj; system Hamiltonian, may be time-dependent for solver choice of `me` or; `mc`.; rho0 : Qobj; Initial state density matrix :math:`\rho(t_0)` or state vector; :math:`\psi(t_0)`. If 'state0' is 'None', then the steady state will; be used as the initial state. The 'steady-state' is only implemented; for the `me` and `es` solvers.; taulist : array_like; list of times for :math:`\tau`. taulist must be positive and contain; the element `0`.; c_ops : list; list of collapse operators, may be time-dependent for solver choice of; `me` or `mc`. a_op : Qobj; operator A. b_op : Qobj; operator B. c_op : Qobj; operator C. d_op : Qobj; operator D. solver : str; choice of solver (`me` for master-equation, `mc` for Monte Carlo, and; `es` for exponential series). options : Options; solver options class. `ntraj` is taken as a two-element list because; the `mc` correlator calls `mcsolve()` recursively; by default,; `ntraj=[20, 100]`. `mc_corr_eps` prevents divide-by-zero errors in; the `mc` correlator; by default, `mc_corr_eps=1e-10`. Returns; -------; corr_vec : array; An array of correlation values for the times specified by `taulist`. References; ----------; See, Gardiner, Quantum Noise, Section 5.2. .. note:: Deprecated in QuTiP 3.1; Use correlation_3op_1t() instead. """""". warn(""correlation_4op_1t() now legacy, please use correlation_3op_1t()"",; FutureWarning); warn(""the reverse argument has been removed as it did not contain any"" +; ""new physical information"", DeprecationWarning). if debug:; print(inspect.stack()[0][3]). return correlation_3op_1t(H, state0, taulist, c_ops,; a_op, b_op * c_op, d_op,; solver=solver, args=args, options=options). [docs]def correlation_4op_2t(H, state0, tlist, taulist, c_ops,; a_op, b_op, c_op, d_op, solver=""me"", args={},; options=Options(ntraj=[20, 100])):; r""""""; Calculate the four-operator two-time correlation function:; :math:`\left<A(t)B(t+\tau)C(t+\tau)D(t)\right>`; along two time axes using the quantum regression theorem and t",MatchSource.WIKI,docs/4.7/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/correlation.html
https://qutip.org/docs/4.7/modules/qutip/correlation.html:25306,Availability,error,errors,25306,"ial state. The 'steady-state' is only implemented; for the `me` and `es` solvers. tlist : array_like; list of times for :math:`t`. tlist must be positive and contain the; element `0`. When taking steady-steady correlations only one tlist; value is necessary, i.e. when :math:`t \rightarrow \infty`; here; tlist is automatically set, ignoring user input. taulist : array_like; list of times for :math:`\tau`. taulist must be positive and contain; the element `0`. c_ops : list; list of collapse operators, may be time-dependent for solver choice of; `me` or `mc`. a_op : Qobj; operator A. b_op : Qobj; operator B. c_op : Qobj; operator C. d_op : Qobj; operator D. solver : str; choice of solver (`me` for master-equation, `mc` for Monte Carlo, and; `es` for exponential series). options : Options; solver options class. `ntraj` is taken as a two-element list because; the `mc` correlator calls `mcsolve()` recursively; by default,; `ntraj=[20, 100]`. `mc_corr_eps` prevents divide-by-zero errors in; the `mc` correlator; by default, `mc_corr_eps=1e-10`. Returns; -------. corr_mat : array; An 2-dimensional array (matrix) of correlation values for the times; specified by `tlist` (first index) and `taulist` (second index). If; `tlist` is `None`, then a 1-dimensional array of correlation values; is returned instead. References; ----------. See, Gardiner, Quantum Noise, Section 5.2. """""". warn(""correlation_4op_2t() now legacy, please use correlation_3op_2t()"",; FutureWarning); warn(""the reverse argument has been removed as it did not contain any"" +; ""new physical information"", DeprecationWarning). if debug:; print(inspect.stack()[0][3]). return correlation_3op_2t(H, state0, tlist, taulist, c_ops,; a_op, b_op * c_op, d_op,; solver=solver, args=args, options=options). # spectrum. [docs]def spectrum_ss(H, wlist, c_ops, a_op, b_op):; r""""""; Calculate the spectrum of the correlation function; :math:`\lim_{t \to \infty} \left<A(t+\tau)B(t)\right>`,; i.e., the Fourier transform of the correlation ",MatchSource.WIKI,docs/4.7/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/correlation.html
https://qutip.org/docs/4.7/modules/qutip/correlation.html:35376,Availability,error,errors,35376,"on of <A(t)B(t+tau)C(t)> from only knowledge of psi0 requires; # averaging over both t and tau; for t_idx in range(np.size(tlist)):; for trial_idx in range(options.ntraj[0]):; if isinstance(a_op, Qobj) and isinstance(c_op, Qobj):; if a_op.dag() == c_op:; # A shortcut here, requires only 1/4 the trials; chi_0 = (options.mc_corr_eps + c_op) * \; psi_t_mat[trial_idx, t_idx]. # evolve these states and calculate expectation value of B; c_tau = chi_0.norm()**2 * mcsolve(; H, chi_0/chi_0.norm(), taulist + tlist[t_idx], c_ops,; [b_op],; args=args, ntraj=options.ntraj[1], options=options,; progress_bar=None; ).expect[0]. # final correlation vector computed by combining the; # averages; corr_mat[t_idx, :] += c_tau/options.ntraj[1]; else:; # otherwise, need four trial wavefunctions; # (Ad+C)*psi_t, (Ad+iC)*psi_t, (Ad-C)*psi_t, (Ad-iC)*psi_t; if isinstance(a_op, Qobj):; a_op_dag = a_op.dag(); else:; # assume this is a number, ex. i.e. a_op = 1; # if this is not correct, the over-loaded addition; # operation will raise errors; a_op_dag = a_op; chi_0 = [(options.mc_corr_eps + a_op_dag +; np.exp(1j*x*np.pi/2)*c_op) *; psi_t_mat[trial_idx, t_idx]; for x in range(4)]. # evolve these states and calculate expectation value of B; c_tau = [; chi.norm()**2 * mcsolve(; H, chi/chi.norm(), taulist + tlist[t_idx], c_ops,; [b_op],; args=args, ntraj=options.ntraj[1], options=options,; progress_bar=None; ).expect[0]; for chi in chi_0; ]. # final correlation vector computed by combining the averages; corr_mat_add = np.asarray(; 1.0 / (4*options.ntraj[0]) *; (c_tau[0] - c_tau[2] - 1j*c_tau[1] + 1j*c_tau[3]),; dtype=corr_mat.dtype; ); corr_mat[t_idx, :] += corr_mat_add. if t_idx == 1:; options.rhs_reuse = True. if config.tdname:; _cython_build_cleanup(config.tdname); rhs_clear(). return corr_mat. # pseudo-inverse solvers; def _spectrum_pi(H, wlist, c_ops, a_op, b_op, use_pinv=False):; r""""""; Internal function for calculating the spectrum of the correlation function; :math:`\left<A(\tau)B(0)\right>`.",MatchSource.WIKI,docs/4.7/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/correlation.html
https://qutip.org/docs/4.7/modules/qutip/correlation.html:37132,Deployability,update,updated,37132," = a_op.dag(); else:; # assume this is a number, ex. i.e. a_op = 1; # if this is not correct, the over-loaded addition; # operation will raise errors; a_op_dag = a_op; chi_0 = [(options.mc_corr_eps + a_op_dag +; np.exp(1j*x*np.pi/2)*c_op) *; psi_t_mat[trial_idx, t_idx]; for x in range(4)]. # evolve these states and calculate expectation value of B; c_tau = [; chi.norm()**2 * mcsolve(; H, chi/chi.norm(), taulist + tlist[t_idx], c_ops,; [b_op],; args=args, ntraj=options.ntraj[1], options=options,; progress_bar=None; ).expect[0]; for chi in chi_0; ]. # final correlation vector computed by combining the averages; corr_mat_add = np.asarray(; 1.0 / (4*options.ntraj[0]) *; (c_tau[0] - c_tau[2] - 1j*c_tau[1] + 1j*c_tau[3]),; dtype=corr_mat.dtype; ); corr_mat[t_idx, :] += corr_mat_add. if t_idx == 1:; options.rhs_reuse = True. if config.tdname:; _cython_build_cleanup(config.tdname); rhs_clear(). return corr_mat. # pseudo-inverse solvers; def _spectrum_pi(H, wlist, c_ops, a_op, b_op, use_pinv=False):; r""""""; Internal function for calculating the spectrum of the correlation function; :math:`\left<A(\tau)B(0)\right>`.; """""". L = H if issuper(H) else liouvillian(H, c_ops). tr_mat = tensor([qeye(n) for n in L.dims[0][0]]); N = np.prod(L.dims[0][0]). A = L.full(); b = spre(b_op).full(); a = spre(a_op).full(). tr_vec = np.transpose(mat2vec(tr_mat.full())). rho_ss = steadystate(L); rho = np.transpose(mat2vec(rho_ss.full())). I = np.identity(N * N); P = np.kron(np.transpose(rho), tr_vec); Q = I - P. spectrum = np.zeros(len(wlist)). for idx, w in enumerate(wlist):; if use_pinv:; MMR = np.linalg.pinv(-1.0j * w * I + A); else:; MMR = np.dot(Q, np.linalg.solve(-1.0j * w * I + A, Q)). s = np.dot(tr_vec,; np.dot(a, np.dot(MMR, np.dot(b, np.transpose(rho))))); spectrum[idx] = -2 * np.real(s[0, 0]). return spectrum. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/correlation.html
https://qutip.org/docs/4.7/modules/qutip/correlation.html:15980,Energy Efficiency,power,power,15980,"is spectrum; is only defined for stationary statistics (uses steady state rho0). Parameters; ----------; H : :class:`qutip.qobj`; system Hamiltonian.; wlist : array_like; list of frequencies for :math:`\omega`.; c_ops : list; list of collapse operators.; a_op : Qobj; operator A.; b_op : Qobj; operator B.; solver : str; choice of solver (`es` for exponential series and; `pi` for psuedo-inverse).; use_pinv : bool; For use with the `pi` solver: if `True` use numpy's pinv method,; otherwise use a generic solver. Returns; -------; spectrum : array; An array with spectrum :math:`S(\omega)` for the frequencies; specified in `wlist`. """""". if debug:; print(inspect.stack()[0][3]). if solver == ""es"":; return _spectrum_es(H, wlist, c_ops, a_op, b_op); elif solver == ""pi"":; return _spectrum_pi(H, wlist, c_ops, a_op, b_op, use_pinv); else:; raise ValueError(""Unrecognized choice of solver"" +; ""%s (use es or pi)."" % solver). [docs]def spectrum_correlation_fft(tlist, y, inverse=False):; """"""; Calculate the power spectrum corresponding to a two-time correlation; function using FFT. Parameters; ----------; tlist : array_like; list/array of times :math:`t` which the correlation function is given.; y : array_like; list/array of correlations corresponding to time delays :math:`t`.; inverse: boolean; boolean parameter for using a positive exponent in the Fourier Transform instead. Default is False. Returns; -------; w, S : tuple; Returns an array of angular frequencies 'w' and the corresponding; two-sided power spectrum 'S(w)'. """""". if debug:; print(inspect.stack()[0][3]); tlist = np.asarray(tlist); N = tlist.shape[0]; dt = tlist[1] - tlist[0]; if not np.allclose(np.diff(tlist), dt*np.ones(N-1,dtype=float)):; raise Exception('tlist must be equally spaced for FFT.'). if inverse:; F = N * scipy.fftpack.ifft(y); else:; F = scipy.fftpack.fft(y). # calculate the frequencies for the components in F; f = scipy.fftpack.fftfreq(N, dt). # re-order frequencies from most negative to most positive (cent",MatchSource.WIKI,docs/4.7/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/correlation.html
https://qutip.org/docs/4.7/modules/qutip/correlation.html:16483,Energy Efficiency,power,power,16483,"py's pinv method,; otherwise use a generic solver. Returns; -------; spectrum : array; An array with spectrum :math:`S(\omega)` for the frequencies; specified in `wlist`. """""". if debug:; print(inspect.stack()[0][3]). if solver == ""es"":; return _spectrum_es(H, wlist, c_ops, a_op, b_op); elif solver == ""pi"":; return _spectrum_pi(H, wlist, c_ops, a_op, b_op, use_pinv); else:; raise ValueError(""Unrecognized choice of solver"" +; ""%s (use es or pi)."" % solver). [docs]def spectrum_correlation_fft(tlist, y, inverse=False):; """"""; Calculate the power spectrum corresponding to a two-time correlation; function using FFT. Parameters; ----------; tlist : array_like; list/array of times :math:`t` which the correlation function is given.; y : array_like; list/array of correlations corresponding to time delays :math:`t`.; inverse: boolean; boolean parameter for using a positive exponent in the Fourier Transform instead. Default is False. Returns; -------; w, S : tuple; Returns an array of angular frequencies 'w' and the corresponding; two-sided power spectrum 'S(w)'. """""". if debug:; print(inspect.stack()[0][3]); tlist = np.asarray(tlist); N = tlist.shape[0]; dt = tlist[1] - tlist[0]; if not np.allclose(np.diff(tlist), dt*np.ones(N-1,dtype=float)):; raise Exception('tlist must be equally spaced for FFT.'). if inverse:; F = N * scipy.fftpack.ifft(y); else:; F = scipy.fftpack.fft(y). # calculate the frequencies for the components in F; f = scipy.fftpack.fftfreq(N, dt). # re-order frequencies from most negative to most positive (centre on 0); idx = np.array([], dtype = 'int'); idx = np.append(idx, np.where(f < 0.0)); idx = np.append(idx, np.where(f >= 0.0)). return 2 * np.pi * f[idx], 2 * dt * np.real(F[idx]). # -----------------------------------------------------------------------------; # LEGACY API; # -----------------------------------------------------------------------------. # low level correlation. [docs]def correlation_ss(H, taulist, c_ops, a_op, b_op,; solver=""me"", reverse=Fa",MatchSource.WIKI,docs/4.7/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/correlation.html
https://qutip.org/docs/4.7/modules/qutip/correlation.html:2090,Integrability,depend,dependent,2090,"ate import rhs_clear, _td_wrap_array_str; from qutip.cy.utilities import _cython_build_cleanup; from qutip.settings import debug; from qutip.solver import Options, config; from qutip.steadystate import steadystate; from qutip.states import ket2dm; from qutip.superoperator import liouvillian, spre, mat2vec; from qutip.tensor import tensor. if debug:; import inspect. # -----------------------------------------------------------------------------; # PUBLIC API; # -----------------------------------------------------------------------------. # low level correlation. [docs]def correlation_2op_1t(H, state0, taulist, c_ops, a_op, b_op,; solver=""me"", reverse=False, args={},; options=Options(ntraj=[20, 100])):; r""""""; Calculate the two-operator two-time correlation function:; :math:`\left<A(t+\tau)B(t)\right>`; along one time axis using the quantum regression theorem and the evolution; solver indicated by the `solver` parameter. Parameters; ----------. H : Qobj; system Hamiltonian, may be time-dependent for solver choice of `me` or; `mc`.; state0 : Qobj; Initial state density matrix :math:`\rho(t_0)` or state vector; :math:`\psi(t_0)`. If 'state0' is 'None', then the steady state will; be used as the initial state. The 'steady-state' is only implemented; for the `me` and `es` solvers.; taulist : array_like; list of times for :math:`\tau`. taulist must be positive and contain; the element `0`.; c_ops : list; list of collapse operators, may be time-dependent for solver choice of; `me` or `mc`.; a_op : Qobj; operator A.; b_op : Qobj; operator B.; reverse : bool {False, True}; If `True`, calculate :math:`\left<A(t)B(t+\tau)\right>` instead of; :math:`\left<A(t+\tau)B(t)\right>`.; solver : str {'me', 'mc', 'es'}; choice of solver (`me` for master-equation, `mc` for Monte Carlo, and; `es` for exponential series).; options : Options; Solver options class. `ntraj` is taken as a two-element list because; the `mc` correlator calls `mcsolve()` recursively; by default,; `ntraj=[20, 100]`",MatchSource.WIKI,docs/4.7/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/correlation.html
https://qutip.org/docs/4.7/modules/qutip/correlation.html:2552,Integrability,depend,dependent,2552,"IC API; # -----------------------------------------------------------------------------. # low level correlation. [docs]def correlation_2op_1t(H, state0, taulist, c_ops, a_op, b_op,; solver=""me"", reverse=False, args={},; options=Options(ntraj=[20, 100])):; r""""""; Calculate the two-operator two-time correlation function:; :math:`\left<A(t+\tau)B(t)\right>`; along one time axis using the quantum regression theorem and the evolution; solver indicated by the `solver` parameter. Parameters; ----------. H : Qobj; system Hamiltonian, may be time-dependent for solver choice of `me` or; `mc`.; state0 : Qobj; Initial state density matrix :math:`\rho(t_0)` or state vector; :math:`\psi(t_0)`. If 'state0' is 'None', then the steady state will; be used as the initial state. The 'steady-state' is only implemented; for the `me` and `es` solvers.; taulist : array_like; list of times for :math:`\tau`. taulist must be positive and contain; the element `0`.; c_ops : list; list of collapse operators, may be time-dependent for solver choice of; `me` or `mc`.; a_op : Qobj; operator A.; b_op : Qobj; operator B.; reverse : bool {False, True}; If `True`, calculate :math:`\left<A(t)B(t+\tau)\right>` instead of; :math:`\left<A(t+\tau)B(t)\right>`.; solver : str {'me', 'mc', 'es'}; choice of solver (`me` for master-equation, `mc` for Monte Carlo, and; `es` for exponential series).; options : Options; Solver options class. `ntraj` is taken as a two-element list because; the `mc` correlator calls `mcsolve()` recursively; by default,; `ntraj=[20, 100]`. `mc_corr_eps` prevents divide-by-zero errors in; the `mc` correlator; by default, `mc_corr_eps=1e-10`. Returns; -------; corr_vec : ndarray; An array of correlation values for the times specified by `taulist`. References; ----------; See, Gardiner, Quantum Noise, Section 5.2. """""". if debug:; print(inspect.stack()[0][3]). if reverse:; A_op = a_op; B_op = b_op; C_op = 1; else:; A_op = 1; B_op = a_op; C_op = b_op. return _correlation_2t(H, state0, [0], ",MatchSource.WIKI,docs/4.7/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/correlation.html
https://qutip.org/docs/4.7/modules/qutip/correlation.html:4066,Integrability,depend,dependent,4066,"vely; by default,; `ntraj=[20, 100]`. `mc_corr_eps` prevents divide-by-zero errors in; the `mc` correlator; by default, `mc_corr_eps=1e-10`. Returns; -------; corr_vec : ndarray; An array of correlation values for the times specified by `taulist`. References; ----------; See, Gardiner, Quantum Noise, Section 5.2. """""". if debug:; print(inspect.stack()[0][3]). if reverse:; A_op = a_op; B_op = b_op; C_op = 1; else:; A_op = 1; B_op = a_op; C_op = b_op. return _correlation_2t(H, state0, [0], taulist, c_ops, A_op, B_op, C_op,; solver=solver, args=args, options=options)[0]. [docs]def correlation_2op_2t(H, state0, tlist, taulist, c_ops, a_op, b_op,; solver=""me"", reverse=False, args={},; options=Options(ntraj=[20, 100])):; r""""""; Calculate the two-operator two-time correlation function:; :math:`\left<A(t+\tau)B(t)\right>`; along two time axes using the quantum regression theorem and the; evolution solver indicated by the `solver` parameter. Parameters; ----------; H : Qobj; system Hamiltonian, may be time-dependent for solver choice of `me` or; `mc`.; state0 : Qobj; Initial state density matrix :math:`\rho_0` or state vector; :math:`\psi_0`. If 'state0' is 'None', then the steady state will; be used as the initial state. The 'steady-state' is only implemented; for the `me` and `es` solvers.; tlist : array_like; list of times for :math:`t`. tlist must be positive and contain the; element `0`. When taking steady-steady correlations only one tlist; value is necessary, i.e. when :math:`t \rightarrow \infty`; here; tlist is automatically set, ignoring user input.; taulist : array_like; list of times for :math:`\tau`. taulist must be positive and contain; the element `0`.; c_ops : list; list of collapse operators, may be time-dependent for solver choice of; `me` or `mc`.; a_op : Qobj; operator A.; b_op : Qobj; operator B.; reverse : bool {False, True}; If `True`, calculate :math:`\left<A(t)B(t+\tau)\right>` instead of; :math:`\left<A(t+\tau)B(t)\right>`.; solver : str; choice of so",MatchSource.WIKI,docs/4.7/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/correlation.html
https://qutip.org/docs/4.7/modules/qutip/correlation.html:4795,Integrability,depend,dependent,4795,"ulate the two-operator two-time correlation function:; :math:`\left<A(t+\tau)B(t)\right>`; along two time axes using the quantum regression theorem and the; evolution solver indicated by the `solver` parameter. Parameters; ----------; H : Qobj; system Hamiltonian, may be time-dependent for solver choice of `me` or; `mc`.; state0 : Qobj; Initial state density matrix :math:`\rho_0` or state vector; :math:`\psi_0`. If 'state0' is 'None', then the steady state will; be used as the initial state. The 'steady-state' is only implemented; for the `me` and `es` solvers.; tlist : array_like; list of times for :math:`t`. tlist must be positive and contain the; element `0`. When taking steady-steady correlations only one tlist; value is necessary, i.e. when :math:`t \rightarrow \infty`; here; tlist is automatically set, ignoring user input.; taulist : array_like; list of times for :math:`\tau`. taulist must be positive and contain; the element `0`.; c_ops : list; list of collapse operators, may be time-dependent for solver choice of; `me` or `mc`.; a_op : Qobj; operator A.; b_op : Qobj; operator B.; reverse : bool {False, True}; If `True`, calculate :math:`\left<A(t)B(t+\tau)\right>` instead of; :math:`\left<A(t+\tau)B(t)\right>`.; solver : str; choice of solver (`me` for master-equation, `mc` for Monte Carlo, and; `es` for exponential series).; options : Options; solver options class. `ntraj` is taken as a two-element list because; the `mc` correlator calls `mcsolve()` recursively; by default,; `ntraj=[20, 100]`. `mc_corr_eps` prevents divide-by-zero errors in; the `mc` correlator; by default, `mc_corr_eps=1e-10`. Returns; -------; corr_mat : ndarray; An 2-dimensional array (matrix) of correlation values for the times; specified by `tlist` (first index) and `taulist` (second index). If; `tlist` is `None`, then a 1-dimensional array of correlation values; is returned instead. References; ----------; See, Gardiner, Quantum Noise, Section 5.2. """""". if debug:; print(inspect.stack()",MatchSource.WIKI,docs/4.7/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/correlation.html
https://qutip.org/docs/4.7/modules/qutip/correlation.html:6703,Integrability,depend,dependent,6703,"nces; ----------; See, Gardiner, Quantum Noise, Section 5.2. """""". if debug:; print(inspect.stack()[0][3]). if tlist is None:; return correlation_2op_1t(H, state0, taulist, c_ops, a_op, b_op,; solver=solver, reverse=reverse, args=args,; options=options); else:; if reverse:; A_op = a_op; B_op = b_op; C_op = 1; else:; A_op = 1; B_op = a_op; C_op = b_op. return _correlation_2t(H, state0, tlist, taulist,; c_ops, A_op, B_op, C_op,; solver=solver, args=args, options=options). [docs]def correlation_3op_1t(H, state0, taulist, c_ops, a_op, b_op, c_op,; solver=""me"", args={},; options=Options(ntraj=[20, 100])):; r""""""; Calculate the three-operator two-time correlation function:; :math:`\left<A(t)B(t+\tau)C(t)\right>`; along one time axis using the quantum regression theorem and the; evolution solver indicated by the `solver` parameter. Note: it is not possibly to calculate a physically meaningful correlation; of this form where :math:`\tau<0`. Parameters; ----------; H : Qobj; system Hamiltonian, may be time-dependent for solver choice of `me` or; `mc`.; rho0 : Qobj; Initial state density matrix :math:`\rho(t_0)` or state vector; :math:`\psi(t_0)`. If 'state0' is 'None', then the steady state will; be used as the initial state. The 'steady-state' is only implemented; for the `me` and `es` solvers.; taulist : array_like; list of times for :math:`\tau`. taulist must be positive and contain; the element `0`.; c_ops : list; list of collapse operators, may be time-dependent for solver choice of; `me` or `mc`.; a_op : Qobj; operator A.; b_op : Qobj; operator B.; c_op : Qobj; operator C.; solver : str; choice of solver (`me` for master-equation, `mc` for Monte Carlo, and; `es` for exponential series).; options : Options; solver options class. `ntraj` is taken as a two-element list because; the `mc` correlator calls `mcsolve()` recursively; by default,; `ntraj=[20, 100]`. `mc_corr_eps` prevents divide-by-zero errors in; the `mc` correlator; by default, `mc_corr_eps=1e-10`. Returns; ----",MatchSource.WIKI,docs/4.7/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/correlation.html
https://qutip.org/docs/4.7/modules/qutip/correlation.html:7163,Integrability,depend,dependent,7163,"ptions). [docs]def correlation_3op_1t(H, state0, taulist, c_ops, a_op, b_op, c_op,; solver=""me"", args={},; options=Options(ntraj=[20, 100])):; r""""""; Calculate the three-operator two-time correlation function:; :math:`\left<A(t)B(t+\tau)C(t)\right>`; along one time axis using the quantum regression theorem and the; evolution solver indicated by the `solver` parameter. Note: it is not possibly to calculate a physically meaningful correlation; of this form where :math:`\tau<0`. Parameters; ----------; H : Qobj; system Hamiltonian, may be time-dependent for solver choice of `me` or; `mc`.; rho0 : Qobj; Initial state density matrix :math:`\rho(t_0)` or state vector; :math:`\psi(t_0)`. If 'state0' is 'None', then the steady state will; be used as the initial state. The 'steady-state' is only implemented; for the `me` and `es` solvers.; taulist : array_like; list of times for :math:`\tau`. taulist must be positive and contain; the element `0`.; c_ops : list; list of collapse operators, may be time-dependent for solver choice of; `me` or `mc`.; a_op : Qobj; operator A.; b_op : Qobj; operator B.; c_op : Qobj; operator C.; solver : str; choice of solver (`me` for master-equation, `mc` for Monte Carlo, and; `es` for exponential series).; options : Options; solver options class. `ntraj` is taken as a two-element list because; the `mc` correlator calls `mcsolve()` recursively; by default,; `ntraj=[20, 100]`. `mc_corr_eps` prevents divide-by-zero errors in; the `mc` correlator; by default, `mc_corr_eps=1e-10`. Returns; -------; corr_vec : array; An array of correlation values for the times specified by `taulist`. References; ----------; See, Gardiner, Quantum Noise, Section 5.2. """""". if debug:; print(inspect.stack()[0][3]). return _correlation_2t(H, state0, [0], taulist, c_ops, a_op, b_op, c_op,; solver=solver, args=args, options=options)[0]. [docs]def correlation_3op_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, c_op,; solver=""me"", args={},; options=Options(ntraj=[20, 100])):;",MatchSource.WIKI,docs/4.7/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/correlation.html
https://qutip.org/docs/4.7/modules/qutip/correlation.html:8562,Integrability,depend,dependent,8562,"ult,; `ntraj=[20, 100]`. `mc_corr_eps` prevents divide-by-zero errors in; the `mc` correlator; by default, `mc_corr_eps=1e-10`. Returns; -------; corr_vec : array; An array of correlation values for the times specified by `taulist`. References; ----------; See, Gardiner, Quantum Noise, Section 5.2. """""". if debug:; print(inspect.stack()[0][3]). return _correlation_2t(H, state0, [0], taulist, c_ops, a_op, b_op, c_op,; solver=solver, args=args, options=options)[0]. [docs]def correlation_3op_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, c_op,; solver=""me"", args={},; options=Options(ntraj=[20, 100])):; r""""""; Calculate the three-operator two-time correlation function:; :math:`\left<A(t)B(t+\tau)C(t)\right>`; along two time axes using the quantum regression theorem and the; evolution solver indicated by the `solver` parameter. Note: it is not possibly to calculate a physically meaningful correlation; of this form where :math:`\tau<0`. Parameters; ----------; H : Qobj; system Hamiltonian, may be time-dependent for solver choice of `me` or; `mc`.; rho0 : Qobj; Initial state density matrix :math:`\rho_0` or state vector; :math:`\psi_0`. If 'state0' is 'None', then the steady state will; be used as the initial state. The 'steady-state' is only implemented; for the `me` and `es` solvers.; tlist : array_like; list of times for :math:`t`. tlist must be positive and contain the; element `0`. When taking steady-steady correlations only one tlist; value is necessary, i.e. when :math:`t \rightarrow \infty`; here; tlist is automatically set, ignoring user input.; taulist : array_like; list of times for :math:`\tau`. taulist must be positive and contain; the element `0`.; c_ops : list; list of collapse operators, may be time-dependent for solver choice of; `me` or `mc`.; a_op : Qobj; operator A.; b_op : Qobj; operator B.; c_op : Qobj; operator C.; solver : str; choice of solver (`me` for master-equation, `mc` for Monte Carlo, and; `es` for exponential series).; options : Options; so",MatchSource.WIKI,docs/4.7/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/correlation.html
https://qutip.org/docs/4.7/modules/qutip/correlation.html:9289,Integrability,depend,dependent,9289,"es using the quantum regression theorem and the; evolution solver indicated by the `solver` parameter. Note: it is not possibly to calculate a physically meaningful correlation; of this form where :math:`\tau<0`. Parameters; ----------; H : Qobj; system Hamiltonian, may be time-dependent for solver choice of `me` or; `mc`.; rho0 : Qobj; Initial state density matrix :math:`\rho_0` or state vector; :math:`\psi_0`. If 'state0' is 'None', then the steady state will; be used as the initial state. The 'steady-state' is only implemented; for the `me` and `es` solvers.; tlist : array_like; list of times for :math:`t`. tlist must be positive and contain the; element `0`. When taking steady-steady correlations only one tlist; value is necessary, i.e. when :math:`t \rightarrow \infty`; here; tlist is automatically set, ignoring user input.; taulist : array_like; list of times for :math:`\tau`. taulist must be positive and contain; the element `0`.; c_ops : list; list of collapse operators, may be time-dependent for solver choice of; `me` or `mc`.; a_op : Qobj; operator A.; b_op : Qobj; operator B.; c_op : Qobj; operator C.; solver : str; choice of solver (`me` for master-equation, `mc` for Monte Carlo, and; `es` for exponential series).; options : Options; solver options class. `ntraj` is taken as a two-element list because; the `mc` correlator calls `mcsolve()` recursively; by default,; `ntraj=[20, 100]`. `mc_corr_eps` prevents divide-by-zero errors in; the `mc` correlator; by default, `mc_corr_eps=1e-10`. Returns; -------; corr_mat : array; An 2-dimensional array (matrix) of correlation values for the times; specified by `tlist` (first index) and `taulist` (second index). If; `tlist` is `None`, then a 1-dimensional array of correlation values; is returned instead. References; ----------. See, Gardiner, Quantum Noise, Section 5.2. """""". if debug:; print(inspect.stack()[0][3]). if tlist is None:; return correlation_3op_1t(H, state0, taulist, c_ops, a_op, b_op, c_op,; solver=solv",MatchSource.WIKI,docs/4.7/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/correlation.html
https://qutip.org/docs/4.7/modules/qutip/correlation.html:10985,Integrability,depend,dependent,10985," If; `tlist` is `None`, then a 1-dimensional array of correlation values; is returned instead. References; ----------. See, Gardiner, Quantum Noise, Section 5.2. """""". if debug:; print(inspect.stack()[0][3]). if tlist is None:; return correlation_3op_1t(H, state0, taulist, c_ops, a_op, b_op, c_op,; solver=solver, args=args, options=options); else:; return _correlation_2t(H, state0, tlist, taulist,; c_ops, a_op, b_op, c_op,; solver=solver, args=args, options=options). # high level correlation. [docs]def coherence_function_g1(H, state0, taulist, c_ops, a_op, solver=""me"",; args={}, options=Options(ntraj=[20, 100])):; r""""""; Calculate the normalized first-order quantum coherence function:. .. math::. g^{(1)}(\tau) =; \frac{\langle A^\dagger(\tau)A(0)\rangle}; {\sqrt{\langle A^\dagger(\tau)A(\tau)\rangle; \langle A^\dagger(0)A(0)\rangle}}. using the quantum regression theorem and the evolution solver indicated by; the `solver` parameter. Parameters; ----------; H : Qobj; system Hamiltonian, may be time-dependent for solver choice of `me` or; `mc`.; state0 : Qobj; Initial state density matrix :math:`\rho(t_0)` or state vector; :math:`\psi(t_0)`. If 'state0' is 'None', then the steady state will; be used as the initial state. The 'steady-state' is only implemented; for the `me` and `es` solvers.; taulist : array_like; list of times for :math:`\tau`. taulist must be positive and contain; the element `0`.; c_ops : list; list of collapse operators, may be time-dependent for solver choice of; `me` or `mc`.; a_op : Qobj; operator A.; solver : str; choice of solver (`me` for master-equation and; `es` for exponential series).; options : Options; solver options class. `ntraj` is taken as a two-element list because; the `mc` correlator calls `mcsolve()` recursively; by default,; `ntraj=[20, 100]`. `mc_corr_eps` prevents divide-by-zero errors in; the `mc` correlator; by default, `mc_corr_eps=1e-10`. Returns; -------; g1, G1 : tuple; The normalized and unnormalized second-order coheren",MatchSource.WIKI,docs/4.7/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/correlation.html
https://qutip.org/docs/4.7/modules/qutip/correlation.html:11447,Integrability,depend,dependent,11447,"s). # high level correlation. [docs]def coherence_function_g1(H, state0, taulist, c_ops, a_op, solver=""me"",; args={}, options=Options(ntraj=[20, 100])):; r""""""; Calculate the normalized first-order quantum coherence function:. .. math::. g^{(1)}(\tau) =; \frac{\langle A^\dagger(\tau)A(0)\rangle}; {\sqrt{\langle A^\dagger(\tau)A(\tau)\rangle; \langle A^\dagger(0)A(0)\rangle}}. using the quantum regression theorem and the evolution solver indicated by; the `solver` parameter. Parameters; ----------; H : Qobj; system Hamiltonian, may be time-dependent for solver choice of `me` or; `mc`.; state0 : Qobj; Initial state density matrix :math:`\rho(t_0)` or state vector; :math:`\psi(t_0)`. If 'state0' is 'None', then the steady state will; be used as the initial state. The 'steady-state' is only implemented; for the `me` and `es` solvers.; taulist : array_like; list of times for :math:`\tau`. taulist must be positive and contain; the element `0`.; c_ops : list; list of collapse operators, may be time-dependent for solver choice of; `me` or `mc`.; a_op : Qobj; operator A.; solver : str; choice of solver (`me` for master-equation and; `es` for exponential series).; options : Options; solver options class. `ntraj` is taken as a two-element list because; the `mc` correlator calls `mcsolve()` recursively; by default,; `ntraj=[20, 100]`. `mc_corr_eps` prevents divide-by-zero errors in; the `mc` correlator; by default, `mc_corr_eps=1e-10`. Returns; -------; g1, G1 : tuple; The normalized and unnormalized second-order coherence function. """""". # first calculate the photon number; if state0 is None:; state0 = steadystate(H, c_ops); n = np.array([expect(state0, a_op.dag() * a_op)]); else:; n = mesolve(H, state0, taulist, c_ops, [a_op.dag() * a_op],; options=options).expect[0]. # calculate the correlation function G1 and normalize with n to obtain g1; G1 = correlation_2op_1t(H, state0, taulist, c_ops, a_op.dag(), a_op,; solver=solver, args=args, options=options); g1 = G1 / np.sqrt(n[0] * ",MatchSource.WIKI,docs/4.7/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/correlation.html
https://qutip.org/docs/4.7/modules/qutip/correlation.html:12988,Integrability,depend,dependent,12988,"function. """""". # first calculate the photon number; if state0 is None:; state0 = steadystate(H, c_ops); n = np.array([expect(state0, a_op.dag() * a_op)]); else:; n = mesolve(H, state0, taulist, c_ops, [a_op.dag() * a_op],; options=options).expect[0]. # calculate the correlation function G1 and normalize with n to obtain g1; G1 = correlation_2op_1t(H, state0, taulist, c_ops, a_op.dag(), a_op,; solver=solver, args=args, options=options); g1 = G1 / np.sqrt(n[0] * n). return g1, G1. [docs]def coherence_function_g2(H, state0, taulist, c_ops, a_op, solver=""me"", args={},; options=Options(ntraj=[20, 100])):; r""""""; Calculate the normalized second-order quantum coherence function:. .. math::. g^{(2)}(\tau) =; \frac{\langle A^\dagger(0)A^\dagger(\tau)A(\tau)A(0)\rangle}; {\langle A^\dagger(\tau)A(\tau)\rangle; \langle A^\dagger(0)A(0)\rangle}. using the quantum regression theorem and the evolution solver indicated by; the `solver` parameter. Parameters; ----------; H : Qobj; system Hamiltonian, may be time-dependent for solver choice of `me` or; `mc`.; state0 : Qobj; Initial state density matrix :math:`\rho(t_0)` or state vector; :math:`\psi(t_0)`. If 'state0' is 'None', then the steady state will; be used as the initial state. The 'steady-state' is only implemented; for the `me` and `es` solvers.; taulist : array_like; list of times for :math:`\tau`. taulist must be positive and contain; the element `0`.; c_ops : list; list of collapse operators, may be time-dependent for solver choice of; `me` or `mc`.; a_op : Qobj; operator A.; args : dict; Dictionary of arguments to be passed to solver.; solver : str; choice of solver (`me` for master-equation and; `es` for exponential series).; options : Options; solver options class. `ntraj` is taken as a two-element list because; the `mc` correlator calls `mcsolve()` recursively; by default,; `ntraj=[20, 100]`. `mc_corr_eps` prevents divide-by-zero errors in; the `mc` correlator; by default, `mc_corr_eps=1e-10`. Returns; -------; g2, G2",MatchSource.WIKI,docs/4.7/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/correlation.html
https://qutip.org/docs/4.7/modules/qutip/correlation.html:13450,Integrability,depend,dependent,13450,". return g1, G1. [docs]def coherence_function_g2(H, state0, taulist, c_ops, a_op, solver=""me"", args={},; options=Options(ntraj=[20, 100])):; r""""""; Calculate the normalized second-order quantum coherence function:. .. math::. g^{(2)}(\tau) =; \frac{\langle A^\dagger(0)A^\dagger(\tau)A(\tau)A(0)\rangle}; {\langle A^\dagger(\tau)A(\tau)\rangle; \langle A^\dagger(0)A(0)\rangle}. using the quantum regression theorem and the evolution solver indicated by; the `solver` parameter. Parameters; ----------; H : Qobj; system Hamiltonian, may be time-dependent for solver choice of `me` or; `mc`.; state0 : Qobj; Initial state density matrix :math:`\rho(t_0)` or state vector; :math:`\psi(t_0)`. If 'state0' is 'None', then the steady state will; be used as the initial state. The 'steady-state' is only implemented; for the `me` and `es` solvers.; taulist : array_like; list of times for :math:`\tau`. taulist must be positive and contain; the element `0`.; c_ops : list; list of collapse operators, may be time-dependent for solver choice of; `me` or `mc`.; a_op : Qobj; operator A.; args : dict; Dictionary of arguments to be passed to solver.; solver : str; choice of solver (`me` for master-equation and; `es` for exponential series).; options : Options; solver options class. `ntraj` is taken as a two-element list because; the `mc` correlator calls `mcsolve()` recursively; by default,; `ntraj=[20, 100]`. `mc_corr_eps` prevents divide-by-zero errors in; the `mc` correlator; by default, `mc_corr_eps=1e-10`. Returns; -------; g2, G2 : tuple; The normalized and unnormalized second-order coherence function. """""". # first calculate the photon number; if state0 is None:; state0 = steadystate(H, c_ops); n = np.array([expect(state0, a_op.dag() * a_op)]); else:; n = mesolve(H, state0, taulist, c_ops, [a_op.dag() * a_op], args=args).expect[0]. # calculate the correlation function G2 and normalize with n to obtain g2; G2 = correlation_3op_1t(H, state0, taulist, c_ops,; a_op.dag(), a_op.dag()*a_op, a_o",MatchSource.WIKI,docs/4.7/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/correlation.html
https://qutip.org/docs/4.7/modules/qutip/correlation.html:19449,Integrability,depend,dependent,19449,"100]`. `mc_corr_eps` prevents divide-by-zero errors in; the `mc` correlator; by default, `mc_corr_eps=1e-10`. Returns; -------. corr_vec : array; An array of correlation values for the times specified by `tlist`. References; ----------. See, Gardiner, Quantum Noise, Section 5.2. """""". warn(""correlation_ss() now legacy, please use correlation_2op_1t() with"" +; ""initial state as None"", FutureWarning). if debug:; print(inspect.stack()[0][3]). return correlation_2op_1t(H, None, taulist, c_ops, a_op, b_op,; solver=solver, reverse=reverse, args=args,; options=options). [docs]def correlation(H, state0, tlist, taulist, c_ops, a_op, b_op,; solver=""me"", reverse=False, args={},; options=Options(ntraj=[20, 100])):; r""""""; Calculate the two-operator two-time correlation function:; :math:`\left<A(t+\tau)B(t)\right>`; along two time axes using the quantum regression theorem and the; evolution solver indicated by the `solver` parameter. Parameters; ----------. H : Qobj; system Hamiltonian, may be time-dependent for solver choice of `me` or; `mc`. state0 : Qobj; Initial state density matrix :math:`\rho(t_0)` or state vector; :math:`\psi(t_0)`. If 'state0' is 'None', then the steady state will; be used as the initial state. The 'steady-state' is only implemented; for the `me` and `es` solvers. tlist : array_like; list of times for :math:`t`. tlist must be positive and contain the; element `0`. When taking steady-steady correlations only one tlist; value is necessary, i.e. when :math:`t \rightarrow \infty`; here; tlist is automatically set, ignoring user input. taulist : array_like; list of times for :math:`\tau`. taulist must be positive and contain; the element `0`. c_ops : list; list of collapse operators, may be time-dependent for solver choice of; `me` or `mc`. a_op : Qobj; operator A. b_op : Qobj; operator B. reverse : *bool*; If `True`, calculate :math:`\left<A(t)B(t+\tau)\right>` instead of; :math:`\left<A(t+\tau)B(t)\right>`. solver : str; choice of solver (`me` for master-equa",MatchSource.WIKI,docs/4.7/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/correlation.html
https://qutip.org/docs/4.7/modules/qutip/correlation.html:20180,Integrability,depend,dependent,20180,"te the two-operator two-time correlation function:; :math:`\left<A(t+\tau)B(t)\right>`; along two time axes using the quantum regression theorem and the; evolution solver indicated by the `solver` parameter. Parameters; ----------. H : Qobj; system Hamiltonian, may be time-dependent for solver choice of `me` or; `mc`. state0 : Qobj; Initial state density matrix :math:`\rho(t_0)` or state vector; :math:`\psi(t_0)`. If 'state0' is 'None', then the steady state will; be used as the initial state. The 'steady-state' is only implemented; for the `me` and `es` solvers. tlist : array_like; list of times for :math:`t`. tlist must be positive and contain the; element `0`. When taking steady-steady correlations only one tlist; value is necessary, i.e. when :math:`t \rightarrow \infty`; here; tlist is automatically set, ignoring user input. taulist : array_like; list of times for :math:`\tau`. taulist must be positive and contain; the element `0`. c_ops : list; list of collapse operators, may be time-dependent for solver choice of; `me` or `mc`. a_op : Qobj; operator A. b_op : Qobj; operator B. reverse : *bool*; If `True`, calculate :math:`\left<A(t)B(t+\tau)\right>` instead of; :math:`\left<A(t+\tau)B(t)\right>`. solver : str; choice of solver (`me` for master-equation, `mc` for Monte Carlo, and; `es` for exponential series). options : Options; solver options class. `ntraj` is taken as a two-element list because; the `mc` correlator calls `mcsolve()` recursively; by default,; `ntraj=[20, 100]`. `mc_corr_eps` prevents divide-by-zero errors in; the `mc` correlator; by default, `mc_corr_eps=1e-10`. Returns; -------. corr_mat : array; An 2-dimensional array (matrix) of correlation values for the times; specified by `tlist` (first index) and `taulist` (second index). If; `tlist` is `None`, then a 1-dimensional array of correlation values; is returned instead. References; ----------. See, Gardiner, Quantum Noise, Section 5.2. """""". warn(""correlation() now legacy, please use correlat",MatchSource.WIKI,docs/4.7/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/correlation.html
https://qutip.org/docs/4.7/modules/qutip/correlation.html:21934,Integrability,depend,dependent,21934,"dex) and `taulist` (second index). If; `tlist` is `None`, then a 1-dimensional array of correlation values; is returned instead. References; ----------. See, Gardiner, Quantum Noise, Section 5.2. """""". warn(""correlation() now legacy, please use correlation_2op_2t()"",; FutureWarning). if debug:; print(inspect.stack()[0][3]). return correlation_2op_2t(H, state0, tlist, taulist, c_ops, a_op, b_op,; solver=solver, reverse=reverse, args=args,; options=options). [docs]def correlation_4op_1t(H, state0, taulist, c_ops, a_op, b_op, c_op, d_op,; solver=""me"", args={},; options=Options(ntraj=[20, 100])):; r""""""; Calculate the four-operator two-time correlation function:; :math:`\left<A(t)B(t+\tau)C(t+\tau)D(t)\right>`; along one time axis using the quantum regression theorem and the; evolution solver indicated by the `solver` parameter. Note: it is not possibly to calculate a physically meaningful correlation; of this form where :math:`\tau<0`. Parameters; ----------; H : Qobj; system Hamiltonian, may be time-dependent for solver choice of `me` or; `mc`.; rho0 : Qobj; Initial state density matrix :math:`\rho(t_0)` or state vector; :math:`\psi(t_0)`. If 'state0' is 'None', then the steady state will; be used as the initial state. The 'steady-state' is only implemented; for the `me` and `es` solvers.; taulist : array_like; list of times for :math:`\tau`. taulist must be positive and contain; the element `0`.; c_ops : list; list of collapse operators, may be time-dependent for solver choice of; `me` or `mc`. a_op : Qobj; operator A. b_op : Qobj; operator B. c_op : Qobj; operator C. d_op : Qobj; operator D. solver : str; choice of solver (`me` for master-equation, `mc` for Monte Carlo, and; `es` for exponential series). options : Options; solver options class. `ntraj` is taken as a two-element list because; the `mc` correlator calls `mcsolve()` recursively; by default,; `ntraj=[20, 100]`. `mc_corr_eps` prevents divide-by-zero errors in; the `mc` correlator; by default, `mc_corr_eps=1",MatchSource.WIKI,docs/4.7/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/correlation.html
https://qutip.org/docs/4.7/modules/qutip/correlation.html:22394,Integrability,depend,dependent,22394,"]def correlation_4op_1t(H, state0, taulist, c_ops, a_op, b_op, c_op, d_op,; solver=""me"", args={},; options=Options(ntraj=[20, 100])):; r""""""; Calculate the four-operator two-time correlation function:; :math:`\left<A(t)B(t+\tau)C(t+\tau)D(t)\right>`; along one time axis using the quantum regression theorem and the; evolution solver indicated by the `solver` parameter. Note: it is not possibly to calculate a physically meaningful correlation; of this form where :math:`\tau<0`. Parameters; ----------; H : Qobj; system Hamiltonian, may be time-dependent for solver choice of `me` or; `mc`.; rho0 : Qobj; Initial state density matrix :math:`\rho(t_0)` or state vector; :math:`\psi(t_0)`. If 'state0' is 'None', then the steady state will; be used as the initial state. The 'steady-state' is only implemented; for the `me` and `es` solvers.; taulist : array_like; list of times for :math:`\tau`. taulist must be positive and contain; the element `0`.; c_ops : list; list of collapse operators, may be time-dependent for solver choice of; `me` or `mc`. a_op : Qobj; operator A. b_op : Qobj; operator B. c_op : Qobj; operator C. d_op : Qobj; operator D. solver : str; choice of solver (`me` for master-equation, `mc` for Monte Carlo, and; `es` for exponential series). options : Options; solver options class. `ntraj` is taken as a two-element list because; the `mc` correlator calls `mcsolve()` recursively; by default,; `ntraj=[20, 100]`. `mc_corr_eps` prevents divide-by-zero errors in; the `mc` correlator; by default, `mc_corr_eps=1e-10`. Returns; -------; corr_vec : array; An array of correlation values for the times specified by `taulist`. References; ----------; See, Gardiner, Quantum Noise, Section 5.2. .. note:: Deprecated in QuTiP 3.1; Use correlation_3op_1t() instead. """""". warn(""correlation_4op_1t() now legacy, please use correlation_3op_1t()"",; FutureWarning); warn(""the reverse argument has been removed as it did not contain any"" +; ""new physical information"", DeprecationWarning). ",MatchSource.WIKI,docs/4.7/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/correlation.html
https://qutip.org/docs/4.7/modules/qutip/correlation.html:24112,Integrability,depend,dependent,24112,"eprecated in QuTiP 3.1; Use correlation_3op_1t() instead. """""". warn(""correlation_4op_1t() now legacy, please use correlation_3op_1t()"",; FutureWarning); warn(""the reverse argument has been removed as it did not contain any"" +; ""new physical information"", DeprecationWarning). if debug:; print(inspect.stack()[0][3]). return correlation_3op_1t(H, state0, taulist, c_ops,; a_op, b_op * c_op, d_op,; solver=solver, args=args, options=options). [docs]def correlation_4op_2t(H, state0, tlist, taulist, c_ops,; a_op, b_op, c_op, d_op, solver=""me"", args={},; options=Options(ntraj=[20, 100])):; r""""""; Calculate the four-operator two-time correlation function:; :math:`\left<A(t)B(t+\tau)C(t+\tau)D(t)\right>`; along two time axes using the quantum regression theorem and the; evolution solver indicated by the `solver` parameter. Note: it is not possibly to calculate a physically meaningful correlation; of this form where :math:`\tau<0`. Parameters; ----------. H : Qobj; system Hamiltonian, may be time-dependent for solver choice of `me` or; `mc`. rho0 : Qobj; Initial state density matrix :math:`\rho_0` or state vector; :math:`\psi_0`. If 'state0' is 'None', then the steady state will; be used as the initial state. The 'steady-state' is only implemented; for the `me` and `es` solvers. tlist : array_like; list of times for :math:`t`. tlist must be positive and contain the; element `0`. When taking steady-steady correlations only one tlist; value is necessary, i.e. when :math:`t \rightarrow \infty`; here; tlist is automatically set, ignoring user input. taulist : array_like; list of times for :math:`\tau`. taulist must be positive and contain; the element `0`. c_ops : list; list of collapse operators, may be time-dependent for solver choice of; `me` or `mc`. a_op : Qobj; operator A. b_op : Qobj; operator B. c_op : Qobj; operator C. d_op : Qobj; operator D. solver : str; choice of solver (`me` for master-equation, `mc` for Monte Carlo, and; `es` for exponential series). options : Options",MatchSource.WIKI,docs/4.7/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/correlation.html
https://qutip.org/docs/4.7/modules/qutip/correlation.html:24835,Integrability,depend,dependent,24835," axes using the quantum regression theorem and the; evolution solver indicated by the `solver` parameter. Note: it is not possibly to calculate a physically meaningful correlation; of this form where :math:`\tau<0`. Parameters; ----------. H : Qobj; system Hamiltonian, may be time-dependent for solver choice of `me` or; `mc`. rho0 : Qobj; Initial state density matrix :math:`\rho_0` or state vector; :math:`\psi_0`. If 'state0' is 'None', then the steady state will; be used as the initial state. The 'steady-state' is only implemented; for the `me` and `es` solvers. tlist : array_like; list of times for :math:`t`. tlist must be positive and contain the; element `0`. When taking steady-steady correlations only one tlist; value is necessary, i.e. when :math:`t \rightarrow \infty`; here; tlist is automatically set, ignoring user input. taulist : array_like; list of times for :math:`\tau`. taulist must be positive and contain; the element `0`. c_ops : list; list of collapse operators, may be time-dependent for solver choice of; `me` or `mc`. a_op : Qobj; operator A. b_op : Qobj; operator B. c_op : Qobj; operator C. d_op : Qobj; operator D. solver : str; choice of solver (`me` for master-equation, `mc` for Monte Carlo, and; `es` for exponential series). options : Options; solver options class. `ntraj` is taken as a two-element list because; the `mc` correlator calls `mcsolve()` recursively; by default,; `ntraj=[20, 100]`. `mc_corr_eps` prevents divide-by-zero errors in; the `mc` correlator; by default, `mc_corr_eps=1e-10`. Returns; -------. corr_mat : array; An 2-dimensional array (matrix) of correlation values for the times; specified by `tlist` (first index) and `taulist` (second index). If; `tlist` is `None`, then a 1-dimensional array of correlation values; is returned instead. References; ----------. See, Gardiner, Quantum Noise, Section 5.2. """""". warn(""correlation_4op_2t() now legacy, please use correlation_3op_2t()"",; FutureWarning); warn(""the reverse argument has be",MatchSource.WIKI,docs/4.7/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/correlation.html
https://qutip.org/docs/4.7/modules/qutip/correlation.html:1255,Modifiability,config,config,1255,"uTiP: Quantum Toolbox in Python. »; Module code »; qutip.correlation. Source code for qutip.correlation; __all__ = ['correlation_2op_1t', 'correlation_2op_2t', 'correlation_3op_1t',; 'correlation_3op_2t', 'coherence_function_g1',; 'coherence_function_g2', 'spectrum', 'spectrum_correlation_fft',; 'correlation_ss', 'correlation', 'correlation_4op_1t',; 'correlation_4op_2t', 'spectrum_ss', 'spectrum_pi']. from re import sub; from warnings import warn; import warnings; import types. import numpy as np; import scipy.fftpack. from qutip.eseries import esval, esspec; from qutip.essolve import ode2es; from qutip.expect import expect; from qutip.mesolve import mesolve; from qutip.mcsolve import mcsolve; from qutip.operators import qeye; from qutip.qobj import Qobj, isket, issuper; from qutip.qobjevo import QobjEvo; from qutip.rhs_generate import rhs_clear, _td_wrap_array_str; from qutip.cy.utilities import _cython_build_cleanup; from qutip.settings import debug; from qutip.solver import Options, config; from qutip.steadystate import steadystate; from qutip.states import ket2dm; from qutip.superoperator import liouvillian, spre, mat2vec; from qutip.tensor import tensor. if debug:; import inspect. # -----------------------------------------------------------------------------; # PUBLIC API; # -----------------------------------------------------------------------------. # low level correlation. [docs]def correlation_2op_1t(H, state0, taulist, c_ops, a_op, b_op,; solver=""me"", reverse=False, args={},; options=Options(ntraj=[20, 100])):; r""""""; Calculate the two-operator two-time correlation function:; :math:`\left<A(t+\tau)B(t)\right>`; along one time axis using the quantum regression theorem and the evolution; solver indicated by the `solver` parameter. Parameters; ----------. H : Qobj; system Hamiltonian, may be time-dependent for solver choice of `me` or; `mc`.; state0 : Qobj; Initial state density matrix :math:`\rho(t_0)` or state vector; :math:`\psi(t_0)`. If 'state0' is 'No",MatchSource.WIKI,docs/4.7/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/correlation.html
https://qutip.org/docs/4.7/modules/qutip/correlation.html:29253,Modifiability,config,config,29253,", c_ops, a_op, b_op,; solver=""pi"", use_pinv=use_pinv). # -----------------------------------------------------------------------------; # PRIVATE SOLVER METHODS; # -----------------------------------------------------------------------------. # master 2t correlation solver. def _correlation_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, c_op,; solver=""me"", args={}, options=Options()):; """"""; Internal function for calling solvers in order to calculate the; three-operator two-time correlation function:; <A(t)B(t+tau)C(t)>; """""". # Note: the current form of the correlator is sufficient for all possible; # two-time correlations (incuding those with 2ops vs 3). Ex: to compute a; # correlation of the form <A(t+tau)B(t)>: a_op = identity, b_op = A,; # and c_op = B. if debug:; print(inspect.stack()[0][3]). if min(tlist) != 0:; raise TypeError(""tlist must be positive and contain the element 0.""); if min(taulist) != 0:; raise TypeError(""taulist must be positive and contain the element 0.""). if config.tdname:; _cython_build_cleanup(config.tdname); rhs_clear(); H, c_ops, args = _td_wrap_array_str(H, c_ops, args, tlist). if solver == ""me"":; return _correlation_me_2t(H, state0, tlist, taulist,; c_ops, a_op, b_op, c_op,; args=args, options=options); elif solver == ""mc"":; return _correlation_mc_2t(H, state0, tlist, taulist,; c_ops, a_op, b_op, c_op,; args=args, options=options); elif solver == ""es"":; return _correlation_es_2t(H, state0, tlist, taulist,; c_ops, a_op, b_op, c_op); else:; raise ValueError(""Unrecognized choice of solver"" +; ""%s (use me, mc, or es)."" % solver). # master equation solvers. def _correlation_me_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, c_op,; args={}, options=Options()):; """"""; Internal function for calculating the three-operator two-time; correlation function:; <A(t)B(t+tau)C(t)>; using a master equation solver.; """""". # the solvers only work for positive time differences and the correlators; # require positive tau; if state0 is None:; rho0 = steadysta",MatchSource.WIKI,docs/4.7/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/correlation.html
https://qutip.org/docs/4.7/modules/qutip/correlation.html:29291,Modifiability,config,config,29291,"ver=""pi"", use_pinv=use_pinv). # -----------------------------------------------------------------------------; # PRIVATE SOLVER METHODS; # -----------------------------------------------------------------------------. # master 2t correlation solver. def _correlation_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, c_op,; solver=""me"", args={}, options=Options()):; """"""; Internal function for calling solvers in order to calculate the; three-operator two-time correlation function:; <A(t)B(t+tau)C(t)>; """""". # Note: the current form of the correlator is sufficient for all possible; # two-time correlations (incuding those with 2ops vs 3). Ex: to compute a; # correlation of the form <A(t+tau)B(t)>: a_op = identity, b_op = A,; # and c_op = B. if debug:; print(inspect.stack()[0][3]). if min(tlist) != 0:; raise TypeError(""tlist must be positive and contain the element 0.""); if min(taulist) != 0:; raise TypeError(""taulist must be positive and contain the element 0.""). if config.tdname:; _cython_build_cleanup(config.tdname); rhs_clear(); H, c_ops, args = _td_wrap_array_str(H, c_ops, args, tlist). if solver == ""me"":; return _correlation_me_2t(H, state0, tlist, taulist,; c_ops, a_op, b_op, c_op,; args=args, options=options); elif solver == ""mc"":; return _correlation_mc_2t(H, state0, tlist, taulist,; c_ops, a_op, b_op, c_op,; args=args, options=options); elif solver == ""es"":; return _correlation_es_2t(H, state0, tlist, taulist,; c_ops, a_op, b_op, c_op); else:; raise ValueError(""Unrecognized choice of solver"" +; ""%s (use me, mc, or es)."" % solver). # master equation solvers. def _correlation_me_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, c_op,; args={}, options=Options()):; """"""; Internal function for calculating the three-operator two-time; correlation function:; <A(t)B(t+tau)C(t)>; using a master equation solver.; """""". # the solvers only work for positive time differences and the correlators; # require positive tau; if state0 is None:; rho0 = steadystate(H, c_ops); tlist = [0",MatchSource.WIKI,docs/4.7/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/correlation.html
https://qutip.org/docs/4.7/modules/qutip/correlation.html:30575,Modifiability,config,config,30575,"tlist, taulist,; c_ops, a_op, b_op, c_op,; args=args, options=options); elif solver == ""es"":; return _correlation_es_2t(H, state0, tlist, taulist,; c_ops, a_op, b_op, c_op); else:; raise ValueError(""Unrecognized choice of solver"" +; ""%s (use me, mc, or es)."" % solver). # master equation solvers. def _correlation_me_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, c_op,; args={}, options=Options()):; """"""; Internal function for calculating the three-operator two-time; correlation function:; <A(t)B(t+tau)C(t)>; using a master equation solver.; """""". # the solvers only work for positive time differences and the correlators; # require positive tau; if state0 is None:; rho0 = steadystate(H, c_ops); tlist = [0]; elif isket(state0):; rho0 = ket2dm(state0); else:; rho0 = state0. if debug:; print(inspect.stack()[0][3]). rho_t = mesolve(H, rho0, tlist, c_ops, [],; args=args, options=options).states; corr_mat = np.zeros([np.size(tlist), np.size(taulist)], dtype=complex); taulist = np.asarray(taulist); if config.tdname:; _cython_build_cleanup(config.tdname); rhs_clear(). for t_idx, rho in enumerate(rho_t):; corr_mat[t_idx, :] = mesolve(; H, c_op * rho * a_op, taulist + tlist[t_idx], c_ops,; [b_op], args=args, options=options; ).expect[0]. if t_idx == 1:; options.rhs_reuse = True. if config.tdname:; _cython_build_cleanup(config.tdname); rhs_clear(). return corr_mat. # exponential series solvers. def _correlation_es_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, c_op):; """"""; Internal function for calculating the three-operator two-time; correlation function:; <A(t)B(t+tau)C(t)>; using an exponential series solver.; """""". # the solvers only work for positive time differences and the correlators; # require positive tau; if state0 is None:; rho0 = steadystate(H, c_ops); tlist = [0]; elif isket(state0):; rho0 = ket2dm(state0); else:; rho0 = state0. if debug:; print(inspect.stack()[0][3]). # contruct the Liouvillian; L = liouvillian(H, c_ops). corr_mat = np.zeros([np.size(tlist), np.si",MatchSource.WIKI,docs/4.7/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/correlation.html
https://qutip.org/docs/4.7/modules/qutip/correlation.html:30613,Modifiability,config,config,30613,"p, c_op,; args=args, options=options); elif solver == ""es"":; return _correlation_es_2t(H, state0, tlist, taulist,; c_ops, a_op, b_op, c_op); else:; raise ValueError(""Unrecognized choice of solver"" +; ""%s (use me, mc, or es)."" % solver). # master equation solvers. def _correlation_me_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, c_op,; args={}, options=Options()):; """"""; Internal function for calculating the three-operator two-time; correlation function:; <A(t)B(t+tau)C(t)>; using a master equation solver.; """""". # the solvers only work for positive time differences and the correlators; # require positive tau; if state0 is None:; rho0 = steadystate(H, c_ops); tlist = [0]; elif isket(state0):; rho0 = ket2dm(state0); else:; rho0 = state0. if debug:; print(inspect.stack()[0][3]). rho_t = mesolve(H, rho0, tlist, c_ops, [],; args=args, options=options).states; corr_mat = np.zeros([np.size(tlist), np.size(taulist)], dtype=complex); taulist = np.asarray(taulist); if config.tdname:; _cython_build_cleanup(config.tdname); rhs_clear(). for t_idx, rho in enumerate(rho_t):; corr_mat[t_idx, :] = mesolve(; H, c_op * rho * a_op, taulist + tlist[t_idx], c_ops,; [b_op], args=args, options=options; ).expect[0]. if t_idx == 1:; options.rhs_reuse = True. if config.tdname:; _cython_build_cleanup(config.tdname); rhs_clear(). return corr_mat. # exponential series solvers. def _correlation_es_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, c_op):; """"""; Internal function for calculating the three-operator two-time; correlation function:; <A(t)B(t+tau)C(t)>; using an exponential series solver.; """""". # the solvers only work for positive time differences and the correlators; # require positive tau; if state0 is None:; rho0 = steadystate(H, c_ops); tlist = [0]; elif isket(state0):; rho0 = ket2dm(state0); else:; rho0 = state0. if debug:; print(inspect.stack()[0][3]). # contruct the Liouvillian; L = liouvillian(H, c_ops). corr_mat = np.zeros([np.size(tlist), np.size(taulist)], dtype=complex). # T",MatchSource.WIKI,docs/4.7/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/correlation.html
https://qutip.org/docs/4.7/modules/qutip/correlation.html:30858,Modifiability,config,config,30858,"vers. def _correlation_me_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, c_op,; args={}, options=Options()):; """"""; Internal function for calculating the three-operator two-time; correlation function:; <A(t)B(t+tau)C(t)>; using a master equation solver.; """""". # the solvers only work for positive time differences and the correlators; # require positive tau; if state0 is None:; rho0 = steadystate(H, c_ops); tlist = [0]; elif isket(state0):; rho0 = ket2dm(state0); else:; rho0 = state0. if debug:; print(inspect.stack()[0][3]). rho_t = mesolve(H, rho0, tlist, c_ops, [],; args=args, options=options).states; corr_mat = np.zeros([np.size(tlist), np.size(taulist)], dtype=complex); taulist = np.asarray(taulist); if config.tdname:; _cython_build_cleanup(config.tdname); rhs_clear(). for t_idx, rho in enumerate(rho_t):; corr_mat[t_idx, :] = mesolve(; H, c_op * rho * a_op, taulist + tlist[t_idx], c_ops,; [b_op], args=args, options=options; ).expect[0]. if t_idx == 1:; options.rhs_reuse = True. if config.tdname:; _cython_build_cleanup(config.tdname); rhs_clear(). return corr_mat. # exponential series solvers. def _correlation_es_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, c_op):; """"""; Internal function for calculating the three-operator two-time; correlation function:; <A(t)B(t+tau)C(t)>; using an exponential series solver.; """""". # the solvers only work for positive time differences and the correlators; # require positive tau; if state0 is None:; rho0 = steadystate(H, c_ops); tlist = [0]; elif isket(state0):; rho0 = ket2dm(state0); else:; rho0 = state0. if debug:; print(inspect.stack()[0][3]). # contruct the Liouvillian; L = liouvillian(H, c_ops). corr_mat = np.zeros([np.size(tlist), np.size(taulist)], dtype=complex). # The user-facing eseries and ode2es are deprecated from QuTiP 4.6, pending; # removal in QuTiP 5.0, however they are being maintained for internal use; # in correlation, so should not raise warnings to the user not matter what; # their settings.; with warnings.",MatchSource.WIKI,docs/4.7/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/correlation.html
https://qutip.org/docs/4.7/modules/qutip/correlation.html:30896,Modifiability,config,config,30896,"_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, c_op,; args={}, options=Options()):; """"""; Internal function for calculating the three-operator two-time; correlation function:; <A(t)B(t+tau)C(t)>; using a master equation solver.; """""". # the solvers only work for positive time differences and the correlators; # require positive tau; if state0 is None:; rho0 = steadystate(H, c_ops); tlist = [0]; elif isket(state0):; rho0 = ket2dm(state0); else:; rho0 = state0. if debug:; print(inspect.stack()[0][3]). rho_t = mesolve(H, rho0, tlist, c_ops, [],; args=args, options=options).states; corr_mat = np.zeros([np.size(tlist), np.size(taulist)], dtype=complex); taulist = np.asarray(taulist); if config.tdname:; _cython_build_cleanup(config.tdname); rhs_clear(). for t_idx, rho in enumerate(rho_t):; corr_mat[t_idx, :] = mesolve(; H, c_op * rho * a_op, taulist + tlist[t_idx], c_ops,; [b_op], args=args, options=options; ).expect[0]. if t_idx == 1:; options.rhs_reuse = True. if config.tdname:; _cython_build_cleanup(config.tdname); rhs_clear(). return corr_mat. # exponential series solvers. def _correlation_es_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, c_op):; """"""; Internal function for calculating the three-operator two-time; correlation function:; <A(t)B(t+tau)C(t)>; using an exponential series solver.; """""". # the solvers only work for positive time differences and the correlators; # require positive tau; if state0 is None:; rho0 = steadystate(H, c_ops); tlist = [0]; elif isket(state0):; rho0 = ket2dm(state0); else:; rho0 = state0. if debug:; print(inspect.stack()[0][3]). # contruct the Liouvillian; L = liouvillian(H, c_ops). corr_mat = np.zeros([np.size(tlist), np.size(taulist)], dtype=complex). # The user-facing eseries and ode2es are deprecated from QuTiP 4.6, pending; # removal in QuTiP 5.0, however they are being maintained for internal use; # in correlation, so should not raise warnings to the user not matter what; # their settings.; with warnings.catch_warnings():; warni",MatchSource.WIKI,docs/4.7/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/correlation.html
https://qutip.org/docs/4.7/modules/qutip/correlation.html:34276,Modifiability,config,config,34276,"ist). # Monte Carlo solvers. def _correlation_mc_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, c_op,; args={}, options=Options()):; """"""; Internal function for calculating the three-operator two-time; correlation function:; <A(t)B(t+tau)C(t)>; using a Monte Carlo solver.; """""". if not c_ops:; raise TypeError(""If no collapse operators are required, use the `me`"" +; ""or `es` solvers""). # the solvers only work for positive time differences and the correlators; # require positive tau; if state0 is None:; raise NotImplementedError(""steady state not implemented for "" +; ""mc solver, please use `es` or `me`""); elif not isket(state0):; raise TypeError(""state0 must be a state vector.""); psi0 = state0. if debug:; print(inspect.stack()[0][3]). psi_t_mat = mcsolve(; H, psi0, tlist, c_ops, [],; args=args, ntraj=options.ntraj[0], options=options, progress_bar=None; ).states. corr_mat = np.zeros([np.size(tlist), np.size(taulist)], dtype=complex); tlist = np.asarray(tlist); taulist = np.asarray(taulist); if config.tdname:; _cython_build_cleanup(config.tdname); rhs_clear(). # calculation of <A(t)B(t+tau)C(t)> from only knowledge of psi0 requires; # averaging over both t and tau; for t_idx in range(np.size(tlist)):; for trial_idx in range(options.ntraj[0]):; if isinstance(a_op, Qobj) and isinstance(c_op, Qobj):; if a_op.dag() == c_op:; # A shortcut here, requires only 1/4 the trials; chi_0 = (options.mc_corr_eps + c_op) * \; psi_t_mat[trial_idx, t_idx]. # evolve these states and calculate expectation value of B; c_tau = chi_0.norm()**2 * mcsolve(; H, chi_0/chi_0.norm(), taulist + tlist[t_idx], c_ops,; [b_op],; args=args, ntraj=options.ntraj[1], options=options,; progress_bar=None; ).expect[0]. # final correlation vector computed by combining the; # averages; corr_mat[t_idx, :] += c_tau/options.ntraj[1]; else:; # otherwise, need four trial wavefunctions; # (Ad+C)*psi_t, (Ad+iC)*psi_t, (Ad-C)*psi_t, (Ad-iC)*psi_t; if isinstance(a_op, Qobj):; a_op_dag = a_op.dag(); else:; # assume this ",MatchSource.WIKI,docs/4.7/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/correlation.html
https://qutip.org/docs/4.7/modules/qutip/correlation.html:34314,Modifiability,config,config,34314,"_correlation_mc_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, c_op,; args={}, options=Options()):; """"""; Internal function for calculating the three-operator two-time; correlation function:; <A(t)B(t+tau)C(t)>; using a Monte Carlo solver.; """""". if not c_ops:; raise TypeError(""If no collapse operators are required, use the `me`"" +; ""or `es` solvers""). # the solvers only work for positive time differences and the correlators; # require positive tau; if state0 is None:; raise NotImplementedError(""steady state not implemented for "" +; ""mc solver, please use `es` or `me`""); elif not isket(state0):; raise TypeError(""state0 must be a state vector.""); psi0 = state0. if debug:; print(inspect.stack()[0][3]). psi_t_mat = mcsolve(; H, psi0, tlist, c_ops, [],; args=args, ntraj=options.ntraj[0], options=options, progress_bar=None; ).states. corr_mat = np.zeros([np.size(tlist), np.size(taulist)], dtype=complex); tlist = np.asarray(tlist); taulist = np.asarray(taulist); if config.tdname:; _cython_build_cleanup(config.tdname); rhs_clear(). # calculation of <A(t)B(t+tau)C(t)> from only knowledge of psi0 requires; # averaging over both t and tau; for t_idx in range(np.size(tlist)):; for trial_idx in range(options.ntraj[0]):; if isinstance(a_op, Qobj) and isinstance(c_op, Qobj):; if a_op.dag() == c_op:; # A shortcut here, requires only 1/4 the trials; chi_0 = (options.mc_corr_eps + c_op) * \; psi_t_mat[trial_idx, t_idx]. # evolve these states and calculate expectation value of B; c_tau = chi_0.norm()**2 * mcsolve(; H, chi_0/chi_0.norm(), taulist + tlist[t_idx], c_ops,; [b_op],; args=args, ntraj=options.ntraj[1], options=options,; progress_bar=None; ).expect[0]. # final correlation vector computed by combining the; # averages; corr_mat[t_idx, :] += c_tau/options.ntraj[1]; else:; # otherwise, need four trial wavefunctions; # (Ad+C)*psi_t, (Ad+iC)*psi_t, (Ad-C)*psi_t, (Ad-iC)*psi_t; if isinstance(a_op, Qobj):; a_op_dag = a_op.dag(); else:; # assume this is a number, ex. i.e. a_op = 1; #",MatchSource.WIKI,docs/4.7/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/correlation.html
https://qutip.org/docs/4.7/modules/qutip/correlation.html:34731,Modifiability,evolve,evolve,34731," is None:; raise NotImplementedError(""steady state not implemented for "" +; ""mc solver, please use `es` or `me`""); elif not isket(state0):; raise TypeError(""state0 must be a state vector.""); psi0 = state0. if debug:; print(inspect.stack()[0][3]). psi_t_mat = mcsolve(; H, psi0, tlist, c_ops, [],; args=args, ntraj=options.ntraj[0], options=options, progress_bar=None; ).states. corr_mat = np.zeros([np.size(tlist), np.size(taulist)], dtype=complex); tlist = np.asarray(tlist); taulist = np.asarray(taulist); if config.tdname:; _cython_build_cleanup(config.tdname); rhs_clear(). # calculation of <A(t)B(t+tau)C(t)> from only knowledge of psi0 requires; # averaging over both t and tau; for t_idx in range(np.size(tlist)):; for trial_idx in range(options.ntraj[0]):; if isinstance(a_op, Qobj) and isinstance(c_op, Qobj):; if a_op.dag() == c_op:; # A shortcut here, requires only 1/4 the trials; chi_0 = (options.mc_corr_eps + c_op) * \; psi_t_mat[trial_idx, t_idx]. # evolve these states and calculate expectation value of B; c_tau = chi_0.norm()**2 * mcsolve(; H, chi_0/chi_0.norm(), taulist + tlist[t_idx], c_ops,; [b_op],; args=args, ntraj=options.ntraj[1], options=options,; progress_bar=None; ).expect[0]. # final correlation vector computed by combining the; # averages; corr_mat[t_idx, :] += c_tau/options.ntraj[1]; else:; # otherwise, need four trial wavefunctions; # (Ad+C)*psi_t, (Ad+iC)*psi_t, (Ad-C)*psi_t, (Ad-iC)*psi_t; if isinstance(a_op, Qobj):; a_op_dag = a_op.dag(); else:; # assume this is a number, ex. i.e. a_op = 1; # if this is not correct, the over-loaded addition; # operation will raise errors; a_op_dag = a_op; chi_0 = [(options.mc_corr_eps + a_op_dag +; np.exp(1j*x*np.pi/2)*c_op) *; psi_t_mat[trial_idx, t_idx]; for x in range(4)]. # evolve these states and calculate expectation value of B; c_tau = [; chi.norm()**2 * mcsolve(; H, chi/chi.norm(), taulist + tlist[t_idx], c_ops,; [b_op],; args=args, ntraj=options.ntraj[1], options=options,; progress_bar=None; ).expect[0]; ",MatchSource.WIKI,docs/4.7/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/correlation.html
https://qutip.org/docs/4.7/modules/qutip/correlation.html:35526,Modifiability,evolve,evolve,35526,"sinstance(c_op, Qobj):; if a_op.dag() == c_op:; # A shortcut here, requires only 1/4 the trials; chi_0 = (options.mc_corr_eps + c_op) * \; psi_t_mat[trial_idx, t_idx]. # evolve these states and calculate expectation value of B; c_tau = chi_0.norm()**2 * mcsolve(; H, chi_0/chi_0.norm(), taulist + tlist[t_idx], c_ops,; [b_op],; args=args, ntraj=options.ntraj[1], options=options,; progress_bar=None; ).expect[0]. # final correlation vector computed by combining the; # averages; corr_mat[t_idx, :] += c_tau/options.ntraj[1]; else:; # otherwise, need four trial wavefunctions; # (Ad+C)*psi_t, (Ad+iC)*psi_t, (Ad-C)*psi_t, (Ad-iC)*psi_t; if isinstance(a_op, Qobj):; a_op_dag = a_op.dag(); else:; # assume this is a number, ex. i.e. a_op = 1; # if this is not correct, the over-loaded addition; # operation will raise errors; a_op_dag = a_op; chi_0 = [(options.mc_corr_eps + a_op_dag +; np.exp(1j*x*np.pi/2)*c_op) *; psi_t_mat[trial_idx, t_idx]; for x in range(4)]. # evolve these states and calculate expectation value of B; c_tau = [; chi.norm()**2 * mcsolve(; H, chi/chi.norm(), taulist + tlist[t_idx], c_ops,; [b_op],; args=args, ntraj=options.ntraj[1], options=options,; progress_bar=None; ).expect[0]; for chi in chi_0; ]. # final correlation vector computed by combining the averages; corr_mat_add = np.asarray(; 1.0 / (4*options.ntraj[0]) *; (c_tau[0] - c_tau[2] - 1j*c_tau[1] + 1j*c_tau[3]),; dtype=corr_mat.dtype; ); corr_mat[t_idx, :] += corr_mat_add. if t_idx == 1:; options.rhs_reuse = True. if config.tdname:; _cython_build_cleanup(config.tdname); rhs_clear(). return corr_mat. # pseudo-inverse solvers; def _spectrum_pi(H, wlist, c_ops, a_op, b_op, use_pinv=False):; r""""""; Internal function for calculating the spectrum of the correlation function; :math:`\left<A(\tau)B(0)\right>`.; """""". L = H if issuper(H) else liouvillian(H, c_ops). tr_mat = tensor([qeye(n) for n in L.dims[0][0]]); N = np.prod(L.dims[0][0]). A = L.full(); b = spre(b_op).full(); a = spre(a_op).full(). tr_vec = np.tr",MatchSource.WIKI,docs/4.7/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/correlation.html
https://qutip.org/docs/4.7/modules/qutip/correlation.html:36066,Modifiability,config,config,36066,"/options.ntraj[1]; else:; # otherwise, need four trial wavefunctions; # (Ad+C)*psi_t, (Ad+iC)*psi_t, (Ad-C)*psi_t, (Ad-iC)*psi_t; if isinstance(a_op, Qobj):; a_op_dag = a_op.dag(); else:; # assume this is a number, ex. i.e. a_op = 1; # if this is not correct, the over-loaded addition; # operation will raise errors; a_op_dag = a_op; chi_0 = [(options.mc_corr_eps + a_op_dag +; np.exp(1j*x*np.pi/2)*c_op) *; psi_t_mat[trial_idx, t_idx]; for x in range(4)]. # evolve these states and calculate expectation value of B; c_tau = [; chi.norm()**2 * mcsolve(; H, chi/chi.norm(), taulist + tlist[t_idx], c_ops,; [b_op],; args=args, ntraj=options.ntraj[1], options=options,; progress_bar=None; ).expect[0]; for chi in chi_0; ]. # final correlation vector computed by combining the averages; corr_mat_add = np.asarray(; 1.0 / (4*options.ntraj[0]) *; (c_tau[0] - c_tau[2] - 1j*c_tau[1] + 1j*c_tau[3]),; dtype=corr_mat.dtype; ); corr_mat[t_idx, :] += corr_mat_add. if t_idx == 1:; options.rhs_reuse = True. if config.tdname:; _cython_build_cleanup(config.tdname); rhs_clear(). return corr_mat. # pseudo-inverse solvers; def _spectrum_pi(H, wlist, c_ops, a_op, b_op, use_pinv=False):; r""""""; Internal function for calculating the spectrum of the correlation function; :math:`\left<A(\tau)B(0)\right>`.; """""". L = H if issuper(H) else liouvillian(H, c_ops). tr_mat = tensor([qeye(n) for n in L.dims[0][0]]); N = np.prod(L.dims[0][0]). A = L.full(); b = spre(b_op).full(); a = spre(a_op).full(). tr_vec = np.transpose(mat2vec(tr_mat.full())). rho_ss = steadystate(L); rho = np.transpose(mat2vec(rho_ss.full())). I = np.identity(N * N); P = np.kron(np.transpose(rho), tr_vec); Q = I - P. spectrum = np.zeros(len(wlist)). for idx, w in enumerate(wlist):; if use_pinv:; MMR = np.linalg.pinv(-1.0j * w * I + A); else:; MMR = np.dot(Q, np.linalg.solve(-1.0j * w * I + A, Q)). s = np.dot(tr_vec,; np.dot(a, np.dot(MMR, np.dot(b, np.transpose(rho))))); spectrum[idx] = -2 * np.real(s[0, 0]). return spectrum. © Copyright 201",MatchSource.WIKI,docs/4.7/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/correlation.html
https://qutip.org/docs/4.7/modules/qutip/correlation.html:36104,Modifiability,config,config,36104," # otherwise, need four trial wavefunctions; # (Ad+C)*psi_t, (Ad+iC)*psi_t, (Ad-C)*psi_t, (Ad-iC)*psi_t; if isinstance(a_op, Qobj):; a_op_dag = a_op.dag(); else:; # assume this is a number, ex. i.e. a_op = 1; # if this is not correct, the over-loaded addition; # operation will raise errors; a_op_dag = a_op; chi_0 = [(options.mc_corr_eps + a_op_dag +; np.exp(1j*x*np.pi/2)*c_op) *; psi_t_mat[trial_idx, t_idx]; for x in range(4)]. # evolve these states and calculate expectation value of B; c_tau = [; chi.norm()**2 * mcsolve(; H, chi/chi.norm(), taulist + tlist[t_idx], c_ops,; [b_op],; args=args, ntraj=options.ntraj[1], options=options,; progress_bar=None; ).expect[0]; for chi in chi_0; ]. # final correlation vector computed by combining the averages; corr_mat_add = np.asarray(; 1.0 / (4*options.ntraj[0]) *; (c_tau[0] - c_tau[2] - 1j*c_tau[1] + 1j*c_tau[3]),; dtype=corr_mat.dtype; ); corr_mat[t_idx, :] += corr_mat_add. if t_idx == 1:; options.rhs_reuse = True. if config.tdname:; _cython_build_cleanup(config.tdname); rhs_clear(). return corr_mat. # pseudo-inverse solvers; def _spectrum_pi(H, wlist, c_ops, a_op, b_op, use_pinv=False):; r""""""; Internal function for calculating the spectrum of the correlation function; :math:`\left<A(\tau)B(0)\right>`.; """""". L = H if issuper(H) else liouvillian(H, c_ops). tr_mat = tensor([qeye(n) for n in L.dims[0][0]]); N = np.prod(L.dims[0][0]). A = L.full(); b = spre(b_op).full(); a = spre(a_op).full(). tr_vec = np.transpose(mat2vec(tr_mat.full())). rho_ss = steadystate(L); rho = np.transpose(mat2vec(rho_ss.full())). I = np.identity(N * N); P = np.kron(np.transpose(rho), tr_vec); Q = I - P. spectrum = np.zeros(len(wlist)). for idx, w in enumerate(wlist):; if use_pinv:; MMR = np.linalg.pinv(-1.0j * w * I + A); else:; MMR = np.dot(Q, np.linalg.solve(-1.0j * w * I + A, Q)). s = np.dot(tr_vec,; np.dot(a, np.dot(MMR, np.dot(b, np.transpose(rho))))); spectrum[idx] = -2 * np.real(s[0, 0]). return spectrum. © Copyright 2011 to 2021 inclusive, QuT",MatchSource.WIKI,docs/4.7/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/correlation.html
https://qutip.org/docs/4.7/modules/qutip/correlation.html:35336,Performance,load,loaded,35336,"on of <A(t)B(t+tau)C(t)> from only knowledge of psi0 requires; # averaging over both t and tau; for t_idx in range(np.size(tlist)):; for trial_idx in range(options.ntraj[0]):; if isinstance(a_op, Qobj) and isinstance(c_op, Qobj):; if a_op.dag() == c_op:; # A shortcut here, requires only 1/4 the trials; chi_0 = (options.mc_corr_eps + c_op) * \; psi_t_mat[trial_idx, t_idx]. # evolve these states and calculate expectation value of B; c_tau = chi_0.norm()**2 * mcsolve(; H, chi_0/chi_0.norm(), taulist + tlist[t_idx], c_ops,; [b_op],; args=args, ntraj=options.ntraj[1], options=options,; progress_bar=None; ).expect[0]. # final correlation vector computed by combining the; # averages; corr_mat[t_idx, :] += c_tau/options.ntraj[1]; else:; # otherwise, need four trial wavefunctions; # (Ad+C)*psi_t, (Ad+iC)*psi_t, (Ad-C)*psi_t, (Ad-iC)*psi_t; if isinstance(a_op, Qobj):; a_op_dag = a_op.dag(); else:; # assume this is a number, ex. i.e. a_op = 1; # if this is not correct, the over-loaded addition; # operation will raise errors; a_op_dag = a_op; chi_0 = [(options.mc_corr_eps + a_op_dag +; np.exp(1j*x*np.pi/2)*c_op) *; psi_t_mat[trial_idx, t_idx]; for x in range(4)]. # evolve these states and calculate expectation value of B; c_tau = [; chi.norm()**2 * mcsolve(; H, chi/chi.norm(), taulist + tlist[t_idx], c_ops,; [b_op],; args=args, ntraj=options.ntraj[1], options=options,; progress_bar=None; ).expect[0]; for chi in chi_0; ]. # final correlation vector computed by combining the averages; corr_mat_add = np.asarray(; 1.0 / (4*options.ntraj[0]) *; (c_tau[0] - c_tau[2] - 1j*c_tau[1] + 1j*c_tau[3]),; dtype=corr_mat.dtype; ); corr_mat[t_idx, :] += corr_mat_add. if t_idx == 1:; options.rhs_reuse = True. if config.tdname:; _cython_build_cleanup(config.tdname); rhs_clear(). return corr_mat. # pseudo-inverse solvers; def _spectrum_pi(H, wlist, c_ops, a_op, b_op, use_pinv=False):; r""""""; Internal function for calculating the spectrum of the correlation function; :math:`\left<A(\tau)B(0)\right>`.",MatchSource.WIKI,docs/4.7/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/correlation.html
https://qutip.org/docs/4.7/modules/qutip/dimensions.html:490,Availability,avail,available,490,". qutip.dimensions — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.dimensions. Source code for qutip.dimensions; """"""; Internal use module for manipulating dims specifications.; """""". __all__ = [] # Everything should be explicitly imported, not made available; # by default. import numpy as np; from operator import getitem; from functools import partial. [docs]def is_scalar(dims):; """"""; Returns True if a dims specification is effectively; a scalar (has dimension 1).; """"""; return np.prod(flatten(dims)) == 1. def is_vector(dims):; return (; isinstance(dims, list) and; isinstance(dims[0], (int, np.integer)); ). def is_vectorized_oper(dims):; return (; isinstance(dims, list) and; isinstance(dims[0], list); ). def type_from_dims(dims, enforce_square=False):; bra_like, ket_like = map(is_scalar, dims). if bra_like:; if is_vector(dims[1]):; return 'bra'; elif is_vectorized_oper(dims[1]):; return 'operator-bra'. if ket_like:; if is_vector(dims[0]):; return 'ket'; elif is_vectorized_oper(dims[0]):; return 'operator-ket'. elif is_vector(dims[0]) and (dims[0] == dims[1] or not enforce_square):; return 'oper'. elif (; is_vectorized_oper(dims[0]) and; (; (; dims[0] == dims[1] and; dims[0][0] == dims[1][0]; ) or not enforce_square; ); ):; return 'super'. return 'other'. [docs]def flatten(l):; """"""Flattens a list of lists to the first level. Given a list containing a mix of scalars and lists,; flattens down to a list of the scalars within the original; list. Examples; --------. >>> flatten([[[0], 1], 2]) # doctest: +SKIP; [0, 1, 2]. """"""; if not isinstance(l, list):; return [l]; else:; return sum(map(flatten, l), []). [docs]def deep_remove(l, *what):; """"""Removes scalars from all levels of a nested list. Given a list containing a mix of scalars and li",MatchSource.WIKI,docs/4.7/modules/qutip/dimensions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/dimensions.html
https://qutip.org/docs/4.7/modules/qutip/dimensions.html:1648,Availability,down,down,1648," a dims specification is effectively; a scalar (has dimension 1).; """"""; return np.prod(flatten(dims)) == 1. def is_vector(dims):; return (; isinstance(dims, list) and; isinstance(dims[0], (int, np.integer)); ). def is_vectorized_oper(dims):; return (; isinstance(dims, list) and; isinstance(dims[0], list); ). def type_from_dims(dims, enforce_square=False):; bra_like, ket_like = map(is_scalar, dims). if bra_like:; if is_vector(dims[1]):; return 'bra'; elif is_vectorized_oper(dims[1]):; return 'operator-bra'. if ket_like:; if is_vector(dims[0]):; return 'ket'; elif is_vectorized_oper(dims[0]):; return 'operator-ket'. elif is_vector(dims[0]) and (dims[0] == dims[1] or not enforce_square):; return 'oper'. elif (; is_vectorized_oper(dims[0]) and; (; (; dims[0] == dims[1] and; dims[0][0] == dims[1][0]; ) or not enforce_square; ); ):; return 'super'. return 'other'. [docs]def flatten(l):; """"""Flattens a list of lists to the first level. Given a list containing a mix of scalars and lists,; flattens down to a list of the scalars within the original; list. Examples; --------. >>> flatten([[[0], 1], 2]) # doctest: +SKIP; [0, 1, 2]. """"""; if not isinstance(l, list):; return [l]; else:; return sum(map(flatten, l), []). [docs]def deep_remove(l, *what):; """"""Removes scalars from all levels of a nested list. Given a list containing a mix of scalars and lists,; returns a list of the same structure, but where one or; more scalars have been removed. Examples; --------. >>> deep_remove([[[[0, 1, 2]], [3, 4], [5], [6, 7]]], 0, 5) # doctest: +SKIP; [[[[1, 2]], [3, 4], [], [6, 7]]]. """"""; if isinstance(l, list):; # Make a shallow copy at this level.; l = l[:]; for to_remove in what:; if to_remove in l:; l.remove(to_remove); else:; l = list(map(lambda elem: deep_remove(elem, to_remove), l)); return l. [docs]def unflatten(l, idxs):; """"""Unflattens a list by a given structure. Given a list of scalars and a deep list of indices; as produced by `flatten`, returns an ""unflattened""; form of the list. T",MatchSource.WIKI,docs/4.7/modules/qutip/dimensions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/dimensions.html
https://qutip.org/docs/4.7/modules/qutip/dimensions.html:9272,Deployability,update,updated,9272,"forming the result to swap; # input and output indices of vectorized matrices, then flattening; # the result. We'll then rebuild indices using this permutation. if dims_type in ('operator-ket', 'super'):; # Swap the input and output spaces of the right part of; # perm.; perm[1] = list(reversed(perm[1])). if dims_type in ('operator-bra', 'super'):; # Ditto, but for the left indices.; perm[0] = list(reversed(perm[0])). return flatten(perm). [docs]def dims_to_tensor_shape(dims):; """"""; Given the dims of a Qobj instance, returns the shape of the; corresponding tensor. This helps, for instance, resolve the; column-stacking convention for superoperators. Parameters; ----------. dims : list; Dimensions specification for a Qobj. Returns; -------. tensor_shape : tuple; NumPy shape of the corresponding tensor.; """""". perm = dims_to_tensor_perm(dims); dims = flatten(dims). return tuple(map(partial(getitem, dims), perm)). [docs]def dims_idxs_to_tensor_idxs(dims, indices):; """"""; Given the dims of a Qobj instance, and some indices into; dims, returns the corresponding tensor indices. This helps; resolve, for instance, that column-stacking for superoperators,; oper-ket and oper-bra implies that the input and output tensor; indices are reversed from their order in dims. Parameters; ----------. dims : list; Dimensions specification for a Qobj. indices : int, list or tuple; Indices to convert to tensor indices. Can be specified; as a single index, or as a collection of indices.; In the latter case, this can be nested arbitrarily; deep. For instance, [0, [0, (2, 3)]]. Returns; -------. tens_indices : int, list or tuple; Container of the same structure as indices containing; the tensor indices for each element of indices.; """""". perm = dims_to_tensor_perm(dims); return deep_map(partial(getitem, perm), indices). © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/modules/qutip/dimensions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/dimensions.html
https://qutip.org/docs/4.7/modules/qutip/distributions.html:6392,Deployability,update,update,6392,"bes the marginal; distribution. """"""; return Distribution(data=self.data.mean(axis=dim),; xvecs=[self.xvecs[dim]],; xlabels=[self.xlabels[dim]]). [docs] def project(self, dim=0):; """"""; Calculate the projection (max value) distribution function along the; dimension `dim`. Return a new Distribution instance describing this; reduced-dimensionality distribution. Parameters; ----------; dim : int; The dimension (coordinate index) along which to obtain the; projected distribution. Returns; -------; d : Distributions; A new instances of Distribution that describes the projection. """"""; return Distribution(data=self.data.max(axis=dim),; xvecs=[self.xvecs[dim]],; xlabels=[self.xlabels[dim]]). [docs]class WignerDistribution(Distribution):. def __init__(self, rho=None, extent=[[-5, 5], [-5, 5]], steps=250):. self.xvecs = [np.linspace(extent[0][0], extent[0][1], steps),; np.linspace(extent[1][0], extent[1][1], steps)]. self.xlabels = [r'$\rm{Re}(\alpha)$', r'$\rm{Im}(\alpha)$']. if rho:; self.update(rho). def update(self, rho):. self.data = wigner(rho, self.xvecs[0], self.xvecs[1]). [docs]class QDistribution(Distribution):. def __init__(self, rho=None, extent=[[-5, 5], [-5, 5]], steps=250):. self.xvecs = [np.linspace(extent[0][0], extent[0][1], steps),; np.linspace(extent[1][0], extent[1][1], steps)]. self.xlabels = [r'$\rm{Re}(\alpha)$', r'$\rm{Im}(\alpha)$']. if rho:; self.update(rho). def update(self, rho):. self.data = qfunc(rho, self.xvecs[0], self.xvecs[1]). [docs]class TwoModeQuadratureCorrelation(Distribution):. def __init__(self, state=None, theta1=0.0, theta2=0.0,; extent=[[-5, 5], [-5, 5]], steps=250):. self.xvecs = [np.linspace(extent[0][0], extent[0][1], steps),; np.linspace(extent[1][0], extent[1][1], steps)]. self.xlabels = [r'$X_1(\theta_1)$', r'$X_2(\theta_2)$']. self.theta1 = theta1; self.theta2 = theta2. self.update(state). [docs] def update(self, state):; """"""; calculate probability distribution for quadrature measurement; outcomes given a two-mode wavefunction",MatchSource.WIKI,docs/4.7/modules/qutip/distributions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/distributions.html
https://qutip.org/docs/4.7/modules/qutip/distributions.html:6409,Deployability,update,update,6409,"distribution. """"""; return Distribution(data=self.data.mean(axis=dim),; xvecs=[self.xvecs[dim]],; xlabels=[self.xlabels[dim]]). [docs] def project(self, dim=0):; """"""; Calculate the projection (max value) distribution function along the; dimension `dim`. Return a new Distribution instance describing this; reduced-dimensionality distribution. Parameters; ----------; dim : int; The dimension (coordinate index) along which to obtain the; projected distribution. Returns; -------; d : Distributions; A new instances of Distribution that describes the projection. """"""; return Distribution(data=self.data.max(axis=dim),; xvecs=[self.xvecs[dim]],; xlabels=[self.xlabels[dim]]). [docs]class WignerDistribution(Distribution):. def __init__(self, rho=None, extent=[[-5, 5], [-5, 5]], steps=250):. self.xvecs = [np.linspace(extent[0][0], extent[0][1], steps),; np.linspace(extent[1][0], extent[1][1], steps)]. self.xlabels = [r'$\rm{Re}(\alpha)$', r'$\rm{Im}(\alpha)$']. if rho:; self.update(rho). def update(self, rho):. self.data = wigner(rho, self.xvecs[0], self.xvecs[1]). [docs]class QDistribution(Distribution):. def __init__(self, rho=None, extent=[[-5, 5], [-5, 5]], steps=250):. self.xvecs = [np.linspace(extent[0][0], extent[0][1], steps),; np.linspace(extent[1][0], extent[1][1], steps)]. self.xlabels = [r'$\rm{Re}(\alpha)$', r'$\rm{Im}(\alpha)$']. if rho:; self.update(rho). def update(self, rho):. self.data = qfunc(rho, self.xvecs[0], self.xvecs[1]). [docs]class TwoModeQuadratureCorrelation(Distribution):. def __init__(self, state=None, theta1=0.0, theta2=0.0,; extent=[[-5, 5], [-5, 5]], steps=250):. self.xvecs = [np.linspace(extent[0][0], extent[0][1], steps),; np.linspace(extent[1][0], extent[1][1], steps)]. self.xlabels = [r'$X_1(\theta_1)$', r'$X_2(\theta_2)$']. self.theta1 = theta1; self.theta2 = theta2. self.update(state). [docs] def update(self, state):; """"""; calculate probability distribution for quadrature measurement; outcomes given a two-mode wavefunction or density matrix",MatchSource.WIKI,docs/4.7/modules/qutip/distributions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/distributions.html
https://qutip.org/docs/4.7/modules/qutip/distributions.html:6782,Deployability,update,update,6782,"int; The dimension (coordinate index) along which to obtain the; projected distribution. Returns; -------; d : Distributions; A new instances of Distribution that describes the projection. """"""; return Distribution(data=self.data.max(axis=dim),; xvecs=[self.xvecs[dim]],; xlabels=[self.xlabels[dim]]). [docs]class WignerDistribution(Distribution):. def __init__(self, rho=None, extent=[[-5, 5], [-5, 5]], steps=250):. self.xvecs = [np.linspace(extent[0][0], extent[0][1], steps),; np.linspace(extent[1][0], extent[1][1], steps)]. self.xlabels = [r'$\rm{Re}(\alpha)$', r'$\rm{Im}(\alpha)$']. if rho:; self.update(rho). def update(self, rho):. self.data = wigner(rho, self.xvecs[0], self.xvecs[1]). [docs]class QDistribution(Distribution):. def __init__(self, rho=None, extent=[[-5, 5], [-5, 5]], steps=250):. self.xvecs = [np.linspace(extent[0][0], extent[0][1], steps),; np.linspace(extent[1][0], extent[1][1], steps)]. self.xlabels = [r'$\rm{Re}(\alpha)$', r'$\rm{Im}(\alpha)$']. if rho:; self.update(rho). def update(self, rho):. self.data = qfunc(rho, self.xvecs[0], self.xvecs[1]). [docs]class TwoModeQuadratureCorrelation(Distribution):. def __init__(self, state=None, theta1=0.0, theta2=0.0,; extent=[[-5, 5], [-5, 5]], steps=250):. self.xvecs = [np.linspace(extent[0][0], extent[0][1], steps),; np.linspace(extent[1][0], extent[1][1], steps)]. self.xlabels = [r'$X_1(\theta_1)$', r'$X_2(\theta_2)$']. self.theta1 = theta1; self.theta2 = theta2. self.update(state). [docs] def update(self, state):; """"""; calculate probability distribution for quadrature measurement; outcomes given a two-mode wavefunction or density matrix; """"""; if isket(state):; self.update_psi(state); else:; self.update_rho(state). [docs] def update_psi(self, psi):; """"""; calculate probability distribution for quadrature measurement; outcomes given a two-mode wavefunction; """""". X1, X2 = np.meshgrid(self.xvecs[0], self.xvecs[1]). p = np.zeros((len(self.xvecs[0]), len(self.xvecs[1])), dtype=complex); N = psi.dims[0][0]. f",MatchSource.WIKI,docs/4.7/modules/qutip/distributions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/distributions.html
https://qutip.org/docs/4.7/modules/qutip/distributions.html:6799,Deployability,update,update,6799," (coordinate index) along which to obtain the; projected distribution. Returns; -------; d : Distributions; A new instances of Distribution that describes the projection. """"""; return Distribution(data=self.data.max(axis=dim),; xvecs=[self.xvecs[dim]],; xlabels=[self.xlabels[dim]]). [docs]class WignerDistribution(Distribution):. def __init__(self, rho=None, extent=[[-5, 5], [-5, 5]], steps=250):. self.xvecs = [np.linspace(extent[0][0], extent[0][1], steps),; np.linspace(extent[1][0], extent[1][1], steps)]. self.xlabels = [r'$\rm{Re}(\alpha)$', r'$\rm{Im}(\alpha)$']. if rho:; self.update(rho). def update(self, rho):. self.data = wigner(rho, self.xvecs[0], self.xvecs[1]). [docs]class QDistribution(Distribution):. def __init__(self, rho=None, extent=[[-5, 5], [-5, 5]], steps=250):. self.xvecs = [np.linspace(extent[0][0], extent[0][1], steps),; np.linspace(extent[1][0], extent[1][1], steps)]. self.xlabels = [r'$\rm{Re}(\alpha)$', r'$\rm{Im}(\alpha)$']. if rho:; self.update(rho). def update(self, rho):. self.data = qfunc(rho, self.xvecs[0], self.xvecs[1]). [docs]class TwoModeQuadratureCorrelation(Distribution):. def __init__(self, state=None, theta1=0.0, theta2=0.0,; extent=[[-5, 5], [-5, 5]], steps=250):. self.xvecs = [np.linspace(extent[0][0], extent[0][1], steps),; np.linspace(extent[1][0], extent[1][1], steps)]. self.xlabels = [r'$X_1(\theta_1)$', r'$X_2(\theta_2)$']. self.theta1 = theta1; self.theta2 = theta2. self.update(state). [docs] def update(self, state):; """"""; calculate probability distribution for quadrature measurement; outcomes given a two-mode wavefunction or density matrix; """"""; if isket(state):; self.update_psi(state); else:; self.update_rho(state). [docs] def update_psi(self, psi):; """"""; calculate probability distribution for quadrature measurement; outcomes given a two-mode wavefunction; """""". X1, X2 = np.meshgrid(self.xvecs[0], self.xvecs[1]). p = np.zeros((len(self.xvecs[0]), len(self.xvecs[1])), dtype=complex); N = psi.dims[0][0]. for n1 in range(N):",MatchSource.WIKI,docs/4.7/modules/qutip/distributions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/distributions.html
https://qutip.org/docs/4.7/modules/qutip/distributions.html:7244,Deployability,update,update,7244,"[0][1], steps),; np.linspace(extent[1][0], extent[1][1], steps)]. self.xlabels = [r'$\rm{Re}(\alpha)$', r'$\rm{Im}(\alpha)$']. if rho:; self.update(rho). def update(self, rho):. self.data = wigner(rho, self.xvecs[0], self.xvecs[1]). [docs]class QDistribution(Distribution):. def __init__(self, rho=None, extent=[[-5, 5], [-5, 5]], steps=250):. self.xvecs = [np.linspace(extent[0][0], extent[0][1], steps),; np.linspace(extent[1][0], extent[1][1], steps)]. self.xlabels = [r'$\rm{Re}(\alpha)$', r'$\rm{Im}(\alpha)$']. if rho:; self.update(rho). def update(self, rho):. self.data = qfunc(rho, self.xvecs[0], self.xvecs[1]). [docs]class TwoModeQuadratureCorrelation(Distribution):. def __init__(self, state=None, theta1=0.0, theta2=0.0,; extent=[[-5, 5], [-5, 5]], steps=250):. self.xvecs = [np.linspace(extent[0][0], extent[0][1], steps),; np.linspace(extent[1][0], extent[1][1], steps)]. self.xlabels = [r'$X_1(\theta_1)$', r'$X_2(\theta_2)$']. self.theta1 = theta1; self.theta2 = theta2. self.update(state). [docs] def update(self, state):; """"""; calculate probability distribution for quadrature measurement; outcomes given a two-mode wavefunction or density matrix; """"""; if isket(state):; self.update_psi(state); else:; self.update_rho(state). [docs] def update_psi(self, psi):; """"""; calculate probability distribution for quadrature measurement; outcomes given a two-mode wavefunction; """""". X1, X2 = np.meshgrid(self.xvecs[0], self.xvecs[1]). p = np.zeros((len(self.xvecs[0]), len(self.xvecs[1])), dtype=complex); N = psi.dims[0][0]. for n1 in range(N):; kn1 = exp(-1j * self.theta1 * n1) / \; sqrt(sqrt(pi) * 2 ** n1 * factorial(n1)) * \; exp(-X1 ** 2 / 2.0) * np.polyval(hermite(n1), X1). for n2 in range(N):; kn2 = exp(-1j * self.theta2 * n2) / \; sqrt(sqrt(pi) * 2 ** n2 * factorial(n2)) * \; exp(-X2 ** 2 / 2.0) * np.polyval(hermite(n2), X2); i = state_number_index([N, N], [n1, n2]); p += kn1 * kn2 * psi.data[i, 0]. self.data = abs(p) ** 2. [docs] def update_rho(self, rho):; """"""; calculate ",MatchSource.WIKI,docs/4.7/modules/qutip/distributions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/distributions.html
https://qutip.org/docs/4.7/modules/qutip/distributions.html:7270,Deployability,update,update,7270,"', r'$\rm{Im}(\alpha)$']. if rho:; self.update(rho). def update(self, rho):. self.data = wigner(rho, self.xvecs[0], self.xvecs[1]). [docs]class QDistribution(Distribution):. def __init__(self, rho=None, extent=[[-5, 5], [-5, 5]], steps=250):. self.xvecs = [np.linspace(extent[0][0], extent[0][1], steps),; np.linspace(extent[1][0], extent[1][1], steps)]. self.xlabels = [r'$\rm{Re}(\alpha)$', r'$\rm{Im}(\alpha)$']. if rho:; self.update(rho). def update(self, rho):. self.data = qfunc(rho, self.xvecs[0], self.xvecs[1]). [docs]class TwoModeQuadratureCorrelation(Distribution):. def __init__(self, state=None, theta1=0.0, theta2=0.0,; extent=[[-5, 5], [-5, 5]], steps=250):. self.xvecs = [np.linspace(extent[0][0], extent[0][1], steps),; np.linspace(extent[1][0], extent[1][1], steps)]. self.xlabels = [r'$X_1(\theta_1)$', r'$X_2(\theta_2)$']. self.theta1 = theta1; self.theta2 = theta2. self.update(state). [docs] def update(self, state):; """"""; calculate probability distribution for quadrature measurement; outcomes given a two-mode wavefunction or density matrix; """"""; if isket(state):; self.update_psi(state); else:; self.update_rho(state). [docs] def update_psi(self, psi):; """"""; calculate probability distribution for quadrature measurement; outcomes given a two-mode wavefunction; """""". X1, X2 = np.meshgrid(self.xvecs[0], self.xvecs[1]). p = np.zeros((len(self.xvecs[0]), len(self.xvecs[1])), dtype=complex); N = psi.dims[0][0]. for n1 in range(N):; kn1 = exp(-1j * self.theta1 * n1) / \; sqrt(sqrt(pi) * 2 ** n1 * factorial(n1)) * \; exp(-X1 ** 2 / 2.0) * np.polyval(hermite(n1), X1). for n2 in range(N):; kn2 = exp(-1j * self.theta2 * n2) / \; sqrt(sqrt(pi) * 2 ** n2 * factorial(n2)) * \; exp(-X2 ** 2 / 2.0) * np.polyval(hermite(n2), X2); i = state_number_index([N, N], [n1, n2]); p += kn1 * kn2 * psi.data[i, 0]. self.data = abs(p) ** 2. [docs] def update_rho(self, rho):; """"""; calculate probability distribution for quadrature measurement; outcomes given a two-mode density matrix; """""". X",MatchSource.WIKI,docs/4.7/modules/qutip/distributions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/distributions.html
https://qutip.org/docs/4.7/modules/qutip/distributions.html:9534,Deployability,update,update,9534,"(self.xvecs[1])), dtype=complex); M2 = np.zeros(; (N, N, len(self.xvecs[0]), len(self.xvecs[1])), dtype=complex). for m in range(N):; for n in range(N):; M1[m, n] = exp(-1j * self.theta1 * (m - n)) / \; sqrt(pi * 2 ** (m + n) * factorial(n) * factorial(m)) * \; exp(-X1 ** 2) * np.polyval(; hermite(m), X1) * np.polyval(hermite(n), X1); M2[m, n] = exp(-1j * self.theta2 * (m - n)) / \; sqrt(pi * 2 ** (m + n) * factorial(n) * factorial(m)) * \; exp(-X2 ** 2) * np.polyval(; hermite(m), X2) * np.polyval(hermite(n), X2). for n1 in range(N):; for n2 in range(N):; i = state_number_index([N, N], [n1, n2]); for p1 in range(N):; for p2 in range(N):; j = state_number_index([N, N], [p1, p2]); p += M1[n1, p1] * M2[n2, p2] * rho.data[i, j]. self.data = p. [docs]class HarmonicOscillatorWaveFunction(Distribution):. def __init__(self, psi=None, omega=1.0, extent=[-5, 5], steps=250):. self.xvecs = [np.linspace(extent[0], extent[1], steps)]; self.xlabels = [r'$x$']; self.omega = omega. if psi:; self.update(psi). [docs] def update(self, psi):; """"""; Calculate the wavefunction for the given state of an harmonic; oscillator; """""". self.data = np.zeros(len(self.xvecs[0]), dtype=complex); N = psi.shape[0]. for n in range(N):; k = pow(self.omega / pi, 0.25) / \; sqrt(2 ** n * factorial(n)) * \; exp(-self.xvecs[0] ** 2 / 2.0) * \; np.polyval(hermite(n), self.xvecs[0]). self.data += k * psi.data[n, 0]. [docs]class HarmonicOscillatorProbabilityFunction(Distribution):. def __init__(self, rho=None, omega=1.0, extent=[-5, 5], steps=250):. self.xvecs = [np.linspace(extent[0], extent[1], steps)]; self.xlabels = [r'$x$']; self.omega = omega. if rho:; self.update(rho). [docs] def update(self, rho):; """"""; Calculate the probability function for the given state of an harmonic; oscillator (as density matrix); """""". if isket(rho):; rho = ket2dm(rho). self.data = np.zeros(len(self.xvecs[0]), dtype=complex); M, N = rho.shape. for m in range(M):; k_m = pow(self.omega / pi, 0.25) / \; sqrt(2 ** m * factorial(m)) *",MatchSource.WIKI,docs/4.7/modules/qutip/distributions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/distributions.html
https://qutip.org/docs/4.7/modules/qutip/distributions.html:9558,Deployability,update,update,9558,"f.xvecs[0]), len(self.xvecs[1])), dtype=complex). for m in range(N):; for n in range(N):; M1[m, n] = exp(-1j * self.theta1 * (m - n)) / \; sqrt(pi * 2 ** (m + n) * factorial(n) * factorial(m)) * \; exp(-X1 ** 2) * np.polyval(; hermite(m), X1) * np.polyval(hermite(n), X1); M2[m, n] = exp(-1j * self.theta2 * (m - n)) / \; sqrt(pi * 2 ** (m + n) * factorial(n) * factorial(m)) * \; exp(-X2 ** 2) * np.polyval(; hermite(m), X2) * np.polyval(hermite(n), X2). for n1 in range(N):; for n2 in range(N):; i = state_number_index([N, N], [n1, n2]); for p1 in range(N):; for p2 in range(N):; j = state_number_index([N, N], [p1, p2]); p += M1[n1, p1] * M2[n2, p2] * rho.data[i, j]. self.data = p. [docs]class HarmonicOscillatorWaveFunction(Distribution):. def __init__(self, psi=None, omega=1.0, extent=[-5, 5], steps=250):. self.xvecs = [np.linspace(extent[0], extent[1], steps)]; self.xlabels = [r'$x$']; self.omega = omega. if psi:; self.update(psi). [docs] def update(self, psi):; """"""; Calculate the wavefunction for the given state of an harmonic; oscillator; """""". self.data = np.zeros(len(self.xvecs[0]), dtype=complex); N = psi.shape[0]. for n in range(N):; k = pow(self.omega / pi, 0.25) / \; sqrt(2 ** n * factorial(n)) * \; exp(-self.xvecs[0] ** 2 / 2.0) * \; np.polyval(hermite(n), self.xvecs[0]). self.data += k * psi.data[n, 0]. [docs]class HarmonicOscillatorProbabilityFunction(Distribution):. def __init__(self, rho=None, omega=1.0, extent=[-5, 5], steps=250):. self.xvecs = [np.linspace(extent[0], extent[1], steps)]; self.xlabels = [r'$x$']; self.omega = omega. if rho:; self.update(rho). [docs] def update(self, rho):; """"""; Calculate the probability function for the given state of an harmonic; oscillator (as density matrix); """""". if isket(rho):; rho = ket2dm(rho). self.data = np.zeros(len(self.xvecs[0]), dtype=complex); M, N = rho.shape. for m in range(M):; k_m = pow(self.omega / pi, 0.25) / \; sqrt(2 ** m * factorial(m)) * \; exp(-self.xvecs[0] ** 2 / 2.0) * \; np.polyval(hermite(m), s",MatchSource.WIKI,docs/4.7/modules/qutip/distributions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/distributions.html
https://qutip.org/docs/4.7/modules/qutip/distributions.html:10186,Deployability,update,update,10186,"e(m), X2) * np.polyval(hermite(n), X2). for n1 in range(N):; for n2 in range(N):; i = state_number_index([N, N], [n1, n2]); for p1 in range(N):; for p2 in range(N):; j = state_number_index([N, N], [p1, p2]); p += M1[n1, p1] * M2[n2, p2] * rho.data[i, j]. self.data = p. [docs]class HarmonicOscillatorWaveFunction(Distribution):. def __init__(self, psi=None, omega=1.0, extent=[-5, 5], steps=250):. self.xvecs = [np.linspace(extent[0], extent[1], steps)]; self.xlabels = [r'$x$']; self.omega = omega. if psi:; self.update(psi). [docs] def update(self, psi):; """"""; Calculate the wavefunction for the given state of an harmonic; oscillator; """""". self.data = np.zeros(len(self.xvecs[0]), dtype=complex); N = psi.shape[0]. for n in range(N):; k = pow(self.omega / pi, 0.25) / \; sqrt(2 ** n * factorial(n)) * \; exp(-self.xvecs[0] ** 2 / 2.0) * \; np.polyval(hermite(n), self.xvecs[0]). self.data += k * psi.data[n, 0]. [docs]class HarmonicOscillatorProbabilityFunction(Distribution):. def __init__(self, rho=None, omega=1.0, extent=[-5, 5], steps=250):. self.xvecs = [np.linspace(extent[0], extent[1], steps)]; self.xlabels = [r'$x$']; self.omega = omega. if rho:; self.update(rho). [docs] def update(self, rho):; """"""; Calculate the probability function for the given state of an harmonic; oscillator (as density matrix); """""". if isket(rho):; rho = ket2dm(rho). self.data = np.zeros(len(self.xvecs[0]), dtype=complex); M, N = rho.shape. for m in range(M):; k_m = pow(self.omega / pi, 0.25) / \; sqrt(2 ** m * factorial(m)) * \; exp(-self.xvecs[0] ** 2 / 2.0) * \; np.polyval(hermite(m), self.xvecs[0]). for n in range(N):; k_n = pow(self.omega / pi, 0.25) / \; sqrt(2 ** n * factorial(n)) * \; exp(-self.xvecs[0] ** 2 / 2.0) * \; np.polyval(hermite(n), self.xvecs[0]). self.data += np.conjugate(k_n) * k_m * rho.data[m, n]. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/modules/qutip/distributions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/distributions.html
https://qutip.org/docs/4.7/modules/qutip/distributions.html:10210,Deployability,update,update,10210,"e(m), X2) * np.polyval(hermite(n), X2). for n1 in range(N):; for n2 in range(N):; i = state_number_index([N, N], [n1, n2]); for p1 in range(N):; for p2 in range(N):; j = state_number_index([N, N], [p1, p2]); p += M1[n1, p1] * M2[n2, p2] * rho.data[i, j]. self.data = p. [docs]class HarmonicOscillatorWaveFunction(Distribution):. def __init__(self, psi=None, omega=1.0, extent=[-5, 5], steps=250):. self.xvecs = [np.linspace(extent[0], extent[1], steps)]; self.xlabels = [r'$x$']; self.omega = omega. if psi:; self.update(psi). [docs] def update(self, psi):; """"""; Calculate the wavefunction for the given state of an harmonic; oscillator; """""". self.data = np.zeros(len(self.xvecs[0]), dtype=complex); N = psi.shape[0]. for n in range(N):; k = pow(self.omega / pi, 0.25) / \; sqrt(2 ** n * factorial(n)) * \; exp(-self.xvecs[0] ** 2 / 2.0) * \; np.polyval(hermite(n), self.xvecs[0]). self.data += k * psi.data[n, 0]. [docs]class HarmonicOscillatorProbabilityFunction(Distribution):. def __init__(self, rho=None, omega=1.0, extent=[-5, 5], steps=250):. self.xvecs = [np.linspace(extent[0], extent[1], steps)]; self.xlabels = [r'$x$']; self.omega = omega. if rho:; self.update(rho). [docs] def update(self, rho):; """"""; Calculate the probability function for the given state of an harmonic; oscillator (as density matrix); """""". if isket(rho):; rho = ket2dm(rho). self.data = np.zeros(len(self.xvecs[0]), dtype=complex); M, N = rho.shape. for m in range(M):; k_m = pow(self.omega / pi, 0.25) / \; sqrt(2 ** m * factorial(m)) * \; exp(-self.xvecs[0] ** 2 / 2.0) * \; np.polyval(hermite(m), self.xvecs[0]). for n in range(N):; k_n = pow(self.omega / pi, 0.25) / \; sqrt(2 ** n * factorial(n)) * \; exp(-self.xvecs[0] ** 2 / 2.0) * \; np.polyval(hermite(n), self.xvecs[0]). self.data += np.conjugate(k_n) * k_m * rho.data[m, n]. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/modules/qutip/distributions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/distributions.html
https://qutip.org/docs/4.7/modules/qutip/distributions.html:10919,Deployability,update,updated,10919,"e(m), X2) * np.polyval(hermite(n), X2). for n1 in range(N):; for n2 in range(N):; i = state_number_index([N, N], [n1, n2]); for p1 in range(N):; for p2 in range(N):; j = state_number_index([N, N], [p1, p2]); p += M1[n1, p1] * M2[n2, p2] * rho.data[i, j]. self.data = p. [docs]class HarmonicOscillatorWaveFunction(Distribution):. def __init__(self, psi=None, omega=1.0, extent=[-5, 5], steps=250):. self.xvecs = [np.linspace(extent[0], extent[1], steps)]; self.xlabels = [r'$x$']; self.omega = omega. if psi:; self.update(psi). [docs] def update(self, psi):; """"""; Calculate the wavefunction for the given state of an harmonic; oscillator; """""". self.data = np.zeros(len(self.xvecs[0]), dtype=complex); N = psi.shape[0]. for n in range(N):; k = pow(self.omega / pi, 0.25) / \; sqrt(2 ** n * factorial(n)) * \; exp(-self.xvecs[0] ** 2 / 2.0) * \; np.polyval(hermite(n), self.xvecs[0]). self.data += k * psi.data[n, 0]. [docs]class HarmonicOscillatorProbabilityFunction(Distribution):. def __init__(self, rho=None, omega=1.0, extent=[-5, 5], steps=250):. self.xvecs = [np.linspace(extent[0], extent[1], steps)]; self.xlabels = [r'$x$']; self.omega = omega. if rho:; self.update(rho). [docs] def update(self, rho):; """"""; Calculate the probability function for the given state of an harmonic; oscillator (as density matrix); """""". if isket(rho):; rho = ket2dm(rho). self.data = np.zeros(len(self.xvecs[0]), dtype=complex); M, N = rho.shape. for m in range(M):; k_m = pow(self.omega / pi, 0.25) / \; sqrt(2 ** m * factorial(m)) * \; exp(-self.xvecs[0] ** 2 / 2.0) * \; np.polyval(hermite(m), self.xvecs[0]). for n in range(N):; k_n = pow(self.omega / pi, 0.25) / \; sqrt(2 ** n * factorial(n)) * \; exp(-self.xvecs[0] ** 2 / 2.0) * \; np.polyval(hermite(n), self.xvecs[0]). self.data += np.conjugate(k_n) * k_m * rho.data[m, n]. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/modules/qutip/distributions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/distributions.html
https://qutip.org/docs/4.7/modules/qutip/distributions.html:5161,Energy Efficiency,reduce,reduced,5161,"igsize); ax = Axes3D(fig, azim=-62, elev=25). if cmap is None:; cmap = mpl.cm.get_cmap('RdBu'). lim = abs(self.data).max(). X, Y = np.meshgrid(self.xvecs[0], self.xvecs[1]); s = ax.plot_surface(X, Y, self.data,; norm=mpl.colors.Normalize(-lim, lim),; rstride=5, cstride=5, cmap=cmap, lw=0.1). if show_xlabel:; ax.set_xlabel(self.xlabels[0], fontsize=12); if show_ylabel:; ax.set_ylabel(self.xlabels[1], fontsize=12). if colorbar:; cb = fig.colorbar(s, ax=ax, shrink=0.5). return fig, ax. def visualize_1d(self, fig=None, ax=None, figsize=(8, 6),; show_xlabel=True, show_ylabel=True):. if not fig and not ax:; fig, ax = plt.subplots(1, 1, figsize=figsize). p = ax.plot(self.xvecs[0], self.data). if show_xlabel:; ax.set_xlabel(self.xlabels[0], fontsize=12); if show_ylabel:; ax.set_ylabel(""Marginal distribution"", fontsize=12). return fig, ax. [docs] def marginal(self, dim=0):; """"""; Calculate the marginal distribution function along the dimension; `dim`. Return a new Distribution instance describing this reduced-; dimensionality distribution. Parameters; ----------; dim : int; The dimension (coordinate index) along which to obtain the; marginal distribution. Returns; -------. d : Distributions; A new instances of Distribution that describes the marginal; distribution. """"""; return Distribution(data=self.data.mean(axis=dim),; xvecs=[self.xvecs[dim]],; xlabels=[self.xlabels[dim]]). [docs] def project(self, dim=0):; """"""; Calculate the projection (max value) distribution function along the; dimension `dim`. Return a new Distribution instance describing this; reduced-dimensionality distribution. Parameters; ----------; dim : int; The dimension (coordinate index) along which to obtain the; projected distribution. Returns; -------; d : Distributions; A new instances of Distribution that describes the projection. """"""; return Distribution(data=self.data.max(axis=dim),; xvecs=[self.xvecs[dim]],; xlabels=[self.xlabels[dim]]). [docs]class WignerDistribution(Distribution):. def __init__(self,",MatchSource.WIKI,docs/4.7/modules/qutip/distributions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/distributions.html
https://qutip.org/docs/4.7/modules/qutip/distributions.html:5721,Energy Efficiency,reduce,reduced-dimensionality,5721,"=True, show_ylabel=True):. if not fig and not ax:; fig, ax = plt.subplots(1, 1, figsize=figsize). p = ax.plot(self.xvecs[0], self.data). if show_xlabel:; ax.set_xlabel(self.xlabels[0], fontsize=12); if show_ylabel:; ax.set_ylabel(""Marginal distribution"", fontsize=12). return fig, ax. [docs] def marginal(self, dim=0):; """"""; Calculate the marginal distribution function along the dimension; `dim`. Return a new Distribution instance describing this reduced-; dimensionality distribution. Parameters; ----------; dim : int; The dimension (coordinate index) along which to obtain the; marginal distribution. Returns; -------. d : Distributions; A new instances of Distribution that describes the marginal; distribution. """"""; return Distribution(data=self.data.mean(axis=dim),; xvecs=[self.xvecs[dim]],; xlabels=[self.xlabels[dim]]). [docs] def project(self, dim=0):; """"""; Calculate the projection (max value) distribution function along the; dimension `dim`. Return a new Distribution instance describing this; reduced-dimensionality distribution. Parameters; ----------; dim : int; The dimension (coordinate index) along which to obtain the; projected distribution. Returns; -------; d : Distributions; A new instances of Distribution that describes the projection. """"""; return Distribution(data=self.data.max(axis=dim),; xvecs=[self.xvecs[dim]],; xlabels=[self.xlabels[dim]]). [docs]class WignerDistribution(Distribution):. def __init__(self, rho=None, extent=[[-5, 5], [-5, 5]], steps=250):. self.xvecs = [np.linspace(extent[0][0], extent[0][1], steps),; np.linspace(extent[1][0], extent[1][1], steps)]. self.xlabels = [r'$\rm{Re}(\alpha)$', r'$\rm{Im}(\alpha)$']. if rho:; self.update(rho). def update(self, rho):. self.data = wigner(rho, self.xvecs[0], self.xvecs[1]). [docs]class QDistribution(Distribution):. def __init__(self, rho=None, extent=[[-5, 5], [-5, 5]], steps=250):. self.xvecs = [np.linspace(extent[0][0], extent[0][1], steps),; np.linspace(extent[1][0], extent[1][1], steps)]. self.x",MatchSource.WIKI,docs/4.7/modules/qutip/distributions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/distributions.html
https://qutip.org/docs/4.7/modules/qutip/distributions.html:2111,Integrability,depend,depending,2111,"cs]class Distribution:; """"""A class for representation spatial distribution functions. The Distribution class can be used to prepresent spatial distribution; functions of arbitray dimension (although only 1D and 2D distributions; are used so far). It is indented as a base class for specific distribution function, and; provide implementation of basic functions that are shared among all; Distribution functions, such as visualization, calculating marginal; distributions, etc. Parameters; ----------; data : array_like; Data for the distribution. The dimensions must match the lengths of; the coordinate arrays in xvecs.; xvecs : list; List of arrays that spans the space for each coordinate.; xlabels : list; List of labels for each coordinate. """""". def __init__(self, data=None, xvecs=[], xlabels=[]):; self.data = data; self.xvecs = xvecs; self.xlabels = xlabels. [docs] def visualize(self, fig=None, ax=None, figsize=(8, 6),; colorbar=True, cmap=None, style=""colormap"",; show_xlabel=True, show_ylabel=True):; """"""; Visualize the data of the distribution in 1D or 2D, depending; on the dimensionality of the underlaying distribution. Parameters:. fig : matplotlib Figure instance; If given, use this figure instance for the visualization,. ax : matplotlib Axes instance; If given, render the visualization using this axis instance. figsize : tuple; Size of the new Figure instance, if one needs to be created. colorbar: Bool; Whether or not the colorbar (in 2D visualization) should be used. cmap: matplotlib colormap instance; If given, use this colormap for 2D visualizations. style : string; Type of visualization: 'colormap' (default) or 'surface'. Returns; -------. fig, ax : tuple; A tuple of matplotlib figure and axes instances. """"""; n = len(self.xvecs); if n == 2:; if style == ""colormap"":; return self.visualize_2d_colormap(fig=fig, ax=ax,; figsize=figsize,; colorbar=colorbar,; cmap=cmap,; show_xlabel=show_xlabel,; show_ylabel=show_ylabel); else:; return self.visualize_2d_surface(fig=fi",MatchSource.WIKI,docs/4.7/modules/qutip/distributions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/distributions.html
https://qutip.org/docs/4.7/modules/qutip/entropy.html:3284,Availability,mask,mask,3284,"ho.dims != [[2, 2], [1, 1]]:; raise Exception(""Ket must be tensor product of two qubits.""). elif rho.isbra and rho.dims != [[1, 1], [2, 2]]:; raise Exception(""Bra must be tensor product of two qubits.""). elif rho.isoper and rho.dims != [[2, 2], [2, 2]]:; raise Exception(""Density matrix must be tensor product of two qubits.""). if rho.isket or rho.isbra:; rho = ket2dm(rho). sysy = tensor(sigmay(), sigmay()). rho_tilde = (rho * sysy) * (rho.conj() * sysy). evals = rho_tilde.eigenenergies(). # abs to avoid problems with sqrt for very small negative numbers; evals = abs(sort(real(evals))). lsum = sqrt(evals[3]) - sqrt(evals[2]) - sqrt(evals[1]) - sqrt(evals[0]). return max(0, lsum). def negativity(rho, subsys, method='tracenorm', logarithmic=False):; """"""; Compute the negativity for a multipartite quantum system described; by the density matrix rho. The subsys argument is an index that; indicates which system to compute the negativity for. .. note::. Experimental.; """"""; mask = [idx == subsys for idx, n in enumerate(rho.dims[0])]; rho_pt = partial_transpose(rho, mask). if method == 'tracenorm':; N = ((rho_pt.dag() * rho_pt).sqrtm().tr().real - 1)/2.0; elif method == 'eigenvalues':; l = rho_pt.eigenenergies(); N = ((abs(l)-l)/2).sum(); else:; raise ValueError(""Unknown method %s"" % method). if logarithmic:; return log2(2 * N + 1); else:; return N. [docs]def entropy_mutual(rho, selA, selB, base=e, sparse=False):; """"""; Calculates the mutual information S(A:B) between selection; components of a system density matrix. Parameters; ----------; rho : qobj; Density matrix for composite quantum systems; selA : int/list; `int` or `list` of first selected density matrix components.; selB : int/list; `int` or `list` of second selected density matrix components.; base : {e,2}; Base of logarithm.; sparse : {False,True}; Use sparse eigensolver. Returns; -------; ent_mut : float; Mutual information between selected components. """"""; if isinstance(selA, int):; selA = [selA]; if isinstance(selB",MatchSource.WIKI,docs/4.7/modules/qutip/entropy.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/entropy.html
https://qutip.org/docs/4.7/modules/qutip/entropy.html:3377,Availability,mask,mask,3377,"st be tensor product of two qubits.""). elif rho.isbra and rho.dims != [[1, 1], [2, 2]]:; raise Exception(""Bra must be tensor product of two qubits.""). elif rho.isoper and rho.dims != [[2, 2], [2, 2]]:; raise Exception(""Density matrix must be tensor product of two qubits.""). if rho.isket or rho.isbra:; rho = ket2dm(rho). sysy = tensor(sigmay(), sigmay()). rho_tilde = (rho * sysy) * (rho.conj() * sysy). evals = rho_tilde.eigenenergies(). # abs to avoid problems with sqrt for very small negative numbers; evals = abs(sort(real(evals))). lsum = sqrt(evals[3]) - sqrt(evals[2]) - sqrt(evals[1]) - sqrt(evals[0]). return max(0, lsum). def negativity(rho, subsys, method='tracenorm', logarithmic=False):; """"""; Compute the negativity for a multipartite quantum system described; by the density matrix rho. The subsys argument is an index that; indicates which system to compute the negativity for. .. note::. Experimental.; """"""; mask = [idx == subsys for idx, n in enumerate(rho.dims[0])]; rho_pt = partial_transpose(rho, mask). if method == 'tracenorm':; N = ((rho_pt.dag() * rho_pt).sqrtm().tr().real - 1)/2.0; elif method == 'eigenvalues':; l = rho_pt.eigenenergies(); N = ((abs(l)-l)/2).sum(); else:; raise ValueError(""Unknown method %s"" % method). if logarithmic:; return log2(2 * N + 1); else:; return N. [docs]def entropy_mutual(rho, selA, selB, base=e, sparse=False):; """"""; Calculates the mutual information S(A:B) between selection; components of a system density matrix. Parameters; ----------; rho : qobj; Density matrix for composite quantum systems; selA : int/list; `int` or `list` of first selected density matrix components.; selB : int/list; `int` or `list` of second selected density matrix components.; base : {e,2}; Base of logarithm.; sparse : {False,True}; Use sparse eigensolver. Returns; -------; ent_mut : float; Mutual information between selected components. """"""; if isinstance(selA, int):; selA = [selA]; if isinstance(selB, int):; selB = [selB]; if rho.type != 'oper':; raise",MatchSource.WIKI,docs/4.7/modules/qutip/entropy.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/entropy.html
https://qutip.org/docs/4.7/modules/qutip/entropy.html:9810,Deployability,update,updated,9810,"omposite object; selB : int/list; Selected components for density matrix B; base : {e,2}; Base of logarithm.; sparse : {False,True}; Use sparse eigensolver. Returns; -------; ent_cond : float; Value of conditional entropy. """"""; if rho.type != 'oper':; raise TypeError(""Input must be density matrix.""); if isinstance(selB, int):; selB = [selB]; B = ptrace(rho, selB); out = (entropy_vn(rho, base, sparse=sparse) -; entropy_vn(B, base, sparse=sparse)); return out. def participation_ratio(rho):; """"""; Returns the effective number of states for a density matrix. The participation is unity for pure states, and maximally N,; where N is the Hilbert space dimensionality, for completely; mixed states. Parameters; ----------; rho : qobj; Density matrix. Returns; -------; pr : float; Effective number of states in the density matrix. """"""; if rho.type == 'ket' or rho.type == 'bra':; return 1.0; else:; return 1.0 / (rho ** 2).tr(). def entangling_power(U):; """"""; Calculate the entangling power of a two-qubit gate U, which; is zero of nonentangling gates and 1 and 2/9 for maximally; entangling gates. Parameters; ----------; U : qobj; Qobj instance representing a two-qubit gate. Returns; -------; ep : float; The entanglement power of U (real number between 0 and 1). References:. Explorations in Quantum Computing, Colin P. Williams (Springer, 2011); """""". if not U.isoper:; raise Exception(""U must be an operator.""). if U.dims != [[2, 2], [2, 2]]:; raise Exception(""U must be a two-qubit gate.""). from qutip.qip.operations.gates import swap; a = (tensor(U, U).dag() * swap(N=4, targets=[1, 3]) *; tensor(U, U) * swap(N=4, targets=[1, 3])); b = (tensor(swap() * U, swap() * U).dag() * swap(N=4, targets=[1, 3]) *; tensor(swap() * U, swap() * U) * swap(N=4, targets=[1, 3])). return 5.0/9 - 1.0/36 * (a.tr() + b.tr()).real. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/modules/qutip/entropy.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/entropy.html
https://qutip.org/docs/4.7/modules/qutip/entropy.html:8894,Energy Efficiency,power,power,8894,"omposite object; selB : int/list; Selected components for density matrix B; base : {e,2}; Base of logarithm.; sparse : {False,True}; Use sparse eigensolver. Returns; -------; ent_cond : float; Value of conditional entropy. """"""; if rho.type != 'oper':; raise TypeError(""Input must be density matrix.""); if isinstance(selB, int):; selB = [selB]; B = ptrace(rho, selB); out = (entropy_vn(rho, base, sparse=sparse) -; entropy_vn(B, base, sparse=sparse)); return out. def participation_ratio(rho):; """"""; Returns the effective number of states for a density matrix. The participation is unity for pure states, and maximally N,; where N is the Hilbert space dimensionality, for completely; mixed states. Parameters; ----------; rho : qobj; Density matrix. Returns; -------; pr : float; Effective number of states in the density matrix. """"""; if rho.type == 'ket' or rho.type == 'bra':; return 1.0; else:; return 1.0 / (rho ** 2).tr(). def entangling_power(U):; """"""; Calculate the entangling power of a two-qubit gate U, which; is zero of nonentangling gates and 1 and 2/9 for maximally; entangling gates. Parameters; ----------; U : qobj; Qobj instance representing a two-qubit gate. Returns; -------; ep : float; The entanglement power of U (real number between 0 and 1). References:. Explorations in Quantum Computing, Colin P. Williams (Springer, 2011); """""". if not U.isoper:; raise Exception(""U must be an operator.""). if U.dims != [[2, 2], [2, 2]]:; raise Exception(""U must be a two-qubit gate.""). from qutip.qip.operations.gates import swap; a = (tensor(U, U).dag() * swap(N=4, targets=[1, 3]) *; tensor(U, U) * swap(N=4, targets=[1, 3])); b = (tensor(swap() * U, swap() * U).dag() * swap(N=4, targets=[1, 3]) *; tensor(swap() * U, swap() * U) * swap(N=4, targets=[1, 3])). return 5.0/9 - 1.0/36 * (a.tr() + b.tr()).real. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/modules/qutip/entropy.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/entropy.html
https://qutip.org/docs/4.7/modules/qutip/entropy.html:9134,Energy Efficiency,power,power,9134,"omposite object; selB : int/list; Selected components for density matrix B; base : {e,2}; Base of logarithm.; sparse : {False,True}; Use sparse eigensolver. Returns; -------; ent_cond : float; Value of conditional entropy. """"""; if rho.type != 'oper':; raise TypeError(""Input must be density matrix.""); if isinstance(selB, int):; selB = [selB]; B = ptrace(rho, selB); out = (entropy_vn(rho, base, sparse=sparse) -; entropy_vn(B, base, sparse=sparse)); return out. def participation_ratio(rho):; """"""; Returns the effective number of states for a density matrix. The participation is unity for pure states, and maximally N,; where N is the Hilbert space dimensionality, for completely; mixed states. Parameters; ----------; rho : qobj; Density matrix. Returns; -------; pr : float; Effective number of states in the density matrix. """"""; if rho.type == 'ket' or rho.type == 'bra':; return 1.0; else:; return 1.0 / (rho ** 2).tr(). def entangling_power(U):; """"""; Calculate the entangling power of a two-qubit gate U, which; is zero of nonentangling gates and 1 and 2/9 for maximally; entangling gates. Parameters; ----------; U : qobj; Qobj instance representing a two-qubit gate. Returns; -------; ep : float; The entanglement power of U (real number between 0 and 1). References:. Explorations in Quantum Computing, Colin P. Williams (Springer, 2011); """""". if not U.isoper:; raise Exception(""U must be an operator.""). if U.dims != [[2, 2], [2, 2]]:; raise Exception(""U must be a two-qubit gate.""). from qutip.qip.operations.gates import swap; a = (tensor(U, U).dag() * swap(N=4, targets=[1, 3]) *; tensor(U, U) * swap(N=4, targets=[1, 3])); b = (tensor(swap() * U, swap() * U).dag() * swap(N=4, targets=[1, 3]) *; tensor(swap() * U, swap() * U) * swap(N=4, targets=[1, 3])). return 5.0/9 - 1.0/36 * (a.tr() + b.tr()).real. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/modules/qutip/entropy.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/entropy.html
https://qutip.org/docs/4.7/modules/qutip/entropy.html:423,Performance,concurren,concurrence,423,". qutip.entropy — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.entropy. Source code for qutip.entropy; __all__ = ['entropy_vn', 'entropy_linear', 'entropy_mutual', 'negativity',; 'concurrence', 'entropy_conditional', 'entangling_power',; 'entropy_relative']. from numpy import conj, e, inf, imag, inner, real, sort, sqrt; from numpy.lib.scimath import log, log2; from qutip.qobj import ptrace; from qutip.states import ket2dm; from qutip.tensor import tensor; from qutip.operators import sigmay; from qutip.sparse import sp_eigs; from qutip.partial_transpose import partial_transpose. [docs]def entropy_vn(rho, base=e, sparse=False):; """"""; Von-Neumann entropy of density matrix. Parameters; ----------; rho : qobj; Density matrix.; base : {e,2}; Base of logarithm.; sparse : {False,True}; Use sparse eigensolver. Returns; -------; entropy : float; Von-Neumann entropy of `rho`. Examples; --------; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_vn(rho,2); 1.0. """"""; if rho.type == 'ket' or rho.type == 'bra':; rho = ket2dm(rho); vals = sp_eigs(rho.data, rho.isherm, vecs=False, sparse=sparse); nzvals = vals[vals != 0]; if base == 2:; logvals = log2(nzvals); elif base == e:; logvals = log(nzvals); else:; raise ValueError(""Base must be 2 or e.""); return float(real(-sum(nzvals * logvals))). [docs]def entropy_linear(rho):; """"""; Linear entropy of a density matrix. Parameters; ----------; rho : qobj; sensity matrix or ket/bra vector. Returns; -------; entropy : float; Linear entropy of rho. Examples; --------; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_linear(rho); 0.5. """"""; if rho.type == 'ket' or rho.type == 'bra':; rho = ket2dm(rho); return float(real(1.0 - (rho ** 2).tr())). [docs]def concurrence(rho):; """"""; Calculate the concu",MatchSource.WIKI,docs/4.7/modules/qutip/entropy.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/entropy.html
https://qutip.org/docs/4.7/modules/qutip/entropy.html:1958,Performance,concurren,concurrence,1958,"garithm.; sparse : {False,True}; Use sparse eigensolver. Returns; -------; entropy : float; Von-Neumann entropy of `rho`. Examples; --------; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_vn(rho,2); 1.0. """"""; if rho.type == 'ket' or rho.type == 'bra':; rho = ket2dm(rho); vals = sp_eigs(rho.data, rho.isherm, vecs=False, sparse=sparse); nzvals = vals[vals != 0]; if base == 2:; logvals = log2(nzvals); elif base == e:; logvals = log(nzvals); else:; raise ValueError(""Base must be 2 or e.""); return float(real(-sum(nzvals * logvals))). [docs]def entropy_linear(rho):; """"""; Linear entropy of a density matrix. Parameters; ----------; rho : qobj; sensity matrix or ket/bra vector. Returns; -------; entropy : float; Linear entropy of rho. Examples; --------; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_linear(rho); 0.5. """"""; if rho.type == 'ket' or rho.type == 'bra':; rho = ket2dm(rho); return float(real(1.0 - (rho ** 2).tr())). [docs]def concurrence(rho):; """"""; Calculate the concurrence entanglement measure for a two-qubit state. Parameters; ----------; state : qobj; Ket, bra, or density matrix for a two-qubit state. Returns; -------; concur : float; Concurrence. References; ----------. .. [1] https://en.wikipedia.org/wiki/Concurrence_(quantum_computing). """"""; if rho.isket and rho.dims != [[2, 2], [1, 1]]:; raise Exception(""Ket must be tensor product of two qubits.""). elif rho.isbra and rho.dims != [[1, 1], [2, 2]]:; raise Exception(""Bra must be tensor product of two qubits.""). elif rho.isoper and rho.dims != [[2, 2], [2, 2]]:; raise Exception(""Density matrix must be tensor product of two qubits.""). if rho.isket or rho.isbra:; rho = ket2dm(rho). sysy = tensor(sigmay(), sigmay()). rho_tilde = (rho * sysy) * (rho.conj() * sysy). evals = rho_tilde.eigenenergies(). # abs to avoid problems with sqrt for very small negative numbers; evals = abs(sort(real(evals))). lsum = sqrt(evals[3]) - sqrt(evals[2]) - sqrt(evals[1]) - sqrt(evals[0]). return max(0, lsum). def neg",MatchSource.WIKI,docs/4.7/modules/qutip/entropy.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/entropy.html
https://qutip.org/docs/4.7/modules/qutip/entropy.html:1996,Performance,concurren,concurrence,1996,"garithm.; sparse : {False,True}; Use sparse eigensolver. Returns; -------; entropy : float; Von-Neumann entropy of `rho`. Examples; --------; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_vn(rho,2); 1.0. """"""; if rho.type == 'ket' or rho.type == 'bra':; rho = ket2dm(rho); vals = sp_eigs(rho.data, rho.isherm, vecs=False, sparse=sparse); nzvals = vals[vals != 0]; if base == 2:; logvals = log2(nzvals); elif base == e:; logvals = log(nzvals); else:; raise ValueError(""Base must be 2 or e.""); return float(real(-sum(nzvals * logvals))). [docs]def entropy_linear(rho):; """"""; Linear entropy of a density matrix. Parameters; ----------; rho : qobj; sensity matrix or ket/bra vector. Returns; -------; entropy : float; Linear entropy of rho. Examples; --------; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_linear(rho); 0.5. """"""; if rho.type == 'ket' or rho.type == 'bra':; rho = ket2dm(rho); return float(real(1.0 - (rho ** 2).tr())). [docs]def concurrence(rho):; """"""; Calculate the concurrence entanglement measure for a two-qubit state. Parameters; ----------; state : qobj; Ket, bra, or density matrix for a two-qubit state. Returns; -------; concur : float; Concurrence. References; ----------. .. [1] https://en.wikipedia.org/wiki/Concurrence_(quantum_computing). """"""; if rho.isket and rho.dims != [[2, 2], [1, 1]]:; raise Exception(""Ket must be tensor product of two qubits.""). elif rho.isbra and rho.dims != [[1, 1], [2, 2]]:; raise Exception(""Bra must be tensor product of two qubits.""). elif rho.isoper and rho.dims != [[2, 2], [2, 2]]:; raise Exception(""Density matrix must be tensor product of two qubits.""). if rho.isket or rho.isbra:; rho = ket2dm(rho). sysy = tensor(sigmay(), sigmay()). rho_tilde = (rho * sysy) * (rho.conj() * sysy). evals = rho_tilde.eigenenergies(). # abs to avoid problems with sqrt for very small negative numbers; evals = abs(sort(real(evals))). lsum = sqrt(evals[3]) - sqrt(evals[2]) - sqrt(evals[1]) - sqrt(evals[0]). return max(0, lsum). def neg",MatchSource.WIKI,docs/4.7/modules/qutip/entropy.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/entropy.html
https://qutip.org/docs/4.7/modules/qutip/entropy.html:2807,Safety,avoid,avoid,2807,"ho.type == 'ket' or rho.type == 'bra':; rho = ket2dm(rho); return float(real(1.0 - (rho ** 2).tr())). [docs]def concurrence(rho):; """"""; Calculate the concurrence entanglement measure for a two-qubit state. Parameters; ----------; state : qobj; Ket, bra, or density matrix for a two-qubit state. Returns; -------; concur : float; Concurrence. References; ----------. .. [1] https://en.wikipedia.org/wiki/Concurrence_(quantum_computing). """"""; if rho.isket and rho.dims != [[2, 2], [1, 1]]:; raise Exception(""Ket must be tensor product of two qubits.""). elif rho.isbra and rho.dims != [[1, 1], [2, 2]]:; raise Exception(""Bra must be tensor product of two qubits.""). elif rho.isoper and rho.dims != [[2, 2], [2, 2]]:; raise Exception(""Density matrix must be tensor product of two qubits.""). if rho.isket or rho.isbra:; rho = ket2dm(rho). sysy = tensor(sigmay(), sigmay()). rho_tilde = (rho * sysy) * (rho.conj() * sysy). evals = rho_tilde.eigenenergies(). # abs to avoid problems with sqrt for very small negative numbers; evals = abs(sort(real(evals))). lsum = sqrt(evals[3]) - sqrt(evals[2]) - sqrt(evals[1]) - sqrt(evals[0]). return max(0, lsum). def negativity(rho, subsys, method='tracenorm', logarithmic=False):; """"""; Compute the negativity for a multipartite quantum system described; by the density matrix rho. The subsys argument is an index that; indicates which system to compute the negativity for. .. note::. Experimental.; """"""; mask = [idx == subsys for idx, n in enumerate(rho.dims[0])]; rho_pt = partial_transpose(rho, mask). if method == 'tracenorm':; N = ((rho_pt.dag() * rho_pt).sqrtm().tr().real - 1)/2.0; elif method == 'eigenvalues':; l = rho_pt.eigenenergies(); N = ((abs(l)-l)/2).sum(); else:; raise ValueError(""Unknown method %s"" % method). if logarithmic:; return log2(2 * N + 1); else:; return N. [docs]def entropy_mutual(rho, selA, selB, base=e, sparse=False):; """"""; Calculates the mutual information S(A:B) between selection; components of a system density matrix. Parameters;",MatchSource.WIKI,docs/4.7/modules/qutip/entropy.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/entropy.html
https://qutip.org/docs/4.7/modules/qutip/entropy.html:5322,Safety,detect,detect,5322,"ho.type != 'oper':; raise TypeError(""Input must be a density matrix.""); if (len(selA) + len(selB)) != len(rho.dims[0]):; raise TypeError(""Number of selected components must match "" +; ""total number.""). rhoA = ptrace(rho, selA); rhoB = ptrace(rho, selB); out = (entropy_vn(rhoA, base, sparse=sparse) +; entropy_vn(rhoB, base, sparse=sparse) -; entropy_vn(rho, base, sparse=sparse)); return out. [docs]def entropy_relative(rho, sigma, base=e, sparse=False, tol=1e-12):; """"""; Calculates the relative entropy S(rho||sigma) between two density; matrices. Parameters; ----------; rho : :class:`qutip.Qobj`; First density matrix (or ket which will be converted to a density; matrix).; sigma : :class:`qutip.Qobj`; Second density matrix (or ket which will be converted to a density; matrix).; base : {e,2}; Base of logarithm. Defaults to e.; sparse : bool; Flag to use sparse solver when determining the eigenvectors; of the density matrices. Defaults to False.; tol : float; Tolerance to use to detect 0 eigenvalues or dot producted between; eigenvectors. Defaults to 1e-12. Returns; -------; rel_ent : float; Value of relative entropy. Guaranteed to be greater than zero; and should equal zero only when rho and sigma are identical. Examples; --------. First we define two density matrices:. >>> rho = qutip.ket2dm(qutip.ket(""00"")); >>> sigma = rho + qutip.ket2dm(qutip.ket(""01"")); >>> sigma = sigma.unit(). Then we calculate their relative entropy using base 2 (i.e. ``log2``); and base e (i.e. ``log``). >>> qutip.entropy_relative(rho, sigma, base=2); 1.0; >>> qutip.entropy_relative(rho, sigma); 0.6931471805599453. References; ----------. See Nielsen & Chuang, ""Quantum Computation and Quantum Information"",; Section 11.3.1, pg. 511 for a detailed explanation of quantum relative; entropy.; """"""; if rho.isket:; rho = ket2dm(rho); if sigma.isket:; sigma = ket2dm(sigma); if not rho.isoper or not sigma.isoper:; raise TypeError(""Inputs must be density matrices.""); if rho.dims != sigma.dims:; raise ValueE",MatchSource.WIKI,docs/4.7/modules/qutip/entropy.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/entropy.html
https://qutip.org/docs/4.7/modules/qutip/entropy.html:7621,Safety,avoid,avoid,7621," e:; log_base = log; else:; raise ValueError(""Base must be 2 or e.""); # S(rho || sigma) = sum_i(p_i log p_i) - sum_ij(p_i P_ij log q_i); #; # S is +inf if the kernel of sigma (i.e. svecs[svals == 0]) has non-trivial; # intersection with the support of rho (i.e. rvecs[rvals != 0]).; rvals, rvecs = sp_eigs(rho.data, rho.isherm, vecs=True, sparse=sparse); if any(abs(imag(rvals)) >= tol):; raise ValueError(""Input rho has non-real eigenvalues.""); rvals = real(rvals); svals, svecs = sp_eigs(sigma.data, sigma.isherm, vecs=True, sparse=sparse); if any(abs(imag(svals)) >= tol):; raise ValueError(""Input sigma has non-real eigenvalues.""); svals = real(svals); # Calculate inner products of eigenvectors and return +inf if kernel; # of sigma overlaps with support of rho.; P = abs(inner(rvecs, conj(svecs))) ** 2; if (rvals >= tol) @ (P >= tol) @ (svals < tol):; return inf; # Avoid -inf from log(0) -- these terms will be multiplied by zero later; # anyway; svals[abs(svals) < tol] = 1; nzrvals = rvals[abs(rvals) >= tol]; # Calculate S; S = nzrvals @ log_base(nzrvals) - rvals @ P @ log_base(svals); # the relative entropy is guaranteed to be >= 0, so we clamp the; # calculated value to 0 to avoid small violations of the lower bound.; return max(0, S). [docs]def entropy_conditional(rho, selB, base=e, sparse=False):; """"""; Calculates the conditional entropy :math:`S(A|B)=S(A,B)-S(B)`; of a selected density matrix component. Parameters; ----------; rho : qobj; Density matrix of composite object; selB : int/list; Selected components for density matrix B; base : {e,2}; Base of logarithm.; sparse : {False,True}; Use sparse eigensolver. Returns; -------; ent_cond : float; Value of conditional entropy. """"""; if rho.type != 'oper':; raise TypeError(""Input must be density matrix.""); if isinstance(selB, int):; selB = [selB]; B = ptrace(rho, selB); out = (entropy_vn(rho, base, sparse=sparse) -; entropy_vn(B, base, sparse=sparse)); return out. def participation_ratio(rho):; """"""; Returns the effectiv",MatchSource.WIKI,docs/4.7/modules/qutip/entropy.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/entropy.html
https://qutip.org/docs/4.7/modules/qutip/entropy.html:595,Testability,log,log,595,". qutip.entropy — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.entropy. Source code for qutip.entropy; __all__ = ['entropy_vn', 'entropy_linear', 'entropy_mutual', 'negativity',; 'concurrence', 'entropy_conditional', 'entangling_power',; 'entropy_relative']. from numpy import conj, e, inf, imag, inner, real, sort, sqrt; from numpy.lib.scimath import log, log2; from qutip.qobj import ptrace; from qutip.states import ket2dm; from qutip.tensor import tensor; from qutip.operators import sigmay; from qutip.sparse import sp_eigs; from qutip.partial_transpose import partial_transpose. [docs]def entropy_vn(rho, base=e, sparse=False):; """"""; Von-Neumann entropy of density matrix. Parameters; ----------; rho : qobj; Density matrix.; base : {e,2}; Base of logarithm.; sparse : {False,True}; Use sparse eigensolver. Returns; -------; entropy : float; Von-Neumann entropy of `rho`. Examples; --------; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_vn(rho,2); 1.0. """"""; if rho.type == 'ket' or rho.type == 'bra':; rho = ket2dm(rho); vals = sp_eigs(rho.data, rho.isherm, vecs=False, sparse=sparse); nzvals = vals[vals != 0]; if base == 2:; logvals = log2(nzvals); elif base == e:; logvals = log(nzvals); else:; raise ValueError(""Base must be 2 or e.""); return float(real(-sum(nzvals * logvals))). [docs]def entropy_linear(rho):; """"""; Linear entropy of a density matrix. Parameters; ----------; rho : qobj; sensity matrix or ket/bra vector. Returns; -------; entropy : float; Linear entropy of rho. Examples; --------; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_linear(rho); 0.5. """"""; if rho.type == 'ket' or rho.type == 'bra':; rho = ket2dm(rho); return float(real(1.0 - (rho ** 2).tr())). [docs]def concurrence(rho):; """"""; Calculate the concu",MatchSource.WIKI,docs/4.7/modules/qutip/entropy.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/entropy.html
https://qutip.org/docs/4.7/modules/qutip/entropy.html:997,Testability,log,logarithm,997,". qutip.entropy — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.entropy. Source code for qutip.entropy; __all__ = ['entropy_vn', 'entropy_linear', 'entropy_mutual', 'negativity',; 'concurrence', 'entropy_conditional', 'entangling_power',; 'entropy_relative']. from numpy import conj, e, inf, imag, inner, real, sort, sqrt; from numpy.lib.scimath import log, log2; from qutip.qobj import ptrace; from qutip.states import ket2dm; from qutip.tensor import tensor; from qutip.operators import sigmay; from qutip.sparse import sp_eigs; from qutip.partial_transpose import partial_transpose. [docs]def entropy_vn(rho, base=e, sparse=False):; """"""; Von-Neumann entropy of density matrix. Parameters; ----------; rho : qobj; Density matrix.; base : {e,2}; Base of logarithm.; sparse : {False,True}; Use sparse eigensolver. Returns; -------; entropy : float; Von-Neumann entropy of `rho`. Examples; --------; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_vn(rho,2); 1.0. """"""; if rho.type == 'ket' or rho.type == 'bra':; rho = ket2dm(rho); vals = sp_eigs(rho.data, rho.isherm, vecs=False, sparse=sparse); nzvals = vals[vals != 0]; if base == 2:; logvals = log2(nzvals); elif base == e:; logvals = log(nzvals); else:; raise ValueError(""Base must be 2 or e.""); return float(real(-sum(nzvals * logvals))). [docs]def entropy_linear(rho):; """"""; Linear entropy of a density matrix. Parameters; ----------; rho : qobj; sensity matrix or ket/bra vector. Returns; -------; entropy : float; Linear entropy of rho. Examples; --------; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_linear(rho); 0.5. """"""; if rho.type == 'ket' or rho.type == 'bra':; rho = ket2dm(rho); return float(real(1.0 - (rho ** 2).tr())). [docs]def concurrence(rho):; """"""; Calculate the concu",MatchSource.WIKI,docs/4.7/modules/qutip/entropy.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/entropy.html
https://qutip.org/docs/4.7/modules/qutip/entropy.html:1386,Testability,log,logvals,1386,"al', 'negativity',; 'concurrence', 'entropy_conditional', 'entangling_power',; 'entropy_relative']. from numpy import conj, e, inf, imag, inner, real, sort, sqrt; from numpy.lib.scimath import log, log2; from qutip.qobj import ptrace; from qutip.states import ket2dm; from qutip.tensor import tensor; from qutip.operators import sigmay; from qutip.sparse import sp_eigs; from qutip.partial_transpose import partial_transpose. [docs]def entropy_vn(rho, base=e, sparse=False):; """"""; Von-Neumann entropy of density matrix. Parameters; ----------; rho : qobj; Density matrix.; base : {e,2}; Base of logarithm.; sparse : {False,True}; Use sparse eigensolver. Returns; -------; entropy : float; Von-Neumann entropy of `rho`. Examples; --------; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_vn(rho,2); 1.0. """"""; if rho.type == 'ket' or rho.type == 'bra':; rho = ket2dm(rho); vals = sp_eigs(rho.data, rho.isherm, vecs=False, sparse=sparse); nzvals = vals[vals != 0]; if base == 2:; logvals = log2(nzvals); elif base == e:; logvals = log(nzvals); else:; raise ValueError(""Base must be 2 or e.""); return float(real(-sum(nzvals * logvals))). [docs]def entropy_linear(rho):; """"""; Linear entropy of a density matrix. Parameters; ----------; rho : qobj; sensity matrix or ket/bra vector. Returns; -------; entropy : float; Linear entropy of rho. Examples; --------; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_linear(rho); 0.5. """"""; if rho.type == 'ket' or rho.type == 'bra':; rho = ket2dm(rho); return float(real(1.0 - (rho ** 2).tr())). [docs]def concurrence(rho):; """"""; Calculate the concurrence entanglement measure for a two-qubit state. Parameters; ----------; state : qobj; Ket, bra, or density matrix for a two-qubit state. Returns; -------; concur : float; Concurrence. References; ----------. .. [1] https://en.wikipedia.org/wiki/Concurrence_(quantum_computing). """"""; if rho.isket and rho.dims != [[2, 2], [1, 1]]:; raise Exception(""Ket must be tensor product of two qubits.""). elif ",MatchSource.WIKI,docs/4.7/modules/qutip/entropy.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/entropy.html
https://qutip.org/docs/4.7/modules/qutip/entropy.html:1427,Testability,log,logvals,1427,"al', 'negativity',; 'concurrence', 'entropy_conditional', 'entangling_power',; 'entropy_relative']. from numpy import conj, e, inf, imag, inner, real, sort, sqrt; from numpy.lib.scimath import log, log2; from qutip.qobj import ptrace; from qutip.states import ket2dm; from qutip.tensor import tensor; from qutip.operators import sigmay; from qutip.sparse import sp_eigs; from qutip.partial_transpose import partial_transpose. [docs]def entropy_vn(rho, base=e, sparse=False):; """"""; Von-Neumann entropy of density matrix. Parameters; ----------; rho : qobj; Density matrix.; base : {e,2}; Base of logarithm.; sparse : {False,True}; Use sparse eigensolver. Returns; -------; entropy : float; Von-Neumann entropy of `rho`. Examples; --------; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_vn(rho,2); 1.0. """"""; if rho.type == 'ket' or rho.type == 'bra':; rho = ket2dm(rho); vals = sp_eigs(rho.data, rho.isherm, vecs=False, sparse=sparse); nzvals = vals[vals != 0]; if base == 2:; logvals = log2(nzvals); elif base == e:; logvals = log(nzvals); else:; raise ValueError(""Base must be 2 or e.""); return float(real(-sum(nzvals * logvals))). [docs]def entropy_linear(rho):; """"""; Linear entropy of a density matrix. Parameters; ----------; rho : qobj; sensity matrix or ket/bra vector. Returns; -------; entropy : float; Linear entropy of rho. Examples; --------; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_linear(rho); 0.5. """"""; if rho.type == 'ket' or rho.type == 'bra':; rho = ket2dm(rho); return float(real(1.0 - (rho ** 2).tr())). [docs]def concurrence(rho):; """"""; Calculate the concurrence entanglement measure for a two-qubit state. Parameters; ----------; state : qobj; Ket, bra, or density matrix for a two-qubit state. Returns; -------; concur : float; Concurrence. References; ----------. .. [1] https://en.wikipedia.org/wiki/Concurrence_(quantum_computing). """"""; if rho.isket and rho.dims != [[2, 2], [1, 1]]:; raise Exception(""Ket must be tensor product of two qubits.""). elif ",MatchSource.WIKI,docs/4.7/modules/qutip/entropy.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/entropy.html
https://qutip.org/docs/4.7/modules/qutip/entropy.html:1437,Testability,log,log,1437,"al', 'negativity',; 'concurrence', 'entropy_conditional', 'entangling_power',; 'entropy_relative']. from numpy import conj, e, inf, imag, inner, real, sort, sqrt; from numpy.lib.scimath import log, log2; from qutip.qobj import ptrace; from qutip.states import ket2dm; from qutip.tensor import tensor; from qutip.operators import sigmay; from qutip.sparse import sp_eigs; from qutip.partial_transpose import partial_transpose. [docs]def entropy_vn(rho, base=e, sparse=False):; """"""; Von-Neumann entropy of density matrix. Parameters; ----------; rho : qobj; Density matrix.; base : {e,2}; Base of logarithm.; sparse : {False,True}; Use sparse eigensolver. Returns; -------; entropy : float; Von-Neumann entropy of `rho`. Examples; --------; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_vn(rho,2); 1.0. """"""; if rho.type == 'ket' or rho.type == 'bra':; rho = ket2dm(rho); vals = sp_eigs(rho.data, rho.isherm, vecs=False, sparse=sparse); nzvals = vals[vals != 0]; if base == 2:; logvals = log2(nzvals); elif base == e:; logvals = log(nzvals); else:; raise ValueError(""Base must be 2 or e.""); return float(real(-sum(nzvals * logvals))). [docs]def entropy_linear(rho):; """"""; Linear entropy of a density matrix. Parameters; ----------; rho : qobj; sensity matrix or ket/bra vector. Returns; -------; entropy : float; Linear entropy of rho. Examples; --------; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_linear(rho); 0.5. """"""; if rho.type == 'ket' or rho.type == 'bra':; rho = ket2dm(rho); return float(real(1.0 - (rho ** 2).tr())). [docs]def concurrence(rho):; """"""; Calculate the concurrence entanglement measure for a two-qubit state. Parameters; ----------; state : qobj; Ket, bra, or density matrix for a two-qubit state. Returns; -------; concur : float; Concurrence. References; ----------. .. [1] https://en.wikipedia.org/wiki/Concurrence_(quantum_computing). """"""; if rho.isket and rho.dims != [[2, 2], [1, 1]]:; raise Exception(""Ket must be tensor product of two qubits.""). elif ",MatchSource.WIKI,docs/4.7/modules/qutip/entropy.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/entropy.html
https://qutip.org/docs/4.7/modules/qutip/entropy.html:1531,Testability,log,logvals,1531,"t conj, e, inf, imag, inner, real, sort, sqrt; from numpy.lib.scimath import log, log2; from qutip.qobj import ptrace; from qutip.states import ket2dm; from qutip.tensor import tensor; from qutip.operators import sigmay; from qutip.sparse import sp_eigs; from qutip.partial_transpose import partial_transpose. [docs]def entropy_vn(rho, base=e, sparse=False):; """"""; Von-Neumann entropy of density matrix. Parameters; ----------; rho : qobj; Density matrix.; base : {e,2}; Base of logarithm.; sparse : {False,True}; Use sparse eigensolver. Returns; -------; entropy : float; Von-Neumann entropy of `rho`. Examples; --------; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_vn(rho,2); 1.0. """"""; if rho.type == 'ket' or rho.type == 'bra':; rho = ket2dm(rho); vals = sp_eigs(rho.data, rho.isherm, vecs=False, sparse=sparse); nzvals = vals[vals != 0]; if base == 2:; logvals = log2(nzvals); elif base == e:; logvals = log(nzvals); else:; raise ValueError(""Base must be 2 or e.""); return float(real(-sum(nzvals * logvals))). [docs]def entropy_linear(rho):; """"""; Linear entropy of a density matrix. Parameters; ----------; rho : qobj; sensity matrix or ket/bra vector. Returns; -------; entropy : float; Linear entropy of rho. Examples; --------; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_linear(rho); 0.5. """"""; if rho.type == 'ket' or rho.type == 'bra':; rho = ket2dm(rho); return float(real(1.0 - (rho ** 2).tr())). [docs]def concurrence(rho):; """"""; Calculate the concurrence entanglement measure for a two-qubit state. Parameters; ----------; state : qobj; Ket, bra, or density matrix for a two-qubit state. Returns; -------; concur : float; Concurrence. References; ----------. .. [1] https://en.wikipedia.org/wiki/Concurrence_(quantum_computing). """"""; if rho.isket and rho.dims != [[2, 2], [1, 1]]:; raise Exception(""Ket must be tensor product of two qubits.""). elif rho.isbra and rho.dims != [[1, 1], [2, 2]]:; raise Exception(""Bra must be tensor product of two qubits.""). elif rho.i",MatchSource.WIKI,docs/4.7/modules/qutip/entropy.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/entropy.html
https://qutip.org/docs/4.7/modules/qutip/entropy.html:3040,Testability,log,logarithmic,3040," state : qobj; Ket, bra, or density matrix for a two-qubit state. Returns; -------; concur : float; Concurrence. References; ----------. .. [1] https://en.wikipedia.org/wiki/Concurrence_(quantum_computing). """"""; if rho.isket and rho.dims != [[2, 2], [1, 1]]:; raise Exception(""Ket must be tensor product of two qubits.""). elif rho.isbra and rho.dims != [[1, 1], [2, 2]]:; raise Exception(""Bra must be tensor product of two qubits.""). elif rho.isoper and rho.dims != [[2, 2], [2, 2]]:; raise Exception(""Density matrix must be tensor product of two qubits.""). if rho.isket or rho.isbra:; rho = ket2dm(rho). sysy = tensor(sigmay(), sigmay()). rho_tilde = (rho * sysy) * (rho.conj() * sysy). evals = rho_tilde.eigenenergies(). # abs to avoid problems with sqrt for very small negative numbers; evals = abs(sort(real(evals))). lsum = sqrt(evals[3]) - sqrt(evals[2]) - sqrt(evals[1]) - sqrt(evals[0]). return max(0, lsum). def negativity(rho, subsys, method='tracenorm', logarithmic=False):; """"""; Compute the negativity for a multipartite quantum system described; by the density matrix rho. The subsys argument is an index that; indicates which system to compute the negativity for. .. note::. Experimental.; """"""; mask = [idx == subsys for idx, n in enumerate(rho.dims[0])]; rho_pt = partial_transpose(rho, mask). if method == 'tracenorm':; N = ((rho_pt.dag() * rho_pt).sqrtm().tr().real - 1)/2.0; elif method == 'eigenvalues':; l = rho_pt.eigenenergies(); N = ((abs(l)-l)/2).sum(); else:; raise ValueError(""Unknown method %s"" % method). if logarithmic:; return log2(2 * N + 1); else:; return N. [docs]def entropy_mutual(rho, selA, selB, base=e, sparse=False):; """"""; Calculates the mutual information S(A:B) between selection; components of a system density matrix. Parameters; ----------; rho : qobj; Density matrix for composite quantum systems; selA : int/list; `int` or `list` of first selected density matrix components.; selB : int/list; `int` or `list` of second selected density matrix components.;",MatchSource.WIKI,docs/4.7/modules/qutip/entropy.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/entropy.html
https://qutip.org/docs/4.7/modules/qutip/entropy.html:3611,Testability,log,logarithmic,3611,"rho.isket or rho.isbra:; rho = ket2dm(rho). sysy = tensor(sigmay(), sigmay()). rho_tilde = (rho * sysy) * (rho.conj() * sysy). evals = rho_tilde.eigenenergies(). # abs to avoid problems with sqrt for very small negative numbers; evals = abs(sort(real(evals))). lsum = sqrt(evals[3]) - sqrt(evals[2]) - sqrt(evals[1]) - sqrt(evals[0]). return max(0, lsum). def negativity(rho, subsys, method='tracenorm', logarithmic=False):; """"""; Compute the negativity for a multipartite quantum system described; by the density matrix rho. The subsys argument is an index that; indicates which system to compute the negativity for. .. note::. Experimental.; """"""; mask = [idx == subsys for idx, n in enumerate(rho.dims[0])]; rho_pt = partial_transpose(rho, mask). if method == 'tracenorm':; N = ((rho_pt.dag() * rho_pt).sqrtm().tr().real - 1)/2.0; elif method == 'eigenvalues':; l = rho_pt.eigenenergies(); N = ((abs(l)-l)/2).sum(); else:; raise ValueError(""Unknown method %s"" % method). if logarithmic:; return log2(2 * N + 1); else:; return N. [docs]def entropy_mutual(rho, selA, selB, base=e, sparse=False):; """"""; Calculates the mutual information S(A:B) between selection; components of a system density matrix. Parameters; ----------; rho : qobj; Density matrix for composite quantum systems; selA : int/list; `int` or `list` of first selected density matrix components.; selB : int/list; `int` or `list` of second selected density matrix components.; base : {e,2}; Base of logarithm.; sparse : {False,True}; Use sparse eigensolver. Returns; -------; ent_mut : float; Mutual information between selected components. """"""; if isinstance(selA, int):; selA = [selA]; if isinstance(selB, int):; selB = [selB]; if rho.type != 'oper':; raise TypeError(""Input must be a density matrix.""); if (len(selA) + len(selB)) != len(rho.dims[0]):; raise TypeError(""Number of selected components must match "" +; ""total number.""). rhoA = ptrace(rho, selA); rhoB = ptrace(rho, selB); out = (entropy_vn(rhoA, base, sparse=sparse) +; ",MatchSource.WIKI,docs/4.7/modules/qutip/entropy.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/entropy.html
https://qutip.org/docs/4.7/modules/qutip/entropy.html:4099,Testability,log,logarithm,4099," a multipartite quantum system described; by the density matrix rho. The subsys argument is an index that; indicates which system to compute the negativity for. .. note::. Experimental.; """"""; mask = [idx == subsys for idx, n in enumerate(rho.dims[0])]; rho_pt = partial_transpose(rho, mask). if method == 'tracenorm':; N = ((rho_pt.dag() * rho_pt).sqrtm().tr().real - 1)/2.0; elif method == 'eigenvalues':; l = rho_pt.eigenenergies(); N = ((abs(l)-l)/2).sum(); else:; raise ValueError(""Unknown method %s"" % method). if logarithmic:; return log2(2 * N + 1); else:; return N. [docs]def entropy_mutual(rho, selA, selB, base=e, sparse=False):; """"""; Calculates the mutual information S(A:B) between selection; components of a system density matrix. Parameters; ----------; rho : qobj; Density matrix for composite quantum systems; selA : int/list; `int` or `list` of first selected density matrix components.; selB : int/list; `int` or `list` of second selected density matrix components.; base : {e,2}; Base of logarithm.; sparse : {False,True}; Use sparse eigensolver. Returns; -------; ent_mut : float; Mutual information between selected components. """"""; if isinstance(selA, int):; selA = [selA]; if isinstance(selB, int):; selB = [selB]; if rho.type != 'oper':; raise TypeError(""Input must be a density matrix.""); if (len(selA) + len(selB)) != len(rho.dims[0]):; raise TypeError(""Number of selected components must match "" +; ""total number.""). rhoA = ptrace(rho, selA); rhoB = ptrace(rho, selB); out = (entropy_vn(rhoA, base, sparse=sparse) +; entropy_vn(rhoB, base, sparse=sparse) -; entropy_vn(rho, base, sparse=sparse)); return out. [docs]def entropy_relative(rho, sigma, base=e, sparse=False, tol=1e-12):; """"""; Calculates the relative entropy S(rho||sigma) between two density; matrices. Parameters; ----------; rho : :class:`qutip.Qobj`; First density matrix (or ket which will be converted to a density; matrix).; sigma : :class:`qutip.Qobj`; Second density matrix (or ket which will be convert",MatchSource.WIKI,docs/4.7/modules/qutip/entropy.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/entropy.html
https://qutip.org/docs/4.7/modules/qutip/entropy.html:5141,Testability,log,logarithm,5141,"Use sparse eigensolver. Returns; -------; ent_mut : float; Mutual information between selected components. """"""; if isinstance(selA, int):; selA = [selA]; if isinstance(selB, int):; selB = [selB]; if rho.type != 'oper':; raise TypeError(""Input must be a density matrix.""); if (len(selA) + len(selB)) != len(rho.dims[0]):; raise TypeError(""Number of selected components must match "" +; ""total number.""). rhoA = ptrace(rho, selA); rhoB = ptrace(rho, selB); out = (entropy_vn(rhoA, base, sparse=sparse) +; entropy_vn(rhoB, base, sparse=sparse) -; entropy_vn(rho, base, sparse=sparse)); return out. [docs]def entropy_relative(rho, sigma, base=e, sparse=False, tol=1e-12):; """"""; Calculates the relative entropy S(rho||sigma) between two density; matrices. Parameters; ----------; rho : :class:`qutip.Qobj`; First density matrix (or ket which will be converted to a density; matrix).; sigma : :class:`qutip.Qobj`; Second density matrix (or ket which will be converted to a density; matrix).; base : {e,2}; Base of logarithm. Defaults to e.; sparse : bool; Flag to use sparse solver when determining the eigenvectors; of the density matrices. Defaults to False.; tol : float; Tolerance to use to detect 0 eigenvalues or dot producted between; eigenvectors. Defaults to 1e-12. Returns; -------; rel_ent : float; Value of relative entropy. Guaranteed to be greater than zero; and should equal zero only when rho and sigma are identical. Examples; --------. First we define two density matrices:. >>> rho = qutip.ket2dm(qutip.ket(""00"")); >>> sigma = rho + qutip.ket2dm(qutip.ket(""01"")); >>> sigma = sigma.unit(). Then we calculate their relative entropy using base 2 (i.e. ``log2``); and base e (i.e. ``log``). >>> qutip.entropy_relative(rho, sigma, base=2); 1.0; >>> qutip.entropy_relative(rho, sigma); 0.6931471805599453. References; ----------. See Nielsen & Chuang, ""Quantum Computation and Quantum Information"",; Section 11.3.1, pg. 511 for a detailed explanation of quantum relative; entropy.; """"""; if rho",MatchSource.WIKI,docs/4.7/modules/qutip/entropy.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/entropy.html
https://qutip.org/docs/4.7/modules/qutip/entropy.html:5826,Testability,log,log,5826,"ve entropy S(rho||sigma) between two density; matrices. Parameters; ----------; rho : :class:`qutip.Qobj`; First density matrix (or ket which will be converted to a density; matrix).; sigma : :class:`qutip.Qobj`; Second density matrix (or ket which will be converted to a density; matrix).; base : {e,2}; Base of logarithm. Defaults to e.; sparse : bool; Flag to use sparse solver when determining the eigenvectors; of the density matrices. Defaults to False.; tol : float; Tolerance to use to detect 0 eigenvalues or dot producted between; eigenvectors. Defaults to 1e-12. Returns; -------; rel_ent : float; Value of relative entropy. Guaranteed to be greater than zero; and should equal zero only when rho and sigma are identical. Examples; --------. First we define two density matrices:. >>> rho = qutip.ket2dm(qutip.ket(""00"")); >>> sigma = rho + qutip.ket2dm(qutip.ket(""01"")); >>> sigma = sigma.unit(). Then we calculate their relative entropy using base 2 (i.e. ``log2``); and base e (i.e. ``log``). >>> qutip.entropy_relative(rho, sigma, base=2); 1.0; >>> qutip.entropy_relative(rho, sigma); 0.6931471805599453. References; ----------. See Nielsen & Chuang, ""Quantum Computation and Quantum Information"",; Section 11.3.1, pg. 511 for a detailed explanation of quantum relative; entropy.; """"""; if rho.isket:; rho = ket2dm(rho); if sigma.isket:; sigma = ket2dm(sigma); if not rho.isoper or not sigma.isoper:; raise TypeError(""Inputs must be density matrices.""); if rho.dims != sigma.dims:; raise ValueError(""Inputs must have the same shape and dims.""); if base == 2:; log_base = log2; elif base == e:; log_base = log; else:; raise ValueError(""Base must be 2 or e.""); # S(rho || sigma) = sum_i(p_i log p_i) - sum_ij(p_i P_ij log q_i); #; # S is +inf if the kernel of sigma (i.e. svecs[svals == 0]) has non-trivial; # intersection with the support of rho (i.e. rvecs[rvals != 0]).; rvals, rvecs = sp_eigs(rho.data, rho.isherm, vecs=True, sparse=sparse); if any(abs(imag(rvals)) >= tol):; raise Val",MatchSource.WIKI,docs/4.7/modules/qutip/entropy.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/entropy.html
https://qutip.org/docs/4.7/modules/qutip/entropy.html:6446,Testability,log,log,6446,"lue of relative entropy. Guaranteed to be greater than zero; and should equal zero only when rho and sigma are identical. Examples; --------. First we define two density matrices:. >>> rho = qutip.ket2dm(qutip.ket(""00"")); >>> sigma = rho + qutip.ket2dm(qutip.ket(""01"")); >>> sigma = sigma.unit(). Then we calculate their relative entropy using base 2 (i.e. ``log2``); and base e (i.e. ``log``). >>> qutip.entropy_relative(rho, sigma, base=2); 1.0; >>> qutip.entropy_relative(rho, sigma); 0.6931471805599453. References; ----------. See Nielsen & Chuang, ""Quantum Computation and Quantum Information"",; Section 11.3.1, pg. 511 for a detailed explanation of quantum relative; entropy.; """"""; if rho.isket:; rho = ket2dm(rho); if sigma.isket:; sigma = ket2dm(sigma); if not rho.isoper or not sigma.isoper:; raise TypeError(""Inputs must be density matrices.""); if rho.dims != sigma.dims:; raise ValueError(""Inputs must have the same shape and dims.""); if base == 2:; log_base = log2; elif base == e:; log_base = log; else:; raise ValueError(""Base must be 2 or e.""); # S(rho || sigma) = sum_i(p_i log p_i) - sum_ij(p_i P_ij log q_i); #; # S is +inf if the kernel of sigma (i.e. svecs[svals == 0]) has non-trivial; # intersection with the support of rho (i.e. rvecs[rvals != 0]).; rvals, rvecs = sp_eigs(rho.data, rho.isherm, vecs=True, sparse=sparse); if any(abs(imag(rvals)) >= tol):; raise ValueError(""Input rho has non-real eigenvalues.""); rvals = real(rvals); svals, svecs = sp_eigs(sigma.data, sigma.isherm, vecs=True, sparse=sparse); if any(abs(imag(svals)) >= tol):; raise ValueError(""Input sigma has non-real eigenvalues.""); svals = real(svals); # Calculate inner products of eigenvectors and return +inf if kernel; # of sigma overlaps with support of rho.; P = abs(inner(rvecs, conj(svecs))) ** 2; if (rvals >= tol) @ (P >= tol) @ (svals < tol):; return inf; # Avoid -inf from log(0) -- these terms will be multiplied by zero later; # anyway; svals[abs(svals) < tol] = 1; nzrvals = rvals[abs(rvals",MatchSource.WIKI,docs/4.7/modules/qutip/entropy.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/entropy.html
https://qutip.org/docs/4.7/modules/qutip/entropy.html:6530,Testability,log,log,6530,"entical. Examples; --------. First we define two density matrices:. >>> rho = qutip.ket2dm(qutip.ket(""00"")); >>> sigma = rho + qutip.ket2dm(qutip.ket(""01"")); >>> sigma = sigma.unit(). Then we calculate their relative entropy using base 2 (i.e. ``log2``); and base e (i.e. ``log``). >>> qutip.entropy_relative(rho, sigma, base=2); 1.0; >>> qutip.entropy_relative(rho, sigma); 0.6931471805599453. References; ----------. See Nielsen & Chuang, ""Quantum Computation and Quantum Information"",; Section 11.3.1, pg. 511 for a detailed explanation of quantum relative; entropy.; """"""; if rho.isket:; rho = ket2dm(rho); if sigma.isket:; sigma = ket2dm(sigma); if not rho.isoper or not sigma.isoper:; raise TypeError(""Inputs must be density matrices.""); if rho.dims != sigma.dims:; raise ValueError(""Inputs must have the same shape and dims.""); if base == 2:; log_base = log2; elif base == e:; log_base = log; else:; raise ValueError(""Base must be 2 or e.""); # S(rho || sigma) = sum_i(p_i log p_i) - sum_ij(p_i P_ij log q_i); #; # S is +inf if the kernel of sigma (i.e. svecs[svals == 0]) has non-trivial; # intersection with the support of rho (i.e. rvecs[rvals != 0]).; rvals, rvecs = sp_eigs(rho.data, rho.isherm, vecs=True, sparse=sparse); if any(abs(imag(rvals)) >= tol):; raise ValueError(""Input rho has non-real eigenvalues.""); rvals = real(rvals); svals, svecs = sp_eigs(sigma.data, sigma.isherm, vecs=True, sparse=sparse); if any(abs(imag(svals)) >= tol):; raise ValueError(""Input sigma has non-real eigenvalues.""); svals = real(svals); # Calculate inner products of eigenvectors and return +inf if kernel; # of sigma overlaps with support of rho.; P = abs(inner(rvecs, conj(svecs))) ** 2; if (rvals >= tol) @ (P >= tol) @ (svals < tol):; return inf; # Avoid -inf from log(0) -- these terms will be multiplied by zero later; # anyway; svals[abs(svals) < tol] = 1; nzrvals = rvals[abs(rvals) >= tol]; # Calculate S; S = nzrvals @ log_base(nzrvals) - rvals @ P @ log_base(svals); # the relative entropy i",MatchSource.WIKI,docs/4.7/modules/qutip/entropy.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/entropy.html
https://qutip.org/docs/4.7/modules/qutip/entropy.html:6557,Testability,log,log,6557,"entical. Examples; --------. First we define two density matrices:. >>> rho = qutip.ket2dm(qutip.ket(""00"")); >>> sigma = rho + qutip.ket2dm(qutip.ket(""01"")); >>> sigma = sigma.unit(). Then we calculate their relative entropy using base 2 (i.e. ``log2``); and base e (i.e. ``log``). >>> qutip.entropy_relative(rho, sigma, base=2); 1.0; >>> qutip.entropy_relative(rho, sigma); 0.6931471805599453. References; ----------. See Nielsen & Chuang, ""Quantum Computation and Quantum Information"",; Section 11.3.1, pg. 511 for a detailed explanation of quantum relative; entropy.; """"""; if rho.isket:; rho = ket2dm(rho); if sigma.isket:; sigma = ket2dm(sigma); if not rho.isoper or not sigma.isoper:; raise TypeError(""Inputs must be density matrices.""); if rho.dims != sigma.dims:; raise ValueError(""Inputs must have the same shape and dims.""); if base == 2:; log_base = log2; elif base == e:; log_base = log; else:; raise ValueError(""Base must be 2 or e.""); # S(rho || sigma) = sum_i(p_i log p_i) - sum_ij(p_i P_ij log q_i); #; # S is +inf if the kernel of sigma (i.e. svecs[svals == 0]) has non-trivial; # intersection with the support of rho (i.e. rvecs[rvals != 0]).; rvals, rvecs = sp_eigs(rho.data, rho.isherm, vecs=True, sparse=sparse); if any(abs(imag(rvals)) >= tol):; raise ValueError(""Input rho has non-real eigenvalues.""); rvals = real(rvals); svals, svecs = sp_eigs(sigma.data, sigma.isherm, vecs=True, sparse=sparse); if any(abs(imag(svals)) >= tol):; raise ValueError(""Input sigma has non-real eigenvalues.""); svals = real(svals); # Calculate inner products of eigenvectors and return +inf if kernel; # of sigma overlaps with support of rho.; P = abs(inner(rvecs, conj(svecs))) ** 2; if (rvals >= tol) @ (P >= tol) @ (svals < tol):; return inf; # Avoid -inf from log(0) -- these terms will be multiplied by zero later; # anyway; svals[abs(svals) < tol] = 1; nzrvals = rvals[abs(rvals) >= tol]; # Calculate S; S = nzrvals @ log_base(nzrvals) - rvals @ P @ log_base(svals); # the relative entropy i",MatchSource.WIKI,docs/4.7/modules/qutip/entropy.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/entropy.html
https://qutip.org/docs/4.7/modules/qutip/entropy.html:7319,Testability,log,log,7319," e:; log_base = log; else:; raise ValueError(""Base must be 2 or e.""); # S(rho || sigma) = sum_i(p_i log p_i) - sum_ij(p_i P_ij log q_i); #; # S is +inf if the kernel of sigma (i.e. svecs[svals == 0]) has non-trivial; # intersection with the support of rho (i.e. rvecs[rvals != 0]).; rvals, rvecs = sp_eigs(rho.data, rho.isherm, vecs=True, sparse=sparse); if any(abs(imag(rvals)) >= tol):; raise ValueError(""Input rho has non-real eigenvalues.""); rvals = real(rvals); svals, svecs = sp_eigs(sigma.data, sigma.isherm, vecs=True, sparse=sparse); if any(abs(imag(svals)) >= tol):; raise ValueError(""Input sigma has non-real eigenvalues.""); svals = real(svals); # Calculate inner products of eigenvectors and return +inf if kernel; # of sigma overlaps with support of rho.; P = abs(inner(rvecs, conj(svecs))) ** 2; if (rvals >= tol) @ (P >= tol) @ (svals < tol):; return inf; # Avoid -inf from log(0) -- these terms will be multiplied by zero later; # anyway; svals[abs(svals) < tol] = 1; nzrvals = rvals[abs(rvals) >= tol]; # Calculate S; S = nzrvals @ log_base(nzrvals) - rvals @ P @ log_base(svals); # the relative entropy is guaranteed to be >= 0, so we clamp the; # calculated value to 0 to avoid small violations of the lower bound.; return max(0, S). [docs]def entropy_conditional(rho, selB, base=e, sparse=False):; """"""; Calculates the conditional entropy :math:`S(A|B)=S(A,B)-S(B)`; of a selected density matrix component. Parameters; ----------; rho : qobj; Density matrix of composite object; selB : int/list; Selected components for density matrix B; base : {e,2}; Base of logarithm.; sparse : {False,True}; Use sparse eigensolver. Returns; -------; ent_cond : float; Value of conditional entropy. """"""; if rho.type != 'oper':; raise TypeError(""Input must be density matrix.""); if isinstance(selB, int):; selB = [selB]; B = ptrace(rho, selB); out = (entropy_vn(rho, base, sparse=sparse) -; entropy_vn(B, base, sparse=sparse)); return out. def participation_ratio(rho):; """"""; Returns the effectiv",MatchSource.WIKI,docs/4.7/modules/qutip/entropy.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/entropy.html
https://qutip.org/docs/4.7/modules/qutip/entropy.html:8009,Testability,log,logarithm,8009,".isherm, vecs=True, sparse=sparse); if any(abs(imag(svals)) >= tol):; raise ValueError(""Input sigma has non-real eigenvalues.""); svals = real(svals); # Calculate inner products of eigenvectors and return +inf if kernel; # of sigma overlaps with support of rho.; P = abs(inner(rvecs, conj(svecs))) ** 2; if (rvals >= tol) @ (P >= tol) @ (svals < tol):; return inf; # Avoid -inf from log(0) -- these terms will be multiplied by zero later; # anyway; svals[abs(svals) < tol] = 1; nzrvals = rvals[abs(rvals) >= tol]; # Calculate S; S = nzrvals @ log_base(nzrvals) - rvals @ P @ log_base(svals); # the relative entropy is guaranteed to be >= 0, so we clamp the; # calculated value to 0 to avoid small violations of the lower bound.; return max(0, S). [docs]def entropy_conditional(rho, selB, base=e, sparse=False):; """"""; Calculates the conditional entropy :math:`S(A|B)=S(A,B)-S(B)`; of a selected density matrix component. Parameters; ----------; rho : qobj; Density matrix of composite object; selB : int/list; Selected components for density matrix B; base : {e,2}; Base of logarithm.; sparse : {False,True}; Use sparse eigensolver. Returns; -------; ent_cond : float; Value of conditional entropy. """"""; if rho.type != 'oper':; raise TypeError(""Input must be density matrix.""); if isinstance(selB, int):; selB = [selB]; B = ptrace(rho, selB); out = (entropy_vn(rho, base, sparse=sparse) -; entropy_vn(B, base, sparse=sparse)); return out. def participation_ratio(rho):; """"""; Returns the effective number of states for a density matrix. The participation is unity for pure states, and maximally N,; where N is the Hilbert space dimensionality, for completely; mixed states. Parameters; ----------; rho : qobj; Density matrix. Returns; -------; pr : float; Effective number of states in the density matrix. """"""; if rho.type == 'ket' or rho.type == 'bra':; return 1.0; else:; return 1.0 / (rho ** 2).tr(). def entangling_power(U):; """"""; Calculate the entangling power of a two-qubit gate U, which; is zero",MatchSource.WIKI,docs/4.7/modules/qutip/entropy.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/entropy.html
https://qutip.org/docs/4.7/modules/qutip/eseries.html:9491,Deployability,update,updated,9491,"nique_rates.keys():; if abs(self.rates[r_idx] - unique_rates[ur_key]) < rate_tol:; idx = ur_key; break; if idx == -1:; # no matching rate, add it; unique_rates[ur_len] = self.rates[r_idx]; ampl_dict[ur_len] = [self.ampl[r_idx]]; ur_len = len(unique_rates); else:; # found matching rate, append amplitude to its list; ampl_dict[idx].append(self.ampl[r_idx]). # create new amplitude and rate list with only unique rates, and; # nonzero amplitudes; rates, ampl = [], []; for ur_key in unique_rates.keys():; total_ampl = sum(ampl_dict[ur_key]); if (isinstance(total_ampl, float) or; isinstance(total_ampl, complex)):; if abs(total_ampl) > ampl_tol:; rates.append(unique_rates[ur_key]); ampl.append(total_ampl); else:; if abs(total_ampl.full()).max() > ampl_tol:; rates.append(unique_rates[ur_key]); ampl.append(total_ampl); self.rates = np.array(rates); self.ampl = np.empty((len(ampl),), dtype=object); self.ampl[:] = ampl; return self. # -----------------------------------------------------------------------------; #; # wrapper functions for accessing the class methods (for compatibility with; # quantum optics toolbox); #; def esval(es, tlist):; """"""; Evaluates an exponential series at the times listed in ``tlist``. Parameters; ----------; tlist : ndarray; Times at which to evaluate exponential series. Returns; -------; val_list : ndarray; Values of exponential at times in ``tlist``. """"""; return es.value(tlist). def esspec(es, wlist):; """"""Evaluate the spectrum of an exponential series at frequencies; in ``wlist``. Parameters; ----------; wlist : array_like; Array/list of frequenies. Returns; -------; val_list : ndarray; Values of exponential series at frequencies in ``wlist``. """"""; return es.spec(wlist). def estidy(es, *args):; """"""; Returns a tidier version of exponential series.; """"""; return es.tidyup(). © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/modules/qutip/eseries.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/eseries.html
https://qutip.org/docs/4.7/modules/qutip/eseries.html:585,Integrability,depend,dependent,585,". qutip.eseries — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.eseries. Source code for qutip.eseries; __all__ = ['eseries', 'esval', 'esspec', 'estidy']. import numpy as np; import scipy.sparse as sp; from qutip.qobj import Qobj. import warnings. [docs]class eseries():; """"""; Class representation of an exponential-series expansion of; time-dependent quantum objects. .. deprecated:: 4.6.0; :obj:`~eseries` will be removed in QuTiP 5.; Please use :obj:`~qutip.QobjEvo` for general time-dependence. Attributes; ----------; ampl : ndarray; Array of amplitudes for exponential series.; rates : ndarray; Array of rates for exponential series.; dims : list; Dimensions of exponential series components; shape : list; Shape corresponding to exponential series components. Methods; -------; value(tlist); Evaluate an exponential series at the times listed in tlist; spec(wlist); Evaluate the spectrum of an exponential series at frequencies in wlist.; tidyup(); Returns a tidier version of the exponential series. """"""; __array_priority__ = 101. def __init__(self, q=None, s=np.array([])):; warnings.warn(; ""eseries is to be removed in QuTiP 5.0,""; "" consider swapping to QobjEvo for general time dependence."",; DeprecationWarning, stacklevel=2,; ). if isinstance(s, (int, float, complex)):; s = np.array([s]). if q is None:; self.ampl = np.array([]); self.rates = np.array([]); self.dims = [[1, 1]]; self.shape = [1, 1]. elif (len(s) == 0):; if isinstance(q, eseries):; self.ampl = q.ampl; self.rates = q.rates; self.dims = q.dims; self.shape = q.shape; elif isinstance(q, (np.ndarray, list)):; num = len(q) # number of elements in q; if any([Qobj(x).shape != Qobj(q[0]).shape for x in q]):; raise TypeError('All amplitudes must have same dimension.'); self.ampl =",MatchSource.WIKI,docs/4.7/modules/qutip/eseries.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/eseries.html
https://qutip.org/docs/4.7/modules/qutip/eseries.html:730,Integrability,depend,dependence,730,". qutip.eseries — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.eseries. Source code for qutip.eseries; __all__ = ['eseries', 'esval', 'esspec', 'estidy']. import numpy as np; import scipy.sparse as sp; from qutip.qobj import Qobj. import warnings. [docs]class eseries():; """"""; Class representation of an exponential-series expansion of; time-dependent quantum objects. .. deprecated:: 4.6.0; :obj:`~eseries` will be removed in QuTiP 5.; Please use :obj:`~qutip.QobjEvo` for general time-dependence. Attributes; ----------; ampl : ndarray; Array of amplitudes for exponential series.; rates : ndarray; Array of rates for exponential series.; dims : list; Dimensions of exponential series components; shape : list; Shape corresponding to exponential series components. Methods; -------; value(tlist); Evaluate an exponential series at the times listed in tlist; spec(wlist); Evaluate the spectrum of an exponential series at frequencies in wlist.; tidyup(); Returns a tidier version of the exponential series. """"""; __array_priority__ = 101. def __init__(self, q=None, s=np.array([])):; warnings.warn(; ""eseries is to be removed in QuTiP 5.0,""; "" consider swapping to QobjEvo for general time dependence."",; DeprecationWarning, stacklevel=2,; ). if isinstance(s, (int, float, complex)):; s = np.array([s]). if q is None:; self.ampl = np.array([]); self.rates = np.array([]); self.dims = [[1, 1]]; self.shape = [1, 1]. elif (len(s) == 0):; if isinstance(q, eseries):; self.ampl = q.ampl; self.rates = q.rates; self.dims = q.dims; self.shape = q.shape; elif isinstance(q, (np.ndarray, list)):; num = len(q) # number of elements in q; if any([Qobj(x).shape != Qobj(q[0]).shape for x in q]):; raise TypeError('All amplitudes must have same dimension.'); self.ampl =",MatchSource.WIKI,docs/4.7/modules/qutip/eseries.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/eseries.html
https://qutip.org/docs/4.7/modules/qutip/eseries.html:1433,Integrability,depend,dependence,1433,"s np; import scipy.sparse as sp; from qutip.qobj import Qobj. import warnings. [docs]class eseries():; """"""; Class representation of an exponential-series expansion of; time-dependent quantum objects. .. deprecated:: 4.6.0; :obj:`~eseries` will be removed in QuTiP 5.; Please use :obj:`~qutip.QobjEvo` for general time-dependence. Attributes; ----------; ampl : ndarray; Array of amplitudes for exponential series.; rates : ndarray; Array of rates for exponential series.; dims : list; Dimensions of exponential series components; shape : list; Shape corresponding to exponential series components. Methods; -------; value(tlist); Evaluate an exponential series at the times listed in tlist; spec(wlist); Evaluate the spectrum of an exponential series at frequencies in wlist.; tidyup(); Returns a tidier version of the exponential series. """"""; __array_priority__ = 101. def __init__(self, q=None, s=np.array([])):; warnings.warn(; ""eseries is to be removed in QuTiP 5.0,""; "" consider swapping to QobjEvo for general time dependence."",; DeprecationWarning, stacklevel=2,; ). if isinstance(s, (int, float, complex)):; s = np.array([s]). if q is None:; self.ampl = np.array([]); self.rates = np.array([]); self.dims = [[1, 1]]; self.shape = [1, 1]. elif (len(s) == 0):; if isinstance(q, eseries):; self.ampl = q.ampl; self.rates = q.rates; self.dims = q.dims; self.shape = q.shape; elif isinstance(q, (np.ndarray, list)):; num = len(q) # number of elements in q; if any([Qobj(x).shape != Qobj(q[0]).shape for x in q]):; raise TypeError('All amplitudes must have same dimension.'); self.ampl = np.empty((num,), dtype=object); self.ampl[:] = q; self.rates = np.zeros((num,)); self.dims = self.ampl[0].dims; self.shape = self.ampl[0].shape; elif isinstance(q, Qobj):; qo = Qobj(q); self.ampl = np.empty((1,), dtype=object); self.ampl[0] = qo; self.rates = np.array([0]); self.dims = qo.dims; self.shape = qo.shape; else:; self.ampl = np.array([q]); self.rates = np.array([0]); self.dims = [[1, 1]]; self.sh",MatchSource.WIKI,docs/4.7/modules/qutip/eseries.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/eseries.html
https://qutip.org/docs/4.7/modules/qutip/eseries.html:8612,Integrability,wrap,wrapper,8612,"nique_rates.keys():; if abs(self.rates[r_idx] - unique_rates[ur_key]) < rate_tol:; idx = ur_key; break; if idx == -1:; # no matching rate, add it; unique_rates[ur_len] = self.rates[r_idx]; ampl_dict[ur_len] = [self.ampl[r_idx]]; ur_len = len(unique_rates); else:; # found matching rate, append amplitude to its list; ampl_dict[idx].append(self.ampl[r_idx]). # create new amplitude and rate list with only unique rates, and; # nonzero amplitudes; rates, ampl = [], []; for ur_key in unique_rates.keys():; total_ampl = sum(ampl_dict[ur_key]); if (isinstance(total_ampl, float) or; isinstance(total_ampl, complex)):; if abs(total_ampl) > ampl_tol:; rates.append(unique_rates[ur_key]); ampl.append(total_ampl); else:; if abs(total_ampl.full()).max() > ampl_tol:; rates.append(unique_rates[ur_key]); ampl.append(total_ampl); self.rates = np.array(rates); self.ampl = np.empty((len(ampl),), dtype=object); self.ampl[:] = ampl; return self. # -----------------------------------------------------------------------------; #; # wrapper functions for accessing the class methods (for compatibility with; # quantum optics toolbox); #; def esval(es, tlist):; """"""; Evaluates an exponential series at the times listed in ``tlist``. Parameters; ----------; tlist : ndarray; Times at which to evaluate exponential series. Returns; -------; val_list : ndarray; Values of exponential at times in ``tlist``. """"""; return es.value(tlist). def esspec(es, wlist):; """"""Evaluate the spectrum of an exponential series at frequencies; in ``wlist``. Parameters; ----------; wlist : array_like; Array/list of frequenies. Returns; -------; val_list : ndarray; Values of exponential series at frequencies in ``wlist``. """"""; return es.spec(wlist). def estidy(es, *args):; """"""; Returns a tidier version of exponential series.; """"""; return es.tidyup(). © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/modules/qutip/eseries.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/eseries.html
https://qutip.org/docs/4.7/modules/qutip/eseries.html:8634,Security,access,accessing,8634,"nique_rates.keys():; if abs(self.rates[r_idx] - unique_rates[ur_key]) < rate_tol:; idx = ur_key; break; if idx == -1:; # no matching rate, add it; unique_rates[ur_len] = self.rates[r_idx]; ampl_dict[ur_len] = [self.ampl[r_idx]]; ur_len = len(unique_rates); else:; # found matching rate, append amplitude to its list; ampl_dict[idx].append(self.ampl[r_idx]). # create new amplitude and rate list with only unique rates, and; # nonzero amplitudes; rates, ampl = [], []; for ur_key in unique_rates.keys():; total_ampl = sum(ampl_dict[ur_key]); if (isinstance(total_ampl, float) or; isinstance(total_ampl, complex)):; if abs(total_ampl) > ampl_tol:; rates.append(unique_rates[ur_key]); ampl.append(total_ampl); else:; if abs(total_ampl.full()).max() > ampl_tol:; rates.append(unique_rates[ur_key]); ampl.append(total_ampl); self.rates = np.array(rates); self.ampl = np.empty((len(ampl),), dtype=object); self.ampl[:] = ampl; return self. # -----------------------------------------------------------------------------; #; # wrapper functions for accessing the class methods (for compatibility with; # quantum optics toolbox); #; def esval(es, tlist):; """"""; Evaluates an exponential series at the times listed in ``tlist``. Parameters; ----------; tlist : ndarray; Times at which to evaluate exponential series. Returns; -------; val_list : ndarray; Values of exponential at times in ``tlist``. """"""; return es.value(tlist). def esspec(es, wlist):; """"""Evaluate the spectrum of an exponential series at frequencies; in ``wlist``. Parameters; ----------; wlist : array_like; Array/list of frequenies. Returns; -------; val_list : ndarray; Values of exponential series at frequencies in ``wlist``. """"""; return es.spec(wlist). def estidy(es, *args):; """"""; Returns a tidier version of exponential series.; """"""; return es.tidyup(). © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/modules/qutip/eseries.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/eseries.html
https://qutip.org/docs/4.7/modules/qutip/essolve.html:4131,Availability,error,error,4131," results[n, :]; for n, e in enumerate(e_ops)]. return data. # -----------------------------------------------------------------------------; #; #; [docs]@_deprecate(""direct eigenstate and -value calculation""); def ode2es(L, rho0):; """"""Creates an exponential series that describes the time evolution for the; initial density matrix (or state vector) `rho0`, given the Liouvillian; (or Hamiltonian) `L`. .. deprecated:: 4.6.0; :obj:`~ode2es` will be removed in QuTiP 5. Please use; :obj:`qutip.Qobj.eigenstates` to get the eigenstates and -values,; and use :obj:`~qutip.QobjEvo` for general time-dependence. Parameters; ----------; L : qobj; Liouvillian of the system. rho0 : qobj; Initial state vector or density matrix. Returns; -------; eseries : :class:`qutip.eseries`; ``eseries`` represention of the system dynamics. """"""; if issuper(L):; # check initial state; if isket(rho0):; # Got a wave function as initial state: convert to density matrix.; rho0 = rho0 * rho0.dag(); # check if state is below error threshold; if abs(rho0.full()).sum() < 1e-10 + 1e-24:; # enforce zero operator; return eseries(qzero(rho0.dims[0])); w, v = L.eigenstates(); v = np.hstack([ket.full() for ket in v]); # w[i] = eigenvalue i; # v[:,i] = eigenvector i. rlen = np.prod(rho0.shape); r0 = mat2vec(rho0.full()); v0 = la.solve(v, r0); vv = v * sp.spdiags(v0.T, 0, rlen, rlen). out = None; for i in range(rlen):; qo = Qobj(vec2mat(vv[:, i]), dims=rho0.dims, shape=rho0.shape); if out:; out += eseries(qo, w[i]); else:; out = eseries(qo, w[i]). elif isoper(L):. if not isket(rho0):; raise TypeError('Second argument must be a ket if first' +; 'is a Hamiltonian.'). # check if state is below error threshold; if abs(rho0.full()).sum() < 1e-5 + 1e-20:; # enforce zero operator; dims = rho0.dims; return eseries(Qobj(sp.csr_matrix((dims[0][0], dims[1][0]),; dtype=complex))). w, v = L.eigenstates(); v = np.hstack([ket.full() for ket in v]); # w[i] = eigenvalue i; # v[:,i] = eigenvector i. rlen = np.prod(rho0.shape); r0 =",MatchSource.WIKI,docs/4.7/modules/qutip/essolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/essolve.html
https://qutip.org/docs/4.7/modules/qutip/essolve.html:4800,Availability,error,error,4800,"s,; and use :obj:`~qutip.QobjEvo` for general time-dependence. Parameters; ----------; L : qobj; Liouvillian of the system. rho0 : qobj; Initial state vector or density matrix. Returns; -------; eseries : :class:`qutip.eseries`; ``eseries`` represention of the system dynamics. """"""; if issuper(L):; # check initial state; if isket(rho0):; # Got a wave function as initial state: convert to density matrix.; rho0 = rho0 * rho0.dag(); # check if state is below error threshold; if abs(rho0.full()).sum() < 1e-10 + 1e-24:; # enforce zero operator; return eseries(qzero(rho0.dims[0])); w, v = L.eigenstates(); v = np.hstack([ket.full() for ket in v]); # w[i] = eigenvalue i; # v[:,i] = eigenvector i. rlen = np.prod(rho0.shape); r0 = mat2vec(rho0.full()); v0 = la.solve(v, r0); vv = v * sp.spdiags(v0.T, 0, rlen, rlen). out = None; for i in range(rlen):; qo = Qobj(vec2mat(vv[:, i]), dims=rho0.dims, shape=rho0.shape); if out:; out += eseries(qo, w[i]); else:; out = eseries(qo, w[i]). elif isoper(L):. if not isket(rho0):; raise TypeError('Second argument must be a ket if first' +; 'is a Hamiltonian.'). # check if state is below error threshold; if abs(rho0.full()).sum() < 1e-5 + 1e-20:; # enforce zero operator; dims = rho0.dims; return eseries(Qobj(sp.csr_matrix((dims[0][0], dims[1][0]),; dtype=complex))). w, v = L.eigenstates(); v = np.hstack([ket.full() for ket in v]); # w[i] = eigenvalue i; # v[:,i] = eigenvector i. rlen = np.prod(rho0.shape); r0 = rho0.full(); v0 = la.solve(v, r0); vv = v * sp.spdiags(v0.T, 0, rlen, rlen). out = None; for i in range(rlen):; qo = Qobj(np.array(vv[:, i]).T, dims=rho0.dims, shape=rho0.shape); if out:; out += eseries(qo, -1.0j * w[i]); else:; out = eseries(qo, -1.0j * w[i]). else:; raise TypeError('First argument must be a Hamiltonian or Liouvillian.'). return estidy(out). © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/modules/qutip/essolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/essolve.html
https://qutip.org/docs/4.7/modules/qutip/essolve.html:1866,Deployability,integrat,integration,1866," removed in QuTiP 5.0""; f"", consider swapping to {alternative}.""; ). @functools.wraps(f); def out(*args, **kwargs):; warnings.warn(message, DeprecationWarning, stacklevel=2); return f(*args, **kwargs); return out; return decorated. # -----------------------------------------------------------------------------; # pass on to wavefunction solver or master equation solver depending on whether; # any collapse operators were given.; #; [docs]@_deprecate(""mesolve""); def essolve(H, rho0, tlist, c_op_list, e_ops):; """"""; Evolution of a state vector or density matrix (`rho0`) for a given; Hamiltonian (`H`) and set of collapse operators (`c_op_list`), by; expressing the ODE as an exponential series. The output is either; the state vector at arbitrary points in time (`tlist`), or the; expectation values of the supplied operators (`e_ops`). .. deprecated:: 4.6.0; :obj:`~essolve` will be removed in QuTiP 5. Please use; :obj:`~qutip.sesolve` or :obj:`~qutip.mesolve` for general-purpose; integration of the Schroedinger/Lindblad master equation.; This will likely be faster than :obj:`~essolve` for you. Parameters; ----------; H : qobj/function_type; System Hamiltonian. rho0 : :class:`qutip.qobj`; Initial state density matrix. tlist : list/array; ``list`` of times for :math:`t`. c_op_list : list of :class:`qutip.qobj`; ``list`` of :class:`qutip.qobj` collapse operators. e_ops : list of :class:`qutip.qobj`; ``list`` of :class:`qutip.qobj` operators for which to evaluate; expectation values. Returns; -------; expt_array : array; Expectation values of wavefunctions/density matrices for the; times specified in ``tlist``. .. note:: This solver does not support time-dependent Hamiltonians. """"""; n_expt_op = len(e_ops); n_tsteps = len(tlist). # Calculate the Liouvillian; if (c_op_list is None or len(c_op_list) == 0) and isket(rho0):; L = H; else:; L = liouvillian(H, c_op_list). es = ode2es(L, rho0). # evaluate the expectation values; if n_expt_op == 0:; results = [Qobj()] * n_tsteps; else:; r",MatchSource.WIKI,docs/4.7/modules/qutip/essolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/essolve.html
https://qutip.org/docs/4.7/modules/qutip/essolve.html:5571,Deployability,update,updated,5571,"s,; and use :obj:`~qutip.QobjEvo` for general time-dependence. Parameters; ----------; L : qobj; Liouvillian of the system. rho0 : qobj; Initial state vector or density matrix. Returns; -------; eseries : :class:`qutip.eseries`; ``eseries`` represention of the system dynamics. """"""; if issuper(L):; # check initial state; if isket(rho0):; # Got a wave function as initial state: convert to density matrix.; rho0 = rho0 * rho0.dag(); # check if state is below error threshold; if abs(rho0.full()).sum() < 1e-10 + 1e-24:; # enforce zero operator; return eseries(qzero(rho0.dims[0])); w, v = L.eigenstates(); v = np.hstack([ket.full() for ket in v]); # w[i] = eigenvalue i; # v[:,i] = eigenvector i. rlen = np.prod(rho0.shape); r0 = mat2vec(rho0.full()); v0 = la.solve(v, r0); vv = v * sp.spdiags(v0.T, 0, rlen, rlen). out = None; for i in range(rlen):; qo = Qobj(vec2mat(vv[:, i]), dims=rho0.dims, shape=rho0.shape); if out:; out += eseries(qo, w[i]); else:; out = eseries(qo, w[i]). elif isoper(L):. if not isket(rho0):; raise TypeError('Second argument must be a ket if first' +; 'is a Hamiltonian.'). # check if state is below error threshold; if abs(rho0.full()).sum() < 1e-5 + 1e-20:; # enforce zero operator; dims = rho0.dims; return eseries(Qobj(sp.csr_matrix((dims[0][0], dims[1][0]),; dtype=complex))). w, v = L.eigenstates(); v = np.hstack([ket.full() for ket in v]); # w[i] = eigenvalue i; # v[:,i] = eigenvector i. rlen = np.prod(rho0.shape); r0 = rho0.full(); v0 = la.solve(v, r0); vv = v * sp.spdiags(v0.T, 0, rlen, rlen). out = None; for i in range(rlen):; qo = Qobj(np.array(vv[:, i]).T, dims=rho0.dims, shape=rho0.shape); if out:; out += eseries(qo, -1.0j * w[i]); else:; out = eseries(qo, -1.0j * w[i]). else:; raise TypeError('First argument must be a Hamiltonian or Liouvillian.'). return estidy(out). © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/modules/qutip/essolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/essolve.html
https://qutip.org/docs/4.7/modules/qutip/essolve.html:843,Integrability,message,message,843,". qutip.essolve — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.essolve. Source code for qutip.essolve; __all__ = ['essolve', 'ode2es']. import numpy as np; import scipy.linalg as la; import scipy.sparse as sp. from qutip.qobj import Qobj, issuper, isket, isoper; from qutip.eseries import eseries, estidy, esval; from qutip.expect import expect; from qutip.superoperator import liouvillian, mat2vec, vec2mat; from qutip.solver import Result; from qutip.operators import qzero. # Only used for deprecation warnings.; import functools; import warnings. def _deprecate(alternative):; def decorated(f):; message = (; f""{f.__name__} is to be removed in QuTiP 5.0""; f"", consider swapping to {alternative}.""; ). @functools.wraps(f); def out(*args, **kwargs):; warnings.warn(message, DeprecationWarning, stacklevel=2); return f(*args, **kwargs); return out; return decorated. # -----------------------------------------------------------------------------; # pass on to wavefunction solver or master equation solver depending on whether; # any collapse operators were given.; #; [docs]@_deprecate(""mesolve""); def essolve(H, rho0, tlist, c_op_list, e_ops):; """"""; Evolution of a state vector or density matrix (`rho0`) for a given; Hamiltonian (`H`) and set of collapse operators (`c_op_list`), by; expressing the ODE as an exponential series. The output is either; the state vector at arbitrary points in time (`tlist`), or the; expectation values of the supplied operators (`e_ops`). .. deprecated:: 4.6.0; :obj:`~essolve` will be removed in QuTiP 5. Please use; :obj:`~qutip.sesolve` or :obj:`~qutip.mesolve` for general-purpose; integration of the Schroedinger/Lindblad master equation.; This will likely be faster than :obj:`~essolve` for you. Parameters; -------",MatchSource.WIKI,docs/4.7/modules/qutip/essolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/essolve.html
https://qutip.org/docs/4.7/modules/qutip/essolve.html:959,Integrability,wrap,wraps,959,". qutip.essolve — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.essolve. Source code for qutip.essolve; __all__ = ['essolve', 'ode2es']. import numpy as np; import scipy.linalg as la; import scipy.sparse as sp. from qutip.qobj import Qobj, issuper, isket, isoper; from qutip.eseries import eseries, estidy, esval; from qutip.expect import expect; from qutip.superoperator import liouvillian, mat2vec, vec2mat; from qutip.solver import Result; from qutip.operators import qzero. # Only used for deprecation warnings.; import functools; import warnings. def _deprecate(alternative):; def decorated(f):; message = (; f""{f.__name__} is to be removed in QuTiP 5.0""; f"", consider swapping to {alternative}.""; ). @functools.wraps(f); def out(*args, **kwargs):; warnings.warn(message, DeprecationWarning, stacklevel=2); return f(*args, **kwargs); return out; return decorated. # -----------------------------------------------------------------------------; # pass on to wavefunction solver or master equation solver depending on whether; # any collapse operators were given.; #; [docs]@_deprecate(""mesolve""); def essolve(H, rho0, tlist, c_op_list, e_ops):; """"""; Evolution of a state vector or density matrix (`rho0`) for a given; Hamiltonian (`H`) and set of collapse operators (`c_op_list`), by; expressing the ODE as an exponential series. The output is either; the state vector at arbitrary points in time (`tlist`), or the; expectation values of the supplied operators (`e_ops`). .. deprecated:: 4.6.0; :obj:`~essolve` will be removed in QuTiP 5. Please use; :obj:`~qutip.sesolve` or :obj:`~qutip.mesolve` for general-purpose; integration of the Schroedinger/Lindblad master equation.; This will likely be faster than :obj:`~essolve` for you. Parameters; -------",MatchSource.WIKI,docs/4.7/modules/qutip/essolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/essolve.html
https://qutip.org/docs/4.7/modules/qutip/essolve.html:1010,Integrability,message,message,1010," Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.essolve. Source code for qutip.essolve; __all__ = ['essolve', 'ode2es']. import numpy as np; import scipy.linalg as la; import scipy.sparse as sp. from qutip.qobj import Qobj, issuper, isket, isoper; from qutip.eseries import eseries, estidy, esval; from qutip.expect import expect; from qutip.superoperator import liouvillian, mat2vec, vec2mat; from qutip.solver import Result; from qutip.operators import qzero. # Only used for deprecation warnings.; import functools; import warnings. def _deprecate(alternative):; def decorated(f):; message = (; f""{f.__name__} is to be removed in QuTiP 5.0""; f"", consider swapping to {alternative}.""; ). @functools.wraps(f); def out(*args, **kwargs):; warnings.warn(message, DeprecationWarning, stacklevel=2); return f(*args, **kwargs); return out; return decorated. # -----------------------------------------------------------------------------; # pass on to wavefunction solver or master equation solver depending on whether; # any collapse operators were given.; #; [docs]@_deprecate(""mesolve""); def essolve(H, rho0, tlist, c_op_list, e_ops):; """"""; Evolution of a state vector or density matrix (`rho0`) for a given; Hamiltonian (`H`) and set of collapse operators (`c_op_list`), by; expressing the ODE as an exponential series. The output is either; the state vector at arbitrary points in time (`tlist`), or the; expectation values of the supplied operators (`e_ops`). .. deprecated:: 4.6.0; :obj:`~essolve` will be removed in QuTiP 5. Please use; :obj:`~qutip.sesolve` or :obj:`~qutip.mesolve` for general-purpose; integration of the Schroedinger/Lindblad master equation.; This will likely be faster than :obj:`~essolve` for you. Parameters; ----------; H : qobj/function_type; System Hamiltonian. rho0 : :",MatchSource.WIKI,docs/4.7/modules/qutip/essolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/essolve.html
https://qutip.org/docs/4.7/modules/qutip/essolve.html:1251,Integrability,depend,depending,1251,"Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.essolve. Source code for qutip.essolve; __all__ = ['essolve', 'ode2es']. import numpy as np; import scipy.linalg as la; import scipy.sparse as sp. from qutip.qobj import Qobj, issuper, isket, isoper; from qutip.eseries import eseries, estidy, esval; from qutip.expect import expect; from qutip.superoperator import liouvillian, mat2vec, vec2mat; from qutip.solver import Result; from qutip.operators import qzero. # Only used for deprecation warnings.; import functools; import warnings. def _deprecate(alternative):; def decorated(f):; message = (; f""{f.__name__} is to be removed in QuTiP 5.0""; f"", consider swapping to {alternative}.""; ). @functools.wraps(f); def out(*args, **kwargs):; warnings.warn(message, DeprecationWarning, stacklevel=2); return f(*args, **kwargs); return out; return decorated. # -----------------------------------------------------------------------------; # pass on to wavefunction solver or master equation solver depending on whether; # any collapse operators were given.; #; [docs]@_deprecate(""mesolve""); def essolve(H, rho0, tlist, c_op_list, e_ops):; """"""; Evolution of a state vector or density matrix (`rho0`) for a given; Hamiltonian (`H`) and set of collapse operators (`c_op_list`), by; expressing the ODE as an exponential series. The output is either; the state vector at arbitrary points in time (`tlist`), or the; expectation values of the supplied operators (`e_ops`). .. deprecated:: 4.6.0; :obj:`~essolve` will be removed in QuTiP 5. Please use; :obj:`~qutip.sesolve` or :obj:`~qutip.mesolve` for general-purpose; integration of the Schroedinger/Lindblad master equation.; This will likely be faster than :obj:`~essolve` for you. Parameters; ----------; H : qobj/function_type; System Hamiltonian. rho0 : :class:`qutip.qobj`; Initial state density matrix. tlist : list/array; ``list`` of times for :math:`t`. c_op_list : list of :class:`qutip.qobj`; ``list``",MatchSource.WIKI,docs/4.7/modules/qutip/essolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/essolve.html
https://qutip.org/docs/4.7/modules/qutip/essolve.html:1866,Integrability,integrat,integration,1866," removed in QuTiP 5.0""; f"", consider swapping to {alternative}.""; ). @functools.wraps(f); def out(*args, **kwargs):; warnings.warn(message, DeprecationWarning, stacklevel=2); return f(*args, **kwargs); return out; return decorated. # -----------------------------------------------------------------------------; # pass on to wavefunction solver or master equation solver depending on whether; # any collapse operators were given.; #; [docs]@_deprecate(""mesolve""); def essolve(H, rho0, tlist, c_op_list, e_ops):; """"""; Evolution of a state vector or density matrix (`rho0`) for a given; Hamiltonian (`H`) and set of collapse operators (`c_op_list`), by; expressing the ODE as an exponential series. The output is either; the state vector at arbitrary points in time (`tlist`), or the; expectation values of the supplied operators (`e_ops`). .. deprecated:: 4.6.0; :obj:`~essolve` will be removed in QuTiP 5. Please use; :obj:`~qutip.sesolve` or :obj:`~qutip.mesolve` for general-purpose; integration of the Schroedinger/Lindblad master equation.; This will likely be faster than :obj:`~essolve` for you. Parameters; ----------; H : qobj/function_type; System Hamiltonian. rho0 : :class:`qutip.qobj`; Initial state density matrix. tlist : list/array; ``list`` of times for :math:`t`. c_op_list : list of :class:`qutip.qobj`; ``list`` of :class:`qutip.qobj` collapse operators. e_ops : list of :class:`qutip.qobj`; ``list`` of :class:`qutip.qobj` operators for which to evaluate; expectation values. Returns; -------; expt_array : array; Expectation values of wavefunctions/density matrices for the; times specified in ``tlist``. .. note:: This solver does not support time-dependent Hamiltonians. """"""; n_expt_op = len(e_ops); n_tsteps = len(tlist). # Calculate the Liouvillian; if (c_op_list is None or len(c_op_list) == 0) and isket(rho0):; L = H; else:; L = liouvillian(H, c_op_list). es = ode2es(L, rho0). # evaluate the expectation values; if n_expt_op == 0:; results = [Qobj()] * n_tsteps; else:; r",MatchSource.WIKI,docs/4.7/modules/qutip/essolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/essolve.html
https://qutip.org/docs/4.7/modules/qutip/essolve.html:2550,Integrability,depend,dependent,2550,"ng the ODE as an exponential series. The output is either; the state vector at arbitrary points in time (`tlist`), or the; expectation values of the supplied operators (`e_ops`). .. deprecated:: 4.6.0; :obj:`~essolve` will be removed in QuTiP 5. Please use; :obj:`~qutip.sesolve` or :obj:`~qutip.mesolve` for general-purpose; integration of the Schroedinger/Lindblad master equation.; This will likely be faster than :obj:`~essolve` for you. Parameters; ----------; H : qobj/function_type; System Hamiltonian. rho0 : :class:`qutip.qobj`; Initial state density matrix. tlist : list/array; ``list`` of times for :math:`t`. c_op_list : list of :class:`qutip.qobj`; ``list`` of :class:`qutip.qobj` collapse operators. e_ops : list of :class:`qutip.qobj`; ``list`` of :class:`qutip.qobj` operators for which to evaluate; expectation values. Returns; -------; expt_array : array; Expectation values of wavefunctions/density matrices for the; times specified in ``tlist``. .. note:: This solver does not support time-dependent Hamiltonians. """"""; n_expt_op = len(e_ops); n_tsteps = len(tlist). # Calculate the Liouvillian; if (c_op_list is None or len(c_op_list) == 0) and isket(rho0):; L = H; else:; L = liouvillian(H, c_op_list). es = ode2es(L, rho0). # evaluate the expectation values; if n_expt_op == 0:; results = [Qobj()] * n_tsteps; else:; results = np.zeros([n_expt_op, n_tsteps], dtype=complex). for n, e in enumerate(e_ops):; results[n, :] = expect(e, esval(es, tlist)). data = Result(); data.solver = ""essolve""; data.times = tlist; data.expect = [np.real(results[n, :]) if e.isherm else results[n, :]; for n, e in enumerate(e_ops)]. return data. # -----------------------------------------------------------------------------; #; #; [docs]@_deprecate(""direct eigenstate and -value calculation""); def ode2es(L, rho0):; """"""Creates an exponential series that describes the time evolution for the; initial density matrix (or state vector) `rho0`, given the Liouvillian; (or Hamiltonian) `L`. .. depreca",MatchSource.WIKI,docs/4.7/modules/qutip/essolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/essolve.html
https://qutip.org/docs/4.7/modules/qutip/essolve.html:3723,Integrability,depend,dependence,3723,"):; L = H; else:; L = liouvillian(H, c_op_list). es = ode2es(L, rho0). # evaluate the expectation values; if n_expt_op == 0:; results = [Qobj()] * n_tsteps; else:; results = np.zeros([n_expt_op, n_tsteps], dtype=complex). for n, e in enumerate(e_ops):; results[n, :] = expect(e, esval(es, tlist)). data = Result(); data.solver = ""essolve""; data.times = tlist; data.expect = [np.real(results[n, :]) if e.isherm else results[n, :]; for n, e in enumerate(e_ops)]. return data. # -----------------------------------------------------------------------------; #; #; [docs]@_deprecate(""direct eigenstate and -value calculation""); def ode2es(L, rho0):; """"""Creates an exponential series that describes the time evolution for the; initial density matrix (or state vector) `rho0`, given the Liouvillian; (or Hamiltonian) `L`. .. deprecated:: 4.6.0; :obj:`~ode2es` will be removed in QuTiP 5. Please use; :obj:`qutip.Qobj.eigenstates` to get the eigenstates and -values,; and use :obj:`~qutip.QobjEvo` for general time-dependence. Parameters; ----------; L : qobj; Liouvillian of the system. rho0 : qobj; Initial state vector or density matrix. Returns; -------; eseries : :class:`qutip.eseries`; ``eseries`` represention of the system dynamics. """"""; if issuper(L):; # check initial state; if isket(rho0):; # Got a wave function as initial state: convert to density matrix.; rho0 = rho0 * rho0.dag(); # check if state is below error threshold; if abs(rho0.full()).sum() < 1e-10 + 1e-24:; # enforce zero operator; return eseries(qzero(rho0.dims[0])); w, v = L.eigenstates(); v = np.hstack([ket.full() for ket in v]); # w[i] = eigenvalue i; # v[:,i] = eigenvector i. rlen = np.prod(rho0.shape); r0 = mat2vec(rho0.full()); v0 = la.solve(v, r0); vv = v * sp.spdiags(v0.T, 0, rlen, rlen). out = None; for i in range(rlen):; qo = Qobj(vec2mat(vv[:, i]), dims=rho0.dims, shape=rho0.shape); if out:; out += eseries(qo, w[i]); else:; out = eseries(qo, w[i]). elif isoper(L):. if not isket(rho0):; raise TypeError('Second ",MatchSource.WIKI,docs/4.7/modules/qutip/essolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/essolve.html
https://qutip.org/docs/4.7/modules/qutip/expect.html:3879,Deployability,update,updated,3879,"; else:; return np.array([_single_qobj_expect(oper, x) for x in state],; dtype=complex); else:; raise TypeError('Arguments must be quantum objects or eseries'). def _single_qobj_expect(oper, state):; """"""; Private function used by expect to calculate expectation values of Qobjs.; """"""; if isoper(oper):; if oper.dims[1] != state.dims[0]:; raise Exception('Operator and state do not have same tensor ' +; 'structure: %s and %s' %; (oper.dims[1], state.dims[0])). if state.type == 'oper':; # calculates expectation value via TR(op*rho); return cy_spmm_tr(oper.data, state.data,; oper.isherm and state.isherm). elif state.type == 'ket':; # calculates expectation value via <psi|op|psi>; return expect_csr_ket(oper.data, state.data,; oper.isherm); else:; raise TypeError('Invalid operand types'). def _single_eseries_expect(oper, state):; """"""; Private function used by expect to calculate expectation values for; eseries.; """""". out = eseries(). if isoper(state.ampl[0]):; out.rates = state.rates; out.ampl = np.array([expect(oper, a) for a in state.ampl]). else:; out.rates = np.array([]); out.ampl = np.array([]). for m in range(len(state.rates)):; op_m = state.ampl[m].data.conj().T * oper.data. for n in range(len(state.rates)):; a = op_m * state.ampl[n].data. if isinstance(a, sp.spmatrix):; a = a.todense(). out.rates = np.append(out.rates, state.rates[n] -; state.rates[m]); out.ampl = np.append(out.ampl, a). return out. [docs]def variance(oper, state):; """"""; Variance of an operator for the given state vector or density matrix. Parameters; ----------; oper : qobj; Operator for expectation value. state : qobj/list; A single or `list` of quantum states or density matrices.. Returns; -------; var : float; Variance of operator 'oper' for given state. """"""; return expect(oper ** 2, state) - expect(oper, state) ** 2. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/modules/qutip/expect.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/expect.html
https://qutip.org/docs/4.7/modules/qutip/fileio.html:5756,Deployability,update,updated,5756," = ""complex""; else:; numtype = ""np.real"". # check format; if (""e"" in line_vec[0]) or (""E"" in line_vec[0]):; numformat = ""exp""; else:; numformat = ""decimal"". elif N != n:; raise ValueError(""Badly formatted data file: "" +; ""unequal number of columns""); M += 1. #; # read data and store in a matrix; #; f.seek(0). if numtype == ""complex"":; data = np.zeros((M, N), dtype=""complex""); m = n = 0; for line in f:; # skip comment lines; if line[0] == '#' or line[0] == '%':; continue; n = 0; for item in line.rstrip().split(sep):; data[m, n] = complex(item); n += 1; m += 1. else:; data = np.zeros((M, N), dtype=""float""); m = n = 0; for line in f:; # skip comment lines; if line[0] == '#' or line[0] == '%':; continue; n = 0; for item in line.rstrip().split(sep):; data[m, n] = float(item); n += 1; m += 1. f.close(). return data. [docs]def qsave(data, name='qutip_data'):; """"""; Saves given data to file named 'filename.qu' in current directory. Parameters; ----------; data : instance/array_like; Input Python object to be stored.; filename : str or pathlib.Path; Name of output data file. """"""; # open the file for writing; path = Path(name); path = path.with_suffix(path.suffix + "".qu""). with open(path, ""wb"") as fileObject:; # this writes the object a to the file named 'filename.qu'; pickle.dump(data, fileObject). [docs]def qload(name):; """"""; Loads data file from file named 'filename.qu' in current directory. Parameters; ----------; name : str or pathlib.Path; Name of data file to be loaded. Returns; -------; qobject : instance / array_like; Object retrieved from requested file. """"""; path = Path(name); path = path.with_suffix(path.suffix + "".qu""). with open(path, ""rb"") as fileObject:; if sys.version_info >= (3, 0):; out = pickle.load(fileObject, encoding='latin1'); else:; out = pickle.load(fileObject). return out. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/modules/qutip/fileio.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/fileio.html
https://qutip.org/docs/4.7/modules/qutip/fileio.html:5340,Performance,load,loaded,5340," = ""complex""; else:; numtype = ""np.real"". # check format; if (""e"" in line_vec[0]) or (""E"" in line_vec[0]):; numformat = ""exp""; else:; numformat = ""decimal"". elif N != n:; raise ValueError(""Badly formatted data file: "" +; ""unequal number of columns""); M += 1. #; # read data and store in a matrix; #; f.seek(0). if numtype == ""complex"":; data = np.zeros((M, N), dtype=""complex""); m = n = 0; for line in f:; # skip comment lines; if line[0] == '#' or line[0] == '%':; continue; n = 0; for item in line.rstrip().split(sep):; data[m, n] = complex(item); n += 1; m += 1. else:; data = np.zeros((M, N), dtype=""float""); m = n = 0; for line in f:; # skip comment lines; if line[0] == '#' or line[0] == '%':; continue; n = 0; for item in line.rstrip().split(sep):; data[m, n] = float(item); n += 1; m += 1. f.close(). return data. [docs]def qsave(data, name='qutip_data'):; """"""; Saves given data to file named 'filename.qu' in current directory. Parameters; ----------; data : instance/array_like; Input Python object to be stored.; filename : str or pathlib.Path; Name of output data file. """"""; # open the file for writing; path = Path(name); path = path.with_suffix(path.suffix + "".qu""). with open(path, ""wb"") as fileObject:; # this writes the object a to the file named 'filename.qu'; pickle.dump(data, fileObject). [docs]def qload(name):; """"""; Loads data file from file named 'filename.qu' in current directory. Parameters; ----------; name : str or pathlib.Path; Name of data file to be loaded. Returns; -------; qobject : instance / array_like; Object retrieved from requested file. """"""; path = Path(name); path = path.with_suffix(path.suffix + "".qu""). with open(path, ""rb"") as fileObject:; if sys.version_info >= (3, 0):; out = pickle.load(fileObject, encoding='latin1'); else:; out = pickle.load(fileObject). return out. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/modules/qutip/fileio.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/fileio.html
https://qutip.org/docs/4.7/modules/qutip/fileio.html:5590,Performance,load,load,5590," = ""complex""; else:; numtype = ""np.real"". # check format; if (""e"" in line_vec[0]) or (""E"" in line_vec[0]):; numformat = ""exp""; else:; numformat = ""decimal"". elif N != n:; raise ValueError(""Badly formatted data file: "" +; ""unequal number of columns""); M += 1. #; # read data and store in a matrix; #; f.seek(0). if numtype == ""complex"":; data = np.zeros((M, N), dtype=""complex""); m = n = 0; for line in f:; # skip comment lines; if line[0] == '#' or line[0] == '%':; continue; n = 0; for item in line.rstrip().split(sep):; data[m, n] = complex(item); n += 1; m += 1. else:; data = np.zeros((M, N), dtype=""float""); m = n = 0; for line in f:; # skip comment lines; if line[0] == '#' or line[0] == '%':; continue; n = 0; for item in line.rstrip().split(sep):; data[m, n] = float(item); n += 1; m += 1. f.close(). return data. [docs]def qsave(data, name='qutip_data'):; """"""; Saves given data to file named 'filename.qu' in current directory. Parameters; ----------; data : instance/array_like; Input Python object to be stored.; filename : str or pathlib.Path; Name of output data file. """"""; # open the file for writing; path = Path(name); path = path.with_suffix(path.suffix + "".qu""). with open(path, ""wb"") as fileObject:; # this writes the object a to the file named 'filename.qu'; pickle.dump(data, fileObject). [docs]def qload(name):; """"""; Loads data file from file named 'filename.qu' in current directory. Parameters; ----------; name : str or pathlib.Path; Name of data file to be loaded. Returns; -------; qobject : instance / array_like; Object retrieved from requested file. """"""; path = Path(name); path = path.with_suffix(path.suffix + "".qu""). with open(path, ""rb"") as fileObject:; if sys.version_info >= (3, 0):; out = pickle.load(fileObject, encoding='latin1'); else:; out = pickle.load(fileObject). return out. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/modules/qutip/fileio.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/fileio.html
https://qutip.org/docs/4.7/modules/qutip/fileio.html:5647,Performance,load,load,5647," = ""complex""; else:; numtype = ""np.real"". # check format; if (""e"" in line_vec[0]) or (""E"" in line_vec[0]):; numformat = ""exp""; else:; numformat = ""decimal"". elif N != n:; raise ValueError(""Badly formatted data file: "" +; ""unequal number of columns""); M += 1. #; # read data and store in a matrix; #; f.seek(0). if numtype == ""complex"":; data = np.zeros((M, N), dtype=""complex""); m = n = 0; for line in f:; # skip comment lines; if line[0] == '#' or line[0] == '%':; continue; n = 0; for item in line.rstrip().split(sep):; data[m, n] = complex(item); n += 1; m += 1. else:; data = np.zeros((M, N), dtype=""float""); m = n = 0; for line in f:; # skip comment lines; if line[0] == '#' or line[0] == '%':; continue; n = 0; for item in line.rstrip().split(sep):; data[m, n] = float(item); n += 1; m += 1. f.close(). return data. [docs]def qsave(data, name='qutip_data'):; """"""; Saves given data to file named 'filename.qu' in current directory. Parameters; ----------; data : instance/array_like; Input Python object to be stored.; filename : str or pathlib.Path; Name of output data file. """"""; # open the file for writing; path = Path(name); path = path.with_suffix(path.suffix + "".qu""). with open(path, ""wb"") as fileObject:; # this writes the object a to the file named 'filename.qu'; pickle.dump(data, fileObject). [docs]def qload(name):; """"""; Loads data file from file named 'filename.qu' in current directory. Parameters; ----------; name : str or pathlib.Path; Name of data file to be loaded. Returns; -------; qobject : instance / array_like; Object retrieved from requested file. """"""; path = Path(name); path = path.with_suffix(path.suffix + "".qu""). with open(path, ""rb"") as fileObject:; if sys.version_info >= (3, 0):; out = pickle.load(fileObject, encoding='latin1'); else:; out = pickle.load(fileObject). return out. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/modules/qutip/fileio.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/fileio.html
https://qutip.org/docs/4.7/modules/qutip/floquet.html:11077,Deployability,patch,patch,11077,"onian, time-dependent with period `T`. T : float; The period of the time-dependence of the hamiltonian. args : dictionary; Dictionary with variables required to evaluate H. Returns; -------. output : :class:`qutip.qobj`. The wavefunction for the time :math:`t`. """""". f_states_t = floquet_states_t(f_modes_0, f_energies, t, H, T, args,; options=options); return sum([f_states_t[i] * f_coeff[i]; for i in np.arange(len(f_energies))]). [docs]def floquet_state_decomposition(f_states, f_energies, psi):; r""""""; Decompose the wavefunction `psi` (typically an initial state) in terms of; the Floquet states, :math:`\psi = \sum_\alpha c_\alpha \psi_\alpha(0)`. Parameters; ----------. f_states : list of :class:`qutip.qobj` (kets); A list of Floquet modes. f_energies : array; The Floquet energies. psi : :class:`qutip.qobj`; The wavefunction to decompose in the Floquet state basis. Returns; -------. output : array. The coefficients :math:`c_\alpha` in the Floquet state decomposition. """"""; # [:1,:1][0, 0] patch around scipy 1.3.0 bug; return [(f_states[i].dag() * psi).data[:1, :1][0, 0]; for i in np.arange(len(f_energies))]. [docs]def fsesolve(H, psi0, tlist, e_ops=[], T=None, args={}, Tsteps=100,; options_modes=None):; """"""; Solve the Schrodinger equation using the Floquet formalism. Parameters; ----------. H : :class:`qutip.Qobj`; System Hamiltonian, time-dependent with period `T`. psi0 : :class:`qutip.qobj`; Initial state vector (ket). tlist : *list* / *array*; list of times for :math:`t`. e_ops : list of :class:`qutip.qobj` / callback function; list of operators for which to evaluate expectation values. If this; list is empty, the state vectors for each time in `tlist` will be; returned instead of expectation values. T : float; The period of the time-dependence of the hamiltonian. args : dictionary; Dictionary with variables required to evaluate H. Tsteps : integer; The number of time steps in one driving period for which to; precalculate the Floquet modes. `Tsteps` should be an even",MatchSource.WIKI,docs/4.7/modules/qutip/floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/floquet.html
https://qutip.org/docs/4.7/modules/qutip/floquet.html:14309,Deployability,integrat,integration,14309,"p.zeros(len(tlist))); else:; output.expect.append(np.zeros(len(tlist), dtype=complex)). else:; raise TypeError(""e_ops must be a list Qobj or a callback function""). psi0_fb = psi0.transform(f_modes_0); for t_idx, t in enumerate(tlist):; f_modes_t = floquet_modes_t_lookup(f_modes_table_t, t, T); f_states_t = floquet_states(f_modes_t, f_energies, t); psi_t = psi0_fb.transform(f_states_t, True). if expt_callback:; # use callback method; e_ops(t, psi_t); else:; # calculate all the expectation values, or output psi if; # no expectation value operators where defined; if output.num_expect == 0:; output.states.append(Qobj(psi_t)); else:; for e_idx, e in enumerate(e_ops):; output.expect[e_idx][t_idx] = expect(e, psi_t). return output. [docs]def floquet_master_equation_rates(f_modes_0, f_energies, c_op, H, T,; args, J_cb, w_th, kmax=5,; f_modes_table_t=None):; """"""; Calculate the rates and matrix elements for the Floquet-Markov master; equation. .. note :; The number of integration steps (for calculating X) within one period; is set to 20 * kmax. Parameters; ----------. f_modes_0 : list of :class:`qutip.qobj` (kets); A list of initial Floquet modes. f_energies : array; The Floquet energies. c_op : :class:`qutip.qobj`; The collapse operators describing the dissipation. H : :class:`qutip.qobj`; System Hamiltonian, time-dependent with period `T`. T : float; The period of the time-dependence of the hamiltonian. args : dictionary; Dictionary with variables required to evaluate H. J_cb : callback functions; A callback function that computes the noise power spectrum, as; a function of frequency, associated with the collapse operator `c_op`. w_th : float; The temperature in units of frequency. kmax : int; The truncation of the number of sidebands (default 5). f_modes_table_t : nested list of :class:`qutip.qobj` (kets); A lookup-table of Floquet modes at times precalculated by; :func:`qutip.floquet.floquet_modes_table` (optional). options : :class:`qutip.solver.Options`; options for the",MatchSource.WIKI,docs/4.7/modules/qutip/floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/floquet.html
https://qutip.org/docs/4.7/modules/qutip/floquet.html:15724,Deployability,integrat,integration,15724,"the hamiltonian. args : dictionary; Dictionary with variables required to evaluate H. J_cb : callback functions; A callback function that computes the noise power spectrum, as; a function of frequency, associated with the collapse operator `c_op`. w_th : float; The temperature in units of frequency. kmax : int; The truncation of the number of sidebands (default 5). f_modes_table_t : nested list of :class:`qutip.qobj` (kets); A lookup-table of Floquet modes at times precalculated by; :func:`qutip.floquet.floquet_modes_table` (optional). options : :class:`qutip.solver.Options`; options for the ODE solver. Returns; -------. output : list. A list (Delta, X, Gamma, A) containing the matrices Delta, X, Gamma; and A used in the construction of the Floquet-Markov master equation. """""". N = len(f_energies); M = 2 * kmax + 1. omega = (2 * pi) / T. Delta = np.zeros((N, N, M)); X = np.zeros((N, N, M), dtype=complex); Gamma = np.zeros((N, N, M)); A = np.zeros((N, N)). # time steps for integration of coupling operator; nT = int(np.max([20 * kmax, 100])); dT = T / nT; tlist = np.arange(dT, T + dT / 2, dT). if f_modes_table_t is None:; f_modes_table_t = floquet_modes_table(f_modes_0, f_energies,; np.linspace(0, T, nT + 1), H, T,; args). for t in tlist:; # TODO: repeated invocations of floquet_modes_t is; # inefficient... make a and b outer loops and use the mesolve; # instead of the propagator. f_modes_t = np.hstack([f.full() for f in floquet_modes_t_lookup(; f_modes_table_t, t, T)]); FF = f_modes_t.T.conj() @ c_op.full() @ f_modes_t; phi = exp(-1j * np.arange(-kmax, kmax+1) * omega * t); X += (dT / T) * np.einsum(""ij,k->ijk"", FF, phi). Heaviside = lambda x: ((np.sign(x) + 1) / 2.0); for a in range(N):; for b in range(N):; k_idx = 0; for k in range(-kmax, kmax + 1, 1):; Delta[a, b, k_idx] = f_energies[a] - f_energies[b] + k * omega; Gamma[a, b, k_idx] = 2 * pi * Heaviside(Delta[a, b, k_idx]) * \; J_cb(Delta[a, b, k_idx]) * abs(X[a, b, k_idx]) ** 2; k_idx += 1. for a in range(N):; fo",MatchSource.WIKI,docs/4.7/modules/qutip/floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/floquet.html
https://qutip.org/docs/4.7/modules/qutip/floquet.html:23668,Deployability,integrat,integrator,23668,"okup); and not all(x is None for x in lab_lookup); ):; warnings.warn(; ""if transformation back to the computational basis in the lab""; ""frame is desired, all of `f_modes_t`, `f_energies` and `T` must""; ""be supplied.""; ); f_modes_table_t = f_energies = T = None. # Initial state.; if f_modes_0 is not None:; rho0 = rho0.transform(f_modes_0). # Evolved states.; if floquet_basis:; def transform(rho, t):; return rho; elif f_modes_table_t is not None:; # Lab frame, computational basis.; def transform(rho, t):; f_modes_t = floquet_modes_t_lookup(f_modes_table_t, t, T); f_states_t = floquet_states(f_modes_t, f_energies, t); return rho.transform(f_states_t, True); elif f_modes_0 is not None:; # Interaction picture, computational basis.; def transform(rho, t):; return rho.transform(f_modes_0, False); else:; raise ValueError(; ""cannot transform out of the Floquet basis without some knowledge ""; ""of the Floquet modes. Pass `f_modes_0`, or all of `f_modes_t`, ""; ""`f_energies` and `T`.""; ). # Setup integrator.; initial_vector = mat2vec(rho0.full()); r = scipy.integrate.ode(cy_ode_rhs); r.set_f_params(R.data.data, R.data.indices, R.data.indptr); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]). # Main evolution loop.; for t_idx, t in enumerate(tlist):; if not r.successful():; break; rho = transform(Qobj(vec2mat(r.y), rho0.dims, rho0.shape), t); if expt_callback:; e_ops(t, rho); else:; for m, e_op in enumerate(e_ops):; output.expect[m][t_idx] = expect(e_op, rho); if store_states:; output.states.append(rho); r.integrate(r.t + dt); return output. # -----------------------------------------------------------------------------; # Solve the Floquet-Markov master equation; #; #. [docs]def fmmesolve(H, rho0, tlist, c_ops=[], e_ops=[], spectra_cb=[], T=None,; args={}, options=Options(), floquet_basis=True, kmax=5,; _safe_mode=True, options_modes=None):; """"""; Solve the dynamics f",MatchSource.WIKI,docs/4.7/modules/qutip/floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/floquet.html
https://qutip.org/docs/4.7/modules/qutip/floquet.html:23730,Deployability,integrat,integrate,23730,"rn(; ""if transformation back to the computational basis in the lab""; ""frame is desired, all of `f_modes_t`, `f_energies` and `T` must""; ""be supplied.""; ); f_modes_table_t = f_energies = T = None. # Initial state.; if f_modes_0 is not None:; rho0 = rho0.transform(f_modes_0). # Evolved states.; if floquet_basis:; def transform(rho, t):; return rho; elif f_modes_table_t is not None:; # Lab frame, computational basis.; def transform(rho, t):; f_modes_t = floquet_modes_t_lookup(f_modes_table_t, t, T); f_states_t = floquet_states(f_modes_t, f_energies, t); return rho.transform(f_states_t, True); elif f_modes_0 is not None:; # Interaction picture, computational basis.; def transform(rho, t):; return rho.transform(f_modes_0, False); else:; raise ValueError(; ""cannot transform out of the Floquet basis without some knowledge ""; ""of the Floquet modes. Pass `f_modes_0`, or all of `f_modes_t`, ""; ""`f_energies` and `T`.""; ). # Setup integrator.; initial_vector = mat2vec(rho0.full()); r = scipy.integrate.ode(cy_ode_rhs); r.set_f_params(R.data.data, R.data.indices, R.data.indptr); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]). # Main evolution loop.; for t_idx, t in enumerate(tlist):; if not r.successful():; break; rho = transform(Qobj(vec2mat(r.y), rho0.dims, rho0.shape), t); if expt_callback:; e_ops(t, rho); else:; for m, e_op in enumerate(e_ops):; output.expect[m][t_idx] = expect(e_op, rho); if store_states:; output.states.append(rho); r.integrate(r.t + dt); return output. # -----------------------------------------------------------------------------; # Solve the Floquet-Markov master equation; #; #. [docs]def fmmesolve(H, rho0, tlist, c_ops=[], e_ops=[], spectra_cb=[], T=None,; args={}, options=Options(), floquet_basis=True, kmax=5,; _safe_mode=True, options_modes=None):; """"""; Solve the dynamics for the system using the Floquet-Markov master equation. .. note::.",MatchSource.WIKI,docs/4.7/modules/qutip/floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/floquet.html
https://qutip.org/docs/4.7/modules/qutip/floquet.html:24301,Deployability,integrat,integrate,24301,"sform(f_states_t, True); elif f_modes_0 is not None:; # Interaction picture, computational basis.; def transform(rho, t):; return rho.transform(f_modes_0, False); else:; raise ValueError(; ""cannot transform out of the Floquet basis without some knowledge ""; ""of the Floquet modes. Pass `f_modes_0`, or all of `f_modes_t`, ""; ""`f_energies` and `T`.""; ). # Setup integrator.; initial_vector = mat2vec(rho0.full()); r = scipy.integrate.ode(cy_ode_rhs); r.set_f_params(R.data.data, R.data.indices, R.data.indptr); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]). # Main evolution loop.; for t_idx, t in enumerate(tlist):; if not r.successful():; break; rho = transform(Qobj(vec2mat(r.y), rho0.dims, rho0.shape), t); if expt_callback:; e_ops(t, rho); else:; for m, e_op in enumerate(e_ops):; output.expect[m][t_idx] = expect(e_op, rho); if store_states:; output.states.append(rho); r.integrate(r.t + dt); return output. # -----------------------------------------------------------------------------; # Solve the Floquet-Markov master equation; #; #. [docs]def fmmesolve(H, rho0, tlist, c_ops=[], e_ops=[], spectra_cb=[], T=None,; args={}, options=Options(), floquet_basis=True, kmax=5,; _safe_mode=True, options_modes=None):; """"""; Solve the dynamics for the system using the Floquet-Markov master equation. .. note::. This solver currently does not support multiple collapse operators. Parameters; ----------. H : :class:`qutip.qobj`; system Hamiltonian. rho0 / psi0 : :class:`qutip.qobj`; initial density matrix or state vector (ket). tlist : *list* / *array*; list of times for :math:`t`. c_ops : list of :class:`qutip.qobj`; list of collapse operators. e_ops : list of :class:`qutip.qobj` / callback function; list of operators for which to evaluate expectation values. spectra_cb : list callback functions; List of callback functions that compute the noise power spectrum as; a functio",MatchSource.WIKI,docs/4.7/modules/qutip/floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/floquet.html
https://qutip.org/docs/4.7/modules/qutip/floquet.html:27961,Deployability,update,updated,27961," * (kB / h) * 2 * pi * 1e-9 \; #doctest: +SKIP. options : :class:`qutip.solver.Options`; options for the ODE solver. For solving the master equation. floquet_basis : bool; Will return results in Floquet basis or computational basis; (optional). k_max : int; The truncation of the number of sidebands (default 5). options_modes : :class:`qutip.solver.Options`; options for the ODE solver. For computing Floquet modes. Returns; -------. output : :class:`qutip.solver.Result`. An instance of the class :class:`qutip.solver.Result`, which contains; either an *array* of expectation values for the times specified; by `tlist`.; """""". if _safe_mode:; _solver_safety_check(H, rho0, c_ops, e_ops, args). if options_modes is None:; options_modes_table = Options(); else:; options_modes_table = options_modes. if T is None:; T = max(tlist). if len(spectra_cb) == 0:; # add white noise callbacks if absent; spectra_cb = [lambda w: 1.0] * len(c_ops). f_modes_0, f_energies = floquet_modes(H, T, args,; options=options_modes). f_modes_table_t = floquet_modes_table(f_modes_0, f_energies,; np.linspace(0, T, 500 + 1),; H, T, args,; options=options_modes_table). # get w_th from args if it exists; if 'w_th' in args:; w_th = args['w_th']; else:; w_th = 0. # TODO: loop over input c_ops and spectra_cb, calculate one R for each set. # calculate the rate-matrices for the floquet-markov master equation; Delta, X, Gamma, Amat = floquet_master_equation_rates(; f_modes_0, f_energies, c_ops[0], H, T, args, spectra_cb[0],; w_th, kmax, f_modes_table_t). # the floquet-markov master equation tensor; R = floquet_master_equation_tensor(Amat, f_energies). return floquet_markov_mesolve(R, rho0, tlist, e_ops,; options=options,; floquet_basis=floquet_basis,; f_modes_0=f_modes_0,; f_modes_table_t=f_modes_table_t,; T=T,; f_energies=f_energies). © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/modules/qutip/floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/floquet.html
https://qutip.org/docs/4.7/modules/qutip/floquet.html:3028,Energy Efficiency,energy,energy,3028,"ip.qobj`; system Hamiltonian, time-dependent with period `T`. args : dictionary; dictionary with variables required to evaluate H. T : float; The period of the time-dependence of the hamiltonian. The default value; 'None' indicates that the 'tlist' spans a single period of the driving. U : :class:`qutip.qobj`; The propagator for the time-dependent Hamiltonian with period `T`.; If U is `None` (default), it will be calculated from the Hamiltonian; `H` using :func:`qutip.propagator.propagator`. options : :class:`qutip.solver.Options`; options for the ODE solver. For the propagator U. Returns; -------. output : list of kets, list of quasi energies. Two lists: the Floquet modes as kets and the quasi energies. """""". if U is None:; # get the unitary propagator; U = propagator(H, T, [], args=args, options=copy(options)). # find the eigenstates for the propagator; evals, evecs = la.eig(U.full()). eargs = angle(evals). # make sure that the phase is in the interval [-pi, pi], so that; # the quasi energy is in the interval [-pi/T, pi/T] where T is the; # period of the driving. eargs += (eargs <= -2*pi) * (2*pi) +; # (eargs > 0) * (-2*pi); eargs += (eargs <= -pi) * (2 * pi) + (eargs > pi) * (-2 * pi); e_quasi = -eargs / T. # sort by the quasi energy; if sort:; order = np.argsort(-e_quasi); else:; order = list(range(len(evals))). # prepare a list of kets for the floquet states; new_dims = [U.dims[0], [1] * len(U.dims[0])]; new_shape = [U.shape[0], 1]; kets_order = [Qobj(np.array(evecs[:, o]).T,; dims=new_dims, shape=new_shape) for o in order]. return kets_order, e_quasi[order]. [docs]def floquet_modes_t(f_modes_0, f_energies, t, H, T, args=None,; options=None):; """"""; Calculate the Floquet modes at times tlist Phi_alpha(tlist) propagting the; initial Floquet modes Phi_alpha(0). Parameters; ----------. f_modes_0 : list of :class:`qutip.qobj` (kets); Floquet modes at :math:`t`. f_energies : list; Floquet energies. t : float; The time at which to evaluate the floquet modes. H : :class:",MatchSource.WIKI,docs/4.7/modules/qutip/floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/floquet.html
https://qutip.org/docs/4.7/modules/qutip/floquet.html:3277,Energy Efficiency,energy,energy,3277,"s a single period of the driving. U : :class:`qutip.qobj`; The propagator for the time-dependent Hamiltonian with period `T`.; If U is `None` (default), it will be calculated from the Hamiltonian; `H` using :func:`qutip.propagator.propagator`. options : :class:`qutip.solver.Options`; options for the ODE solver. For the propagator U. Returns; -------. output : list of kets, list of quasi energies. Two lists: the Floquet modes as kets and the quasi energies. """""". if U is None:; # get the unitary propagator; U = propagator(H, T, [], args=args, options=copy(options)). # find the eigenstates for the propagator; evals, evecs = la.eig(U.full()). eargs = angle(evals). # make sure that the phase is in the interval [-pi, pi], so that; # the quasi energy is in the interval [-pi/T, pi/T] where T is the; # period of the driving. eargs += (eargs <= -2*pi) * (2*pi) +; # (eargs > 0) * (-2*pi); eargs += (eargs <= -pi) * (2 * pi) + (eargs > pi) * (-2 * pi); e_quasi = -eargs / T. # sort by the quasi energy; if sort:; order = np.argsort(-e_quasi); else:; order = list(range(len(evals))). # prepare a list of kets for the floquet states; new_dims = [U.dims[0], [1] * len(U.dims[0])]; new_shape = [U.shape[0], 1]; kets_order = [Qobj(np.array(evecs[:, o]).T,; dims=new_dims, shape=new_shape) for o in order]. return kets_order, e_quasi[order]. [docs]def floquet_modes_t(f_modes_0, f_energies, t, H, T, args=None,; options=None):; """"""; Calculate the Floquet modes at times tlist Phi_alpha(tlist) propagting the; initial Floquet modes Phi_alpha(0). Parameters; ----------. f_modes_0 : list of :class:`qutip.qobj` (kets); Floquet modes at :math:`t`. f_energies : list; Floquet energies. t : float; The time at which to evaluate the floquet modes. H : :class:`qutip.qobj`; system Hamiltonian, time-dependent with period `T`. args : dictionary; dictionary with variables required to evaluate H. T : float; The period of the time-dependence of the hamiltonian. options : :class:`qutip.solver.Options`; options for",MatchSource.WIKI,docs/4.7/modules/qutip/floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/floquet.html
https://qutip.org/docs/4.7/modules/qutip/floquet.html:14895,Energy Efficiency,power,power,14895,"f output.num_expect == 0:; output.states.append(Qobj(psi_t)); else:; for e_idx, e in enumerate(e_ops):; output.expect[e_idx][t_idx] = expect(e, psi_t). return output. [docs]def floquet_master_equation_rates(f_modes_0, f_energies, c_op, H, T,; args, J_cb, w_th, kmax=5,; f_modes_table_t=None):; """"""; Calculate the rates and matrix elements for the Floquet-Markov master; equation. .. note :; The number of integration steps (for calculating X) within one period; is set to 20 * kmax. Parameters; ----------. f_modes_0 : list of :class:`qutip.qobj` (kets); A list of initial Floquet modes. f_energies : array; The Floquet energies. c_op : :class:`qutip.qobj`; The collapse operators describing the dissipation. H : :class:`qutip.qobj`; System Hamiltonian, time-dependent with period `T`. T : float; The period of the time-dependence of the hamiltonian. args : dictionary; Dictionary with variables required to evaluate H. J_cb : callback functions; A callback function that computes the noise power spectrum, as; a function of frequency, associated with the collapse operator `c_op`. w_th : float; The temperature in units of frequency. kmax : int; The truncation of the number of sidebands (default 5). f_modes_table_t : nested list of :class:`qutip.qobj` (kets); A lookup-table of Floquet modes at times precalculated by; :func:`qutip.floquet.floquet_modes_table` (optional). options : :class:`qutip.solver.Options`; options for the ODE solver. Returns; -------. output : list. A list (Delta, X, Gamma, A) containing the matrices Delta, X, Gamma; and A used in the construction of the Floquet-Markov master equation. """""". N = len(f_energies); M = 2 * kmax + 1. omega = (2 * pi) / T. Delta = np.zeros((N, N, M)); X = np.zeros((N, N, M), dtype=complex); Gamma = np.zeros((N, N, M)); A = np.zeros((N, N)). # time steps for integration of coupling operator; nT = int(np.max([20 * kmax, 100])); dT = T / nT; tlist = np.arange(dT, T + dT / 2, dT). if f_modes_table_t is None:; f_modes_table_t = floquet_mod",MatchSource.WIKI,docs/4.7/modules/qutip/floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/floquet.html
https://qutip.org/docs/4.7/modules/qutip/floquet.html:25279,Energy Efficiency,power,power,25279,"put.states.append(rho); r.integrate(r.t + dt); return output. # -----------------------------------------------------------------------------; # Solve the Floquet-Markov master equation; #; #. [docs]def fmmesolve(H, rho0, tlist, c_ops=[], e_ops=[], spectra_cb=[], T=None,; args={}, options=Options(), floquet_basis=True, kmax=5,; _safe_mode=True, options_modes=None):; """"""; Solve the dynamics for the system using the Floquet-Markov master equation. .. note::. This solver currently does not support multiple collapse operators. Parameters; ----------. H : :class:`qutip.qobj`; system Hamiltonian. rho0 / psi0 : :class:`qutip.qobj`; initial density matrix or state vector (ket). tlist : *list* / *array*; list of times for :math:`t`. c_ops : list of :class:`qutip.qobj`; list of collapse operators. e_ops : list of :class:`qutip.qobj` / callback function; list of operators for which to evaluate expectation values. spectra_cb : list callback functions; List of callback functions that compute the noise power spectrum as; a function of frequency for the collapse operators in `c_ops`. T : float; The period of the time-dependence of the hamiltonian. The default value; 'None' indicates that the 'tlist' spans a single period of the driving. args : *dictionary*; dictionary of parameters for time-dependent Hamiltonians and; collapse operators. This dictionary should also contain an entry 'w_th', which is; the temperature of the environment (if finite) in the; energy/frequency units of the Hamiltonian. For example, if; the Hamiltonian written in units of 2pi GHz, and the; temperature is given in K, use the following conversion. >>> temperature = 25e-3 # unit K # doctest: +SKIP; >>> h = 6.626e-34 # doctest: +SKIP; >>> kB = 1.38e-23 # doctest: +SKIP; >>> args['w_th'] = temperature * (kB / h) * 2 * pi * 1e-9 \; #doctest: +SKIP. options : :class:`qutip.solver.Options`; options for the ODE solver. For solving the master equation. floquet_basis : bool; Will return results in Floquet basis or c",MatchSource.WIKI,docs/4.7/modules/qutip/floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/floquet.html
https://qutip.org/docs/4.7/modules/qutip/floquet.html:25738,Energy Efficiency,energy,energy,25738,"t-Markov master equation. .. note::. This solver currently does not support multiple collapse operators. Parameters; ----------. H : :class:`qutip.qobj`; system Hamiltonian. rho0 / psi0 : :class:`qutip.qobj`; initial density matrix or state vector (ket). tlist : *list* / *array*; list of times for :math:`t`. c_ops : list of :class:`qutip.qobj`; list of collapse operators. e_ops : list of :class:`qutip.qobj` / callback function; list of operators for which to evaluate expectation values. spectra_cb : list callback functions; List of callback functions that compute the noise power spectrum as; a function of frequency for the collapse operators in `c_ops`. T : float; The period of the time-dependence of the hamiltonian. The default value; 'None' indicates that the 'tlist' spans a single period of the driving. args : *dictionary*; dictionary of parameters for time-dependent Hamiltonians and; collapse operators. This dictionary should also contain an entry 'w_th', which is; the temperature of the environment (if finite) in the; energy/frequency units of the Hamiltonian. For example, if; the Hamiltonian written in units of 2pi GHz, and the; temperature is given in K, use the following conversion. >>> temperature = 25e-3 # unit K # doctest: +SKIP; >>> h = 6.626e-34 # doctest: +SKIP; >>> kB = 1.38e-23 # doctest: +SKIP; >>> args['w_th'] = temperature * (kB / h) * 2 * pi * 1e-9 \; #doctest: +SKIP. options : :class:`qutip.solver.Options`; options for the ODE solver. For solving the master equation. floquet_basis : bool; Will return results in Floquet basis or computational basis; (optional). k_max : int; The truncation of the number of sidebands (default 5). options_modes : :class:`qutip.solver.Options`; options for the ODE solver. For computing Floquet modes. Returns; -------. output : :class:`qutip.solver.Result`. An instance of the class :class:`qutip.solver.Result`, which contains; either an *array* of expectation values for the times specified; by `tlist`.; """""". if _safe_m",MatchSource.WIKI,docs/4.7/modules/qutip/floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/floquet.html
https://qutip.org/docs/4.7/modules/qutip/floquet.html:2063,Integrability,depend,dependent,2063,"om qutip.mesolve import mesolve; from qutip.sesolve import sesolve; from qutip.rhs_generate import rhs_clear; from qutip.steadystate import steadystate; from qutip.states import ket2dm; from qutip.states import projection; from qutip.solver import Options; from qutip.propagator import propagator; from qutip.solver import Result, _solver_safety_check; from qutip.cy.spmatfuncs import cy_ode_rhs; from qutip.expect import expect; from qutip.utilities import n_thermal. [docs]def floquet_modes(H, T, args=None, sort=False, U=None, options=None):; """"""; Calculate the initial Floquet modes Phi_alpha(0) for a driven system with; period T. Returns a list of :class:`qutip.qobj` instances representing the Floquet; modes and a list of corresponding quasienergies, sorted by increasing; quasienergy in the interval [-pi/T, pi/T]. The optional parameter `sort`; decides if the output is to be sorted in increasing quasienergies or not. Parameters; ----------. H : :class:`qutip.qobj`; system Hamiltonian, time-dependent with period `T`. args : dictionary; dictionary with variables required to evaluate H. T : float; The period of the time-dependence of the hamiltonian. The default value; 'None' indicates that the 'tlist' spans a single period of the driving. U : :class:`qutip.qobj`; The propagator for the time-dependent Hamiltonian with period `T`.; If U is `None` (default), it will be calculated from the Hamiltonian; `H` using :func:`qutip.propagator.propagator`. options : :class:`qutip.solver.Options`; options for the ODE solver. For the propagator U. Returns; -------. output : list of kets, list of quasi energies. Two lists: the Floquet modes as kets and the quasi energies. """""". if U is None:; # get the unitary propagator; U = propagator(H, T, [], args=args, options=copy(options)). # find the eigenstates for the propagator; evals, evecs = la.eig(U.full()). eargs = angle(evals). # make sure that the phase is in the interval [-pi, pi], so that; # the quasi energy is in the interval [-pi/T",MatchSource.WIKI,docs/4.7/modules/qutip/floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/floquet.html
https://qutip.org/docs/4.7/modules/qutip/floquet.html:2193,Integrability,depend,dependence,2193,"te import steadystate; from qutip.states import ket2dm; from qutip.states import projection; from qutip.solver import Options; from qutip.propagator import propagator; from qutip.solver import Result, _solver_safety_check; from qutip.cy.spmatfuncs import cy_ode_rhs; from qutip.expect import expect; from qutip.utilities import n_thermal. [docs]def floquet_modes(H, T, args=None, sort=False, U=None, options=None):; """"""; Calculate the initial Floquet modes Phi_alpha(0) for a driven system with; period T. Returns a list of :class:`qutip.qobj` instances representing the Floquet; modes and a list of corresponding quasienergies, sorted by increasing; quasienergy in the interval [-pi/T, pi/T]. The optional parameter `sort`; decides if the output is to be sorted in increasing quasienergies or not. Parameters; ----------. H : :class:`qutip.qobj`; system Hamiltonian, time-dependent with period `T`. args : dictionary; dictionary with variables required to evaluate H. T : float; The period of the time-dependence of the hamiltonian. The default value; 'None' indicates that the 'tlist' spans a single period of the driving. U : :class:`qutip.qobj`; The propagator for the time-dependent Hamiltonian with period `T`.; If U is `None` (default), it will be calculated from the Hamiltonian; `H` using :func:`qutip.propagator.propagator`. options : :class:`qutip.solver.Options`; options for the ODE solver. For the propagator U. Returns; -------. output : list of kets, list of quasi energies. Two lists: the Floquet modes as kets and the quasi energies. """""". if U is None:; # get the unitary propagator; U = propagator(H, T, [], args=args, options=copy(options)). # find the eigenstates for the propagator; evals, evecs = la.eig(U.full()). eargs = angle(evals). # make sure that the phase is in the interval [-pi, pi], so that; # the quasi energy is in the interval [-pi/T, pi/T] where T is the; # period of the driving. eargs += (eargs <= -2*pi) * (2*pi) +; # (eargs > 0) * (-2*pi); eargs += (eargs <= ",MatchSource.WIKI,docs/4.7/modules/qutip/floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/floquet.html
https://qutip.org/docs/4.7/modules/qutip/floquet.html:2368,Integrability,depend,dependent,2368,"solver import Result, _solver_safety_check; from qutip.cy.spmatfuncs import cy_ode_rhs; from qutip.expect import expect; from qutip.utilities import n_thermal. [docs]def floquet_modes(H, T, args=None, sort=False, U=None, options=None):; """"""; Calculate the initial Floquet modes Phi_alpha(0) for a driven system with; period T. Returns a list of :class:`qutip.qobj` instances representing the Floquet; modes and a list of corresponding quasienergies, sorted by increasing; quasienergy in the interval [-pi/T, pi/T]. The optional parameter `sort`; decides if the output is to be sorted in increasing quasienergies or not. Parameters; ----------. H : :class:`qutip.qobj`; system Hamiltonian, time-dependent with period `T`. args : dictionary; dictionary with variables required to evaluate H. T : float; The period of the time-dependence of the hamiltonian. The default value; 'None' indicates that the 'tlist' spans a single period of the driving. U : :class:`qutip.qobj`; The propagator for the time-dependent Hamiltonian with period `T`.; If U is `None` (default), it will be calculated from the Hamiltonian; `H` using :func:`qutip.propagator.propagator`. options : :class:`qutip.solver.Options`; options for the ODE solver. For the propagator U. Returns; -------. output : list of kets, list of quasi energies. Two lists: the Floquet modes as kets and the quasi energies. """""". if U is None:; # get the unitary propagator; U = propagator(H, T, [], args=args, options=copy(options)). # find the eigenstates for the propagator; evals, evecs = la.eig(U.full()). eargs = angle(evals). # make sure that the phase is in the interval [-pi, pi], so that; # the quasi energy is in the interval [-pi/T, pi/T] where T is the; # period of the driving. eargs += (eargs <= -2*pi) * (2*pi) +; # (eargs > 0) * (-2*pi); eargs += (eargs <= -pi) * (2 * pi) + (eargs > pi) * (-2 * pi); e_quasi = -eargs / T. # sort by the quasi energy; if sort:; order = np.argsort(-e_quasi); else:; order = list(range(len(evals))). # pre",MatchSource.WIKI,docs/4.7/modules/qutip/floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/floquet.html
https://qutip.org/docs/4.7/modules/qutip/floquet.html:4068,Integrability,depend,dependent,4068,"T] where T is the; # period of the driving. eargs += (eargs <= -2*pi) * (2*pi) +; # (eargs > 0) * (-2*pi); eargs += (eargs <= -pi) * (2 * pi) + (eargs > pi) * (-2 * pi); e_quasi = -eargs / T. # sort by the quasi energy; if sort:; order = np.argsort(-e_quasi); else:; order = list(range(len(evals))). # prepare a list of kets for the floquet states; new_dims = [U.dims[0], [1] * len(U.dims[0])]; new_shape = [U.shape[0], 1]; kets_order = [Qobj(np.array(evecs[:, o]).T,; dims=new_dims, shape=new_shape) for o in order]. return kets_order, e_quasi[order]. [docs]def floquet_modes_t(f_modes_0, f_energies, t, H, T, args=None,; options=None):; """"""; Calculate the Floquet modes at times tlist Phi_alpha(tlist) propagting the; initial Floquet modes Phi_alpha(0). Parameters; ----------. f_modes_0 : list of :class:`qutip.qobj` (kets); Floquet modes at :math:`t`. f_energies : list; Floquet energies. t : float; The time at which to evaluate the floquet modes. H : :class:`qutip.qobj`; system Hamiltonian, time-dependent with period `T`. args : dictionary; dictionary with variables required to evaluate H. T : float; The period of the time-dependence of the hamiltonian. options : :class:`qutip.solver.Options`; options for the ODE solver. For the propagator. Returns; -------. output : list of kets. The Floquet modes as kets at time :math:`t`. """"""; # find t in [0,T] such that t_orig = t + n * T for integer n; t = t - int(t / T) * T; f_modes_t = []. # get the unitary propagator from 0 to t; if t > 0.0:; U = propagator(H, t, [], args, options=copy(options)). for n in np.arange(len(f_modes_0)):; f_modes_t.append(U * f_modes_0[n] * exp(1j * f_energies[n] * t)); else:; f_modes_t = f_modes_0. return f_modes_t. [docs]def floquet_modes_table(f_modes_0, f_energies, tlist, H, T, args=None,; options=None):; """"""; Pre-calculate the Floquet modes for a range of times spanning the floquet; period. Can later be used as a table to look up the floquet modes for; any time. Parameters; ----------. f_modes_0 : li",MatchSource.WIKI,docs/4.7/modules/qutip/floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/floquet.html
https://qutip.org/docs/4.7/modules/qutip/floquet.html:4198,Integrability,depend,dependence,4198," * (2 * pi) + (eargs > pi) * (-2 * pi); e_quasi = -eargs / T. # sort by the quasi energy; if sort:; order = np.argsort(-e_quasi); else:; order = list(range(len(evals))). # prepare a list of kets for the floquet states; new_dims = [U.dims[0], [1] * len(U.dims[0])]; new_shape = [U.shape[0], 1]; kets_order = [Qobj(np.array(evecs[:, o]).T,; dims=new_dims, shape=new_shape) for o in order]. return kets_order, e_quasi[order]. [docs]def floquet_modes_t(f_modes_0, f_energies, t, H, T, args=None,; options=None):; """"""; Calculate the Floquet modes at times tlist Phi_alpha(tlist) propagting the; initial Floquet modes Phi_alpha(0). Parameters; ----------. f_modes_0 : list of :class:`qutip.qobj` (kets); Floquet modes at :math:`t`. f_energies : list; Floquet energies. t : float; The time at which to evaluate the floquet modes. H : :class:`qutip.qobj`; system Hamiltonian, time-dependent with period `T`. args : dictionary; dictionary with variables required to evaluate H. T : float; The period of the time-dependence of the hamiltonian. options : :class:`qutip.solver.Options`; options for the ODE solver. For the propagator. Returns; -------. output : list of kets. The Floquet modes as kets at time :math:`t`. """"""; # find t in [0,T] such that t_orig = t + n * T for integer n; t = t - int(t / T) * T; f_modes_t = []. # get the unitary propagator from 0 to t; if t > 0.0:; U = propagator(H, t, [], args, options=copy(options)). for n in np.arange(len(f_modes_0)):; f_modes_t.append(U * f_modes_0[n] * exp(1j * f_energies[n] * t)); else:; f_modes_t = f_modes_0. return f_modes_t. [docs]def floquet_modes_table(f_modes_0, f_energies, tlist, H, T, args=None,; options=None):; """"""; Pre-calculate the Floquet modes for a range of times spanning the floquet; period. Can later be used as a table to look up the floquet modes for; any time. Parameters; ----------. f_modes_0 : list of :class:`qutip.qobj` (kets); Floquet modes at :math:`t`. f_energies : list; Floquet energies. tlist : array; The list of times",MatchSource.WIKI,docs/4.7/modules/qutip/floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/floquet.html
https://qutip.org/docs/4.7/modules/qutip/floquet.html:5287,Integrability,depend,dependent,5287,"e ODE solver. For the propagator. Returns; -------. output : list of kets. The Floquet modes as kets at time :math:`t`. """"""; # find t in [0,T] such that t_orig = t + n * T for integer n; t = t - int(t / T) * T; f_modes_t = []. # get the unitary propagator from 0 to t; if t > 0.0:; U = propagator(H, t, [], args, options=copy(options)). for n in np.arange(len(f_modes_0)):; f_modes_t.append(U * f_modes_0[n] * exp(1j * f_energies[n] * t)); else:; f_modes_t = f_modes_0. return f_modes_t. [docs]def floquet_modes_table(f_modes_0, f_energies, tlist, H, T, args=None,; options=None):; """"""; Pre-calculate the Floquet modes for a range of times spanning the floquet; period. Can later be used as a table to look up the floquet modes for; any time. Parameters; ----------. f_modes_0 : list of :class:`qutip.qobj` (kets); Floquet modes at :math:`t`. f_energies : list; Floquet energies. tlist : array; The list of times at which to evaluate the floquet modes. H : :class:`qutip.qobj`; system Hamiltonian, time-dependent with period `T`. T : float; The period of the time-dependence of the hamiltonian. args : dictionary; dictionary with variables required to evaluate H. options : :class:`qutip.solver.Options`; options for the ODE solver. Returns; -------. output : nested list. A nested list of Floquet modes as kets for each time in `tlist`. """"""; options = copy(options) or Options(); # truncate tlist to the driving period; tlist_period = tlist[np.where(tlist <= T)]. f_modes_table_t = [[] for t in tlist_period]. opt = options; opt.rhs_reuse = True; rhs_clear(). for n, f_mode in enumerate(f_modes_0):; output = sesolve(H, f_mode, tlist_period, [], args, opt); for t_idx, f_state_t in enumerate(output.states):; f_modes_table_t[t_idx].append(; f_state_t * exp(1j * f_energies[n] * tlist_period[t_idx])). return f_modes_table_t. [docs]def floquet_modes_t_lookup(f_modes_table_t, t, T):; """"""; Lookup the floquet mode at time t in the pre-calculated table of floquet; modes in the first period of the time",MatchSource.WIKI,docs/4.7/modules/qutip/floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/floquet.html
https://qutip.org/docs/4.7/modules/qutip/floquet.html:5348,Integrability,depend,dependence,5348,"list of kets. The Floquet modes as kets at time :math:`t`. """"""; # find t in [0,T] such that t_orig = t + n * T for integer n; t = t - int(t / T) * T; f_modes_t = []. # get the unitary propagator from 0 to t; if t > 0.0:; U = propagator(H, t, [], args, options=copy(options)). for n in np.arange(len(f_modes_0)):; f_modes_t.append(U * f_modes_0[n] * exp(1j * f_energies[n] * t)); else:; f_modes_t = f_modes_0. return f_modes_t. [docs]def floquet_modes_table(f_modes_0, f_energies, tlist, H, T, args=None,; options=None):; """"""; Pre-calculate the Floquet modes for a range of times spanning the floquet; period. Can later be used as a table to look up the floquet modes for; any time. Parameters; ----------. f_modes_0 : list of :class:`qutip.qobj` (kets); Floquet modes at :math:`t`. f_energies : list; Floquet energies. tlist : array; The list of times at which to evaluate the floquet modes. H : :class:`qutip.qobj`; system Hamiltonian, time-dependent with period `T`. T : float; The period of the time-dependence of the hamiltonian. args : dictionary; dictionary with variables required to evaluate H. options : :class:`qutip.solver.Options`; options for the ODE solver. Returns; -------. output : nested list. A nested list of Floquet modes as kets for each time in `tlist`. """"""; options = copy(options) or Options(); # truncate tlist to the driving period; tlist_period = tlist[np.where(tlist <= T)]. f_modes_table_t = [[] for t in tlist_period]. opt = options; opt.rhs_reuse = True; rhs_clear(). for n, f_mode in enumerate(f_modes_0):; output = sesolve(H, f_mode, tlist_period, [], args, opt); for t_idx, f_state_t in enumerate(output.states):; f_modes_table_t[t_idx].append(; f_state_t * exp(1j * f_energies[n] * tlist_period[t_idx])). return f_modes_table_t. [docs]def floquet_modes_t_lookup(f_modes_table_t, t, T):; """"""; Lookup the floquet mode at time t in the pre-calculated table of floquet; modes in the first period of the time-dependence. Parameters; ----------. f_modes_table_t : nested ",MatchSource.WIKI,docs/4.7/modules/qutip/floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/floquet.html
https://qutip.org/docs/4.7/modules/qutip/floquet.html:6285,Integrability,depend,dependence,6285,"ich to evaluate the floquet modes. H : :class:`qutip.qobj`; system Hamiltonian, time-dependent with period `T`. T : float; The period of the time-dependence of the hamiltonian. args : dictionary; dictionary with variables required to evaluate H. options : :class:`qutip.solver.Options`; options for the ODE solver. Returns; -------. output : nested list. A nested list of Floquet modes as kets for each time in `tlist`. """"""; options = copy(options) or Options(); # truncate tlist to the driving period; tlist_period = tlist[np.where(tlist <= T)]. f_modes_table_t = [[] for t in tlist_period]. opt = options; opt.rhs_reuse = True; rhs_clear(). for n, f_mode in enumerate(f_modes_0):; output = sesolve(H, f_mode, tlist_period, [], args, opt); for t_idx, f_state_t in enumerate(output.states):; f_modes_table_t[t_idx].append(; f_state_t * exp(1j * f_energies[n] * tlist_period[t_idx])). return f_modes_table_t. [docs]def floquet_modes_t_lookup(f_modes_table_t, t, T):; """"""; Lookup the floquet mode at time t in the pre-calculated table of floquet; modes in the first period of the time-dependence. Parameters; ----------. f_modes_table_t : nested list of :class:`qutip.qobj` (kets); A lookup-table of Floquet modes at times precalculated by; :func:`qutip.floquet.floquet_modes_table`. t : float; The time for which to evaluate the Floquet modes. T : float; The period of the time-dependence of the hamiltonian. Returns; -------. output : nested list. A list of Floquet modes as kets for the time that most closely matching; the time `t` in the supplied table of Floquet modes.; """""". # find t_wrap in [0,T] such that t = t_wrap + n * T for integer n; t_wrap = t - int(t / T) * T. # find the index in the table that corresponds to t_wrap (= tlist[t_idx]); t_idx = int(t_wrap / T * len(f_modes_table_t)). # XXX: might want to give a warning if the cast of t_idx to int discard; # a significant fraction in t_idx, which would happen if the list of time; # values isn't perfect matching the driving period; # ",MatchSource.WIKI,docs/4.7/modules/qutip/floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/floquet.html
https://qutip.org/docs/4.7/modules/qutip/floquet.html:6579,Integrability,depend,dependence,6579,"oquet modes as kets for each time in `tlist`. """"""; options = copy(options) or Options(); # truncate tlist to the driving period; tlist_period = tlist[np.where(tlist <= T)]. f_modes_table_t = [[] for t in tlist_period]. opt = options; opt.rhs_reuse = True; rhs_clear(). for n, f_mode in enumerate(f_modes_0):; output = sesolve(H, f_mode, tlist_period, [], args, opt); for t_idx, f_state_t in enumerate(output.states):; f_modes_table_t[t_idx].append(; f_state_t * exp(1j * f_energies[n] * tlist_period[t_idx])). return f_modes_table_t. [docs]def floquet_modes_t_lookup(f_modes_table_t, t, T):; """"""; Lookup the floquet mode at time t in the pre-calculated table of floquet; modes in the first period of the time-dependence. Parameters; ----------. f_modes_table_t : nested list of :class:`qutip.qobj` (kets); A lookup-table of Floquet modes at times precalculated by; :func:`qutip.floquet.floquet_modes_table`. t : float; The time for which to evaluate the Floquet modes. T : float; The period of the time-dependence of the hamiltonian. Returns; -------. output : nested list. A list of Floquet modes as kets for the time that most closely matching; the time `t` in the supplied table of Floquet modes.; """""". # find t_wrap in [0,T] such that t = t_wrap + n * T for integer n; t_wrap = t - int(t / T) * T. # find the index in the table that corresponds to t_wrap (= tlist[t_idx]); t_idx = int(t_wrap / T * len(f_modes_table_t)). # XXX: might want to give a warning if the cast of t_idx to int discard; # a significant fraction in t_idx, which would happen if the list of time; # values isn't perfect matching the driving period; # if debug: print ""t = %f -> t_wrap = %f @ %d of %d"" % (t, t_wrap, t_idx,; # N). return f_modes_table_t[t_idx]. [docs]def floquet_states(f_modes_t, f_energies, t):; """"""; Evaluate the floquet states at time t given the Floquet modes at that time. Parameters; ----------. f_modes_t : list of :class:`qutip.qobj` (kets); A list of Floquet modes for time :math:`t`. f_energies : a",MatchSource.WIKI,docs/4.7/modules/qutip/floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/floquet.html
https://qutip.org/docs/4.7/modules/qutip/floquet.html:8292,Integrability,depend,dependent,8292,"f_modes_table_t[t_idx]. [docs]def floquet_states(f_modes_t, f_energies, t):; """"""; Evaluate the floquet states at time t given the Floquet modes at that time. Parameters; ----------. f_modes_t : list of :class:`qutip.qobj` (kets); A list of Floquet modes for time :math:`t`. f_energies : array; The Floquet energies. t : float; The time for which to evaluate the Floquet states. Returns; -------. output : list. A list of Floquet states for the time :math:`t`. """""". return [(f_modes_t[i] * exp(-1j * f_energies[i] * t)); for i in np.arange(len(f_energies))]. [docs]def floquet_states_t(f_modes_0, f_energies, t, H, T, args=None,; options=None):; """"""; Evaluate the floquet states at time t given the initial Floquet modes. Parameters; ----------. f_modes_t : list of :class:`qutip.qobj` (kets); A list of initial Floquet modes (for time :math:`t=0`). f_energies : array; The Floquet energies. t : float; The time for which to evaluate the Floquet states. H : :class:`qutip.qobj`; System Hamiltonian, time-dependent with period `T`. T : float; The period of the time-dependence of the hamiltonian. args : dictionary; Dictionary with variables required to evaluate H. options : :class:`qutip.solver.Options`; options for the ODE solver. Returns; -------. output : list. A list of Floquet states for the time :math:`t`. """""". f_modes_t = floquet_modes_t(f_modes_0, f_energies, t, H, T, args,; options=options); return [(f_modes_t[i] * exp(-1j * f_energies[i] * t)); for i in np.arange(len(f_energies))]. [docs]def floquet_wavefunction(f_modes_t, f_energies, f_coeff, t):; """"""; Evaluate the wavefunction for a time t using the Floquet state; decompositon, given the Floquet modes at time `t`. Parameters; ----------. f_modes_t : list of :class:`qutip.qobj` (kets); A list of initial Floquet modes (for time :math:`t=0`). f_energies : array; The Floquet energies. f_coeff : array; The coefficients for Floquet decomposition of the initial wavefunction. t : float; The time for which to evaluate the Floquet s",MatchSource.WIKI,docs/4.7/modules/qutip/floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/floquet.html
https://qutip.org/docs/4.7/modules/qutip/floquet.html:8353,Integrability,depend,dependence,8353,"_energies, t):; """"""; Evaluate the floquet states at time t given the Floquet modes at that time. Parameters; ----------. f_modes_t : list of :class:`qutip.qobj` (kets); A list of Floquet modes for time :math:`t`. f_energies : array; The Floquet energies. t : float; The time for which to evaluate the Floquet states. Returns; -------. output : list. A list of Floquet states for the time :math:`t`. """""". return [(f_modes_t[i] * exp(-1j * f_energies[i] * t)); for i in np.arange(len(f_energies))]. [docs]def floquet_states_t(f_modes_0, f_energies, t, H, T, args=None,; options=None):; """"""; Evaluate the floquet states at time t given the initial Floquet modes. Parameters; ----------. f_modes_t : list of :class:`qutip.qobj` (kets); A list of initial Floquet modes (for time :math:`t=0`). f_energies : array; The Floquet energies. t : float; The time for which to evaluate the Floquet states. H : :class:`qutip.qobj`; System Hamiltonian, time-dependent with period `T`. T : float; The period of the time-dependence of the hamiltonian. args : dictionary; Dictionary with variables required to evaluate H. options : :class:`qutip.solver.Options`; options for the ODE solver. Returns; -------. output : list. A list of Floquet states for the time :math:`t`. """""". f_modes_t = floquet_modes_t(f_modes_0, f_energies, t, H, T, args,; options=options); return [(f_modes_t[i] * exp(-1j * f_energies[i] * t)); for i in np.arange(len(f_energies))]. [docs]def floquet_wavefunction(f_modes_t, f_energies, f_coeff, t):; """"""; Evaluate the wavefunction for a time t using the Floquet state; decompositon, given the Floquet modes at time `t`. Parameters; ----------. f_modes_t : list of :class:`qutip.qobj` (kets); A list of initial Floquet modes (for time :math:`t=0`). f_energies : array; The Floquet energies. f_coeff : array; The coefficients for Floquet decomposition of the initial wavefunction. t : float; The time for which to evaluate the Floquet states. Returns; -------. output : :class:`qutip.qobj`. The wav",MatchSource.WIKI,docs/4.7/modules/qutip/floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/floquet.html
https://qutip.org/docs/4.7/modules/qutip/floquet.html:10088,Integrability,depend,dependent,10088,"ime :math:`t=0`). f_energies : array; The Floquet energies. f_coeff : array; The coefficients for Floquet decomposition of the initial wavefunction. t : float; The time for which to evaluate the Floquet states. Returns; -------. output : :class:`qutip.qobj`. The wavefunction for the time :math:`t`. """"""; return sum([f_modes_t[i] * exp(-1j * f_energies[i] * t) * f_coeff[i]; for i in np.arange(len(f_energies))]). [docs]def floquet_wavefunction_t(f_modes_0, f_energies, f_coeff, t, H, T, args=None,; options=None):; """"""; Evaluate the wavefunction for a time t using the Floquet state; decompositon, given the initial Floquet modes. Parameters; ----------. f_modes_t : list of :class:`qutip.qobj` (kets); A list of initial Floquet modes (for time :math:`t=0`). f_energies : array; The Floquet energies. f_coeff : array; The coefficients for Floquet decomposition of the initial wavefunction. t : float; The time for which to evaluate the Floquet states. H : :class:`qutip.qobj`; System Hamiltonian, time-dependent with period `T`. T : float; The period of the time-dependence of the hamiltonian. args : dictionary; Dictionary with variables required to evaluate H. Returns; -------. output : :class:`qutip.qobj`. The wavefunction for the time :math:`t`. """""". f_states_t = floquet_states_t(f_modes_0, f_energies, t, H, T, args,; options=options); return sum([f_states_t[i] * f_coeff[i]; for i in np.arange(len(f_energies))]). [docs]def floquet_state_decomposition(f_states, f_energies, psi):; r""""""; Decompose the wavefunction `psi` (typically an initial state) in terms of; the Floquet states, :math:`\psi = \sum_\alpha c_\alpha \psi_\alpha(0)`. Parameters; ----------. f_states : list of :class:`qutip.qobj` (kets); A list of Floquet modes. f_energies : array; The Floquet energies. psi : :class:`qutip.qobj`; The wavefunction to decompose in the Floquet state basis. Returns; -------. output : array. The coefficients :math:`c_\alpha` in the Floquet state decomposition. """"""; # [:1,:1][0, 0] patch ar",MatchSource.WIKI,docs/4.7/modules/qutip/floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/floquet.html
https://qutip.org/docs/4.7/modules/qutip/floquet.html:10149,Integrability,depend,dependence,10149,"_coeff : array; The coefficients for Floquet decomposition of the initial wavefunction. t : float; The time for which to evaluate the Floquet states. Returns; -------. output : :class:`qutip.qobj`. The wavefunction for the time :math:`t`. """"""; return sum([f_modes_t[i] * exp(-1j * f_energies[i] * t) * f_coeff[i]; for i in np.arange(len(f_energies))]). [docs]def floquet_wavefunction_t(f_modes_0, f_energies, f_coeff, t, H, T, args=None,; options=None):; """"""; Evaluate the wavefunction for a time t using the Floquet state; decompositon, given the initial Floquet modes. Parameters; ----------. f_modes_t : list of :class:`qutip.qobj` (kets); A list of initial Floquet modes (for time :math:`t=0`). f_energies : array; The Floquet energies. f_coeff : array; The coefficients for Floquet decomposition of the initial wavefunction. t : float; The time for which to evaluate the Floquet states. H : :class:`qutip.qobj`; System Hamiltonian, time-dependent with period `T`. T : float; The period of the time-dependence of the hamiltonian. args : dictionary; Dictionary with variables required to evaluate H. Returns; -------. output : :class:`qutip.qobj`. The wavefunction for the time :math:`t`. """""". f_states_t = floquet_states_t(f_modes_0, f_energies, t, H, T, args,; options=options); return sum([f_states_t[i] * f_coeff[i]; for i in np.arange(len(f_energies))]). [docs]def floquet_state_decomposition(f_states, f_energies, psi):; r""""""; Decompose the wavefunction `psi` (typically an initial state) in terms of; the Floquet states, :math:`\psi = \sum_\alpha c_\alpha \psi_\alpha(0)`. Parameters; ----------. f_states : list of :class:`qutip.qobj` (kets); A list of Floquet modes. f_energies : array; The Floquet energies. psi : :class:`qutip.qobj`; The wavefunction to decompose in the Floquet state basis. Returns; -------. output : array. The coefficients :math:`c_\alpha` in the Floquet state decomposition. """"""; # [:1,:1][0, 0] patch around scipy 1.3.0 bug; return [(f_states[i].dag() * psi).data[:",MatchSource.WIKI,docs/4.7/modules/qutip/floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/floquet.html
https://qutip.org/docs/4.7/modules/qutip/floquet.html:11435,Integrability,depend,dependent,11435,"turn sum([f_states_t[i] * f_coeff[i]; for i in np.arange(len(f_energies))]). [docs]def floquet_state_decomposition(f_states, f_energies, psi):; r""""""; Decompose the wavefunction `psi` (typically an initial state) in terms of; the Floquet states, :math:`\psi = \sum_\alpha c_\alpha \psi_\alpha(0)`. Parameters; ----------. f_states : list of :class:`qutip.qobj` (kets); A list of Floquet modes. f_energies : array; The Floquet energies. psi : :class:`qutip.qobj`; The wavefunction to decompose in the Floquet state basis. Returns; -------. output : array. The coefficients :math:`c_\alpha` in the Floquet state decomposition. """"""; # [:1,:1][0, 0] patch around scipy 1.3.0 bug; return [(f_states[i].dag() * psi).data[:1, :1][0, 0]; for i in np.arange(len(f_energies))]. [docs]def fsesolve(H, psi0, tlist, e_ops=[], T=None, args={}, Tsteps=100,; options_modes=None):; """"""; Solve the Schrodinger equation using the Floquet formalism. Parameters; ----------. H : :class:`qutip.Qobj`; System Hamiltonian, time-dependent with period `T`. psi0 : :class:`qutip.qobj`; Initial state vector (ket). tlist : *list* / *array*; list of times for :math:`t`. e_ops : list of :class:`qutip.qobj` / callback function; list of operators for which to evaluate expectation values. If this; list is empty, the state vectors for each time in `tlist` will be; returned instead of expectation values. T : float; The period of the time-dependence of the hamiltonian. args : dictionary; Dictionary with variables required to evaluate H. Tsteps : integer; The number of time steps in one driving period for which to; precalculate the Floquet modes. `Tsteps` should be an even number. options_modes : :class:`qutip.solver.Options`; options for the ODE solver. Returns; -------. output : :class:`qutip.solver.Result`. An instance of the class :class:`qutip.solver.Result`, which; contains either an *array* of expectation values or an array of; state vectors, for the times specified by `tlist`.; """""". if not T:; # assume that tlist",MatchSource.WIKI,docs/4.7/modules/qutip/floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/floquet.html
https://qutip.org/docs/4.7/modules/qutip/floquet.html:11840,Integrability,depend,dependence,11840," array; The Floquet energies. psi : :class:`qutip.qobj`; The wavefunction to decompose in the Floquet state basis. Returns; -------. output : array. The coefficients :math:`c_\alpha` in the Floquet state decomposition. """"""; # [:1,:1][0, 0] patch around scipy 1.3.0 bug; return [(f_states[i].dag() * psi).data[:1, :1][0, 0]; for i in np.arange(len(f_energies))]. [docs]def fsesolve(H, psi0, tlist, e_ops=[], T=None, args={}, Tsteps=100,; options_modes=None):; """"""; Solve the Schrodinger equation using the Floquet formalism. Parameters; ----------. H : :class:`qutip.Qobj`; System Hamiltonian, time-dependent with period `T`. psi0 : :class:`qutip.qobj`; Initial state vector (ket). tlist : *list* / *array*; list of times for :math:`t`. e_ops : list of :class:`qutip.qobj` / callback function; list of operators for which to evaluate expectation values. If this; list is empty, the state vectors for each time in `tlist` will be; returned instead of expectation values. T : float; The period of the time-dependence of the hamiltonian. args : dictionary; Dictionary with variables required to evaluate H. Tsteps : integer; The number of time steps in one driving period for which to; precalculate the Floquet modes. `Tsteps` should be an even number. options_modes : :class:`qutip.solver.Options`; options for the ODE solver. Returns; -------. output : :class:`qutip.solver.Result`. An instance of the class :class:`qutip.solver.Result`, which; contains either an *array* of expectation values or an array of; state vectors, for the times specified by `tlist`.; """""". if not T:; # assume that tlist span exactly one period of the driving; T = tlist[-1]. if options_modes is None:; options_modes_table = Options(); else:; options_modes_table = options_modes. # find the floquet modes for the time-dependent hamiltonian; f_modes_0, f_energies = floquet_modes(H, T, args,; options=options_modes). # calculate the wavefunctions using the from the floquet modes; f_modes_table_t = floquet_modes_table(f_modes_",MatchSource.WIKI,docs/4.7/modules/qutip/floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/floquet.html
https://qutip.org/docs/4.7/modules/qutip/floquet.html:12630,Integrability,depend,dependent,12630,"o evaluate expectation values. If this; list is empty, the state vectors for each time in `tlist` will be; returned instead of expectation values. T : float; The period of the time-dependence of the hamiltonian. args : dictionary; Dictionary with variables required to evaluate H. Tsteps : integer; The number of time steps in one driving period for which to; precalculate the Floquet modes. `Tsteps` should be an even number. options_modes : :class:`qutip.solver.Options`; options for the ODE solver. Returns; -------. output : :class:`qutip.solver.Result`. An instance of the class :class:`qutip.solver.Result`, which; contains either an *array* of expectation values or an array of; state vectors, for the times specified by `tlist`.; """""". if not T:; # assume that tlist span exactly one period of the driving; T = tlist[-1]. if options_modes is None:; options_modes_table = Options(); else:; options_modes_table = options_modes. # find the floquet modes for the time-dependent hamiltonian; f_modes_0, f_energies = floquet_modes(H, T, args,; options=options_modes). # calculate the wavefunctions using the from the floquet modes; f_modes_table_t = floquet_modes_table(f_modes_0, f_energies,; np.linspace(0, T, Tsteps + 1),; H, T, args,; options=options_modes_table). # setup Result for storing the results; output = Result(); output.times = tlist; output.solver = ""fsesolve"". if isinstance(e_ops, FunctionType):; output.num_expect = 0; expt_callback = True. elif isinstance(e_ops, list):. output.num_expect = len(e_ops); expt_callback = False. if output.num_expect == 0:; output.states = []; else:; output.expect = []; for op in e_ops:; if op.isherm:; output.expect.append(np.zeros(len(tlist))); else:; output.expect.append(np.zeros(len(tlist), dtype=complex)). else:; raise TypeError(""e_ops must be a list Qobj or a callback function""). psi0_fb = psi0.transform(f_modes_0); for t_idx, t in enumerate(tlist):; f_modes_t = floquet_modes_t_lookup(f_modes_table_t, t, T); f_states_t = floquet_states(",MatchSource.WIKI,docs/4.7/modules/qutip/floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/floquet.html
https://qutip.org/docs/4.7/modules/qutip/floquet.html:14309,Integrability,integrat,integration,14309,"p.zeros(len(tlist))); else:; output.expect.append(np.zeros(len(tlist), dtype=complex)). else:; raise TypeError(""e_ops must be a list Qobj or a callback function""). psi0_fb = psi0.transform(f_modes_0); for t_idx, t in enumerate(tlist):; f_modes_t = floquet_modes_t_lookup(f_modes_table_t, t, T); f_states_t = floquet_states(f_modes_t, f_energies, t); psi_t = psi0_fb.transform(f_states_t, True). if expt_callback:; # use callback method; e_ops(t, psi_t); else:; # calculate all the expectation values, or output psi if; # no expectation value operators where defined; if output.num_expect == 0:; output.states.append(Qobj(psi_t)); else:; for e_idx, e in enumerate(e_ops):; output.expect[e_idx][t_idx] = expect(e, psi_t). return output. [docs]def floquet_master_equation_rates(f_modes_0, f_energies, c_op, H, T,; args, J_cb, w_th, kmax=5,; f_modes_table_t=None):; """"""; Calculate the rates and matrix elements for the Floquet-Markov master; equation. .. note :; The number of integration steps (for calculating X) within one period; is set to 20 * kmax. Parameters; ----------. f_modes_0 : list of :class:`qutip.qobj` (kets); A list of initial Floquet modes. f_energies : array; The Floquet energies. c_op : :class:`qutip.qobj`; The collapse operators describing the dissipation. H : :class:`qutip.qobj`; System Hamiltonian, time-dependent with period `T`. T : float; The period of the time-dependence of the hamiltonian. args : dictionary; Dictionary with variables required to evaluate H. J_cb : callback functions; A callback function that computes the noise power spectrum, as; a function of frequency, associated with the collapse operator `c_op`. w_th : float; The temperature in units of frequency. kmax : int; The truncation of the number of sidebands (default 5). f_modes_table_t : nested list of :class:`qutip.qobj` (kets); A lookup-table of Floquet modes at times precalculated by; :func:`qutip.floquet.floquet_modes_table` (optional). options : :class:`qutip.solver.Options`; options for the",MatchSource.WIKI,docs/4.7/modules/qutip/floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/floquet.html
https://qutip.org/docs/4.7/modules/qutip/floquet.html:14663,Integrability,depend,dependent,14663,"_modes_t, f_energies, t); psi_t = psi0_fb.transform(f_states_t, True). if expt_callback:; # use callback method; e_ops(t, psi_t); else:; # calculate all the expectation values, or output psi if; # no expectation value operators where defined; if output.num_expect == 0:; output.states.append(Qobj(psi_t)); else:; for e_idx, e in enumerate(e_ops):; output.expect[e_idx][t_idx] = expect(e, psi_t). return output. [docs]def floquet_master_equation_rates(f_modes_0, f_energies, c_op, H, T,; args, J_cb, w_th, kmax=5,; f_modes_table_t=None):; """"""; Calculate the rates and matrix elements for the Floquet-Markov master; equation. .. note :; The number of integration steps (for calculating X) within one period; is set to 20 * kmax. Parameters; ----------. f_modes_0 : list of :class:`qutip.qobj` (kets); A list of initial Floquet modes. f_energies : array; The Floquet energies. c_op : :class:`qutip.qobj`; The collapse operators describing the dissipation. H : :class:`qutip.qobj`; System Hamiltonian, time-dependent with period `T`. T : float; The period of the time-dependence of the hamiltonian. args : dictionary; Dictionary with variables required to evaluate H. J_cb : callback functions; A callback function that computes the noise power spectrum, as; a function of frequency, associated with the collapse operator `c_op`. w_th : float; The temperature in units of frequency. kmax : int; The truncation of the number of sidebands (default 5). f_modes_table_t : nested list of :class:`qutip.qobj` (kets); A lookup-table of Floquet modes at times precalculated by; :func:`qutip.floquet.floquet_modes_table` (optional). options : :class:`qutip.solver.Options`; options for the ODE solver. Returns; -------. output : list. A list (Delta, X, Gamma, A) containing the matrices Delta, X, Gamma; and A used in the construction of the Floquet-Markov master equation. """""". N = len(f_energies); M = 2 * kmax + 1. omega = (2 * pi) / T. Delta = np.zeros((N, N, M)); X = np.zeros((N, N, M), dtype=complex); Gamm",MatchSource.WIKI,docs/4.7/modules/qutip/floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/floquet.html
https://qutip.org/docs/4.7/modules/qutip/floquet.html:14724,Integrability,depend,dependence,14724,"t, True). if expt_callback:; # use callback method; e_ops(t, psi_t); else:; # calculate all the expectation values, or output psi if; # no expectation value operators where defined; if output.num_expect == 0:; output.states.append(Qobj(psi_t)); else:; for e_idx, e in enumerate(e_ops):; output.expect[e_idx][t_idx] = expect(e, psi_t). return output. [docs]def floquet_master_equation_rates(f_modes_0, f_energies, c_op, H, T,; args, J_cb, w_th, kmax=5,; f_modes_table_t=None):; """"""; Calculate the rates and matrix elements for the Floquet-Markov master; equation. .. note :; The number of integration steps (for calculating X) within one period; is set to 20 * kmax. Parameters; ----------. f_modes_0 : list of :class:`qutip.qobj` (kets); A list of initial Floquet modes. f_energies : array; The Floquet energies. c_op : :class:`qutip.qobj`; The collapse operators describing the dissipation. H : :class:`qutip.qobj`; System Hamiltonian, time-dependent with period `T`. T : float; The period of the time-dependence of the hamiltonian. args : dictionary; Dictionary with variables required to evaluate H. J_cb : callback functions; A callback function that computes the noise power spectrum, as; a function of frequency, associated with the collapse operator `c_op`. w_th : float; The temperature in units of frequency. kmax : int; The truncation of the number of sidebands (default 5). f_modes_table_t : nested list of :class:`qutip.qobj` (kets); A lookup-table of Floquet modes at times precalculated by; :func:`qutip.floquet.floquet_modes_table` (optional). options : :class:`qutip.solver.Options`; options for the ODE solver. Returns; -------. output : list. A list (Delta, X, Gamma, A) containing the matrices Delta, X, Gamma; and A used in the construction of the Floquet-Markov master equation. """""". N = len(f_energies); M = 2 * kmax + 1. omega = (2 * pi) / T. Delta = np.zeros((N, N, M)); X = np.zeros((N, N, M), dtype=complex); Gamma = np.zeros((N, N, M)); A = np.zeros((N, N)). # time steps fo",MatchSource.WIKI,docs/4.7/modules/qutip/floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/floquet.html
https://qutip.org/docs/4.7/modules/qutip/floquet.html:15724,Integrability,integrat,integration,15724,"the hamiltonian. args : dictionary; Dictionary with variables required to evaluate H. J_cb : callback functions; A callback function that computes the noise power spectrum, as; a function of frequency, associated with the collapse operator `c_op`. w_th : float; The temperature in units of frequency. kmax : int; The truncation of the number of sidebands (default 5). f_modes_table_t : nested list of :class:`qutip.qobj` (kets); A lookup-table of Floquet modes at times precalculated by; :func:`qutip.floquet.floquet_modes_table` (optional). options : :class:`qutip.solver.Options`; options for the ODE solver. Returns; -------. output : list. A list (Delta, X, Gamma, A) containing the matrices Delta, X, Gamma; and A used in the construction of the Floquet-Markov master equation. """""". N = len(f_energies); M = 2 * kmax + 1. omega = (2 * pi) / T. Delta = np.zeros((N, N, M)); X = np.zeros((N, N, M), dtype=complex); Gamma = np.zeros((N, N, M)); A = np.zeros((N, N)). # time steps for integration of coupling operator; nT = int(np.max([20 * kmax, 100])); dT = T / nT; tlist = np.arange(dT, T + dT / 2, dT). if f_modes_table_t is None:; f_modes_table_t = floquet_modes_table(f_modes_0, f_energies,; np.linspace(0, T, nT + 1), H, T,; args). for t in tlist:; # TODO: repeated invocations of floquet_modes_t is; # inefficient... make a and b outer loops and use the mesolve; # instead of the propagator. f_modes_t = np.hstack([f.full() for f in floquet_modes_t_lookup(; f_modes_table_t, t, T)]); FF = f_modes_t.T.conj() @ c_op.full() @ f_modes_t; phi = exp(-1j * np.arange(-kmax, kmax+1) * omega * t); X += (dT / T) * np.einsum(""ij,k->ijk"", FF, phi). Heaviside = lambda x: ((np.sign(x) + 1) / 2.0); for a in range(N):; for b in range(N):; k_idx = 0; for k in range(-kmax, kmax + 1, 1):; Delta[a, b, k_idx] = f_energies[a] - f_energies[b] + k * omega; Gamma[a, b, k_idx] = 2 * pi * Heaviside(Delta[a, b, k_idx]) * \; J_cb(Delta[a, b, k_idx]) * abs(X[a, b, k_idx]) ** 2; k_idx += 1. for a in range(N):; fo",MatchSource.WIKI,docs/4.7/modules/qutip/floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/floquet.html
https://qutip.org/docs/4.7/modules/qutip/floquet.html:23668,Integrability,integrat,integrator,23668,"okup); and not all(x is None for x in lab_lookup); ):; warnings.warn(; ""if transformation back to the computational basis in the lab""; ""frame is desired, all of `f_modes_t`, `f_energies` and `T` must""; ""be supplied.""; ); f_modes_table_t = f_energies = T = None. # Initial state.; if f_modes_0 is not None:; rho0 = rho0.transform(f_modes_0). # Evolved states.; if floquet_basis:; def transform(rho, t):; return rho; elif f_modes_table_t is not None:; # Lab frame, computational basis.; def transform(rho, t):; f_modes_t = floquet_modes_t_lookup(f_modes_table_t, t, T); f_states_t = floquet_states(f_modes_t, f_energies, t); return rho.transform(f_states_t, True); elif f_modes_0 is not None:; # Interaction picture, computational basis.; def transform(rho, t):; return rho.transform(f_modes_0, False); else:; raise ValueError(; ""cannot transform out of the Floquet basis without some knowledge ""; ""of the Floquet modes. Pass `f_modes_0`, or all of `f_modes_t`, ""; ""`f_energies` and `T`.""; ). # Setup integrator.; initial_vector = mat2vec(rho0.full()); r = scipy.integrate.ode(cy_ode_rhs); r.set_f_params(R.data.data, R.data.indices, R.data.indptr); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]). # Main evolution loop.; for t_idx, t in enumerate(tlist):; if not r.successful():; break; rho = transform(Qobj(vec2mat(r.y), rho0.dims, rho0.shape), t); if expt_callback:; e_ops(t, rho); else:; for m, e_op in enumerate(e_ops):; output.expect[m][t_idx] = expect(e_op, rho); if store_states:; output.states.append(rho); r.integrate(r.t + dt); return output. # -----------------------------------------------------------------------------; # Solve the Floquet-Markov master equation; #; #. [docs]def fmmesolve(H, rho0, tlist, c_ops=[], e_ops=[], spectra_cb=[], T=None,; args={}, options=Options(), floquet_basis=True, kmax=5,; _safe_mode=True, options_modes=None):; """"""; Solve the dynamics f",MatchSource.WIKI,docs/4.7/modules/qutip/floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/floquet.html
https://qutip.org/docs/4.7/modules/qutip/floquet.html:23730,Integrability,integrat,integrate,23730,"rn(; ""if transformation back to the computational basis in the lab""; ""frame is desired, all of `f_modes_t`, `f_energies` and `T` must""; ""be supplied.""; ); f_modes_table_t = f_energies = T = None. # Initial state.; if f_modes_0 is not None:; rho0 = rho0.transform(f_modes_0). # Evolved states.; if floquet_basis:; def transform(rho, t):; return rho; elif f_modes_table_t is not None:; # Lab frame, computational basis.; def transform(rho, t):; f_modes_t = floquet_modes_t_lookup(f_modes_table_t, t, T); f_states_t = floquet_states(f_modes_t, f_energies, t); return rho.transform(f_states_t, True); elif f_modes_0 is not None:; # Interaction picture, computational basis.; def transform(rho, t):; return rho.transform(f_modes_0, False); else:; raise ValueError(; ""cannot transform out of the Floquet basis without some knowledge ""; ""of the Floquet modes. Pass `f_modes_0`, or all of `f_modes_t`, ""; ""`f_energies` and `T`.""; ). # Setup integrator.; initial_vector = mat2vec(rho0.full()); r = scipy.integrate.ode(cy_ode_rhs); r.set_f_params(R.data.data, R.data.indices, R.data.indptr); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]). # Main evolution loop.; for t_idx, t in enumerate(tlist):; if not r.successful():; break; rho = transform(Qobj(vec2mat(r.y), rho0.dims, rho0.shape), t); if expt_callback:; e_ops(t, rho); else:; for m, e_op in enumerate(e_ops):; output.expect[m][t_idx] = expect(e_op, rho); if store_states:; output.states.append(rho); r.integrate(r.t + dt); return output. # -----------------------------------------------------------------------------; # Solve the Floquet-Markov master equation; #; #. [docs]def fmmesolve(H, rho0, tlist, c_ops=[], e_ops=[], spectra_cb=[], T=None,; args={}, options=Options(), floquet_basis=True, kmax=5,; _safe_mode=True, options_modes=None):; """"""; Solve the dynamics for the system using the Floquet-Markov master equation. .. note::.",MatchSource.WIKI,docs/4.7/modules/qutip/floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/floquet.html
https://qutip.org/docs/4.7/modules/qutip/floquet.html:24301,Integrability,integrat,integrate,24301,"sform(f_states_t, True); elif f_modes_0 is not None:; # Interaction picture, computational basis.; def transform(rho, t):; return rho.transform(f_modes_0, False); else:; raise ValueError(; ""cannot transform out of the Floquet basis without some knowledge ""; ""of the Floquet modes. Pass `f_modes_0`, or all of `f_modes_t`, ""; ""`f_energies` and `T`.""; ). # Setup integrator.; initial_vector = mat2vec(rho0.full()); r = scipy.integrate.ode(cy_ode_rhs); r.set_f_params(R.data.data, R.data.indices, R.data.indptr); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]). # Main evolution loop.; for t_idx, t in enumerate(tlist):; if not r.successful():; break; rho = transform(Qobj(vec2mat(r.y), rho0.dims, rho0.shape), t); if expt_callback:; e_ops(t, rho); else:; for m, e_op in enumerate(e_ops):; output.expect[m][t_idx] = expect(e_op, rho); if store_states:; output.states.append(rho); r.integrate(r.t + dt); return output. # -----------------------------------------------------------------------------; # Solve the Floquet-Markov master equation; #; #. [docs]def fmmesolve(H, rho0, tlist, c_ops=[], e_ops=[], spectra_cb=[], T=None,; args={}, options=Options(), floquet_basis=True, kmax=5,; _safe_mode=True, options_modes=None):; """"""; Solve the dynamics for the system using the Floquet-Markov master equation. .. note::. This solver currently does not support multiple collapse operators. Parameters; ----------. H : :class:`qutip.qobj`; system Hamiltonian. rho0 / psi0 : :class:`qutip.qobj`; initial density matrix or state vector (ket). tlist : *list* / *array*; list of times for :math:`t`. c_ops : list of :class:`qutip.qobj`; list of collapse operators. e_ops : list of :class:`qutip.qobj` / callback function; list of operators for which to evaluate expectation values. spectra_cb : list callback functions; List of callback functions that compute the noise power spectrum as; a functio",MatchSource.WIKI,docs/4.7/modules/qutip/floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/floquet.html
https://qutip.org/docs/4.7/modules/qutip/floquet.html:25395,Integrability,depend,dependence,25395,"------------------------; # Solve the Floquet-Markov master equation; #; #. [docs]def fmmesolve(H, rho0, tlist, c_ops=[], e_ops=[], spectra_cb=[], T=None,; args={}, options=Options(), floquet_basis=True, kmax=5,; _safe_mode=True, options_modes=None):; """"""; Solve the dynamics for the system using the Floquet-Markov master equation. .. note::. This solver currently does not support multiple collapse operators. Parameters; ----------. H : :class:`qutip.qobj`; system Hamiltonian. rho0 / psi0 : :class:`qutip.qobj`; initial density matrix or state vector (ket). tlist : *list* / *array*; list of times for :math:`t`. c_ops : list of :class:`qutip.qobj`; list of collapse operators. e_ops : list of :class:`qutip.qobj` / callback function; list of operators for which to evaluate expectation values. spectra_cb : list callback functions; List of callback functions that compute the noise power spectrum as; a function of frequency for the collapse operators in `c_ops`. T : float; The period of the time-dependence of the hamiltonian. The default value; 'None' indicates that the 'tlist' spans a single period of the driving. args : *dictionary*; dictionary of parameters for time-dependent Hamiltonians and; collapse operators. This dictionary should also contain an entry 'w_th', which is; the temperature of the environment (if finite) in the; energy/frequency units of the Hamiltonian. For example, if; the Hamiltonian written in units of 2pi GHz, and the; temperature is given in K, use the following conversion. >>> temperature = 25e-3 # unit K # doctest: +SKIP; >>> h = 6.626e-34 # doctest: +SKIP; >>> kB = 1.38e-23 # doctest: +SKIP; >>> args['w_th'] = temperature * (kB / h) * 2 * pi * 1e-9 \; #doctest: +SKIP. options : :class:`qutip.solver.Options`; options for the ODE solver. For solving the master equation. floquet_basis : bool; Will return results in Floquet basis or computational basis; (optional). k_max : int; The truncation of the number of sidebands (default 5). options_modes : :c",MatchSource.WIKI,docs/4.7/modules/qutip/floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/floquet.html
https://qutip.org/docs/4.7/modules/qutip/floquet.html:25572,Integrability,depend,dependent,25572,"tions(), floquet_basis=True, kmax=5,; _safe_mode=True, options_modes=None):; """"""; Solve the dynamics for the system using the Floquet-Markov master equation. .. note::. This solver currently does not support multiple collapse operators. Parameters; ----------. H : :class:`qutip.qobj`; system Hamiltonian. rho0 / psi0 : :class:`qutip.qobj`; initial density matrix or state vector (ket). tlist : *list* / *array*; list of times for :math:`t`. c_ops : list of :class:`qutip.qobj`; list of collapse operators. e_ops : list of :class:`qutip.qobj` / callback function; list of operators for which to evaluate expectation values. spectra_cb : list callback functions; List of callback functions that compute the noise power spectrum as; a function of frequency for the collapse operators in `c_ops`. T : float; The period of the time-dependence of the hamiltonian. The default value; 'None' indicates that the 'tlist' spans a single period of the driving. args : *dictionary*; dictionary of parameters for time-dependent Hamiltonians and; collapse operators. This dictionary should also contain an entry 'w_th', which is; the temperature of the environment (if finite) in the; energy/frequency units of the Hamiltonian. For example, if; the Hamiltonian written in units of 2pi GHz, and the; temperature is given in K, use the following conversion. >>> temperature = 25e-3 # unit K # doctest: +SKIP; >>> h = 6.626e-34 # doctest: +SKIP; >>> kB = 1.38e-23 # doctest: +SKIP; >>> args['w_th'] = temperature * (kB / h) * 2 * pi * 1e-9 \; #doctest: +SKIP. options : :class:`qutip.solver.Options`; options for the ODE solver. For solving the master equation. floquet_basis : bool; Will return results in Floquet basis or computational basis; (optional). k_max : int; The truncation of the number of sidebands (default 5). options_modes : :class:`qutip.solver.Options`; options for the ODE solver. For computing Floquet modes. Returns; -------. output : :class:`qutip.solver.Result`. An instance of the class :class:",MatchSource.WIKI,docs/4.7/modules/qutip/floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/floquet.html
https://qutip.org/docs/4.7/modules/qutip/floquet.html:2125,Modifiability,variab,variables,2125,"lve; from qutip.rhs_generate import rhs_clear; from qutip.steadystate import steadystate; from qutip.states import ket2dm; from qutip.states import projection; from qutip.solver import Options; from qutip.propagator import propagator; from qutip.solver import Result, _solver_safety_check; from qutip.cy.spmatfuncs import cy_ode_rhs; from qutip.expect import expect; from qutip.utilities import n_thermal. [docs]def floquet_modes(H, T, args=None, sort=False, U=None, options=None):; """"""; Calculate the initial Floquet modes Phi_alpha(0) for a driven system with; period T. Returns a list of :class:`qutip.qobj` instances representing the Floquet; modes and a list of corresponding quasienergies, sorted by increasing; quasienergy in the interval [-pi/T, pi/T]. The optional parameter `sort`; decides if the output is to be sorted in increasing quasienergies or not. Parameters; ----------. H : :class:`qutip.qobj`; system Hamiltonian, time-dependent with period `T`. args : dictionary; dictionary with variables required to evaluate H. T : float; The period of the time-dependence of the hamiltonian. The default value; 'None' indicates that the 'tlist' spans a single period of the driving. U : :class:`qutip.qobj`; The propagator for the time-dependent Hamiltonian with period `T`.; If U is `None` (default), it will be calculated from the Hamiltonian; `H` using :func:`qutip.propagator.propagator`. options : :class:`qutip.solver.Options`; options for the ODE solver. For the propagator U. Returns; -------. output : list of kets, list of quasi energies. Two lists: the Floquet modes as kets and the quasi energies. """""". if U is None:; # get the unitary propagator; U = propagator(H, T, [], args=args, options=copy(options)). # find the eigenstates for the propagator; evals, evecs = la.eig(U.full()). eargs = angle(evals). # make sure that the phase is in the interval [-pi, pi], so that; # the quasi energy is in the interval [-pi/T, pi/T] where T is the; # period of the driving. eargs += (eargs",MatchSource.WIKI,docs/4.7/modules/qutip/floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/floquet.html
https://qutip.org/docs/4.7/modules/qutip/floquet.html:4130,Modifiability,variab,variables,4130,"-2*pi) * (2*pi) +; # (eargs > 0) * (-2*pi); eargs += (eargs <= -pi) * (2 * pi) + (eargs > pi) * (-2 * pi); e_quasi = -eargs / T. # sort by the quasi energy; if sort:; order = np.argsort(-e_quasi); else:; order = list(range(len(evals))). # prepare a list of kets for the floquet states; new_dims = [U.dims[0], [1] * len(U.dims[0])]; new_shape = [U.shape[0], 1]; kets_order = [Qobj(np.array(evecs[:, o]).T,; dims=new_dims, shape=new_shape) for o in order]. return kets_order, e_quasi[order]. [docs]def floquet_modes_t(f_modes_0, f_energies, t, H, T, args=None,; options=None):; """"""; Calculate the Floquet modes at times tlist Phi_alpha(tlist) propagting the; initial Floquet modes Phi_alpha(0). Parameters; ----------. f_modes_0 : list of :class:`qutip.qobj` (kets); Floquet modes at :math:`t`. f_energies : list; Floquet energies. t : float; The time at which to evaluate the floquet modes. H : :class:`qutip.qobj`; system Hamiltonian, time-dependent with period `T`. args : dictionary; dictionary with variables required to evaluate H. T : float; The period of the time-dependence of the hamiltonian. options : :class:`qutip.solver.Options`; options for the ODE solver. For the propagator. Returns; -------. output : list of kets. The Floquet modes as kets at time :math:`t`. """"""; # find t in [0,T] such that t_orig = t + n * T for integer n; t = t - int(t / T) * T; f_modes_t = []. # get the unitary propagator from 0 to t; if t > 0.0:; U = propagator(H, t, [], args, options=copy(options)). for n in np.arange(len(f_modes_0)):; f_modes_t.append(U * f_modes_0[n] * exp(1j * f_energies[n] * t)); else:; f_modes_t = f_modes_0. return f_modes_t. [docs]def floquet_modes_table(f_modes_0, f_energies, tlist, H, T, args=None,; options=None):; """"""; Pre-calculate the Floquet modes for a range of times spanning the floquet; period. Can later be used as a table to look up the floquet modes for; any time. Parameters; ----------. f_modes_0 : list of :class:`qutip.qobj` (kets); Floquet modes at :math:`t`. f_",MatchSource.WIKI,docs/4.7/modules/qutip/floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/floquet.html
https://qutip.org/docs/4.7/modules/qutip/floquet.html:5414,Modifiability,variab,variables,5414,"ind t in [0,T] such that t_orig = t + n * T for integer n; t = t - int(t / T) * T; f_modes_t = []. # get the unitary propagator from 0 to t; if t > 0.0:; U = propagator(H, t, [], args, options=copy(options)). for n in np.arange(len(f_modes_0)):; f_modes_t.append(U * f_modes_0[n] * exp(1j * f_energies[n] * t)); else:; f_modes_t = f_modes_0. return f_modes_t. [docs]def floquet_modes_table(f_modes_0, f_energies, tlist, H, T, args=None,; options=None):; """"""; Pre-calculate the Floquet modes for a range of times spanning the floquet; period. Can later be used as a table to look up the floquet modes for; any time. Parameters; ----------. f_modes_0 : list of :class:`qutip.qobj` (kets); Floquet modes at :math:`t`. f_energies : list; Floquet energies. tlist : array; The list of times at which to evaluate the floquet modes. H : :class:`qutip.qobj`; system Hamiltonian, time-dependent with period `T`. T : float; The period of the time-dependence of the hamiltonian. args : dictionary; dictionary with variables required to evaluate H. options : :class:`qutip.solver.Options`; options for the ODE solver. Returns; -------. output : nested list. A nested list of Floquet modes as kets for each time in `tlist`. """"""; options = copy(options) or Options(); # truncate tlist to the driving period; tlist_period = tlist[np.where(tlist <= T)]. f_modes_table_t = [[] for t in tlist_period]. opt = options; opt.rhs_reuse = True; rhs_clear(). for n, f_mode in enumerate(f_modes_0):; output = sesolve(H, f_mode, tlist_period, [], args, opt); for t_idx, f_state_t in enumerate(output.states):; f_modes_table_t[t_idx].append(; f_state_t * exp(1j * f_energies[n] * tlist_period[t_idx])). return f_modes_table_t. [docs]def floquet_modes_t_lookup(f_modes_table_t, t, T):; """"""; Lookup the floquet mode at time t in the pre-calculated table of floquet; modes in the first period of the time-dependence. Parameters; ----------. f_modes_table_t : nested list of :class:`qutip.qobj` (kets); A lookup-table of Floquet modes",MatchSource.WIKI,docs/4.7/modules/qutip/floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/floquet.html
https://qutip.org/docs/4.7/modules/qutip/floquet.html:8419,Modifiability,variab,variables,8419,"e Floquet modes at that time. Parameters; ----------. f_modes_t : list of :class:`qutip.qobj` (kets); A list of Floquet modes for time :math:`t`. f_energies : array; The Floquet energies. t : float; The time for which to evaluate the Floquet states. Returns; -------. output : list. A list of Floquet states for the time :math:`t`. """""". return [(f_modes_t[i] * exp(-1j * f_energies[i] * t)); for i in np.arange(len(f_energies))]. [docs]def floquet_states_t(f_modes_0, f_energies, t, H, T, args=None,; options=None):; """"""; Evaluate the floquet states at time t given the initial Floquet modes. Parameters; ----------. f_modes_t : list of :class:`qutip.qobj` (kets); A list of initial Floquet modes (for time :math:`t=0`). f_energies : array; The Floquet energies. t : float; The time for which to evaluate the Floquet states. H : :class:`qutip.qobj`; System Hamiltonian, time-dependent with period `T`. T : float; The period of the time-dependence of the hamiltonian. args : dictionary; Dictionary with variables required to evaluate H. options : :class:`qutip.solver.Options`; options for the ODE solver. Returns; -------. output : list. A list of Floquet states for the time :math:`t`. """""". f_modes_t = floquet_modes_t(f_modes_0, f_energies, t, H, T, args,; options=options); return [(f_modes_t[i] * exp(-1j * f_energies[i] * t)); for i in np.arange(len(f_energies))]. [docs]def floquet_wavefunction(f_modes_t, f_energies, f_coeff, t):; """"""; Evaluate the wavefunction for a time t using the Floquet state; decompositon, given the Floquet modes at time `t`. Parameters; ----------. f_modes_t : list of :class:`qutip.qobj` (kets); A list of initial Floquet modes (for time :math:`t=0`). f_energies : array; The Floquet energies. f_coeff : array; The coefficients for Floquet decomposition of the initial wavefunction. t : float; The time for which to evaluate the Floquet states. Returns; -------. output : :class:`qutip.qobj`. The wavefunction for the time :math:`t`. """"""; return sum([f_modes_t[i] * e",MatchSource.WIKI,docs/4.7/modules/qutip/floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/floquet.html
https://qutip.org/docs/4.7/modules/qutip/floquet.html:10215,Modifiability,variab,variables,10215,"nitial wavefunction. t : float; The time for which to evaluate the Floquet states. Returns; -------. output : :class:`qutip.qobj`. The wavefunction for the time :math:`t`. """"""; return sum([f_modes_t[i] * exp(-1j * f_energies[i] * t) * f_coeff[i]; for i in np.arange(len(f_energies))]). [docs]def floquet_wavefunction_t(f_modes_0, f_energies, f_coeff, t, H, T, args=None,; options=None):; """"""; Evaluate the wavefunction for a time t using the Floquet state; decompositon, given the initial Floquet modes. Parameters; ----------. f_modes_t : list of :class:`qutip.qobj` (kets); A list of initial Floquet modes (for time :math:`t=0`). f_energies : array; The Floquet energies. f_coeff : array; The coefficients for Floquet decomposition of the initial wavefunction. t : float; The time for which to evaluate the Floquet states. H : :class:`qutip.qobj`; System Hamiltonian, time-dependent with period `T`. T : float; The period of the time-dependence of the hamiltonian. args : dictionary; Dictionary with variables required to evaluate H. Returns; -------. output : :class:`qutip.qobj`. The wavefunction for the time :math:`t`. """""". f_states_t = floquet_states_t(f_modes_0, f_energies, t, H, T, args,; options=options); return sum([f_states_t[i] * f_coeff[i]; for i in np.arange(len(f_energies))]). [docs]def floquet_state_decomposition(f_states, f_energies, psi):; r""""""; Decompose the wavefunction `psi` (typically an initial state) in terms of; the Floquet states, :math:`\psi = \sum_\alpha c_\alpha \psi_\alpha(0)`. Parameters; ----------. f_states : list of :class:`qutip.qobj` (kets); A list of Floquet modes. f_energies : array; The Floquet energies. psi : :class:`qutip.qobj`; The wavefunction to decompose in the Floquet state basis. Returns; -------. output : array. The coefficients :math:`c_\alpha` in the Floquet state decomposition. """"""; # [:1,:1][0, 0] patch around scipy 1.3.0 bug; return [(f_states[i].dag() * psi).data[:1, :1][0, 0]; for i in np.arange(len(f_energies))]. [docs]def fseso",MatchSource.WIKI,docs/4.7/modules/qutip/floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/floquet.html
https://qutip.org/docs/4.7/modules/qutip/floquet.html:11906,Modifiability,variab,variables,11906,"nction to decompose in the Floquet state basis. Returns; -------. output : array. The coefficients :math:`c_\alpha` in the Floquet state decomposition. """"""; # [:1,:1][0, 0] patch around scipy 1.3.0 bug; return [(f_states[i].dag() * psi).data[:1, :1][0, 0]; for i in np.arange(len(f_energies))]. [docs]def fsesolve(H, psi0, tlist, e_ops=[], T=None, args={}, Tsteps=100,; options_modes=None):; """"""; Solve the Schrodinger equation using the Floquet formalism. Parameters; ----------. H : :class:`qutip.Qobj`; System Hamiltonian, time-dependent with period `T`. psi0 : :class:`qutip.qobj`; Initial state vector (ket). tlist : *list* / *array*; list of times for :math:`t`. e_ops : list of :class:`qutip.qobj` / callback function; list of operators for which to evaluate expectation values. If this; list is empty, the state vectors for each time in `tlist` will be; returned instead of expectation values. T : float; The period of the time-dependence of the hamiltonian. args : dictionary; Dictionary with variables required to evaluate H. Tsteps : integer; The number of time steps in one driving period for which to; precalculate the Floquet modes. `Tsteps` should be an even number. options_modes : :class:`qutip.solver.Options`; options for the ODE solver. Returns; -------. output : :class:`qutip.solver.Result`. An instance of the class :class:`qutip.solver.Result`, which; contains either an *array* of expectation values or an array of; state vectors, for the times specified by `tlist`.; """""". if not T:; # assume that tlist span exactly one period of the driving; T = tlist[-1]. if options_modes is None:; options_modes_table = Options(); else:; options_modes_table = options_modes. # find the floquet modes for the time-dependent hamiltonian; f_modes_0, f_energies = floquet_modes(H, T, args,; options=options_modes). # calculate the wavefunctions using the from the floquet modes; f_modes_table_t = floquet_modes_table(f_modes_0, f_energies,; np.linspace(0, T, Tsteps + 1),; H, T, args,; option",MatchSource.WIKI,docs/4.7/modules/qutip/floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/floquet.html
https://qutip.org/docs/4.7/modules/qutip/floquet.html:14790,Modifiability,variab,variables,14790,"; else:; # calculate all the expectation values, or output psi if; # no expectation value operators where defined; if output.num_expect == 0:; output.states.append(Qobj(psi_t)); else:; for e_idx, e in enumerate(e_ops):; output.expect[e_idx][t_idx] = expect(e, psi_t). return output. [docs]def floquet_master_equation_rates(f_modes_0, f_energies, c_op, H, T,; args, J_cb, w_th, kmax=5,; f_modes_table_t=None):; """"""; Calculate the rates and matrix elements for the Floquet-Markov master; equation. .. note :; The number of integration steps (for calculating X) within one period; is set to 20 * kmax. Parameters; ----------. f_modes_0 : list of :class:`qutip.qobj` (kets); A list of initial Floquet modes. f_energies : array; The Floquet energies. c_op : :class:`qutip.qobj`; The collapse operators describing the dissipation. H : :class:`qutip.qobj`; System Hamiltonian, time-dependent with period `T`. T : float; The period of the time-dependence of the hamiltonian. args : dictionary; Dictionary with variables required to evaluate H. J_cb : callback functions; A callback function that computes the noise power spectrum, as; a function of frequency, associated with the collapse operator `c_op`. w_th : float; The temperature in units of frequency. kmax : int; The truncation of the number of sidebands (default 5). f_modes_table_t : nested list of :class:`qutip.qobj` (kets); A lookup-table of Floquet modes at times precalculated by; :func:`qutip.floquet.floquet_modes_table` (optional). options : :class:`qutip.solver.Options`; options for the ODE solver. Returns; -------. output : list. A list (Delta, X, Gamma, A) containing the matrices Delta, X, Gamma; and A used in the construction of the Floquet-Markov master equation. """""". N = len(f_energies); M = 2 * kmax + 1. omega = (2 * pi) / T. Delta = np.zeros((N, N, M)); X = np.zeros((N, N, M), dtype=complex); Gamma = np.zeros((N, N, M)); A = np.zeros((N, N)). # time steps for integration of coupling operator; nT = int(np.max([20 * kmax, 100",MatchSource.WIKI,docs/4.7/modules/qutip/floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/floquet.html
https://qutip.org/docs/4.7/modules/qutip/floquet.html:15739,Modifiability,coupling,coupling,15739,"the hamiltonian. args : dictionary; Dictionary with variables required to evaluate H. J_cb : callback functions; A callback function that computes the noise power spectrum, as; a function of frequency, associated with the collapse operator `c_op`. w_th : float; The temperature in units of frequency. kmax : int; The truncation of the number of sidebands (default 5). f_modes_table_t : nested list of :class:`qutip.qobj` (kets); A lookup-table of Floquet modes at times precalculated by; :func:`qutip.floquet.floquet_modes_table` (optional). options : :class:`qutip.solver.Options`; options for the ODE solver. Returns; -------. output : list. A list (Delta, X, Gamma, A) containing the matrices Delta, X, Gamma; and A used in the construction of the Floquet-Markov master equation. """""". N = len(f_energies); M = 2 * kmax + 1. omega = (2 * pi) / T. Delta = np.zeros((N, N, M)); X = np.zeros((N, N, M), dtype=complex); Gamma = np.zeros((N, N, M)); A = np.zeros((N, N)). # time steps for integration of coupling operator; nT = int(np.max([20 * kmax, 100])); dT = T / nT; tlist = np.arange(dT, T + dT / 2, dT). if f_modes_table_t is None:; f_modes_table_t = floquet_modes_table(f_modes_0, f_energies,; np.linspace(0, T, nT + 1), H, T,; args). for t in tlist:; # TODO: repeated invocations of floquet_modes_t is; # inefficient... make a and b outer loops and use the mesolve; # instead of the propagator. f_modes_t = np.hstack([f.full() for f in floquet_modes_t_lookup(; f_modes_table_t, t, T)]); FF = f_modes_t.T.conj() @ c_op.full() @ f_modes_t; phi = exp(-1j * np.arange(-kmax, kmax+1) * omega * t); X += (dT / T) * np.einsum(""ij,k->ijk"", FF, phi). Heaviside = lambda x: ((np.sign(x) + 1) / 2.0); for a in range(N):; for b in range(N):; k_idx = 0; for k in range(-kmax, kmax + 1, 1):; Delta[a, b, k_idx] = f_energies[a] - f_energies[b] + k * omega; Gamma[a, b, k_idx] = 2 * pi * Heaviside(Delta[a, b, k_idx]) * \; J_cb(Delta[a, b, k_idx]) * abs(X[a, b, k_idx]) ** 2; k_idx += 1. for a in range(N):; fo",MatchSource.WIKI,docs/4.7/modules/qutip/floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/floquet.html
https://qutip.org/docs/4.7/modules/qutip/floquet.html:22570,Modifiability,evolve,evolved,22570,"tip.solver.Result`, which; contains either an *array* of expectation values or an array of; state vectors, for the times specified by `tlist`.; """"""; opt = options or Options(); if opt.tidy:; R.tidyup(); rho0 = rho0.proj() if rho0.isket else rho0. # Prepare output object.; dt = tlist[1] - tlist[0]; output = Result(); output.solver = ""fmmesolve""; output.times = tlist; if isinstance(e_ops, FunctionType):; expt_callback = True; store_states = opt.store_states or False; else:; expt_callback = False; try:; e_ops = list(e_ops); except TypeError:; raise TypeError(""`e_ops` must be iterable or a function"") from None; n_expt_op = len(e_ops); if n_expt_op == 0:; store_states = True; else:; output.expect = []; output.num_expect = n_expt_op; for op in e_ops:; dtype = np.float64 if op.isherm else np.complex128; output.expect.append(np.zeros(len(tlist), dtype=dtype)); store_states = opt.store_states or (n_expt_op == 0); if store_states:; output.states = []. # Choose which frame transformations should be done on the initial and; # evolved states.; lab_lookup = [f_modes_table_t, f_energies, T]; if (; any(x is None for x in lab_lookup); and not all(x is None for x in lab_lookup); ):; warnings.warn(; ""if transformation back to the computational basis in the lab""; ""frame is desired, all of `f_modes_t`, `f_energies` and `T` must""; ""be supplied.""; ); f_modes_table_t = f_energies = T = None. # Initial state.; if f_modes_0 is not None:; rho0 = rho0.transform(f_modes_0). # Evolved states.; if floquet_basis:; def transform(rho, t):; return rho; elif f_modes_table_t is not None:; # Lab frame, computational basis.; def transform(rho, t):; f_modes_t = floquet_modes_t_lookup(f_modes_table_t, t, T); f_states_t = floquet_states(f_modes_t, f_energies, t); return rho.transform(f_states_t, True); elif f_modes_0 is not None:; # Interaction picture, computational basis.; def transform(rho, t):; return rho.transform(f_modes_0, False); else:; raise ValueError(; ""cannot transform out of the Floquet basis w",MatchSource.WIKI,docs/4.7/modules/qutip/floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/floquet.html
https://qutip.org/docs/4.7/modules/qutip/floquet.html:18207,Usability,simpl,simple,18207,"on Bloch-Redfield form, or perhaps; # we can use the Lindblad form master equation with some rotating frame; # approximations? ...; #; for a in range(N):; for b in range(N):; if a != b and abs(A[a, b]) > 0.0:; # only relaxation terms included...; c_ops.append(sqrt(A[a, b]) * projection(N, a, b)). return c_ops. def floquet_master_equation_tensor(Alist, f_energies):; """"""; Construct a tensor that represents the master equation in the floquet; basis (with constant Hamiltonian and collapse operators). Simplest RWA approximation [Grifoni et al, Phys.Rep. 304 229 (1998)]. Parameters; ----------. Alist : list; A list of Floquet-Markov master equation rate matrices. f_energies : array; The Floquet energies. Returns; -------. output : array. The Floquet-Markov master equation tensor `R`. """""". if isinstance(Alist, list):; # Alist can be a list of rate matrices corresponding; # to different operators that couple to the environment; N, M = np.shape(Alist[0]); else:; # or a simple rate matrix, in which case we put it in a list; Alist = [Alist]; N, M = np.shape(Alist[0]). Rdata_lil = scipy.sparse.lil_matrix((N * N, N * N), dtype=complex). AsumList = [np.sum(A, axis=1) for A in Alist]. for k in range(len(Alist)):; for i in range(N):; Rdata_lil[i+N*i, i+N*i] -= -Alist[k][i, i] + AsumList[k][i]; for j in range(i+1, N):; Rdata_lil[i+N*i, j+N*j] += Alist[k][j, i]; Rdata_lil[j+N*j, i+N*i] += Alist[k][i, j]; a_term = -(1/2)*(AsumList[k][i] + AsumList[k][j]); Rdata_lil[i+N*j, i+N*j] += a_term; Rdata_lil[j+N*i, j+N*i] += a_term. return Qobj(Rdata_lil, dims=[[N, N], [N, N]], shape=(N*N, N*N)). [docs]def floquet_master_equation_steadystate(H, A):; """"""; Returns the steadystate density matrix (in the floquet basis!) for the; Floquet-Markov master equation.; """"""; c_ops = floquet_collapse_operators(A); rho_ss = steadystate(H, c_ops); return rho_ss. [docs]def floquet_basis_transform(f_modes, f_energies, rho0):; """"""; Make a basis transform that takes rho0 from the floquet basis to the; computationa",MatchSource.WIKI,docs/4.7/modules/qutip/floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/floquet.html
https://qutip.org/docs/4.7/modules/qutip/graph.html:7931,Deployability,update,updated,7931,"tations that attempts to maximize the product; of the ABS values of the diagonal elements in a nonsingular square CSC; sparse matrix. Such a permutation is always possible provided that the; matrix is nonsingular. This function looks at both the structure and ABS values of the underlying; matrix. Parameters; ----------; A : csc_matrix; Input matrix. perm_type : str {'row', 'column'}; Type of permutation to generate. Returns; -------; perm : array; Array of row or column permutations. Notes; -----; This function uses a weighted maximum cardinality bipartite matching; algorithm based on breadth-first search (BFS). The columns are weighted; according to the element of max ABS value in the associated rows and are; traversed in descending order by weight. When performing the BFS; traversal, the row associated to a given column is the one with maximum; weight. Unlike other techniques[1]_, this algorithm does not guarantee the; product of the diagonal is maximized. However, this limitation is offset; by the substantially faster runtime of this method. References; ----------; I. S. Duff and J. Koster, ""The design and use of algorithms for permuting; large entries to the diagonal of sparse matrices"", SIAM J. Matrix Anal.; and Applics. 20, no. 4, 889 (1997).; """"""; _deprecate(); nrows = A.shape[0]; if A.shape[0] != A.shape[1]:; raise ValueError('weighted_bfs_matching requires a square matrix.'); if sp.isspmatrix_csr(A) or sp.isspmatrix_coo(A):; A = A.tocsc(); elif not sp.isspmatrix_csc(A):; raise TypeError(""matrix must be in CSC, CSR, or COO format.""). if perm_type == 'column':; A = A.transpose().tocsc(); perm = _weighted_bipartite_matching(; np.asarray(np.abs(A.data), dtype=float),; A.indices, A.indptr, nrows); if np.any(perm == -1):; raise Exception('Possibly singular input matrix.'); return perm. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/modules/qutip/graph.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/graph.html
https://qutip.org/docs/4.7/modules/qutip/graph.html:395,Integrability,rout,routines,395,". qutip.graph — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.graph. Source code for qutip.graph; """"""; This module contains a collection of graph theory routines used mainly; to reorder matrices for iterative steady state solvers.; """""". __all__ = ['graph_degree', 'column_permutation', 'breadth_first_search',; 'reverse_cuthill_mckee', 'maximum_bipartite_matching',; 'weighted_bipartite_matching']. import numpy as np; import scipy.sparse as sp; from qutip.cy.graph_utils import (; _breadth_first_search, _node_degrees,; _reverse_cuthill_mckee, _maximum_bipartite_matching,; _weighted_bipartite_matching); import warnings. def _deprecate():; warnings.warn((""qutip graph functions are deprecated.""; "" Consider using scipy.sparse.csgraph instead.""),; DeprecationWarning). [docs]def graph_degree(A):; """"""; Returns the degree for the nodes (rows) of a symmetric graph in sparse CSR; or CSC format, or a qobj. Parameters; ----------; A : qobj, csr_matrix, csc_matrix; Input quantum object or csr_matrix. Returns; -------; degree : array; Array of integers giving the degree for each node (row).; """"""; _deprecate(); if not (sp.isspmatrix_csc(A) or sp.isspmatrix_csr(A)):; raise TypeError('Input must be CSC or CSR sparse matrix.'); return np.asarray(_node_degrees(A.indices, A.indptr, A.shape[0])). [docs]def breadth_first_search(A, start):; """"""; Breadth-First-Search (BFS) of a graph in CSR or CSC matrix format starting; from a given node (row). Takes Qobjs and CSR or CSC matrices as inputs. This function requires a matrix with symmetric structure. Use A+trans(A); if original matrix is not symmetric or not sure. Parameters; ----------; A : csc_matrix, csr_matrix; Input graph in CSC or CSR matrix format; start : int; Staring node for BFS traversal. Returns; ",MatchSource.WIKI,docs/4.7/modules/qutip/graph.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/graph.html
https://qutip.org/docs/4.7/modules/qutip/graph.html:3289,Integrability,rout,routine,3289,"pe[0]; start = int(start); order, levels = _breadth_first_search(A.indices, A.indptr, num_rows, start); # since maybe not all nodes are in search, check for unused entires in; # arrays; return order[order != -1], levels[levels != -1]. def column_permutation(A):; """"""; Finds the non-symmetric column permutation of A such that the columns; are given in ascending order according to the number of nonzero entries.; This is sometimes useful for decreasing the fill-in of sparse LU; factorization. Parameters; ----------; A : csc_matrix; Input sparse CSC sparse matrix. Returns; -------; perm : array; Array of permuted row and column indices.; """"""; _deprecate(); if not sp.isspmatrix_csc(A):; A = sp.csc_matrix(A); count = np.diff(A.indptr); perm = np.argsort(count); return perm. [docs]def reverse_cuthill_mckee(A, sym=False):; """"""; Returns the permutation array that orders a sparse CSR or CSC matrix in; Reverse-Cuthill McKee ordering. Since the input matrix must be symmetric,; this routine works on the matrix A+Trans(A) if the sym flag is set to False; (Default). It is assumed by default (*sym=False*) that the input matrix is not; symmetric. This is because it is faster to do A+Trans(A) than it is to; check for symmetry for a generic matrix. If you are guaranteed that the; matrix is symmetric in structure (values of matrix element do not matter); then set *sym=True*. Parameters; ----------; A : csc_matrix, csr_matrix; Input sparse CSC or CSR sparse matrix format.; sym : bool {False, True}; Flag to set whether input matrix is symmetric. Returns; -------; perm : array; Array of permuted row and column indices. Notes; -----; This routine is used primarily for internal reordering of Lindblad; superoperators for use in iterative solver routines. References; ----------; E. Cuthill and J. McKee, ""Reducing the Bandwidth of Sparse Symmetric; Matrices"", ACM '69 Proceedings of the 1969 24th national conference,; (1969).; """"""; _deprecate(); if not (sp.isspmatrix_csc(A) or sp.isspmatrix_csr(A",MatchSource.WIKI,docs/4.7/modules/qutip/graph.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/graph.html
https://qutip.org/docs/4.7/modules/qutip/graph.html:3947,Integrability,rout,routine,3947," A = sp.csc_matrix(A); count = np.diff(A.indptr); perm = np.argsort(count); return perm. [docs]def reverse_cuthill_mckee(A, sym=False):; """"""; Returns the permutation array that orders a sparse CSR or CSC matrix in; Reverse-Cuthill McKee ordering. Since the input matrix must be symmetric,; this routine works on the matrix A+Trans(A) if the sym flag is set to False; (Default). It is assumed by default (*sym=False*) that the input matrix is not; symmetric. This is because it is faster to do A+Trans(A) than it is to; check for symmetry for a generic matrix. If you are guaranteed that the; matrix is symmetric in structure (values of matrix element do not matter); then set *sym=True*. Parameters; ----------; A : csc_matrix, csr_matrix; Input sparse CSC or CSR sparse matrix format.; sym : bool {False, True}; Flag to set whether input matrix is symmetric. Returns; -------; perm : array; Array of permuted row and column indices. Notes; -----; This routine is used primarily for internal reordering of Lindblad; superoperators for use in iterative solver routines. References; ----------; E. Cuthill and J. McKee, ""Reducing the Bandwidth of Sparse Symmetric; Matrices"", ACM '69 Proceedings of the 1969 24th national conference,; (1969).; """"""; _deprecate(); if not (sp.isspmatrix_csc(A) or sp.isspmatrix_csr(A)):; raise TypeError('Input must be CSC or CSR sparse matrix.'); nrows = A.shape[0]; if not sym:; A = A + A.transpose(); return _reverse_cuthill_mckee(A.indices, A.indptr, nrows). [docs]def maximum_bipartite_matching(A, perm_type='row'):; """"""; Returns an array of row or column permutations that removes nonzero; elements from the diagonal of a nonsingular square CSC sparse matrix. Such; a permutation is always possible provided that the matrix is nonsingular.; This function looks at the structure of the matrix only. The input matrix will be converted to CSC matrix format if necessary. Parameters; ----------; A : sparse matrix; Input matrix. perm_type : str {'row', 'column'}; Type o",MatchSource.WIKI,docs/4.7/modules/qutip/graph.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/graph.html
https://qutip.org/docs/4.7/modules/qutip/graph.html:4053,Integrability,rout,routines,4053," A = sp.csc_matrix(A); count = np.diff(A.indptr); perm = np.argsort(count); return perm. [docs]def reverse_cuthill_mckee(A, sym=False):; """"""; Returns the permutation array that orders a sparse CSR or CSC matrix in; Reverse-Cuthill McKee ordering. Since the input matrix must be symmetric,; this routine works on the matrix A+Trans(A) if the sym flag is set to False; (Default). It is assumed by default (*sym=False*) that the input matrix is not; symmetric. This is because it is faster to do A+Trans(A) than it is to; check for symmetry for a generic matrix. If you are guaranteed that the; matrix is symmetric in structure (values of matrix element do not matter); then set *sym=True*. Parameters; ----------; A : csc_matrix, csr_matrix; Input sparse CSC or CSR sparse matrix format.; sym : bool {False, True}; Flag to set whether input matrix is symmetric. Returns; -------; perm : array; Array of permuted row and column indices. Notes; -----; This routine is used primarily for internal reordering of Lindblad; superoperators for use in iterative solver routines. References; ----------; E. Cuthill and J. McKee, ""Reducing the Bandwidth of Sparse Symmetric; Matrices"", ACM '69 Proceedings of the 1969 24th national conference,; (1969).; """"""; _deprecate(); if not (sp.isspmatrix_csc(A) or sp.isspmatrix_csr(A)):; raise TypeError('Input must be CSC or CSR sparse matrix.'); nrows = A.shape[0]; if not sym:; A = A + A.transpose(); return _reverse_cuthill_mckee(A.indices, A.indptr, nrows). [docs]def maximum_bipartite_matching(A, perm_type='row'):; """"""; Returns an array of row or column permutations that removes nonzero; elements from the diagonal of a nonsingular square CSC sparse matrix. Such; a permutation is always possible provided that the matrix is nonsingular.; This function looks at the structure of the matrix only. The input matrix will be converted to CSC matrix format if necessary. Parameters; ----------; A : sparse matrix; Input matrix. perm_type : str {'row', 'column'}; Type o",MatchSource.WIKI,docs/4.7/modules/qutip/graph.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/graph.html
https://qutip.org/docs/4.7/modules/qutip/graph.html:6798,Performance,perform,performing,6798,"s); if np.any(perm == -1):; raise Exception('Possibly singular input matrix.'); return perm. [docs]def weighted_bipartite_matching(A, perm_type='row'):; """"""; Returns an array of row permutations that attempts to maximize the product; of the ABS values of the diagonal elements in a nonsingular square CSC; sparse matrix. Such a permutation is always possible provided that the; matrix is nonsingular. This function looks at both the structure and ABS values of the underlying; matrix. Parameters; ----------; A : csc_matrix; Input matrix. perm_type : str {'row', 'column'}; Type of permutation to generate. Returns; -------; perm : array; Array of row or column permutations. Notes; -----; This function uses a weighted maximum cardinality bipartite matching; algorithm based on breadth-first search (BFS). The columns are weighted; according to the element of max ABS value in the associated rows and are; traversed in descending order by weight. When performing the BFS; traversal, the row associated to a given column is the one with maximum; weight. Unlike other techniques[1]_, this algorithm does not guarantee the; product of the diagonal is maximized. However, this limitation is offset; by the substantially faster runtime of this method. References; ----------; I. S. Duff and J. Koster, ""The design and use of algorithms for permuting; large entries to the diagonal of sparse matrices"", SIAM J. Matrix Anal.; and Applics. 20, no. 4, 889 (1997).; """"""; _deprecate(); nrows = A.shape[0]; if A.shape[0] != A.shape[1]:; raise ValueError('weighted_bfs_matching requires a square matrix.'); if sp.isspmatrix_csr(A) or sp.isspmatrix_coo(A):; A = A.tocsc(); elif not sp.isspmatrix_csc(A):; raise TypeError(""matrix must be in CSC, CSR, or COO format.""). if perm_type == 'column':; A = A.transpose().tocsc(); perm = _weighted_bipartite_matching(; np.asarray(np.abs(A.data), dtype=float),; A.indices, A.indptr, nrows); if np.any(perm == -1):; raise Exception('Possibly singular input matrix.'); return",MatchSource.WIKI,docs/4.7/modules/qutip/graph.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/graph.html
https://qutip.org/docs/4.7/modules/qutip/interpolate.html:3085,Deployability,update,updated,3085,"t can be called like a normal function with a; single or array of input points at which to evaluate; the interplating function.; ; Habermann & Kindermann, ""Multidimensional Spline Interpolation: ; Theory and Applications"", Comput Econ 30, 153 (2007). ; ; '''; ; def __init__(self, a, b, y, alpha=0, beta=0):; y = np.asarray(y); n = y.shape[0] - 1; h = (b - a)/n. coeff = np.zeros(n + 3, dtype=y.dtype); # Solutions to boundary coeffcients of spline; coeff[1] = 1/6. * (y[0] - (alpha * h**2)/6) #C2 in paper; coeff[n + 1] = 1/6. * (y[n] - (beta * h**2)/6) #cn+2 in paper. # Compressed tridiagonal matrix ; ab = np.ones((3, n - 1), dtype=float); ab[0,0] = 0 # Because top row is upper diag with one less elem; ab[1, :] = 4; ab[-1,-1] = 0 # Because bottom row is lower diag with one less elem; ; B = y[1:-1].copy() #grabs elements y[1] - > y[n-2] for reduced array; B[0] -= coeff[1]; B[-1] -= coeff[n + 1]. coeff[2:-2] = la.solve_banded((1, 1), ab, B, overwrite_ab=True, ; overwrite_b=True, check_finite=False). coeff[0] = alpha * h**2/6. + 2 * coeff[1] - coeff[2]; coeff[-1] = beta * h**2/6. + 2 * coeff[-2] - coeff[-3]. self.a = a # Lower-bound of domain; self.b = b # Uppser-bound of domain; self.coeffs = coeff # Spline coefficients; self.is_complex = (y.dtype == complex) #Tells which dtype solver to use; ; def __call__(self, pnts, *args):; #If requesting a single return value; if isinstance(pnts, (int, float, complex)):; if self.is_complex:; return zinterp(pnts, self.a, ; self.b, self.coeffs); else:; return interp(pnts, self.a, self.b, self.coeffs); #If requesting multiple return values from array_like; elif isinstance(pnts, (np.ndarray,list)):; pnts = np.asarray(pnts); if self.is_complex:; return arr_zinterp(pnts, self.a, ; self.b, self.coeffs); else:; return arr_interp(pnts, self.a, self.b, self.coeffs). © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/modules/qutip/interpolate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/interpolate.html
https://qutip.org/docs/4.7/modules/qutip/interpolate.html:2034,Energy Efficiency,reduce,reduced,2034," the interval.; b : float; Upper bound of the interval.; coeffs : ndarray; Array of coeffcients defining cubic spline.; ; Notes; -----; This object can be called like a normal function with a; single or array of input points at which to evaluate; the interplating function.; ; Habermann & Kindermann, ""Multidimensional Spline Interpolation: ; Theory and Applications"", Comput Econ 30, 153 (2007). ; ; '''; ; def __init__(self, a, b, y, alpha=0, beta=0):; y = np.asarray(y); n = y.shape[0] - 1; h = (b - a)/n. coeff = np.zeros(n + 3, dtype=y.dtype); # Solutions to boundary coeffcients of spline; coeff[1] = 1/6. * (y[0] - (alpha * h**2)/6) #C2 in paper; coeff[n + 1] = 1/6. * (y[n] - (beta * h**2)/6) #cn+2 in paper. # Compressed tridiagonal matrix ; ab = np.ones((3, n - 1), dtype=float); ab[0,0] = 0 # Because top row is upper diag with one less elem; ab[1, :] = 4; ab[-1,-1] = 0 # Because bottom row is lower diag with one less elem; ; B = y[1:-1].copy() #grabs elements y[1] - > y[n-2] for reduced array; B[0] -= coeff[1]; B[-1] -= coeff[n + 1]. coeff[2:-2] = la.solve_banded((1, 1), ab, B, overwrite_ab=True, ; overwrite_b=True, check_finite=False). coeff[0] = alpha * h**2/6. + 2 * coeff[1] - coeff[2]; coeff[-1] = beta * h**2/6. + 2 * coeff[-2] - coeff[-3]. self.a = a # Lower-bound of domain; self.b = b # Uppser-bound of domain; self.coeffs = coeff # Spline coefficients; self.is_complex = (y.dtype == complex) #Tells which dtype solver to use; ; def __call__(self, pnts, *args):; #If requesting a single return value; if isinstance(pnts, (int, float, complex)):; if self.is_complex:; return zinterp(pnts, self.a, ; self.b, self.coeffs); else:; return interp(pnts, self.a, self.b, self.coeffs); #If requesting multiple return values from array_like; elif isinstance(pnts, (np.ndarray,list)):; pnts = np.asarray(pnts); if self.is_complex:; return arr_zinterp(pnts, self.a, ; self.b, self.coeffs); else:; return arr_interp(pnts, self.a, self.b, self.coeffs). © Copyright 2011 to 2021 inclusive",MatchSource.WIKI,docs/4.7/modules/qutip/interpolate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/interpolate.html
https://qutip.org/docs/4.7/modules/qutip/ipynbtools.html:9153,Availability,avail,available,9153,"Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client view; The view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default False; Display a graph showing how the tasks (the evaluation of ``task`` for; for the value in ``task_vec1``) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default False; Display a HTML-based progress bar during the execution of the parfor; loop. Returns; --------; result : list; The result list contains the value of; ``task(value, task_args, task_kwargs)`` for each; value in ``values``. """"""; submitted = datetime.datetime.now(). if task_args is None:; task_args = tuple(). if task_kwargs is None:; task_kwargs = {}. if client is None:; client = Client(). # make sure qutip is available at engines; dview = client[:]; dview.block = True; dview.execute(""from qutip import *""). if view is None:; view = client.load_balanced_view(). ar_list = [view.apply_async(task, value, *task_args, **task_kwargs); for value in values]. if progress_bar is None:; view.wait(ar_list); else:; if progress_bar is True:; progress_bar = HTMLProgressBar(). n = len(ar_list); progress_bar.start(n); while True:; n_finished = sum([ar.progress for ar in ar_list]); progress_bar.update(n_finished). if view.wait(ar_list, timeout=0.5):; progress_bar.update(n); break; progress_bar.finished(). if show_scheduling:; metadata = [[ar.engine_id,; (ar.started - submitted).total_seconds(),; (ar.completed - submitted).total_seconds()]; for ar in ar_list]; _visualize_parfor_data(metadata). return [ar.get() for ar in ar_list]. def plot_animation(plot_setup_func, plot_func, result, name=""movie"",; writer=""avconv"", codec=""libx264"", verbose=False):; """"""; Create an animated plot of a Result object, as returned by one of; the ",MatchSource.WIKI,docs/4.7/modules/qutip/ipynbtools.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/ipynbtools.html
https://qutip.org/docs/4.7/modules/qutip/ipynbtools.html:3240,Deployability,update,update,3240,"""IPython"", IPython.__version__),; (""Python"", sys.version),; (""OS"", ""%s [%s]"" % (os.name, sys.platform)); ]. for name, version in packages:; html += ""<tr><td>%s</td><td>%s</td></tr>"" % (name, version). if verbose:; html += ""<tr><th colspan='2'>Additional information</th></tr>""; qutip_install_path = os.path.dirname(inspect.getsourcefile(qutip)); html += (""<tr><td>Installation path</td><td>%s</td></tr>"" %; qutip_install_path); try:; import getpass; html += (""<tr><td>User</td><td>%s</td></tr>"" %; getpass.getuser()); except:; pass. html += ""<tr><td colspan='2'>%s</td></tr>"" % time.strftime(; '%a %b %d %H:%M:%S %Y %Z'); html += ""</table>"". return HTML(html). class HTMLProgressBar(BaseProgressBar):; """"""; A simple HTML progress bar for using in IPython notebooks. Based on; IPython ProgressBar demo notebook:; https://github.com/ipython/ipython/tree/master/examples/notebooks. Example usage:. n_vec = linspace(0, 10, 100); pbar = HTMLProgressBar(len(n_vec)); for n in n_vec:; pbar.update(n); compute_with_n(n); """""". def __init__(self, iterations=0, chunk_size=1.0):; self.divid = str(uuid.uuid4()); self.textid = str(uuid.uuid4()); self.pb = HTML(""""""\; <div style=""border: 2px solid grey; width: 600px"">; <div id=""%s"" \; style=""background-color: rgba(121,195,106,0.75); width:0%%"">&nbsp;</div>; </div>; <p id=""%s""></p>; """""" % (self.divid, self.textid)); display(self.pb); super(HTMLProgressBar, self).start(iterations, chunk_size). def start(self, iterations=0, chunk_size=1.0):; super(HTMLProgressBar, self).start(iterations, chunk_size). def update(self, n):; p = (n / self.N) * 100.0; if p >= self.p_chunk:; lbl = (""Elapsed time: %s. "" % self.time_elapsed() +; ""Est. remaining time: %s."" % self.time_remaining_est(p)); js_code = (""$('div#%s').width('%i%%');"" % (self.divid, p) +; ""$('p#%s').text('%s');"" % (self.textid, lbl)); display(Javascript(js_code)); # display(Javascript(""$('div#%s').width('%i%%')"" % (self.divid,; # p))); self.p_chunk += self.p_chunk_size. def finished(self):; self.t_do",MatchSource.WIKI,docs/4.7/modules/qutip/ipynbtools.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/ipynbtools.html
https://qutip.org/docs/4.7/modules/qutip/ipynbtools.html:3803,Deployability,update,update,3803,"2'>%s</td></tr>"" % time.strftime(; '%a %b %d %H:%M:%S %Y %Z'); html += ""</table>"". return HTML(html). class HTMLProgressBar(BaseProgressBar):; """"""; A simple HTML progress bar for using in IPython notebooks. Based on; IPython ProgressBar demo notebook:; https://github.com/ipython/ipython/tree/master/examples/notebooks. Example usage:. n_vec = linspace(0, 10, 100); pbar = HTMLProgressBar(len(n_vec)); for n in n_vec:; pbar.update(n); compute_with_n(n); """""". def __init__(self, iterations=0, chunk_size=1.0):; self.divid = str(uuid.uuid4()); self.textid = str(uuid.uuid4()); self.pb = HTML(""""""\; <div style=""border: 2px solid grey; width: 600px"">; <div id=""%s"" \; style=""background-color: rgba(121,195,106,0.75); width:0%%"">&nbsp;</div>; </div>; <p id=""%s""></p>; """""" % (self.divid, self.textid)); display(self.pb); super(HTMLProgressBar, self).start(iterations, chunk_size). def start(self, iterations=0, chunk_size=1.0):; super(HTMLProgressBar, self).start(iterations, chunk_size). def update(self, n):; p = (n / self.N) * 100.0; if p >= self.p_chunk:; lbl = (""Elapsed time: %s. "" % self.time_elapsed() +; ""Est. remaining time: %s."" % self.time_remaining_est(p)); js_code = (""$('div#%s').width('%i%%');"" % (self.divid, p) +; ""$('p#%s').text('%s');"" % (self.textid, lbl)); display(Javascript(js_code)); # display(Javascript(""$('div#%s').width('%i%%')"" % (self.divid,; # p))); self.p_chunk += self.p_chunk_size. def finished(self):; self.t_done = time.time(); lbl = ""Elapsed time: %s"" % self.time_elapsed(); js_code = (""$('div#%s').width('%i%%');"" % (self.divid, 100.0) +; ""$('p#%s').text('%s');"" % (self.textid, lbl)); display(Javascript(js_code)). def _visualize_parfor_data(metadata):; """"""; Visualizing the task scheduling meta data collected from AsyncResults.; """"""; res = numpy.array(metadata); fig, ax = plt.subplots(figsize=(10, res.shape[1])). yticks = []; yticklabels = []; tmin = min(res[:, 1]); for n, pid in enumerate(numpy.unique(res[:, 0])):; yticks.append(n); yticklabels.append(""%d"" % p",MatchSource.WIKI,docs/4.7/modules/qutip/ipynbtools.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/ipynbtools.html
https://qutip.org/docs/4.7/modules/qutip/ipynbtools.html:9628,Deployability,update,update,9628,"vec1``) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default False; Display a HTML-based progress bar during the execution of the parfor; loop. Returns; --------; result : list; The result list contains the value of; ``task(value, task_args, task_kwargs)`` for each; value in ``values``. """"""; submitted = datetime.datetime.now(). if task_args is None:; task_args = tuple(). if task_kwargs is None:; task_kwargs = {}. if client is None:; client = Client(). # make sure qutip is available at engines; dview = client[:]; dview.block = True; dview.execute(""from qutip import *""). if view is None:; view = client.load_balanced_view(). ar_list = [view.apply_async(task, value, *task_args, **task_kwargs); for value in values]. if progress_bar is None:; view.wait(ar_list); else:; if progress_bar is True:; progress_bar = HTMLProgressBar(). n = len(ar_list); progress_bar.start(n); while True:; n_finished = sum([ar.progress for ar in ar_list]); progress_bar.update(n_finished). if view.wait(ar_list, timeout=0.5):; progress_bar.update(n); break; progress_bar.finished(). if show_scheduling:; metadata = [[ar.engine_id,; (ar.started - submitted).total_seconds(),; (ar.completed - submitted).total_seconds()]; for ar in ar_list]; _visualize_parfor_data(metadata). return [ar.get() for ar in ar_list]. def plot_animation(plot_setup_func, plot_func, result, name=""movie"",; writer=""avconv"", codec=""libx264"", verbose=False):; """"""; Create an animated plot of a Result object, as returned by one of; the qutip evolution solvers. .. note :: experimental; """""". fig, axes = plot_setup_func(result). def update(n):; return plot_func(result, n, fig=fig, axes=axes). anim = animation.FuncAnimation(; fig, update, frames=len(result.times), blit=True). anim.save(name + '.mp4', fps=10, writer=writer, codec=codec). plt.close(fig). if verbose:; print(""Created %s.m4v"" % name). video = open(name + '.mp4', ""rb"").read(); video_encoded = b64encode(video).decode(""ascii""); video_tag = '<vi",MatchSource.WIKI,docs/4.7/modules/qutip/ipynbtools.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/ipynbtools.html
https://qutip.org/docs/4.7/modules/qutip/ipynbtools.html:9698,Deployability,update,update,9698," {False, True}, default False; Display a HTML-based progress bar during the execution of the parfor; loop. Returns; --------; result : list; The result list contains the value of; ``task(value, task_args, task_kwargs)`` for each; value in ``values``. """"""; submitted = datetime.datetime.now(). if task_args is None:; task_args = tuple(). if task_kwargs is None:; task_kwargs = {}. if client is None:; client = Client(). # make sure qutip is available at engines; dview = client[:]; dview.block = True; dview.execute(""from qutip import *""). if view is None:; view = client.load_balanced_view(). ar_list = [view.apply_async(task, value, *task_args, **task_kwargs); for value in values]. if progress_bar is None:; view.wait(ar_list); else:; if progress_bar is True:; progress_bar = HTMLProgressBar(). n = len(ar_list); progress_bar.start(n); while True:; n_finished = sum([ar.progress for ar in ar_list]); progress_bar.update(n_finished). if view.wait(ar_list, timeout=0.5):; progress_bar.update(n); break; progress_bar.finished(). if show_scheduling:; metadata = [[ar.engine_id,; (ar.started - submitted).total_seconds(),; (ar.completed - submitted).total_seconds()]; for ar in ar_list]; _visualize_parfor_data(metadata). return [ar.get() for ar in ar_list]. def plot_animation(plot_setup_func, plot_func, result, name=""movie"",; writer=""avconv"", codec=""libx264"", verbose=False):; """"""; Create an animated plot of a Result object, as returned by one of; the qutip evolution solvers. .. note :: experimental; """""". fig, axes = plot_setup_func(result). def update(n):; return plot_func(result, n, fig=fig, axes=axes). anim = animation.FuncAnimation(; fig, update, frames=len(result.times), blit=True). anim.save(name + '.mp4', fps=10, writer=writer, codec=codec). plt.close(fig). if verbose:; print(""Created %s.m4v"" % name). video = open(name + '.mp4', ""rb"").read(); video_encoded = b64encode(video).decode(""ascii""); video_tag = '<video controls src=""data:video/x-m4v;base64,{0}"">'.format(; video_encoded); re",MatchSource.WIKI,docs/4.7/modules/qutip/ipynbtools.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/ipynbtools.html
https://qutip.org/docs/4.7/modules/qutip/ipynbtools.html:10262,Deployability,update,update,10262,", task_kwargs)`` for each; value in ``values``. """"""; submitted = datetime.datetime.now(). if task_args is None:; task_args = tuple(). if task_kwargs is None:; task_kwargs = {}. if client is None:; client = Client(). # make sure qutip is available at engines; dview = client[:]; dview.block = True; dview.execute(""from qutip import *""). if view is None:; view = client.load_balanced_view(). ar_list = [view.apply_async(task, value, *task_args, **task_kwargs); for value in values]. if progress_bar is None:; view.wait(ar_list); else:; if progress_bar is True:; progress_bar = HTMLProgressBar(). n = len(ar_list); progress_bar.start(n); while True:; n_finished = sum([ar.progress for ar in ar_list]); progress_bar.update(n_finished). if view.wait(ar_list, timeout=0.5):; progress_bar.update(n); break; progress_bar.finished(). if show_scheduling:; metadata = [[ar.engine_id,; (ar.started - submitted).total_seconds(),; (ar.completed - submitted).total_seconds()]; for ar in ar_list]; _visualize_parfor_data(metadata). return [ar.get() for ar in ar_list]. def plot_animation(plot_setup_func, plot_func, result, name=""movie"",; writer=""avconv"", codec=""libx264"", verbose=False):; """"""; Create an animated plot of a Result object, as returned by one of; the qutip evolution solvers. .. note :: experimental; """""". fig, axes = plot_setup_func(result). def update(n):; return plot_func(result, n, fig=fig, axes=axes). anim = animation.FuncAnimation(; fig, update, frames=len(result.times), blit=True). anim.save(name + '.mp4', fps=10, writer=writer, codec=codec). plt.close(fig). if verbose:; print(""Created %s.m4v"" % name). video = open(name + '.mp4', ""rb"").read(); video_encoded = b64encode(video).decode(""ascii""); video_tag = '<video controls src=""data:video/x-m4v;base64,{0}"">'.format(; video_encoded); return HTML(video_tag). © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/modules/qutip/ipynbtools.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/ipynbtools.html
https://qutip.org/docs/4.7/modules/qutip/ipynbtools.html:10361,Deployability,update,update,10361,", task_kwargs)`` for each; value in ``values``. """"""; submitted = datetime.datetime.now(). if task_args is None:; task_args = tuple(). if task_kwargs is None:; task_kwargs = {}. if client is None:; client = Client(). # make sure qutip is available at engines; dview = client[:]; dview.block = True; dview.execute(""from qutip import *""). if view is None:; view = client.load_balanced_view(). ar_list = [view.apply_async(task, value, *task_args, **task_kwargs); for value in values]. if progress_bar is None:; view.wait(ar_list); else:; if progress_bar is True:; progress_bar = HTMLProgressBar(). n = len(ar_list); progress_bar.start(n); while True:; n_finished = sum([ar.progress for ar in ar_list]); progress_bar.update(n_finished). if view.wait(ar_list, timeout=0.5):; progress_bar.update(n); break; progress_bar.finished(). if show_scheduling:; metadata = [[ar.engine_id,; (ar.started - submitted).total_seconds(),; (ar.completed - submitted).total_seconds()]; for ar in ar_list]; _visualize_parfor_data(metadata). return [ar.get() for ar in ar_list]. def plot_animation(plot_setup_func, plot_func, result, name=""movie"",; writer=""avconv"", codec=""libx264"", verbose=False):; """"""; Create an animated plot of a Result object, as returned by one of; the qutip evolution solvers. .. note :: experimental; """""". fig, axes = plot_setup_func(result). def update(n):; return plot_func(result, n, fig=fig, axes=axes). anim = animation.FuncAnimation(; fig, update, frames=len(result.times), blit=True). anim.save(name + '.mp4', fps=10, writer=writer, codec=codec). plt.close(fig). if verbose:; print(""Created %s.m4v"" % name). video = open(name + '.mp4', ""rb"").read(); video_encoded = b64encode(video).decode(""ascii""); video_tag = '<video controls src=""data:video/x-m4v;base64,{0}"">'.format(; video_encoded); return HTML(video_tag). © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/modules/qutip/ipynbtools.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/ipynbtools.html
https://qutip.org/docs/4.7/modules/qutip/ipynbtools.html:10815,Deployability,update,updated,10815,", task_kwargs)`` for each; value in ``values``. """"""; submitted = datetime.datetime.now(). if task_args is None:; task_args = tuple(). if task_kwargs is None:; task_kwargs = {}. if client is None:; client = Client(). # make sure qutip is available at engines; dview = client[:]; dview.block = True; dview.execute(""from qutip import *""). if view is None:; view = client.load_balanced_view(). ar_list = [view.apply_async(task, value, *task_args, **task_kwargs); for value in values]. if progress_bar is None:; view.wait(ar_list); else:; if progress_bar is True:; progress_bar = HTMLProgressBar(). n = len(ar_list); progress_bar.start(n); while True:; n_finished = sum([ar.progress for ar in ar_list]); progress_bar.update(n_finished). if view.wait(ar_list, timeout=0.5):; progress_bar.update(n); break; progress_bar.finished(). if show_scheduling:; metadata = [[ar.engine_id,; (ar.started - submitted).total_seconds(),; (ar.completed - submitted).total_seconds()]; for ar in ar_list]; _visualize_parfor_data(metadata). return [ar.get() for ar in ar_list]. def plot_animation(plot_setup_func, plot_func, result, name=""movie"",; writer=""avconv"", codec=""libx264"", verbose=False):; """"""; Create an animated plot of a Result object, as returned by one of; the qutip evolution solvers. .. note :: experimental; """""". fig, axes = plot_setup_func(result). def update(n):; return plot_func(result, n, fig=fig, axes=axes). anim = animation.FuncAnimation(; fig, update, frames=len(result.times), blit=True). anim.save(name + '.mp4', fps=10, writer=writer, codec=codec). plt.close(fig). if verbose:; print(""Created %s.m4v"" % name). video = open(name + '.mp4', ""rb"").read(); video_encoded = b64encode(video).decode(""ascii""); video_tag = '<video controls src=""data:video/x-m4v;base64,{0}"">'.format(; video_encoded); return HTML(video_tag). © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/modules/qutip/ipynbtools.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/ipynbtools.html
https://qutip.org/docs/4.7/modules/qutip/ipynbtools.html:4530,Energy Efficiency,schedul,scheduling,4530,",0.75); width:0%%"">&nbsp;</div>; </div>; <p id=""%s""></p>; """""" % (self.divid, self.textid)); display(self.pb); super(HTMLProgressBar, self).start(iterations, chunk_size). def start(self, iterations=0, chunk_size=1.0):; super(HTMLProgressBar, self).start(iterations, chunk_size). def update(self, n):; p = (n / self.N) * 100.0; if p >= self.p_chunk:; lbl = (""Elapsed time: %s. "" % self.time_elapsed() +; ""Est. remaining time: %s."" % self.time_remaining_est(p)); js_code = (""$('div#%s').width('%i%%');"" % (self.divid, p) +; ""$('p#%s').text('%s');"" % (self.textid, lbl)); display(Javascript(js_code)); # display(Javascript(""$('div#%s').width('%i%%')"" % (self.divid,; # p))); self.p_chunk += self.p_chunk_size. def finished(self):; self.t_done = time.time(); lbl = ""Elapsed time: %s"" % self.time_elapsed(); js_code = (""$('div#%s').width('%i%%');"" % (self.divid, 100.0) +; ""$('p#%s').text('%s');"" % (self.textid, lbl)); display(Javascript(js_code)). def _visualize_parfor_data(metadata):; """"""; Visualizing the task scheduling meta data collected from AsyncResults.; """"""; res = numpy.array(metadata); fig, ax = plt.subplots(figsize=(10, res.shape[1])). yticks = []; yticklabels = []; tmin = min(res[:, 1]); for n, pid in enumerate(numpy.unique(res[:, 0])):; yticks.append(n); yticklabels.append(""%d"" % pid); for m in numpy.where(res[:, 0] == pid)[0]:; ax.add_patch(plt.Rectangle((res[m, 1] - tmin, n - 0.25),; res[m, 2] - res[m, 1], 0.5, color=""green"", alpha=0.5)). ax.set_ylim(-.5, n + .5); ax.set_xlim(0, max(res[:, 2]) - tmin + 0.); ax.set_yticks(yticks); ax.set_yticklabels(yticklabels); ax.set_ylabel(""Engine""); ax.set_xlabel(""seconds""); ax.set_title(""Task schedule""). [docs]def parfor(task, task_vec, args=None, client=None, view=None,; show_scheduling=False, show_progressbar=False):; """"""; Call the function ``tast`` for each value in ``task_vec`` using a cluster; of IPython engines. The function ``task`` should have the signature; ``task(value, args)`` or ``task(value)`` if ``args=None``. The ``cl",MatchSource.WIKI,docs/4.7/modules/qutip/ipynbtools.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/ipynbtools.html
https://qutip.org/docs/4.7/modules/qutip/ipynbtools.html:4959,Energy Efficiency,green,green,4959,"remaining_est(p)); js_code = (""$('div#%s').width('%i%%');"" % (self.divid, p) +; ""$('p#%s').text('%s');"" % (self.textid, lbl)); display(Javascript(js_code)); # display(Javascript(""$('div#%s').width('%i%%')"" % (self.divid,; # p))); self.p_chunk += self.p_chunk_size. def finished(self):; self.t_done = time.time(); lbl = ""Elapsed time: %s"" % self.time_elapsed(); js_code = (""$('div#%s').width('%i%%');"" % (self.divid, 100.0) +; ""$('p#%s').text('%s');"" % (self.textid, lbl)); display(Javascript(js_code)). def _visualize_parfor_data(metadata):; """"""; Visualizing the task scheduling meta data collected from AsyncResults.; """"""; res = numpy.array(metadata); fig, ax = plt.subplots(figsize=(10, res.shape[1])). yticks = []; yticklabels = []; tmin = min(res[:, 1]); for n, pid in enumerate(numpy.unique(res[:, 0])):; yticks.append(n); yticklabels.append(""%d"" % pid); for m in numpy.where(res[:, 0] == pid)[0]:; ax.add_patch(plt.Rectangle((res[m, 1] - tmin, n - 0.25),; res[m, 2] - res[m, 1], 0.5, color=""green"", alpha=0.5)). ax.set_ylim(-.5, n + .5); ax.set_xlim(0, max(res[:, 2]) - tmin + 0.); ax.set_yticks(yticks); ax.set_yticklabels(yticklabels); ax.set_ylabel(""Engine""); ax.set_xlabel(""seconds""); ax.set_title(""Task schedule""). [docs]def parfor(task, task_vec, args=None, client=None, view=None,; show_scheduling=False, show_progressbar=False):; """"""; Call the function ``tast`` for each value in ``task_vec`` using a cluster; of IPython engines. The function ``task`` should have the signature; ``task(value, args)`` or ``task(value)`` if ``args=None``. The ``client`` and ``view`` are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are ``None``, new instances will be created. Parameters; ----------. task: a Python function; The function that is to be called for each value in ``task_vec``. task_vec: array / list; The list or array of values for which the ``task`` function is to be; evaluated. args: list / dictionary; The optional addition",MatchSource.WIKI,docs/4.7/modules/qutip/ipynbtools.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/ipynbtools.html
https://qutip.org/docs/4.7/modules/qutip/ipynbtools.html:5176,Energy Efficiency,schedul,schedule,5176,"lf.divid,; # p))); self.p_chunk += self.p_chunk_size. def finished(self):; self.t_done = time.time(); lbl = ""Elapsed time: %s"" % self.time_elapsed(); js_code = (""$('div#%s').width('%i%%');"" % (self.divid, 100.0) +; ""$('p#%s').text('%s');"" % (self.textid, lbl)); display(Javascript(js_code)). def _visualize_parfor_data(metadata):; """"""; Visualizing the task scheduling meta data collected from AsyncResults.; """"""; res = numpy.array(metadata); fig, ax = plt.subplots(figsize=(10, res.shape[1])). yticks = []; yticklabels = []; tmin = min(res[:, 1]); for n, pid in enumerate(numpy.unique(res[:, 0])):; yticks.append(n); yticklabels.append(""%d"" % pid); for m in numpy.where(res[:, 0] == pid)[0]:; ax.add_patch(plt.Rectangle((res[m, 1] - tmin, n - 0.25),; res[m, 2] - res[m, 1], 0.5, color=""green"", alpha=0.5)). ax.set_ylim(-.5, n + .5); ax.set_xlim(0, max(res[:, 2]) - tmin + 0.); ax.set_yticks(yticks); ax.set_yticklabels(yticklabels); ax.set_ylabel(""Engine""); ax.set_xlabel(""seconds""); ax.set_title(""Task schedule""). [docs]def parfor(task, task_vec, args=None, client=None, view=None,; show_scheduling=False, show_progressbar=False):; """"""; Call the function ``tast`` for each value in ``task_vec`` using a cluster; of IPython engines. The function ``task`` should have the signature; ``task(value, args)`` or ``task(value)`` if ``args=None``. The ``client`` and ``view`` are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are ``None``, new instances will be created. Parameters; ----------. task: a Python function; The function that is to be called for each value in ``task_vec``. task_vec: array / list; The list or array of values for which the ``task`` function is to be; evaluated. args: list / dictionary; The optional additional argument to the ``task`` function. For example; a dictionary with parameter values. client: IPython.parallel.Client; The IPython.parallel Client instance that will be used in the; parfor execution. view: a IPy",MatchSource.WIKI,docs/4.7/modules/qutip/ipynbtools.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/ipynbtools.html
https://qutip.org/docs/4.7/modules/qutip/ipynbtools.html:6232,Energy Efficiency,schedul,scheduling,6232,"client=None, view=None,; show_scheduling=False, show_progressbar=False):; """"""; Call the function ``tast`` for each value in ``task_vec`` using a cluster; of IPython engines. The function ``task`` should have the signature; ``task(value, args)`` or ``task(value)`` if ``args=None``. The ``client`` and ``view`` are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are ``None``, new instances will be created. Parameters; ----------. task: a Python function; The function that is to be called for each value in ``task_vec``. task_vec: array / list; The list or array of values for which the ``task`` function is to be; evaluated. args: list / dictionary; The optional additional argument to the ``task`` function. For example; a dictionary with parameter values. client: IPython.parallel.Client; The IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client view; The view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default False; Display a graph showing how the tasks (the evaluation of ``task`` for; for the value in ``task_vec1``) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default False; Display a HTML-based progress bar duing the execution of the parfor; loop. Returns; --------; result : list; The result list contains the value of ``task(value, args)`` for each; value in ``task_vec``, that is, it should be equivalent to; ``[task(v, args) for v in task_vec]``.; """""". if show_progressbar:; progress_bar = HTMLProgressBar(); else:; progress_bar = None. return parallel_map(task, task_vec, task_args=args,; client=client, view=view, progress_bar=progress_bar,; show_scheduling=show_scheduling). [docs]def parallel_map(task, values, task_",MatchSource.WIKI,docs/4.7/modules/qutip/ipynbtools.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/ipynbtools.html
https://qutip.org/docs/4.7/modules/qutip/ipynbtools.html:6587,Energy Efficiency,schedul,scheduled,6587,"` and ``view`` are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are ``None``, new instances will be created. Parameters; ----------. task: a Python function; The function that is to be called for each value in ``task_vec``. task_vec: array / list; The list or array of values for which the ``task`` function is to be; evaluated. args: list / dictionary; The optional additional argument to the ``task`` function. For example; a dictionary with parameter values. client: IPython.parallel.Client; The IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client view; The view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default False; Display a graph showing how the tasks (the evaluation of ``task`` for; for the value in ``task_vec1``) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default False; Display a HTML-based progress bar duing the execution of the parfor; loop. Returns; --------; result : list; The result list contains the value of ``task(value, args)`` for each; value in ``task_vec``, that is, it should be equivalent to; ``[task(v, args) for v in task_vec]``.; """""". if show_progressbar:; progress_bar = HTMLProgressBar(); else:; progress_bar = None. return parallel_map(task, task_vec, task_args=args,; client=client, view=view, progress_bar=progress_bar,; show_scheduling=show_scheduling). [docs]def parallel_map(task, values, task_args=None, task_kwargs=None,; client=None, view=None, progress_bar=None,; show_scheduling=False, **kwargs):; """"""; Call the function ``task`` for each value in ``values`` using a cluster; of IPython engines. The function ``task`` should have the signature; ``task(value, *args, **kwargs)``. The `",MatchSource.WIKI,docs/4.7/modules/qutip/ipynbtools.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/ipynbtools.html
https://qutip.org/docs/4.7/modules/qutip/ipynbtools.html:8294,Energy Efficiency,schedul,scheduling,8294,"s_bar=None,; show_scheduling=False, **kwargs):; """"""; Call the function ``task`` for each value in ``values`` using a cluster; of IPython engines. The function ``task`` should have the signature; ``task(value, *args, **kwargs)``. The ``client`` and ``view`` are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are ``None``, new instances will be created. Parameters; ----------. task: a Python function; The function that is to be called for each value in ``task_vec``. values: array / list; The list or array of values for which the ``task`` function is to be; evaluated. task_args: list / dictionary; The optional additional argument to the ``task`` function. task_kwargs: list / dictionary; The optional additional keyword argument to the ``task`` function. client: IPython.parallel.Client; The IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client view; The view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default False; Display a graph showing how the tasks (the evaluation of ``task`` for; for the value in ``task_vec1``) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default False; Display a HTML-based progress bar during the execution of the parfor; loop. Returns; --------; result : list; The result list contains the value of; ``task(value, task_args, task_kwargs)`` for each; value in ``values``. """"""; submitted = datetime.datetime.now(). if task_args is None:; task_args = tuple(). if task_kwargs is None:; task_kwargs = {}. if client is None:; client = Client(). # make sure qutip is available at engines; dview = client[:]; dview.block = True; dview.execute(""from qutip import *""). if view is None:; view = client.load_balanc",MatchSource.WIKI,docs/4.7/modules/qutip/ipynbtools.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/ipynbtools.html
https://qutip.org/docs/4.7/modules/qutip/ipynbtools.html:8649,Energy Efficiency,schedul,scheduled,8649,"oad-balanced view that will be used in the parfor execution. If these; are ``None``, new instances will be created. Parameters; ----------. task: a Python function; The function that is to be called for each value in ``task_vec``. values: array / list; The list or array of values for which the ``task`` function is to be; evaluated. task_args: list / dictionary; The optional additional argument to the ``task`` function. task_kwargs: list / dictionary; The optional additional keyword argument to the ``task`` function. client: IPython.parallel.Client; The IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client view; The view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default False; Display a graph showing how the tasks (the evaluation of ``task`` for; for the value in ``task_vec1``) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default False; Display a HTML-based progress bar during the execution of the parfor; loop. Returns; --------; result : list; The result list contains the value of; ``task(value, task_args, task_kwargs)`` for each; value in ``values``. """"""; submitted = datetime.datetime.now(). if task_args is None:; task_args = tuple(). if task_kwargs is None:; task_kwargs = {}. if client is None:; client = Client(). # make sure qutip is available at engines; dview = client[:]; dview.block = True; dview.execute(""from qutip import *""). if view is None:; view = client.load_balanced_view(). ar_list = [view.apply_async(task, value, *task_args, **task_kwargs); for value in values]. if progress_bar is None:; view.wait(ar_list); else:; if progress_bar is True:; progress_bar = HTMLProgressBar(). n = len(ar_list); progress_bar.start(n); while True:; n_finished = sum([ar.progr",MatchSource.WIKI,docs/4.7/modules/qutip/ipynbtools.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/ipynbtools.html
https://qutip.org/docs/4.7/modules/qutip/ipynbtools.html:590,Integrability,rout,routines,590,". qutip.ipynbtools — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.ipynbtools. Source code for qutip.ipynbtools; """"""; This module contains utility functions for using QuTiP with IPython notebooks.; """"""; from qutip.ui.progressbar import BaseProgressBar; from qutip.utilities import _blas_info, available_cpu_count; import IPython. #IPython parallel routines moved to ipyparallel in V4; #IPython parallel routines not in Anaconda by default; if IPython.version_info[0] >= 4:; try:; from ipyparallel import Client; __all__ = ['version_table', 'parfor', 'plot_animation',; 'parallel_map', 'HTMLProgressBar']; except:; __all__ = ['version_table', 'plot_animation', 'HTMLProgressBar']; else:; try:; from IPython.parallel import Client; __all__ = ['version_table', 'parfor', 'plot_animation',; 'parallel_map', 'HTMLProgressBar']; except:; __all__ = ['version_table', 'plot_animation', 'HTMLProgressBar']. from IPython.display import HTML, Javascript, display. import matplotlib.pyplot as plt; from matplotlib import animation; from base64 import b64encode. import datetime; import uuid; import sys; import os; import time; import inspect. import qutip; import numpy; import scipy; import Cython; import matplotlib; import IPython. [docs]def version_table(verbose=False):; """"""; Print an HTML-formatted table with version numbers for QuTiP and its; dependencies. Use it in a IPython notebook to show which versions of; different packages that were used to run the notebook. This should make it; possible to reproduce the environment and the calculation later on. Returns; --------; version_table: string; Return an HTML-formatted string containing version information for; QuTiP dependencies. """""". html = ""<table>""; html += ""<tr><th>Software</th><th>Version</th></tr>""",MatchSource.WIKI,docs/4.7/modules/qutip/ipynbtools.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/ipynbtools.html
https://qutip.org/docs/4.7/modules/qutip/ipynbtools.html:645,Integrability,rout,routines,645,". qutip.ipynbtools — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.ipynbtools. Source code for qutip.ipynbtools; """"""; This module contains utility functions for using QuTiP with IPython notebooks.; """"""; from qutip.ui.progressbar import BaseProgressBar; from qutip.utilities import _blas_info, available_cpu_count; import IPython. #IPython parallel routines moved to ipyparallel in V4; #IPython parallel routines not in Anaconda by default; if IPython.version_info[0] >= 4:; try:; from ipyparallel import Client; __all__ = ['version_table', 'parfor', 'plot_animation',; 'parallel_map', 'HTMLProgressBar']; except:; __all__ = ['version_table', 'plot_animation', 'HTMLProgressBar']; else:; try:; from IPython.parallel import Client; __all__ = ['version_table', 'parfor', 'plot_animation',; 'parallel_map', 'HTMLProgressBar']; except:; __all__ = ['version_table', 'plot_animation', 'HTMLProgressBar']. from IPython.display import HTML, Javascript, display. import matplotlib.pyplot as plt; from matplotlib import animation; from base64 import b64encode. import datetime; import uuid; import sys; import os; import time; import inspect. import qutip; import numpy; import scipy; import Cython; import matplotlib; import IPython. [docs]def version_table(verbose=False):; """"""; Print an HTML-formatted table with version numbers for QuTiP and its; dependencies. Use it in a IPython notebook to show which versions of; different packages that were used to run the notebook. This should make it; possible to reproduce the environment and the calculation later on. Returns; --------; version_table: string; Return an HTML-formatted string containing version information for; QuTiP dependencies. """""". html = ""<table>""; html += ""<tr><th>Software</th><th>Version</th></tr>""",MatchSource.WIKI,docs/4.7/modules/qutip/ipynbtools.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/ipynbtools.html
https://qutip.org/docs/4.7/modules/qutip/ipynbtools.html:1582,Integrability,depend,dependencies,1582,"nfo, available_cpu_count; import IPython. #IPython parallel routines moved to ipyparallel in V4; #IPython parallel routines not in Anaconda by default; if IPython.version_info[0] >= 4:; try:; from ipyparallel import Client; __all__ = ['version_table', 'parfor', 'plot_animation',; 'parallel_map', 'HTMLProgressBar']; except:; __all__ = ['version_table', 'plot_animation', 'HTMLProgressBar']; else:; try:; from IPython.parallel import Client; __all__ = ['version_table', 'parfor', 'plot_animation',; 'parallel_map', 'HTMLProgressBar']; except:; __all__ = ['version_table', 'plot_animation', 'HTMLProgressBar']. from IPython.display import HTML, Javascript, display. import matplotlib.pyplot as plt; from matplotlib import animation; from base64 import b64encode. import datetime; import uuid; import sys; import os; import time; import inspect. import qutip; import numpy; import scipy; import Cython; import matplotlib; import IPython. [docs]def version_table(verbose=False):; """"""; Print an HTML-formatted table with version numbers for QuTiP and its; dependencies. Use it in a IPython notebook to show which versions of; different packages that were used to run the notebook. This should make it; possible to reproduce the environment and the calculation later on. Returns; --------; version_table: string; Return an HTML-formatted string containing version information for; QuTiP dependencies. """""". html = ""<table>""; html += ""<tr><th>Software</th><th>Version</th></tr>"". packages = [(""QuTiP"", qutip.__version__),; (""Numpy"", numpy.__version__),; (""SciPy"", scipy.__version__),; (""matplotlib"", matplotlib.__version__),; (""Cython"", Cython.__version__),; (""Number of CPUs"", available_cpu_count()),; (""BLAS Info"", _blas_info()),; (""IPython"", IPython.__version__),; (""Python"", sys.version),; (""OS"", ""%s [%s]"" % (os.name, sys.platform)); ]. for name, version in packages:; html += ""<tr><td>%s</td><td>%s</td></tr>"" % (name, version). if verbose:; html += ""<tr><th colspan='2'>Additional information</th></t",MatchSource.WIKI,docs/4.7/modules/qutip/ipynbtools.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/ipynbtools.html
https://qutip.org/docs/4.7/modules/qutip/ipynbtools.html:1912,Integrability,depend,dependencies,1912,"l__ = ['version_table', 'plot_animation', 'HTMLProgressBar']; else:; try:; from IPython.parallel import Client; __all__ = ['version_table', 'parfor', 'plot_animation',; 'parallel_map', 'HTMLProgressBar']; except:; __all__ = ['version_table', 'plot_animation', 'HTMLProgressBar']. from IPython.display import HTML, Javascript, display. import matplotlib.pyplot as plt; from matplotlib import animation; from base64 import b64encode. import datetime; import uuid; import sys; import os; import time; import inspect. import qutip; import numpy; import scipy; import Cython; import matplotlib; import IPython. [docs]def version_table(verbose=False):; """"""; Print an HTML-formatted table with version numbers for QuTiP and its; dependencies. Use it in a IPython notebook to show which versions of; different packages that were used to run the notebook. This should make it; possible to reproduce the environment and the calculation later on. Returns; --------; version_table: string; Return an HTML-formatted string containing version information for; QuTiP dependencies. """""". html = ""<table>""; html += ""<tr><th>Software</th><th>Version</th></tr>"". packages = [(""QuTiP"", qutip.__version__),; (""Numpy"", numpy.__version__),; (""SciPy"", scipy.__version__),; (""matplotlib"", matplotlib.__version__),; (""Cython"", Cython.__version__),; (""Number of CPUs"", available_cpu_count()),; (""BLAS Info"", _blas_info()),; (""IPython"", IPython.__version__),; (""Python"", sys.version),; (""OS"", ""%s [%s]"" % (os.name, sys.platform)); ]. for name, version in packages:; html += ""<tr><td>%s</td><td>%s</td></tr>"" % (name, version). if verbose:; html += ""<tr><th colspan='2'>Additional information</th></tr>""; qutip_install_path = os.path.dirname(inspect.getsourcefile(qutip)); html += (""<tr><td>Installation path</td><td>%s</td></tr>"" %; qutip_install_path); try:; import getpass; html += (""<tr><td>User</td><td>%s</td></tr>"" %; getpass.getuser()); except:; pass. html += ""<tr><td colspan='2'>%s</td></tr>"" % time.strftime(; '%a %b %d",MatchSource.WIKI,docs/4.7/modules/qutip/ipynbtools.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/ipynbtools.html
https://qutip.org/docs/4.7/modules/qutip/ipynbtools.html:5579,Performance,load,load-balanced,5579,"rray(metadata); fig, ax = plt.subplots(figsize=(10, res.shape[1])). yticks = []; yticklabels = []; tmin = min(res[:, 1]); for n, pid in enumerate(numpy.unique(res[:, 0])):; yticks.append(n); yticklabels.append(""%d"" % pid); for m in numpy.where(res[:, 0] == pid)[0]:; ax.add_patch(plt.Rectangle((res[m, 1] - tmin, n - 0.25),; res[m, 2] - res[m, 1], 0.5, color=""green"", alpha=0.5)). ax.set_ylim(-.5, n + .5); ax.set_xlim(0, max(res[:, 2]) - tmin + 0.); ax.set_yticks(yticks); ax.set_yticklabels(yticklabels); ax.set_ylabel(""Engine""); ax.set_xlabel(""seconds""); ax.set_title(""Task schedule""). [docs]def parfor(task, task_vec, args=None, client=None, view=None,; show_scheduling=False, show_progressbar=False):; """"""; Call the function ``tast`` for each value in ``task_vec`` using a cluster; of IPython engines. The function ``task`` should have the signature; ``task(value, args)`` or ``task(value)`` if ``args=None``. The ``client`` and ``view`` are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are ``None``, new instances will be created. Parameters; ----------. task: a Python function; The function that is to be called for each value in ``task_vec``. task_vec: array / list; The list or array of values for which the ``task`` function is to be; evaluated. args: list / dictionary; The optional additional argument to the ``task`` function. For example; a dictionary with parameter values. client: IPython.parallel.Client; The IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client view; The view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default False; Display a graph showing how the tasks (the evaluation of ``task`` for; for the value in ``task_vec1``) was scheduled on",MatchSource.WIKI,docs/4.7/modules/qutip/ipynbtools.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/ipynbtools.html
https://qutip.org/docs/4.7/modules/qutip/ipynbtools.html:6291,Performance,load,load-balanced,6291,"all the function ``tast`` for each value in ``task_vec`` using a cluster; of IPython engines. The function ``task`` should have the signature; ``task(value, args)`` or ``task(value)`` if ``args=None``. The ``client`` and ``view`` are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are ``None``, new instances will be created. Parameters; ----------. task: a Python function; The function that is to be called for each value in ``task_vec``. task_vec: array / list; The list or array of values for which the ``task`` function is to be; evaluated. args: list / dictionary; The optional additional argument to the ``task`` function. For example; a dictionary with parameter values. client: IPython.parallel.Client; The IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client view; The view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default False; Display a graph showing how the tasks (the evaluation of ``task`` for; for the value in ``task_vec1``) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default False; Display a HTML-based progress bar duing the execution of the parfor; loop. Returns; --------; result : list; The result list contains the value of ``task(value, args)`` for each; value in ``task_vec``, that is, it should be equivalent to; ``[task(v, args) for v in task_vec]``.; """""". if show_progressbar:; progress_bar = HTMLProgressBar(); else:; progress_bar = None. return parallel_map(task, task_vec, task_args=args,; client=client, view=view, progress_bar=progress_bar,; show_scheduling=show_scheduling). [docs]def parallel_map(task, values, task_args=None, task_kwargs=None,; client=None, view=None, progress_bar=None,; show_",MatchSource.WIKI,docs/4.7/modules/qutip/ipynbtools.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/ipynbtools.html
https://qutip.org/docs/4.7/modules/qutip/ipynbtools.html:7588,Performance,load,load-balanced,7588,"hon engine; cluster. show_progressbar: bool {False, True}, default False; Display a HTML-based progress bar duing the execution of the parfor; loop. Returns; --------; result : list; The result list contains the value of ``task(value, args)`` for each; value in ``task_vec``, that is, it should be equivalent to; ``[task(v, args) for v in task_vec]``.; """""". if show_progressbar:; progress_bar = HTMLProgressBar(); else:; progress_bar = None. return parallel_map(task, task_vec, task_args=args,; client=client, view=view, progress_bar=progress_bar,; show_scheduling=show_scheduling). [docs]def parallel_map(task, values, task_args=None, task_kwargs=None,; client=None, view=None, progress_bar=None,; show_scheduling=False, **kwargs):; """"""; Call the function ``task`` for each value in ``values`` using a cluster; of IPython engines. The function ``task`` should have the signature; ``task(value, *args, **kwargs)``. The ``client`` and ``view`` are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are ``None``, new instances will be created. Parameters; ----------. task: a Python function; The function that is to be called for each value in ``task_vec``. values: array / list; The list or array of values for which the ``task`` function is to be; evaluated. task_args: list / dictionary; The optional additional argument to the ``task`` function. task_kwargs: list / dictionary; The optional additional keyword argument to the ``task`` function. client: IPython.parallel.Client; The IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client view; The view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default False; Display a graph showing how the tasks (the evaluation of ``task`` ",MatchSource.WIKI,docs/4.7/modules/qutip/ipynbtools.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/ipynbtools.html
https://qutip.org/docs/4.7/modules/qutip/ipynbtools.html:8353,Performance,load,load-balanced,8353,"for each value in ``values`` using a cluster; of IPython engines. The function ``task`` should have the signature; ``task(value, *args, **kwargs)``. The ``client`` and ``view`` are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are ``None``, new instances will be created. Parameters; ----------. task: a Python function; The function that is to be called for each value in ``task_vec``. values: array / list; The list or array of values for which the ``task`` function is to be; evaluated. task_args: list / dictionary; The optional additional argument to the ``task`` function. task_kwargs: list / dictionary; The optional additional keyword argument to the ``task`` function. client: IPython.parallel.Client; The IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client view; The view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default False; Display a graph showing how the tasks (the evaluation of ``task`` for; for the value in ``task_vec1``) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default False; Display a HTML-based progress bar during the execution of the parfor; loop. Returns; --------; result : list; The result list contains the value of; ``task(value, task_args, task_kwargs)`` for each; value in ``values``. """"""; submitted = datetime.datetime.now(). if task_args is None:; task_args = tuple(). if task_kwargs is None:; task_kwargs = {}. if client is None:; client = Client(). # make sure qutip is available at engines; dview = client[:]; dview.block = True; dview.execute(""from qutip import *""). if view is None:; view = client.load_balanced_view(). ar_list = [view.apply_async(task, value, *task_args, **task_kwargs);",MatchSource.WIKI,docs/4.7/modules/qutip/ipynbtools.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/ipynbtools.html
https://qutip.org/docs/4.7/modules/qutip/ipynbtools.html:9670,Safety,timeout,timeout,9670,"ython engine; cluster. show_progressbar: bool {False, True}, default False; Display a HTML-based progress bar during the execution of the parfor; loop. Returns; --------; result : list; The result list contains the value of; ``task(value, task_args, task_kwargs)`` for each; value in ``values``. """"""; submitted = datetime.datetime.now(). if task_args is None:; task_args = tuple(). if task_kwargs is None:; task_kwargs = {}. if client is None:; client = Client(). # make sure qutip is available at engines; dview = client[:]; dview.block = True; dview.execute(""from qutip import *""). if view is None:; view = client.load_balanced_view(). ar_list = [view.apply_async(task, value, *task_args, **task_kwargs); for value in values]. if progress_bar is None:; view.wait(ar_list); else:; if progress_bar is True:; progress_bar = HTMLProgressBar(). n = len(ar_list); progress_bar.start(n); while True:; n_finished = sum([ar.progress for ar in ar_list]); progress_bar.update(n_finished). if view.wait(ar_list, timeout=0.5):; progress_bar.update(n); break; progress_bar.finished(). if show_scheduling:; metadata = [[ar.engine_id,; (ar.started - submitted).total_seconds(),; (ar.completed - submitted).total_seconds()]; for ar in ar_list]; _visualize_parfor_data(metadata). return [ar.get() for ar in ar_list]. def plot_animation(plot_setup_func, plot_func, result, name=""movie"",; writer=""avconv"", codec=""libx264"", verbose=False):; """"""; Create an animated plot of a Result object, as returned by one of; the qutip evolution solvers. .. note :: experimental; """""". fig, axes = plot_setup_func(result). def update(n):; return plot_func(result, n, fig=fig, axes=axes). anim = animation.FuncAnimation(; fig, update, frames=len(result.times), blit=True). anim.save(name + '.mp4', fps=10, writer=writer, codec=codec). plt.close(fig). if verbose:; print(""Created %s.m4v"" % name). video = open(name + '.mp4', ""rb"").read(); video_encoded = b64encode(video).decode(""ascii""); video_tag = '<video controls src=""data:video/x",MatchSource.WIKI,docs/4.7/modules/qutip/ipynbtools.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/ipynbtools.html
https://qutip.org/docs/4.7/modules/qutip/ipynbtools.html:2966,Usability,simpl,simple,2966,"tware</th><th>Version</th></tr>"". packages = [(""QuTiP"", qutip.__version__),; (""Numpy"", numpy.__version__),; (""SciPy"", scipy.__version__),; (""matplotlib"", matplotlib.__version__),; (""Cython"", Cython.__version__),; (""Number of CPUs"", available_cpu_count()),; (""BLAS Info"", _blas_info()),; (""IPython"", IPython.__version__),; (""Python"", sys.version),; (""OS"", ""%s [%s]"" % (os.name, sys.platform)); ]. for name, version in packages:; html += ""<tr><td>%s</td><td>%s</td></tr>"" % (name, version). if verbose:; html += ""<tr><th colspan='2'>Additional information</th></tr>""; qutip_install_path = os.path.dirname(inspect.getsourcefile(qutip)); html += (""<tr><td>Installation path</td><td>%s</td></tr>"" %; qutip_install_path); try:; import getpass; html += (""<tr><td>User</td><td>%s</td></tr>"" %; getpass.getuser()); except:; pass. html += ""<tr><td colspan='2'>%s</td></tr>"" % time.strftime(; '%a %b %d %H:%M:%S %Y %Z'); html += ""</table>"". return HTML(html). class HTMLProgressBar(BaseProgressBar):; """"""; A simple HTML progress bar for using in IPython notebooks. Based on; IPython ProgressBar demo notebook:; https://github.com/ipython/ipython/tree/master/examples/notebooks. Example usage:. n_vec = linspace(0, 10, 100); pbar = HTMLProgressBar(len(n_vec)); for n in n_vec:; pbar.update(n); compute_with_n(n); """""". def __init__(self, iterations=0, chunk_size=1.0):; self.divid = str(uuid.uuid4()); self.textid = str(uuid.uuid4()); self.pb = HTML(""""""\; <div style=""border: 2px solid grey; width: 600px"">; <div id=""%s"" \; style=""background-color: rgba(121,195,106,0.75); width:0%%"">&nbsp;</div>; </div>; <p id=""%s""></p>; """""" % (self.divid, self.textid)); display(self.pb); super(HTMLProgressBar, self).start(iterations, chunk_size). def start(self, iterations=0, chunk_size=1.0):; super(HTMLProgressBar, self).start(iterations, chunk_size). def update(self, n):; p = (n / self.N) * 100.0; if p >= self.p_chunk:; lbl = (""Elapsed time: %s. "" % self.time_elapsed() +; ""Est. remaining time: %s."" % self.time_remainin",MatchSource.WIKI,docs/4.7/modules/qutip/ipynbtools.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/ipynbtools.html
https://qutip.org/docs/4.7/modules/qutip/ipynbtools.html:2978,Usability,progress bar,progress bar,2978,"tware</th><th>Version</th></tr>"". packages = [(""QuTiP"", qutip.__version__),; (""Numpy"", numpy.__version__),; (""SciPy"", scipy.__version__),; (""matplotlib"", matplotlib.__version__),; (""Cython"", Cython.__version__),; (""Number of CPUs"", available_cpu_count()),; (""BLAS Info"", _blas_info()),; (""IPython"", IPython.__version__),; (""Python"", sys.version),; (""OS"", ""%s [%s]"" % (os.name, sys.platform)); ]. for name, version in packages:; html += ""<tr><td>%s</td><td>%s</td></tr>"" % (name, version). if verbose:; html += ""<tr><th colspan='2'>Additional information</th></tr>""; qutip_install_path = os.path.dirname(inspect.getsourcefile(qutip)); html += (""<tr><td>Installation path</td><td>%s</td></tr>"" %; qutip_install_path); try:; import getpass; html += (""<tr><td>User</td><td>%s</td></tr>"" %; getpass.getuser()); except:; pass. html += ""<tr><td colspan='2'>%s</td></tr>"" % time.strftime(; '%a %b %d %H:%M:%S %Y %Z'); html += ""</table>"". return HTML(html). class HTMLProgressBar(BaseProgressBar):; """"""; A simple HTML progress bar for using in IPython notebooks. Based on; IPython ProgressBar demo notebook:; https://github.com/ipython/ipython/tree/master/examples/notebooks. Example usage:. n_vec = linspace(0, 10, 100); pbar = HTMLProgressBar(len(n_vec)); for n in n_vec:; pbar.update(n); compute_with_n(n); """""". def __init__(self, iterations=0, chunk_size=1.0):; self.divid = str(uuid.uuid4()); self.textid = str(uuid.uuid4()); self.pb = HTML(""""""\; <div style=""border: 2px solid grey; width: 600px"">; <div id=""%s"" \; style=""background-color: rgba(121,195,106,0.75); width:0%%"">&nbsp;</div>; </div>; <p id=""%s""></p>; """""" % (self.divid, self.textid)); display(self.pb); super(HTMLProgressBar, self).start(iterations, chunk_size). def start(self, iterations=0, chunk_size=1.0):; super(HTMLProgressBar, self).start(iterations, chunk_size). def update(self, n):; p = (n / self.N) * 100.0; if p >= self.p_chunk:; lbl = (""Elapsed time: %s. "" % self.time_elapsed() +; ""Est. remaining time: %s."" % self.time_remainin",MatchSource.WIKI,docs/4.7/modules/qutip/ipynbtools.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/ipynbtools.html
https://qutip.org/docs/4.7/modules/qutip/ipynbtools.html:6703,Usability,progress bar,progress bar,6703,"ed. Parameters; ----------. task: a Python function; The function that is to be called for each value in ``task_vec``. task_vec: array / list; The list or array of values for which the ``task`` function is to be; evaluated. args: list / dictionary; The optional additional argument to the ``task`` function. For example; a dictionary with parameter values. client: IPython.parallel.Client; The IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client view; The view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default False; Display a graph showing how the tasks (the evaluation of ``task`` for; for the value in ``task_vec1``) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default False; Display a HTML-based progress bar duing the execution of the parfor; loop. Returns; --------; result : list; The result list contains the value of ``task(value, args)`` for each; value in ``task_vec``, that is, it should be equivalent to; ``[task(v, args) for v in task_vec]``.; """""". if show_progressbar:; progress_bar = HTMLProgressBar(); else:; progress_bar = None. return parallel_map(task, task_vec, task_args=args,; client=client, view=view, progress_bar=progress_bar,; show_scheduling=show_scheduling). [docs]def parallel_map(task, values, task_args=None, task_kwargs=None,; client=None, view=None, progress_bar=None,; show_scheduling=False, **kwargs):; """"""; Call the function ``task`` for each value in ``values`` using a cluster; of IPython engines. The function ``task`` should have the signature; ``task(value, *args, **kwargs)``. The ``client`` and ``view`` are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are ``None``, new instances will",MatchSource.WIKI,docs/4.7/modules/qutip/ipynbtools.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/ipynbtools.html
https://qutip.org/docs/4.7/modules/qutip/ipynbtools.html:8765,Usability,progress bar,progress bar,8765,"The function that is to be called for each value in ``task_vec``. values: array / list; The list or array of values for which the ``task`` function is to be; evaluated. task_args: list / dictionary; The optional additional argument to the ``task`` function. task_kwargs: list / dictionary; The optional additional keyword argument to the ``task`` function. client: IPython.parallel.Client; The IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client view; The view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default False; Display a graph showing how the tasks (the evaluation of ``task`` for; for the value in ``task_vec1``) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default False; Display a HTML-based progress bar during the execution of the parfor; loop. Returns; --------; result : list; The result list contains the value of; ``task(value, task_args, task_kwargs)`` for each; value in ``values``. """"""; submitted = datetime.datetime.now(). if task_args is None:; task_args = tuple(). if task_kwargs is None:; task_kwargs = {}. if client is None:; client = Client(). # make sure qutip is available at engines; dview = client[:]; dview.block = True; dview.execute(""from qutip import *""). if view is None:; view = client.load_balanced_view(). ar_list = [view.apply_async(task, value, *task_args, **task_kwargs); for value in values]. if progress_bar is None:; view.wait(ar_list); else:; if progress_bar is True:; progress_bar = HTMLProgressBar(). n = len(ar_list); progress_bar.start(n); while True:; n_finished = sum([ar.progress for ar in ar_list]); progress_bar.update(n_finished). if view.wait(ar_list, timeout=0.5):; progress_bar.update(n); break; progress_bar.finished(). if show_schedu",MatchSource.WIKI,docs/4.7/modules/qutip/ipynbtools.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/ipynbtools.html
https://qutip.org/docs/4.7/modules/qutip/krylovsolve.html:2334,Availability,error,error,2334,"tion values of; supplied operators (""e_ops"") at arbitrary points at (""tlist""). **Additional options**. Additional options to krylovsolve can be set with the following:. * ""store_states"": stores states even though expectation values are; requested via the ""e_ops"" argument. * ""store_final_state"": store final state even though expectation values are; requested via the ""e_ops"" argument. Parameters; ----------; H : :class:`qutip.Qobj`; System Hamiltonian.; psi0 : :class: `qutip.Qobj`; Initial state vector (ket).; tlist : None / *list* / *array*; List of times on which to evolve the initial state. If None, nothing; happens but the code won't break.; krylov_dim: int; Dimension of Krylov approximation subspaces used for the time; evolution approximation.; e_ops : None / list of :class:`qutip.Qobj`; Single operator or list of operators for which to evaluate; expectation values.; options : Options; Instance of ODE solver options, as well as krylov parameters.; atol: controls (approximately) the error desired for the final; solution. (Defaults to 1e-8); nsteps: maximum number of krylov's internal number of Lanczos; iterations. (Defaults to 10000); progress_bar : None / BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation.; sparse : bool (default False); Use np.array to represent system Hamiltonians. If True, scipy sparse; arrays are used instead. Returns; -------; result: :class:`qutip.solver.Result`; An instance of the class :class:`qutip.solver.Result`, which contains; either an *array* `result.expect` of expectation values for the times; `tlist`, or an *array* `result.states` of state vectors corresponding; to the times `tlist` [if `e_ops` is an empty list].; """"""; # check the physics; _check_inputs(H, psi0, krylov_dim). # check extra inputs; e_ops, e_ops_dict = _check_e_ops(e_ops); pbar = _check_progress_bar(progress_bar). # transform inputs type from Qobj to np.ndarray/csr_matrix; if sparse:; _H = H.get_da",MatchSource.WIKI,docs/4.7/modules/qutip/krylovsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/krylovsolve.html
https://qutip.org/docs/4.7/modules/qutip/krylovsolve.html:14883,Availability,toler,tolerance,14883,"m if a happy breakdown of an eigenstate occurs.; """"""; for i in range(1, len(tlist)):; if options.store_states:; res.states.append(psi0); if expt_callback:; res.expect.append(e_0). for m in range(n_expt_op):; op = e_ops[m]; res.expect[m][i] = e_m_0[m]; return res. def _optimize_lanczos_timestep_size(T, krylov_basis, tlist, options):; """"""; Solves the equation defined to optimize the number of Lanczos; iterations to be performed inside Krylov's algorithm.; """""". f = _lanczos_error_equation_to_optimize_delta_t(; T,; krylov_basis=krylov_basis,; t0=tlist[0],; tf=tlist[-1],; target_tolerance=options.atol,; ). # To avoid the singularity at t0, we add a small epsilon value; t_min = (tlist[-1] - tlist[0]) / options.nsteps + tlist[0]; bracket = [t_min, tlist[-1]]. if (np.sign(f(bracket[0])) == -1) and (np.sign(f(bracket[-1])) == -1):; delta_t = tlist[-1] - tlist[0]; return delta_t. elif (np.sign(f(bracket[0])) == 1) and (np.sign(f(bracket[-1])) == 1):; raise ValueError(; ""No solution exists with the given combination of parameters 'krylov_dim', ""; ""tolerance = 'options.atol', maximum number allowed of krylov internal ""; ""partitions = 'options.nsteps' and 'tlist'. Try reducing the tolerance, or ""; ""increasing 'krylov_dim'. If nothing works, then a deeper analysis of the ""; ""problem is recommended.""; ). else:; sol = root_scalar(f=f, bracket=bracket, method=""brentq"", xtol=options.atol); if sol.converged:; delta_t = sol.root; return delta_t; else:; raise Exception(; ""Method did not converge, try increasing 'krylov_dim', ""; ""taking a lesser final time 'tlist[-1]' or decreasing the ""; ""tolerance via Options().atol. ""; ""If nothing works, this problem might not be suitable for ""; ""Krylov or a deeper analysis might be required.""; ). def _lanczos_error_equation_to_optimize_delta_t(; T, krylov_basis, t0, tf, target_tolerance; ):; """"""; Function to optimize in order to obtain the optimal number of; Lanczos algorithm iterations, governed by the optimal timestep size between; Lanczos iteracti",MatchSource.WIKI,docs/4.7/modules/qutip/krylovsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/krylovsolve.html
https://qutip.org/docs/4.7/modules/qutip/krylovsolve.html:15017,Availability,toler,tolerance,15017,"pt_op):; op = e_ops[m]; res.expect[m][i] = e_m_0[m]; return res. def _optimize_lanczos_timestep_size(T, krylov_basis, tlist, options):; """"""; Solves the equation defined to optimize the number of Lanczos; iterations to be performed inside Krylov's algorithm.; """""". f = _lanczos_error_equation_to_optimize_delta_t(; T,; krylov_basis=krylov_basis,; t0=tlist[0],; tf=tlist[-1],; target_tolerance=options.atol,; ). # To avoid the singularity at t0, we add a small epsilon value; t_min = (tlist[-1] - tlist[0]) / options.nsteps + tlist[0]; bracket = [t_min, tlist[-1]]. if (np.sign(f(bracket[0])) == -1) and (np.sign(f(bracket[-1])) == -1):; delta_t = tlist[-1] - tlist[0]; return delta_t. elif (np.sign(f(bracket[0])) == 1) and (np.sign(f(bracket[-1])) == 1):; raise ValueError(; ""No solution exists with the given combination of parameters 'krylov_dim', ""; ""tolerance = 'options.atol', maximum number allowed of krylov internal ""; ""partitions = 'options.nsteps' and 'tlist'. Try reducing the tolerance, or ""; ""increasing 'krylov_dim'. If nothing works, then a deeper analysis of the ""; ""problem is recommended.""; ). else:; sol = root_scalar(f=f, bracket=bracket, method=""brentq"", xtol=options.atol); if sol.converged:; delta_t = sol.root; return delta_t; else:; raise Exception(; ""Method did not converge, try increasing 'krylov_dim', ""; ""taking a lesser final time 'tlist[-1]' or decreasing the ""; ""tolerance via Options().atol. ""; ""If nothing works, this problem might not be suitable for ""; ""Krylov or a deeper analysis might be required.""; ). def _lanczos_error_equation_to_optimize_delta_t(; T, krylov_basis, t0, tf, target_tolerance; ):; """"""; Function to optimize in order to obtain the optimal number of; Lanczos algorithm iterations, governed by the optimal timestep size between; Lanczos iteractions.; """"""; eigenvalues1, eigenvectors1 = eigh(T[0:, 0:]); U1 = np.matmul(krylov_basis[0:, 0:].T, eigenvectors1); e01 = eigenvectors1.conj().T[:, 0]. eigenvalues2, eigenvectors2 = eigh(T[0:-1, 0: T.sh",MatchSource.WIKI,docs/4.7/modules/qutip/krylovsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/krylovsolve.html
https://qutip.org/docs/4.7/modules/qutip/krylovsolve.html:15425,Availability,toler,tolerance,15425,"_basis=krylov_basis,; t0=tlist[0],; tf=tlist[-1],; target_tolerance=options.atol,; ). # To avoid the singularity at t0, we add a small epsilon value; t_min = (tlist[-1] - tlist[0]) / options.nsteps + tlist[0]; bracket = [t_min, tlist[-1]]. if (np.sign(f(bracket[0])) == -1) and (np.sign(f(bracket[-1])) == -1):; delta_t = tlist[-1] - tlist[0]; return delta_t. elif (np.sign(f(bracket[0])) == 1) and (np.sign(f(bracket[-1])) == 1):; raise ValueError(; ""No solution exists with the given combination of parameters 'krylov_dim', ""; ""tolerance = 'options.atol', maximum number allowed of krylov internal ""; ""partitions = 'options.nsteps' and 'tlist'. Try reducing the tolerance, or ""; ""increasing 'krylov_dim'. If nothing works, then a deeper analysis of the ""; ""problem is recommended.""; ). else:; sol = root_scalar(f=f, bracket=bracket, method=""brentq"", xtol=options.atol); if sol.converged:; delta_t = sol.root; return delta_t; else:; raise Exception(; ""Method did not converge, try increasing 'krylov_dim', ""; ""taking a lesser final time 'tlist[-1]' or decreasing the ""; ""tolerance via Options().atol. ""; ""If nothing works, this problem might not be suitable for ""; ""Krylov or a deeper analysis might be required.""; ). def _lanczos_error_equation_to_optimize_delta_t(; T, krylov_basis, t0, tf, target_tolerance; ):; """"""; Function to optimize in order to obtain the optimal number of; Lanczos algorithm iterations, governed by the optimal timestep size between; Lanczos iteractions.; """"""; eigenvalues1, eigenvectors1 = eigh(T[0:, 0:]); U1 = np.matmul(krylov_basis[0:, 0:].T, eigenvectors1); e01 = eigenvectors1.conj().T[:, 0]. eigenvalues2, eigenvectors2 = eigh(T[0:-1, 0: T.shape[1] - 1]); U2 = np.matmul(krylov_basis[0:-1, :].T, eigenvectors2); e02 = eigenvectors2.conj().T[:, 0]. def f(t):; delta_t = -1j * (t - t0). aux1 = np.multiply(np.exp(delta_t * eigenvalues1), e01); psi1 = np.matmul(U1, aux1). aux2 = np.multiply(np.exp(delta_t * eigenvalues2), e02); psi2 = np.matmul(U2, aux2). error = np.l",MatchSource.WIKI,docs/4.7/modules/qutip/krylovsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/krylovsolve.html
https://qutip.org/docs/4.7/modules/qutip/krylovsolve.html:16342,Availability,error,error,16342,"krylov_dim', ""; ""taking a lesser final time 'tlist[-1]' or decreasing the ""; ""tolerance via Options().atol. ""; ""If nothing works, this problem might not be suitable for ""; ""Krylov or a deeper analysis might be required.""; ). def _lanczos_error_equation_to_optimize_delta_t(; T, krylov_basis, t0, tf, target_tolerance; ):; """"""; Function to optimize in order to obtain the optimal number of; Lanczos algorithm iterations, governed by the optimal timestep size between; Lanczos iteractions.; """"""; eigenvalues1, eigenvectors1 = eigh(T[0:, 0:]); U1 = np.matmul(krylov_basis[0:, 0:].T, eigenvectors1); e01 = eigenvectors1.conj().T[:, 0]. eigenvalues2, eigenvectors2 = eigh(T[0:-1, 0: T.shape[1] - 1]); U2 = np.matmul(krylov_basis[0:-1, :].T, eigenvectors2); e02 = eigenvectors2.conj().T[:, 0]. def f(t):; delta_t = -1j * (t - t0). aux1 = np.multiply(np.exp(delta_t * eigenvalues1), e01); psi1 = np.matmul(U1, aux1). aux2 = np.multiply(np.exp(delta_t * eigenvalues2), e02); psi2 = np.matmul(U2, aux2). error = np.linalg.norm(psi1 - psi2). steps = max(1, (tf - t0) // (t - t0)); return np.log10(error) + np.log10(steps) - np.log10(target_tolerance). return f. def _make_partitions(tlist, n_timesteps):; """"""Generates an internal 'partitions' list of np.arrays to iterate Lanczos; algorithms on each of them, based on 'tlist' and the optimized number of; iterations 'n_timesteps'.; """""". _tlist = np.copy(tlist). if n_timesteps == 1:; _tlist = np.insert(_tlist, 0, tlist[0]); _tlist = np.append(_tlist, tlist[-1]); partitions = [_tlist]; return partitions. n_timesteps += 1; krylov_tlist = np.linspace(tlist[0], tlist[-1], n_timesteps); krylov_partitions = [; np.array(krylov_tlist[i: i + 2]) for i in range(n_timesteps - 1); ]; partitions = []; for krylov_partition in krylov_partitions:; start = krylov_partition[0]; end = krylov_partition[-1]; condition = _tlist <= end; partitions.append([start] + _tlist[condition].tolist() + [end]); _tlist = _tlist[~condition]. return partitions. def _e_ops_outputs(krylo",MatchSource.WIKI,docs/4.7/modules/qutip/krylovsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/krylovsolve.html
https://qutip.org/docs/4.7/modules/qutip/krylovsolve.html:16434,Availability,error,error,16434,"a Options().atol. ""; ""If nothing works, this problem might not be suitable for ""; ""Krylov or a deeper analysis might be required.""; ). def _lanczos_error_equation_to_optimize_delta_t(; T, krylov_basis, t0, tf, target_tolerance; ):; """"""; Function to optimize in order to obtain the optimal number of; Lanczos algorithm iterations, governed by the optimal timestep size between; Lanczos iteractions.; """"""; eigenvalues1, eigenvectors1 = eigh(T[0:, 0:]); U1 = np.matmul(krylov_basis[0:, 0:].T, eigenvectors1); e01 = eigenvectors1.conj().T[:, 0]. eigenvalues2, eigenvectors2 = eigh(T[0:-1, 0: T.shape[1] - 1]); U2 = np.matmul(krylov_basis[0:-1, :].T, eigenvectors2); e02 = eigenvectors2.conj().T[:, 0]. def f(t):; delta_t = -1j * (t - t0). aux1 = np.multiply(np.exp(delta_t * eigenvalues1), e01); psi1 = np.matmul(U1, aux1). aux2 = np.multiply(np.exp(delta_t * eigenvalues2), e02); psi2 = np.matmul(U2, aux2). error = np.linalg.norm(psi1 - psi2). steps = max(1, (tf - t0) // (t - t0)); return np.log10(error) + np.log10(steps) - np.log10(target_tolerance). return f. def _make_partitions(tlist, n_timesteps):; """"""Generates an internal 'partitions' list of np.arrays to iterate Lanczos; algorithms on each of them, based on 'tlist' and the optimized number of; iterations 'n_timesteps'.; """""". _tlist = np.copy(tlist). if n_timesteps == 1:; _tlist = np.insert(_tlist, 0, tlist[0]); _tlist = np.append(_tlist, tlist[-1]); partitions = [_tlist]; return partitions. n_timesteps += 1; krylov_tlist = np.linspace(tlist[0], tlist[-1], n_timesteps); krylov_partitions = [; np.array(krylov_tlist[i: i + 2]) for i in range(n_timesteps - 1); ]; partitions = []; for krylov_partition in krylov_partitions:; start = krylov_partition[0]; end = krylov_partition[-1]; condition = _tlist <= end; partitions.append([start] + _tlist[condition].tolist() + [end]); _tlist = _tlist[~condition]. return partitions. def _e_ops_outputs(krylov_results, e_ops, n_tlist_steps, opt):; krylov_results.expect = []; if callable(e_ops):; n",MatchSource.WIKI,docs/4.7/modules/qutip/krylovsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/krylovsolve.html
https://qutip.org/docs/4.7/modules/qutip/krylovsolve.html:5319,Deployability,update,update,5319,"; # symmetry of H subspace. Thus, theres no work to be done.; krylov_results = particular_tlist_or_happy_breakdown(; tlist,; n_tlist_steps,; options,; psi0,; e_ops,; krylov_results,; pbar,; happy_breakdown=True,; ); return krylov_results; else:; # no optimization is required, convergence is guaranteed.; delta_t = tf - t0; n_timesteps = 1; else:. # calculate optimal number of internal timesteps.; delta_t = _optimize_lanczos_timestep_size(; T_m, krylov_basis=krylov_basis, tlist=tlist, options=options; ); n_timesteps = int(ceil((tf - t0) / delta_t)). if n_timesteps >= options.nsteps:; raise Exception(; f""Optimization requires a number {n_timesteps} of lanczos iterations, ""; f""which exceeds the defined allowed number {options.nsteps}. This can ""; ""be increased via the 'Options.nsteps' property.""; ). partitions = _make_partitions(tlist=tlist, n_timesteps=n_timesteps). if progress_bar:; pbar.start(len(partitions)). # update parameters regarding e_ops; krylov_results, expt_callback, options, n_expt_op = _e_ops_outputs(; krylov_results, e_ops, n_tlist_steps, options; ). # parameters for the lazy iteration evolve tlist; psi_norm = np.linalg.norm(_psi); last_t = t0. for idx, partition in enumerate(partitions):. evolved_states = _evolve_krylov_tlist(; H=_H,; psi0=_psi,; krylov_dim=dim_m,; tlist=partition,; t0=last_t,; psi_norm=psi_norm,; krylov_basis=krylov_basis,; T_m=T_m,; sparse=sparse,; ). if idx == 0:; krylov_basis = None; T_m = None; t_idx = 0. _psi = evolved_states[-1]; psi_norm = np.linalg.norm(_psi); last_t = partition[-1]. # apply qobj to each evolved state, remove repeated tail elements; qobj_evolved_states = [; Qobj(state, dims=psi0.dims) for state in evolved_states[1:-1]; ]. krylov_results = _expectation_values(; e_ops,; n_expt_op,; expt_callback,; krylov_results,; qobj_evolved_states,; partitions,; idx,; t_idx,; options,; ). t_idx += len(partition[1:-1]). pbar.update(idx). pbar.finished(). if e_ops_dict:; krylov_results.expect = {; e: krylov_results.expect[n]; fo",MatchSource.WIKI,docs/4.7/modules/qutip/krylovsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/krylovsolve.html
https://qutip.org/docs/4.7/modules/qutip/krylovsolve.html:6290,Deployability,update,update,6290,"rt(len(partitions)). # update parameters regarding e_ops; krylov_results, expt_callback, options, n_expt_op = _e_ops_outputs(; krylov_results, e_ops, n_tlist_steps, options; ). # parameters for the lazy iteration evolve tlist; psi_norm = np.linalg.norm(_psi); last_t = t0. for idx, partition in enumerate(partitions):. evolved_states = _evolve_krylov_tlist(; H=_H,; psi0=_psi,; krylov_dim=dim_m,; tlist=partition,; t0=last_t,; psi_norm=psi_norm,; krylov_basis=krylov_basis,; T_m=T_m,; sparse=sparse,; ). if idx == 0:; krylov_basis = None; T_m = None; t_idx = 0. _psi = evolved_states[-1]; psi_norm = np.linalg.norm(_psi); last_t = partition[-1]. # apply qobj to each evolved state, remove repeated tail elements; qobj_evolved_states = [; Qobj(state, dims=psi0.dims) for state in evolved_states[1:-1]; ]. krylov_results = _expectation_values(; e_ops,; n_expt_op,; expt_callback,; krylov_results,; qobj_evolved_states,; partitions,; idx,; t_idx,; options,; ). t_idx += len(partition[1:-1]). pbar.update(idx). pbar.finished(). if e_ops_dict:; krylov_results.expect = {; e: krylov_results.expect[n]; for n, e in enumerate(e_ops_dict.keys()); }. return krylov_results. def _expectation_values(; e_ops,; n_expt_op,; expt_callback,; res,; evolved_states,; partitions,; idx,; t_idx,; options,; ):. if options.store_states:; res.states += evolved_states. for t, state in zip(; range(t_idx, t_idx + len(partitions[idx][1:-1])), evolved_states; ):. if expt_callback:; # use callback method; res.expect.append(e_ops(t, state)). for m in range(n_expt_op):; op = e_ops[m]; if not isinstance(op, Qobj) and callable(op):; res.expect[m][t] = op(t, state); continue. res.expect[m][t] = expect(op, state). if (; idx == len(partitions) - 1; and options.store_final_state; and not options.store_states; ):; res.states = [evolved_states[-1]]. return res. def lanczos_algorithm(; H,; psi: np.ndarray,; krylov_dim: int,; sparse: bool = False,; ):; """"""; Computes a basis of the Krylov subspace for Hamiltonian 'H', a system; ",MatchSource.WIKI,docs/4.7/modules/qutip/krylovsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/krylovsolve.html
https://qutip.org/docs/4.7/modules/qutip/krylovsolve.html:13655,Deployability,update,update,13655,"that same ket is returned and evaluated at 'e_ops', if provided.; """""". if len(tlist) == 0:; warnings.warn(; ""Input 'tlist' contains a single element. If 'e_ops' were provided""; "", return its corresponding expectation values at 'psi0', else ""; ""return 'psi0'.""; ). progress_bar.start(1). res, expt_callback, options, n_expt_op = _e_ops_outputs(; res, e_ops, n_tlist_steps, options; ). if options.store_states:; res.states = [psi0]. e_0 = None; if expt_callback:; # use callback method; e_0 = e_ops(0, psi0); res.expect.append(e_0). e_m_0 = []; for m in range(n_expt_op):; op = e_ops[m]. if not isinstance(op, Qobj) and callable(op):; e_m_0.append(op(0, psi0)); res.expect[m][0] = e_m_0[m]; continue. e_m_0.append(expect(op, psi0)); res.expect[m][0] = e_m_0[m]. if happy_breakdown:; res = _happy_breakdown(; tlist,; options,; res,; psi0,; expt_callback,; e_0,; n_expt_op,; e_ops,; e_m_0,; ). if (options.store_final_state) and (not options.store_states):; res.states = [psi0]. progress_bar.update(1); progress_bar.finished(); return res. def _happy_breakdown(; tlist, options, res, psi0, expt_callback, e_0, n_expt_op, e_ops, e_m_0; ):; """"""; Dummy evolves the system if a happy breakdown of an eigenstate occurs.; """"""; for i in range(1, len(tlist)):; if options.store_states:; res.states.append(psi0); if expt_callback:; res.expect.append(e_0). for m in range(n_expt_op):; op = e_ops[m]; res.expect[m][i] = e_m_0[m]; return res. def _optimize_lanczos_timestep_size(T, krylov_basis, tlist, options):; """"""; Solves the equation defined to optimize the number of Lanczos; iterations to be performed inside Krylov's algorithm.; """""". f = _lanczos_error_equation_to_optimize_delta_t(; T,; krylov_basis=krylov_basis,; t0=tlist[0],; tf=tlist[-1],; target_tolerance=options.atol,; ). # To avoid the singularity at t0, we add a small epsilon value; t_min = (tlist[-1] - tlist[0]) / options.nsteps + tlist[0]; bracket = [t_min, tlist[-1]]. if (np.sign(f(bracket[0])) == -1) and (np.sign(f(bracket[-1])) == -1):; de",MatchSource.WIKI,docs/4.7/modules/qutip/krylovsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/krylovsolve.html
https://qutip.org/docs/4.7/modules/qutip/krylovsolve.html:18215,Deployability,update,updated,18215,"i2 = np.matmul(U2, aux2). error = np.linalg.norm(psi1 - psi2). steps = max(1, (tf - t0) // (t - t0)); return np.log10(error) + np.log10(steps) - np.log10(target_tolerance). return f. def _make_partitions(tlist, n_timesteps):; """"""Generates an internal 'partitions' list of np.arrays to iterate Lanczos; algorithms on each of them, based on 'tlist' and the optimized number of; iterations 'n_timesteps'.; """""". _tlist = np.copy(tlist). if n_timesteps == 1:; _tlist = np.insert(_tlist, 0, tlist[0]); _tlist = np.append(_tlist, tlist[-1]); partitions = [_tlist]; return partitions. n_timesteps += 1; krylov_tlist = np.linspace(tlist[0], tlist[-1], n_timesteps); krylov_partitions = [; np.array(krylov_tlist[i: i + 2]) for i in range(n_timesteps - 1); ]; partitions = []; for krylov_partition in krylov_partitions:; start = krylov_partition[0]; end = krylov_partition[-1]; condition = _tlist <= end; partitions.append([start] + _tlist[condition].tolist() + [end]); _tlist = _tlist[~condition]. return partitions. def _e_ops_outputs(krylov_results, e_ops, n_tlist_steps, opt):; krylov_results.expect = []; if callable(e_ops):; n_expt_op = 0; expt_callback = True; krylov_results.num_expect = 1; elif isinstance(e_ops, list):; n_expt_op = len(e_ops); expt_callback = False; krylov_results.num_expect = n_expt_op; if n_expt_op == 0:; # fall back on storing states; opt.store_states = True; else:; for op in e_ops:; if not isinstance(op, Qobj) and callable(op):; krylov_results.expect.append(; np.zeros(n_tlist_steps, dtype=complex); ); continue; if op.isherm:; krylov_results.expect.append(np.zeros(n_tlist_steps)); else:; krylov_results.expect.append(; np.zeros(n_tlist_steps, dtype=complex); ). else:; raise TypeError(""Expectation parameter must be a list or a function""). return krylov_results, expt_callback, opt, n_expt_op. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/modules/qutip/krylovsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/krylovsolve.html
https://qutip.org/docs/4.7/modules/qutip/krylovsolve.html:1907,Modifiability,evolve,evolve,1907,"; e_ops=None,; options=None,; progress_bar: bool = None,; sparse: bool = False,; ):; """"""; Time evolution of state vectors for time independent Hamiltonians.; Evolve the state vector (""psi0"") finding an approximation for the time; evolution operator of Hamiltonian (""H"") by obtaining the projection of; the time evolution operator on a set of small dimensional Krylov; subspaces (m << dim(H)). The output is either the state vector or the expectation values of; supplied operators (""e_ops"") at arbitrary points at (""tlist""). **Additional options**. Additional options to krylovsolve can be set with the following:. * ""store_states"": stores states even though expectation values are; requested via the ""e_ops"" argument. * ""store_final_state"": store final state even though expectation values are; requested via the ""e_ops"" argument. Parameters; ----------; H : :class:`qutip.Qobj`; System Hamiltonian.; psi0 : :class: `qutip.Qobj`; Initial state vector (ket).; tlist : None / *list* / *array*; List of times on which to evolve the initial state. If None, nothing; happens but the code won't break.; krylov_dim: int; Dimension of Krylov approximation subspaces used for the time; evolution approximation.; e_ops : None / list of :class:`qutip.Qobj`; Single operator or list of operators for which to evaluate; expectation values.; options : Options; Instance of ODE solver options, as well as krylov parameters.; atol: controls (approximately) the error desired for the final; solution. (Defaults to 1e-8); nsteps: maximum number of krylov's internal number of Lanczos; iterations. (Defaults to 10000); progress_bar : None / BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation.; sparse : bool (default False); Use np.array to represent system Hamiltonians. If True, scipy sparse; arrays are used instead. Returns; -------; result: :class:`qutip.solver.Result`; An instance of the class :class:`qutip.solver.Result`, which contains; e",MatchSource.WIKI,docs/4.7/modules/qutip/krylovsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/krylovsolve.html
https://qutip.org/docs/4.7/modules/qutip/krylovsolve.html:3485,Modifiability,variab,variable,3485,"stance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation.; sparse : bool (default False); Use np.array to represent system Hamiltonians. If True, scipy sparse; arrays are used instead. Returns; -------; result: :class:`qutip.solver.Result`; An instance of the class :class:`qutip.solver.Result`, which contains; either an *array* `result.expect` of expectation values for the times; `tlist`, or an *array* `result.states` of state vectors corresponding; to the times `tlist` [if `e_ops` is an empty list].; """"""; # check the physics; _check_inputs(H, psi0, krylov_dim). # check extra inputs; e_ops, e_ops_dict = _check_e_ops(e_ops); pbar = _check_progress_bar(progress_bar). # transform inputs type from Qobj to np.ndarray/csr_matrix; if sparse:; _H = H.get_data() # (fast_) csr_matrix; else:; _H = H.full().copy() # np.ndarray; _psi = psi0.full().copy(); _psi = _psi / np.linalg.norm(_psi). # create internal variable and output containers; if options is None:; options = Options(nsteps=10000); krylov_results = Result(); krylov_results.solver = ""krylovsolve"". # handle particular cases of an empty tlist or single element; n_tlist_steps = len(tlist); if n_tlist_steps < 1:; return krylov_results. if n_tlist_steps == 1: # if tlist has only one element, return it; krylov_results = particular_tlist_or_happy_breakdown(; tlist, n_tlist_steps, options, psi0, e_ops, krylov_results, pbar; ) # this will also raise a warning; return krylov_results. tf = tlist[-1]; t0 = tlist[0]. # optimization step using Lanczos, then reuse it for the first partition; dim_m = krylov_dim; krylov_basis, T_m = lanczos_algorithm(; _H, _psi, krylov_dim=dim_m, sparse=sparse; ). # check if a happy breakdown occurred; if T_m.shape[0] < krylov_dim + 1:; if T_m.shape[0] == 1:; # this means that the state does not evolve in time, it lies in a; # symmetry of H subspace. Thus, theres no work to be done.; krylov_results = particular_tlist_or_happy_breakdown(; tlist,; n_tlist_steps,; optio",MatchSource.WIKI,docs/4.7/modules/qutip/krylovsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/krylovsolve.html
https://qutip.org/docs/4.7/modules/qutip/krylovsolve.html:4366,Modifiability,evolve,evolve,4366,"; _H = H.full().copy() # np.ndarray; _psi = psi0.full().copy(); _psi = _psi / np.linalg.norm(_psi). # create internal variable and output containers; if options is None:; options = Options(nsteps=10000); krylov_results = Result(); krylov_results.solver = ""krylovsolve"". # handle particular cases of an empty tlist or single element; n_tlist_steps = len(tlist); if n_tlist_steps < 1:; return krylov_results. if n_tlist_steps == 1: # if tlist has only one element, return it; krylov_results = particular_tlist_or_happy_breakdown(; tlist, n_tlist_steps, options, psi0, e_ops, krylov_results, pbar; ) # this will also raise a warning; return krylov_results. tf = tlist[-1]; t0 = tlist[0]. # optimization step using Lanczos, then reuse it for the first partition; dim_m = krylov_dim; krylov_basis, T_m = lanczos_algorithm(; _H, _psi, krylov_dim=dim_m, sparse=sparse; ). # check if a happy breakdown occurred; if T_m.shape[0] < krylov_dim + 1:; if T_m.shape[0] == 1:; # this means that the state does not evolve in time, it lies in a; # symmetry of H subspace. Thus, theres no work to be done.; krylov_results = particular_tlist_or_happy_breakdown(; tlist,; n_tlist_steps,; options,; psi0,; e_ops,; krylov_results,; pbar,; happy_breakdown=True,; ); return krylov_results; else:; # no optimization is required, convergence is guaranteed.; delta_t = tf - t0; n_timesteps = 1; else:. # calculate optimal number of internal timesteps.; delta_t = _optimize_lanczos_timestep_size(; T_m, krylov_basis=krylov_basis, tlist=tlist, options=options; ); n_timesteps = int(ceil((tf - t0) / delta_t)). if n_timesteps >= options.nsteps:; raise Exception(; f""Optimization requires a number {n_timesteps} of lanczos iterations, ""; f""which exceeds the defined allowed number {options.nsteps}. This can ""; ""be increased via the 'Options.nsteps' property.""; ). partitions = _make_partitions(tlist=tlist, n_timesteps=n_timesteps). if progress_bar:; pbar.start(len(partitions)). # update parameters regarding e_ops; krylov_result",MatchSource.WIKI,docs/4.7/modules/qutip/krylovsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/krylovsolve.html
https://qutip.org/docs/4.7/modules/qutip/krylovsolve.html:5509,Modifiability,evolve,evolve,5509,"down(; tlist,; n_tlist_steps,; options,; psi0,; e_ops,; krylov_results,; pbar,; happy_breakdown=True,; ); return krylov_results; else:; # no optimization is required, convergence is guaranteed.; delta_t = tf - t0; n_timesteps = 1; else:. # calculate optimal number of internal timesteps.; delta_t = _optimize_lanczos_timestep_size(; T_m, krylov_basis=krylov_basis, tlist=tlist, options=options; ); n_timesteps = int(ceil((tf - t0) / delta_t)). if n_timesteps >= options.nsteps:; raise Exception(; f""Optimization requires a number {n_timesteps} of lanczos iterations, ""; f""which exceeds the defined allowed number {options.nsteps}. This can ""; ""be increased via the 'Options.nsteps' property.""; ). partitions = _make_partitions(tlist=tlist, n_timesteps=n_timesteps). if progress_bar:; pbar.start(len(partitions)). # update parameters regarding e_ops; krylov_results, expt_callback, options, n_expt_op = _e_ops_outputs(; krylov_results, e_ops, n_tlist_steps, options; ). # parameters for the lazy iteration evolve tlist; psi_norm = np.linalg.norm(_psi); last_t = t0. for idx, partition in enumerate(partitions):. evolved_states = _evolve_krylov_tlist(; H=_H,; psi0=_psi,; krylov_dim=dim_m,; tlist=partition,; t0=last_t,; psi_norm=psi_norm,; krylov_basis=krylov_basis,; T_m=T_m,; sparse=sparse,; ). if idx == 0:; krylov_basis = None; T_m = None; t_idx = 0. _psi = evolved_states[-1]; psi_norm = np.linalg.norm(_psi); last_t = partition[-1]. # apply qobj to each evolved state, remove repeated tail elements; qobj_evolved_states = [; Qobj(state, dims=psi0.dims) for state in evolved_states[1:-1]; ]. krylov_results = _expectation_values(; e_ops,; n_expt_op,; expt_callback,; krylov_results,; qobj_evolved_states,; partitions,; idx,; t_idx,; options,; ). t_idx += len(partition[1:-1]). pbar.update(idx). pbar.finished(). if e_ops_dict:; krylov_results.expect = {; e: krylov_results.expect[n]; for n, e in enumerate(e_ops_dict.keys()); }. return krylov_results. def _expectation_values(; e_ops,; n_expt_op,;",MatchSource.WIKI,docs/4.7/modules/qutip/krylovsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/krylovsolve.html
https://qutip.org/docs/4.7/modules/qutip/krylovsolve.html:5963,Modifiability,evolve,evolved,5963,"(; f""Optimization requires a number {n_timesteps} of lanczos iterations, ""; f""which exceeds the defined allowed number {options.nsteps}. This can ""; ""be increased via the 'Options.nsteps' property.""; ). partitions = _make_partitions(tlist=tlist, n_timesteps=n_timesteps). if progress_bar:; pbar.start(len(partitions)). # update parameters regarding e_ops; krylov_results, expt_callback, options, n_expt_op = _e_ops_outputs(; krylov_results, e_ops, n_tlist_steps, options; ). # parameters for the lazy iteration evolve tlist; psi_norm = np.linalg.norm(_psi); last_t = t0. for idx, partition in enumerate(partitions):. evolved_states = _evolve_krylov_tlist(; H=_H,; psi0=_psi,; krylov_dim=dim_m,; tlist=partition,; t0=last_t,; psi_norm=psi_norm,; krylov_basis=krylov_basis,; T_m=T_m,; sparse=sparse,; ). if idx == 0:; krylov_basis = None; T_m = None; t_idx = 0. _psi = evolved_states[-1]; psi_norm = np.linalg.norm(_psi); last_t = partition[-1]. # apply qobj to each evolved state, remove repeated tail elements; qobj_evolved_states = [; Qobj(state, dims=psi0.dims) for state in evolved_states[1:-1]; ]. krylov_results = _expectation_values(; e_ops,; n_expt_op,; expt_callback,; krylov_results,; qobj_evolved_states,; partitions,; idx,; t_idx,; options,; ). t_idx += len(partition[1:-1]). pbar.update(idx). pbar.finished(). if e_ops_dict:; krylov_results.expect = {; e: krylov_results.expect[n]; for n, e in enumerate(e_ops_dict.keys()); }. return krylov_results. def _expectation_values(; e_ops,; n_expt_op,; expt_callback,; res,; evolved_states,; partitions,; idx,; t_idx,; options,; ):. if options.store_states:; res.states += evolved_states. for t, state in zip(; range(t_idx, t_idx + len(partitions[idx][1:-1])), evolved_states; ):. if expt_callback:; # use callback method; res.expect.append(e_ops(t, state)). for m in range(n_expt_op):; op = e_ops[m]; if not isinstance(op, Qobj) and callable(op):; res.expect[m][t] = op(t, state); continue. res.expect[m][t] = expect(op, state). if (; idx == len",MatchSource.WIKI,docs/4.7/modules/qutip/krylovsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/krylovsolve.html
https://qutip.org/docs/4.7/modules/qutip/krylovsolve.html:10529,Modifiability,evolve,evolved,10529,"list: list,; t0: float,; psi_norm: float = None,; krylov_basis: np.array = None,; T_m: np.array = None,; sparse: bool = False,; ):; """"""; Computes the Krylov approximation time evolution of dimension 'krylov_dim'; for Hamiltonian 'H' and initial state 'psi0' for each time in 'tlist'.; Parameters; ------------; H: np.ndarray or csr_matrix; System Hamiltonian.; psi0: np.ndarray; Initial state vector.; krylov_basis: np.ndarray; Krylov basis projector operator.; tlist: list; List of timesteps for the time evolution.; t0: float; Initial time for the time evolution.; psi_norm: float (optional, default False); Norm-2 of psi0.; krylov_basis: np.ndarray (optional, default None); Krylov basis projector operator. If 'krylov_basis' is None, perform; a lanczos iteration.; T_m: np.ndarray (optional, default None); Tridiagonal matrix decomposition of the system given by lanczos; algorithm. If 'T_m' is None, perform a lanczos iteration.; Returns; ---------; psi_list: List[np.ndarray]; List of evolved states at times t in 'tlist'.; """""". if psi_norm is None:; psi_norm = np.linalg.norm(psi0). if psi_norm != 1:; psi = psi0 / psi_norm; else:; psi = psi0. if (krylov_basis is None) or (T_m is None):; krylov_basis, T_m = lanczos_algorithm(; H=H, psi=psi, krylov_dim=krylov_dim, sparse=sparse; ). evolve = _evolve(t0, krylov_basis, T_m); psi_list = list(map(evolve, tlist)). return psi_list. # ----------------------------------------------------------------------; # Auxiliar functions. def _check_inputs(H, psi0, krylov_dim):; """"""Check that the inputs 'H' and 'psi0' have the correct structures.""""""; if not isinstance(H, Qobj):; raise TypeError(; ""krylovsolve currently supports Hamiltonian Qobj operators only""; ). if not H.isherm:; raise TypeError(""Hamiltonian 'H' must be hermician.""). if not isinstance(psi0, Qobj):; raise TypeError(""'psi0' must be a Qobj.""). if not psi0.isket:; raise TypeError(""Initial state must be a ket Qobj.""). if not ((len(H.shape) == 2) and (H.shape[0] == H.shape[1])):; raise",MatchSource.WIKI,docs/4.7/modules/qutip/krylovsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/krylovsolve.html
https://qutip.org/docs/4.7/modules/qutip/krylovsolve.html:10829,Modifiability,evolve,evolve,10829,"sr_matrix; System Hamiltonian.; psi0: np.ndarray; Initial state vector.; krylov_basis: np.ndarray; Krylov basis projector operator.; tlist: list; List of timesteps for the time evolution.; t0: float; Initial time for the time evolution.; psi_norm: float (optional, default False); Norm-2 of psi0.; krylov_basis: np.ndarray (optional, default None); Krylov basis projector operator. If 'krylov_basis' is None, perform; a lanczos iteration.; T_m: np.ndarray (optional, default None); Tridiagonal matrix decomposition of the system given by lanczos; algorithm. If 'T_m' is None, perform a lanczos iteration.; Returns; ---------; psi_list: List[np.ndarray]; List of evolved states at times t in 'tlist'.; """""". if psi_norm is None:; psi_norm = np.linalg.norm(psi0). if psi_norm != 1:; psi = psi0 / psi_norm; else:; psi = psi0. if (krylov_basis is None) or (T_m is None):; krylov_basis, T_m = lanczos_algorithm(; H=H, psi=psi, krylov_dim=krylov_dim, sparse=sparse; ). evolve = _evolve(t0, krylov_basis, T_m); psi_list = list(map(evolve, tlist)). return psi_list. # ----------------------------------------------------------------------; # Auxiliar functions. def _check_inputs(H, psi0, krylov_dim):; """"""Check that the inputs 'H' and 'psi0' have the correct structures.""""""; if not isinstance(H, Qobj):; raise TypeError(; ""krylovsolve currently supports Hamiltonian Qobj operators only""; ). if not H.isherm:; raise TypeError(""Hamiltonian 'H' must be hermician.""). if not isinstance(psi0, Qobj):; raise TypeError(""'psi0' must be a Qobj.""). if not psi0.isket:; raise TypeError(""Initial state must be a ket Qobj.""). if not ((len(H.shape) == 2) and (H.shape[0] == H.shape[1])):; raise ValueError(""the Hamiltonian must be 2-dimensional square Qobj.""). if not (psi0.dims[0] == H.dims[0]):; raise ValueError(; ""'psi0' and the Hamiltonian must share the same dimension.""; ). if not (H.shape[0] >= krylov_dim):; raise ValueError(; ""the Hamiltonian dimension must be greater or equal to the maximum""; "" allowed krylov ",MatchSource.WIKI,docs/4.7/modules/qutip/krylovsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/krylovsolve.html
https://qutip.org/docs/4.7/modules/qutip/krylovsolve.html:10890,Modifiability,evolve,evolve,10890,"sr_matrix; System Hamiltonian.; psi0: np.ndarray; Initial state vector.; krylov_basis: np.ndarray; Krylov basis projector operator.; tlist: list; List of timesteps for the time evolution.; t0: float; Initial time for the time evolution.; psi_norm: float (optional, default False); Norm-2 of psi0.; krylov_basis: np.ndarray (optional, default None); Krylov basis projector operator. If 'krylov_basis' is None, perform; a lanczos iteration.; T_m: np.ndarray (optional, default None); Tridiagonal matrix decomposition of the system given by lanczos; algorithm. If 'T_m' is None, perform a lanczos iteration.; Returns; ---------; psi_list: List[np.ndarray]; List of evolved states at times t in 'tlist'.; """""". if psi_norm is None:; psi_norm = np.linalg.norm(psi0). if psi_norm != 1:; psi = psi0 / psi_norm; else:; psi = psi0. if (krylov_basis is None) or (T_m is None):; krylov_basis, T_m = lanczos_algorithm(; H=H, psi=psi, krylov_dim=krylov_dim, sparse=sparse; ). evolve = _evolve(t0, krylov_basis, T_m); psi_list = list(map(evolve, tlist)). return psi_list. # ----------------------------------------------------------------------; # Auxiliar functions. def _check_inputs(H, psi0, krylov_dim):; """"""Check that the inputs 'H' and 'psi0' have the correct structures.""""""; if not isinstance(H, Qobj):; raise TypeError(; ""krylovsolve currently supports Hamiltonian Qobj operators only""; ). if not H.isherm:; raise TypeError(""Hamiltonian 'H' must be hermician.""). if not isinstance(psi0, Qobj):; raise TypeError(""'psi0' must be a Qobj.""). if not psi0.isket:; raise TypeError(""Initial state must be a ket Qobj.""). if not ((len(H.shape) == 2) and (H.shape[0] == H.shape[1])):; raise ValueError(""the Hamiltonian must be 2-dimensional square Qobj.""). if not (psi0.dims[0] == H.dims[0]):; raise ValueError(; ""'psi0' and the Hamiltonian must share the same dimension.""; ). if not (H.shape[0] >= krylov_dim):; raise ValueError(; ""the Hamiltonian dimension must be greater or equal to the maximum""; "" allowed krylov ",MatchSource.WIKI,docs/4.7/modules/qutip/krylovsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/krylovsolve.html
https://qutip.org/docs/4.7/modules/qutip/krylovsolve.html:13813,Modifiability,evolve,evolves,13813," contains a single element. If 'e_ops' were provided""; "", return its corresponding expectation values at 'psi0', else ""; ""return 'psi0'.""; ). progress_bar.start(1). res, expt_callback, options, n_expt_op = _e_ops_outputs(; res, e_ops, n_tlist_steps, options; ). if options.store_states:; res.states = [psi0]. e_0 = None; if expt_callback:; # use callback method; e_0 = e_ops(0, psi0); res.expect.append(e_0). e_m_0 = []; for m in range(n_expt_op):; op = e_ops[m]. if not isinstance(op, Qobj) and callable(op):; e_m_0.append(op(0, psi0)); res.expect[m][0] = e_m_0[m]; continue. e_m_0.append(expect(op, psi0)); res.expect[m][0] = e_m_0[m]. if happy_breakdown:; res = _happy_breakdown(; tlist,; options,; res,; psi0,; expt_callback,; e_0,; n_expt_op,; e_ops,; e_m_0,; ). if (options.store_final_state) and (not options.store_states):; res.states = [psi0]. progress_bar.update(1); progress_bar.finished(); return res. def _happy_breakdown(; tlist, options, res, psi0, expt_callback, e_0, n_expt_op, e_ops, e_m_0; ):; """"""; Dummy evolves the system if a happy breakdown of an eigenstate occurs.; """"""; for i in range(1, len(tlist)):; if options.store_states:; res.states.append(psi0); if expt_callback:; res.expect.append(e_0). for m in range(n_expt_op):; op = e_ops[m]; res.expect[m][i] = e_m_0[m]; return res. def _optimize_lanczos_timestep_size(T, krylov_basis, tlist, options):; """"""; Solves the equation defined to optimize the number of Lanczos; iterations to be performed inside Krylov's algorithm.; """""". f = _lanczos_error_equation_to_optimize_delta_t(; T,; krylov_basis=krylov_basis,; t0=tlist[0],; tf=tlist[-1],; target_tolerance=options.atol,; ). # To avoid the singularity at t0, we add a small epsilon value; t_min = (tlist[-1] - tlist[0]) / options.nsteps + tlist[0]; bracket = [t_min, tlist[-1]]. if (np.sign(f(bracket[0])) == -1) and (np.sign(f(bracket[-1])) == -1):; delta_t = tlist[-1] - tlist[0]; return delta_t. elif (np.sign(f(bracket[0])) == 1) and (np.sign(f(bracket[-1])) == 1):; raise",MatchSource.WIKI,docs/4.7/modules/qutip/krylovsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/krylovsolve.html
https://qutip.org/docs/4.7/modules/qutip/krylovsolve.html:517,Performance,optimiz,optimize,517,". qutip.krylovsolve — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.krylovsolve. Source code for qutip.krylovsolve; __all__ = [""krylovsolve""]; """"""; This module provides approximations of the time evolution operator; using small dimensional Krylov subspaces.; """""". from scipy.optimize import root_scalar; from math import ceil; import numpy as np; import warnings. from qutip.expect import expect; from qutip.qobj import Qobj; from qutip.solver import Result, Options; from qutip.ui.progressbar import BaseProgressBar, TextProgressBar; from qutip.sparse import eigh. [docs]def krylovsolve(; H: Qobj,; psi0: Qobj,; tlist: np.array,; krylov_dim: int,; e_ops=None,; options=None,; progress_bar: bool = None,; sparse: bool = False,; ):; """"""; Time evolution of state vectors for time independent Hamiltonians.; Evolve the state vector (""psi0"") finding an approximation for the time; evolution operator of Hamiltonian (""H"") by obtaining the projection of; the time evolution operator on a set of small dimensional Krylov; subspaces (m << dim(H)). The output is either the state vector or the expectation values of; supplied operators (""e_ops"") at arbitrary points at (""tlist""). **Additional options**. Additional options to krylovsolve can be set with the following:. * ""store_states"": stores states even though expectation values are; requested via the ""e_ops"" argument. * ""store_final_state"": store final state even though expectation values are; requested via the ""e_ops"" argument. Parameters; ----------; H : :class:`qutip.Qobj`; System Hamiltonian.; psi0 : :class: `qutip.Qobj`; Initial state vector (ket).; tlist : None / *list* / *array*; List of times on which to evolve the initial state. If None, nothing; happens but the code won't break.; krylov_dim: int",MatchSource.WIKI,docs/4.7/modules/qutip/krylovsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/krylovsolve.html
https://qutip.org/docs/4.7/modules/qutip/krylovsolve.html:4054,Performance,optimiz,optimization,4054,"m). # check extra inputs; e_ops, e_ops_dict = _check_e_ops(e_ops); pbar = _check_progress_bar(progress_bar). # transform inputs type from Qobj to np.ndarray/csr_matrix; if sparse:; _H = H.get_data() # (fast_) csr_matrix; else:; _H = H.full().copy() # np.ndarray; _psi = psi0.full().copy(); _psi = _psi / np.linalg.norm(_psi). # create internal variable and output containers; if options is None:; options = Options(nsteps=10000); krylov_results = Result(); krylov_results.solver = ""krylovsolve"". # handle particular cases of an empty tlist or single element; n_tlist_steps = len(tlist); if n_tlist_steps < 1:; return krylov_results. if n_tlist_steps == 1: # if tlist has only one element, return it; krylov_results = particular_tlist_or_happy_breakdown(; tlist, n_tlist_steps, options, psi0, e_ops, krylov_results, pbar; ) # this will also raise a warning; return krylov_results. tf = tlist[-1]; t0 = tlist[0]. # optimization step using Lanczos, then reuse it for the first partition; dim_m = krylov_dim; krylov_basis, T_m = lanczos_algorithm(; _H, _psi, krylov_dim=dim_m, sparse=sparse; ). # check if a happy breakdown occurred; if T_m.shape[0] < krylov_dim + 1:; if T_m.shape[0] == 1:; # this means that the state does not evolve in time, it lies in a; # symmetry of H subspace. Thus, theres no work to be done.; krylov_results = particular_tlist_or_happy_breakdown(; tlist,; n_tlist_steps,; options,; psi0,; e_ops,; krylov_results,; pbar,; happy_breakdown=True,; ); return krylov_results; else:; # no optimization is required, convergence is guaranteed.; delta_t = tf - t0; n_timesteps = 1; else:. # calculate optimal number of internal timesteps.; delta_t = _optimize_lanczos_timestep_size(; T_m, krylov_basis=krylov_basis, tlist=tlist, options=options; ); n_timesteps = int(ceil((tf - t0) / delta_t)). if n_timesteps >= options.nsteps:; raise Exception(; f""Optimization requires a number {n_timesteps} of lanczos iterations, ""; f""which exceeds the defined allowed number {options.nsteps}. This c",MatchSource.WIKI,docs/4.7/modules/qutip/krylovsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/krylovsolve.html
https://qutip.org/docs/4.7/modules/qutip/krylovsolve.html:4645,Performance,optimiz,optimization,4645,"ov_results = Result(); krylov_results.solver = ""krylovsolve"". # handle particular cases of an empty tlist or single element; n_tlist_steps = len(tlist); if n_tlist_steps < 1:; return krylov_results. if n_tlist_steps == 1: # if tlist has only one element, return it; krylov_results = particular_tlist_or_happy_breakdown(; tlist, n_tlist_steps, options, psi0, e_ops, krylov_results, pbar; ) # this will also raise a warning; return krylov_results. tf = tlist[-1]; t0 = tlist[0]. # optimization step using Lanczos, then reuse it for the first partition; dim_m = krylov_dim; krylov_basis, T_m = lanczos_algorithm(; _H, _psi, krylov_dim=dim_m, sparse=sparse; ). # check if a happy breakdown occurred; if T_m.shape[0] < krylov_dim + 1:; if T_m.shape[0] == 1:; # this means that the state does not evolve in time, it lies in a; # symmetry of H subspace. Thus, theres no work to be done.; krylov_results = particular_tlist_or_happy_breakdown(; tlist,; n_tlist_steps,; options,; psi0,; e_ops,; krylov_results,; pbar,; happy_breakdown=True,; ); return krylov_results; else:; # no optimization is required, convergence is guaranteed.; delta_t = tf - t0; n_timesteps = 1; else:. # calculate optimal number of internal timesteps.; delta_t = _optimize_lanczos_timestep_size(; T_m, krylov_basis=krylov_basis, tlist=tlist, options=options; ); n_timesteps = int(ceil((tf - t0) / delta_t)). if n_timesteps >= options.nsteps:; raise Exception(; f""Optimization requires a number {n_timesteps} of lanczos iterations, ""; f""which exceeds the defined allowed number {options.nsteps}. This can ""; ""be increased via the 'Options.nsteps' property.""; ). partitions = _make_partitions(tlist=tlist, n_timesteps=n_timesteps). if progress_bar:; pbar.start(len(partitions)). # update parameters regarding e_ops; krylov_results, expt_callback, options, n_expt_op = _e_ops_outputs(; krylov_results, e_ops, n_tlist_steps, options; ). # parameters for the lazy iteration evolve tlist; psi_norm = np.linalg.norm(_psi); last_t = t0. for idx",MatchSource.WIKI,docs/4.7/modules/qutip/krylovsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/krylovsolve.html
https://qutip.org/docs/4.7/modules/qutip/krylovsolve.html:7793,Performance,perform,perform,7793,"or m in range(n_expt_op):; op = e_ops[m]; if not isinstance(op, Qobj) and callable(op):; res.expect[m][t] = op(t, state); continue. res.expect[m][t] = expect(op, state). if (; idx == len(partitions) - 1; and options.store_final_state; and not options.store_states; ):; res.states = [evolved_states[-1]]. return res. def lanczos_algorithm(; H,; psi: np.ndarray,; krylov_dim: int,; sparse: bool = False,; ):; """"""; Computes a basis of the Krylov subspace for Hamiltonian 'H', a system; state 'psi' and Krylov dimension 'krylov_dim'. The space is spanned; by {psi, H psi, H^2 psi, ..., H^(krylov_dim) psi}.; Parameters; ------------; H : np.ndarray or csr_matrix; System Hamiltonian. If the Hamiltonian is dense, a np.ndarray is; preferred, whereas if it is sparse, a scipy csr_matrix is optimal.; psi: np.ndarray; State used to calculate Krylov subspace.; krylov_dim: int; Dimension (krylov_dim + 1) of the spanned Krylov subspace.; sparse: bool (optional, default False); Wether to perform scipy sparse matrix multiplication operations or; numpy dense matrix multiplications.; Returns; ---------; v: np.ndarray; Lanczos eigenvector.; T: np.ndarray; Tridiagonal decomposition.; """""". v = np.zeros((krylov_dim + 1, psi.shape[0]), dtype=complex); T_m = np.zeros((krylov_dim + 1, krylov_dim + 1), dtype=complex). v[0, :] = psi.squeeze(). w_prime = H.dot(v[0, :]). alpha = np.vdot(w_prime, v[0, :]). w = w_prime - alpha * v[0, :]. T_m[0, 0] = alpha. for j in range(1, krylov_dim + 1):. beta = np.linalg.norm(w). if beta < 1e-7:. # Happy breakdown; v_happy = v[0:j, :]; T_m_happy = T_m[0:j, 0:j]. return v_happy, T_m_happy. v[j, :] = w / beta; w_prime = H.dot(v[j, :]); alpha = np.vdot(w_prime, v[j, :]). w = w_prime - alpha * v[j, :] - beta * v[j - 1, :]. T_m[j, j] = alpha; T_m[j, j - 1] = beta; T_m[j - 1, j] = beta. return v, T_m. def _evolve(t0: float, krylov_basis: np.ndarray, T_m: np.ndarray):; """"""; Computes the time evolution operator 'U(t - t0) psi0_k', where 'psi0_k'; is the first basis element of",MatchSource.WIKI,docs/4.7/modules/qutip/krylovsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/krylovsolve.html
https://qutip.org/docs/4.7/modules/qutip/krylovsolve.html:10276,Performance,perform,perform,10276,"ctors); e0 = eigenvectors.conj().T[:, 0]. def time_evolution(t):; delta_t = t - t0; aux = np.multiply(np.exp(-1j * delta_t * eigenvalues), e0); return np.matmul(U, aux). return time_evolution. def _evolve_krylov_tlist(; H,; psi0: np.ndarray,; krylov_dim: int,; tlist: list,; t0: float,; psi_norm: float = None,; krylov_basis: np.array = None,; T_m: np.array = None,; sparse: bool = False,; ):; """"""; Computes the Krylov approximation time evolution of dimension 'krylov_dim'; for Hamiltonian 'H' and initial state 'psi0' for each time in 'tlist'.; Parameters; ------------; H: np.ndarray or csr_matrix; System Hamiltonian.; psi0: np.ndarray; Initial state vector.; krylov_basis: np.ndarray; Krylov basis projector operator.; tlist: list; List of timesteps for the time evolution.; t0: float; Initial time for the time evolution.; psi_norm: float (optional, default False); Norm-2 of psi0.; krylov_basis: np.ndarray (optional, default None); Krylov basis projector operator. If 'krylov_basis' is None, perform; a lanczos iteration.; T_m: np.ndarray (optional, default None); Tridiagonal matrix decomposition of the system given by lanczos; algorithm. If 'T_m' is None, perform a lanczos iteration.; Returns; ---------; psi_list: List[np.ndarray]; List of evolved states at times t in 'tlist'.; """""". if psi_norm is None:; psi_norm = np.linalg.norm(psi0). if psi_norm != 1:; psi = psi0 / psi_norm; else:; psi = psi0. if (krylov_basis is None) or (T_m is None):; krylov_basis, T_m = lanczos_algorithm(; H=H, psi=psi, krylov_dim=krylov_dim, sparse=sparse; ). evolve = _evolve(t0, krylov_basis, T_m); psi_list = list(map(evolve, tlist)). return psi_list. # ----------------------------------------------------------------------; # Auxiliar functions. def _check_inputs(H, psi0, krylov_dim):; """"""Check that the inputs 'H' and 'psi0' have the correct structures.""""""; if not isinstance(H, Qobj):; raise TypeError(; ""krylovsolve currently supports Hamiltonian Qobj operators only""; ). if not H.isherm:; raise Typ",MatchSource.WIKI,docs/4.7/modules/qutip/krylovsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/krylovsolve.html
https://qutip.org/docs/4.7/modules/qutip/krylovsolve.html:10443,Performance,perform,perform,10443,"eturn time_evolution. def _evolve_krylov_tlist(; H,; psi0: np.ndarray,; krylov_dim: int,; tlist: list,; t0: float,; psi_norm: float = None,; krylov_basis: np.array = None,; T_m: np.array = None,; sparse: bool = False,; ):; """"""; Computes the Krylov approximation time evolution of dimension 'krylov_dim'; for Hamiltonian 'H' and initial state 'psi0' for each time in 'tlist'.; Parameters; ------------; H: np.ndarray or csr_matrix; System Hamiltonian.; psi0: np.ndarray; Initial state vector.; krylov_basis: np.ndarray; Krylov basis projector operator.; tlist: list; List of timesteps for the time evolution.; t0: float; Initial time for the time evolution.; psi_norm: float (optional, default False); Norm-2 of psi0.; krylov_basis: np.ndarray (optional, default None); Krylov basis projector operator. If 'krylov_basis' is None, perform; a lanczos iteration.; T_m: np.ndarray (optional, default None); Tridiagonal matrix decomposition of the system given by lanczos; algorithm. If 'T_m' is None, perform a lanczos iteration.; Returns; ---------; psi_list: List[np.ndarray]; List of evolved states at times t in 'tlist'.; """""". if psi_norm is None:; psi_norm = np.linalg.norm(psi0). if psi_norm != 1:; psi = psi0 / psi_norm; else:; psi = psi0. if (krylov_basis is None) or (T_m is None):; krylov_basis, T_m = lanczos_algorithm(; H=H, psi=psi, krylov_dim=krylov_dim, sparse=sparse; ). evolve = _evolve(t0, krylov_basis, T_m); psi_list = list(map(evolve, tlist)). return psi_list. # ----------------------------------------------------------------------; # Auxiliar functions. def _check_inputs(H, psi0, krylov_dim):; """"""Check that the inputs 'H' and 'psi0' have the correct structures.""""""; if not isinstance(H, Qobj):; raise TypeError(; ""krylovsolve currently supports Hamiltonian Qobj operators only""; ). if not H.isherm:; raise TypeError(""Hamiltonian 'H' must be hermician.""). if not isinstance(psi0, Qobj):; raise TypeError(""'psi0' must be a Qobj.""). if not psi0.isket:; raise TypeError(""Initial state",MatchSource.WIKI,docs/4.7/modules/qutip/krylovsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/krylovsolve.html
https://qutip.org/docs/4.7/modules/qutip/krylovsolve.html:14201,Performance,optimiz,optimize,14201,"nd(e_0). e_m_0 = []; for m in range(n_expt_op):; op = e_ops[m]. if not isinstance(op, Qobj) and callable(op):; e_m_0.append(op(0, psi0)); res.expect[m][0] = e_m_0[m]; continue. e_m_0.append(expect(op, psi0)); res.expect[m][0] = e_m_0[m]. if happy_breakdown:; res = _happy_breakdown(; tlist,; options,; res,; psi0,; expt_callback,; e_0,; n_expt_op,; e_ops,; e_m_0,; ). if (options.store_final_state) and (not options.store_states):; res.states = [psi0]. progress_bar.update(1); progress_bar.finished(); return res. def _happy_breakdown(; tlist, options, res, psi0, expt_callback, e_0, n_expt_op, e_ops, e_m_0; ):; """"""; Dummy evolves the system if a happy breakdown of an eigenstate occurs.; """"""; for i in range(1, len(tlist)):; if options.store_states:; res.states.append(psi0); if expt_callback:; res.expect.append(e_0). for m in range(n_expt_op):; op = e_ops[m]; res.expect[m][i] = e_m_0[m]; return res. def _optimize_lanczos_timestep_size(T, krylov_basis, tlist, options):; """"""; Solves the equation defined to optimize the number of Lanczos; iterations to be performed inside Krylov's algorithm.; """""". f = _lanczos_error_equation_to_optimize_delta_t(; T,; krylov_basis=krylov_basis,; t0=tlist[0],; tf=tlist[-1],; target_tolerance=options.atol,; ). # To avoid the singularity at t0, we add a small epsilon value; t_min = (tlist[-1] - tlist[0]) / options.nsteps + tlist[0]; bracket = [t_min, tlist[-1]]. if (np.sign(f(bracket[0])) == -1) and (np.sign(f(bracket[-1])) == -1):; delta_t = tlist[-1] - tlist[0]; return delta_t. elif (np.sign(f(bracket[0])) == 1) and (np.sign(f(bracket[-1])) == 1):; raise ValueError(; ""No solution exists with the given combination of parameters 'krylov_dim', ""; ""tolerance = 'options.atol', maximum number allowed of krylov internal ""; ""partitions = 'options.nsteps' and 'tlist'. Try reducing the tolerance, or ""; ""increasing 'krylov_dim'. If nothing works, then a deeper analysis of the ""; ""problem is recommended.""; ). else:; sol = root_scalar(f=f, bracket=bracket, me",MatchSource.WIKI,docs/4.7/modules/qutip/krylovsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/krylovsolve.html
https://qutip.org/docs/4.7/modules/qutip/krylovsolve.html:14250,Performance,perform,performed,14250,"nd(e_0). e_m_0 = []; for m in range(n_expt_op):; op = e_ops[m]. if not isinstance(op, Qobj) and callable(op):; e_m_0.append(op(0, psi0)); res.expect[m][0] = e_m_0[m]; continue. e_m_0.append(expect(op, psi0)); res.expect[m][0] = e_m_0[m]. if happy_breakdown:; res = _happy_breakdown(; tlist,; options,; res,; psi0,; expt_callback,; e_0,; n_expt_op,; e_ops,; e_m_0,; ). if (options.store_final_state) and (not options.store_states):; res.states = [psi0]. progress_bar.update(1); progress_bar.finished(); return res. def _happy_breakdown(; tlist, options, res, psi0, expt_callback, e_0, n_expt_op, e_ops, e_m_0; ):; """"""; Dummy evolves the system if a happy breakdown of an eigenstate occurs.; """"""; for i in range(1, len(tlist)):; if options.store_states:; res.states.append(psi0); if expt_callback:; res.expect.append(e_0). for m in range(n_expt_op):; op = e_ops[m]; res.expect[m][i] = e_m_0[m]; return res. def _optimize_lanczos_timestep_size(T, krylov_basis, tlist, options):; """"""; Solves the equation defined to optimize the number of Lanczos; iterations to be performed inside Krylov's algorithm.; """""". f = _lanczos_error_equation_to_optimize_delta_t(; T,; krylov_basis=krylov_basis,; t0=tlist[0],; tf=tlist[-1],; target_tolerance=options.atol,; ). # To avoid the singularity at t0, we add a small epsilon value; t_min = (tlist[-1] - tlist[0]) / options.nsteps + tlist[0]; bracket = [t_min, tlist[-1]]. if (np.sign(f(bracket[0])) == -1) and (np.sign(f(bracket[-1])) == -1):; delta_t = tlist[-1] - tlist[0]; return delta_t. elif (np.sign(f(bracket[0])) == 1) and (np.sign(f(bracket[-1])) == 1):; raise ValueError(; ""No solution exists with the given combination of parameters 'krylov_dim', ""; ""tolerance = 'options.atol', maximum number allowed of krylov internal ""; ""partitions = 'options.nsteps' and 'tlist'. Try reducing the tolerance, or ""; ""increasing 'krylov_dim'. If nothing works, then a deeper analysis of the ""; ""problem is recommended.""; ). else:; sol = root_scalar(f=f, bracket=bracket, me",MatchSource.WIKI,docs/4.7/modules/qutip/krylovsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/krylovsolve.html
https://qutip.org/docs/4.7/modules/qutip/krylovsolve.html:15686,Performance,optimiz,optimize,15686,"n delta_t. elif (np.sign(f(bracket[0])) == 1) and (np.sign(f(bracket[-1])) == 1):; raise ValueError(; ""No solution exists with the given combination of parameters 'krylov_dim', ""; ""tolerance = 'options.atol', maximum number allowed of krylov internal ""; ""partitions = 'options.nsteps' and 'tlist'. Try reducing the tolerance, or ""; ""increasing 'krylov_dim'. If nothing works, then a deeper analysis of the ""; ""problem is recommended.""; ). else:; sol = root_scalar(f=f, bracket=bracket, method=""brentq"", xtol=options.atol); if sol.converged:; delta_t = sol.root; return delta_t; else:; raise Exception(; ""Method did not converge, try increasing 'krylov_dim', ""; ""taking a lesser final time 'tlist[-1]' or decreasing the ""; ""tolerance via Options().atol. ""; ""If nothing works, this problem might not be suitable for ""; ""Krylov or a deeper analysis might be required.""; ). def _lanczos_error_equation_to_optimize_delta_t(; T, krylov_basis, t0, tf, target_tolerance; ):; """"""; Function to optimize in order to obtain the optimal number of; Lanczos algorithm iterations, governed by the optimal timestep size between; Lanczos iteractions.; """"""; eigenvalues1, eigenvectors1 = eigh(T[0:, 0:]); U1 = np.matmul(krylov_basis[0:, 0:].T, eigenvectors1); e01 = eigenvectors1.conj().T[:, 0]. eigenvalues2, eigenvectors2 = eigh(T[0:-1, 0: T.shape[1] - 1]); U2 = np.matmul(krylov_basis[0:-1, :].T, eigenvectors2); e02 = eigenvectors2.conj().T[:, 0]. def f(t):; delta_t = -1j * (t - t0). aux1 = np.multiply(np.exp(delta_t * eigenvalues1), e01); psi1 = np.matmul(U1, aux1). aux2 = np.multiply(np.exp(delta_t * eigenvalues2), e02); psi2 = np.matmul(U2, aux2). error = np.linalg.norm(psi1 - psi2). steps = max(1, (tf - t0) // (t - t0)); return np.log10(error) + np.log10(steps) - np.log10(target_tolerance). return f. def _make_partitions(tlist, n_timesteps):; """"""Generates an internal 'partitions' list of np.arrays to iterate Lanczos; algorithms on each of them, based on 'tlist' and the optimized number of; iterations ",MatchSource.WIKI,docs/4.7/modules/qutip/krylovsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/krylovsolve.html
https://qutip.org/docs/4.7/modules/qutip/krylovsolve.html:16671,Performance,optimiz,optimized,16671,"tolerance; ):; """"""; Function to optimize in order to obtain the optimal number of; Lanczos algorithm iterations, governed by the optimal timestep size between; Lanczos iteractions.; """"""; eigenvalues1, eigenvectors1 = eigh(T[0:, 0:]); U1 = np.matmul(krylov_basis[0:, 0:].T, eigenvectors1); e01 = eigenvectors1.conj().T[:, 0]. eigenvalues2, eigenvectors2 = eigh(T[0:-1, 0: T.shape[1] - 1]); U2 = np.matmul(krylov_basis[0:-1, :].T, eigenvectors2); e02 = eigenvectors2.conj().T[:, 0]. def f(t):; delta_t = -1j * (t - t0). aux1 = np.multiply(np.exp(delta_t * eigenvalues1), e01); psi1 = np.matmul(U1, aux1). aux2 = np.multiply(np.exp(delta_t * eigenvalues2), e02); psi2 = np.matmul(U2, aux2). error = np.linalg.norm(psi1 - psi2). steps = max(1, (tf - t0) // (t - t0)); return np.log10(error) + np.log10(steps) - np.log10(target_tolerance). return f. def _make_partitions(tlist, n_timesteps):; """"""Generates an internal 'partitions' list of np.arrays to iterate Lanczos; algorithms on each of them, based on 'tlist' and the optimized number of; iterations 'n_timesteps'.; """""". _tlist = np.copy(tlist). if n_timesteps == 1:; _tlist = np.insert(_tlist, 0, tlist[0]); _tlist = np.append(_tlist, tlist[-1]); partitions = [_tlist]; return partitions. n_timesteps += 1; krylov_tlist = np.linspace(tlist[0], tlist[-1], n_timesteps); krylov_partitions = [; np.array(krylov_tlist[i: i + 2]) for i in range(n_timesteps - 1); ]; partitions = []; for krylov_partition in krylov_partitions:; start = krylov_partition[0]; end = krylov_partition[-1]; condition = _tlist <= end; partitions.append([start] + _tlist[condition].tolist() + [end]); _tlist = _tlist[~condition]. return partitions. def _e_ops_outputs(krylov_results, e_ops, n_tlist_steps, opt):; krylov_results.expect = []; if callable(e_ops):; n_expt_op = 0; expt_callback = True; krylov_results.num_expect = 1; elif isinstance(e_ops, list):; n_expt_op = len(e_ops); expt_callback = False; krylov_results.num_expect = n_expt_op; if n_expt_op == 0:; # fall back o",MatchSource.WIKI,docs/4.7/modules/qutip/krylovsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/krylovsolve.html
https://qutip.org/docs/4.7/modules/qutip/krylovsolve.html:14444,Safety,avoid,avoid,14444,"res,; psi0,; expt_callback,; e_0,; n_expt_op,; e_ops,; e_m_0,; ). if (options.store_final_state) and (not options.store_states):; res.states = [psi0]. progress_bar.update(1); progress_bar.finished(); return res. def _happy_breakdown(; tlist, options, res, psi0, expt_callback, e_0, n_expt_op, e_ops, e_m_0; ):; """"""; Dummy evolves the system if a happy breakdown of an eigenstate occurs.; """"""; for i in range(1, len(tlist)):; if options.store_states:; res.states.append(psi0); if expt_callback:; res.expect.append(e_0). for m in range(n_expt_op):; op = e_ops[m]; res.expect[m][i] = e_m_0[m]; return res. def _optimize_lanczos_timestep_size(T, krylov_basis, tlist, options):; """"""; Solves the equation defined to optimize the number of Lanczos; iterations to be performed inside Krylov's algorithm.; """""". f = _lanczos_error_equation_to_optimize_delta_t(; T,; krylov_basis=krylov_basis,; t0=tlist[0],; tf=tlist[-1],; target_tolerance=options.atol,; ). # To avoid the singularity at t0, we add a small epsilon value; t_min = (tlist[-1] - tlist[0]) / options.nsteps + tlist[0]; bracket = [t_min, tlist[-1]]. if (np.sign(f(bracket[0])) == -1) and (np.sign(f(bracket[-1])) == -1):; delta_t = tlist[-1] - tlist[0]; return delta_t. elif (np.sign(f(bracket[0])) == 1) and (np.sign(f(bracket[-1])) == 1):; raise ValueError(; ""No solution exists with the given combination of parameters 'krylov_dim', ""; ""tolerance = 'options.atol', maximum number allowed of krylov internal ""; ""partitions = 'options.nsteps' and 'tlist'. Try reducing the tolerance, or ""; ""increasing 'krylov_dim'. If nothing works, then a deeper analysis of the ""; ""problem is recommended.""; ). else:; sol = root_scalar(f=f, bracket=bracket, method=""brentq"", xtol=options.atol); if sol.converged:; delta_t = sol.root; return delta_t; else:; raise Exception(; ""Method did not converge, try increasing 'krylov_dim', ""; ""taking a lesser final time 'tlist[-1]' or decreasing the ""; ""tolerance via Options().atol. ""; ""If nothing works, this problem m",MatchSource.WIKI,docs/4.7/modules/qutip/krylovsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/krylovsolve.html
https://qutip.org/docs/4.7/modules/qutip/lattice.html:13396,Deployability,configurat,configuration,13396,"ell_num_site, cell_num_site-1); bN0 = basis(cell_num_site, 0); siteT = -bNm * bN0.dag(); inter_hop = tensor(Qobj(siteT), qeye(self.cell_site_dof)); dih = inter_hop.dims[0]; if all(x == 1 for x in dih):; dih = [1]; else:; while 1 in dih:; dih.remove(1); self._H_inter_list = [Qobj(inter_hop, dims=[dih, dih],; type='oper')]; self._H_inter = Qobj(inter_hop, dims=[dih, dih], type='oper'); else:; raise Exception(""inter_hop is required to be a Qobj or a \; list of Qobjs.""). self.positions_of_sites = [(i/self.cell_num_site) for i in; range(self.cell_num_site)]; self._inter_vec_list = [[1] for i in range(len(self._H_inter_list))]; self._Brav_lattice_vectors_list = [[1]] # unit vectors; self.is_real = is_real. def __repr__(self):; s = """"; s += (""Lattice1d object: "" +; ""Number of cells = "" + str(self.num_cell) +; "",\nNumber of sites in the cell = "" + str(self.cell_num_site) +; "",\nDegrees of freedom per site = "" +; str(; self.lattice_tensor_config[2:len(self.lattice_tensor_config)]) +; "",\nLattice tensor configuration = "" +; str(self.lattice_tensor_config) +; "",\nbasis_Hamiltonian = "" + str(self._H_intra) +; "",\ninter_hop = "" + str(self._H_inter_list) +; "",\ncell_tensor_config = "" + str(self.cell_tensor_config) +; ""\n""); if self.period_bnd_cond_x == 1:; s += ""Boundary Condition: Periodic""; else:; s += ""Boundary Condition: Hardwall""; return s. [docs] def Hamiltonian(self):; """"""; Returns the lattice Hamiltonian for the instance of Lattice1d. Returns; ----------; Qobj(Hamil) : qutip.Qobj; oper type Quantum object representing the lattice Hamiltonian.; """"""; D = qeye(self.num_cell); T = np.diag(np.zeros(self.num_cell-1)+1, 1); Tdag = np.diag(np.zeros(self.num_cell-1)+1, -1). if self.period_bnd_cond_x == 1 and self.num_cell > 2:; Tdag[0][self.num_cell-1] = 1; T[self.num_cell-1][0] = 1; T = Qobj(T); Tdag = Qobj(Tdag); Hamil = tensor(D, self._H_intra) + tensor(; T, self._H_inter) + tensor(Tdag, self._H_inter.dag()); dim_H = [self.lattice_tensor_config, self.lattice_tensor_config]; retu",MatchSource.WIKI,docs/4.7/modules/qutip/lattice.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/lattice.html
https://qutip.org/docs/4.7/modules/qutip/lattice.html:39416,Deployability,update,updated,39416,"ns_of_sites[; csn-1] + x_cell + self.positions_of_sites[0])/2. plt.text(x=x_b, y=0.1, s='T',; horizontalalignment='center',; verticalalignment='center'); if i == csn-1:; continue. for j in range(i+1, csn):. if (Hcell[i][j].full() == 0).all():; continue; c_cen = self.positions_of_sites[i]; c_cen = (c_cen+self.positions_of_sites[j])/2; c_cen = c_cen + x_cell. c_radius = self.positions_of_sites[j]; c_radius = (c_radius-self.positions_of_sites[i])/2. circle1 = plt.Circle((c_cen, 0),; c_radius, color='g', fill=False); ax.add_artist(circle1); if (self.period_bnd_cond_x == 1):; x_cell = 0; x_b = 2*x_cell-1+self.positions_of_sites[csn-1]; x_b = (x_b+self.positions_of_sites[0])/2. plt.text(x=x_b, y=0.1, s='T', horizontalalignment='center',; verticalalignment='center'); ax.plot([x_cell-1+self.positions_of_sites[csn-1],; x_cell+self.positions_of_sites[0]], [0.0, 0.0],; ""-"", c=""r"", lw=1.5, zorder=7). x_cell = self.num_cell; x_b = 2*x_cell-1+self.positions_of_sites[csn-1]; x_b = (x_b+self.positions_of_sites[0])/2. plt.text(x=x_b, y=0.1, s='T', horizontalalignment='center',; verticalalignment='center'); ax.plot([x_cell-1+self.positions_of_sites[csn-1],; x_cell+self.positions_of_sites[0]], [0.0, 0.0],; ""-"", c=""r"", lw=1.5, zorder=7). x2 = (1+self.positions_of_sites[csn-1])/2; x1 = x2-1; h = 0.5. if self.num_cell > 2:; xu = 1 # The index of cell over which the black box is drawn; x1 = x1+xu; x2 = x2+xu; ax.plot([x1, x1], [-h, h], ""-"", c=""k"", lw=1.5, zorder=7, alpha=0.3); ax.plot([x2, x2], [-h, h], ""-"", c=""k"", lw=1.5, zorder=7, alpha=0.3); ax.plot([x1, x2], [h, h], ""-"", c=""k"", lw=1.5, zorder=7, alpha=0.3); ax.plot([x1, x2], [-h, -h], ""-"", c=""k"", lw=1.5, zorder=7, alpha=0.3); plt.axis('off'); plt.show(); plt.close(); dims_site = [self.cell_site_dof, self.cell_site_dof]; return Qobj(inter_T, dims=dims_site). © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/modules/qutip/lattice.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/lattice.html
https://qutip.org/docs/4.7/modules/qutip/lattice.html:23009,Energy Efficiency,energy,energy,23009,"ots the dispersion relationship for the lattice with the specified; number of unit cells. The dispersion of the infinte crystal is also; plotted if num_cell is smaller than MAXc.; """"""; MAXc = 20 # Cell numbers above which we do not plot the infinite; # crystal dispersion; if self.period_bnd_cond_x == 0:; raise Exception(""The lattice is not periodic.""). if self.num_cell <= MAXc:; (kxA, val_ks) = self.get_dispersion(101); (knxA, val_kns) = self.get_dispersion(); fig, ax = plt.subplots(); if self.num_cell <= MAXc:; for g in range(self._length_of_unit_cell):; ax.plot(kxA/np.pi, val_ks[g, :]). for g in range(self._length_of_unit_cell):; if self.num_cell % 2 == 0:; ax.plot(np.append(knxA, [np.pi])/np.pi,; np.append(val_kns[g, :], val_kns[g, 0]), 'ro'); else:; ax.plot(knxA/np.pi, val_kns[g, :], 'ro'); ax.set_ylabel('Energy'); ax.set_xlabel(r'$k_x(\pi/a)$'); plt.show(fig); fig.savefig('./Dispersion.pdf'). [docs] def get_dispersion(self, knpoints=0):; """"""; Returns dispersion relationship for the lattice with the specified; number of unit cells with a k array and a band energy array. Returns; -------; knxa : np.array; knxA[j][0] is the jth good Quantum number k. val_kns : np.array; val_kns[j][:] is the array of band energies of the jth band good at; all the good Quantum numbers of k.; """"""; # The _k_space_calculations() function is not used for get_dispersion; # because we calculate the infinite crystal dispersion in; # plot_dispersion using this coode and we do not want to calculate; # all the eigen-values, eigenvectors of the bulk Hamiltonian for too; # many points, as is done in the _k_space_calculations() function.; if self.period_bnd_cond_x == 0:; raise Exception(""The lattice is not periodic.""); if knpoints == 0:; knpoints = self.num_cell. a = 1 # The unit cell length is always considered 1; kn_start = 0; kn_end = 2*np.pi/a; val_kns = np.zeros((self._length_of_unit_cell, knpoints), dtype=float); knxA = np.zeros((knpoints, 1), dtype=float); G0_H = self._H_intra; # knxA = n",MatchSource.WIKI,docs/4.7/modules/qutip/lattice.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/lattice.html
https://qutip.org/docs/4.7/modules/qutip/lattice.html:6241,Modifiability,coupling,coupling,6241,"("":cell(i+1) >""); llt = ''.join(llt); T_inter_cell_s[ir][jr] = llt. H_cell = np.zeros(np.shape(H_cell_s), dtype=complex); T_inter_cell = np.zeros(np.shape(T_inter_cell_s), dtype=complex); return (H_cell_s, T_inter_cell_s, H_cell, T_inter_cell). [docs]class Lattice1d():; """"""A class for representing a 1d crystal. The Lattice1d class can be defined with any specific unit cells and a; specified number of unit cells in the crystal. It can return dispersion; relationship, position operators, Hamiltonian in the position represention; etc. Parameters; ----------; num_cell : int; The number of cells in the crystal.; boundary : str; Specification of the type of boundary the crystal is defined with.; cell_num_site : int; The number of sites in the unit cell.; cell_site_dof : list of int/ int; The tensor structure of the degrees of freedom at each site of a unit; cell.; Hamiltonian_of_cell : qutip.Qobj; The Hamiltonian of the unit cell.; inter_hop : qutip.Qobj / list of Qobj; The coupling between the unit cell at i and at (i+unit vector). Attributes; ----------; num_cell : int; The number of unit cells in the crystal.; cell_num_site : int; The nuber of sites in a unit cell.; length_for_site : int; The length of the dimension per site of a unit cell.; cell_tensor_config : list of int; The tensor structure of the cell in the form; [cell_num_site,cell_site_dof[:][0] ]; lattice_tensor_config : list of int; The tensor structure of the crystal in the; form [num_cell,cell_num_site,cell_site_dof[:][0]]; length_of_unit_cell : int; The length of the dimension for a unit cell.; period_bnd_cond_x : int; 1 indicates ""periodic"" and 0 indicates ""hardwall"" boundary condition; inter_vec_list : list of list; The list of list of coefficients of inter unitcell vectors' components; along Cartesian uit vectors.; lattice_vectors_list : list of list; The list of list of coefficients of lattice basis vectors' components; along Cartesian unit vectors.; H_intra : qutip.Qobj; The Qobj storing the Hamilton",MatchSource.WIKI,docs/4.7/modules/qutip/lattice.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/lattice.html
https://qutip.org/docs/4.7/modules/qutip/lattice.html:7335,Modifiability,coupling,coupling,7335,"r of unit cells in the crystal.; cell_num_site : int; The nuber of sites in a unit cell.; length_for_site : int; The length of the dimension per site of a unit cell.; cell_tensor_config : list of int; The tensor structure of the cell in the form; [cell_num_site,cell_site_dof[:][0] ]; lattice_tensor_config : list of int; The tensor structure of the crystal in the; form [num_cell,cell_num_site,cell_site_dof[:][0]]; length_of_unit_cell : int; The length of the dimension for a unit cell.; period_bnd_cond_x : int; 1 indicates ""periodic"" and 0 indicates ""hardwall"" boundary condition; inter_vec_list : list of list; The list of list of coefficients of inter unitcell vectors' components; along Cartesian uit vectors.; lattice_vectors_list : list of list; The list of list of coefficients of lattice basis vectors' components; along Cartesian unit vectors.; H_intra : qutip.Qobj; The Qobj storing the Hamiltonian of the unnit cell.; H_inter_list : list of Qobj/ qutip.Qobj; The list of coupling terms between unit cells of the lattice.; is_real : bool; Indicates if the Hamiltonian is real or not.; """"""; def __init__(self, num_cell=10, boundary=""periodic"", cell_num_site=1,; cell_site_dof=[1], Hamiltonian_of_cell=None,; inter_hop=None):; self.num_cell = num_cell; self.cell_num_site = cell_num_site; if (not isinstance(cell_num_site, int)) or cell_num_site < 0:; raise Exception(""cell_num_site is required to be a positive \; integer.""). if isinstance(cell_site_dof, list):; l_v = 1; for i, csd_i in enumerate(cell_site_dof):; if (not isinstance(csd_i, int)) or csd_i < 0:; raise Exception(""Invalid cell_site_dof list element at \; index: "", i, ""Elements of cell_site_dof \; required to be positive integers.""); l_v = l_v * cell_site_dof[i]; self.cell_site_dof = cell_site_dof. elif isinstance(cell_site_dof, int):; if cell_site_dof < 0:; raise Exception(""cell_site_dof is required to be a positive \; integer.""); else:; l_v = cell_site_dof; self.cell_site_dof = [cell_site_dof]; else:; raise Exceptio",MatchSource.WIKI,docs/4.7/modules/qutip/lattice.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/lattice.html
https://qutip.org/docs/4.7/modules/qutip/lattice.html:13396,Modifiability,config,configuration,13396,"ell_num_site, cell_num_site-1); bN0 = basis(cell_num_site, 0); siteT = -bNm * bN0.dag(); inter_hop = tensor(Qobj(siteT), qeye(self.cell_site_dof)); dih = inter_hop.dims[0]; if all(x == 1 for x in dih):; dih = [1]; else:; while 1 in dih:; dih.remove(1); self._H_inter_list = [Qobj(inter_hop, dims=[dih, dih],; type='oper')]; self._H_inter = Qobj(inter_hop, dims=[dih, dih], type='oper'); else:; raise Exception(""inter_hop is required to be a Qobj or a \; list of Qobjs.""). self.positions_of_sites = [(i/self.cell_num_site) for i in; range(self.cell_num_site)]; self._inter_vec_list = [[1] for i in range(len(self._H_inter_list))]; self._Brav_lattice_vectors_list = [[1]] # unit vectors; self.is_real = is_real. def __repr__(self):; s = """"; s += (""Lattice1d object: "" +; ""Number of cells = "" + str(self.num_cell) +; "",\nNumber of sites in the cell = "" + str(self.cell_num_site) +; "",\nDegrees of freedom per site = "" +; str(; self.lattice_tensor_config[2:len(self.lattice_tensor_config)]) +; "",\nLattice tensor configuration = "" +; str(self.lattice_tensor_config) +; "",\nbasis_Hamiltonian = "" + str(self._H_intra) +; "",\ninter_hop = "" + str(self._H_inter_list) +; "",\ncell_tensor_config = "" + str(self.cell_tensor_config) +; ""\n""); if self.period_bnd_cond_x == 1:; s += ""Boundary Condition: Periodic""; else:; s += ""Boundary Condition: Hardwall""; return s. [docs] def Hamiltonian(self):; """"""; Returns the lattice Hamiltonian for the instance of Lattice1d. Returns; ----------; Qobj(Hamil) : qutip.Qobj; oper type Quantum object representing the lattice Hamiltonian.; """"""; D = qeye(self.num_cell); T = np.diag(np.zeros(self.num_cell-1)+1, 1); Tdag = np.diag(np.zeros(self.num_cell-1)+1, -1). if self.period_bnd_cond_x == 1 and self.num_cell > 2:; Tdag[0][self.num_cell-1] = 1; T[self.num_cell-1][0] = 1; T = Qobj(T); Tdag = Qobj(Tdag); Hamil = tensor(D, self._H_intra) + tensor(; T, self._H_inter) + tensor(Tdag, self._H_inter.dag()); dim_H = [self.lattice_tensor_config, self.lattice_tensor_config]; retu",MatchSource.WIKI,docs/4.7/modules/qutip/lattice.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/lattice.html
https://qutip.org/docs/4.7/modules/qutip/lattice.html:35888,Modifiability,coupling,coupling,35888,"radius = (self.positions_of_sites[; j]-self.positions_of_sites[i])/2. circle1 = plt.Circle((c_cen, 0), c_radius, color='g',; fill=False); ax.add_artist(circle1); if label_on is True:; x_b = c_cen; y_b = c_radius - 0.025; plt.text(x=x_b, y=y_b, s='H'+str(i)+str(j),; horizontalalignment='center',; verticalalignment='center'); x2 = (1+self.positions_of_sites[CNS-1])/2; x1 = x2-1; h = (self.positions_of_sites[; CNS-1]-self.positions_of_sites[0])*8/15; ax.plot([x1, x1], [-h, h], ""-"", c=""k"", lw=1.5, zorder=7); ax.plot([x2, x2], [-h, h], ""-"", c=""k"", lw=1.5, zorder=7); ax.plot([x1, x2], [h, h], ""-"", c=""k"", lw=1.5, zorder=7); ax.plot([x1, x2], [-h, -h], ""-"", c=""k"", lw=1.5, zorder=7); plt.axis('off'); plt.show(); plt.close(); return Hcell. [docs] def display_lattice(self):; r""""""; Produces a graphic portraying the lattice symbolically with a unit cell; marked in it. Returns; -------; inter_T : Qobj; The coefficient of $\psi_{i,N}^{\dagger}\psi_{0,i+1}$, i.e. the; coupling between the two boundary sites of the two unit cells i and; i+1.; """"""; dim_I = [self.cell_tensor_config, self.cell_tensor_config]; H_inter = Qobj(np.zeros((self._length_of_unit_cell,; self._length_of_unit_cell)), dims=dim_I); for no, inter_hop_no in enumerate(self._H_inter_list):; H_inter = H_inter + inter_hop_no. H_inter = np.array(H_inter); csn = self.cell_num_site; Hcell = [[{} for i in range(csn)] for j in range(csn)]. for i0 in range(csn):; for j0 in range(csn):; Qin = np.zeros((self._length_for_site, self._length_for_site),; dtype=complex); for i in range(self._length_for_site):; for j in range(self._length_for_site):; Qin[i, j] = self._H_intra[; i0*self._length_for_site+i,; j0*self._length_for_site+j]; dims_site = [self.cell_site_dof, self.cell_site_dof]; Hcell[i0][j0] = Qobj(Qin, dims=dims_site). j0 = 0; i0 = csn-1; Qin = np.zeros((self._length_for_site, self._length_for_site),; dtype=complex); for i in range(self._length_for_site):; for j in range(self._length_for_site):; Qin[i, j] = H_inter[i0*self._",MatchSource.WIKI,docs/4.7/modules/qutip/lattice.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/lattice.html
https://qutip.org/docs/4.7/modules/qutip/matplotlib_utilities.html:4979,Deployability,update,updated,4979,"interpolate colors; for k in range(0, levels):; if k < zero_pos:; interp = k / (num_neg + 1.0); adjust_RGBA[k][0:3] = (1.0 - interp) * \; min_color[0:3] + interp * neg_color[0:3]; elif k > zero_pos:; interp = (k - zero_pos) / (num_pos + 1.0); adjust_RGBA[k][0:3] = (1.0 - interp) * \; mid_color[0:3] + interp * max_color[0:3]; # create colormap; wig_cmap = mpl.colors.LinearSegmentedColormap.from_list('wigner_cmap',; adjust_RGBA,; N=levels); return wig_cmap. [docs]def complex_phase_cmap():; """"""; Create a cyclic colormap for representing the phase of complex variables. Returns; -------; cmap :; A matplotlib linear segmented colormap.; """"""; cdict = {'blue': ((0.00, 0.0, 0.0),; (0.25, 0.0, 0.0),; (0.50, 1.0, 1.0),; (0.75, 1.0, 1.0),; (1.00, 0.0, 0.0)),; 'green': ((0.00, 0.0, 0.0),; (0.25, 1.0, 1.0),; (0.50, 0.0, 0.0),; (0.75, 1.0, 1.0),; (1.00, 0.0, 0.0)),; 'red': ((0.00, 1.0, 1.0),; (0.25, 0.5, 0.5),; (0.50, 0.0, 0.0),; (0.75, 0.0, 0.0),; (1.00, 1.0, 1.0))}. cmap = mpl.colors.LinearSegmentedColormap('phase_colormap', cdict, 256). return cmap. class MidpointNorm(Normalize):; """"""Normalization for a colormap centered about a given midpoint. Parameters; ----------; midpoint : float (optional, default=0); Midpoint about which colormap is centered.; vmin: float (optional); Minimal value for colormap. Calculated from data by default.; vmax: float (optional); Maximal value for colormap. Calculated from data by default. Returns; -------; Returns a Matplotlib colormap normalization that can be used; with any colormap. """""". def __init__(self, midpoint=0, vmin=None, vmax=None, clip=False):; self.midpoint = midpoint; Normalize.__init__(self, vmin, vmax, clip). def __call__(self, value, clip=None):; x, y = [self.vmin, self.midpoint, self.vmax], [0, 0.5, 1]; return np.ma.masked_array(np.interp(value, x, y)). © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/modules/qutip/matplotlib_utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/matplotlib_utilities.html
https://qutip.org/docs/4.7/modules/qutip/matplotlib_utilities.html:3839,Energy Efficiency,green,green,3839,")), np.ones((levels, 1)))); zero_pos = int(np.round(levels * np.abs(shift - bounds[0]); / (bounds[1] - bounds[0]))); num_pos = levels - zero_pos; num_neg = zero_pos - 1; # set zero values to mid_color; adjust_RGBA[zero_pos] = mid_color; # interpolate colors; for k in range(0, levels):; if k < zero_pos:; interp = k / (num_neg + 1.0); adjust_RGBA[k][0:3] = (1.0 - interp) * \; min_color[0:3] + interp * neg_color[0:3]; elif k > zero_pos:; interp = (k - zero_pos) / (num_pos + 1.0); adjust_RGBA[k][0:3] = (1.0 - interp) * \; mid_color[0:3] + interp * max_color[0:3]; # create colormap; wig_cmap = mpl.colors.LinearSegmentedColormap.from_list('wigner_cmap',; adjust_RGBA,; N=levels); return wig_cmap. [docs]def complex_phase_cmap():; """"""; Create a cyclic colormap for representing the phase of complex variables. Returns; -------; cmap :; A matplotlib linear segmented colormap.; """"""; cdict = {'blue': ((0.00, 0.0, 0.0),; (0.25, 0.0, 0.0),; (0.50, 1.0, 1.0),; (0.75, 1.0, 1.0),; (1.00, 0.0, 0.0)),; 'green': ((0.00, 0.0, 0.0),; (0.25, 1.0, 1.0),; (0.50, 0.0, 0.0),; (0.75, 1.0, 1.0),; (1.00, 0.0, 0.0)),; 'red': ((0.00, 1.0, 1.0),; (0.25, 0.5, 0.5),; (0.50, 0.0, 0.0),; (0.75, 0.0, 0.0),; (1.00, 1.0, 1.0))}. cmap = mpl.colors.LinearSegmentedColormap('phase_colormap', cdict, 256). return cmap. class MidpointNorm(Normalize):; """"""Normalization for a colormap centered about a given midpoint. Parameters; ----------; midpoint : float (optional, default=0); Midpoint about which colormap is centered.; vmin: float (optional); Minimal value for colormap. Calculated from data by default.; vmax: float (optional); Maximal value for colormap. Calculated from data by default. Returns; -------; Returns a Matplotlib colormap normalization that can be used; with any colormap. """""". def __init__(self, midpoint=0, vmin=None, vmax=None, clip=False):; self.midpoint = midpoint; Normalize.__init__(self, vmin, vmax, clip). def __call__(self, value, clip=None):; x, y = [self.vmin, self.midpoint, self.vmax], [0, 0.",MatchSource.WIKI,docs/4.7/modules/qutip/matplotlib_utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/matplotlib_utilities.html
https://qutip.org/docs/4.7/modules/qutip/matplotlib_utilities.html:434,Modifiability,enhance,enhance,434,". qutip.matplotlib_utilities — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.matplotlib_utilities. Source code for qutip.matplotlib_utilities; """"""; This module contains utility functions that enhance Matplotlib; in one way or another.; """""". __all__ = ['wigner_cmap', 'MidpointNorm', 'complex_phase_cmap']. import numpy as np. try:; import matplotlib as mpl; from matplotlib import cm; from matplotlib.colors import (Normalize, ColorConverter); except:; class Normalize(object):; def __init__(self, vmin=None, vmax=None, clip=False):; pass. [docs]def wigner_cmap(W, levels=1024, shift=0, max_color='#09224F',; mid_color='#FFFFFF', min_color='#530017',; neg_color='#FF97D4', invert=False):; """"""A custom colormap that emphasizes negative values by creating a; nonlinear colormap. Parameters; ----------; W : array; Wigner function array, or any array.; levels : int; Number of color levels to create.; shift : float; Shifts the value at which Wigner elements are emphasized.; This parameter should typically be negative and small (i.e -1e-5).; max_color : str; String for color corresponding to maximum value of data. Accepts; any string format compatible with the Matplotlib.colors.ColorConverter.; mid_color : str; Color corresponding to zero values. Accepts any string format; compatible with the Matplotlib.colors.ColorConverter.; min_color : str; Color corresponding to minimum data values. Accepts any string format; compatible with the Matplotlib.colors.ColorConverter.; neg_color : str; Color that starts highlighting negative values. Accepts any string; format compatible with the Matplotlib.colors.ColorConverter.; invert : bool; Invert the color scheme for negative values so that smaller negative; values have darker color. Returns; -------; Returns ",MatchSource.WIKI,docs/4.7/modules/qutip/matplotlib_utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/matplotlib_utilities.html
https://qutip.org/docs/4.7/modules/qutip/matplotlib_utilities.html:3641,Modifiability,variab,variables,3641,"gba(min_color), dtype=float); neg_color = np.array(cc.to_rgba(neg_color), dtype=float); # get min and max values from Wigner function; bounds = [W.min(), W.max()]; # create empty array for RGBA colors; adjust_RGBA = np.hstack((np.zeros((levels, 3)), np.ones((levels, 1)))); zero_pos = int(np.round(levels * np.abs(shift - bounds[0]); / (bounds[1] - bounds[0]))); num_pos = levels - zero_pos; num_neg = zero_pos - 1; # set zero values to mid_color; adjust_RGBA[zero_pos] = mid_color; # interpolate colors; for k in range(0, levels):; if k < zero_pos:; interp = k / (num_neg + 1.0); adjust_RGBA[k][0:3] = (1.0 - interp) * \; min_color[0:3] + interp * neg_color[0:3]; elif k > zero_pos:; interp = (k - zero_pos) / (num_pos + 1.0); adjust_RGBA[k][0:3] = (1.0 - interp) * \; mid_color[0:3] + interp * max_color[0:3]; # create colormap; wig_cmap = mpl.colors.LinearSegmentedColormap.from_list('wigner_cmap',; adjust_RGBA,; N=levels); return wig_cmap. [docs]def complex_phase_cmap():; """"""; Create a cyclic colormap for representing the phase of complex variables. Returns; -------; cmap :; A matplotlib linear segmented colormap.; """"""; cdict = {'blue': ((0.00, 0.0, 0.0),; (0.25, 0.0, 0.0),; (0.50, 1.0, 1.0),; (0.75, 1.0, 1.0),; (1.00, 0.0, 0.0)),; 'green': ((0.00, 0.0, 0.0),; (0.25, 1.0, 1.0),; (0.50, 0.0, 0.0),; (0.75, 1.0, 1.0),; (1.00, 0.0, 0.0)),; 'red': ((0.00, 1.0, 1.0),; (0.25, 0.5, 0.5),; (0.50, 0.0, 0.0),; (0.75, 0.0, 0.0),; (1.00, 1.0, 1.0))}. cmap = mpl.colors.LinearSegmentedColormap('phase_colormap', cdict, 256). return cmap. class MidpointNorm(Normalize):; """"""Normalization for a colormap centered about a given midpoint. Parameters; ----------; midpoint : float (optional, default=0); Midpoint about which colormap is centered.; vmin: float (optional); Minimal value for colormap. Calculated from data by default.; vmax: float (optional); Maximal value for colormap. Calculated from data by default. Returns; -------; Returns a Matplotlib colormap normalization that can be used; with ",MatchSource.WIKI,docs/4.7/modules/qutip/matplotlib_utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/matplotlib_utilities.html
https://qutip.org/docs/4.7/modules/qutip/mcsolve.html:485,Deployability,integrat,integrate,485,". qutip.mcsolve — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.mcsolve. Source code for qutip.mcsolve; __all__ = ['mcsolve']. import os; import numpy as np; from numpy.random import RandomState, randint; import scipy.sparse as sp; from scipy.integrate import ode; from scipy.integrate._ode import zvode. from types import FunctionType, BuiltinFunctionType; from functools import partial; from qutip.fastsparse import csr2fast; from qutip.qobj import Qobj; from qutip.qobjevo import QobjEvo; from qutip.parallel import parfor, parallel_map, serial_map; from qutip.cy.mcsolve import CyMcOde, CyMcOdeDiag; from qutip.cy.spconvert import dense1D_to_fastcsr_ket; from qutip.sesolve import sesolve; from qutip.solver import (Options, Result, ExpectOps,; solver_safe, SolverSystem); from qutip.settings import debug; from qutip.ui.progressbar import TextProgressBar, BaseProgressBar; import qutip.settings. if debug:; import inspect. #; # Internal, global variables for storing references to dynamically loaded; # cython functions. # Todo: use real warning; def warn(text):; print(text). class qutip_zvode(zvode):; def step(self, *args):; itask = self.call_args[2]; self.rwork[0] = args[4]; self.call_args[2] = 5; r = self.run(*args); self.call_args[2] = itask; return r. [docs]def mcsolve(H, psi0, tlist, c_ops=[], e_ops=[], ntraj=0,; args={}, options=None, progress_bar=True,; map_func=parallel_map, map_kwargs={}, _safe_mode=True):; r""""""Monte Carlo evolution of a state vector :math:`|\psi \rangle` for a; given Hamiltonian and sets of collapse operators, and possibly, operators; for calculating expectation values. Options for the underlying ODE solver; are given by the Options class. mcsolve supports time-dependent Hamiltonians and collapse operators using;",MatchSource.WIKI,docs/4.7/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/mcsolve.html
https://qutip.org/docs/4.7/modules/qutip/mcsolve.html:518,Deployability,integrat,integrate,518,". qutip.mcsolve — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.mcsolve. Source code for qutip.mcsolve; __all__ = ['mcsolve']. import os; import numpy as np; from numpy.random import RandomState, randint; import scipy.sparse as sp; from scipy.integrate import ode; from scipy.integrate._ode import zvode. from types import FunctionType, BuiltinFunctionType; from functools import partial; from qutip.fastsparse import csr2fast; from qutip.qobj import Qobj; from qutip.qobjevo import QobjEvo; from qutip.parallel import parfor, parallel_map, serial_map; from qutip.cy.mcsolve import CyMcOde, CyMcOdeDiag; from qutip.cy.spconvert import dense1D_to_fastcsr_ket; from qutip.sesolve import sesolve; from qutip.solver import (Options, Result, ExpectOps,; solver_safe, SolverSystem); from qutip.settings import debug; from qutip.ui.progressbar import TextProgressBar, BaseProgressBar; import qutip.settings. if debug:; import inspect. #; # Internal, global variables for storing references to dynamically loaded; # cython functions. # Todo: use real warning; def warn(text):; print(text). class qutip_zvode(zvode):; def step(self, *args):; itask = self.call_args[2]; self.rwork[0] = args[4]; self.call_args[2] = 5; r = self.run(*args); self.call_args[2] = itask; return r. [docs]def mcsolve(H, psi0, tlist, c_ops=[], e_ops=[], ntraj=0,; args={}, options=None, progress_bar=True,; map_func=parallel_map, map_kwargs={}, _safe_mode=True):; r""""""Monte Carlo evolution of a state vector :math:`|\psi \rangle` for a; given Hamiltonian and sets of collapse operators, and possibly, operators; for calculating expectation values. Options for the underlying ODE solver; are given by the Options class. mcsolve supports time-dependent Hamiltonians and collapse operators using;",MatchSource.WIKI,docs/4.7/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/mcsolve.html
https://qutip.org/docs/4.7/modules/qutip/mcsolve.html:10452,Deployability,update,update,10452,"rn. if args and args != self.ss.args:; self.ss.set_args(self.ss, args); self.reset(). if e_ops and e_ops != self.e_ops:; self.set_e_ops(e_ops); self.reset(). if psi0 is not None and psi0 != self.psi0:; self.psi0 = psi0; self.reset(). tlist = np.array(tlist); if tlist is not None and np.all(tlist != self.tlist):; self.tlist = tlist; self.reset(). if self.ran:; if options.store_states and self._psi_out[0].shape[0] == 1:; self.reset(); else:; # if not reset here, add trajectories; self.add_traj(num_traj, progress_bar, map_func, map_kwargs); return. if not num_traj:; num_traj = options.ntraj. if options.num_cpus == 1 or num_traj == 1:; map_func = serial_map. if len(self.seeds) != num_traj:; self.seed(num_traj, self.seeds). if not progress_bar:; progress_bar = BaseProgressBar(); elif progress_bar is True:; progress_bar = TextProgressBar(). # set arguments for input to monte carlo; map_kwargs_ = {'progress_bar': progress_bar,; 'num_cpus': options.num_cpus}; map_kwargs_.update(map_kwargs); map_kwargs = map_kwargs_. if self.e_ops is None:; self.set_e_ops(). if self.ss.type == ""Diagonal"":; results = map_func(self._single_traj_diag, list(range(num_traj)),; **map_kwargs); else:; results = map_func(self._single_traj, list(range(num_traj)),; **map_kwargs). self.t = self.tlist[-1]; self.num_traj = num_traj; self.ran = True. for result in results:; state_out, ss_out, expect, collapse = result; self._psi_out.append(state_out); self._ss_out.append(ss_out); self._expect_out.append(expect); self._collapse.append(collapse); self._psi_out = np.stack(self._psi_out); self._ss_out = np.stack(self._ss_out). def add_traj(self, num_traj,; progress_bar=True,; map_func=parallel_map, map_kwargs={}):; raise NotImplementedError. def continue_runs(self, num_traj, tlist, args={}, e_ops=[], options=None,; progress_bar=True,; map_func=parallel_map, map_kwargs={}):; raise NotImplementedError. # --------------------------------------------------------------------------; # results functions; # -----------",MatchSource.WIKI,docs/4.7/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/mcsolve.html
https://qutip.org/docs/4.7/modules/qutip/mcsolve.html:16646,Deployability,integrat,integration,16646,"----------------------------; # single-trajectory for monte carlo; # --------------------------------------------------------------------------; def _single_traj(self, nt):; """"""; Monte Carlo algorithm returning state-vector or expectation values; at times tlist for a single trajectory.; """"""; # SEED AND RNG AND GENERATE; prng = RandomState(self.seeds[nt]); opt = self.options. # set initial conditions; ss = self.ss; tlist = self.tlist; e_ops = self.e_ops.copy(); opt = self.options; rhs, ode_args = self.ss.makefunc(ss); ODE = self._build_integration_func(rhs, ode_args, opt); ODE.set_initial_value(self.initial_vector, tlist[0]); e_ops.init(tlist). cymc = CyMcOde(ss, opt); states_out, ss_out, collapses = cymc.run_ode(ODE, tlist, e_ops, prng). # Run at end of mc_alg function; # -----------------------------; if opt.steady_state_average:; ss_out /= float(len(tlist)). return (states_out, ss_out, e_ops, collapses). def _build_integration_func(self, rhs, ode_args, opt):; """"""; Create the integration function while fixing the parameters; """"""; ODE = ode(rhs); if ode_args:; ODE.set_f_params(ode_args); # initialize ODE solver for RHS; ODE.set_integrator('zvode', method=""adams""); ODE._integrator = qutip_zvode(; method=opt.method, order=opt.order, atol=opt.atol,; rtol=opt.rtol, nsteps=opt.nsteps, first_step=opt.first_step,; min_step=opt.min_step, max_step=opt.max_step); return ODE. # --------------------------------------------------------------------------; # In development diagonalize the Hamiltonian before solving; # Same seeds give same evolution; # 3~5 time faster; # constant system only.; # --------------------------------------------------------------------------; def make_diag_system(self, H, c_ops):; ss = SolverSystem(); ss.td_c_ops = []; ss.td_n_ops = []. H_ = H.copy(); H_ *= -1j; for c in c_ops:; H_ += -0.5 * c.dag() * c. w, v = np.linalg.eig(H_.full()); arg = np.argsort(np.abs(w)); eig = w[arg]; U = v.T[arg].T; Ud = U.T.conj(). for c in c_ops:; c_diag = Qobj(Ud @ c.full(",MatchSource.WIKI,docs/4.7/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/mcsolve.html
https://qutip.org/docs/4.7/modules/qutip/mcsolve.html:20788,Deployability,update,updated,20788,"----------------------------------------------------------------------------; def _qobjevo_set(ss, psi0=None, args={}, opt=None):; if args:; self.set_args(args); rhs = ss.H_td.compiled_qobjevo.mul_vec; return rhs, (). def _qobjevo_args(ss, args):; var = _collapse_args(args); ss.col_args = var; ss.args = args; ss.H_td.solver_set_args(args, psi0, e_ops); for c in ss.td_c_ops:; c.solver_set_args(args, psi0, e_ops); for c in ss.td_n_ops:; c.solver_set_args(args, psi0, e_ops). def _func_set(HS, psi0=None, args={}, opt=None):; if args:; self.set_args(args); else:; args = ss.args; if ss.with_state:; rhs = _funcrhs; else:; rhs = _funcrhs_with_state; return rhs, (ss.h_func, ss.Hc_td, args). def _func_args(ss, args):; var = _collapse_args(args); ss.col_args = var; ss.args = args; for c in ss.td_c_ops:; c.solver_set_args(args, psi0, e_ops); for c in ss.td_n_ops:; c.solver_set_args(args, psi0, e_ops); return rhs, (ss.h_func, ss.Hc_td, args). # RHS of ODE for python function Hamiltonian; def _funcrhs(t, psi, h_func, Hc_td, args):; h_func_data = -1.0j * h_func(t, args).data; h_func_term = h_func_data * psi; return h_func_term + Hc_td.mul_vec(t, psi). def _funcrhs_with_state(t, psi, h_func, Hc_td, args):; h_func_data = - 1.0j * h_func(t, psi, args).data; h_func_term = h_func_data * psi; return h_func_term + Hc_td.mul_vec(t, psi). def _mc_dm_avg(psi_list):; """"""; Private function that averages density matrices in parallel; over all trajectories for a single time using parfor.; """"""; ln = len(psi_list); dims = psi_list[0].dims; shape = psi_list[0].shape; out_data = sum([psi.data for psi in psi_list]) / ln; return Qobj(out_data, dims=dims, shape=shape, fast='mc-dm'). def _collapse_args(args):; for key in args:; if key == ""collapse"":; if not isinstance(args[key], list):; args[key] = []; return key; return """". © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/mcsolve.html
https://qutip.org/docs/4.7/modules/qutip/mcsolve.html:485,Integrability,integrat,integrate,485,". qutip.mcsolve — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.mcsolve. Source code for qutip.mcsolve; __all__ = ['mcsolve']. import os; import numpy as np; from numpy.random import RandomState, randint; import scipy.sparse as sp; from scipy.integrate import ode; from scipy.integrate._ode import zvode. from types import FunctionType, BuiltinFunctionType; from functools import partial; from qutip.fastsparse import csr2fast; from qutip.qobj import Qobj; from qutip.qobjevo import QobjEvo; from qutip.parallel import parfor, parallel_map, serial_map; from qutip.cy.mcsolve import CyMcOde, CyMcOdeDiag; from qutip.cy.spconvert import dense1D_to_fastcsr_ket; from qutip.sesolve import sesolve; from qutip.solver import (Options, Result, ExpectOps,; solver_safe, SolverSystem); from qutip.settings import debug; from qutip.ui.progressbar import TextProgressBar, BaseProgressBar; import qutip.settings. if debug:; import inspect. #; # Internal, global variables for storing references to dynamically loaded; # cython functions. # Todo: use real warning; def warn(text):; print(text). class qutip_zvode(zvode):; def step(self, *args):; itask = self.call_args[2]; self.rwork[0] = args[4]; self.call_args[2] = 5; r = self.run(*args); self.call_args[2] = itask; return r. [docs]def mcsolve(H, psi0, tlist, c_ops=[], e_ops=[], ntraj=0,; args={}, options=None, progress_bar=True,; map_func=parallel_map, map_kwargs={}, _safe_mode=True):; r""""""Monte Carlo evolution of a state vector :math:`|\psi \rangle` for a; given Hamiltonian and sets of collapse operators, and possibly, operators; for calculating expectation values. Options for the underlying ODE solver; are given by the Options class. mcsolve supports time-dependent Hamiltonians and collapse operators using;",MatchSource.WIKI,docs/4.7/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/mcsolve.html
https://qutip.org/docs/4.7/modules/qutip/mcsolve.html:518,Integrability,integrat,integrate,518,". qutip.mcsolve — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.mcsolve. Source code for qutip.mcsolve; __all__ = ['mcsolve']. import os; import numpy as np; from numpy.random import RandomState, randint; import scipy.sparse as sp; from scipy.integrate import ode; from scipy.integrate._ode import zvode. from types import FunctionType, BuiltinFunctionType; from functools import partial; from qutip.fastsparse import csr2fast; from qutip.qobj import Qobj; from qutip.qobjevo import QobjEvo; from qutip.parallel import parfor, parallel_map, serial_map; from qutip.cy.mcsolve import CyMcOde, CyMcOdeDiag; from qutip.cy.spconvert import dense1D_to_fastcsr_ket; from qutip.sesolve import sesolve; from qutip.solver import (Options, Result, ExpectOps,; solver_safe, SolverSystem); from qutip.settings import debug; from qutip.ui.progressbar import TextProgressBar, BaseProgressBar; import qutip.settings. if debug:; import inspect. #; # Internal, global variables for storing references to dynamically loaded; # cython functions. # Todo: use real warning; def warn(text):; print(text). class qutip_zvode(zvode):; def step(self, *args):; itask = self.call_args[2]; self.rwork[0] = args[4]; self.call_args[2] = 5; r = self.run(*args); self.call_args[2] = itask; return r. [docs]def mcsolve(H, psi0, tlist, c_ops=[], e_ops=[], ntraj=0,; args={}, options=None, progress_bar=True,; map_func=parallel_map, map_kwargs={}, _safe_mode=True):; r""""""Monte Carlo evolution of a state vector :math:`|\psi \rangle` for a; given Hamiltonian and sets of collapse operators, and possibly, operators; for calculating expectation values. Options for the underlying ODE solver; are given by the Options class. mcsolve supports time-dependent Hamiltonians and collapse operators using;",MatchSource.WIKI,docs/4.7/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/mcsolve.html
https://qutip.org/docs/4.7/modules/qutip/mcsolve.html:1949,Integrability,depend,dependent,1949,", SolverSystem); from qutip.settings import debug; from qutip.ui.progressbar import TextProgressBar, BaseProgressBar; import qutip.settings. if debug:; import inspect. #; # Internal, global variables for storing references to dynamically loaded; # cython functions. # Todo: use real warning; def warn(text):; print(text). class qutip_zvode(zvode):; def step(self, *args):; itask = self.call_args[2]; self.rwork[0] = args[4]; self.call_args[2] = 5; r = self.run(*args); self.call_args[2] = itask; return r. [docs]def mcsolve(H, psi0, tlist, c_ops=[], e_ops=[], ntraj=0,; args={}, options=None, progress_bar=True,; map_func=parallel_map, map_kwargs={}, _safe_mode=True):; r""""""Monte Carlo evolution of a state vector :math:`|\psi \rangle` for a; given Hamiltonian and sets of collapse operators, and possibly, operators; for calculating expectation values. Options for the underlying ODE solver; are given by the Options class. mcsolve supports time-dependent Hamiltonians and collapse operators using; either Python functions of strings to represent time-dependent; coefficients. Note that, the system Hamiltonian MUST have at least one; constant term. As an example of a time-dependent problem, consider a Hamiltonian with two; terms ``H0`` and ``H1``, where ``H1`` is time-dependent with coefficient; ``sin(w*t)``, and collapse operators ``C0`` and ``C1``, where ``C1`` is; time-dependent with coeffcient ``exp(-a*t)``. Here, w and a are constant; arguments with values ``W`` and ``A``. Using the Python function time-dependent format requires two Python; functions, one for each collapse coefficient. Therefore, this problem could; be expressed as::. def H1_coeff(t,args):; return sin(args['w']*t). def C1_coeff(t,args):; return exp(-args['a']*t). H = [H0, [H1, H1_coeff]]. c_ops = [C0, [C1, C1_coeff]]. args={'a': A, 'w': W}. or in String (Cython) format we could write::. H = [H0, [H1, 'sin(w*t)']]. c_ops = [C0, [C1, 'exp(-a*t)']]. args={'a': A, 'w': W}. Constant terms are preferably placed first",MatchSource.WIKI,docs/4.7/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/mcsolve.html
https://qutip.org/docs/4.7/modules/qutip/mcsolve.html:2055,Integrability,depend,dependent,2055,", SolverSystem); from qutip.settings import debug; from qutip.ui.progressbar import TextProgressBar, BaseProgressBar; import qutip.settings. if debug:; import inspect. #; # Internal, global variables for storing references to dynamically loaded; # cython functions. # Todo: use real warning; def warn(text):; print(text). class qutip_zvode(zvode):; def step(self, *args):; itask = self.call_args[2]; self.rwork[0] = args[4]; self.call_args[2] = 5; r = self.run(*args); self.call_args[2] = itask; return r. [docs]def mcsolve(H, psi0, tlist, c_ops=[], e_ops=[], ntraj=0,; args={}, options=None, progress_bar=True,; map_func=parallel_map, map_kwargs={}, _safe_mode=True):; r""""""Monte Carlo evolution of a state vector :math:`|\psi \rangle` for a; given Hamiltonian and sets of collapse operators, and possibly, operators; for calculating expectation values. Options for the underlying ODE solver; are given by the Options class. mcsolve supports time-dependent Hamiltonians and collapse operators using; either Python functions of strings to represent time-dependent; coefficients. Note that, the system Hamiltonian MUST have at least one; constant term. As an example of a time-dependent problem, consider a Hamiltonian with two; terms ``H0`` and ``H1``, where ``H1`` is time-dependent with coefficient; ``sin(w*t)``, and collapse operators ``C0`` and ``C1``, where ``C1`` is; time-dependent with coeffcient ``exp(-a*t)``. Here, w and a are constant; arguments with values ``W`` and ``A``. Using the Python function time-dependent format requires two Python; functions, one for each collapse coefficient. Therefore, this problem could; be expressed as::. def H1_coeff(t,args):; return sin(args['w']*t). def C1_coeff(t,args):; return exp(-args['a']*t). H = [H0, [H1, H1_coeff]]. c_ops = [C0, [C1, C1_coeff]]. args={'a': A, 'w': W}. or in String (Cython) format we could write::. H = [H0, [H1, 'sin(w*t)']]. c_ops = [C0, [C1, 'exp(-a*t)']]. args={'a': A, 'w': W}. Constant terms are preferably placed first",MatchSource.WIKI,docs/4.7/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/mcsolve.html
https://qutip.org/docs/4.7/modules/qutip/mcsolve.html:2177,Integrability,depend,dependent,2177,"arning; def warn(text):; print(text). class qutip_zvode(zvode):; def step(self, *args):; itask = self.call_args[2]; self.rwork[0] = args[4]; self.call_args[2] = 5; r = self.run(*args); self.call_args[2] = itask; return r. [docs]def mcsolve(H, psi0, tlist, c_ops=[], e_ops=[], ntraj=0,; args={}, options=None, progress_bar=True,; map_func=parallel_map, map_kwargs={}, _safe_mode=True):; r""""""Monte Carlo evolution of a state vector :math:`|\psi \rangle` for a; given Hamiltonian and sets of collapse operators, and possibly, operators; for calculating expectation values. Options for the underlying ODE solver; are given by the Options class. mcsolve supports time-dependent Hamiltonians and collapse operators using; either Python functions of strings to represent time-dependent; coefficients. Note that, the system Hamiltonian MUST have at least one; constant term. As an example of a time-dependent problem, consider a Hamiltonian with two; terms ``H0`` and ``H1``, where ``H1`` is time-dependent with coefficient; ``sin(w*t)``, and collapse operators ``C0`` and ``C1``, where ``C1`` is; time-dependent with coeffcient ``exp(-a*t)``. Here, w and a are constant; arguments with values ``W`` and ``A``. Using the Python function time-dependent format requires two Python; functions, one for each collapse coefficient. Therefore, this problem could; be expressed as::. def H1_coeff(t,args):; return sin(args['w']*t). def C1_coeff(t,args):; return exp(-args['a']*t). H = [H0, [H1, H1_coeff]]. c_ops = [C0, [C1, C1_coeff]]. args={'a': A, 'w': W}. or in String (Cython) format we could write::. H = [H0, [H1, 'sin(w*t)']]. c_ops = [C0, [C1, 'exp(-a*t)']]. args={'a': A, 'w': W}. Constant terms are preferably placed first in the Hamiltonian and collapse; operator lists. Parameters; ----------; H : :class:`qutip.Qobj`, ``list``; System Hamiltonian. psi0 : :class:`qutip.Qobj`; Initial state vector. tlist : array_like; Times at which results are recorded. ntraj : int; Number of trajectories to run. c_op",MatchSource.WIKI,docs/4.7/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/mcsolve.html
https://qutip.org/docs/4.7/modules/qutip/mcsolve.html:2275,Integrability,depend,dependent,2275,"arning; def warn(text):; print(text). class qutip_zvode(zvode):; def step(self, *args):; itask = self.call_args[2]; self.rwork[0] = args[4]; self.call_args[2] = 5; r = self.run(*args); self.call_args[2] = itask; return r. [docs]def mcsolve(H, psi0, tlist, c_ops=[], e_ops=[], ntraj=0,; args={}, options=None, progress_bar=True,; map_func=parallel_map, map_kwargs={}, _safe_mode=True):; r""""""Monte Carlo evolution of a state vector :math:`|\psi \rangle` for a; given Hamiltonian and sets of collapse operators, and possibly, operators; for calculating expectation values. Options for the underlying ODE solver; are given by the Options class. mcsolve supports time-dependent Hamiltonians and collapse operators using; either Python functions of strings to represent time-dependent; coefficients. Note that, the system Hamiltonian MUST have at least one; constant term. As an example of a time-dependent problem, consider a Hamiltonian with two; terms ``H0`` and ``H1``, where ``H1`` is time-dependent with coefficient; ``sin(w*t)``, and collapse operators ``C0`` and ``C1``, where ``C1`` is; time-dependent with coeffcient ``exp(-a*t)``. Here, w and a are constant; arguments with values ``W`` and ``A``. Using the Python function time-dependent format requires two Python; functions, one for each collapse coefficient. Therefore, this problem could; be expressed as::. def H1_coeff(t,args):; return sin(args['w']*t). def C1_coeff(t,args):; return exp(-args['a']*t). H = [H0, [H1, H1_coeff]]. c_ops = [C0, [C1, C1_coeff]]. args={'a': A, 'w': W}. or in String (Cython) format we could write::. H = [H0, [H1, 'sin(w*t)']]. c_ops = [C0, [C1, 'exp(-a*t)']]. args={'a': A, 'w': W}. Constant terms are preferably placed first in the Hamiltonian and collapse; operator lists. Parameters; ----------; H : :class:`qutip.Qobj`, ``list``; System Hamiltonian. psi0 : :class:`qutip.Qobj`; Initial state vector. tlist : array_like; Times at which results are recorded. ntraj : int; Number of trajectories to run. c_op",MatchSource.WIKI,docs/4.7/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/mcsolve.html
https://qutip.org/docs/4.7/modules/qutip/mcsolve.html:2381,Integrability,depend,dependent,2381,"arning; def warn(text):; print(text). class qutip_zvode(zvode):; def step(self, *args):; itask = self.call_args[2]; self.rwork[0] = args[4]; self.call_args[2] = 5; r = self.run(*args); self.call_args[2] = itask; return r. [docs]def mcsolve(H, psi0, tlist, c_ops=[], e_ops=[], ntraj=0,; args={}, options=None, progress_bar=True,; map_func=parallel_map, map_kwargs={}, _safe_mode=True):; r""""""Monte Carlo evolution of a state vector :math:`|\psi \rangle` for a; given Hamiltonian and sets of collapse operators, and possibly, operators; for calculating expectation values. Options for the underlying ODE solver; are given by the Options class. mcsolve supports time-dependent Hamiltonians and collapse operators using; either Python functions of strings to represent time-dependent; coefficients. Note that, the system Hamiltonian MUST have at least one; constant term. As an example of a time-dependent problem, consider a Hamiltonian with two; terms ``H0`` and ``H1``, where ``H1`` is time-dependent with coefficient; ``sin(w*t)``, and collapse operators ``C0`` and ``C1``, where ``C1`` is; time-dependent with coeffcient ``exp(-a*t)``. Here, w and a are constant; arguments with values ``W`` and ``A``. Using the Python function time-dependent format requires two Python; functions, one for each collapse coefficient. Therefore, this problem could; be expressed as::. def H1_coeff(t,args):; return sin(args['w']*t). def C1_coeff(t,args):; return exp(-args['a']*t). H = [H0, [H1, H1_coeff]]. c_ops = [C0, [C1, C1_coeff]]. args={'a': A, 'w': W}. or in String (Cython) format we could write::. H = [H0, [H1, 'sin(w*t)']]. c_ops = [C0, [C1, 'exp(-a*t)']]. args={'a': A, 'w': W}. Constant terms are preferably placed first in the Hamiltonian and collapse; operator lists. Parameters; ----------; H : :class:`qutip.Qobj`, ``list``; System Hamiltonian. psi0 : :class:`qutip.Qobj`; Initial state vector. tlist : array_like; Times at which results are recorded. ntraj : int; Number of trajectories to run. c_op",MatchSource.WIKI,docs/4.7/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/mcsolve.html
https://qutip.org/docs/4.7/modules/qutip/mcsolve.html:2520,Integrability,depend,dependent,2520,"ps=[], e_ops=[], ntraj=0,; args={}, options=None, progress_bar=True,; map_func=parallel_map, map_kwargs={}, _safe_mode=True):; r""""""Monte Carlo evolution of a state vector :math:`|\psi \rangle` for a; given Hamiltonian and sets of collapse operators, and possibly, operators; for calculating expectation values. Options for the underlying ODE solver; are given by the Options class. mcsolve supports time-dependent Hamiltonians and collapse operators using; either Python functions of strings to represent time-dependent; coefficients. Note that, the system Hamiltonian MUST have at least one; constant term. As an example of a time-dependent problem, consider a Hamiltonian with two; terms ``H0`` and ``H1``, where ``H1`` is time-dependent with coefficient; ``sin(w*t)``, and collapse operators ``C0`` and ``C1``, where ``C1`` is; time-dependent with coeffcient ``exp(-a*t)``. Here, w and a are constant; arguments with values ``W`` and ``A``. Using the Python function time-dependent format requires two Python; functions, one for each collapse coefficient. Therefore, this problem could; be expressed as::. def H1_coeff(t,args):; return sin(args['w']*t). def C1_coeff(t,args):; return exp(-args['a']*t). H = [H0, [H1, H1_coeff]]. c_ops = [C0, [C1, C1_coeff]]. args={'a': A, 'w': W}. or in String (Cython) format we could write::. H = [H0, [H1, 'sin(w*t)']]. c_ops = [C0, [C1, 'exp(-a*t)']]. args={'a': A, 'w': W}. Constant terms are preferably placed first in the Hamiltonian and collapse; operator lists. Parameters; ----------; H : :class:`qutip.Qobj`, ``list``; System Hamiltonian. psi0 : :class:`qutip.Qobj`; Initial state vector. tlist : array_like; Times at which results are recorded. ntraj : int; Number of trajectories to run. c_ops : :class:`qutip.Qobj`, ``list``; single collapse operator or a ``list`` of collapse operators. e_ops : :class:`qutip.Qobj`, ``list``; single operator as Qobj or ``list`` or equivalent of Qobj operators; for calculating expectation values. args : dict; Argum",MatchSource.WIKI,docs/4.7/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/mcsolve.html
https://qutip.org/docs/4.7/modules/qutip/mcsolve.html:3560,Integrability,depend,dependent,3560," one for each collapse coefficient. Therefore, this problem could; be expressed as::. def H1_coeff(t,args):; return sin(args['w']*t). def C1_coeff(t,args):; return exp(-args['a']*t). H = [H0, [H1, H1_coeff]]. c_ops = [C0, [C1, C1_coeff]]. args={'a': A, 'w': W}. or in String (Cython) format we could write::. H = [H0, [H1, 'sin(w*t)']]. c_ops = [C0, [C1, 'exp(-a*t)']]. args={'a': A, 'w': W}. Constant terms are preferably placed first in the Hamiltonian and collapse; operator lists. Parameters; ----------; H : :class:`qutip.Qobj`, ``list``; System Hamiltonian. psi0 : :class:`qutip.Qobj`; Initial state vector. tlist : array_like; Times at which results are recorded. ntraj : int; Number of trajectories to run. c_ops : :class:`qutip.Qobj`, ``list``; single collapse operator or a ``list`` of collapse operators. e_ops : :class:`qutip.Qobj`, ``list``; single operator as Qobj or ``list`` or equivalent of Qobj operators; for calculating expectation values. args : dict; Arguments for time-dependent Hamiltonian and collapse operator terms. options : Options; Instance of ODE solver options. progress_bar: BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. Set to None to disable the; progress bar. map_func: function; A map function for managing the calls to the single-trajactory solver. map_kwargs: dictionary; Optional keyword arguments to the map_func function. Returns; -------; results : :class:`qutip.solver.Result`; Object storing all results from the simulation. .. note::. It is possible to reuse the random number seeds from a previous run; of the mcsolver by passing the output Result object seeds via the; Options class, i.e. Options(seeds=prev_result.seeds).; """"""; if isinstance(c_ops, (Qobj, QobjEvo)):; c_ops = [c_ops]. if options is None:; options = Options(). if options.rhs_reuse and not isinstance(H, SolverSystem):; # TODO: deprecate when going to class based solver.; if ""mcsolve"" in solver_safe:; # prin",MatchSource.WIKI,docs/4.7/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/mcsolve.html
https://qutip.org/docs/4.7/modules/qutip/mcsolve.html:16646,Integrability,integrat,integration,16646,"----------------------------; # single-trajectory for monte carlo; # --------------------------------------------------------------------------; def _single_traj(self, nt):; """"""; Monte Carlo algorithm returning state-vector or expectation values; at times tlist for a single trajectory.; """"""; # SEED AND RNG AND GENERATE; prng = RandomState(self.seeds[nt]); opt = self.options. # set initial conditions; ss = self.ss; tlist = self.tlist; e_ops = self.e_ops.copy(); opt = self.options; rhs, ode_args = self.ss.makefunc(ss); ODE = self._build_integration_func(rhs, ode_args, opt); ODE.set_initial_value(self.initial_vector, tlist[0]); e_ops.init(tlist). cymc = CyMcOde(ss, opt); states_out, ss_out, collapses = cymc.run_ode(ODE, tlist, e_ops, prng). # Run at end of mc_alg function; # -----------------------------; if opt.steady_state_average:; ss_out /= float(len(tlist)). return (states_out, ss_out, e_ops, collapses). def _build_integration_func(self, rhs, ode_args, opt):; """"""; Create the integration function while fixing the parameters; """"""; ODE = ode(rhs); if ode_args:; ODE.set_f_params(ode_args); # initialize ODE solver for RHS; ODE.set_integrator('zvode', method=""adams""); ODE._integrator = qutip_zvode(; method=opt.method, order=opt.order, atol=opt.atol,; rtol=opt.rtol, nsteps=opt.nsteps, first_step=opt.first_step,; min_step=opt.min_step, max_step=opt.max_step); return ODE. # --------------------------------------------------------------------------; # In development diagonalize the Hamiltonian before solving; # Same seeds give same evolution; # 3~5 time faster; # constant system only.; # --------------------------------------------------------------------------; def make_diag_system(self, H, c_ops):; ss = SolverSystem(); ss.td_c_ops = []; ss.td_n_ops = []. H_ = H.copy(); H_ *= -1j; for c in c_ops:; H_ += -0.5 * c.dag() * c. w, v = np.linalg.eig(H_.full()); arg = np.argsort(np.abs(w)); eig = w[arg]; U = v.T[arg].T; Ud = U.T.conj(). for c in c_ops:; c_diag = Qobj(Ud @ c.full(",MatchSource.WIKI,docs/4.7/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/mcsolve.html
https://qutip.org/docs/4.7/modules/qutip/mcsolve.html:1192,Modifiability,variab,variables,1192,"phy; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.mcsolve. Source code for qutip.mcsolve; __all__ = ['mcsolve']. import os; import numpy as np; from numpy.random import RandomState, randint; import scipy.sparse as sp; from scipy.integrate import ode; from scipy.integrate._ode import zvode. from types import FunctionType, BuiltinFunctionType; from functools import partial; from qutip.fastsparse import csr2fast; from qutip.qobj import Qobj; from qutip.qobjevo import QobjEvo; from qutip.parallel import parfor, parallel_map, serial_map; from qutip.cy.mcsolve import CyMcOde, CyMcOdeDiag; from qutip.cy.spconvert import dense1D_to_fastcsr_ket; from qutip.sesolve import sesolve; from qutip.solver import (Options, Result, ExpectOps,; solver_safe, SolverSystem); from qutip.settings import debug; from qutip.ui.progressbar import TextProgressBar, BaseProgressBar; import qutip.settings. if debug:; import inspect. #; # Internal, global variables for storing references to dynamically loaded; # cython functions. # Todo: use real warning; def warn(text):; print(text). class qutip_zvode(zvode):; def step(self, *args):; itask = self.call_args[2]; self.rwork[0] = args[4]; self.call_args[2] = 5; r = self.run(*args); self.call_args[2] = itask; return r. [docs]def mcsolve(H, psi0, tlist, c_ops=[], e_ops=[], ntraj=0,; args={}, options=None, progress_bar=True,; map_func=parallel_map, map_kwargs={}, _safe_mode=True):; r""""""Monte Carlo evolution of a state vector :math:`|\psi \rangle` for a; given Hamiltonian and sets of collapse operators, and possibly, operators; for calculating expectation values. Options for the underlying ODE solver; are given by the Options class. mcsolve supports time-dependent Hamiltonians and collapse operators using; either Python functions of strings to represent time-dependent; coefficients. Note that, the system Hamiltonian MUST have at least one; constant term. As an example of a time-dependent problem, consider a Hamiltonian",MatchSource.WIKI,docs/4.7/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/mcsolve.html
https://qutip.org/docs/4.7/modules/qutip/mcsolve.html:1240,Performance,load,loaded,1240,"phy; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.mcsolve. Source code for qutip.mcsolve; __all__ = ['mcsolve']. import os; import numpy as np; from numpy.random import RandomState, randint; import scipy.sparse as sp; from scipy.integrate import ode; from scipy.integrate._ode import zvode. from types import FunctionType, BuiltinFunctionType; from functools import partial; from qutip.fastsparse import csr2fast; from qutip.qobj import Qobj; from qutip.qobjevo import QobjEvo; from qutip.parallel import parfor, parallel_map, serial_map; from qutip.cy.mcsolve import CyMcOde, CyMcOdeDiag; from qutip.cy.spconvert import dense1D_to_fastcsr_ket; from qutip.sesolve import sesolve; from qutip.solver import (Options, Result, ExpectOps,; solver_safe, SolverSystem); from qutip.settings import debug; from qutip.ui.progressbar import TextProgressBar, BaseProgressBar; import qutip.settings. if debug:; import inspect. #; # Internal, global variables for storing references to dynamically loaded; # cython functions. # Todo: use real warning; def warn(text):; print(text). class qutip_zvode(zvode):; def step(self, *args):; itask = self.call_args[2]; self.rwork[0] = args[4]; self.call_args[2] = 5; r = self.run(*args); self.call_args[2] = itask; return r. [docs]def mcsolve(H, psi0, tlist, c_ops=[], e_ops=[], ntraj=0,; args={}, options=None, progress_bar=True,; map_func=parallel_map, map_kwargs={}, _safe_mode=True):; r""""""Monte Carlo evolution of a state vector :math:`|\psi \rangle` for a; given Hamiltonian and sets of collapse operators, and possibly, operators; for calculating expectation values. Options for the underlying ODE solver; are given by the Options class. mcsolve supports time-dependent Hamiltonians and collapse operators using; either Python functions of strings to represent time-dependent; coefficients. Note that, the system Hamiltonian MUST have at least one; constant term. As an example of a time-dependent problem, consider a Hamiltonian",MatchSource.WIKI,docs/4.7/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/mcsolve.html
https://qutip.org/docs/4.7/modules/qutip/mcsolve.html:5094,Performance,load,load,5094,". .. note::. It is possible to reuse the random number seeds from a previous run; of the mcsolver by passing the output Result object seeds via the; Options class, i.e. Options(seeds=prev_result.seeds).; """"""; if isinstance(c_ops, (Qobj, QobjEvo)):; c_ops = [c_ops]. if options is None:; options = Options(). if options.rhs_reuse and not isinstance(H, SolverSystem):; # TODO: deprecate when going to class based solver.; if ""mcsolve"" in solver_safe:; # print("" ""); H = solver_safe[""mcsolve""]; else:; pass; # raise Exception(""Could not find the Hamiltonian to reuse.""). if not ntraj:; ntraj = options.ntraj. if len(c_ops) == 0 and not options.rhs_reuse:; warn(""No c_ops, using sesolve""); return sesolve(H, psi0, tlist, e_ops=e_ops, args=args,; options=options, progress_bar=progress_bar,; _safe_mode=_safe_mode). try:; num_traj = int(ntraj); except TypeError:; num_traj = max(ntraj). # set the physics; if not psi0.isket:; raise Exception(""Initial state must be a state vector.""). # load monte carlo class; mc = _MC(options). if isinstance(H, SolverSystem):; mc.ss = H; else:; mc.make_system(H, c_ops, tlist, args, options). mc.reset(tlist[0], psi0). mc.set_e_ops(e_ops). if options.seeds is not None:; mc.seed(num_traj, options.seeds). if _safe_mode:; mc.run_test(). # Run the simulation; mc.run(num_traj=num_traj, tlist=tlist,; progress_bar=progress_bar,; map_func=map_func, map_kwargs=map_kwargs). return mc.get_result(ntraj). # -----------------------------------------------------------------------------; # MONTE CARLO CLASS; # -----------------------------------------------------------------------------; class _MC():; """"""; Private class for solving Monte Carlo evolution from mcsolve; """"""; def __init__(self, options=None):; if options is None:; options = Options(); self.options = options; self.ss = None; self.tlist = None; self.e_ops = None; self.ran = False; self.psi0 = None; self.seeds = []; self.t = 0.; self.num_traj = 0; self.args_col = None. self._psi_out = []; self._expect_out = [];",MatchSource.WIKI,docs/4.7/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/mcsolve.html
https://qutip.org/docs/4.7/modules/qutip/mcsolve.html:3827,Usability,progress bar,progress bar,3827,", 'w': W}. or in String (Cython) format we could write::. H = [H0, [H1, 'sin(w*t)']]. c_ops = [C0, [C1, 'exp(-a*t)']]. args={'a': A, 'w': W}. Constant terms are preferably placed first in the Hamiltonian and collapse; operator lists. Parameters; ----------; H : :class:`qutip.Qobj`, ``list``; System Hamiltonian. psi0 : :class:`qutip.Qobj`; Initial state vector. tlist : array_like; Times at which results are recorded. ntraj : int; Number of trajectories to run. c_ops : :class:`qutip.Qobj`, ``list``; single collapse operator or a ``list`` of collapse operators. e_ops : :class:`qutip.Qobj`, ``list``; single operator as Qobj or ``list`` or equivalent of Qobj operators; for calculating expectation values. args : dict; Arguments for time-dependent Hamiltonian and collapse operator terms. options : Options; Instance of ODE solver options. progress_bar: BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. Set to None to disable the; progress bar. map_func: function; A map function for managing the calls to the single-trajactory solver. map_kwargs: dictionary; Optional keyword arguments to the map_func function. Returns; -------; results : :class:`qutip.solver.Result`; Object storing all results from the simulation. .. note::. It is possible to reuse the random number seeds from a previous run; of the mcsolver by passing the output Result object seeds via the; Options class, i.e. Options(seeds=prev_result.seeds).; """"""; if isinstance(c_ops, (Qobj, QobjEvo)):; c_ops = [c_ops]. if options is None:; options = Options(). if options.rhs_reuse and not isinstance(H, SolverSystem):; # TODO: deprecate when going to class based solver.; if ""mcsolve"" in solver_safe:; # print("" ""); H = solver_safe[""mcsolve""]; else:; pass; # raise Exception(""Could not find the Hamiltonian to reuse.""). if not ntraj:; ntraj = options.ntraj. if len(c_ops) == 0 and not options.rhs_reuse:; warn(""No c_ops, using sesolve""); return sesolve(H, ps",MatchSource.WIKI,docs/4.7/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/mcsolve.html
https://qutip.org/docs/4.7/modules/qutip/measurement.html:7936,Availability,down,down,7936,"----; state : :class:`.Qobj`; The ket or density matrix specifying the state to measure. op : :class:`.Qobj`; The measurement operator. targets : list of ints, optional; Specifies a list of target ""qubit"" indices on which to apply the; measurement using :func:`qutip.qip.operations.gates.expand_operator`; to expand op into full dimension. Returns; -------; measured_value : float; The result of the measurement (one of the eigenvalues of op). state : :class:`.Qobj`; The new state (a ket if a ket was given, otherwise a density matrix). Examples; --------. Measure the z-component of the spin of the spin-up basis state:. >>> measure_observable(basis(2, 0), sigmaz()); (1.0, Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[-1.]; [ 0.]]). Since the spin-up basis is an eigenstate of sigmaz, this measurement always; returns 1 as the measurement result (the eigenvalue of the spin-up basis); and the original state (up to a global phase). Measure the x-component of the spin of the spin-down basis state:. >>> measure_observable(basis(2, 1), sigmax()); (-1.0, Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[-0.70710678]; [ 0.70710678]]). This measurement returns 1 fifty percent of the time and -1 the other fifty; percent of the time. The new state returned is the corresponding eigenstate; of sigmax. One may also perform a measurement on a density matrix. Below we perform; the same measurement as above, but on the density matrix representing the; pure spin-down state:. >>> measure_observable(ket2dm(basis(2, 1)), sigmax()); (-1.0, Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper; Qobj data =; [[ 0.5 -0.5]; [-0.5 0.5]]). The measurement result is the same, but the new state is returned as a; density matrix.; """"""; eigenvalues, eigenstates_or_projectors, probabilities = (; measurement_statistics_observable(state, op, targets)); i = np.random.choice(range(len(eigenvalues)), p=probabilities); if state.isket:; eigenstat",MatchSource.WIKI,docs/4.7/modules/qutip/measurement.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/measurement.html
https://qutip.org/docs/4.7/modules/qutip/measurement.html:8442,Availability,down,down,8442,"state (a ket if a ket was given, otherwise a density matrix). Examples; --------. Measure the z-component of the spin of the spin-up basis state:. >>> measure_observable(basis(2, 0), sigmaz()); (1.0, Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[-1.]; [ 0.]]). Since the spin-up basis is an eigenstate of sigmaz, this measurement always; returns 1 as the measurement result (the eigenvalue of the spin-up basis); and the original state (up to a global phase). Measure the x-component of the spin of the spin-down basis state:. >>> measure_observable(basis(2, 1), sigmax()); (-1.0, Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[-0.70710678]; [ 0.70710678]]). This measurement returns 1 fifty percent of the time and -1 the other fifty; percent of the time. The new state returned is the corresponding eigenstate; of sigmax. One may also perform a measurement on a density matrix. Below we perform; the same measurement as above, but on the density matrix representing the; pure spin-down state:. >>> measure_observable(ket2dm(basis(2, 1)), sigmax()); (-1.0, Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper; Qobj data =; [[ 0.5 -0.5]; [-0.5 0.5]]). The measurement result is the same, but the new state is returned as a; density matrix.; """"""; eigenvalues, eigenstates_or_projectors, probabilities = (; measurement_statistics_observable(state, op, targets)); i = np.random.choice(range(len(eigenvalues)), p=probabilities); if state.isket:; eigenstates = eigenstates_or_projectors; state = eigenstates[i]; else:; projectors = eigenstates_or_projectors; state = (projectors[i] * state * projectors[i]) / probabilities[i]; return eigenvalues[i], state. [docs]def measure_povm(state, ops, targets=None):; r""""""; Perform a measurement specified by list of POVMs. This function simulates a POVM measurement. The measurement collapses the; state to one of the resultant states of the measurement and returns the; index of the operat",MatchSource.WIKI,docs/4.7/modules/qutip/measurement.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/measurement.html
https://qutip.org/docs/4.7/modules/qutip/measurement.html:12930,Deployability,update,updated,12930,"s:.Qobj); or; - list of measurement operators :math:`M_i` or kets (list of; :class:`.Qobj`) Either:. 1. specifying a POVM s.t. :math:`E_i = M_i^\dagger * M_i`; 2. projection operators if ops correspond to projectors (s.t.; :math:`E_i = M_i^\dagger = M_i`); 3. kets (transformed to projectors). targets : list of ints, optional; Specifies a list of target ""qubit"" indices on which to apply the; measurement using :func:`qutip.qip.operations.gates.expand_operator`; to expand ops into full dimension.; """"""; if isinstance(ops, list):; return measurement_statistics_povm(state, ops, targets); else:; return measurement_statistics_observable(state, ops, targets). [docs]def measure(state, ops, targets=None):; r""""""; A dispatch method that provides measurement results handling both; observable style measurements and projector style measurements (POVMs and; PVMs). For return signatures, please check:. - :func:`~measure_observable` for observable measurements.; - :func:`~measure_povm` for POVM measurements. Parameters; ----------; state : :class:`.Qobj`; The ket or density matrix specifying the state to measure. ops : :class:`.Qobj` or list of :class:`.Qobj`; - measurement observable (:class:`.Qobj`); or; - list of measurement operators :math:`M_i` or kets (list of; :class:`.Qobj`) Either:. 1. specifying a POVM s.t. :math:`E_i = M_i^\dagger M_i`; 2. projection operators if ops correspond to projectors (s.t.; :math:`E_i = M_i^\dagger = M_i`); 3. kets (transformed to projectors). targets : list of ints, optional; Specifies a list of target ""qubit"" indices on which to apply the; measurement using :func:`qutip.qip.operations.gates.expand_operator`; to expand ops into full dimension.; """"""; if isinstance(ops, list):; return measure_povm(state, ops, targets); else:; return measure_observable(state, ops, targets). © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/modules/qutip/measurement.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/measurement.html
https://qutip.org/docs/4.7/modules/qutip/measurement.html:8296,Performance,perform,perform,8296,"lt of the measurement (one of the eigenvalues of op). state : :class:`.Qobj`; The new state (a ket if a ket was given, otherwise a density matrix). Examples; --------. Measure the z-component of the spin of the spin-up basis state:. >>> measure_observable(basis(2, 0), sigmaz()); (1.0, Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[-1.]; [ 0.]]). Since the spin-up basis is an eigenstate of sigmaz, this measurement always; returns 1 as the measurement result (the eigenvalue of the spin-up basis); and the original state (up to a global phase). Measure the x-component of the spin of the spin-down basis state:. >>> measure_observable(basis(2, 1), sigmax()); (-1.0, Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[-0.70710678]; [ 0.70710678]]). This measurement returns 1 fifty percent of the time and -1 the other fifty; percent of the time. The new state returned is the corresponding eigenstate; of sigmax. One may also perform a measurement on a density matrix. Below we perform; the same measurement as above, but on the density matrix representing the; pure spin-down state:. >>> measure_observable(ket2dm(basis(2, 1)), sigmax()); (-1.0, Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper; Qobj data =; [[ 0.5 -0.5]; [-0.5 0.5]]). The measurement result is the same, but the new state is returned as a; density matrix.; """"""; eigenvalues, eigenstates_or_projectors, probabilities = (; measurement_statistics_observable(state, op, targets)); i = np.random.choice(range(len(eigenvalues)), p=probabilities); if state.isket:; eigenstates = eigenstates_or_projectors; state = eigenstates[i]; else:; projectors = eigenstates_or_projectors; state = (projectors[i] * state * projectors[i]) / probabilities[i]; return eigenvalues[i], state. [docs]def measure_povm(state, ops, targets=None):; r""""""; Perform a measurement specified by list of POVMs. This function simulates a POVM measurement. The measurement collapses the; state ",MatchSource.WIKI,docs/4.7/modules/qutip/measurement.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/measurement.html
https://qutip.org/docs/4.7/modules/qutip/measurement.html:8348,Performance,perform,perform,8348,"state (a ket if a ket was given, otherwise a density matrix). Examples; --------. Measure the z-component of the spin of the spin-up basis state:. >>> measure_observable(basis(2, 0), sigmaz()); (1.0, Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[-1.]; [ 0.]]). Since the spin-up basis is an eigenstate of sigmaz, this measurement always; returns 1 as the measurement result (the eigenvalue of the spin-up basis); and the original state (up to a global phase). Measure the x-component of the spin of the spin-down basis state:. >>> measure_observable(basis(2, 1), sigmax()); (-1.0, Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[-0.70710678]; [ 0.70710678]]). This measurement returns 1 fifty percent of the time and -1 the other fifty; percent of the time. The new state returned is the corresponding eigenstate; of sigmax. One may also perform a measurement on a density matrix. Below we perform; the same measurement as above, but on the density matrix representing the; pure spin-down state:. >>> measure_observable(ket2dm(basis(2, 1)), sigmax()); (-1.0, Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper; Qobj data =; [[ 0.5 -0.5]; [-0.5 0.5]]). The measurement result is the same, but the new state is returned as a; density matrix.; """"""; eigenvalues, eigenstates_or_projectors, probabilities = (; measurement_statistics_observable(state, op, targets)); i = np.random.choice(range(len(eigenvalues)), p=probabilities); if state.isket:; eigenstates = eigenstates_or_projectors; state = eigenstates[i]; else:; projectors = eigenstates_or_projectors; state = (projectors[i] * state * projectors[i]) / probabilities[i]; return eigenvalues[i], state. [docs]def measure_povm(state, ops, targets=None):; r""""""; Perform a measurement specified by list of POVMs. This function simulates a POVM measurement. The measurement collapses the; state to one of the resultant states of the measurement and returns the; index of the operat",MatchSource.WIKI,docs/4.7/modules/qutip/measurement.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/measurement.html
https://qutip.org/docs/4.7/modules/qutip/mesolve.html:16328,Availability,error,error,16328,"_expt_op == 0:; # fall back on storing states; opt.store_states = True; need_qobj_state = True; else:; for op in e_ops:; if not isinstance(op, Qobj) and callable(op):; output.expect.append(np.zeros(n_tsteps, dtype=complex)); need_qobj_state = True; e_ops_data.append(None); continue; if op.dims != rho0.dims:; raise TypeError(f""e_ops dims ({op.dims}) are not ""; f""compatible with the state's ""; f""({rho0.dims})""); e_ops_data.append(spre(op).data); if op.isherm and rho0.isherm:; output.expect.append(np.zeros(n_tsteps)); else:; output.expect.append(np.zeros(n_tsteps, dtype=complex)); else:; raise TypeError(""Expectation parameter must be a list or a function""). if opt.store_states:; output.states = []. def get_curr_state_data(r):; return vec2mat(r.y). #; # start evolution; #; dt = np.diff(tlist); cdata = None; progress_bar.start(n_tsteps); for t_idx, t in enumerate(tlist):; progress_bar.update(t_idx). if not r.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""). if need_qobj_state:; cdata = get_curr_state_data(r); fdata = dense2D_to_fastcsr_fmode(cdata, size, size). # Try to guess if there is a fast path for rho_t; if issuper(rho0) or not rho0.isherm:; rho_t = Qobj(fdata, dims=dims); else:; rho_t = Qobj(fdata, dims=dims, fast=""mc-dm""). if opt.store_states:; output.states.append(rho_t). if expt_callback:; # use callback method; output.expect.append(e_ops(t, rho_t)). for m in range(n_expt_op):; if not isinstance(e_ops[m], Qobj) and callable(e_ops[m]):; output.expect[m][t_idx] = e_ops[m](t, rho_t); else:; output.expect[m][t_idx] = expect_rho_vec(e_ops_data[m], r.y,; e_ops[m].isherm; and rho0.isherm). if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]). progress_bar.finished(). if opt.store_final_state:; cdata = get_curr_state_data(r); output.final_state = Qobj(cdata, dims=dims,; isherm=rho0.isherm or None). return output. © Copyright 2011 to 2021 inclusive, ",MatchSource.WIKI,docs/4.7/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/mesolve.html
https://qutip.org/docs/4.7/modules/qutip/mesolve.html:502,Deployability,integrat,integrate,502,". qutip.mesolve — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.mesolve. Source code for qutip.mesolve; """"""; This module provides solvers for the Lindblad master equation and von Neumann; equation.; """""". __all__ = ['mesolve']. import numpy as np; import scipy.integrate; from qutip.qobj import Qobj, isket, isoper, issuper; from qutip.superoperator import spre, spost, liouvillian, vec2mat, lindblad_dissipator; from qutip.expect import expect_rho_vec; from qutip.solver import Options, Result, solver_safe, SolverSystem; from qutip.cy.spmatfuncs import spmv; from qutip.cy.spconvert import dense2D_to_fastcsr_fmode; from qutip.states import ket2dm; from qutip.sesolve import sesolve; from qutip.ui.progressbar import BaseProgressBar, TextProgressBar; from qutip.qobjevo import QobjEvo. from qutip.cy.openmp.utilities import check_use_openmp. # -----------------------------------------------------------------------------; # pass on to wavefunction solver or master equation solver depending on whether; # any collapse operators were given.; #; [docs]def mesolve(H, rho0, tlist, c_ops=None, e_ops=None, args=None, options=None,; progress_bar=None, _safe_mode=True):; """"""; Master equation evolution of a density matrix for a given Hamiltonian and; set of collapse operators, or a Liouvillian. Evolve the state vector or density matrix (`rho0`) using a given; Hamiltonian or Liouvillian (`H`) and an optional set of collapse operators; (`c_ops`), by integrating the set of ordinary differential equations; that define the system. In the absence of collapse operators the system is; evolved according to the unitary evolution of the Hamiltonian. The output is either the state vector at arbitrary points in time; (`tlist`), or the expectation values of the supp",MatchSource.WIKI,docs/4.7/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/mesolve.html
https://qutip.org/docs/4.7/modules/qutip/mesolve.html:1691,Deployability,integrat,integrating,1691,"; from qutip.expect import expect_rho_vec; from qutip.solver import Options, Result, solver_safe, SolverSystem; from qutip.cy.spmatfuncs import spmv; from qutip.cy.spconvert import dense2D_to_fastcsr_fmode; from qutip.states import ket2dm; from qutip.sesolve import sesolve; from qutip.ui.progressbar import BaseProgressBar, TextProgressBar; from qutip.qobjevo import QobjEvo. from qutip.cy.openmp.utilities import check_use_openmp. # -----------------------------------------------------------------------------; # pass on to wavefunction solver or master equation solver depending on whether; # any collapse operators were given.; #; [docs]def mesolve(H, rho0, tlist, c_ops=None, e_ops=None, args=None, options=None,; progress_bar=None, _safe_mode=True):; """"""; Master equation evolution of a density matrix for a given Hamiltonian and; set of collapse operators, or a Liouvillian. Evolve the state vector or density matrix (`rho0`) using a given; Hamiltonian or Liouvillian (`H`) and an optional set of collapse operators; (`c_ops`), by integrating the set of ordinary differential equations; that define the system. In the absence of collapse operators the system is; evolved according to the unitary evolution of the Hamiltonian. The output is either the state vector at arbitrary points in time; (`tlist`), or the expectation values of the supplied operators; (`e_ops`). If e_ops is a callback function, it is invoked for each; time in `tlist` with time and the state as arguments, and the function; does not use any return values. If either `H` or the Qobj elements in `c_ops` are superoperators, they; will be treated as direct contributions to the total system Liouvillian.; This allows the solution of master equations that are not in standard; Lindblad form. **Time-dependent operators**. For time-dependent problems, `H` and `c_ops` can be a specified in a; nested-list format where each element in the list is a list of length 2,; containing an operator (:class:`qutip.qobj`) at the first",MatchSource.WIKI,docs/4.7/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/mesolve.html
https://qutip.org/docs/4.7/modules/qutip/mesolve.html:4083,Deployability,integrat,integration,4083,"ouvillian superoperator at any point in time. If the; equation cannot be put in standard Lindblad form, then this time-dependence; format must be used. *Examples*. H = [[H0, 'sin(w*t)'], [H1, 'sin(2*w*t)']]. H = [[H0, f0_t], [H1, f1_t]]. where f0_t and f1_t are python functions with signature f_t(t, args). H = [[H0, np.sin(w*tlist)], [H1, np.sin(2*w*tlist)]]. In the *list string format* and *list callback format*, the string; expression and the callback function must evaluate to a real or complex; number (coefficient for the corresponding operator). In all cases of time-dependent operators, `args` is a dictionary of; parameters that is used when evaluating operators. It is passed to the; callback functions as their second argument. **Additional options**. Additional options to mesolve can be set via the `options` argument, which; should be an instance of :class:`qutip.solver.Options`. Many ODE; integration options can be set this way, and the `store_states` and; `store_final_state` options can be used to store states even though; expectation values are requested via the `e_ops` argument. .. note::. If an element in the list-specification of the Hamiltonian or; the list of collapse operators are in superoperator form it will be; added to the total Liouvillian of the problem without further; transformation. This allows for using mesolve for solving master; equations that are not in standard Lindblad form. .. note::. On using callback functions: mesolve transforms all :class:`qutip.Qobj`; objects to sparse matrices before handing the problem to the integrator; function. In order for your callback function to work correctly, pass; all :class:`qutip.Qobj` objects that are used in constructing the; Hamiltonian via `args`. mesolve will check for :class:`qutip.Qobj` in; `args` and handle the conversion to sparse matrices. All other; :class:`qutip.Qobj` objects that are not passed via `args` will be; passed on to the integrator in scipy which will raise a NotImplemented; exce",MatchSource.WIKI,docs/4.7/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/mesolve.html
https://qutip.org/docs/4.7/modules/qutip/mesolve.html:4747,Deployability,integrat,integrator,4747,"rator). In all cases of time-dependent operators, `args` is a dictionary of; parameters that is used when evaluating operators. It is passed to the; callback functions as their second argument. **Additional options**. Additional options to mesolve can be set via the `options` argument, which; should be an instance of :class:`qutip.solver.Options`. Many ODE; integration options can be set this way, and the `store_states` and; `store_final_state` options can be used to store states even though; expectation values are requested via the `e_ops` argument. .. note::. If an element in the list-specification of the Hamiltonian or; the list of collapse operators are in superoperator form it will be; added to the total Liouvillian of the problem without further; transformation. This allows for using mesolve for solving master; equations that are not in standard Lindblad form. .. note::. On using callback functions: mesolve transforms all :class:`qutip.Qobj`; objects to sparse matrices before handing the problem to the integrator; function. In order for your callback function to work correctly, pass; all :class:`qutip.Qobj` objects that are used in constructing the; Hamiltonian via `args`. mesolve will check for :class:`qutip.Qobj` in; `args` and handle the conversion to sparse matrices. All other; :class:`qutip.Qobj` objects that are not passed via `args` will be; passed on to the integrator in scipy which will raise a NotImplemented; exception. Parameters; ----------. H : :class:`qutip.Qobj`; System Hamiltonian, or a callback function for time-dependent; Hamiltonians, or alternatively a system Liouvillian. rho0 : :class:`qutip.Qobj`; initial density matrix or state vector (ket). tlist : *list* / *array*; list of times for :math:`t`. c_ops : None / list of :class:`qutip.Qobj`; single collapse operator, or list of collapse operators, or a list; of Liouvillian superoperators. e_ops : None / list / callback function, optional; A list of operators as `Qobj` and/or callable functio",MatchSource.WIKI,docs/4.7/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/mesolve.html
https://qutip.org/docs/4.7/modules/qutip/mesolve.html:5117,Deployability,integrat,integrator,5117,"this way, and the `store_states` and; `store_final_state` options can be used to store states even though; expectation values are requested via the `e_ops` argument. .. note::. If an element in the list-specification of the Hamiltonian or; the list of collapse operators are in superoperator form it will be; added to the total Liouvillian of the problem without further; transformation. This allows for using mesolve for solving master; equations that are not in standard Lindblad form. .. note::. On using callback functions: mesolve transforms all :class:`qutip.Qobj`; objects to sparse matrices before handing the problem to the integrator; function. In order for your callback function to work correctly, pass; all :class:`qutip.Qobj` objects that are used in constructing the; Hamiltonian via `args`. mesolve will check for :class:`qutip.Qobj` in; `args` and handle the conversion to sparse matrices. All other; :class:`qutip.Qobj` objects that are not passed via `args` will be; passed on to the integrator in scipy which will raise a NotImplemented; exception. Parameters; ----------. H : :class:`qutip.Qobj`; System Hamiltonian, or a callback function for time-dependent; Hamiltonians, or alternatively a system Liouvillian. rho0 : :class:`qutip.Qobj`; initial density matrix or state vector (ket). tlist : *list* / *array*; list of times for :math:`t`. c_ops : None / list of :class:`qutip.Qobj`; single collapse operator, or list of collapse operators, or a list; of Liouvillian superoperators. e_ops : None / list / callback function, optional; A list of operators as `Qobj` and/or callable functions (can be mixed); or a single callable function. For operators, the result's expect will; be computed by :func:`qutip.expect`. For callable functions, they are; called as ``f(t, state)`` and return the expectation value.; A single callback's expectation value can be any type, but a callback; part of a list must return a number as the expectation value. args : None / *dictionary*; dictio",MatchSource.WIKI,docs/4.7/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/mesolve.html
https://qutip.org/docs/4.7/modules/qutip/mesolve.html:14775,Deployability,integrat,integrate,14775,"f _ode_super_func_td(t, y, L_func, args):; L = L_func(t, y, args); ym = vec2mat(y); return (L*ym).ravel('F'). # -----------------------------------------------------------------------------; # Generic ODE solver: shared code among the various ODE solver; # -----------------------------------------------------------------------------. def _generic_ode_solve(func, ode_args, rho0, tlist, e_ops, opt,; progress_bar, dims=None):; """"""; Internal function for solving ME.; Calculate the required expectation values or invoke; callback function at each time step.; """"""; # %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%; # This function is made similar to sesolve's one for futur merging in a; # solver class; # %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%. # prepare output array; n_tsteps = len(tlist); output = Result(); output.solver = ""mesolve""; output.times = tlist; size = rho0.shape[0]. initial_vector = rho0.full().ravel('F'). r = scipy.integrate.ode(func); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); if ode_args:; r.set_f_params(*ode_args); r.set_initial_value(initial_vector, tlist[0]). e_ops_data = []; output.expect = []; need_qobj_state = opt.store_states; if callable(e_ops):; n_expt_op = 0; expt_callback = True; output.num_expect = 1; need_qobj_state = True; elif isinstance(e_ops, list):; n_expt_op = len(e_ops); expt_callback = False; output.num_expect = n_expt_op; if n_expt_op == 0:; # fall back on storing states; opt.store_states = True; need_qobj_state = True; else:; for op in e_ops:; if not isinstance(op, Qobj) and callable(op):; output.expect.append(np.zeros(n_tsteps, dtype=complex)); need_qobj_state = True; e_ops_data.append(None); continue; if op.dims != rho0.dims:; raise TypeError(f""e_ops dims ({op.dims}) are not ""; f""compatible with the state's ""; f""({rho0.dims})""); e_o",MatchSource.WIKI,docs/4.7/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/mesolve.html
https://qutip.org/docs/4.7/modules/qutip/mesolve.html:16256,Deployability,update,update,16256,"ce(e_ops, list):; n_expt_op = len(e_ops); expt_callback = False; output.num_expect = n_expt_op; if n_expt_op == 0:; # fall back on storing states; opt.store_states = True; need_qobj_state = True; else:; for op in e_ops:; if not isinstance(op, Qobj) and callable(op):; output.expect.append(np.zeros(n_tsteps, dtype=complex)); need_qobj_state = True; e_ops_data.append(None); continue; if op.dims != rho0.dims:; raise TypeError(f""e_ops dims ({op.dims}) are not ""; f""compatible with the state's ""; f""({rho0.dims})""); e_ops_data.append(spre(op).data); if op.isherm and rho0.isherm:; output.expect.append(np.zeros(n_tsteps)); else:; output.expect.append(np.zeros(n_tsteps, dtype=complex)); else:; raise TypeError(""Expectation parameter must be a list or a function""). if opt.store_states:; output.states = []. def get_curr_state_data(r):; return vec2mat(r.y). #; # start evolution; #; dt = np.diff(tlist); cdata = None; progress_bar.start(n_tsteps); for t_idx, t in enumerate(tlist):; progress_bar.update(t_idx). if not r.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""). if need_qobj_state:; cdata = get_curr_state_data(r); fdata = dense2D_to_fastcsr_fmode(cdata, size, size). # Try to guess if there is a fast path for rho_t; if issuper(rho0) or not rho0.isherm:; rho_t = Qobj(fdata, dims=dims); else:; rho_t = Qobj(fdata, dims=dims, fast=""mc-dm""). if opt.store_states:; output.states.append(rho_t). if expt_callback:; # use callback method; output.expect.append(e_ops(t, rho_t)). for m in range(n_expt_op):; if not isinstance(e_ops[m], Qobj) and callable(e_ops[m]):; output.expect[m][t_idx] = e_ops[m](t, rho_t); else:; output.expect[m][t_idx] = expect_rho_vec(e_ops_data[m], r.y,; e_ops[m].isherm; and rho0.isherm). if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]). progress_bar.finished(). if opt.store_final_state:; cdata = get_curr_state_data(r); output.final_state = Qobj",MatchSource.WIKI,docs/4.7/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/mesolve.html
https://qutip.org/docs/4.7/modules/qutip/mesolve.html:16316,Deployability,integrat,integration,16316,"_expt_op == 0:; # fall back on storing states; opt.store_states = True; need_qobj_state = True; else:; for op in e_ops:; if not isinstance(op, Qobj) and callable(op):; output.expect.append(np.zeros(n_tsteps, dtype=complex)); need_qobj_state = True; e_ops_data.append(None); continue; if op.dims != rho0.dims:; raise TypeError(f""e_ops dims ({op.dims}) are not ""; f""compatible with the state's ""; f""({rho0.dims})""); e_ops_data.append(spre(op).data); if op.isherm and rho0.isherm:; output.expect.append(np.zeros(n_tsteps)); else:; output.expect.append(np.zeros(n_tsteps, dtype=complex)); else:; raise TypeError(""Expectation parameter must be a list or a function""). if opt.store_states:; output.states = []. def get_curr_state_data(r):; return vec2mat(r.y). #; # start evolution; #; dt = np.diff(tlist); cdata = None; progress_bar.start(n_tsteps); for t_idx, t in enumerate(tlist):; progress_bar.update(t_idx). if not r.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""). if need_qobj_state:; cdata = get_curr_state_data(r); fdata = dense2D_to_fastcsr_fmode(cdata, size, size). # Try to guess if there is a fast path for rho_t; if issuper(rho0) or not rho0.isherm:; rho_t = Qobj(fdata, dims=dims); else:; rho_t = Qobj(fdata, dims=dims, fast=""mc-dm""). if opt.store_states:; output.states.append(rho_t). if expt_callback:; # use callback method; output.expect.append(e_ops(t, rho_t)). for m in range(n_expt_op):; if not isinstance(e_ops[m], Qobj) and callable(e_ops[m]):; output.expect[m][t_idx] = e_ops[m](t, rho_t); else:; output.expect[m][t_idx] = expect_rho_vec(e_ops_data[m], r.y,; e_ops[m].isherm; and rho0.isherm). if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]). progress_bar.finished(). if opt.store_final_state:; cdata = get_curr_state_data(r); output.final_state = Qobj(cdata, dims=dims,; isherm=rho0.isherm or None). return output. © Copyright 2011 to 2021 inclusive, ",MatchSource.WIKI,docs/4.7/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/mesolve.html
https://qutip.org/docs/4.7/modules/qutip/mesolve.html:17126,Deployability,integrat,integrate,17126,"obj) and callable(op):; output.expect.append(np.zeros(n_tsteps, dtype=complex)); need_qobj_state = True; e_ops_data.append(None); continue; if op.dims != rho0.dims:; raise TypeError(f""e_ops dims ({op.dims}) are not ""; f""compatible with the state's ""; f""({rho0.dims})""); e_ops_data.append(spre(op).data); if op.isherm and rho0.isherm:; output.expect.append(np.zeros(n_tsteps)); else:; output.expect.append(np.zeros(n_tsteps, dtype=complex)); else:; raise TypeError(""Expectation parameter must be a list or a function""). if opt.store_states:; output.states = []. def get_curr_state_data(r):; return vec2mat(r.y). #; # start evolution; #; dt = np.diff(tlist); cdata = None; progress_bar.start(n_tsteps); for t_idx, t in enumerate(tlist):; progress_bar.update(t_idx). if not r.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""). if need_qobj_state:; cdata = get_curr_state_data(r); fdata = dense2D_to_fastcsr_fmode(cdata, size, size). # Try to guess if there is a fast path for rho_t; if issuper(rho0) or not rho0.isherm:; rho_t = Qobj(fdata, dims=dims); else:; rho_t = Qobj(fdata, dims=dims, fast=""mc-dm""). if opt.store_states:; output.states.append(rho_t). if expt_callback:; # use callback method; output.expect.append(e_ops(t, rho_t)). for m in range(n_expt_op):; if not isinstance(e_ops[m], Qobj) and callable(e_ops[m]):; output.expect[m][t_idx] = e_ops[m](t, rho_t); else:; output.expect[m][t_idx] = expect_rho_vec(e_ops_data[m], r.y,; e_ops[m].isherm; and rho0.isherm). if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]). progress_bar.finished(). if opt.store_final_state:; cdata = get_curr_state_data(r); output.final_state = Qobj(cdata, dims=dims,; isherm=rho0.isherm or None). return output. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/mesolve.html
https://qutip.org/docs/4.7/modules/qutip/mesolve.html:17406,Deployability,update,updated,17406,"obj) and callable(op):; output.expect.append(np.zeros(n_tsteps, dtype=complex)); need_qobj_state = True; e_ops_data.append(None); continue; if op.dims != rho0.dims:; raise TypeError(f""e_ops dims ({op.dims}) are not ""; f""compatible with the state's ""; f""({rho0.dims})""); e_ops_data.append(spre(op).data); if op.isherm and rho0.isherm:; output.expect.append(np.zeros(n_tsteps)); else:; output.expect.append(np.zeros(n_tsteps, dtype=complex)); else:; raise TypeError(""Expectation parameter must be a list or a function""). if opt.store_states:; output.states = []. def get_curr_state_data(r):; return vec2mat(r.y). #; # start evolution; #; dt = np.diff(tlist); cdata = None; progress_bar.start(n_tsteps); for t_idx, t in enumerate(tlist):; progress_bar.update(t_idx). if not r.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""). if need_qobj_state:; cdata = get_curr_state_data(r); fdata = dense2D_to_fastcsr_fmode(cdata, size, size). # Try to guess if there is a fast path for rho_t; if issuper(rho0) or not rho0.isherm:; rho_t = Qobj(fdata, dims=dims); else:; rho_t = Qobj(fdata, dims=dims, fast=""mc-dm""). if opt.store_states:; output.states.append(rho_t). if expt_callback:; # use callback method; output.expect.append(e_ops(t, rho_t)). for m in range(n_expt_op):; if not isinstance(e_ops[m], Qobj) and callable(e_ops[m]):; output.expect[m][t_idx] = e_ops[m](t, rho_t); else:; output.expect[m][t_idx] = expect_rho_vec(e_ops_data[m], r.y,; e_ops[m].isherm; and rho0.isherm). if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]). progress_bar.finished(). if opt.store_final_state:; cdata = get_curr_state_data(r); output.final_state = Qobj(cdata, dims=dims,; isherm=rho0.isherm or None). return output. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/mesolve.html
https://qutip.org/docs/4.7/modules/qutip/mesolve.html:502,Integrability,integrat,integrate,502,". qutip.mesolve — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.mesolve. Source code for qutip.mesolve; """"""; This module provides solvers for the Lindblad master equation and von Neumann; equation.; """""". __all__ = ['mesolve']. import numpy as np; import scipy.integrate; from qutip.qobj import Qobj, isket, isoper, issuper; from qutip.superoperator import spre, spost, liouvillian, vec2mat, lindblad_dissipator; from qutip.expect import expect_rho_vec; from qutip.solver import Options, Result, solver_safe, SolverSystem; from qutip.cy.spmatfuncs import spmv; from qutip.cy.spconvert import dense2D_to_fastcsr_fmode; from qutip.states import ket2dm; from qutip.sesolve import sesolve; from qutip.ui.progressbar import BaseProgressBar, TextProgressBar; from qutip.qobjevo import QobjEvo. from qutip.cy.openmp.utilities import check_use_openmp. # -----------------------------------------------------------------------------; # pass on to wavefunction solver or master equation solver depending on whether; # any collapse operators were given.; #; [docs]def mesolve(H, rho0, tlist, c_ops=None, e_ops=None, args=None, options=None,; progress_bar=None, _safe_mode=True):; """"""; Master equation evolution of a density matrix for a given Hamiltonian and; set of collapse operators, or a Liouvillian. Evolve the state vector or density matrix (`rho0`) using a given; Hamiltonian or Liouvillian (`H`) and an optional set of collapse operators; (`c_ops`), by integrating the set of ordinary differential equations; that define the system. In the absence of collapse operators the system is; evolved according to the unitary evolution of the Hamiltonian. The output is either the state vector at arbitrary points in time; (`tlist`), or the expectation values of the supp",MatchSource.WIKI,docs/4.7/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/mesolve.html
https://qutip.org/docs/4.7/modules/qutip/mesolve.html:1225,Integrability,depend,depending,1225,"evelopment Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.mesolve. Source code for qutip.mesolve; """"""; This module provides solvers for the Lindblad master equation and von Neumann; equation.; """""". __all__ = ['mesolve']. import numpy as np; import scipy.integrate; from qutip.qobj import Qobj, isket, isoper, issuper; from qutip.superoperator import spre, spost, liouvillian, vec2mat, lindblad_dissipator; from qutip.expect import expect_rho_vec; from qutip.solver import Options, Result, solver_safe, SolverSystem; from qutip.cy.spmatfuncs import spmv; from qutip.cy.spconvert import dense2D_to_fastcsr_fmode; from qutip.states import ket2dm; from qutip.sesolve import sesolve; from qutip.ui.progressbar import BaseProgressBar, TextProgressBar; from qutip.qobjevo import QobjEvo. from qutip.cy.openmp.utilities import check_use_openmp. # -----------------------------------------------------------------------------; # pass on to wavefunction solver or master equation solver depending on whether; # any collapse operators were given.; #; [docs]def mesolve(H, rho0, tlist, c_ops=None, e_ops=None, args=None, options=None,; progress_bar=None, _safe_mode=True):; """"""; Master equation evolution of a density matrix for a given Hamiltonian and; set of collapse operators, or a Liouvillian. Evolve the state vector or density matrix (`rho0`) using a given; Hamiltonian or Liouvillian (`H`) and an optional set of collapse operators; (`c_ops`), by integrating the set of ordinary differential equations; that define the system. In the absence of collapse operators the system is; evolved according to the unitary evolution of the Hamiltonian. The output is either the state vector at arbitrary points in time; (`tlist`), or the expectation values of the supplied operators; (`e_ops`). If e_ops is a callback function, it is invoked for each; time in `tlist` with time and the state as arguments, and the function; does not use any return val",MatchSource.WIKI,docs/4.7/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/mesolve.html
https://qutip.org/docs/4.7/modules/qutip/mesolve.html:1691,Integrability,integrat,integrating,1691,"; from qutip.expect import expect_rho_vec; from qutip.solver import Options, Result, solver_safe, SolverSystem; from qutip.cy.spmatfuncs import spmv; from qutip.cy.spconvert import dense2D_to_fastcsr_fmode; from qutip.states import ket2dm; from qutip.sesolve import sesolve; from qutip.ui.progressbar import BaseProgressBar, TextProgressBar; from qutip.qobjevo import QobjEvo. from qutip.cy.openmp.utilities import check_use_openmp. # -----------------------------------------------------------------------------; # pass on to wavefunction solver or master equation solver depending on whether; # any collapse operators were given.; #; [docs]def mesolve(H, rho0, tlist, c_ops=None, e_ops=None, args=None, options=None,; progress_bar=None, _safe_mode=True):; """"""; Master equation evolution of a density matrix for a given Hamiltonian and; set of collapse operators, or a Liouvillian. Evolve the state vector or density matrix (`rho0`) using a given; Hamiltonian or Liouvillian (`H`) and an optional set of collapse operators; (`c_ops`), by integrating the set of ordinary differential equations; that define the system. In the absence of collapse operators the system is; evolved according to the unitary evolution of the Hamiltonian. The output is either the state vector at arbitrary points in time; (`tlist`), or the expectation values of the supplied operators; (`e_ops`). If e_ops is a callback function, it is invoked for each; time in `tlist` with time and the state as arguments, and the function; does not use any return values. If either `H` or the Qobj elements in `c_ops` are superoperators, they; will be treated as direct contributions to the total system Liouvillian.; This allows the solution of master equations that are not in standard; Lindblad form. **Time-dependent operators**. For time-dependent problems, `H` and `c_ops` can be a specified in a; nested-list format where each element in the list is a list of length 2,; containing an operator (:class:`qutip.qobj`) at the first",MatchSource.WIKI,docs/4.7/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/mesolve.html
https://qutip.org/docs/4.7/modules/qutip/mesolve.html:2428,Integrability,depend,dependent,2428,"ution of a density matrix for a given Hamiltonian and; set of collapse operators, or a Liouvillian. Evolve the state vector or density matrix (`rho0`) using a given; Hamiltonian or Liouvillian (`H`) and an optional set of collapse operators; (`c_ops`), by integrating the set of ordinary differential equations; that define the system. In the absence of collapse operators the system is; evolved according to the unitary evolution of the Hamiltonian. The output is either the state vector at arbitrary points in time; (`tlist`), or the expectation values of the supplied operators; (`e_ops`). If e_ops is a callback function, it is invoked for each; time in `tlist` with time and the state as arguments, and the function; does not use any return values. If either `H` or the Qobj elements in `c_ops` are superoperators, they; will be treated as direct contributions to the total system Liouvillian.; This allows the solution of master equations that are not in standard; Lindblad form. **Time-dependent operators**. For time-dependent problems, `H` and `c_ops` can be a specified in a; nested-list format where each element in the list is a list of length 2,; containing an operator (:class:`qutip.qobj`) at the first element and where; the second element is either a string (*list string format*), a callback; function (*list callback format*) that evaluates to the time-dependent; coefficient for the corresponding operator, or a NumPy array (*list; array format*) which specifies the value of the coefficient to the; corresponding operator for each value of t in `tlist`. Alternatively, `H` (but not `c_ops`) can be a callback function with the; signature `f(t, args) -> Qobj` (*callback format*), which can return the; Hamiltonian or Liouvillian superoperator at any point in time. If the; equation cannot be put in standard Lindblad form, then this time-dependence; format must be used. *Examples*. H = [[H0, 'sin(w*t)'], [H1, 'sin(2*w*t)']]. H = [[H0, f0_t], [H1, f1_t]]. where f0_t and f1_t ar",MatchSource.WIKI,docs/4.7/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/mesolve.html
https://qutip.org/docs/4.7/modules/qutip/mesolve.html:2460,Integrability,depend,dependent,2460," the state vector or density matrix (`rho0`) using a given; Hamiltonian or Liouvillian (`H`) and an optional set of collapse operators; (`c_ops`), by integrating the set of ordinary differential equations; that define the system. In the absence of collapse operators the system is; evolved according to the unitary evolution of the Hamiltonian. The output is either the state vector at arbitrary points in time; (`tlist`), or the expectation values of the supplied operators; (`e_ops`). If e_ops is a callback function, it is invoked for each; time in `tlist` with time and the state as arguments, and the function; does not use any return values. If either `H` or the Qobj elements in `c_ops` are superoperators, they; will be treated as direct contributions to the total system Liouvillian.; This allows the solution of master equations that are not in standard; Lindblad form. **Time-dependent operators**. For time-dependent problems, `H` and `c_ops` can be a specified in a; nested-list format where each element in the list is a list of length 2,; containing an operator (:class:`qutip.qobj`) at the first element and where; the second element is either a string (*list string format*), a callback; function (*list callback format*) that evaluates to the time-dependent; coefficient for the corresponding operator, or a NumPy array (*list; array format*) which specifies the value of the coefficient to the; corresponding operator for each value of t in `tlist`. Alternatively, `H` (but not `c_ops`) can be a callback function with the; signature `f(t, args) -> Qobj` (*callback format*), which can return the; Hamiltonian or Liouvillian superoperator at any point in time. If the; equation cannot be put in standard Lindblad form, then this time-dependence; format must be used. *Examples*. H = [[H0, 'sin(w*t)'], [H1, 'sin(2*w*t)']]. H = [[H0, f0_t], [H1, f1_t]]. where f0_t and f1_t are python functions with signature f_t(t, args). H = [[H0, np.sin(w*tlist)], [H1, np.sin(2*w*tlist)]]. In th",MatchSource.WIKI,docs/4.7/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/mesolve.html
https://qutip.org/docs/4.7/modules/qutip/mesolve.html:2807,Integrability,depend,dependent,2807,"; evolved according to the unitary evolution of the Hamiltonian. The output is either the state vector at arbitrary points in time; (`tlist`), or the expectation values of the supplied operators; (`e_ops`). If e_ops is a callback function, it is invoked for each; time in `tlist` with time and the state as arguments, and the function; does not use any return values. If either `H` or the Qobj elements in `c_ops` are superoperators, they; will be treated as direct contributions to the total system Liouvillian.; This allows the solution of master equations that are not in standard; Lindblad form. **Time-dependent operators**. For time-dependent problems, `H` and `c_ops` can be a specified in a; nested-list format where each element in the list is a list of length 2,; containing an operator (:class:`qutip.qobj`) at the first element and where; the second element is either a string (*list string format*), a callback; function (*list callback format*) that evaluates to the time-dependent; coefficient for the corresponding operator, or a NumPy array (*list; array format*) which specifies the value of the coefficient to the; corresponding operator for each value of t in `tlist`. Alternatively, `H` (but not `c_ops`) can be a callback function with the; signature `f(t, args) -> Qobj` (*callback format*), which can return the; Hamiltonian or Liouvillian superoperator at any point in time. If the; equation cannot be put in standard Lindblad form, then this time-dependence; format must be used. *Examples*. H = [[H0, 'sin(w*t)'], [H1, 'sin(2*w*t)']]. H = [[H0, f0_t], [H1, f1_t]]. where f0_t and f1_t are python functions with signature f_t(t, args). H = [[H0, np.sin(w*tlist)], [H1, np.sin(2*w*tlist)]]. In the *list string format* and *list callback format*, the string; expression and the callback function must evaluate to a real or complex; number (coefficient for the corresponding operator). In all cases of time-dependent operators, `args` is a dictionary of; parameters that is us",MatchSource.WIKI,docs/4.7/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/mesolve.html
https://qutip.org/docs/4.7/modules/qutip/mesolve.html:3294,Integrability,depend,dependence,3294,"ted as direct contributions to the total system Liouvillian.; This allows the solution of master equations that are not in standard; Lindblad form. **Time-dependent operators**. For time-dependent problems, `H` and `c_ops` can be a specified in a; nested-list format where each element in the list is a list of length 2,; containing an operator (:class:`qutip.qobj`) at the first element and where; the second element is either a string (*list string format*), a callback; function (*list callback format*) that evaluates to the time-dependent; coefficient for the corresponding operator, or a NumPy array (*list; array format*) which specifies the value of the coefficient to the; corresponding operator for each value of t in `tlist`. Alternatively, `H` (but not `c_ops`) can be a callback function with the; signature `f(t, args) -> Qobj` (*callback format*), which can return the; Hamiltonian or Liouvillian superoperator at any point in time. If the; equation cannot be put in standard Lindblad form, then this time-dependence; format must be used. *Examples*. H = [[H0, 'sin(w*t)'], [H1, 'sin(2*w*t)']]. H = [[H0, f0_t], [H1, f1_t]]. where f0_t and f1_t are python functions with signature f_t(t, args). H = [[H0, np.sin(w*tlist)], [H1, np.sin(2*w*tlist)]]. In the *list string format* and *list callback format*, the string; expression and the callback function must evaluate to a real or complex; number (coefficient for the corresponding operator). In all cases of time-dependent operators, `args` is a dictionary of; parameters that is used when evaluating operators. It is passed to the; callback functions as their second argument. **Additional options**. Additional options to mesolve can be set via the `options` argument, which; should be an instance of :class:`qutip.solver.Options`. Many ODE; integration options can be set this way, and the `store_states` and; `store_final_state` options can be used to store states even though; expectation values are requested via the `e_ops` arg",MatchSource.WIKI,docs/4.7/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/mesolve.html
https://qutip.org/docs/4.7/modules/qutip/mesolve.html:3752,Integrability,depend,dependent,3752,"ates to the time-dependent; coefficient for the corresponding operator, or a NumPy array (*list; array format*) which specifies the value of the coefficient to the; corresponding operator for each value of t in `tlist`. Alternatively, `H` (but not `c_ops`) can be a callback function with the; signature `f(t, args) -> Qobj` (*callback format*), which can return the; Hamiltonian or Liouvillian superoperator at any point in time. If the; equation cannot be put in standard Lindblad form, then this time-dependence; format must be used. *Examples*. H = [[H0, 'sin(w*t)'], [H1, 'sin(2*w*t)']]. H = [[H0, f0_t], [H1, f1_t]]. where f0_t and f1_t are python functions with signature f_t(t, args). H = [[H0, np.sin(w*tlist)], [H1, np.sin(2*w*tlist)]]. In the *list string format* and *list callback format*, the string; expression and the callback function must evaluate to a real or complex; number (coefficient for the corresponding operator). In all cases of time-dependent operators, `args` is a dictionary of; parameters that is used when evaluating operators. It is passed to the; callback functions as their second argument. **Additional options**. Additional options to mesolve can be set via the `options` argument, which; should be an instance of :class:`qutip.solver.Options`. Many ODE; integration options can be set this way, and the `store_states` and; `store_final_state` options can be used to store states even though; expectation values are requested via the `e_ops` argument. .. note::. If an element in the list-specification of the Hamiltonian or; the list of collapse operators are in superoperator form it will be; added to the total Liouvillian of the problem without further; transformation. This allows for using mesolve for solving master; equations that are not in standard Lindblad form. .. note::. On using callback functions: mesolve transforms all :class:`qutip.Qobj`; objects to sparse matrices before handing the problem to the integrator; function. In order for your cal",MatchSource.WIKI,docs/4.7/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/mesolve.html
https://qutip.org/docs/4.7/modules/qutip/mesolve.html:4083,Integrability,integrat,integration,4083,"ouvillian superoperator at any point in time. If the; equation cannot be put in standard Lindblad form, then this time-dependence; format must be used. *Examples*. H = [[H0, 'sin(w*t)'], [H1, 'sin(2*w*t)']]. H = [[H0, f0_t], [H1, f1_t]]. where f0_t and f1_t are python functions with signature f_t(t, args). H = [[H0, np.sin(w*tlist)], [H1, np.sin(2*w*tlist)]]. In the *list string format* and *list callback format*, the string; expression and the callback function must evaluate to a real or complex; number (coefficient for the corresponding operator). In all cases of time-dependent operators, `args` is a dictionary of; parameters that is used when evaluating operators. It is passed to the; callback functions as their second argument. **Additional options**. Additional options to mesolve can be set via the `options` argument, which; should be an instance of :class:`qutip.solver.Options`. Many ODE; integration options can be set this way, and the `store_states` and; `store_final_state` options can be used to store states even though; expectation values are requested via the `e_ops` argument. .. note::. If an element in the list-specification of the Hamiltonian or; the list of collapse operators are in superoperator form it will be; added to the total Liouvillian of the problem without further; transformation. This allows for using mesolve for solving master; equations that are not in standard Lindblad form. .. note::. On using callback functions: mesolve transforms all :class:`qutip.Qobj`; objects to sparse matrices before handing the problem to the integrator; function. In order for your callback function to work correctly, pass; all :class:`qutip.Qobj` objects that are used in constructing the; Hamiltonian via `args`. mesolve will check for :class:`qutip.Qobj` in; `args` and handle the conversion to sparse matrices. All other; :class:`qutip.Qobj` objects that are not passed via `args` will be; passed on to the integrator in scipy which will raise a NotImplemented; exce",MatchSource.WIKI,docs/4.7/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/mesolve.html
https://qutip.org/docs/4.7/modules/qutip/mesolve.html:4747,Integrability,integrat,integrator,4747,"rator). In all cases of time-dependent operators, `args` is a dictionary of; parameters that is used when evaluating operators. It is passed to the; callback functions as their second argument. **Additional options**. Additional options to mesolve can be set via the `options` argument, which; should be an instance of :class:`qutip.solver.Options`. Many ODE; integration options can be set this way, and the `store_states` and; `store_final_state` options can be used to store states even though; expectation values are requested via the `e_ops` argument. .. note::. If an element in the list-specification of the Hamiltonian or; the list of collapse operators are in superoperator form it will be; added to the total Liouvillian of the problem without further; transformation. This allows for using mesolve for solving master; equations that are not in standard Lindblad form. .. note::. On using callback functions: mesolve transforms all :class:`qutip.Qobj`; objects to sparse matrices before handing the problem to the integrator; function. In order for your callback function to work correctly, pass; all :class:`qutip.Qobj` objects that are used in constructing the; Hamiltonian via `args`. mesolve will check for :class:`qutip.Qobj` in; `args` and handle the conversion to sparse matrices. All other; :class:`qutip.Qobj` objects that are not passed via `args` will be; passed on to the integrator in scipy which will raise a NotImplemented; exception. Parameters; ----------. H : :class:`qutip.Qobj`; System Hamiltonian, or a callback function for time-dependent; Hamiltonians, or alternatively a system Liouvillian. rho0 : :class:`qutip.Qobj`; initial density matrix or state vector (ket). tlist : *list* / *array*; list of times for :math:`t`. c_ops : None / list of :class:`qutip.Qobj`; single collapse operator, or list of collapse operators, or a list; of Liouvillian superoperators. e_ops : None / list / callback function, optional; A list of operators as `Qobj` and/or callable functio",MatchSource.WIKI,docs/4.7/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/mesolve.html
https://qutip.org/docs/4.7/modules/qutip/mesolve.html:5117,Integrability,integrat,integrator,5117,"this way, and the `store_states` and; `store_final_state` options can be used to store states even though; expectation values are requested via the `e_ops` argument. .. note::. If an element in the list-specification of the Hamiltonian or; the list of collapse operators are in superoperator form it will be; added to the total Liouvillian of the problem without further; transformation. This allows for using mesolve for solving master; equations that are not in standard Lindblad form. .. note::. On using callback functions: mesolve transforms all :class:`qutip.Qobj`; objects to sparse matrices before handing the problem to the integrator; function. In order for your callback function to work correctly, pass; all :class:`qutip.Qobj` objects that are used in constructing the; Hamiltonian via `args`. mesolve will check for :class:`qutip.Qobj` in; `args` and handle the conversion to sparse matrices. All other; :class:`qutip.Qobj` objects that are not passed via `args` will be; passed on to the integrator in scipy which will raise a NotImplemented; exception. Parameters; ----------. H : :class:`qutip.Qobj`; System Hamiltonian, or a callback function for time-dependent; Hamiltonians, or alternatively a system Liouvillian. rho0 : :class:`qutip.Qobj`; initial density matrix or state vector (ket). tlist : *list* / *array*; list of times for :math:`t`. c_ops : None / list of :class:`qutip.Qobj`; single collapse operator, or list of collapse operators, or a list; of Liouvillian superoperators. e_ops : None / list / callback function, optional; A list of operators as `Qobj` and/or callable functions (can be mixed); or a single callable function. For operators, the result's expect will; be computed by :func:`qutip.expect`. For callable functions, they are; called as ``f(t, state)`` and return the expectation value.; A single callback's expectation value can be any type, but a callback; part of a list must return a number as the expectation value. args : None / *dictionary*; dictio",MatchSource.WIKI,docs/4.7/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/mesolve.html
https://qutip.org/docs/4.7/modules/qutip/mesolve.html:5284,Integrability,depend,dependent,5284,"e::. If an element in the list-specification of the Hamiltonian or; the list of collapse operators are in superoperator form it will be; added to the total Liouvillian of the problem without further; transformation. This allows for using mesolve for solving master; equations that are not in standard Lindblad form. .. note::. On using callback functions: mesolve transforms all :class:`qutip.Qobj`; objects to sparse matrices before handing the problem to the integrator; function. In order for your callback function to work correctly, pass; all :class:`qutip.Qobj` objects that are used in constructing the; Hamiltonian via `args`. mesolve will check for :class:`qutip.Qobj` in; `args` and handle the conversion to sparse matrices. All other; :class:`qutip.Qobj` objects that are not passed via `args` will be; passed on to the integrator in scipy which will raise a NotImplemented; exception. Parameters; ----------. H : :class:`qutip.Qobj`; System Hamiltonian, or a callback function for time-dependent; Hamiltonians, or alternatively a system Liouvillian. rho0 : :class:`qutip.Qobj`; initial density matrix or state vector (ket). tlist : *list* / *array*; list of times for :math:`t`. c_ops : None / list of :class:`qutip.Qobj`; single collapse operator, or list of collapse operators, or a list; of Liouvillian superoperators. e_ops : None / list / callback function, optional; A list of operators as `Qobj` and/or callable functions (can be mixed); or a single callable function. For operators, the result's expect will; be computed by :func:`qutip.expect`. For callable functions, they are; called as ``f(t, state)`` and return the expectation value.; A single callback's expectation value can be any type, but a callback; part of a list must return a number as the expectation value. args : None / *dictionary*; dictionary of parameters for time-dependent Hamiltonians and; collapse operators. options : None / :class:`qutip.solver.Options`; with options for the solver. progress_bar : None",MatchSource.WIKI,docs/4.7/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/mesolve.html
https://qutip.org/docs/4.7/modules/qutip/mesolve.html:6142,Integrability,depend,dependent,6142,"py which will raise a NotImplemented; exception. Parameters; ----------. H : :class:`qutip.Qobj`; System Hamiltonian, or a callback function for time-dependent; Hamiltonians, or alternatively a system Liouvillian. rho0 : :class:`qutip.Qobj`; initial density matrix or state vector (ket). tlist : *list* / *array*; list of times for :math:`t`. c_ops : None / list of :class:`qutip.Qobj`; single collapse operator, or list of collapse operators, or a list; of Liouvillian superoperators. e_ops : None / list / callback function, optional; A list of operators as `Qobj` and/or callable functions (can be mixed); or a single callable function. For operators, the result's expect will; be computed by :func:`qutip.expect`. For callable functions, they are; called as ``f(t, state)`` and return the expectation value.; A single callback's expectation value can be any type, but a callback; part of a list must return a number as the expectation value. args : None / *dictionary*; dictionary of parameters for time-dependent Hamiltonians and; collapse operators. options : None / :class:`qutip.solver.Options`; with options for the solver. progress_bar : None / BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. Returns; -------; result: :class:`qutip.solver.Result`. An instance of the class :class:`qutip.solver.Result`, which contains; either an *array* `result.expect` of expectation values for the times; specified by `tlist`, or an *array* `result.states` of state vectors or; density matrices corresponding to the times in `tlist` [if `e_ops` is; an empty list], or nothing if a callback function was given in place of; operators for which to calculate the expectation values. """"""; if c_ops is None:; c_ops = []; if isinstance(c_ops, (Qobj, QobjEvo)):; c_ops = [c_ops]. if e_ops is None:; e_ops = []; if isinstance(e_ops, Qobj):; e_ops = [e_ops]. if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.value",MatchSource.WIKI,docs/4.7/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/mesolve.html
https://qutip.org/docs/4.7/modules/qutip/mesolve.html:9498,Integrability,depend,dependent,9498,"o0.dims[0] != rho0.dims[1]):; raise ValueError(; ""input state must be a pure state vector, square density matrix, ""; ""or superoperator""; ). if isinstance(H, SolverSystem):; ss = H; elif isinstance(H, (list, Qobj, QobjEvo)):; ss = _mesolve_QobjEvo(H, c_ops, tlist, args, options); elif callable(H):; ss = _mesolve_func_td(H, c_ops, rho0, tlist, args, options); else:; raise Exception(""Invalid H type""). func, ode_args = ss.makefunc(ss, rho0, args, e_ops, options). if _safe_mode:; # This is to test safety of the function before starting the loop.; v = rho0.full().ravel('F'); func(0., v, *ode_args) + v. res = _generic_ode_solve(func, ode_args, rho0, tlist, e_ops, options,; progress_bar, dims=rho0.dims); res.num_collapse = len(c_ops). if e_ops_dict:; res.expect = {e: res.expect[n]; for n, e in enumerate(e_ops_dict.keys())}. return res. # -----------------------------------------------------------------------------; # A time-dependent unitary wavefunction equation on the list-function format; #_mesolve_QobjEvo(H, c_ops, tlist, args, options); def _mesolve_QobjEvo(H, c_ops, tlist, args, opt):; """"""; Prepare the system for the solver, H can be an QobjEvo.; """"""; H_td = QobjEvo(H, args, tlist=tlist); if not issuper(H_td.cte):; L_td = liouvillian(H_td); else:; L_td = H_td; for op in c_ops:; # We want to avoid passing tlist where it isn't necessary, to allow a; # Hamiltonian/Liouvillian which already _has_ time-dependence not equal; # to the mesolve evaluation times to be used in conjunction with; # time-independent c_ops. If we _always_ pass it, it may appear to; # QobjEvo that there is a tlist mismatch, even though it is not used.; if isinstance(op, Qobj):; op_td = QobjEvo(op); elif isinstance(op, QobjEvo):; op_td = QobjEvo(op, args); else:; op_td = QobjEvo(op, args, tlist=tlist); if not issuper(op_td.cte):; op_td = lindblad_dissipator(op_td); L_td += op_td. if opt.rhs_with_state:; L_td._check_old_with_state(). nthread = opt.openmp_threads if opt.use_openmp else 0; L_td.compile(o",MatchSource.WIKI,docs/4.7/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/mesolve.html
https://qutip.org/docs/4.7/modules/qutip/mesolve.html:9987,Integrability,depend,dependence,9987,"ion(""Invalid H type""). func, ode_args = ss.makefunc(ss, rho0, args, e_ops, options). if _safe_mode:; # This is to test safety of the function before starting the loop.; v = rho0.full().ravel('F'); func(0., v, *ode_args) + v. res = _generic_ode_solve(func, ode_args, rho0, tlist, e_ops, options,; progress_bar, dims=rho0.dims); res.num_collapse = len(c_ops). if e_ops_dict:; res.expect = {e: res.expect[n]; for n, e in enumerate(e_ops_dict.keys())}. return res. # -----------------------------------------------------------------------------; # A time-dependent unitary wavefunction equation on the list-function format; #_mesolve_QobjEvo(H, c_ops, tlist, args, options); def _mesolve_QobjEvo(H, c_ops, tlist, args, opt):; """"""; Prepare the system for the solver, H can be an QobjEvo.; """"""; H_td = QobjEvo(H, args, tlist=tlist); if not issuper(H_td.cte):; L_td = liouvillian(H_td); else:; L_td = H_td; for op in c_ops:; # We want to avoid passing tlist where it isn't necessary, to allow a; # Hamiltonian/Liouvillian which already _has_ time-dependence not equal; # to the mesolve evaluation times to be used in conjunction with; # time-independent c_ops. If we _always_ pass it, it may appear to; # QobjEvo that there is a tlist mismatch, even though it is not used.; if isinstance(op, Qobj):; op_td = QobjEvo(op); elif isinstance(op, QobjEvo):; op_td = QobjEvo(op, args); else:; op_td = QobjEvo(op, args, tlist=tlist); if not issuper(op_td.cte):; op_td = lindblad_dissipator(op_td); L_td += op_td. if opt.rhs_with_state:; L_td._check_old_with_state(). nthread = opt.openmp_threads if opt.use_openmp else 0; L_td.compile(omp=nthread). ss = SolverSystem(); ss.H = L_td; ss.makefunc = _qobjevo_set; solver_safe[""mesolve""] = ss; return ss. def _test_liouvillian_dimensions(L_dims, rho_dims):; """"""; Raise ValueError if the dimensions of the Liouvillian and the density; matrix or superoperator state are incompatible with the master equation.; """"""; if L_dims[0] != L_dims[1]:; raise ValueError(""Liouvillia",MatchSource.WIKI,docs/4.7/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/mesolve.html
https://qutip.org/docs/4.7/modules/qutip/mesolve.html:11796,Integrability,depend,dependence,11796," """"""; Raise ValueError if the dimensions of the Liouvillian and the density; matrix or superoperator state are incompatible with the master equation.; """"""; if L_dims[0] != L_dims[1]:; raise ValueError(""Liouvillian had nonsquare dims: "" + str(L_dims)); if not ((L_dims[1] == rho_dims) or (L_dims[1] == rho_dims[0])):; raise ValueError("""".join([; ""incompatible Liouvillian and state dimensions: "",; str(L_dims), "" and "", str(rho_dims),; ])). def _qobjevo_set(HS, rho0, args, e_ops, opt):; """"""; From the system, get the ode function and args; """"""; H_td = HS.H; H_td.solver_set_args(args, rho0, e_ops); if issuper(rho0):; func = H_td.compiled_qobjevo.ode_mul_mat_f_vec; elif rho0.isket or rho0.isoper:; func = H_td.compiled_qobjevo.mul_vec; else:; # Should be caught earlier in mesolve.; raise ValueError(""rho0 must be a ket, density matrix or superoperator""); _test_liouvillian_dimensions(H_td.cte.dims, rho0.dims); return func, (). # -----------------------------------------------------------------------------; # Master equation solver for python-function time-dependence.; #; class _LiouvillianFromFunc:; def __init__(self, func, c_ops, rho_dims):; self.f = func; self.c_ops = c_ops; self.rho_dims = rho_dims. def H2L(self, t, rho, args):; Ht = self.f(t, args); Lt = -1.0j * (spre(Ht) - spost(Ht)); _test_liouvillian_dimensions(Lt.dims, self.rho_dims); Lt = Lt.data; for op in self.c_ops:; Lt += op(t).data; return Lt. def H2L_with_state(self, t, rho, args):; Ht = self.f(t, rho, args); Lt = -1.0j * (spre(Ht) - spost(Ht)); _test_liouvillian_dimensions(Lt.dims, self.rho_dims); Lt = Lt.data; for op in self.c_ops:; Lt += op(t).data; return Lt. def L(self, t, rho, args):; Lt = self.f(t, args); _test_liouvillian_dimensions(Lt.dims, self.rho_dims); Lt = Lt.data; for op in self.c_ops:; Lt += op(t).data; return Lt. def L_with_state(self, t, rho, args):; Lt = self.f(t, rho, args); _test_liouvillian_dimensions(Lt.dims, self.rho_dims); Lt = Lt.data; for op in self.c_ops:; Lt += op(t).data; return Lt. ",MatchSource.WIKI,docs/4.7/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/mesolve.html
https://qutip.org/docs/4.7/modules/qutip/mesolve.html:12863,Integrability,depend,dependent,12863,"; class _LiouvillianFromFunc:; def __init__(self, func, c_ops, rho_dims):; self.f = func; self.c_ops = c_ops; self.rho_dims = rho_dims. def H2L(self, t, rho, args):; Ht = self.f(t, args); Lt = -1.0j * (spre(Ht) - spost(Ht)); _test_liouvillian_dimensions(Lt.dims, self.rho_dims); Lt = Lt.data; for op in self.c_ops:; Lt += op(t).data; return Lt. def H2L_with_state(self, t, rho, args):; Ht = self.f(t, rho, args); Lt = -1.0j * (spre(Ht) - spost(Ht)); _test_liouvillian_dimensions(Lt.dims, self.rho_dims); Lt = Lt.data; for op in self.c_ops:; Lt += op(t).data; return Lt. def L(self, t, rho, args):; Lt = self.f(t, args); _test_liouvillian_dimensions(Lt.dims, self.rho_dims); Lt = Lt.data; for op in self.c_ops:; Lt += op(t).data; return Lt. def L_with_state(self, t, rho, args):; Lt = self.f(t, rho, args); _test_liouvillian_dimensions(Lt.dims, self.rho_dims); Lt = Lt.data; for op in self.c_ops:; Lt += op(t).data; return Lt. def _mesolve_func_td(L_func, c_op_list, rho0, tlist, args, opt):; """"""; Evolve the density matrix using an ODE solver with time dependent; Hamiltonian.; """"""; c_ops = []; for op in c_op_list:; td = QobjEvo(op, args, tlist=tlist, copy=False); c_ops.append(td if td.cte.issuper else lindblad_dissipator(td)); c_ops_ = [sum(c_ops)] if c_op_list else []; L_api = _LiouvillianFromFunc(L_func, c_ops_, rho0.dims); if opt.rhs_with_state:; obj = L_func(0., rho0.full().ravel(""F""), args); L_func = L_api.L_with_state if issuper(obj) else L_api.H2L_with_state; else:; obj = L_func(0., args); L_func = L_api.L if issuper(obj) else L_api.H2L; ss = SolverSystem(); ss.L = L_func; ss.makefunc = _Lfunc_set; solver_safe[""mesolve""] = ss; return ss. def _Lfunc_set(HS, rho0, args, e_ops, opt):; """"""; From the system, get the ode function and args; """"""; L_func = HS.L; if issuper(rho0):; func = _ode_super_func_td; else:; func = _ode_rho_func_td. return func, (L_func, args). def _ode_rho_func_td(t, y, L_func, args):; L = L_func(t, y, args); return spmv(L, y). def _ode_super_func_td(t, y, L_fu",MatchSource.WIKI,docs/4.7/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/mesolve.html
https://qutip.org/docs/4.7/modules/qutip/mesolve.html:14775,Integrability,integrat,integrate,14775,"f _ode_super_func_td(t, y, L_func, args):; L = L_func(t, y, args); ym = vec2mat(y); return (L*ym).ravel('F'). # -----------------------------------------------------------------------------; # Generic ODE solver: shared code among the various ODE solver; # -----------------------------------------------------------------------------. def _generic_ode_solve(func, ode_args, rho0, tlist, e_ops, opt,; progress_bar, dims=None):; """"""; Internal function for solving ME.; Calculate the required expectation values or invoke; callback function at each time step.; """"""; # %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%; # This function is made similar to sesolve's one for futur merging in a; # solver class; # %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%. # prepare output array; n_tsteps = len(tlist); output = Result(); output.solver = ""mesolve""; output.times = tlist; size = rho0.shape[0]. initial_vector = rho0.full().ravel('F'). r = scipy.integrate.ode(func); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); if ode_args:; r.set_f_params(*ode_args); r.set_initial_value(initial_vector, tlist[0]). e_ops_data = []; output.expect = []; need_qobj_state = opt.store_states; if callable(e_ops):; n_expt_op = 0; expt_callback = True; output.num_expect = 1; need_qobj_state = True; elif isinstance(e_ops, list):; n_expt_op = len(e_ops); expt_callback = False; output.num_expect = n_expt_op; if n_expt_op == 0:; # fall back on storing states; opt.store_states = True; need_qobj_state = True; else:; for op in e_ops:; if not isinstance(op, Qobj) and callable(op):; output.expect.append(np.zeros(n_tsteps, dtype=complex)); need_qobj_state = True; e_ops_data.append(None); continue; if op.dims != rho0.dims:; raise TypeError(f""e_ops dims ({op.dims}) are not ""; f""compatible with the state's ""; f""({rho0.dims})""); e_o",MatchSource.WIKI,docs/4.7/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/mesolve.html
https://qutip.org/docs/4.7/modules/qutip/mesolve.html:16316,Integrability,integrat,integration,16316,"_expt_op == 0:; # fall back on storing states; opt.store_states = True; need_qobj_state = True; else:; for op in e_ops:; if not isinstance(op, Qobj) and callable(op):; output.expect.append(np.zeros(n_tsteps, dtype=complex)); need_qobj_state = True; e_ops_data.append(None); continue; if op.dims != rho0.dims:; raise TypeError(f""e_ops dims ({op.dims}) are not ""; f""compatible with the state's ""; f""({rho0.dims})""); e_ops_data.append(spre(op).data); if op.isherm and rho0.isherm:; output.expect.append(np.zeros(n_tsteps)); else:; output.expect.append(np.zeros(n_tsteps, dtype=complex)); else:; raise TypeError(""Expectation parameter must be a list or a function""). if opt.store_states:; output.states = []. def get_curr_state_data(r):; return vec2mat(r.y). #; # start evolution; #; dt = np.diff(tlist); cdata = None; progress_bar.start(n_tsteps); for t_idx, t in enumerate(tlist):; progress_bar.update(t_idx). if not r.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""). if need_qobj_state:; cdata = get_curr_state_data(r); fdata = dense2D_to_fastcsr_fmode(cdata, size, size). # Try to guess if there is a fast path for rho_t; if issuper(rho0) or not rho0.isherm:; rho_t = Qobj(fdata, dims=dims); else:; rho_t = Qobj(fdata, dims=dims, fast=""mc-dm""). if opt.store_states:; output.states.append(rho_t). if expt_callback:; # use callback method; output.expect.append(e_ops(t, rho_t)). for m in range(n_expt_op):; if not isinstance(e_ops[m], Qobj) and callable(e_ops[m]):; output.expect[m][t_idx] = e_ops[m](t, rho_t); else:; output.expect[m][t_idx] = expect_rho_vec(e_ops_data[m], r.y,; e_ops[m].isherm; and rho0.isherm). if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]). progress_bar.finished(). if opt.store_final_state:; cdata = get_curr_state_data(r); output.final_state = Qobj(cdata, dims=dims,; isherm=rho0.isherm or None). return output. © Copyright 2011 to 2021 inclusive, ",MatchSource.WIKI,docs/4.7/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/mesolve.html
https://qutip.org/docs/4.7/modules/qutip/mesolve.html:17126,Integrability,integrat,integrate,17126,"obj) and callable(op):; output.expect.append(np.zeros(n_tsteps, dtype=complex)); need_qobj_state = True; e_ops_data.append(None); continue; if op.dims != rho0.dims:; raise TypeError(f""e_ops dims ({op.dims}) are not ""; f""compatible with the state's ""; f""({rho0.dims})""); e_ops_data.append(spre(op).data); if op.isherm and rho0.isherm:; output.expect.append(np.zeros(n_tsteps)); else:; output.expect.append(np.zeros(n_tsteps, dtype=complex)); else:; raise TypeError(""Expectation parameter must be a list or a function""). if opt.store_states:; output.states = []. def get_curr_state_data(r):; return vec2mat(r.y). #; # start evolution; #; dt = np.diff(tlist); cdata = None; progress_bar.start(n_tsteps); for t_idx, t in enumerate(tlist):; progress_bar.update(t_idx). if not r.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""). if need_qobj_state:; cdata = get_curr_state_data(r); fdata = dense2D_to_fastcsr_fmode(cdata, size, size). # Try to guess if there is a fast path for rho_t; if issuper(rho0) or not rho0.isherm:; rho_t = Qobj(fdata, dims=dims); else:; rho_t = Qobj(fdata, dims=dims, fast=""mc-dm""). if opt.store_states:; output.states.append(rho_t). if expt_callback:; # use callback method; output.expect.append(e_ops(t, rho_t)). for m in range(n_expt_op):; if not isinstance(e_ops[m], Qobj) and callable(e_ops[m]):; output.expect[m][t_idx] = e_ops[m](t, rho_t); else:; output.expect[m][t_idx] = expect_rho_vec(e_ops_data[m], r.y,; e_ops[m].isherm; and rho0.isherm). if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]). progress_bar.finished(). if opt.store_final_state:; cdata = get_curr_state_data(r); output.final_state = Qobj(cdata, dims=dims,; isherm=rho0.isherm or None). return output. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/mesolve.html
https://qutip.org/docs/4.7/modules/qutip/mesolve.html:1823,Modifiability,evolve,evolved,1823,"mport dense2D_to_fastcsr_fmode; from qutip.states import ket2dm; from qutip.sesolve import sesolve; from qutip.ui.progressbar import BaseProgressBar, TextProgressBar; from qutip.qobjevo import QobjEvo. from qutip.cy.openmp.utilities import check_use_openmp. # -----------------------------------------------------------------------------; # pass on to wavefunction solver or master equation solver depending on whether; # any collapse operators were given.; #; [docs]def mesolve(H, rho0, tlist, c_ops=None, e_ops=None, args=None, options=None,; progress_bar=None, _safe_mode=True):; """"""; Master equation evolution of a density matrix for a given Hamiltonian and; set of collapse operators, or a Liouvillian. Evolve the state vector or density matrix (`rho0`) using a given; Hamiltonian or Liouvillian (`H`) and an optional set of collapse operators; (`c_ops`), by integrating the set of ordinary differential equations; that define the system. In the absence of collapse operators the system is; evolved according to the unitary evolution of the Hamiltonian. The output is either the state vector at arbitrary points in time; (`tlist`), or the expectation values of the supplied operators; (`e_ops`). If e_ops is a callback function, it is invoked for each; time in `tlist` with time and the state as arguments, and the function; does not use any return values. If either `H` or the Qobj elements in `c_ops` are superoperators, they; will be treated as direct contributions to the total system Liouvillian.; This allows the solution of master equations that are not in standard; Lindblad form. **Time-dependent operators**. For time-dependent problems, `H` and `c_ops` can be a specified in a; nested-list format where each element in the list is a list of length 2,; containing an operator (:class:`qutip.qobj`) at the first element and where; the second element is either a string (*list string format*), a callback; function (*list callback format*) that evaluates to the time-dependent; coefficien",MatchSource.WIKI,docs/4.7/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/mesolve.html
https://qutip.org/docs/4.7/modules/qutip/mesolve.html:9066,Safety,safe,safety,9066,"isinstance(H, list) and isinstance(H[0], Qobj) and; issuper(H[0])); or (not isinstance(H, (Qobj, QobjEvo)) and callable(H) and; not options.rhs_with_state and issuper(H(0., args))); or (not isinstance(H, (Qobj, QobjEvo)) and callable(H) and; options.rhs_with_state)). if not use_mesolve:; return sesolve(H, rho0, tlist, e_ops=e_ops, args=args, options=options,; progress_bar=progress_bar, _safe_mode=_safe_mode). if isket(rho0):; rho0 = ket2dm(rho0); if (not (rho0.isoper or rho0.issuper)) or (rho0.dims[0] != rho0.dims[1]):; raise ValueError(; ""input state must be a pure state vector, square density matrix, ""; ""or superoperator""; ). if isinstance(H, SolverSystem):; ss = H; elif isinstance(H, (list, Qobj, QobjEvo)):; ss = _mesolve_QobjEvo(H, c_ops, tlist, args, options); elif callable(H):; ss = _mesolve_func_td(H, c_ops, rho0, tlist, args, options); else:; raise Exception(""Invalid H type""). func, ode_args = ss.makefunc(ss, rho0, args, e_ops, options). if _safe_mode:; # This is to test safety of the function before starting the loop.; v = rho0.full().ravel('F'); func(0., v, *ode_args) + v. res = _generic_ode_solve(func, ode_args, rho0, tlist, e_ops, options,; progress_bar, dims=rho0.dims); res.num_collapse = len(c_ops). if e_ops_dict:; res.expect = {e: res.expect[n]; for n, e in enumerate(e_ops_dict.keys())}. return res. # -----------------------------------------------------------------------------; # A time-dependent unitary wavefunction equation on the list-function format; #_mesolve_QobjEvo(H, c_ops, tlist, args, options); def _mesolve_QobjEvo(H, c_ops, tlist, args, opt):; """"""; Prepare the system for the solver, H can be an QobjEvo.; """"""; H_td = QobjEvo(H, args, tlist=tlist); if not issuper(H_td.cte):; L_td = liouvillian(H_td); else:; L_td = H_td; for op in c_ops:; # We want to avoid passing tlist where it isn't necessary, to allow a; # Hamiltonian/Liouvillian which already _has_ time-dependence not equal; # to the mesolve evaluation times to be used in conjunction with",MatchSource.WIKI,docs/4.7/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/mesolve.html
https://qutip.org/docs/4.7/modules/qutip/mesolve.html:9878,Safety,avoid,avoid,9878,"ion(""Invalid H type""). func, ode_args = ss.makefunc(ss, rho0, args, e_ops, options). if _safe_mode:; # This is to test safety of the function before starting the loop.; v = rho0.full().ravel('F'); func(0., v, *ode_args) + v. res = _generic_ode_solve(func, ode_args, rho0, tlist, e_ops, options,; progress_bar, dims=rho0.dims); res.num_collapse = len(c_ops). if e_ops_dict:; res.expect = {e: res.expect[n]; for n, e in enumerate(e_ops_dict.keys())}. return res. # -----------------------------------------------------------------------------; # A time-dependent unitary wavefunction equation on the list-function format; #_mesolve_QobjEvo(H, c_ops, tlist, args, options); def _mesolve_QobjEvo(H, c_ops, tlist, args, opt):; """"""; Prepare the system for the solver, H can be an QobjEvo.; """"""; H_td = QobjEvo(H, args, tlist=tlist); if not issuper(H_td.cte):; L_td = liouvillian(H_td); else:; L_td = H_td; for op in c_ops:; # We want to avoid passing tlist where it isn't necessary, to allow a; # Hamiltonian/Liouvillian which already _has_ time-dependence not equal; # to the mesolve evaluation times to be used in conjunction with; # time-independent c_ops. If we _always_ pass it, it may appear to; # QobjEvo that there is a tlist mismatch, even though it is not used.; if isinstance(op, Qobj):; op_td = QobjEvo(op); elif isinstance(op, QobjEvo):; op_td = QobjEvo(op, args); else:; op_td = QobjEvo(op, args, tlist=tlist); if not issuper(op_td.cte):; op_td = lindblad_dissipator(op_td); L_td += op_td. if opt.rhs_with_state:; L_td._check_old_with_state(). nthread = opt.openmp_threads if opt.use_openmp else 0; L_td.compile(omp=nthread). ss = SolverSystem(); ss.H = L_td; ss.makefunc = _qobjevo_set; solver_safe[""mesolve""] = ss; return ss. def _test_liouvillian_dimensions(L_dims, rho_dims):; """"""; Raise ValueError if the dimensions of the Liouvillian and the density; matrix or superoperator state are incompatible with the master equation.; """"""; if L_dims[0] != L_dims[1]:; raise ValueError(""Liouvillia",MatchSource.WIKI,docs/4.7/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/mesolve.html
https://qutip.org/docs/4.7/modules/qutip/mesolve.html:9061,Testability,test,test,9061,"isinstance(H, list) and isinstance(H[0], Qobj) and; issuper(H[0])); or (not isinstance(H, (Qobj, QobjEvo)) and callable(H) and; not options.rhs_with_state and issuper(H(0., args))); or (not isinstance(H, (Qobj, QobjEvo)) and callable(H) and; options.rhs_with_state)). if not use_mesolve:; return sesolve(H, rho0, tlist, e_ops=e_ops, args=args, options=options,; progress_bar=progress_bar, _safe_mode=_safe_mode). if isket(rho0):; rho0 = ket2dm(rho0); if (not (rho0.isoper or rho0.issuper)) or (rho0.dims[0] != rho0.dims[1]):; raise ValueError(; ""input state must be a pure state vector, square density matrix, ""; ""or superoperator""; ). if isinstance(H, SolverSystem):; ss = H; elif isinstance(H, (list, Qobj, QobjEvo)):; ss = _mesolve_QobjEvo(H, c_ops, tlist, args, options); elif callable(H):; ss = _mesolve_func_td(H, c_ops, rho0, tlist, args, options); else:; raise Exception(""Invalid H type""). func, ode_args = ss.makefunc(ss, rho0, args, e_ops, options). if _safe_mode:; # This is to test safety of the function before starting the loop.; v = rho0.full().ravel('F'); func(0., v, *ode_args) + v. res = _generic_ode_solve(func, ode_args, rho0, tlist, e_ops, options,; progress_bar, dims=rho0.dims); res.num_collapse = len(c_ops). if e_ops_dict:; res.expect = {e: res.expect[n]; for n, e in enumerate(e_ops_dict.keys())}. return res. # -----------------------------------------------------------------------------; # A time-dependent unitary wavefunction equation on the list-function format; #_mesolve_QobjEvo(H, c_ops, tlist, args, options); def _mesolve_QobjEvo(H, c_ops, tlist, args, opt):; """"""; Prepare the system for the solver, H can be an QobjEvo.; """"""; H_td = QobjEvo(H, args, tlist=tlist); if not issuper(H_td.cte):; L_td = liouvillian(H_td); else:; L_td = H_td; for op in c_ops:; # We want to avoid passing tlist where it isn't necessary, to allow a; # Hamiltonian/Liouvillian which already _has_ time-dependence not equal; # to the mesolve evaluation times to be used in conjunction with",MatchSource.WIKI,docs/4.7/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/mesolve.html
https://qutip.org/docs/4.7/modules/qutip/metrics.html:10551,Availability,error,error,10551,"Ti and SchattenNorms.jl. (By contrast,; # QETLAB uses the dual problem.). # Check if A and B are both unitaries. If so, then we can without; # loss of generality choose B to be the identity by using the; # unitary invariance of the diamond norm,; # || A - B ||_♢ = || A B⁺ - I ||_♢.; # Then, using the technique mentioned by each of Johnston and; # da Silva,; # || A B⁺ - I ||_♢ = max_{i, j} | \lambda_i(A B⁺) - \lambda_j(A B⁺) |,; # where \lambda_i(U) is the ith eigenvalue of U. if (; # There's a lot of conditions to check for this path.; not force_solve and B is not None and; # Only check if they aren't superoperators.; A.type == ""oper"" and B.type == ""oper"" and; # The difference of unitaries optimization is currently; # only implemented for d == 2. Much of the code below is more general,; # though, in anticipation of generalizing the optimization.; A.shape[0] == 2; ):; # Make an identity the same size as A and B to; # compare against.; I = qeye(A.dims[0]); # Compare to B first, so that an error is raised; # as soon as possible.; Bd = B.dag(); if (; (B * Bd - I).norm() < 1e-6 and; (A * A.dag() - I).norm() < 1e-6; ):; # Now we are on the fast path, so let's compute the; # eigenvalues, then find the diameter of the smallest circle; # containing all of them.; #; # For now, this is only implemented for dim = 2, such that; # generalizing here will allow for generalizing the optimization.; # A reasonable approach would probably be to use Welzl's algorithm; # (https://en.wikipedia.org/wiki/Smallest-circle_problem).; U = A * B.dag(); eigs = U.eigenenergies(); eig_distances = np.abs(eigs[:, None] - eigs[None, :]); return np.max(eig_distances). # Force the input superoperator to be a Choi matrix.; J = to_choi(A). if B is not None:; J -= to_choi(B). # Watrous 2012 also points out that the diamond norm of Lambda; # is the same as the completely-bounded operator-norm (∞-norm); # of the dual map of Lambda. We can evaluate that norm much more; # easily if Lambda is completely positiv",MatchSource.WIKI,docs/4.7/modules/qutip/metrics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/metrics.html
https://qutip.org/docs/4.7/modules/qutip/metrics.html:9379,Deployability,install,installed,9379,"_solve=False,; sparse=True):; """"""; Calculates the diamond norm of the quantum map q_oper, using; the simplified semidefinite program of [Wat13]_. The diamond norm SDP is solved by using CVXPY_. Parameters; ----------; A : Qobj; Quantum map to take the diamond norm of.; B : Qobj or None; If provided, the diamond norm of :math:`A - B` is taken instead.; solver : str; Solver to use with CVXPY. One of ""CVXOPT"" (default) or ""SCS"". The; latter tends to be significantly faster, but somewhat less accurate.; verbose : bool; If True, prints additional information about the solution.; force_solve : bool; If True, forces dnorm to solve the associated SDP, even if a special; case is known for the argument.; sparse : bool; Whether to use sparse matrices in the convex optimisation problem.; Default True. Returns; -------; dn : float; Diamond norm of q_oper. Raises; ------; ImportError; If CVXPY cannot be imported. .. _cvxpy: https://www.cvxpy.org/en/latest/; """"""; if cvxpy is None: # pragma: no cover; raise ImportError(""dnorm() requires CVXPY to be installed.""). # We follow the strategy of using Watrous' simpler semidefinite; # program in its primal form. This is the same strategy used,; # for instance, by both pyGSTi and SchattenNorms.jl. (By contrast,; # QETLAB uses the dual problem.). # Check if A and B are both unitaries. If so, then we can without; # loss of generality choose B to be the identity by using the; # unitary invariance of the diamond norm,; # || A - B ||_♢ = || A B⁺ - I ||_♢.; # Then, using the technique mentioned by each of Johnston and; # da Silva,; # || A B⁺ - I ||_♢ = max_{i, j} | \lambda_i(A B⁺) - \lambda_j(A B⁺) |,; # where \lambda_i(U) is the ith eigenvalue of U. if (; # There's a lot of conditions to check for this path.; not force_solve and B is not None and; # Only check if they aren't superoperators.; A.type == ""oper"" and B.type == ""oper"" and; # The difference of unitaries optimization is currently; # only implemented for d == 2. Much of the code below is",MatchSource.WIKI,docs/4.7/modules/qutip/metrics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/metrics.html
https://qutip.org/docs/4.7/modules/qutip/metrics.html:13246,Deployability,update,updated,13246,"hat the diamond norm of Lambda; # is the same as the completely-bounded operator-norm (∞-norm); # of the dual map of Lambda. We can evaluate that norm much more; # easily if Lambda is completely positive, since then the largest; # eigenvalue is the same as the largest singular value. if not force_solve and J.iscp:; S_dual = to_super(J.dual_chan()); vec_eye = operator_to_vector(qeye(S_dual.dims[1][1])); op = vector_to_operator(S_dual * vec_eye); # The 2-norm was not implemented for sparse matrices as of the time; # of this writing. Thus, we must yet again go dense.; return la.norm(op.full(), 2). # If we're still here, we need to actually solve the problem. # Assume square...; dim = np.prod(J.dims[0][0]). J_dat = J.data. if not sparse:; # The parameters and constraints only depend on the dimension, so; # we can cache them efficiently.; problem, Jr, Ji = dnorm_problem(dim). # Load the parameters with the Choi matrix passed in.; Jr.value = sp.csr_matrix((J_dat.data.real, J_dat.indices,; J_dat.indptr),; shape=J_dat.shape).toarray(). Ji.value = sp.csr_matrix((J_dat.data.imag, J_dat.indices,; J_dat.indptr),; shape=J_dat.shape).toarray(); else:. # The parameters do not depend solely on the dimension,; # so we can not cache them efficiently.; problem = dnorm_sparse_problem(dim, J_dat). problem.solve(solver=solver, verbose=verbose). return problem.value. [docs]def unitarity(oper):; """"""; Returns the unitarity of a quantum map, defined as the Frobenius norm; of the unital block of that map's superoperator representation. Parameters; ----------; oper : Qobj; Quantum map under consideration. Returns; -------; u : float; Unitarity of ``oper``.; """"""; Eu = _super_to_superpauli(oper).full()[1:, 1:]; #return np.real(np.trace(np.dot(Eu, Eu.conj().T))) / len(Eu); return np.linalg.norm(Eu, 'fro')**2 / len(Eu). © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/modules/qutip/metrics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/metrics.html
https://qutip.org/docs/4.7/modules/qutip/metrics.html:1869,Energy Efficiency,reduce,reduces,1869,", to_choi, _super_to_superpauli, to_super; from qutip.superoperator import operator_to_vector, vector_to_operator; from qutip.operators import qeye; from qutip.semidefinite import dnorm_problem, dnorm_sparse_problem; import qutip.settings as settings. import qutip.logging_utils as logging; logger = logging.get_logger('qutip.metrics'). try:; import cvxpy; except ImportError:; cvxpy = None. [docs]def fidelity(A, B):; """"""; Calculates the fidelity (pseudo-metric) between two density matrices.; See: Nielsen & Chuang, ""Quantum Computation and Quantum Information"". Parameters; ----------; A : qobj; Density matrix or state vector.; B : qobj; Density matrix or state vector with same dimensions as A. Returns; -------; fid : float; Fidelity pseudo-metric between A and B. Examples; --------; >>> x = fock_dm(5,3); >>> y = coherent_dm(5,1); >>> np.testing.assert_almost_equal(fidelity(x,y), 0.24104350624628332); """"""; if A.isket or A.isbra:; if B.isket or B.isbra:; # The fidelity for pure states reduces to the modulus of their; # inner product.; return np.abs(A.overlap(B)); # Take advantage of the fact that the density operator for A; # is a projector to avoid a sqrtm call.; sqrtmA = ket2dm(A); else:; if B.isket or B.isbra:; # Swap the order so that we can take a more numerically; # stable square root of B.; return fidelity(B, A); # If we made it here, both A and B are operators, so; # we have to take the sqrtm of one of them.; sqrtmA = A.sqrtm(). if sqrtmA.dims != B.dims:; raise TypeError('Density matrices do not have same dimensions.'). # We don't actually need the whole matrix here, just the trace; # of its square root, so let's just get its eigenenergies instead.; # We also truncate negative eigenvalues to avoid nan propagation;; # even for positive semidefinite matrices, small negative eigenvalues; # can be reported.; eig_vals = (sqrtmA * B * sqrtmA).eigenenergies(); return float(np.real(np.sqrt(eig_vals[eig_vals > 0]).sum())). [docs]def process_fidelity(U1, U2, normalize=True",MatchSource.WIKI,docs/4.7/modules/qutip/metrics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/metrics.html
https://qutip.org/docs/4.7/modules/qutip/metrics.html:12179,Energy Efficiency,efficient,efficiently,12179,"nces = np.abs(eigs[:, None] - eigs[None, :]); return np.max(eig_distances). # Force the input superoperator to be a Choi matrix.; J = to_choi(A). if B is not None:; J -= to_choi(B). # Watrous 2012 also points out that the diamond norm of Lambda; # is the same as the completely-bounded operator-norm (∞-norm); # of the dual map of Lambda. We can evaluate that norm much more; # easily if Lambda is completely positive, since then the largest; # eigenvalue is the same as the largest singular value. if not force_solve and J.iscp:; S_dual = to_super(J.dual_chan()); vec_eye = operator_to_vector(qeye(S_dual.dims[1][1])); op = vector_to_operator(S_dual * vec_eye); # The 2-norm was not implemented for sparse matrices as of the time; # of this writing. Thus, we must yet again go dense.; return la.norm(op.full(), 2). # If we're still here, we need to actually solve the problem. # Assume square...; dim = np.prod(J.dims[0][0]). J_dat = J.data. if not sparse:; # The parameters and constraints only depend on the dimension, so; # we can cache them efficiently.; problem, Jr, Ji = dnorm_problem(dim). # Load the parameters with the Choi matrix passed in.; Jr.value = sp.csr_matrix((J_dat.data.real, J_dat.indices,; J_dat.indptr),; shape=J_dat.shape).toarray(). Ji.value = sp.csr_matrix((J_dat.data.imag, J_dat.indices,; J_dat.indptr),; shape=J_dat.shape).toarray(); else:. # The parameters do not depend solely on the dimension,; # so we can not cache them efficiently.; problem = dnorm_sparse_problem(dim, J_dat). problem.solve(solver=solver, verbose=verbose). return problem.value. [docs]def unitarity(oper):; """"""; Returns the unitarity of a quantum map, defined as the Frobenius norm; of the unital block of that map's superoperator representation. Parameters; ----------; oper : Qobj; Quantum map under consideration. Returns; -------; u : float; Unitarity of ``oper``.; """"""; Eu = _super_to_superpauli(oper).full()[1:, 1:]; #return np.real(np.trace(np.dot(Eu, Eu.conj().T))) / len(Eu); return np.lin",MatchSource.WIKI,docs/4.7/modules/qutip/metrics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/metrics.html
https://qutip.org/docs/4.7/modules/qutip/metrics.html:12587,Energy Efficiency,efficient,efficiently,12587,"hat the diamond norm of Lambda; # is the same as the completely-bounded operator-norm (∞-norm); # of the dual map of Lambda. We can evaluate that norm much more; # easily if Lambda is completely positive, since then the largest; # eigenvalue is the same as the largest singular value. if not force_solve and J.iscp:; S_dual = to_super(J.dual_chan()); vec_eye = operator_to_vector(qeye(S_dual.dims[1][1])); op = vector_to_operator(S_dual * vec_eye); # The 2-norm was not implemented for sparse matrices as of the time; # of this writing. Thus, we must yet again go dense.; return la.norm(op.full(), 2). # If we're still here, we need to actually solve the problem. # Assume square...; dim = np.prod(J.dims[0][0]). J_dat = J.data. if not sparse:; # The parameters and constraints only depend on the dimension, so; # we can cache them efficiently.; problem, Jr, Ji = dnorm_problem(dim). # Load the parameters with the Choi matrix passed in.; Jr.value = sp.csr_matrix((J_dat.data.real, J_dat.indices,; J_dat.indptr),; shape=J_dat.shape).toarray(). Ji.value = sp.csr_matrix((J_dat.data.imag, J_dat.indices,; J_dat.indptr),; shape=J_dat.shape).toarray(); else:. # The parameters do not depend solely on the dimension,; # so we can not cache them efficiently.; problem = dnorm_sparse_problem(dim, J_dat). problem.solve(solver=solver, verbose=verbose). return problem.value. [docs]def unitarity(oper):; """"""; Returns the unitarity of a quantum map, defined as the Frobenius norm; of the unital block of that map's superoperator representation. Parameters; ----------; oper : Qobj; Quantum map under consideration. Returns; -------; u : float; Unitarity of ``oper``.; """"""; Eu = _super_to_superpauli(oper).full()[1:, 1:]; #return np.real(np.trace(np.dot(Eu, Eu.conj().T))) / len(Eu); return np.linalg.norm(Eu, 'fro')**2 / len(Eu). © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/modules/qutip/metrics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/metrics.html
https://qutip.org/docs/4.7/modules/qutip/metrics.html:12130,Integrability,depend,depend,12130,"nces = np.abs(eigs[:, None] - eigs[None, :]); return np.max(eig_distances). # Force the input superoperator to be a Choi matrix.; J = to_choi(A). if B is not None:; J -= to_choi(B). # Watrous 2012 also points out that the diamond norm of Lambda; # is the same as the completely-bounded operator-norm (∞-norm); # of the dual map of Lambda. We can evaluate that norm much more; # easily if Lambda is completely positive, since then the largest; # eigenvalue is the same as the largest singular value. if not force_solve and J.iscp:; S_dual = to_super(J.dual_chan()); vec_eye = operator_to_vector(qeye(S_dual.dims[1][1])); op = vector_to_operator(S_dual * vec_eye); # The 2-norm was not implemented for sparse matrices as of the time; # of this writing. Thus, we must yet again go dense.; return la.norm(op.full(), 2). # If we're still here, we need to actually solve the problem. # Assume square...; dim = np.prod(J.dims[0][0]). J_dat = J.data. if not sparse:; # The parameters and constraints only depend on the dimension, so; # we can cache them efficiently.; problem, Jr, Ji = dnorm_problem(dim). # Load the parameters with the Choi matrix passed in.; Jr.value = sp.csr_matrix((J_dat.data.real, J_dat.indices,; J_dat.indptr),; shape=J_dat.shape).toarray(). Ji.value = sp.csr_matrix((J_dat.data.imag, J_dat.indices,; J_dat.indptr),; shape=J_dat.shape).toarray(); else:. # The parameters do not depend solely on the dimension,; # so we can not cache them efficiently.; problem = dnorm_sparse_problem(dim, J_dat). problem.solve(solver=solver, verbose=verbose). return problem.value. [docs]def unitarity(oper):; """"""; Returns the unitarity of a quantum map, defined as the Frobenius norm; of the unital block of that map's superoperator representation. Parameters; ----------; oper : Qobj; Quantum map under consideration. Returns; -------; u : float; Unitarity of ``oper``.; """"""; Eu = _super_to_superpauli(oper).full()[1:, 1:]; #return np.real(np.trace(np.dot(Eu, Eu.conj().T))) / len(Eu); return np.lin",MatchSource.WIKI,docs/4.7/modules/qutip/metrics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/metrics.html
https://qutip.org/docs/4.7/modules/qutip/metrics.html:12527,Integrability,depend,depend,12527,"hat the diamond norm of Lambda; # is the same as the completely-bounded operator-norm (∞-norm); # of the dual map of Lambda. We can evaluate that norm much more; # easily if Lambda is completely positive, since then the largest; # eigenvalue is the same as the largest singular value. if not force_solve and J.iscp:; S_dual = to_super(J.dual_chan()); vec_eye = operator_to_vector(qeye(S_dual.dims[1][1])); op = vector_to_operator(S_dual * vec_eye); # The 2-norm was not implemented for sparse matrices as of the time; # of this writing. Thus, we must yet again go dense.; return la.norm(op.full(), 2). # If we're still here, we need to actually solve the problem. # Assume square...; dim = np.prod(J.dims[0][0]). J_dat = J.data. if not sparse:; # The parameters and constraints only depend on the dimension, so; # we can cache them efficiently.; problem, Jr, Ji = dnorm_problem(dim). # Load the parameters with the Choi matrix passed in.; Jr.value = sp.csr_matrix((J_dat.data.real, J_dat.indices,; J_dat.indptr),; shape=J_dat.shape).toarray(). Ji.value = sp.csr_matrix((J_dat.data.imag, J_dat.indices,; J_dat.indptr),; shape=J_dat.shape).toarray(); else:. # The parameters do not depend solely on the dimension,; # so we can not cache them efficiently.; problem = dnorm_sparse_problem(dim, J_dat). problem.solve(solver=solver, verbose=verbose). return problem.value. [docs]def unitarity(oper):; """"""; Returns the unitarity of a quantum map, defined as the Frobenius norm; of the unital block of that map's superoperator representation. Parameters; ----------; oper : Qobj; Quantum map under consideration. Returns; -------; u : float; Unitarity of ``oper``.; """"""; Eu = _super_to_superpauli(oper).full()[1:, 1:]; #return np.real(np.trace(np.dot(Eu, Eu.conj().T))) / len(Eu); return np.linalg.norm(Eu, 'fro')**2 / len(Eu). © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/modules/qutip/metrics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/metrics.html
https://qutip.org/docs/4.7/modules/qutip/metrics.html:10248,Performance,optimiz,optimization,10248,"y: https://www.cvxpy.org/en/latest/; """"""; if cvxpy is None: # pragma: no cover; raise ImportError(""dnorm() requires CVXPY to be installed.""). # We follow the strategy of using Watrous' simpler semidefinite; # program in its primal form. This is the same strategy used,; # for instance, by both pyGSTi and SchattenNorms.jl. (By contrast,; # QETLAB uses the dual problem.). # Check if A and B are both unitaries. If so, then we can without; # loss of generality choose B to be the identity by using the; # unitary invariance of the diamond norm,; # || A - B ||_♢ = || A B⁺ - I ||_♢.; # Then, using the technique mentioned by each of Johnston and; # da Silva,; # || A B⁺ - I ||_♢ = max_{i, j} | \lambda_i(A B⁺) - \lambda_j(A B⁺) |,; # where \lambda_i(U) is the ith eigenvalue of U. if (; # There's a lot of conditions to check for this path.; not force_solve and B is not None and; # Only check if they aren't superoperators.; A.type == ""oper"" and B.type == ""oper"" and; # The difference of unitaries optimization is currently; # only implemented for d == 2. Much of the code below is more general,; # though, in anticipation of generalizing the optimization.; A.shape[0] == 2; ):; # Make an identity the same size as A and B to; # compare against.; I = qeye(A.dims[0]); # Compare to B first, so that an error is raised; # as soon as possible.; Bd = B.dag(); if (; (B * Bd - I).norm() < 1e-6 and; (A * A.dag() - I).norm() < 1e-6; ):; # Now we are on the fast path, so let's compute the; # eigenvalues, then find the diameter of the smallest circle; # containing all of them.; #; # For now, this is only implemented for dim = 2, such that; # generalizing here will allow for generalizing the optimization.; # A reasonable approach would probably be to use Welzl's algorithm; # (https://en.wikipedia.org/wiki/Smallest-circle_problem).; U = A * B.dag(); eigs = U.eigenenergies(); eig_distances = np.abs(eigs[:, None] - eigs[None, :]); return np.max(eig_distances). # Force the input superoperator to be a Cho",MatchSource.WIKI,docs/4.7/modules/qutip/metrics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/metrics.html
https://qutip.org/docs/4.7/modules/qutip/metrics.html:10393,Performance,optimiz,optimization,10393,"() requires CVXPY to be installed.""). # We follow the strategy of using Watrous' simpler semidefinite; # program in its primal form. This is the same strategy used,; # for instance, by both pyGSTi and SchattenNorms.jl. (By contrast,; # QETLAB uses the dual problem.). # Check if A and B are both unitaries. If so, then we can without; # loss of generality choose B to be the identity by using the; # unitary invariance of the diamond norm,; # || A - B ||_♢ = || A B⁺ - I ||_♢.; # Then, using the technique mentioned by each of Johnston and; # da Silva,; # || A B⁺ - I ||_♢ = max_{i, j} | \lambda_i(A B⁺) - \lambda_j(A B⁺) |,; # where \lambda_i(U) is the ith eigenvalue of U. if (; # There's a lot of conditions to check for this path.; not force_solve and B is not None and; # Only check if they aren't superoperators.; A.type == ""oper"" and B.type == ""oper"" and; # The difference of unitaries optimization is currently; # only implemented for d == 2. Much of the code below is more general,; # though, in anticipation of generalizing the optimization.; A.shape[0] == 2; ):; # Make an identity the same size as A and B to; # compare against.; I = qeye(A.dims[0]); # Compare to B first, so that an error is raised; # as soon as possible.; Bd = B.dag(); if (; (B * Bd - I).norm() < 1e-6 and; (A * A.dag() - I).norm() < 1e-6; ):; # Now we are on the fast path, so let's compute the; # eigenvalues, then find the diameter of the smallest circle; # containing all of them.; #; # For now, this is only implemented for dim = 2, such that; # generalizing here will allow for generalizing the optimization.; # A reasonable approach would probably be to use Welzl's algorithm; # (https://en.wikipedia.org/wiki/Smallest-circle_problem).; U = A * B.dag(); eigs = U.eigenenergies(); eig_distances = np.abs(eigs[:, None] - eigs[None, :]); return np.max(eig_distances). # Force the input superoperator to be a Choi matrix.; J = to_choi(A). if B is not None:; J -= to_choi(B). # Watrous 2012 also points out that the d",MatchSource.WIKI,docs/4.7/modules/qutip/metrics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/metrics.html
https://qutip.org/docs/4.7/modules/qutip/metrics.html:10938,Performance,optimiz,optimization,10938,"ston and; # da Silva,; # || A B⁺ - I ||_♢ = max_{i, j} | \lambda_i(A B⁺) - \lambda_j(A B⁺) |,; # where \lambda_i(U) is the ith eigenvalue of U. if (; # There's a lot of conditions to check for this path.; not force_solve and B is not None and; # Only check if they aren't superoperators.; A.type == ""oper"" and B.type == ""oper"" and; # The difference of unitaries optimization is currently; # only implemented for d == 2. Much of the code below is more general,; # though, in anticipation of generalizing the optimization.; A.shape[0] == 2; ):; # Make an identity the same size as A and B to; # compare against.; I = qeye(A.dims[0]); # Compare to B first, so that an error is raised; # as soon as possible.; Bd = B.dag(); if (; (B * Bd - I).norm() < 1e-6 and; (A * A.dag() - I).norm() < 1e-6; ):; # Now we are on the fast path, so let's compute the; # eigenvalues, then find the diameter of the smallest circle; # containing all of them.; #; # For now, this is only implemented for dim = 2, such that; # generalizing here will allow for generalizing the optimization.; # A reasonable approach would probably be to use Welzl's algorithm; # (https://en.wikipedia.org/wiki/Smallest-circle_problem).; U = A * B.dag(); eigs = U.eigenenergies(); eig_distances = np.abs(eigs[:, None] - eigs[None, :]); return np.max(eig_distances). # Force the input superoperator to be a Choi matrix.; J = to_choi(A). if B is not None:; J -= to_choi(B). # Watrous 2012 also points out that the diamond norm of Lambda; # is the same as the completely-bounded operator-norm (∞-norm); # of the dual map of Lambda. We can evaluate that norm much more; # easily if Lambda is completely positive, since then the largest; # eigenvalue is the same as the largest singular value. if not force_solve and J.iscp:; S_dual = to_super(J.dual_chan()); vec_eye = operator_to_vector(qeye(S_dual.dims[1][1])); op = vector_to_operator(S_dual * vec_eye); # The 2-norm was not implemented for sparse matrices as of the time; # of this writing. Th",MatchSource.WIKI,docs/4.7/modules/qutip/metrics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/metrics.html
https://qutip.org/docs/4.7/modules/qutip/metrics.html:12168,Performance,cache,cache,12168,"nces = np.abs(eigs[:, None] - eigs[None, :]); return np.max(eig_distances). # Force the input superoperator to be a Choi matrix.; J = to_choi(A). if B is not None:; J -= to_choi(B). # Watrous 2012 also points out that the diamond norm of Lambda; # is the same as the completely-bounded operator-norm (∞-norm); # of the dual map of Lambda. We can evaluate that norm much more; # easily if Lambda is completely positive, since then the largest; # eigenvalue is the same as the largest singular value. if not force_solve and J.iscp:; S_dual = to_super(J.dual_chan()); vec_eye = operator_to_vector(qeye(S_dual.dims[1][1])); op = vector_to_operator(S_dual * vec_eye); # The 2-norm was not implemented for sparse matrices as of the time; # of this writing. Thus, we must yet again go dense.; return la.norm(op.full(), 2). # If we're still here, we need to actually solve the problem. # Assume square...; dim = np.prod(J.dims[0][0]). J_dat = J.data. if not sparse:; # The parameters and constraints only depend on the dimension, so; # we can cache them efficiently.; problem, Jr, Ji = dnorm_problem(dim). # Load the parameters with the Choi matrix passed in.; Jr.value = sp.csr_matrix((J_dat.data.real, J_dat.indices,; J_dat.indptr),; shape=J_dat.shape).toarray(). Ji.value = sp.csr_matrix((J_dat.data.imag, J_dat.indices,; J_dat.indptr),; shape=J_dat.shape).toarray(); else:. # The parameters do not depend solely on the dimension,; # so we can not cache them efficiently.; problem = dnorm_sparse_problem(dim, J_dat). problem.solve(solver=solver, verbose=verbose). return problem.value. [docs]def unitarity(oper):; """"""; Returns the unitarity of a quantum map, defined as the Frobenius norm; of the unital block of that map's superoperator representation. Parameters; ----------; oper : Qobj; Quantum map under consideration. Returns; -------; u : float; Unitarity of ``oper``.; """"""; Eu = _super_to_superpauli(oper).full()[1:, 1:]; #return np.real(np.trace(np.dot(Eu, Eu.conj().T))) / len(Eu); return np.lin",MatchSource.WIKI,docs/4.7/modules/qutip/metrics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/metrics.html
https://qutip.org/docs/4.7/modules/qutip/metrics.html:12576,Performance,cache,cache,12576,"hat the diamond norm of Lambda; # is the same as the completely-bounded operator-norm (∞-norm); # of the dual map of Lambda. We can evaluate that norm much more; # easily if Lambda is completely positive, since then the largest; # eigenvalue is the same as the largest singular value. if not force_solve and J.iscp:; S_dual = to_super(J.dual_chan()); vec_eye = operator_to_vector(qeye(S_dual.dims[1][1])); op = vector_to_operator(S_dual * vec_eye); # The 2-norm was not implemented for sparse matrices as of the time; # of this writing. Thus, we must yet again go dense.; return la.norm(op.full(), 2). # If we're still here, we need to actually solve the problem. # Assume square...; dim = np.prod(J.dims[0][0]). J_dat = J.data. if not sparse:; # The parameters and constraints only depend on the dimension, so; # we can cache them efficiently.; problem, Jr, Ji = dnorm_problem(dim). # Load the parameters with the Choi matrix passed in.; Jr.value = sp.csr_matrix((J_dat.data.real, J_dat.indices,; J_dat.indptr),; shape=J_dat.shape).toarray(). Ji.value = sp.csr_matrix((J_dat.data.imag, J_dat.indices,; J_dat.indptr),; shape=J_dat.shape).toarray(); else:. # The parameters do not depend solely on the dimension,; # so we can not cache them efficiently.; problem = dnorm_sparse_problem(dim, J_dat). problem.solve(solver=solver, verbose=verbose). return problem.value. [docs]def unitarity(oper):; """"""; Returns the unitarity of a quantum map, defined as the Frobenius norm; of the unital block of that map's superoperator representation. Parameters; ----------; oper : Qobj; Quantum map under consideration. Returns; -------; u : float; Unitarity of ``oper``.; """"""; Eu = _super_to_superpauli(oper).full()[1:, 1:]; #return np.real(np.trace(np.dot(Eu, Eu.conj().T))) / len(Eu); return np.linalg.norm(Eu, 'fro')**2 / len(Eu). © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/modules/qutip/metrics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/metrics.html
https://qutip.org/docs/4.7/modules/qutip/metrics.html:2031,Safety,avoid,avoid,2031," qutip.operators import qeye; from qutip.semidefinite import dnorm_problem, dnorm_sparse_problem; import qutip.settings as settings. import qutip.logging_utils as logging; logger = logging.get_logger('qutip.metrics'). try:; import cvxpy; except ImportError:; cvxpy = None. [docs]def fidelity(A, B):; """"""; Calculates the fidelity (pseudo-metric) between two density matrices.; See: Nielsen & Chuang, ""Quantum Computation and Quantum Information"". Parameters; ----------; A : qobj; Density matrix or state vector.; B : qobj; Density matrix or state vector with same dimensions as A. Returns; -------; fid : float; Fidelity pseudo-metric between A and B. Examples; --------; >>> x = fock_dm(5,3); >>> y = coherent_dm(5,1); >>> np.testing.assert_almost_equal(fidelity(x,y), 0.24104350624628332); """"""; if A.isket or A.isbra:; if B.isket or B.isbra:; # The fidelity for pure states reduces to the modulus of their; # inner product.; return np.abs(A.overlap(B)); # Take advantage of the fact that the density operator for A; # is a projector to avoid a sqrtm call.; sqrtmA = ket2dm(A); else:; if B.isket or B.isbra:; # Swap the order so that we can take a more numerically; # stable square root of B.; return fidelity(B, A); # If we made it here, both A and B are operators, so; # we have to take the sqrtm of one of them.; sqrtmA = A.sqrtm(). if sqrtmA.dims != B.dims:; raise TypeError('Density matrices do not have same dimensions.'). # We don't actually need the whole matrix here, just the trace; # of its square root, so let's just get its eigenenergies instead.; # We also truncate negative eigenvalues to avoid nan propagation;; # even for positive semidefinite matrices, small negative eigenvalues; # can be reported.; eig_vals = (sqrtmA * B * sqrtmA).eigenenergies(); return float(np.real(np.sqrt(eig_vals[eig_vals > 0]).sum())). [docs]def process_fidelity(U1, U2, normalize=True):; """"""; Calculate the process fidelity given two process operators.; """"""; if normalize:; return (U1 * U2).tr() / (U1.t",MatchSource.WIKI,docs/4.7/modules/qutip/metrics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/metrics.html
https://qutip.org/docs/4.7/modules/qutip/metrics.html:2598,Safety,avoid,avoid,2598,"een A and B. Examples; --------; >>> x = fock_dm(5,3); >>> y = coherent_dm(5,1); >>> np.testing.assert_almost_equal(fidelity(x,y), 0.24104350624628332); """"""; if A.isket or A.isbra:; if B.isket or B.isbra:; # The fidelity for pure states reduces to the modulus of their; # inner product.; return np.abs(A.overlap(B)); # Take advantage of the fact that the density operator for A; # is a projector to avoid a sqrtm call.; sqrtmA = ket2dm(A); else:; if B.isket or B.isbra:; # Swap the order so that we can take a more numerically; # stable square root of B.; return fidelity(B, A); # If we made it here, both A and B are operators, so; # we have to take the sqrtm of one of them.; sqrtmA = A.sqrtm(). if sqrtmA.dims != B.dims:; raise TypeError('Density matrices do not have same dimensions.'). # We don't actually need the whole matrix here, just the trace; # of its square root, so let's just get its eigenenergies instead.; # We also truncate negative eigenvalues to avoid nan propagation;; # even for positive semidefinite matrices, small negative eigenvalues; # can be reported.; eig_vals = (sqrtmA * B * sqrtmA).eigenenergies(); return float(np.real(np.sqrt(eig_vals[eig_vals > 0]).sum())). [docs]def process_fidelity(U1, U2, normalize=True):; """"""; Calculate the process fidelity given two process operators.; """"""; if normalize:; return (U1 * U2).tr() / (U1.tr() * U2.tr()); else:; return (U1 * U2).tr(). [docs]def average_gate_fidelity(oper, target=None):; """"""; Given a Qobj representing the supermatrix form of a map, returns the; average gate fidelity (pseudo-metric) of that map. Parameters; ----------; A : Qobj; Quantum object representing a superoperator.; target : Qobj; Quantum object representing the target unitary; the inverse; is applied before evaluating the fidelity. Returns; -------; fid : float; Fidelity pseudo-metric between A and the identity superoperator,; or between A and the target superunitary.; """"""; kraus_form = to_kraus(oper); d = kraus_form[0].shape[0]. if kraus_form",MatchSource.WIKI,docs/4.7/modules/qutip/metrics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/metrics.html
https://qutip.org/docs/4.7/modules/qutip/metrics.html:8033,Safety,avoid,avoid,8033,"arameters; ----------; A : :class:`qutip.Qobj`; Density matrix or state vector.; B : :class:`qutip.Qobj`; Density matrix or state vector with same dimensions as A.; tol : float; Tolerance used by sparse eigensolver, if used. (0=Machine precision); sparse : {False, True}; Use sparse eigensolver. Returns; -------; hellinger_dist : float; Quantum Hellinger distance between A and B. Ranges from 0 to sqrt(2). Examples; --------; >>> x=fock_dm(5,3); >>> y=coherent_dm(5,1); >>> np.testing.assert_almost_equal(hellinger_dist(x,y), 1.3725145002591095); """"""; if A.isket or A.isbra:; sqrtmA = ket2dm(A); else:; sqrtmA = A.sqrtm(sparse=sparse, tol=tol); if B.isket or B.isbra:; sqrtmB = ket2dm(B); else:; sqrtmB = B.sqrtm(sparse=sparse, tol=tol). if sqrtmA.dims != sqrtmB.dims:; raise TypeError(""A and B do not have compatible dimensions.""). product = sqrtmA*sqrtmB; eigs = sp_eigs(product.data,; isherm=product.isherm, vecs=False, sparse=sparse, tol=tol); # np.maximum() is to avoid nan appearing sometimes due to numerical; # instabilities causing np.sum(eigs) slightly (~1e-8) larger than 1; # when hellinger_dist(A, B) is called for A=B; return np.sqrt(2.0 * np.maximum(0., (1.0 - np.real(np.sum(eigs))))). [docs]def dnorm(A, B=None, solver=""CVXOPT"", verbose=False, force_solve=False,; sparse=True):; """"""; Calculates the diamond norm of the quantum map q_oper, using; the simplified semidefinite program of [Wat13]_. The diamond norm SDP is solved by using CVXPY_. Parameters; ----------; A : Qobj; Quantum map to take the diamond norm of.; B : Qobj or None; If provided, the diamond norm of :math:`A - B` is taken instead.; solver : str; Solver to use with CVXPY. One of ""CVXOPT"" (default) or ""SCS"". The; latter tends to be significantly faster, but somewhat less accurate.; verbose : bool; If True, prints additional information about the solution.; force_solve : bool; If True, forces dnorm to solve the associated SDP, even if a special; case is known for the argument.; sparse : bool; Whether to use",MatchSource.WIKI,docs/4.7/modules/qutip/metrics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/metrics.html
https://qutip.org/docs/4.7/modules/qutip/metrics.html:1156,Testability,log,logging,1156,"ange Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.metrics. Source code for qutip.metrics; # -*- coding: utf-8 -*-. """"""; This module contains a collection of functions for calculating metrics; (distance measures) between states and operators.; """""". __all__ = ['fidelity', 'tracedist', 'bures_dist', 'bures_angle',; 'hellinger_dist', 'hilbert_dist', 'average_gate_fidelity',; 'process_fidelity', 'unitarity', 'dnorm']. import numpy as np; from scipy import linalg as la; import scipy.sparse as sp; from qutip.sparse import sp_eigs; from qutip.states import ket2dm; from qutip.superop_reps import to_kraus, to_stinespring, to_choi, _super_to_superpauli, to_super; from qutip.superoperator import operator_to_vector, vector_to_operator; from qutip.operators import qeye; from qutip.semidefinite import dnorm_problem, dnorm_sparse_problem; import qutip.settings as settings. import qutip.logging_utils as logging; logger = logging.get_logger('qutip.metrics'). try:; import cvxpy; except ImportError:; cvxpy = None. [docs]def fidelity(A, B):; """"""; Calculates the fidelity (pseudo-metric) between two density matrices.; See: Nielsen & Chuang, ""Quantum Computation and Quantum Information"". Parameters; ----------; A : qobj; Density matrix or state vector.; B : qobj; Density matrix or state vector with same dimensions as A. Returns; -------; fid : float; Fidelity pseudo-metric between A and B. Examples; --------; >>> x = fock_dm(5,3); >>> y = coherent_dm(5,1); >>> np.testing.assert_almost_equal(fidelity(x,y), 0.24104350624628332); """"""; if A.isket or A.isbra:; if B.isket or B.isbra:; # The fidelity for pure states reduces to the modulus of their; # inner product.; return np.abs(A.overlap(B)); # Take advantage of the fact that the density operator for A; # is a projector to avoid a sqrtm call.; sqrtmA = ket2dm(A); else:; if B.isket or B.isbra:; # Swap the order so that we can take a more numerically; #",MatchSource.WIKI,docs/4.7/modules/qutip/metrics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/metrics.html
https://qutip.org/docs/4.7/modules/qutip/metrics.html:1165,Testability,log,logger,1165,"ange Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.metrics. Source code for qutip.metrics; # -*- coding: utf-8 -*-. """"""; This module contains a collection of functions for calculating metrics; (distance measures) between states and operators.; """""". __all__ = ['fidelity', 'tracedist', 'bures_dist', 'bures_angle',; 'hellinger_dist', 'hilbert_dist', 'average_gate_fidelity',; 'process_fidelity', 'unitarity', 'dnorm']. import numpy as np; from scipy import linalg as la; import scipy.sparse as sp; from qutip.sparse import sp_eigs; from qutip.states import ket2dm; from qutip.superop_reps import to_kraus, to_stinespring, to_choi, _super_to_superpauli, to_super; from qutip.superoperator import operator_to_vector, vector_to_operator; from qutip.operators import qeye; from qutip.semidefinite import dnorm_problem, dnorm_sparse_problem; import qutip.settings as settings. import qutip.logging_utils as logging; logger = logging.get_logger('qutip.metrics'). try:; import cvxpy; except ImportError:; cvxpy = None. [docs]def fidelity(A, B):; """"""; Calculates the fidelity (pseudo-metric) between two density matrices.; See: Nielsen & Chuang, ""Quantum Computation and Quantum Information"". Parameters; ----------; A : qobj; Density matrix or state vector.; B : qobj; Density matrix or state vector with same dimensions as A. Returns; -------; fid : float; Fidelity pseudo-metric between A and B. Examples; --------; >>> x = fock_dm(5,3); >>> y = coherent_dm(5,1); >>> np.testing.assert_almost_equal(fidelity(x,y), 0.24104350624628332); """"""; if A.isket or A.isbra:; if B.isket or B.isbra:; # The fidelity for pure states reduces to the modulus of their; # inner product.; return np.abs(A.overlap(B)); # Take advantage of the fact that the density operator for A; # is a projector to avoid a sqrtm call.; sqrtmA = ket2dm(A); else:; if B.isket or B.isbra:; # Swap the order so that we can take a more numerically; #",MatchSource.WIKI,docs/4.7/modules/qutip/metrics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/metrics.html
https://qutip.org/docs/4.7/modules/qutip/metrics.html:1174,Testability,log,logging,1174,"ange Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.metrics. Source code for qutip.metrics; # -*- coding: utf-8 -*-. """"""; This module contains a collection of functions for calculating metrics; (distance measures) between states and operators.; """""". __all__ = ['fidelity', 'tracedist', 'bures_dist', 'bures_angle',; 'hellinger_dist', 'hilbert_dist', 'average_gate_fidelity',; 'process_fidelity', 'unitarity', 'dnorm']. import numpy as np; from scipy import linalg as la; import scipy.sparse as sp; from qutip.sparse import sp_eigs; from qutip.states import ket2dm; from qutip.superop_reps import to_kraus, to_stinespring, to_choi, _super_to_superpauli, to_super; from qutip.superoperator import operator_to_vector, vector_to_operator; from qutip.operators import qeye; from qutip.semidefinite import dnorm_problem, dnorm_sparse_problem; import qutip.settings as settings. import qutip.logging_utils as logging; logger = logging.get_logger('qutip.metrics'). try:; import cvxpy; except ImportError:; cvxpy = None. [docs]def fidelity(A, B):; """"""; Calculates the fidelity (pseudo-metric) between two density matrices.; See: Nielsen & Chuang, ""Quantum Computation and Quantum Information"". Parameters; ----------; A : qobj; Density matrix or state vector.; B : qobj; Density matrix or state vector with same dimensions as A. Returns; -------; fid : float; Fidelity pseudo-metric between A and B. Examples; --------; >>> x = fock_dm(5,3); >>> y = coherent_dm(5,1); >>> np.testing.assert_almost_equal(fidelity(x,y), 0.24104350624628332); """"""; if A.isket or A.isbra:; if B.isket or B.isbra:; # The fidelity for pure states reduces to the modulus of their; # inner product.; return np.abs(A.overlap(B)); # Take advantage of the fact that the density operator for A; # is a projector to avoid a sqrtm call.; sqrtmA = ket2dm(A); else:; if B.isket or B.isbra:; # Swap the order so that we can take a more numerically; #",MatchSource.WIKI,docs/4.7/modules/qutip/metrics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/metrics.html
https://qutip.org/docs/4.7/modules/qutip/metrics.html:1720,Testability,test,testing,1720," import scipy.sparse as sp; from qutip.sparse import sp_eigs; from qutip.states import ket2dm; from qutip.superop_reps import to_kraus, to_stinespring, to_choi, _super_to_superpauli, to_super; from qutip.superoperator import operator_to_vector, vector_to_operator; from qutip.operators import qeye; from qutip.semidefinite import dnorm_problem, dnorm_sparse_problem; import qutip.settings as settings. import qutip.logging_utils as logging; logger = logging.get_logger('qutip.metrics'). try:; import cvxpy; except ImportError:; cvxpy = None. [docs]def fidelity(A, B):; """"""; Calculates the fidelity (pseudo-metric) between two density matrices.; See: Nielsen & Chuang, ""Quantum Computation and Quantum Information"". Parameters; ----------; A : qobj; Density matrix or state vector.; B : qobj; Density matrix or state vector with same dimensions as A. Returns; -------; fid : float; Fidelity pseudo-metric between A and B. Examples; --------; >>> x = fock_dm(5,3); >>> y = coherent_dm(5,1); >>> np.testing.assert_almost_equal(fidelity(x,y), 0.24104350624628332); """"""; if A.isket or A.isbra:; if B.isket or B.isbra:; # The fidelity for pure states reduces to the modulus of their; # inner product.; return np.abs(A.overlap(B)); # Take advantage of the fact that the density operator for A; # is a projector to avoid a sqrtm call.; sqrtmA = ket2dm(A); else:; if B.isket or B.isbra:; # Swap the order so that we can take a more numerically; # stable square root of B.; return fidelity(B, A); # If we made it here, both A and B are operators, so; # we have to take the sqrtm of one of them.; sqrtmA = A.sqrtm(). if sqrtmA.dims != B.dims:; raise TypeError('Density matrices do not have same dimensions.'). # We don't actually need the whole matrix here, just the trace; # of its square root, so let's just get its eigenenergies instead.; # We also truncate negative eigenvalues to avoid nan propagation;; # even for positive semidefinite matrices, small negative eigenvalues; # can be reported.; eig_vals = ",MatchSource.WIKI,docs/4.7/modules/qutip/metrics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/metrics.html
https://qutip.org/docs/4.7/modules/qutip/metrics.html:4542,Testability,test,testing,4542,"runitary.; """"""; kraus_form = to_kraus(oper); d = kraus_form[0].shape[0]. if kraus_form[0].shape[1] != d:; return TypeError(""Average gate fidelity only implemented for square ""; ""superoperators.""). if target is None:; return (d + np.sum([np.abs(A_k.tr())**2; for A_k in kraus_form])) / (d**2 + d); else:; return (d + np.sum([np.abs((A_k * target.dag()).tr())**2; for A_k in kraus_form])) / (d**2 + d). [docs]def tracedist(A, B, sparse=False, tol=0):; """"""; Calculates the trace distance between two density matrices..; See: Nielsen & Chuang, ""Quantum Computation and Quantum Information"". Parameters; ----------!=; A : qobj; Density matrix or state vector.; B : qobj; Density matrix or state vector with same dimensions as A.; tol : float; Tolerance used by sparse eigensolver, if used. (0=Machine precision); sparse : {False, True}; Use sparse eigensolver. Returns; -------; tracedist : float; Trace distance between A and B. Examples; --------; >>> x=fock_dm(5,3); >>> y=coherent_dm(5,1); >>> np.testing.assert_almost_equal(tracedist(x,y), 0.9705143161472971); """"""; if A.isket or A.isbra:; A = ket2dm(A); if B.isket or B.isbra:; B = ket2dm(B). if A.dims != B.dims:; raise TypeError(""A and B do not have same dimensions.""). diff = A - B; diff = diff.dag() * diff; vals = sp_eigs(diff.data, diff.isherm, vecs=False, sparse=sparse, tol=tol); return float(np.real(0.5 * np.sum(np.sqrt(np.abs(vals))))). [docs]def hilbert_dist(A, B):; """"""; Returns the Hilbert-Schmidt distance between two density matrices A & B. Parameters; ----------; A : qobj; Density matrix or state vector.; B : qobj; Density matrix or state vector with same dimensions as A. Returns; -------; dist : float; Hilbert-Schmidt distance between density matrices. Notes; -----; See V. Vedral and M. B. Plenio, Phys. Rev. A 57, 1619 (1998). """"""; if A.isket or A.isbra:; A = ket2dm(A); if B.isket or B.isbra:; B = ket2dm(B). if A.dims != B.dims:; raise TypeError('A and B do not have same dimensions.'). return ((A - B)**2).tr(). [docs]def ",MatchSource.WIKI,docs/4.7/modules/qutip/metrics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/metrics.html
https://qutip.org/docs/4.7/modules/qutip/metrics.html:7541,Testability,test,testing,7541,"= ket2dm(A); if B.isket or B.isbra:; B = ket2dm(B). if A.dims != B.dims:; raise TypeError('A and B do not have same dimensions.'). return np.arccos(fidelity(A, B)). [docs]def hellinger_dist(A, B, sparse=False, tol=0):; """"""; Calculates the quantum Hellinger distance between two density matrices. Formula:; hellinger_dist(A, B) = sqrt(2-2*Tr(sqrt(A)*sqrt(B))). See: D. Spehner, F. Illuminati, M. Orszag, and W. Roga, ""Geometric; measures of quantum correlations with Bures and Hellinger distances""; arXiv:1611.03449. Parameters; ----------; A : :class:`qutip.Qobj`; Density matrix or state vector.; B : :class:`qutip.Qobj`; Density matrix or state vector with same dimensions as A.; tol : float; Tolerance used by sparse eigensolver, if used. (0=Machine precision); sparse : {False, True}; Use sparse eigensolver. Returns; -------; hellinger_dist : float; Quantum Hellinger distance between A and B. Ranges from 0 to sqrt(2). Examples; --------; >>> x=fock_dm(5,3); >>> y=coherent_dm(5,1); >>> np.testing.assert_almost_equal(hellinger_dist(x,y), 1.3725145002591095); """"""; if A.isket or A.isbra:; sqrtmA = ket2dm(A); else:; sqrtmA = A.sqrtm(sparse=sparse, tol=tol); if B.isket or B.isbra:; sqrtmB = ket2dm(B); else:; sqrtmB = B.sqrtm(sparse=sparse, tol=tol). if sqrtmA.dims != sqrtmB.dims:; raise TypeError(""A and B do not have compatible dimensions.""). product = sqrtmA*sqrtmB; eigs = sp_eigs(product.data,; isherm=product.isherm, vecs=False, sparse=sparse, tol=tol); # np.maximum() is to avoid nan appearing sometimes due to numerical; # instabilities causing np.sum(eigs) slightly (~1e-8) larger than 1; # when hellinger_dist(A, B) is called for A=B; return np.sqrt(2.0 * np.maximum(0., (1.0 - np.real(np.sum(eigs))))). [docs]def dnorm(A, B=None, solver=""CVXOPT"", verbose=False, force_solve=False,; sparse=True):; """"""; Calculates the diamond norm of the quantum map q_oper, using; the simplified semidefinite program of [Wat13]_. The diamond norm SDP is solved by using CVXPY_. Parameters; ---------",MatchSource.WIKI,docs/4.7/modules/qutip/metrics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/metrics.html
https://qutip.org/docs/4.7/modules/qutip/metrics.html:8431,Usability,simpl,simplified,8431,"----; hellinger_dist : float; Quantum Hellinger distance between A and B. Ranges from 0 to sqrt(2). Examples; --------; >>> x=fock_dm(5,3); >>> y=coherent_dm(5,1); >>> np.testing.assert_almost_equal(hellinger_dist(x,y), 1.3725145002591095); """"""; if A.isket or A.isbra:; sqrtmA = ket2dm(A); else:; sqrtmA = A.sqrtm(sparse=sparse, tol=tol); if B.isket or B.isbra:; sqrtmB = ket2dm(B); else:; sqrtmB = B.sqrtm(sparse=sparse, tol=tol). if sqrtmA.dims != sqrtmB.dims:; raise TypeError(""A and B do not have compatible dimensions.""). product = sqrtmA*sqrtmB; eigs = sp_eigs(product.data,; isherm=product.isherm, vecs=False, sparse=sparse, tol=tol); # np.maximum() is to avoid nan appearing sometimes due to numerical; # instabilities causing np.sum(eigs) slightly (~1e-8) larger than 1; # when hellinger_dist(A, B) is called for A=B; return np.sqrt(2.0 * np.maximum(0., (1.0 - np.real(np.sum(eigs))))). [docs]def dnorm(A, B=None, solver=""CVXOPT"", verbose=False, force_solve=False,; sparse=True):; """"""; Calculates the diamond norm of the quantum map q_oper, using; the simplified semidefinite program of [Wat13]_. The diamond norm SDP is solved by using CVXPY_. Parameters; ----------; A : Qobj; Quantum map to take the diamond norm of.; B : Qobj or None; If provided, the diamond norm of :math:`A - B` is taken instead.; solver : str; Solver to use with CVXPY. One of ""CVXOPT"" (default) or ""SCS"". The; latter tends to be significantly faster, but somewhat less accurate.; verbose : bool; If True, prints additional information about the solution.; force_solve : bool; If True, forces dnorm to solve the associated SDP, even if a special; case is known for the argument.; sparse : bool; Whether to use sparse matrices in the convex optimisation problem.; Default True. Returns; -------; dn : float; Diamond norm of q_oper. Raises; ------; ImportError; If CVXPY cannot be imported. .. _cvxpy: https://www.cvxpy.org/en/latest/; """"""; if cvxpy is None: # pragma: no cover; raise ImportError(""dnorm() requires CVX",MatchSource.WIKI,docs/4.7/modules/qutip/metrics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/metrics.html
https://qutip.org/docs/4.7/modules/qutip/metrics.html:9436,Usability,simpl,simpler,9436,"ed semidefinite program of [Wat13]_. The diamond norm SDP is solved by using CVXPY_. Parameters; ----------; A : Qobj; Quantum map to take the diamond norm of.; B : Qobj or None; If provided, the diamond norm of :math:`A - B` is taken instead.; solver : str; Solver to use with CVXPY. One of ""CVXOPT"" (default) or ""SCS"". The; latter tends to be significantly faster, but somewhat less accurate.; verbose : bool; If True, prints additional information about the solution.; force_solve : bool; If True, forces dnorm to solve the associated SDP, even if a special; case is known for the argument.; sparse : bool; Whether to use sparse matrices in the convex optimisation problem.; Default True. Returns; -------; dn : float; Diamond norm of q_oper. Raises; ------; ImportError; If CVXPY cannot be imported. .. _cvxpy: https://www.cvxpy.org/en/latest/; """"""; if cvxpy is None: # pragma: no cover; raise ImportError(""dnorm() requires CVXPY to be installed.""). # We follow the strategy of using Watrous' simpler semidefinite; # program in its primal form. This is the same strategy used,; # for instance, by both pyGSTi and SchattenNorms.jl. (By contrast,; # QETLAB uses the dual problem.). # Check if A and B are both unitaries. If so, then we can without; # loss of generality choose B to be the identity by using the; # unitary invariance of the diamond norm,; # || A - B ||_♢ = || A B⁺ - I ||_♢.; # Then, using the technique mentioned by each of Johnston and; # da Silva,; # || A B⁺ - I ||_♢ = max_{i, j} | \lambda_i(A B⁺) - \lambda_j(A B⁺) |,; # where \lambda_i(U) is the ith eigenvalue of U. if (; # There's a lot of conditions to check for this path.; not force_solve and B is not None and; # Only check if they aren't superoperators.; A.type == ""oper"" and B.type == ""oper"" and; # The difference of unitaries optimization is currently; # only implemented for d == 2. Much of the code below is more general,; # though, in anticipation of generalizing the optimization.; A.shape[0] == 2; ):; # Make an i",MatchSource.WIKI,docs/4.7/modules/qutip/metrics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/metrics.html
https://qutip.org/docs/4.7/modules/qutip/operators.html:6920,Availability,error,error,6920,"[[ 1. 0.]; [ 0. -1.]]. """"""; return 2 * jmat(1 / 2, 'z'). #; # DESTROY returns annihilation operator for N dimensional Hilbert space; # out = destroy(N), N is integer value & N>0; #; [docs]def destroy(N, offset=0):; '''Destruction (lowering) operator. Parameters; ----------; N : int; Dimension of Hilbert space. offset : int (default 0); The lowest number state that is included in the finite number state; representation of the operator. Returns; -------; oper : qobj; Qobj for lowering operator. Examples; --------; >>> destroy(4) # doctest: +SKIP; Quantum object: dims = [[4], [4]], \; shape = [4, 4], type = oper, isHerm = False; Qobj data =; [[ 0.00000000+0.j 1.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 0.00000000+0.j 0.00000000+0.j 1.41421356+0.j 0.00000000+0.j]; [ 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j 1.73205081+0.j]; [ 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]]. '''; if not isinstance(N, (int, np.integer)): # raise error if N not integer; raise ValueError(""Hilbert space dimension must be integer value""); data = np.sqrt(np.arange(offset+1, N+offset, dtype=complex)); ind = np.arange(1,N, dtype=np.int32); ptr = np.arange(N+1, dtype=np.int32); ptr[-1] = N-1; return Qobj(fast_csr_matrix((data,ind,ptr),shape=(N,N)), isherm=False). #; # create returns creation operator for N dimensional Hilbert space; # out = create(N), N is integer value & N>0; #; [docs]def create(N, offset=0):; '''Creation (raising) operator. Parameters; ----------; N : int; Dimension of Hilbert space. Returns; -------; oper : qobj; Qobj for raising operator. offset : int (default 0); The lowest number state that is included in the finite number state; representation of the operator. Examples; --------; >>> create(4) # doctest: +SKIP; Quantum object: dims = [[4], [4]], \; shape = [4, 4], type = oper, isHerm = False; Qobj data =; [[ 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 1.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 0.00000000+0.j 1.",MatchSource.WIKI,docs/4.7/modules/qutip/operators.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/operators.html
https://qutip.org/docs/4.7/modules/qutip/operators.html:8125,Availability,error,error,8125,"ptr),shape=(N,N)), isherm=False). #; # create returns creation operator for N dimensional Hilbert space; # out = create(N), N is integer value & N>0; #; [docs]def create(N, offset=0):; '''Creation (raising) operator. Parameters; ----------; N : int; Dimension of Hilbert space. Returns; -------; oper : qobj; Qobj for raising operator. offset : int (default 0); The lowest number state that is included in the finite number state; representation of the operator. Examples; --------; >>> create(4) # doctest: +SKIP; Quantum object: dims = [[4], [4]], \; shape = [4, 4], type = oper, isHerm = False; Qobj data =; [[ 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 1.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 0.00000000+0.j 1.41421356+0.j 0.00000000+0.j 0.00000000+0.j]; [ 0.00000000+0.j 0.00000000+0.j 1.73205081+0.j 0.00000000+0.j]]. '''; if not isinstance(N, (int, np.integer)): # raise error if N not integer; raise ValueError(""Hilbert space dimension must be integer value""); qo = destroy(N, offset=offset) # create operator using destroy function; return qo.dag(). def _implicit_tensor_dimensions(dimensions):; """"""; Total flattened size and operator dimensions for operator creation routines; that automatically perform tensor products. Parameters; ----------; dimensions : (int) or (list of int) or (list of list of int); First dimension of an operator which can create an implicit tensor; product. If the type is `int`, it is promoted first to `[dimensions]`.; From there, it should be one of the two-elements `dims` parameter of a; `qutip.Qobj` representing an `oper` or `super`, with possible tensor; products. Returns; -------; size : int; Dimension of backing matrix required to represent operator.; dimensions : list; Dimension list in the form required by ``Qobj`` creation.; """"""; if not isinstance(dimensions, list):; dimensions = [dimensions]; flat = flatten(dimensions); if not all(isinstance(x, numbers.Integral) and x >= 0 for x in flat):; raise Val",MatchSource.WIKI,docs/4.7/modules/qutip/operators.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/operators.html
https://qutip.org/docs/4.7/modules/qutip/operators.html:22037,Deployability,update,updated,22037,"mber of excitations that are to be included in the; state space. state : list of integers; The state in the number basis representation. Returns; -------; op : Qobj; A Qobj instance that represent the identity operator in the; exication-number-restricted state space defined by `dims` and; `exciations`.; """"""; from qutip.states import enr_state_dictionaries. nstates, _, _ = enr_state_dictionaries(dims, excitations); data = sp.eye(nstates, nstates, dtype=np.complex128); return Qobj(data, dims=[dims, dims]). [docs]def charge(Nmax, Nmin=None, frac = 1):; """"""; Generate the diagonal charge operator over charge states; from Nmin to Nmax. Parameters; ----------; Nmax : int; Maximum charge state to consider. Nmin : int (default = -Nmax); Lowest charge state to consider. frac : float (default = 1); Specify fractional charge if needed. Returns; -------; C : Qobj; Charge operator over [Nmin,Nmax]. Notes; -----; .. versionadded:: 3.2. """"""; if Nmin is None:; Nmin = -Nmax; diag = np.arange(Nmin, Nmax+1, dtype=float); if frac != 1:; diag *= frac; C = sp.diags(diag, 0, format='csr', dtype=complex); return Qobj(C, isherm=True). [docs]def tunneling(N, m=1):; """"""; Tunneling operator with elements of the form; :math:`\\sum |N><N+m| + |N+m><N|`. Parameters; ----------; N : int; Number of basis states in Hilbert space.; m : int (default = 1); Number of excitations in tunneling event. Returns; -------; T : Qobj; Tunneling operator. Notes; -----; .. versionadded:: 3.2. """"""; diags = [np.ones(N-m,dtype=int),np.ones(N-m,dtype=int)]; T = sp.diags(diags,[m,-m],format='csr', dtype=complex); return Qobj(T, isherm=True). # Break circular dependencies by a trailing import.; # Note that we use a relative import here to deal with that; # qutip.tensor is the *function* tensor, not the module.; from qutip.tensor import tensor. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/modules/qutip/operators.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/operators.html
https://qutip.org/docs/4.7/modules/qutip/operators.html:822,Energy Efficiency,charge,charge,822,". qutip.operators — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.operators. Source code for qutip.operators; """"""; This module contains functions for generating Qobj representation of a variety; of commonly occuring quantum operators.; """""". __all__ = ['jmat', 'spin_Jx', 'spin_Jy', 'spin_Jz', 'spin_Jm', 'spin_Jp',; 'spin_J_set', 'sigmap', 'sigmam', 'sigmax', 'sigmay', 'sigmaz',; 'destroy', 'create', 'qeye', 'identity', 'position', 'momentum',; 'num', 'squeeze', 'squeezing', 'displace', 'commutator',; 'qutrit_ops', 'qdiags', 'phase', 'qzero', 'enr_destroy',; 'enr_identity', 'charge', 'tunneling']. import numbers; import numpy as np; import scipy.sparse as sp; from qutip.qobj import Qobj; from qutip.fastsparse import fast_csr_matrix, fast_identity; from qutip.dimensions import flatten. #; # Spin operators; #; [docs]def jmat(j, *args):; """"""Higher-order spin operators:. Parameters; ----------; j : float; Spin of operator. args : str; Which operator to return 'x','y','z','+','-'.; If no args given, then output is ['x','y','z']. Returns; -------; jmat : qobj / ndarray; ``qobj`` for requested spin operator(s). Examples; --------; >>> jmat(1) # doctest: +SKIP; [ Quantum object: dims = [[3], [3]], \; shape = [3, 3], type = oper, isHerm = True; Qobj data =; [[ 0. 0.70710678 0. ]; [ 0.70710678 0. 0.70710678]; [ 0. 0.70710678 0. ]]; Quantum object: dims = [[3], [3]], \; shape = [3, 3], type = oper, isHerm = True; Qobj data =; [[ 0.+0.j 0.-0.70710678j 0.+0.j ]; [ 0.+0.70710678j 0.+0.j 0.-0.70710678j]; [ 0.+0.j 0.+0.70710678j 0.+0.j ]]; Quantum object: dims = [[3], [3]], \; shape = [3, 3], type = oper, isHerm = True; Qobj data =; [[ 1. 0. 0.]; [ 0. 0. 0.]; [ 0. 0. -1.]]]. Notes; -----; If no 'args' input, then returns array of ['x','y','z'] ope",MatchSource.WIKI,docs/4.7/modules/qutip/operators.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/operators.html
https://qutip.org/docs/4.7/modules/qutip/operators.html:20658,Energy Efficiency,charge,charge,20658," a in a_ops]. [docs]def enr_identity(dims, excitations):; """"""; Generate the identity operator for the excitation-number restricted; state space defined by the `dims` and `exciations` arguments. See the; docstring for enr_fock for a more detailed description of these arguments. Parameters; ----------; dims : list; A list of the dimensions of each subsystem of a composite quantum; system. excitations : integer; The maximum number of excitations that are to be included in the; state space. state : list of integers; The state in the number basis representation. Returns; -------; op : Qobj; A Qobj instance that represent the identity operator in the; exication-number-restricted state space defined by `dims` and; `exciations`.; """"""; from qutip.states import enr_state_dictionaries. nstates, _, _ = enr_state_dictionaries(dims, excitations); data = sp.eye(nstates, nstates, dtype=np.complex128); return Qobj(data, dims=[dims, dims]). [docs]def charge(Nmax, Nmin=None, frac = 1):; """"""; Generate the diagonal charge operator over charge states; from Nmin to Nmax. Parameters; ----------; Nmax : int; Maximum charge state to consider. Nmin : int (default = -Nmax); Lowest charge state to consider. frac : float (default = 1); Specify fractional charge if needed. Returns; -------; C : Qobj; Charge operator over [Nmin,Nmax]. Notes; -----; .. versionadded:: 3.2. """"""; if Nmin is None:; Nmin = -Nmax; diag = np.arange(Nmin, Nmax+1, dtype=float); if frac != 1:; diag *= frac; C = sp.diags(diag, 0, format='csr', dtype=complex); return Qobj(C, isherm=True). [docs]def tunneling(N, m=1):; """"""; Tunneling operator with elements of the form; :math:`\\sum |N><N+m| + |N+m><N|`. Parameters; ----------; N : int; Number of basis states in Hilbert space.; m : int (default = 1); Number of excitations in tunneling event. Returns; -------; T : Qobj; Tunneling operator. Notes; -----; .. versionadded:: 3.2. """"""; diags = [np.ones(N-m,dtype=int),np.ones(N-m,dtype=int)]; T = sp.diags(diags,[m,-m],format='csr', dty",MatchSource.WIKI,docs/4.7/modules/qutip/operators.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/operators.html
https://qutip.org/docs/4.7/modules/qutip/operators.html:20721,Energy Efficiency,charge,charge,20721," a in a_ops]. [docs]def enr_identity(dims, excitations):; """"""; Generate the identity operator for the excitation-number restricted; state space defined by the `dims` and `exciations` arguments. See the; docstring for enr_fock for a more detailed description of these arguments. Parameters; ----------; dims : list; A list of the dimensions of each subsystem of a composite quantum; system. excitations : integer; The maximum number of excitations that are to be included in the; state space. state : list of integers; The state in the number basis representation. Returns; -------; op : Qobj; A Qobj instance that represent the identity operator in the; exication-number-restricted state space defined by `dims` and; `exciations`.; """"""; from qutip.states import enr_state_dictionaries. nstates, _, _ = enr_state_dictionaries(dims, excitations); data = sp.eye(nstates, nstates, dtype=np.complex128); return Qobj(data, dims=[dims, dims]). [docs]def charge(Nmax, Nmin=None, frac = 1):; """"""; Generate the diagonal charge operator over charge states; from Nmin to Nmax. Parameters; ----------; Nmax : int; Maximum charge state to consider. Nmin : int (default = -Nmax); Lowest charge state to consider. frac : float (default = 1); Specify fractional charge if needed. Returns; -------; C : Qobj; Charge operator over [Nmin,Nmax]. Notes; -----; .. versionadded:: 3.2. """"""; if Nmin is None:; Nmin = -Nmax; diag = np.arange(Nmin, Nmax+1, dtype=float); if frac != 1:; diag *= frac; C = sp.diags(diag, 0, format='csr', dtype=complex); return Qobj(C, isherm=True). [docs]def tunneling(N, m=1):; """"""; Tunneling operator with elements of the form; :math:`\\sum |N><N+m| + |N+m><N|`. Parameters; ----------; N : int; Number of basis states in Hilbert space.; m : int (default = 1); Number of excitations in tunneling event. Returns; -------; T : Qobj; Tunneling operator. Notes; -----; .. versionadded:: 3.2. """"""; diags = [np.ones(N-m,dtype=int),np.ones(N-m,dtype=int)]; T = sp.diags(diags,[m,-m],format='csr', dty",MatchSource.WIKI,docs/4.7/modules/qutip/operators.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/operators.html
https://qutip.org/docs/4.7/modules/qutip/operators.html:20742,Energy Efficiency,charge,charge,20742," a in a_ops]. [docs]def enr_identity(dims, excitations):; """"""; Generate the identity operator for the excitation-number restricted; state space defined by the `dims` and `exciations` arguments. See the; docstring for enr_fock for a more detailed description of these arguments. Parameters; ----------; dims : list; A list of the dimensions of each subsystem of a composite quantum; system. excitations : integer; The maximum number of excitations that are to be included in the; state space. state : list of integers; The state in the number basis representation. Returns; -------; op : Qobj; A Qobj instance that represent the identity operator in the; exication-number-restricted state space defined by `dims` and; `exciations`.; """"""; from qutip.states import enr_state_dictionaries. nstates, _, _ = enr_state_dictionaries(dims, excitations); data = sp.eye(nstates, nstates, dtype=np.complex128); return Qobj(data, dims=[dims, dims]). [docs]def charge(Nmax, Nmin=None, frac = 1):; """"""; Generate the diagonal charge operator over charge states; from Nmin to Nmax. Parameters; ----------; Nmax : int; Maximum charge state to consider. Nmin : int (default = -Nmax); Lowest charge state to consider. frac : float (default = 1); Specify fractional charge if needed. Returns; -------; C : Qobj; Charge operator over [Nmin,Nmax]. Notes; -----; .. versionadded:: 3.2. """"""; if Nmin is None:; Nmin = -Nmax; diag = np.arange(Nmin, Nmax+1, dtype=float); if frac != 1:; diag *= frac; C = sp.diags(diag, 0, format='csr', dtype=complex); return Qobj(C, isherm=True). [docs]def tunneling(N, m=1):; """"""; Tunneling operator with elements of the form; :math:`\\sum |N><N+m| + |N+m><N|`. Parameters; ----------; N : int; Number of basis states in Hilbert space.; m : int (default = 1); Number of excitations in tunneling event. Returns; -------; T : Qobj; Tunneling operator. Notes; -----; .. versionadded:: 3.2. """"""; diags = [np.ones(N-m,dtype=int),np.ones(N-m,dtype=int)]; T = sp.diags(diags,[m,-m],format='csr', dty",MatchSource.WIKI,docs/4.7/modules/qutip/operators.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/operators.html
https://qutip.org/docs/4.7/modules/qutip/operators.html:20820,Energy Efficiency,charge,charge,20820,"he excitation-number restricted; state space defined by the `dims` and `exciations` arguments. See the; docstring for enr_fock for a more detailed description of these arguments. Parameters; ----------; dims : list; A list of the dimensions of each subsystem of a composite quantum; system. excitations : integer; The maximum number of excitations that are to be included in the; state space. state : list of integers; The state in the number basis representation. Returns; -------; op : Qobj; A Qobj instance that represent the identity operator in the; exication-number-restricted state space defined by `dims` and; `exciations`.; """"""; from qutip.states import enr_state_dictionaries. nstates, _, _ = enr_state_dictionaries(dims, excitations); data = sp.eye(nstates, nstates, dtype=np.complex128); return Qobj(data, dims=[dims, dims]). [docs]def charge(Nmax, Nmin=None, frac = 1):; """"""; Generate the diagonal charge operator over charge states; from Nmin to Nmax. Parameters; ----------; Nmax : int; Maximum charge state to consider. Nmin : int (default = -Nmax); Lowest charge state to consider. frac : float (default = 1); Specify fractional charge if needed. Returns; -------; C : Qobj; Charge operator over [Nmin,Nmax]. Notes; -----; .. versionadded:: 3.2. """"""; if Nmin is None:; Nmin = -Nmax; diag = np.arange(Nmin, Nmax+1, dtype=float); if frac != 1:; diag *= frac; C = sp.diags(diag, 0, format='csr', dtype=complex); return Qobj(C, isherm=True). [docs]def tunneling(N, m=1):; """"""; Tunneling operator with elements of the form; :math:`\\sum |N><N+m| + |N+m><N|`. Parameters; ----------; N : int; Number of basis states in Hilbert space.; m : int (default = 1); Number of excitations in tunneling event. Returns; -------; T : Qobj; Tunneling operator. Notes; -----; .. versionadded:: 3.2. """"""; diags = [np.ones(N-m,dtype=int),np.ones(N-m,dtype=int)]; T = sp.diags(diags,[m,-m],format='csr', dtype=complex); return Qobj(T, isherm=True). # Break circular dependencies by a trailing import.; # No",MatchSource.WIKI,docs/4.7/modules/qutip/operators.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/operators.html
https://qutip.org/docs/4.7/modules/qutip/operators.html:20883,Energy Efficiency,charge,charge,20883," and `exciations` arguments. See the; docstring for enr_fock for a more detailed description of these arguments. Parameters; ----------; dims : list; A list of the dimensions of each subsystem of a composite quantum; system. excitations : integer; The maximum number of excitations that are to be included in the; state space. state : list of integers; The state in the number basis representation. Returns; -------; op : Qobj; A Qobj instance that represent the identity operator in the; exication-number-restricted state space defined by `dims` and; `exciations`.; """"""; from qutip.states import enr_state_dictionaries. nstates, _, _ = enr_state_dictionaries(dims, excitations); data = sp.eye(nstates, nstates, dtype=np.complex128); return Qobj(data, dims=[dims, dims]). [docs]def charge(Nmax, Nmin=None, frac = 1):; """"""; Generate the diagonal charge operator over charge states; from Nmin to Nmax. Parameters; ----------; Nmax : int; Maximum charge state to consider. Nmin : int (default = -Nmax); Lowest charge state to consider. frac : float (default = 1); Specify fractional charge if needed. Returns; -------; C : Qobj; Charge operator over [Nmin,Nmax]. Notes; -----; .. versionadded:: 3.2. """"""; if Nmin is None:; Nmin = -Nmax; diag = np.arange(Nmin, Nmax+1, dtype=float); if frac != 1:; diag *= frac; C = sp.diags(diag, 0, format='csr', dtype=complex); return Qobj(C, isherm=True). [docs]def tunneling(N, m=1):; """"""; Tunneling operator with elements of the form; :math:`\\sum |N><N+m| + |N+m><N|`. Parameters; ----------; N : int; Number of basis states in Hilbert space.; m : int (default = 1); Number of excitations in tunneling event. Returns; -------; T : Qobj; Tunneling operator. Notes; -----; .. versionadded:: 3.2. """"""; diags = [np.ones(N-m,dtype=int),np.ones(N-m,dtype=int)]; T = sp.diags(diags,[m,-m],format='csr', dtype=complex); return Qobj(T, isherm=True). # Break circular dependencies by a trailing import.; # Note that we use a relative import here to deal with that; # qutip.te",MatchSource.WIKI,docs/4.7/modules/qutip/operators.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/operators.html
https://qutip.org/docs/4.7/modules/qutip/operators.html:20956,Energy Efficiency,charge,charge,20956," a more detailed description of these arguments. Parameters; ----------; dims : list; A list of the dimensions of each subsystem of a composite quantum; system. excitations : integer; The maximum number of excitations that are to be included in the; state space. state : list of integers; The state in the number basis representation. Returns; -------; op : Qobj; A Qobj instance that represent the identity operator in the; exication-number-restricted state space defined by `dims` and; `exciations`.; """"""; from qutip.states import enr_state_dictionaries. nstates, _, _ = enr_state_dictionaries(dims, excitations); data = sp.eye(nstates, nstates, dtype=np.complex128); return Qobj(data, dims=[dims, dims]). [docs]def charge(Nmax, Nmin=None, frac = 1):; """"""; Generate the diagonal charge operator over charge states; from Nmin to Nmax. Parameters; ----------; Nmax : int; Maximum charge state to consider. Nmin : int (default = -Nmax); Lowest charge state to consider. frac : float (default = 1); Specify fractional charge if needed. Returns; -------; C : Qobj; Charge operator over [Nmin,Nmax]. Notes; -----; .. versionadded:: 3.2. """"""; if Nmin is None:; Nmin = -Nmax; diag = np.arange(Nmin, Nmax+1, dtype=float); if frac != 1:; diag *= frac; C = sp.diags(diag, 0, format='csr', dtype=complex); return Qobj(C, isherm=True). [docs]def tunneling(N, m=1):; """"""; Tunneling operator with elements of the form; :math:`\\sum |N><N+m| + |N+m><N|`. Parameters; ----------; N : int; Number of basis states in Hilbert space.; m : int (default = 1); Number of excitations in tunneling event. Returns; -------; T : Qobj; Tunneling operator. Notes; -----; .. versionadded:: 3.2. """"""; diags = [np.ones(N-m,dtype=int),np.ones(N-m,dtype=int)]; T = sp.diags(diags,[m,-m],format='csr', dtype=complex); return Qobj(T, isherm=True). # Break circular dependencies by a trailing import.; # Note that we use a relative import here to deal with that; # qutip.tensor is the *function* tensor, not the module.; from qutip.tenso",MatchSource.WIKI,docs/4.7/modules/qutip/operators.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/operators.html
https://qutip.org/docs/4.7/modules/qutip/operators.html:8424,Integrability,rout,routines,8424,"reation (raising) operator. Parameters; ----------; N : int; Dimension of Hilbert space. Returns; -------; oper : qobj; Qobj for raising operator. offset : int (default 0); The lowest number state that is included in the finite number state; representation of the operator. Examples; --------; >>> create(4) # doctest: +SKIP; Quantum object: dims = [[4], [4]], \; shape = [4, 4], type = oper, isHerm = False; Qobj data =; [[ 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 1.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 0.00000000+0.j 1.41421356+0.j 0.00000000+0.j 0.00000000+0.j]; [ 0.00000000+0.j 0.00000000+0.j 1.73205081+0.j 0.00000000+0.j]]. '''; if not isinstance(N, (int, np.integer)): # raise error if N not integer; raise ValueError(""Hilbert space dimension must be integer value""); qo = destroy(N, offset=offset) # create operator using destroy function; return qo.dag(). def _implicit_tensor_dimensions(dimensions):; """"""; Total flattened size and operator dimensions for operator creation routines; that automatically perform tensor products. Parameters; ----------; dimensions : (int) or (list of int) or (list of list of int); First dimension of an operator which can create an implicit tensor; product. If the type is `int`, it is promoted first to `[dimensions]`.; From there, it should be one of the two-elements `dims` parameter of a; `qutip.Qobj` representing an `oper` or `super`, with possible tensor; products. Returns; -------; size : int; Dimension of backing matrix required to represent operator.; dimensions : list; Dimension list in the form required by ``Qobj`` creation.; """"""; if not isinstance(dimensions, list):; dimensions = [dimensions]; flat = flatten(dimensions); if not all(isinstance(x, numbers.Integral) and x >= 0 for x in flat):; raise ValueError(""All dimensions must be integers >= 0""); return np.prod(flat), [dimensions, dimensions]. [docs]def qzero(dimensions):; """"""; Zero operator. Parameters; ----------; dimensions : (int",MatchSource.WIKI,docs/4.7/modules/qutip/operators.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/operators.html
https://qutip.org/docs/4.7/modules/qutip/operators.html:9654,Integrability,depend,depending,9654,"pe is `int`, it is promoted first to `[dimensions]`.; From there, it should be one of the two-elements `dims` parameter of a; `qutip.Qobj` representing an `oper` or `super`, with possible tensor; products. Returns; -------; size : int; Dimension of backing matrix required to represent operator.; dimensions : list; Dimension list in the form required by ``Qobj`` creation.; """"""; if not isinstance(dimensions, list):; dimensions = [dimensions]; flat = flatten(dimensions); if not all(isinstance(x, numbers.Integral) and x >= 0 for x in flat):; raise ValueError(""All dimensions must be integers >= 0""); return np.prod(flat), [dimensions, dimensions]. [docs]def qzero(dimensions):; """"""; Zero operator. Parameters; ----------; dimensions : (int) or (list of int) or (list of list of int); Dimension of Hilbert space. If provided as a list of ints, then the; dimension is the product over this list, but the ``dims`` property of; the new Qobj are set to this list. This can produce either `oper` or; `super` depending on the passed `dimensions`. Returns; -------; qzero : qobj; Zero operator Qobj. """"""; size, dimensions = _implicit_tensor_dimensions(dimensions); # A sparse matrix with no data is equal to a zero matrix.; return Qobj(fast_csr_matrix(shape=(size, size), dtype=complex),; dims=dimensions, isherm=True). #; # QEYE returns identity operator for a Hilbert space with dimensions dims.; # a = qeye(N), N is integer or list of integers & all elements >= 0; #; [docs]def qeye(dimensions):; """"""; Identity operator. Parameters; ----------; dimensions : (int) or (list of int) or (list of list of int); Dimension of Hilbert space. If provided as a list of ints, then the; dimension is the product over this list, but the ``dims`` property of; the new Qobj are set to this list. This can produce either `oper` or; `super` depending on the passed `dimensions`. Returns; -------; oper : qobj; Identity operator Qobj. Examples; --------; >>> qeye(3) # doctest: +SKIP; Quantum object: dims = [[3], [3]], s",MatchSource.WIKI,docs/4.7/modules/qutip/operators.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/operators.html
https://qutip.org/docs/4.7/modules/qutip/operators.html:10472,Integrability,depend,depending,10472,"rovided as a list of ints, then the; dimension is the product over this list, but the ``dims`` property of; the new Qobj are set to this list. This can produce either `oper` or; `super` depending on the passed `dimensions`. Returns; -------; qzero : qobj; Zero operator Qobj. """"""; size, dimensions = _implicit_tensor_dimensions(dimensions); # A sparse matrix with no data is equal to a zero matrix.; return Qobj(fast_csr_matrix(shape=(size, size), dtype=complex),; dims=dimensions, isherm=True). #; # QEYE returns identity operator for a Hilbert space with dimensions dims.; # a = qeye(N), N is integer or list of integers & all elements >= 0; #; [docs]def qeye(dimensions):; """"""; Identity operator. Parameters; ----------; dimensions : (int) or (list of int) or (list of list of int); Dimension of Hilbert space. If provided as a list of ints, then the; dimension is the product over this list, but the ``dims`` property of; the new Qobj are set to this list. This can produce either `oper` or; `super` depending on the passed `dimensions`. Returns; -------; oper : qobj; Identity operator Qobj. Examples; --------; >>> qeye(3) # doctest: +SKIP; Quantum object: dims = [[3], [3]], shape = (3, 3), type = oper, \; isherm = True; Qobj data =; [[ 1. 0. 0.]; [ 0. 1. 0.]; [ 0. 0. 1.]]; >>> qeye([2,2]) # doctest: +SKIP; Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, \; isherm = True; Qobj data =; [[1. 0. 0. 0.]; [0. 1. 0. 0.]; [0. 0. 1. 0.]; [0. 0. 0. 1.]]. """"""; size, dimensions = _implicit_tensor_dimensions(dimensions); return Qobj(fast_identity(size),; dims=dimensions, isherm=True, isunitary=True). [docs]def identity(dims):; """"""Identity operator. Alternative name to :func:`qeye`. Parameters; ----------; dimensions : (int) or (list of int) or (list of list of int); Dimension of Hilbert space. If provided as a list of ints, then the; dimension is the product over this list, but the ``dims`` property of; the new Qobj are set to this list. This can produce either `oper` ",MatchSource.WIKI,docs/4.7/modules/qutip/operators.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/operators.html
https://qutip.org/docs/4.7/modules/qutip/operators.html:11481,Integrability,depend,depending,11481,"ding on the passed `dimensions`. Returns; -------; oper : qobj; Identity operator Qobj. Examples; --------; >>> qeye(3) # doctest: +SKIP; Quantum object: dims = [[3], [3]], shape = (3, 3), type = oper, \; isherm = True; Qobj data =; [[ 1. 0. 0.]; [ 0. 1. 0.]; [ 0. 0. 1.]]; >>> qeye([2,2]) # doctest: +SKIP; Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, \; isherm = True; Qobj data =; [[1. 0. 0. 0.]; [0. 1. 0. 0.]; [0. 0. 1. 0.]; [0. 0. 0. 1.]]. """"""; size, dimensions = _implicit_tensor_dimensions(dimensions); return Qobj(fast_identity(size),; dims=dimensions, isherm=True, isunitary=True). [docs]def identity(dims):; """"""Identity operator. Alternative name to :func:`qeye`. Parameters; ----------; dimensions : (int) or (list of int) or (list of list of int); Dimension of Hilbert space. If provided as a list of ints, then the; dimension is the product over this list, but the ``dims`` property of; the new Qobj are set to this list. This can produce either `oper` or; `super` depending on the passed `dimensions`. Returns; -------; oper : qobj; Identity operator Qobj.; """"""; return qeye(dims). [docs]def position(N, offset=0):; """"""; Position operator x=1/sqrt(2)*(a+a.dag()). Parameters; ----------; N : int; Number of Fock states in Hilbert space. offset : int (default 0); The lowest number state that is included in the finite number state; representation of the operator. Returns; -------; oper : qobj; Position operator as Qobj.; """"""; a = destroy(N, offset=offset); return 1.0 / np.sqrt(2.0) * (a + a.dag()). [docs]def momentum(N, offset=0):; """"""; Momentum operator p=-1j/sqrt(2)*(a-a.dag()). Parameters; ----------; N : int; Number of Fock states in Hilbert space. offset : int (default 0); The lowest number state that is included in the finite number state; representation of the operator. Returns; -------; oper : qobj; Momentum operator as Qobj.; """"""; a = destroy(N, offset=offset); return -1j / np.sqrt(2.0) * (a - a.dag()). [docs]def num(N, offset=0):; """"""Quant",MatchSource.WIKI,docs/4.7/modules/qutip/operators.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/operators.html
https://qutip.org/docs/4.7/modules/qutip/operators.html:21770,Integrability,depend,dependencies,21770,"mber of excitations that are to be included in the; state space. state : list of integers; The state in the number basis representation. Returns; -------; op : Qobj; A Qobj instance that represent the identity operator in the; exication-number-restricted state space defined by `dims` and; `exciations`.; """"""; from qutip.states import enr_state_dictionaries. nstates, _, _ = enr_state_dictionaries(dims, excitations); data = sp.eye(nstates, nstates, dtype=np.complex128); return Qobj(data, dims=[dims, dims]). [docs]def charge(Nmax, Nmin=None, frac = 1):; """"""; Generate the diagonal charge operator over charge states; from Nmin to Nmax. Parameters; ----------; Nmax : int; Maximum charge state to consider. Nmin : int (default = -Nmax); Lowest charge state to consider. frac : float (default = 1); Specify fractional charge if needed. Returns; -------; C : Qobj; Charge operator over [Nmin,Nmax]. Notes; -----; .. versionadded:: 3.2. """"""; if Nmin is None:; Nmin = -Nmax; diag = np.arange(Nmin, Nmax+1, dtype=float); if frac != 1:; diag *= frac; C = sp.diags(diag, 0, format='csr', dtype=complex); return Qobj(C, isherm=True). [docs]def tunneling(N, m=1):; """"""; Tunneling operator with elements of the form; :math:`\\sum |N><N+m| + |N+m><N|`. Parameters; ----------; N : int; Number of basis states in Hilbert space.; m : int (default = 1); Number of excitations in tunneling event. Returns; -------; T : Qobj; Tunneling operator. Notes; -----; .. versionadded:: 3.2. """"""; diags = [np.ones(N-m,dtype=int),np.ones(N-m,dtype=int)]; T = sp.diags(diags,[m,-m],format='csr', dtype=complex); return Qobj(T, isherm=True). # Break circular dependencies by a trailing import.; # Note that we use a relative import here to deal with that; # qutip.tensor is the *function* tensor, not the module.; from qutip.tensor import tensor. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/modules/qutip/operators.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/operators.html
https://qutip.org/docs/4.7/modules/qutip/operators.html:8453,Performance,perform,perform,8453,"reation (raising) operator. Parameters; ----------; N : int; Dimension of Hilbert space. Returns; -------; oper : qobj; Qobj for raising operator. offset : int (default 0); The lowest number state that is included in the finite number state; representation of the operator. Examples; --------; >>> create(4) # doctest: +SKIP; Quantum object: dims = [[4], [4]], \; shape = [4, 4], type = oper, isHerm = False; Qobj data =; [[ 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 1.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 0.00000000+0.j 1.41421356+0.j 0.00000000+0.j 0.00000000+0.j]; [ 0.00000000+0.j 0.00000000+0.j 1.73205081+0.j 0.00000000+0.j]]. '''; if not isinstance(N, (int, np.integer)): # raise error if N not integer; raise ValueError(""Hilbert space dimension must be integer value""); qo = destroy(N, offset=offset) # create operator using destroy function; return qo.dag(). def _implicit_tensor_dimensions(dimensions):; """"""; Total flattened size and operator dimensions for operator creation routines; that automatically perform tensor products. Parameters; ----------; dimensions : (int) or (list of int) or (list of list of int); First dimension of an operator which can create an implicit tensor; product. If the type is `int`, it is promoted first to `[dimensions]`.; From there, it should be one of the two-elements `dims` parameter of a; `qutip.Qobj` representing an `oper` or `super`, with possible tensor; products. Returns; -------; size : int; Dimension of backing matrix required to represent operator.; dimensions : list; Dimension list in the form required by ``Qobj`` creation.; """"""; if not isinstance(dimensions, list):; dimensions = [dimensions]; flat = flatten(dimensions); if not all(isinstance(x, numbers.Integral) and x >= 0 for x in flat):; raise ValueError(""All dimensions must be integers >= 0""); return np.prod(flat), [dimensions, dimensions]. [docs]def qzero(dimensions):; """"""; Zero operator. Parameters; ----------; dimensions : (int",MatchSource.WIKI,docs/4.7/modules/qutip/operators.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/operators.html
https://qutip.org/docs/4.7/modules/qutip/orbital.html:2629,Deployability,update,updated,2629,"}` are the; coefficients specified by the list of kets. Each ket has 2l+1 components; for some integer l. The first entry of the ket defines the coefficient; c_{l,-l}, while the last entry of the ket defines the; coefficient c_{l, l}. Parameters; ----------; theta : int/float/list/array; Polar angles in [0, pi]. phi : int/float/list/array; Azimuthal angles in [0, 2*pi]. args : list/array; ``list`` of ket vectors. Returns; -------; ``array`` for angular wave function evaluated at all; possible combinations of theta and phi. """"""; if isinstance(args[0], list):; # use the list in args[0]; args = args[0]. # convert to numpy array; theta = np.atleast_1d(theta); phi = np.atleast_1d(phi); # check that arrays are only 1D; if len(theta.shape) != 1:; raise ValueError('Polar angles theta must be 1D list'); if len(phi.shape) != 1:; raise ValueError('Azimuthal angles phi must be 1D list'). # make meshgrid; phi_mesh, theta_mesh = np.meshgrid(phi, theta); # setup empty wavefunction; psi = np.zeros([theta.shape[0], phi.shape[0]], dtype=complex); # iterate through provided kets; for k in range(len(args)):; ket = args[k]; if ket.type == 'bra':; ket = ket.conj(); elif not ket.type == 'ket':; raise TypeError('Invalid type for input ket in orbital'); # Extract l value from the state; l = (ket.shape[0] - 1) / 2.0; if l != np.floor(l):; raise ValueError(; 'Kets must have odd number of components in orbital'); l = int(l); # get factors from ket; factors = ket.full(); # iterate through the possible m. for i in range(len(factors)):; # set correct m; m = i - l; # calculate spherical harmonics; # note that theta and phi are interchanged in scipy implementation; res = sph_harm(m, l, phi_mesh, theta_mesh); psi += factors[i] * res. # flatten output if only one row; if psi.shape[1] == 1:; psi = psi.flatten(). return psi. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/modules/qutip/orbital.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/orbital.html
https://qutip.org/docs/4.7/modules/qutip/parallel.html:4774,Deployability,update,update,4774,"nction work as a drop-in replacement of; :func:`qutip.parallel.parallel_map`. Parameters; ----------; task : a Python function; The function that is to be called for each value in ``task_vec``.; values : array / list; The list or array of values for which the ``task`` function is to be; evaluated.; task_args : list / dictionary; The optional additional argument to the ``task`` function.; task_kwargs : list / dictionary; The optional additional keyword argument to the ``task`` function.; progress_bar : ProgressBar; Progress bar class instance for showing progress. Returns; --------; result : list; The result list contains the value of; ``task(value, *task_args, **task_kwargs)`` for each; value in ``values``. """"""; try:; progress_bar = kwargs['progress_bar']; if progress_bar is True:; progress_bar = TextProgressBar(); except:; progress_bar = BaseProgressBar(). progress_bar.start(len(values)); results = []; for n, value in enumerate(values):; progress_bar.update(n); result = task(value, *task_args, **task_kwargs); results.append(result); progress_bar.finished(). return results. [docs]def parallel_map(task, values, task_args=tuple(), task_kwargs={}, **kwargs):; """"""; Parallel execution of a mapping of `values` to the function `task`. This; is functionally equivalent to::. result = [task(value, *task_args, **task_kwargs) for value in values]. Parameters; ----------; task : a Python function; The function that is to be called for each value in ``task_vec``.; values : array / list; The list or array of values for which the ``task`` function is to be; evaluated.; task_args : list / dictionary; The optional additional argument to the ``task`` function.; task_kwargs : list / dictionary; The optional additional keyword argument to the ``task`` function.; progress_bar : ProgressBar; Progress bar class instance for showing progress. Returns; --------; result : list; The result list contains the value of; ``task(value, *task_args, **task_kwargs)`` for; each value in ``values``. """"""",MatchSource.WIKI,docs/4.7/modules/qutip/parallel.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/parallel.html
https://qutip.org/docs/4.7/modules/qutip/parallel.html:6199,Deployability,update,update,6199,"allel execution of a mapping of `values` to the function `task`. This; is functionally equivalent to::. result = [task(value, *task_args, **task_kwargs) for value in values]. Parameters; ----------; task : a Python function; The function that is to be called for each value in ``task_vec``.; values : array / list; The list or array of values for which the ``task`` function is to be; evaluated.; task_args : list / dictionary; The optional additional argument to the ``task`` function.; task_kwargs : list / dictionary; The optional additional keyword argument to the ``task`` function.; progress_bar : ProgressBar; Progress bar class instance for showing progress. Returns; --------; result : list; The result list contains the value of; ``task(value, *task_args, **task_kwargs)`` for; each value in ``values``. """"""; os.environ['QUTIP_IN_PARALLEL'] = 'TRUE'; kw = _default_kwargs(); if 'num_cpus' in kwargs:; kw['num_cpus'] = kwargs['num_cpus']. try:; progress_bar = kwargs['progress_bar']; if progress_bar is True:; progress_bar = TextProgressBar(); except:; progress_bar = BaseProgressBar(). progress_bar.start(len(values)); nfinished = [0]. def _update_progress_bar(x):; nfinished[0] += 1; progress_bar.update(nfinished[0]). try:; pool = Pool(processes=kw['num_cpus']). async_res = [pool.apply_async(task, (value,) + task_args, task_kwargs,; _update_progress_bar); for value in values]. while not all([ar.ready() for ar in async_res]):; for ar in async_res:; ar.wait(timeout=0.1). pool.terminate(); pool.join(). except KeyboardInterrupt as e:; os.environ['QUTIP_IN_PARALLEL'] = 'FALSE'; pool.terminate(); pool.join(); raise e. progress_bar.finished(); os.environ['QUTIP_IN_PARALLEL'] = 'FALSE'; return [ar.get() for ar in async_res]. def _default_kwargs():; settings = {'num_cpus': qset.num_cpus}; return settings. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/modules/qutip/parallel.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/parallel.html
https://qutip.org/docs/4.7/modules/qutip/parallel.html:6890,Deployability,update,updated,6890,"allel execution of a mapping of `values` to the function `task`. This; is functionally equivalent to::. result = [task(value, *task_args, **task_kwargs) for value in values]. Parameters; ----------; task : a Python function; The function that is to be called for each value in ``task_vec``.; values : array / list; The list or array of values for which the ``task`` function is to be; evaluated.; task_args : list / dictionary; The optional additional argument to the ``task`` function.; task_kwargs : list / dictionary; The optional additional keyword argument to the ``task`` function.; progress_bar : ProgressBar; Progress bar class instance for showing progress. Returns; --------; result : list; The result list contains the value of; ``task(value, *task_args, **task_kwargs)`` for; each value in ``values``. """"""; os.environ['QUTIP_IN_PARALLEL'] = 'TRUE'; kw = _default_kwargs(); if 'num_cpus' in kwargs:; kw['num_cpus'] = kwargs['num_cpus']. try:; progress_bar = kwargs['progress_bar']; if progress_bar is True:; progress_bar = TextProgressBar(); except:; progress_bar = BaseProgressBar(). progress_bar.start(len(values)); nfinished = [0]. def _update_progress_bar(x):; nfinished[0] += 1; progress_bar.update(nfinished[0]). try:; pool = Pool(processes=kw['num_cpus']). async_res = [pool.apply_async(task, (value,) + task_args, task_kwargs,; _update_progress_bar); for value in values]. while not all([ar.ready() for ar in async_res]):; for ar in async_res:; ar.wait(timeout=0.1). pool.terminate(); pool.join(). except KeyboardInterrupt as e:; os.environ['QUTIP_IN_PARALLEL'] = 'FALSE'; pool.terminate(); pool.join(); raise e. progress_bar.finished(); os.environ['QUTIP_IN_PARALLEL'] = 'FALSE'; return [ar.get() for ar in async_res]. def _default_kwargs():; settings = {'num_cpus': qset.num_cpus}; return settings. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/modules/qutip/parallel.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/parallel.html
https://qutip.org/docs/4.7/modules/qutip/parallel.html:1239,Modifiability,variab,variable,1239," and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.parallel. Source code for qutip.parallel; """"""; This function provides functions for parallel execution of loops and function; mappings, using the builtin Python module multiprocessing.; """"""; __all__ = ['parfor', 'parallel_map', 'serial_map']. from numpy import array; import multiprocessing; from functools import partial; import os; import sys; import signal; import qutip.settings as qset; from qutip.ui.progressbar import BaseProgressBar, TextProgressBar. if sys.platform == 'darwin':; Pool = multiprocessing.get_context('fork').Pool; else:; Pool = multiprocessing.Pool. def _task_wrapper(args):; try:; return args[0](*args[1]); except KeyboardInterrupt:; os.kill(args[2], signal.SIGINT); sys.exit(1). def _task_wrapper_with_args(args, user_args):; try:; return args[0](*args[1], **user_args); except KeyboardInterrupt:; os.kill(args[2], signal.SIGINT); sys.exit(1). [docs]def parfor(func, *args, **kwargs):; """"""Executes a multi-variable function in parallel on the local machine. Parallel execution of a for-loop over function `func` for multiple input; arguments and keyword arguments. .. note::. From QuTiP 3.1, we recommend to use :func:`qutip.parallel.parallel_map`; instead of this function. Parameters; ----------; func : function_type; A function to run in parallel on the local machine. The function 'func'; accepts a series of arguments that are passed to the function as; variables. In general, the function can have multiple input variables,; and these arguments must be passed in the same order as they are; defined in the function definition. In addition, the user can pass; multiple keyword arguments to the function. The following keyword argument is reserved:. num_cpus : int; Number of CPU's to use. Default uses maximum number of CPU's.; Performance degrades if num_cpus is larger than the physical CPU; count of your machine. Returns; -------; result : list; A ``list`` with length equal to number of in",MatchSource.WIKI,docs/4.7/modules/qutip/parallel.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/parallel.html
https://qutip.org/docs/4.7/modules/qutip/parallel.html:1693,Modifiability,variab,variables,1693,"mport signal; import qutip.settings as qset; from qutip.ui.progressbar import BaseProgressBar, TextProgressBar. if sys.platform == 'darwin':; Pool = multiprocessing.get_context('fork').Pool; else:; Pool = multiprocessing.Pool. def _task_wrapper(args):; try:; return args[0](*args[1]); except KeyboardInterrupt:; os.kill(args[2], signal.SIGINT); sys.exit(1). def _task_wrapper_with_args(args, user_args):; try:; return args[0](*args[1], **user_args); except KeyboardInterrupt:; os.kill(args[2], signal.SIGINT); sys.exit(1). [docs]def parfor(func, *args, **kwargs):; """"""Executes a multi-variable function in parallel on the local machine. Parallel execution of a for-loop over function `func` for multiple input; arguments and keyword arguments. .. note::. From QuTiP 3.1, we recommend to use :func:`qutip.parallel.parallel_map`; instead of this function. Parameters; ----------; func : function_type; A function to run in parallel on the local machine. The function 'func'; accepts a series of arguments that are passed to the function as; variables. In general, the function can have multiple input variables,; and these arguments must be passed in the same order as they are; defined in the function definition. In addition, the user can pass; multiple keyword arguments to the function. The following keyword argument is reserved:. num_cpus : int; Number of CPU's to use. Default uses maximum number of CPU's.; Performance degrades if num_cpus is larger than the physical CPU; count of your machine. Returns; -------; result : list; A ``list`` with length equal to number of input parameters; containing the output from `func`. """"""; os.environ['QUTIP_IN_PARALLEL'] = 'TRUE'; kw = _default_kwargs(); if 'num_cpus' in kwargs.keys():; kw['num_cpus'] = kwargs['num_cpus']; del kwargs['num_cpus']; if len(kwargs) != 0:; task_func = partial(_task_wrapper_with_args, user_args=kwargs); else:; task_func = _task_wrapper. if kw['num_cpus'] > qset.num_cpus:; print(""Requested number of CPUs (%s) "" % kw['num_",MatchSource.WIKI,docs/4.7/modules/qutip/parallel.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/parallel.html
https://qutip.org/docs/4.7/modules/qutip/parallel.html:1753,Modifiability,variab,variables,1753," 'darwin':; Pool = multiprocessing.get_context('fork').Pool; else:; Pool = multiprocessing.Pool. def _task_wrapper(args):; try:; return args[0](*args[1]); except KeyboardInterrupt:; os.kill(args[2], signal.SIGINT); sys.exit(1). def _task_wrapper_with_args(args, user_args):; try:; return args[0](*args[1], **user_args); except KeyboardInterrupt:; os.kill(args[2], signal.SIGINT); sys.exit(1). [docs]def parfor(func, *args, **kwargs):; """"""Executes a multi-variable function in parallel on the local machine. Parallel execution of a for-loop over function `func` for multiple input; arguments and keyword arguments. .. note::. From QuTiP 3.1, we recommend to use :func:`qutip.parallel.parallel_map`; instead of this function. Parameters; ----------; func : function_type; A function to run in parallel on the local machine. The function 'func'; accepts a series of arguments that are passed to the function as; variables. In general, the function can have multiple input variables,; and these arguments must be passed in the same order as they are; defined in the function definition. In addition, the user can pass; multiple keyword arguments to the function. The following keyword argument is reserved:. num_cpus : int; Number of CPU's to use. Default uses maximum number of CPU's.; Performance degrades if num_cpus is larger than the physical CPU; count of your machine. Returns; -------; result : list; A ``list`` with length equal to number of input parameters; containing the output from `func`. """"""; os.environ['QUTIP_IN_PARALLEL'] = 'TRUE'; kw = _default_kwargs(); if 'num_cpus' in kwargs.keys():; kw['num_cpus'] = kwargs['num_cpus']; del kwargs['num_cpus']; if len(kwargs) != 0:; task_func = partial(_task_wrapper_with_args, user_args=kwargs); else:; task_func = _task_wrapper. if kw['num_cpus'] > qset.num_cpus:; print(""Requested number of CPUs (%s) "" % kw['num_cpus'] +; ""is larger than physical number (%s)."" % qset.num_cpus); print(""Reduce 'num_cpus' for greater performance.""). pool = Pool",MatchSource.WIKI,docs/4.7/modules/qutip/parallel.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/parallel.html
https://qutip.org/docs/4.7/modules/qutip/parallel.html:2758,Performance,perform,performance,2758,"ltiple input variables,; and these arguments must be passed in the same order as they are; defined in the function definition. In addition, the user can pass; multiple keyword arguments to the function. The following keyword argument is reserved:. num_cpus : int; Number of CPU's to use. Default uses maximum number of CPU's.; Performance degrades if num_cpus is larger than the physical CPU; count of your machine. Returns; -------; result : list; A ``list`` with length equal to number of input parameters; containing the output from `func`. """"""; os.environ['QUTIP_IN_PARALLEL'] = 'TRUE'; kw = _default_kwargs(); if 'num_cpus' in kwargs.keys():; kw['num_cpus'] = kwargs['num_cpus']; del kwargs['num_cpus']; if len(kwargs) != 0:; task_func = partial(_task_wrapper_with_args, user_args=kwargs); else:; task_func = _task_wrapper. if kw['num_cpus'] > qset.num_cpus:; print(""Requested number of CPUs (%s) "" % kw['num_cpus'] +; ""is larger than physical number (%s)."" % qset.num_cpus); print(""Reduce 'num_cpus' for greater performance.""). pool = Pool(processes=kw['num_cpus']); args = [list(arg) for arg in args]; var = [[args[j][i] for j in range(len(args))]; for i in range(len(list(args[0])))]; try:; map_args = ((func, v, os.getpid()) for v in var); par_return = list(pool.map(task_func, map_args)). pool.terminate(); pool.join(); os.environ['QUTIP_IN_PARALLEL'] = 'FALSE'; if isinstance(par_return[0], tuple):; par_return = [elem for elem in par_return]; num_elems = len(par_return[0]); dt = [type(ii) for ii in par_return[0]]; return [array([elem[ii] for elem in par_return], dtype=dt[ii]); for ii in range(num_elems)]; else:; return par_return. except KeyboardInterrupt:; os.environ['QUTIP_IN_PARALLEL'] = 'FALSE'; pool.terminate(). [docs]def serial_map(task, values, task_args=tuple(), task_kwargs={}, **kwargs):; """"""; Serial mapping function with the same call signature as parallel_map, for; easy switching between serial and parallel execution. This; is functionally equivalent to::. result = [",MatchSource.WIKI,docs/4.7/modules/qutip/parallel.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/parallel.html
https://qutip.org/docs/4.7/modules/qutip/parallel.html:6463,Safety,timeout,timeout,6463,"allel execution of a mapping of `values` to the function `task`. This; is functionally equivalent to::. result = [task(value, *task_args, **task_kwargs) for value in values]. Parameters; ----------; task : a Python function; The function that is to be called for each value in ``task_vec``.; values : array / list; The list or array of values for which the ``task`` function is to be; evaluated.; task_args : list / dictionary; The optional additional argument to the ``task`` function.; task_kwargs : list / dictionary; The optional additional keyword argument to the ``task`` function.; progress_bar : ProgressBar; Progress bar class instance for showing progress. Returns; --------; result : list; The result list contains the value of; ``task(value, *task_args, **task_kwargs)`` for; each value in ``values``. """"""; os.environ['QUTIP_IN_PARALLEL'] = 'TRUE'; kw = _default_kwargs(); if 'num_cpus' in kwargs:; kw['num_cpus'] = kwargs['num_cpus']. try:; progress_bar = kwargs['progress_bar']; if progress_bar is True:; progress_bar = TextProgressBar(); except:; progress_bar = BaseProgressBar(). progress_bar.start(len(values)); nfinished = [0]. def _update_progress_bar(x):; nfinished[0] += 1; progress_bar.update(nfinished[0]). try:; pool = Pool(processes=kw['num_cpus']). async_res = [pool.apply_async(task, (value,) + task_args, task_kwargs,; _update_progress_bar); for value in values]. while not all([ar.ready() for ar in async_res]):; for ar in async_res:; ar.wait(timeout=0.1). pool.terminate(); pool.join(). except KeyboardInterrupt as e:; os.environ['QUTIP_IN_PARALLEL'] = 'FALSE'; pool.terminate(); pool.join(); raise e. progress_bar.finished(); os.environ['QUTIP_IN_PARALLEL'] = 'FALSE'; return [ar.get() for ar in async_res]. def _default_kwargs():; settings = {'num_cpus': qset.num_cpus}; return settings. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/modules/qutip/parallel.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/parallel.html
https://qutip.org/docs/4.7/modules/qutip/partial_transpose.html:610,Availability,mask,mask,610,". qutip.partial_transpose — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.partial_transpose. Source code for qutip.partial_transpose; __all__ = ['partial_transpose']. import numpy as np; import scipy.sparse as sp. from qutip.qobj import Qobj; from qutip.states import (state_index_number, state_number_index,; state_number_enumerate). [docs]def partial_transpose(rho, mask, method='dense'):; """"""; Return the partial transpose of a Qobj instance `rho`,; where `mask` is an array/list with length that equals; the number of components of `rho` (that is, the length of; `rho.dims[0]`), and the values in `mask` indicates whether; or not the corresponding subsystem is to be transposed.; The elements in `mask` can be boolean or integers `0` or `1`,; where `True`/`1` indicates that the corresponding subsystem; should be tranposed. Parameters; ----------. rho : :class:`qutip.qobj`; A density matrix. mask : *list* / *array*; A mask that selects which subsystems should be transposed. method : str; choice of method, `dense` or `sparse`. The default method; is `dense`. The `sparse` implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns; -------. rho_pr: :class:`qutip.qobj`. A density matrix with the selected subsystems transposed. """""". mask = [int(i) for i in mask]. if method == 'sparse':; return _partial_transpose_sparse(rho, mask); else:; return _partial_transpose_dense(rho, mask). def _partial_transpose_dense(rho, mask):; """"""; Based on Jonas' implementation using numpy.; Very fast for dense problems.; """"""; nsys = len(mask); pt_dims = np.arange(2 * nsys).reshape(2, nsys).T; pt_idx = np.concatenate([[pt_dims[n, mask[n]] for n in range(nsys)],; [pt_dims[n, 1 - mask[n]] for n in range(nsys)]]). data = rho.da",MatchSource.WIKI,docs/4.7/modules/qutip/partial_transpose.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/partial_transpose.html
https://qutip.org/docs/4.7/modules/qutip/partial_transpose.html:702,Availability,mask,mask,702,". qutip.partial_transpose — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.partial_transpose. Source code for qutip.partial_transpose; __all__ = ['partial_transpose']. import numpy as np; import scipy.sparse as sp. from qutip.qobj import Qobj; from qutip.states import (state_index_number, state_number_index,; state_number_enumerate). [docs]def partial_transpose(rho, mask, method='dense'):; """"""; Return the partial transpose of a Qobj instance `rho`,; where `mask` is an array/list with length that equals; the number of components of `rho` (that is, the length of; `rho.dims[0]`), and the values in `mask` indicates whether; or not the corresponding subsystem is to be transposed.; The elements in `mask` can be boolean or integers `0` or `1`,; where `True`/`1` indicates that the corresponding subsystem; should be tranposed. Parameters; ----------. rho : :class:`qutip.qobj`; A density matrix. mask : *list* / *array*; A mask that selects which subsystems should be transposed. method : str; choice of method, `dense` or `sparse`. The default method; is `dense`. The `sparse` implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns; -------. rho_pr: :class:`qutip.qobj`. A density matrix with the selected subsystems transposed. """""". mask = [int(i) for i in mask]. if method == 'sparse':; return _partial_transpose_sparse(rho, mask); else:; return _partial_transpose_dense(rho, mask). def _partial_transpose_dense(rho, mask):; """"""; Based on Jonas' implementation using numpy.; Very fast for dense problems.; """"""; nsys = len(mask); pt_dims = np.arange(2 * nsys).reshape(2, nsys).T; pt_idx = np.concatenate([[pt_dims[n, mask[n]] for n in range(nsys)],; [pt_dims[n, 1 - mask[n]] for n in range(nsys)]]). data = rho.da",MatchSource.WIKI,docs/4.7/modules/qutip/partial_transpose.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/partial_transpose.html
https://qutip.org/docs/4.7/modules/qutip/partial_transpose.html:844,Availability,mask,mask,844,". qutip.partial_transpose — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.partial_transpose. Source code for qutip.partial_transpose; __all__ = ['partial_transpose']. import numpy as np; import scipy.sparse as sp. from qutip.qobj import Qobj; from qutip.states import (state_index_number, state_number_index,; state_number_enumerate). [docs]def partial_transpose(rho, mask, method='dense'):; """"""; Return the partial transpose of a Qobj instance `rho`,; where `mask` is an array/list with length that equals; the number of components of `rho` (that is, the length of; `rho.dims[0]`), and the values in `mask` indicates whether; or not the corresponding subsystem is to be transposed.; The elements in `mask` can be boolean or integers `0` or `1`,; where `True`/`1` indicates that the corresponding subsystem; should be tranposed. Parameters; ----------. rho : :class:`qutip.qobj`; A density matrix. mask : *list* / *array*; A mask that selects which subsystems should be transposed. method : str; choice of method, `dense` or `sparse`. The default method; is `dense`. The `sparse` implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns; -------. rho_pr: :class:`qutip.qobj`. A density matrix with the selected subsystems transposed. """""". mask = [int(i) for i in mask]. if method == 'sparse':; return _partial_transpose_sparse(rho, mask); else:; return _partial_transpose_dense(rho, mask). def _partial_transpose_dense(rho, mask):; """"""; Based on Jonas' implementation using numpy.; Very fast for dense problems.; """"""; nsys = len(mask); pt_dims = np.arange(2 * nsys).reshape(2, nsys).T; pt_idx = np.concatenate([[pt_dims[n, mask[n]] for n in range(nsys)],; [pt_dims[n, 1 - mask[n]] for n in range(nsys)]]). data = rho.da",MatchSource.WIKI,docs/4.7/modules/qutip/partial_transpose.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/partial_transpose.html
https://qutip.org/docs/4.7/modules/qutip/partial_transpose.html:943,Availability,mask,mask,943,". qutip.partial_transpose — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.partial_transpose. Source code for qutip.partial_transpose; __all__ = ['partial_transpose']. import numpy as np; import scipy.sparse as sp. from qutip.qobj import Qobj; from qutip.states import (state_index_number, state_number_index,; state_number_enumerate). [docs]def partial_transpose(rho, mask, method='dense'):; """"""; Return the partial transpose of a Qobj instance `rho`,; where `mask` is an array/list with length that equals; the number of components of `rho` (that is, the length of; `rho.dims[0]`), and the values in `mask` indicates whether; or not the corresponding subsystem is to be transposed.; The elements in `mask` can be boolean or integers `0` or `1`,; where `True`/`1` indicates that the corresponding subsystem; should be tranposed. Parameters; ----------. rho : :class:`qutip.qobj`; A density matrix. mask : *list* / *array*; A mask that selects which subsystems should be transposed. method : str; choice of method, `dense` or `sparse`. The default method; is `dense`. The `sparse` implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns; -------. rho_pr: :class:`qutip.qobj`. A density matrix with the selected subsystems transposed. """""". mask = [int(i) for i in mask]. if method == 'sparse':; return _partial_transpose_sparse(rho, mask); else:; return _partial_transpose_dense(rho, mask). def _partial_transpose_dense(rho, mask):; """"""; Based on Jonas' implementation using numpy.; Very fast for dense problems.; """"""; nsys = len(mask); pt_dims = np.arange(2 * nsys).reshape(2, nsys).T; pt_idx = np.concatenate([[pt_dims[n, mask[n]] for n in range(nsys)],; [pt_dims[n, 1 - mask[n]] for n in range(nsys)]]). data = rho.da",MatchSource.WIKI,docs/4.7/modules/qutip/partial_transpose.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/partial_transpose.html
https://qutip.org/docs/4.7/modules/qutip/partial_transpose.html:1140,Availability,mask,mask,1140,"evelopers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.partial_transpose. Source code for qutip.partial_transpose; __all__ = ['partial_transpose']. import numpy as np; import scipy.sparse as sp. from qutip.qobj import Qobj; from qutip.states import (state_index_number, state_number_index,; state_number_enumerate). [docs]def partial_transpose(rho, mask, method='dense'):; """"""; Return the partial transpose of a Qobj instance `rho`,; where `mask` is an array/list with length that equals; the number of components of `rho` (that is, the length of; `rho.dims[0]`), and the values in `mask` indicates whether; or not the corresponding subsystem is to be transposed.; The elements in `mask` can be boolean or integers `0` or `1`,; where `True`/`1` indicates that the corresponding subsystem; should be tranposed. Parameters; ----------. rho : :class:`qutip.qobj`; A density matrix. mask : *list* / *array*; A mask that selects which subsystems should be transposed. method : str; choice of method, `dense` or `sparse`. The default method; is `dense`. The `sparse` implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns; -------. rho_pr: :class:`qutip.qobj`. A density matrix with the selected subsystems transposed. """""". mask = [int(i) for i in mask]. if method == 'sparse':; return _partial_transpose_sparse(rho, mask); else:; return _partial_transpose_dense(rho, mask). def _partial_transpose_dense(rho, mask):; """"""; Based on Jonas' implementation using numpy.; Very fast for dense problems.; """"""; nsys = len(mask); pt_dims = np.arange(2 * nsys).reshape(2, nsys).T; pt_idx = np.concatenate([[pt_dims[n, mask[n]] for n in range(nsys)],; [pt_dims[n, 1 - mask[n]] for n in range(nsys)]]). data = rho.data.toarray().reshape(; np.array(rho.dims).flatten()).transpose(pt_idx).reshape(rho.shape). return Qobj(data, dims=rho.dims). def _partial_transpose_sparse(rho, mask):; """"""; Impleme",MatchSource.WIKI,docs/4.7/modules/qutip/partial_transpose.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/partial_transpose.html
https://qutip.org/docs/4.7/modules/qutip/partial_transpose.html:1167,Availability,mask,mask,1167,"evelopers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.partial_transpose. Source code for qutip.partial_transpose; __all__ = ['partial_transpose']. import numpy as np; import scipy.sparse as sp. from qutip.qobj import Qobj; from qutip.states import (state_index_number, state_number_index,; state_number_enumerate). [docs]def partial_transpose(rho, mask, method='dense'):; """"""; Return the partial transpose of a Qobj instance `rho`,; where `mask` is an array/list with length that equals; the number of components of `rho` (that is, the length of; `rho.dims[0]`), and the values in `mask` indicates whether; or not the corresponding subsystem is to be transposed.; The elements in `mask` can be boolean or integers `0` or `1`,; where `True`/`1` indicates that the corresponding subsystem; should be tranposed. Parameters; ----------. rho : :class:`qutip.qobj`; A density matrix. mask : *list* / *array*; A mask that selects which subsystems should be transposed. method : str; choice of method, `dense` or `sparse`. The default method; is `dense`. The `sparse` implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns; -------. rho_pr: :class:`qutip.qobj`. A density matrix with the selected subsystems transposed. """""". mask = [int(i) for i in mask]. if method == 'sparse':; return _partial_transpose_sparse(rho, mask); else:; return _partial_transpose_dense(rho, mask). def _partial_transpose_dense(rho, mask):; """"""; Based on Jonas' implementation using numpy.; Very fast for dense problems.; """"""; nsys = len(mask); pt_dims = np.arange(2 * nsys).reshape(2, nsys).T; pt_idx = np.concatenate([[pt_dims[n, mask[n]] for n in range(nsys)],; [pt_dims[n, 1 - mask[n]] for n in range(nsys)]]). data = rho.data.toarray().reshape(; np.array(rho.dims).flatten()).transpose(pt_idx).reshape(rho.shape). return Qobj(data, dims=rho.dims). def _partial_transpose_sparse(rho, mask):; """"""; Impleme",MatchSource.WIKI,docs/4.7/modules/qutip/partial_transpose.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/partial_transpose.html
https://qutip.org/docs/4.7/modules/qutip/partial_transpose.html:1521,Availability,mask,mask,1521,"e_number_index,; state_number_enumerate). [docs]def partial_transpose(rho, mask, method='dense'):; """"""; Return the partial transpose of a Qobj instance `rho`,; where `mask` is an array/list with length that equals; the number of components of `rho` (that is, the length of; `rho.dims[0]`), and the values in `mask` indicates whether; or not the corresponding subsystem is to be transposed.; The elements in `mask` can be boolean or integers `0` or `1`,; where `True`/`1` indicates that the corresponding subsystem; should be tranposed. Parameters; ----------. rho : :class:`qutip.qobj`; A density matrix. mask : *list* / *array*; A mask that selects which subsystems should be transposed. method : str; choice of method, `dense` or `sparse`. The default method; is `dense`. The `sparse` implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns; -------. rho_pr: :class:`qutip.qobj`. A density matrix with the selected subsystems transposed. """""". mask = [int(i) for i in mask]. if method == 'sparse':; return _partial_transpose_sparse(rho, mask); else:; return _partial_transpose_dense(rho, mask). def _partial_transpose_dense(rho, mask):; """"""; Based on Jonas' implementation using numpy.; Very fast for dense problems.; """"""; nsys = len(mask); pt_dims = np.arange(2 * nsys).reshape(2, nsys).T; pt_idx = np.concatenate([[pt_dims[n, mask[n]] for n in range(nsys)],; [pt_dims[n, 1 - mask[n]] for n in range(nsys)]]). data = rho.data.toarray().reshape(; np.array(rho.dims).flatten()).transpose(pt_idx).reshape(rho.shape). return Qobj(data, dims=rho.dims). def _partial_transpose_sparse(rho, mask):; """"""; Implement the partial transpose using the CSR sparse matrix.; """""". data = sp.lil_matrix((rho.shape[0], rho.shape[1]), dtype=complex). for m in range(len(rho.data.indptr) - 1):. n1 = rho.data.indptr[m]; n2 = rho.data.indptr[m + 1]. psi_A = state_index_number(rho.dims[0], m). for idx, n in enumerate(rho.data.indices[n1:n2]):. psi_B = state_index_number(rho.dims[",MatchSource.WIKI,docs/4.7/modules/qutip/partial_transpose.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/partial_transpose.html
https://qutip.org/docs/4.7/modules/qutip/partial_transpose.html:1545,Availability,mask,mask,1545,"e_number_index,; state_number_enumerate). [docs]def partial_transpose(rho, mask, method='dense'):; """"""; Return the partial transpose of a Qobj instance `rho`,; where `mask` is an array/list with length that equals; the number of components of `rho` (that is, the length of; `rho.dims[0]`), and the values in `mask` indicates whether; or not the corresponding subsystem is to be transposed.; The elements in `mask` can be boolean or integers `0` or `1`,; where `True`/`1` indicates that the corresponding subsystem; should be tranposed. Parameters; ----------. rho : :class:`qutip.qobj`; A density matrix. mask : *list* / *array*; A mask that selects which subsystems should be transposed. method : str; choice of method, `dense` or `sparse`. The default method; is `dense`. The `sparse` implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns; -------. rho_pr: :class:`qutip.qobj`. A density matrix with the selected subsystems transposed. """""". mask = [int(i) for i in mask]. if method == 'sparse':; return _partial_transpose_sparse(rho, mask); else:; return _partial_transpose_dense(rho, mask). def _partial_transpose_dense(rho, mask):; """"""; Based on Jonas' implementation using numpy.; Very fast for dense problems.; """"""; nsys = len(mask); pt_dims = np.arange(2 * nsys).reshape(2, nsys).T; pt_idx = np.concatenate([[pt_dims[n, mask[n]] for n in range(nsys)],; [pt_dims[n, 1 - mask[n]] for n in range(nsys)]]). data = rho.data.toarray().reshape(; np.array(rho.dims).flatten()).transpose(pt_idx).reshape(rho.shape). return Qobj(data, dims=rho.dims). def _partial_transpose_sparse(rho, mask):; """"""; Implement the partial transpose using the CSR sparse matrix.; """""". data = sp.lil_matrix((rho.shape[0], rho.shape[1]), dtype=complex). for m in range(len(rho.data.indptr) - 1):. n1 = rho.data.indptr[m]; n2 = rho.data.indptr[m + 1]. psi_A = state_index_number(rho.dims[0], m). for idx, n in enumerate(rho.data.indices[n1:n2]):. psi_B = state_index_number(rho.dims[",MatchSource.WIKI,docs/4.7/modules/qutip/partial_transpose.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/partial_transpose.html
https://qutip.org/docs/4.7/modules/qutip/partial_transpose.html:1614,Availability,mask,mask,1614,"ask, method='dense'):; """"""; Return the partial transpose of a Qobj instance `rho`,; where `mask` is an array/list with length that equals; the number of components of `rho` (that is, the length of; `rho.dims[0]`), and the values in `mask` indicates whether; or not the corresponding subsystem is to be transposed.; The elements in `mask` can be boolean or integers `0` or `1`,; where `True`/`1` indicates that the corresponding subsystem; should be tranposed. Parameters; ----------. rho : :class:`qutip.qobj`; A density matrix. mask : *list* / *array*; A mask that selects which subsystems should be transposed. method : str; choice of method, `dense` or `sparse`. The default method; is `dense`. The `sparse` implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns; -------. rho_pr: :class:`qutip.qobj`. A density matrix with the selected subsystems transposed. """""". mask = [int(i) for i in mask]. if method == 'sparse':; return _partial_transpose_sparse(rho, mask); else:; return _partial_transpose_dense(rho, mask). def _partial_transpose_dense(rho, mask):; """"""; Based on Jonas' implementation using numpy.; Very fast for dense problems.; """"""; nsys = len(mask); pt_dims = np.arange(2 * nsys).reshape(2, nsys).T; pt_idx = np.concatenate([[pt_dims[n, mask[n]] for n in range(nsys)],; [pt_dims[n, 1 - mask[n]] for n in range(nsys)]]). data = rho.data.toarray().reshape(; np.array(rho.dims).flatten()).transpose(pt_idx).reshape(rho.shape). return Qobj(data, dims=rho.dims). def _partial_transpose_sparse(rho, mask):; """"""; Implement the partial transpose using the CSR sparse matrix.; """""". data = sp.lil_matrix((rho.shape[0], rho.shape[1]), dtype=complex). for m in range(len(rho.data.indptr) - 1):. n1 = rho.data.indptr[m]; n2 = rho.data.indptr[m + 1]. psi_A = state_index_number(rho.dims[0], m). for idx, n in enumerate(rho.data.indices[n1:n2]):. psi_B = state_index_number(rho.dims[1], n). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, ps",MatchSource.WIKI,docs/4.7/modules/qutip/partial_transpose.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/partial_transpose.html
https://qutip.org/docs/4.7/modules/qutip/partial_transpose.html:1665,Availability,mask,mask,1665,"ask, method='dense'):; """"""; Return the partial transpose of a Qobj instance `rho`,; where `mask` is an array/list with length that equals; the number of components of `rho` (that is, the length of; `rho.dims[0]`), and the values in `mask` indicates whether; or not the corresponding subsystem is to be transposed.; The elements in `mask` can be boolean or integers `0` or `1`,; where `True`/`1` indicates that the corresponding subsystem; should be tranposed. Parameters; ----------. rho : :class:`qutip.qobj`; A density matrix. mask : *list* / *array*; A mask that selects which subsystems should be transposed. method : str; choice of method, `dense` or `sparse`. The default method; is `dense`. The `sparse` implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns; -------. rho_pr: :class:`qutip.qobj`. A density matrix with the selected subsystems transposed. """""". mask = [int(i) for i in mask]. if method == 'sparse':; return _partial_transpose_sparse(rho, mask); else:; return _partial_transpose_dense(rho, mask). def _partial_transpose_dense(rho, mask):; """"""; Based on Jonas' implementation using numpy.; Very fast for dense problems.; """"""; nsys = len(mask); pt_dims = np.arange(2 * nsys).reshape(2, nsys).T; pt_idx = np.concatenate([[pt_dims[n, mask[n]] for n in range(nsys)],; [pt_dims[n, 1 - mask[n]] for n in range(nsys)]]). data = rho.data.toarray().reshape(; np.array(rho.dims).flatten()).transpose(pt_idx).reshape(rho.shape). return Qobj(data, dims=rho.dims). def _partial_transpose_sparse(rho, mask):; """"""; Implement the partial transpose using the CSR sparse matrix.; """""". data = sp.lil_matrix((rho.shape[0], rho.shape[1]), dtype=complex). for m in range(len(rho.data.indptr) - 1):. n1 = rho.data.indptr[m]; n2 = rho.data.indptr[m + 1]. psi_A = state_index_number(rho.dims[0], m). for idx, n in enumerate(rho.data.indices[n1:n2]):. psi_B = state_index_number(rho.dims[1], n). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, ps",MatchSource.WIKI,docs/4.7/modules/qutip/partial_transpose.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/partial_transpose.html
https://qutip.org/docs/4.7/modules/qutip/partial_transpose.html:1706,Availability,mask,mask,1706,"ray/list with length that equals; the number of components of `rho` (that is, the length of; `rho.dims[0]`), and the values in `mask` indicates whether; or not the corresponding subsystem is to be transposed.; The elements in `mask` can be boolean or integers `0` or `1`,; where `True`/`1` indicates that the corresponding subsystem; should be tranposed. Parameters; ----------. rho : :class:`qutip.qobj`; A density matrix. mask : *list* / *array*; A mask that selects which subsystems should be transposed. method : str; choice of method, `dense` or `sparse`. The default method; is `dense`. The `sparse` implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns; -------. rho_pr: :class:`qutip.qobj`. A density matrix with the selected subsystems transposed. """""". mask = [int(i) for i in mask]. if method == 'sparse':; return _partial_transpose_sparse(rho, mask); else:; return _partial_transpose_dense(rho, mask). def _partial_transpose_dense(rho, mask):; """"""; Based on Jonas' implementation using numpy.; Very fast for dense problems.; """"""; nsys = len(mask); pt_dims = np.arange(2 * nsys).reshape(2, nsys).T; pt_idx = np.concatenate([[pt_dims[n, mask[n]] for n in range(nsys)],; [pt_dims[n, 1 - mask[n]] for n in range(nsys)]]). data = rho.data.toarray().reshape(; np.array(rho.dims).flatten()).transpose(pt_idx).reshape(rho.shape). return Qobj(data, dims=rho.dims). def _partial_transpose_sparse(rho, mask):; """"""; Implement the partial transpose using the CSR sparse matrix.; """""". data = sp.lil_matrix((rho.shape[0], rho.shape[1]), dtype=complex). for m in range(len(rho.data.indptr) - 1):. n1 = rho.data.indptr[m]; n2 = rho.data.indptr[m + 1]. psi_A = state_index_number(rho.dims[0], m). for idx, n in enumerate(rho.data.indices[n1:n2]):. psi_B = state_index_number(rho.dims[1], n). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, psi_B])); n_pt = state_number_index(; rho.dims[0], np.choose(mask, [psi_B, psi_A])). data[m_pt, n_pt] = rho.",MatchSource.WIKI,docs/4.7/modules/qutip/partial_transpose.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/partial_transpose.html
https://qutip.org/docs/4.7/modules/qutip/partial_transpose.html:1811,Availability,mask,mask,1811,"o.dims[0]`), and the values in `mask` indicates whether; or not the corresponding subsystem is to be transposed.; The elements in `mask` can be boolean or integers `0` or `1`,; where `True`/`1` indicates that the corresponding subsystem; should be tranposed. Parameters; ----------. rho : :class:`qutip.qobj`; A density matrix. mask : *list* / *array*; A mask that selects which subsystems should be transposed. method : str; choice of method, `dense` or `sparse`. The default method; is `dense`. The `sparse` implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns; -------. rho_pr: :class:`qutip.qobj`. A density matrix with the selected subsystems transposed. """""". mask = [int(i) for i in mask]. if method == 'sparse':; return _partial_transpose_sparse(rho, mask); else:; return _partial_transpose_dense(rho, mask). def _partial_transpose_dense(rho, mask):; """"""; Based on Jonas' implementation using numpy.; Very fast for dense problems.; """"""; nsys = len(mask); pt_dims = np.arange(2 * nsys).reshape(2, nsys).T; pt_idx = np.concatenate([[pt_dims[n, mask[n]] for n in range(nsys)],; [pt_dims[n, 1 - mask[n]] for n in range(nsys)]]). data = rho.data.toarray().reshape(; np.array(rho.dims).flatten()).transpose(pt_idx).reshape(rho.shape). return Qobj(data, dims=rho.dims). def _partial_transpose_sparse(rho, mask):; """"""; Implement the partial transpose using the CSR sparse matrix.; """""". data = sp.lil_matrix((rho.shape[0], rho.shape[1]), dtype=complex). for m in range(len(rho.data.indptr) - 1):. n1 = rho.data.indptr[m]; n2 = rho.data.indptr[m + 1]. psi_A = state_index_number(rho.dims[0], m). for idx, n in enumerate(rho.data.indices[n1:n2]):. psi_B = state_index_number(rho.dims[1], n). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, psi_B])); n_pt = state_number_index(; rho.dims[0], np.choose(mask, [psi_B, psi_A])). data[m_pt, n_pt] = rho.data.data[n1 + idx]. return Qobj(data.tocsr(), dims=rho.dims). def _partial_transpose_reference",MatchSource.WIKI,docs/4.7/modules/qutip/partial_transpose.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/partial_transpose.html
https://qutip.org/docs/4.7/modules/qutip/partial_transpose.html:1905,Availability,mask,mask,1905,"ments in `mask` can be boolean or integers `0` or `1`,; where `True`/`1` indicates that the corresponding subsystem; should be tranposed. Parameters; ----------. rho : :class:`qutip.qobj`; A density matrix. mask : *list* / *array*; A mask that selects which subsystems should be transposed. method : str; choice of method, `dense` or `sparse`. The default method; is `dense`. The `sparse` implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns; -------. rho_pr: :class:`qutip.qobj`. A density matrix with the selected subsystems transposed. """""". mask = [int(i) for i in mask]. if method == 'sparse':; return _partial_transpose_sparse(rho, mask); else:; return _partial_transpose_dense(rho, mask). def _partial_transpose_dense(rho, mask):; """"""; Based on Jonas' implementation using numpy.; Very fast for dense problems.; """"""; nsys = len(mask); pt_dims = np.arange(2 * nsys).reshape(2, nsys).T; pt_idx = np.concatenate([[pt_dims[n, mask[n]] for n in range(nsys)],; [pt_dims[n, 1 - mask[n]] for n in range(nsys)]]). data = rho.data.toarray().reshape(; np.array(rho.dims).flatten()).transpose(pt_idx).reshape(rho.shape). return Qobj(data, dims=rho.dims). def _partial_transpose_sparse(rho, mask):; """"""; Implement the partial transpose using the CSR sparse matrix.; """""". data = sp.lil_matrix((rho.shape[0], rho.shape[1]), dtype=complex). for m in range(len(rho.data.indptr) - 1):. n1 = rho.data.indptr[m]; n2 = rho.data.indptr[m + 1]. psi_A = state_index_number(rho.dims[0], m). for idx, n in enumerate(rho.data.indices[n1:n2]):. psi_B = state_index_number(rho.dims[1], n). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, psi_B])); n_pt = state_number_index(; rho.dims[0], np.choose(mask, [psi_B, psi_A])). data[m_pt, n_pt] = rho.data.data[n1 + idx]. return Qobj(data.tocsr(), dims=rho.dims). def _partial_transpose_reference(rho, mask):; """"""; This is a reference implementation that explicitly loops over; all states and performs the transpose. I",MatchSource.WIKI,docs/4.7/modules/qutip/partial_transpose.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/partial_transpose.html
https://qutip.org/docs/4.7/modules/qutip/partial_transpose.html:1954,Availability,mask,mask,1954,"ments in `mask` can be boolean or integers `0` or `1`,; where `True`/`1` indicates that the corresponding subsystem; should be tranposed. Parameters; ----------. rho : :class:`qutip.qobj`; A density matrix. mask : *list* / *array*; A mask that selects which subsystems should be transposed. method : str; choice of method, `dense` or `sparse`. The default method; is `dense`. The `sparse` implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns; -------. rho_pr: :class:`qutip.qobj`. A density matrix with the selected subsystems transposed. """""". mask = [int(i) for i in mask]. if method == 'sparse':; return _partial_transpose_sparse(rho, mask); else:; return _partial_transpose_dense(rho, mask). def _partial_transpose_dense(rho, mask):; """"""; Based on Jonas' implementation using numpy.; Very fast for dense problems.; """"""; nsys = len(mask); pt_dims = np.arange(2 * nsys).reshape(2, nsys).T; pt_idx = np.concatenate([[pt_dims[n, mask[n]] for n in range(nsys)],; [pt_dims[n, 1 - mask[n]] for n in range(nsys)]]). data = rho.data.toarray().reshape(; np.array(rho.dims).flatten()).transpose(pt_idx).reshape(rho.shape). return Qobj(data, dims=rho.dims). def _partial_transpose_sparse(rho, mask):; """"""; Implement the partial transpose using the CSR sparse matrix.; """""". data = sp.lil_matrix((rho.shape[0], rho.shape[1]), dtype=complex). for m in range(len(rho.data.indptr) - 1):. n1 = rho.data.indptr[m]; n2 = rho.data.indptr[m + 1]. psi_A = state_index_number(rho.dims[0], m). for idx, n in enumerate(rho.data.indices[n1:n2]):. psi_B = state_index_number(rho.dims[1], n). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, psi_B])); n_pt = state_number_index(; rho.dims[0], np.choose(mask, [psi_B, psi_A])). data[m_pt, n_pt] = rho.data.data[n1 + idx]. return Qobj(data.tocsr(), dims=rho.dims). def _partial_transpose_reference(rho, mask):; """"""; This is a reference implementation that explicitly loops over; all states and performs the transpose. I",MatchSource.WIKI,docs/4.7/modules/qutip/partial_transpose.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/partial_transpose.html
https://qutip.org/docs/4.7/modules/qutip/partial_transpose.html:2161,Availability,mask,mask,2161,"lects which subsystems should be transposed. method : str; choice of method, `dense` or `sparse`. The default method; is `dense`. The `sparse` implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns; -------. rho_pr: :class:`qutip.qobj`. A density matrix with the selected subsystems transposed. """""". mask = [int(i) for i in mask]. if method == 'sparse':; return _partial_transpose_sparse(rho, mask); else:; return _partial_transpose_dense(rho, mask). def _partial_transpose_dense(rho, mask):; """"""; Based on Jonas' implementation using numpy.; Very fast for dense problems.; """"""; nsys = len(mask); pt_dims = np.arange(2 * nsys).reshape(2, nsys).T; pt_idx = np.concatenate([[pt_dims[n, mask[n]] for n in range(nsys)],; [pt_dims[n, 1 - mask[n]] for n in range(nsys)]]). data = rho.data.toarray().reshape(; np.array(rho.dims).flatten()).transpose(pt_idx).reshape(rho.shape). return Qobj(data, dims=rho.dims). def _partial_transpose_sparse(rho, mask):; """"""; Implement the partial transpose using the CSR sparse matrix.; """""". data = sp.lil_matrix((rho.shape[0], rho.shape[1]), dtype=complex). for m in range(len(rho.data.indptr) - 1):. n1 = rho.data.indptr[m]; n2 = rho.data.indptr[m + 1]. psi_A = state_index_number(rho.dims[0], m). for idx, n in enumerate(rho.data.indices[n1:n2]):. psi_B = state_index_number(rho.dims[1], n). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, psi_B])); n_pt = state_number_index(; rho.dims[0], np.choose(mask, [psi_B, psi_A])). data[m_pt, n_pt] = rho.data.data[n1 + idx]. return Qobj(data.tocsr(), dims=rho.dims). def _partial_transpose_reference(rho, mask):; """"""; This is a reference implementation that explicitly loops over; all states and performs the transpose. It's slow but easy to; understand and useful for testing.; """""". A_pt = np.zeros(rho.shape, dtype=complex). for psi_A in state_number_enumerate(rho.dims[0]):; m = state_number_index(rho.dims[0], psi_A). for psi_B in state_number_enumerate(rho.dims[",MatchSource.WIKI,docs/4.7/modules/qutip/partial_transpose.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/partial_transpose.html
https://qutip.org/docs/4.7/modules/qutip/partial_transpose.html:2595,Availability,mask,mask,2595,"; else:; return _partial_transpose_dense(rho, mask). def _partial_transpose_dense(rho, mask):; """"""; Based on Jonas' implementation using numpy.; Very fast for dense problems.; """"""; nsys = len(mask); pt_dims = np.arange(2 * nsys).reshape(2, nsys).T; pt_idx = np.concatenate([[pt_dims[n, mask[n]] for n in range(nsys)],; [pt_dims[n, 1 - mask[n]] for n in range(nsys)]]). data = rho.data.toarray().reshape(; np.array(rho.dims).flatten()).transpose(pt_idx).reshape(rho.shape). return Qobj(data, dims=rho.dims). def _partial_transpose_sparse(rho, mask):; """"""; Implement the partial transpose using the CSR sparse matrix.; """""". data = sp.lil_matrix((rho.shape[0], rho.shape[1]), dtype=complex). for m in range(len(rho.data.indptr) - 1):. n1 = rho.data.indptr[m]; n2 = rho.data.indptr[m + 1]. psi_A = state_index_number(rho.dims[0], m). for idx, n in enumerate(rho.data.indices[n1:n2]):. psi_B = state_index_number(rho.dims[1], n). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, psi_B])); n_pt = state_number_index(; rho.dims[0], np.choose(mask, [psi_B, psi_A])). data[m_pt, n_pt] = rho.data.data[n1 + idx]. return Qobj(data.tocsr(), dims=rho.dims). def _partial_transpose_reference(rho, mask):; """"""; This is a reference implementation that explicitly loops over; all states and performs the transpose. It's slow but easy to; understand and useful for testing.; """""". A_pt = np.zeros(rho.shape, dtype=complex). for psi_A in state_number_enumerate(rho.dims[0]):; m = state_number_index(rho.dims[0], psi_A). for psi_B in state_number_enumerate(rho.dims[1]):; n = state_number_index(rho.dims[1], psi_B). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, psi_B])); n_pt = state_number_index(; rho.dims[0], np.choose(mask, [psi_B, psi_A])). A_pt[m_pt, n_pt] = rho.data[m, n]. return Qobj(A_pt, dims=rho.dims). © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the",MatchSource.WIKI,docs/4.7/modules/qutip/partial_transpose.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/partial_transpose.html
https://qutip.org/docs/4.7/modules/qutip/partial_transpose.html:2670,Availability,mask,mask,2670,"eturn _partial_transpose_dense(rho, mask). def _partial_transpose_dense(rho, mask):; """"""; Based on Jonas' implementation using numpy.; Very fast for dense problems.; """"""; nsys = len(mask); pt_dims = np.arange(2 * nsys).reshape(2, nsys).T; pt_idx = np.concatenate([[pt_dims[n, mask[n]] for n in range(nsys)],; [pt_dims[n, 1 - mask[n]] for n in range(nsys)]]). data = rho.data.toarray().reshape(; np.array(rho.dims).flatten()).transpose(pt_idx).reshape(rho.shape). return Qobj(data, dims=rho.dims). def _partial_transpose_sparse(rho, mask):; """"""; Implement the partial transpose using the CSR sparse matrix.; """""". data = sp.lil_matrix((rho.shape[0], rho.shape[1]), dtype=complex). for m in range(len(rho.data.indptr) - 1):. n1 = rho.data.indptr[m]; n2 = rho.data.indptr[m + 1]. psi_A = state_index_number(rho.dims[0], m). for idx, n in enumerate(rho.data.indices[n1:n2]):. psi_B = state_index_number(rho.dims[1], n). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, psi_B])); n_pt = state_number_index(; rho.dims[0], np.choose(mask, [psi_B, psi_A])). data[m_pt, n_pt] = rho.data.data[n1 + idx]. return Qobj(data.tocsr(), dims=rho.dims). def _partial_transpose_reference(rho, mask):; """"""; This is a reference implementation that explicitly loops over; all states and performs the transpose. It's slow but easy to; understand and useful for testing.; """""". A_pt = np.zeros(rho.shape, dtype=complex). for psi_A in state_number_enumerate(rho.dims[0]):; m = state_number_index(rho.dims[0], psi_A). for psi_B in state_number_enumerate(rho.dims[1]):; n = state_number_index(rho.dims[1], psi_B). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, psi_B])); n_pt = state_number_index(; rho.dims[0], np.choose(mask, [psi_B, psi_A])). A_pt[m_pt, n_pt] = rho.data[m, n]. return Qobj(A_pt, dims=rho.dims). © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/modules/qutip/partial_transpose.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/partial_transpose.html
https://qutip.org/docs/4.7/modules/qutip/partial_transpose.html:2818,Availability,mask,mask,2818,"eturn _partial_transpose_dense(rho, mask). def _partial_transpose_dense(rho, mask):; """"""; Based on Jonas' implementation using numpy.; Very fast for dense problems.; """"""; nsys = len(mask); pt_dims = np.arange(2 * nsys).reshape(2, nsys).T; pt_idx = np.concatenate([[pt_dims[n, mask[n]] for n in range(nsys)],; [pt_dims[n, 1 - mask[n]] for n in range(nsys)]]). data = rho.data.toarray().reshape(; np.array(rho.dims).flatten()).transpose(pt_idx).reshape(rho.shape). return Qobj(data, dims=rho.dims). def _partial_transpose_sparse(rho, mask):; """"""; Implement the partial transpose using the CSR sparse matrix.; """""". data = sp.lil_matrix((rho.shape[0], rho.shape[1]), dtype=complex). for m in range(len(rho.data.indptr) - 1):. n1 = rho.data.indptr[m]; n2 = rho.data.indptr[m + 1]. psi_A = state_index_number(rho.dims[0], m). for idx, n in enumerate(rho.data.indices[n1:n2]):. psi_B = state_index_number(rho.dims[1], n). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, psi_B])); n_pt = state_number_index(; rho.dims[0], np.choose(mask, [psi_B, psi_A])). data[m_pt, n_pt] = rho.data.data[n1 + idx]. return Qobj(data.tocsr(), dims=rho.dims). def _partial_transpose_reference(rho, mask):; """"""; This is a reference implementation that explicitly loops over; all states and performs the transpose. It's slow but easy to; understand and useful for testing.; """""". A_pt = np.zeros(rho.shape, dtype=complex). for psi_A in state_number_enumerate(rho.dims[0]):; m = state_number_index(rho.dims[0], psi_A). for psi_B in state_number_enumerate(rho.dims[1]):; n = state_number_index(rho.dims[1], psi_B). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, psi_B])); n_pt = state_number_index(; rho.dims[0], np.choose(mask, [psi_B, psi_A])). A_pt[m_pt, n_pt] = rho.data[m, n]. return Qobj(A_pt, dims=rho.dims). © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/modules/qutip/partial_transpose.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/partial_transpose.html
https://qutip.org/docs/4.7/modules/qutip/partial_transpose.html:3281,Availability,mask,mask,3281,"eturn _partial_transpose_dense(rho, mask). def _partial_transpose_dense(rho, mask):; """"""; Based on Jonas' implementation using numpy.; Very fast for dense problems.; """"""; nsys = len(mask); pt_dims = np.arange(2 * nsys).reshape(2, nsys).T; pt_idx = np.concatenate([[pt_dims[n, mask[n]] for n in range(nsys)],; [pt_dims[n, 1 - mask[n]] for n in range(nsys)]]). data = rho.data.toarray().reshape(; np.array(rho.dims).flatten()).transpose(pt_idx).reshape(rho.shape). return Qobj(data, dims=rho.dims). def _partial_transpose_sparse(rho, mask):; """"""; Implement the partial transpose using the CSR sparse matrix.; """""". data = sp.lil_matrix((rho.shape[0], rho.shape[1]), dtype=complex). for m in range(len(rho.data.indptr) - 1):. n1 = rho.data.indptr[m]; n2 = rho.data.indptr[m + 1]. psi_A = state_index_number(rho.dims[0], m). for idx, n in enumerate(rho.data.indices[n1:n2]):. psi_B = state_index_number(rho.dims[1], n). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, psi_B])); n_pt = state_number_index(; rho.dims[0], np.choose(mask, [psi_B, psi_A])). data[m_pt, n_pt] = rho.data.data[n1 + idx]. return Qobj(data.tocsr(), dims=rho.dims). def _partial_transpose_reference(rho, mask):; """"""; This is a reference implementation that explicitly loops over; all states and performs the transpose. It's slow but easy to; understand and useful for testing.; """""". A_pt = np.zeros(rho.shape, dtype=complex). for psi_A in state_number_enumerate(rho.dims[0]):; m = state_number_index(rho.dims[0], psi_A). for psi_B in state_number_enumerate(rho.dims[1]):; n = state_number_index(rho.dims[1], psi_B). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, psi_B])); n_pt = state_number_index(; rho.dims[0], np.choose(mask, [psi_B, psi_A])). A_pt[m_pt, n_pt] = rho.data[m, n]. return Qobj(A_pt, dims=rho.dims). © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/modules/qutip/partial_transpose.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/partial_transpose.html
https://qutip.org/docs/4.7/modules/qutip/partial_transpose.html:3356,Availability,mask,mask,3356,"eturn _partial_transpose_dense(rho, mask). def _partial_transpose_dense(rho, mask):; """"""; Based on Jonas' implementation using numpy.; Very fast for dense problems.; """"""; nsys = len(mask); pt_dims = np.arange(2 * nsys).reshape(2, nsys).T; pt_idx = np.concatenate([[pt_dims[n, mask[n]] for n in range(nsys)],; [pt_dims[n, 1 - mask[n]] for n in range(nsys)]]). data = rho.data.toarray().reshape(; np.array(rho.dims).flatten()).transpose(pt_idx).reshape(rho.shape). return Qobj(data, dims=rho.dims). def _partial_transpose_sparse(rho, mask):; """"""; Implement the partial transpose using the CSR sparse matrix.; """""". data = sp.lil_matrix((rho.shape[0], rho.shape[1]), dtype=complex). for m in range(len(rho.data.indptr) - 1):. n1 = rho.data.indptr[m]; n2 = rho.data.indptr[m + 1]. psi_A = state_index_number(rho.dims[0], m). for idx, n in enumerate(rho.data.indices[n1:n2]):. psi_B = state_index_number(rho.dims[1], n). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, psi_B])); n_pt = state_number_index(; rho.dims[0], np.choose(mask, [psi_B, psi_A])). data[m_pt, n_pt] = rho.data.data[n1 + idx]. return Qobj(data.tocsr(), dims=rho.dims). def _partial_transpose_reference(rho, mask):; """"""; This is a reference implementation that explicitly loops over; all states and performs the transpose. It's slow but easy to; understand and useful for testing.; """""". A_pt = np.zeros(rho.shape, dtype=complex). for psi_A in state_number_enumerate(rho.dims[0]):; m = state_number_index(rho.dims[0], psi_A). for psi_B in state_number_enumerate(rho.dims[1]):; n = state_number_index(rho.dims[1], psi_B). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, psi_B])); n_pt = state_number_index(; rho.dims[0], np.choose(mask, [psi_B, psi_A])). A_pt[m_pt, n_pt] = rho.data[m, n]. return Qobj(A_pt, dims=rho.dims). © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/modules/qutip/partial_transpose.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/partial_transpose.html
https://qutip.org/docs/4.7/modules/qutip/partial_transpose.html:3528,Deployability,update,updated,3528,"eturn _partial_transpose_dense(rho, mask). def _partial_transpose_dense(rho, mask):; """"""; Based on Jonas' implementation using numpy.; Very fast for dense problems.; """"""; nsys = len(mask); pt_dims = np.arange(2 * nsys).reshape(2, nsys).T; pt_idx = np.concatenate([[pt_dims[n, mask[n]] for n in range(nsys)],; [pt_dims[n, 1 - mask[n]] for n in range(nsys)]]). data = rho.data.toarray().reshape(; np.array(rho.dims).flatten()).transpose(pt_idx).reshape(rho.shape). return Qobj(data, dims=rho.dims). def _partial_transpose_sparse(rho, mask):; """"""; Implement the partial transpose using the CSR sparse matrix.; """""". data = sp.lil_matrix((rho.shape[0], rho.shape[1]), dtype=complex). for m in range(len(rho.data.indptr) - 1):. n1 = rho.data.indptr[m]; n2 = rho.data.indptr[m + 1]. psi_A = state_index_number(rho.dims[0], m). for idx, n in enumerate(rho.data.indices[n1:n2]):. psi_B = state_index_number(rho.dims[1], n). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, psi_B])); n_pt = state_number_index(; rho.dims[0], np.choose(mask, [psi_B, psi_A])). data[m_pt, n_pt] = rho.data.data[n1 + idx]. return Qobj(data.tocsr(), dims=rho.dims). def _partial_transpose_reference(rho, mask):; """"""; This is a reference implementation that explicitly loops over; all states and performs the transpose. It's slow but easy to; understand and useful for testing.; """""". A_pt = np.zeros(rho.shape, dtype=complex). for psi_A in state_number_enumerate(rho.dims[0]):; m = state_number_index(rho.dims[0], psi_A). for psi_B in state_number_enumerate(rho.dims[1]):; n = state_number_index(rho.dims[1], psi_B). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, psi_B])); n_pt = state_number_index(; rho.dims[0], np.choose(mask, [psi_B, psi_A])). A_pt[m_pt, n_pt] = rho.data[m, n]. return Qobj(A_pt, dims=rho.dims). © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/modules/qutip/partial_transpose.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/partial_transpose.html
https://qutip.org/docs/4.7/modules/qutip/partial_transpose.html:2909,Performance,perform,performs,2909,"eturn _partial_transpose_dense(rho, mask). def _partial_transpose_dense(rho, mask):; """"""; Based on Jonas' implementation using numpy.; Very fast for dense problems.; """"""; nsys = len(mask); pt_dims = np.arange(2 * nsys).reshape(2, nsys).T; pt_idx = np.concatenate([[pt_dims[n, mask[n]] for n in range(nsys)],; [pt_dims[n, 1 - mask[n]] for n in range(nsys)]]). data = rho.data.toarray().reshape(; np.array(rho.dims).flatten()).transpose(pt_idx).reshape(rho.shape). return Qobj(data, dims=rho.dims). def _partial_transpose_sparse(rho, mask):; """"""; Implement the partial transpose using the CSR sparse matrix.; """""". data = sp.lil_matrix((rho.shape[0], rho.shape[1]), dtype=complex). for m in range(len(rho.data.indptr) - 1):. n1 = rho.data.indptr[m]; n2 = rho.data.indptr[m + 1]. psi_A = state_index_number(rho.dims[0], m). for idx, n in enumerate(rho.data.indices[n1:n2]):. psi_B = state_index_number(rho.dims[1], n). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, psi_B])); n_pt = state_number_index(; rho.dims[0], np.choose(mask, [psi_B, psi_A])). data[m_pt, n_pt] = rho.data.data[n1 + idx]. return Qobj(data.tocsr(), dims=rho.dims). def _partial_transpose_reference(rho, mask):; """"""; This is a reference implementation that explicitly loops over; all states and performs the transpose. It's slow but easy to; understand and useful for testing.; """""". A_pt = np.zeros(rho.shape, dtype=complex). for psi_A in state_number_enumerate(rho.dims[0]):; m = state_number_index(rho.dims[0], psi_A). for psi_B in state_number_enumerate(rho.dims[1]):; n = state_number_index(rho.dims[1], psi_B). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, psi_B])); n_pt = state_number_index(; rho.dims[0], np.choose(mask, [psi_B, psi_A])). A_pt[m_pt, n_pt] = rho.data[m, n]. return Qobj(A_pt, dims=rho.dims). © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/modules/qutip/partial_transpose.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/partial_transpose.html
https://qutip.org/docs/4.7/modules/qutip/partial_transpose.html:2982,Testability,test,testing,2982,"eturn _partial_transpose_dense(rho, mask). def _partial_transpose_dense(rho, mask):; """"""; Based on Jonas' implementation using numpy.; Very fast for dense problems.; """"""; nsys = len(mask); pt_dims = np.arange(2 * nsys).reshape(2, nsys).T; pt_idx = np.concatenate([[pt_dims[n, mask[n]] for n in range(nsys)],; [pt_dims[n, 1 - mask[n]] for n in range(nsys)]]). data = rho.data.toarray().reshape(; np.array(rho.dims).flatten()).transpose(pt_idx).reshape(rho.shape). return Qobj(data, dims=rho.dims). def _partial_transpose_sparse(rho, mask):; """"""; Implement the partial transpose using the CSR sparse matrix.; """""". data = sp.lil_matrix((rho.shape[0], rho.shape[1]), dtype=complex). for m in range(len(rho.data.indptr) - 1):. n1 = rho.data.indptr[m]; n2 = rho.data.indptr[m + 1]. psi_A = state_index_number(rho.dims[0], m). for idx, n in enumerate(rho.data.indices[n1:n2]):. psi_B = state_index_number(rho.dims[1], n). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, psi_B])); n_pt = state_number_index(; rho.dims[0], np.choose(mask, [psi_B, psi_A])). data[m_pt, n_pt] = rho.data.data[n1 + idx]. return Qobj(data.tocsr(), dims=rho.dims). def _partial_transpose_reference(rho, mask):; """"""; This is a reference implementation that explicitly loops over; all states and performs the transpose. It's slow but easy to; understand and useful for testing.; """""". A_pt = np.zeros(rho.shape, dtype=complex). for psi_A in state_number_enumerate(rho.dims[0]):; m = state_number_index(rho.dims[0], psi_A). for psi_B in state_number_enumerate(rho.dims[1]):; n = state_number_index(rho.dims[1], psi_B). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, psi_B])); n_pt = state_number_index(; rho.dims[0], np.choose(mask, [psi_B, psi_A])). A_pt[m_pt, n_pt] = rho.data[m, n]. return Qobj(A_pt, dims=rho.dims). © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/modules/qutip/partial_transpose.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/partial_transpose.html
https://qutip.org/docs/4.7/modules/qutip/piqs.html:888,Deployability,integrat,integrate,888,". qutip.piqs — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.piqs. Source code for qutip.piqs; """"""Permutational Invariant Quantum Solver (PIQS). This module calculates the Liouvillian for the dynamics of ensembles of; identical two-level systems (TLS) in the presence of local and collective; processes by exploiting permutational symmetry and using the Dicke basis.; It also allows to characterize nonlinear functions of the density matrix.; """""". # Authors: Nathan Shammah, Shahnawaz Ahmed; # Contact: nathan.shammah@gmail.com, shahnawaz.ahmed95@gmail.com. from math import factorial; from decimal import Decimal. import numpy as np; from scipy.integrate import odeint; from scipy.linalg import eigvalsh; from scipy.special import entr; from scipy.sparse import dok_matrix, block_diag, lil_matrix; from qutip.solver import Options, Result; from qutip import (; Qobj,; spre,; spost,; tensor,; identity,; ket2dm,; ); from qutip import sigmax, sigmay, sigmaz, sigmap, sigmam; from qutip.cy.piqs import Dicke as _Dicke; from qutip.cy.piqs import (; jmm1_dictionary,; _num_dicke_states,; _num_dicke_ladders,; get_blocks,; j_min,; j_vals,; ). __all__ = [; ""num_dicke_states"",; ""num_dicke_ladders"",; ""num_tls"",; ""isdiagonal"",; ""dicke_blocks"",; ""dicke_blocks_full"",; ""dicke_function_trace"",; ""purity_dicke"",; ""entropy_vn_dicke"",; ""Dicke"",; ""state_degeneracy"",; ""m_degeneracy"",; ""energy_degeneracy"",; ""ap"",; ""am"",; ""spin_algebra"",; ""jspin"",; ""collapse_uncoupled"",; ""dicke_basis"",; ""dicke"",; ""excited"",; ""superradiant"",; ""css"",; ""ghz"",; ""ground"",; ""identity_uncoupled"",; ""block_matrix"",; ""tau_column"",; ""Pim"",; ]. def _ensure_int(x):; """"""; Ensure that a floating-point value `x` is exactly an integer, and return it; as an int.; """"""; out = int(x); if out != x:; raise ",MatchSource.WIKI,docs/4.7/modules/qutip/piqs.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/piqs.html
https://qutip.org/docs/4.7/modules/qutip/piqs.html:12145,Deployability,integrat,integrate,12145,"tip.Qobj`.; """"""; cythonized_dicke = _Dicke(; int(self.N),; float(self.emission),; float(self.dephasing),; float(self.pumping),; float(self.collective_emission),; float(self.collective_dephasing),; float(self.collective_pumping),; ); return cythonized_dicke.lindbladian(). [docs] def liouvillian(self):; """"""Build the total Liouvillian using the Dicke basis. Returns; -------; liouv : :class:`qutip.Qobj`; The Liouvillian matrix for the system.; """"""; lindblad = self.lindbladian(); if self.hamiltonian is None:; liouv = lindblad. else:; hamiltonian = self.hamiltonian; hamiltonian_superoperator = -1j * spre(hamiltonian) + 1j * spost(; hamiltonian; ); liouv = lindblad + hamiltonian_superoperator; return liouv. [docs] def pisolve(self, initial_state, tlist, options=None):; """"""; Solve for diagonal Hamiltonians and initial states faster. Parameters; ==========; initial_state : :class:`qutip.Qobj`; An initial state specified as a density matrix of; `qutip.Qbj` type. tlist: ndarray; A 1D numpy array of list of timesteps to integrate. options : :class:`qutip.solver.Options`; The options for the solver. Returns; =======; result: list; A dictionary of the type `qutip.solver.Result` which holds the; results of the evolution.; """"""; if isdiagonal(initial_state) == False:; msg = ""`pisolve` requires a diagonal initial density matrix. ""; msg += ""In general construct the Liouvillian using ""; msg += ""`piqs.liouvillian` and use qutip.mesolve.""; raise ValueError(msg). if self.hamiltonian and isdiagonal(self.hamiltonian) == False:; msg = ""`pisolve` should only be used for diagonal Hamiltonians. ""; msg += ""Construct the Liouvillian using `piqs.liouvillian` and""; msg += "" use `qutip.mesolve`.""; raise ValueError(msg). if initial_state.full().shape != self.dshape:; msg = ""Initial density matrix should be diagonal.""; raise ValueError(msg). pim = Pim(; self.N,; self.emission,; self.dephasing,; self.pumping,; self.collective_emission,; self.collective_pumping,; self.collective_dephasing,; ); result = ",MatchSource.WIKI,docs/4.7/modules/qutip/piqs.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/piqs.html
https://qutip.org/docs/4.7/modules/qutip/piqs.html:45263,Deployability,update,updated,45263," (j+1, m+1, m+1).; """"""; yL = self.emission; N = float(self.N); num = (j + m - 1) * (j + m) * (j + 1 + N / 2); den = 2 * j * (2 * j + 1); t3 = yL * (num / den); return t3. [docs] def tau4(self, j, m):; """"""; Calculate coefficient matrix element relative to (j-1, m+1, m+1).; """"""; yL = self.emission; N = float(self.N); num = (j - m + 1) * (j - m + 2) * (N / 2 - j); den = 2 * (j + 1) * (2 * j + 1); t4 = yL * (num / den); return t4. [docs] def tau5(self, j, m):; """"""; Calculate coefficient matrix element relative to (j+1, m, m).; """"""; yD = self.dephasing; N = float(self.N); num = (j - m) * (j + m) * (j + 1 + N / 2); den = 2 * j * (2 * j + 1); t5 = yD * (num / den); return t5. [docs] def tau6(self, j, m):; """"""; Calculate coefficient matrix element relative to (j-1, m, m).; """"""; yD = self.dephasing; N = float(self.N); num = (j - m + 1) * (j + m + 1) * (N / 2 - j); den = 2 * (j + 1) * (2 * j + 1); t6 = yD * (num / den); return t6. [docs] def tau7(self, j, m):; """"""; Calculate coefficient matrix element relative to (j+1, m-1, m-1).; """"""; yP = self.pumping; N = float(self.N); num = (j - m - 1) * (j - m) * (j + 1 + N / 2); den = 2 * j * (2 * j + 1); t7 = yP * (float(num) / den); return t7. [docs] def tau8(self, j, m):; """"""; Calculate coefficient matrix element relative to (j, m-1, m-1).; """"""; yP = self.pumping; yCP = self.collective_pumping; N = float(self.N). num = (1 + N / 2) * (j - m) * (j + m + 1); den = 2 * j * (j + 1); pump = yP * (float(num) / den); collective_pump = yCP * (j - m) * (j + m + 1); t8 = pump + collective_pump; return t8. [docs] def tau9(self, j, m):; """"""; Calculate coefficient matrix element relative to (j-1, m-1, m-1).; """"""; yP = self.pumping; N = float(self.N); num = (j + m + 1) * (j + m + 2) * (N / 2 - j); den = 2 * (j + 1) * (2 * j + 1); t9 = yP * (float(num) / den); return t9. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/modules/qutip/piqs.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/piqs.html
https://qutip.org/docs/4.7/modules/qutip/piqs.html:14436,Energy Efficiency,energy,energy,14436,"""""; ce = self.collective_emission; cd = self.collective_dephasing; cp = self.collective_pumping; c_ops_list = collapse_uncoupled(; N=self.N,; emission=self.emission,; dephasing=self.dephasing,; pumping=self.pumping,; collective_emission=ce,; collective_dephasing=cd,; collective_pumping=cp,; ); return c_ops_list. [docs] def coefficient_matrix(self):; """"""Build coefficient matrix for ODE for a diagonal problem. Returns; -------; M: ndarray; The matrix M of the coefficients for the ODE dp/dt = Mp.; p is the vector of the diagonal matrix elements; of the density matrix rho in the Dicke basis.; """"""; diagonal_system = Pim(; N=self.N,; emission=self.emission,; dephasing=self.dephasing,; pumping=self.pumping,; collective_emission=self.collective_emission,; collective_dephasing=self.collective_dephasing,; collective_pumping=self.collective_pumping,; ); coef_matrix = diagonal_system.coefficient_matrix(); return coef_matrix. # Utility functions for properties of the Dicke space; [docs]def energy_degeneracy(N, m):; """"""Calculate the number of Dicke states with same energy. The use of the `Decimals` class allows to explore N > 1000,; unlike the built-in function `scipy.special.binom`. Parameters; ----------; N: int; The number of two-level systems. m: float; Total spin z-axis projection eigenvalue.; This is proportional to the total energy. Returns; -------; degeneracy: int; The energy degeneracy; """"""; numerator = Decimal(factorial(N)); d1 = Decimal(factorial(_ensure_int(N / 2 + m))); d2 = Decimal(factorial(_ensure_int(N / 2 - m))); degeneracy = numerator / (d1 * d2); return int(degeneracy). [docs]def state_degeneracy(N, j):; r""""""Calculate the degeneracy of the Dicke state. Each state :math:`\lvert j, m\rangle` includes D(N,j) irreducible; representations :math:`\lvert j, m, \alpha\rangle`. Uses Decimals to calculate higher numerator and denominators numbers. Parameters; ----------; N: int; The number of two-level systems. j: float; Total spin eigenvalue (cooperativity). Returns; -",MatchSource.WIKI,docs/4.7/modules/qutip/piqs.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/piqs.html
https://qutip.org/docs/4.7/modules/qutip/piqs.html:14708,Energy Efficiency,energy,energy,14708,"coefficient_matrix(self):; """"""Build coefficient matrix for ODE for a diagonal problem. Returns; -------; M: ndarray; The matrix M of the coefficients for the ODE dp/dt = Mp.; p is the vector of the diagonal matrix elements; of the density matrix rho in the Dicke basis.; """"""; diagonal_system = Pim(; N=self.N,; emission=self.emission,; dephasing=self.dephasing,; pumping=self.pumping,; collective_emission=self.collective_emission,; collective_dephasing=self.collective_dephasing,; collective_pumping=self.collective_pumping,; ); coef_matrix = diagonal_system.coefficient_matrix(); return coef_matrix. # Utility functions for properties of the Dicke space; [docs]def energy_degeneracy(N, m):; """"""Calculate the number of Dicke states with same energy. The use of the `Decimals` class allows to explore N > 1000,; unlike the built-in function `scipy.special.binom`. Parameters; ----------; N: int; The number of two-level systems. m: float; Total spin z-axis projection eigenvalue.; This is proportional to the total energy. Returns; -------; degeneracy: int; The energy degeneracy; """"""; numerator = Decimal(factorial(N)); d1 = Decimal(factorial(_ensure_int(N / 2 + m))); d2 = Decimal(factorial(_ensure_int(N / 2 - m))); degeneracy = numerator / (d1 * d2); return int(degeneracy). [docs]def state_degeneracy(N, j):; r""""""Calculate the degeneracy of the Dicke state. Each state :math:`\lvert j, m\rangle` includes D(N,j) irreducible; representations :math:`\lvert j, m, \alpha\rangle`. Uses Decimals to calculate higher numerator and denominators numbers. Parameters; ----------; N: int; The number of two-level systems. j: float; Total spin eigenvalue (cooperativity). Returns; -------; degeneracy: int; The state degeneracy.; """"""; if j < 0:; raise ValueError(""j value should be >= 0""); numerator = Decimal(factorial(N)) * Decimal(2 * j + 1); denominator_1 = Decimal(factorial(_ensure_int(N / 2 + j + 1))); denominator_2 = Decimal(factorial(_ensure_int(N / 2 - j))); degeneracy = numerator / (denominator",MatchSource.WIKI,docs/4.7/modules/qutip/piqs.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/piqs.html
https://qutip.org/docs/4.7/modules/qutip/piqs.html:14755,Energy Efficiency,energy,energy,14755,"for the ODE dp/dt = Mp.; p is the vector of the diagonal matrix elements; of the density matrix rho in the Dicke basis.; """"""; diagonal_system = Pim(; N=self.N,; emission=self.emission,; dephasing=self.dephasing,; pumping=self.pumping,; collective_emission=self.collective_emission,; collective_dephasing=self.collective_dephasing,; collective_pumping=self.collective_pumping,; ); coef_matrix = diagonal_system.coefficient_matrix(); return coef_matrix. # Utility functions for properties of the Dicke space; [docs]def energy_degeneracy(N, m):; """"""Calculate the number of Dicke states with same energy. The use of the `Decimals` class allows to explore N > 1000,; unlike the built-in function `scipy.special.binom`. Parameters; ----------; N: int; The number of two-level systems. m: float; Total spin z-axis projection eigenvalue.; This is proportional to the total energy. Returns; -------; degeneracy: int; The energy degeneracy; """"""; numerator = Decimal(factorial(N)); d1 = Decimal(factorial(_ensure_int(N / 2 + m))); d2 = Decimal(factorial(_ensure_int(N / 2 - m))); degeneracy = numerator / (d1 * d2); return int(degeneracy). [docs]def state_degeneracy(N, j):; r""""""Calculate the degeneracy of the Dicke state. Each state :math:`\lvert j, m\rangle` includes D(N,j) irreducible; representations :math:`\lvert j, m, \alpha\rangle`. Uses Decimals to calculate higher numerator and denominators numbers. Parameters; ----------; N: int; The number of two-level systems. j: float; Total spin eigenvalue (cooperativity). Returns; -------; degeneracy: int; The state degeneracy.; """"""; if j < 0:; raise ValueError(""j value should be >= 0""); numerator = Decimal(factorial(N)) * Decimal(2 * j + 1); denominator_1 = Decimal(factorial(_ensure_int(N / 2 + j + 1))); denominator_2 = Decimal(factorial(_ensure_int(N / 2 - j))); degeneracy = numerator / (denominator_1 * denominator_2); degeneracy = int(np.round(float(degeneracy))); return degeneracy. [docs]def m_degeneracy(N, m):; r""""""Calculate the number of Dic",MatchSource.WIKI,docs/4.7/modules/qutip/piqs.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/piqs.html
https://qutip.org/docs/4.7/modules/qutip/piqs.html:15891,Energy Efficiency,energy,energy,15891,"nsure_int(N / 2 + m))); d2 = Decimal(factorial(_ensure_int(N / 2 - m))); degeneracy = numerator / (d1 * d2); return int(degeneracy). [docs]def state_degeneracy(N, j):; r""""""Calculate the degeneracy of the Dicke state. Each state :math:`\lvert j, m\rangle` includes D(N,j) irreducible; representations :math:`\lvert j, m, \alpha\rangle`. Uses Decimals to calculate higher numerator and denominators numbers. Parameters; ----------; N: int; The number of two-level systems. j: float; Total spin eigenvalue (cooperativity). Returns; -------; degeneracy: int; The state degeneracy.; """"""; if j < 0:; raise ValueError(""j value should be >= 0""); numerator = Decimal(factorial(N)) * Decimal(2 * j + 1); denominator_1 = Decimal(factorial(_ensure_int(N / 2 + j + 1))); denominator_2 = Decimal(factorial(_ensure_int(N / 2 - j))); degeneracy = numerator / (denominator_1 * denominator_2); degeneracy = int(np.round(float(degeneracy))); return degeneracy. [docs]def m_degeneracy(N, m):; r""""""Calculate the number of Dicke states :math:`\lvert j, m\rangle` with; same energy. Parameters; ----------; N: int; The number of two-level systems. m: float; Total spin z-axis projection eigenvalue (proportional to the total; energy). Returns; -------; degeneracy: int; The m-degeneracy.; """"""; jvals = j_vals(N); maxj = np.max(jvals); if m < -maxj:; e = ""m value is incorrect for this N.""; e += "" Minimum m value can be {}"".format(-maxj); raise ValueError(e); degeneracy = N / 2 + 1 - abs(m); return int(degeneracy). [docs]def ap(j, m):; r""""""; Calculate the coefficient ``ap`` by applying :math:`J_+\lvert j,m\rangle`. The action of ap is given by:; :math:`J_{+}\lvert j, m\rangle = A_{+}(j, m) \lvert j, m+1\rangle`. Parameters; ----------; j, m: float; The value for j and m in the dicke basis :math:`\lvert j, m\rangle`. Returns; -------; a_plus: float; The value of :math:`a_{+}`.; """"""; a_plus = np.sqrt((j - m) * (j + m + 1)); return a_plus. [docs]def am(j, m):; r""""""Calculate the operator ``am`` used later. The actio",MatchSource.WIKI,docs/4.7/modules/qutip/piqs.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/piqs.html
https://qutip.org/docs/4.7/modules/qutip/piqs.html:16042,Energy Efficiency,energy,energy,16042," r""""""Calculate the degeneracy of the Dicke state. Each state :math:`\lvert j, m\rangle` includes D(N,j) irreducible; representations :math:`\lvert j, m, \alpha\rangle`. Uses Decimals to calculate higher numerator and denominators numbers. Parameters; ----------; N: int; The number of two-level systems. j: float; Total spin eigenvalue (cooperativity). Returns; -------; degeneracy: int; The state degeneracy.; """"""; if j < 0:; raise ValueError(""j value should be >= 0""); numerator = Decimal(factorial(N)) * Decimal(2 * j + 1); denominator_1 = Decimal(factorial(_ensure_int(N / 2 + j + 1))); denominator_2 = Decimal(factorial(_ensure_int(N / 2 - j))); degeneracy = numerator / (denominator_1 * denominator_2); degeneracy = int(np.round(float(degeneracy))); return degeneracy. [docs]def m_degeneracy(N, m):; r""""""Calculate the number of Dicke states :math:`\lvert j, m\rangle` with; same energy. Parameters; ----------; N: int; The number of two-level systems. m: float; Total spin z-axis projection eigenvalue (proportional to the total; energy). Returns; -------; degeneracy: int; The m-degeneracy.; """"""; jvals = j_vals(N); maxj = np.max(jvals); if m < -maxj:; e = ""m value is incorrect for this N.""; e += "" Minimum m value can be {}"".format(-maxj); raise ValueError(e); degeneracy = N / 2 + 1 - abs(m); return int(degeneracy). [docs]def ap(j, m):; r""""""; Calculate the coefficient ``ap`` by applying :math:`J_+\lvert j,m\rangle`. The action of ap is given by:; :math:`J_{+}\lvert j, m\rangle = A_{+}(j, m) \lvert j, m+1\rangle`. Parameters; ----------; j, m: float; The value for j and m in the dicke basis :math:`\lvert j, m\rangle`. Returns; -------; a_plus: float; The value of :math:`a_{+}`.; """"""; a_plus = np.sqrt((j - m) * (j + m + 1)); return a_plus. [docs]def am(j, m):; r""""""Calculate the operator ``am`` used later. The action of ``ap`` is given by:; :math:`J_{-}\lvert j,m\rangle = A_{-}(jm)\lvert j,m-1\rangle`. Parameters; ----------; j: float; The value for j. m: float; The value for m. R",MatchSource.WIKI,docs/4.7/modules/qutip/piqs.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/piqs.html
https://qutip.org/docs/4.7/modules/qutip/piqs.html:23172,Energy Efficiency,reduce,reduce,23172,"2) Pauli matrices. Notes; -----; The collapse operator list can be given to `qutip.mesolve`.; Notice that the operators are placed in a Hilbert space of; dimension :math:`2^N`. Thus the method is suitable only for; small N (of the order of 10). Parameters; ----------; N: int; The number of two-level systems. emission: float; Incoherent emission coefficient (also nonradiative emission).; default: 0.0. dephasing: float; Local dephasing coefficient.; default: 0.0. pumping: float; Incoherent pumping coefficient.; default: 0.0. collective_emission: float; Collective (superradiant) emmission coefficient.; default: 0.0. collective_pumping: float; Collective pumping coefficient.; default: 0.0. collective_dephasing: float; Collective dephasing coefficient.; default: 0.0. Returns; -------; c_ops: list; The list of collapse operators as `qutip.Qobj` for the system.; """"""; N = int(N). if N > 10:; msg = ""N > 10. dim(H) = 2^N. ""; msg += ""Better use `piqs.lindbladian` to reduce Hilbert space ""; msg += ""dimension and exploit permutational symmetry.""; raise Warning(msg). [sx, sy, sz] = spin_algebra(N); sp, sm = spin_algebra(N, ""+""), spin_algebra(N, ""-""); [jx, jy, jz] = jspin(N, basis=""uncoupled""); jp, jm = (; jspin(N, ""+"", basis=""uncoupled""),; jspin(N, ""-"", basis=""uncoupled""),; ). c_ops = []. if emission != 0:; for i in range(0, N):; c_ops.append(np.sqrt(emission) * sm[i]). if dephasing != 0:; for i in range(0, N):; c_ops.append(np.sqrt(dephasing) * sz[i]). if pumping != 0:; for i in range(0, N):; c_ops.append(np.sqrt(pumping) * sp[i]). if collective_emission != 0:; c_ops.append(np.sqrt(collective_emission) * jm). if collective_dephasing != 0:; c_ops.append(np.sqrt(collective_dephasing) * jz). if collective_pumping != 0:; c_ops.append(np.sqrt(collective_pumping) * jp). return c_ops. # State definitions in the Dicke basis with an option for basis transformation; [docs]def dicke_basis(N, jmm1=None):; r""""""; Initialize the density matrix of a Dicke state for several (j, m, m1). This funct",MatchSource.WIKI,docs/4.7/modules/qutip/piqs.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/piqs.html
https://qutip.org/docs/4.7/modules/qutip/piqs.html:888,Integrability,integrat,integrate,888,". qutip.piqs — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.piqs. Source code for qutip.piqs; """"""Permutational Invariant Quantum Solver (PIQS). This module calculates the Liouvillian for the dynamics of ensembles of; identical two-level systems (TLS) in the presence of local and collective; processes by exploiting permutational symmetry and using the Dicke basis.; It also allows to characterize nonlinear functions of the density matrix.; """""". # Authors: Nathan Shammah, Shahnawaz Ahmed; # Contact: nathan.shammah@gmail.com, shahnawaz.ahmed95@gmail.com. from math import factorial; from decimal import Decimal. import numpy as np; from scipy.integrate import odeint; from scipy.linalg import eigvalsh; from scipy.special import entr; from scipy.sparse import dok_matrix, block_diag, lil_matrix; from qutip.solver import Options, Result; from qutip import (; Qobj,; spre,; spost,; tensor,; identity,; ket2dm,; ); from qutip import sigmax, sigmay, sigmaz, sigmap, sigmam; from qutip.cy.piqs import Dicke as _Dicke; from qutip.cy.piqs import (; jmm1_dictionary,; _num_dicke_states,; _num_dicke_ladders,; get_blocks,; j_min,; j_vals,; ). __all__ = [; ""num_dicke_states"",; ""num_dicke_ladders"",; ""num_tls"",; ""isdiagonal"",; ""dicke_blocks"",; ""dicke_blocks_full"",; ""dicke_function_trace"",; ""purity_dicke"",; ""entropy_vn_dicke"",; ""Dicke"",; ""state_degeneracy"",; ""m_degeneracy"",; ""energy_degeneracy"",; ""ap"",; ""am"",; ""spin_algebra"",; ""jspin"",; ""collapse_uncoupled"",; ""dicke_basis"",; ""dicke"",; ""excited"",; ""superradiant"",; ""css"",; ""ghz"",; ""ground"",; ""identity_uncoupled"",; ""block_matrix"",; ""tau_column"",; ""Pim"",; ]. def _ensure_int(x):; """"""; Ensure that a floating-point value `x` is exactly an integer, and return it; as an int.; """"""; out = int(x); if out != x:; raise ",MatchSource.WIKI,docs/4.7/modules/qutip/piqs.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/piqs.html
https://qutip.org/docs/4.7/modules/qutip/piqs.html:3249,Integrability,depend,depending,3249,"tems. Returns; -------; nds: int; The number of Dicke states.; """"""; return _num_dicke_states(N). [docs]def num_dicke_ladders(N):; """"""Calculate the total number of ladders in the Dicke space. For a collection of N two-level systems it counts how many different; ""j"" exist or the number of blocks in the block-diagonal matrix. Parameters; ----------; N: int; The number of two-level systems. Returns; -------; Nj: int; The number of Dicke ladders.; """"""; return _num_dicke_ladders(N). [docs]def num_tls(nds):; """"""Calculate the number of two-level systems. Parameters; ----------; nds: int; The number of Dicke states. Returns; -------; N: int; The number of two-level systems.; """"""; if np.sqrt(nds).is_integer():; # N is even; N = 2 * (np.sqrt(nds) - 1); else:; # N is odd; N = 2 * (np.sqrt(nds + 1 / 4) - 1); return int(N). [docs]def isdiagonal(mat):; """"""; Check if the input matrix is diagonal. Parameters; ==========; mat: ndarray/Qobj; A 2D numpy array. Returns; =======; diag: bool; True/False depending on whether the input matrix is diagonal.; """"""; if isinstance(mat, Qobj):; mat = mat.full(). return np.all(mat == np.diag(np.diagonal(mat))). # nonlinear functions of the density matrix; [docs]def dicke_blocks(rho):; """"""Create the list of blocks for block-diagonal density matrix in the Dicke basis. Parameters; ----------; rho : :class:`qutip.Qobj`; A 2D block-diagonal matrix of ones with dimension (nds,nds),; where nds is the number of Dicke states for N two-level; systems. Returns; -------; square_blocks: list of np.array; Give back the blocks list. """"""; shape_dimension = rho.shape[0]; N = num_tls(shape_dimension); ladders = num_dicke_ladders(N); # create a list with the sizes of the blocks, in order; blocks_dimensions = int(N / 2 + 1 - 0.5 * (N % 2)); blocks_list = [; (2 * (i + 1 * (N % 2)) + 1 * ((N + 1) % 2)); for i in range(blocks_dimensions); ]; blocks_list = np.flip(blocks_list, 0); # create a list with each block matrix as element; square_blocks = []; block_position = 0; f",MatchSource.WIKI,docs/4.7/modules/qutip/piqs.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/piqs.html
https://qutip.org/docs/4.7/modules/qutip/piqs.html:12145,Integrability,integrat,integrate,12145,"tip.Qobj`.; """"""; cythonized_dicke = _Dicke(; int(self.N),; float(self.emission),; float(self.dephasing),; float(self.pumping),; float(self.collective_emission),; float(self.collective_dephasing),; float(self.collective_pumping),; ); return cythonized_dicke.lindbladian(). [docs] def liouvillian(self):; """"""Build the total Liouvillian using the Dicke basis. Returns; -------; liouv : :class:`qutip.Qobj`; The Liouvillian matrix for the system.; """"""; lindblad = self.lindbladian(); if self.hamiltonian is None:; liouv = lindblad. else:; hamiltonian = self.hamiltonian; hamiltonian_superoperator = -1j * spre(hamiltonian) + 1j * spost(; hamiltonian; ); liouv = lindblad + hamiltonian_superoperator; return liouv. [docs] def pisolve(self, initial_state, tlist, options=None):; """"""; Solve for diagonal Hamiltonians and initial states faster. Parameters; ==========; initial_state : :class:`qutip.Qobj`; An initial state specified as a density matrix of; `qutip.Qbj` type. tlist: ndarray; A 1D numpy array of list of timesteps to integrate. options : :class:`qutip.solver.Options`; The options for the solver. Returns; =======; result: list; A dictionary of the type `qutip.solver.Result` which holds the; results of the evolution.; """"""; if isdiagonal(initial_state) == False:; msg = ""`pisolve` requires a diagonal initial density matrix. ""; msg += ""In general construct the Liouvillian using ""; msg += ""`piqs.liouvillian` and use qutip.mesolve.""; raise ValueError(msg). if self.hamiltonian and isdiagonal(self.hamiltonian) == False:; msg = ""`pisolve` should only be used for diagonal Hamiltonians. ""; msg += ""Construct the Liouvillian using `piqs.liouvillian` and""; msg += "" use `qutip.mesolve`.""; raise ValueError(msg). if initial_state.full().shape != self.dshape:; msg = ""Initial density matrix should be diagonal.""; raise ValueError(msg). pim = Pim(; self.N,; self.emission,; self.dephasing,; self.pumping,; self.collective_emission,; self.collective_pumping,; self.collective_dephasing,; ); result = ",MatchSource.WIKI,docs/4.7/modules/qutip/piqs.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/piqs.html
https://qutip.org/docs/4.7/modules/qutip/piqs.html:36618,Modifiability,evolve,evolves,36618,"ariant matrix; # ============================================================================; [docs]def tau_column(tau, k, j):; """"""; Determine the column index for the non-zero elements of the matrix for a; particular row `k` and the value of `j` from the Dicke space. Parameters; ----------; tau: str; The tau function to check for this `k` and `j`. k: int; The row of the matrix M for which the non zero elements have; to be calculated. j: float; The value of `j` for this row.; """"""; # In the notes, we indexed from k = 1, here we do it from k = 0; k = k + 1; mapping = {; ""tau3"": k - (2 * j + 3),; ""tau2"": k - 1,; ""tau4"": k + (2 * j - 1),; ""tau5"": k - (2 * j + 2),; ""tau1"": k,; ""tau6"": k + (2 * j),; ""tau7"": k - (2 * j + 1),; ""tau8"": k + 1,; ""tau9"": k + (2 * j + 1),; }; # we need to decrement k again as indexing is from 0; return int(mapping[tau] - 1). [docs]class Pim(object):; """"""; The Permutation Invariant Matrix class. Initialize the class with the parameters for generating a Permutation; Invariant matrix which evolves a given diagonal initial state `p` as:. dp/dt = Mp. Parameters; ----------; N: int; The number of two-level systems. emission: float; Incoherent emission coefficient (also nonradiative emission).; default: 0.0. dephasing: float; Local dephasing coefficient.; default: 0.0. pumping: float; Incoherent pumping coefficient.; default: 0.0. collective_emission: float; Collective (superradiant) emmission coefficient.; default: 0.0. collective_pumping: float; Collective pumping coefficient.; default: 0.0. collective_dephasing: float; Collective dephasing coefficient.; default: 0.0. Attributes; ----------; N: int; The number of two-level systems. emission: float; Incoherent emission coefficient (also nonradiative emission).; default: 0.0. dephasing: float; Local dephasing coefficient.; default: 0.0. pumping: float; Incoherent pumping coefficient.; default: 0.0. collective_emission: float; Collective (superradiant) emmission coefficient.; default: 0.0. collective_d",MatchSource.WIKI,docs/4.7/modules/qutip/piqs.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/piqs.html
https://qutip.org/docs/4.7/modules/qutip/piqs.html:41213,Usability,simpl,simple,41213,"ulate_j_m(self, dicke_row, dicke_col):; """"""; Get the value of j and m for the particular Dicke space element. Parameters; ----------; dicke_row, dicke_col: int; The row and column from the Dicke space matrix. Returns; -------; j, m: float; The j and m values.; """"""; N = self.N; j = N / 2 - dicke_col; m = N / 2 - dicke_row; return (j, m). [docs] def calculate_k(self, dicke_row, dicke_col):; """"""; Get k value from the current row and column element in the Dicke space. Parameters; ----------; dicke_row, dicke_col: int; The row and column from the Dicke space matrix.; Returns; -------; k: int; The row index for the matrix M for given Dicke space; element.; """"""; N = self.N; if dicke_row == 0:; k = dicke_col; else:; k = int(; ((dicke_col) / 2) * (2 * (N + 1) - 2 * (dicke_col - 1)); + (dicke_row - (dicke_col)); ); return k. [docs] def coefficient_matrix(self):; """"""; Generate the matrix M governing the dynamics for diagonal cases. If the initial density matrix and the Hamiltonian is diagonal, the; evolution of the system is given by the simple ODE: dp/dt = Mp.; """"""; N = self.N; nds = num_dicke_states(N); rows = self.N + 1; cols = 0. sparse_M = lil_matrix((nds, nds), dtype=float); if (self.N % 2) == 0:; cols = int(self.N / 2 + 1); else:; cols = int(self.N / 2 + 1 / 2); for (dicke_row, dicke_col) in np.ndindex(rows, cols):; if self.isdicke(dicke_row, dicke_col):; k = int(self.calculate_k(dicke_row, dicke_col)); row = {}; taus = self.tau_valid(dicke_row, dicke_col); for tau in taus:; j, m = self.calculate_j_m(dicke_row, dicke_col); current_col = tau_column(tau, k, j); sparse_M[k, int(current_col)] = taus[tau]; return sparse_M.tocsr(). [docs] def solve(self, rho0, tlist, options=None):; """"""; Solve the ODE for the evolution of diagonal states and Hamiltonians.; """"""; if options is None:; options = Options(); output = Result(); output.solver = ""pisolve""; output.times = tlist; output.states = []; output.states.append(Qobj(rho0)); rhs_generate = lambda y, tt, M: M.dot(y); rho0_flat = ",MatchSource.WIKI,docs/4.7/modules/qutip/piqs.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/piqs.html
https://qutip.org/docs/4.7/modules/qutip/propagator.html:6371,Deployability,update,update,6371,"s_bar, num_cpus=num_cpus). u = np.zeros([N, N, len(tlist)], dtype=complex); for n in range(N):; for k, t in enumerate(tlist):; u[:, n, k] = mat2vec(output[n].states[k].full()).T; else:; rho0 = qeye(H0.dims[0]); output = mesolve(; H, rho0, tlist, args=args, options=options,; _safe_mode=False); return output.states[-1] if len(tlist) == 2 else output.states. else:; # calculate the propagator for the vector representation of the; # density matrix (a superoperator propagator); unitary_mode = 'single'; N = H0.shape[0]; dims = [H0.dims, H0.dims]. u = np.zeros([N * N, N * N, len(tlist)], dtype=complex). if parallel:; output = parallel_map(_parallel_mesolve, range(N * N),; task_args=(; N, H, tlist, c_op_list, args, options),; task_kwargs={""dims"": H0.dims},; progress_bar=progress_bar, num_cpus=num_cpus); for n in range(N * N):; for k, t in enumerate(tlist):; u[:, n, k] = mat2vec(output[n].states[k].full()).T; else:; progress_bar.start(N * N); for n in range(N * N):; progress_bar.update(n); col_idx, row_idx = np.unravel_index(n, (N, N)); rho0 = projection(N, row_idx, col_idx); rho0.dims = H0.dims; output = mesolve(; H, rho0, tlist, c_ops=c_op_list, args=args,; options=options, _safe_mode=False); for k, t in enumerate(tlist):; u[:, n, k] = mat2vec(output.states[k].full()).T; progress_bar.finished(). if len(tlist) == 2:; data = u[-1] if unitary_mode == 'batch' else u[:, :, 1]; return Qobj(data, dims=dims). out = np.empty((len(tlist),), dtype=object); if unitary_mode == 'batch':; out[:] = [Qobj(u[k], dims=dims) for k in range(len(tlist))]; else:; out[:] = [Qobj(u[:, :, k], dims=dims) for k in range(len(tlist))]; return out. def _get_min_and_index(lst):; """"""; Private function for obtaining min and max indicies.; """"""; minval, minidx = lst[0], 0; for i, v in enumerate(lst[1:]):; if v < minval:; minval, minidx = v, i + 1; return minval, minidx. [docs]def propagator_steadystate(U):; """"""Find the steady state for successive applications of the propagator; :math:`U`. Parameters; ---------",MatchSource.WIKI,docs/4.7/modules/qutip/propagator.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/propagator.html
https://qutip.org/docs/4.7/modules/qutip/propagator.html:8384,Deployability,update,updated,8384,"dims; output = mesolve(; H, rho0, tlist, c_ops=c_op_list, args=args,; options=options, _safe_mode=False); for k, t in enumerate(tlist):; u[:, n, k] = mat2vec(output.states[k].full()).T; progress_bar.finished(). if len(tlist) == 2:; data = u[-1] if unitary_mode == 'batch' else u[:, :, 1]; return Qobj(data, dims=dims). out = np.empty((len(tlist),), dtype=object); if unitary_mode == 'batch':; out[:] = [Qobj(u[k], dims=dims) for k in range(len(tlist))]; else:; out[:] = [Qobj(u[:, :, k], dims=dims) for k in range(len(tlist))]; return out. def _get_min_and_index(lst):; """"""; Private function for obtaining min and max indicies.; """"""; minval, minidx = lst[0], 0; for i, v in enumerate(lst[1:]):; if v < minval:; minval, minidx = v, i + 1; return minval, minidx. [docs]def propagator_steadystate(U):; """"""Find the steady state for successive applications of the propagator; :math:`U`. Parameters; ----------; U : qobj; Operator representing the propagator. Returns; -------; a : qobj; Instance representing the steady-state density matrix. """""". evals, evecs = la.eig(U.full()). shifted_vals = np.abs(evals - 1.0); ev_idx = np.argmin(shifted_vals); ev_min = shifted_vals[ev_idx]; evecs = evecs.T; rho = Qobj(vec2mat(evecs[ev_idx]), dims=U.dims[0]); rho = rho * (1.0 / rho.tr()); rho = 0.5 * (rho + rho.dag()) # make sure rho is herm; rho.isherm = True; return rho. def _parallel_sesolve(n, N, H, tlist, args, options):; psi0 = basis(N, n); output = sesolve(H, psi0, tlist, [], args, options, _safe_mode=False); return output. def _parallel_mesolve(n, N, H, tlist, c_op_list, args, options, dims=None):; col_idx, row_idx = np.unravel_index(n, (N, N)); rho0 = projection(N, row_idx, col_idx); rho0.dims = dims; output = mesolve(; H, rho0, tlist, c_ops=c_op_list, args=args, options=options,; _safe_mode=False); return output. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/modules/qutip/propagator.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/propagator.html
https://qutip.org/docs/4.7/modules/qutip/propagator.html:1741,Integrability,depend,dependent,1741,"eroperator import (vec2mat, mat2vec,; vector_to_operator, operator_to_vector); from qutip.sparse import sp_reshape; from qutip.cy.sparse_utils import unit_row_norm; from qutip.mesolve import mesolve; from qutip.sesolve import sesolve; from qutip.states import basis, projection; from qutip.solver import Options, _solver_safety_check, config; from qutip.parallel import parallel_map, _default_kwargs; from qutip.ui.progressbar import BaseProgressBar, TextProgressBar. [docs]def propagator(H, t, c_op_list=[], args={}, options=None,; unitary_mode='batch', parallel=False,; progress_bar=None, _safe_mode=True,; **kwargs):; r""""""; Calculate the propagator U(t) for the density matrix or wave function such; that :math:`\psi(t) = U(t)\psi(0)` or; :math:`\rho_{\mathrm vec}(t) = U(t) \rho_{\mathrm vec}(0)`; where :math:`\rho_{\mathrm vec}` is the vector representation of the; density matrix. Parameters; ----------; H : qobj or list; Hamiltonian as a Qobj instance of a nested list of Qobjs and; coefficients in the list-string or list-function format for; time-dependent Hamiltonians (see description in :func:`qutip.mesolve`). t : float or array-like; Time or list of times for which to evaluate the propagator. c_op_list : list; List of qobj collapse operators. args : list/array/dictionary; Parameters to callback functions for time-dependent Hamiltonians and; collapse operators. options : :class:`qutip.solver.Options`; with options for the ODE solver. unitary_mode = str ('batch', 'single'); Solve all basis vectors simulaneously ('batch') or individually; ('single'). parallel : bool {False, True}; Run the propagator in parallel mode. This will override the; unitary_mode settings if set to True. progress_bar: BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. By default no progress bar; is used, and if set to True a TextProgressBar will be used. Returns; -------; a : qobj; Instance representing the propagator :math:`U(",MatchSource.WIKI,docs/4.7/modules/qutip/propagator.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/propagator.html
https://qutip.org/docs/4.7/modules/qutip/propagator.html:2016,Integrability,depend,dependent,2016,"_safety_check, config; from qutip.parallel import parallel_map, _default_kwargs; from qutip.ui.progressbar import BaseProgressBar, TextProgressBar. [docs]def propagator(H, t, c_op_list=[], args={}, options=None,; unitary_mode='batch', parallel=False,; progress_bar=None, _safe_mode=True,; **kwargs):; r""""""; Calculate the propagator U(t) for the density matrix or wave function such; that :math:`\psi(t) = U(t)\psi(0)` or; :math:`\rho_{\mathrm vec}(t) = U(t) \rho_{\mathrm vec}(0)`; where :math:`\rho_{\mathrm vec}` is the vector representation of the; density matrix. Parameters; ----------; H : qobj or list; Hamiltonian as a Qobj instance of a nested list of Qobjs and; coefficients in the list-string or list-function format for; time-dependent Hamiltonians (see description in :func:`qutip.mesolve`). t : float or array-like; Time or list of times for which to evaluate the propagator. c_op_list : list; List of qobj collapse operators. args : list/array/dictionary; Parameters to callback functions for time-dependent Hamiltonians and; collapse operators. options : :class:`qutip.solver.Options`; with options for the ODE solver. unitary_mode = str ('batch', 'single'); Solve all basis vectors simulaneously ('batch') or individually; ('single'). parallel : bool {False, True}; Run the propagator in parallel mode. This will override the; unitary_mode settings if set to True. progress_bar: BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. By default no progress bar; is used, and if set to True a TextProgressBar will be used. Returns; -------; a : qobj; Instance representing the propagator :math:`U(t)`. """"""; kw = _default_kwargs(); if 'num_cpus' in kwargs:; num_cpus = kwargs['num_cpus']; else:; num_cpus = kw['num_cpus']. if progress_bar is None:; progress_bar = BaseProgressBar(); elif progress_bar is True:; progress_bar = TextProgressBar(). if options is None:; options = Options(); options.rhs_reuse = True; rhs_",MatchSource.WIKI,docs/4.7/modules/qutip/propagator.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/propagator.html
https://qutip.org/docs/4.7/modules/qutip/propagator.html:1018,Modifiability,config,config,1018,"ip.propagator — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.propagator. Source code for qutip.propagator; __all__ = ['propagator', 'propagator_steadystate']. import types; import numpy as np; import scipy.linalg as la; import functools; import scipy.sparse as sp; from qutip.qobj import Qobj; from qutip.tensor import tensor; from qutip.operators import qeye; from qutip.rhs_generate import rhs_clear, _td_format_check; from qutip.superoperator import (vec2mat, mat2vec,; vector_to_operator, operator_to_vector); from qutip.sparse import sp_reshape; from qutip.cy.sparse_utils import unit_row_norm; from qutip.mesolve import mesolve; from qutip.sesolve import sesolve; from qutip.states import basis, projection; from qutip.solver import Options, _solver_safety_check, config; from qutip.parallel import parallel_map, _default_kwargs; from qutip.ui.progressbar import BaseProgressBar, TextProgressBar. [docs]def propagator(H, t, c_op_list=[], args={}, options=None,; unitary_mode='batch', parallel=False,; progress_bar=None, _safe_mode=True,; **kwargs):; r""""""; Calculate the propagator U(t) for the density matrix or wave function such; that :math:`\psi(t) = U(t)\psi(0)` or; :math:`\rho_{\mathrm vec}(t) = U(t) \rho_{\mathrm vec}(0)`; where :math:`\rho_{\mathrm vec}` is the vector representation of the; density matrix. Parameters; ----------; H : qobj or list; Hamiltonian as a Qobj instance of a nested list of Qobjs and; coefficients in the list-string or list-function format for; time-dependent Hamiltonians (see description in :func:`qutip.mesolve`). t : float or array-like; Time or list of times for which to evaluate the propagator. c_op_list : list; List of qobj collapse operators. args : list/array/dictionary; Parameters to callback function",MatchSource.WIKI,docs/4.7/modules/qutip/propagator.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/propagator.html
https://qutip.org/docs/4.7/modules/qutip/propagator.html:2536,Usability,progress bar,progress bar,2536,"trix. Parameters; ----------; H : qobj or list; Hamiltonian as a Qobj instance of a nested list of Qobjs and; coefficients in the list-string or list-function format for; time-dependent Hamiltonians (see description in :func:`qutip.mesolve`). t : float or array-like; Time or list of times for which to evaluate the propagator. c_op_list : list; List of qobj collapse operators. args : list/array/dictionary; Parameters to callback functions for time-dependent Hamiltonians and; collapse operators. options : :class:`qutip.solver.Options`; with options for the ODE solver. unitary_mode = str ('batch', 'single'); Solve all basis vectors simulaneously ('batch') or individually; ('single'). parallel : bool {False, True}; Run the propagator in parallel mode. This will override the; unitary_mode settings if set to True. progress_bar: BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. By default no progress bar; is used, and if set to True a TextProgressBar will be used. Returns; -------; a : qobj; Instance representing the propagator :math:`U(t)`. """"""; kw = _default_kwargs(); if 'num_cpus' in kwargs:; num_cpus = kwargs['num_cpus']; else:; num_cpus = kw['num_cpus']. if progress_bar is None:; progress_bar = BaseProgressBar(); elif progress_bar is True:; progress_bar = TextProgressBar(). if options is None:; options = Options(); options.rhs_reuse = True; rhs_clear(). if isinstance(t, (int, float, np.integer, np.floating)):; tlist = [0, t]; else:; tlist = t. if _safe_mode:; _solver_safety_check(H, None, c_ops=c_op_list, e_ops=[], args=args). td_type = _td_format_check(H, c_op_list, solver='me'). if isinstance(H, (types.FunctionType, types.BuiltinFunctionType,; functools.partial)):; H0 = H(0.0, args); if unitary_mode == 'batch':; # batch don't work with function Hamiltonian; unitary_mode = 'single'; elif isinstance(H, list):; H0 = H[0][0] if isinstance(H[0], list) else H[0]; else:; H0 = H. if len(c_op_list) == 0",MatchSource.WIKI,docs/4.7/modules/qutip/propagator.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/propagator.html
https://qutip.org/docs/4.7/modules/qutip/qobj.html:14428,Availability,mask,mask,14428,"er). def __rsub__(self, other):; """"""; SUBTRACTION with Qobj on RIGHT [ ex. 4-Qobj ]; """"""; return (-self) + other. def __mul__(self, other):; """"""; MULTIPLICATION with Qobj on LEFT [ ex. Qobj*4 ]; """"""; self._isunitary = None. if isinstance(other, Qobj):; if self.dims[1] == other.dims[0]:; out = Qobj(); out.data = self.data * other.data; dims = [self.dims[0], other.dims[1]]; out.dims = dims; if settings.auto_tidyup:; out.tidyup(); if (settings.auto_tidyup_dims; and not isinstance(dims[0][0], list); and not isinstance(dims[1][0], list)):; # If neither left or right is a superoperator,; # we should implicitly partial trace over; # matching dimensions of 1.; # Using izip_longest allows for the left and right dims; # to have uneven length (non-square Qobjs).; # We use None as padding so that it doesn't match anything,; # and will never cause a partial trace on the other side.; mask = [l == r == 1; for l, r in zip_longest(dims[0], dims[1],; fillvalue=None)]; # To ensure that there are still any dimensions left, we; # use max() to add a dimensions list of [1] if all matching; # dims are traced out of that side.; out.dims = [max([1],; [dim for dim, m in zip(dims[0], mask); if not m]),; max([1],; [dim for dim, m in zip(dims[1], mask); if not m])]. else:; out.dims = dims. out._isherm = None. if self.superrep and other.superrep:; if self.superrep != other.superrep:; msg = (""Multiplying superoperators with different "" +; ""representations""); warnings.warn(msg). out.superrep = self.superrep. return out. elif np.prod(self.shape) == 1:; out = Qobj(other); out.data *= self.data[0, 0]; out.superrep = other.superrep; return out.tidyup() if settings.auto_tidyup else out. elif np.prod(other.shape) == 1:; out = Qobj(self); out.data *= other.data[0, 0]; out.superrep = self.superrep; return out.tidyup() if settings.auto_tidyup else out. elif self.shape[1] == 1 and other.shape[0] == 1:; out = Qobj(); out.data = self.data * other.data; out.dims = [self.dims[0], other.dims[1]]; return out.tidyu",MatchSource.WIKI,docs/4.7/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qobj.html
https://qutip.org/docs/4.7/modules/qutip/qobj.html:14720,Availability,mask,mask,14720,"4 ]; """"""; self._isunitary = None. if isinstance(other, Qobj):; if self.dims[1] == other.dims[0]:; out = Qobj(); out.data = self.data * other.data; dims = [self.dims[0], other.dims[1]]; out.dims = dims; if settings.auto_tidyup:; out.tidyup(); if (settings.auto_tidyup_dims; and not isinstance(dims[0][0], list); and not isinstance(dims[1][0], list)):; # If neither left or right is a superoperator,; # we should implicitly partial trace over; # matching dimensions of 1.; # Using izip_longest allows for the left and right dims; # to have uneven length (non-square Qobjs).; # We use None as padding so that it doesn't match anything,; # and will never cause a partial trace on the other side.; mask = [l == r == 1; for l, r in zip_longest(dims[0], dims[1],; fillvalue=None)]; # To ensure that there are still any dimensions left, we; # use max() to add a dimensions list of [1] if all matching; # dims are traced out of that side.; out.dims = [max([1],; [dim for dim, m in zip(dims[0], mask); if not m]),; max([1],; [dim for dim, m in zip(dims[1], mask); if not m])]. else:; out.dims = dims. out._isherm = None. if self.superrep and other.superrep:; if self.superrep != other.superrep:; msg = (""Multiplying superoperators with different "" +; ""representations""); warnings.warn(msg). out.superrep = self.superrep. return out. elif np.prod(self.shape) == 1:; out = Qobj(other); out.data *= self.data[0, 0]; out.superrep = other.superrep; return out.tidyup() if settings.auto_tidyup else out. elif np.prod(other.shape) == 1:; out = Qobj(self); out.data *= other.data[0, 0]; out.superrep = self.superrep; return out.tidyup() if settings.auto_tidyup else out. elif self.shape[1] == 1 and other.shape[0] == 1:; out = Qobj(); out.data = self.data * other.data; out.dims = [self.dims[0], other.dims[1]]; return out.tidyup() if settings.auto_tidyup else out. else:; raise TypeError(""Incompatible Qobj shapes""). elif isinstance(other, np.ndarray):; if other.dtype == 'object':; out = np.empty(other.shape, dtype=o",MatchSource.WIKI,docs/4.7/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qobj.html
https://qutip.org/docs/4.7/modules/qutip/qobj.html:14782,Availability,mask,mask,14782,"4 ]; """"""; self._isunitary = None. if isinstance(other, Qobj):; if self.dims[1] == other.dims[0]:; out = Qobj(); out.data = self.data * other.data; dims = [self.dims[0], other.dims[1]]; out.dims = dims; if settings.auto_tidyup:; out.tidyup(); if (settings.auto_tidyup_dims; and not isinstance(dims[0][0], list); and not isinstance(dims[1][0], list)):; # If neither left or right is a superoperator,; # we should implicitly partial trace over; # matching dimensions of 1.; # Using izip_longest allows for the left and right dims; # to have uneven length (non-square Qobjs).; # We use None as padding so that it doesn't match anything,; # and will never cause a partial trace on the other side.; mask = [l == r == 1; for l, r in zip_longest(dims[0], dims[1],; fillvalue=None)]; # To ensure that there are still any dimensions left, we; # use max() to add a dimensions list of [1] if all matching; # dims are traced out of that side.; out.dims = [max([1],; [dim for dim, m in zip(dims[0], mask); if not m]),; max([1],; [dim for dim, m in zip(dims[1], mask); if not m])]. else:; out.dims = dims. out._isherm = None. if self.superrep and other.superrep:; if self.superrep != other.superrep:; msg = (""Multiplying superoperators with different "" +; ""representations""); warnings.warn(msg). out.superrep = self.superrep. return out. elif np.prod(self.shape) == 1:; out = Qobj(other); out.data *= self.data[0, 0]; out.superrep = other.superrep; return out.tidyup() if settings.auto_tidyup else out. elif np.prod(other.shape) == 1:; out = Qobj(self); out.data *= other.data[0, 0]; out.superrep = self.superrep; return out.tidyup() if settings.auto_tidyup else out. elif self.shape[1] == 1 and other.shape[0] == 1:; out = Qobj(); out.data = self.data * other.data; out.dims = [self.dims[0], other.dims[1]]; return out.tidyup() if settings.auto_tidyup else out. else:; raise TypeError(""Incompatible Qobj shapes""). elif isinstance(other, np.ndarray):; if other.dtype == 'object':; out = np.empty(other.shape, dtype=o",MatchSource.WIKI,docs/4.7/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qobj.html
https://qutip.org/docs/4.7/modules/qutip/qobj.html:19967,Availability,error,errors,19967,"rators and super-operators (square matrices).""). if m is not None:; raise NotImplementedError(""modulo is not implemented for Qobj""). try:; data = self.data ** n; except (TypeError, ValueError):; raise ValueError('Invalid choice of exponent.'); out = Qobj(data, dims=self.dims); out.superrep = self.superrep; return out.tidyup() if settings.auto_tidyup else out. def __abs__(self):; return abs(self.data). def __str__(self):; s = """"; t = self.type; shape = self.shape; if self.type in ['oper', 'super']:; s += (""Quantum object: "" +; ""dims = "" + str(self.dims) +; "", shape = "" + str(shape) +; "", type = "" + t +; "", isherm = "" + str(self.isherm) +; (; "", superrep = {0.superrep}"".format(self); if t == ""super"" and self.superrep != ""super""; else """"; ) + ""\n""); else:; s += (""Quantum object: "" +; ""dims = "" + str(self.dims) +; "", shape = "" + str(shape) +; "", type = "" + t + ""\n""); s += ""Qobj data =\n"". if shape[0] > 10000 or shape[1] > 10000:; # if the system is huge, don't attempt to convert to a; # dense matrix and then to string, because it is pointless; # and is likely going to produce memory errors. Instead print the; # sparse data string representation; s += str(self.data). elif all(np.imag(self.data.data) == 0):; s += str(np.real(self.full())). else:; s += str(self.full()). return s. def __repr__(self):; # give complete information on Qobj without print statement in; # command-line we cant realistically serialize a Qobj into a string,; # so we simply return the informal __str__ representation instead.); return self.__str__(). def __call__(self, other):; """"""; Acts this Qobj on another Qobj either by left-multiplication,; or by vectorization and devectorization, as; appropriate.; """"""; if not isinstance(other, Qobj):; raise TypeError(""Only defined for quantum objects.""). if self.type == ""super"":; if other.type == ""ket"":; other = qutip.states.ket2dm(other). if other.type == ""oper"":; return qutip.superoperator.vector_to_operator(; self * qutip.superoperator.operator_to_vector(other",MatchSource.WIKI,docs/4.7/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qobj.html
https://qutip.org/docs/4.7/modules/qutip/qobj.html:25702,Availability,toler,tolerance,25702,"merate_flat(J.dims); J_dual = tensor.tensor_swap(J, *(; list(zip(tensor_idxs[0][1], tensor_idxs[0][0])) +; list(zip(tensor_idxs[1][1], tensor_idxs[1][0])); )).trans(); J_dual.superrep = 'choi'; return J_dual. [docs] def conj(self):; """"""Conjugate operator of quantum object.; """"""; out = Qobj(); out.data = self.data.conj(); out.dims = [self.dims[0], self.dims[1]]; return out. [docs] def norm(self, norm=None, sparse=False, tol=0, maxiter=100000):; """"""Norm of a quantum object. Default norm is L2-norm for kets and trace-norm for operators.; Other ket and operator norms may be specified using the `norm` and; argument. Parameters; ----------; norm : str; Which norm to use for ket/bra vectors: L2 'l2', max norm 'max',; or for operators: trace 'tr', Frobius 'fro', one 'one', or max; 'max'. sparse : bool; Use sparse eigenvalue solver for trace norm. Other norms are not; affected by this parameter. tol : float; Tolerance for sparse solver (if used) for trace norm. The sparse; solver may not converge if the tolerance is set too low. maxiter : int; Maximum number of iterations performed by sparse solver (if used); for trace norm. Returns; -------; norm : float; The requested norm of the operator or state quantum object. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; if self.type in ['oper', 'super']:; if norm is None or norm == 'tr':; _op = self.data * zcsr_adjoint(self.data); vals = sp_eigs(_op, True, vecs=False,; sparse=sparse, tol=tol, maxiter=maxiter); return np.sum(np.sqrt(np.abs(vals))); elif norm == 'fro':; return sp_fro_norm(self.data); elif norm == 'one':; return sp_one_norm(self.data); elif norm == 'max':; return sp_max_norm(self.data); else:; raise ValueError(; ""For matrices, norm must be 'tr', 'fro', 'one', or 'max'.""); else:; if norm is None or norm == 'l2':; return sp_L2_norm(self.data); elif norm == 'max':; return sp_max_norm(self.data); else:; raise ValueError(""For vectors, norm mu",MatchSource.WIKI,docs/4.7/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qobj.html
https://qutip.org/docs/4.7/modules/qutip/qobj.html:29036,Availability,avail,available,29036,"t) or Fortran ordering.; squeeze : bool {False, True}; Squeeze output array. Returns; -------; data : array; Array of complex data from quantum objects `data` attribute.; """"""; if squeeze:; return self.data.toarray(order=order).squeeze(); else:; return self.data.toarray(order=order). def __array__(self, *arg, **kwarg):; """"""Numpy array from Qobj; For compatibility with np.array; """"""; return self.full(). [docs] def diag(self):; """"""Diagonal elements of quantum object. Returns; -------; diags : array; Returns array of ``real`` values if operators is Hermitian,; otherwise ``complex`` values are returned. """"""; out = self.data.diagonal(); if np.any(np.imag(out) > settings.atol) or not self.isherm:; return out; else:; return np.real(out). [docs] def expm(self, method='dense'):; """"""Matrix exponential of quantum operator. Input operator must be square. Parameters; ----------; method : str {'dense', 'sparse'}; Use set method to use to calculate the matrix exponentiation. The; available choices includes 'dense' and 'sparse'. Since the; exponential of a matrix is nearly always dense, method='dense'; is set as default.s. Returns; -------; oper : :class:`qutip.Qobj`; Exponentiated quantum operator. Raises; ------; TypeError; Quantum operator is not square. """"""; if self.dims[0][0] != self.dims[1][0]:; raise TypeError('Invalid operand for matrix exponential'). if method == 'dense':; F = sp_expm(self.data, sparse=False). elif method == 'sparse':; F = sp_expm(self.data, sparse=True). else:; raise ValueError(""method must be 'dense' or 'sparse'.""). out = Qobj(F, dims=self.dims); return out.tidyup() if settings.auto_tidyup else out. [docs] def check_herm(self):; """"""Check if the quantum object is hermitian. Returns; -------; isherm : bool; Returns the new value of isherm property.; """"""; self._isherm = None; return self.isherm. [docs] def sqrtm(self, sparse=False, tol=0, maxiter=100000):; """"""Sqrt of a quantum operator. Operator must be square. Parameters; ----------; sparse : bool; Use spar",MatchSource.WIKI,docs/4.7/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qobj.html
https://qutip.org/docs/4.7/modules/qutip/qobj.html:34556,Availability,toler,tolerance,34556,"urns; -------; oper : :class:`qutip.Qobj`; Quantum object representing partial trace with selected components; remaining. Notes; -----; This function is identical to the :func:`qutip.qobj.ptrace` function; that has been deprecated. """"""; if sparse is None:; if self.isket:; sparse = False; elif (self.data.nnz / (self.shape[0] * self.shape[1])) >= 0.1:; sparse = False; if sparse:; q = Qobj(); q.data, q.dims, _ = _ptrace(self, sel); out = q.tidyup() if settings.auto_tidyup else q; else:; out = _ptrace_dense(self, sel); if isket(out):; out = out.proj(); return out. [docs] def permute(self, order):; """"""Permutes a composite quantum object. Parameters; ----------; order : list/array; List specifying new tensor order. Returns; -------; P : :class:`qutip.Qobj`; Permuted quantum object. """"""; q = Qobj(); q.data, q.dims = _permute(self, order); q.data.sort_indices(); return q. [docs] def tidyup(self, atol=None):; """"""Removes small elements from the quantum object. Parameters; ----------; atol : float; Absolute tolerance used by tidyup. Default is set; via qutip global settings parameters. Returns; -------; oper : :class:`qutip.Qobj`; Quantum object with small elements removed. """"""; if atol is None:; atol = settings.auto_tidyup_atol. if self.data.nnz:; # This does the tidyup and returns True if; # The sparse data needs to be shortened; if use_openmp() and self.data.nnz > 500:; if omp_tidyup(self.data.data, atol, self.data.nnz,; settings.num_cpus):; self.data.eliminate_zeros(); else:; if cy_tidyup(self.data.data, atol, self.data.nnz):; self.data.eliminate_zeros(); return self; else:; return self. [docs] def transform(self, inpt, inverse=False, sparse=True):; """"""Basis transform defined by input array. Input array can be a ``matrix`` defining the transformation,; or a ``list`` of kets that defines the new basis. Parameters; ----------; inpt : array_like; A ``matrix`` or ``list`` of kets defining the transformation.; inverse : bool; Whether to return inverse transformation.; sparse : b",MatchSource.WIKI,docs/4.7/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qobj.html
https://qutip.org/docs/4.7/modules/qutip/qobj.html:41660,Availability,toler,tolerance,41660,"qutip.states.ket2dm(self).dag() * other).tr(); else:; err = ""Can only calculate overlap for state vector Qobjs""; raise TypeError(err). elif self.isoper:; if other.isket or other.isbra:; return (self.dag() * qutip.states.ket2dm(other)).tr(); elif other.isoper:; return (self.dag() * other).tr(); else:; err = ""Can only calculate overlap for state vector Qobjs""; raise TypeError(err); raise TypeError(""Can only calculate overlap for state vector Qobjs""). [docs] def eigenstates(self, sparse=False, sort='low', eigvals=0,; tol=0, maxiter=100000, phase_fix=None):; """"""Eigenstates and eigenenergies. Eigenstates and eigenenergies are defined for operators and; superoperators only. Parameters; ----------; sparse : bool; Use sparse Eigensolver. sort : str; Sort eigenvalues (and vectors) 'low' to high, or 'high' to low. eigvals : int; Number of requested eigenvalues. Default is all eigenvalues. tol : float; Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiter : int; Maximum number of iterations performed by sparse solver (if used). phase_fix : int, None; If not None, set the phase of each kets so that ket[phase_fix,0]; is real positive. Returns; -------; eigvals : array; Array of eigenvalues for operator. eigvecs : array; Array of quantum operators representing the oprator eigenkets.; Order of eigenkets is determined by order of eigenvalues. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; evals, evecs = sp_eigs(self.data, self.isherm, sparse=sparse,; sort=sort, eigvals=eigvals, tol=tol,; maxiter=maxiter); if self.type == 'super':; new_dims = [self.dims[0], [1]]; new_type = 'operator-ket'; else:; new_dims = [self.dims[0], [1] * len(self.dims[0])]; new_type = 'ket'; ekets = np.empty((len(evecs),), dtype=object); ekets[:] = [Qobj(vec, dims=new_dims, type=new_type) for vec in evecs]; norms = np.array([ket.norm() for ket",MatchSource.WIKI,docs/4.7/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qobj.html
https://qutip.org/docs/4.7/modules/qutip/qobj.html:43411,Availability,toler,tolerance,43411," = 'operator-ket'; else:; new_dims = [self.dims[0], [1] * len(self.dims[0])]; new_type = 'ket'; ekets = np.empty((len(evecs),), dtype=object); ekets[:] = [Qobj(vec, dims=new_dims, type=new_type) for vec in evecs]; norms = np.array([ket.norm() for ket in ekets]); if phase_fix is None:; phase = np.array([1] * len(ekets)); else:; phase = np.array([np.abs(ket[phase_fix, 0]) / ket[phase_fix, 0]; if ket[phase_fix, 0] else 1; for ket in ekets]); return evals, ekets / norms * phase. [docs] def eigenenergies(self, sparse=False, sort='low',; eigvals=0, tol=0, maxiter=100000):; """"""Eigenenergies of a quantum object. Eigenenergies (eigenvalues) are defined for operators or superoperators; only. Parameters; ----------; sparse : bool; Use sparse Eigensolver; sort : str; Sort eigenvalues 'low' to high, or 'high' to low.; eigvals : int; Number of requested eigenvalues. Default is all eigenvalues.; tol : float; Tolerance used by sparse Eigensolver (0=machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter : int; Maximum number of iterations performed by sparse solver (if used). Returns; -------; eigvals : array; Array of eigenvalues for operator. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; return sp_eigs(self.data, self.isherm, vecs=False, sparse=sparse,; sort=sort, eigvals=eigvals, tol=tol, maxiter=maxiter). [docs] def groundstate(self, sparse=False, tol=0, maxiter=100000, safe=True):; """"""Ground state Eigenvalue and Eigenvector. Defined for quantum operators or superoperators only. Parameters; ----------; sparse : bool; Use sparse Eigensolver; tol : float; Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter : int; Maximum number of iterations performed by sparse solver (if used).; safe : bool (default=True); Check for degenerate ground state. Returns; -------; eigval : ",MatchSource.WIKI,docs/4.7/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qobj.html
https://qutip.org/docs/4.7/modules/qutip/qobj.html:44202,Availability,toler,tolerance,44202," high, or 'high' to low.; eigvals : int; Number of requested eigenvalues. Default is all eigenvalues.; tol : float; Tolerance used by sparse Eigensolver (0=machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter : int; Maximum number of iterations performed by sparse solver (if used). Returns; -------; eigvals : array; Array of eigenvalues for operator. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; return sp_eigs(self.data, self.isherm, vecs=False, sparse=sparse,; sort=sort, eigvals=eigvals, tol=tol, maxiter=maxiter). [docs] def groundstate(self, sparse=False, tol=0, maxiter=100000, safe=True):; """"""Ground state Eigenvalue and Eigenvector. Defined for quantum operators or superoperators only. Parameters; ----------; sparse : bool; Use sparse Eigensolver; tol : float; Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter : int; Maximum number of iterations performed by sparse solver (if used).; safe : bool (default=True); Check for degenerate ground state. Returns; -------; eigval : float; Eigenvalue for the ground state of quantum operator.; eigvec : :class:`qutip.Qobj`; Eigenket for the ground state of quantum operator. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; if safe:; evals = 2; else:; evals = 1; grndval, grndvec = sp_eigs(self.data, self.isherm, sparse=sparse,; eigvals=evals, tol=tol, maxiter=maxiter); if safe:; tol = 1e-15 if tol == 0 else tol; if (grndval[1]-grndval[0]) <= 10*tol:; print(""WARNING: Ground state may be degenerate. ""; ""Use Q.eigenstates()""); new_dims = [self.dims[0], [1] * len(self.dims[0])]; grndvec = Qobj(grndvec[0], dims=new_dims); grndvec = grndvec / grndvec.norm(); return grndval[0], grndvec. [docs] def trans(self):; """"""Transposed operator. Ret",MatchSource.WIKI,docs/4.7/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qobj.html
https://qutip.org/docs/4.7/modules/qutip/qobj.html:59426,Availability,toler,tolerance,59426,"is recommended. """"""; return True if isinstance(Q, Qobj) and Q.isoperbra else False. [docs]def isoper(Q):; """"""Determines if given quantum object is a operator. Parameters; ----------; Q : :class:`qutip.Qobj`; Quantum object. Returns; -------; isoper : bool; True if Qobj is operator, False otherwise. Examples; --------; >>> a = destroy(5); >>> isoper(a); True. Notes; -----; This function is for legacy compatibility only. Using the `Qobj.isoper`; attribute is recommended. """"""; return True if isinstance(Q, Qobj) and Q.isoper else False. [docs]def issuper(Q):; """"""Determines if given quantum object is a super-operator. Parameters; ----------; Q : :class:`qutip.Qobj`; Quantum object. Returns; -------; issuper : bool; True if Qobj is superoperator, False otherwise. Notes; -----; This function is for legacy compatibility only. Using the `Qobj.issuper`; attribute is recommended. """"""; return True if isinstance(Q, Qobj) and Q.issuper else False. [docs]def isequal(A, B, tol=None):; """"""Determines if two qobj objects are equal to within given tolerance. Parameters; ----------; A : :class:`qutip.Qobj`; Qobj one; B : :class:`qutip.Qobj`; Qobj two; tol : float; Tolerence for equality to be valid. Returns; -------; isequal : bool; True if qobjs are equal, False otherwise. Notes; -----; This function is for legacy compatibility only. Instead, it is recommended; to use the equality operator of Qobj instances instead: A == B. """"""; if tol is None:; tol = settings.atol. if not isinstance(A, Qobj) or not isinstance(B, Qobj):; return False. if A.dims != B.dims:; return False. Adat = A.data; Bdat = B.data; elems = (Adat - Bdat).data; if np.any(np.abs(elems) > tol):; return False. return True. [docs]def isherm(Q):; """"""Determines if given operator is Hermitian. Parameters; ----------; Q : :class:`qutip.Qobj`; Quantum object. Returns; -------; isherm : bool; True if operator is Hermitian, False otherwise. Examples; --------; >>> a = destroy(4); >>> isherm(a); False. Notes; -----; This function is",MatchSource.WIKI,docs/4.7/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qobj.html
https://qutip.org/docs/4.7/modules/qutip/qobj.html:21158,Deployability,update,update,21158,"# give complete information on Qobj without print statement in; # command-line we cant realistically serialize a Qobj into a string,; # so we simply return the informal __str__ representation instead.); return self.__str__(). def __call__(self, other):; """"""; Acts this Qobj on another Qobj either by left-multiplication,; or by vectorization and devectorization, as; appropriate.; """"""; if not isinstance(other, Qobj):; raise TypeError(""Only defined for quantum objects.""). if self.type == ""super"":; if other.type == ""ket"":; other = qutip.states.ket2dm(other). if other.type == ""oper"":; return qutip.superoperator.vector_to_operator(; self * qutip.superoperator.operator_to_vector(other); ); else:; raise TypeError(""Can only act super on oper or ket.""). elif self.type == ""oper"":; if other.type == ""ket"":; return self * other; else:; raise TypeError(""Can only act oper on ket.""). def __getstate__(self):; # defines what happens when Qobj object gets pickled; self.__dict__.update({'qutip_version': __version__[:5]}); return self.__dict__. def __setstate__(self, state):; # defines what happens when loading a pickled Qobj; if 'qutip_version' in state.keys():; del state['qutip_version']; (self.__dict__).update(state). def _repr_latex_(self):; """"""; Generate a LaTeX representation of the Qobj instance. Can be used for; formatted output in ipython notebook.; """"""; t = self.type; shape = self.shape; s = r''; if self.type in ['oper', 'super']:; s += (""Quantum object: "" +; ""dims = "" + str(self.dims) +; "", shape = "" + str(shape) +; "", type = "" + t +; "", isherm = "" + str(self.isherm) +; (; "", superrep = {0.superrep}"".format(self); if t == ""super"" and self.superrep != ""super""; else """"; )); else:; s += (""Quantum object: "" +; ""dims = "" + str(self.dims) +; "", shape = "" + str(shape) +; "", type = "" + t). M, N = self.data.shape. s += r' $ \\ \left(\begin{matrix}'. def _format_float(value):; if value == 0.0:; return ""0.0""; elif abs(value) > 1000.0 or abs(value) < 0.001:; return (""%.3e"" % value).replace",MatchSource.WIKI,docs/4.7/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qobj.html
https://qutip.org/docs/4.7/modules/qutip/qobj.html:21389,Deployability,update,update,21389,"self.__str__(). def __call__(self, other):; """"""; Acts this Qobj on another Qobj either by left-multiplication,; or by vectorization and devectorization, as; appropriate.; """"""; if not isinstance(other, Qobj):; raise TypeError(""Only defined for quantum objects.""). if self.type == ""super"":; if other.type == ""ket"":; other = qutip.states.ket2dm(other). if other.type == ""oper"":; return qutip.superoperator.vector_to_operator(; self * qutip.superoperator.operator_to_vector(other); ); else:; raise TypeError(""Can only act super on oper or ket.""). elif self.type == ""oper"":; if other.type == ""ket"":; return self * other; else:; raise TypeError(""Can only act oper on ket.""). def __getstate__(self):; # defines what happens when Qobj object gets pickled; self.__dict__.update({'qutip_version': __version__[:5]}); return self.__dict__. def __setstate__(self, state):; # defines what happens when loading a pickled Qobj; if 'qutip_version' in state.keys():; del state['qutip_version']; (self.__dict__).update(state). def _repr_latex_(self):; """"""; Generate a LaTeX representation of the Qobj instance. Can be used for; formatted output in ipython notebook.; """"""; t = self.type; shape = self.shape; s = r''; if self.type in ['oper', 'super']:; s += (""Quantum object: "" +; ""dims = "" + str(self.dims) +; "", shape = "" + str(shape) +; "", type = "" + t +; "", isherm = "" + str(self.isherm) +; (; "", superrep = {0.superrep}"".format(self); if t == ""super"" and self.superrep != ""super""; else """"; )); else:; s += (""Quantum object: "" +; ""dims = "" + str(self.dims) +; "", shape = "" + str(shape) +; "", type = "" + t). M, N = self.data.shape. s += r' $ \\ \left(\begin{matrix}'. def _format_float(value):; if value == 0.0:; return ""0.0""; elif abs(value) > 1000.0 or abs(value) < 0.001:; return (""%.3e"" % value).replace(""e"", r""\times10^{"") + ""}""; elif abs(value - int(value)) < 0.001:; return ""%.1f"" % value; else:; return ""%.3f"" % value. def _format_element(m, n, d):; s = "" & "" if n > 0 else """"; if type(d) == str:; return s + ",MatchSource.WIKI,docs/4.7/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qobj.html
https://qutip.org/docs/4.7/modules/qutip/qobj.html:60898,Deployability,update,updated,60898,"or. Parameters; ----------; Q : :class:`qutip.Qobj`; Quantum object. Returns; -------; issuper : bool; True if Qobj is superoperator, False otherwise. Notes; -----; This function is for legacy compatibility only. Using the `Qobj.issuper`; attribute is recommended. """"""; return True if isinstance(Q, Qobj) and Q.issuper else False. [docs]def isequal(A, B, tol=None):; """"""Determines if two qobj objects are equal to within given tolerance. Parameters; ----------; A : :class:`qutip.Qobj`; Qobj one; B : :class:`qutip.Qobj`; Qobj two; tol : float; Tolerence for equality to be valid. Returns; -------; isequal : bool; True if qobjs are equal, False otherwise. Notes; -----; This function is for legacy compatibility only. Instead, it is recommended; to use the equality operator of Qobj instances instead: A == B. """"""; if tol is None:; tol = settings.atol. if not isinstance(A, Qobj) or not isinstance(B, Qobj):; return False. if A.dims != B.dims:; return False. Adat = A.data; Bdat = B.data; elems = (Adat - Bdat).data; if np.any(np.abs(elems) > tol):; return False. return True. [docs]def isherm(Q):; """"""Determines if given operator is Hermitian. Parameters; ----------; Q : :class:`qutip.Qobj`; Quantum object. Returns; -------; isherm : bool; True if operator is Hermitian, False otherwise. Examples; --------; >>> a = destroy(4); >>> isherm(a); False. Notes; -----; This function is for legacy compatibility only. Using the `Qobj.isherm`; attribute is recommended. """"""; return True if isinstance(Q, Qobj) and Q.isherm else False. # TRAILING IMPORTS; # We do a few imports here to avoid circular dependencies.; from qutip.eseries import eseries; import qutip.superop_reps as sr; import qutip.tensor as tensor; import qutip.operators as ops; import qutip.metrics as mts; import qutip.states; import qutip.superoperator. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qobj.html
https://qutip.org/docs/4.7/modules/qutip/qobj.html:18721,Energy Efficiency,power,powers,18721,"t.dims = self.dims; if settings.auto_tidyup:; out.tidyup(); if isinstance(other, complex):; out._isherm = out.isherm; else:; out._isherm = self._isherm. out.superrep = self.superrep. return out. else:; raise TypeError(""Incompatible object for division""). def __neg__(self):; """"""; NEGATION operation.; """"""; out = Qobj(); out.data = -self.data; out.dims = self.dims; out.superrep = self.superrep; if settings.auto_tidyup:; out.tidyup(); out._isherm = self._isherm; out._isunitary = self._isunitary; return out. def __getitem__(self, ind):; """"""; GET qobj elements.; """"""; out = self.data[ind]; if sp.issparse(out):; return out.toarray(); else:; return out. def __eq__(self, other):; """"""; EQUALITY operator.; """"""; if (isinstance(other, Qobj) and; self.dims == other.dims and; not np.any(np.abs((self.data - other.data).data) >; settings.atol)):; return True; else:; return False. def __ne__(self, other):; """"""; INEQUALITY operator.; """"""; return not (self == other). def __pow__(self, n, m=None): # calculates powers of Qobj; """"""; POWER operation.; """"""; if self.shape[0] != self.shape[1]:; raise Exception(""Raising a qobj to some power works only for "" +; ""operators and super-operators (square matrices).""). if m is not None:; raise NotImplementedError(""modulo is not implemented for Qobj""). try:; data = self.data ** n; except (TypeError, ValueError):; raise ValueError('Invalid choice of exponent.'); out = Qobj(data, dims=self.dims); out.superrep = self.superrep; return out.tidyup() if settings.auto_tidyup else out. def __abs__(self):; return abs(self.data). def __str__(self):; s = """"; t = self.type; shape = self.shape; if self.type in ['oper', 'super']:; s += (""Quantum object: "" +; ""dims = "" + str(self.dims) +; "", shape = "" + str(shape) +; "", type = "" + t +; "", isherm = "" + str(self.isherm) +; (; "", superrep = {0.superrep}"".format(self); if t == ""super"" and self.superrep != ""super""; else """"; ) + ""\n""); else:; s += (""Quantum object: "" +; ""dims = "" + str(self.dims) +; "", shape = "" + str(shape)",MatchSource.WIKI,docs/4.7/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qobj.html
https://qutip.org/docs/4.7/modules/qutip/qobj.html:18841,Energy Efficiency,power,power,18841," = self._isherm. out.superrep = self.superrep. return out. else:; raise TypeError(""Incompatible object for division""). def __neg__(self):; """"""; NEGATION operation.; """"""; out = Qobj(); out.data = -self.data; out.dims = self.dims; out.superrep = self.superrep; if settings.auto_tidyup:; out.tidyup(); out._isherm = self._isherm; out._isunitary = self._isunitary; return out. def __getitem__(self, ind):; """"""; GET qobj elements.; """"""; out = self.data[ind]; if sp.issparse(out):; return out.toarray(); else:; return out. def __eq__(self, other):; """"""; EQUALITY operator.; """"""; if (isinstance(other, Qobj) and; self.dims == other.dims and; not np.any(np.abs((self.data - other.data).data) >; settings.atol)):; return True; else:; return False. def __ne__(self, other):; """"""; INEQUALITY operator.; """"""; return not (self == other). def __pow__(self, n, m=None): # calculates powers of Qobj; """"""; POWER operation.; """"""; if self.shape[0] != self.shape[1]:; raise Exception(""Raising a qobj to some power works only for "" +; ""operators and super-operators (square matrices).""). if m is not None:; raise NotImplementedError(""modulo is not implemented for Qobj""). try:; data = self.data ** n; except (TypeError, ValueError):; raise ValueError('Invalid choice of exponent.'); out = Qobj(data, dims=self.dims); out.superrep = self.superrep; return out.tidyup() if settings.auto_tidyup else out. def __abs__(self):; return abs(self.data). def __str__(self):; s = """"; t = self.type; shape = self.shape; if self.type in ['oper', 'super']:; s += (""Quantum object: "" +; ""dims = "" + str(self.dims) +; "", shape = "" + str(shape) +; "", type = "" + t +; "", isherm = "" + str(self.isherm) +; (; "", superrep = {0.superrep}"".format(self); if t == ""super"" and self.superrep != ""super""; else """"; ) + ""\n""); else:; s += (""Quantum object: "" +; ""dims = "" + str(self.dims) +; "", shape = "" + str(shape) +; "", type = "" + t + ""\n""); s += ""Qobj data =\n"". if shape[0] > 10000 or shape[1] > 10000:; # if the system is huge, don't attempt to ",MatchSource.WIKI,docs/4.7/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qobj.html
https://qutip.org/docs/4.7/modules/qutip/qobj.html:38823,Energy Efficiency,efficient,efficient,38823,"; eigvals = eigvals[idx_nonzero]; eigstates = eigstates[idx_nonzero]. if method == 'clip':; eigvals[eigvals < 0] = 0; elif method == 'sgs':; eigvals = eigvals[::-1]; eigstates = eigstates[::-1]. acc = 0.0; dim = self.shape[0]; n_eigs = len(eigvals). for idx in reversed(range(n_eigs)):; if eigvals[idx] + acc / (idx + 1) >= 0:; break; else:; acc += eigvals[idx]; eigvals[idx] = 0.0. eigvals[:idx+1] += acc / (idx + 1). return sum([; val * qutip.states.ket2dm(state); for val, state in zip(eigvals, eigstates); ], Qobj(np.zeros(self.shape), dims=self.dims); ).unit(). [docs] def matrix_element(self, bra, ket):; """"""Calculates a matrix element. Gives the matrix element for the quantum object sandwiched between a; `bra` and `ket` vector. Parameters; -----------; bra : :class:`qutip.Qobj`; Quantum object of type 'bra' or 'ket'. ket : :class:`qutip.Qobj`; Quantum object of type 'ket'. Returns; -------; elem : complex; Complex valued matrix element. Notes; -----; It is slightly more computationally efficient to use a ket; vector for the 'bra' input.; """"""; if not self.isoper:; raise TypeError(""Can only get matrix elements for an operator.""). else:; if bra.isbra and ket.isket:; return zcsr_mat_elem(self.data, bra.data, ket.data, 1). elif bra.isket and ket.isket:; return zcsr_mat_elem(self.data, bra.data, ket.data, 0); else:; err = ""Can only calculate matrix elements for bra""; err += "" and ket vectors.""; raise TypeError(err). [docs] def overlap(self, other):; """"""Overlap between two state vectors or two operators. Gives the overlap (inner product) between the current bra or ket Qobj; and and another bra or ket Qobj. It gives the Hilbert-Schmidt overlap; when one of the Qobj is an operator/density matrix. Parameters; -----------; other : :class:`qutip.Qobj`; Quantum object for a state vector of type 'ket', 'bra' or density; matrix. Returns; -------; overlap : complex; Complex valued overlap. Raises; ------; TypeError; Can only calculate overlap between a bra, ket and density matrix; q",MatchSource.WIKI,docs/4.7/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qobj.html
https://qutip.org/docs/4.7/modules/qutip/qobj.html:39905,Energy Efficiency,efficient,efficient,39905,"ix elements for an operator.""). else:; if bra.isbra and ket.isket:; return zcsr_mat_elem(self.data, bra.data, ket.data, 1). elif bra.isket and ket.isket:; return zcsr_mat_elem(self.data, bra.data, ket.data, 0); else:; err = ""Can only calculate matrix elements for bra""; err += "" and ket vectors.""; raise TypeError(err). [docs] def overlap(self, other):; """"""Overlap between two state vectors or two operators. Gives the overlap (inner product) between the current bra or ket Qobj; and and another bra or ket Qobj. It gives the Hilbert-Schmidt overlap; when one of the Qobj is an operator/density matrix. Parameters; -----------; other : :class:`qutip.Qobj`; Quantum object for a state vector of type 'ket', 'bra' or density; matrix. Returns; -------; overlap : complex; Complex valued overlap. Raises; ------; TypeError; Can only calculate overlap between a bra, ket and density matrix; quantum objects. Notes; -----; Since QuTiP mainly deals with ket vectors, the most efficient inner; product call is the ket-ket version that computes the product; <self|other> with both vectors expressed as kets.; """""". if isinstance(other, Qobj):. if self.isbra:; if other.isket:; return zcsr_inner(self.data, other.data, 1); elif other.isbra:; # Since we deal mainly with ket vectors, the bra-bra combo; # is not common, and not optimized.; return zcsr_inner(self.data, other.dag().data, 1); elif other.isoper:; return (qutip.states.ket2dm(self).dag() * other).tr(); else:; err = ""Can only calculate overlap for state vector Qobjs""; raise TypeError(err). elif self.isket:; if other.isbra:; return zcsr_inner(other.data, self.data, 1); elif other.isket:; return zcsr_inner(self.data, other.data, 0); elif other.isoper:; return (qutip.states.ket2dm(self).dag() * other).tr(); else:; err = ""Can only calculate overlap for state vector Qobjs""; raise TypeError(err). elif self.isoper:; if other.isket or other.isbra:; return (self.dag() * qutip.states.ket2dm(other)).tr(); elif other.isoper:; return (self.dag() * othe",MatchSource.WIKI,docs/4.7/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qobj.html
https://qutip.org/docs/4.7/modules/qutip/qobj.html:51375,Integrability,depend,dependent,51375,"ngs.atol; ); ); else:; return False. @property; def isunitary(self):; if self._isunitary is not None:; # used previously computed value; return self._isunitary. self._isunitary = self.check_isunitary(). return self._isunitary. @isunitary.setter; def isunitary(self, isunitary):; self._isunitary = isunitary. @property; def type(self):; if not self._type:; self._type = type_from_dims(self.dims). return self._type. @property; def shape(self):; if self.data.shape == (1, 1):; return tuple([np.prod(self.dims[0]), np.prod(self.dims[1])]); else:; return tuple(self.data.shape). @property; def isbra(self):; return self.type == 'bra'. @property; def isket(self):; return self.type == 'ket'. @property; def isoperbra(self):; return self.type == 'operator-bra'. @property; def isoperket(self):; return self.type == 'operator-ket'. @property; def isoper(self):; return self.type == 'oper'. @property; def issuper(self):; return self.type == 'super'. [docs] @staticmethod; def evaluate(qobj_list, t, args):; """"""Evaluate a time-dependent quantum object in list format. For; example,. qobj_list = [H0, [H1, func_t]]. is evaluated to. Qobj(t) = H0 + H1 * func_t(t, args). and. qobj_list = [H0, [H1, 'sin(w * t)']]. is evaluated to. Qobj(t) = H0 + H1 * sin(args['w'] * t). Parameters; ----------; qobj_list : list; A nested list of Qobj instances and corresponding time-dependent; coefficients.; t : float; The time for which to evaluate the time-dependent Qobj instance.; args : dictionary; A dictionary with parameter values required to evaluate the; time-dependent Qobj intance. Returns; -------; output : :class:`qutip.Qobj`; A Qobj instance that represents the value of qobj_list at time t. """""". q_sum = 0; if isinstance(qobj_list, Qobj):; q_sum = qobj_list; elif isinstance(qobj_list, list):; for q in qobj_list:; if isinstance(q, Qobj):; q_sum += q; elif (isinstance(q, list) and len(q) == 2 and; isinstance(q[0], Qobj)):; if isinstance(q[1], types.FunctionType):; q_sum += q[0] * q[1](t, args); elif isins",MatchSource.WIKI,docs/4.7/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qobj.html
https://qutip.org/docs/4.7/modules/qutip/qobj.html:51714,Integrability,depend,dependent,51714,"f type(self):; if not self._type:; self._type = type_from_dims(self.dims). return self._type. @property; def shape(self):; if self.data.shape == (1, 1):; return tuple([np.prod(self.dims[0]), np.prod(self.dims[1])]); else:; return tuple(self.data.shape). @property; def isbra(self):; return self.type == 'bra'. @property; def isket(self):; return self.type == 'ket'. @property; def isoperbra(self):; return self.type == 'operator-bra'. @property; def isoperket(self):; return self.type == 'operator-ket'. @property; def isoper(self):; return self.type == 'oper'. @property; def issuper(self):; return self.type == 'super'. [docs] @staticmethod; def evaluate(qobj_list, t, args):; """"""Evaluate a time-dependent quantum object in list format. For; example,. qobj_list = [H0, [H1, func_t]]. is evaluated to. Qobj(t) = H0 + H1 * func_t(t, args). and. qobj_list = [H0, [H1, 'sin(w * t)']]. is evaluated to. Qobj(t) = H0 + H1 * sin(args['w'] * t). Parameters; ----------; qobj_list : list; A nested list of Qobj instances and corresponding time-dependent; coefficients.; t : float; The time for which to evaluate the time-dependent Qobj instance.; args : dictionary; A dictionary with parameter values required to evaluate the; time-dependent Qobj intance. Returns; -------; output : :class:`qutip.Qobj`; A Qobj instance that represents the value of qobj_list at time t. """""". q_sum = 0; if isinstance(qobj_list, Qobj):; q_sum = qobj_list; elif isinstance(qobj_list, list):; for q in qobj_list:; if isinstance(q, Qobj):; q_sum += q; elif (isinstance(q, list) and len(q) == 2 and; isinstance(q[0], Qobj)):; if isinstance(q[1], types.FunctionType):; q_sum += q[0] * q[1](t, args); elif isinstance(q[1], str):; args['t'] = t; q_sum += q[0] * float(eval(q[1], globals(), args)); else:; raise TypeError('Unrecognized format for ' +; 'specification of time-dependent Qobj'); else:; raise TypeError('Unrecognized format for specification ' +; 'of time-dependent Qobj'); else:; raise TypeError(; 'Unrecongized format ",MatchSource.WIKI,docs/4.7/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qobj.html
https://qutip.org/docs/4.7/modules/qutip/qobj.html:51791,Integrability,depend,dependent,51791,"erty; def shape(self):; if self.data.shape == (1, 1):; return tuple([np.prod(self.dims[0]), np.prod(self.dims[1])]); else:; return tuple(self.data.shape). @property; def isbra(self):; return self.type == 'bra'. @property; def isket(self):; return self.type == 'ket'. @property; def isoperbra(self):; return self.type == 'operator-bra'. @property; def isoperket(self):; return self.type == 'operator-ket'. @property; def isoper(self):; return self.type == 'oper'. @property; def issuper(self):; return self.type == 'super'. [docs] @staticmethod; def evaluate(qobj_list, t, args):; """"""Evaluate a time-dependent quantum object in list format. For; example,. qobj_list = [H0, [H1, func_t]]. is evaluated to. Qobj(t) = H0 + H1 * func_t(t, args). and. qobj_list = [H0, [H1, 'sin(w * t)']]. is evaluated to. Qobj(t) = H0 + H1 * sin(args['w'] * t). Parameters; ----------; qobj_list : list; A nested list of Qobj instances and corresponding time-dependent; coefficients.; t : float; The time for which to evaluate the time-dependent Qobj instance.; args : dictionary; A dictionary with parameter values required to evaluate the; time-dependent Qobj intance. Returns; -------; output : :class:`qutip.Qobj`; A Qobj instance that represents the value of qobj_list at time t. """""". q_sum = 0; if isinstance(qobj_list, Qobj):; q_sum = qobj_list; elif isinstance(qobj_list, list):; for q in qobj_list:; if isinstance(q, Qobj):; q_sum += q; elif (isinstance(q, list) and len(q) == 2 and; isinstance(q[0], Qobj)):; if isinstance(q[1], types.FunctionType):; q_sum += q[0] * q[1](t, args); elif isinstance(q[1], str):; args['t'] = t; q_sum += q[0] * float(eval(q[1], globals(), args)); else:; raise TypeError('Unrecognized format for ' +; 'specification of time-dependent Qobj'); else:; raise TypeError('Unrecognized format for specification ' +; 'of time-dependent Qobj'); else:; raise TypeError(; 'Unrecongized format for specification of time-dependent Qobj'). return q_sum. # ----------------------------------------",MatchSource.WIKI,docs/4.7/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qobj.html
https://qutip.org/docs/4.7/modules/qutip/qobj.html:51902,Integrability,depend,dependent,51902,".prod(self.dims[1])]); else:; return tuple(self.data.shape). @property; def isbra(self):; return self.type == 'bra'. @property; def isket(self):; return self.type == 'ket'. @property; def isoperbra(self):; return self.type == 'operator-bra'. @property; def isoperket(self):; return self.type == 'operator-ket'. @property; def isoper(self):; return self.type == 'oper'. @property; def issuper(self):; return self.type == 'super'. [docs] @staticmethod; def evaluate(qobj_list, t, args):; """"""Evaluate a time-dependent quantum object in list format. For; example,. qobj_list = [H0, [H1, func_t]]. is evaluated to. Qobj(t) = H0 + H1 * func_t(t, args). and. qobj_list = [H0, [H1, 'sin(w * t)']]. is evaluated to. Qobj(t) = H0 + H1 * sin(args['w'] * t). Parameters; ----------; qobj_list : list; A nested list of Qobj instances and corresponding time-dependent; coefficients.; t : float; The time for which to evaluate the time-dependent Qobj instance.; args : dictionary; A dictionary with parameter values required to evaluate the; time-dependent Qobj intance. Returns; -------; output : :class:`qutip.Qobj`; A Qobj instance that represents the value of qobj_list at time t. """""". q_sum = 0; if isinstance(qobj_list, Qobj):; q_sum = qobj_list; elif isinstance(qobj_list, list):; for q in qobj_list:; if isinstance(q, Qobj):; q_sum += q; elif (isinstance(q, list) and len(q) == 2 and; isinstance(q[0], Qobj)):; if isinstance(q[1], types.FunctionType):; q_sum += q[0] * q[1](t, args); elif isinstance(q[1], str):; args['t'] = t; q_sum += q[0] * float(eval(q[1], globals(), args)); else:; raise TypeError('Unrecognized format for ' +; 'specification of time-dependent Qobj'); else:; raise TypeError('Unrecognized format for specification ' +; 'of time-dependent Qobj'); else:; raise TypeError(; 'Unrecongized format for specification of time-dependent Qobj'). return q_sum. # -----------------------------------------------------------------------------; # This functions evaluates a time-dependent quantum ob",MatchSource.WIKI,docs/4.7/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qobj.html
https://qutip.org/docs/4.7/modules/qutip/qobj.html:52519,Integrability,depend,dependent,52519,"args). and. qobj_list = [H0, [H1, 'sin(w * t)']]. is evaluated to. Qobj(t) = H0 + H1 * sin(args['w'] * t). Parameters; ----------; qobj_list : list; A nested list of Qobj instances and corresponding time-dependent; coefficients.; t : float; The time for which to evaluate the time-dependent Qobj instance.; args : dictionary; A dictionary with parameter values required to evaluate the; time-dependent Qobj intance. Returns; -------; output : :class:`qutip.Qobj`; A Qobj instance that represents the value of qobj_list at time t. """""". q_sum = 0; if isinstance(qobj_list, Qobj):; q_sum = qobj_list; elif isinstance(qobj_list, list):; for q in qobj_list:; if isinstance(q, Qobj):; q_sum += q; elif (isinstance(q, list) and len(q) == 2 and; isinstance(q[0], Qobj)):; if isinstance(q[1], types.FunctionType):; q_sum += q[0] * q[1](t, args); elif isinstance(q[1], str):; args['t'] = t; q_sum += q[0] * float(eval(q[1], globals(), args)); else:; raise TypeError('Unrecognized format for ' +; 'specification of time-dependent Qobj'); else:; raise TypeError('Unrecognized format for specification ' +; 'of time-dependent Qobj'); else:; raise TypeError(; 'Unrecongized format for specification of time-dependent Qobj'). return q_sum. # -----------------------------------------------------------------------------; # This functions evaluates a time-dependent quantum object on the list-string; # and list-function formats that are used by the time-dependent solvers.; # Although not used directly in by those solvers, it can for test purposes be; # conventient to be able to evaluate the expressions passed to the solver for; # arbitrary value of time. This function provides this functionality.; #; [docs]def qobj_list_evaluate(qobj_list, t, args):; """"""; Deprecated: See Qobj.evaluate; """"""; warnings.warn(""Deprecated: Use Qobj.evaluate"", DeprecationWarning); return Qobj.evaluate(qobj_list, t, args). # -----------------------------------------------------------------------------; #; # A collection of tests",MatchSource.WIKI,docs/4.7/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qobj.html
https://qutip.org/docs/4.7/modules/qutip/qobj.html:52613,Integrability,depend,dependent,52613,"args). and. qobj_list = [H0, [H1, 'sin(w * t)']]. is evaluated to. Qobj(t) = H0 + H1 * sin(args['w'] * t). Parameters; ----------; qobj_list : list; A nested list of Qobj instances and corresponding time-dependent; coefficients.; t : float; The time for which to evaluate the time-dependent Qobj instance.; args : dictionary; A dictionary with parameter values required to evaluate the; time-dependent Qobj intance. Returns; -------; output : :class:`qutip.Qobj`; A Qobj instance that represents the value of qobj_list at time t. """""". q_sum = 0; if isinstance(qobj_list, Qobj):; q_sum = qobj_list; elif isinstance(qobj_list, list):; for q in qobj_list:; if isinstance(q, Qobj):; q_sum += q; elif (isinstance(q, list) and len(q) == 2 and; isinstance(q[0], Qobj)):; if isinstance(q[1], types.FunctionType):; q_sum += q[0] * q[1](t, args); elif isinstance(q[1], str):; args['t'] = t; q_sum += q[0] * float(eval(q[1], globals(), args)); else:; raise TypeError('Unrecognized format for ' +; 'specification of time-dependent Qobj'); else:; raise TypeError('Unrecognized format for specification ' +; 'of time-dependent Qobj'); else:; raise TypeError(; 'Unrecongized format for specification of time-dependent Qobj'). return q_sum. # -----------------------------------------------------------------------------; # This functions evaluates a time-dependent quantum object on the list-string; # and list-function formats that are used by the time-dependent solvers.; # Although not used directly in by those solvers, it can for test purposes be; # conventient to be able to evaluate the expressions passed to the solver for; # arbitrary value of time. This function provides this functionality.; #; [docs]def qobj_list_evaluate(qobj_list, t, args):; """"""; Deprecated: See Qobj.evaluate; """"""; warnings.warn(""Deprecated: Use Qobj.evaluate"", DeprecationWarning); return Qobj.evaluate(qobj_list, t, args). # -----------------------------------------------------------------------------; #; # A collection of tests",MatchSource.WIKI,docs/4.7/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qobj.html
https://qutip.org/docs/4.7/modules/qutip/qobj.html:52703,Integrability,depend,dependent,52703,"args). and. qobj_list = [H0, [H1, 'sin(w * t)']]. is evaluated to. Qobj(t) = H0 + H1 * sin(args['w'] * t). Parameters; ----------; qobj_list : list; A nested list of Qobj instances and corresponding time-dependent; coefficients.; t : float; The time for which to evaluate the time-dependent Qobj instance.; args : dictionary; A dictionary with parameter values required to evaluate the; time-dependent Qobj intance. Returns; -------; output : :class:`qutip.Qobj`; A Qobj instance that represents the value of qobj_list at time t. """""". q_sum = 0; if isinstance(qobj_list, Qobj):; q_sum = qobj_list; elif isinstance(qobj_list, list):; for q in qobj_list:; if isinstance(q, Qobj):; q_sum += q; elif (isinstance(q, list) and len(q) == 2 and; isinstance(q[0], Qobj)):; if isinstance(q[1], types.FunctionType):; q_sum += q[0] * q[1](t, args); elif isinstance(q[1], str):; args['t'] = t; q_sum += q[0] * float(eval(q[1], globals(), args)); else:; raise TypeError('Unrecognized format for ' +; 'specification of time-dependent Qobj'); else:; raise TypeError('Unrecognized format for specification ' +; 'of time-dependent Qobj'); else:; raise TypeError(; 'Unrecongized format for specification of time-dependent Qobj'). return q_sum. # -----------------------------------------------------------------------------; # This functions evaluates a time-dependent quantum object on the list-string; # and list-function formats that are used by the time-dependent solvers.; # Although not used directly in by those solvers, it can for test purposes be; # conventient to be able to evaluate the expressions passed to the solver for; # arbitrary value of time. This function provides this functionality.; #; [docs]def qobj_list_evaluate(qobj_list, t, args):; """"""; Deprecated: See Qobj.evaluate; """"""; warnings.warn(""Deprecated: Use Qobj.evaluate"", DeprecationWarning); return Qobj.evaluate(qobj_list, t, args). # -----------------------------------------------------------------------------; #; # A collection of tests",MatchSource.WIKI,docs/4.7/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qobj.html
https://qutip.org/docs/4.7/modules/qutip/qobj.html:52850,Integrability,depend,dependent,52850,"ith parameter values required to evaluate the; time-dependent Qobj intance. Returns; -------; output : :class:`qutip.Qobj`; A Qobj instance that represents the value of qobj_list at time t. """""". q_sum = 0; if isinstance(qobj_list, Qobj):; q_sum = qobj_list; elif isinstance(qobj_list, list):; for q in qobj_list:; if isinstance(q, Qobj):; q_sum += q; elif (isinstance(q, list) and len(q) == 2 and; isinstance(q[0], Qobj)):; if isinstance(q[1], types.FunctionType):; q_sum += q[0] * q[1](t, args); elif isinstance(q[1], str):; args['t'] = t; q_sum += q[0] * float(eval(q[1], globals(), args)); else:; raise TypeError('Unrecognized format for ' +; 'specification of time-dependent Qobj'); else:; raise TypeError('Unrecognized format for specification ' +; 'of time-dependent Qobj'); else:; raise TypeError(; 'Unrecongized format for specification of time-dependent Qobj'). return q_sum. # -----------------------------------------------------------------------------; # This functions evaluates a time-dependent quantum object on the list-string; # and list-function formats that are used by the time-dependent solvers.; # Although not used directly in by those solvers, it can for test purposes be; # conventient to be able to evaluate the expressions passed to the solver for; # arbitrary value of time. This function provides this functionality.; #; [docs]def qobj_list_evaluate(qobj_list, t, args):; """"""; Deprecated: See Qobj.evaluate; """"""; warnings.warn(""Deprecated: Use Qobj.evaluate"", DeprecationWarning); return Qobj.evaluate(qobj_list, t, args). # -----------------------------------------------------------------------------; #; # A collection of tests used to determine the type of quantum objects, and some; # functions for increased compatibility with quantum optics toolbox.; #; [docs]def dag(A):; """"""Adjont operator (dagger) of a quantum object. Parameters; ----------; A : :class:`qutip.Qobj`; Input quantum object. Returns; -------; oper : :class:`qutip.Qobj`; Adjoint of input operator",MatchSource.WIKI,docs/4.7/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qobj.html
https://qutip.org/docs/4.7/modules/qutip/qobj.html:52949,Integrability,depend,dependent,52949,"ith parameter values required to evaluate the; time-dependent Qobj intance. Returns; -------; output : :class:`qutip.Qobj`; A Qobj instance that represents the value of qobj_list at time t. """""". q_sum = 0; if isinstance(qobj_list, Qobj):; q_sum = qobj_list; elif isinstance(qobj_list, list):; for q in qobj_list:; if isinstance(q, Qobj):; q_sum += q; elif (isinstance(q, list) and len(q) == 2 and; isinstance(q[0], Qobj)):; if isinstance(q[1], types.FunctionType):; q_sum += q[0] * q[1](t, args); elif isinstance(q[1], str):; args['t'] = t; q_sum += q[0] * float(eval(q[1], globals(), args)); else:; raise TypeError('Unrecognized format for ' +; 'specification of time-dependent Qobj'); else:; raise TypeError('Unrecognized format for specification ' +; 'of time-dependent Qobj'); else:; raise TypeError(; 'Unrecongized format for specification of time-dependent Qobj'). return q_sum. # -----------------------------------------------------------------------------; # This functions evaluates a time-dependent quantum object on the list-string; # and list-function formats that are used by the time-dependent solvers.; # Although not used directly in by those solvers, it can for test purposes be; # conventient to be able to evaluate the expressions passed to the solver for; # arbitrary value of time. This function provides this functionality.; #; [docs]def qobj_list_evaluate(qobj_list, t, args):; """"""; Deprecated: See Qobj.evaluate; """"""; warnings.warn(""Deprecated: Use Qobj.evaluate"", DeprecationWarning); return Qobj.evaluate(qobj_list, t, args). # -----------------------------------------------------------------------------; #; # A collection of tests used to determine the type of quantum objects, and some; # functions for increased compatibility with quantum optics toolbox.; #; [docs]def dag(A):; """"""Adjont operator (dagger) of a quantum object. Parameters; ----------; A : :class:`qutip.Qobj`; Input quantum object. Returns; -------; oper : :class:`qutip.Qobj`; Adjoint of input operator",MatchSource.WIKI,docs/4.7/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qobj.html
https://qutip.org/docs/4.7/modules/qutip/qobj.html:60596,Integrability,depend,dependencies,60596,"or. Parameters; ----------; Q : :class:`qutip.Qobj`; Quantum object. Returns; -------; issuper : bool; True if Qobj is superoperator, False otherwise. Notes; -----; This function is for legacy compatibility only. Using the `Qobj.issuper`; attribute is recommended. """"""; return True if isinstance(Q, Qobj) and Q.issuper else False. [docs]def isequal(A, B, tol=None):; """"""Determines if two qobj objects are equal to within given tolerance. Parameters; ----------; A : :class:`qutip.Qobj`; Qobj one; B : :class:`qutip.Qobj`; Qobj two; tol : float; Tolerence for equality to be valid. Returns; -------; isequal : bool; True if qobjs are equal, False otherwise. Notes; -----; This function is for legacy compatibility only. Instead, it is recommended; to use the equality operator of Qobj instances instead: A == B. """"""; if tol is None:; tol = settings.atol. if not isinstance(A, Qobj) or not isinstance(B, Qobj):; return False. if A.dims != B.dims:; return False. Adat = A.data; Bdat = B.data; elems = (Adat - Bdat).data; if np.any(np.abs(elems) > tol):; return False. return True. [docs]def isherm(Q):; """"""Determines if given operator is Hermitian. Parameters; ----------; Q : :class:`qutip.Qobj`; Quantum object. Returns; -------; isherm : bool; True if operator is Hermitian, False otherwise. Examples; --------; >>> a = destroy(4); >>> isherm(a); False. Notes; -----; This function is for legacy compatibility only. Using the `Qobj.isherm`; attribute is recommended. """"""; return True if isinstance(Q, Qobj) and Q.isherm else False. # TRAILING IMPORTS; # We do a few imports here to avoid circular dependencies.; from qutip.eseries import eseries; import qutip.superop_reps as sr; import qutip.tensor as tensor; import qutip.operators as ops; import qutip.metrics as mts; import qutip.states; import qutip.superoperator. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qobj.html
https://qutip.org/docs/4.7/modules/qutip/qobj.html:5737,Performance,perform,performing,5737,"; Dual channel of quantum object representing a CP map.; eigenenergies(sparse=False, sort='low', eigvals=0, tol=0, maxiter=100000); Returns eigenenergies (eigenvalues) of a quantum object.; eigenstates(sparse=False, sort='low', eigvals=0, tol=0, maxiter=100000); Returns eigenenergies and eigenstates of quantum object.; expm(); Matrix exponential of quantum object.; full(order='C'); Returns dense array of quantum object `data` attribute.; groundstate(sparse=False, tol=0, maxiter=100000); Returns eigenvalue and eigenket for the groundstate of a quantum; object.; inv(); Return a Qobj corresponding to the matrix inverse of the operator.; matrix_element(bra, ket); Returns the matrix element of operator between `bra` and `ket` vectors.; norm(norm='tr', sparse=False, tol=0, maxiter=100000); Returns norm of a ket or an operator.; permute(order); Returns composite qobj with indices reordered.; proj(); Computes the projector for a ket or bra vector.; ptrace(sel); Returns quantum object for selected dimensions after performing; partial trace.; sinm(); Sine of quantum object.; sqrtm(); Matrix square root of quantum object.; tidyup(atol=1e-12); Removes small elements from quantum object.; tr(); Trace of quantum object.; trans(); Transpose of quantum object.; transform(inpt, inverse=False); Performs a basis transformation defined by `inpt` matrix.; trunc_neg(method='clip'); Removes negative eigenvalues and returns a new Qobj that is; a valid density operator.; unit(norm='tr', sparse=False, tol=0, maxiter=100000); Returns normalized quantum object. """"""; __array_priority__ = 100 # sets Qobj priority above numpy arrays; # Disable ufuncs from acting directly on Qobj. This is necessary because we; # define __array__.; __array_ufunc__ = None. def __init__(self, inpt=None, dims=None, shape=None,; type=None, isherm=None, copy=True,; fast=False, superrep=None, isunitary=None):; """"""; Qobj constructor.; """"""; self._isherm = isherm; self._type = type; self.superrep = superrep; self._isunitary",MatchSource.WIKI,docs/4.7/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qobj.html
https://qutip.org/docs/4.7/modules/qutip/qobj.html:10529,Performance,cache,cache,10529," shape.; if dims is None and self.shape[0] == self.shape[1]:; sub_shape = np.sqrt(self.shape[0]); # check if root of shape is int; if (sub_shape % 1) != 0:; raise Exception('Invalid shape for a super operator.'); else:; sub_shape = int(sub_shape); self.dims = [[[sub_shape], [sub_shape]]]*2. if superrep:; self.superrep = superrep; else:; if self.type == 'super' and self.superrep is None:; self.superrep = 'super'. # While the obvious check would be != that would fail valid; # use cases such as enr_fock and other enr_ functions.; # This does leave open the possibility of data still being; # misused such as Qobj(complex[n**2][1], dims = [[n],[n]]); dims_size = (; np.prod(flatten(self.dims[0]), dtype=np.int64),; np.prod(flatten(self.dims[1]), dtype=np.int64); ); shape = self._data.shape; if (; (shape[0] > dims_size[0] or shape[1] > dims_size[1]); and self.type != 'super'; ):; raise ValueError(f""Qobj has smaller dims {self.dims} "" +; f""than underlying shape {self._data.shape}""). # clear type cache; self._type = None. [docs] def copy(self):; """"""Create identical copy""""""; return Qobj(inpt=self). def get_data(self):; return self._data. # Here we perfrom a check of the csr matrix type during setting of Q.data; def set_data(self, data):; if not isinstance(data, fast_csr_matrix):; raise TypeError('Qobj data must be in fast_csr format.'); else:; self._data = data; data = property(get_data, set_data). def __add__(self, other):; """"""; ADDITION with Qobj on LEFT [ ex. Qobj+4 ]; """"""; self._isunitary = None. if isinstance(other, eseries):; return other.__radd__(self). if not isinstance(other, Qobj):; if isinstance(other, (int, float, complex, np.integer, np.floating,; np.complexfloating, np.ndarray, list, tuple)) \; or sp.issparse(other):; other = Qobj(other); else:; return NotImplemented. if np.prod(other.shape) == 1 and np.prod(self.shape) != 1:; # case for scalar quantum object; dat = other.data[0, 0]; if dat == 0:; return self. out = Qobj(). if self.type in ['oper', 'super']:; out.",MatchSource.WIKI,docs/4.7/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qobj.html
https://qutip.org/docs/4.7/modules/qutip/qobj.html:21284,Performance,load,loading,21284,"tically serialize a Qobj into a string,; # so we simply return the informal __str__ representation instead.); return self.__str__(). def __call__(self, other):; """"""; Acts this Qobj on another Qobj either by left-multiplication,; or by vectorization and devectorization, as; appropriate.; """"""; if not isinstance(other, Qobj):; raise TypeError(""Only defined for quantum objects.""). if self.type == ""super"":; if other.type == ""ket"":; other = qutip.states.ket2dm(other). if other.type == ""oper"":; return qutip.superoperator.vector_to_operator(; self * qutip.superoperator.operator_to_vector(other); ); else:; raise TypeError(""Can only act super on oper or ket.""). elif self.type == ""oper"":; if other.type == ""ket"":; return self * other; else:; raise TypeError(""Can only act oper on ket.""). def __getstate__(self):; # defines what happens when Qobj object gets pickled; self.__dict__.update({'qutip_version': __version__[:5]}); return self.__dict__. def __setstate__(self, state):; # defines what happens when loading a pickled Qobj; if 'qutip_version' in state.keys():; del state['qutip_version']; (self.__dict__).update(state). def _repr_latex_(self):; """"""; Generate a LaTeX representation of the Qobj instance. Can be used for; formatted output in ipython notebook.; """"""; t = self.type; shape = self.shape; s = r''; if self.type in ['oper', 'super']:; s += (""Quantum object: "" +; ""dims = "" + str(self.dims) +; "", shape = "" + str(shape) +; "", type = "" + t +; "", isherm = "" + str(self.isherm) +; (; "", superrep = {0.superrep}"".format(self); if t == ""super"" and self.superrep != ""super""; else """"; )); else:; s += (""Quantum object: "" +; ""dims = "" + str(self.dims) +; "", shape = "" + str(shape) +; "", type = "" + t). M, N = self.data.shape. s += r' $ \\ \left(\begin{matrix}'. def _format_float(value):; if value == 0.0:; return ""0.0""; elif abs(value) > 1000.0 or abs(value) < 0.001:; return (""%.3e"" % value).replace(""e"", r""\times10^{"") + ""}""; elif abs(value - int(value)) < 0.001:; return ""%.1f"" % value; else",MatchSource.WIKI,docs/4.7/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qobj.html
https://qutip.org/docs/4.7/modules/qutip/qobj.html:25772,Performance,perform,performed,25772,"tensor_idxs[0][0])) +; list(zip(tensor_idxs[1][1], tensor_idxs[1][0])); )).trans(); J_dual.superrep = 'choi'; return J_dual. [docs] def conj(self):; """"""Conjugate operator of quantum object.; """"""; out = Qobj(); out.data = self.data.conj(); out.dims = [self.dims[0], self.dims[1]]; return out. [docs] def norm(self, norm=None, sparse=False, tol=0, maxiter=100000):; """"""Norm of a quantum object. Default norm is L2-norm for kets and trace-norm for operators.; Other ket and operator norms may be specified using the `norm` and; argument. Parameters; ----------; norm : str; Which norm to use for ket/bra vectors: L2 'l2', max norm 'max',; or for operators: trace 'tr', Frobius 'fro', one 'one', or max; 'max'. sparse : bool; Use sparse eigenvalue solver for trace norm. Other norms are not; affected by this parameter. tol : float; Tolerance for sparse solver (if used) for trace norm. The sparse; solver may not converge if the tolerance is set too low. maxiter : int; Maximum number of iterations performed by sparse solver (if used); for trace norm. Returns; -------; norm : float; The requested norm of the operator or state quantum object. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; if self.type in ['oper', 'super']:; if norm is None or norm == 'tr':; _op = self.data * zcsr_adjoint(self.data); vals = sp_eigs(_op, True, vecs=False,; sparse=sparse, tol=tol, maxiter=maxiter); return np.sum(np.sqrt(np.abs(vals))); elif norm == 'fro':; return sp_fro_norm(self.data); elif norm == 'one':; return sp_one_norm(self.data); elif norm == 'max':; return sp_max_norm(self.data); else:; raise ValueError(; ""For matrices, norm must be 'tr', 'fro', 'one', or 'max'.""); else:; if norm is None or norm == 'l2':; return sp_L2_norm(self.data); elif norm == 'max':; return sp_max_norm(self.data); else:; raise ValueError(""For vectors, norm must be 'l2', or 'max'.""). [docs] def proj(self):; """"""Form the projector from a given",MatchSource.WIKI,docs/4.7/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qobj.html
https://qutip.org/docs/4.7/modules/qutip/qobj.html:32776,Performance,perform,performed,32776,"e:; raise TypeError('Invalid operand for matrix square root'). [docs] def inv(self, sparse=False):; """"""Matrix inverse of a quantum operator. Operator must be square. Returns; -------; oper : :class:`qutip.Qobj`; Matrix inverse of operator. Raises; ------; TypeError; Quantum object is not square.; """"""; if self.shape[0] != self.shape[1]:; raise TypeError('Invalid operand for matrix inverse'); if sparse:; inv_mat = sp.linalg.inv(sp.csc_matrix(self.data)); else:; inv_mat = np.linalg.inv(self.full()); return Qobj(inv_mat, dims=self.dims[::-1]). [docs] def unit(self, inplace=False,; norm=None, sparse=False,; tol=0, maxiter=100000):; """"""Operator or state normalized to unity. Uses norm from Qobj.norm(). Parameters; ----------; inplace : bool; Do an in-place normalization; norm : str; Requested norm for states / operators.; sparse : bool; Use sparse eigensolver for trace norm. Does not affect other norms.; tol : float; Tolerance used by sparse eigensolver.; maxiter : int; Number of maximum iterations performed by sparse eigensolver. Returns; -------; oper : :class:`qutip.Qobj`; Normalized quantum object if not in-place,; else None. """"""; if inplace:; nrm = self.norm(norm=norm, sparse=sparse,; tol=tol, maxiter=maxiter). self.data /= nrm; elif not inplace:; out = self / self.norm(norm=norm, sparse=sparse,; tol=tol, maxiter=maxiter); if settings.auto_tidyup:; return out.tidyup(); else:; return out; else:; raise Exception('inplace kwarg must be bool.'). [docs] def ptrace(self, sel, sparse=None):; """"""Partial trace of the quantum object. Parameters; ----------; sel : int/list; An ``int`` or ``list`` of components to keep after partial trace.; The order is unimportant; no transposition will be done and the; spaces will remain in the same order in the output. Returns; -------; oper : :class:`qutip.Qobj`; Quantum object representing partial trace with selected components; remaining. Notes; -----; This function is identical to the :func:`qutip.qobj.ptrace` function; that has been depre",MatchSource.WIKI,docs/4.7/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qobj.html
https://qutip.org/docs/4.7/modules/qutip/qobj.html:40252,Performance,optimiz,optimized,40252,"+= "" and ket vectors.""; raise TypeError(err). [docs] def overlap(self, other):; """"""Overlap between two state vectors or two operators. Gives the overlap (inner product) between the current bra or ket Qobj; and and another bra or ket Qobj. It gives the Hilbert-Schmidt overlap; when one of the Qobj is an operator/density matrix. Parameters; -----------; other : :class:`qutip.Qobj`; Quantum object for a state vector of type 'ket', 'bra' or density; matrix. Returns; -------; overlap : complex; Complex valued overlap. Raises; ------; TypeError; Can only calculate overlap between a bra, ket and density matrix; quantum objects. Notes; -----; Since QuTiP mainly deals with ket vectors, the most efficient inner; product call is the ket-ket version that computes the product; <self|other> with both vectors expressed as kets.; """""". if isinstance(other, Qobj):. if self.isbra:; if other.isket:; return zcsr_inner(self.data, other.data, 1); elif other.isbra:; # Since we deal mainly with ket vectors, the bra-bra combo; # is not common, and not optimized.; return zcsr_inner(self.data, other.dag().data, 1); elif other.isoper:; return (qutip.states.ket2dm(self).dag() * other).tr(); else:; err = ""Can only calculate overlap for state vector Qobjs""; raise TypeError(err). elif self.isket:; if other.isbra:; return zcsr_inner(other.data, self.data, 1); elif other.isket:; return zcsr_inner(self.data, other.data, 0); elif other.isoper:; return (qutip.states.ket2dm(self).dag() * other).tr(); else:; err = ""Can only calculate overlap for state vector Qobjs""; raise TypeError(err). elif self.isoper:; if other.isket or other.isbra:; return (self.dag() * qutip.states.ket2dm(other)).tr(); elif other.isoper:; return (self.dag() * other).tr(); else:; err = ""Can only calculate overlap for state vector Qobjs""; raise TypeError(err); raise TypeError(""Can only calculate overlap for state vector Qobjs""). [docs] def eigenstates(self, sparse=False, sort='low', eigvals=0,; tol=0, maxiter=100000, phase_fix=None):; ",MatchSource.WIKI,docs/4.7/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qobj.html
https://qutip.org/docs/4.7/modules/qutip/qobj.html:41730,Performance,perform,performed,41730,"ate overlap for state vector Qobjs""; raise TypeError(err). elif self.isoper:; if other.isket or other.isbra:; return (self.dag() * qutip.states.ket2dm(other)).tr(); elif other.isoper:; return (self.dag() * other).tr(); else:; err = ""Can only calculate overlap for state vector Qobjs""; raise TypeError(err); raise TypeError(""Can only calculate overlap for state vector Qobjs""). [docs] def eigenstates(self, sparse=False, sort='low', eigvals=0,; tol=0, maxiter=100000, phase_fix=None):; """"""Eigenstates and eigenenergies. Eigenstates and eigenenergies are defined for operators and; superoperators only. Parameters; ----------; sparse : bool; Use sparse Eigensolver. sort : str; Sort eigenvalues (and vectors) 'low' to high, or 'high' to low. eigvals : int; Number of requested eigenvalues. Default is all eigenvalues. tol : float; Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiter : int; Maximum number of iterations performed by sparse solver (if used). phase_fix : int, None; If not None, set the phase of each kets so that ket[phase_fix,0]; is real positive. Returns; -------; eigvals : array; Array of eigenvalues for operator. eigvecs : array; Array of quantum operators representing the oprator eigenkets.; Order of eigenkets is determined by order of eigenvalues. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; evals, evecs = sp_eigs(self.data, self.isherm, sparse=sparse,; sort=sort, eigvals=eigvals, tol=tol,; maxiter=maxiter); if self.type == 'super':; new_dims = [self.dims[0], [1]]; new_type = 'operator-ket'; else:; new_dims = [self.dims[0], [1] * len(self.dims[0])]; new_type = 'ket'; ekets = np.empty((len(evecs),), dtype=object); ekets[:] = [Qobj(vec, dims=new_dims, type=new_type) for vec in evecs]; norms = np.array([ket.norm() for ket in ekets]); if phase_fix is None:; phase = np.array([1] * len(ekets)); els",MatchSource.WIKI,docs/4.7/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qobj.html
https://qutip.org/docs/4.7/modules/qutip/qobj.html:43482,Performance,perform,performed,43482,"; new_type = 'ket'; ekets = np.empty((len(evecs),), dtype=object); ekets[:] = [Qobj(vec, dims=new_dims, type=new_type) for vec in evecs]; norms = np.array([ket.norm() for ket in ekets]); if phase_fix is None:; phase = np.array([1] * len(ekets)); else:; phase = np.array([np.abs(ket[phase_fix, 0]) / ket[phase_fix, 0]; if ket[phase_fix, 0] else 1; for ket in ekets]); return evals, ekets / norms * phase. [docs] def eigenenergies(self, sparse=False, sort='low',; eigvals=0, tol=0, maxiter=100000):; """"""Eigenenergies of a quantum object. Eigenenergies (eigenvalues) are defined for operators or superoperators; only. Parameters; ----------; sparse : bool; Use sparse Eigensolver; sort : str; Sort eigenvalues 'low' to high, or 'high' to low.; eigvals : int; Number of requested eigenvalues. Default is all eigenvalues.; tol : float; Tolerance used by sparse Eigensolver (0=machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter : int; Maximum number of iterations performed by sparse solver (if used). Returns; -------; eigvals : array; Array of eigenvalues for operator. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; return sp_eigs(self.data, self.isherm, vecs=False, sparse=sparse,; sort=sort, eigvals=eigvals, tol=tol, maxiter=maxiter). [docs] def groundstate(self, sparse=False, tol=0, maxiter=100000, safe=True):; """"""Ground state Eigenvalue and Eigenvector. Defined for quantum operators or superoperators only. Parameters; ----------; sparse : bool; Use sparse Eigensolver; tol : float; Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter : int; Maximum number of iterations performed by sparse solver (if used).; safe : bool (default=True); Check for degenerate ground state. Returns; -------; eigval : float; Eigenvalue for the ground state of quantum operator.; eigvec : :class",MatchSource.WIKI,docs/4.7/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qobj.html
https://qutip.org/docs/4.7/modules/qutip/qobj.html:44273,Performance,perform,performed,44273,"fault is all eigenvalues.; tol : float; Tolerance used by sparse Eigensolver (0=machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter : int; Maximum number of iterations performed by sparse solver (if used). Returns; -------; eigvals : array; Array of eigenvalues for operator. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; return sp_eigs(self.data, self.isherm, vecs=False, sparse=sparse,; sort=sort, eigvals=eigvals, tol=tol, maxiter=maxiter). [docs] def groundstate(self, sparse=False, tol=0, maxiter=100000, safe=True):; """"""Ground state Eigenvalue and Eigenvector. Defined for quantum operators or superoperators only. Parameters; ----------; sparse : bool; Use sparse Eigensolver; tol : float; Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter : int; Maximum number of iterations performed by sparse solver (if used).; safe : bool (default=True); Check for degenerate ground state. Returns; -------; eigval : float; Eigenvalue for the ground state of quantum operator.; eigvec : :class:`qutip.Qobj`; Eigenket for the ground state of quantum operator. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; if safe:; evals = 2; else:; evals = 1; grndval, grndvec = sp_eigs(self.data, self.isherm, sparse=sparse,; eigvals=evals, tol=tol, maxiter=maxiter); if safe:; tol = 1e-15 if tol == 0 else tol; if (grndval[1]-grndval[0]) <= 10*tol:; print(""WARNING: Ground state may be degenerate. ""; ""Use Q.eigenstates()""); new_dims = [self.dims[0], [1] * len(self.dims[0])]; grndvec = Qobj(grndvec[0], dims=new_dims); grndvec = grndvec / grndvec.norm(); return grndval[0], grndvec. [docs] def trans(self):; """"""Transposed operator. Returns; -------; oper : :class:`qutip.Qobj`; Transpose of input operator. """""";",MatchSource.WIKI,docs/4.7/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qobj.html
https://qutip.org/docs/4.7/modules/qutip/qobj.html:47806,Performance,cache,cached,47806,"normalized should probably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; should be False. Returns; -------; q : :class:`qutip.Qobj`; A new instance of :class:`qutip.Qobj` that contains only the states; corresponding to indices that are **not** in `state_inds`. Notes; -----; Experimental. """"""; keep_indices = np.array([s not in states_inds; for s in range(self.shape[0])]).nonzero()[0]. return self.extract_states(keep_indices, normalize=normalize). [docs] def dnorm(self, B=None):; """"""Calculates the diamond norm, or the diamond distance to another; operator. Parameters; ----------; B : :class:`qutip.Qobj` or None; If B is not None, the diamond distance d(A, B) = dnorm(A - B); between this operator and B is returned instead of the diamond; norm. Returns; -------; d : float; Either the diamond norm of this operator, or the diamond distance; from this operator to B. """"""; return mts.dnorm(self, B). @property; def ishp(self):; # FIXME: this needs to be cached in the same ways as isherm.; if self.type in [""super"", ""oper""]:; try:; J = sr.to_choi(self); return J.isherm; except TypeError:; return False; else:; return False. @property; def iscp(self):; # FIXME: this needs to be cached in the same ways as isherm.; if self.type in [""super"", ""oper""]:; try:; J = (; self; # We can test with either Choi or chi, since the basis; # transformation between them is unitary and hence; # preserves the CP and TP conditions.; if self.superrep in ('choi', 'chi'); else sr.to_choi(self); ); # If J isn't hermitian, then that could indicate either; # that J is not normal, or is normal,; # but has complex eigenvalues.; # In either case, it makes no sense to then demand that the; # eigenvalues be non-negative.; if not J.isherm:; return False; eigs = J.eigenenergies(); return all(eigs >= -settings.atol); except TypeError:; return False; else:; return False. @property; def istp(self):; import qutip.superop_reps as sr; if self.type in [""super"", ""oper""]:",MatchSource.WIKI,docs/4.7/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qobj.html
https://qutip.org/docs/4.7/modules/qutip/qobj.html:48031,Performance,cache,cached,48031,"hat contains only the states; corresponding to indices that are **not** in `state_inds`. Notes; -----; Experimental. """"""; keep_indices = np.array([s not in states_inds; for s in range(self.shape[0])]).nonzero()[0]. return self.extract_states(keep_indices, normalize=normalize). [docs] def dnorm(self, B=None):; """"""Calculates the diamond norm, or the diamond distance to another; operator. Parameters; ----------; B : :class:`qutip.Qobj` or None; If B is not None, the diamond distance d(A, B) = dnorm(A - B); between this operator and B is returned instead of the diamond; norm. Returns; -------; d : float; Either the diamond norm of this operator, or the diamond distance; from this operator to B. """"""; return mts.dnorm(self, B). @property; def ishp(self):; # FIXME: this needs to be cached in the same ways as isherm.; if self.type in [""super"", ""oper""]:; try:; J = sr.to_choi(self); return J.isherm; except TypeError:; return False; else:; return False. @property; def iscp(self):; # FIXME: this needs to be cached in the same ways as isherm.; if self.type in [""super"", ""oper""]:; try:; J = (; self; # We can test with either Choi or chi, since the basis; # transformation between them is unitary and hence; # preserves the CP and TP conditions.; if self.superrep in ('choi', 'chi'); else sr.to_choi(self); ); # If J isn't hermitian, then that could indicate either; # that J is not normal, or is normal,; # but has complex eigenvalues.; # In either case, it makes no sense to then demand that the; # eigenvalues be non-negative.; if not J.isherm:; return False; eigs = J.eigenenergies(); return all(eigs >= -settings.atol); except TypeError:; return False; else:; return False. @property; def istp(self):; import qutip.superop_reps as sr; if self.type in [""super"", ""oper""]:; try:; # Normalize to a super of type choi or chi.; # We can test with either Choi or chi, since the basis; # transformation between them is unitary and hence; # preserves the CP and TP conditions.; if self.type == ""super"" a",MatchSource.WIKI,docs/4.7/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qobj.html
https://qutip.org/docs/4.7/modules/qutip/qobj.html:43910,Safety,safe,safe,43910,"s(self, sparse=False, sort='low',; eigvals=0, tol=0, maxiter=100000):; """"""Eigenenergies of a quantum object. Eigenenergies (eigenvalues) are defined for operators or superoperators; only. Parameters; ----------; sparse : bool; Use sparse Eigensolver; sort : str; Sort eigenvalues 'low' to high, or 'high' to low.; eigvals : int; Number of requested eigenvalues. Default is all eigenvalues.; tol : float; Tolerance used by sparse Eigensolver (0=machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter : int; Maximum number of iterations performed by sparse solver (if used). Returns; -------; eigvals : array; Array of eigenvalues for operator. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; return sp_eigs(self.data, self.isherm, vecs=False, sparse=sparse,; sort=sort, eigvals=eigvals, tol=tol, maxiter=maxiter). [docs] def groundstate(self, sparse=False, tol=0, maxiter=100000, safe=True):; """"""Ground state Eigenvalue and Eigenvector. Defined for quantum operators or superoperators only. Parameters; ----------; sparse : bool; Use sparse Eigensolver; tol : float; Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter : int; Maximum number of iterations performed by sparse solver (if used).; safe : bool (default=True); Check for degenerate ground state. Returns; -------; eigval : float; Eigenvalue for the ground state of quantum operator.; eigvec : :class:`qutip.Qobj`; Eigenket for the ground state of quantum operator. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; if safe:; evals = 2; else:; evals = 1; grndval, grndvec = sp_eigs(self.data, self.isherm, sparse=sparse,; eigvals=evals, tol=tol, maxiter=maxiter); if safe:; tol = 1e-15 if tol == 0 else tol; if (grndval[1]-grndval[0]) <= 10*tol:",MatchSource.WIKI,docs/4.7/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qobj.html
https://qutip.org/docs/4.7/modules/qutip/qobj.html:44312,Safety,safe,safe,44312,"er (0=machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter : int; Maximum number of iterations performed by sparse solver (if used). Returns; -------; eigvals : array; Array of eigenvalues for operator. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; return sp_eigs(self.data, self.isherm, vecs=False, sparse=sparse,; sort=sort, eigvals=eigvals, tol=tol, maxiter=maxiter). [docs] def groundstate(self, sparse=False, tol=0, maxiter=100000, safe=True):; """"""Ground state Eigenvalue and Eigenvector. Defined for quantum operators or superoperators only. Parameters; ----------; sparse : bool; Use sparse Eigensolver; tol : float; Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter : int; Maximum number of iterations performed by sparse solver (if used).; safe : bool (default=True); Check for degenerate ground state. Returns; -------; eigval : float; Eigenvalue for the ground state of quantum operator.; eigvec : :class:`qutip.Qobj`; Eigenket for the ground state of quantum operator. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; if safe:; evals = 2; else:; evals = 1; grndval, grndvec = sp_eigs(self.data, self.isherm, sparse=sparse,; eigvals=evals, tol=tol, maxiter=maxiter); if safe:; tol = 1e-15 if tol == 0 else tol; if (grndval[1]-grndval[0]) <= 10*tol:; print(""WARNING: Ground state may be degenerate. ""; ""Use Q.eigenstates()""); new_dims = [self.dims[0], [1] * len(self.dims[0])]; grndvec = Qobj(grndvec[0], dims=new_dims); grndvec = grndvec / grndvec.norm(); return grndval[0], grndvec. [docs] def trans(self):; """"""Transposed operator. Returns; -------; oper : :class:`qutip.Qobj`; Transpose of input operator. """"""; out = Qobj(); out.data = zcsr_transpose(self.data); out.dims = [self.dim",MatchSource.WIKI,docs/4.7/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qobj.html
https://qutip.org/docs/4.7/modules/qutip/qobj.html:44679,Safety,safe,safe,44679,"mand it. """"""; return sp_eigs(self.data, self.isherm, vecs=False, sparse=sparse,; sort=sort, eigvals=eigvals, tol=tol, maxiter=maxiter). [docs] def groundstate(self, sparse=False, tol=0, maxiter=100000, safe=True):; """"""Ground state Eigenvalue and Eigenvector. Defined for quantum operators or superoperators only. Parameters; ----------; sparse : bool; Use sparse Eigensolver; tol : float; Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter : int; Maximum number of iterations performed by sparse solver (if used).; safe : bool (default=True); Check for degenerate ground state. Returns; -------; eigval : float; Eigenvalue for the ground state of quantum operator.; eigvec : :class:`qutip.Qobj`; Eigenket for the ground state of quantum operator. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; if safe:; evals = 2; else:; evals = 1; grndval, grndvec = sp_eigs(self.data, self.isherm, sparse=sparse,; eigvals=evals, tol=tol, maxiter=maxiter); if safe:; tol = 1e-15 if tol == 0 else tol; if (grndval[1]-grndval[0]) <= 10*tol:; print(""WARNING: Ground state may be degenerate. ""; ""Use Q.eigenstates()""); new_dims = [self.dims[0], [1] * len(self.dims[0])]; grndvec = Qobj(grndvec[0], dims=new_dims); grndvec = grndvec / grndvec.norm(); return grndval[0], grndvec. [docs] def trans(self):; """"""Transposed operator. Returns; -------; oper : :class:`qutip.Qobj`; Transpose of input operator. """"""; out = Qobj(); out.data = zcsr_transpose(self.data); out.dims = [self.dims[1], self.dims[0]]; return out. [docs] def extract_states(self, states_inds, normalize=False):; """"""Qobj with states in state_inds only. Parameters; ----------; states_inds : list of integer; The states that should be kept. normalize : True / False; Weather or not the new Qobj instance should be normalized (default; is False). For Qobjs that represents density matr",MatchSource.WIKI,docs/4.7/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qobj.html
https://qutip.org/docs/4.7/modules/qutip/qobj.html:44827,Safety,safe,safe,44827,"roundstate(self, sparse=False, tol=0, maxiter=100000, safe=True):; """"""Ground state Eigenvalue and Eigenvector. Defined for quantum operators or superoperators only. Parameters; ----------; sparse : bool; Use sparse Eigensolver; tol : float; Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter : int; Maximum number of iterations performed by sparse solver (if used).; safe : bool (default=True); Check for degenerate ground state. Returns; -------; eigval : float; Eigenvalue for the ground state of quantum operator.; eigvec : :class:`qutip.Qobj`; Eigenket for the ground state of quantum operator. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; if safe:; evals = 2; else:; evals = 1; grndval, grndvec = sp_eigs(self.data, self.isherm, sparse=sparse,; eigvals=evals, tol=tol, maxiter=maxiter); if safe:; tol = 1e-15 if tol == 0 else tol; if (grndval[1]-grndval[0]) <= 10*tol:; print(""WARNING: Ground state may be degenerate. ""; ""Use Q.eigenstates()""); new_dims = [self.dims[0], [1] * len(self.dims[0])]; grndvec = Qobj(grndvec[0], dims=new_dims); grndvec = grndvec / grndvec.norm(); return grndval[0], grndvec. [docs] def trans(self):; """"""Transposed operator. Returns; -------; oper : :class:`qutip.Qobj`; Transpose of input operator. """"""; out = Qobj(); out.data = zcsr_transpose(self.data); out.dims = [self.dims[1], self.dims[0]]; return out. [docs] def extract_states(self, states_inds, normalize=False):; """"""Qobj with states in state_inds only. Parameters; ----------; states_inds : list of integer; The states that should be kept. normalize : True / False; Weather or not the new Qobj instance should be normalized (default; is False). For Qobjs that represents density matrices or state; vectors normalized should probably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize",MatchSource.WIKI,docs/4.7/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qobj.html
https://qutip.org/docs/4.7/modules/qutip/qobj.html:60581,Safety,avoid,avoid,60581,"or. Parameters; ----------; Q : :class:`qutip.Qobj`; Quantum object. Returns; -------; issuper : bool; True if Qobj is superoperator, False otherwise. Notes; -----; This function is for legacy compatibility only. Using the `Qobj.issuper`; attribute is recommended. """"""; return True if isinstance(Q, Qobj) and Q.issuper else False. [docs]def isequal(A, B, tol=None):; """"""Determines if two qobj objects are equal to within given tolerance. Parameters; ----------; A : :class:`qutip.Qobj`; Qobj one; B : :class:`qutip.Qobj`; Qobj two; tol : float; Tolerence for equality to be valid. Returns; -------; isequal : bool; True if qobjs are equal, False otherwise. Notes; -----; This function is for legacy compatibility only. Instead, it is recommended; to use the equality operator of Qobj instances instead: A == B. """"""; if tol is None:; tol = settings.atol. if not isinstance(A, Qobj) or not isinstance(B, Qobj):; return False. if A.dims != B.dims:; return False. Adat = A.data; Bdat = B.data; elems = (Adat - Bdat).data; if np.any(np.abs(elems) > tol):; return False. return True. [docs]def isherm(Q):; """"""Determines if given operator is Hermitian. Parameters; ----------; Q : :class:`qutip.Qobj`; Quantum object. Returns; -------; isherm : bool; True if operator is Hermitian, False otherwise. Examples; --------; >>> a = destroy(4); >>> isherm(a); False. Notes; -----; This function is for legacy compatibility only. Using the `Qobj.isherm`; attribute is recommended. """"""; return True if isinstance(Q, Qobj) and Q.isherm else False. # TRAILING IMPORTS; # We do a few imports here to avoid circular dependencies.; from qutip.eseries import eseries; import qutip.superop_reps as sr; import qutip.tensor as tensor; import qutip.operators as ops; import qutip.metrics as mts; import qutip.states; import qutip.superoperator. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qobj.html
https://qutip.org/docs/4.7/modules/qutip/qobj.html:999,Testability,log,log,999,". qutip.qobj — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.qobj. Source code for qutip.qobj; """"""The Quantum Object (Qobj) class, for representing quantum states and; operators, and related functions.; """""". __all__ = ['Qobj', 'qobj_list_evaluate', 'ptrace', 'dag', 'isequal',; 'issuper', 'isoper', 'isoperket', 'isoperbra', 'isket', 'isbra',; 'isherm', 'shape', 'dims']. import warnings; import types; import numbers. try:; import builtins; except ImportError:; import __builtin__ as builtins. # import math functions from numpy.math: required for td string evaluation; from numpy import (arccos, arccosh, arcsin, arcsinh, arctan, arctan2, arctanh,; ceil, copysign, cos, cosh, degrees, e, exp, expm1, fabs,; floor, fmod, frexp, hypot, isinf, isnan, ldexp, log, log10,; log1p, modf, pi, radians, sin, sinh, sqrt, tan, tanh). import numpy as np; import scipy.sparse as sp; import qutip.settings as settings; from qutip import __version__; from qutip.fastsparse import fast_csr_matrix, fast_identity; from qutip.cy.ptrace import _ptrace; from qutip.permute import _permute; from qutip.dimensions import flatten; from qutip.sparse import (; sp_eigs, sp_expm, sp_fro_norm, sp_max_norm, sp_one_norm, sp_L2_norm,; ); from qutip.dimensions import (; type_from_dims, enumerate_flat, collapse_dims_super,; ); from qutip.cy.spmath import (; zcsr_transpose, zcsr_adjoint, zcsr_isherm, zcsr_trace, zcsr_proj,; zcsr_inner,; ); from qutip.cy.spmatfuncs import zcsr_mat_elem; from qutip.cy.sparse_utils import cy_tidyup; import sys; if sys.version_info.major >= 3:; from itertools import zip_longest; elif sys.version_info.major < 3:; from itertools import izip_longest; zip_longest = izip_longest. # OPENMP stuff; from qutip.cy.openmp.utilities import use_openmp; if settin",MatchSource.WIKI,docs/4.7/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qobj.html
https://qutip.org/docs/4.7/modules/qutip/qobj.html:48131,Testability,test,test,48131,"t in states_inds; for s in range(self.shape[0])]).nonzero()[0]. return self.extract_states(keep_indices, normalize=normalize). [docs] def dnorm(self, B=None):; """"""Calculates the diamond norm, or the diamond distance to another; operator. Parameters; ----------; B : :class:`qutip.Qobj` or None; If B is not None, the diamond distance d(A, B) = dnorm(A - B); between this operator and B is returned instead of the diamond; norm. Returns; -------; d : float; Either the diamond norm of this operator, or the diamond distance; from this operator to B. """"""; return mts.dnorm(self, B). @property; def ishp(self):; # FIXME: this needs to be cached in the same ways as isherm.; if self.type in [""super"", ""oper""]:; try:; J = sr.to_choi(self); return J.isherm; except TypeError:; return False; else:; return False. @property; def iscp(self):; # FIXME: this needs to be cached in the same ways as isherm.; if self.type in [""super"", ""oper""]:; try:; J = (; self; # We can test with either Choi or chi, since the basis; # transformation between them is unitary and hence; # preserves the CP and TP conditions.; if self.superrep in ('choi', 'chi'); else sr.to_choi(self); ); # If J isn't hermitian, then that could indicate either; # that J is not normal, or is normal,; # but has complex eigenvalues.; # In either case, it makes no sense to then demand that the; # eigenvalues be non-negative.; if not J.isherm:; return False; eigs = J.eigenenergies(); return all(eigs >= -settings.atol); except TypeError:; return False; else:; return False. @property; def istp(self):; import qutip.superop_reps as sr; if self.type in [""super"", ""oper""]:; try:; # Normalize to a super of type choi or chi.; # We can test with either Choi or chi, since the basis; # transformation between them is unitary and hence; # preserves the CP and TP conditions.; if self.type == ""super"" and self.superrep in ('choi', 'chi'):; qobj = self; else:; qobj = sr.to_choi(self). # Possibly collapse dims.; if any(; len(index) > 1; for super_index",MatchSource.WIKI,docs/4.7/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qobj.html
https://qutip.org/docs/4.7/modules/qutip/qobj.html:48858,Testability,test,test,48858,"m; except TypeError:; return False; else:; return False. @property; def iscp(self):; # FIXME: this needs to be cached in the same ways as isherm.; if self.type in [""super"", ""oper""]:; try:; J = (; self; # We can test with either Choi or chi, since the basis; # transformation between them is unitary and hence; # preserves the CP and TP conditions.; if self.superrep in ('choi', 'chi'); else sr.to_choi(self); ); # If J isn't hermitian, then that could indicate either; # that J is not normal, or is normal,; # but has complex eigenvalues.; # In either case, it makes no sense to then demand that the; # eigenvalues be non-negative.; if not J.isherm:; return False; eigs = J.eigenenergies(); return all(eigs >= -settings.atol); except TypeError:; return False; else:; return False. @property; def istp(self):; import qutip.superop_reps as sr; if self.type in [""super"", ""oper""]:; try:; # Normalize to a super of type choi or chi.; # We can test with either Choi or chi, since the basis; # transformation between them is unitary and hence; # preserves the CP and TP conditions.; if self.type == ""super"" and self.superrep in ('choi', 'chi'):; qobj = self; else:; qobj = sr.to_choi(self). # Possibly collapse dims.; if any(; len(index) > 1; for super_index in qobj.dims for index in super_index; ):; qobj = Qobj(qobj, dims=collapse_dims_super(qobj.dims)); else:; qobj = qobj. # We use the condition from John Watrous' lecture notes,; # Tr_1(J(Phi)) = identity_2.; tr_oper = qobj.ptrace([0]); ident = ops.identity(tr_oper.shape[0]); return isequal(tr_oper, ident); except TypeError:; return False; else:; return False. @property; def iscptp(self):; from qutip.superop_reps import to_choi; if self.type == ""super"" or self.type == ""oper"":; reps = ('choi', 'chi'); q_oper = to_choi(self) if self.superrep not in reps else self; return q_oper.iscp and q_oper.istp; else:; return False. @property; def isherm(self):; if self._isherm is not None:; # used previously computed value; return self._isherm. self._ishe",MatchSource.WIKI,docs/4.7/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qobj.html
https://qutip.org/docs/4.7/modules/qutip/qobj.html:53030,Testability,test,test,53030,"sinstance(qobj_list, Qobj):; q_sum = qobj_list; elif isinstance(qobj_list, list):; for q in qobj_list:; if isinstance(q, Qobj):; q_sum += q; elif (isinstance(q, list) and len(q) == 2 and; isinstance(q[0], Qobj)):; if isinstance(q[1], types.FunctionType):; q_sum += q[0] * q[1](t, args); elif isinstance(q[1], str):; args['t'] = t; q_sum += q[0] * float(eval(q[1], globals(), args)); else:; raise TypeError('Unrecognized format for ' +; 'specification of time-dependent Qobj'); else:; raise TypeError('Unrecognized format for specification ' +; 'of time-dependent Qobj'); else:; raise TypeError(; 'Unrecongized format for specification of time-dependent Qobj'). return q_sum. # -----------------------------------------------------------------------------; # This functions evaluates a time-dependent quantum object on the list-string; # and list-function formats that are used by the time-dependent solvers.; # Although not used directly in by those solvers, it can for test purposes be; # conventient to be able to evaluate the expressions passed to the solver for; # arbitrary value of time. This function provides this functionality.; #; [docs]def qobj_list_evaluate(qobj_list, t, args):; """"""; Deprecated: See Qobj.evaluate; """"""; warnings.warn(""Deprecated: Use Qobj.evaluate"", DeprecationWarning); return Qobj.evaluate(qobj_list, t, args). # -----------------------------------------------------------------------------; #; # A collection of tests used to determine the type of quantum objects, and some; # functions for increased compatibility with quantum optics toolbox.; #; [docs]def dag(A):; """"""Adjont operator (dagger) of a quantum object. Parameters; ----------; A : :class:`qutip.Qobj`; Input quantum object. Returns; -------; oper : :class:`qutip.Qobj`; Adjoint of input operator. Notes; -----; This function is for legacy compatibility only. It is recommended to use; the ``dag()`` Qobj method. """"""; if not isinstance(A, Qobj):; raise TypeError(""Input is not a quantum object""). return A",MatchSource.WIKI,docs/4.7/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qobj.html
https://qutip.org/docs/4.7/modules/qutip/qobj.html:53505,Testability,test,tests,53505,"dependent Qobj'); else:; raise TypeError('Unrecognized format for specification ' +; 'of time-dependent Qobj'); else:; raise TypeError(; 'Unrecongized format for specification of time-dependent Qobj'). return q_sum. # -----------------------------------------------------------------------------; # This functions evaluates a time-dependent quantum object on the list-string; # and list-function formats that are used by the time-dependent solvers.; # Although not used directly in by those solvers, it can for test purposes be; # conventient to be able to evaluate the expressions passed to the solver for; # arbitrary value of time. This function provides this functionality.; #; [docs]def qobj_list_evaluate(qobj_list, t, args):; """"""; Deprecated: See Qobj.evaluate; """"""; warnings.warn(""Deprecated: Use Qobj.evaluate"", DeprecationWarning); return Qobj.evaluate(qobj_list, t, args). # -----------------------------------------------------------------------------; #; # A collection of tests used to determine the type of quantum objects, and some; # functions for increased compatibility with quantum optics toolbox.; #; [docs]def dag(A):; """"""Adjont operator (dagger) of a quantum object. Parameters; ----------; A : :class:`qutip.Qobj`; Input quantum object. Returns; -------; oper : :class:`qutip.Qobj`; Adjoint of input operator. Notes; -----; This function is for legacy compatibility only. It is recommended to use; the ``dag()`` Qobj method. """"""; if not isinstance(A, Qobj):; raise TypeError(""Input is not a quantum object""). return A.dag(). [docs]def ptrace(Q, sel):; """"""Partial trace of the Qobj with selected components remaining. Parameters; ----------; Q : :class:`qutip.Qobj`; Composite quantum object.; sel : int/list; An ``int`` or ``list`` of components to keep after partial trace. Returns; -------; oper : :class:`qutip.Qobj`; Quantum object representing partial trace with selected components; remaining. Notes; -----; This function is for legacy compatibility only. It is recommen",MatchSource.WIKI,docs/4.7/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qobj.html
https://qutip.org/docs/4.7/modules/qutip/qobj.html:10518,Usability,clear,clear,10518," shape.; if dims is None and self.shape[0] == self.shape[1]:; sub_shape = np.sqrt(self.shape[0]); # check if root of shape is int; if (sub_shape % 1) != 0:; raise Exception('Invalid shape for a super operator.'); else:; sub_shape = int(sub_shape); self.dims = [[[sub_shape], [sub_shape]]]*2. if superrep:; self.superrep = superrep; else:; if self.type == 'super' and self.superrep is None:; self.superrep = 'super'. # While the obvious check would be != that would fail valid; # use cases such as enr_fock and other enr_ functions.; # This does leave open the possibility of data still being; # misused such as Qobj(complex[n**2][1], dims = [[n],[n]]); dims_size = (; np.prod(flatten(self.dims[0]), dtype=np.int64),; np.prod(flatten(self.dims[1]), dtype=np.int64); ); shape = self._data.shape; if (; (shape[0] > dims_size[0] or shape[1] > dims_size[1]); and self.type != 'super'; ):; raise ValueError(f""Qobj has smaller dims {self.dims} "" +; f""than underlying shape {self._data.shape}""). # clear type cache; self._type = None. [docs] def copy(self):; """"""Create identical copy""""""; return Qobj(inpt=self). def get_data(self):; return self._data. # Here we perfrom a check of the csr matrix type during setting of Q.data; def set_data(self, data):; if not isinstance(data, fast_csr_matrix):; raise TypeError('Qobj data must be in fast_csr format.'); else:; self._data = data; data = property(get_data, set_data). def __add__(self, other):; """"""; ADDITION with Qobj on LEFT [ ex. Qobj+4 ]; """"""; self._isunitary = None. if isinstance(other, eseries):; return other.__radd__(self). if not isinstance(other, Qobj):; if isinstance(other, (int, float, complex, np.integer, np.floating,; np.complexfloating, np.ndarray, list, tuple)) \; or sp.issparse(other):; other = Qobj(other); else:; return NotImplemented. if np.prod(other.shape) == 1 and np.prod(self.shape) != 1:; # case for scalar quantum object; dat = other.data[0, 0]; if dat == 0:; return self. out = Qobj(). if self.type in ['oper', 'super']:; out.",MatchSource.WIKI,docs/4.7/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qobj.html
https://qutip.org/docs/4.7/modules/qutip/qobj.html:20328,Usability,simpl,simply,20328," def __str__(self):; s = """"; t = self.type; shape = self.shape; if self.type in ['oper', 'super']:; s += (""Quantum object: "" +; ""dims = "" + str(self.dims) +; "", shape = "" + str(shape) +; "", type = "" + t +; "", isherm = "" + str(self.isherm) +; (; "", superrep = {0.superrep}"".format(self); if t == ""super"" and self.superrep != ""super""; else """"; ) + ""\n""); else:; s += (""Quantum object: "" +; ""dims = "" + str(self.dims) +; "", shape = "" + str(shape) +; "", type = "" + t + ""\n""); s += ""Qobj data =\n"". if shape[0] > 10000 or shape[1] > 10000:; # if the system is huge, don't attempt to convert to a; # dense matrix and then to string, because it is pointless; # and is likely going to produce memory errors. Instead print the; # sparse data string representation; s += str(self.data). elif all(np.imag(self.data.data) == 0):; s += str(np.real(self.full())). else:; s += str(self.full()). return s. def __repr__(self):; # give complete information on Qobj without print statement in; # command-line we cant realistically serialize a Qobj into a string,; # so we simply return the informal __str__ representation instead.); return self.__str__(). def __call__(self, other):; """"""; Acts this Qobj on another Qobj either by left-multiplication,; or by vectorization and devectorization, as; appropriate.; """"""; if not isinstance(other, Qobj):; raise TypeError(""Only defined for quantum objects.""). if self.type == ""super"":; if other.type == ""ket"":; other = qutip.states.ket2dm(other). if other.type == ""oper"":; return qutip.superoperator.vector_to_operator(; self * qutip.superoperator.operator_to_vector(other); ); else:; raise TypeError(""Can only act super on oper or ket.""). elif self.type == ""oper"":; if other.type == ""ket"":; return self * other; else:; raise TypeError(""Can only act oper on ket.""). def __getstate__(self):; # defines what happens when Qobj object gets pickled; self.__dict__.update({'qutip_version': __version__[:5]}); return self.__dict__. def __setstate__(self, state):; # defines what happ",MatchSource.WIKI,docs/4.7/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qobj.html
https://qutip.org/docs/4.7/modules/qutip/qobj.html:37200,Usability,simpl,simply,37200,"lse:; raise TypeError('Invalid operand for basis transformation'). # transform data; if inverse:; if self.isket:; data = (S.conj().T) * self.data; elif self.isbra:; data = self.data.dot(S); else:; if sparse:; data = (S.conj().T) * self.data * S; else:; data = (S.conj().T).dot(self.data.dot(S)); else:; if self.isket:; data = S * self.data; elif self.isbra:; data = self.data.dot(S.conj().T); else:; if sparse:; data = S * self.data * (S.conj().T); else:; data = S.dot(self.data.dot(S.conj().T)). out = Qobj(data, dims=self.dims); out._isherm = self._isherm; out.superrep = self.superrep. if settings.auto_tidyup:; return out.tidyup(); else:; return out. [docs] def trunc_neg(self, method=""clip""):; """"""Truncates negative eigenvalues and renormalizes. Returns a new Qobj by removing the negative eigenvalues; of this instance, then renormalizing to obtain a valid density; operator. Parameters; ----------; method : str; Algorithm to use to remove negative eigenvalues. ""clip""; simply discards negative eigenvalues, then renormalizes.; ""sgs"" uses the SGS algorithm (doi:10/bb76) to find the; positive operator that is nearest in the Shatten 2-norm. Returns; -------; oper : :class:`qutip.Qobj`; A valid density operator. """"""; if not self.isherm:; raise ValueError(""Must be a Hermitian operator to remove negative ""; ""eigenvalues.""). if method not in ('clip', 'sgs'):; raise ValueError(""Method {} not recognized."".format(method)). eigvals, eigstates = self.eigenstates(); if all([eigval >= 0 for eigval in eigvals]):; # All positive, so just renormalize.; return self.unit(); idx_nonzero = eigvals != 0; eigvals = eigvals[idx_nonzero]; eigstates = eigstates[idx_nonzero]. if method == 'clip':; eigvals[eigvals < 0] = 0; elif method == 'sgs':; eigvals = eigvals[::-1]; eigstates = eigstates[::-1]. acc = 0.0; dim = self.shape[0]; n_eigs = len(eigvals). for idx in reversed(range(n_eigs)):; if eigvals[idx] + acc / (idx + 1) >= 0:; break; else:; acc += eigvals[idx]; eigvals[idx] = 0.0. eigvals[:idx+1] +=",MatchSource.WIKI,docs/4.7/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qobj.html
https://qutip.org/docs/4.7/modules/qutip/qobjevo.html:7897,Availability,avail,available,7897,"r the coefficient at time t. If the coefficients are to be; treated as step functions, use the arguments; ``args = {""_step_func_coeff"": True}``. Examples of array-format usage are:. .. code-block:: python. tlist = np.logspace(-5,0,100); H = QobjEvo([H0, [H1, np.exp(-1j*tlist)], [H2, np.cos(2.*tlist)]],; tlist=tlist). Mixing time formats is allowed. It is not possible to create a single; ``QobjEvo`` that contains different ``tlist`` values, however. **Passing arguments**. ``args`` is a dict of (name: object). The name must be a valid Python; identifier string, and in general the object can be any type that is; supported by the code to be compiled in the string. There are some ""magic"" names that can be specified, whose objects will be; overwritten when used within :func:`.sesolve`, :func:`.mesolve` and; :func:`.mcsolve`. This allows access to the solvers' internal states, and; they are updated at every call. The initial values of these dictionary; elements is unimportant. The magic names available are:. - ``""state""``: the current state as a :class:`~qutip.Qobj`; - ``""state_vec""``: the current state as a column-stacked 1D ``np.ndarray``; - ``""state_mat""``: the current state as a 2D ``np.ndarray``; - ``""expect_op_<n>""``: the current expectation value of the element; ``e_ops[n]``, which is an argument to the solvers. Replace ``<n>`` with; an integer literal, e.g. ``""expect_op_0""``. This will be either real- or; complex-valued, depending on whether the state and operator are both; Hermitian or not.; - ``""collapse""``: (:func:`.mcsolve` only) a list of the collapses that have; occurred during the evolution. Each element of the list is a 2-tuple; ``(time: float, which: int)``, where ``time`` is the time this collapse; happened, and ``which`` is an integer indexing the ``c_ops`` argument to; :func:`.mcsolve`. Parameters; ----------; Q_object : list, :class:`~qutip.Qobj` or :class:`~qutip.QobjEvo`; The time-dependent description of the quantum object. This is of the; same form",MatchSource.WIKI,docs/4.7/modules/qutip/qobjevo.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qobjevo.html
https://qutip.org/docs/4.7/modules/qutip/qobjevo.html:2647,Deployability,update,update,2647," np.pi,; ""sinh"": np.sinh,; ""cosh"": np.cosh,; ""tanh"": np.tanh,; ""asinh"": np.arcsinh,; ""acosh"": np.arccosh,; ""atanh"": np.arctanh,; ""exp"": np.exp,; ""log"": np.log,; ""log10"": np.log10,; ""erf"": scipy.special.erf,; ""zerf"": scipy.special.erf,; ""sqrt"": np.sqrt,; ""real"": np.real,; ""imag"": np.imag,; ""conj"": np.conj,; ""abs"": np.abs,; ""norm"": lambda x: np.abs(x)**2,; ""arg"": np.angle,; ""proj"": proj,; ""np"": np,; ""spe"": scipy.special}. class _file_list:; """"""; Contain temp a list .pyx to clean; """""". def __init__(self):; self.files = []. def add(self, file_):; self.files += [file_]. def clean(self):; to_del = []; for i, file_ in enumerate(self.files):; try:; os.remove(file_); to_del.append(i); except Exception:; if not os.path.isfile(file_):; to_del.append(i). for i in to_del[::-1]:; del self.files[i]. def __del__(self):; self.clean(). coeff_files = _file_list(). class _StrWrapper:; def __init__(self, code):; self.code = ""_out = "" + code. def __call__(self, t, args={}):; env = {""t"": t}; env.update(args); exec(self.code, str_env, env); return env[""_out""]. class _CubicSplineWrapper:; # Using scipy's CubicSpline since Qutip's one; # only accept linearly distributed tlist; def __init__(self, tlist, coeff, args=None):; self.coeff = coeff; self.tlist = tlist; try:; use_step_func = args[""_step_func_coeff""]; except KeyError:; use_step_func = 0; if use_step_func:; self.func = interp1d(; self.tlist, self.coeff, kind=""previous"",; bounds_error=False, fill_value=0.); else:; self.func = CubicSpline(self.tlist, self.coeff). def __call__(self, t, args={}):; return self.func([t])[0]. class _StateAsArgs:; # old with state (f(t, psi, args)) to new (args[""state""] = psi); def __init__(self, coeff_func):; self.coeff_func = coeff_func. def __call__(self, t, args={}):; return self.coeff_func(t, args[""_state_vec""], args). # %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%; class StateArgs:; """"""Object to indicate to use the state in args outside solver.; args[key] = StateArgs(type, op); """""". def __init__(self, type=",MatchSource.WIKI,docs/4.7/modules/qutip/qobjevo.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qobjevo.html
https://qutip.org/docs/4.7/modules/qutip/qobjevo.html:7793,Deployability,update,updated,7793,"mes of the tlist do not need to be; equidistant, but must be sorted. By default, a cubic spline interpolation; will be used for the coefficient at time t. If the coefficients are to be; treated as step functions, use the arguments; ``args = {""_step_func_coeff"": True}``. Examples of array-format usage are:. .. code-block:: python. tlist = np.logspace(-5,0,100); H = QobjEvo([H0, [H1, np.exp(-1j*tlist)], [H2, np.cos(2.*tlist)]],; tlist=tlist). Mixing time formats is allowed. It is not possible to create a single; ``QobjEvo`` that contains different ``tlist`` values, however. **Passing arguments**. ``args`` is a dict of (name: object). The name must be a valid Python; identifier string, and in general the object can be any type that is; supported by the code to be compiled in the string. There are some ""magic"" names that can be specified, whose objects will be; overwritten when used within :func:`.sesolve`, :func:`.mesolve` and; :func:`.mcsolve`. This allows access to the solvers' internal states, and; they are updated at every call. The initial values of these dictionary; elements is unimportant. The magic names available are:. - ``""state""``: the current state as a :class:`~qutip.Qobj`; - ``""state_vec""``: the current state as a column-stacked 1D ``np.ndarray``; - ``""state_mat""``: the current state as a 2D ``np.ndarray``; - ``""expect_op_<n>""``: the current expectation value of the element; ``e_ops[n]``, which is an argument to the solvers. Replace ``<n>`` with; an integer literal, e.g. ``""expect_op_0""``. This will be either real- or; complex-valued, depending on whether the state and operator are both; Hermitian or not.; - ``""collapse""``: (:func:`.mcsolve` only) a list of the collapses that have; occurred during the evolution. Each element of the list is a 2-tuple; ``(time: float, which: int)``, where ``time`` is the time this collapse; happened, and ``which`` is an integer indexing the ``c_ops`` argument to; :func:`.mcsolve`. Parameters; ----------; Q_object : list, :cl",MatchSource.WIKI,docs/4.7/modules/qutip/qobjevo.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qobjevo.html
https://qutip.org/docs/4.7/modules/qutip/qobjevo.html:17358,Deployability,update,update,17358,"nce(self.args[key], StateArgs):; self.dynamics_args += [(key, *self.args[key]())]; self.args[key] = 0. def _check_old_with_state(self):; add_vec = False; for op in self.ops:; if op.type == ""func"":; try:; op.get_coeff(0., self.args); except TypeError as e:; nfunc = _StateAsArgs(self.coeff); op = EvoElement((op.qobj, nfunc, nfunc, ""func"")); add_vec = True; if add_vec:; self.dynamics_args += [(""_state_vec"", ""vec"", None)]. def __del__(self):; for file_ in self.coeff_files:; try:; os.remove(file_); except:; pass. def __call__(self, t, data=False, state=None, args={}):; """"""; Return a single :obj:`~qutip.Qobj` at the given time ``t``.; """"""; try:; t = float(t); except Exception as e:; raise TypeError(""Time must be a real scalar."") from e. if state is not None:; self._dynamics_args_update(t, state). if args:; if not isinstance(args, dict):; raise TypeError(""The new args must be in a dict""); old_args = self.args.copy(); old_compiled = self.compiled; self.compiled = False; self.args.update(args); op_t = self.__call__(t, data=data); self.args = old_args; self.compiled = old_compiled; elif self.const:; if data:; op_t = self.cte.data.copy(); else:; op_t = self.cte.copy(); elif self.compiled and self.compiled.split()[0] != ""dense"":; op_t = self.compiled_qobjevo.call(t, data); elif data:; op_t = self.cte.data.copy(); for part in self.ops:; op_t += part.qobj.data * part.get_coeff(t, self.args); else:; op_t = self.cte.copy(); for part in self.ops:; op_t += part.qobj * part.get_coeff(t, self.args). return op_t. def _dynamics_args_update(self, t, state):; if isinstance(state, Qobj):; for name, what, op in self.dynamics_args:; if what == ""vec"":; self.args[name] = state.full().ravel(""F""); elif what == ""mat"":; self.args[name] = state.full(); elif what == ""Qobj"":; self.args[name] = state; elif what == ""expect"":; self.args[name] = op.expect(t, state). elif isinstance(state, np.ndarray) and state.ndim == 1:; s1 = self.cte.shape[1]; for name, what, op in self.dynamics_args:; if what == ""vec"":",MatchSource.WIKI,docs/4.7/modules/qutip/qobjevo.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qobjevo.html
https://qutip.org/docs/4.7/modules/qutip/qobjevo.html:21356,Deployability,update,update,21356,"inplace_copy(self, other):; self.cte = other.cte; self.const = other.const; self.args = other.args.copy(); self.dynamics_args = other.dynamics_args; self.tlist = other.tlist; self.dummy_cte = other.dummy_cte; self.num_obj = other.num_obj; self.type = other.type; self.compiled = """"; self.compiled_qobjevo = None; self.coeff_get = None; self.ops = []; self.coeff_files = []; self.use_cython = other.use_cython; self.safePickle = other.safePickle. for op in other.ops:; if op.type == ""array"":; new_coeff = op.coeff.copy(); else:; new_coeff = op.coeff; self.ops.append(EvoElement(op.qobj.copy(), op.get_coeff,; new_coeff, op.type)). [docs] def arguments(self, new_args):; """"""; Update the scoped variables that were passed as ``args`` to new values.; """"""; if not isinstance(new_args, dict):; raise TypeError(""The new args must be in a dict""); # remove dynamics_args that are to be refreshed; self.dynamics_args = [dargs for dargs in self.dynamics_args; if dargs[0] not in new_args]; self.args.update(new_args); self._args_checks(); if self.compiled and self.compiled.split()[2] != ""cte"":; if isinstance(self.coeff_get, StrCoeff):; self.coeff_get.set_args(self.args); self.coeff_get._set_dyn_args(self.dynamics_args); elif isinstance(self.coeff_get, _UnitedFuncCaller):; self.coeff_get.set_args(self.args, self.dynamics_args). def solver_set_args(self, new_args, state, e_ops):; self.dynamics_args = []; self.args.update(new_args); self._args_checks(); for i, dargs in enumerate(self.dynamics_args):; if dargs[1] == ""expect"" and isinstance(dargs[2], int):; self.dynamics_args[i] = (dargs[0], ""expect"",; QobjEvo(e_ops[dargs[2]])); if self.compiled:; self.dynamics_args[i][2].compile(); self._dynamics_args_update(0., state); if self.compiled and self.compiled.split()[2] != ""cte"":; if isinstance(self.coeff_get, StrCoeff):; self.coeff_get.set_args(self.args); self.coeff_get._set_dyn_args(self.dynamics_args); elif isinstance(self.coeff_get, _UnitedFuncCaller):; self.coeff_get.set_args(self.args, self.dyna",MatchSource.WIKI,docs/4.7/modules/qutip/qobjevo.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qobjevo.html
https://qutip.org/docs/4.7/modules/qutip/qobjevo.html:21776,Deployability,update,update,21776,"ickle = other.safePickle. for op in other.ops:; if op.type == ""array"":; new_coeff = op.coeff.copy(); else:; new_coeff = op.coeff; self.ops.append(EvoElement(op.qobj.copy(), op.get_coeff,; new_coeff, op.type)). [docs] def arguments(self, new_args):; """"""; Update the scoped variables that were passed as ``args`` to new values.; """"""; if not isinstance(new_args, dict):; raise TypeError(""The new args must be in a dict""); # remove dynamics_args that are to be refreshed; self.dynamics_args = [dargs for dargs in self.dynamics_args; if dargs[0] not in new_args]; self.args.update(new_args); self._args_checks(); if self.compiled and self.compiled.split()[2] != ""cte"":; if isinstance(self.coeff_get, StrCoeff):; self.coeff_get.set_args(self.args); self.coeff_get._set_dyn_args(self.dynamics_args); elif isinstance(self.coeff_get, _UnitedFuncCaller):; self.coeff_get.set_args(self.args, self.dynamics_args). def solver_set_args(self, new_args, state, e_ops):; self.dynamics_args = []; self.args.update(new_args); self._args_checks(); for i, dargs in enumerate(self.dynamics_args):; if dargs[1] == ""expect"" and isinstance(dargs[2], int):; self.dynamics_args[i] = (dargs[0], ""expect"",; QobjEvo(e_ops[dargs[2]])); if self.compiled:; self.dynamics_args[i][2].compile(); self._dynamics_args_update(0., state); if self.compiled and self.compiled.split()[2] != ""cte"":; if isinstance(self.coeff_get, StrCoeff):; self.coeff_get.set_args(self.args); self.coeff_get._set_dyn_args(self.dynamics_args); elif isinstance(self.coeff_get, _UnitedFuncCaller):; self.coeff_get.set_args(self.args, self.dynamics_args). [docs] def to_list(self):; """"""; Return this operator in the list-like form used to initialised it, like; can be passed to :func:`~mesolve`.; """"""; list_qobj = []; if not self.dummy_cte:; list_qobj.append(self.cte); for op in self.ops:; list_qobj.append([op.qobj, op.coeff]); return list_qobj. # Math function; def __add__(self, other):; res = self.copy(); res += other; return res. def __radd__(self, other):;",MatchSource.WIKI,docs/4.7/modules/qutip/qobjevo.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qobjevo.html
https://qutip.org/docs/4.7/modules/qutip/qobjevo.html:23138,Deployability,update,update,23138," isinstance(self.coeff_get, StrCoeff):; self.coeff_get.set_args(self.args); self.coeff_get._set_dyn_args(self.dynamics_args); elif isinstance(self.coeff_get, _UnitedFuncCaller):; self.coeff_get.set_args(self.args, self.dynamics_args). [docs] def to_list(self):; """"""; Return this operator in the list-like form used to initialised it, like; can be passed to :func:`~mesolve`.; """"""; list_qobj = []; if not self.dummy_cte:; list_qobj.append(self.cte); for op in self.ops:; list_qobj.append([op.qobj, op.coeff]); return list_qobj. # Math function; def __add__(self, other):; res = self.copy(); res += other; return res. def __radd__(self, other):; res = self.copy(); res += other; return res. def __iadd__(self, other):; if isinstance(other, QobjEvo):; self.cte += other.cte; l = len(self.ops); for op in other.ops:; if op.type == ""array"":; new_coeff = op.coeff.copy(); else:; new_coeff = op.coeff; self.ops.append(EvoElement(op.qobj.copy(), op.get_coeff,; new_coeff, op.type)); l += 1; self.args.update(**other.args); self.dynamics_args += other.dynamics_args; self.const = self.const and other.const; self.dummy_cte = self.dummy_cte and other.dummy_cte; if self.type != other.type:; if self.type in [""func"", ""mixed_callable""] or \; other.type in [""func"", ""mixed_callable""]:; self.type = ""mixed_callable""; else:; self.type = ""mixed_compilable""; self.compiled = """"; self.compiled_qobjevo = None; self.coeff_get = None. if self.tlist is None:; self.tlist = other.tlist; else:; if other.tlist is None:; pass; elif len(other.tlist) != len(self.tlist) or \; other.tlist[-1] != self.tlist[-1]:; raise ValueError(""Time lists are not compatible""); else:; self.cte += other; self.dummy_cte = False. self.num_obj = (len(self.ops) if self.dummy_cte else len(self.ops) + 1); self._reset_type(); return self. def __sub__(self, other):; res = self.copy(); res -= other; return res. def __rsub__(self, other):; res = -self.copy(); res += other; return res. def __isub__(self, other):; self += (-other); return self. def",MatchSource.WIKI,docs/4.7/modules/qutip/qobjevo.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qobjevo.html
https://qutip.org/docs/4.7/modules/qutip/qobjevo.html:25242,Deployability,update,update,25242," self.copy(); if isinstance(other, Qobj):; res.cte = other * res.cte; for op in res.ops:; op.qobj = other * op.qobj; return res; else:; res *= other; return res. def __imul__(self, other):; if isinstance(other, Qobj) or isinstance(other, Number):; self.cte *= other; for op in self.ops:; op.qobj *= other; return self; if isinstance(other, QobjEvo):; if other.const:; self.cte *= other.cte; for op in self.ops:; op.qobj *= other.cte; elif self.const:; cte = self.cte.copy(); self = other.copy(); self.cte = cte * self.cte; for op in self.ops:; op.qobj = cte*op.qobj; else:; cte = self.cte.copy(); self.cte *= other.cte; new_terms = []; old_ops = self.ops; if not other.dummy_cte:; for op in old_ops:; new_terms.append(self._ops_mul_cte(op, other.cte, ""R"")); if not self.dummy_cte:; for op in other.ops:; new_terms.append(self._ops_mul_cte(op, cte, ""L"")). for op_left in old_ops:; for op_right in other.ops:; new_terms.append(self._ops_mul_(op_left,; op_right)); self.ops = new_terms; self.args.update(other.args); self.dynamics_args += other.dynamics_args; self.dummy_cte = self.dummy_cte and other.dummy_cte; self.num_obj = (len(self.ops) if; self.dummy_cte else len(self.ops) + 1); self._reset_type(); return self; return NotImplemented. def __div__(self, other):; if isinstance(other, (int, float, complex,; np.integer, np.floating, np.complexfloating)):; res = self.copy(); res *= other**(-1); return res; return NotImplemented. def __idiv__(self, other):; if isinstance(other, (int, float, complex,; np.integer, np.floating, np.complexfloating)):; self *= other**(-1); return self; return NotImplemented. def __truediv__(self, other):; return self.__div__(other). def __neg__(self):; res = self.copy(); res.cte = -res.cte; for op in res.ops:; op.qobj = -op.qobj; return res. def _ops_mul_(self, opL, opR):; new_f = _Prod(opL.get_coeff, opR.get_coeff); new_op = [opL.qobj*opR.qobj, new_f, None, 0]; if opL.type == opR.type and opL.type == ""string"":; new_op[2] = ""("" + opL.coeff + "") * ("" + opR.coe",MatchSource.WIKI,docs/4.7/modules/qutip/qobjevo.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qobjevo.html
https://qutip.org/docs/4.7/modules/qutip/qobjevo.html:36159,Deployability,update,update,36159,"coeff)**2; new_op[1] = _CubicSplineWrapper(; self.tlist, new_op[2], args=self.args); elif op.type == ""spline"":; new_op[1] = _Norm2(op.get_coeff); new_op[2] = new_op[1]; new_op[3] = ""func""; self.type = ""mixed_callable""; new_ops.append(EvoElement.make(new_op)); self.ops = new_ops; return self. def _f_conj(self):; self.compiled = """"; new_ops = []; for op in self.ops:; new_op = [op.qobj, None, None, op.type]; if op.type == ""func"":; new_op[1] = _Conj(op.get_coeff); new_op[2] = new_op[1]; elif op.type == ""string"":; new_op[2] = ""conj("" + op.coeff + "")""; new_op[1] = _StrWrapper(new_op[2]); elif op.type == ""array"":; new_op[2] = np.conj(op.coeff); new_op[1] = _CubicSplineWrapper(; self.tlist, new_op[2], args=self.args); elif op.type == ""spline"":; new_op[1] = _Conj(op.get_coeff); new_op[2] = new_op[1]; new_op[3] = ""func""; self.type = ""mixed_callable""; new_ops.append(EvoElement.make(new_op)); self.ops = new_ops; return self. def _shift(self):; self.compiled = """"; self.args.update({""_t0"": 0}); new_ops = []; for op in self.ops:; new_op = [op.qobj, None, None, op.type]; if op.type == ""func"":; new_op[1] = _Shift(op.get_coeff); new_op[2] = new_op[1]; elif op.type == ""string"":; new_op[2] = sub(""(?<=[^0-9a-zA-Z_])t(?=[^0-9a-zA-Z_])"",; ""(t+_t0)"", "" "" + op.coeff + "" ""); new_op[1] = _StrWrapper(new_op[2]); elif op.type == ""array"":; new_op[2] = _Shift(op.get_coeff); new_op[1] = new_op[2]; new_op[3] = ""func""; self.type = ""mixed_callable""; elif op.type == ""spline"":; new_op[1] = _Shift(op.get_coeff); new_op[2] = new_op[1]; new_op[3] = ""func""; self.type = ""mixed_callable""; new_ops.append(EvoElement.make(new_op)); self.ops = new_ops; return self. [docs] def expect(self, t, state, herm=False):; """"""; Calculate the expectation value of this operator on the given; (time-independent) state at a particular time. This is more efficient than ``expect(QobjEvo(t), state)``. Parameters; ----------; t : float; The time to evaluate this operator at. state : Qobj or np.ndarray; The state to take the expectat",MatchSource.WIKI,docs/4.7/modules/qutip/qobjevo.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qobjevo.html
https://qutip.org/docs/4.7/modules/qutip/qobjevo.html:49460,Deployability,update,update,49460,"dynamics_args, cte):; self.funclist = funclist; self.args = args; self.dynamics_args = dynamics_args; self.dims = cte.dims; self.shape = cte.shape. def set_args(self, args, dynamics_args):; self.args = args; self.dynamics_args = dynamics_args. def dyn_args(self, t, state, shape):; # 1d array are to F ordered; mat = state.reshape(shape, order=""F""); for name, what, op in self.dynamics_args:; if what == ""vec"":; self.args[name] = state; elif what == ""mat"":; self.args[name] = mat; elif what == ""Qobj"":; if self.shape[1] == shape[1]: # oper; self.args[name] = Qobj(mat, dims=self.dims); elif shape[1] == 1: # ket; self.args[name] = Qobj(mat, dims=[self.dims[1], [1]]); else: # rho; self.args[name] = Qobj(mat, dims=self.dims[1]); elif what == ""expect"":; if shape[1] == op.cte.shape[1]: # same shape as object; self.args[name] = op.mul_mat(t, mat).trace(); else:; self.args[name] = op.expect(t, state). def __call__(self, t, args={}):; if args:; now_args = self.args.copy(); now_args.update(args); else:; now_args = self.args; out = []; for func in self.funclist:; out.append(func(t, now_args)); return out. def get_args(self):; return self.args. class _Norm2():; def __init__(self, f):; self.func = f. def __call__(self, t, args):; return self.func(t, args)*np.conj(self.func(t, args)). class _Shift():; def __init__(self, f):; self.func = f. def __call__(self, t, args):; return np.conj(self.func(t + args[""_t0""], args)). class _Conj():; def __init__(self, f):; self.func = f. def __call__(self, t, args):; return np.conj(self.func(t, args)). class _Prod():; def __init__(self, f, g):; self.func_1 = f; self.func_2 = g. def __call__(self, t, args):; return self.func_1(t, args)*self.func_2(t, args). class _Add():; def __init__(self, fs):; self.funcs = fs. def __call__(self, t, args):; return np.sum([f(t, args) for f in self.funcs]). © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Re",MatchSource.WIKI,docs/4.7/modules/qutip/qobjevo.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qobjevo.html
https://qutip.org/docs/4.7/modules/qutip/qobjevo.html:50393,Deployability,update,updated,50393,"te):; self.funclist = funclist; self.args = args; self.dynamics_args = dynamics_args; self.dims = cte.dims; self.shape = cte.shape. def set_args(self, args, dynamics_args):; self.args = args; self.dynamics_args = dynamics_args. def dyn_args(self, t, state, shape):; # 1d array are to F ordered; mat = state.reshape(shape, order=""F""); for name, what, op in self.dynamics_args:; if what == ""vec"":; self.args[name] = state; elif what == ""mat"":; self.args[name] = mat; elif what == ""Qobj"":; if self.shape[1] == shape[1]: # oper; self.args[name] = Qobj(mat, dims=self.dims); elif shape[1] == 1: # ket; self.args[name] = Qobj(mat, dims=[self.dims[1], [1]]); else: # rho; self.args[name] = Qobj(mat, dims=self.dims[1]); elif what == ""expect"":; if shape[1] == op.cte.shape[1]: # same shape as object; self.args[name] = op.mul_mat(t, mat).trace(); else:; self.args[name] = op.expect(t, state). def __call__(self, t, args={}):; if args:; now_args = self.args.copy(); now_args.update(args); else:; now_args = self.args; out = []; for func in self.funclist:; out.append(func(t, now_args)); return out. def get_args(self):; return self.args. class _Norm2():; def __init__(self, f):; self.func = f. def __call__(self, t, args):; return self.func(t, args)*np.conj(self.func(t, args)). class _Shift():; def __init__(self, f):; self.func = f. def __call__(self, t, args):; return np.conj(self.func(t + args[""_t0""], args)). class _Conj():; def __init__(self, f):; self.func = f. def __call__(self, t, args):; return np.conj(self.func(t, args)). class _Prod():; def __init__(self, f, g):; self.func_1 = f; self.func_2 = g. def __call__(self, t, args):; return self.func_1(t, args)*self.func_2(t, args). class _Add():; def __init__(self, fs):; self.funcs = fs. def __call__(self, t, args):; return np.sum([f(t, args) for f in self.funcs]). © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/modules/qutip/qobjevo.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qobjevo.html
https://qutip.org/docs/4.7/modules/qutip/qobjevo.html:30280,Energy Efficiency,reduce,reduce,30280," ""("" + self.ops[_set[0]].coeff + "")""; for i in _set[1:]:; new_str += "" + ("" + self.ops[i].coeff + "")""; new_op[1] = _StrWrapper(new_str); new_op[2] = new_str; new_ops.append(EvoElement.make(new_op)). elif self.ops[_set[0]].type == ""array"":; new_op = [self.ops[_set[0]].qobj, None, None, ""array""]; new_array = (self.ops[_set[0]].coeff).copy(); for i in _set[1:]:; new_array += self.ops[i].coeff; new_op[2] = new_array; new_op[1] = _CubicSplineWrapper(; self.tlist, new_array, args=self.args); new_ops.append(EvoElement.make(new_op)). self.ops = new_ops. def _compress_merge_func(self, fsets):; new_ops = []; for _set in fsets:; base = self.ops[_set[0]]; new_op = [None, base.get_coeff, base.coeff, base.type]; if len(_set) == 1:; new_op[0] = base.qobj; else:; new_op[0] = base.qobj.copy(); for i in _set[1:]:; new_op[0] += self.ops[i].qobj; new_ops.append(EvoElement.make(new_op)); self.ops = new_ops. [docs] def compress(self):; """"""; Merge together elements that share the same time-dependence, to reduce; the number of matrix multiplications and additions that need to be done; to evaluate this object. Modifies the object inplace.; """"""; self.tidyup(); sets, fsets = self._compress_make_set(); N_sets = len(sets); N_fsets = len(fsets); num_ops = len(self.ops). if N_sets < num_ops and N_fsets < num_ops:; # Both could be better; self.compiled = """"; self.compiled_qobjevo = None; self.coeff_get = None; if N_sets < N_fsets:; self._compress_merge_qobj(sets); else:; self._compress_merge_func(fsets); sets, fsets = self._compress_make_set(); N_sets = len(sets); N_fsets = len(fsets); num_ops = len(self.ops). if N_sets < num_ops:; self.compiled = """"; self.compiled_qobjevo = None; self.coeff_get = None; self._compress_merge_qobj(sets); elif N_fsets < num_ops:; self.compiled = """"; self.compiled_qobjevo = None; self.coeff_get = None; self._compress_merge_func(fsets); self._reset_type(). def _reset_type(self):; op_type_count = [0, 0, 0, 0]; for op in self.ops:; if op.type == ""func"":; op_type_count[0] ",MatchSource.WIKI,docs/4.7/modules/qutip/qobjevo.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qobjevo.html
https://qutip.org/docs/4.7/modules/qutip/qobjevo.html:37006,Energy Efficiency,efficient,efficient,37006,"xed_callable""; new_ops.append(EvoElement.make(new_op)); self.ops = new_ops; return self. def _shift(self):; self.compiled = """"; self.args.update({""_t0"": 0}); new_ops = []; for op in self.ops:; new_op = [op.qobj, None, None, op.type]; if op.type == ""func"":; new_op[1] = _Shift(op.get_coeff); new_op[2] = new_op[1]; elif op.type == ""string"":; new_op[2] = sub(""(?<=[^0-9a-zA-Z_])t(?=[^0-9a-zA-Z_])"",; ""(t+_t0)"", "" "" + op.coeff + "" ""); new_op[1] = _StrWrapper(new_op[2]); elif op.type == ""array"":; new_op[2] = _Shift(op.get_coeff); new_op[1] = new_op[2]; new_op[3] = ""func""; self.type = ""mixed_callable""; elif op.type == ""spline"":; new_op[1] = _Shift(op.get_coeff); new_op[2] = new_op[1]; new_op[3] = ""func""; self.type = ""mixed_callable""; new_ops.append(EvoElement.make(new_op)); self.ops = new_ops; return self. [docs] def expect(self, t, state, herm=False):; """"""; Calculate the expectation value of this operator on the given; (time-independent) state at a particular time. This is more efficient than ``expect(QobjEvo(t), state)``. Parameters; ----------; t : float; The time to evaluate this operator at. state : Qobj or np.ndarray; The state to take the expectation value around. herm : bool, default False; Whether this operator and the state are both Hermitian. If True,; only the real part of the result will be returned. See Also; --------; expect : General-purpose expectation values.; """"""; if not isinstance(t, (int, float)):; raise TypeError(""Time must be a real scalar""); if isinstance(state, Qobj):; if self.cte.dims[1] == state.dims[0]:; vec = state.full().ravel(""F""); elif self.cte.dims[1] == state.dims:; vec = state.full().ravel(""F""); else:; raise ValueError(""Dimensions do not fit""); elif isinstance(state, np.ndarray):; vec = state.ravel(""F""); else:; raise TypeError(""The vector must be an array or Qobj""). if vec.shape[0] == self.cte.shape[1]:; if self.compiled:; exp = self.compiled_qobjevo.expect(t, vec); elif self.cte.issuper:; self._dynamics_args_update(t, state); exp = cy_expec",MatchSource.WIKI,docs/4.7/modules/qutip/qobjevo.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qobjevo.html
https://qutip.org/docs/4.7/modules/qutip/qobjevo.html:354,Integrability,depend,dependent,354,". qutip.qobjevo — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.qobjevo. Source code for qutip.qobjevo; """"""Time-dependent Quantum Object (Qobj) class.; """"""; __all__ = ['QobjEvo']. from qutip.qobj import Qobj; import qutip.settings as qset; from qutip.interpolate import Cubic_Spline; from scipy.interpolate import CubicSpline, interp1d; from functools import partial; from types import FunctionType, BuiltinFunctionType; import numpy as np; from numbers import Number; from qutip.qobjevo_codegen import (_compile_str_single, _compiled_coeffs,; _compiled_coeffs_python); from qutip.cy.spmatfuncs import (cy_expect_rho_vec, cy_expect_psi,; spmv); from qutip.cy.cqobjevo import (CQobjCte, CQobjCteDense, CQobjEvoTd,; CQobjEvoTdMatched, CQobjEvoTdDense); from qutip.cy.cqobjevo_factor import (InterCoeffT, InterCoeffCte,; InterpolateCoeff, StrCoeff,; StepCoeffCte, StepCoeffT); import sys; import scipy; import os; from re import sub. if qset.has_openmp:; from qutip.cy.openmp.cqobjevo_omp import (CQobjCteOmp, CQobjEvoTdOmp,; CQobjEvoTdMatchedOmp). safePickle = [False]; if sys.platform == 'win32':; safePickle[0] = True. if qset.has_cython:; import cython; use_cython = [True]; else:; use_cython = [False]. def proj(x):; if np.isfinite(x):; return (x); else:; return np.inf + 0j * np.imag(x). str_env = {; ""sin"": np.sin,; ""cos"": np.cos,; ""tan"": np.tan,; ""asin"": np.arcsin,; ""acos"": np.arccos,; ""atan"": np.arctan,; ""pi"": np.pi,; ""sinh"": np.sinh,; ""cosh"": np.cosh,; ""tanh"": np.tanh,; ""asinh"": np.arcsinh,; ""acosh"": np.arccosh,; ""atanh"": np.arctanh,; ""exp"": np.exp,; ""log"": np.log,; ""log10"": np.log10,; ""erf"": scipy.special.erf,; ""zerf"": scipy.special.erf,; ""sqrt"": np.sqrt,; ""real"": np.real,; ""imag"": np.imag,; ""conj"": np.conj,; ""abs"": np.abs,; ""norm"": lambda x: ",MatchSource.WIKI,docs/4.7/modules/qutip/qobjevo.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qobjevo.html
https://qutip.org/docs/4.7/modules/qutip/qobjevo.html:3818,Integrability,depend,dependent,3818,"f.tlist = tlist; try:; use_step_func = args[""_step_func_coeff""]; except KeyError:; use_step_func = 0; if use_step_func:; self.func = interp1d(; self.tlist, self.coeff, kind=""previous"",; bounds_error=False, fill_value=0.); else:; self.func = CubicSpline(self.tlist, self.coeff). def __call__(self, t, args={}):; return self.func([t])[0]. class _StateAsArgs:; # old with state (f(t, psi, args)) to new (args[""state""] = psi); def __init__(self, coeff_func):; self.coeff_func = coeff_func. def __call__(self, t, args={}):; return self.coeff_func(t, args[""_state_vec""], args). # %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%; class StateArgs:; """"""Object to indicate to use the state in args outside solver.; args[key] = StateArgs(type, op); """""". def __init__(self, type=""Qobj"", op=None):; self.dyn_args = (type, op). def __call__(self):; return self.dyn_args. # %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%; # object for each time dependent element of the QobjEvo; # qobj : the Qobj of element ([*Qobj*, f]); # get_coeff : a callable that take (t, args) and return the coeff at that t; # coeff : The coeff as a string, array or function as provided by the user.; # type : flag for the type of coeff; class EvoElement:; """"""; Internal type used to represent the time-dependent parts of a; :class:`~qutip.QobjEvo`. Availables ""types"" are. 1. function; 2. string; 3. ``np.ndarray``; 4. :class:`.Cubic_Spline`; """""". def __init__(self, qobj, get_coeff, coeff, type):; self.qobj = qobj; self.get_coeff = get_coeff; self.coeff = coeff; self.type = type. @classmethod; def make(cls, list_):; return cls(*list_). def __getitem__(self, i):; if i == 0:; return self.qobj; if i == 1:; return self.get_coeff; if i == 2:; return self.coeff; if i == 3:; return self.type. [docs]class QobjEvo:; """"""; A class for representing time-dependent quantum objects, such as quantum; operators and states. Basic math operations are defined:. - ``+``, ``-`` : :class:`~qutip.QobjEvo`, :class:`~qutip.Qobj`, scalars.; - ``*``: :class:`~quti",MatchSource.WIKI,docs/4.7/modules/qutip/qobjevo.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qobjevo.html
https://qutip.org/docs/4.7/modules/qutip/qobjevo.html:4152,Integrability,depend,dependent,4152,"; else:; self.func = CubicSpline(self.tlist, self.coeff). def __call__(self, t, args={}):; return self.func([t])[0]. class _StateAsArgs:; # old with state (f(t, psi, args)) to new (args[""state""] = psi); def __init__(self, coeff_func):; self.coeff_func = coeff_func. def __call__(self, t, args={}):; return self.coeff_func(t, args[""_state_vec""], args). # %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%; class StateArgs:; """"""Object to indicate to use the state in args outside solver.; args[key] = StateArgs(type, op); """""". def __init__(self, type=""Qobj"", op=None):; self.dyn_args = (type, op). def __call__(self):; return self.dyn_args. # %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%; # object for each time dependent element of the QobjEvo; # qobj : the Qobj of element ([*Qobj*, f]); # get_coeff : a callable that take (t, args) and return the coeff at that t; # coeff : The coeff as a string, array or function as provided by the user.; # type : flag for the type of coeff; class EvoElement:; """"""; Internal type used to represent the time-dependent parts of a; :class:`~qutip.QobjEvo`. Availables ""types"" are. 1. function; 2. string; 3. ``np.ndarray``; 4. :class:`.Cubic_Spline`; """""". def __init__(self, qobj, get_coeff, coeff, type):; self.qobj = qobj; self.get_coeff = get_coeff; self.coeff = coeff; self.type = type. @classmethod; def make(cls, list_):; return cls(*list_). def __getitem__(self, i):; if i == 0:; return self.qobj; if i == 1:; return self.get_coeff; if i == 2:; return self.coeff; if i == 3:; return self.type. [docs]class QobjEvo:; """"""; A class for representing time-dependent quantum objects, such as quantum; operators and states. Basic math operations are defined:. - ``+``, ``-`` : :class:`~qutip.QobjEvo`, :class:`~qutip.Qobj`, scalars.; - ``*``: :class:`~qutip.Qobj`, C number; - ``/`` : C number. This object is constructed by passing a list of :obj:`~qutip.Qobj`; instances, each of which *may* have an associated scalar time dependence.; The list is summed to produce the final",MatchSource.WIKI,docs/4.7/modules/qutip/qobjevo.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qobjevo.html
https://qutip.org/docs/4.7/modules/qutip/qobjevo.html:4700,Integrability,depend,dependent,4700,"). def __call__(self):; return self.dyn_args. # %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%; # object for each time dependent element of the QobjEvo; # qobj : the Qobj of element ([*Qobj*, f]); # get_coeff : a callable that take (t, args) and return the coeff at that t; # coeff : The coeff as a string, array or function as provided by the user.; # type : flag for the type of coeff; class EvoElement:; """"""; Internal type used to represent the time-dependent parts of a; :class:`~qutip.QobjEvo`. Availables ""types"" are. 1. function; 2. string; 3. ``np.ndarray``; 4. :class:`.Cubic_Spline`; """""". def __init__(self, qobj, get_coeff, coeff, type):; self.qobj = qobj; self.get_coeff = get_coeff; self.coeff = coeff; self.type = type. @classmethod; def make(cls, list_):; return cls(*list_). def __getitem__(self, i):; if i == 0:; return self.qobj; if i == 1:; return self.get_coeff; if i == 2:; return self.coeff; if i == 3:; return self.type. [docs]class QobjEvo:; """"""; A class for representing time-dependent quantum objects, such as quantum; operators and states. Basic math operations are defined:. - ``+``, ``-`` : :class:`~qutip.QobjEvo`, :class:`~qutip.Qobj`, scalars.; - ``*``: :class:`~qutip.Qobj`, C number; - ``/`` : C number. This object is constructed by passing a list of :obj:`~qutip.Qobj`; instances, each of which *may* have an associated scalar time dependence.; The list is summed to produce the final result. In other words, if an; instance of this class is :math:`Q(t)`, then it is constructed from a set; of constant:obj:`~qutip.Qobj` :math:`\\{Q_k\\}` and time-dependent scalars; :math:`f_k(t)` by. .. math::. Q(t) = \\sum_k f_k(t) Q_k. If a scalar :math:`f_k(t)` is not passed with a given :obj:`~qutip.Qobj`,; then that term is assumed to be constant. The next section contains more; detail on the allowed forms of the constants, and gives several examples; for how to build instances of this class. **Time-dependence formats**. There are three major formats for specifying a time",MatchSource.WIKI,docs/4.7/modules/qutip/qobjevo.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qobjevo.html
https://qutip.org/docs/4.7/modules/qutip/qobjevo.html:5067,Integrability,depend,dependence,5067," the user.; # type : flag for the type of coeff; class EvoElement:; """"""; Internal type used to represent the time-dependent parts of a; :class:`~qutip.QobjEvo`. Availables ""types"" are. 1. function; 2. string; 3. ``np.ndarray``; 4. :class:`.Cubic_Spline`; """""". def __init__(self, qobj, get_coeff, coeff, type):; self.qobj = qobj; self.get_coeff = get_coeff; self.coeff = coeff; self.type = type. @classmethod; def make(cls, list_):; return cls(*list_). def __getitem__(self, i):; if i == 0:; return self.qobj; if i == 1:; return self.get_coeff; if i == 2:; return self.coeff; if i == 3:; return self.type. [docs]class QobjEvo:; """"""; A class for representing time-dependent quantum objects, such as quantum; operators and states. Basic math operations are defined:. - ``+``, ``-`` : :class:`~qutip.QobjEvo`, :class:`~qutip.Qobj`, scalars.; - ``*``: :class:`~qutip.Qobj`, C number; - ``/`` : C number. This object is constructed by passing a list of :obj:`~qutip.Qobj`; instances, each of which *may* have an associated scalar time dependence.; The list is summed to produce the final result. In other words, if an; instance of this class is :math:`Q(t)`, then it is constructed from a set; of constant:obj:`~qutip.Qobj` :math:`\\{Q_k\\}` and time-dependent scalars; :math:`f_k(t)` by. .. math::. Q(t) = \\sum_k f_k(t) Q_k. If a scalar :math:`f_k(t)` is not passed with a given :obj:`~qutip.Qobj`,; then that term is assumed to be constant. The next section contains more; detail on the allowed forms of the constants, and gives several examples; for how to build instances of this class. **Time-dependence formats**. There are three major formats for specifying a time-dependent scalar:. - Python function; - string; - array. For function format, the function signature must be; ``f(t: float, args: dict) -> complex``, for example. .. code-block:: python. def f1_t(t, args):; return np.exp(-1j * t * args[""w1""]). def f2_t(t, args):; return np.cos(t * args[""w2""]). H = QobjEvo([H0, [H1, f1_t], [H2, f2_t",MatchSource.WIKI,docs/4.7/modules/qutip/qobjevo.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qobjevo.html
https://qutip.org/docs/4.7/modules/qutip/qobjevo.html:5283,Integrability,depend,dependent,5283,"pline`; """""". def __init__(self, qobj, get_coeff, coeff, type):; self.qobj = qobj; self.get_coeff = get_coeff; self.coeff = coeff; self.type = type. @classmethod; def make(cls, list_):; return cls(*list_). def __getitem__(self, i):; if i == 0:; return self.qobj; if i == 1:; return self.get_coeff; if i == 2:; return self.coeff; if i == 3:; return self.type. [docs]class QobjEvo:; """"""; A class for representing time-dependent quantum objects, such as quantum; operators and states. Basic math operations are defined:. - ``+``, ``-`` : :class:`~qutip.QobjEvo`, :class:`~qutip.Qobj`, scalars.; - ``*``: :class:`~qutip.Qobj`, C number; - ``/`` : C number. This object is constructed by passing a list of :obj:`~qutip.Qobj`; instances, each of which *may* have an associated scalar time dependence.; The list is summed to produce the final result. In other words, if an; instance of this class is :math:`Q(t)`, then it is constructed from a set; of constant:obj:`~qutip.Qobj` :math:`\\{Q_k\\}` and time-dependent scalars; :math:`f_k(t)` by. .. math::. Q(t) = \\sum_k f_k(t) Q_k. If a scalar :math:`f_k(t)` is not passed with a given :obj:`~qutip.Qobj`,; then that term is assumed to be constant. The next section contains more; detail on the allowed forms of the constants, and gives several examples; for how to build instances of this class. **Time-dependence formats**. There are three major formats for specifying a time-dependent scalar:. - Python function; - string; - array. For function format, the function signature must be; ``f(t: float, args: dict) -> complex``, for example. .. code-block:: python. def f1_t(t, args):; return np.exp(-1j * t * args[""w1""]). def f2_t(t, args):; return np.cos(t * args[""w2""]). H = QobjEvo([H0, [H1, f1_t], [H2, f2_t]], args={""w1"":1., ""w2"":2.}). For string-based coeffients, the string must be a compilable python code; resulting in a complex. The following symbols are defined:. .. code-block::. pi exp log log10; erf zerf norm proj; real imag conj abs arg; sin ",MatchSource.WIKI,docs/4.7/modules/qutip/qobjevo.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qobjevo.html
https://qutip.org/docs/4.7/modules/qutip/qobjevo.html:5631,Integrability,depend,dependence,5631,"type. [docs]class QobjEvo:; """"""; A class for representing time-dependent quantum objects, such as quantum; operators and states. Basic math operations are defined:. - ``+``, ``-`` : :class:`~qutip.QobjEvo`, :class:`~qutip.Qobj`, scalars.; - ``*``: :class:`~qutip.Qobj`, C number; - ``/`` : C number. This object is constructed by passing a list of :obj:`~qutip.Qobj`; instances, each of which *may* have an associated scalar time dependence.; The list is summed to produce the final result. In other words, if an; instance of this class is :math:`Q(t)`, then it is constructed from a set; of constant:obj:`~qutip.Qobj` :math:`\\{Q_k\\}` and time-dependent scalars; :math:`f_k(t)` by. .. math::. Q(t) = \\sum_k f_k(t) Q_k. If a scalar :math:`f_k(t)` is not passed with a given :obj:`~qutip.Qobj`,; then that term is assumed to be constant. The next section contains more; detail on the allowed forms of the constants, and gives several examples; for how to build instances of this class. **Time-dependence formats**. There are three major formats for specifying a time-dependent scalar:. - Python function; - string; - array. For function format, the function signature must be; ``f(t: float, args: dict) -> complex``, for example. .. code-block:: python. def f1_t(t, args):; return np.exp(-1j * t * args[""w1""]). def f2_t(t, args):; return np.cos(t * args[""w2""]). H = QobjEvo([H0, [H1, f1_t], [H2, f2_t]], args={""w1"":1., ""w2"":2.}). For string-based coeffients, the string must be a compilable python code; resulting in a complex. The following symbols are defined:. .. code-block::. pi exp log log10; erf zerf norm proj; real imag conj abs arg; sin sinh asin asinh; cos cosh acos acosh; tan tanh atan atanh; numpy as np; scipy.special as spe. A couple more simple examples:. .. code-block:: python. H = QobjEvo([H0, [H1, 'exp(-1j*w1*t)'], [H2, 'cos(w2*t)']],; args={""w1"":1.,""w2"":2.}). For numpy array format, the array must be an 1d of dtype ``np.float64`` or; ``np.complex128``. A list of times (``np.",MatchSource.WIKI,docs/4.7/modules/qutip/qobjevo.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qobjevo.html
https://qutip.org/docs/4.7/modules/qutip/qobjevo.html:5705,Integrability,depend,dependent,5705,"senting time-dependent quantum objects, such as quantum; operators and states. Basic math operations are defined:. - ``+``, ``-`` : :class:`~qutip.QobjEvo`, :class:`~qutip.Qobj`, scalars.; - ``*``: :class:`~qutip.Qobj`, C number; - ``/`` : C number. This object is constructed by passing a list of :obj:`~qutip.Qobj`; instances, each of which *may* have an associated scalar time dependence.; The list is summed to produce the final result. In other words, if an; instance of this class is :math:`Q(t)`, then it is constructed from a set; of constant:obj:`~qutip.Qobj` :math:`\\{Q_k\\}` and time-dependent scalars; :math:`f_k(t)` by. .. math::. Q(t) = \\sum_k f_k(t) Q_k. If a scalar :math:`f_k(t)` is not passed with a given :obj:`~qutip.Qobj`,; then that term is assumed to be constant. The next section contains more; detail on the allowed forms of the constants, and gives several examples; for how to build instances of this class. **Time-dependence formats**. There are three major formats for specifying a time-dependent scalar:. - Python function; - string; - array. For function format, the function signature must be; ``f(t: float, args: dict) -> complex``, for example. .. code-block:: python. def f1_t(t, args):; return np.exp(-1j * t * args[""w1""]). def f2_t(t, args):; return np.cos(t * args[""w2""]). H = QobjEvo([H0, [H1, f1_t], [H2, f2_t]], args={""w1"":1., ""w2"":2.}). For string-based coeffients, the string must be a compilable python code; resulting in a complex. The following symbols are defined:. .. code-block::. pi exp log log10; erf zerf norm proj; real imag conj abs arg; sin sinh asin asinh; cos cosh acos acosh; tan tanh atan atanh; numpy as np; scipy.special as spe. A couple more simple examples:. .. code-block:: python. H = QobjEvo([H0, [H1, 'exp(-1j*w1*t)'], [H2, 'cos(w2*t)']],; args={""w1"":1.,""w2"":2.}). For numpy array format, the array must be an 1d of dtype ``np.float64`` or; ``np.complex128``. A list of times (``np.float64``) at which the; coeffients must be given ",MatchSource.WIKI,docs/4.7/modules/qutip/qobjevo.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qobjevo.html
https://qutip.org/docs/4.7/modules/qutip/qobjevo.html:8342,Integrability,depend,depending,8342,"sing arguments**. ``args`` is a dict of (name: object). The name must be a valid Python; identifier string, and in general the object can be any type that is; supported by the code to be compiled in the string. There are some ""magic"" names that can be specified, whose objects will be; overwritten when used within :func:`.sesolve`, :func:`.mesolve` and; :func:`.mcsolve`. This allows access to the solvers' internal states, and; they are updated at every call. The initial values of these dictionary; elements is unimportant. The magic names available are:. - ``""state""``: the current state as a :class:`~qutip.Qobj`; - ``""state_vec""``: the current state as a column-stacked 1D ``np.ndarray``; - ``""state_mat""``: the current state as a 2D ``np.ndarray``; - ``""expect_op_<n>""``: the current expectation value of the element; ``e_ops[n]``, which is an argument to the solvers. Replace ``<n>`` with; an integer literal, e.g. ``""expect_op_0""``. This will be either real- or; complex-valued, depending on whether the state and operator are both; Hermitian or not.; - ``""collapse""``: (:func:`.mcsolve` only) a list of the collapses that have; occurred during the evolution. Each element of the list is a 2-tuple; ``(time: float, which: int)``, where ``time`` is the time this collapse; happened, and ``which`` is an integer indexing the ``c_ops`` argument to; :func:`.mcsolve`. Parameters; ----------; Q_object : list, :class:`~qutip.Qobj` or :class:`~qutip.QobjEvo`; The time-dependent description of the quantum object. This is of the; same format as the first parameter to the general ODE solvers; in; general, it is a list of ``[Qobj, time_dependence]`` pairs that are; summed to make the whole object. The ``time_dependence`` can be any of; the formats discussed in the previous section. If a particular term; has no time-dependence, then you should just give the ``Qobj`` instead; of the 2-element list. args : dict, optional; Mapping of ``{str: object}``, discussed in greater detail above. The; st",MatchSource.WIKI,docs/4.7/modules/qutip/qobjevo.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qobjevo.html
https://qutip.org/docs/4.7/modules/qutip/qobjevo.html:8826,Integrability,depend,dependent,8826,"these dictionary; elements is unimportant. The magic names available are:. - ``""state""``: the current state as a :class:`~qutip.Qobj`; - ``""state_vec""``: the current state as a column-stacked 1D ``np.ndarray``; - ``""state_mat""``: the current state as a 2D ``np.ndarray``; - ``""expect_op_<n>""``: the current expectation value of the element; ``e_ops[n]``, which is an argument to the solvers. Replace ``<n>`` with; an integer literal, e.g. ``""expect_op_0""``. This will be either real- or; complex-valued, depending on whether the state and operator are both; Hermitian or not.; - ``""collapse""``: (:func:`.mcsolve` only) a list of the collapses that have; occurred during the evolution. Each element of the list is a 2-tuple; ``(time: float, which: int)``, where ``time`` is the time this collapse; happened, and ``which`` is an integer indexing the ``c_ops`` argument to; :func:`.mcsolve`. Parameters; ----------; Q_object : list, :class:`~qutip.Qobj` or :class:`~qutip.QobjEvo`; The time-dependent description of the quantum object. This is of the; same format as the first parameter to the general ODE solvers; in; general, it is a list of ``[Qobj, time_dependence]`` pairs that are; summed to make the whole object. The ``time_dependence`` can be any of; the formats discussed in the previous section. If a particular term; has no time-dependence, then you should just give the ``Qobj`` instead; of the 2-element list. args : dict, optional; Mapping of ``{str: object}``, discussed in greater detail above. The; strings can be any valid Python identifier, and the objects are of the; consumable types. See the previous section for details on the ""magic""; names used to access solver internals. tlist : array_like, optional; List of the times any numpy-array coefficients describe. This is used; only in at least one of the time dependences in ``Q_object`` is given; in Numpy-array format. The times must be sorted, but need not be; equidistant. Values inbetween will be interpolated. Attributes; ---",MatchSource.WIKI,docs/4.7/modules/qutip/qobjevo.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qobjevo.html
https://qutip.org/docs/4.7/modules/qutip/qobjevo.html:9176,Integrability,depend,dependence,9176,"is an argument to the solvers. Replace ``<n>`` with; an integer literal, e.g. ``""expect_op_0""``. This will be either real- or; complex-valued, depending on whether the state and operator are both; Hermitian or not.; - ``""collapse""``: (:func:`.mcsolve` only) a list of the collapses that have; occurred during the evolution. Each element of the list is a 2-tuple; ``(time: float, which: int)``, where ``time`` is the time this collapse; happened, and ``which`` is an integer indexing the ``c_ops`` argument to; :func:`.mcsolve`. Parameters; ----------; Q_object : list, :class:`~qutip.Qobj` or :class:`~qutip.QobjEvo`; The time-dependent description of the quantum object. This is of the; same format as the first parameter to the general ODE solvers; in; general, it is a list of ``[Qobj, time_dependence]`` pairs that are; summed to make the whole object. The ``time_dependence`` can be any of; the formats discussed in the previous section. If a particular term; has no time-dependence, then you should just give the ``Qobj`` instead; of the 2-element list. args : dict, optional; Mapping of ``{str: object}``, discussed in greater detail above. The; strings can be any valid Python identifier, and the objects are of the; consumable types. See the previous section for details on the ""magic""; names used to access solver internals. tlist : array_like, optional; List of the times any numpy-array coefficients describe. This is used; only in at least one of the time dependences in ``Q_object`` is given; in Numpy-array format. The times must be sorted, but need not be; equidistant. Values inbetween will be interpolated. Attributes; ----------; cte : :class:`~qutip.Qobj`; Constant part of the QobjEvo. ops : list of :class:`.EvoElement`; Internal representation of the time-dependence structure of the; elements. args : dict; The current value of the ``args`` dictionary passed into the; constructor. dynamics_args : list; Names of the dynamic arguments that the solvers will generate. These; are",MatchSource.WIKI,docs/4.7/modules/qutip/qobjevo.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qobjevo.html
https://qutip.org/docs/4.7/modules/qutip/qobjevo.html:9668,Integrability,depend,dependences,9668,"ndexing the ``c_ops`` argument to; :func:`.mcsolve`. Parameters; ----------; Q_object : list, :class:`~qutip.Qobj` or :class:`~qutip.QobjEvo`; The time-dependent description of the quantum object. This is of the; same format as the first parameter to the general ODE solvers; in; general, it is a list of ``[Qobj, time_dependence]`` pairs that are; summed to make the whole object. The ``time_dependence`` can be any of; the formats discussed in the previous section. If a particular term; has no time-dependence, then you should just give the ``Qobj`` instead; of the 2-element list. args : dict, optional; Mapping of ``{str: object}``, discussed in greater detail above. The; strings can be any valid Python identifier, and the objects are of the; consumable types. See the previous section for details on the ""magic""; names used to access solver internals. tlist : array_like, optional; List of the times any numpy-array coefficients describe. This is used; only in at least one of the time dependences in ``Q_object`` is given; in Numpy-array format. The times must be sorted, but need not be; equidistant. Values inbetween will be interpolated. Attributes; ----------; cte : :class:`~qutip.Qobj`; Constant part of the QobjEvo. ops : list of :class:`.EvoElement`; Internal representation of the time-dependence structure of the; elements. args : dict; The current value of the ``args`` dictionary passed into the; constructor. dynamics_args : list; Names of the dynamic arguments that the solvers will generate. These; are the magic names that were found in the ``args`` parameter. tlist : array_like; List of times at which the numpy-array coefficients are applied. compiled : str; A string representing the properties of the low-level Cython class; backing this object (may be empty). compiled_qobjevo : ``CQobjCte`` or ``CQobjEvoTd``; Cython version of the QobjEvo. coeff_get : callable; Object called to obtain a list of all the coefficients at a particular; time. coeff_files : list; Runtime",MatchSource.WIKI,docs/4.7/modules/qutip/qobjevo.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qobjevo.html
https://qutip.org/docs/4.7/modules/qutip/qobjevo.html:9978,Integrability,depend,dependence,9978,"ist of ``[Qobj, time_dependence]`` pairs that are; summed to make the whole object. The ``time_dependence`` can be any of; the formats discussed in the previous section. If a particular term; has no time-dependence, then you should just give the ``Qobj`` instead; of the 2-element list. args : dict, optional; Mapping of ``{str: object}``, discussed in greater detail above. The; strings can be any valid Python identifier, and the objects are of the; consumable types. See the previous section for details on the ""magic""; names used to access solver internals. tlist : array_like, optional; List of the times any numpy-array coefficients describe. This is used; only in at least one of the time dependences in ``Q_object`` is given; in Numpy-array format. The times must be sorted, but need not be; equidistant. Values inbetween will be interpolated. Attributes; ----------; cte : :class:`~qutip.Qobj`; Constant part of the QobjEvo. ops : list of :class:`.EvoElement`; Internal representation of the time-dependence structure of the; elements. args : dict; The current value of the ``args`` dictionary passed into the; constructor. dynamics_args : list; Names of the dynamic arguments that the solvers will generate. These; are the magic names that were found in the ``args`` parameter. tlist : array_like; List of times at which the numpy-array coefficients are applied. compiled : str; A string representing the properties of the low-level Cython class; backing this object (may be empty). compiled_qobjevo : ``CQobjCte`` or ``CQobjEvoTd``; Cython version of the QobjEvo. coeff_get : callable; Object called to obtain a list of all the coefficients at a particular; time. coeff_files : list; Runtime created files to delete with the instance. dummy_cte : bool; Is self.cte an empty Qobj. const : bool; Indicates if quantum object is constant. type : {""cte"", ""string"", ""func"", ""array"", ""spline"", ""mixed_callable"", \; ""mixed_compilable""}; Information about the type of coefficients used in the entire",MatchSource.WIKI,docs/4.7/modules/qutip/qobjevo.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qobjevo.html
https://qutip.org/docs/4.7/modules/qutip/qobjevo.html:12108,Integrability,depend,dependent,12108,"le : bool; Flag to not share pointers between thread.; """""". def __init__(self, Q_object=[], args={}, copy=True,; tlist=None, state0=None, e_ops=[]):; if isinstance(Q_object, QobjEvo):; if copy:; self._inplace_copy(Q_object); else:; self.__dict__ = Q_object.__dict__; if args:; self.arguments(args); for i, dargs in enumerate(self.dynamics_args):; e_int = dargs[1] == ""expect"" and isinstance(dargs[2], int); if e_ops and e_int:; self.dynamics_args[i] = (dargs[0], ""expect"",; e_ops[dargs[2]]); if state0 is not None:; self._dynamics_args_update(0., state0); return. self.const = False; self.dummy_cte = False; self.args = args.copy(); self.dynamics_args = []; self.cte = None; self.tlist = np.asarray(tlist) if tlist is not None else None; self.compiled = """"; self.compiled_qobjevo = None; self.coeff_get = None; self.type = ""none""; self.omp = 0; self.coeff_files = []; self.use_cython = use_cython[0]; self.safePickle = safePickle[0]. # Attempt to determine if a 2-element list is a single, time-dependent; # operator, or a list with 2 possibly time-dependent elements.; if isinstance(Q_object, list) and len(Q_object) == 2:; try:; # Test if parsing succeeds on this as a single element.; self._td_op_type(Q_object); Q_object = [Q_object]; except (TypeError, ValueError):; pass. op_type = self._td_format_check(Q_object); self.ops = []. if isinstance(op_type, int):; if op_type == 0:; self.cte = Q_object; self.const = True; self.type = ""cte""; elif op_type == 1:; raise TypeError(""The Qobj must not already be a function""); elif op_type == -1:; pass; else:; op_type_count = [0, 0, 0, 0]; for type_, op in zip(op_type, Q_object):; if type_ == 0:; if self.cte is None:; self.cte = op; else:; self.cte += op; elif type_ == 1:; op_type_count[0] += 1; self.ops.append(EvoElement(op[0], op[1], op[1], ""func"")); elif type_ == 2:; op_type_count[1] += 1; self.ops.append(EvoElement(op[0], _StrWrapper(op[1]),; op[1], ""string"")); elif type_ == 3:; op_type_count[2] += 1; self.ops.append(EvoElement(; op[0],; _Cub",MatchSource.WIKI,docs/4.7/modules/qutip/qobjevo.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qobjevo.html
https://qutip.org/docs/4.7/modules/qutip/qobjevo.html:12162,Integrability,depend,dependent,12162,"le : bool; Flag to not share pointers between thread.; """""". def __init__(self, Q_object=[], args={}, copy=True,; tlist=None, state0=None, e_ops=[]):; if isinstance(Q_object, QobjEvo):; if copy:; self._inplace_copy(Q_object); else:; self.__dict__ = Q_object.__dict__; if args:; self.arguments(args); for i, dargs in enumerate(self.dynamics_args):; e_int = dargs[1] == ""expect"" and isinstance(dargs[2], int); if e_ops and e_int:; self.dynamics_args[i] = (dargs[0], ""expect"",; e_ops[dargs[2]]); if state0 is not None:; self._dynamics_args_update(0., state0); return. self.const = False; self.dummy_cte = False; self.args = args.copy(); self.dynamics_args = []; self.cte = None; self.tlist = np.asarray(tlist) if tlist is not None else None; self.compiled = """"; self.compiled_qobjevo = None; self.coeff_get = None; self.type = ""none""; self.omp = 0; self.coeff_files = []; self.use_cython = use_cython[0]; self.safePickle = safePickle[0]. # Attempt to determine if a 2-element list is a single, time-dependent; # operator, or a list with 2 possibly time-dependent elements.; if isinstance(Q_object, list) and len(Q_object) == 2:; try:; # Test if parsing succeeds on this as a single element.; self._td_op_type(Q_object); Q_object = [Q_object]; except (TypeError, ValueError):; pass. op_type = self._td_format_check(Q_object); self.ops = []. if isinstance(op_type, int):; if op_type == 0:; self.cte = Q_object; self.const = True; self.type = ""cte""; elif op_type == 1:; raise TypeError(""The Qobj must not already be a function""); elif op_type == -1:; pass; else:; op_type_count = [0, 0, 0, 0]; for type_, op in zip(op_type, Q_object):; if type_ == 0:; if self.cte is None:; self.cte = op; else:; self.cte += op; elif type_ == 1:; op_type_count[0] += 1; self.ops.append(EvoElement(op[0], op[1], op[1], ""func"")); elif type_ == 2:; op_type_count[1] += 1; self.ops.append(EvoElement(op[0], _StrWrapper(op[1]),; op[1], ""string"")); elif type_ == 3:; op_type_count[2] += 1; self.ops.append(EvoElement(; op[0],; _Cub",MatchSource.WIKI,docs/4.7/modules/qutip/qobjevo.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qobjevo.html
https://qutip.org/docs/4.7/modules/qutip/qobjevo.html:30265,Integrability,depend,dependence,30265," ""("" + self.ops[_set[0]].coeff + "")""; for i in _set[1:]:; new_str += "" + ("" + self.ops[i].coeff + "")""; new_op[1] = _StrWrapper(new_str); new_op[2] = new_str; new_ops.append(EvoElement.make(new_op)). elif self.ops[_set[0]].type == ""array"":; new_op = [self.ops[_set[0]].qobj, None, None, ""array""]; new_array = (self.ops[_set[0]].coeff).copy(); for i in _set[1:]:; new_array += self.ops[i].coeff; new_op[2] = new_array; new_op[1] = _CubicSplineWrapper(; self.tlist, new_array, args=self.args); new_ops.append(EvoElement.make(new_op)). self.ops = new_ops. def _compress_merge_func(self, fsets):; new_ops = []; for _set in fsets:; base = self.ops[_set[0]]; new_op = [None, base.get_coeff, base.coeff, base.type]; if len(_set) == 1:; new_op[0] = base.qobj; else:; new_op[0] = base.qobj.copy(); for i in _set[1:]:; new_op[0] += self.ops[i].qobj; new_ops.append(EvoElement.make(new_op)); self.ops = new_ops. [docs] def compress(self):; """"""; Merge together elements that share the same time-dependence, to reduce; the number of matrix multiplications and additions that need to be done; to evaluate this object. Modifies the object inplace.; """"""; self.tidyup(); sets, fsets = self._compress_make_set(); N_sets = len(sets); N_fsets = len(fsets); num_ops = len(self.ops). if N_sets < num_ops and N_fsets < num_ops:; # Both could be better; self.compiled = """"; self.compiled_qobjevo = None; self.coeff_get = None; if N_sets < N_fsets:; self._compress_merge_qobj(sets); else:; self._compress_merge_func(fsets); sets, fsets = self._compress_make_set(); N_sets = len(sets); N_fsets = len(fsets); num_ops = len(self.ops). if N_sets < num_ops:; self.compiled = """"; self.compiled_qobjevo = None; self.coeff_get = None; self._compress_merge_qobj(sets); elif N_fsets < num_ops:; self.compiled = """"; self.compiled_qobjevo = None; self.coeff_get = None; self._compress_merge_func(fsets); self._reset_type(). def _reset_type(self):; op_type_count = [0, 0, 0, 0]; for op in self.ops:; if op.type == ""func"":; op_type_count[0] ",MatchSource.WIKI,docs/4.7/modules/qutip/qobjevo.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qobjevo.html
https://qutip.org/docs/4.7/modules/qutip/qobjevo.html:32371,Integrability,depend,dependent,32371," += 1; elif op.type == ""array"":; op_type_count[2] += 1; elif op.type == ""spline"":; op_type_count[3] += 1. nops = sum(op_type_count); if not self.ops and self.dummy_cte is False:; self.type = ""cte""; elif op_type_count[0] == nops:; self.type = ""func""; elif op_type_count[1] == nops:; self.type = ""string""; elif op_type_count[2] == nops:; self.type = ""array""; elif op_type_count[3] == nops:; self.type = ""spline""; elif op_type_count[0]:; self.type = ""mixed_callable""; else:; self.type = ""mixed_compilable"". self.num_obj = (len(self.ops) if self.dummy_cte else len(self.ops) + 1). [docs] def permute(self, order):; """"""; Permute the tensor structure of the underlying matrices into a new; format. See Also; --------; Qobj.permute : the same operation on constant quantum objects.; """"""; res = self.copy(); res.cte = res.cte.permute(order); for op in res.ops:; op.qobj = op.qobj.permute(order); return res. [docs] def apply(self, function, *args, **kw_args):; """"""; Apply the linear function ``function`` to every ``Qobj`` included in; this time-dependent object, and return a new ``QobjEvo`` with the; result. Any additional arguments or keyword arguments will be appended to every; function call.; """"""; self.compiled = """"; res = self.copy(); cte_res = function(res.cte, *args, **kw_args); if not isinstance(cte_res, Qobj):; raise TypeError(""The function must return a Qobj""); res.cte = cte_res; for op in res.ops:; op.qobj = function(op.qobj, *args, **kw_args); return res. [docs] def apply_decorator(self, function, *args,; str_mod=None, inplace_np=False, **kw_args):; """"""; Apply the given function to every time-dependent coefficient in the; quantum object, and return a new object with the result. Any additional arguments and keyword arguments will be appended to the; function calls. Parameters; ----------; function : callable; ``(time_dependence, *args, **kwargs) -> time_dependence``. Called; on each time-dependent coefficient to produce a new coefficient.; The additional arguments and keyword arg",MatchSource.WIKI,docs/4.7/modules/qutip/qobjevo.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qobjevo.html
https://qutip.org/docs/4.7/modules/qutip/qobjevo.html:32941,Integrability,depend,dependent,32941,"cs] def permute(self, order):; """"""; Permute the tensor structure of the underlying matrices into a new; format. See Also; --------; Qobj.permute : the same operation on constant quantum objects.; """"""; res = self.copy(); res.cte = res.cte.permute(order); for op in res.ops:; op.qobj = op.qobj.permute(order); return res. [docs] def apply(self, function, *args, **kw_args):; """"""; Apply the linear function ``function`` to every ``Qobj`` included in; this time-dependent object, and return a new ``QobjEvo`` with the; result. Any additional arguments or keyword arguments will be appended to every; function call.; """"""; self.compiled = """"; res = self.copy(); cte_res = function(res.cte, *args, **kw_args); if not isinstance(cte_res, Qobj):; raise TypeError(""The function must return a Qobj""); res.cte = cte_res; for op in res.ops:; op.qobj = function(op.qobj, *args, **kw_args); return res. [docs] def apply_decorator(self, function, *args,; str_mod=None, inplace_np=False, **kw_args):; """"""; Apply the given function to every time-dependent coefficient in the; quantum object, and return a new object with the result. Any additional arguments and keyword arguments will be appended to the; function calls. Parameters; ----------; function : callable; ``(time_dependence, *args, **kwargs) -> time_dependence``. Called; on each time-dependent coefficient to produce a new coefficient.; The additional arguments and keyword arguments are the ones given; to this function. str_mod : list; A 2-element list of strings, that will additionally wrap any string; time-dependences. An existing time-dependence string ``x`` will; become ``str_mod[0] + x + str_mod[1]``. inplace_np : bool, default False; Whether this function should modify Numpy arrays inplace, or be; used like a regular decorator. Some decorators create incorrect; arrays as some transformations ``f'(t) = f(g(t))`` create a; mismatch between the array and the associated time list.; """"""; res = self.copy(); for op in res.ops:; op.get_coeff = fun",MatchSource.WIKI,docs/4.7/modules/qutip/qobjevo.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qobjevo.html
https://qutip.org/docs/4.7/modules/qutip/qobjevo.html:33241,Integrability,depend,dependent,33241," function, *args, **kw_args):; """"""; Apply the linear function ``function`` to every ``Qobj`` included in; this time-dependent object, and return a new ``QobjEvo`` with the; result. Any additional arguments or keyword arguments will be appended to every; function call.; """"""; self.compiled = """"; res = self.copy(); cte_res = function(res.cte, *args, **kw_args); if not isinstance(cte_res, Qobj):; raise TypeError(""The function must return a Qobj""); res.cte = cte_res; for op in res.ops:; op.qobj = function(op.qobj, *args, **kw_args); return res. [docs] def apply_decorator(self, function, *args,; str_mod=None, inplace_np=False, **kw_args):; """"""; Apply the given function to every time-dependent coefficient in the; quantum object, and return a new object with the result. Any additional arguments and keyword arguments will be appended to the; function calls. Parameters; ----------; function : callable; ``(time_dependence, *args, **kwargs) -> time_dependence``. Called; on each time-dependent coefficient to produce a new coefficient.; The additional arguments and keyword arguments are the ones given; to this function. str_mod : list; A 2-element list of strings, that will additionally wrap any string; time-dependences. An existing time-dependence string ``x`` will; become ``str_mod[0] + x + str_mod[1]``. inplace_np : bool, default False; Whether this function should modify Numpy arrays inplace, or be; used like a regular decorator. Some decorators create incorrect; arrays as some transformations ``f'(t) = f(g(t))`` create a; mismatch between the array and the associated time list.; """"""; res = self.copy(); for op in res.ops:; op.get_coeff = function(op.get_coeff, *args, **kw_args); if op.type == [""func"", ""spline""]:; op.coeff = op.get_coeff; op.type = ""func""; elif op.type == ""string"":; if str_mod is None:; op.coeff = op.get_coeff; op.type = ""func""; else:; op.coeff = str_mod[0] + op.coeff + str_mod[1]; elif op.type == ""array"":; if inplace_np:; # keep the original function, change t",MatchSource.WIKI,docs/4.7/modules/qutip/qobjevo.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qobjevo.html
https://qutip.org/docs/4.7/modules/qutip/qobjevo.html:33447,Integrability,wrap,wrap,33447,"esult. Any additional arguments or keyword arguments will be appended to every; function call.; """"""; self.compiled = """"; res = self.copy(); cte_res = function(res.cte, *args, **kw_args); if not isinstance(cte_res, Qobj):; raise TypeError(""The function must return a Qobj""); res.cte = cte_res; for op in res.ops:; op.qobj = function(op.qobj, *args, **kw_args); return res. [docs] def apply_decorator(self, function, *args,; str_mod=None, inplace_np=False, **kw_args):; """"""; Apply the given function to every time-dependent coefficient in the; quantum object, and return a new object with the result. Any additional arguments and keyword arguments will be appended to the; function calls. Parameters; ----------; function : callable; ``(time_dependence, *args, **kwargs) -> time_dependence``. Called; on each time-dependent coefficient to produce a new coefficient.; The additional arguments and keyword arguments are the ones given; to this function. str_mod : list; A 2-element list of strings, that will additionally wrap any string; time-dependences. An existing time-dependence string ``x`` will; become ``str_mod[0] + x + str_mod[1]``. inplace_np : bool, default False; Whether this function should modify Numpy arrays inplace, or be; used like a regular decorator. Some decorators create incorrect; arrays as some transformations ``f'(t) = f(g(t))`` create a; mismatch between the array and the associated time list.; """"""; res = self.copy(); for op in res.ops:; op.get_coeff = function(op.get_coeff, *args, **kw_args); if op.type == [""func"", ""spline""]:; op.coeff = op.get_coeff; op.type = ""func""; elif op.type == ""string"":; if str_mod is None:; op.coeff = op.get_coeff; op.type = ""func""; else:; op.coeff = str_mod[0] + op.coeff + str_mod[1]; elif op.type == ""array"":; if inplace_np:; # keep the original function, change the array; def f(a):; return a; ff = function(f, *args, **kw_args); for i, v in enumerate(op.coeff):; op.coeff[i] = ff(v); op.get_coeff = _CubicSplineWrapper(; self.tlist, op.",MatchSource.WIKI,docs/4.7/modules/qutip/qobjevo.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qobjevo.html
https://qutip.org/docs/4.7/modules/qutip/qobjevo.html:33469,Integrability,depend,dependences,33469,"esult. Any additional arguments or keyword arguments will be appended to every; function call.; """"""; self.compiled = """"; res = self.copy(); cte_res = function(res.cte, *args, **kw_args); if not isinstance(cte_res, Qobj):; raise TypeError(""The function must return a Qobj""); res.cte = cte_res; for op in res.ops:; op.qobj = function(op.qobj, *args, **kw_args); return res. [docs] def apply_decorator(self, function, *args,; str_mod=None, inplace_np=False, **kw_args):; """"""; Apply the given function to every time-dependent coefficient in the; quantum object, and return a new object with the result. Any additional arguments and keyword arguments will be appended to the; function calls. Parameters; ----------; function : callable; ``(time_dependence, *args, **kwargs) -> time_dependence``. Called; on each time-dependent coefficient to produce a new coefficient.; The additional arguments and keyword arguments are the ones given; to this function. str_mod : list; A 2-element list of strings, that will additionally wrap any string; time-dependences. An existing time-dependence string ``x`` will; become ``str_mod[0] + x + str_mod[1]``. inplace_np : bool, default False; Whether this function should modify Numpy arrays inplace, or be; used like a regular decorator. Some decorators create incorrect; arrays as some transformations ``f'(t) = f(g(t))`` create a; mismatch between the array and the associated time list.; """"""; res = self.copy(); for op in res.ops:; op.get_coeff = function(op.get_coeff, *args, **kw_args); if op.type == [""func"", ""spline""]:; op.coeff = op.get_coeff; op.type = ""func""; elif op.type == ""string"":; if str_mod is None:; op.coeff = op.get_coeff; op.type = ""func""; else:; op.coeff = str_mod[0] + op.coeff + str_mod[1]; elif op.type == ""array"":; if inplace_np:; # keep the original function, change the array; def f(a):; return a; ff = function(f, *args, **kw_args); for i, v in enumerate(op.coeff):; op.coeff[i] = ff(v); op.get_coeff = _CubicSplineWrapper(; self.tlist, op.",MatchSource.WIKI,docs/4.7/modules/qutip/qobjevo.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qobjevo.html
https://qutip.org/docs/4.7/modules/qutip/qobjevo.html:33499,Integrability,depend,dependence,33499," """"""; self.compiled = """"; res = self.copy(); cte_res = function(res.cte, *args, **kw_args); if not isinstance(cte_res, Qobj):; raise TypeError(""The function must return a Qobj""); res.cte = cte_res; for op in res.ops:; op.qobj = function(op.qobj, *args, **kw_args); return res. [docs] def apply_decorator(self, function, *args,; str_mod=None, inplace_np=False, **kw_args):; """"""; Apply the given function to every time-dependent coefficient in the; quantum object, and return a new object with the result. Any additional arguments and keyword arguments will be appended to the; function calls. Parameters; ----------; function : callable; ``(time_dependence, *args, **kwargs) -> time_dependence``. Called; on each time-dependent coefficient to produce a new coefficient.; The additional arguments and keyword arguments are the ones given; to this function. str_mod : list; A 2-element list of strings, that will additionally wrap any string; time-dependences. An existing time-dependence string ``x`` will; become ``str_mod[0] + x + str_mod[1]``. inplace_np : bool, default False; Whether this function should modify Numpy arrays inplace, or be; used like a regular decorator. Some decorators create incorrect; arrays as some transformations ``f'(t) = f(g(t))`` create a; mismatch between the array and the associated time list.; """"""; res = self.copy(); for op in res.ops:; op.get_coeff = function(op.get_coeff, *args, **kw_args); if op.type == [""func"", ""spline""]:; op.coeff = op.get_coeff; op.type = ""func""; elif op.type == ""string"":; if str_mod is None:; op.coeff = op.get_coeff; op.type = ""func""; else:; op.coeff = str_mod[0] + op.coeff + str_mod[1]; elif op.type == ""array"":; if inplace_np:; # keep the original function, change the array; def f(a):; return a; ff = function(f, *args, **kw_args); for i, v in enumerate(op.coeff):; op.coeff[i] = ff(v); op.get_coeff = _CubicSplineWrapper(; self.tlist, op.coeff, args=self.args); else:; op.coeff = op.get_coeff; op.type = ""func""; if self.type == ""stri",MatchSource.WIKI,docs/4.7/modules/qutip/qobjevo.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qobjevo.html
https://qutip.org/docs/4.7/modules/qutip/qobjevo.html:46782,Integrability,depend,dependence,46782,"s. coeff_files.clean(); if code:; return Code. def _get_coeff(self, t):; out = []; for part in self.ops:; out.append(part.get_coeff(t, self.args)); return out. def __getstate__(self):; _dict_ = {key: self.__dict__[key]; for key in self.__dict__ if key != ""compiled_qobjevo""}; if self.compiled:; return (_dict_, self.compiled_qobjevo.__getstate__()); else:; return (_dict_,). def __setstate__(self, state):; self.__dict__ = state[0]; self.compiled_qobjevo = None; if self.compiled:; mat_type, threading, td = self.compiled.split(); if mat_type == ""csr"":; if self.safePickle:; # __getstate__ and __setstate__ of compiled_qobjevo pass pointers; # In 'safe' mod, these pointers are not used.; if td == ""cte"":; if threading == ""single"":; self.compiled_qobjevo = CQobjCte(); self.compiled_qobjevo.set_data(self.cte); elif threading == ""omp"":; self.compiled_qobjevo = CQobjCteOmp(); self.compiled_qobjevo.set_data(self.cte); self.compiled_qobjevo.set_threads(self.omp); else:; # time dependence is pyfunc or cyfactor; if threading == ""single"":; self.compiled_qobjevo = CQobjEvoTd(); self.compiled_qobjevo.set_data(self.cte, self.ops); elif threading == ""omp"":; self.compiled_qobjevo = CQobjEvoTdOmp(); self.compiled_qobjevo.set_data(self.cte, self.ops); self.compiled_qobjevo.set_threads(self.omp). if td == ""pyfunc"":; self.compiled_qobjevo.set_factor(; func=self.coeff_get); elif td == ""cyfactor"":; self.compiled_qobjevo.set_factor(; obj=self.coeff_get); else:; if td == ""cte"":; if threading == ""single"":; self.compiled_qobjevo = CQobjCte.__new__(CQobjCte); elif threading == ""omp"":; self.compiled_qobjevo = CQobjCteOmp.__new__(; CQobjCteOmp); self.compiled_qobjevo.set_threads(self.omp); else:; # time dependence is pyfunc or cyfactor; if threading == ""single"":; self.compiled_qobjevo = CQobjEvoTd.__new__(; CQobjEvoTd); elif threading == ""omp"":; self.compiled_qobjevo = CQobjEvoTdOmp.__new__(; CQobjEvoTdOmp); self.compiled_qobjevo.set_threads(self.omp); self.compiled_qobjevo.__setstate__(state[1]). eli",MatchSource.WIKI,docs/4.7/modules/qutip/qobjevo.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qobjevo.html
https://qutip.org/docs/4.7/modules/qutip/qobjevo.html:47502,Integrability,depend,dependence,47502,"= ""single"":; self.compiled_qobjevo = CQobjCte(); self.compiled_qobjevo.set_data(self.cte); elif threading == ""omp"":; self.compiled_qobjevo = CQobjCteOmp(); self.compiled_qobjevo.set_data(self.cte); self.compiled_qobjevo.set_threads(self.omp); else:; # time dependence is pyfunc or cyfactor; if threading == ""single"":; self.compiled_qobjevo = CQobjEvoTd(); self.compiled_qobjevo.set_data(self.cte, self.ops); elif threading == ""omp"":; self.compiled_qobjevo = CQobjEvoTdOmp(); self.compiled_qobjevo.set_data(self.cte, self.ops); self.compiled_qobjevo.set_threads(self.omp). if td == ""pyfunc"":; self.compiled_qobjevo.set_factor(; func=self.coeff_get); elif td == ""cyfactor"":; self.compiled_qobjevo.set_factor(; obj=self.coeff_get); else:; if td == ""cte"":; if threading == ""single"":; self.compiled_qobjevo = CQobjCte.__new__(CQobjCte); elif threading == ""omp"":; self.compiled_qobjevo = CQobjCteOmp.__new__(; CQobjCteOmp); self.compiled_qobjevo.set_threads(self.omp); else:; # time dependence is pyfunc or cyfactor; if threading == ""single"":; self.compiled_qobjevo = CQobjEvoTd.__new__(; CQobjEvoTd); elif threading == ""omp"":; self.compiled_qobjevo = CQobjEvoTdOmp.__new__(; CQobjEvoTdOmp); self.compiled_qobjevo.set_threads(self.omp); self.compiled_qobjevo.__setstate__(state[1]). elif mat_type == ""dense"":; if td == ""cte"":; self.compiled_qobjevo = \; CQobjCteDense.__new__(CQobjCteDense); else:; CQobjEvoTdDense.__new__(CQobjEvoTdDense); self.compiled_qobjevo.__setstate__(state[1]). elif mat_type == ""matched"":; if threading == ""single"":; self.compiled_qobjevo = \; CQobjEvoTdMatched.__new__(CQobjEvoTdMatched); elif threading == ""omp"":; self.compiled_qobjevo = \; CQobjEvoTdMatchedOmp.__new__(CQobjEvoTdMatchedOmp); self.compiled_qobjevo.set_threads(self.omp); self.compiled_qobjevo.__setstate__(state[1]). # Function defined inside another function cannot be pickled,; # Using class instead; class _UnitedFuncCaller:; def __init__(self, funclist, args, dynamics_args, cte):; self.funclist = funclist;",MatchSource.WIKI,docs/4.7/modules/qutip/qobjevo.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qobjevo.html
https://qutip.org/docs/4.7/modules/qutip/qobjevo.html:21059,Modifiability,variab,variables,21059,"; new.coeff_get = None; new.coeff_files = []; new.use_cython = self.use_cython; new.safePickle = self.safePickle. for op in self.ops:; if op.type == ""array"":; new_coeff = op.coeff.copy(); else:; new_coeff = op.coeff; new.ops.append(EvoElement(op.qobj.copy(), op.get_coeff,; new_coeff, op.type)). return new. def _inplace_copy(self, other):; self.cte = other.cte; self.const = other.const; self.args = other.args.copy(); self.dynamics_args = other.dynamics_args; self.tlist = other.tlist; self.dummy_cte = other.dummy_cte; self.num_obj = other.num_obj; self.type = other.type; self.compiled = """"; self.compiled_qobjevo = None; self.coeff_get = None; self.ops = []; self.coeff_files = []; self.use_cython = other.use_cython; self.safePickle = other.safePickle. for op in other.ops:; if op.type == ""array"":; new_coeff = op.coeff.copy(); else:; new_coeff = op.coeff; self.ops.append(EvoElement(op.qobj.copy(), op.get_coeff,; new_coeff, op.type)). [docs] def arguments(self, new_args):; """"""; Update the scoped variables that were passed as ``args`` to new values.; """"""; if not isinstance(new_args, dict):; raise TypeError(""The new args must be in a dict""); # remove dynamics_args that are to be refreshed; self.dynamics_args = [dargs for dargs in self.dynamics_args; if dargs[0] not in new_args]; self.args.update(new_args); self._args_checks(); if self.compiled and self.compiled.split()[2] != ""cte"":; if isinstance(self.coeff_get, StrCoeff):; self.coeff_get.set_args(self.args); self.coeff_get._set_dyn_args(self.dynamics_args); elif isinstance(self.coeff_get, _UnitedFuncCaller):; self.coeff_get.set_args(self.args, self.dynamics_args). def solver_set_args(self, new_args, state, e_ops):; self.dynamics_args = []; self.args.update(new_args); self._args_checks(); for i, dargs in enumerate(self.dynamics_args):; if dargs[1] == ""expect"" and isinstance(dargs[2], int):; self.dynamics_args[i] = (dargs[0], ""expect"",; QobjEvo(e_ops[dargs[2]])); if self.compiled:; self.dynamics_args[i][2].compile(); self._d",MatchSource.WIKI,docs/4.7/modules/qutip/qobjevo.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qobjevo.html
https://qutip.org/docs/4.7/modules/qutip/qobjevo.html:1288,Safety,safe,safePickle,1288,"tip.qobjevo. Source code for qutip.qobjevo; """"""Time-dependent Quantum Object (Qobj) class.; """"""; __all__ = ['QobjEvo']. from qutip.qobj import Qobj; import qutip.settings as qset; from qutip.interpolate import Cubic_Spline; from scipy.interpolate import CubicSpline, interp1d; from functools import partial; from types import FunctionType, BuiltinFunctionType; import numpy as np; from numbers import Number; from qutip.qobjevo_codegen import (_compile_str_single, _compiled_coeffs,; _compiled_coeffs_python); from qutip.cy.spmatfuncs import (cy_expect_rho_vec, cy_expect_psi,; spmv); from qutip.cy.cqobjevo import (CQobjCte, CQobjCteDense, CQobjEvoTd,; CQobjEvoTdMatched, CQobjEvoTdDense); from qutip.cy.cqobjevo_factor import (InterCoeffT, InterCoeffCte,; InterpolateCoeff, StrCoeff,; StepCoeffCte, StepCoeffT); import sys; import scipy; import os; from re import sub. if qset.has_openmp:; from qutip.cy.openmp.cqobjevo_omp import (CQobjCteOmp, CQobjEvoTdOmp,; CQobjEvoTdMatchedOmp). safePickle = [False]; if sys.platform == 'win32':; safePickle[0] = True. if qset.has_cython:; import cython; use_cython = [True]; else:; use_cython = [False]. def proj(x):; if np.isfinite(x):; return (x); else:; return np.inf + 0j * np.imag(x). str_env = {; ""sin"": np.sin,; ""cos"": np.cos,; ""tan"": np.tan,; ""asin"": np.arcsin,; ""acos"": np.arccos,; ""atan"": np.arctan,; ""pi"": np.pi,; ""sinh"": np.sinh,; ""cosh"": np.cosh,; ""tanh"": np.tanh,; ""asinh"": np.arcsinh,; ""acosh"": np.arccosh,; ""atanh"": np.arctanh,; ""exp"": np.exp,; ""log"": np.log,; ""log10"": np.log10,; ""erf"": scipy.special.erf,; ""zerf"": scipy.special.erf,; ""sqrt"": np.sqrt,; ""real"": np.real,; ""imag"": np.imag,; ""conj"": np.conj,; ""abs"": np.abs,; ""norm"": lambda x: np.abs(x)**2,; ""arg"": np.angle,; ""proj"": proj,; ""np"": np,; ""spe"": scipy.special}. class _file_list:; """"""; Contain temp a list .pyx to clean; """""". def __init__(self):; self.files = []. def add(self, file_):; self.files += [file_]. def clean(self):; to_del = []; for i, file_ in enumerate(self.files):; ",MatchSource.WIKI,docs/4.7/modules/qutip/qobjevo.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qobjevo.html
https://qutip.org/docs/4.7/modules/qutip/qobjevo.html:1339,Safety,safe,safePickle,1339,"objevo; """"""Time-dependent Quantum Object (Qobj) class.; """"""; __all__ = ['QobjEvo']. from qutip.qobj import Qobj; import qutip.settings as qset; from qutip.interpolate import Cubic_Spline; from scipy.interpolate import CubicSpline, interp1d; from functools import partial; from types import FunctionType, BuiltinFunctionType; import numpy as np; from numbers import Number; from qutip.qobjevo_codegen import (_compile_str_single, _compiled_coeffs,; _compiled_coeffs_python); from qutip.cy.spmatfuncs import (cy_expect_rho_vec, cy_expect_psi,; spmv); from qutip.cy.cqobjevo import (CQobjCte, CQobjCteDense, CQobjEvoTd,; CQobjEvoTdMatched, CQobjEvoTdDense); from qutip.cy.cqobjevo_factor import (InterCoeffT, InterCoeffCte,; InterpolateCoeff, StrCoeff,; StepCoeffCte, StepCoeffT); import sys; import scipy; import os; from re import sub. if qset.has_openmp:; from qutip.cy.openmp.cqobjevo_omp import (CQobjCteOmp, CQobjEvoTdOmp,; CQobjEvoTdMatchedOmp). safePickle = [False]; if sys.platform == 'win32':; safePickle[0] = True. if qset.has_cython:; import cython; use_cython = [True]; else:; use_cython = [False]. def proj(x):; if np.isfinite(x):; return (x); else:; return np.inf + 0j * np.imag(x). str_env = {; ""sin"": np.sin,; ""cos"": np.cos,; ""tan"": np.tan,; ""asin"": np.arcsin,; ""acos"": np.arccos,; ""atan"": np.arctan,; ""pi"": np.pi,; ""sinh"": np.sinh,; ""cosh"": np.cosh,; ""tanh"": np.tanh,; ""asinh"": np.arcsinh,; ""acosh"": np.arccosh,; ""atanh"": np.arctanh,; ""exp"": np.exp,; ""log"": np.log,; ""log10"": np.log10,; ""erf"": scipy.special.erf,; ""zerf"": scipy.special.erf,; ""sqrt"": np.sqrt,; ""real"": np.real,; ""imag"": np.imag,; ""conj"": np.conj,; ""abs"": np.abs,; ""norm"": lambda x: np.abs(x)**2,; ""arg"": np.angle,; ""proj"": proj,; ""np"": np,; ""spe"": scipy.special}. class _file_list:; """"""; Contain temp a list .pyx to clean; """""". def __init__(self):; self.files = []. def add(self, file_):; self.files += [file_]. def clean(self):; to_del = []; for i, file_ in enumerate(self.files):; try:; os.remove(file_); to_del.append",MatchSource.WIKI,docs/4.7/modules/qutip/qobjevo.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qobjevo.html
https://qutip.org/docs/4.7/modules/qutip/qobjevo.html:11105,Safety,safe,safePickle,11105," the dynamic arguments that the solvers will generate. These; are the magic names that were found in the ``args`` parameter. tlist : array_like; List of times at which the numpy-array coefficients are applied. compiled : str; A string representing the properties of the low-level Cython class; backing this object (may be empty). compiled_qobjevo : ``CQobjCte`` or ``CQobjEvoTd``; Cython version of the QobjEvo. coeff_get : callable; Object called to obtain a list of all the coefficients at a particular; time. coeff_files : list; Runtime created files to delete with the instance. dummy_cte : bool; Is self.cte an empty Qobj. const : bool; Indicates if quantum object is constant. type : {""cte"", ""string"", ""func"", ""array"", ""spline"", ""mixed_callable"", \; ""mixed_compilable""}; Information about the type of coefficients used in the entire object. num_obj : int; Number of :obj:`~qutip.Qobj` in the QobjEvo. use_cython : bool; Flag to compile string to Cython or Python. safePickle : bool; Flag to not share pointers between thread.; """""". def __init__(self, Q_object=[], args={}, copy=True,; tlist=None, state0=None, e_ops=[]):; if isinstance(Q_object, QobjEvo):; if copy:; self._inplace_copy(Q_object); else:; self.__dict__ = Q_object.__dict__; if args:; self.arguments(args); for i, dargs in enumerate(self.dynamics_args):; e_int = dargs[1] == ""expect"" and isinstance(dargs[2], int); if e_ops and e_int:; self.dynamics_args[i] = (dargs[0], ""expect"",; e_ops[dargs[2]]); if state0 is not None:; self._dynamics_args_update(0., state0); return. self.const = False; self.dummy_cte = False; self.args = args.copy(); self.dynamics_args = []; self.cte = None; self.tlist = np.asarray(tlist) if tlist is not None else None; self.compiled = """"; self.compiled_qobjevo = None; self.coeff_get = None; self.type = ""none""; self.omp = 0; self.coeff_files = []; self.use_cython = use_cython[0]; self.safePickle = safePickle[0]. # Attempt to determine if a 2-element list is a single, time-dependent; # operator, or a",MatchSource.WIKI,docs/4.7/modules/qutip/qobjevo.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qobjevo.html
https://qutip.org/docs/4.7/modules/qutip/qobjevo.html:12019,Safety,safe,safePickle,12019," QobjEvo. use_cython : bool; Flag to compile string to Cython or Python. safePickle : bool; Flag to not share pointers between thread.; """""". def __init__(self, Q_object=[], args={}, copy=True,; tlist=None, state0=None, e_ops=[]):; if isinstance(Q_object, QobjEvo):; if copy:; self._inplace_copy(Q_object); else:; self.__dict__ = Q_object.__dict__; if args:; self.arguments(args); for i, dargs in enumerate(self.dynamics_args):; e_int = dargs[1] == ""expect"" and isinstance(dargs[2], int); if e_ops and e_int:; self.dynamics_args[i] = (dargs[0], ""expect"",; e_ops[dargs[2]]); if state0 is not None:; self._dynamics_args_update(0., state0); return. self.const = False; self.dummy_cte = False; self.args = args.copy(); self.dynamics_args = []; self.cte = None; self.tlist = np.asarray(tlist) if tlist is not None else None; self.compiled = """"; self.compiled_qobjevo = None; self.coeff_get = None; self.type = ""none""; self.omp = 0; self.coeff_files = []; self.use_cython = use_cython[0]; self.safePickle = safePickle[0]. # Attempt to determine if a 2-element list is a single, time-dependent; # operator, or a list with 2 possibly time-dependent elements.; if isinstance(Q_object, list) and len(Q_object) == 2:; try:; # Test if parsing succeeds on this as a single element.; self._td_op_type(Q_object); Q_object = [Q_object]; except (TypeError, ValueError):; pass. op_type = self._td_format_check(Q_object); self.ops = []. if isinstance(op_type, int):; if op_type == 0:; self.cte = Q_object; self.const = True; self.type = ""cte""; elif op_type == 1:; raise TypeError(""The Qobj must not already be a function""); elif op_type == -1:; pass; else:; op_type_count = [0, 0, 0, 0]; for type_, op in zip(op_type, Q_object):; if type_ == 0:; if self.cte is None:; self.cte = op; else:; self.cte += op; elif type_ == 1:; op_type_count[0] += 1; self.ops.append(EvoElement(op[0], op[1], op[1], ""func"")); elif type_ == 2:; op_type_count[1] += 1; self.ops.append(EvoElement(op[0], _StrWrapper(op[1]),; op[1], ""string"")); e",MatchSource.WIKI,docs/4.7/modules/qutip/qobjevo.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qobjevo.html
https://qutip.org/docs/4.7/modules/qutip/qobjevo.html:12032,Safety,safe,safePickle,12032," QobjEvo. use_cython : bool; Flag to compile string to Cython or Python. safePickle : bool; Flag to not share pointers between thread.; """""". def __init__(self, Q_object=[], args={}, copy=True,; tlist=None, state0=None, e_ops=[]):; if isinstance(Q_object, QobjEvo):; if copy:; self._inplace_copy(Q_object); else:; self.__dict__ = Q_object.__dict__; if args:; self.arguments(args); for i, dargs in enumerate(self.dynamics_args):; e_int = dargs[1] == ""expect"" and isinstance(dargs[2], int); if e_ops and e_int:; self.dynamics_args[i] = (dargs[0], ""expect"",; e_ops[dargs[2]]); if state0 is not None:; self._dynamics_args_update(0., state0); return. self.const = False; self.dummy_cte = False; self.args = args.copy(); self.dynamics_args = []; self.cte = None; self.tlist = np.asarray(tlist) if tlist is not None else None; self.compiled = """"; self.compiled_qobjevo = None; self.coeff_get = None; self.type = ""none""; self.omp = 0; self.coeff_files = []; self.use_cython = use_cython[0]; self.safePickle = safePickle[0]. # Attempt to determine if a 2-element list is a single, time-dependent; # operator, or a list with 2 possibly time-dependent elements.; if isinstance(Q_object, list) and len(Q_object) == 2:; try:; # Test if parsing succeeds on this as a single element.; self._td_op_type(Q_object); Q_object = [Q_object]; except (TypeError, ValueError):; pass. op_type = self._td_format_check(Q_object); self.ops = []. if isinstance(op_type, int):; if op_type == 0:; self.cte = Q_object; self.const = True; self.type = ""cte""; elif op_type == 1:; raise TypeError(""The Qobj must not already be a function""); elif op_type == -1:; pass; else:; op_type_count = [0, 0, 0, 0]; for type_, op in zip(op_type, Q_object):; if type_ == 0:; if self.cte is None:; self.cte = op; else:; self.cte += op; elif type_ == 1:; op_type_count[0] += 1; self.ops.append(EvoElement(op[0], op[1], op[1], ""func"")); elif type_ == 2:; op_type_count[1] += 1; self.ops.append(EvoElement(op[0], _StrWrapper(op[1]),; op[1], ""string"")); e",MatchSource.WIKI,docs/4.7/modules/qutip/qobjevo.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qobjevo.html
https://qutip.org/docs/4.7/modules/qutip/qobjevo.html:20138,Safety,safe,safePickle,20138," np.ndarray) and state.ndim == 2:; s1 = self.cte.shape[1]; new_l = int(np.sqrt(s1)); for name, what, op in self.dynamics_args:; if what == ""vec"":; self.args[name] = state.ravel(""F""); elif what == ""mat"":; self.args[name] = state; elif what == ""expect"":; self.args[name] = op.expect(t, state); elif state.shape[1] == 1:; self.args[name] = Qobj(state, dims=[self.cte.dims[1], [1]]); elif state.shape[1] == s1:; self.args[name] = Qobj(state, dims=self.cte.dims); else:; self.args[name] = Qobj(state). else:; raise TypeError(""state must be a Qobj or np.ndarray""). [docs] def copy(self):; """"""Return a copy of this object.""""""; new = QobjEvo(self.cte.copy()); new.const = self.const; new.args = self.args.copy(); new.dynamics_args = self.dynamics_args.copy(); new.tlist = self.tlist; new.dummy_cte = self.dummy_cte; new.num_obj = self.num_obj; new.type = self.type; new.compiled = False; new.compiled_qobjevo = None; new.coeff_get = None; new.coeff_files = []; new.use_cython = self.use_cython; new.safePickle = self.safePickle. for op in self.ops:; if op.type == ""array"":; new_coeff = op.coeff.copy(); else:; new_coeff = op.coeff; new.ops.append(EvoElement(op.qobj.copy(), op.get_coeff,; new_coeff, op.type)). return new. def _inplace_copy(self, other):; self.cte = other.cte; self.const = other.const; self.args = other.args.copy(); self.dynamics_args = other.dynamics_args; self.tlist = other.tlist; self.dummy_cte = other.dummy_cte; self.num_obj = other.num_obj; self.type = other.type; self.compiled = """"; self.compiled_qobjevo = None; self.coeff_get = None; self.ops = []; self.coeff_files = []; self.use_cython = other.use_cython; self.safePickle = other.safePickle. for op in other.ops:; if op.type == ""array"":; new_coeff = op.coeff.copy(); else:; new_coeff = op.coeff; self.ops.append(EvoElement(op.qobj.copy(), op.get_coeff,; new_coeff, op.type)). [docs] def arguments(self, new_args):; """"""; Update the scoped variables that were passed as ``args`` to new values.; """"""; if not isinstance(new_args, ",MatchSource.WIKI,docs/4.7/modules/qutip/qobjevo.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qobjevo.html
https://qutip.org/docs/4.7/modules/qutip/qobjevo.html:20156,Safety,safe,safePickle,20156,"nd state.ndim == 2:; s1 = self.cte.shape[1]; new_l = int(np.sqrt(s1)); for name, what, op in self.dynamics_args:; if what == ""vec"":; self.args[name] = state.ravel(""F""); elif what == ""mat"":; self.args[name] = state; elif what == ""expect"":; self.args[name] = op.expect(t, state); elif state.shape[1] == 1:; self.args[name] = Qobj(state, dims=[self.cte.dims[1], [1]]); elif state.shape[1] == s1:; self.args[name] = Qobj(state, dims=self.cte.dims); else:; self.args[name] = Qobj(state). else:; raise TypeError(""state must be a Qobj or np.ndarray""). [docs] def copy(self):; """"""Return a copy of this object.""""""; new = QobjEvo(self.cte.copy()); new.const = self.const; new.args = self.args.copy(); new.dynamics_args = self.dynamics_args.copy(); new.tlist = self.tlist; new.dummy_cte = self.dummy_cte; new.num_obj = self.num_obj; new.type = self.type; new.compiled = False; new.compiled_qobjevo = None; new.coeff_get = None; new.coeff_files = []; new.use_cython = self.use_cython; new.safePickle = self.safePickle. for op in self.ops:; if op.type == ""array"":; new_coeff = op.coeff.copy(); else:; new_coeff = op.coeff; new.ops.append(EvoElement(op.qobj.copy(), op.get_coeff,; new_coeff, op.type)). return new. def _inplace_copy(self, other):; self.cte = other.cte; self.const = other.const; self.args = other.args.copy(); self.dynamics_args = other.dynamics_args; self.tlist = other.tlist; self.dummy_cte = other.dummy_cte; self.num_obj = other.num_obj; self.type = other.type; self.compiled = """"; self.compiled_qobjevo = None; self.coeff_get = None; self.ops = []; self.coeff_files = []; self.use_cython = other.use_cython; self.safePickle = other.safePickle. for op in other.ops:; if op.type == ""array"":; new_coeff = op.coeff.copy(); else:; new_coeff = op.coeff; self.ops.append(EvoElement(op.qobj.copy(), op.get_coeff,; new_coeff, op.type)). [docs] def arguments(self, new_args):; """"""; Update the scoped variables that were passed as ``args`` to new values.; """"""; if not isinstance(new_args, dict):; raise T",MatchSource.WIKI,docs/4.7/modules/qutip/qobjevo.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qobjevo.html
https://qutip.org/docs/4.7/modules/qutip/qobjevo.html:20782,Safety,safe,safePickle,20782,"opy()); new.const = self.const; new.args = self.args.copy(); new.dynamics_args = self.dynamics_args.copy(); new.tlist = self.tlist; new.dummy_cte = self.dummy_cte; new.num_obj = self.num_obj; new.type = self.type; new.compiled = False; new.compiled_qobjevo = None; new.coeff_get = None; new.coeff_files = []; new.use_cython = self.use_cython; new.safePickle = self.safePickle. for op in self.ops:; if op.type == ""array"":; new_coeff = op.coeff.copy(); else:; new_coeff = op.coeff; new.ops.append(EvoElement(op.qobj.copy(), op.get_coeff,; new_coeff, op.type)). return new. def _inplace_copy(self, other):; self.cte = other.cte; self.const = other.const; self.args = other.args.copy(); self.dynamics_args = other.dynamics_args; self.tlist = other.tlist; self.dummy_cte = other.dummy_cte; self.num_obj = other.num_obj; self.type = other.type; self.compiled = """"; self.compiled_qobjevo = None; self.coeff_get = None; self.ops = []; self.coeff_files = []; self.use_cython = other.use_cython; self.safePickle = other.safePickle. for op in other.ops:; if op.type == ""array"":; new_coeff = op.coeff.copy(); else:; new_coeff = op.coeff; self.ops.append(EvoElement(op.qobj.copy(), op.get_coeff,; new_coeff, op.type)). [docs] def arguments(self, new_args):; """"""; Update the scoped variables that were passed as ``args`` to new values.; """"""; if not isinstance(new_args, dict):; raise TypeError(""The new args must be in a dict""); # remove dynamics_args that are to be refreshed; self.dynamics_args = [dargs for dargs in self.dynamics_args; if dargs[0] not in new_args]; self.args.update(new_args); self._args_checks(); if self.compiled and self.compiled.split()[2] != ""cte"":; if isinstance(self.coeff_get, StrCoeff):; self.coeff_get.set_args(self.args); self.coeff_get._set_dyn_args(self.dynamics_args); elif isinstance(self.coeff_get, _UnitedFuncCaller):; self.coeff_get.set_args(self.args, self.dynamics_args). def solver_set_args(self, new_args, state, e_ops):; self.dynamics_args = []; self.args.update(new_args)",MatchSource.WIKI,docs/4.7/modules/qutip/qobjevo.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qobjevo.html
https://qutip.org/docs/4.7/modules/qutip/qobjevo.html:20801,Safety,safe,safePickle,20801,"st = self.const; new.args = self.args.copy(); new.dynamics_args = self.dynamics_args.copy(); new.tlist = self.tlist; new.dummy_cte = self.dummy_cte; new.num_obj = self.num_obj; new.type = self.type; new.compiled = False; new.compiled_qobjevo = None; new.coeff_get = None; new.coeff_files = []; new.use_cython = self.use_cython; new.safePickle = self.safePickle. for op in self.ops:; if op.type == ""array"":; new_coeff = op.coeff.copy(); else:; new_coeff = op.coeff; new.ops.append(EvoElement(op.qobj.copy(), op.get_coeff,; new_coeff, op.type)). return new. def _inplace_copy(self, other):; self.cte = other.cte; self.const = other.const; self.args = other.args.copy(); self.dynamics_args = other.dynamics_args; self.tlist = other.tlist; self.dummy_cte = other.dummy_cte; self.num_obj = other.num_obj; self.type = other.type; self.compiled = """"; self.compiled_qobjevo = None; self.coeff_get = None; self.ops = []; self.coeff_files = []; self.use_cython = other.use_cython; self.safePickle = other.safePickle. for op in other.ops:; if op.type == ""array"":; new_coeff = op.coeff.copy(); else:; new_coeff = op.coeff; self.ops.append(EvoElement(op.qobj.copy(), op.get_coeff,; new_coeff, op.type)). [docs] def arguments(self, new_args):; """"""; Update the scoped variables that were passed as ``args`` to new values.; """"""; if not isinstance(new_args, dict):; raise TypeError(""The new args must be in a dict""); # remove dynamics_args that are to be refreshed; self.dynamics_args = [dargs for dargs in self.dynamics_args; if dargs[0] not in new_args]; self.args.update(new_args); self._args_checks(); if self.compiled and self.compiled.split()[2] != ""cte"":; if isinstance(self.coeff_get, StrCoeff):; self.coeff_get.set_args(self.args); self.coeff_get._set_dyn_args(self.dynamics_args); elif isinstance(self.coeff_get, _UnitedFuncCaller):; self.coeff_get.set_args(self.args, self.dynamics_args). def solver_set_args(self, new_args, state, e_ops):; self.dynamics_args = []; self.args.update(new_args); self._args_ch",MatchSource.WIKI,docs/4.7/modules/qutip/qobjevo.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qobjevo.html
https://qutip.org/docs/4.7/modules/qutip/qobjevo.html:46367,Safety,safe,safePickle,46367,"et = StepCoeffT(; self.ops, None, self.tlist); else:; self.coeff_get = InterCoeffT(; self.ops, None, self.tlist); self.compiled += ""cyfactor""; self.compiled_qobjevo.set_factor(obj=self.coeff_get). elif self.type == ""spline"":; self.coeff_get = InterpolateCoeff(self.ops, None, None); self.compiled += ""cyfactor""; self.compiled_qobjevo.set_factor(obj=self.coeff_get). else:; pass. coeff_files.clean(); if code:; return Code. def _get_coeff(self, t):; out = []; for part in self.ops:; out.append(part.get_coeff(t, self.args)); return out. def __getstate__(self):; _dict_ = {key: self.__dict__[key]; for key in self.__dict__ if key != ""compiled_qobjevo""}; if self.compiled:; return (_dict_, self.compiled_qobjevo.__getstate__()); else:; return (_dict_,). def __setstate__(self, state):; self.__dict__ = state[0]; self.compiled_qobjevo = None; if self.compiled:; mat_type, threading, td = self.compiled.split(); if mat_type == ""csr"":; if self.safePickle:; # __getstate__ and __setstate__ of compiled_qobjevo pass pointers; # In 'safe' mod, these pointers are not used.; if td == ""cte"":; if threading == ""single"":; self.compiled_qobjevo = CQobjCte(); self.compiled_qobjevo.set_data(self.cte); elif threading == ""omp"":; self.compiled_qobjevo = CQobjCteOmp(); self.compiled_qobjevo.set_data(self.cte); self.compiled_qobjevo.set_threads(self.omp); else:; # time dependence is pyfunc or cyfactor; if threading == ""single"":; self.compiled_qobjevo = CQobjEvoTd(); self.compiled_qobjevo.set_data(self.cte, self.ops); elif threading == ""omp"":; self.compiled_qobjevo = CQobjEvoTdOmp(); self.compiled_qobjevo.set_data(self.cte, self.ops); self.compiled_qobjevo.set_threads(self.omp). if td == ""pyfunc"":; self.compiled_qobjevo.set_factor(; func=self.coeff_get); elif td == ""cyfactor"":; self.compiled_qobjevo.set_factor(; obj=self.coeff_get); else:; if td == ""cte"":; if threading == ""single"":; self.compiled_qobjevo = CQobjCte.__new__(CQobjCte); elif threading == ""omp"":; self.compiled_qobjevo = CQobjCteOmp.__new__(; C",MatchSource.WIKI,docs/4.7/modules/qutip/qobjevo.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qobjevo.html
https://qutip.org/docs/4.7/modules/qutip/qobjevo.html:46453,Safety,safe,safe,46453,"et = StepCoeffT(; self.ops, None, self.tlist); else:; self.coeff_get = InterCoeffT(; self.ops, None, self.tlist); self.compiled += ""cyfactor""; self.compiled_qobjevo.set_factor(obj=self.coeff_get). elif self.type == ""spline"":; self.coeff_get = InterpolateCoeff(self.ops, None, None); self.compiled += ""cyfactor""; self.compiled_qobjevo.set_factor(obj=self.coeff_get). else:; pass. coeff_files.clean(); if code:; return Code. def _get_coeff(self, t):; out = []; for part in self.ops:; out.append(part.get_coeff(t, self.args)); return out. def __getstate__(self):; _dict_ = {key: self.__dict__[key]; for key in self.__dict__ if key != ""compiled_qobjevo""}; if self.compiled:; return (_dict_, self.compiled_qobjevo.__getstate__()); else:; return (_dict_,). def __setstate__(self, state):; self.__dict__ = state[0]; self.compiled_qobjevo = None; if self.compiled:; mat_type, threading, td = self.compiled.split(); if mat_type == ""csr"":; if self.safePickle:; # __getstate__ and __setstate__ of compiled_qobjevo pass pointers; # In 'safe' mod, these pointers are not used.; if td == ""cte"":; if threading == ""single"":; self.compiled_qobjevo = CQobjCte(); self.compiled_qobjevo.set_data(self.cte); elif threading == ""omp"":; self.compiled_qobjevo = CQobjCteOmp(); self.compiled_qobjevo.set_data(self.cte); self.compiled_qobjevo.set_threads(self.omp); else:; # time dependence is pyfunc or cyfactor; if threading == ""single"":; self.compiled_qobjevo = CQobjEvoTd(); self.compiled_qobjevo.set_data(self.cte, self.ops); elif threading == ""omp"":; self.compiled_qobjevo = CQobjEvoTdOmp(); self.compiled_qobjevo.set_data(self.cte, self.ops); self.compiled_qobjevo.set_threads(self.omp). if td == ""pyfunc"":; self.compiled_qobjevo.set_factor(; func=self.coeff_get); elif td == ""cyfactor"":; self.compiled_qobjevo.set_factor(; obj=self.coeff_get); else:; if td == ""cte"":; if threading == ""single"":; self.compiled_qobjevo = CQobjCte.__new__(CQobjCte); elif threading == ""omp"":; self.compiled_qobjevo = CQobjCteOmp.__new__(; C",MatchSource.WIKI,docs/4.7/modules/qutip/qobjevo.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qobjevo.html
https://qutip.org/docs/4.7/modules/qutip/qobjevo.html:7739,Security,access,access,7739,"mes of the tlist do not need to be; equidistant, but must be sorted. By default, a cubic spline interpolation; will be used for the coefficient at time t. If the coefficients are to be; treated as step functions, use the arguments; ``args = {""_step_func_coeff"": True}``. Examples of array-format usage are:. .. code-block:: python. tlist = np.logspace(-5,0,100); H = QobjEvo([H0, [H1, np.exp(-1j*tlist)], [H2, np.cos(2.*tlist)]],; tlist=tlist). Mixing time formats is allowed. It is not possible to create a single; ``QobjEvo`` that contains different ``tlist`` values, however. **Passing arguments**. ``args`` is a dict of (name: object). The name must be a valid Python; identifier string, and in general the object can be any type that is; supported by the code to be compiled in the string. There are some ""magic"" names that can be specified, whose objects will be; overwritten when used within :func:`.sesolve`, :func:`.mesolve` and; :func:`.mcsolve`. This allows access to the solvers' internal states, and; they are updated at every call. The initial values of these dictionary; elements is unimportant. The magic names available are:. - ``""state""``: the current state as a :class:`~qutip.Qobj`; - ``""state_vec""``: the current state as a column-stacked 1D ``np.ndarray``; - ``""state_mat""``: the current state as a 2D ``np.ndarray``; - ``""expect_op_<n>""``: the current expectation value of the element; ``e_ops[n]``, which is an argument to the solvers. Replace ``<n>`` with; an integer literal, e.g. ``""expect_op_0""``. This will be either real- or; complex-valued, depending on whether the state and operator are both; Hermitian or not.; - ``""collapse""``: (:func:`.mcsolve` only) a list of the collapses that have; occurred during the evolution. Each element of the list is a 2-tuple; ``(time: float, which: int)``, where ``time`` is the time this collapse; happened, and ``which`` is an integer indexing the ``c_ops`` argument to; :func:`.mcsolve`. Parameters; ----------; Q_object : list, :cl",MatchSource.WIKI,docs/4.7/modules/qutip/qobjevo.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qobjevo.html
https://qutip.org/docs/4.7/modules/qutip/qobjevo.html:9509,Security,access,access,9509,"ave; occurred during the evolution. Each element of the list is a 2-tuple; ``(time: float, which: int)``, where ``time`` is the time this collapse; happened, and ``which`` is an integer indexing the ``c_ops`` argument to; :func:`.mcsolve`. Parameters; ----------; Q_object : list, :class:`~qutip.Qobj` or :class:`~qutip.QobjEvo`; The time-dependent description of the quantum object. This is of the; same format as the first parameter to the general ODE solvers; in; general, it is a list of ``[Qobj, time_dependence]`` pairs that are; summed to make the whole object. The ``time_dependence`` can be any of; the formats discussed in the previous section. If a particular term; has no time-dependence, then you should just give the ``Qobj`` instead; of the 2-element list. args : dict, optional; Mapping of ``{str: object}``, discussed in greater detail above. The; strings can be any valid Python identifier, and the objects are of the; consumable types. See the previous section for details on the ""magic""; names used to access solver internals. tlist : array_like, optional; List of the times any numpy-array coefficients describe. This is used; only in at least one of the time dependences in ``Q_object`` is given; in Numpy-array format. The times must be sorted, but need not be; equidistant. Values inbetween will be interpolated. Attributes; ----------; cte : :class:`~qutip.Qobj`; Constant part of the QobjEvo. ops : list of :class:`.EvoElement`; Internal representation of the time-dependence structure of the; elements. args : dict; The current value of the ``args`` dictionary passed into the; constructor. dynamics_args : list; Names of the dynamic arguments that the solvers will generate. These; are the magic names that were found in the ``args`` parameter. tlist : array_like; List of times at which the numpy-array coefficients are applied. compiled : str; A string representing the properties of the low-level Cython class; backing this object (may be empty). compiled_qobjevo : ``C",MatchSource.WIKI,docs/4.7/modules/qutip/qobjevo.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qobjevo.html
https://qutip.org/docs/4.7/modules/qutip/qobjevo.html:1805,Testability,log,log,1805,"hon); from qutip.cy.spmatfuncs import (cy_expect_rho_vec, cy_expect_psi,; spmv); from qutip.cy.cqobjevo import (CQobjCte, CQobjCteDense, CQobjEvoTd,; CQobjEvoTdMatched, CQobjEvoTdDense); from qutip.cy.cqobjevo_factor import (InterCoeffT, InterCoeffCte,; InterpolateCoeff, StrCoeff,; StepCoeffCte, StepCoeffT); import sys; import scipy; import os; from re import sub. if qset.has_openmp:; from qutip.cy.openmp.cqobjevo_omp import (CQobjCteOmp, CQobjEvoTdOmp,; CQobjEvoTdMatchedOmp). safePickle = [False]; if sys.platform == 'win32':; safePickle[0] = True. if qset.has_cython:; import cython; use_cython = [True]; else:; use_cython = [False]. def proj(x):; if np.isfinite(x):; return (x); else:; return np.inf + 0j * np.imag(x). str_env = {; ""sin"": np.sin,; ""cos"": np.cos,; ""tan"": np.tan,; ""asin"": np.arcsin,; ""acos"": np.arccos,; ""atan"": np.arctan,; ""pi"": np.pi,; ""sinh"": np.sinh,; ""cosh"": np.cosh,; ""tanh"": np.tanh,; ""asinh"": np.arcsinh,; ""acosh"": np.arccosh,; ""atanh"": np.arctanh,; ""exp"": np.exp,; ""log"": np.log,; ""log10"": np.log10,; ""erf"": scipy.special.erf,; ""zerf"": scipy.special.erf,; ""sqrt"": np.sqrt,; ""real"": np.real,; ""imag"": np.imag,; ""conj"": np.conj,; ""abs"": np.abs,; ""norm"": lambda x: np.abs(x)**2,; ""arg"": np.angle,; ""proj"": proj,; ""np"": np,; ""spe"": scipy.special}. class _file_list:; """"""; Contain temp a list .pyx to clean; """""". def __init__(self):; self.files = []. def add(self, file_):; self.files += [file_]. def clean(self):; to_del = []; for i, file_ in enumerate(self.files):; try:; os.remove(file_); to_del.append(i); except Exception:; if not os.path.isfile(file_):; to_del.append(i). for i in to_del[::-1]:; del self.files[i]. def __del__(self):; self.clean(). coeff_files = _file_list(). class _StrWrapper:; def __init__(self, code):; self.code = ""_out = "" + code. def __call__(self, t, args={}):; env = {""t"": t}; env.update(args); exec(self.code, str_env, env); return env[""_out""]. class _CubicSplineWrapper:; # Using scipy's CubicSpline since Qutip's one; # only accept linea",MatchSource.WIKI,docs/4.7/modules/qutip/qobjevo.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qobjevo.html
https://qutip.org/docs/4.7/modules/qutip/qobjevo.html:1814,Testability,log,log,1814,"cy.spmatfuncs import (cy_expect_rho_vec, cy_expect_psi,; spmv); from qutip.cy.cqobjevo import (CQobjCte, CQobjCteDense, CQobjEvoTd,; CQobjEvoTdMatched, CQobjEvoTdDense); from qutip.cy.cqobjevo_factor import (InterCoeffT, InterCoeffCte,; InterpolateCoeff, StrCoeff,; StepCoeffCte, StepCoeffT); import sys; import scipy; import os; from re import sub. if qset.has_openmp:; from qutip.cy.openmp.cqobjevo_omp import (CQobjCteOmp, CQobjEvoTdOmp,; CQobjEvoTdMatchedOmp). safePickle = [False]; if sys.platform == 'win32':; safePickle[0] = True. if qset.has_cython:; import cython; use_cython = [True]; else:; use_cython = [False]. def proj(x):; if np.isfinite(x):; return (x); else:; return np.inf + 0j * np.imag(x). str_env = {; ""sin"": np.sin,; ""cos"": np.cos,; ""tan"": np.tan,; ""asin"": np.arcsin,; ""acos"": np.arccos,; ""atan"": np.arctan,; ""pi"": np.pi,; ""sinh"": np.sinh,; ""cosh"": np.cosh,; ""tanh"": np.tanh,; ""asinh"": np.arcsinh,; ""acosh"": np.arccosh,; ""atanh"": np.arctanh,; ""exp"": np.exp,; ""log"": np.log,; ""log10"": np.log10,; ""erf"": scipy.special.erf,; ""zerf"": scipy.special.erf,; ""sqrt"": np.sqrt,; ""real"": np.real,; ""imag"": np.imag,; ""conj"": np.conj,; ""abs"": np.abs,; ""norm"": lambda x: np.abs(x)**2,; ""arg"": np.angle,; ""proj"": proj,; ""np"": np,; ""spe"": scipy.special}. class _file_list:; """"""; Contain temp a list .pyx to clean; """""". def __init__(self):; self.files = []. def add(self, file_):; self.files += [file_]. def clean(self):; to_del = []; for i, file_ in enumerate(self.files):; try:; os.remove(file_); to_del.append(i); except Exception:; if not os.path.isfile(file_):; to_del.append(i). for i in to_del[::-1]:; del self.files[i]. def __del__(self):; self.clean(). coeff_files = _file_list(). class _StrWrapper:; def __init__(self, code):; self.code = ""_out = "" + code. def __call__(self, t, args={}):; env = {""t"": t}; env.update(args); exec(self.code, str_env, env); return env[""_out""]. class _CubicSplineWrapper:; # Using scipy's CubicSpline since Qutip's one; # only accept linearly distributed t",MatchSource.WIKI,docs/4.7/modules/qutip/qobjevo.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qobjevo.html
https://qutip.org/docs/4.7/modules/qutip/qobjevo.html:6226,Testability,log,log,6226,"nt scalars; :math:`f_k(t)` by. .. math::. Q(t) = \\sum_k f_k(t) Q_k. If a scalar :math:`f_k(t)` is not passed with a given :obj:`~qutip.Qobj`,; then that term is assumed to be constant. The next section contains more; detail on the allowed forms of the constants, and gives several examples; for how to build instances of this class. **Time-dependence formats**. There are three major formats for specifying a time-dependent scalar:. - Python function; - string; - array. For function format, the function signature must be; ``f(t: float, args: dict) -> complex``, for example. .. code-block:: python. def f1_t(t, args):; return np.exp(-1j * t * args[""w1""]). def f2_t(t, args):; return np.cos(t * args[""w2""]). H = QobjEvo([H0, [H1, f1_t], [H2, f2_t]], args={""w1"":1., ""w2"":2.}). For string-based coeffients, the string must be a compilable python code; resulting in a complex. The following symbols are defined:. .. code-block::. pi exp log log10; erf zerf norm proj; real imag conj abs arg; sin sinh asin asinh; cos cosh acos acosh; tan tanh atan atanh; numpy as np; scipy.special as spe. A couple more simple examples:. .. code-block:: python. H = QobjEvo([H0, [H1, 'exp(-1j*w1*t)'], [H2, 'cos(w2*t)']],; args={""w1"":1.,""w2"":2.}). For numpy array format, the array must be an 1d of dtype ``np.float64`` or; ``np.complex128``. A list of times (``np.float64``) at which the; coeffients must be given as ``tlist``. The coeffients array must have the; same length as the tlist. The times of the tlist do not need to be; equidistant, but must be sorted. By default, a cubic spline interpolation; will be used for the coefficient at time t. If the coefficients are to be; treated as step functions, use the arguments; ``args = {""_step_func_coeff"": True}``. Examples of array-format usage are:. .. code-block:: python. tlist = np.logspace(-5,0,100); H = QobjEvo([H0, [H1, np.exp(-1j*tlist)], [H2, np.cos(2.*tlist)]],; tlist=tlist). Mixing time formats is allowed. It is not possible to create a single; ``Qob",MatchSource.WIKI,docs/4.7/modules/qutip/qobjevo.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qobjevo.html
https://qutip.org/docs/4.7/modules/qutip/qobjevo.html:7113,Testability,log,logspace,7113," code; resulting in a complex. The following symbols are defined:. .. code-block::. pi exp log log10; erf zerf norm proj; real imag conj abs arg; sin sinh asin asinh; cos cosh acos acosh; tan tanh atan atanh; numpy as np; scipy.special as spe. A couple more simple examples:. .. code-block:: python. H = QobjEvo([H0, [H1, 'exp(-1j*w1*t)'], [H2, 'cos(w2*t)']],; args={""w1"":1.,""w2"":2.}). For numpy array format, the array must be an 1d of dtype ``np.float64`` or; ``np.complex128``. A list of times (``np.float64``) at which the; coeffients must be given as ``tlist``. The coeffients array must have the; same length as the tlist. The times of the tlist do not need to be; equidistant, but must be sorted. By default, a cubic spline interpolation; will be used for the coefficient at time t. If the coefficients are to be; treated as step functions, use the arguments; ``args = {""_step_func_coeff"": True}``. Examples of array-format usage are:. .. code-block:: python. tlist = np.logspace(-5,0,100); H = QobjEvo([H0, [H1, np.exp(-1j*tlist)], [H2, np.cos(2.*tlist)]],; tlist=tlist). Mixing time formats is allowed. It is not possible to create a single; ``QobjEvo`` that contains different ``tlist`` values, however. **Passing arguments**. ``args`` is a dict of (name: object). The name must be a valid Python; identifier string, and in general the object can be any type that is; supported by the code to be compiled in the string. There are some ""magic"" names that can be specified, whose objects will be; overwritten when used within :func:`.sesolve`, :func:`.mesolve` and; :func:`.mcsolve`. This allows access to the solvers' internal states, and; they are updated at every call. The initial values of these dictionary; elements is unimportant. The magic names available are:. - ``""state""``: the current state as a :class:`~qutip.Qobj`; - ``""state_vec""``: the current state as a column-stacked 1D ``np.ndarray``; - ``""state_mat""``: the current state as a 2D ``np.ndarray``; - ``""expect_op_<n>""``: the",MatchSource.WIKI,docs/4.7/modules/qutip/qobjevo.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qobjevo.html
https://qutip.org/docs/4.7/modules/qutip/qobjevo.html:13737,Testability,test,test,13737,"f.cte is None:; self.cte = op; else:; self.cte += op; elif type_ == 1:; op_type_count[0] += 1; self.ops.append(EvoElement(op[0], op[1], op[1], ""func"")); elif type_ == 2:; op_type_count[1] += 1; self.ops.append(EvoElement(op[0], _StrWrapper(op[1]),; op[1], ""string"")); elif type_ == 3:; op_type_count[2] += 1; self.ops.append(EvoElement(; op[0],; _CubicSplineWrapper(tlist, op[1], args=self.args),; op[1].copy(), ""array"")); elif type_ == 4:; op_type_count[3] += 1; self.ops.append(EvoElement(op[0], op[1], op[1], ""spline"")). nops = sum(op_type_count); if all([op_t == 0 for op_t in op_type]):; self.type = ""cte""; elif op_type_count[0] == nops:; self.type = ""func""; elif op_type_count[1] == nops:; self.type = ""string""; elif op_type_count[2] == nops:; self.type = ""array""; elif op_type_count[3] == nops:; self.type = ""spline""; elif op_type_count[0]:; self.type = ""mixed_callable""; else:; self.type = ""mixed_compilable"". try:; if not self.cte:; self.cte = self.ops[0].qobj; # test is all qobj are compatible (shape, dims); for op in self.ops[1:]:; self.cte += op.qobj; self.cte *= 0.; self.dummy_cte = True; else:; cte_copy = self.cte.copy(); # test is all qobj are compatible (shape, dims); for op in self.ops:; cte_copy += op.qobj; except Exception as e:; raise TypeError(""Qobj not compatible."") from e. if not self.ops:; self.const = True; self.num_obj = (len(self.ops) if self.dummy_cte else len(self.ops) + 1); self._args_checks(); if e_ops:; for i, dargs in enumerate(self.dynamics_args):; if dargs[1] == ""expect"" and isinstance(dargs[2], int):; self.dynamics_args[i] = (dargs[0], ""expect"",; QobjEvo(e_ops[dargs[2]])); if state0 is not None:; self._dynamics_args_update(0., state0). def _td_format_check(self, Q_object):; if isinstance(Q_object, Qobj):; return 0; if isinstance(Q_object, (FunctionType, BuiltinFunctionType, partial)):; return 1; if isinstance(Q_object, list):; return [self._td_op_type(element) for element in Q_object] or -1; raise TypeError(""Incorrect Q_object specification""). ",MatchSource.WIKI,docs/4.7/modules/qutip/qobjevo.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qobjevo.html
https://qutip.org/docs/4.7/modules/qutip/qobjevo.html:13906,Testability,test,test,13906,":; op_type_count[1] += 1; self.ops.append(EvoElement(op[0], _StrWrapper(op[1]),; op[1], ""string"")); elif type_ == 3:; op_type_count[2] += 1; self.ops.append(EvoElement(; op[0],; _CubicSplineWrapper(tlist, op[1], args=self.args),; op[1].copy(), ""array"")); elif type_ == 4:; op_type_count[3] += 1; self.ops.append(EvoElement(op[0], op[1], op[1], ""spline"")). nops = sum(op_type_count); if all([op_t == 0 for op_t in op_type]):; self.type = ""cte""; elif op_type_count[0] == nops:; self.type = ""func""; elif op_type_count[1] == nops:; self.type = ""string""; elif op_type_count[2] == nops:; self.type = ""array""; elif op_type_count[3] == nops:; self.type = ""spline""; elif op_type_count[0]:; self.type = ""mixed_callable""; else:; self.type = ""mixed_compilable"". try:; if not self.cte:; self.cte = self.ops[0].qobj; # test is all qobj are compatible (shape, dims); for op in self.ops[1:]:; self.cte += op.qobj; self.cte *= 0.; self.dummy_cte = True; else:; cte_copy = self.cte.copy(); # test is all qobj are compatible (shape, dims); for op in self.ops:; cte_copy += op.qobj; except Exception as e:; raise TypeError(""Qobj not compatible."") from e. if not self.ops:; self.const = True; self.num_obj = (len(self.ops) if self.dummy_cte else len(self.ops) + 1); self._args_checks(); if e_ops:; for i, dargs in enumerate(self.dynamics_args):; if dargs[1] == ""expect"" and isinstance(dargs[2], int):; self.dynamics_args[i] = (dargs[0], ""expect"",; QobjEvo(e_ops[dargs[2]])); if state0 is not None:; self._dynamics_args_update(0., state0). def _td_format_check(self, Q_object):; if isinstance(Q_object, Qobj):; return 0; if isinstance(Q_object, (FunctionType, BuiltinFunctionType, partial)):; return 1; if isinstance(Q_object, list):; return [self._td_op_type(element) for element in Q_object] or -1; raise TypeError(""Incorrect Q_object specification""). def _td_op_type(self, element):; if isinstance(element, Qobj):; return 0; try:; op, td = element; except (TypeError, ValueError) as exc:; raise TypeError(""Incorrect Q_o",MatchSource.WIKI,docs/4.7/modules/qutip/qobjevo.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qobjevo.html
https://qutip.org/docs/4.7/modules/qutip/qobjevo.html:6393,Usability,simpl,simple,6393,"assed with a given :obj:`~qutip.Qobj`,; then that term is assumed to be constant. The next section contains more; detail on the allowed forms of the constants, and gives several examples; for how to build instances of this class. **Time-dependence formats**. There are three major formats for specifying a time-dependent scalar:. - Python function; - string; - array. For function format, the function signature must be; ``f(t: float, args: dict) -> complex``, for example. .. code-block:: python. def f1_t(t, args):; return np.exp(-1j * t * args[""w1""]). def f2_t(t, args):; return np.cos(t * args[""w2""]). H = QobjEvo([H0, [H1, f1_t], [H2, f2_t]], args={""w1"":1., ""w2"":2.}). For string-based coeffients, the string must be a compilable python code; resulting in a complex. The following symbols are defined:. .. code-block::. pi exp log log10; erf zerf norm proj; real imag conj abs arg; sin sinh asin asinh; cos cosh acos acosh; tan tanh atan atanh; numpy as np; scipy.special as spe. A couple more simple examples:. .. code-block:: python. H = QobjEvo([H0, [H1, 'exp(-1j*w1*t)'], [H2, 'cos(w2*t)']],; args={""w1"":1.,""w2"":2.}). For numpy array format, the array must be an 1d of dtype ``np.float64`` or; ``np.complex128``. A list of times (``np.float64``) at which the; coeffients must be given as ``tlist``. The coeffients array must have the; same length as the tlist. The times of the tlist do not need to be; equidistant, but must be sorted. By default, a cubic spline interpolation; will be used for the coefficient at time t. If the coefficients are to be; treated as step functions, use the arguments; ``args = {""_step_func_coeff"": True}``. Examples of array-format usage are:. .. code-block:: python. tlist = np.logspace(-5,0,100); H = QobjEvo([H0, [H1, np.exp(-1j*tlist)], [H2, np.cos(2.*tlist)]],; tlist=tlist). Mixing time formats is allowed. It is not possible to create a single; ``QobjEvo`` that contains different ``tlist`` values, however. **Passing arguments**. ``args`` is a dict of ",MatchSource.WIKI,docs/4.7/modules/qutip/qobjevo.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qobjevo.html
https://qutip.org/docs/4.7/modules/qutip/random_objects.html:10374,Availability,error,error,10374,"d dims is None:; raise ValueError('Specify either the number of rows of state vector'; '(N) or dimensions of quantum object (dims)'); if N and dims:; _check_dims(dims, N, 1); elif dims:; N = np.prod(dims[0]); _check_dims(dims, N, 1); else:; dims = [[N], [1]]; psi = rand_unitary_haar(N, seed=seed) * basis(N, 0); psi.dims = dims; return psi. [docs]def rand_dm(N, density=0.75, pure=False, dims=None, seed=None):; r""""""Creates a random NxN density matrix. Parameters; ----------; N : int, ndarray, list; If int, then shape of output operator. If list/ndarray then eigenvalues; of generated density matrix.; density : float; Density between [0,1] of output density matrix.; dims : list; Dimensions of quantum object. Used for specifying; tensor structure. Default is dims=[[N],[N]].; seed : int; Seed for the random number generator. Returns; -------; oper : qobj; NxN density matrix quantum operator. Notes; -----; For small density matrices., choosing a low density will result in an error; as no diagonal elements will be generated such that :math:`Tr(\rho)=1`. """"""; if isinstance(N, (np.ndarray, list)):; if np.abs(np.sum(N)-1.0) > 1e-15:; raise ValueError('Eigenvalues of a density matrix '; 'must sum to one.'); H = sp.diags(N, 0, dtype=complex, format='csr'); N = len(N); if dims:; _check_dims(dims, N, N); nvals = N**2*density; H = rand_jacobi_rotation(H, seed=seed); while H.nnz < 0.95*nvals:; H = rand_jacobi_rotation(H); H.sort_indices(); elif isinstance(N, (int, np.int32, np.int64)):; if dims:; _check_dims(dims, N, N); if pure:; dm_density = np.sqrt(density); psi = rand_ket(N, dm_density, seed=seed); H = psi * psi.dag(); H.data.sort_indices(); else:; non_zero = 0; tries = 0; while non_zero == 0 and tries < 10:; H = rand_herm(N, density, seed=seed); H = H.dag() * H; non_zero = H.tr(); tries += 1; if tries >= 10:; raise ValueError(; ""Requested density is too low to generate density matrix.""); H = H / H.tr(); H.data.sort_indices(); else:; raise TypeError('Input N must be an integer or",MatchSource.WIKI,docs/4.7/modules/qutip/random_objects.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/random_objects.html
https://qutip.org/docs/4.7/modules/qutip/random_objects.html:18903,Deployability,update,updated,18903,"rep = 'choi'. return sr.to_super(D). [docs]def rand_stochastic(N, density=0.75, kind='left', dims=None, seed=None):; """"""Generates a random stochastic matrix. Parameters; ----------; N : int; Dimension of matrix.; density : float; Density between [0,1] of output density matrix.; kind : str (Default = 'left'); Generate 'left' or 'right' stochastic matrix.; dims : list; Dimensions of quantum object. Used for specifying; tensor structure. Default is dims=[[N],[N]]. Returns; -------; oper : qobj; Quantum operator form of stochastic matrix.; """"""; if seed is not None:; np.random.seed(seed=seed); if dims:; _check_dims(dims, N, N); num_elems = max([int(np.ceil(N*(N+1)*density)/2), N]); data = np.random.rand(num_elems); # Ensure an element on every row and column; row_idx = np.hstack([np.random.permutation(N),; np.random.choice(N, num_elems-N)]); col_idx = np.hstack([np.random.permutation(N),; np.random.choice(N, num_elems-N)]); M = sp.coo_matrix((data, (row_idx, col_idx)),; dtype=float, shape=(N, N)).tocsr(); M = 0.5 * (M + M.conj().transpose()); num_rows = M.indptr.shape[0]-1; for row in range(num_rows):; row_start = M.indptr[row]; row_end = M.indptr[row+1]; row_sum = np.sum(M.data[row_start:row_end]); M.data[row_start:row_end] /= row_sum; if kind == 'left':; M = M.transpose(); return Qobj(M, dims=dims, shape=(N, N)). def _check_dims(dims, N1, N2):; if len(dims) != 2:; raise Exception(""Qobj dimensions must be list of length 2.""); if (not isinstance(dims[0], list)) or (not isinstance(dims[1], list)):; raise TypeError(; ""Qobj dimension components must be lists. i.e. dims=[[N],[N]]""); if np.prod(dims[0]) != N1 or np.prod(dims[1]) != N2:; raise ValueError(""Qobj dimensions must match matrix shape.""); if len(dims[0]) != len(dims[1]):; raise TypeError(""Qobj dimension components must have same length.""). © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/modules/qutip/random_objects.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/random_objects.html
https://qutip.org/docs/4.7/modules/qutip/random_objects.html:15972,Safety,avoid,avoid,15972,": list; Dimensions of quantum object. Used for specifying; tensor structure. Default is dims=[[[N],[N]], [[N],[N]]]. Returns; -------; rho : Qobj; A superoperator acting on vectorized dim × dim density operators,; sampled from the BCSZ distribution.; """"""; if dims is not None:; # TODO: check!; pass; else:; dims = [[[N], [N]], [[N], [N]]]. if rank is None:; rank = N**2; if rank > N**2:; raise ValueError(""Rank cannot exceed superoperator dimension.""). # We use mainly dense matrices here for speed in low; # dimensions. In the future, it would likely be better to switch off; # between sparse and dense matrices as the dimension grows. # We start with a Ginibre uniform matrix X of the appropriate rank,; # and use it to construct a positive semidefinite matrix X X⁺.; X = randnz((N**2, rank), norm='ginibre', seed=seed). # Precompute X X⁺, as we'll need it in two different places.; XXdag = np.dot(X, X.T.conj()). if enforce_tp:; # We do the partial trace over the first index by using dense reshape; # operations, so that we can avoid bouncing to a sparse representation; # and back.; Y = np.einsum('ijik->jk', XXdag.reshape((N, N, N, N))). # Now we have the matrix 𝟙 ⊗ Y^{-1/2}, which we can find by doing; # the square root and the inverse separately. As a possible; # improvement, iterative methods exist to find inverse square root; # matrices directly, as this is important in statistics.; Z = np.kron(; np.eye(N),; la.sqrtm(la.inv(Y)); ). # Finally, we dot everything together and pack it into a Qobj,; # marking the dimensions as that of a type=super (that is,; # with left and right compound indices, each representing; # left and right indices on the underlying Hilbert space).; D = Qobj(np.dot(Z, np.dot(XXdag, Z))); else:; D = N * Qobj(XXdag / np.trace(XXdag)). D.dims = [; # Left dims; [[N], [N]],; # Right dims; [[N], [N]]; ]. # Since [BCSZ08] gives a row-stacking Choi matrix, but QuTiP; # expects a column-stacking Choi matrix, we must permute the indices.; D = D.permute([[1], [0]])",MatchSource.WIKI,docs/4.7/modules/qutip/random_objects.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/random_objects.html
https://qutip.org/docs/4.7/modules/qutip/rhs_generate.html:3531,Deployability,install,installed,3531,"r k in range(len(c_ops)):; if isinstance(c_ops[k], Qobj):; c_const.append(k); elif isinstance(c_ops[k], list):; if len(c_ops[k]) != 2:; raise TypeError(; ""Incorrect collapse operator specification.""); else:; if isinstance(c_ops[k][1], (FunctionType,; BuiltinFunctionType, partial)):; c_func.append(k); elif isinstance(c_ops[k][1], str):; c_str.append(k); elif isinstance(c_ops[k][1], Cubic_Spline):; c_obj.append(k); elif hasattr(c_ops[k][1], '__call__'):; c_func.append(k); elif isinstance(c_ops[k][1], np.ndarray):; c_str.append(k); elif isinstance(c_ops[k][1], tuple):; c_str.append(k); else:; raise TypeError(; ""Incorrect collapse operator specification""); else:; raise TypeError(""Incorrect collapse operator specification""). #; # if n_str == 0 and n_func == 0:; # # no time-dependence at all; #; if ((len(h_str) > 0 and len(h_func) > 0) or; (len(c_str) > 0 and len(c_func) > 0)):; raise TypeError(; ""Cannot mix string and function type time-dependence formats""). # check to see if Cython is installed and version is high enough.; if len(h_str) > 0 or len(c_str) > 0:; pass; #try:; # import Cython; #except:; # raise Exception(; # ""Unable to load Cython. Use Python function format.""); #else:; # if Cython.__version__ < '0.21':; # raise Exception(""Cython version (%s) is too old. Upgrade to"" +; # "" version 0.21+"" % Cython.__version__). # If only time-dependence is in Objects, then prefer string based format; if (len(h_func) + len(c_func) + len(h_str) + len(c_str)) == 0:; h_str += h_obj #Does nothing if not objects; c_str += c_obj; else:; # Combine Hamiltonian objects; if len(h_func) > 0:; h_func += h_obj; elif len(h_str) > 0:; h_str += h_obj. #Combine collapse objects; if len(c_func) > 0:; c_func += c_obj; elif len(c_str) > 0:; c_str += c_obj. if solver == 'me':; return (len(h_const + c_const),; len(h_func) + len(c_func),; len(h_str) + len(c_str)). elif solver == 'mc':. # H C_ops #; # -- ----- --; # NO NO 00; # NO STR 01; # NO FUNC 02; #; # STR NO 10; # STR STR 11; #; # FUNC NO 20; ",MatchSource.WIKI,docs/4.7/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.7/modules/qutip/rhs_generate.html:6513,Deployability,update,update,6513,"0:; time_type = 1; elif len(c_func) > 0:; time_type = 2; else:; raise Exception(""Error determining time-dependence.""). # list style Hamiltonian; elif len(h_str) > 0:; if len(c_func) == len(c_str) == 0:; time_type = 10; elif len(c_str) > 0:; time_type = 11; else:; raise Exception(""Error determining time-dependence.""). # Python function style Hamiltonian; elif len(h_func) > 0:; if len(c_func) == len(c_str) == 0:; time_type = 20; elif len(c_func) > 0:; time_type = 22; else:; raise Exception(""Error determining time-dependence.""). return time_type, [h_const, h_func, h_str], [c_const, c_func, c_str]. def _td_wrap_array_str(H, c_ops, args, times):; """"""; Wrap numpy-array based time-dependence in the string-based time dependence; format; """"""; n = 0; H_new = []; c_ops_new = []; args_new = {}. if not isinstance(H, list):; H_new = H; else:; for Hk in H:; if isinstance(Hk, list) and isinstance(Hk[1], np.ndarray):; H_op, H_td = Hk; td_array_name = ""_td_array_%d"" % n; H_td_str = '(0 if (t > %f) else %s[int(round(%d * (t/%f)))])' %\; (times[-1], td_array_name, len(times) - 1, times[-1]); args_new[td_array_name] = H_td; H_new.append([H_op, H_td_str]); n += 1; else:; H_new.append(Hk). if not isinstance(c_ops, list):; c_ops_new = c_ops; else:; for ck in c_ops:; if isinstance(ck, list) and isinstance(ck[1], np.ndarray):; c_op, c_td = ck; td_array_name = ""_td_array_%d"" % n; c_td_str = '(0 if (t > %f) else %s[int(round(%d * (t/%f)))])' %\; (times[-1], td_array_name, len(times) - 1, times[-1]); args_new[td_array_name] = c_td; c_ops_new.append([c_op, c_td_str]); n += 1; else:; c_ops_new.append(ck). if not args_new:; args_new = args; elif isinstance(args, dict):; args_new.update(args); else:; raise ValueError(""Time-dependent array format requires args to "" +; ""be a dictionary""). return H_new, c_ops_new, args_new. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.7/modules/qutip/rhs_generate.html:6736,Deployability,update,updated,6736,"0:; time_type = 1; elif len(c_func) > 0:; time_type = 2; else:; raise Exception(""Error determining time-dependence.""). # list style Hamiltonian; elif len(h_str) > 0:; if len(c_func) == len(c_str) == 0:; time_type = 10; elif len(c_str) > 0:; time_type = 11; else:; raise Exception(""Error determining time-dependence.""). # Python function style Hamiltonian; elif len(h_func) > 0:; if len(c_func) == len(c_str) == 0:; time_type = 20; elif len(c_func) > 0:; time_type = 22; else:; raise Exception(""Error determining time-dependence.""). return time_type, [h_const, h_func, h_str], [c_const, c_func, c_str]. def _td_wrap_array_str(H, c_ops, args, times):; """"""; Wrap numpy-array based time-dependence in the string-based time dependence; format; """"""; n = 0; H_new = []; c_ops_new = []; args_new = {}. if not isinstance(H, list):; H_new = H; else:; for Hk in H:; if isinstance(Hk, list) and isinstance(Hk[1], np.ndarray):; H_op, H_td = Hk; td_array_name = ""_td_array_%d"" % n; H_td_str = '(0 if (t > %f) else %s[int(round(%d * (t/%f)))])' %\; (times[-1], td_array_name, len(times) - 1, times[-1]); args_new[td_array_name] = H_td; H_new.append([H_op, H_td_str]); n += 1; else:; H_new.append(Hk). if not isinstance(c_ops, list):; c_ops_new = c_ops; else:; for ck in c_ops:; if isinstance(ck, list) and isinstance(ck[1], np.ndarray):; c_op, c_td = ck; td_array_name = ""_td_array_%d"" % n; c_td_str = '(0 if (t > %f) else %s[int(round(%d * (t/%f)))])' %\; (times[-1], td_array_name, len(times) - 1, times[-1]); args_new[td_array_name] = c_td; c_ops_new.append([c_op, c_td_str]); n += 1; else:; c_ops_new.append(ck). if not args_new:; args_new = args; elif isinstance(args, dict):; args_new.update(args); else:; raise ValueError(""Time-dependent array format requires args to "" +; ""be a dictionary""). return H_new, c_ops_new, args_new. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.7/modules/qutip/rhs_generate.html:771,Integrability,depend,dependent,771,". qutip.rhs_generate — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.rhs_generate. Source code for qutip.rhs_generate; __all__ = ['rhs_clear']. import os; import numpy as np; from types import FunctionType, BuiltinFunctionType; from functools import partial. from qutip.cy.codegen import Codegen; from qutip.solver import Options, config, solver_safe; from qutip.qobj import Qobj; from qutip.superoperator import spre, spost; from qutip.interpolate import Cubic_Spline. [docs]def rhs_clear():; """"""; Resets the string-format time-dependent Hamiltonian parameters. Parameters; ----------. Returns; -------; Nothing, just clears data from internal config module. """"""; # time-dependent (TD) function stuff; config.tdfunc = None # Placeholder for TD RHS function.; config.colspmv = None # Placeholder for TD col-spmv function.; config.colexpect = None # Placeholder for TD col_expect function.; config.string = None # Holds string of variables to be passed to solver; config.tdname = None # Name of td .pyx file (used in parallel mc code); if ""sesolve"" in solver_safe:; del solver_safe[""sesolve""]; if ""mesolve"" in solver_safe:; del solver_safe[""mesolve""]; if ""mcsolve"" in solver_safe:; del solver_safe[""mcsolve""]. def _td_format_check(H, c_ops, solver='me'):; """"""; Checks on time-dependent format.; """"""; h_const = []; h_func = []; h_str = []; h_obj = []; # check H for incorrect format; if isinstance(H, Qobj):; pass; elif isinstance(H, (FunctionType, BuiltinFunctionType, partial)):; pass # n_func += 1; elif isinstance(H, list):; for k, H_k in enumerate(H):; if isinstance(H_k, Qobj):; h_const.append(k); elif isinstance(H_k, list):; if len(H_k) != 2 or not isinstance(H_k[0], Qobj):; raise TypeError(""Incorrect hamiltonian specification""); else:; if isinstance(",MatchSource.WIKI,docs/4.7/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.7/modules/qutip/rhs_generate.html:914,Integrability,depend,dependent,914,". qutip.rhs_generate — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.rhs_generate. Source code for qutip.rhs_generate; __all__ = ['rhs_clear']. import os; import numpy as np; from types import FunctionType, BuiltinFunctionType; from functools import partial. from qutip.cy.codegen import Codegen; from qutip.solver import Options, config, solver_safe; from qutip.qobj import Qobj; from qutip.superoperator import spre, spost; from qutip.interpolate import Cubic_Spline. [docs]def rhs_clear():; """"""; Resets the string-format time-dependent Hamiltonian parameters. Parameters; ----------. Returns; -------; Nothing, just clears data from internal config module. """"""; # time-dependent (TD) function stuff; config.tdfunc = None # Placeholder for TD RHS function.; config.colspmv = None # Placeholder for TD col-spmv function.; config.colexpect = None # Placeholder for TD col_expect function.; config.string = None # Holds string of variables to be passed to solver; config.tdname = None # Name of td .pyx file (used in parallel mc code); if ""sesolve"" in solver_safe:; del solver_safe[""sesolve""]; if ""mesolve"" in solver_safe:; del solver_safe[""mesolve""]; if ""mcsolve"" in solver_safe:; del solver_safe[""mcsolve""]. def _td_format_check(H, c_ops, solver='me'):; """"""; Checks on time-dependent format.; """"""; h_const = []; h_func = []; h_str = []; h_obj = []; # check H for incorrect format; if isinstance(H, Qobj):; pass; elif isinstance(H, (FunctionType, BuiltinFunctionType, partial)):; pass # n_func += 1; elif isinstance(H, list):; for k, H_k in enumerate(H):; if isinstance(H_k, Qobj):; h_const.append(k); elif isinstance(H_k, list):; if len(H_k) != 2 or not isinstance(H_k[0], Qobj):; raise TypeError(""Incorrect hamiltonian specification""); else:; if isinstance(",MatchSource.WIKI,docs/4.7/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.7/modules/qutip/rhs_generate.html:1517,Integrability,depend,dependent,1517,"partial. from qutip.cy.codegen import Codegen; from qutip.solver import Options, config, solver_safe; from qutip.qobj import Qobj; from qutip.superoperator import spre, spost; from qutip.interpolate import Cubic_Spline. [docs]def rhs_clear():; """"""; Resets the string-format time-dependent Hamiltonian parameters. Parameters; ----------. Returns; -------; Nothing, just clears data from internal config module. """"""; # time-dependent (TD) function stuff; config.tdfunc = None # Placeholder for TD RHS function.; config.colspmv = None # Placeholder for TD col-spmv function.; config.colexpect = None # Placeholder for TD col_expect function.; config.string = None # Holds string of variables to be passed to solver; config.tdname = None # Name of td .pyx file (used in parallel mc code); if ""sesolve"" in solver_safe:; del solver_safe[""sesolve""]; if ""mesolve"" in solver_safe:; del solver_safe[""mesolve""]; if ""mcsolve"" in solver_safe:; del solver_safe[""mcsolve""]. def _td_format_check(H, c_ops, solver='me'):; """"""; Checks on time-dependent format.; """"""; h_const = []; h_func = []; h_str = []; h_obj = []; # check H for incorrect format; if isinstance(H, Qobj):; pass; elif isinstance(H, (FunctionType, BuiltinFunctionType, partial)):; pass # n_func += 1; elif isinstance(H, list):; for k, H_k in enumerate(H):; if isinstance(H_k, Qobj):; h_const.append(k); elif isinstance(H_k, list):; if len(H_k) != 2 or not isinstance(H_k[0], Qobj):; raise TypeError(""Incorrect hamiltonian specification""); else:; if isinstance(H_k[1], (FunctionType,; BuiltinFunctionType, partial)):; h_func.append(k); elif isinstance(H_k[1], str):; h_str.append(k); elif isinstance(H_k[1], Cubic_Spline):; h_obj.append(k); elif hasattr(H_k[1], '__call__'):; h_obj.append(k); elif isinstance(H_k[1], np.ndarray):; h_str.append(k); else:; raise TypeError(""Incorrect hamiltonian specification""); else:; raise TypeError(""Incorrect hamiltonian specification""). # the the whole thing again for c_ops; c_const = []; c_func = []; c_str = []; ",MatchSource.WIKI,docs/4.7/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.7/modules/qutip/rhs_generate.html:3314,Integrability,depend,dependence,3314,"t hamiltonian specification""). # the the whole thing again for c_ops; c_const = []; c_func = []; c_str = []; c_obj = []; if isinstance(c_ops, list):; for k in range(len(c_ops)):; if isinstance(c_ops[k], Qobj):; c_const.append(k); elif isinstance(c_ops[k], list):; if len(c_ops[k]) != 2:; raise TypeError(; ""Incorrect collapse operator specification.""); else:; if isinstance(c_ops[k][1], (FunctionType,; BuiltinFunctionType, partial)):; c_func.append(k); elif isinstance(c_ops[k][1], str):; c_str.append(k); elif isinstance(c_ops[k][1], Cubic_Spline):; c_obj.append(k); elif hasattr(c_ops[k][1], '__call__'):; c_func.append(k); elif isinstance(c_ops[k][1], np.ndarray):; c_str.append(k); elif isinstance(c_ops[k][1], tuple):; c_str.append(k); else:; raise TypeError(; ""Incorrect collapse operator specification""); else:; raise TypeError(""Incorrect collapse operator specification""). #; # if n_str == 0 and n_func == 0:; # # no time-dependence at all; #; if ((len(h_str) > 0 and len(h_func) > 0) or; (len(c_str) > 0 and len(c_func) > 0)):; raise TypeError(; ""Cannot mix string and function type time-dependence formats""). # check to see if Cython is installed and version is high enough.; if len(h_str) > 0 or len(c_str) > 0:; pass; #try:; # import Cython; #except:; # raise Exception(; # ""Unable to load Cython. Use Python function format.""); #else:; # if Cython.__version__ < '0.21':; # raise Exception(""Cython version (%s) is too old. Upgrade to"" +; # "" version 0.21+"" % Cython.__version__). # If only time-dependence is in Objects, then prefer string based format; if (len(h_func) + len(c_func) + len(h_str) + len(c_str)) == 0:; h_str += h_obj #Does nothing if not objects; c_str += c_obj; else:; # Combine Hamiltonian objects; if len(h_func) > 0:; h_func += h_obj; elif len(h_str) > 0:; h_str += h_obj. #Combine collapse objects; if len(c_func) > 0:; c_func += c_obj; elif len(c_str) > 0:; c_str += c_obj. if solver == 'me':; return (len(h_const + c_const),; len(h_func) + len(c_func),; len(h_str)",MatchSource.WIKI,docs/4.7/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.7/modules/qutip/rhs_generate.html:3481,Integrability,depend,dependence,3481,"t hamiltonian specification""). # the the whole thing again for c_ops; c_const = []; c_func = []; c_str = []; c_obj = []; if isinstance(c_ops, list):; for k in range(len(c_ops)):; if isinstance(c_ops[k], Qobj):; c_const.append(k); elif isinstance(c_ops[k], list):; if len(c_ops[k]) != 2:; raise TypeError(; ""Incorrect collapse operator specification.""); else:; if isinstance(c_ops[k][1], (FunctionType,; BuiltinFunctionType, partial)):; c_func.append(k); elif isinstance(c_ops[k][1], str):; c_str.append(k); elif isinstance(c_ops[k][1], Cubic_Spline):; c_obj.append(k); elif hasattr(c_ops[k][1], '__call__'):; c_func.append(k); elif isinstance(c_ops[k][1], np.ndarray):; c_str.append(k); elif isinstance(c_ops[k][1], tuple):; c_str.append(k); else:; raise TypeError(; ""Incorrect collapse operator specification""); else:; raise TypeError(""Incorrect collapse operator specification""). #; # if n_str == 0 and n_func == 0:; # # no time-dependence at all; #; if ((len(h_str) > 0 and len(h_func) > 0) or; (len(c_str) > 0 and len(c_func) > 0)):; raise TypeError(; ""Cannot mix string and function type time-dependence formats""). # check to see if Cython is installed and version is high enough.; if len(h_str) > 0 or len(c_str) > 0:; pass; #try:; # import Cython; #except:; # raise Exception(; # ""Unable to load Cython. Use Python function format.""); #else:; # if Cython.__version__ < '0.21':; # raise Exception(""Cython version (%s) is too old. Upgrade to"" +; # "" version 0.21+"" % Cython.__version__). # If only time-dependence is in Objects, then prefer string based format; if (len(h_func) + len(c_func) + len(h_str) + len(c_str)) == 0:; h_str += h_obj #Does nothing if not objects; c_str += c_obj; else:; # Combine Hamiltonian objects; if len(h_func) > 0:; h_func += h_obj; elif len(h_str) > 0:; h_str += h_obj. #Combine collapse objects; if len(c_func) > 0:; c_func += c_obj; elif len(c_str) > 0:; c_str += c_obj. if solver == 'me':; return (len(h_const + c_const),; len(h_func) + len(c_func),; len(h_str)",MatchSource.WIKI,docs/4.7/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.7/modules/qutip/rhs_generate.html:3891,Integrability,depend,dependence,3891,"[k][1], np.ndarray):; c_str.append(k); elif isinstance(c_ops[k][1], tuple):; c_str.append(k); else:; raise TypeError(; ""Incorrect collapse operator specification""); else:; raise TypeError(""Incorrect collapse operator specification""). #; # if n_str == 0 and n_func == 0:; # # no time-dependence at all; #; if ((len(h_str) > 0 and len(h_func) > 0) or; (len(c_str) > 0 and len(c_func) > 0)):; raise TypeError(; ""Cannot mix string and function type time-dependence formats""). # check to see if Cython is installed and version is high enough.; if len(h_str) > 0 or len(c_str) > 0:; pass; #try:; # import Cython; #except:; # raise Exception(; # ""Unable to load Cython. Use Python function format.""); #else:; # if Cython.__version__ < '0.21':; # raise Exception(""Cython version (%s) is too old. Upgrade to"" +; # "" version 0.21+"" % Cython.__version__). # If only time-dependence is in Objects, then prefer string based format; if (len(h_func) + len(c_func) + len(h_str) + len(c_str)) == 0:; h_str += h_obj #Does nothing if not objects; c_str += c_obj; else:; # Combine Hamiltonian objects; if len(h_func) > 0:; h_func += h_obj; elif len(h_str) > 0:; h_str += h_obj. #Combine collapse objects; if len(c_func) > 0:; c_func += c_obj; elif len(c_str) > 0:; c_str += c_obj. if solver == 'me':; return (len(h_const + c_const),; len(h_func) + len(c_func),; len(h_str) + len(c_str)). elif solver == 'mc':. # H C_ops #; # -- ----- --; # NO NO 00; # NO STR 01; # NO FUNC 02; #; # STR NO 10; # STR STR 11; #; # FUNC NO 20; #; # FUNC FUNC 22. if isinstance(H, FunctionType):; time_type = 3; # Time-indepdent problems; elif ((len(h_func) == len(h_str) == 0) and; (len(c_func) == len(c_str) == 0)):; time_type = 0. # constant Hamiltonian, time-dependent collapse operators; elif len(h_func) == len(h_str) == 0:; if len(c_str) > 0:; time_type = 1; elif len(c_func) > 0:; time_type = 2; else:; raise Exception(""Error determining time-dependence.""). # list style Hamiltonian; elif len(h_str) > 0:; if len(c_func) == len(c_str)",MatchSource.WIKI,docs/4.7/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.7/modules/qutip/rhs_generate.html:4753,Integrability,depend,dependent,4753," version 0.21+"" % Cython.__version__). # If only time-dependence is in Objects, then prefer string based format; if (len(h_func) + len(c_func) + len(h_str) + len(c_str)) == 0:; h_str += h_obj #Does nothing if not objects; c_str += c_obj; else:; # Combine Hamiltonian objects; if len(h_func) > 0:; h_func += h_obj; elif len(h_str) > 0:; h_str += h_obj. #Combine collapse objects; if len(c_func) > 0:; c_func += c_obj; elif len(c_str) > 0:; c_str += c_obj. if solver == 'me':; return (len(h_const + c_const),; len(h_func) + len(c_func),; len(h_str) + len(c_str)). elif solver == 'mc':. # H C_ops #; # -- ----- --; # NO NO 00; # NO STR 01; # NO FUNC 02; #; # STR NO 10; # STR STR 11; #; # FUNC NO 20; #; # FUNC FUNC 22. if isinstance(H, FunctionType):; time_type = 3; # Time-indepdent problems; elif ((len(h_func) == len(h_str) == 0) and; (len(c_func) == len(c_str) == 0)):; time_type = 0. # constant Hamiltonian, time-dependent collapse operators; elif len(h_func) == len(h_str) == 0:; if len(c_str) > 0:; time_type = 1; elif len(c_func) > 0:; time_type = 2; else:; raise Exception(""Error determining time-dependence.""). # list style Hamiltonian; elif len(h_str) > 0:; if len(c_func) == len(c_str) == 0:; time_type = 10; elif len(c_str) > 0:; time_type = 11; else:; raise Exception(""Error determining time-dependence.""). # Python function style Hamiltonian; elif len(h_func) > 0:; if len(c_func) == len(c_str) == 0:; time_type = 20; elif len(c_func) > 0:; time_type = 22; else:; raise Exception(""Error determining time-dependence.""). return time_type, [h_const, h_func, h_str], [c_const, c_func, c_str]. def _td_wrap_array_str(H, c_ops, args, times):; """"""; Wrap numpy-array based time-dependence in the string-based time dependence; format; """"""; n = 0; H_new = []; c_ops_new = []; args_new = {}. if not isinstance(H, list):; H_new = H; else:; for Hk in H:; if isinstance(Hk, list) and isinstance(Hk[1], np.ndarray):; H_op, H_td = Hk; td_array_name = ""_td_array_%d"" % n; H_td_str = '(0 if (t > %f) else %",MatchSource.WIKI,docs/4.7/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.7/modules/qutip/rhs_generate.html:4941,Integrability,depend,dependence,4941," version 0.21+"" % Cython.__version__). # If only time-dependence is in Objects, then prefer string based format; if (len(h_func) + len(c_func) + len(h_str) + len(c_str)) == 0:; h_str += h_obj #Does nothing if not objects; c_str += c_obj; else:; # Combine Hamiltonian objects; if len(h_func) > 0:; h_func += h_obj; elif len(h_str) > 0:; h_str += h_obj. #Combine collapse objects; if len(c_func) > 0:; c_func += c_obj; elif len(c_str) > 0:; c_str += c_obj. if solver == 'me':; return (len(h_const + c_const),; len(h_func) + len(c_func),; len(h_str) + len(c_str)). elif solver == 'mc':. # H C_ops #; # -- ----- --; # NO NO 00; # NO STR 01; # NO FUNC 02; #; # STR NO 10; # STR STR 11; #; # FUNC NO 20; #; # FUNC FUNC 22. if isinstance(H, FunctionType):; time_type = 3; # Time-indepdent problems; elif ((len(h_func) == len(h_str) == 0) and; (len(c_func) == len(c_str) == 0)):; time_type = 0. # constant Hamiltonian, time-dependent collapse operators; elif len(h_func) == len(h_str) == 0:; if len(c_str) > 0:; time_type = 1; elif len(c_func) > 0:; time_type = 2; else:; raise Exception(""Error determining time-dependence.""). # list style Hamiltonian; elif len(h_str) > 0:; if len(c_func) == len(c_str) == 0:; time_type = 10; elif len(c_str) > 0:; time_type = 11; else:; raise Exception(""Error determining time-dependence.""). # Python function style Hamiltonian; elif len(h_func) > 0:; if len(c_func) == len(c_str) == 0:; time_type = 20; elif len(c_func) > 0:; time_type = 22; else:; raise Exception(""Error determining time-dependence.""). return time_type, [h_const, h_func, h_str], [c_const, c_func, c_str]. def _td_wrap_array_str(H, c_ops, args, times):; """"""; Wrap numpy-array based time-dependence in the string-based time dependence; format; """"""; n = 0; H_new = []; c_ops_new = []; args_new = {}. if not isinstance(H, list):; H_new = H; else:; for Hk in H:; if isinstance(Hk, list) and isinstance(Hk[1], np.ndarray):; H_op, H_td = Hk; td_array_name = ""_td_array_%d"" % n; H_td_str = '(0 if (t > %f) else %",MatchSource.WIKI,docs/4.7/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.7/modules/qutip/rhs_generate.html:5141,Integrability,depend,dependence,5141,"ects; c_str += c_obj; else:; # Combine Hamiltonian objects; if len(h_func) > 0:; h_func += h_obj; elif len(h_str) > 0:; h_str += h_obj. #Combine collapse objects; if len(c_func) > 0:; c_func += c_obj; elif len(c_str) > 0:; c_str += c_obj. if solver == 'me':; return (len(h_const + c_const),; len(h_func) + len(c_func),; len(h_str) + len(c_str)). elif solver == 'mc':. # H C_ops #; # -- ----- --; # NO NO 00; # NO STR 01; # NO FUNC 02; #; # STR NO 10; # STR STR 11; #; # FUNC NO 20; #; # FUNC FUNC 22. if isinstance(H, FunctionType):; time_type = 3; # Time-indepdent problems; elif ((len(h_func) == len(h_str) == 0) and; (len(c_func) == len(c_str) == 0)):; time_type = 0. # constant Hamiltonian, time-dependent collapse operators; elif len(h_func) == len(h_str) == 0:; if len(c_str) > 0:; time_type = 1; elif len(c_func) > 0:; time_type = 2; else:; raise Exception(""Error determining time-dependence.""). # list style Hamiltonian; elif len(h_str) > 0:; if len(c_func) == len(c_str) == 0:; time_type = 10; elif len(c_str) > 0:; time_type = 11; else:; raise Exception(""Error determining time-dependence.""). # Python function style Hamiltonian; elif len(h_func) > 0:; if len(c_func) == len(c_str) == 0:; time_type = 20; elif len(c_func) > 0:; time_type = 22; else:; raise Exception(""Error determining time-dependence.""). return time_type, [h_const, h_func, h_str], [c_const, c_func, c_str]. def _td_wrap_array_str(H, c_ops, args, times):; """"""; Wrap numpy-array based time-dependence in the string-based time dependence; format; """"""; n = 0; H_new = []; c_ops_new = []; args_new = {}. if not isinstance(H, list):; H_new = H; else:; for Hk in H:; if isinstance(Hk, list) and isinstance(Hk[1], np.ndarray):; H_op, H_td = Hk; td_array_name = ""_td_array_%d"" % n; H_td_str = '(0 if (t > %f) else %s[int(round(%d * (t/%f)))])' %\; (times[-1], td_array_name, len(times) - 1, times[-1]); args_new[td_array_name] = H_td; H_new.append([H_op, H_td_str]); n += 1; else:; H_new.append(Hk). if not isinstance(c_ops, list):",MatchSource.WIKI,docs/4.7/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.7/modules/qutip/rhs_generate.html:5354,Integrability,depend,dependence,5354,"en(c_str) > 0:; c_str += c_obj. if solver == 'me':; return (len(h_const + c_const),; len(h_func) + len(c_func),; len(h_str) + len(c_str)). elif solver == 'mc':. # H C_ops #; # -- ----- --; # NO NO 00; # NO STR 01; # NO FUNC 02; #; # STR NO 10; # STR STR 11; #; # FUNC NO 20; #; # FUNC FUNC 22. if isinstance(H, FunctionType):; time_type = 3; # Time-indepdent problems; elif ((len(h_func) == len(h_str) == 0) and; (len(c_func) == len(c_str) == 0)):; time_type = 0. # constant Hamiltonian, time-dependent collapse operators; elif len(h_func) == len(h_str) == 0:; if len(c_str) > 0:; time_type = 1; elif len(c_func) > 0:; time_type = 2; else:; raise Exception(""Error determining time-dependence.""). # list style Hamiltonian; elif len(h_str) > 0:; if len(c_func) == len(c_str) == 0:; time_type = 10; elif len(c_str) > 0:; time_type = 11; else:; raise Exception(""Error determining time-dependence.""). # Python function style Hamiltonian; elif len(h_func) > 0:; if len(c_func) == len(c_str) == 0:; time_type = 20; elif len(c_func) > 0:; time_type = 22; else:; raise Exception(""Error determining time-dependence.""). return time_type, [h_const, h_func, h_str], [c_const, c_func, c_str]. def _td_wrap_array_str(H, c_ops, args, times):; """"""; Wrap numpy-array based time-dependence in the string-based time dependence; format; """"""; n = 0; H_new = []; c_ops_new = []; args_new = {}. if not isinstance(H, list):; H_new = H; else:; for Hk in H:; if isinstance(Hk, list) and isinstance(Hk[1], np.ndarray):; H_op, H_td = Hk; td_array_name = ""_td_array_%d"" % n; H_td_str = '(0 if (t > %f) else %s[int(round(%d * (t/%f)))])' %\; (times[-1], td_array_name, len(times) - 1, times[-1]); args_new[td_array_name] = H_td; H_new.append([H_op, H_td_str]); n += 1; else:; H_new.append(Hk). if not isinstance(c_ops, list):; c_ops_new = c_ops; else:; for ck in c_ops:; if isinstance(ck, list) and isinstance(ck[1], np.ndarray):; c_op, c_td = ck; td_array_name = ""_td_array_%d"" % n; c_td_str = '(0 if (t > %f) else %s[int(round(%d",MatchSource.WIKI,docs/4.7/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.7/modules/qutip/rhs_generate.html:5520,Integrability,depend,dependence,5520," #; # FUNC FUNC 22. if isinstance(H, FunctionType):; time_type = 3; # Time-indepdent problems; elif ((len(h_func) == len(h_str) == 0) and; (len(c_func) == len(c_str) == 0)):; time_type = 0. # constant Hamiltonian, time-dependent collapse operators; elif len(h_func) == len(h_str) == 0:; if len(c_str) > 0:; time_type = 1; elif len(c_func) > 0:; time_type = 2; else:; raise Exception(""Error determining time-dependence.""). # list style Hamiltonian; elif len(h_str) > 0:; if len(c_func) == len(c_str) == 0:; time_type = 10; elif len(c_str) > 0:; time_type = 11; else:; raise Exception(""Error determining time-dependence.""). # Python function style Hamiltonian; elif len(h_func) > 0:; if len(c_func) == len(c_str) == 0:; time_type = 20; elif len(c_func) > 0:; time_type = 22; else:; raise Exception(""Error determining time-dependence.""). return time_type, [h_const, h_func, h_str], [c_const, c_func, c_str]. def _td_wrap_array_str(H, c_ops, args, times):; """"""; Wrap numpy-array based time-dependence in the string-based time dependence; format; """"""; n = 0; H_new = []; c_ops_new = []; args_new = {}. if not isinstance(H, list):; H_new = H; else:; for Hk in H:; if isinstance(Hk, list) and isinstance(Hk[1], np.ndarray):; H_op, H_td = Hk; td_array_name = ""_td_array_%d"" % n; H_td_str = '(0 if (t > %f) else %s[int(round(%d * (t/%f)))])' %\; (times[-1], td_array_name, len(times) - 1, times[-1]); args_new[td_array_name] = H_td; H_new.append([H_op, H_td_str]); n += 1; else:; H_new.append(Hk). if not isinstance(c_ops, list):; c_ops_new = c_ops; else:; for ck in c_ops:; if isinstance(ck, list) and isinstance(ck[1], np.ndarray):; c_op, c_td = ck; td_array_name = ""_td_array_%d"" % n; c_td_str = '(0 if (t > %f) else %s[int(round(%d * (t/%f)))])' %\; (times[-1], td_array_name, len(times) - 1, times[-1]); args_new[td_array_name] = c_td; c_ops_new.append([c_op, c_td_str]); n += 1; else:; c_ops_new.append(ck). if not args_new:; args_new = args; elif isinstance(args, dict):; args_new.update(args); else:; ",MatchSource.WIKI,docs/4.7/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.7/modules/qutip/rhs_generate.html:5556,Integrability,depend,dependence,5556," #; # FUNC FUNC 22. if isinstance(H, FunctionType):; time_type = 3; # Time-indepdent problems; elif ((len(h_func) == len(h_str) == 0) and; (len(c_func) == len(c_str) == 0)):; time_type = 0. # constant Hamiltonian, time-dependent collapse operators; elif len(h_func) == len(h_str) == 0:; if len(c_str) > 0:; time_type = 1; elif len(c_func) > 0:; time_type = 2; else:; raise Exception(""Error determining time-dependence.""). # list style Hamiltonian; elif len(h_str) > 0:; if len(c_func) == len(c_str) == 0:; time_type = 10; elif len(c_str) > 0:; time_type = 11; else:; raise Exception(""Error determining time-dependence.""). # Python function style Hamiltonian; elif len(h_func) > 0:; if len(c_func) == len(c_str) == 0:; time_type = 20; elif len(c_func) > 0:; time_type = 22; else:; raise Exception(""Error determining time-dependence.""). return time_type, [h_const, h_func, h_str], [c_const, c_func, c_str]. def _td_wrap_array_str(H, c_ops, args, times):; """"""; Wrap numpy-array based time-dependence in the string-based time dependence; format; """"""; n = 0; H_new = []; c_ops_new = []; args_new = {}. if not isinstance(H, list):; H_new = H; else:; for Hk in H:; if isinstance(Hk, list) and isinstance(Hk[1], np.ndarray):; H_op, H_td = Hk; td_array_name = ""_td_array_%d"" % n; H_td_str = '(0 if (t > %f) else %s[int(round(%d * (t/%f)))])' %\; (times[-1], td_array_name, len(times) - 1, times[-1]); args_new[td_array_name] = H_td; H_new.append([H_op, H_td_str]); n += 1; else:; H_new.append(Hk). if not isinstance(c_ops, list):; c_ops_new = c_ops; else:; for ck in c_ops:; if isinstance(ck, list) and isinstance(ck[1], np.ndarray):; c_op, c_td = ck; td_array_name = ""_td_array_%d"" % n; c_td_str = '(0 if (t > %f) else %s[int(round(%d * (t/%f)))])' %\; (times[-1], td_array_name, len(times) - 1, times[-1]); args_new[td_array_name] = c_td; c_ops_new.append([c_op, c_td_str]); n += 1; else:; c_ops_new.append(ck). if not args_new:; args_new = args; elif isinstance(args, dict):; args_new.update(args); else:; ",MatchSource.WIKI,docs/4.7/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.7/modules/qutip/rhs_generate.html:6557,Integrability,depend,dependent,6557,"0:; time_type = 1; elif len(c_func) > 0:; time_type = 2; else:; raise Exception(""Error determining time-dependence.""). # list style Hamiltonian; elif len(h_str) > 0:; if len(c_func) == len(c_str) == 0:; time_type = 10; elif len(c_str) > 0:; time_type = 11; else:; raise Exception(""Error determining time-dependence.""). # Python function style Hamiltonian; elif len(h_func) > 0:; if len(c_func) == len(c_str) == 0:; time_type = 20; elif len(c_func) > 0:; time_type = 22; else:; raise Exception(""Error determining time-dependence.""). return time_type, [h_const, h_func, h_str], [c_const, c_func, c_str]. def _td_wrap_array_str(H, c_ops, args, times):; """"""; Wrap numpy-array based time-dependence in the string-based time dependence; format; """"""; n = 0; H_new = []; c_ops_new = []; args_new = {}. if not isinstance(H, list):; H_new = H; else:; for Hk in H:; if isinstance(Hk, list) and isinstance(Hk[1], np.ndarray):; H_op, H_td = Hk; td_array_name = ""_td_array_%d"" % n; H_td_str = '(0 if (t > %f) else %s[int(round(%d * (t/%f)))])' %\; (times[-1], td_array_name, len(times) - 1, times[-1]); args_new[td_array_name] = H_td; H_new.append([H_op, H_td_str]); n += 1; else:; H_new.append(Hk). if not isinstance(c_ops, list):; c_ops_new = c_ops; else:; for ck in c_ops:; if isinstance(ck, list) and isinstance(ck[1], np.ndarray):; c_op, c_td = ck; td_array_name = ""_td_array_%d"" % n; c_td_str = '(0 if (t > %f) else %s[int(round(%d * (t/%f)))])' %\; (times[-1], td_array_name, len(times) - 1, times[-1]); args_new[td_array_name] = c_td; c_ops_new.append([c_op, c_td_str]); n += 1; else:; c_ops_new.append(ck). if not args_new:; args_new = args; elif isinstance(args, dict):; args_new.update(args); else:; raise ValueError(""Time-dependent array format requires args to "" +; ""be a dictionary""). return H_new, c_ops_new, args_new. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.7/modules/qutip/rhs_generate.html:573,Modifiability,config,config,573,". qutip.rhs_generate — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.rhs_generate. Source code for qutip.rhs_generate; __all__ = ['rhs_clear']. import os; import numpy as np; from types import FunctionType, BuiltinFunctionType; from functools import partial. from qutip.cy.codegen import Codegen; from qutip.solver import Options, config, solver_safe; from qutip.qobj import Qobj; from qutip.superoperator import spre, spost; from qutip.interpolate import Cubic_Spline. [docs]def rhs_clear():; """"""; Resets the string-format time-dependent Hamiltonian parameters. Parameters; ----------. Returns; -------; Nothing, just clears data from internal config module. """"""; # time-dependent (TD) function stuff; config.tdfunc = None # Placeholder for TD RHS function.; config.colspmv = None # Placeholder for TD col-spmv function.; config.colexpect = None # Placeholder for TD col_expect function.; config.string = None # Holds string of variables to be passed to solver; config.tdname = None # Name of td .pyx file (used in parallel mc code); if ""sesolve"" in solver_safe:; del solver_safe[""sesolve""]; if ""mesolve"" in solver_safe:; del solver_safe[""mesolve""]; if ""mcsolve"" in solver_safe:; del solver_safe[""mcsolve""]. def _td_format_check(H, c_ops, solver='me'):; """"""; Checks on time-dependent format.; """"""; h_const = []; h_func = []; h_str = []; h_obj = []; # check H for incorrect format; if isinstance(H, Qobj):; pass; elif isinstance(H, (FunctionType, BuiltinFunctionType, partial)):; pass # n_func += 1; elif isinstance(H, list):; for k, H_k in enumerate(H):; if isinstance(H_k, Qobj):; h_const.append(k); elif isinstance(H_k, list):; if len(H_k) != 2 or not isinstance(H_k[0], Qobj):; raise TypeError(""Incorrect hamiltonian specification""); else:; if isinstance(",MatchSource.WIKI,docs/4.7/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.7/modules/qutip/rhs_generate.html:887,Modifiability,config,config,887,". qutip.rhs_generate — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.rhs_generate. Source code for qutip.rhs_generate; __all__ = ['rhs_clear']. import os; import numpy as np; from types import FunctionType, BuiltinFunctionType; from functools import partial. from qutip.cy.codegen import Codegen; from qutip.solver import Options, config, solver_safe; from qutip.qobj import Qobj; from qutip.superoperator import spre, spost; from qutip.interpolate import Cubic_Spline. [docs]def rhs_clear():; """"""; Resets the string-format time-dependent Hamiltonian parameters. Parameters; ----------. Returns; -------; Nothing, just clears data from internal config module. """"""; # time-dependent (TD) function stuff; config.tdfunc = None # Placeholder for TD RHS function.; config.colspmv = None # Placeholder for TD col-spmv function.; config.colexpect = None # Placeholder for TD col_expect function.; config.string = None # Holds string of variables to be passed to solver; config.tdname = None # Name of td .pyx file (used in parallel mc code); if ""sesolve"" in solver_safe:; del solver_safe[""sesolve""]; if ""mesolve"" in solver_safe:; del solver_safe[""mesolve""]; if ""mcsolve"" in solver_safe:; del solver_safe[""mcsolve""]. def _td_format_check(H, c_ops, solver='me'):; """"""; Checks on time-dependent format.; """"""; h_const = []; h_func = []; h_str = []; h_obj = []; # check H for incorrect format; if isinstance(H, Qobj):; pass; elif isinstance(H, (FunctionType, BuiltinFunctionType, partial)):; pass # n_func += 1; elif isinstance(H, list):; for k, H_k in enumerate(H):; if isinstance(H_k, Qobj):; h_const.append(k); elif isinstance(H_k, list):; if len(H_k) != 2 or not isinstance(H_k[0], Qobj):; raise TypeError(""Incorrect hamiltonian specification""); else:; if isinstance(",MatchSource.WIKI,docs/4.7/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.7/modules/qutip/rhs_generate.html:945,Modifiability,config,config,945,". qutip.rhs_generate — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.rhs_generate. Source code for qutip.rhs_generate; __all__ = ['rhs_clear']. import os; import numpy as np; from types import FunctionType, BuiltinFunctionType; from functools import partial. from qutip.cy.codegen import Codegen; from qutip.solver import Options, config, solver_safe; from qutip.qobj import Qobj; from qutip.superoperator import spre, spost; from qutip.interpolate import Cubic_Spline. [docs]def rhs_clear():; """"""; Resets the string-format time-dependent Hamiltonian parameters. Parameters; ----------. Returns; -------; Nothing, just clears data from internal config module. """"""; # time-dependent (TD) function stuff; config.tdfunc = None # Placeholder for TD RHS function.; config.colspmv = None # Placeholder for TD col-spmv function.; config.colexpect = None # Placeholder for TD col_expect function.; config.string = None # Holds string of variables to be passed to solver; config.tdname = None # Name of td .pyx file (used in parallel mc code); if ""sesolve"" in solver_safe:; del solver_safe[""sesolve""]; if ""mesolve"" in solver_safe:; del solver_safe[""mesolve""]; if ""mcsolve"" in solver_safe:; del solver_safe[""mcsolve""]. def _td_format_check(H, c_ops, solver='me'):; """"""; Checks on time-dependent format.; """"""; h_const = []; h_func = []; h_str = []; h_obj = []; # check H for incorrect format; if isinstance(H, Qobj):; pass; elif isinstance(H, (FunctionType, BuiltinFunctionType, partial)):; pass # n_func += 1; elif isinstance(H, list):; for k, H_k in enumerate(H):; if isinstance(H_k, Qobj):; h_const.append(k); elif isinstance(H_k, list):; if len(H_k) != 2 or not isinstance(H_k[0], Qobj):; raise TypeError(""Incorrect hamiltonian specification""); else:; if isinstance(",MatchSource.WIKI,docs/4.7/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.7/modules/qutip/rhs_generate.html:1002,Modifiability,config,config,1002,"tip.rhs_generate — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.rhs_generate. Source code for qutip.rhs_generate; __all__ = ['rhs_clear']. import os; import numpy as np; from types import FunctionType, BuiltinFunctionType; from functools import partial. from qutip.cy.codegen import Codegen; from qutip.solver import Options, config, solver_safe; from qutip.qobj import Qobj; from qutip.superoperator import spre, spost; from qutip.interpolate import Cubic_Spline. [docs]def rhs_clear():; """"""; Resets the string-format time-dependent Hamiltonian parameters. Parameters; ----------. Returns; -------; Nothing, just clears data from internal config module. """"""; # time-dependent (TD) function stuff; config.tdfunc = None # Placeholder for TD RHS function.; config.colspmv = None # Placeholder for TD col-spmv function.; config.colexpect = None # Placeholder for TD col_expect function.; config.string = None # Holds string of variables to be passed to solver; config.tdname = None # Name of td .pyx file (used in parallel mc code); if ""sesolve"" in solver_safe:; del solver_safe[""sesolve""]; if ""mesolve"" in solver_safe:; del solver_safe[""mesolve""]; if ""mcsolve"" in solver_safe:; del solver_safe[""mcsolve""]. def _td_format_check(H, c_ops, solver='me'):; """"""; Checks on time-dependent format.; """"""; h_const = []; h_func = []; h_str = []; h_obj = []; # check H for incorrect format; if isinstance(H, Qobj):; pass; elif isinstance(H, (FunctionType, BuiltinFunctionType, partial)):; pass # n_func += 1; elif isinstance(H, list):; for k, H_k in enumerate(H):; if isinstance(H_k, Qobj):; h_const.append(k); elif isinstance(H_k, list):; if len(H_k) != 2 or not isinstance(H_k[0], Qobj):; raise TypeError(""Incorrect hamiltonian specification""); else:; if isinstance(H_k[",MatchSource.WIKI,docs/4.7/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.7/modules/qutip/rhs_generate.html:1065,Modifiability,config,config,1065,"box in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.rhs_generate. Source code for qutip.rhs_generate; __all__ = ['rhs_clear']. import os; import numpy as np; from types import FunctionType, BuiltinFunctionType; from functools import partial. from qutip.cy.codegen import Codegen; from qutip.solver import Options, config, solver_safe; from qutip.qobj import Qobj; from qutip.superoperator import spre, spost; from qutip.interpolate import Cubic_Spline. [docs]def rhs_clear():; """"""; Resets the string-format time-dependent Hamiltonian parameters. Parameters; ----------. Returns; -------; Nothing, just clears data from internal config module. """"""; # time-dependent (TD) function stuff; config.tdfunc = None # Placeholder for TD RHS function.; config.colspmv = None # Placeholder for TD col-spmv function.; config.colexpect = None # Placeholder for TD col_expect function.; config.string = None # Holds string of variables to be passed to solver; config.tdname = None # Name of td .pyx file (used in parallel mc code); if ""sesolve"" in solver_safe:; del solver_safe[""sesolve""]; if ""mesolve"" in solver_safe:; del solver_safe[""mesolve""]; if ""mcsolve"" in solver_safe:; del solver_safe[""mcsolve""]. def _td_format_check(H, c_ops, solver='me'):; """"""; Checks on time-dependent format.; """"""; h_const = []; h_func = []; h_str = []; h_obj = []; # check H for incorrect format; if isinstance(H, Qobj):; pass; elif isinstance(H, (FunctionType, BuiltinFunctionType, partial)):; pass # n_func += 1; elif isinstance(H, list):; for k, H_k in enumerate(H):; if isinstance(H_k, Qobj):; h_const.append(k); elif isinstance(H_k, list):; if len(H_k) != 2 or not isinstance(H_k[0], Qobj):; raise TypeError(""Incorrect hamiltonian specification""); else:; if isinstance(H_k[1], (FunctionType,; BuiltinFunctionType, partial)):; h_func.app",MatchSource.WIKI,docs/4.7/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.7/modules/qutip/rhs_generate.html:1132,Modifiability,config,config,1132," Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.rhs_generate. Source code for qutip.rhs_generate; __all__ = ['rhs_clear']. import os; import numpy as np; from types import FunctionType, BuiltinFunctionType; from functools import partial. from qutip.cy.codegen import Codegen; from qutip.solver import Options, config, solver_safe; from qutip.qobj import Qobj; from qutip.superoperator import spre, spost; from qutip.interpolate import Cubic_Spline. [docs]def rhs_clear():; """"""; Resets the string-format time-dependent Hamiltonian parameters. Parameters; ----------. Returns; -------; Nothing, just clears data from internal config module. """"""; # time-dependent (TD) function stuff; config.tdfunc = None # Placeholder for TD RHS function.; config.colspmv = None # Placeholder for TD col-spmv function.; config.colexpect = None # Placeholder for TD col_expect function.; config.string = None # Holds string of variables to be passed to solver; config.tdname = None # Name of td .pyx file (used in parallel mc code); if ""sesolve"" in solver_safe:; del solver_safe[""sesolve""]; if ""mesolve"" in solver_safe:; del solver_safe[""mesolve""]; if ""mcsolve"" in solver_safe:; del solver_safe[""mcsolve""]. def _td_format_check(H, c_ops, solver='me'):; """"""; Checks on time-dependent format.; """"""; h_const = []; h_func = []; h_str = []; h_obj = []; # check H for incorrect format; if isinstance(H, Qobj):; pass; elif isinstance(H, (FunctionType, BuiltinFunctionType, partial)):; pass # n_func += 1; elif isinstance(H, list):; for k, H_k in enumerate(H):; if isinstance(H_k, Qobj):; h_const.append(k); elif isinstance(H_k, list):; if len(H_k) != 2 or not isinstance(H_k[0], Qobj):; raise TypeError(""Incorrect hamiltonian specification""); else:; if isinstance(H_k[1], (FunctionType,; BuiltinFunctionType, partial)):; h_func.append(k); elif isinstance(H_k[1], str):; h_str.append(k); elif isinst",MatchSource.WIKI,docs/4.7/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.7/modules/qutip/rhs_generate.html:1171,Modifiability,variab,variables,1171,"Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.rhs_generate. Source code for qutip.rhs_generate; __all__ = ['rhs_clear']. import os; import numpy as np; from types import FunctionType, BuiltinFunctionType; from functools import partial. from qutip.cy.codegen import Codegen; from qutip.solver import Options, config, solver_safe; from qutip.qobj import Qobj; from qutip.superoperator import spre, spost; from qutip.interpolate import Cubic_Spline. [docs]def rhs_clear():; """"""; Resets the string-format time-dependent Hamiltonian parameters. Parameters; ----------. Returns; -------; Nothing, just clears data from internal config module. """"""; # time-dependent (TD) function stuff; config.tdfunc = None # Placeholder for TD RHS function.; config.colspmv = None # Placeholder for TD col-spmv function.; config.colexpect = None # Placeholder for TD col_expect function.; config.string = None # Holds string of variables to be passed to solver; config.tdname = None # Name of td .pyx file (used in parallel mc code); if ""sesolve"" in solver_safe:; del solver_safe[""sesolve""]; if ""mesolve"" in solver_safe:; del solver_safe[""mesolve""]; if ""mcsolve"" in solver_safe:; del solver_safe[""mcsolve""]. def _td_format_check(H, c_ops, solver='me'):; """"""; Checks on time-dependent format.; """"""; h_const = []; h_func = []; h_str = []; h_obj = []; # check H for incorrect format; if isinstance(H, Qobj):; pass; elif isinstance(H, (FunctionType, BuiltinFunctionType, partial)):; pass # n_func += 1; elif isinstance(H, list):; for k, H_k in enumerate(H):; if isinstance(H_k, Qobj):; h_const.append(k); elif isinstance(H_k, list):; if len(H_k) != 2 or not isinstance(H_k[0], Qobj):; raise TypeError(""Incorrect hamiltonian specification""); else:; if isinstance(H_k[1], (FunctionType,; BuiltinFunctionType, partial)):; h_func.append(k); elif isinstance(H_k[1], str):; h_str.append(k); elif isinstance(H_k[1], Cubic_Spline):; h_obj.append",MatchSource.WIKI,docs/4.7/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.7/modules/qutip/rhs_generate.html:1205,Modifiability,config,config,1205,"Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.rhs_generate. Source code for qutip.rhs_generate; __all__ = ['rhs_clear']. import os; import numpy as np; from types import FunctionType, BuiltinFunctionType; from functools import partial. from qutip.cy.codegen import Codegen; from qutip.solver import Options, config, solver_safe; from qutip.qobj import Qobj; from qutip.superoperator import spre, spost; from qutip.interpolate import Cubic_Spline. [docs]def rhs_clear():; """"""; Resets the string-format time-dependent Hamiltonian parameters. Parameters; ----------. Returns; -------; Nothing, just clears data from internal config module. """"""; # time-dependent (TD) function stuff; config.tdfunc = None # Placeholder for TD RHS function.; config.colspmv = None # Placeholder for TD col-spmv function.; config.colexpect = None # Placeholder for TD col_expect function.; config.string = None # Holds string of variables to be passed to solver; config.tdname = None # Name of td .pyx file (used in parallel mc code); if ""sesolve"" in solver_safe:; del solver_safe[""sesolve""]; if ""mesolve"" in solver_safe:; del solver_safe[""mesolve""]; if ""mcsolve"" in solver_safe:; del solver_safe[""mcsolve""]. def _td_format_check(H, c_ops, solver='me'):; """"""; Checks on time-dependent format.; """"""; h_const = []; h_func = []; h_str = []; h_obj = []; # check H for incorrect format; if isinstance(H, Qobj):; pass; elif isinstance(H, (FunctionType, BuiltinFunctionType, partial)):; pass # n_func += 1; elif isinstance(H, list):; for k, H_k in enumerate(H):; if isinstance(H_k, Qobj):; h_const.append(k); elif isinstance(H_k, list):; if len(H_k) != 2 or not isinstance(H_k[0], Qobj):; raise TypeError(""Incorrect hamiltonian specification""); else:; if isinstance(H_k[1], (FunctionType,; BuiltinFunctionType, partial)):; h_func.append(k); elif isinstance(H_k[1], str):; h_str.append(k); elif isinstance(H_k[1], Cubic_Spline):; h_obj.append",MatchSource.WIKI,docs/4.7/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.7/modules/qutip/rhs_generate.html:3681,Performance,load,load,3681,"_ops[k], list):; if len(c_ops[k]) != 2:; raise TypeError(; ""Incorrect collapse operator specification.""); else:; if isinstance(c_ops[k][1], (FunctionType,; BuiltinFunctionType, partial)):; c_func.append(k); elif isinstance(c_ops[k][1], str):; c_str.append(k); elif isinstance(c_ops[k][1], Cubic_Spline):; c_obj.append(k); elif hasattr(c_ops[k][1], '__call__'):; c_func.append(k); elif isinstance(c_ops[k][1], np.ndarray):; c_str.append(k); elif isinstance(c_ops[k][1], tuple):; c_str.append(k); else:; raise TypeError(; ""Incorrect collapse operator specification""); else:; raise TypeError(""Incorrect collapse operator specification""). #; # if n_str == 0 and n_func == 0:; # # no time-dependence at all; #; if ((len(h_str) > 0 and len(h_func) > 0) or; (len(c_str) > 0 and len(c_func) > 0)):; raise TypeError(; ""Cannot mix string and function type time-dependence formats""). # check to see if Cython is installed and version is high enough.; if len(h_str) > 0 or len(c_str) > 0:; pass; #try:; # import Cython; #except:; # raise Exception(; # ""Unable to load Cython. Use Python function format.""); #else:; # if Cython.__version__ < '0.21':; # raise Exception(""Cython version (%s) is too old. Upgrade to"" +; # "" version 0.21+"" % Cython.__version__). # If only time-dependence is in Objects, then prefer string based format; if (len(h_func) + len(c_func) + len(h_str) + len(c_str)) == 0:; h_str += h_obj #Does nothing if not objects; c_str += c_obj; else:; # Combine Hamiltonian objects; if len(h_func) > 0:; h_func += h_obj; elif len(h_str) > 0:; h_str += h_obj. #Combine collapse objects; if len(c_func) > 0:; c_func += c_obj; elif len(c_str) > 0:; c_str += c_obj. if solver == 'me':; return (len(h_const + c_const),; len(h_func) + len(c_func),; len(h_str) + len(c_str)). elif solver == 'mc':. # H C_ops #; # -- ----- --; # NO NO 00; # NO STR 01; # NO FUNC 02; #; # STR NO 10; # STR STR 11; #; # FUNC NO 20; #; # FUNC FUNC 22. if isinstance(H, FunctionType):; time_type = 3; # Time-indepdent problems; el",MatchSource.WIKI,docs/4.7/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.7/modules/qutip/rhs_generate.html:861,Usability,clear,clears,861,". qutip.rhs_generate — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.rhs_generate. Source code for qutip.rhs_generate; __all__ = ['rhs_clear']. import os; import numpy as np; from types import FunctionType, BuiltinFunctionType; from functools import partial. from qutip.cy.codegen import Codegen; from qutip.solver import Options, config, solver_safe; from qutip.qobj import Qobj; from qutip.superoperator import spre, spost; from qutip.interpolate import Cubic_Spline. [docs]def rhs_clear():; """"""; Resets the string-format time-dependent Hamiltonian parameters. Parameters; ----------. Returns; -------; Nothing, just clears data from internal config module. """"""; # time-dependent (TD) function stuff; config.tdfunc = None # Placeholder for TD RHS function.; config.colspmv = None # Placeholder for TD col-spmv function.; config.colexpect = None # Placeholder for TD col_expect function.; config.string = None # Holds string of variables to be passed to solver; config.tdname = None # Name of td .pyx file (used in parallel mc code); if ""sesolve"" in solver_safe:; del solver_safe[""sesolve""]; if ""mesolve"" in solver_safe:; del solver_safe[""mesolve""]; if ""mcsolve"" in solver_safe:; del solver_safe[""mcsolve""]. def _td_format_check(H, c_ops, solver='me'):; """"""; Checks on time-dependent format.; """"""; h_const = []; h_func = []; h_str = []; h_obj = []; # check H for incorrect format; if isinstance(H, Qobj):; pass; elif isinstance(H, (FunctionType, BuiltinFunctionType, partial)):; pass # n_func += 1; elif isinstance(H, list):; for k, H_k in enumerate(H):; if isinstance(H_k, Qobj):; h_const.append(k); elif isinstance(H_k, list):; if len(H_k) != 2 or not isinstance(H_k[0], Qobj):; raise TypeError(""Incorrect hamiltonian specification""); else:; if isinstance(",MatchSource.WIKI,docs/4.7/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.7/modules/qutip/scattering.html:542,Deployability,configurat,configuration,542,". qutip.scattering — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.scattering. Source code for qutip.scattering; """"""; Photon scattering in quantum optical systems. This module includes a collection of functions for numerically computing photon; scattering in driven arbitrary systems coupled to some configuration of output; waveguides. The implementation of these functions closely follows the; mathematical treatment given in K.A. Fischer, et. al., Scattering of Coherent; Pulses from Quantum Optical Systems (2017, arXiv:1710.02875).; """"""; # Author: Ben Bartlett; # Contact: benbartlett@stanford.edu. import numpy as np; from itertools import product, combinations_with_replacement; from qutip import propagator, Options, basis, tensor, zero_ket, Qobj. __all__ = ['temporal_basis_vector',; 'temporal_scattered_state',; 'scattering_probability']. class Evolver:; """"""; A caching class which takes a Hamiltonian and a list of times to calculate; and memoize propagators for the system between any two times as demanded. Parameters; ----------; H : :class: qutip.Qobj or list; System-waveguide(s) Hamiltonian or effective Hamiltonian in `Qobj` or; list-callback format. If construct_effective_hamiltonian is not; specified, an effective Hamiltonian is constructed from H and c_ops.; times : list-like; List of times to evaluate propagators over.; options : :class: qutip.Options; Solver options to use when computing propagators. Attributes; ----------; H : :class: qutip.Qobj or list; System-waveguide(s) Hamiltonian, may be time-dependent.; tlist : list-like; List of times to evaluate propagators over.; propagators : (dict of float: (dict of float: :class: qutip.Qobj)); Dictionary of dictionaries of propagator objects with keys of; evaluation times, e.g.",MatchSource.WIKI,docs/4.7/modules/qutip/scattering.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/scattering.html
https://qutip.org/docs/4.7/modules/qutip/scattering.html:9424,Deployability,integrat,integrated,9424,"]; else:; raise TypeError(""Hamiltonian must be Qobj or list-callback format""); else:; Heff = H. evolver = Evolver(Heff, tlist). all_emission_indices = combinations_with_replacement(range(T), n_emissions). if system_zero_state is None:; system_zero_state = psi0. # Compute <omega_tau> for all combinations of tau; for emission_indices in all_emission_indices:; # Consider unique partitionings of emission times into waveguides; partition = tuple(set(set_partition(emission_indices, W))); # Consider all possible partitionings of time bins by waveguide; for indices in partition:; taus = [[tlist[i] for i in wg_indices] for wg_indices in indices]; omega = photon_scattering_operator(evolver, c_ops, taus); phi_n_amp = system_zero_state.dag() * omega * psi0; # Add scatter amplitude times temporal basis to overall state; phi_n += phi_n_amp * temporal_basis_vector(indices, T). return phi_n. [docs]def scattering_probability(H, psi0, n_emissions, c_ops, tlist,; system_zero_state=None,; construct_effective_hamiltonian=True):; """"""; Compute the integrated probability of scattering n photons in an arbitrary; system. This function accepts a nonlinearly spaced array of times. Parameters; ----------; H : :class: qutip.Qobj or list; System-waveguide(s) Hamiltonian or effective Hamiltonian in Qobj or; list-callback format. If construct_effective_hamiltonian is not; specified, an effective Hamiltonian is constructed from H and; `c_ops`.; psi0 : :class: qutip.Qobj; Initial state density matrix :math:`\\rho(t_0)` or state vector; :math:`\\psi(t_0)`.; n_emissions : int; Number of photons emitted by the system (into any combination of; waveguides).; c_ops : list; List of collapse operators for each waveguide; these are assumed to; include spontaneous decay rates, e.g.; :math:`\\sigma = \\sqrt \\gamma \\cdot a`.; tlist : array_like; List of times for :math:`\\tau_i`. tlist should contain 0 and exceed; the pulse duration / temporal region of interest; tlist need not be; linearly spaced.; system_zer",MatchSource.WIKI,docs/4.7/modules/qutip/scattering.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/scattering.html
https://qutip.org/docs/4.7/modules/qutip/scattering.html:11622,Deployability,integrat,integrate,11622,"si(t_0)`.; n_emissions : int; Number of photons emitted by the system (into any combination of; waveguides).; c_ops : list; List of collapse operators for each waveguide; these are assumed to; include spontaneous decay rates, e.g.; :math:`\\sigma = \\sqrt \\gamma \\cdot a`.; tlist : array_like; List of times for :math:`\\tau_i`. tlist should contain 0 and exceed; the pulse duration / temporal region of interest; tlist need not be; linearly spaced.; system_zero_state : :class: qutip.Qobj; State representing zero excitations in the system. Defaults to; `basis(systemDims, 0)`.; construct_effective_hamiltonian : bool; Whether an effective Hamiltonian should be constructed from H and c_ops:; :math:`H_{eff} = H - \\frac{i}{2} \\sum_n \\sigma_n^\\dagger \\sigma_n`; Default: True. Returns; -------; scattering_prob : float; The probability of scattering n photons from the system over the time; range specified.; """"""; phi_n = temporal_scattered_state(H, psi0, n_emissions, c_ops, tlist,; system_zero_state,; construct_effective_hamiltonian); T = len(tlist); W = len(c_ops). # Compute <omega_tau> for all combinations of tau; all_emission_indices = combinations_with_replacement(range(T), n_emissions); probs = np.zeros([T] * n_emissions). # Project scattered state onto temporal basis; for emit_indices in all_emission_indices:; # Consider unique emission time partitionings; partition = tuple(set(set_partition(emit_indices, W))); # wg_indices_list = list(set_partition(indices, W)); for wg_indices in partition:; projector = temporal_basis_vector(wg_indices, T); amplitude = (projector.dag() * phi_n).full().item(); probs[emit_indices] += np.real(amplitude.conjugate() * amplitude). # Iteratively integrate to obtain single value; while probs.shape != ():; probs = np.trapz(probs, x = tlist); return np.abs(probs). © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/modules/qutip/scattering.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/scattering.html
https://qutip.org/docs/4.7/modules/qutip/scattering.html:11819,Deployability,update,updated,11819,"si(t_0)`.; n_emissions : int; Number of photons emitted by the system (into any combination of; waveguides).; c_ops : list; List of collapse operators for each waveguide; these are assumed to; include spontaneous decay rates, e.g.; :math:`\\sigma = \\sqrt \\gamma \\cdot a`.; tlist : array_like; List of times for :math:`\\tau_i`. tlist should contain 0 and exceed; the pulse duration / temporal region of interest; tlist need not be; linearly spaced.; system_zero_state : :class: qutip.Qobj; State representing zero excitations in the system. Defaults to; `basis(systemDims, 0)`.; construct_effective_hamiltonian : bool; Whether an effective Hamiltonian should be constructed from H and c_ops:; :math:`H_{eff} = H - \\frac{i}{2} \\sum_n \\sigma_n^\\dagger \\sigma_n`; Default: True. Returns; -------; scattering_prob : float; The probability of scattering n photons from the system over the time; range specified.; """"""; phi_n = temporal_scattered_state(H, psi0, n_emissions, c_ops, tlist,; system_zero_state,; construct_effective_hamiltonian); T = len(tlist); W = len(c_ops). # Compute <omega_tau> for all combinations of tau; all_emission_indices = combinations_with_replacement(range(T), n_emissions); probs = np.zeros([T] * n_emissions). # Project scattered state onto temporal basis; for emit_indices in all_emission_indices:; # Consider unique emission time partitionings; partition = tuple(set(set_partition(emit_indices, W))); # wg_indices_list = list(set_partition(indices, W)); for wg_indices in partition:; projector = temporal_basis_vector(wg_indices, T); amplitude = (projector.dag() * phi_n).full().item(); probs[emit_indices] += np.real(amplitude.conjugate() * amplitude). # Iteratively integrate to obtain single value; while probs.shape != ():; probs = np.trapz(probs, x = tlist); return np.abs(probs). © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/modules/qutip/scattering.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/scattering.html
https://qutip.org/docs/4.7/modules/qutip/scattering.html:1772,Integrability,depend,dependent,1772,"stems (2017, arXiv:1710.02875).; """"""; # Author: Ben Bartlett; # Contact: benbartlett@stanford.edu. import numpy as np; from itertools import product, combinations_with_replacement; from qutip import propagator, Options, basis, tensor, zero_ket, Qobj. __all__ = ['temporal_basis_vector',; 'temporal_scattered_state',; 'scattering_probability']. class Evolver:; """"""; A caching class which takes a Hamiltonian and a list of times to calculate; and memoize propagators for the system between any two times as demanded. Parameters; ----------; H : :class: qutip.Qobj or list; System-waveguide(s) Hamiltonian or effective Hamiltonian in `Qobj` or; list-callback format. If construct_effective_hamiltonian is not; specified, an effective Hamiltonian is constructed from H and c_ops.; times : list-like; List of times to evaluate propagators over.; options : :class: qutip.Options; Solver options to use when computing propagators. Attributes; ----------; H : :class: qutip.Qobj or list; System-waveguide(s) Hamiltonian, may be time-dependent.; tlist : list-like; List of times to evaluate propagators over.; propagators : (dict of float: (dict of float: :class: qutip.Qobj)); Dictionary of dictionaries of propagator objects with keys of; evaluation times, e.g. propagators[t2][t1] returns U[t2,t1].; """"""; def __init__(self, H, tlist, options=None):; self.H = H; self.tlist = tlist; if options is None:; self.options = Options(nsteps=10000, normalize_output=False); else:; self.options = options; # Make a blank nested dictionary to store propagators; self.propagators = dict.fromkeys(tlist); for t in tlist:; self.propagators[t] = dict.fromkeys(tlist). def prop(self, tf, ti):; """"""Compute U[t2,t1] where t2 > t1 or return the cached operator. Parameters; ----------; tf : float; Final time to compute the propagator U[tf, ti].; ti : float; Initial time to compute the propagator U[tf,ti]. Returns; -------; propagator : :class: qutip.Qobj; The propagation operator.; """"""; left, right = np.searchsorted(self.",MatchSource.WIKI,docs/4.7/modules/qutip/scattering.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/scattering.html
https://qutip.org/docs/4.7/modules/qutip/scattering.html:4011,Integrability,wrap,wrapped,4011,"e #807); return self.propagators[t2][t1]. def set_partition(collection, num_sets):; """"""; Enumerate all ways of partitioning collection into num_sets different lists,; e.g. list(set_partition([1,2], 2)) = [[[1, 2], []], [[1], [2]], [[2], [1]],; [[], [1, 2]]]. Parameters; ----------; collection : iterable; Collection to generate a set partition of.; num_sets : int; Number of sets to partition collection into. Returns; -------; partition : iterable; The partitioning of collection into num_sets sets.; """"""; for partitioning in product(range(num_sets), repeat=len(collection)):; partition = [[] for _ in range(num_sets)]; for i, set_index in enumerate(partitioning):; partition[set_index].append(collection[i]); yield tuple(tuple(indices) for indices in partition). def photon_scattering_operator(evolver, c_ops, taus_list):; """"""; Compute the scattering operator for a system emitting into multiple; waveguides. Parameters; ----------; evolver : :class: qutip.scattering.Evolver; Evolver-wrapped Hamiltonian describing the system.; c_ops : list; list of collapse operators for each waveguide; these are assumed to; include spontaneous decay rates, e.g.; :math:`\\sigma = \\sqrt \\gamma \\cdot a`; taus_list : list-like; List of (list of emission times) for each waveguide. Returns; -------; omega : :class: qutip.Qobj; The temporal scattering operator with dimensionality equal to the; system state.; """"""; omega = 1. # Extract the full list of taus; taus = [(0.0, -1)] # temporal ""ground state"" for arbitrary waveguide; for i, tau_wg in enumerate(taus_list):; for tau in tau_wg:; taus.append((tau, i)); taus.sort(key = lambda tup: tup[0]) # sort taus by time. # Compute Prod Ueff(tq, tq-1); for i in range(1, len(taus)):; tq, q = taus[i]; tprev, _ = taus[i - 1]; omega = c_ops[q] * evolver.prop(tq, tprev) * omega. # Add the <0|Uff(TP, tm)|0> term; tmax = evolver.tlist[-1]; taumax, _ = taus[-1]; # if taus[-1] < tmax:; omega = evolver.prop(tmax, taumax) * omega. return omega. [docs]def temporal_basi",MatchSource.WIKI,docs/4.7/modules/qutip/scattering.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/scattering.html
https://qutip.org/docs/4.7/modules/qutip/scattering.html:9424,Integrability,integrat,integrated,9424,"]; else:; raise TypeError(""Hamiltonian must be Qobj or list-callback format""); else:; Heff = H. evolver = Evolver(Heff, tlist). all_emission_indices = combinations_with_replacement(range(T), n_emissions). if system_zero_state is None:; system_zero_state = psi0. # Compute <omega_tau> for all combinations of tau; for emission_indices in all_emission_indices:; # Consider unique partitionings of emission times into waveguides; partition = tuple(set(set_partition(emission_indices, W))); # Consider all possible partitionings of time bins by waveguide; for indices in partition:; taus = [[tlist[i] for i in wg_indices] for wg_indices in indices]; omega = photon_scattering_operator(evolver, c_ops, taus); phi_n_amp = system_zero_state.dag() * omega * psi0; # Add scatter amplitude times temporal basis to overall state; phi_n += phi_n_amp * temporal_basis_vector(indices, T). return phi_n. [docs]def scattering_probability(H, psi0, n_emissions, c_ops, tlist,; system_zero_state=None,; construct_effective_hamiltonian=True):; """"""; Compute the integrated probability of scattering n photons in an arbitrary; system. This function accepts a nonlinearly spaced array of times. Parameters; ----------; H : :class: qutip.Qobj or list; System-waveguide(s) Hamiltonian or effective Hamiltonian in Qobj or; list-callback format. If construct_effective_hamiltonian is not; specified, an effective Hamiltonian is constructed from H and; `c_ops`.; psi0 : :class: qutip.Qobj; Initial state density matrix :math:`\\rho(t_0)` or state vector; :math:`\\psi(t_0)`.; n_emissions : int; Number of photons emitted by the system (into any combination of; waveguides).; c_ops : list; List of collapse operators for each waveguide; these are assumed to; include spontaneous decay rates, e.g.; :math:`\\sigma = \\sqrt \\gamma \\cdot a`.; tlist : array_like; List of times for :math:`\\tau_i`. tlist should contain 0 and exceed; the pulse duration / temporal region of interest; tlist need not be; linearly spaced.; system_zer",MatchSource.WIKI,docs/4.7/modules/qutip/scattering.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/scattering.html
https://qutip.org/docs/4.7/modules/qutip/scattering.html:11622,Integrability,integrat,integrate,11622,"si(t_0)`.; n_emissions : int; Number of photons emitted by the system (into any combination of; waveguides).; c_ops : list; List of collapse operators for each waveguide; these are assumed to; include spontaneous decay rates, e.g.; :math:`\\sigma = \\sqrt \\gamma \\cdot a`.; tlist : array_like; List of times for :math:`\\tau_i`. tlist should contain 0 and exceed; the pulse duration / temporal region of interest; tlist need not be; linearly spaced.; system_zero_state : :class: qutip.Qobj; State representing zero excitations in the system. Defaults to; `basis(systemDims, 0)`.; construct_effective_hamiltonian : bool; Whether an effective Hamiltonian should be constructed from H and c_ops:; :math:`H_{eff} = H - \\frac{i}{2} \\sum_n \\sigma_n^\\dagger \\sigma_n`; Default: True. Returns; -------; scattering_prob : float; The probability of scattering n photons from the system over the time; range specified.; """"""; phi_n = temporal_scattered_state(H, psi0, n_emissions, c_ops, tlist,; system_zero_state,; construct_effective_hamiltonian); T = len(tlist); W = len(c_ops). # Compute <omega_tau> for all combinations of tau; all_emission_indices = combinations_with_replacement(range(T), n_emissions); probs = np.zeros([T] * n_emissions). # Project scattered state onto temporal basis; for emit_indices in all_emission_indices:; # Consider unique emission time partitionings; partition = tuple(set(set_partition(emit_indices, W))); # wg_indices_list = list(set_partition(indices, W)); for wg_indices in partition:; projector = temporal_basis_vector(wg_indices, T); amplitude = (projector.dag() * phi_n).full().item(); probs[emit_indices] += np.real(amplitude.conjugate() * amplitude). # Iteratively integrate to obtain single value; while probs.shape != ():; probs = np.trapz(probs, x = tlist); return np.abs(probs). © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/modules/qutip/scattering.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/scattering.html
https://qutip.org/docs/4.7/modules/qutip/scattering.html:542,Modifiability,config,configuration,542,". qutip.scattering — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.scattering. Source code for qutip.scattering; """"""; Photon scattering in quantum optical systems. This module includes a collection of functions for numerically computing photon; scattering in driven arbitrary systems coupled to some configuration of output; waveguides. The implementation of these functions closely follows the; mathematical treatment given in K.A. Fischer, et. al., Scattering of Coherent; Pulses from Quantum Optical Systems (2017, arXiv:1710.02875).; """"""; # Author: Ben Bartlett; # Contact: benbartlett@stanford.edu. import numpy as np; from itertools import product, combinations_with_replacement; from qutip import propagator, Options, basis, tensor, zero_ket, Qobj. __all__ = ['temporal_basis_vector',; 'temporal_scattered_state',; 'scattering_probability']. class Evolver:; """"""; A caching class which takes a Hamiltonian and a list of times to calculate; and memoize propagators for the system between any two times as demanded. Parameters; ----------; H : :class: qutip.Qobj or list; System-waveguide(s) Hamiltonian or effective Hamiltonian in `Qobj` or; list-callback format. If construct_effective_hamiltonian is not; specified, an effective Hamiltonian is constructed from H and c_ops.; times : list-like; List of times to evaluate propagators over.; options : :class: qutip.Options; Solver options to use when computing propagators. Attributes; ----------; H : :class: qutip.Qobj or list; System-waveguide(s) Hamiltonian, may be time-dependent.; tlist : list-like; List of times to evaluate propagators over.; propagators : (dict of float: (dict of float: :class: qutip.Qobj)); Dictionary of dictionaries of propagator objects with keys of; evaluation times, e.g.",MatchSource.WIKI,docs/4.7/modules/qutip/scattering.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/scattering.html
https://qutip.org/docs/4.7/modules/qutip/scattering.html:3820,Modifiability,evolve,evolver,3820,"; self.propagators[t2][t1] = propagator(self.H, [t1, t2],; options=self.options,; unitary_mode='single'); # Something is still broken about batch unitary mode (see #807); return self.propagators[t2][t1]. def set_partition(collection, num_sets):; """"""; Enumerate all ways of partitioning collection into num_sets different lists,; e.g. list(set_partition([1,2], 2)) = [[[1, 2], []], [[1], [2]], [[2], [1]],; [[], [1, 2]]]. Parameters; ----------; collection : iterable; Collection to generate a set partition of.; num_sets : int; Number of sets to partition collection into. Returns; -------; partition : iterable; The partitioning of collection into num_sets sets.; """"""; for partitioning in product(range(num_sets), repeat=len(collection)):; partition = [[] for _ in range(num_sets)]; for i, set_index in enumerate(partitioning):; partition[set_index].append(collection[i]); yield tuple(tuple(indices) for indices in partition). def photon_scattering_operator(evolver, c_ops, taus_list):; """"""; Compute the scattering operator for a system emitting into multiple; waveguides. Parameters; ----------; evolver : :class: qutip.scattering.Evolver; Evolver-wrapped Hamiltonian describing the system.; c_ops : list; list of collapse operators for each waveguide; these are assumed to; include spontaneous decay rates, e.g.; :math:`\\sigma = \\sqrt \\gamma \\cdot a`; taus_list : list-like; List of (list of emission times) for each waveguide. Returns; -------; omega : :class: qutip.Qobj; The temporal scattering operator with dimensionality equal to the; system state.; """"""; omega = 1. # Extract the full list of taus; taus = [(0.0, -1)] # temporal ""ground state"" for arbitrary waveguide; for i, tau_wg in enumerate(taus_list):; for tau in tau_wg:; taus.append((tau, i)); taus.sort(key = lambda tup: tup[0]) # sort taus by time. # Compute Prod Ueff(tq, tq-1); for i in range(1, len(taus)):; tq, q = taus[i]; tprev, _ = taus[i - 1]; omega = c_ops[q] * evolver.prop(tq, tprev) * omega. # Add the <0|Uff(TP, tm",MatchSource.WIKI,docs/4.7/modules/qutip/scattering.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/scattering.html
https://qutip.org/docs/4.7/modules/qutip/scattering.html:3959,Modifiability,evolve,evolver,3959,"ingle'); # Something is still broken about batch unitary mode (see #807); return self.propagators[t2][t1]. def set_partition(collection, num_sets):; """"""; Enumerate all ways of partitioning collection into num_sets different lists,; e.g. list(set_partition([1,2], 2)) = [[[1, 2], []], [[1], [2]], [[2], [1]],; [[], [1, 2]]]. Parameters; ----------; collection : iterable; Collection to generate a set partition of.; num_sets : int; Number of sets to partition collection into. Returns; -------; partition : iterable; The partitioning of collection into num_sets sets.; """"""; for partitioning in product(range(num_sets), repeat=len(collection)):; partition = [[] for _ in range(num_sets)]; for i, set_index in enumerate(partitioning):; partition[set_index].append(collection[i]); yield tuple(tuple(indices) for indices in partition). def photon_scattering_operator(evolver, c_ops, taus_list):; """"""; Compute the scattering operator for a system emitting into multiple; waveguides. Parameters; ----------; evolver : :class: qutip.scattering.Evolver; Evolver-wrapped Hamiltonian describing the system.; c_ops : list; list of collapse operators for each waveguide; these are assumed to; include spontaneous decay rates, e.g.; :math:`\\sigma = \\sqrt \\gamma \\cdot a`; taus_list : list-like; List of (list of emission times) for each waveguide. Returns; -------; omega : :class: qutip.Qobj; The temporal scattering operator with dimensionality equal to the; system state.; """"""; omega = 1. # Extract the full list of taus; taus = [(0.0, -1)] # temporal ""ground state"" for arbitrary waveguide; for i, tau_wg in enumerate(taus_list):; for tau in tau_wg:; taus.append((tau, i)); taus.sort(key = lambda tup: tup[0]) # sort taus by time. # Compute Prod Ueff(tq, tq-1); for i in range(1, len(taus)):; tq, q = taus[i]; tprev, _ = taus[i - 1]; omega = c_ops[q] * evolver.prop(tq, tprev) * omega. # Add the <0|Uff(TP, tm)|0> term; tmax = evolver.tlist[-1]; taumax, _ = taus[-1]; # if taus[-1] < tmax:; omega = evolver.",MatchSource.WIKI,docs/4.7/modules/qutip/scattering.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/scattering.html
https://qutip.org/docs/4.7/modules/qutip/scattering.html:4805,Modifiability,evolve,evolver,4805,"tuple(indices) for indices in partition). def photon_scattering_operator(evolver, c_ops, taus_list):; """"""; Compute the scattering operator for a system emitting into multiple; waveguides. Parameters; ----------; evolver : :class: qutip.scattering.Evolver; Evolver-wrapped Hamiltonian describing the system.; c_ops : list; list of collapse operators for each waveguide; these are assumed to; include spontaneous decay rates, e.g.; :math:`\\sigma = \\sqrt \\gamma \\cdot a`; taus_list : list-like; List of (list of emission times) for each waveguide. Returns; -------; omega : :class: qutip.Qobj; The temporal scattering operator with dimensionality equal to the; system state.; """"""; omega = 1. # Extract the full list of taus; taus = [(0.0, -1)] # temporal ""ground state"" for arbitrary waveguide; for i, tau_wg in enumerate(taus_list):; for tau in tau_wg:; taus.append((tau, i)); taus.sort(key = lambda tup: tup[0]) # sort taus by time. # Compute Prod Ueff(tq, tq-1); for i in range(1, len(taus)):; tq, q = taus[i]; tprev, _ = taus[i - 1]; omega = c_ops[q] * evolver.prop(tq, tprev) * omega. # Add the <0|Uff(TP, tm)|0> term; tmax = evolver.tlist[-1]; taumax, _ = taus[-1]; # if taus[-1] < tmax:; omega = evolver.prop(tmax, taumax) * omega. return omega. [docs]def temporal_basis_vector(waveguide_emission_indices, n_time_bins):; """"""; Generate a temporal basis vector for emissions at specified time bins into; specified waveguides. Parameters; ----------; waveguide_emission_indices : list or tuple; List of indices where photon emission occurs for each waveguide,; e.g. [[t1_wg1], [t1_wg2, t2_wg2], [], [t1_wg4, t2_wg4, t3_wg4]].; n_time_bins : int; Number of time bins; the range over which each index can vary. Returns; -------; temporal_basis_vector : :class: qutip.Qobj; A basis vector representing photon scattering at the specified indices.; If there are W waveguides, T times, and N photon emissions, then the; basis vector has dimensionality (W*T)^N.; """"""; # Cast waveguide_emission_indices t",MatchSource.WIKI,docs/4.7/modules/qutip/scattering.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/scattering.html
https://qutip.org/docs/4.7/modules/qutip/scattering.html:4879,Modifiability,evolve,evolver,4879,"the scattering operator for a system emitting into multiple; waveguides. Parameters; ----------; evolver : :class: qutip.scattering.Evolver; Evolver-wrapped Hamiltonian describing the system.; c_ops : list; list of collapse operators for each waveguide; these are assumed to; include spontaneous decay rates, e.g.; :math:`\\sigma = \\sqrt \\gamma \\cdot a`; taus_list : list-like; List of (list of emission times) for each waveguide. Returns; -------; omega : :class: qutip.Qobj; The temporal scattering operator with dimensionality equal to the; system state.; """"""; omega = 1. # Extract the full list of taus; taus = [(0.0, -1)] # temporal ""ground state"" for arbitrary waveguide; for i, tau_wg in enumerate(taus_list):; for tau in tau_wg:; taus.append((tau, i)); taus.sort(key = lambda tup: tup[0]) # sort taus by time. # Compute Prod Ueff(tq, tq-1); for i in range(1, len(taus)):; tq, q = taus[i]; tprev, _ = taus[i - 1]; omega = c_ops[q] * evolver.prop(tq, tprev) * omega. # Add the <0|Uff(TP, tm)|0> term; tmax = evolver.tlist[-1]; taumax, _ = taus[-1]; # if taus[-1] < tmax:; omega = evolver.prop(tmax, taumax) * omega. return omega. [docs]def temporal_basis_vector(waveguide_emission_indices, n_time_bins):; """"""; Generate a temporal basis vector for emissions at specified time bins into; specified waveguides. Parameters; ----------; waveguide_emission_indices : list or tuple; List of indices where photon emission occurs for each waveguide,; e.g. [[t1_wg1], [t1_wg2, t2_wg2], [], [t1_wg4, t2_wg4, t3_wg4]].; n_time_bins : int; Number of time bins; the range over which each index can vary. Returns; -------; temporal_basis_vector : :class: qutip.Qobj; A basis vector representing photon scattering at the specified indices.; If there are W waveguides, T times, and N photon emissions, then the; basis vector has dimensionality (W*T)^N.; """"""; # Cast waveguide_emission_indices to list for mutability; waveguide_emission_indices = [list(i) for i in waveguide_emission_indices]. # Calculate tot",MatchSource.WIKI,docs/4.7/modules/qutip/scattering.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/scattering.html
https://qutip.org/docs/4.7/modules/qutip/scattering.html:4951,Modifiability,evolve,evolver,4951,"waveguides. Parameters; ----------; evolver : :class: qutip.scattering.Evolver; Evolver-wrapped Hamiltonian describing the system.; c_ops : list; list of collapse operators for each waveguide; these are assumed to; include spontaneous decay rates, e.g.; :math:`\\sigma = \\sqrt \\gamma \\cdot a`; taus_list : list-like; List of (list of emission times) for each waveguide. Returns; -------; omega : :class: qutip.Qobj; The temporal scattering operator with dimensionality equal to the; system state.; """"""; omega = 1. # Extract the full list of taus; taus = [(0.0, -1)] # temporal ""ground state"" for arbitrary waveguide; for i, tau_wg in enumerate(taus_list):; for tau in tau_wg:; taus.append((tau, i)); taus.sort(key = lambda tup: tup[0]) # sort taus by time. # Compute Prod Ueff(tq, tq-1); for i in range(1, len(taus)):; tq, q = taus[i]; tprev, _ = taus[i - 1]; omega = c_ops[q] * evolver.prop(tq, tprev) * omega. # Add the <0|Uff(TP, tm)|0> term; tmax = evolver.tlist[-1]; taumax, _ = taus[-1]; # if taus[-1] < tmax:; omega = evolver.prop(tmax, taumax) * omega. return omega. [docs]def temporal_basis_vector(waveguide_emission_indices, n_time_bins):; """"""; Generate a temporal basis vector for emissions at specified time bins into; specified waveguides. Parameters; ----------; waveguide_emission_indices : list or tuple; List of indices where photon emission occurs for each waveguide,; e.g. [[t1_wg1], [t1_wg2, t2_wg2], [], [t1_wg4, t2_wg4, t3_wg4]].; n_time_bins : int; Number of time bins; the range over which each index can vary. Returns; -------; temporal_basis_vector : :class: qutip.Qobj; A basis vector representing photon scattering at the specified indices.; If there are W waveguides, T times, and N photon emissions, then the; basis vector has dimensionality (W*T)^N.; """"""; # Cast waveguide_emission_indices to list for mutability; waveguide_emission_indices = [list(i) for i in waveguide_emission_indices]. # Calculate total number of waveguides; W = len(waveguide_emission_indices).",MatchSource.WIKI,docs/4.7/modules/qutip/scattering.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/scattering.html
https://qutip.org/docs/4.7/modules/qutip/scattering.html:8479,Modifiability,evolve,evolver,8479,"h:`\\psi(t_0)`; construct_effective_hamiltonian : bool; Whether an effective Hamiltonian should be constructed from H and c_ops:; :math:`H_{eff} = H - \\frac{i}{2} \\sum_n \\sigma_n^\\dagger \\sigma_n`; Default: True. Returns; -------; phi_n : :class: qutip.Qobj; The scattered bath state projected onto the temporal basis given by; tlist. If there are W waveguides, T times, and N photon emissions, then; the state is a tensor product state with dimensionality T^(W*N).; """"""; T = len(tlist); W = len(c_ops). if n_emissions == 0:; phi_n = zero_ket(W * T); else:; phi_n = tensor([zero_ket(W * T)] * n_emissions). if construct_effective_hamiltonian:; # Construct an effective Hamiltonian from system hamiltonian and c_ops; if isinstance(H, Qobj):; Heff = H - 1j / 2 * sum([op.dag() * op for op in c_ops]); elif isinstance(H, list):; Heff = H + [-1j / 2 * sum([op.dag() * op for op in c_ops])]; else:; raise TypeError(""Hamiltonian must be Qobj or list-callback format""); else:; Heff = H. evolver = Evolver(Heff, tlist). all_emission_indices = combinations_with_replacement(range(T), n_emissions). if system_zero_state is None:; system_zero_state = psi0. # Compute <omega_tau> for all combinations of tau; for emission_indices in all_emission_indices:; # Consider unique partitionings of emission times into waveguides; partition = tuple(set(set_partition(emission_indices, W))); # Consider all possible partitionings of time bins by waveguide; for indices in partition:; taus = [[tlist[i] for i in wg_indices] for wg_indices in indices]; omega = photon_scattering_operator(evolver, c_ops, taus); phi_n_amp = system_zero_state.dag() * omega * psi0; # Add scatter amplitude times temporal basis to overall state; phi_n += phi_n_amp * temporal_basis_vector(indices, T). return phi_n. [docs]def scattering_probability(H, psi0, n_emissions, c_ops, tlist,; system_zero_state=None,; construct_effective_hamiltonian=True):; """"""; Compute the integrated probability of scattering n photons in an arbitrary; system",MatchSource.WIKI,docs/4.7/modules/qutip/scattering.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/scattering.html
https://qutip.org/docs/4.7/modules/qutip/scattering.html:9064,Modifiability,evolve,evolver,9064,"on emissions, then; the state is a tensor product state with dimensionality T^(W*N).; """"""; T = len(tlist); W = len(c_ops). if n_emissions == 0:; phi_n = zero_ket(W * T); else:; phi_n = tensor([zero_ket(W * T)] * n_emissions). if construct_effective_hamiltonian:; # Construct an effective Hamiltonian from system hamiltonian and c_ops; if isinstance(H, Qobj):; Heff = H - 1j / 2 * sum([op.dag() * op for op in c_ops]); elif isinstance(H, list):; Heff = H + [-1j / 2 * sum([op.dag() * op for op in c_ops])]; else:; raise TypeError(""Hamiltonian must be Qobj or list-callback format""); else:; Heff = H. evolver = Evolver(Heff, tlist). all_emission_indices = combinations_with_replacement(range(T), n_emissions). if system_zero_state is None:; system_zero_state = psi0. # Compute <omega_tau> for all combinations of tau; for emission_indices in all_emission_indices:; # Consider unique partitionings of emission times into waveguides; partition = tuple(set(set_partition(emission_indices, W))); # Consider all possible partitionings of time bins by waveguide; for indices in partition:; taus = [[tlist[i] for i in wg_indices] for wg_indices in indices]; omega = photon_scattering_operator(evolver, c_ops, taus); phi_n_amp = system_zero_state.dag() * omega * psi0; # Add scatter amplitude times temporal basis to overall state; phi_n += phi_n_amp * temporal_basis_vector(indices, T). return phi_n. [docs]def scattering_probability(H, psi0, n_emissions, c_ops, tlist,; system_zero_state=None,; construct_effective_hamiltonian=True):; """"""; Compute the integrated probability of scattering n photons in an arbitrary; system. This function accepts a nonlinearly spaced array of times. Parameters; ----------; H : :class: qutip.Qobj or list; System-waveguide(s) Hamiltonian or effective Hamiltonian in Qobj or; list-callback format. If construct_effective_hamiltonian is not; specified, an effective Hamiltonian is constructed from H and; `c_ops`.; psi0 : :class: qutip.Qobj; Initial state density matrix :math:`",MatchSource.WIKI,docs/4.7/modules/qutip/scattering.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/scattering.html
https://qutip.org/docs/4.7/modules/qutip/scattering.html:2467,Performance,cache,cached,2467,"ltonian is not; specified, an effective Hamiltonian is constructed from H and c_ops.; times : list-like; List of times to evaluate propagators over.; options : :class: qutip.Options; Solver options to use when computing propagators. Attributes; ----------; H : :class: qutip.Qobj or list; System-waveguide(s) Hamiltonian, may be time-dependent.; tlist : list-like; List of times to evaluate propagators over.; propagators : (dict of float: (dict of float: :class: qutip.Qobj)); Dictionary of dictionaries of propagator objects with keys of; evaluation times, e.g. propagators[t2][t1] returns U[t2,t1].; """"""; def __init__(self, H, tlist, options=None):; self.H = H; self.tlist = tlist; if options is None:; self.options = Options(nsteps=10000, normalize_output=False); else:; self.options = options; # Make a blank nested dictionary to store propagators; self.propagators = dict.fromkeys(tlist); for t in tlist:; self.propagators[t] = dict.fromkeys(tlist). def prop(self, tf, ti):; """"""Compute U[t2,t1] where t2 > t1 or return the cached operator. Parameters; ----------; tf : float; Final time to compute the propagator U[tf, ti].; ti : float; Initial time to compute the propagator U[tf,ti]. Returns; -------; propagator : :class: qutip.Qobj; The propagation operator.; """"""; left, right = np.searchsorted(self.tlist, [ti, tf], side='left'); t1, t2 = self.tlist[left], self.tlist[right]; if self.propagators[t2][t1] is None:; self.propagators[t2][t1] = propagator(self.H, [t1, t2],; options=self.options,; unitary_mode='single'); # Something is still broken about batch unitary mode (see #807); return self.propagators[t2][t1]. def set_partition(collection, num_sets):; """"""; Enumerate all ways of partitioning collection into num_sets different lists,; e.g. list(set_partition([1,2], 2)) = [[[1, 2], []], [[1], [2]], [[2], [1]],; [[], [1, 2]]]. Parameters; ----------; collection : iterable; Collection to generate a set partition of.; num_sets : int; Number of sets to partition collection into. Retu",MatchSource.WIKI,docs/4.7/modules/qutip/scattering.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/scattering.html
https://qutip.org/docs/4.7/modules/qutip/sesolve.html:10071,Availability,error,error,10071,"os(n_tsteps, dtype=complex)); if oper_evo:; for e in e_ops:; if not isinstance(e, Qobj):; e_ops_data.append(e); elif e.dims[1] != psi0.dims[0]:; raise TypeError(f""e_ops dims ({e.dims}) are not compatible""; f"" with the state's ({psi0.dims})""); else:; e_ops_data.append(e.dag().data); else:; for e in e_ops:; if not isinstance(e, Qobj):; e_ops_data.append(e); elif e.dims[1] != psi0.dims[0]:; raise TypeError(f""e_ops dims ({e.dims}) are not compatible""; f"" with the state's ({psi0.dims})""); else:; e_ops_data.append(e.data); else:; raise TypeError(""Expectation parameter must be a list or a function""). if opt.store_states:; output.states = []. if oper_evo:; def get_curr_state_data(r):; return vec2mat(r.y); else:; def get_curr_state_data(r):; return r.y. #; # start evolution; #; dt = np.diff(tlist); cdata = None; progress_bar.start(n_tsteps); for t_idx, t in enumerate(tlist):; progress_bar.update(t_idx); if not r.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""); # get the current state / oper data if needed; if opt.store_states or opt.normalize_output \; or n_expt_op > 0 or expt_callback:; cdata = get_curr_state_data(r). if opt.normalize_output:; # normalize per column; if oper_evo:; cdata /= la_norm(cdata, axis=0); #cdata *= norm_dim_factor / la_norm(cdata); r.set_initial_value(cdata.ravel('F'), r.t); else:; #cdata /= la_norm(cdata); norm = normalize_inplace(cdata); if norm > 1e-12:; # only reset the solver if state changed; r.set_initial_value(cdata, r.t); else:; r._y = cdata. if opt.store_states:; if oper_evo:; fdata = dense2D_to_fastcsr_fmode(cdata, size, size); output.states.append(Qobj(fdata, dims=dims)); else:; fdata = dense1D_to_fastcsr_ket(cdata); output.states.append(Qobj(fdata, dims=dims, fast='mc')). if expt_callback:; # use callback method; output.expect.append(e_ops(t, Qobj(cdata, dims=dims))). if oper_evo:; for m in range(n_expt_op):; if calla",MatchSource.WIKI,docs/4.7/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/sesolve.html
https://qutip.org/docs/4.7/modules/qutip/sesolve.html:505,Deployability,integrat,integrate,505,". qutip.sesolve — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.sesolve. Source code for qutip.sesolve; """"""; This module provides solvers for the unitary Schrodinger equation.; """""". __all__ = ['sesolve']. import os; import types; import numpy as np; import scipy.integrate; from scipy.linalg import norm as la_norm; from qutip.cy.stochastic import normalize_inplace; import qutip.settings as qset; from qutip.qobj import Qobj; from qutip.qobjevo import QobjEvo; from qutip.cy.spconvert import dense1D_to_fastcsr_ket, dense2D_to_fastcsr_fmode; from qutip.cy.spmatfuncs import (cy_expect_psi, cy_ode_psi_func_td,; cy_ode_psi_func_td_with_state); from qutip.solver import Result, Options, config, solver_safe, SolverSystem; from qutip.superoperator import vec2mat; from qutip.ui.progressbar import (BaseProgressBar, TextProgressBar); from qutip.cy.openmp.utilities import check_use_openmp, openmp_components. [docs]def sesolve(H, psi0, tlist, e_ops=None, args=None, options=None,; progress_bar=None, _safe_mode=True):; """"""; Schrödinger equation evolution of a state vector or unitary matrix for a; given Hamiltonian. Evolve the state vector (``psi0``) using a given Hamiltonian (``H``), by; integrating the set of ordinary differential equations that define the; system. Alternatively evolve a unitary matrix in solving the Schrodinger; operator equation. The output is either the state vector or unitary matrix at arbitrary points; in time (``tlist``), or the expectation values of the supplied operators; (``e_ops``). If ``e_ops`` is a callback function, it is invoked for each; time in ``tlist`` with time and the state as arguments, and the function; does not use any return values. ``e_ops`` cannot be used in conjunction; with solving the Schrodinger opera",MatchSource.WIKI,docs/4.7/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/sesolve.html
https://qutip.org/docs/4.7/modules/qutip/sesolve.html:1430,Deployability,integrat,integrating,1430,"= ['sesolve']. import os; import types; import numpy as np; import scipy.integrate; from scipy.linalg import norm as la_norm; from qutip.cy.stochastic import normalize_inplace; import qutip.settings as qset; from qutip.qobj import Qobj; from qutip.qobjevo import QobjEvo; from qutip.cy.spconvert import dense1D_to_fastcsr_ket, dense2D_to_fastcsr_fmode; from qutip.cy.spmatfuncs import (cy_expect_psi, cy_ode_psi_func_td,; cy_ode_psi_func_td_with_state); from qutip.solver import Result, Options, config, solver_safe, SolverSystem; from qutip.superoperator import vec2mat; from qutip.ui.progressbar import (BaseProgressBar, TextProgressBar); from qutip.cy.openmp.utilities import check_use_openmp, openmp_components. [docs]def sesolve(H, psi0, tlist, e_ops=None, args=None, options=None,; progress_bar=None, _safe_mode=True):; """"""; Schrödinger equation evolution of a state vector or unitary matrix for a; given Hamiltonian. Evolve the state vector (``psi0``) using a given Hamiltonian (``H``), by; integrating the set of ordinary differential equations that define the; system. Alternatively evolve a unitary matrix in solving the Schrodinger; operator equation. The output is either the state vector or unitary matrix at arbitrary points; in time (``tlist``), or the expectation values of the supplied operators; (``e_ops``). If ``e_ops`` is a callback function, it is invoked for each; time in ``tlist`` with time and the state as arguments, and the function; does not use any return values. ``e_ops`` cannot be used in conjunction; with solving the Schrodinger operator equation. Parameters; ----------. H : :class:`~qutip.Qobj`, :class:`~qutip.QobjEvo`, list, or callable; System Hamiltonian as a :obj:`~qutip.Qobj` , list of; :obj:`~qutip.Qobj` and coefficient, :obj:`~qutip.QobjEvo`,; or a callback function for time-dependent Hamiltonians. List format; and options can be found in QobjEvo's description. psi0 : :class:`~qutip.Qobj`; Initial state vector (ket) or initial unitary operator ``psi",MatchSource.WIKI,docs/4.7/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/sesolve.html
https://qutip.org/docs/4.7/modules/qutip/sesolve.html:8277,Deployability,integrat,integrate,8277,"eturn (H * ym).ravel(""F""). # -----------------------------------------------------------------------------; # Solve an ODE for func.; # Calculate the required expectation values or invoke callback; # function at each time step.; def _generic_ode_solve(func, ode_args, psi0, tlist, e_ops, opt,; progress_bar, dims=None):; """"""; Internal function for solving ODEs.; """"""; # %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%; # This function is made similar to mesolve's one for futur merging in a; # solver class; # %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%. # prepare output array; n_tsteps = len(tlist); output = Result(); output.solver = ""sesolve""; output.times = tlist. if psi0.isunitary:; initial_vector = psi0.full().ravel('F'); oper_evo = True; size = psi0.shape[0]; # oper_n = dims[0][0]; # norm_dim_factor = np.sqrt(oper_n); elif psi0.isket:; initial_vector = psi0.full().ravel(); oper_evo = False; # norm_dim_factor = 1.0. r = scipy.integrate.ode(func); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); if ode_args:; r.set_f_params(*ode_args); r.set_initial_value(initial_vector, tlist[0]). e_ops_data = []; output.expect = []; if callable(e_ops):; n_expt_op = 0; expt_callback = True; output.num_expect = 1; elif isinstance(e_ops, list):; n_expt_op = len(e_ops); expt_callback = False; output.num_expect = n_expt_op; if n_expt_op == 0:; # fallback on storing states; opt.store_states = True; else:; for op in e_ops:; if not isinstance(op, Qobj) and callable(op):; output.expect.append(np.zeros(n_tsteps, dtype=complex)); continue; if op.isherm:; output.expect.append(np.zeros(n_tsteps)); else:; output.expect.append(np.zeros(n_tsteps, dtype=complex)); if oper_evo:; for e in e_ops:; if not isinstance(e, Qobj):; e_ops_data.append(e); elif e.dims[1] != psi0.dims[0]:; raise TypeError(f""e_ops dims ({",MatchSource.WIKI,docs/4.7/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/sesolve.html
https://qutip.org/docs/4.7/modules/qutip/sesolve.html:9999,Deployability,update,update,9999,"ue; if op.isherm:; output.expect.append(np.zeros(n_tsteps)); else:; output.expect.append(np.zeros(n_tsteps, dtype=complex)); if oper_evo:; for e in e_ops:; if not isinstance(e, Qobj):; e_ops_data.append(e); elif e.dims[1] != psi0.dims[0]:; raise TypeError(f""e_ops dims ({e.dims}) are not compatible""; f"" with the state's ({psi0.dims})""); else:; e_ops_data.append(e.dag().data); else:; for e in e_ops:; if not isinstance(e, Qobj):; e_ops_data.append(e); elif e.dims[1] != psi0.dims[0]:; raise TypeError(f""e_ops dims ({e.dims}) are not compatible""; f"" with the state's ({psi0.dims})""); else:; e_ops_data.append(e.data); else:; raise TypeError(""Expectation parameter must be a list or a function""). if opt.store_states:; output.states = []. if oper_evo:; def get_curr_state_data(r):; return vec2mat(r.y); else:; def get_curr_state_data(r):; return r.y. #; # start evolution; #; dt = np.diff(tlist); cdata = None; progress_bar.start(n_tsteps); for t_idx, t in enumerate(tlist):; progress_bar.update(t_idx); if not r.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""); # get the current state / oper data if needed; if opt.store_states or opt.normalize_output \; or n_expt_op > 0 or expt_callback:; cdata = get_curr_state_data(r). if opt.normalize_output:; # normalize per column; if oper_evo:; cdata /= la_norm(cdata, axis=0); #cdata *= norm_dim_factor / la_norm(cdata); r.set_initial_value(cdata.ravel('F'), r.t); else:; #cdata /= la_norm(cdata); norm = normalize_inplace(cdata); if norm > 1e-12:; # only reset the solver if state changed; r.set_initial_value(cdata, r.t); else:; r._y = cdata. if opt.store_states:; if oper_evo:; fdata = dense2D_to_fastcsr_fmode(cdata, size, size); output.states.append(Qobj(fdata, dims=dims)); else:; fdata = dense1D_to_fastcsr_ket(cdata); output.states.append(Qobj(fdata, dims=dims, fast='mc')). if expt_callback:; # use callback method; output.expe",MatchSource.WIKI,docs/4.7/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/sesolve.html
https://qutip.org/docs/4.7/modules/qutip/sesolve.html:10059,Deployability,integrat,integration,10059,"os(n_tsteps, dtype=complex)); if oper_evo:; for e in e_ops:; if not isinstance(e, Qobj):; e_ops_data.append(e); elif e.dims[1] != psi0.dims[0]:; raise TypeError(f""e_ops dims ({e.dims}) are not compatible""; f"" with the state's ({psi0.dims})""); else:; e_ops_data.append(e.dag().data); else:; for e in e_ops:; if not isinstance(e, Qobj):; e_ops_data.append(e); elif e.dims[1] != psi0.dims[0]:; raise TypeError(f""e_ops dims ({e.dims}) are not compatible""; f"" with the state's ({psi0.dims})""); else:; e_ops_data.append(e.data); else:; raise TypeError(""Expectation parameter must be a list or a function""). if opt.store_states:; output.states = []. if oper_evo:; def get_curr_state_data(r):; return vec2mat(r.y); else:; def get_curr_state_data(r):; return r.y. #; # start evolution; #; dt = np.diff(tlist); cdata = None; progress_bar.start(n_tsteps); for t_idx, t in enumerate(tlist):; progress_bar.update(t_idx); if not r.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""); # get the current state / oper data if needed; if opt.store_states or opt.normalize_output \; or n_expt_op > 0 or expt_callback:; cdata = get_curr_state_data(r). if opt.normalize_output:; # normalize per column; if oper_evo:; cdata /= la_norm(cdata, axis=0); #cdata *= norm_dim_factor / la_norm(cdata); r.set_initial_value(cdata.ravel('F'), r.t); else:; #cdata /= la_norm(cdata); norm = normalize_inplace(cdata); if norm > 1e-12:; # only reset the solver if state changed; r.set_initial_value(cdata, r.t); else:; r._y = cdata. if opt.store_states:; if oper_evo:; fdata = dense2D_to_fastcsr_fmode(cdata, size, size); output.states.append(Qobj(fdata, dims=dims)); else:; fdata = dense1D_to_fastcsr_ket(cdata); output.states.append(Qobj(fdata, dims=dims, fast='mc')). if expt_callback:; # use callback method; output.expect.append(e_ops(t, Qobj(cdata, dims=dims))). if oper_evo:; for m in range(n_expt_op):; if calla",MatchSource.WIKI,docs/4.7/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/sesolve.html
https://qutip.org/docs/4.7/modules/qutip/sesolve.html:11541,Deployability,integrat,integrate,11541,"r.update(t_idx); if not r.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""); # get the current state / oper data if needed; if opt.store_states or opt.normalize_output \; or n_expt_op > 0 or expt_callback:; cdata = get_curr_state_data(r). if opt.normalize_output:; # normalize per column; if oper_evo:; cdata /= la_norm(cdata, axis=0); #cdata *= norm_dim_factor / la_norm(cdata); r.set_initial_value(cdata.ravel('F'), r.t); else:; #cdata /= la_norm(cdata); norm = normalize_inplace(cdata); if norm > 1e-12:; # only reset the solver if state changed; r.set_initial_value(cdata, r.t); else:; r._y = cdata. if opt.store_states:; if oper_evo:; fdata = dense2D_to_fastcsr_fmode(cdata, size, size); output.states.append(Qobj(fdata, dims=dims)); else:; fdata = dense1D_to_fastcsr_ket(cdata); output.states.append(Qobj(fdata, dims=dims, fast='mc')). if expt_callback:; # use callback method; output.expect.append(e_ops(t, Qobj(cdata, dims=dims))). if oper_evo:; for m in range(n_expt_op):; if callable(e_ops_data[m]):; func = e_ops_data[m]; output.expect[m][t_idx] = func(t, Qobj(cdata, dims=dims)); continue; output.expect[m][t_idx] = (e_ops_data[m] * cdata).trace(); else:; for m in range(n_expt_op):; if callable(e_ops_data[m]):; func = e_ops_data[m]; output.expect[m][t_idx] = func(t, Qobj(cdata, dims=dims)); continue; output.expect[m][t_idx] = cy_expect_psi(e_ops_data[m], cdata,; e_ops[m].isherm). if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]). progress_bar.finished(). if opt.store_final_state:; cdata = get_curr_state_data(r); if opt.normalize_output:; cdata /= la_norm(cdata, axis=0); # cdata *= norm_dim_factor / la_norm(cdata); output.final_state = Qobj(cdata, dims=dims). return output. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/sesolve.html
https://qutip.org/docs/4.7/modules/qutip/sesolve.html:11896,Deployability,update,updated,11896,"r.update(t_idx); if not r.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""); # get the current state / oper data if needed; if opt.store_states or opt.normalize_output \; or n_expt_op > 0 or expt_callback:; cdata = get_curr_state_data(r). if opt.normalize_output:; # normalize per column; if oper_evo:; cdata /= la_norm(cdata, axis=0); #cdata *= norm_dim_factor / la_norm(cdata); r.set_initial_value(cdata.ravel('F'), r.t); else:; #cdata /= la_norm(cdata); norm = normalize_inplace(cdata); if norm > 1e-12:; # only reset the solver if state changed; r.set_initial_value(cdata, r.t); else:; r._y = cdata. if opt.store_states:; if oper_evo:; fdata = dense2D_to_fastcsr_fmode(cdata, size, size); output.states.append(Qobj(fdata, dims=dims)); else:; fdata = dense1D_to_fastcsr_ket(cdata); output.states.append(Qobj(fdata, dims=dims, fast='mc')). if expt_callback:; # use callback method; output.expect.append(e_ops(t, Qobj(cdata, dims=dims))). if oper_evo:; for m in range(n_expt_op):; if callable(e_ops_data[m]):; func = e_ops_data[m]; output.expect[m][t_idx] = func(t, Qobj(cdata, dims=dims)); continue; output.expect[m][t_idx] = (e_ops_data[m] * cdata).trace(); else:; for m in range(n_expt_op):; if callable(e_ops_data[m]):; func = e_ops_data[m]; output.expect[m][t_idx] = func(t, Qobj(cdata, dims=dims)); continue; output.expect[m][t_idx] = cy_expect_psi(e_ops_data[m], cdata,; e_ops[m].isherm). if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]). progress_bar.finished(). if opt.store_final_state:; cdata = get_curr_state_data(r); if opt.normalize_output:; cdata /= la_norm(cdata, axis=0); # cdata *= norm_dim_factor / la_norm(cdata); output.final_state = Qobj(cdata, dims=dims). return output. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/sesolve.html
https://qutip.org/docs/4.7/modules/qutip/sesolve.html:505,Integrability,integrat,integrate,505,". qutip.sesolve — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.sesolve. Source code for qutip.sesolve; """"""; This module provides solvers for the unitary Schrodinger equation.; """""". __all__ = ['sesolve']. import os; import types; import numpy as np; import scipy.integrate; from scipy.linalg import norm as la_norm; from qutip.cy.stochastic import normalize_inplace; import qutip.settings as qset; from qutip.qobj import Qobj; from qutip.qobjevo import QobjEvo; from qutip.cy.spconvert import dense1D_to_fastcsr_ket, dense2D_to_fastcsr_fmode; from qutip.cy.spmatfuncs import (cy_expect_psi, cy_ode_psi_func_td,; cy_ode_psi_func_td_with_state); from qutip.solver import Result, Options, config, solver_safe, SolverSystem; from qutip.superoperator import vec2mat; from qutip.ui.progressbar import (BaseProgressBar, TextProgressBar); from qutip.cy.openmp.utilities import check_use_openmp, openmp_components. [docs]def sesolve(H, psi0, tlist, e_ops=None, args=None, options=None,; progress_bar=None, _safe_mode=True):; """"""; Schrödinger equation evolution of a state vector or unitary matrix for a; given Hamiltonian. Evolve the state vector (``psi0``) using a given Hamiltonian (``H``), by; integrating the set of ordinary differential equations that define the; system. Alternatively evolve a unitary matrix in solving the Schrodinger; operator equation. The output is either the state vector or unitary matrix at arbitrary points; in time (``tlist``), or the expectation values of the supplied operators; (``e_ops``). If ``e_ops`` is a callback function, it is invoked for each; time in ``tlist`` with time and the state as arguments, and the function; does not use any return values. ``e_ops`` cannot be used in conjunction; with solving the Schrodinger opera",MatchSource.WIKI,docs/4.7/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/sesolve.html
https://qutip.org/docs/4.7/modules/qutip/sesolve.html:1430,Integrability,integrat,integrating,1430,"= ['sesolve']. import os; import types; import numpy as np; import scipy.integrate; from scipy.linalg import norm as la_norm; from qutip.cy.stochastic import normalize_inplace; import qutip.settings as qset; from qutip.qobj import Qobj; from qutip.qobjevo import QobjEvo; from qutip.cy.spconvert import dense1D_to_fastcsr_ket, dense2D_to_fastcsr_fmode; from qutip.cy.spmatfuncs import (cy_expect_psi, cy_ode_psi_func_td,; cy_ode_psi_func_td_with_state); from qutip.solver import Result, Options, config, solver_safe, SolverSystem; from qutip.superoperator import vec2mat; from qutip.ui.progressbar import (BaseProgressBar, TextProgressBar); from qutip.cy.openmp.utilities import check_use_openmp, openmp_components. [docs]def sesolve(H, psi0, tlist, e_ops=None, args=None, options=None,; progress_bar=None, _safe_mode=True):; """"""; Schrödinger equation evolution of a state vector or unitary matrix for a; given Hamiltonian. Evolve the state vector (``psi0``) using a given Hamiltonian (``H``), by; integrating the set of ordinary differential equations that define the; system. Alternatively evolve a unitary matrix in solving the Schrodinger; operator equation. The output is either the state vector or unitary matrix at arbitrary points; in time (``tlist``), or the expectation values of the supplied operators; (``e_ops``). If ``e_ops`` is a callback function, it is invoked for each; time in ``tlist`` with time and the state as arguments, and the function; does not use any return values. ``e_ops`` cannot be used in conjunction; with solving the Schrodinger operator equation. Parameters; ----------. H : :class:`~qutip.Qobj`, :class:`~qutip.QobjEvo`, list, or callable; System Hamiltonian as a :obj:`~qutip.Qobj` , list of; :obj:`~qutip.Qobj` and coefficient, :obj:`~qutip.QobjEvo`,; or a callback function for time-dependent Hamiltonians. List format; and options can be found in QobjEvo's description. psi0 : :class:`~qutip.Qobj`; Initial state vector (ket) or initial unitary operator ``psi",MatchSource.WIKI,docs/4.7/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/sesolve.html
https://qutip.org/docs/4.7/modules/qutip/sesolve.html:2255,Integrability,depend,dependent,2255,"mode=True):; """"""; Schrödinger equation evolution of a state vector or unitary matrix for a; given Hamiltonian. Evolve the state vector (``psi0``) using a given Hamiltonian (``H``), by; integrating the set of ordinary differential equations that define the; system. Alternatively evolve a unitary matrix in solving the Schrodinger; operator equation. The output is either the state vector or unitary matrix at arbitrary points; in time (``tlist``), or the expectation values of the supplied operators; (``e_ops``). If ``e_ops`` is a callback function, it is invoked for each; time in ``tlist`` with time and the state as arguments, and the function; does not use any return values. ``e_ops`` cannot be used in conjunction; with solving the Schrodinger operator equation. Parameters; ----------. H : :class:`~qutip.Qobj`, :class:`~qutip.QobjEvo`, list, or callable; System Hamiltonian as a :obj:`~qutip.Qobj` , list of; :obj:`~qutip.Qobj` and coefficient, :obj:`~qutip.QobjEvo`,; or a callback function for time-dependent Hamiltonians. List format; and options can be found in QobjEvo's description. psi0 : :class:`~qutip.Qobj`; Initial state vector (ket) or initial unitary operator ``psi0 = U``. tlist : array_like of float; List of times for :math:`t`. e_ops : None / list / callback function, optional; A list of operators as `Qobj` and/or callable functions (can be mixed); or a single callable function. For callable functions, they are called; as ``f(t, state)`` and return the expectation value. A single; callback's expectation value can be any type, but a callback part of a; list must return a number as the expectation value. For operators, the; result's expect will be computed by :func:`qutip.expect` when the state; is a ``ket``. For operator evolution, the overlap is computed by: ::. (e_ops[i].dag() * op(t)).tr(). args : dict, optional; Dictionary of scope parameters for time-dependent Hamiltonians. options : :obj:`~qutip.solver.Options`, optional; Options for the ODE solver. progr",MatchSource.WIKI,docs/4.7/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/sesolve.html
https://qutip.org/docs/4.7/modules/qutip/sesolve.html:3138,Integrability,depend,dependent,3138,"amiltonian as a :obj:`~qutip.Qobj` , list of; :obj:`~qutip.Qobj` and coefficient, :obj:`~qutip.QobjEvo`,; or a callback function for time-dependent Hamiltonians. List format; and options can be found in QobjEvo's description. psi0 : :class:`~qutip.Qobj`; Initial state vector (ket) or initial unitary operator ``psi0 = U``. tlist : array_like of float; List of times for :math:`t`. e_ops : None / list / callback function, optional; A list of operators as `Qobj` and/or callable functions (can be mixed); or a single callable function. For callable functions, they are called; as ``f(t, state)`` and return the expectation value. A single; callback's expectation value can be any type, but a callback part of a; list must return a number as the expectation value. For operators, the; result's expect will be computed by :func:`qutip.expect` when the state; is a ``ket``. For operator evolution, the overlap is computed by: ::. (e_ops[i].dag() * op(t)).tr(). args : dict, optional; Dictionary of scope parameters for time-dependent Hamiltonians. options : :obj:`~qutip.solver.Options`, optional; Options for the ODE solver. progress_bar : :obj:`~BaseProgressBar`, optional; Optional instance of :obj:`~BaseProgressBar`, or a subclass thereof,; for showing the progress of the simulation. Returns; -------. output: :class:`~qutip.solver.Result`; An instance of the class :class:`~qutip.solver.Options`, which; contains either an array of expectation values for the times; specified by ``tlist``, or an array or state vectors; corresponding to the times in ``tlist`` (if ``e_ops`` is an empty; list), or nothing if a callback function was given inplace of; operators for which to calculate the expectation values.; """"""; if e_ops is None:; e_ops = []; if isinstance(e_ops, Qobj):; e_ops = [e_ops]; elif isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None. if progress_bar is None:; progress_bar = BaseProgressBar(); if progress_bar is True:; progres",MatchSource.WIKI,docs/4.7/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/sesolve.html
https://qutip.org/docs/4.7/modules/qutip/sesolve.html:5244,Integrability,depend,dependent,5244,"s initial operator.""). if options is None:; options = Options(); if options.rhs_reuse and not isinstance(H, SolverSystem):; # TODO: deprecate when going to class based solver.; if ""sesolve"" in solver_safe:; H = solver_safe[""sesolve""]. if args is None:; args = {}. check_use_openmp(options). if isinstance(H, SolverSystem):; ss = H; elif isinstance(H, (list, Qobj, QobjEvo)):; ss = _sesolve_QobjEvo(H, tlist, args, options); elif callable(H):; ss = _sesolve_func_td(H, args, options); else:; raise TypeError(f""Invalid H: {H!r}""). func, ode_args = ss.makefunc(ss, psi0, args, e_ops, options). if _safe_mode:; v = psi0.full().ravel('F'); func(0., v, *ode_args) + v. res = _generic_ode_solve(func, ode_args, psi0, tlist, e_ops, options,; progress_bar, dims=psi0.dims); if e_ops_dict:; res.expect = {e: res.expect[n]; for n, e in enumerate(e_ops_dict.keys())}; return res. # -----------------------------------------------------------------------------; # A time-dependent unitary wavefunction equation on the list-function format; #; def _sesolve_QobjEvo(H, tlist, args, opt):; """"""; Prepare the system for the solver, H can be an QobjEvo.; """"""; H_td = -1.0j * QobjEvo(H, args, tlist=tlist); if opt.rhs_with_state:; H_td._check_old_with_state(); nthread = opt.openmp_threads if opt.use_openmp else 0; H_td.compile(omp=nthread). ss = SolverSystem(); ss.H = H_td; ss.makefunc = _qobjevo_set; solver_safe[""sesolve""] = ss; return ss. def _qobjevo_set(HS, psi, args, e_ops, opt):; """"""; From the system, get the ode function and args; """"""; H_td = HS.H; H_td.solver_set_args(args, psi, e_ops); if psi.isunitary:; func = H_td.compiled_qobjevo.ode_mul_mat_f_vec; elif psi.isket:; func = H_td.compiled_qobjevo.mul_vec; else:; raise TypeError(""The unitary solver requires psi0 to be""; "" a ket as initial state""; "" or a unitary as initial operator.""); return func, (). # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary quantum evolut",MatchSource.WIKI,docs/4.7/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/sesolve.html
https://qutip.org/docs/4.7/modules/qutip/sesolve.html:6305,Integrability,depend,dependent,6305,"-; # A time-dependent unitary wavefunction equation on the list-function format; #; def _sesolve_QobjEvo(H, tlist, args, opt):; """"""; Prepare the system for the solver, H can be an QobjEvo.; """"""; H_td = -1.0j * QobjEvo(H, args, tlist=tlist); if opt.rhs_with_state:; H_td._check_old_with_state(); nthread = opt.openmp_threads if opt.use_openmp else 0; H_td.compile(omp=nthread). ss = SolverSystem(); ss.H = H_td; ss.makefunc = _qobjevo_set; solver_safe[""sesolve""] = ss; return ss. def _qobjevo_set(HS, psi, args, e_ops, opt):; """"""; From the system, get the ode function and args; """"""; H_td = HS.H; H_td.solver_set_args(args, psi, e_ops); if psi.isunitary:; func = H_td.compiled_qobjevo.ode_mul_mat_f_vec; elif psi.isket:; func = H_td.compiled_qobjevo.mul_vec; else:; raise TypeError(""The unitary solver requires psi0 to be""; "" a ket as initial state""; "" or a unitary as initial operator.""); return func, (). # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary quantum evolution), for; # time dependent hamiltonians.; #; def _sesolve_func_td(H_func, args, opt):; """"""; Prepare the system for the solver, H is a function.; """"""; ss = SolverSystem(); ss.H = H_func; ss.makefunc = _Hfunc_set; solver_safe[""sesolve""] = ss; return ss. def _Hfunc_set(HS, psi, args, e_ops, opt):; """"""; From the system, get the ode function and args; """"""; H_func = HS.H; if psi.isunitary:; if not opt.rhs_with_state:; func = _ode_oper_func_td; else:; func = _ode_oper_func_td_with_state; else:; if not opt.rhs_with_state:; func = cy_ode_psi_func_td; else:; func = cy_ode_psi_func_td_with_state. return func, (H_func, args). # -----------------------------------------------------------------------------; # evaluate dU(t)/dt according to the schrodinger equation; #; def _ode_oper_func_td(t, y, H_func, args):; H = H_func(t, args).data * -1j; ym = vec2mat(y); return (H * ym).ravel(""F""). def _ode_oper_func_td_with_state(t, y, H_func, args):; H = ",MatchSource.WIKI,docs/4.7/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/sesolve.html
https://qutip.org/docs/4.7/modules/qutip/sesolve.html:8277,Integrability,integrat,integrate,8277,"eturn (H * ym).ravel(""F""). # -----------------------------------------------------------------------------; # Solve an ODE for func.; # Calculate the required expectation values or invoke callback; # function at each time step.; def _generic_ode_solve(func, ode_args, psi0, tlist, e_ops, opt,; progress_bar, dims=None):; """"""; Internal function for solving ODEs.; """"""; # %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%; # This function is made similar to mesolve's one for futur merging in a; # solver class; # %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%. # prepare output array; n_tsteps = len(tlist); output = Result(); output.solver = ""sesolve""; output.times = tlist. if psi0.isunitary:; initial_vector = psi0.full().ravel('F'); oper_evo = True; size = psi0.shape[0]; # oper_n = dims[0][0]; # norm_dim_factor = np.sqrt(oper_n); elif psi0.isket:; initial_vector = psi0.full().ravel(); oper_evo = False; # norm_dim_factor = 1.0. r = scipy.integrate.ode(func); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); if ode_args:; r.set_f_params(*ode_args); r.set_initial_value(initial_vector, tlist[0]). e_ops_data = []; output.expect = []; if callable(e_ops):; n_expt_op = 0; expt_callback = True; output.num_expect = 1; elif isinstance(e_ops, list):; n_expt_op = len(e_ops); expt_callback = False; output.num_expect = n_expt_op; if n_expt_op == 0:; # fallback on storing states; opt.store_states = True; else:; for op in e_ops:; if not isinstance(op, Qobj) and callable(op):; output.expect.append(np.zeros(n_tsteps, dtype=complex)); continue; if op.isherm:; output.expect.append(np.zeros(n_tsteps)); else:; output.expect.append(np.zeros(n_tsteps, dtype=complex)); if oper_evo:; for e in e_ops:; if not isinstance(e, Qobj):; e_ops_data.append(e); elif e.dims[1] != psi0.dims[0]:; raise TypeError(f""e_ops dims ({",MatchSource.WIKI,docs/4.7/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/sesolve.html
https://qutip.org/docs/4.7/modules/qutip/sesolve.html:10059,Integrability,integrat,integration,10059,"os(n_tsteps, dtype=complex)); if oper_evo:; for e in e_ops:; if not isinstance(e, Qobj):; e_ops_data.append(e); elif e.dims[1] != psi0.dims[0]:; raise TypeError(f""e_ops dims ({e.dims}) are not compatible""; f"" with the state's ({psi0.dims})""); else:; e_ops_data.append(e.dag().data); else:; for e in e_ops:; if not isinstance(e, Qobj):; e_ops_data.append(e); elif e.dims[1] != psi0.dims[0]:; raise TypeError(f""e_ops dims ({e.dims}) are not compatible""; f"" with the state's ({psi0.dims})""); else:; e_ops_data.append(e.data); else:; raise TypeError(""Expectation parameter must be a list or a function""). if opt.store_states:; output.states = []. if oper_evo:; def get_curr_state_data(r):; return vec2mat(r.y); else:; def get_curr_state_data(r):; return r.y. #; # start evolution; #; dt = np.diff(tlist); cdata = None; progress_bar.start(n_tsteps); for t_idx, t in enumerate(tlist):; progress_bar.update(t_idx); if not r.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""); # get the current state / oper data if needed; if opt.store_states or opt.normalize_output \; or n_expt_op > 0 or expt_callback:; cdata = get_curr_state_data(r). if opt.normalize_output:; # normalize per column; if oper_evo:; cdata /= la_norm(cdata, axis=0); #cdata *= norm_dim_factor / la_norm(cdata); r.set_initial_value(cdata.ravel('F'), r.t); else:; #cdata /= la_norm(cdata); norm = normalize_inplace(cdata); if norm > 1e-12:; # only reset the solver if state changed; r.set_initial_value(cdata, r.t); else:; r._y = cdata. if opt.store_states:; if oper_evo:; fdata = dense2D_to_fastcsr_fmode(cdata, size, size); output.states.append(Qobj(fdata, dims=dims)); else:; fdata = dense1D_to_fastcsr_ket(cdata); output.states.append(Qobj(fdata, dims=dims, fast='mc')). if expt_callback:; # use callback method; output.expect.append(e_ops(t, Qobj(cdata, dims=dims))). if oper_evo:; for m in range(n_expt_op):; if calla",MatchSource.WIKI,docs/4.7/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/sesolve.html
https://qutip.org/docs/4.7/modules/qutip/sesolve.html:11541,Integrability,integrat,integrate,11541,"r.update(t_idx); if not r.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""); # get the current state / oper data if needed; if opt.store_states or opt.normalize_output \; or n_expt_op > 0 or expt_callback:; cdata = get_curr_state_data(r). if opt.normalize_output:; # normalize per column; if oper_evo:; cdata /= la_norm(cdata, axis=0); #cdata *= norm_dim_factor / la_norm(cdata); r.set_initial_value(cdata.ravel('F'), r.t); else:; #cdata /= la_norm(cdata); norm = normalize_inplace(cdata); if norm > 1e-12:; # only reset the solver if state changed; r.set_initial_value(cdata, r.t); else:; r._y = cdata. if opt.store_states:; if oper_evo:; fdata = dense2D_to_fastcsr_fmode(cdata, size, size); output.states.append(Qobj(fdata, dims=dims)); else:; fdata = dense1D_to_fastcsr_ket(cdata); output.states.append(Qobj(fdata, dims=dims, fast='mc')). if expt_callback:; # use callback method; output.expect.append(e_ops(t, Qobj(cdata, dims=dims))). if oper_evo:; for m in range(n_expt_op):; if callable(e_ops_data[m]):; func = e_ops_data[m]; output.expect[m][t_idx] = func(t, Qobj(cdata, dims=dims)); continue; output.expect[m][t_idx] = (e_ops_data[m] * cdata).trace(); else:; for m in range(n_expt_op):; if callable(e_ops_data[m]):; func = e_ops_data[m]; output.expect[m][t_idx] = func(t, Qobj(cdata, dims=dims)); continue; output.expect[m][t_idx] = cy_expect_psi(e_ops_data[m], cdata,; e_ops[m].isherm). if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]). progress_bar.finished(). if opt.store_final_state:; cdata = get_curr_state_data(r); if opt.normalize_output:; cdata /= la_norm(cdata, axis=0); # cdata *= norm_dim_factor / la_norm(cdata); output.final_state = Qobj(cdata, dims=dims). return output. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/sesolve.html
https://qutip.org/docs/4.7/modules/qutip/sesolve.html:928,Modifiability,config,config,928,". qutip.sesolve — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.sesolve. Source code for qutip.sesolve; """"""; This module provides solvers for the unitary Schrodinger equation.; """""". __all__ = ['sesolve']. import os; import types; import numpy as np; import scipy.integrate; from scipy.linalg import norm as la_norm; from qutip.cy.stochastic import normalize_inplace; import qutip.settings as qset; from qutip.qobj import Qobj; from qutip.qobjevo import QobjEvo; from qutip.cy.spconvert import dense1D_to_fastcsr_ket, dense2D_to_fastcsr_fmode; from qutip.cy.spmatfuncs import (cy_expect_psi, cy_ode_psi_func_td,; cy_ode_psi_func_td_with_state); from qutip.solver import Result, Options, config, solver_safe, SolverSystem; from qutip.superoperator import vec2mat; from qutip.ui.progressbar import (BaseProgressBar, TextProgressBar); from qutip.cy.openmp.utilities import check_use_openmp, openmp_components. [docs]def sesolve(H, psi0, tlist, e_ops=None, args=None, options=None,; progress_bar=None, _safe_mode=True):; """"""; Schrödinger equation evolution of a state vector or unitary matrix for a; given Hamiltonian. Evolve the state vector (``psi0``) using a given Hamiltonian (``H``), by; integrating the set of ordinary differential equations that define the; system. Alternatively evolve a unitary matrix in solving the Schrodinger; operator equation. The output is either the state vector or unitary matrix at arbitrary points; in time (``tlist``), or the expectation values of the supplied operators; (``e_ops``). If ``e_ops`` is a callback function, it is invoked for each; time in ``tlist`` with time and the state as arguments, and the function; does not use any return values. ``e_ops`` cannot be used in conjunction; with solving the Schrodinger opera",MatchSource.WIKI,docs/4.7/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/sesolve.html
https://qutip.org/docs/4.7/modules/qutip/sesolve.html:1524,Modifiability,evolve,evolve,1524,"_norm; from qutip.cy.stochastic import normalize_inplace; import qutip.settings as qset; from qutip.qobj import Qobj; from qutip.qobjevo import QobjEvo; from qutip.cy.spconvert import dense1D_to_fastcsr_ket, dense2D_to_fastcsr_fmode; from qutip.cy.spmatfuncs import (cy_expect_psi, cy_ode_psi_func_td,; cy_ode_psi_func_td_with_state); from qutip.solver import Result, Options, config, solver_safe, SolverSystem; from qutip.superoperator import vec2mat; from qutip.ui.progressbar import (BaseProgressBar, TextProgressBar); from qutip.cy.openmp.utilities import check_use_openmp, openmp_components. [docs]def sesolve(H, psi0, tlist, e_ops=None, args=None, options=None,; progress_bar=None, _safe_mode=True):; """"""; Schrödinger equation evolution of a state vector or unitary matrix for a; given Hamiltonian. Evolve the state vector (``psi0``) using a given Hamiltonian (``H``), by; integrating the set of ordinary differential equations that define the; system. Alternatively evolve a unitary matrix in solving the Schrodinger; operator equation. The output is either the state vector or unitary matrix at arbitrary points; in time (``tlist``), or the expectation values of the supplied operators; (``e_ops``). If ``e_ops`` is a callback function, it is invoked for each; time in ``tlist`` with time and the state as arguments, and the function; does not use any return values. ``e_ops`` cannot be used in conjunction; with solving the Schrodinger operator equation. Parameters; ----------. H : :class:`~qutip.Qobj`, :class:`~qutip.QobjEvo`, list, or callable; System Hamiltonian as a :obj:`~qutip.Qobj` , list of; :obj:`~qutip.Qobj` and coefficient, :obj:`~qutip.QobjEvo`,; or a callback function for time-dependent Hamiltonians. List format; and options can be found in QobjEvo's description. psi0 : :class:`~qutip.Qobj`; Initial state vector (ket) or initial unitary operator ``psi0 = U``. tlist : array_like of float; List of times for :math:`t`. e_ops : None / list / callback function, optional; A ",MatchSource.WIKI,docs/4.7/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/sesolve.html
https://qutip.org/docs/4.7/modules/qutip/simdiag.html:3719,Deployability,update,updated,3719,"nerate eigenstates. safe_mode : bool [True]; Whether to check that all ops are Hermitian and commuting. If set to; ``False`` and operators are not commuting, the eigenvectors returned; will often be eigenvectors of only the first operator. Returns; --------; eigs : tuple; Tuple of arrays representing eigvecs and eigvals of quantum objects; corresponding to simultaneous eigenvectors and eigenvalues for each; operator. """"""; if not ops:; raise ValueError(""No input matrices.""); N = ops[0].shape[0]; num_ops = len(ops) if safe_mode else 0; for jj in range(num_ops):; A = ops[jj]; shape = A.shape; if shape[0] != shape[1]:; raise TypeError('Matricies must be square.'); if shape[0] != N:; raise TypeError('All matrices. must be the same shape'); if not A.isherm:; raise TypeError('Matricies must be Hermitian'); for kk in range(jj):; B = ops[kk]; if (A * B - B * A).norm() / (A * B).norm() > tol:; raise TypeError('Matricies must commute.'). eigvals, eigvecs = la.eigh(ops[0].full()); perm = np.argsort(eigvals); eigvecs = eigvecs[:, perm]; eigvals = eigvals[perm]. k = 0; while k < N:; # find degenerate eigenvalues, get indicies of degenerate eigvals; ttol = max(tol, tol * abs(eigvals[k])); inds, = np.where(abs(eigvals - eigvals[k]) < ttol); if len(inds) > 1: # if at least 2 eigvals are degenerate; eigvecs[:, inds] = _degen(tol, eigvecs[:, inds], ops, 1); k = inds[-1] + 1. for k in range(N):; eigvecs[:, k] = eigvecs[:, k] / la.norm(eigvecs[:, k]). kets_out = [; Qobj(eigvecs[:, j],; dims=[ops[0].dims[0], [1]], shape=[ops[0].shape[0], 1]); for j in range(N); ]; eigvals_out = np.zeros((len(ops), N), dtype=np.float64); if not evals:; return kets_out; else:; for kk in range(len(ops)):; for j in range(N):; eigvals_out[kk, j] = ops[kk].matrix_element(kets_out[j],; kets_out[j]).real; return eigvals_out, kets_out. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/modules/qutip/simdiag.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/simdiag.html
https://qutip.org/docs/4.7/modules/qutip/simdiag.html:1806,Safety,detect,detecting,1806,", k]); / (1 - np.abs(dot)**2)**0.5). subspace = vecs.conj().T @ ops[i].data @ vecs; eigvals, eigvecs = la.eig(subspace). perm = np.argsort(eigvals); eigvals = eigvals[perm]. vecs_new = vecs @ eigvecs[:, perm]; for k in range(len(eigvals)):; vecs_new[:, k] = vecs_new[:, k] / la.norm(vecs_new[:, k]). k = 0; while k < len(eigvals):; ttol = max(tol, tol * abs(eigvals[k])); inds, = np.where(abs(eigvals - eigvals[k]) < ttol); if len(inds) > 1: # if at least 2 eigvals are degenerate; vecs_new[:, inds] = _degen(tol, vecs_new[:, inds], ops, i+1); k = inds[-1] + 1; return vecs_new. [docs]def simdiag(ops, evals: bool = True, *,; tol: float = 1e-14, safe_mode: bool = True):; """"""Simultaneous diagonalization of commuting Hermitian matrices. Parameters; ----------; ops : list/array; ``list`` or ``array`` of qobjs representing commuting Hermitian; operators. evals : bool [True]; Whether to return the eigenvalues for each ops and eigenvectors or just; the eigenvectors. tol : float [1e-14]; Tolerance for detecting degenerate eigenstates. safe_mode : bool [True]; Whether to check that all ops are Hermitian and commuting. If set to; ``False`` and operators are not commuting, the eigenvectors returned; will often be eigenvectors of only the first operator. Returns; --------; eigs : tuple; Tuple of arrays representing eigvecs and eigvals of quantum objects; corresponding to simultaneous eigenvectors and eigenvalues for each; operator. """"""; if not ops:; raise ValueError(""No input matrices.""); N = ops[0].shape[0]; num_ops = len(ops) if safe_mode else 0; for jj in range(num_ops):; A = ops[jj]; shape = A.shape; if shape[0] != shape[1]:; raise TypeError('Matricies must be square.'); if shape[0] != N:; raise TypeError('All matrices. must be the same shape'); if not A.isherm:; raise TypeError('Matricies must be Hermitian'); for kk in range(jj):; B = ops[kk]; if (A * B - B * A).norm() / (A * B).norm() > tol:; raise TypeError('Matricies must commute.'). eigvals, eigvecs = la.eigh(ops[0].full()); p",MatchSource.WIKI,docs/4.7/modules/qutip/simdiag.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/simdiag.html
https://qutip.org/docs/4.7/modules/qutip/solver.html:3971,Availability,toler,tolerance,3971,".e_ops_qoevo[ii](t, state). def finish(self):; if self.isfunc:; result = self.raw_out; else:; result = []; for ii in range(self.e_num):; if self.e_ops_isherm[ii]:; result.append(np.real(self.raw_out[ii, :])); else:; result.append(self.raw_out[ii, :]); if self.e_ops_dict:; result = {e: result[n]; for n, e in enumerate(self.e_ops_dict.keys())}; return result. def __eq__(self, other):; if isinstance(other, ExpectOps):; other = other.raw_e_ops; return self.raw_e_ops == other. def __ne__(self, other):; return not (self == other). def __bool__(self):; return bool(self.e_num). [docs]class Options():; """"""; Class of options for evolution solvers such as :func:`qutip.mesolve` and; :func:`qutip.mcsolve`. Options can be specified either as arguments to the; constructor::. opts = Options(order=10, ...). or by changing the class attributes after creation::. opts = Options(); opts.order = 10. Returns options class to be used as options in evolution solvers. Attributes; ----------. atol : float {1e-8}; Absolute tolerance.; rtol : float {1e-6}; Relative tolerance.; method : str {'adams','bdf'}; Integration method.; order : int {12}; Order of integrator (<=12 'adams', <=5 'bdf'); nsteps : int {2500}; Max. number of internal steps/call.; first_step : float {0}; Size of initial step (0 = automatic).; min_step : float {0}; Minimum step size (0 = automatic).; max_step : float {0}; Maximum step size (0 = automatic); tidy : bool {True,False}; Tidyup Hamiltonian and initial state by removing small terms.; num_cpus : int; Number of cpus used by mcsolver (default = # of cpus).; norm_tol : float; Tolerance used when finding wavefunction norm in mcsolve.; norm_steps : int; Max. number of steps used to find wavefunction norm to within norm_tol; in mcsolve.; average_states : bool {False}; Average states values over trajectories in stochastic solvers.; average_expect : bool {True}; Average expectation values over trajectories for stochastic solvers.; mc_corr_eps : float {1e-10}; Arbitrarily small v",MatchSource.WIKI,docs/4.7/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/solver.html
https://qutip.org/docs/4.7/modules/qutip/solver.html:4013,Availability,toler,tolerance,4013,"f):; if self.isfunc:; result = self.raw_out; else:; result = []; for ii in range(self.e_num):; if self.e_ops_isherm[ii]:; result.append(np.real(self.raw_out[ii, :])); else:; result.append(self.raw_out[ii, :]); if self.e_ops_dict:; result = {e: result[n]; for n, e in enumerate(self.e_ops_dict.keys())}; return result. def __eq__(self, other):; if isinstance(other, ExpectOps):; other = other.raw_e_ops; return self.raw_e_ops == other. def __ne__(self, other):; return not (self == other). def __bool__(self):; return bool(self.e_num). [docs]class Options():; """"""; Class of options for evolution solvers such as :func:`qutip.mesolve` and; :func:`qutip.mcsolve`. Options can be specified either as arguments to the; constructor::. opts = Options(order=10, ...). or by changing the class attributes after creation::. opts = Options(); opts.order = 10. Returns options class to be used as options in evolution solvers. Attributes; ----------. atol : float {1e-8}; Absolute tolerance.; rtol : float {1e-6}; Relative tolerance.; method : str {'adams','bdf'}; Integration method.; order : int {12}; Order of integrator (<=12 'adams', <=5 'bdf'); nsteps : int {2500}; Max. number of internal steps/call.; first_step : float {0}; Size of initial step (0 = automatic).; min_step : float {0}; Minimum step size (0 = automatic).; max_step : float {0}; Maximum step size (0 = automatic); tidy : bool {True,False}; Tidyup Hamiltonian and initial state by removing small terms.; num_cpus : int; Number of cpus used by mcsolver (default = # of cpus).; norm_tol : float; Tolerance used when finding wavefunction norm in mcsolve.; norm_steps : int; Max. number of steps used to find wavefunction norm to within norm_tol; in mcsolve.; average_states : bool {False}; Average states values over trajectories in stochastic solvers.; average_expect : bool {True}; Average expectation values over trajectories for stochastic solvers.; mc_corr_eps : float {1e-10}; Arbitrarily small value for eliminating any divide-by-zero e",MatchSource.WIKI,docs/4.7/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/solver.html
https://qutip.org/docs/4.7/modules/qutip/solver.html:5001,Availability,error,errors,5001,"rtol : float {1e-6}; Relative tolerance.; method : str {'adams','bdf'}; Integration method.; order : int {12}; Order of integrator (<=12 'adams', <=5 'bdf'); nsteps : int {2500}; Max. number of internal steps/call.; first_step : float {0}; Size of initial step (0 = automatic).; min_step : float {0}; Minimum step size (0 = automatic).; max_step : float {0}; Maximum step size (0 = automatic); tidy : bool {True,False}; Tidyup Hamiltonian and initial state by removing small terms.; num_cpus : int; Number of cpus used by mcsolver (default = # of cpus).; norm_tol : float; Tolerance used when finding wavefunction norm in mcsolve.; norm_steps : int; Max. number of steps used to find wavefunction norm to within norm_tol; in mcsolve.; average_states : bool {False}; Average states values over trajectories in stochastic solvers.; average_expect : bool {True}; Average expectation values over trajectories for stochastic solvers.; mc_corr_eps : float {1e-10}; Arbitrarily small value for eliminating any divide-by-zero errors in; correlation calculations when using mcsolve.; ntraj : int {500}; Number of trajectories in stochastic solvers.; openmp_threads : int; Number of OPENMP threads to use. Default is number of cpu cores.; rhs_reuse : bool {False,True}; Reuse Hamiltonian data.; rhs_with_state : bool {False,True}; Whether or not to include the state in the Hamiltonian function; callback signature.; rhs_filename : str; Name for compiled Cython file.; seeds : ndarray; Array containing random number seeds for mcsolver.; store_final_state : bool {False, True}; Whether or not to store the final state of the evolution in the; result class.; store_states : bool {False, True}; Whether or not to store the state vectors or density matrices in the; result class, even if expectation values operators are given. If no; expectation are provided, then states are stored by default and this; option has no effect.; use_openmp : bool {True, False}; Use OPENMP for sparse matrix vector multiplication. D",MatchSource.WIKI,docs/4.7/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/solver.html
https://qutip.org/docs/4.7/modules/qutip/solver.html:6497,Availability,toler,tolerance,6497,"th_state : bool {False,True}; Whether or not to include the state in the Hamiltonian function; callback signature.; rhs_filename : str; Name for compiled Cython file.; seeds : ndarray; Array containing random number seeds for mcsolver.; store_final_state : bool {False, True}; Whether or not to store the final state of the evolution in the; result class.; store_states : bool {False, True}; Whether or not to store the state vectors or density matrices in the; result class, even if expectation values operators are given. If no; expectation are provided, then states are stored by default and this; option has no effect.; use_openmp : bool {True, False}; Use OPENMP for sparse matrix vector multiplication. Default; None means auto check. """""". def __init__(self, atol=1e-8, rtol=1e-6, method='adams', order=12,; nsteps=1000, first_step=0, max_step=0, min_step=0,; average_expect=True, average_states=False, tidy=True,; num_cpus=0, norm_tol=1e-3, norm_t_tol=1e-6, norm_steps=5,; rhs_reuse=False, rhs_filename=None, ntraj=500, gui=False,; rhs_with_state=False, store_final_state=False,; store_states=False, steady_state_average=False,; seeds=None,; normalize_output=True, use_openmp=None, openmp_threads=None):; # Absolute tolerance (default = 1e-8); self.atol = atol; # Relative tolerance (default = 1e-6); self.rtol = rtol; # Integration method (default = 'adams', for stiff 'bdf'); self.method = method; # Max. number of internal steps/call; self.nsteps = nsteps; # Size of initial step (0 = determined by solver); self.first_step = first_step; # Minimal step size (0 = determined by solver); self.min_step = min_step; # Max step size (0 = determined by solver); self.max_step = max_step; # Maximum order used by integrator (<=12 for 'adams', <=5 for 'bdf'); self.order = order; # Average expectation values over trajectories (default = True); self.average_states = average_states; # average expectation values; self.average_expect = average_expect; # Number of trajectories (default = 500); self.n",MatchSource.WIKI,docs/4.7/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/solver.html
https://qutip.org/docs/4.7/modules/qutip/solver.html:6554,Availability,toler,tolerance,6554," or not to store the final state of the evolution in the; result class.; store_states : bool {False, True}; Whether or not to store the state vectors or density matrices in the; result class, even if expectation values operators are given. If no; expectation are provided, then states are stored by default and this; option has no effect.; use_openmp : bool {True, False}; Use OPENMP for sparse matrix vector multiplication. Default; None means auto check. """""". def __init__(self, atol=1e-8, rtol=1e-6, method='adams', order=12,; nsteps=1000, first_step=0, max_step=0, min_step=0,; average_expect=True, average_states=False, tidy=True,; num_cpus=0, norm_tol=1e-3, norm_t_tol=1e-6, norm_steps=5,; rhs_reuse=False, rhs_filename=None, ntraj=500, gui=False,; rhs_with_state=False, store_final_state=False,; store_states=False, steady_state_average=False,; seeds=None,; normalize_output=True, use_openmp=None, openmp_threads=None):; # Absolute tolerance (default = 1e-8); self.atol = atol; # Relative tolerance (default = 1e-6); self.rtol = rtol; # Integration method (default = 'adams', for stiff 'bdf'); self.method = method; # Max. number of internal steps/call; self.nsteps = nsteps; # Size of initial step (0 = determined by solver); self.first_step = first_step; # Minimal step size (0 = determined by solver); self.min_step = min_step; # Max step size (0 = determined by solver); self.max_step = max_step; # Maximum order used by integrator (<=12 for 'adams', <=5 for 'bdf'); self.order = order; # Average expectation values over trajectories (default = True); self.average_states = average_states; # average expectation values; self.average_expect = average_expect; # Number of trajectories (default = 500); self.ntraj = ntraj; # Holds seeds for rand num gen; self.seeds = seeds; # tidyup Hamiltonian before calculation (default = True); self.tidy = tidy; # include the state in the function callback signature; self.rhs_with_state = rhs_with_state; # Use preexisting RHS function for time-dependen",MatchSource.WIKI,docs/4.7/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/solver.html
https://qutip.org/docs/4.7/modules/qutip/solver.html:12520,Availability,toler,tolerance,12520,"pect) > 0:; s += ""expect = True\nnum_expect = "" + str(self.num_expect) + "", ""; else:; s += ""states = True, expect = True\n"" + \; ""num_expect = "" + str(self.num_expect) + "", ""; s += ""num_collapse = "" + str(self.num_collapse); if self.solver == 'mcsolve':; s += "", ntraj = "" + str(self.ntraj); return s. def __repr__(self):; return self.__str__(). def __getstate__(self):; # defines what happens when Qobj object gets pickled; self.__dict__.update({'qutip_version': __version__[:5]}); return self.__dict__. def __setstate__(self, state):; # defines what happens when loading a pickled Qobj; if 'qutip_version' in state.keys():; del state['qutip_version']; (self.__dict__).update(state). # %%%%%%%%%%% remove ?; [docs]class SolverConfiguration():; def __init__(self):. self.cgen_num = 0. self.reset(). def reset(self):; # General stuff; self.tlist = None # evaluations times; self.ntraj = None # number / list of trajectories; self.options = None # options for solvers; self.norm_tol = None # tolerance for wavefunction norm; self.norm_steps = None # max. number of steps to take in finding; # Initial state stuff; self.psi0 = None # initial state; self.psi0_dims = None # initial state dims; self.psi0_shape = None # initial state shape. # flags for setting time-dependence, collapse ops, and number of times; # codegen has been run; self.cflag = 0 # Flag signaling collapse operators; self.tflag = 0 # Flag signaling time-dependent problem. self.soft_reset(). def soft_reset(self):; # Hamiltonian stuff; self.h_td_inds = [] # indicies of time-dependent Hamiltonian operators; self.h_tdterms = [] # List of td strs and funcs; self.h_data = None # List of sparse matrix data; self.h_ind = None # List of sparse matrix indices; self.h_ptr = None # List of sparse matrix ptrs. # Expectation operator stuff; self.e_num = 0 # number of expect ops; self.e_ops_data = [] # expect op data; self.e_ops_ind = [] # expect op indices; self.e_ops_ptr = [] # expect op indptrs; self.e_ops_isherm = [] # expect op ish",MatchSource.WIKI,docs/4.7/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/solver.html
https://qutip.org/docs/4.7/modules/qutip/solver.html:4103,Deployability,integrat,integrator,4103,"]:; result.append(np.real(self.raw_out[ii, :])); else:; result.append(self.raw_out[ii, :]); if self.e_ops_dict:; result = {e: result[n]; for n, e in enumerate(self.e_ops_dict.keys())}; return result. def __eq__(self, other):; if isinstance(other, ExpectOps):; other = other.raw_e_ops; return self.raw_e_ops == other. def __ne__(self, other):; return not (self == other). def __bool__(self):; return bool(self.e_num). [docs]class Options():; """"""; Class of options for evolution solvers such as :func:`qutip.mesolve` and; :func:`qutip.mcsolve`. Options can be specified either as arguments to the; constructor::. opts = Options(order=10, ...). or by changing the class attributes after creation::. opts = Options(); opts.order = 10. Returns options class to be used as options in evolution solvers. Attributes; ----------. atol : float {1e-8}; Absolute tolerance.; rtol : float {1e-6}; Relative tolerance.; method : str {'adams','bdf'}; Integration method.; order : int {12}; Order of integrator (<=12 'adams', <=5 'bdf'); nsteps : int {2500}; Max. number of internal steps/call.; first_step : float {0}; Size of initial step (0 = automatic).; min_step : float {0}; Minimum step size (0 = automatic).; max_step : float {0}; Maximum step size (0 = automatic); tidy : bool {True,False}; Tidyup Hamiltonian and initial state by removing small terms.; num_cpus : int; Number of cpus used by mcsolver (default = # of cpus).; norm_tol : float; Tolerance used when finding wavefunction norm in mcsolve.; norm_steps : int; Max. number of steps used to find wavefunction norm to within norm_tol; in mcsolve.; average_states : bool {False}; Average states values over trajectories in stochastic solvers.; average_expect : bool {True}; Average expectation values over trajectories for stochastic solvers.; mc_corr_eps : float {1e-10}; Arbitrarily small value for eliminating any divide-by-zero errors in; correlation calculations when using mcsolve.; ntraj : int {500}; Number of trajectories in stochastic solver",MatchSource.WIKI,docs/4.7/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/solver.html
https://qutip.org/docs/4.7/modules/qutip/solver.html:6990,Deployability,integrat,integrator,6990,"one means auto check. """""". def __init__(self, atol=1e-8, rtol=1e-6, method='adams', order=12,; nsteps=1000, first_step=0, max_step=0, min_step=0,; average_expect=True, average_states=False, tidy=True,; num_cpus=0, norm_tol=1e-3, norm_t_tol=1e-6, norm_steps=5,; rhs_reuse=False, rhs_filename=None, ntraj=500, gui=False,; rhs_with_state=False, store_final_state=False,; store_states=False, steady_state_average=False,; seeds=None,; normalize_output=True, use_openmp=None, openmp_threads=None):; # Absolute tolerance (default = 1e-8); self.atol = atol; # Relative tolerance (default = 1e-6); self.rtol = rtol; # Integration method (default = 'adams', for stiff 'bdf'); self.method = method; # Max. number of internal steps/call; self.nsteps = nsteps; # Size of initial step (0 = determined by solver); self.first_step = first_step; # Minimal step size (0 = determined by solver); self.min_step = min_step; # Max step size (0 = determined by solver); self.max_step = max_step; # Maximum order used by integrator (<=12 for 'adams', <=5 for 'bdf'); self.order = order; # Average expectation values over trajectories (default = True); self.average_states = average_states; # average expectation values; self.average_expect = average_expect; # Number of trajectories (default = 500); self.ntraj = ntraj; # Holds seeds for rand num gen; self.seeds = seeds; # tidyup Hamiltonian before calculation (default = True); self.tidy = tidy; # include the state in the function callback signature; self.rhs_with_state = rhs_with_state; # Use preexisting RHS function for time-dependent solvers; self.rhs_reuse = rhs_reuse; # Use filename for preexisting RHS function (will default to last; # compiled function if None & rhs_exists=True); self.rhs_filename = rhs_filename; # small value in mc solver for computing correlations; self.mc_corr_eps = 1e-10; # Number of processors to use (mcsolve only); if num_cpus:; self.num_cpus = num_cpus; else:; self.num_cpus = qset.num_cpus; # Tolerance for wavefunction norm (mcsolv",MatchSource.WIKI,docs/4.7/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/solver.html
https://qutip.org/docs/4.7/modules/qutip/solver.html:11969,Deployability,update,update,11969,"ver. """"""; def __init__(self):; self.solver = None; self.times = None; self.states = []; self.expect = []; self.num_expect = 0; self.num_collapse = 0; self.ntraj = None; self.seeds = None; self.col_times = None; self.col_which = None. def __str__(self):; s = ""Result object ""; if self.solver:; s += ""with "" + self.solver + "" data.\n""; else:; s += ""missing solver information.\n""; s += ""-"" * (len(s) - 1) + ""\n""; if self.states is not None and len(self.states) > 0:; s += ""states = True\n""; elif self.expect is not None and len(self.expect) > 0:; s += ""expect = True\nnum_expect = "" + str(self.num_expect) + "", ""; else:; s += ""states = True, expect = True\n"" + \; ""num_expect = "" + str(self.num_expect) + "", ""; s += ""num_collapse = "" + str(self.num_collapse); if self.solver == 'mcsolve':; s += "", ntraj = "" + str(self.ntraj); return s. def __repr__(self):; return self.__str__(). def __getstate__(self):; # defines what happens when Qobj object gets pickled; self.__dict__.update({'qutip_version': __version__[:5]}); return self.__dict__. def __setstate__(self, state):; # defines what happens when loading a pickled Qobj; if 'qutip_version' in state.keys():; del state['qutip_version']; (self.__dict__).update(state). # %%%%%%%%%%% remove ?; [docs]class SolverConfiguration():; def __init__(self):. self.cgen_num = 0. self.reset(). def reset(self):; # General stuff; self.tlist = None # evaluations times; self.ntraj = None # number / list of trajectories; self.options = None # options for solvers; self.norm_tol = None # tolerance for wavefunction norm; self.norm_steps = None # max. number of steps to take in finding; # Initial state stuff; self.psi0 = None # initial state; self.psi0_dims = None # initial state dims; self.psi0_shape = None # initial state shape. # flags for setting time-dependence, collapse ops, and number of times; # codegen has been run; self.cflag = 0 # Flag signaling collapse operators; self.tflag = 0 # Flag signaling time-dependent problem. self.soft_reset(). def soft",MatchSource.WIKI,docs/4.7/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/solver.html
https://qutip.org/docs/4.7/modules/qutip/solver.html:12200,Deployability,update,update,12200," self.col_which = None. def __str__(self):; s = ""Result object ""; if self.solver:; s += ""with "" + self.solver + "" data.\n""; else:; s += ""missing solver information.\n""; s += ""-"" * (len(s) - 1) + ""\n""; if self.states is not None and len(self.states) > 0:; s += ""states = True\n""; elif self.expect is not None and len(self.expect) > 0:; s += ""expect = True\nnum_expect = "" + str(self.num_expect) + "", ""; else:; s += ""states = True, expect = True\n"" + \; ""num_expect = "" + str(self.num_expect) + "", ""; s += ""num_collapse = "" + str(self.num_collapse); if self.solver == 'mcsolve':; s += "", ntraj = "" + str(self.ntraj); return s. def __repr__(self):; return self.__str__(). def __getstate__(self):; # defines what happens when Qobj object gets pickled; self.__dict__.update({'qutip_version': __version__[:5]}); return self.__dict__. def __setstate__(self, state):; # defines what happens when loading a pickled Qobj; if 'qutip_version' in state.keys():; del state['qutip_version']; (self.__dict__).update(state). # %%%%%%%%%%% remove ?; [docs]class SolverConfiguration():; def __init__(self):. self.cgen_num = 0. self.reset(). def reset(self):; # General stuff; self.tlist = None # evaluations times; self.ntraj = None # number / list of trajectories; self.options = None # options for solvers; self.norm_tol = None # tolerance for wavefunction norm; self.norm_steps = None # max. number of steps to take in finding; # Initial state stuff; self.psi0 = None # initial state; self.psi0_dims = None # initial state dims; self.psi0_shape = None # initial state shape. # flags for setting time-dependence, collapse ops, and number of times; # codegen has been run; self.cflag = 0 # Flag signaling collapse operators; self.tflag = 0 # Flag signaling time-dependent problem. self.soft_reset(). def soft_reset(self):; # Hamiltonian stuff; self.h_td_inds = [] # indicies of time-dependent Hamiltonian operators; self.h_tdterms = [] # List of td strs and funcs; self.h_data = None # List of sparse matrix data; self",MatchSource.WIKI,docs/4.7/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/solver.html
https://qutip.org/docs/4.7/modules/qutip/solver.html:28343,Deployability,update,updated,28343,"stance(c_ops[ii], list):; if isinstance(c_ops[ii][0], Qobj):; _temp_state = c_ops[ii][0]; elif isinstance(c_ops[ii][0], tuple):; do_tests = False; for kk in range(len(c_ops[ii][0])):; _temp_state = c_ops[ii][0][kk]; _structure_check(Hdims, Htype, _temp_state); else:; raise Exception('Invalid td-list element.'); if do_tests:; _structure_check(Hdims, Htype, _temp_state). if isinstance(e_ops, list):; for ii in range(len(e_ops)):; if isinstance(e_ops[ii], Qobj):; _temp_state = e_ops[ii]; elif isinstance(e_ops[ii], list):; _temp_state = e_ops[ii][0]; else:; raise Exception('Invalid td-list element.'); _structure_check(Hdims,Htype,_temp_state); elif isinstance(e_ops, FunctionType):; pass; else:; raise Exception('Invalid e_ops specification.'). def _structure_check(Hdims, Htype, state):; if state is not None:; # Input state is a ket vector; if state.type == 'ket':; # Input is Hamiltonian; if Htype == 'oper':; if Hdims[1] != state.dims[0]:; raise Exception('Input operator and ket do not '; 'share same structure.'); # Input is super and state is ket; elif Htype == 'super':; if Hdims[1][1] != state.dims[0]:; raise Exception('Input operator and ket do not '; 'share same structure.'); else:; raise Exception('Invalid input operator.'); # Input state is a density matrix; elif state.type == 'oper':; # Input is Hamiltonian and state is density matrix; if Htype == 'oper':; if Hdims[1] != state.dims[0]:; raise Exception('Input operators do not '; 'share same structure.'); # Input is super op. and state is density matrix; elif Htype == 'super':; if Hdims[1] != state.dims:; raise Exception('Input operators do not '; 'share same structure.'). #; # create a global instance of the SolverConfiguration class; #; config = SolverConfiguration(). # for backwards compatibility; Odeoptions = Options; Odedata = Result. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/solver.html
https://qutip.org/docs/4.7/modules/qutip/solver.html:4103,Integrability,integrat,integrator,4103,"]:; result.append(np.real(self.raw_out[ii, :])); else:; result.append(self.raw_out[ii, :]); if self.e_ops_dict:; result = {e: result[n]; for n, e in enumerate(self.e_ops_dict.keys())}; return result. def __eq__(self, other):; if isinstance(other, ExpectOps):; other = other.raw_e_ops; return self.raw_e_ops == other. def __ne__(self, other):; return not (self == other). def __bool__(self):; return bool(self.e_num). [docs]class Options():; """"""; Class of options for evolution solvers such as :func:`qutip.mesolve` and; :func:`qutip.mcsolve`. Options can be specified either as arguments to the; constructor::. opts = Options(order=10, ...). or by changing the class attributes after creation::. opts = Options(); opts.order = 10. Returns options class to be used as options in evolution solvers. Attributes; ----------. atol : float {1e-8}; Absolute tolerance.; rtol : float {1e-6}; Relative tolerance.; method : str {'adams','bdf'}; Integration method.; order : int {12}; Order of integrator (<=12 'adams', <=5 'bdf'); nsteps : int {2500}; Max. number of internal steps/call.; first_step : float {0}; Size of initial step (0 = automatic).; min_step : float {0}; Minimum step size (0 = automatic).; max_step : float {0}; Maximum step size (0 = automatic); tidy : bool {True,False}; Tidyup Hamiltonian and initial state by removing small terms.; num_cpus : int; Number of cpus used by mcsolver (default = # of cpus).; norm_tol : float; Tolerance used when finding wavefunction norm in mcsolve.; norm_steps : int; Max. number of steps used to find wavefunction norm to within norm_tol; in mcsolve.; average_states : bool {False}; Average states values over trajectories in stochastic solvers.; average_expect : bool {True}; Average expectation values over trajectories for stochastic solvers.; mc_corr_eps : float {1e-10}; Arbitrarily small value for eliminating any divide-by-zero errors in; correlation calculations when using mcsolve.; ntraj : int {500}; Number of trajectories in stochastic solver",MatchSource.WIKI,docs/4.7/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/solver.html
https://qutip.org/docs/4.7/modules/qutip/solver.html:6990,Integrability,integrat,integrator,6990,"one means auto check. """""". def __init__(self, atol=1e-8, rtol=1e-6, method='adams', order=12,; nsteps=1000, first_step=0, max_step=0, min_step=0,; average_expect=True, average_states=False, tidy=True,; num_cpus=0, norm_tol=1e-3, norm_t_tol=1e-6, norm_steps=5,; rhs_reuse=False, rhs_filename=None, ntraj=500, gui=False,; rhs_with_state=False, store_final_state=False,; store_states=False, steady_state_average=False,; seeds=None,; normalize_output=True, use_openmp=None, openmp_threads=None):; # Absolute tolerance (default = 1e-8); self.atol = atol; # Relative tolerance (default = 1e-6); self.rtol = rtol; # Integration method (default = 'adams', for stiff 'bdf'); self.method = method; # Max. number of internal steps/call; self.nsteps = nsteps; # Size of initial step (0 = determined by solver); self.first_step = first_step; # Minimal step size (0 = determined by solver); self.min_step = min_step; # Max step size (0 = determined by solver); self.max_step = max_step; # Maximum order used by integrator (<=12 for 'adams', <=5 for 'bdf'); self.order = order; # Average expectation values over trajectories (default = True); self.average_states = average_states; # average expectation values; self.average_expect = average_expect; # Number of trajectories (default = 500); self.ntraj = ntraj; # Holds seeds for rand num gen; self.seeds = seeds; # tidyup Hamiltonian before calculation (default = True); self.tidy = tidy; # include the state in the function callback signature; self.rhs_with_state = rhs_with_state; # Use preexisting RHS function for time-dependent solvers; self.rhs_reuse = rhs_reuse; # Use filename for preexisting RHS function (will default to last; # compiled function if None & rhs_exists=True); self.rhs_filename = rhs_filename; # small value in mc solver for computing correlations; self.mc_corr_eps = 1e-10; # Number of processors to use (mcsolve only); if num_cpus:; self.num_cpus = num_cpus; else:; self.num_cpus = qset.num_cpus; # Tolerance for wavefunction norm (mcsolv",MatchSource.WIKI,docs/4.7/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/solver.html
https://qutip.org/docs/4.7/modules/qutip/solver.html:7551,Integrability,depend,dependent,7551,"elf.atol = atol; # Relative tolerance (default = 1e-6); self.rtol = rtol; # Integration method (default = 'adams', for stiff 'bdf'); self.method = method; # Max. number of internal steps/call; self.nsteps = nsteps; # Size of initial step (0 = determined by solver); self.first_step = first_step; # Minimal step size (0 = determined by solver); self.min_step = min_step; # Max step size (0 = determined by solver); self.max_step = max_step; # Maximum order used by integrator (<=12 for 'adams', <=5 for 'bdf'); self.order = order; # Average expectation values over trajectories (default = True); self.average_states = average_states; # average expectation values; self.average_expect = average_expect; # Number of trajectories (default = 500); self.ntraj = ntraj; # Holds seeds for rand num gen; self.seeds = seeds; # tidyup Hamiltonian before calculation (default = True); self.tidy = tidy; # include the state in the function callback signature; self.rhs_with_state = rhs_with_state; # Use preexisting RHS function for time-dependent solvers; self.rhs_reuse = rhs_reuse; # Use filename for preexisting RHS function (will default to last; # compiled function if None & rhs_exists=True); self.rhs_filename = rhs_filename; # small value in mc solver for computing correlations; self.mc_corr_eps = 1e-10; # Number of processors to use (mcsolve only); if num_cpus:; self.num_cpus = num_cpus; else:; self.num_cpus = qset.num_cpus; # Tolerance for wavefunction norm (mcsolve only); self.norm_tol = norm_tol; # Tolerance for collapse time precision (mcsolve only); self.norm_t_tol = norm_t_tol; # Max. number of steps taken to find wavefunction norm to within; # norm_tol (mcsolve only); self.norm_steps = norm_steps; # Number of threads for openmp; if openmp_threads is None:; self.openmp_threads = qset.num_cpus; else:; self.openmp_threads = openmp_threads; # store final state?; self.store_final_state = store_final_state; # store states even if expectation operators are given?; self.store_states = store",MatchSource.WIKI,docs/4.7/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/solver.html
https://qutip.org/docs/4.7/modules/qutip/solver.html:12791,Integrability,depend,dependence,12791,"raj); return s. def __repr__(self):; return self.__str__(). def __getstate__(self):; # defines what happens when Qobj object gets pickled; self.__dict__.update({'qutip_version': __version__[:5]}); return self.__dict__. def __setstate__(self, state):; # defines what happens when loading a pickled Qobj; if 'qutip_version' in state.keys():; del state['qutip_version']; (self.__dict__).update(state). # %%%%%%%%%%% remove ?; [docs]class SolverConfiguration():; def __init__(self):. self.cgen_num = 0. self.reset(). def reset(self):; # General stuff; self.tlist = None # evaluations times; self.ntraj = None # number / list of trajectories; self.options = None # options for solvers; self.norm_tol = None # tolerance for wavefunction norm; self.norm_steps = None # max. number of steps to take in finding; # Initial state stuff; self.psi0 = None # initial state; self.psi0_dims = None # initial state dims; self.psi0_shape = None # initial state shape. # flags for setting time-dependence, collapse ops, and number of times; # codegen has been run; self.cflag = 0 # Flag signaling collapse operators; self.tflag = 0 # Flag signaling time-dependent problem. self.soft_reset(). def soft_reset(self):; # Hamiltonian stuff; self.h_td_inds = [] # indicies of time-dependent Hamiltonian operators; self.h_tdterms = [] # List of td strs and funcs; self.h_data = None # List of sparse matrix data; self.h_ind = None # List of sparse matrix indices; self.h_ptr = None # List of sparse matrix ptrs. # Expectation operator stuff; self.e_num = 0 # number of expect ops; self.e_ops_data = [] # expect op data; self.e_ops_ind = [] # expect op indices; self.e_ops_ptr = [] # expect op indptrs; self.e_ops_isherm = [] # expect op isherm. # Collapse operator stuff; self.c_num = 0 # number of collapse ops; self.c_const_inds = [] # indicies of constant collapse operators; self.c_td_inds = [] # indicies of time-dependent collapse operators; self.c_ops_data = [] # collapse op data; self.c_ops_ind = [] # collapse op ind",MatchSource.WIKI,docs/4.7/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/solver.html
https://qutip.org/docs/4.7/modules/qutip/solver.html:12951,Integrability,depend,dependent,12951,"s pickled; self.__dict__.update({'qutip_version': __version__[:5]}); return self.__dict__. def __setstate__(self, state):; # defines what happens when loading a pickled Qobj; if 'qutip_version' in state.keys():; del state['qutip_version']; (self.__dict__).update(state). # %%%%%%%%%%% remove ?; [docs]class SolverConfiguration():; def __init__(self):. self.cgen_num = 0. self.reset(). def reset(self):; # General stuff; self.tlist = None # evaluations times; self.ntraj = None # number / list of trajectories; self.options = None # options for solvers; self.norm_tol = None # tolerance for wavefunction norm; self.norm_steps = None # max. number of steps to take in finding; # Initial state stuff; self.psi0 = None # initial state; self.psi0_dims = None # initial state dims; self.psi0_shape = None # initial state shape. # flags for setting time-dependence, collapse ops, and number of times; # codegen has been run; self.cflag = 0 # Flag signaling collapse operators; self.tflag = 0 # Flag signaling time-dependent problem. self.soft_reset(). def soft_reset(self):; # Hamiltonian stuff; self.h_td_inds = [] # indicies of time-dependent Hamiltonian operators; self.h_tdterms = [] # List of td strs and funcs; self.h_data = None # List of sparse matrix data; self.h_ind = None # List of sparse matrix indices; self.h_ptr = None # List of sparse matrix ptrs. # Expectation operator stuff; self.e_num = 0 # number of expect ops; self.e_ops_data = [] # expect op data; self.e_ops_ind = [] # expect op indices; self.e_ops_ptr = [] # expect op indptrs; self.e_ops_isherm = [] # expect op isherm. # Collapse operator stuff; self.c_num = 0 # number of collapse ops; self.c_const_inds = [] # indicies of constant collapse operators; self.c_td_inds = [] # indicies of time-dependent collapse operators; self.c_ops_data = [] # collapse op data; self.c_ops_ind = [] # collapse op indices; self.c_ops_ptr = [] # collapse op indptrs; self.c_args = [] # store args for time-dependent collapse func. # Norm collapse",MatchSource.WIKI,docs/4.7/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/solver.html
https://qutip.org/docs/4.7/modules/qutip/solver.html:13072,Integrability,depend,dependent,13072,"es what happens when loading a pickled Qobj; if 'qutip_version' in state.keys():; del state['qutip_version']; (self.__dict__).update(state). # %%%%%%%%%%% remove ?; [docs]class SolverConfiguration():; def __init__(self):. self.cgen_num = 0. self.reset(). def reset(self):; # General stuff; self.tlist = None # evaluations times; self.ntraj = None # number / list of trajectories; self.options = None # options for solvers; self.norm_tol = None # tolerance for wavefunction norm; self.norm_steps = None # max. number of steps to take in finding; # Initial state stuff; self.psi0 = None # initial state; self.psi0_dims = None # initial state dims; self.psi0_shape = None # initial state shape. # flags for setting time-dependence, collapse ops, and number of times; # codegen has been run; self.cflag = 0 # Flag signaling collapse operators; self.tflag = 0 # Flag signaling time-dependent problem. self.soft_reset(). def soft_reset(self):; # Hamiltonian stuff; self.h_td_inds = [] # indicies of time-dependent Hamiltonian operators; self.h_tdterms = [] # List of td strs and funcs; self.h_data = None # List of sparse matrix data; self.h_ind = None # List of sparse matrix indices; self.h_ptr = None # List of sparse matrix ptrs. # Expectation operator stuff; self.e_num = 0 # number of expect ops; self.e_ops_data = [] # expect op data; self.e_ops_ind = [] # expect op indices; self.e_ops_ptr = [] # expect op indptrs; self.e_ops_isherm = [] # expect op isherm. # Collapse operator stuff; self.c_num = 0 # number of collapse ops; self.c_const_inds = [] # indicies of constant collapse operators; self.c_td_inds = [] # indicies of time-dependent collapse operators; self.c_ops_data = [] # collapse op data; self.c_ops_ind = [] # collapse op indices; self.c_ops_ptr = [] # collapse op indptrs; self.c_args = [] # store args for time-dependent collapse func. # Norm collapse operator stuff; self.n_ops_data = [] # norm collapse op data; self.n_ops_ind = [] # norm collapse op indices; self.n_ops_ptr = []",MatchSource.WIKI,docs/4.7/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/solver.html
https://qutip.org/docs/4.7/modules/qutip/solver.html:13708,Integrability,depend,dependent,13708,"state dims; self.psi0_shape = None # initial state shape. # flags for setting time-dependence, collapse ops, and number of times; # codegen has been run; self.cflag = 0 # Flag signaling collapse operators; self.tflag = 0 # Flag signaling time-dependent problem. self.soft_reset(). def soft_reset(self):; # Hamiltonian stuff; self.h_td_inds = [] # indicies of time-dependent Hamiltonian operators; self.h_tdterms = [] # List of td strs and funcs; self.h_data = None # List of sparse matrix data; self.h_ind = None # List of sparse matrix indices; self.h_ptr = None # List of sparse matrix ptrs. # Expectation operator stuff; self.e_num = 0 # number of expect ops; self.e_ops_data = [] # expect op data; self.e_ops_ind = [] # expect op indices; self.e_ops_ptr = [] # expect op indptrs; self.e_ops_isherm = [] # expect op isherm. # Collapse operator stuff; self.c_num = 0 # number of collapse ops; self.c_const_inds = [] # indicies of constant collapse operators; self.c_td_inds = [] # indicies of time-dependent collapse operators; self.c_ops_data = [] # collapse op data; self.c_ops_ind = [] # collapse op indices; self.c_ops_ptr = [] # collapse op indptrs; self.c_args = [] # store args for time-dependent collapse func. # Norm collapse operator stuff; self.n_ops_data = [] # norm collapse op data; self.n_ops_ind = [] # norm collapse op indices; self.n_ops_ptr = [] # norm collapse op indptrs. # holds executable strings for time-dependent collapse evaluation; self.col_expect_code = None; self.col_spmv_code = None. # hold stuff for function list based time dependence; self.h_td_inds = []; self.h_td_data = []; self.h_td_ind = []; self.h_td_ptr = []; self.h_funcs = None; self.h_func_args = None; self.c_funcs = None; self.c_func_args = None. # time-dependent (TD) function stuff; self.tdfunc = None # Placeholder for TD RHS function.; self.tdname = None # Name of td .pyx file; self.colspmv = None # Placeholder for TD col-spmv function.; self.colexpect = None # Placeholder for TD col_expect func",MatchSource.WIKI,docs/4.7/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/solver.html
https://qutip.org/docs/4.7/modules/qutip/solver.html:13904,Integrability,depend,dependent,13904,"pse operators; self.tflag = 0 # Flag signaling time-dependent problem. self.soft_reset(). def soft_reset(self):; # Hamiltonian stuff; self.h_td_inds = [] # indicies of time-dependent Hamiltonian operators; self.h_tdterms = [] # List of td strs and funcs; self.h_data = None # List of sparse matrix data; self.h_ind = None # List of sparse matrix indices; self.h_ptr = None # List of sparse matrix ptrs. # Expectation operator stuff; self.e_num = 0 # number of expect ops; self.e_ops_data = [] # expect op data; self.e_ops_ind = [] # expect op indices; self.e_ops_ptr = [] # expect op indptrs; self.e_ops_isherm = [] # expect op isherm. # Collapse operator stuff; self.c_num = 0 # number of collapse ops; self.c_const_inds = [] # indicies of constant collapse operators; self.c_td_inds = [] # indicies of time-dependent collapse operators; self.c_ops_data = [] # collapse op data; self.c_ops_ind = [] # collapse op indices; self.c_ops_ptr = [] # collapse op indptrs; self.c_args = [] # store args for time-dependent collapse func. # Norm collapse operator stuff; self.n_ops_data = [] # norm collapse op data; self.n_ops_ind = [] # norm collapse op indices; self.n_ops_ptr = [] # norm collapse op indptrs. # holds executable strings for time-dependent collapse evaluation; self.col_expect_code = None; self.col_spmv_code = None. # hold stuff for function list based time dependence; self.h_td_inds = []; self.h_td_data = []; self.h_td_ind = []; self.h_td_ptr = []; self.h_funcs = None; self.h_func_args = None; self.c_funcs = None; self.c_func_args = None. # time-dependent (TD) function stuff; self.tdfunc = None # Placeholder for TD RHS function.; self.tdname = None # Name of td .pyx file; self.colspmv = None # Placeholder for TD col-spmv function.; self.colexpect = None # Placeholder for TD col_expect function.; self.string = None # Holds string of variables passed to td solver. def _format_time(t, tt=None, ttt=None):; time_str = str(datetime.timedelta(seconds=t)); if tt is not None and ttt i",MatchSource.WIKI,docs/4.7/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/solver.html
https://qutip.org/docs/4.7/modules/qutip/solver.html:14139,Integrability,depend,dependent,14139,"strs and funcs; self.h_data = None # List of sparse matrix data; self.h_ind = None # List of sparse matrix indices; self.h_ptr = None # List of sparse matrix ptrs. # Expectation operator stuff; self.e_num = 0 # number of expect ops; self.e_ops_data = [] # expect op data; self.e_ops_ind = [] # expect op indices; self.e_ops_ptr = [] # expect op indptrs; self.e_ops_isherm = [] # expect op isherm. # Collapse operator stuff; self.c_num = 0 # number of collapse ops; self.c_const_inds = [] # indicies of constant collapse operators; self.c_td_inds = [] # indicies of time-dependent collapse operators; self.c_ops_data = [] # collapse op data; self.c_ops_ind = [] # collapse op indices; self.c_ops_ptr = [] # collapse op indptrs; self.c_args = [] # store args for time-dependent collapse func. # Norm collapse operator stuff; self.n_ops_data = [] # norm collapse op data; self.n_ops_ind = [] # norm collapse op indices; self.n_ops_ptr = [] # norm collapse op indptrs. # holds executable strings for time-dependent collapse evaluation; self.col_expect_code = None; self.col_spmv_code = None. # hold stuff for function list based time dependence; self.h_td_inds = []; self.h_td_data = []; self.h_td_ind = []; self.h_td_ptr = []; self.h_funcs = None; self.h_func_args = None; self.c_funcs = None; self.c_func_args = None. # time-dependent (TD) function stuff; self.tdfunc = None # Placeholder for TD RHS function.; self.tdname = None # Name of td .pyx file; self.colspmv = None # Placeholder for TD col-spmv function.; self.colexpect = None # Placeholder for TD col_expect function.; self.string = None # Holds string of variables passed to td solver. def _format_time(t, tt=None, ttt=None):; time_str = str(datetime.timedelta(seconds=t)); if tt is not None and ttt is not None:; sect_percent = 100*t/tt; solve_percent = 100*t/ttt; time_str += "" ({:03.2f}% section, {:03.2f}% total)"".format(; sect_percent, solve_percent); elif tt is not None:; sect_percent = 100*t/tt; time_str += "" ({:03.2f}% section)"".fo",MatchSource.WIKI,docs/4.7/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/solver.html
https://qutip.org/docs/4.7/modules/qutip/solver.html:14268,Integrability,depend,dependence,14268,"elf.h_ptr = None # List of sparse matrix ptrs. # Expectation operator stuff; self.e_num = 0 # number of expect ops; self.e_ops_data = [] # expect op data; self.e_ops_ind = [] # expect op indices; self.e_ops_ptr = [] # expect op indptrs; self.e_ops_isherm = [] # expect op isherm. # Collapse operator stuff; self.c_num = 0 # number of collapse ops; self.c_const_inds = [] # indicies of constant collapse operators; self.c_td_inds = [] # indicies of time-dependent collapse operators; self.c_ops_data = [] # collapse op data; self.c_ops_ind = [] # collapse op indices; self.c_ops_ptr = [] # collapse op indptrs; self.c_args = [] # store args for time-dependent collapse func. # Norm collapse operator stuff; self.n_ops_data = [] # norm collapse op data; self.n_ops_ind = [] # norm collapse op indices; self.n_ops_ptr = [] # norm collapse op indptrs. # holds executable strings for time-dependent collapse evaluation; self.col_expect_code = None; self.col_spmv_code = None. # hold stuff for function list based time dependence; self.h_td_inds = []; self.h_td_data = []; self.h_td_ind = []; self.h_td_ptr = []; self.h_funcs = None; self.h_func_args = None; self.c_funcs = None; self.c_func_args = None. # time-dependent (TD) function stuff; self.tdfunc = None # Placeholder for TD RHS function.; self.tdname = None # Name of td .pyx file; self.colspmv = None # Placeholder for TD col-spmv function.; self.colexpect = None # Placeholder for TD col_expect function.; self.string = None # Holds string of variables passed to td solver. def _format_time(t, tt=None, ttt=None):; time_str = str(datetime.timedelta(seconds=t)); if tt is not None and ttt is not None:; sect_percent = 100*t/tt; solve_percent = 100*t/ttt; time_str += "" ({:03.2f}% section, {:03.2f}% total)"".format(; sect_percent, solve_percent); elif tt is not None:; sect_percent = 100*t/tt; time_str += "" ({:03.2f}% section)"".format(sect_percent). elif ttt is not None:; solve_percent = 100*t/ttt; time_str += "" ({:03.2f}% total)"".format(solve_",MatchSource.WIKI,docs/4.7/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/solver.html
https://qutip.org/docs/4.7/modules/qutip/solver.html:14461,Integrability,depend,dependent,14461,"pect op indptrs; self.e_ops_isherm = [] # expect op isherm. # Collapse operator stuff; self.c_num = 0 # number of collapse ops; self.c_const_inds = [] # indicies of constant collapse operators; self.c_td_inds = [] # indicies of time-dependent collapse operators; self.c_ops_data = [] # collapse op data; self.c_ops_ind = [] # collapse op indices; self.c_ops_ptr = [] # collapse op indptrs; self.c_args = [] # store args for time-dependent collapse func. # Norm collapse operator stuff; self.n_ops_data = [] # norm collapse op data; self.n_ops_ind = [] # norm collapse op indices; self.n_ops_ptr = [] # norm collapse op indptrs. # holds executable strings for time-dependent collapse evaluation; self.col_expect_code = None; self.col_spmv_code = None. # hold stuff for function list based time dependence; self.h_td_inds = []; self.h_td_data = []; self.h_td_ind = []; self.h_td_ptr = []; self.h_funcs = None; self.h_func_args = None; self.c_funcs = None; self.c_func_args = None. # time-dependent (TD) function stuff; self.tdfunc = None # Placeholder for TD RHS function.; self.tdname = None # Name of td .pyx file; self.colspmv = None # Placeholder for TD col-spmv function.; self.colexpect = None # Placeholder for TD col_expect function.; self.string = None # Holds string of variables passed to td solver. def _format_time(t, tt=None, ttt=None):; time_str = str(datetime.timedelta(seconds=t)); if tt is not None and ttt is not None:; sect_percent = 100*t/tt; solve_percent = 100*t/ttt; time_str += "" ({:03.2f}% section, {:03.2f}% total)"".format(; sect_percent, solve_percent); elif tt is not None:; sect_percent = 100*t/tt; time_str += "" ({:03.2f}% section)"".format(sect_percent). elif ttt is not None:; solve_percent = 100*t/ttt; time_str += "" ({:03.2f}% total)"".format(solve_percent). return time_str. [docs]class Stats:; """"""; Statistical information on the solver performance; Statistics can be grouped into sections.; If no section names are given in the the contructor, then all statistics; w",MatchSource.WIKI,docs/4.7/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/solver.html
https://qutip.org/docs/4.7/modules/qutip/solver.html:18712,Integrability,message,message,18712,"ion of value. value : int; Initial value of the count, or added to an existing count. section : string or :class:`_StatsSection`; Section which to add the count to.; If None given, the default (first) section will be used; """""". self._get_section(section).add_count(key, value). [docs] def add_timing(self, key, value, section=None):; """"""; Add value to timing. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be a float, and given in seconds. Parameters; ----------; key : string; key for the section.timings dictionary; reusing a key will result in numerical addition of value. value : int; Initial value of the timing, or added to an existing timing. section: string or `class` : _StatsSection; Section which to add the timing to.; If None given, the default (first) section will be used; """"""; self._get_section(section).add_timing(key, value). [docs] def add_message(self, key, value, section=None, sep="";""):; """"""; Add value to message. If key does not already exist in section then; it is created with this value.; If key already exists the value is added to the message; The value will be converted to a string. Parameters; ----------; key : string; key for the section.messages dictionary; reusing a key will result in concatenation of value. value : int; Initial value of the message, or added to an existing message. sep : string; Message will be prefixed with this string when concatenating. section: string or `class` : _StatsSection; Section which to add the message to.; If None given, the default (first) section will be used; """"""; self._get_section(section).add_message(key, value, sep=sep). [docs] def set_total_time(self, value, section=None):; """"""; Sets the total time for the complete solve or for a specific section; value is expected to be a float, and given in seconds. Parameters; ----------; value : float; Time in seconds to complete the solver section. section : strin",MatchSource.WIKI,docs/4.7/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/solver.html
https://qutip.org/docs/4.7/modules/qutip/solver.html:18848,Integrability,message,message,18848,"given, the default (first) section will be used; """""". self._get_section(section).add_count(key, value). [docs] def add_timing(self, key, value, section=None):; """"""; Add value to timing. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be a float, and given in seconds. Parameters; ----------; key : string; key for the section.timings dictionary; reusing a key will result in numerical addition of value. value : int; Initial value of the timing, or added to an existing timing. section: string or `class` : _StatsSection; Section which to add the timing to.; If None given, the default (first) section will be used; """"""; self._get_section(section).add_timing(key, value). [docs] def add_message(self, key, value, section=None, sep="";""):; """"""; Add value to message. If key does not already exist in section then; it is created with this value.; If key already exists the value is added to the message; The value will be converted to a string. Parameters; ----------; key : string; key for the section.messages dictionary; reusing a key will result in concatenation of value. value : int; Initial value of the message, or added to an existing message. sep : string; Message will be prefixed with this string when concatenating. section: string or `class` : _StatsSection; Section which to add the message to.; If None given, the default (first) section will be used; """"""; self._get_section(section).add_message(key, value, sep=sep). [docs] def set_total_time(self, value, section=None):; """"""; Sets the total time for the complete solve or for a specific section; value is expected to be a float, and given in seconds. Parameters; ----------; value : float; Time in seconds to complete the solver section. section : string or `class` : _StatsSection; Section which to set the total_time for; If None given, the total_time for complete solve is set; """"""; if not isinstance(value, float):; try:; v",MatchSource.WIKI,docs/4.7/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/solver.html
https://qutip.org/docs/4.7/modules/qutip/solver.html:18956,Integrability,message,messages,18956,"ection=None):; """"""; Add value to timing. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be a float, and given in seconds. Parameters; ----------; key : string; key for the section.timings dictionary; reusing a key will result in numerical addition of value. value : int; Initial value of the timing, or added to an existing timing. section: string or `class` : _StatsSection; Section which to add the timing to.; If None given, the default (first) section will be used; """"""; self._get_section(section).add_timing(key, value). [docs] def add_message(self, key, value, section=None, sep="";""):; """"""; Add value to message. If key does not already exist in section then; it is created with this value.; If key already exists the value is added to the message; The value will be converted to a string. Parameters; ----------; key : string; key for the section.messages dictionary; reusing a key will result in concatenation of value. value : int; Initial value of the message, or added to an existing message. sep : string; Message will be prefixed with this string when concatenating. section: string or `class` : _StatsSection; Section which to add the message to.; If None given, the default (first) section will be used; """"""; self._get_section(section).add_message(key, value, sep=sep). [docs] def set_total_time(self, value, section=None):; """"""; Sets the total time for the complete solve or for a specific section; value is expected to be a float, and given in seconds. Parameters; ----------; value : float; Time in seconds to complete the solver section. section : string or `class` : _StatsSection; Section which to set the total_time for; If None given, the total_time for complete solve is set; """"""; if not isinstance(value, float):; try:; value = float(value); except:; raise TypeError(""value is expected to be a float""). if section is None:; self.total_time = value; else:; sect = sel",MatchSource.WIKI,docs/4.7/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/solver.html
https://qutip.org/docs/4.7/modules/qutip/solver.html:19064,Integrability,message,message,19064,"ection then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be a float, and given in seconds. Parameters; ----------; key : string; key for the section.timings dictionary; reusing a key will result in numerical addition of value. value : int; Initial value of the timing, or added to an existing timing. section: string or `class` : _StatsSection; Section which to add the timing to.; If None given, the default (first) section will be used; """"""; self._get_section(section).add_timing(key, value). [docs] def add_message(self, key, value, section=None, sep="";""):; """"""; Add value to message. If key does not already exist in section then; it is created with this value.; If key already exists the value is added to the message; The value will be converted to a string. Parameters; ----------; key : string; key for the section.messages dictionary; reusing a key will result in concatenation of value. value : int; Initial value of the message, or added to an existing message. sep : string; Message will be prefixed with this string when concatenating. section: string or `class` : _StatsSection; Section which to add the message to.; If None given, the default (first) section will be used; """"""; self._get_section(section).add_message(key, value, sep=sep). [docs] def set_total_time(self, value, section=None):; """"""; Sets the total time for the complete solve or for a specific section; value is expected to be a float, and given in seconds. Parameters; ----------; value : float; Time in seconds to complete the solver section. section : string or `class` : _StatsSection; Section which to set the total_time for; If None given, the total_time for complete solve is set; """"""; if not isinstance(value, float):; try:; value = float(value); except:; raise TypeError(""value is expected to be a float""). if section is None:; self.total_time = value; else:; sect = self._get_section(section); sect.total_time = value. [docs] def report(self, ",MatchSource.WIKI,docs/4.7/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/solver.html
https://qutip.org/docs/4.7/modules/qutip/solver.html:19097,Integrability,message,message,19097,"ection then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be a float, and given in seconds. Parameters; ----------; key : string; key for the section.timings dictionary; reusing a key will result in numerical addition of value. value : int; Initial value of the timing, or added to an existing timing. section: string or `class` : _StatsSection; Section which to add the timing to.; If None given, the default (first) section will be used; """"""; self._get_section(section).add_timing(key, value). [docs] def add_message(self, key, value, section=None, sep="";""):; """"""; Add value to message. If key does not already exist in section then; it is created with this value.; If key already exists the value is added to the message; The value will be converted to a string. Parameters; ----------; key : string; key for the section.messages dictionary; reusing a key will result in concatenation of value. value : int; Initial value of the message, or added to an existing message. sep : string; Message will be prefixed with this string when concatenating. section: string or `class` : _StatsSection; Section which to add the message to.; If None given, the default (first) section will be used; """"""; self._get_section(section).add_message(key, value, sep=sep). [docs] def set_total_time(self, value, section=None):; """"""; Sets the total time for the complete solve or for a specific section; value is expected to be a float, and given in seconds. Parameters; ----------; value : float; Time in seconds to complete the solver section. section : string or `class` : _StatsSection; Section which to set the total_time for; If None given, the total_time for complete solve is set; """"""; if not isinstance(value, float):; try:; value = float(value); except:; raise TypeError(""value is expected to be a float""). if section is None:; self.total_time = value; else:; sect = self._get_section(section); sect.total_time = value. [docs] def report(self, ",MatchSource.WIKI,docs/4.7/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/solver.html
https://qutip.org/docs/4.7/modules/qutip/solver.html:19251,Integrability,message,message,19251,"s. Parameters; ----------; key : string; key for the section.timings dictionary; reusing a key will result in numerical addition of value. value : int; Initial value of the timing, or added to an existing timing. section: string or `class` : _StatsSection; Section which to add the timing to.; If None given, the default (first) section will be used; """"""; self._get_section(section).add_timing(key, value). [docs] def add_message(self, key, value, section=None, sep="";""):; """"""; Add value to message. If key does not already exist in section then; it is created with this value.; If key already exists the value is added to the message; The value will be converted to a string. Parameters; ----------; key : string; key for the section.messages dictionary; reusing a key will result in concatenation of value. value : int; Initial value of the message, or added to an existing message. sep : string; Message will be prefixed with this string when concatenating. section: string or `class` : _StatsSection; Section which to add the message to.; If None given, the default (first) section will be used; """"""; self._get_section(section).add_message(key, value, sep=sep). [docs] def set_total_time(self, value, section=None):; """"""; Sets the total time for the complete solve or for a specific section; value is expected to be a float, and given in seconds. Parameters; ----------; value : float; Time in seconds to complete the solver section. section : string or `class` : _StatsSection; Section which to set the total_time for; If None given, the total_time for complete solve is set; """"""; if not isinstance(value, float):; try:; value = float(value); except:; raise TypeError(""value is expected to be a float""). if section is None:; self.total_time = value; else:; sect = self._get_section(section); sect.total_time = value. [docs] def report(self, output=sys.stdout):; """"""; Report the counts, timings and messages from the sections.; Sections are reported in the order that the names were supplied; in t",MatchSource.WIKI,docs/4.7/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/solver.html
https://qutip.org/docs/4.7/modules/qutip/solver.html:20124,Integrability,message,messages,20124,"ring; Message will be prefixed with this string when concatenating. section: string or `class` : _StatsSection; Section which to add the message to.; If None given, the default (first) section will be used; """"""; self._get_section(section).add_message(key, value, sep=sep). [docs] def set_total_time(self, value, section=None):; """"""; Sets the total time for the complete solve or for a specific section; value is expected to be a float, and given in seconds. Parameters; ----------; value : float; Time in seconds to complete the solver section. section : string or `class` : _StatsSection; Section which to set the total_time for; If None given, the total_time for complete solve is set; """"""; if not isinstance(value, float):; try:; value = float(value); except:; raise TypeError(""value is expected to be a float""). if section is None:; self.total_time = value; else:; sect = self._get_section(section); sect.total_time = value. [docs] def report(self, output=sys.stdout):; """"""; Report the counts, timings and messages from the sections.; Sections are reported in the order that the names were supplied; in the constructor.; The counts, timings and messages are reported in the order that they; are added to the sections; The output can be written to anything that supports a write method,; e.g. a file or the console (default); The output is intended to in markdown format. Parameters; ----------; output : stream; file or console stream - anything that support write - where; the output will be written; """""". if not hasattr(output, 'write'):; raise TypeError(""output must have a write method""). if self.header:; output.write(""{}\n{}\n"".format(self.header,; (""=""*len(self.header)))); for name, sect in self.sections.items():; sect.report(output). if self.total_time is not None:; output.write(""\nSummary\n-------\n""); output.write(""{}\t solver total time\n"".format(; _format_time(self.total_time))). [docs] def clear(self):; """"""; Clear counts, timings and messages from all sections; """"""; for sect in",MatchSource.WIKI,docs/4.7/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/solver.html
https://qutip.org/docs/4.7/modules/qutip/solver.html:20263,Integrability,message,messages,20263,"""""; self._get_section(section).add_message(key, value, sep=sep). [docs] def set_total_time(self, value, section=None):; """"""; Sets the total time for the complete solve or for a specific section; value is expected to be a float, and given in seconds. Parameters; ----------; value : float; Time in seconds to complete the solver section. section : string or `class` : _StatsSection; Section which to set the total_time for; If None given, the total_time for complete solve is set; """"""; if not isinstance(value, float):; try:; value = float(value); except:; raise TypeError(""value is expected to be a float""). if section is None:; self.total_time = value; else:; sect = self._get_section(section); sect.total_time = value. [docs] def report(self, output=sys.stdout):; """"""; Report the counts, timings and messages from the sections.; Sections are reported in the order that the names were supplied; in the constructor.; The counts, timings and messages are reported in the order that they; are added to the sections; The output can be written to anything that supports a write method,; e.g. a file or the console (default); The output is intended to in markdown format. Parameters; ----------; output : stream; file or console stream - anything that support write - where; the output will be written; """""". if not hasattr(output, 'write'):; raise TypeError(""output must have a write method""). if self.header:; output.write(""{}\n{}\n"".format(self.header,; (""=""*len(self.header)))); for name, sect in self.sections.items():; sect.report(output). if self.total_time is not None:; output.write(""\nSummary\n-------\n""); output.write(""{}\t solver total time\n"".format(; _format_time(self.total_time))). [docs] def clear(self):; """"""; Clear counts, timings and messages from all sections; """"""; for sect in self.sections.values():; sect.clear(); self.total_time = None. class _StatsSection(object):; """"""; Not intended to be directly instantiated; This is the type for the SolverStats.sections values. The method p",MatchSource.WIKI,docs/4.7/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/solver.html
https://qutip.org/docs/4.7/modules/qutip/solver.html:21071,Integrability,message,messages,21071,"output=sys.stdout):; """"""; Report the counts, timings and messages from the sections.; Sections are reported in the order that the names were supplied; in the constructor.; The counts, timings and messages are reported in the order that they; are added to the sections; The output can be written to anything that supports a write method,; e.g. a file or the console (default); The output is intended to in markdown format. Parameters; ----------; output : stream; file or console stream - anything that support write - where; the output will be written; """""". if not hasattr(output, 'write'):; raise TypeError(""output must have a write method""). if self.header:; output.write(""{}\n{}\n"".format(self.header,; (""=""*len(self.header)))); for name, sect in self.sections.items():; sect.report(output). if self.total_time is not None:; output.write(""\nSummary\n-------\n""); output.write(""{}\t solver total time\n"".format(; _format_time(self.total_time))). [docs] def clear(self):; """"""; Clear counts, timings and messages from all sections; """"""; for sect in self.sections.values():; sect.clear(); self.total_time = None. class _StatsSection(object):; """"""; Not intended to be directly instantiated; This is the type for the SolverStats.sections values. The method parameter descriptions are the same as for those the parent; with the same method name. Parameters; ----------; name : string; key for the parent sections dictionary; will also be used as the header. parent : `class` : SolverStats; The container for all the sections. Attributes; ----------; name : string; key for the parent sections dictionary; will also be used as the header. parent : `class` : SolverStats; The container for all the sections. header : string; Used as heading for section in report. counts : OrderedDict; The integer type statistics for the stats section. timings : OrderedDict; The timing type statistics for the stats section; Expected to contain float values representing values in seconds. messages : OrderedDict; Text typ",MatchSource.WIKI,docs/4.7/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/solver.html
https://qutip.org/docs/4.7/modules/qutip/solver.html:22036,Integrability,message,messages,22036,"ngs and messages from all sections; """"""; for sect in self.sections.values():; sect.clear(); self.total_time = None. class _StatsSection(object):; """"""; Not intended to be directly instantiated; This is the type for the SolverStats.sections values. The method parameter descriptions are the same as for those the parent; with the same method name. Parameters; ----------; name : string; key for the parent sections dictionary; will also be used as the header. parent : `class` : SolverStats; The container for all the sections. Attributes; ----------; name : string; key for the parent sections dictionary; will also be used as the header. parent : `class` : SolverStats; The container for all the sections. header : string; Used as heading for section in report. counts : OrderedDict; The integer type statistics for the stats section. timings : OrderedDict; The timing type statistics for the stats section; Expected to contain float values representing values in seconds. messages : OrderedDict; Text type output to be reported. total_time : float; Total time for processing in the section; Can be None, meaning that section timing percentages will be reported; """"""; def __init__(self, name, parent):; self.parent = parent; self.header = str(name); self.name = name; self.counts = OrderedDict(); self.timings = OrderedDict(); self.messages = OrderedDict(); self.total_time = None. def add_count(self, key, value):; """"""; Add value to count. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the given value; value is expected to be an integer; """"""; if not isinstance(value, int):; try:; value = int(value); except:; raise TypeError(""value is expected to be an integer""). if key in self.counts:; self.counts[key] += value; else:; self.counts[key] = value. def add_timing(self, key, value):; """"""; Add value to timing. If key does not already exist in section then; it is created with this value.; If key already exists it is increase",MatchSource.WIKI,docs/4.7/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/solver.html
https://qutip.org/docs/4.7/modules/qutip/solver.html:22395,Integrability,message,messages,22395,"arameters; ----------; name : string; key for the parent sections dictionary; will also be used as the header. parent : `class` : SolverStats; The container for all the sections. Attributes; ----------; name : string; key for the parent sections dictionary; will also be used as the header. parent : `class` : SolverStats; The container for all the sections. header : string; Used as heading for section in report. counts : OrderedDict; The integer type statistics for the stats section. timings : OrderedDict; The timing type statistics for the stats section; Expected to contain float values representing values in seconds. messages : OrderedDict; Text type output to be reported. total_time : float; Total time for processing in the section; Can be None, meaning that section timing percentages will be reported; """"""; def __init__(self, name, parent):; self.parent = parent; self.header = str(name); self.name = name; self.counts = OrderedDict(); self.timings = OrderedDict(); self.messages = OrderedDict(); self.total_time = None. def add_count(self, key, value):; """"""; Add value to count. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the given value; value is expected to be an integer; """"""; if not isinstance(value, int):; try:; value = int(value); except:; raise TypeError(""value is expected to be an integer""). if key in self.counts:; self.counts[key] += value; else:; self.counts[key] = value. def add_timing(self, key, value):; """"""; Add value to timing. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be a float, and given in seconds.; """"""; if not isinstance(value, float):; try:; value = float(value); except:; raise TypeError(""value is expected to be a float""). if key in self.timings:; self.timings[key] += value; else:; self.timings[key] = value. def add_message(self, key, value, sep="";""):; """"""; Add v",MatchSource.WIKI,docs/4.7/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/solver.html
https://qutip.org/docs/4.7/modules/qutip/solver.html:23419,Integrability,message,message,23419,"elf.messages = OrderedDict(); self.total_time = None. def add_count(self, key, value):; """"""; Add value to count. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the given value; value is expected to be an integer; """"""; if not isinstance(value, int):; try:; value = int(value); except:; raise TypeError(""value is expected to be an integer""). if key in self.counts:; self.counts[key] += value; else:; self.counts[key] = value. def add_timing(self, key, value):; """"""; Add value to timing. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be a float, and given in seconds.; """"""; if not isinstance(value, float):; try:; value = float(value); except:; raise TypeError(""value is expected to be a float""). if key in self.timings:; self.timings[key] += value; else:; self.timings[key] = value. def add_message(self, key, value, sep="";""):; """"""; Add value to message. If key does not already exist in section then; it is created with this value.; If key already exists the value is added to the message; The value will be converted to a string; """"""; value = str(value). if key in self.messages:; if sep is not None:; try:; value = sep + value; except:; TypeError(""It is not possible to concatenate the value ""; ""with the given seperator""); self.messages[key] += value; else:; self.messages[key] = value. def report(self, output=sys.stdout):; """"""; Report the counts, timings and messages for this section.; Note the percentage of the section and solver total times will be; given if the parent and or section total_time is set; """"""; if self.header:; output.write(""\n{}\n{}\n"".format(self.header,; (""-""*len(self.header)))). # TODO: Make the timings and counts ouput in a table format; # Generally make more pretty. # Report timings; try:; ttt = self.parent.total_time; except:; ttt = None. tt = self.total_time. output.write(""### Tim",MatchSource.WIKI,docs/4.7/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/solver.html
https://qutip.org/docs/4.7/modules/qutip/solver.html:23555,Integrability,message,message,23555,"th this value.; If key already exists it is increased by the given value; value is expected to be an integer; """"""; if not isinstance(value, int):; try:; value = int(value); except:; raise TypeError(""value is expected to be an integer""). if key in self.counts:; self.counts[key] += value; else:; self.counts[key] = value. def add_timing(self, key, value):; """"""; Add value to timing. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be a float, and given in seconds.; """"""; if not isinstance(value, float):; try:; value = float(value); except:; raise TypeError(""value is expected to be a float""). if key in self.timings:; self.timings[key] += value; else:; self.timings[key] = value. def add_message(self, key, value, sep="";""):; """"""; Add value to message. If key does not already exist in section then; it is created with this value.; If key already exists the value is added to the message; The value will be converted to a string; """"""; value = str(value). if key in self.messages:; if sep is not None:; try:; value = sep + value; except:; TypeError(""It is not possible to concatenate the value ""; ""with the given seperator""); self.messages[key] += value; else:; self.messages[key] = value. def report(self, output=sys.stdout):; """"""; Report the counts, timings and messages for this section.; Note the percentage of the section and solver total times will be; given if the parent and or section total_time is set; """"""; if self.header:; output.write(""\n{}\n{}\n"".format(self.header,; (""-""*len(self.header)))). # TODO: Make the timings and counts ouput in a table format; # Generally make more pretty. # Report timings; try:; ttt = self.parent.total_time; except:; ttt = None. tt = self.total_time. output.write(""### Timings:\n""); for key, value in self.timings.items():; l = "" - {}\t{}\n"".format(_format_time(value, tt, ttt), key); output.write(l); if tt is not None:; output.write("" - {}\t{} to",MatchSource.WIKI,docs/4.7/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/solver.html
https://qutip.org/docs/4.7/modules/qutip/solver.html:23645,Integrability,message,messages,23645," = int(value); except:; raise TypeError(""value is expected to be an integer""). if key in self.counts:; self.counts[key] += value; else:; self.counts[key] = value. def add_timing(self, key, value):; """"""; Add value to timing. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be a float, and given in seconds.; """"""; if not isinstance(value, float):; try:; value = float(value); except:; raise TypeError(""value is expected to be a float""). if key in self.timings:; self.timings[key] += value; else:; self.timings[key] = value. def add_message(self, key, value, sep="";""):; """"""; Add value to message. If key does not already exist in section then; it is created with this value.; If key already exists the value is added to the message; The value will be converted to a string; """"""; value = str(value). if key in self.messages:; if sep is not None:; try:; value = sep + value; except:; TypeError(""It is not possible to concatenate the value ""; ""with the given seperator""); self.messages[key] += value; else:; self.messages[key] = value. def report(self, output=sys.stdout):; """"""; Report the counts, timings and messages for this section.; Note the percentage of the section and solver total times will be; given if the parent and or section total_time is set; """"""; if self.header:; output.write(""\n{}\n{}\n"".format(self.header,; (""-""*len(self.header)))). # TODO: Make the timings and counts ouput in a table format; # Generally make more pretty. # Report timings; try:; ttt = self.parent.total_time; except:; ttt = None. tt = self.total_time. output.write(""### Timings:\n""); for key, value in self.timings.items():; l = "" - {}\t{}\n"".format(_format_time(value, tt, ttt), key); output.write(l); if tt is not None:; output.write("" - {}\t{} total time\n"".format(_format_time(tt),; self.name)). # Report counts; output.write(""### Counts:\n""); for key, value in self.counts.items():; l = "" - {}\t{}\n"".f",MatchSource.WIKI,docs/4.7/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/solver.html
https://qutip.org/docs/4.7/modules/qutip/solver.html:23805,Integrability,message,messages,23805,"ts:; self.counts[key] += value; else:; self.counts[key] = value. def add_timing(self, key, value):; """"""; Add value to timing. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be a float, and given in seconds.; """"""; if not isinstance(value, float):; try:; value = float(value); except:; raise TypeError(""value is expected to be a float""). if key in self.timings:; self.timings[key] += value; else:; self.timings[key] = value. def add_message(self, key, value, sep="";""):; """"""; Add value to message. If key does not already exist in section then; it is created with this value.; If key already exists the value is added to the message; The value will be converted to a string; """"""; value = str(value). if key in self.messages:; if sep is not None:; try:; value = sep + value; except:; TypeError(""It is not possible to concatenate the value ""; ""with the given seperator""); self.messages[key] += value; else:; self.messages[key] = value. def report(self, output=sys.stdout):; """"""; Report the counts, timings and messages for this section.; Note the percentage of the section and solver total times will be; given if the parent and or section total_time is set; """"""; if self.header:; output.write(""\n{}\n{}\n"".format(self.header,; (""-""*len(self.header)))). # TODO: Make the timings and counts ouput in a table format; # Generally make more pretty. # Report timings; try:; ttt = self.parent.total_time; except:; ttt = None. tt = self.total_time. output.write(""### Timings:\n""); for key, value in self.timings.items():; l = "" - {}\t{}\n"".format(_format_time(value, tt, ttt), key); output.write(l); if tt is not None:; output.write("" - {}\t{} total time\n"".format(_format_time(tt),; self.name)). # Report counts; output.write(""### Counts:\n""); for key, value in self.counts.items():; l = "" - {}\t{}\n"".format(value, key); output.write(l). # Report messages; output.write(""### Messages:\n""); for key, v",MatchSource.WIKI,docs/4.7/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/solver.html
https://qutip.org/docs/4.7/modules/qutip/solver.html:23841,Integrability,message,messages,23841,"e; else:; self.counts[key] = value. def add_timing(self, key, value):; """"""; Add value to timing. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be a float, and given in seconds.; """"""; if not isinstance(value, float):; try:; value = float(value); except:; raise TypeError(""value is expected to be a float""). if key in self.timings:; self.timings[key] += value; else:; self.timings[key] = value. def add_message(self, key, value, sep="";""):; """"""; Add value to message. If key does not already exist in section then; it is created with this value.; If key already exists the value is added to the message; The value will be converted to a string; """"""; value = str(value). if key in self.messages:; if sep is not None:; try:; value = sep + value; except:; TypeError(""It is not possible to concatenate the value ""; ""with the given seperator""); self.messages[key] += value; else:; self.messages[key] = value. def report(self, output=sys.stdout):; """"""; Report the counts, timings and messages for this section.; Note the percentage of the section and solver total times will be; given if the parent and or section total_time is set; """"""; if self.header:; output.write(""\n{}\n{}\n"".format(self.header,; (""-""*len(self.header)))). # TODO: Make the timings and counts ouput in a table format; # Generally make more pretty. # Report timings; try:; ttt = self.parent.total_time; except:; ttt = None. tt = self.total_time. output.write(""### Timings:\n""); for key, value in self.timings.items():; l = "" - {}\t{}\n"".format(_format_time(value, tt, ttt), key); output.write(l); if tt is not None:; output.write("" - {}\t{} total time\n"".format(_format_time(tt),; self.name)). # Report counts; output.write(""### Counts:\n""); for key, value in self.counts.items():; l = "" - {}\t{}\n"".format(value, key); output.write(l). # Report messages; output.write(""### Messages:\n""); for key, value in self.messages.items()",MatchSource.WIKI,docs/4.7/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/solver.html
https://qutip.org/docs/4.7/modules/qutip/solver.html:23938,Integrability,message,messages,23938,"Add value to timing. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be a float, and given in seconds.; """"""; if not isinstance(value, float):; try:; value = float(value); except:; raise TypeError(""value is expected to be a float""). if key in self.timings:; self.timings[key] += value; else:; self.timings[key] = value. def add_message(self, key, value, sep="";""):; """"""; Add value to message. If key does not already exist in section then; it is created with this value.; If key already exists the value is added to the message; The value will be converted to a string; """"""; value = str(value). if key in self.messages:; if sep is not None:; try:; value = sep + value; except:; TypeError(""It is not possible to concatenate the value ""; ""with the given seperator""); self.messages[key] += value; else:; self.messages[key] = value. def report(self, output=sys.stdout):; """"""; Report the counts, timings and messages for this section.; Note the percentage of the section and solver total times will be; given if the parent and or section total_time is set; """"""; if self.header:; output.write(""\n{}\n{}\n"".format(self.header,; (""-""*len(self.header)))). # TODO: Make the timings and counts ouput in a table format; # Generally make more pretty. # Report timings; try:; ttt = self.parent.total_time; except:; ttt = None. tt = self.total_time. output.write(""### Timings:\n""); for key, value in self.timings.items():; l = "" - {}\t{}\n"".format(_format_time(value, tt, ttt), key); output.write(l); if tt is not None:; output.write("" - {}\t{} total time\n"".format(_format_time(tt),; self.name)). # Report counts; output.write(""### Counts:\n""); for key, value in self.counts.items():; l = "" - {}\t{}\n"".format(value, key); output.write(l). # Report messages; output.write(""### Messages:\n""); for key, value in self.messages.items():; l = "" - {}:\t{}\n"".format(key, value); output.write(l). def clear(self):;",MatchSource.WIKI,docs/4.7/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/solver.html
https://qutip.org/docs/4.7/modules/qutip/solver.html:24770,Integrability,message,messages,24770,"ith the given seperator""); self.messages[key] += value; else:; self.messages[key] = value. def report(self, output=sys.stdout):; """"""; Report the counts, timings and messages for this section.; Note the percentage of the section and solver total times will be; given if the parent and or section total_time is set; """"""; if self.header:; output.write(""\n{}\n{}\n"".format(self.header,; (""-""*len(self.header)))). # TODO: Make the timings and counts ouput in a table format; # Generally make more pretty. # Report timings; try:; ttt = self.parent.total_time; except:; ttt = None. tt = self.total_time. output.write(""### Timings:\n""); for key, value in self.timings.items():; l = "" - {}\t{}\n"".format(_format_time(value, tt, ttt), key); output.write(l); if tt is not None:; output.write("" - {}\t{} total time\n"".format(_format_time(tt),; self.name)). # Report counts; output.write(""### Counts:\n""); for key, value in self.counts.items():; l = "" - {}\t{}\n"".format(value, key); output.write(l). # Report messages; output.write(""### Messages:\n""); for key, value in self.messages.items():; l = "" - {}:\t{}\n"".format(key, value); output.write(l). def clear(self):; """"""; Clear counts, timings and messages from this section; """"""; self.counts.clear(); self.timings.clear(); self.messages.clear(); self.total_time = None. def _solver_safety_check(H, state=None, c_ops=[], e_ops=[], args={}):; # Input is std Qobj (Hamiltonian or Liouvillian); if isinstance(H, Qobj):; Hdims = H.dims; Htype = H.type; _structure_check(Hdims, Htype, state); # Input H is function; elif isinstance(H, (FunctionType, BuiltinFunctionType)):; Hdims = H(0,args).dims; Htype = H(0,args).type; _structure_check(Hdims, Htype, state); # Input is td-list; elif isinstance(H, list):; if isinstance(H[0], Qobj):; Hdims = H[0].dims; Htype = H[0].type; elif isinstance(H[0], list):; Hdims = H[0][0].dims; Htype = H[0][0].type; elif isinstance(H[0], (FunctionType, BuiltinFunctionType)):; Hdims = H[0](0,args).dims; Htype = H[0](0,args).type; else",MatchSource.WIKI,docs/4.7/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/solver.html
https://qutip.org/docs/4.7/modules/qutip/solver.html:24836,Integrability,message,messages,24836,".messages[key] = value. def report(self, output=sys.stdout):; """"""; Report the counts, timings and messages for this section.; Note the percentage of the section and solver total times will be; given if the parent and or section total_time is set; """"""; if self.header:; output.write(""\n{}\n{}\n"".format(self.header,; (""-""*len(self.header)))). # TODO: Make the timings and counts ouput in a table format; # Generally make more pretty. # Report timings; try:; ttt = self.parent.total_time; except:; ttt = None. tt = self.total_time. output.write(""### Timings:\n""); for key, value in self.timings.items():; l = "" - {}\t{}\n"".format(_format_time(value, tt, ttt), key); output.write(l); if tt is not None:; output.write("" - {}\t{} total time\n"".format(_format_time(tt),; self.name)). # Report counts; output.write(""### Counts:\n""); for key, value in self.counts.items():; l = "" - {}\t{}\n"".format(value, key); output.write(l). # Report messages; output.write(""### Messages:\n""); for key, value in self.messages.items():; l = "" - {}:\t{}\n"".format(key, value); output.write(l). def clear(self):; """"""; Clear counts, timings and messages from this section; """"""; self.counts.clear(); self.timings.clear(); self.messages.clear(); self.total_time = None. def _solver_safety_check(H, state=None, c_ops=[], e_ops=[], args={}):; # Input is std Qobj (Hamiltonian or Liouvillian); if isinstance(H, Qobj):; Hdims = H.dims; Htype = H.type; _structure_check(Hdims, Htype, state); # Input H is function; elif isinstance(H, (FunctionType, BuiltinFunctionType)):; Hdims = H(0,args).dims; Htype = H(0,args).type; _structure_check(Hdims, Htype, state); # Input is td-list; elif isinstance(H, list):; if isinstance(H[0], Qobj):; Hdims = H[0].dims; Htype = H[0].type; elif isinstance(H[0], list):; Hdims = H[0][0].dims; Htype = H[0][0].type; elif isinstance(H[0], (FunctionType, BuiltinFunctionType)):; Hdims = H[0](0,args).dims; Htype = H[0](0,args).type; else:; raise Exception('Invalid td-list element.'); # Check all operato",MatchSource.WIKI,docs/4.7/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/solver.html
https://qutip.org/docs/4.7/modules/qutip/solver.html:24960,Integrability,message,messages,24960,"s section.; Note the percentage of the section and solver total times will be; given if the parent and or section total_time is set; """"""; if self.header:; output.write(""\n{}\n{}\n"".format(self.header,; (""-""*len(self.header)))). # TODO: Make the timings and counts ouput in a table format; # Generally make more pretty. # Report timings; try:; ttt = self.parent.total_time; except:; ttt = None. tt = self.total_time. output.write(""### Timings:\n""); for key, value in self.timings.items():; l = "" - {}\t{}\n"".format(_format_time(value, tt, ttt), key); output.write(l); if tt is not None:; output.write("" - {}\t{} total time\n"".format(_format_time(tt),; self.name)). # Report counts; output.write(""### Counts:\n""); for key, value in self.counts.items():; l = "" - {}\t{}\n"".format(value, key); output.write(l). # Report messages; output.write(""### Messages:\n""); for key, value in self.messages.items():; l = "" - {}:\t{}\n"".format(key, value); output.write(l). def clear(self):; """"""; Clear counts, timings and messages from this section; """"""; self.counts.clear(); self.timings.clear(); self.messages.clear(); self.total_time = None. def _solver_safety_check(H, state=None, c_ops=[], e_ops=[], args={}):; # Input is std Qobj (Hamiltonian or Liouvillian); if isinstance(H, Qobj):; Hdims = H.dims; Htype = H.type; _structure_check(Hdims, Htype, state); # Input H is function; elif isinstance(H, (FunctionType, BuiltinFunctionType)):; Hdims = H(0,args).dims; Htype = H(0,args).type; _structure_check(Hdims, Htype, state); # Input is td-list; elif isinstance(H, list):; if isinstance(H[0], Qobj):; Hdims = H[0].dims; Htype = H[0].type; elif isinstance(H[0], list):; Hdims = H[0][0].dims; Htype = H[0][0].type; elif isinstance(H[0], (FunctionType, BuiltinFunctionType)):; Hdims = H[0](0,args).dims; Htype = H[0](0,args).type; else:; raise Exception('Invalid td-list element.'); # Check all operators in list; for ii in range(len(H)):; if isinstance(H[ii], Qobj):; _temp_dims = H[ii].dims; _temp_type = H[ii].ty",MatchSource.WIKI,docs/4.7/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/solver.html
https://qutip.org/docs/4.7/modules/qutip/solver.html:25041,Integrability,message,messages,25041," parent and or section total_time is set; """"""; if self.header:; output.write(""\n{}\n{}\n"".format(self.header,; (""-""*len(self.header)))). # TODO: Make the timings and counts ouput in a table format; # Generally make more pretty. # Report timings; try:; ttt = self.parent.total_time; except:; ttt = None. tt = self.total_time. output.write(""### Timings:\n""); for key, value in self.timings.items():; l = "" - {}\t{}\n"".format(_format_time(value, tt, ttt), key); output.write(l); if tt is not None:; output.write("" - {}\t{} total time\n"".format(_format_time(tt),; self.name)). # Report counts; output.write(""### Counts:\n""); for key, value in self.counts.items():; l = "" - {}\t{}\n"".format(value, key); output.write(l). # Report messages; output.write(""### Messages:\n""); for key, value in self.messages.items():; l = "" - {}:\t{}\n"".format(key, value); output.write(l). def clear(self):; """"""; Clear counts, timings and messages from this section; """"""; self.counts.clear(); self.timings.clear(); self.messages.clear(); self.total_time = None. def _solver_safety_check(H, state=None, c_ops=[], e_ops=[], args={}):; # Input is std Qobj (Hamiltonian or Liouvillian); if isinstance(H, Qobj):; Hdims = H.dims; Htype = H.type; _structure_check(Hdims, Htype, state); # Input H is function; elif isinstance(H, (FunctionType, BuiltinFunctionType)):; Hdims = H(0,args).dims; Htype = H(0,args).type; _structure_check(Hdims, Htype, state); # Input is td-list; elif isinstance(H, list):; if isinstance(H[0], Qobj):; Hdims = H[0].dims; Htype = H[0].type; elif isinstance(H[0], list):; Hdims = H[0][0].dims; Htype = H[0][0].type; elif isinstance(H[0], (FunctionType, BuiltinFunctionType)):; Hdims = H[0](0,args).dims; Htype = H[0](0,args).type; else:; raise Exception('Invalid td-list element.'); # Check all operators in list; for ii in range(len(H)):; if isinstance(H[ii], Qobj):; _temp_dims = H[ii].dims; _temp_type = H[ii].type; elif isinstance(H[ii], list):; _temp_dims = H[ii][0].dims; _temp_type = H[ii][0].type; e",MatchSource.WIKI,docs/4.7/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/solver.html
https://qutip.org/docs/4.7/modules/qutip/solver.html:26309,Integrability,depend,dependent,26309,"; # Input H is function; elif isinstance(H, (FunctionType, BuiltinFunctionType)):; Hdims = H(0,args).dims; Htype = H(0,args).type; _structure_check(Hdims, Htype, state); # Input is td-list; elif isinstance(H, list):; if isinstance(H[0], Qobj):; Hdims = H[0].dims; Htype = H[0].type; elif isinstance(H[0], list):; Hdims = H[0][0].dims; Htype = H[0][0].type; elif isinstance(H[0], (FunctionType, BuiltinFunctionType)):; Hdims = H[0](0,args).dims; Htype = H[0](0,args).type; else:; raise Exception('Invalid td-list element.'); # Check all operators in list; for ii in range(len(H)):; if isinstance(H[ii], Qobj):; _temp_dims = H[ii].dims; _temp_type = H[ii].type; elif isinstance(H[ii], list):; _temp_dims = H[ii][0].dims; _temp_type = H[ii][0].type; elif isinstance(H[ii], (FunctionType, BuiltinFunctionType)):; _temp_dims = H[ii](0,args).dims; _temp_type = H[ii](0,args).type; else:; raise Exception('Invalid td-list element.'); _structure_check(_temp_dims,_temp_type,state). else:; raise Exception('Invalid time-dependent format.'). for ii in range(len(c_ops)):; do_tests = True; if isinstance(c_ops[ii], Qobj):; _temp_state = c_ops[ii]; elif isinstance(c_ops[ii], list):; if isinstance(c_ops[ii][0], Qobj):; _temp_state = c_ops[ii][0]; elif isinstance(c_ops[ii][0], tuple):; do_tests = False; for kk in range(len(c_ops[ii][0])):; _temp_state = c_ops[ii][0][kk]; _structure_check(Hdims, Htype, _temp_state); else:; raise Exception('Invalid td-list element.'); if do_tests:; _structure_check(Hdims, Htype, _temp_state). if isinstance(e_ops, list):; for ii in range(len(e_ops)):; if isinstance(e_ops[ii], Qobj):; _temp_state = e_ops[ii]; elif isinstance(e_ops[ii], list):; _temp_state = e_ops[ii][0]; else:; raise Exception('Invalid td-list element.'); _structure_check(Hdims,Htype,_temp_state); elif isinstance(e_ops, FunctionType):; pass; else:; raise Exception('Invalid e_ops specification.'). def _structure_check(Hdims, Htype, state):; if state is not None:; # Input state is a ket vector; if state.",MatchSource.WIKI,docs/4.7/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/solver.html
https://qutip.org/docs/4.7/modules/qutip/solver.html:14753,Modifiability,variab,variables,14753,"a = [] # collapse op data; self.c_ops_ind = [] # collapse op indices; self.c_ops_ptr = [] # collapse op indptrs; self.c_args = [] # store args for time-dependent collapse func. # Norm collapse operator stuff; self.n_ops_data = [] # norm collapse op data; self.n_ops_ind = [] # norm collapse op indices; self.n_ops_ptr = [] # norm collapse op indptrs. # holds executable strings for time-dependent collapse evaluation; self.col_expect_code = None; self.col_spmv_code = None. # hold stuff for function list based time dependence; self.h_td_inds = []; self.h_td_data = []; self.h_td_ind = []; self.h_td_ptr = []; self.h_funcs = None; self.h_func_args = None; self.c_funcs = None; self.c_func_args = None. # time-dependent (TD) function stuff; self.tdfunc = None # Placeholder for TD RHS function.; self.tdname = None # Name of td .pyx file; self.colspmv = None # Placeholder for TD col-spmv function.; self.colexpect = None # Placeholder for TD col_expect function.; self.string = None # Holds string of variables passed to td solver. def _format_time(t, tt=None, ttt=None):; time_str = str(datetime.timedelta(seconds=t)); if tt is not None and ttt is not None:; sect_percent = 100*t/tt; solve_percent = 100*t/ttt; time_str += "" ({:03.2f}% section, {:03.2f}% total)"".format(; sect_percent, solve_percent); elif tt is not None:; sect_percent = 100*t/tt; time_str += "" ({:03.2f}% section)"".format(sect_percent). elif ttt is not None:; solve_percent = 100*t/ttt; time_str += "" ({:03.2f}% total)"".format(solve_percent). return time_str. [docs]class Stats:; """"""; Statistical information on the solver performance; Statistics can be grouped into sections.; If no section names are given in the the contructor, then all statistics; will be added to one section 'main'. Parameters; ----------; section_names : list; list of keys that will be used as keys for the sections; These keys will also be used as names for the sections; The text in the output can be overidden by setting the header property; of the sec",MatchSource.WIKI,docs/4.7/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/solver.html
https://qutip.org/docs/4.7/modules/qutip/solver.html:28161,Modifiability,config,config,28161,"stance(c_ops[ii], list):; if isinstance(c_ops[ii][0], Qobj):; _temp_state = c_ops[ii][0]; elif isinstance(c_ops[ii][0], tuple):; do_tests = False; for kk in range(len(c_ops[ii][0])):; _temp_state = c_ops[ii][0][kk]; _structure_check(Hdims, Htype, _temp_state); else:; raise Exception('Invalid td-list element.'); if do_tests:; _structure_check(Hdims, Htype, _temp_state). if isinstance(e_ops, list):; for ii in range(len(e_ops)):; if isinstance(e_ops[ii], Qobj):; _temp_state = e_ops[ii]; elif isinstance(e_ops[ii], list):; _temp_state = e_ops[ii][0]; else:; raise Exception('Invalid td-list element.'); _structure_check(Hdims,Htype,_temp_state); elif isinstance(e_ops, FunctionType):; pass; else:; raise Exception('Invalid e_ops specification.'). def _structure_check(Hdims, Htype, state):; if state is not None:; # Input state is a ket vector; if state.type == 'ket':; # Input is Hamiltonian; if Htype == 'oper':; if Hdims[1] != state.dims[0]:; raise Exception('Input operator and ket do not '; 'share same structure.'); # Input is super and state is ket; elif Htype == 'super':; if Hdims[1][1] != state.dims[0]:; raise Exception('Input operator and ket do not '; 'share same structure.'); else:; raise Exception('Invalid input operator.'); # Input state is a density matrix; elif state.type == 'oper':; # Input is Hamiltonian and state is density matrix; if Htype == 'oper':; if Hdims[1] != state.dims[0]:; raise Exception('Input operators do not '; 'share same structure.'); # Input is super op. and state is density matrix; elif Htype == 'super':; if Hdims[1] != state.dims:; raise Exception('Input operators do not '; 'share same structure.'). #; # create a global instance of the SolverConfiguration class; #; config = SolverConfiguration(). # for backwards compatibility; Odeoptions = Options; Odedata = Result. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/solver.html
https://qutip.org/docs/4.7/modules/qutip/solver.html:12095,Performance,load,loading,12095,"expect = []; self.num_expect = 0; self.num_collapse = 0; self.ntraj = None; self.seeds = None; self.col_times = None; self.col_which = None. def __str__(self):; s = ""Result object ""; if self.solver:; s += ""with "" + self.solver + "" data.\n""; else:; s += ""missing solver information.\n""; s += ""-"" * (len(s) - 1) + ""\n""; if self.states is not None and len(self.states) > 0:; s += ""states = True\n""; elif self.expect is not None and len(self.expect) > 0:; s += ""expect = True\nnum_expect = "" + str(self.num_expect) + "", ""; else:; s += ""states = True, expect = True\n"" + \; ""num_expect = "" + str(self.num_expect) + "", ""; s += ""num_collapse = "" + str(self.num_collapse); if self.solver == 'mcsolve':; s += "", ntraj = "" + str(self.ntraj); return s. def __repr__(self):; return self.__str__(). def __getstate__(self):; # defines what happens when Qobj object gets pickled; self.__dict__.update({'qutip_version': __version__[:5]}); return self.__dict__. def __setstate__(self, state):; # defines what happens when loading a pickled Qobj; if 'qutip_version' in state.keys():; del state['qutip_version']; (self.__dict__).update(state). # %%%%%%%%%%% remove ?; [docs]class SolverConfiguration():; def __init__(self):. self.cgen_num = 0. self.reset(). def reset(self):; # General stuff; self.tlist = None # evaluations times; self.ntraj = None # number / list of trajectories; self.options = None # options for solvers; self.norm_tol = None # tolerance for wavefunction norm; self.norm_steps = None # max. number of steps to take in finding; # Initial state stuff; self.psi0 = None # initial state; self.psi0_dims = None # initial state dims; self.psi0_shape = None # initial state shape. # flags for setting time-dependence, collapse ops, and number of times; # codegen has been run; self.cflag = 0 # Flag signaling collapse operators; self.tflag = 0 # Flag signaling time-dependent problem. self.soft_reset(). def soft_reset(self):; # Hamiltonian stuff; self.h_td_inds = [] # indicies of time-dependent Hamiltoni",MatchSource.WIKI,docs/4.7/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/solver.html
https://qutip.org/docs/4.7/modules/qutip/solver.html:15345,Performance,perform,performance,15345,"]; self.h_td_ptr = []; self.h_funcs = None; self.h_func_args = None; self.c_funcs = None; self.c_func_args = None. # time-dependent (TD) function stuff; self.tdfunc = None # Placeholder for TD RHS function.; self.tdname = None # Name of td .pyx file; self.colspmv = None # Placeholder for TD col-spmv function.; self.colexpect = None # Placeholder for TD col_expect function.; self.string = None # Holds string of variables passed to td solver. def _format_time(t, tt=None, ttt=None):; time_str = str(datetime.timedelta(seconds=t)); if tt is not None and ttt is not None:; sect_percent = 100*t/tt; solve_percent = 100*t/ttt; time_str += "" ({:03.2f}% section, {:03.2f}% total)"".format(; sect_percent, solve_percent); elif tt is not None:; sect_percent = 100*t/tt; time_str += "" ({:03.2f}% section)"".format(sect_percent). elif ttt is not None:; solve_percent = 100*t/ttt; time_str += "" ({:03.2f}% total)"".format(solve_percent). return time_str. [docs]class Stats:; """"""; Statistical information on the solver performance; Statistics can be grouped into sections.; If no section names are given in the the contructor, then all statistics; will be added to one section 'main'. Parameters; ----------; section_names : list; list of keys that will be used as keys for the sections; These keys will also be used as names for the sections; The text in the output can be overidden by setting the header property; of the section; If no names are given then one section called 'main' is created. Attributes; ----------; sections : OrderedDict of _StatsSection; These are the sections that are created automatically on instantiation; or added using add_section. header : string; Some text that will be used as the heading in the report; By default there is None. total_time : float; Time in seconds for the solver to complete processing; Can be None, meaning that total timing percentages will be reported; """""". def __init__(self, section_names=None):; self._def_section_name = 'main'; self.sections = OrderedDict(",MatchSource.WIKI,docs/4.7/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/solver.html
https://qutip.org/docs/4.7/modules/qutip/solver.html:21026,Usability,clear,clear,21026,"output=sys.stdout):; """"""; Report the counts, timings and messages from the sections.; Sections are reported in the order that the names were supplied; in the constructor.; The counts, timings and messages are reported in the order that they; are added to the sections; The output can be written to anything that supports a write method,; e.g. a file or the console (default); The output is intended to in markdown format. Parameters; ----------; output : stream; file or console stream - anything that support write - where; the output will be written; """""". if not hasattr(output, 'write'):; raise TypeError(""output must have a write method""). if self.header:; output.write(""{}\n{}\n"".format(self.header,; (""=""*len(self.header)))); for name, sect in self.sections.items():; sect.report(output). if self.total_time is not None:; output.write(""\nSummary\n-------\n""); output.write(""{}\t solver total time\n"".format(; _format_time(self.total_time))). [docs] def clear(self):; """"""; Clear counts, timings and messages from all sections; """"""; for sect in self.sections.values():; sect.clear(); self.total_time = None. class _StatsSection(object):; """"""; Not intended to be directly instantiated; This is the type for the SolverStats.sections values. The method parameter descriptions are the same as for those the parent; with the same method name. Parameters; ----------; name : string; key for the parent sections dictionary; will also be used as the header. parent : `class` : SolverStats; The container for all the sections. Attributes; ----------; name : string; key for the parent sections dictionary; will also be used as the header. parent : `class` : SolverStats; The container for all the sections. header : string; Used as heading for section in report. counts : OrderedDict; The integer type statistics for the stats section. timings : OrderedDict; The timing type statistics for the stats section; Expected to contain float values representing values in seconds. messages : OrderedDict; Text typ",MatchSource.WIKI,docs/4.7/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/solver.html
https://qutip.org/docs/4.7/modules/qutip/solver.html:21146,Usability,clear,clear,21146,"Sections are reported in the order that the names were supplied; in the constructor.; The counts, timings and messages are reported in the order that they; are added to the sections; The output can be written to anything that supports a write method,; e.g. a file or the console (default); The output is intended to in markdown format. Parameters; ----------; output : stream; file or console stream - anything that support write - where; the output will be written; """""". if not hasattr(output, 'write'):; raise TypeError(""output must have a write method""). if self.header:; output.write(""{}\n{}\n"".format(self.header,; (""=""*len(self.header)))); for name, sect in self.sections.items():; sect.report(output). if self.total_time is not None:; output.write(""\nSummary\n-------\n""); output.write(""{}\t solver total time\n"".format(; _format_time(self.total_time))). [docs] def clear(self):; """"""; Clear counts, timings and messages from all sections; """"""; for sect in self.sections.values():; sect.clear(); self.total_time = None. class _StatsSection(object):; """"""; Not intended to be directly instantiated; This is the type for the SolverStats.sections values. The method parameter descriptions are the same as for those the parent; with the same method name. Parameters; ----------; name : string; key for the parent sections dictionary; will also be used as the header. parent : `class` : SolverStats; The container for all the sections. Attributes; ----------; name : string; key for the parent sections dictionary; will also be used as the header. parent : `class` : SolverStats; The container for all the sections. header : string; Used as heading for section in report. counts : OrderedDict; The integer type statistics for the stats section. timings : OrderedDict; The timing type statistics for the stats section; Expected to contain float values representing values in seconds. messages : OrderedDict; Text type output to be reported. total_time : float; Total time for processing in the section",MatchSource.WIKI,docs/4.7/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/solver.html
https://qutip.org/docs/4.7/modules/qutip/solver.html:24915,Usability,clear,clear,24915,"s section.; Note the percentage of the section and solver total times will be; given if the parent and or section total_time is set; """"""; if self.header:; output.write(""\n{}\n{}\n"".format(self.header,; (""-""*len(self.header)))). # TODO: Make the timings and counts ouput in a table format; # Generally make more pretty. # Report timings; try:; ttt = self.parent.total_time; except:; ttt = None. tt = self.total_time. output.write(""### Timings:\n""); for key, value in self.timings.items():; l = "" - {}\t{}\n"".format(_format_time(value, tt, ttt), key); output.write(l); if tt is not None:; output.write("" - {}\t{} total time\n"".format(_format_time(tt),; self.name)). # Report counts; output.write(""### Counts:\n""); for key, value in self.counts.items():; l = "" - {}\t{}\n"".format(value, key); output.write(l). # Report messages; output.write(""### Messages:\n""); for key, value in self.messages.items():; l = "" - {}:\t{}\n"".format(key, value); output.write(l). def clear(self):; """"""; Clear counts, timings and messages from this section; """"""; self.counts.clear(); self.timings.clear(); self.messages.clear(); self.total_time = None. def _solver_safety_check(H, state=None, c_ops=[], e_ops=[], args={}):; # Input is std Qobj (Hamiltonian or Liouvillian); if isinstance(H, Qobj):; Hdims = H.dims; Htype = H.type; _structure_check(Hdims, Htype, state); # Input H is function; elif isinstance(H, (FunctionType, BuiltinFunctionType)):; Hdims = H(0,args).dims; Htype = H(0,args).type; _structure_check(Hdims, Htype, state); # Input is td-list; elif isinstance(H, list):; if isinstance(H[0], Qobj):; Hdims = H[0].dims; Htype = H[0].type; elif isinstance(H[0], list):; Hdims = H[0][0].dims; Htype = H[0][0].type; elif isinstance(H[0], (FunctionType, BuiltinFunctionType)):; Hdims = H[0](0,args).dims; Htype = H[0](0,args).type; else:; raise Exception('Invalid td-list element.'); # Check all operators in list; for ii in range(len(H)):; if isinstance(H[ii], Qobj):; _temp_dims = H[ii].dims; _temp_type = H[ii].ty",MatchSource.WIKI,docs/4.7/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/solver.html
https://qutip.org/docs/4.7/modules/qutip/solver.html:25005,Usability,clear,clear,25005,"total times will be; given if the parent and or section total_time is set; """"""; if self.header:; output.write(""\n{}\n{}\n"".format(self.header,; (""-""*len(self.header)))). # TODO: Make the timings and counts ouput in a table format; # Generally make more pretty. # Report timings; try:; ttt = self.parent.total_time; except:; ttt = None. tt = self.total_time. output.write(""### Timings:\n""); for key, value in self.timings.items():; l = "" - {}\t{}\n"".format(_format_time(value, tt, ttt), key); output.write(l); if tt is not None:; output.write("" - {}\t{} total time\n"".format(_format_time(tt),; self.name)). # Report counts; output.write(""### Counts:\n""); for key, value in self.counts.items():; l = "" - {}\t{}\n"".format(value, key); output.write(l). # Report messages; output.write(""### Messages:\n""); for key, value in self.messages.items():; l = "" - {}:\t{}\n"".format(key, value); output.write(l). def clear(self):; """"""; Clear counts, timings and messages from this section; """"""; self.counts.clear(); self.timings.clear(); self.messages.clear(); self.total_time = None. def _solver_safety_check(H, state=None, c_ops=[], e_ops=[], args={}):; # Input is std Qobj (Hamiltonian or Liouvillian); if isinstance(H, Qobj):; Hdims = H.dims; Htype = H.type; _structure_check(Hdims, Htype, state); # Input H is function; elif isinstance(H, (FunctionType, BuiltinFunctionType)):; Hdims = H(0,args).dims; Htype = H(0,args).type; _structure_check(Hdims, Htype, state); # Input is td-list; elif isinstance(H, list):; if isinstance(H[0], Qobj):; Hdims = H[0].dims; Htype = H[0].type; elif isinstance(H[0], list):; Hdims = H[0][0].dims; Htype = H[0][0].type; elif isinstance(H[0], (FunctionType, BuiltinFunctionType)):; Hdims = H[0](0,args).dims; Htype = H[0](0,args).type; else:; raise Exception('Invalid td-list element.'); # Check all operators in list; for ii in range(len(H)):; if isinstance(H[ii], Qobj):; _temp_dims = H[ii].dims; _temp_type = H[ii].type; elif isinstance(H[ii], list):; _temp_dims = H[ii][0].d",MatchSource.WIKI,docs/4.7/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/solver.html
https://qutip.org/docs/4.7/modules/qutip/solver.html:25027,Usability,clear,clear,25027,"iven if the parent and or section total_time is set; """"""; if self.header:; output.write(""\n{}\n{}\n"".format(self.header,; (""-""*len(self.header)))). # TODO: Make the timings and counts ouput in a table format; # Generally make more pretty. # Report timings; try:; ttt = self.parent.total_time; except:; ttt = None. tt = self.total_time. output.write(""### Timings:\n""); for key, value in self.timings.items():; l = "" - {}\t{}\n"".format(_format_time(value, tt, ttt), key); output.write(l); if tt is not None:; output.write("" - {}\t{} total time\n"".format(_format_time(tt),; self.name)). # Report counts; output.write(""### Counts:\n""); for key, value in self.counts.items():; l = "" - {}\t{}\n"".format(value, key); output.write(l). # Report messages; output.write(""### Messages:\n""); for key, value in self.messages.items():; l = "" - {}:\t{}\n"".format(key, value); output.write(l). def clear(self):; """"""; Clear counts, timings and messages from this section; """"""; self.counts.clear(); self.timings.clear(); self.messages.clear(); self.total_time = None. def _solver_safety_check(H, state=None, c_ops=[], e_ops=[], args={}):; # Input is std Qobj (Hamiltonian or Liouvillian); if isinstance(H, Qobj):; Hdims = H.dims; Htype = H.type; _structure_check(Hdims, Htype, state); # Input H is function; elif isinstance(H, (FunctionType, BuiltinFunctionType)):; Hdims = H(0,args).dims; Htype = H(0,args).type; _structure_check(Hdims, Htype, state); # Input is td-list; elif isinstance(H, list):; if isinstance(H[0], Qobj):; Hdims = H[0].dims; Htype = H[0].type; elif isinstance(H[0], list):; Hdims = H[0][0].dims; Htype = H[0][0].type; elif isinstance(H[0], (FunctionType, BuiltinFunctionType)):; Hdims = H[0](0,args).dims; Htype = H[0](0,args).type; else:; raise Exception('Invalid td-list element.'); # Check all operators in list; for ii in range(len(H)):; if isinstance(H[ii], Qobj):; _temp_dims = H[ii].dims; _temp_type = H[ii].type; elif isinstance(H[ii], list):; _temp_dims = H[ii][0].dims; _temp_type = H[ii",MatchSource.WIKI,docs/4.7/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/solver.html
https://qutip.org/docs/4.7/modules/qutip/solver.html:25050,Usability,clear,clear,25050,"or section total_time is set; """"""; if self.header:; output.write(""\n{}\n{}\n"".format(self.header,; (""-""*len(self.header)))). # TODO: Make the timings and counts ouput in a table format; # Generally make more pretty. # Report timings; try:; ttt = self.parent.total_time; except:; ttt = None. tt = self.total_time. output.write(""### Timings:\n""); for key, value in self.timings.items():; l = "" - {}\t{}\n"".format(_format_time(value, tt, ttt), key); output.write(l); if tt is not None:; output.write("" - {}\t{} total time\n"".format(_format_time(tt),; self.name)). # Report counts; output.write(""### Counts:\n""); for key, value in self.counts.items():; l = "" - {}\t{}\n"".format(value, key); output.write(l). # Report messages; output.write(""### Messages:\n""); for key, value in self.messages.items():; l = "" - {}:\t{}\n"".format(key, value); output.write(l). def clear(self):; """"""; Clear counts, timings and messages from this section; """"""; self.counts.clear(); self.timings.clear(); self.messages.clear(); self.total_time = None. def _solver_safety_check(H, state=None, c_ops=[], e_ops=[], args={}):; # Input is std Qobj (Hamiltonian or Liouvillian); if isinstance(H, Qobj):; Hdims = H.dims; Htype = H.type; _structure_check(Hdims, Htype, state); # Input H is function; elif isinstance(H, (FunctionType, BuiltinFunctionType)):; Hdims = H(0,args).dims; Htype = H(0,args).type; _structure_check(Hdims, Htype, state); # Input is td-list; elif isinstance(H, list):; if isinstance(H[0], Qobj):; Hdims = H[0].dims; Htype = H[0].type; elif isinstance(H[0], list):; Hdims = H[0][0].dims; Htype = H[0][0].type; elif isinstance(H[0], (FunctionType, BuiltinFunctionType)):; Hdims = H[0](0,args).dims; Htype = H[0](0,args).type; else:; raise Exception('Invalid td-list element.'); # Check all operators in list; for ii in range(len(H)):; if isinstance(H[ii], Qobj):; _temp_dims = H[ii].dims; _temp_type = H[ii].type; elif isinstance(H[ii], list):; _temp_dims = H[ii][0].dims; _temp_type = H[ii][0].type; elif isinsta",MatchSource.WIKI,docs/4.7/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/solver.html
https://qutip.org/docs/4.7/modules/qutip/states.html:14467,Availability,down,down,14467,"[3]], \; shape = [3, 3], type = oper, isHerm = True; Qobj data =; [[ 0.+0.j 0.+0.j 0.+0.j]; [ 0.+0.j 0.+0.j 0.+0.j]; [ 0.+0.j 0.+0.j 1.+0.j]]. """"""; if Q.type == 'ket':; out = Q * Q.dag(); elif Q.type == 'bra':; out = Q.dag() * Q; else:; raise TypeError(""Input is not a ket or bra vector.""); return Qobj(out). #; # projection operator; #; [docs]def projection(N, n, m, offset=None):; r""""""; The projection operator that projects state :math:`\lvert m\rangle` on; state :math:`\lvert n\rangle`. Parameters; ----------; N : int; Number of basis states in Hilbert space. n, m : float; The number states in the projection. offset : int (default 0); The lowest number state that is included in the finite number state; representation of the projector. Returns; -------; oper : qobj; Requested projection operator.; """"""; ket1 = basis(N, n, offset=offset); ket2 = basis(N, m, offset=offset). return ket1 * ket2.dag(). #; # composite qubit states; #; def qstate(string):; r""""""Creates a tensor product for a set of qubits in either; the 'up' :math:`\lvert0\rangle` or 'down' :math:`\lvert1\rangle` state. Parameters; ----------; string : str; String containing 'u' or 'd' for each qubit (ex. 'ududd'). Returns; -------; qstate : qobj; Qobj for tensor product corresponding to input string. Notes; -----; Look at ket and bra for more general functions; creating multiparticle states. Examples; --------; >>> qstate('udu') # doctest: +SKIP; Quantum object: dims = [[2, 2, 2], [1, 1, 1]], shape = [8, 1], type = ket; Qobj data =; [[ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 1.]; [ 0.]; [ 0.]]; """"""; n = len(string); if n != (string.count('u') + string.count('d')):; raise TypeError('String input to QSTATE must consist ' +; 'of ""u"" and ""d"" elements only'); else:; up = basis(2, 1); dn = basis(2, 0); lst = []; for k in range(n):; if string[k] == 'u':; lst.append(up); else:; lst.append(dn); return tensor(lst). #; # different qubit notation dictionary; #; _qubit_dict = {'g': 0, # ground state; 'e': 1, # excited state; '",MatchSource.WIKI,docs/4.7/modules/qutip/states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/states.html
https://qutip.org/docs/4.7/modules/qutip/states.html:15443,Availability,down,down,15443,"et of qubits in either; the 'up' :math:`\lvert0\rangle` or 'down' :math:`\lvert1\rangle` state. Parameters; ----------; string : str; String containing 'u' or 'd' for each qubit (ex. 'ududd'). Returns; -------; qstate : qobj; Qobj for tensor product corresponding to input string. Notes; -----; Look at ket and bra for more general functions; creating multiparticle states. Examples; --------; >>> qstate('udu') # doctest: +SKIP; Quantum object: dims = [[2, 2, 2], [1, 1, 1]], shape = [8, 1], type = ket; Qobj data =; [[ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 1.]; [ 0.]; [ 0.]]; """"""; n = len(string); if n != (string.count('u') + string.count('d')):; raise TypeError('String input to QSTATE must consist ' +; 'of ""u"" and ""d"" elements only'); else:; up = basis(2, 1); dn = basis(2, 0); lst = []; for k in range(n):; if string[k] == 'u':; lst.append(up); else:; lst.append(dn); return tensor(lst). #; # different qubit notation dictionary; #; _qubit_dict = {'g': 0, # ground state; 'e': 1, # excited state; 'u': 0, # spin up; 'd': 1, # spin down; 'H': 0, # horizontal polarization; 'V': 1} # vertical polarization. def _character_to_qudit(x):; """"""; Converts a character representing a one-particle state into int.; """"""; if x in _qubit_dict:; return _qubit_dict[x]; else:; return int(x). [docs]def ket(seq, dim=2):; """"""; Produces a multiparticle ket state for a list or string,; where each element stands for state of the respective particle. Parameters; ----------; seq : str / list of ints or characters; Each element defines state of the respective particle.; (e.g. [1,1,0,1] or a string ""1101"").; For qubits it is also possible to use the following conventions:; - 'g'/'e' (ground and excited state); - 'u'/'d' (spin up and down); - 'H'/'V' (horizontal and vertical polarization); Note: for dimension > 9 you need to use a list. dim : int (default: 2) / list of ints; Space dimension for each particle:; int if there are the same, list if they are different. Returns; -------; ket : qobj. Examples; ----",MatchSource.WIKI,docs/4.7/modules/qutip/states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/states.html
https://qutip.org/docs/4.7/modules/qutip/states.html:16129,Availability,down,down,16129," ""u"" and ""d"" elements only'); else:; up = basis(2, 1); dn = basis(2, 0); lst = []; for k in range(n):; if string[k] == 'u':; lst.append(up); else:; lst.append(dn); return tensor(lst). #; # different qubit notation dictionary; #; _qubit_dict = {'g': 0, # ground state; 'e': 1, # excited state; 'u': 0, # spin up; 'd': 1, # spin down; 'H': 0, # horizontal polarization; 'V': 1} # vertical polarization. def _character_to_qudit(x):; """"""; Converts a character representing a one-particle state into int.; """"""; if x in _qubit_dict:; return _qubit_dict[x]; else:; return int(x). [docs]def ket(seq, dim=2):; """"""; Produces a multiparticle ket state for a list or string,; where each element stands for state of the respective particle. Parameters; ----------; seq : str / list of ints or characters; Each element defines state of the respective particle.; (e.g. [1,1,0,1] or a string ""1101"").; For qubits it is also possible to use the following conventions:; - 'g'/'e' (ground and excited state); - 'u'/'d' (spin up and down); - 'H'/'V' (horizontal and vertical polarization); Note: for dimension > 9 you need to use a list. dim : int (default: 2) / list of ints; Space dimension for each particle:; int if there are the same, list if they are different. Returns; -------; ket : qobj. Examples; --------; >>> ket(""10"") # doctest: +SKIP; Quantum object: dims = [[2, 2], [1, 1]], shape = [4, 1], type = ket; Qobj data =; [[ 0.]; [ 0.]; [ 1.]; [ 0.]]. >>> ket(""Hue"") # doctest: +SKIP; Quantum object: dims = [[2, 2, 2], [1, 1, 1]], shape = [8, 1], type = ket; Qobj data =; [[ 0.]; [ 1.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]]. >>> ket(""12"", 3) # doctest: +SKIP; Quantum object: dims = [[3, 3], [1, 1]], shape = [9, 1], type = ket; Qobj data =; [[ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 1.]; [ 0.]; [ 0.]; [ 0.]]. >>> ket(""31"", [5, 2]) # doctest: +SKIP; Quantum object: dims = [[5, 2], [1, 1]], shape = [10, 1], type = ket; Qobj data =; [[ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 1.]; [ 0.]; [ 0.]]; """"""",MatchSource.WIKI,docs/4.7/modules/qutip/states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/states.html
https://qutip.org/docs/4.7/modules/qutip/states.html:17693,Availability,down,down,17693,".]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]]. >>> ket(""12"", 3) # doctest: +SKIP; Quantum object: dims = [[3, 3], [1, 1]], shape = [9, 1], type = ket; Qobj data =; [[ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 1.]; [ 0.]; [ 0.]; [ 0.]]. >>> ket(""31"", [5, 2]) # doctest: +SKIP; Quantum object: dims = [[5, 2], [1, 1]], shape = [10, 1], type = ket; Qobj data =; [[ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 1.]; [ 0.]; [ 0.]]; """"""; if isinstance(dim, int):; dim = [dim] * len(seq); return tensor([basis(dim[i], _character_to_qudit(x)); for i, x in enumerate(seq)]). [docs]def bra(seq, dim=2):; """"""; Produces a multiparticle bra state for a list or string,; where each element stands for state of the respective particle. Parameters; ----------; seq : str / list of ints or characters; Each element defines state of the respective particle.; (e.g. [1,1,0,1] or a string ""1101"").; For qubits it is also possible to use the following conventions:. - 'g'/'e' (ground and excited state); - 'u'/'d' (spin up and down); - 'H'/'V' (horizontal and vertical polarization). Note: for dimension > 9 you need to use a list. dim : int (default: 2) / list of ints; Space dimension for each particle:; int if there are the same, list if they are different. Returns; -------; bra : qobj. Examples; --------; >>> bra(""10"") # doctest: +SKIP; Quantum object: dims = [[1, 1], [2, 2]], shape = [1, 4], type = bra; Qobj data =; [[ 0. 0. 1. 0.]]. >>> bra(""Hue"") # doctest: +SKIP; Quantum object: dims = [[1, 1, 1], [2, 2, 2]], shape = [1, 8], type = bra; Qobj data =; [[ 0. 1. 0. 0. 0. 0. 0. 0.]]. >>> bra(""12"", 3) # doctest: +SKIP; Quantum object: dims = [[1, 1], [3, 3]], shape = [1, 9], type = bra; Qobj data =; [[ 0. 0. 0. 0. 0. 1. 0. 0. 0.]]. >>> bra(""31"", [5, 2]) # doctest: +SKIP; Quantum object: dims = [[1, 1], [5, 2]], shape = [1, 10], type = bra; Qobj data =; [[ 0. 0. 0. 0. 0. 0. 0. 1. 0. 0.]]; """"""; return ket(seq, dim=dim).dag(). #; # quantum state number helper functions; #; [docs]def state_number_enumerate(dim",MatchSource.WIKI,docs/4.7/modules/qutip/states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/states.html
https://qutip.org/docs/4.7/modules/qutip/states.html:30603,Deployability,update,updated,30603,", basis(2))-tensor(basis(2, 1), basis(2, 1)); elif state == '10':; Bell_state = tensor(; basis(2), basis(2, 1))+tensor(basis(2, 1), basis(2)); elif state == '11':; Bell_state = tensor(; basis(2), basis(2, 1))-tensor(basis(2, 1), basis(2)). return Bell_state.unit(). [docs]def singlet_state():; r""""""; Returns the two particle singlet-state:. .. math::. \lvert S\rangle = \frac1{\sqrt2}(\lvert01\rangle-\lvert10\rangle). that is identical to the fourth bell state. Returns; -------; Bell_state : qobj; :math:`\lvert B_{11}\rangle` Bell state; """"""; return bell_state('11'). [docs]def triplet_states():; r""""""; Returns a list of the two particle triplet-states:. .. math::. \lvert T_1\rangle = \lvert11\rangle; \lvert T_2\rangle = \frac1{\sqrt2}(\lvert01\rangle + \lvert10\rangle); \lvert T_3\rangle = \lvert00\rangle. Returns; -------; trip_states : list; 2 particle triplet states. """"""; trip_states = []; trip_states.append(tensor(basis(2, 1), basis(2, 1))); trip_states.append(; (tensor(basis(2), basis(2, 1)) + tensor(basis(2, 1), basis(2))).unit(); ); trip_states.append(tensor(basis(2), basis(2))); return trip_states. [docs]def w_state(N=3):; """"""; Returns the N-qubit W-state. Parameters; ----------; N : int (default=3); Number of qubits in state. Returns; -------; W : qobj; N-qubit W-state. """"""; inds = np.zeros(N, dtype=int); inds[0] = 1; state = tensor([basis(2, x) for x in inds]); for kk in range(1, N):; perm_inds = np.roll(inds, kk); state += tensor([basis(2, x) for x in perm_inds]); return state.unit(). [docs]def ghz_state(N=3):; """"""; Returns the N-qubit GHZ-state. Parameters; ----------; N : int (default=3); Number of qubits in state. Returns; -------; G : qobj; N-qubit GHZ-state. """"""; state = (tensor([basis(2) for k in range(N)]) +; tensor([basis(2, 1) for k in range(N)])); return state/np.sqrt(2). © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/modules/qutip/states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/states.html
https://qutip.org/docs/4.7/modules/qutip/states.html:19814,Safety,avoid,avoid,19814,"n2, n3, ...)) for a system with dimensions given by dims. Example:. >>> for state in state_number_enumerate([2,2]): # doctest: +SKIP; >>> print(state) # doctest: +SKIP; ( 0 0 ); ( 0 1 ); ( 1 0 ); ( 1 1 ). Parameters; ----------; dims : list or array; The quantum state dimensions array, as it would appear in a Qobj. excitations : integer (None); Restrict state space to states with excitation numbers below or; equal to this value. Returns; -------; state_number : tuple; Successive state number tuples that can be used in loops and other; iterations, using standard state enumeration *by definition*. """""". if excitations is None:; # in this case, state numbers are a direct product; yield from itertools.product(*(range(d) for d in dims)); return. # From here on, excitations is not None. # General idea of algorithm: add excitations one by one in last mode (idx =; # len(dims)-1), and carry over to the next index when the limit is reached.; # Keep track of the number of excitations while doing so to avoid having to; # do explicit sums over the states.; state = (0,)*len(dims); nexc = 0; while True:; yield state; idx = len(dims) - 1; state = state[:idx] + (state[idx]+1,); nexc += 1; while nexc > excitations or state[idx] >= dims[idx]:; # remove all excitations in mode idx, add one in idx-1; idx -= 1; if idx < 0:; return; nexc -= state[idx+1] - 1; state = state[:idx] + (state[idx]+1, 0) + state[idx+2:]. [docs]def state_number_index(dims, state):; """"""; Return the index of a quantum state corresponding to state,; given a system with dimensions given by dims. Example:. >>> state_number_index([2, 2, 2], [1, 1, 0]); 6. Parameters; ----------; dims : list or array; The quantum state dimensions array, as it would appear in a Qobj. state : list; State number array. Returns; -------; idx : int; The index of the state given by `state` in standard enumeration; ordering. """"""; return np.ravel_multi_index(state, dims). [docs]def state_index_number(dims, index):; """"""; Return a quantum number r",MatchSource.WIKI,docs/4.7/modules/qutip/states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/states.html
https://qutip.org/docs/4.7/modules/qutip/states.html:3131,Testability,log,logic,3131,"ted. The shape must match ``dimensions``, e.g. if; ``dimensions`` is a list, then ``n`` must either be omitted or a list; of equal length. offset : int or list of ints, optional (default 0 for all dimensions); The lowest number state that is included in the finite number state; representation of the state in the relevant dimension. Returns; -------; state : :class:`qutip.Qobj`; Qobj representing the requested number state ``|n>``. Examples; --------; >>> basis(5,2) # doctest: +SKIP; Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[ 0.+0.j]; [ 0.+0.j]; [ 1.+0.j]; [ 0.+0.j]; [ 0.+0.j]]; >>> basis([2,2,2], [0,1,0]) # doctest: +SKIP; Quantum object: dims = [[2, 2, 2], [1, 1, 1]], shape = (8, 1), type = ket; Qobj data =; [[0.]; [0.]; [1.]; [0.]; [0.]; [0.]; [0.]; [0.]]. Notes; -----; A subtle incompatibility with the quantum optics toolbox: In QuTiP::. basis(N, 0) = ground state. but in the qotoolbox::. basis(N, 1) = ground state. """"""; # Promote all parameters to lists to simplify later logic.; if not isinstance(dimensions, list):; dimensions = [dimensions]; n_dimensions = len(dimensions); ns = [m-off for m, off in zip(_promote_to_zero_list(n, n_dimensions),; _promote_to_zero_list(offset, n_dimensions))]; if any((not isinstance(x, numbers.Integral)) or x < 0 for x in dimensions):; raise ValueError(""All dimensions must be >= 0.""); if not all(0 <= n < dimension for n, dimension in zip(ns, dimensions)):; raise ValueError(""All basis indices must be ""; ""`offset <= n < dimension+offset`.""); location, size = 0, 1; for m, dimension in zip(reversed(ns), reversed(dimensions)):; location += m*size; size *= dimension; data = np.array([1], dtype=complex); ind = np.array([0], dtype=np.int32); ptr = np.array([0]*(location+1) + [1]*(size-location), dtype=np.int32); return Qobj(fast_csr_matrix((data, ind, ptr), shape=(size, 1)),; dims=[dimensions, [1]*n_dimensions], isherm=False). [docs]def qutrit_basis():; """"""Basis states for a three level system (qutrit). R",MatchSource.WIKI,docs/4.7/modules/qutip/states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/states.html
https://qutip.org/docs/4.7/modules/qutip/states.html:12132,Testability,log,log,12132,"-------; >>> thermal_dm(5, 1) # doctest: +SKIP; Quantum object: dims = [[5], [5]], \; shape = [5, 5], type = oper, isHerm = True; Qobj data =; [[ 0.51612903 0. 0. 0. 0. ]; [ 0. 0.25806452 0. 0. 0. ]; [ 0. 0. 0.12903226 0. 0. ]; [ 0. 0. 0. 0.06451613 0. ]; [ 0. 0. 0. 0. 0.03225806]]. >>> thermal_dm(5, 1, 'analytic') # doctest: +SKIP; Quantum object: dims = [[5], [5]], \; shape = [5, 5], type = oper, isHerm = True; Qobj data =; [[ 0.5 0. 0. 0. 0. ]; [ 0. 0.25 0. 0. 0. ]; [ 0. 0. 0.125 0. 0. ]; [ 0. 0. 0. 0.0625 0. ]; [ 0. 0. 0. 0. 0.03125]]. Notes; -----; The 'operator' method (default) generates; the thermal state using the truncated number operator ``num(N)``. This; is the method that should be used in computations. The; 'analytic' method uses the analytic coefficients derived in; an infinite Hilbert space. The analytic form is not necessarily normalized,; if truncated too aggressively. """"""; if n == 0:; return fock_dm(N, 0); else:; i = arange(N); if method == 'operator':; beta = np.log(1.0 / n + 1.0); diags = np.exp(-beta * i); diags = diags / np.sum(diags); # populates diagonal terms using truncated operator expression; rm = sp.spdiags(diags, 0, N, N, format='csr'); elif method == 'analytic':; # populates diagonal terms using analytic values; rm = sp.spdiags((1.0 + n) ** (-1.0) * (n / (1.0 + n)) ** (i),; 0, N, N, format='csr'); else:; raise ValueError(""The method option can only take ""; ""values 'operator' or 'analytic'""); return Qobj(rm). [docs]def maximally_mixed_dm(N):; """"""; Returns the maximally mixed density matrix for a Hilbert space of; dimension N. Parameters; ----------; N : int; Number of basis states in Hilbert space. Returns; -------; dm : qobj; Thermal state density matrix.; """"""; if (not isinstance(N, (int, np.int64))) or N <= 0:; raise ValueError(""N must be integer N > 0""). dm = sp.spdiags(np.ones(N, dtype=complex)/float(N), 0, N, N, format='csr'). return Qobj(dm, isherm=True). [docs]def ket2dm(Q):; """"""Takes input ket or bra vector and returns density ",MatchSource.WIKI,docs/4.7/modules/qutip/states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/states.html
https://qutip.org/docs/4.7/modules/qutip/states.html:21907,Testability,assert,assert,21907,", 1, 0]. Parameters; ----------; dims : list or array; The quantum state dimensions array, as it would appear in a Qobj. index : integer; The index of the state in standard enumeration ordering. Returns; -------; state : tuple; The state number tuple corresponding to index `index` in standard; enumeration ordering. """"""; return np.unravel_index(index, dims). [docs]def state_number_qobj(dims, state):; """"""; Return a Qobj representation of a quantum state specified by the state; array `state`. Example:. >>> state_number_qobj([2, 2, 2], [1, 0, 1]) # doctest: +SKIP; Quantum object: dims = [[2, 2, 2], [1, 1, 1]], \; shape = [8, 1], type = ket; Qobj data =; [[ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 1.]; [ 0.]; [ 0.]]. Parameters; ----------; dims : list or array; The quantum state dimensions array, as it would appear in a Qobj. state : list; State number array. Returns; -------; state : :class:`qutip.Qobj`; The state as a :class:`qutip.Qobj` instance. """"""; assert len(state) == len(dims); return tensor([fock(d, s) for d, s in zip(dims, state)]). #; # Excitation-number restricted (enr) states; #; [docs]def enr_state_dictionaries(dims, excitations):; """"""; Return the number of states, and lookup-dictionaries for translating; a state tuple to a state index, and vice versa, for a system with a given; number of components and maximum number of excitations. Parameters; ----------; dims: list; A list with the number of states in each sub-system. excitations : integer; The maximum numbers of dimension. Returns; -------; nstates, state2idx, idx2state: integer, dict, list; The number of states `nstates`, a dictionary for looking up state; indices from a state tuple, and a list containing the state tuples; ordered by state indices. state2idx and idx2state are reverses of; each other, i.e., state2idx[idx2state[idx]] = idx and; idx2state[state2idx[state]] = state.; """"""; idx2state = list(state_number_enumerate(dims, excitations)); state2idx = {state: idx for idx, state in enumerate(idx2state)};",MatchSource.WIKI,docs/4.7/modules/qutip/states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/states.html
https://qutip.org/docs/4.7/modules/qutip/states.html:3116,Usability,simpl,simplify,3116,"ted. The shape must match ``dimensions``, e.g. if; ``dimensions`` is a list, then ``n`` must either be omitted or a list; of equal length. offset : int or list of ints, optional (default 0 for all dimensions); The lowest number state that is included in the finite number state; representation of the state in the relevant dimension. Returns; -------; state : :class:`qutip.Qobj`; Qobj representing the requested number state ``|n>``. Examples; --------; >>> basis(5,2) # doctest: +SKIP; Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[ 0.+0.j]; [ 0.+0.j]; [ 1.+0.j]; [ 0.+0.j]; [ 0.+0.j]]; >>> basis([2,2,2], [0,1,0]) # doctest: +SKIP; Quantum object: dims = [[2, 2, 2], [1, 1, 1]], shape = (8, 1), type = ket; Qobj data =; [[0.]; [0.]; [1.]; [0.]; [0.]; [0.]; [0.]; [0.]]. Notes; -----; A subtle incompatibility with the quantum optics toolbox: In QuTiP::. basis(N, 0) = ground state. but in the qotoolbox::. basis(N, 1) = ground state. """"""; # Promote all parameters to lists to simplify later logic.; if not isinstance(dimensions, list):; dimensions = [dimensions]; n_dimensions = len(dimensions); ns = [m-off for m, off in zip(_promote_to_zero_list(n, n_dimensions),; _promote_to_zero_list(offset, n_dimensions))]; if any((not isinstance(x, numbers.Integral)) or x < 0 for x in dimensions):; raise ValueError(""All dimensions must be >= 0.""); if not all(0 <= n < dimension for n, dimension in zip(ns, dimensions)):; raise ValueError(""All basis indices must be ""; ""`offset <= n < dimension+offset`.""); location, size = 0, 1; for m, dimension in zip(reversed(ns), reversed(dimensions)):; location += m*size; size *= dimension; data = np.array([1], dtype=complex); ind = np.array([0], dtype=np.int32); ptr = np.array([0]*(location+1) + [1]*(size-location), dtype=np.int32); return Qobj(fast_csr_matrix((data, ind, ptr), shape=(size, 1)),; dims=[dimensions, [1]*n_dimensions], isherm=False). [docs]def qutrit_basis():; """"""Basis states for a three level system (qutrit). R",MatchSource.WIKI,docs/4.7/modules/qutip/states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/states.html
https://qutip.org/docs/4.7/modules/qutip/steadystate.html:4748,Availability,avail,availability,4748,"diag_pivot_thresh': 0.1, 'maxiter': 1000,; 'permc_spec': 'COLAMD', 'ILU_MILU': 'smilu_2',; 'restart': 20,; 'max_iter_refine': 10,; 'scaling_vectors': True,; 'weighted_matching': True,; 'return_info': False, 'info': _empty_info_dict(),; 'verbose': False, 'solver': 'scipy', 'weight': None,; 'tol': 1e-12, 'matol': 1e-15, 'mtol': None}; return def_args. [docs]def steadystate(A, c_op_list=[], method='direct', solver=None, **kwargs):; """"""; Calculates the steady state for quantum evolution subject to the supplied; Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a list of; collapse operators. If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters; ----------; A : :obj:`~qutip.Qobj`; A Hamiltonian or Liouvillian operator. c_op_list : list; A list of collapse operators. solver : {'scipy', 'mkl'}, optional; Selects the sparse solver to use. Default is to auto-select based on; the availability of the MKL library. method : str, default 'direct'; The allowed methods are. - 'direct'; - 'eigen'; - 'iterative-gmres'; - 'iterative-lgmres'; - 'iterative-bicgstab'; - 'svd'; - 'power'; - 'power-gmres'; - 'power-lgmres'; - 'power-bicgstab'. Method for solving the underlying linear equation. Direct LU solver; 'direct' (default), sparse eigenvalue problem 'eigen', iterative GMRES; method 'iterative-gmres', iterative LGMRES method 'iterative-lgmres',; iterative BICGSTAB method 'iterative-bicgstab', SVD 'svd' (dense), or; inverse-power method 'power'. The iterative power methods; 'power-gmres', 'power-lgmres', 'power-bicgstab' use the same solvers as; their direct counterparts. return_info : bool, default False; Return a dictionary of solver-specific infomation about the solution; and how it was obtained. sparse : bool, default True; Solve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; ma",MatchSource.WIKI,docs/4.7/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/steadystate.html
https://qutip.org/docs/4.7/modules/qutip/steadystate.html:7069,Availability,toler,tolerance,7069,"; only, and is set to ``True`` by default when finding a preconditioner. weight : float, optional; Sets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user. max_iter_refine : int, default 10; MKL ONLY. Max. number of iterative refinements to perform. scaling_vectors : bool; MKL ONLY. Scale matrix to unit norm columns and rows. weighted_matching : bool; MKL ONLY. Use weighted matching to better condition diagonal. x0 : ndarray, optional; ITERATIVE ONLY. Initial guess for solution vector. maxiter : int, default 1000; ITERATIVE ONLY. Maximum number of iterations to perform. tol : float, default 1e-12; ITERATIVE ONLY. Tolerance used for terminating solver. mtol : float, optional; ITERATIVE 'power' methods ONLY. Tolerance for lu solve method. If None; given then ``max(0.1*tol, 1e-15)`` is used. matol : float, default 1e-15; ITERATIVE ONLY. Absolute tolerance for lu solve method. permc_spec : str, optional; ITERATIVE ONLY. Column ordering used internally by superLU for the; 'direct' LU decomposition method. Options include 'COLAMD' (default); and 'NATURAL'. If using RCM then this is set to 'NATURAL' automatically; unless explicitly specified. use_precond : bool, default False; ITERATIVE ONLY. Use an incomplete sparse LU decomposition as a; preconditioner for the 'iterative' GMRES and BICG solvers. Speeds up; convergence time by orders of magnitude in many cases. M : {sparse matrix, dense matrix, LinearOperator}, optional; ITERATIVE ONLY. Preconditioner for A. The preconditioner should; approximate the inverse of A. Effective preconditioning can; dramatically improve the rate of convergence for iterative methods.; If no preconditioner is given and ``use_precond = True``, then one; is generated automatically. fill_factor : float, default 100; ITERATIVE ONLY. Specifies the fill ratio upper bound (>=1) of the iLU; preconditioner. Lower values s",MatchSource.WIKI,docs/4.7/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/steadystate.html
https://qutip.org/docs/4.7/modules/qutip/steadystate.html:22330,Availability,error,error,22330," M=ss_args['M'], x0=ss_args['x0'],; maxiter=ss_args['maxiter'],; callback=_iter_count); elif ss_args['method'] == 'iterative-bicgstab':; v, check = bicgstab(L, b, tol=ss_args['tol'],; atol=ss_args['matol'],; M=ss_args['M'], x0=ss_args['x0'],; maxiter=ss_args['maxiter'],; callback=_iter_count); else:; raise Exception(""Invalid iterative solver method.""); _iter_end = time.time(). ss_args['info']['iter_time'] = _iter_end - _iter_start; if 'precond_time' in ss_args['info'].keys():; ss_args['info']['solution_time'] = (ss_args['info']['iter_time'] +; ss_args['info']['precond_time']); else:; ss_args['info']['solution_time'] = ss_args['info']['iter_time']; ss_args['info']['iterations'] = ss_iters['iter']; if ss_args['return_info']:; ss_args['info']['residual_norm'] = la.norm(b - L*v, np.inf). if settings.debug:; logger.debug('Number of Iterations: %i' % ss_iters['iter']); logger.debug('Iteration. time: %f' % (_iter_end - _iter_start)). if check > 0:; raise Exception(""Steadystate error: Did not reach tolerance after "" +; str(ss_args['maxiter']) + "" steps."" +; ""\nResidual norm: "" +; str(ss_args['info']['residual_norm'])). elif check < 0:; raise Exception(; ""Steadystate error: Failed with fatal error: "" + str(check) + "".""). if ss_args['use_rcm']:; v = v[np.ix_(rev_perm,)]. data = vec2mat(v); data = 0.5 * (data + data.conj().T); if ss_args['return_info']:; return Qobj(data, dims=dims, isherm=True), ss_args['info']; else:; return Qobj(data, dims=dims, isherm=True). def _steadystate_svd_dense(L, ss_args):; """"""; Find the steady state(s) of an open quantum system by solving for the; nullspace of the Liouvillian.; """"""; ss_args['info'].pop('weight', None); atol = 1e-12; rtol = 1e-12; if settings.debug:; logger.debug('Starting SVD solver.'); _svd_start = time.time(); u, s, vh = svd(L.full(), full_matrices=False); tol = max(atol, rtol * s[0]); nnz = (s >= tol).sum(); ns = vh[nnz:].conj().T; _svd_end = time.time(); ss_args['info']['solution_time'] = _svd_end-_svd_start; if ss_args['all_st",MatchSource.WIKI,docs/4.7/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/steadystate.html
https://qutip.org/docs/4.7/modules/qutip/steadystate.html:22351,Availability,toler,tolerance,22351," M=ss_args['M'], x0=ss_args['x0'],; maxiter=ss_args['maxiter'],; callback=_iter_count); elif ss_args['method'] == 'iterative-bicgstab':; v, check = bicgstab(L, b, tol=ss_args['tol'],; atol=ss_args['matol'],; M=ss_args['M'], x0=ss_args['x0'],; maxiter=ss_args['maxiter'],; callback=_iter_count); else:; raise Exception(""Invalid iterative solver method.""); _iter_end = time.time(). ss_args['info']['iter_time'] = _iter_end - _iter_start; if 'precond_time' in ss_args['info'].keys():; ss_args['info']['solution_time'] = (ss_args['info']['iter_time'] +; ss_args['info']['precond_time']); else:; ss_args['info']['solution_time'] = ss_args['info']['iter_time']; ss_args['info']['iterations'] = ss_iters['iter']; if ss_args['return_info']:; ss_args['info']['residual_norm'] = la.norm(b - L*v, np.inf). if settings.debug:; logger.debug('Number of Iterations: %i' % ss_iters['iter']); logger.debug('Iteration. time: %f' % (_iter_end - _iter_start)). if check > 0:; raise Exception(""Steadystate error: Did not reach tolerance after "" +; str(ss_args['maxiter']) + "" steps."" +; ""\nResidual norm: "" +; str(ss_args['info']['residual_norm'])). elif check < 0:; raise Exception(; ""Steadystate error: Failed with fatal error: "" + str(check) + "".""). if ss_args['use_rcm']:; v = v[np.ix_(rev_perm,)]. data = vec2mat(v); data = 0.5 * (data + data.conj().T); if ss_args['return_info']:; return Qobj(data, dims=dims, isherm=True), ss_args['info']; else:; return Qobj(data, dims=dims, isherm=True). def _steadystate_svd_dense(L, ss_args):; """"""; Find the steady state(s) of an open quantum system by solving for the; nullspace of the Liouvillian.; """"""; ss_args['info'].pop('weight', None); atol = 1e-12; rtol = 1e-12; if settings.debug:; logger.debug('Starting SVD solver.'); _svd_start = time.time(); u, s, vh = svd(L.full(), full_matrices=False); tol = max(atol, rtol * s[0]); nnz = (s >= tol).sum(); ns = vh[nnz:].conj().T; _svd_end = time.time(); ss_args['info']['solution_time'] = _svd_end-_svd_start; if ss_args['all_st",MatchSource.WIKI,docs/4.7/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/steadystate.html
https://qutip.org/docs/4.7/modules/qutip/steadystate.html:22522,Availability,error,error,22522,"l'],; atol=ss_args['matol'],; M=ss_args['M'], x0=ss_args['x0'],; maxiter=ss_args['maxiter'],; callback=_iter_count); else:; raise Exception(""Invalid iterative solver method.""); _iter_end = time.time(). ss_args['info']['iter_time'] = _iter_end - _iter_start; if 'precond_time' in ss_args['info'].keys():; ss_args['info']['solution_time'] = (ss_args['info']['iter_time'] +; ss_args['info']['precond_time']); else:; ss_args['info']['solution_time'] = ss_args['info']['iter_time']; ss_args['info']['iterations'] = ss_iters['iter']; if ss_args['return_info']:; ss_args['info']['residual_norm'] = la.norm(b - L*v, np.inf). if settings.debug:; logger.debug('Number of Iterations: %i' % ss_iters['iter']); logger.debug('Iteration. time: %f' % (_iter_end - _iter_start)). if check > 0:; raise Exception(""Steadystate error: Did not reach tolerance after "" +; str(ss_args['maxiter']) + "" steps."" +; ""\nResidual norm: "" +; str(ss_args['info']['residual_norm'])). elif check < 0:; raise Exception(; ""Steadystate error: Failed with fatal error: "" + str(check) + "".""). if ss_args['use_rcm']:; v = v[np.ix_(rev_perm,)]. data = vec2mat(v); data = 0.5 * (data + data.conj().T); if ss_args['return_info']:; return Qobj(data, dims=dims, isherm=True), ss_args['info']; else:; return Qobj(data, dims=dims, isherm=True). def _steadystate_svd_dense(L, ss_args):; """"""; Find the steady state(s) of an open quantum system by solving for the; nullspace of the Liouvillian.; """"""; ss_args['info'].pop('weight', None); atol = 1e-12; rtol = 1e-12; if settings.debug:; logger.debug('Starting SVD solver.'); _svd_start = time.time(); u, s, vh = svd(L.full(), full_matrices=False); tol = max(atol, rtol * s[0]); nnz = (s >= tol).sum(); ns = vh[nnz:].conj().T; _svd_end = time.time(); ss_args['info']['solution_time'] = _svd_end-_svd_start; if ss_args['all_states']:; rhoss_list = []; for n in range(ns.shape[1]):; rhoss = Qobj(vec2mat(ns[:, n]), dims=L.dims[0]); rhoss_list.append(rhoss / rhoss.tr()); if ss_args['return_info']:; retur",MatchSource.WIKI,docs/4.7/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/steadystate.html
https://qutip.org/docs/4.7/modules/qutip/steadystate.html:22547,Availability,error,error,22547,"l'],; atol=ss_args['matol'],; M=ss_args['M'], x0=ss_args['x0'],; maxiter=ss_args['maxiter'],; callback=_iter_count); else:; raise Exception(""Invalid iterative solver method.""); _iter_end = time.time(). ss_args['info']['iter_time'] = _iter_end - _iter_start; if 'precond_time' in ss_args['info'].keys():; ss_args['info']['solution_time'] = (ss_args['info']['iter_time'] +; ss_args['info']['precond_time']); else:; ss_args['info']['solution_time'] = ss_args['info']['iter_time']; ss_args['info']['iterations'] = ss_iters['iter']; if ss_args['return_info']:; ss_args['info']['residual_norm'] = la.norm(b - L*v, np.inf). if settings.debug:; logger.debug('Number of Iterations: %i' % ss_iters['iter']); logger.debug('Iteration. time: %f' % (_iter_end - _iter_start)). if check > 0:; raise Exception(""Steadystate error: Did not reach tolerance after "" +; str(ss_args['maxiter']) + "" steps."" +; ""\nResidual norm: "" +; str(ss_args['info']['residual_norm'])). elif check < 0:; raise Exception(; ""Steadystate error: Failed with fatal error: "" + str(check) + "".""). if ss_args['use_rcm']:; v = v[np.ix_(rev_perm,)]. data = vec2mat(v); data = 0.5 * (data + data.conj().T); if ss_args['return_info']:; return Qobj(data, dims=dims, isherm=True), ss_args['info']; else:; return Qobj(data, dims=dims, isherm=True). def _steadystate_svd_dense(L, ss_args):; """"""; Find the steady state(s) of an open quantum system by solving for the; nullspace of the Liouvillian.; """"""; ss_args['info'].pop('weight', None); atol = 1e-12; rtol = 1e-12; if settings.debug:; logger.debug('Starting SVD solver.'); _svd_start = time.time(); u, s, vh = svd(L.full(), full_matrices=False); tol = max(atol, rtol * s[0]); nnz = (s >= tol).sum(); ns = vh[nnz:].conj().T; _svd_end = time.time(); ss_args['info']['solution_time'] = _svd_end-_svd_start; if ss_args['all_states']:; rhoss_list = []; for n in range(ns.shape[1]):; rhoss = Qobj(vec2mat(ns[:, n]), dims=L.dims[0]); rhoss_list.append(rhoss / rhoss.tr()); if ss_args['return_info']:; retur",MatchSource.WIKI,docs/4.7/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/steadystate.html
https://qutip.org/docs/4.7/modules/qutip/steadystate.html:39983,Availability,avail,available,39983,"e, for the Liouvillian; superoperator L. w : double; frequency at which to evaluate pseudo-inverse. Can be zero for dense; systems and large sparse systems. Small sparse systems can fail for; zero frequencies. sparse : bool; Flag that indicate whether to use sparse or dense matrix methods when; computing the pseudo inverse. method : string; Name of method to use. For sparse=True, allowed values are 'spsolve',; 'splu' and 'spilu'. For sparse=False, allowed values are 'direct' and; 'numpy'. kwargs : dictionary; Additional keyword arguments for setting parameters for solver methods. Returns; -------; R : Qobj; Returns a Qobj instance representing the pseudo inverse of L. Note; ----; In general the inverse of a sparse matrix will be dense. If you; are applying the inverse to a density matrix then it is better to; cast the problem as an Ax=b type problem where the explicit calculation; of the inverse is not required. See page 67 of ""Electrons in; nanostructures"" C. Flindt, PhD Thesis available online:; https://orbit.dtu.dk/fedora/objects/orbit:82314/datastreams/; file_4732600/content. Note also that the definition of the pseudo-inverse herein is different; from numpys pinv() alone, as it includes pre and post projection onto; the subspace defined by the projector Q. """"""; pseudo_args = _default_steadystate_args(); for key in kwargs.keys():; if key in pseudo_args.keys():; pseudo_args[key] = kwargs[key]; else:; raise TypeError(; ""Invalid keyword argument '""+key+""' passed to pseudo_inverse.""); pseudo_args['method'] = method. # Set column perm to NATURAL if using RCM and not specified by user; if pseudo_args['use_rcm'] and ('permc_spec' not in kwargs.keys()):; pseudo_args['permc_spec'] = 'NATURAL'. if rhoss is None:; rhoss = steadystate(L, **pseudo_args). if sparse:; return _pseudo_inverse_sparse(L, rhoss, w=w, **pseudo_args); else:; if pseudo_args['method'] != 'splu':; pseudo_args['method'] = pseudo_args['method']; else:; pseudo_args['method'] = 'direct'; return _pseudo_inver",MatchSource.WIKI,docs/4.7/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/steadystate.html
https://qutip.org/docs/4.7/modules/qutip/steadystate.html:41109,Deployability,update,updated,41109,"ol; Flag that indicate whether to use sparse or dense matrix methods when; computing the pseudo inverse. method : string; Name of method to use. For sparse=True, allowed values are 'spsolve',; 'splu' and 'spilu'. For sparse=False, allowed values are 'direct' and; 'numpy'. kwargs : dictionary; Additional keyword arguments for setting parameters for solver methods. Returns; -------; R : Qobj; Returns a Qobj instance representing the pseudo inverse of L. Note; ----; In general the inverse of a sparse matrix will be dense. If you; are applying the inverse to a density matrix then it is better to; cast the problem as an Ax=b type problem where the explicit calculation; of the inverse is not required. See page 67 of ""Electrons in; nanostructures"" C. Flindt, PhD Thesis available online:; https://orbit.dtu.dk/fedora/objects/orbit:82314/datastreams/; file_4732600/content. Note also that the definition of the pseudo-inverse herein is different; from numpys pinv() alone, as it includes pre and post projection onto; the subspace defined by the projector Q. """"""; pseudo_args = _default_steadystate_args(); for key in kwargs.keys():; if key in pseudo_args.keys():; pseudo_args[key] = kwargs[key]; else:; raise TypeError(; ""Invalid keyword argument '""+key+""' passed to pseudo_inverse.""); pseudo_args['method'] = method. # Set column perm to NATURAL if using RCM and not specified by user; if pseudo_args['use_rcm'] and ('permc_spec' not in kwargs.keys()):; pseudo_args['permc_spec'] = 'NATURAL'. if rhoss is None:; rhoss = steadystate(L, **pseudo_args). if sparse:; return _pseudo_inverse_sparse(L, rhoss, w=w, **pseudo_args); else:; if pseudo_args['method'] != 'splu':; pseudo_args['method'] = pseudo_args['method']; else:; pseudo_args['method'] = 'direct'; return _pseudo_inverse_dense(L, rhoss, w=w, **pseudo_args). © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/steadystate.html
https://qutip.org/docs/4.7/modules/qutip/steadystate.html:4940,Energy Efficiency,power,power,4940,": True,; 'return_info': False, 'info': _empty_info_dict(),; 'verbose': False, 'solver': 'scipy', 'weight': None,; 'tol': 1e-12, 'matol': 1e-15, 'mtol': None}; return def_args. [docs]def steadystate(A, c_op_list=[], method='direct', solver=None, **kwargs):; """"""; Calculates the steady state for quantum evolution subject to the supplied; Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a list of; collapse operators. If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters; ----------; A : :obj:`~qutip.Qobj`; A Hamiltonian or Liouvillian operator. c_op_list : list; A list of collapse operators. solver : {'scipy', 'mkl'}, optional; Selects the sparse solver to use. Default is to auto-select based on; the availability of the MKL library. method : str, default 'direct'; The allowed methods are. - 'direct'; - 'eigen'; - 'iterative-gmres'; - 'iterative-lgmres'; - 'iterative-bicgstab'; - 'svd'; - 'power'; - 'power-gmres'; - 'power-lgmres'; - 'power-bicgstab'. Method for solving the underlying linear equation. Direct LU solver; 'direct' (default), sparse eigenvalue problem 'eigen', iterative GMRES; method 'iterative-gmres', iterative LGMRES method 'iterative-lgmres',; iterative BICGSTAB method 'iterative-bicgstab', SVD 'svd' (dense), or; inverse-power method 'power'. The iterative power methods; 'power-gmres', 'power-lgmres', 'power-bicgstab' use the same solvers as; their direct counterparts. return_info : bool, default False; Return a dictionary of solver-specific infomation about the solution; and how it was obtained. sparse : bool, default True; Solve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for 'smaller' systems. use_rcm : bool, default False; Use reverse Cuthill-Mckee reordering to minimize fill-in in the LU; factorization of the Liouvillian. use_w",MatchSource.WIKI,docs/4.7/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/steadystate.html
https://qutip.org/docs/4.7/modules/qutip/steadystate.html:4951,Energy Efficiency,power,power-gmres,4951,": True,; 'return_info': False, 'info': _empty_info_dict(),; 'verbose': False, 'solver': 'scipy', 'weight': None,; 'tol': 1e-12, 'matol': 1e-15, 'mtol': None}; return def_args. [docs]def steadystate(A, c_op_list=[], method='direct', solver=None, **kwargs):; """"""; Calculates the steady state for quantum evolution subject to the supplied; Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a list of; collapse operators. If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters; ----------; A : :obj:`~qutip.Qobj`; A Hamiltonian or Liouvillian operator. c_op_list : list; A list of collapse operators. solver : {'scipy', 'mkl'}, optional; Selects the sparse solver to use. Default is to auto-select based on; the availability of the MKL library. method : str, default 'direct'; The allowed methods are. - 'direct'; - 'eigen'; - 'iterative-gmres'; - 'iterative-lgmres'; - 'iterative-bicgstab'; - 'svd'; - 'power'; - 'power-gmres'; - 'power-lgmres'; - 'power-bicgstab'. Method for solving the underlying linear equation. Direct LU solver; 'direct' (default), sparse eigenvalue problem 'eigen', iterative GMRES; method 'iterative-gmres', iterative LGMRES method 'iterative-lgmres',; iterative BICGSTAB method 'iterative-bicgstab', SVD 'svd' (dense), or; inverse-power method 'power'. The iterative power methods; 'power-gmres', 'power-lgmres', 'power-bicgstab' use the same solvers as; their direct counterparts. return_info : bool, default False; Return a dictionary of solver-specific infomation about the solution; and how it was obtained. sparse : bool, default True; Solve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for 'smaller' systems. use_rcm : bool, default False; Use reverse Cuthill-Mckee reordering to minimize fill-in in the LU; factorization of the Liouvillian. use_w",MatchSource.WIKI,docs/4.7/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/steadystate.html
https://qutip.org/docs/4.7/modules/qutip/steadystate.html:4968,Energy Efficiency,power,power-lgmres,4968,": True,; 'return_info': False, 'info': _empty_info_dict(),; 'verbose': False, 'solver': 'scipy', 'weight': None,; 'tol': 1e-12, 'matol': 1e-15, 'mtol': None}; return def_args. [docs]def steadystate(A, c_op_list=[], method='direct', solver=None, **kwargs):; """"""; Calculates the steady state for quantum evolution subject to the supplied; Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a list of; collapse operators. If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters; ----------; A : :obj:`~qutip.Qobj`; A Hamiltonian or Liouvillian operator. c_op_list : list; A list of collapse operators. solver : {'scipy', 'mkl'}, optional; Selects the sparse solver to use. Default is to auto-select based on; the availability of the MKL library. method : str, default 'direct'; The allowed methods are. - 'direct'; - 'eigen'; - 'iterative-gmres'; - 'iterative-lgmres'; - 'iterative-bicgstab'; - 'svd'; - 'power'; - 'power-gmres'; - 'power-lgmres'; - 'power-bicgstab'. Method for solving the underlying linear equation. Direct LU solver; 'direct' (default), sparse eigenvalue problem 'eigen', iterative GMRES; method 'iterative-gmres', iterative LGMRES method 'iterative-lgmres',; iterative BICGSTAB method 'iterative-bicgstab', SVD 'svd' (dense), or; inverse-power method 'power'. The iterative power methods; 'power-gmres', 'power-lgmres', 'power-bicgstab' use the same solvers as; their direct counterparts. return_info : bool, default False; Return a dictionary of solver-specific infomation about the solution; and how it was obtained. sparse : bool, default True; Solve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for 'smaller' systems. use_rcm : bool, default False; Use reverse Cuthill-Mckee reordering to minimize fill-in in the LU; factorization of the Liouvillian. use_w",MatchSource.WIKI,docs/4.7/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/steadystate.html
https://qutip.org/docs/4.7/modules/qutip/steadystate.html:4986,Energy Efficiency,power,power-bicgstab,4986,": True,; 'return_info': False, 'info': _empty_info_dict(),; 'verbose': False, 'solver': 'scipy', 'weight': None,; 'tol': 1e-12, 'matol': 1e-15, 'mtol': None}; return def_args. [docs]def steadystate(A, c_op_list=[], method='direct', solver=None, **kwargs):; """"""; Calculates the steady state for quantum evolution subject to the supplied; Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a list of; collapse operators. If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters; ----------; A : :obj:`~qutip.Qobj`; A Hamiltonian or Liouvillian operator. c_op_list : list; A list of collapse operators. solver : {'scipy', 'mkl'}, optional; Selects the sparse solver to use. Default is to auto-select based on; the availability of the MKL library. method : str, default 'direct'; The allowed methods are. - 'direct'; - 'eigen'; - 'iterative-gmres'; - 'iterative-lgmres'; - 'iterative-bicgstab'; - 'svd'; - 'power'; - 'power-gmres'; - 'power-lgmres'; - 'power-bicgstab'. Method for solving the underlying linear equation. Direct LU solver; 'direct' (default), sparse eigenvalue problem 'eigen', iterative GMRES; method 'iterative-gmres', iterative LGMRES method 'iterative-lgmres',; iterative BICGSTAB method 'iterative-bicgstab', SVD 'svd' (dense), or; inverse-power method 'power'. The iterative power methods; 'power-gmres', 'power-lgmres', 'power-bicgstab' use the same solvers as; their direct counterparts. return_info : bool, default False; Return a dictionary of solver-specific infomation about the solution; and how it was obtained. sparse : bool, default True; Solve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for 'smaller' systems. use_rcm : bool, default False; Use reverse Cuthill-Mckee reordering to minimize fill-in in the LU; factorization of the Liouvillian. use_w",MatchSource.WIKI,docs/4.7/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/steadystate.html
https://qutip.org/docs/4.7/modules/qutip/steadystate.html:5294,Energy Efficiency,power,power,5294,"culates the steady state for quantum evolution subject to the supplied; Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a list of; collapse operators. If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters; ----------; A : :obj:`~qutip.Qobj`; A Hamiltonian or Liouvillian operator. c_op_list : list; A list of collapse operators. solver : {'scipy', 'mkl'}, optional; Selects the sparse solver to use. Default is to auto-select based on; the availability of the MKL library. method : str, default 'direct'; The allowed methods are. - 'direct'; - 'eigen'; - 'iterative-gmres'; - 'iterative-lgmres'; - 'iterative-bicgstab'; - 'svd'; - 'power'; - 'power-gmres'; - 'power-lgmres'; - 'power-bicgstab'. Method for solving the underlying linear equation. Direct LU solver; 'direct' (default), sparse eigenvalue problem 'eigen', iterative GMRES; method 'iterative-gmres', iterative LGMRES method 'iterative-lgmres',; iterative BICGSTAB method 'iterative-bicgstab', SVD 'svd' (dense), or; inverse-power method 'power'. The iterative power methods; 'power-gmres', 'power-lgmres', 'power-bicgstab' use the same solvers as; their direct counterparts. return_info : bool, default False; Return a dictionary of solver-specific infomation about the solution; and how it was obtained. sparse : bool, default True; Solve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for 'smaller' systems. use_rcm : bool, default False; Use reverse Cuthill-Mckee reordering to minimize fill-in in the LU; factorization of the Liouvillian. use_wbm : bool, default False; Use Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to ``True`` by default when finding a preconditioner. weight : float, optional; Sets t",MatchSource.WIKI,docs/4.7/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/steadystate.html
https://qutip.org/docs/4.7/modules/qutip/steadystate.html:5308,Energy Efficiency,power,power,5308,"culates the steady state for quantum evolution subject to the supplied; Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a list of; collapse operators. If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters; ----------; A : :obj:`~qutip.Qobj`; A Hamiltonian or Liouvillian operator. c_op_list : list; A list of collapse operators. solver : {'scipy', 'mkl'}, optional; Selects the sparse solver to use. Default is to auto-select based on; the availability of the MKL library. method : str, default 'direct'; The allowed methods are. - 'direct'; - 'eigen'; - 'iterative-gmres'; - 'iterative-lgmres'; - 'iterative-bicgstab'; - 'svd'; - 'power'; - 'power-gmres'; - 'power-lgmres'; - 'power-bicgstab'. Method for solving the underlying linear equation. Direct LU solver; 'direct' (default), sparse eigenvalue problem 'eigen', iterative GMRES; method 'iterative-gmres', iterative LGMRES method 'iterative-lgmres',; iterative BICGSTAB method 'iterative-bicgstab', SVD 'svd' (dense), or; inverse-power method 'power'. The iterative power methods; 'power-gmres', 'power-lgmres', 'power-bicgstab' use the same solvers as; their direct counterparts. return_info : bool, default False; Return a dictionary of solver-specific infomation about the solution; and how it was obtained. sparse : bool, default True; Solve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for 'smaller' systems. use_rcm : bool, default False; Use reverse Cuthill-Mckee reordering to minimize fill-in in the LU; factorization of the Liouvillian. use_wbm : bool, default False; Use Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to ``True`` by default when finding a preconditioner. weight : float, optional; Sets t",MatchSource.WIKI,docs/4.7/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/steadystate.html
https://qutip.org/docs/4.7/modules/qutip/steadystate.html:5330,Energy Efficiency,power,power,5330,"onian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters; ----------; A : :obj:`~qutip.Qobj`; A Hamiltonian or Liouvillian operator. c_op_list : list; A list of collapse operators. solver : {'scipy', 'mkl'}, optional; Selects the sparse solver to use. Default is to auto-select based on; the availability of the MKL library. method : str, default 'direct'; The allowed methods are. - 'direct'; - 'eigen'; - 'iterative-gmres'; - 'iterative-lgmres'; - 'iterative-bicgstab'; - 'svd'; - 'power'; - 'power-gmres'; - 'power-lgmres'; - 'power-bicgstab'. Method for solving the underlying linear equation. Direct LU solver; 'direct' (default), sparse eigenvalue problem 'eigen', iterative GMRES; method 'iterative-gmres', iterative LGMRES method 'iterative-lgmres',; iterative BICGSTAB method 'iterative-bicgstab', SVD 'svd' (dense), or; inverse-power method 'power'. The iterative power methods; 'power-gmres', 'power-lgmres', 'power-bicgstab' use the same solvers as; their direct counterparts. return_info : bool, default False; Return a dictionary of solver-specific infomation about the solution; and how it was obtained. sparse : bool, default True; Solve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for 'smaller' systems. use_rcm : bool, default False; Use reverse Cuthill-Mckee reordering to minimize fill-in in the LU; factorization of the Liouvillian. use_wbm : bool, default False; Use Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to ``True`` by default when finding a preconditioner. weight : float, optional; Sets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user. max_iter_r",MatchSource.WIKI,docs/4.7/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/steadystate.html
https://qutip.org/docs/4.7/modules/qutip/steadystate.html:5346,Energy Efficiency,power,power-gmres,5346,"onian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters; ----------; A : :obj:`~qutip.Qobj`; A Hamiltonian or Liouvillian operator. c_op_list : list; A list of collapse operators. solver : {'scipy', 'mkl'}, optional; Selects the sparse solver to use. Default is to auto-select based on; the availability of the MKL library. method : str, default 'direct'; The allowed methods are. - 'direct'; - 'eigen'; - 'iterative-gmres'; - 'iterative-lgmres'; - 'iterative-bicgstab'; - 'svd'; - 'power'; - 'power-gmres'; - 'power-lgmres'; - 'power-bicgstab'. Method for solving the underlying linear equation. Direct LU solver; 'direct' (default), sparse eigenvalue problem 'eigen', iterative GMRES; method 'iterative-gmres', iterative LGMRES method 'iterative-lgmres',; iterative BICGSTAB method 'iterative-bicgstab', SVD 'svd' (dense), or; inverse-power method 'power'. The iterative power methods; 'power-gmres', 'power-lgmres', 'power-bicgstab' use the same solvers as; their direct counterparts. return_info : bool, default False; Return a dictionary of solver-specific infomation about the solution; and how it was obtained. sparse : bool, default True; Solve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for 'smaller' systems. use_rcm : bool, default False; Use reverse Cuthill-Mckee reordering to minimize fill-in in the LU; factorization of the Liouvillian. use_wbm : bool, default False; Use Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to ``True`` by default when finding a preconditioner. weight : float, optional; Sets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user. max_iter_r",MatchSource.WIKI,docs/4.7/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/steadystate.html
https://qutip.org/docs/4.7/modules/qutip/steadystate.html:5361,Energy Efficiency,power,power-lgmres,5361,"onian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters; ----------; A : :obj:`~qutip.Qobj`; A Hamiltonian or Liouvillian operator. c_op_list : list; A list of collapse operators. solver : {'scipy', 'mkl'}, optional; Selects the sparse solver to use. Default is to auto-select based on; the availability of the MKL library. method : str, default 'direct'; The allowed methods are. - 'direct'; - 'eigen'; - 'iterative-gmres'; - 'iterative-lgmres'; - 'iterative-bicgstab'; - 'svd'; - 'power'; - 'power-gmres'; - 'power-lgmres'; - 'power-bicgstab'. Method for solving the underlying linear equation. Direct LU solver; 'direct' (default), sparse eigenvalue problem 'eigen', iterative GMRES; method 'iterative-gmres', iterative LGMRES method 'iterative-lgmres',; iterative BICGSTAB method 'iterative-bicgstab', SVD 'svd' (dense), or; inverse-power method 'power'. The iterative power methods; 'power-gmres', 'power-lgmres', 'power-bicgstab' use the same solvers as; their direct counterparts. return_info : bool, default False; Return a dictionary of solver-specific infomation about the solution; and how it was obtained. sparse : bool, default True; Solve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for 'smaller' systems. use_rcm : bool, default False; Use reverse Cuthill-Mckee reordering to minimize fill-in in the LU; factorization of the Liouvillian. use_wbm : bool, default False; Use Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to ``True`` by default when finding a preconditioner. weight : float, optional; Sets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user. max_iter_r",MatchSource.WIKI,docs/4.7/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/steadystate.html
https://qutip.org/docs/4.7/modules/qutip/steadystate.html:5377,Energy Efficiency,power,power-bicgstab,5377,"onian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters; ----------; A : :obj:`~qutip.Qobj`; A Hamiltonian or Liouvillian operator. c_op_list : list; A list of collapse operators. solver : {'scipy', 'mkl'}, optional; Selects the sparse solver to use. Default is to auto-select based on; the availability of the MKL library. method : str, default 'direct'; The allowed methods are. - 'direct'; - 'eigen'; - 'iterative-gmres'; - 'iterative-lgmres'; - 'iterative-bicgstab'; - 'svd'; - 'power'; - 'power-gmres'; - 'power-lgmres'; - 'power-bicgstab'. Method for solving the underlying linear equation. Direct LU solver; 'direct' (default), sparse eigenvalue problem 'eigen', iterative GMRES; method 'iterative-gmres', iterative LGMRES method 'iterative-lgmres',; iterative BICGSTAB method 'iterative-bicgstab', SVD 'svd' (dense), or; inverse-power method 'power'. The iterative power methods; 'power-gmres', 'power-lgmres', 'power-bicgstab' use the same solvers as; their direct counterparts. return_info : bool, default False; Return a dictionary of solver-specific infomation about the solution; and how it was obtained. sparse : bool, default True; Solve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for 'smaller' systems. use_rcm : bool, default False; Use reverse Cuthill-Mckee reordering to minimize fill-in in the LU; factorization of the Liouvillian. use_wbm : bool, default False; Use Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to ``True`` by default when finding a preconditioner. weight : float, optional; Sets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user. max_iter_r",MatchSource.WIKI,docs/4.7/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/steadystate.html
https://qutip.org/docs/4.7/modules/qutip/steadystate.html:6909,Energy Efficiency,power,power,6909," Liouvillian. use_wbm : bool, default False; Use Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to ``True`` by default when finding a preconditioner. weight : float, optional; Sets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user. max_iter_refine : int, default 10; MKL ONLY. Max. number of iterative refinements to perform. scaling_vectors : bool; MKL ONLY. Scale matrix to unit norm columns and rows. weighted_matching : bool; MKL ONLY. Use weighted matching to better condition diagonal. x0 : ndarray, optional; ITERATIVE ONLY. Initial guess for solution vector. maxiter : int, default 1000; ITERATIVE ONLY. Maximum number of iterations to perform. tol : float, default 1e-12; ITERATIVE ONLY. Tolerance used for terminating solver. mtol : float, optional; ITERATIVE 'power' methods ONLY. Tolerance for lu solve method. If None; given then ``max(0.1*tol, 1e-15)`` is used. matol : float, default 1e-15; ITERATIVE ONLY. Absolute tolerance for lu solve method. permc_spec : str, optional; ITERATIVE ONLY. Column ordering used internally by superLU for the; 'direct' LU decomposition method. Options include 'COLAMD' (default); and 'NATURAL'. If using RCM then this is set to 'NATURAL' automatically; unless explicitly specified. use_precond : bool, default False; ITERATIVE ONLY. Use an incomplete sparse LU decomposition as a; preconditioner for the 'iterative' GMRES and BICG solvers. Speeds up; convergence time by orders of magnitude in many cases. M : {sparse matrix, dense matrix, LinearOperator}, optional; ITERATIVE ONLY. Preconditioner for A. The preconditioner should; approximate the inverse of A. Effective preconditioning can; dramatically improve the rate of convergence for iterative methods.; If no preconditioner is given and ``use_precond = Tru",MatchSource.WIKI,docs/4.7/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/steadystate.html
https://qutip.org/docs/4.7/modules/qutip/steadystate.html:8312,Energy Efficiency,reduce,reduced,8312,"_precond : bool, default False; ITERATIVE ONLY. Use an incomplete sparse LU decomposition as a; preconditioner for the 'iterative' GMRES and BICG solvers. Speeds up; convergence time by orders of magnitude in many cases. M : {sparse matrix, dense matrix, LinearOperator}, optional; ITERATIVE ONLY. Preconditioner for A. The preconditioner should; approximate the inverse of A. Effective preconditioning can; dramatically improve the rate of convergence for iterative methods.; If no preconditioner is given and ``use_precond = True``, then one; is generated automatically. fill_factor : float, default 100; ITERATIVE ONLY. Specifies the fill ratio upper bound (>=1) of the iLU; preconditioner. Lower values save memory at the cost of longer; execution times and a possible singular factorization. drop_tol : float, default 1e-4; ITERATIVE ONLY. Sets the threshold for the magnitude of preconditioner; elements that should be dropped. Can be reduced for a courser; factorization at the cost of an increased number of iterations, and a; possible singular factorization. diag_pivot_thresh : float, optional; ITERATIVE ONLY. Sets the threshold between [0,1] for which diagonal; elements are considered acceptable pivot points when using a; preconditioner. A value of zero forces the pivot to be the diagonal; element. ILU_MILU : str, default 'smilu_2'; ITERATIVE ONLY. Selects the incomplete LU decomposition method algoithm; used in creating the preconditoner. Should only be used by advanced; users. Returns; -------; dm : qobj; Steady state density matrix.; info : dict, optional; Dictionary containing solver-specific information about the solution. Notes; -----; The SVD method works only for dense operators (i.e. small systems).; """"""; if solver is None:; solver = 'scipy'; if settings.has_mkl:; if method in ['direct', 'power']:; solver = 'mkl'; elif solver == 'mkl' and \; (method not in ['direct', 'power']):; raise ValueError('MKL solver only for direct or power methods.'). elif solver not in ",MatchSource.WIKI,docs/4.7/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/steadystate.html
https://qutip.org/docs/4.7/modules/qutip/steadystate.html:9194,Energy Efficiency,power,power,9194,"of preconditioner; elements that should be dropped. Can be reduced for a courser; factorization at the cost of an increased number of iterations, and a; possible singular factorization. diag_pivot_thresh : float, optional; ITERATIVE ONLY. Sets the threshold between [0,1] for which diagonal; elements are considered acceptable pivot points when using a; preconditioner. A value of zero forces the pivot to be the diagonal; element. ILU_MILU : str, default 'smilu_2'; ITERATIVE ONLY. Selects the incomplete LU decomposition method algoithm; used in creating the preconditoner. Should only be used by advanced; users. Returns; -------; dm : qobj; Steady state density matrix.; info : dict, optional; Dictionary containing solver-specific information about the solution. Notes; -----; The SVD method works only for dense operators (i.e. small systems).; """"""; if solver is None:; solver = 'scipy'; if settings.has_mkl:; if method in ['direct', 'power']:; solver = 'mkl'; elif solver == 'mkl' and \; (method not in ['direct', 'power']):; raise ValueError('MKL solver only for direct or power methods.'). elif solver not in ['scipy', 'mkl']:; raise ValueError('Invalid solver kwarg.'). ss_args = _default_steadystate_args(); ss_args['method'] = method; if solver is not None:; ss_args['solver'] = solver; ss_args['info']['solver'] = ss_args['solver']; ss_args['info']['method'] = ss_args['method']. for key in kwargs.keys():; if key in ss_args.keys():; ss_args[key] = kwargs[key]; else:; raise TypeError(; ""Invalid keyword argument '""+key+""' passed to steadystate.""). # Set column perm to NATURAL if using RCM and not specified by user; if ss_args['use_rcm'] and ('permc_spec' not in kwargs.keys()):; ss_args['permc_spec'] = 'NATURAL'. # Create & check Liouvillian; A = _steadystate_setup(A, c_op_list). # Set weight parameter to avg abs val in L if not set explicitly; if 'weight' not in kwargs.keys():; # set the weight to the mean of the non-zero absoluate values in A:; ss_args['weight'] = np.mean(np.ab",MatchSource.WIKI,docs/4.7/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/steadystate.html
https://qutip.org/docs/4.7/modules/qutip/steadystate.html:9275,Energy Efficiency,power,power,9275,"of preconditioner; elements that should be dropped. Can be reduced for a courser; factorization at the cost of an increased number of iterations, and a; possible singular factorization. diag_pivot_thresh : float, optional; ITERATIVE ONLY. Sets the threshold between [0,1] for which diagonal; elements are considered acceptable pivot points when using a; preconditioner. A value of zero forces the pivot to be the diagonal; element. ILU_MILU : str, default 'smilu_2'; ITERATIVE ONLY. Selects the incomplete LU decomposition method algoithm; used in creating the preconditoner. Should only be used by advanced; users. Returns; -------; dm : qobj; Steady state density matrix.; info : dict, optional; Dictionary containing solver-specific information about the solution. Notes; -----; The SVD method works only for dense operators (i.e. small systems).; """"""; if solver is None:; solver = 'scipy'; if settings.has_mkl:; if method in ['direct', 'power']:; solver = 'mkl'; elif solver == 'mkl' and \; (method not in ['direct', 'power']):; raise ValueError('MKL solver only for direct or power methods.'). elif solver not in ['scipy', 'mkl']:; raise ValueError('Invalid solver kwarg.'). ss_args = _default_steadystate_args(); ss_args['method'] = method; if solver is not None:; ss_args['solver'] = solver; ss_args['info']['solver'] = ss_args['solver']; ss_args['info']['method'] = ss_args['method']. for key in kwargs.keys():; if key in ss_args.keys():; ss_args[key] = kwargs[key]; else:; raise TypeError(; ""Invalid keyword argument '""+key+""' passed to steadystate.""). # Set column perm to NATURAL if using RCM and not specified by user; if ss_args['use_rcm'] and ('permc_spec' not in kwargs.keys()):; ss_args['permc_spec'] = 'NATURAL'. # Create & check Liouvillian; A = _steadystate_setup(A, c_op_list). # Set weight parameter to avg abs val in L if not set explicitly; if 'weight' not in kwargs.keys():; # set the weight to the mean of the non-zero absoluate values in A:; ss_args['weight'] = np.mean(np.ab",MatchSource.WIKI,docs/4.7/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/steadystate.html
https://qutip.org/docs/4.7/modules/qutip/steadystate.html:9334,Energy Efficiency,power,power,9334,"of preconditioner; elements that should be dropped. Can be reduced for a courser; factorization at the cost of an increased number of iterations, and a; possible singular factorization. diag_pivot_thresh : float, optional; ITERATIVE ONLY. Sets the threshold between [0,1] for which diagonal; elements are considered acceptable pivot points when using a; preconditioner. A value of zero forces the pivot to be the diagonal; element. ILU_MILU : str, default 'smilu_2'; ITERATIVE ONLY. Selects the incomplete LU decomposition method algoithm; used in creating the preconditoner. Should only be used by advanced; users. Returns; -------; dm : qobj; Steady state density matrix.; info : dict, optional; Dictionary containing solver-specific information about the solution. Notes; -----; The SVD method works only for dense operators (i.e. small systems).; """"""; if solver is None:; solver = 'scipy'; if settings.has_mkl:; if method in ['direct', 'power']:; solver = 'mkl'; elif solver == 'mkl' and \; (method not in ['direct', 'power']):; raise ValueError('MKL solver only for direct or power methods.'). elif solver not in ['scipy', 'mkl']:; raise ValueError('Invalid solver kwarg.'). ss_args = _default_steadystate_args(); ss_args['method'] = method; if solver is not None:; ss_args['solver'] = solver; ss_args['info']['solver'] = ss_args['solver']; ss_args['info']['method'] = ss_args['method']. for key in kwargs.keys():; if key in ss_args.keys():; ss_args[key] = kwargs[key]; else:; raise TypeError(; ""Invalid keyword argument '""+key+""' passed to steadystate.""). # Set column perm to NATURAL if using RCM and not specified by user; if ss_args['use_rcm'] and ('permc_spec' not in kwargs.keys()):; ss_args['permc_spec'] = 'NATURAL'. # Create & check Liouvillian; A = _steadystate_setup(A, c_op_list). # Set weight parameter to avg abs val in L if not set explicitly; if 'weight' not in kwargs.keys():; # set the weight to the mean of the non-zero absoluate values in A:; ss_args['weight'] = np.mean(np.ab",MatchSource.WIKI,docs/4.7/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/steadystate.html
https://qutip.org/docs/4.7/modules/qutip/steadystate.html:10858,Energy Efficiency,power,power,10858,"gs['use_rcm'] and ('permc_spec' not in kwargs.keys()):; ss_args['permc_spec'] = 'NATURAL'. # Create & check Liouvillian; A = _steadystate_setup(A, c_op_list). # Set weight parameter to avg abs val in L if not set explicitly; if 'weight' not in kwargs.keys():; # set the weight to the mean of the non-zero absoluate values in A:; ss_args['weight'] = np.mean(np.abs(A.data.data)); ss_args['info']['weight'] = ss_args['weight']. if ss_args['method'] == 'direct':; if (ss_args['solver'] == 'scipy' and ss_args['sparse']) \; or ss_args['solver'] == 'mkl':; return _steadystate_direct_sparse(A, ss_args); else:; return _steadystate_direct_dense(A, ss_args). elif ss_args['method'] == 'eigen':; return _steadystate_eigen(A, ss_args). elif ss_args['method'] in ['iterative-gmres',; 'iterative-lgmres', 'iterative-bicgstab']:; return _steadystate_iterative(A, ss_args). elif ss_args['method'] == 'svd':; return _steadystate_svd_dense(A, ss_args). elif ss_args['method'] in ['power', 'power-gmres',; 'power-lgmres', 'power-bicgstab']:; return _steadystate_power(A, ss_args). else:; raise ValueError('Invalid method argument for steadystate.'). def _steadystate_setup(A, c_op_list):; """"""Build Liouvillian (if necessary) and check input.; """"""; if isoper(A):; if len(c_op_list) > 0:; return liouvillian(A, c_op_list). raise TypeError('Cannot calculate the steady state for a ' +; 'non-dissipative system ' +; '(no collapse operators given)'); elif issuper(A):; return A; else:; raise TypeError('Solving for steady states requires ' +; 'Liouvillian (super) operators'). def _steadystate_LU_liouvillian(L, ss_args, has_mkl=0):; """"""Creates modified Liouvillian for LU based SS methods.; """"""; perm = None; perm2 = None; rev_perm = None; n = int(np.sqrt(L.shape[0])); form = 'csr'; if has_mkl:; L = L.data + sp.csr_matrix(; (ss_args['weight']*np.ones(n), (np.zeros(n), [nn * (n + 1); for nn in range(n)])), shape=(n ** 2, n ** 2)); else:; form = 'csc'; L = L.data.tocsc() + sp.csc_matrix(; (ss_args['weight']*np.ones(n)",MatchSource.WIKI,docs/4.7/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/steadystate.html
https://qutip.org/docs/4.7/modules/qutip/steadystate.html:10867,Energy Efficiency,power,power-gmres,10867,"gs['use_rcm'] and ('permc_spec' not in kwargs.keys()):; ss_args['permc_spec'] = 'NATURAL'. # Create & check Liouvillian; A = _steadystate_setup(A, c_op_list). # Set weight parameter to avg abs val in L if not set explicitly; if 'weight' not in kwargs.keys():; # set the weight to the mean of the non-zero absoluate values in A:; ss_args['weight'] = np.mean(np.abs(A.data.data)); ss_args['info']['weight'] = ss_args['weight']. if ss_args['method'] == 'direct':; if (ss_args['solver'] == 'scipy' and ss_args['sparse']) \; or ss_args['solver'] == 'mkl':; return _steadystate_direct_sparse(A, ss_args); else:; return _steadystate_direct_dense(A, ss_args). elif ss_args['method'] == 'eigen':; return _steadystate_eigen(A, ss_args). elif ss_args['method'] in ['iterative-gmres',; 'iterative-lgmres', 'iterative-bicgstab']:; return _steadystate_iterative(A, ss_args). elif ss_args['method'] == 'svd':; return _steadystate_svd_dense(A, ss_args). elif ss_args['method'] in ['power', 'power-gmres',; 'power-lgmres', 'power-bicgstab']:; return _steadystate_power(A, ss_args). else:; raise ValueError('Invalid method argument for steadystate.'). def _steadystate_setup(A, c_op_list):; """"""Build Liouvillian (if necessary) and check input.; """"""; if isoper(A):; if len(c_op_list) > 0:; return liouvillian(A, c_op_list). raise TypeError('Cannot calculate the steady state for a ' +; 'non-dissipative system ' +; '(no collapse operators given)'); elif issuper(A):; return A; else:; raise TypeError('Solving for steady states requires ' +; 'Liouvillian (super) operators'). def _steadystate_LU_liouvillian(L, ss_args, has_mkl=0):; """"""Creates modified Liouvillian for LU based SS methods.; """"""; perm = None; perm2 = None; rev_perm = None; n = int(np.sqrt(L.shape[0])); form = 'csr'; if has_mkl:; L = L.data + sp.csr_matrix(; (ss_args['weight']*np.ones(n), (np.zeros(n), [nn * (n + 1); for nn in range(n)])), shape=(n ** 2, n ** 2)); else:; form = 'csc'; L = L.data.tocsc() + sp.csc_matrix(; (ss_args['weight']*np.ones(n)",MatchSource.WIKI,docs/4.7/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/steadystate.html
https://qutip.org/docs/4.7/modules/qutip/steadystate.html:10883,Energy Efficiency,power,power-lgmres,10883,"gs['use_rcm'] and ('permc_spec' not in kwargs.keys()):; ss_args['permc_spec'] = 'NATURAL'. # Create & check Liouvillian; A = _steadystate_setup(A, c_op_list). # Set weight parameter to avg abs val in L if not set explicitly; if 'weight' not in kwargs.keys():; # set the weight to the mean of the non-zero absoluate values in A:; ss_args['weight'] = np.mean(np.abs(A.data.data)); ss_args['info']['weight'] = ss_args['weight']. if ss_args['method'] == 'direct':; if (ss_args['solver'] == 'scipy' and ss_args['sparse']) \; or ss_args['solver'] == 'mkl':; return _steadystate_direct_sparse(A, ss_args); else:; return _steadystate_direct_dense(A, ss_args). elif ss_args['method'] == 'eigen':; return _steadystate_eigen(A, ss_args). elif ss_args['method'] in ['iterative-gmres',; 'iterative-lgmres', 'iterative-bicgstab']:; return _steadystate_iterative(A, ss_args). elif ss_args['method'] == 'svd':; return _steadystate_svd_dense(A, ss_args). elif ss_args['method'] in ['power', 'power-gmres',; 'power-lgmres', 'power-bicgstab']:; return _steadystate_power(A, ss_args). else:; raise ValueError('Invalid method argument for steadystate.'). def _steadystate_setup(A, c_op_list):; """"""Build Liouvillian (if necessary) and check input.; """"""; if isoper(A):; if len(c_op_list) > 0:; return liouvillian(A, c_op_list). raise TypeError('Cannot calculate the steady state for a ' +; 'non-dissipative system ' +; '(no collapse operators given)'); elif issuper(A):; return A; else:; raise TypeError('Solving for steady states requires ' +; 'Liouvillian (super) operators'). def _steadystate_LU_liouvillian(L, ss_args, has_mkl=0):; """"""Creates modified Liouvillian for LU based SS methods.; """"""; perm = None; perm2 = None; rev_perm = None; n = int(np.sqrt(L.shape[0])); form = 'csr'; if has_mkl:; L = L.data + sp.csr_matrix(; (ss_args['weight']*np.ones(n), (np.zeros(n), [nn * (n + 1); for nn in range(n)])), shape=(n ** 2, n ** 2)); else:; form = 'csc'; L = L.data.tocsc() + sp.csc_matrix(; (ss_args['weight']*np.ones(n)",MatchSource.WIKI,docs/4.7/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/steadystate.html
https://qutip.org/docs/4.7/modules/qutip/steadystate.html:10899,Energy Efficiency,power,power-bicgstab,10899,"gs['use_rcm'] and ('permc_spec' not in kwargs.keys()):; ss_args['permc_spec'] = 'NATURAL'. # Create & check Liouvillian; A = _steadystate_setup(A, c_op_list). # Set weight parameter to avg abs val in L if not set explicitly; if 'weight' not in kwargs.keys():; # set the weight to the mean of the non-zero absoluate values in A:; ss_args['weight'] = np.mean(np.abs(A.data.data)); ss_args['info']['weight'] = ss_args['weight']. if ss_args['method'] == 'direct':; if (ss_args['solver'] == 'scipy' and ss_args['sparse']) \; or ss_args['solver'] == 'mkl':; return _steadystate_direct_sparse(A, ss_args); else:; return _steadystate_direct_dense(A, ss_args). elif ss_args['method'] == 'eigen':; return _steadystate_eigen(A, ss_args). elif ss_args['method'] in ['iterative-gmres',; 'iterative-lgmres', 'iterative-bicgstab']:; return _steadystate_iterative(A, ss_args). elif ss_args['method'] == 'svd':; return _steadystate_svd_dense(A, ss_args). elif ss_args['method'] in ['power', 'power-gmres',; 'power-lgmres', 'power-bicgstab']:; return _steadystate_power(A, ss_args). else:; raise ValueError('Invalid method argument for steadystate.'). def _steadystate_setup(A, c_op_list):; """"""Build Liouvillian (if necessary) and check input.; """"""; if isoper(A):; if len(c_op_list) > 0:; return liouvillian(A, c_op_list). raise TypeError('Cannot calculate the steady state for a ' +; 'non-dissipative system ' +; '(no collapse operators given)'); elif issuper(A):; return A; else:; raise TypeError('Solving for steady states requires ' +; 'Liouvillian (super) operators'). def _steadystate_LU_liouvillian(L, ss_args, has_mkl=0):; """"""Creates modified Liouvillian for LU based SS methods.; """"""; perm = None; perm2 = None; rev_perm = None; n = int(np.sqrt(L.shape[0])); form = 'csr'; if has_mkl:; L = L.data + sp.csr_matrix(; (ss_args['weight']*np.ones(n), (np.zeros(n), [nn * (n + 1); for nn in range(n)])), shape=(n ** 2, n ** 2)); else:; form = 'csc'; L = L.data.tocsc() + sp.csc_matrix(; (ss_args['weight']*np.ones(n)",MatchSource.WIKI,docs/4.7/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/steadystate.html
https://qutip.org/docs/4.7/modules/qutip/steadystate.html:23830,Energy Efficiency,power,power,23830,"a, dims=dims, isherm=True). def _steadystate_svd_dense(L, ss_args):; """"""; Find the steady state(s) of an open quantum system by solving for the; nullspace of the Liouvillian.; """"""; ss_args['info'].pop('weight', None); atol = 1e-12; rtol = 1e-12; if settings.debug:; logger.debug('Starting SVD solver.'); _svd_start = time.time(); u, s, vh = svd(L.full(), full_matrices=False); tol = max(atol, rtol * s[0]); nnz = (s >= tol).sum(); ns = vh[nnz:].conj().T; _svd_end = time.time(); ss_args['info']['solution_time'] = _svd_end-_svd_start; if ss_args['all_states']:; rhoss_list = []; for n in range(ns.shape[1]):; rhoss = Qobj(vec2mat(ns[:, n]), dims=L.dims[0]); rhoss_list.append(rhoss / rhoss.tr()); if ss_args['return_info']:; return rhoss_list, ss_args['info']; else:; if ss_args['return_info']:; return rhoss_list, ss_args['info']; else:; return rhoss_list; else:; rhoss = Qobj(vec2mat(ns[:, 0]), dims=L.dims[0]); return rhoss / rhoss.tr(). def _steadystate_power_liouvillian(L, ss_args, has_mkl=0):; """"""Creates modified Liouvillian for power based SS methods.; """"""; perm = None; perm2 = None; rev_perm = None; n = L.shape[0]; if ss_args['solver'] == 'mkl':; L = L.data - (1e-15) * sp.eye(n, n, format='csr'); kind = 'csr'; else:; L = L.data.tocsc() - (1e-15) * sp.eye(n, n, format='csc'); kind = 'csc'; if settings.debug:; old_band = sp_bandwidth(L)[0]; old_pro = sp_profile(L)[0]; logger.debug('Original bandwidth: %i' % old_band); logger.debug('Original profile: %i' % old_pro). if ss_args['use_wbm']:; if settings.debug:; logger.debug('Calculating Weighted Bipartite Matching ordering...'); _wbm_start = time.time(); with warnings.catch_warnings():; warnings.filterwarnings(; ""ignore"", ""qutip graph functions are deprecated"",; DeprecationWarning,; ); perm = weighted_bipartite_matching(L); _wbm_end = time.time(); L = sp_permute(L, perm, [], kind); ss_args['info']['perm'].append('wbm'); ss_args['info']['wbm_time'] = _wbm_end-_wbm_start; if settings.debug:; wbm_band = sp_bandwidth(L)[0]; wbm_pr",MatchSource.WIKI,docs/4.7/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/steadystate.html
https://qutip.org/docs/4.7/modules/qutip/steadystate.html:25681,Energy Efficiency,power,power,25681,"nd('wbm'); ss_args['info']['wbm_time'] = _wbm_end-_wbm_start; if settings.debug:; wbm_band = sp_bandwidth(L)[0]; wbm_pro = sp_profile(L)[0]; logger.debug('WBM bandwidth: %i' % wbm_band); logger.debug('WBM profile: %i' % wbm_pro). if ss_args['use_rcm']:; if settings.debug:; logger.debug('Calculating Reverse Cuthill-Mckee ordering...'); ss_args['info']['perm'].append('rcm'); _rcm_start = time.time(); perm2 = sp.csgraph.reverse_cuthill_mckee(L); _rcm_end = time.time(); ss_args['info']['rcm_time'] = _rcm_end-_rcm_start; rev_perm = np.argsort(perm2); L = sp_permute(L, perm2, perm2, kind); if settings.debug:; new_band = sp_bandwidth(L)[0]; new_pro = sp_profile(L)[0]; logger.debug('RCM bandwidth: %i' % new_band); logger.debug('Bandwidth reduction factor: %f'; % (old_band/new_band)); logger.debug('RCM profile: %i' % new_pro); logger.debug('Profile reduction factor: %f'; % (old_pro/new_pro)); L.sort_indices(); return L, perm, perm2, rev_perm, ss_args. def _steadystate_power(L, ss_args):; """"""; Inverse power method for steady state solving.; """"""; ss_args['info'].pop('weight', None); if settings.debug:; logger.debug('Starting iterative inverse-power method solver.'); tol = ss_args['tol']; mtol = ss_args['mtol']; if mtol is None:; mtol = max(0.1*tol, 1e-15); maxiter = ss_args['maxiter']. use_solver(assumeSortedIndices=True); rhoss = Qobj(); sflag = issuper(L); if sflag:; rhoss.dims = L.dims[0]; else:; rhoss.dims = [L.dims[0], 1]; n = L.shape[0]; # Build Liouvillian; if ss_args['solver'] == 'mkl' and ss_args['method'] == 'power':; has_mkl = 1; else:; has_mkl = 0; L, perm, perm2, rev_perm, ss_args = _steadystate_power_liouvillian(L,; ss_args,; has_mkl); orig_nnz = L.nnz; # start with all ones as RHS; v = np.ones(n, dtype=complex); if ss_args['use_rcm']:; v = v[np.ix_(perm2,)]. # Do preconditioning; if ss_args['solver'] == 'scipy':; if ss_args['M'] is None and ss_args['use_precond'] and \; ss_args['method'] in ['power-gmres',; 'power-lgmres',; 'power-bicgstab']:; ss_args['M'], ss_ar",MatchSource.WIKI,docs/4.7/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/steadystate.html
https://qutip.org/docs/4.7/modules/qutip/steadystate.html:25824,Energy Efficiency,power,power,25824,"gger.debug('WBM bandwidth: %i' % wbm_band); logger.debug('WBM profile: %i' % wbm_pro). if ss_args['use_rcm']:; if settings.debug:; logger.debug('Calculating Reverse Cuthill-Mckee ordering...'); ss_args['info']['perm'].append('rcm'); _rcm_start = time.time(); perm2 = sp.csgraph.reverse_cuthill_mckee(L); _rcm_end = time.time(); ss_args['info']['rcm_time'] = _rcm_end-_rcm_start; rev_perm = np.argsort(perm2); L = sp_permute(L, perm2, perm2, kind); if settings.debug:; new_band = sp_bandwidth(L)[0]; new_pro = sp_profile(L)[0]; logger.debug('RCM bandwidth: %i' % new_band); logger.debug('Bandwidth reduction factor: %f'; % (old_band/new_band)); logger.debug('RCM profile: %i' % new_pro); logger.debug('Profile reduction factor: %f'; % (old_pro/new_pro)); L.sort_indices(); return L, perm, perm2, rev_perm, ss_args. def _steadystate_power(L, ss_args):; """"""; Inverse power method for steady state solving.; """"""; ss_args['info'].pop('weight', None); if settings.debug:; logger.debug('Starting iterative inverse-power method solver.'); tol = ss_args['tol']; mtol = ss_args['mtol']; if mtol is None:; mtol = max(0.1*tol, 1e-15); maxiter = ss_args['maxiter']. use_solver(assumeSortedIndices=True); rhoss = Qobj(); sflag = issuper(L); if sflag:; rhoss.dims = L.dims[0]; else:; rhoss.dims = [L.dims[0], 1]; n = L.shape[0]; # Build Liouvillian; if ss_args['solver'] == 'mkl' and ss_args['method'] == 'power':; has_mkl = 1; else:; has_mkl = 0; L, perm, perm2, rev_perm, ss_args = _steadystate_power_liouvillian(L,; ss_args,; has_mkl); orig_nnz = L.nnz; # start with all ones as RHS; v = np.ones(n, dtype=complex); if ss_args['use_rcm']:; v = v[np.ix_(perm2,)]. # Do preconditioning; if ss_args['solver'] == 'scipy':; if ss_args['M'] is None and ss_args['use_precond'] and \; ss_args['method'] in ['power-gmres',; 'power-lgmres',; 'power-bicgstab']:; ss_args['M'], ss_args = _iterative_precondition(L, int(np.sqrt(n)),; ss_args); if ss_args['M'] is None:; warnings.warn(""Preconditioning failed. Continuing withou",MatchSource.WIKI,docs/4.7/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/steadystate.html
https://qutip.org/docs/4.7/modules/qutip/steadystate.html:26208,Energy Efficiency,power,power,26208,"ute(L, perm2, perm2, kind); if settings.debug:; new_band = sp_bandwidth(L)[0]; new_pro = sp_profile(L)[0]; logger.debug('RCM bandwidth: %i' % new_band); logger.debug('Bandwidth reduction factor: %f'; % (old_band/new_band)); logger.debug('RCM profile: %i' % new_pro); logger.debug('Profile reduction factor: %f'; % (old_pro/new_pro)); L.sort_indices(); return L, perm, perm2, rev_perm, ss_args. def _steadystate_power(L, ss_args):; """"""; Inverse power method for steady state solving.; """"""; ss_args['info'].pop('weight', None); if settings.debug:; logger.debug('Starting iterative inverse-power method solver.'); tol = ss_args['tol']; mtol = ss_args['mtol']; if mtol is None:; mtol = max(0.1*tol, 1e-15); maxiter = ss_args['maxiter']. use_solver(assumeSortedIndices=True); rhoss = Qobj(); sflag = issuper(L); if sflag:; rhoss.dims = L.dims[0]; else:; rhoss.dims = [L.dims[0], 1]; n = L.shape[0]; # Build Liouvillian; if ss_args['solver'] == 'mkl' and ss_args['method'] == 'power':; has_mkl = 1; else:; has_mkl = 0; L, perm, perm2, rev_perm, ss_args = _steadystate_power_liouvillian(L,; ss_args,; has_mkl); orig_nnz = L.nnz; # start with all ones as RHS; v = np.ones(n, dtype=complex); if ss_args['use_rcm']:; v = v[np.ix_(perm2,)]. # Do preconditioning; if ss_args['solver'] == 'scipy':; if ss_args['M'] is None and ss_args['use_precond'] and \; ss_args['method'] in ['power-gmres',; 'power-lgmres',; 'power-bicgstab']:; ss_args['M'], ss_args = _iterative_precondition(L, int(np.sqrt(n)),; ss_args); if ss_args['M'] is None:; warnings.warn(""Preconditioning failed. Continuing without."",; UserWarning). ss_iters = {'iter': 0}. def _iter_count(r):; ss_iters['iter'] += 1; return. _power_start = time.time(); # Get LU factors; if ss_args['method'] == 'power':; if ss_args['solver'] == 'mkl':; lu = mkl_splu(L, max_iter_refine=ss_args['max_iter_refine'],; scaling_vectors=ss_args['scaling_vectors'],; weighted_matching=ss_args['weighted_matching']); else:; lu = splu(L, permc_spec=ss_args['permc_spec'],; di",MatchSource.WIKI,docs/4.7/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/steadystate.html
https://qutip.org/docs/4.7/modules/qutip/steadystate.html:26604,Energy Efficiency,power,power-gmres,26604,"eturn L, perm, perm2, rev_perm, ss_args. def _steadystate_power(L, ss_args):; """"""; Inverse power method for steady state solving.; """"""; ss_args['info'].pop('weight', None); if settings.debug:; logger.debug('Starting iterative inverse-power method solver.'); tol = ss_args['tol']; mtol = ss_args['mtol']; if mtol is None:; mtol = max(0.1*tol, 1e-15); maxiter = ss_args['maxiter']. use_solver(assumeSortedIndices=True); rhoss = Qobj(); sflag = issuper(L); if sflag:; rhoss.dims = L.dims[0]; else:; rhoss.dims = [L.dims[0], 1]; n = L.shape[0]; # Build Liouvillian; if ss_args['solver'] == 'mkl' and ss_args['method'] == 'power':; has_mkl = 1; else:; has_mkl = 0; L, perm, perm2, rev_perm, ss_args = _steadystate_power_liouvillian(L,; ss_args,; has_mkl); orig_nnz = L.nnz; # start with all ones as RHS; v = np.ones(n, dtype=complex); if ss_args['use_rcm']:; v = v[np.ix_(perm2,)]. # Do preconditioning; if ss_args['solver'] == 'scipy':; if ss_args['M'] is None and ss_args['use_precond'] and \; ss_args['method'] in ['power-gmres',; 'power-lgmres',; 'power-bicgstab']:; ss_args['M'], ss_args = _iterative_precondition(L, int(np.sqrt(n)),; ss_args); if ss_args['M'] is None:; warnings.warn(""Preconditioning failed. Continuing without."",; UserWarning). ss_iters = {'iter': 0}. def _iter_count(r):; ss_iters['iter'] += 1; return. _power_start = time.time(); # Get LU factors; if ss_args['method'] == 'power':; if ss_args['solver'] == 'mkl':; lu = mkl_splu(L, max_iter_refine=ss_args['max_iter_refine'],; scaling_vectors=ss_args['scaling_vectors'],; weighted_matching=ss_args['weighted_matching']); else:; lu = splu(L, permc_spec=ss_args['permc_spec'],; diag_pivot_thresh=ss_args['diag_pivot_thresh'],; options=dict(ILU_MILU=ss_args['ILU_MILU'])). if settings.debug:; L_nnz = lu.L.nnz; U_nnz = lu.U.nnz; logger.debug('L NNZ: %i ; U NNZ: %i' % (L_nnz, U_nnz)); logger.debug('Fill factor: %f' % ((L_nnz+U_nnz)/orig_nnz)). it = 0; while (la.norm(L * v, np.inf) > tol) and (it < maxiter):; check = 0; if ss_args[",MatchSource.WIKI,docs/4.7/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/steadystate.html
https://qutip.org/docs/4.7/modules/qutip/steadystate.html:26620,Energy Efficiency,power,power-lgmres,26620,"eturn L, perm, perm2, rev_perm, ss_args. def _steadystate_power(L, ss_args):; """"""; Inverse power method for steady state solving.; """"""; ss_args['info'].pop('weight', None); if settings.debug:; logger.debug('Starting iterative inverse-power method solver.'); tol = ss_args['tol']; mtol = ss_args['mtol']; if mtol is None:; mtol = max(0.1*tol, 1e-15); maxiter = ss_args['maxiter']. use_solver(assumeSortedIndices=True); rhoss = Qobj(); sflag = issuper(L); if sflag:; rhoss.dims = L.dims[0]; else:; rhoss.dims = [L.dims[0], 1]; n = L.shape[0]; # Build Liouvillian; if ss_args['solver'] == 'mkl' and ss_args['method'] == 'power':; has_mkl = 1; else:; has_mkl = 0; L, perm, perm2, rev_perm, ss_args = _steadystate_power_liouvillian(L,; ss_args,; has_mkl); orig_nnz = L.nnz; # start with all ones as RHS; v = np.ones(n, dtype=complex); if ss_args['use_rcm']:; v = v[np.ix_(perm2,)]. # Do preconditioning; if ss_args['solver'] == 'scipy':; if ss_args['M'] is None and ss_args['use_precond'] and \; ss_args['method'] in ['power-gmres',; 'power-lgmres',; 'power-bicgstab']:; ss_args['M'], ss_args = _iterative_precondition(L, int(np.sqrt(n)),; ss_args); if ss_args['M'] is None:; warnings.warn(""Preconditioning failed. Continuing without."",; UserWarning). ss_iters = {'iter': 0}. def _iter_count(r):; ss_iters['iter'] += 1; return. _power_start = time.time(); # Get LU factors; if ss_args['method'] == 'power':; if ss_args['solver'] == 'mkl':; lu = mkl_splu(L, max_iter_refine=ss_args['max_iter_refine'],; scaling_vectors=ss_args['scaling_vectors'],; weighted_matching=ss_args['weighted_matching']); else:; lu = splu(L, permc_spec=ss_args['permc_spec'],; diag_pivot_thresh=ss_args['diag_pivot_thresh'],; options=dict(ILU_MILU=ss_args['ILU_MILU'])). if settings.debug:; L_nnz = lu.L.nnz; U_nnz = lu.U.nnz; logger.debug('L NNZ: %i ; U NNZ: %i' % (L_nnz, U_nnz)); logger.debug('Fill factor: %f' % ((L_nnz+U_nnz)/orig_nnz)). it = 0; while (la.norm(L * v, np.inf) > tol) and (it < maxiter):; check = 0; if ss_args[",MatchSource.WIKI,docs/4.7/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/steadystate.html
https://qutip.org/docs/4.7/modules/qutip/steadystate.html:26637,Energy Efficiency,power,power-bicgstab,26637,"eturn L, perm, perm2, rev_perm, ss_args. def _steadystate_power(L, ss_args):; """"""; Inverse power method for steady state solving.; """"""; ss_args['info'].pop('weight', None); if settings.debug:; logger.debug('Starting iterative inverse-power method solver.'); tol = ss_args['tol']; mtol = ss_args['mtol']; if mtol is None:; mtol = max(0.1*tol, 1e-15); maxiter = ss_args['maxiter']. use_solver(assumeSortedIndices=True); rhoss = Qobj(); sflag = issuper(L); if sflag:; rhoss.dims = L.dims[0]; else:; rhoss.dims = [L.dims[0], 1]; n = L.shape[0]; # Build Liouvillian; if ss_args['solver'] == 'mkl' and ss_args['method'] == 'power':; has_mkl = 1; else:; has_mkl = 0; L, perm, perm2, rev_perm, ss_args = _steadystate_power_liouvillian(L,; ss_args,; has_mkl); orig_nnz = L.nnz; # start with all ones as RHS; v = np.ones(n, dtype=complex); if ss_args['use_rcm']:; v = v[np.ix_(perm2,)]. # Do preconditioning; if ss_args['solver'] == 'scipy':; if ss_args['M'] is None and ss_args['use_precond'] and \; ss_args['method'] in ['power-gmres',; 'power-lgmres',; 'power-bicgstab']:; ss_args['M'], ss_args = _iterative_precondition(L, int(np.sqrt(n)),; ss_args); if ss_args['M'] is None:; warnings.warn(""Preconditioning failed. Continuing without."",; UserWarning). ss_iters = {'iter': 0}. def _iter_count(r):; ss_iters['iter'] += 1; return. _power_start = time.time(); # Get LU factors; if ss_args['method'] == 'power':; if ss_args['solver'] == 'mkl':; lu = mkl_splu(L, max_iter_refine=ss_args['max_iter_refine'],; scaling_vectors=ss_args['scaling_vectors'],; weighted_matching=ss_args['weighted_matching']); else:; lu = splu(L, permc_spec=ss_args['permc_spec'],; diag_pivot_thresh=ss_args['diag_pivot_thresh'],; options=dict(ILU_MILU=ss_args['ILU_MILU'])). if settings.debug:; L_nnz = lu.L.nnz; U_nnz = lu.U.nnz; logger.debug('L NNZ: %i ; U NNZ: %i' % (L_nnz, U_nnz)); logger.debug('Fill factor: %f' % ((L_nnz+U_nnz)/orig_nnz)). it = 0; while (la.norm(L * v, np.inf) > tol) and (it < maxiter):; check = 0; if ss_args[",MatchSource.WIKI,docs/4.7/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/steadystate.html
https://qutip.org/docs/4.7/modules/qutip/steadystate.html:26984,Energy Efficiency,power,power,26984,"# Build Liouvillian; if ss_args['solver'] == 'mkl' and ss_args['method'] == 'power':; has_mkl = 1; else:; has_mkl = 0; L, perm, perm2, rev_perm, ss_args = _steadystate_power_liouvillian(L,; ss_args,; has_mkl); orig_nnz = L.nnz; # start with all ones as RHS; v = np.ones(n, dtype=complex); if ss_args['use_rcm']:; v = v[np.ix_(perm2,)]. # Do preconditioning; if ss_args['solver'] == 'scipy':; if ss_args['M'] is None and ss_args['use_precond'] and \; ss_args['method'] in ['power-gmres',; 'power-lgmres',; 'power-bicgstab']:; ss_args['M'], ss_args = _iterative_precondition(L, int(np.sqrt(n)),; ss_args); if ss_args['M'] is None:; warnings.warn(""Preconditioning failed. Continuing without."",; UserWarning). ss_iters = {'iter': 0}. def _iter_count(r):; ss_iters['iter'] += 1; return. _power_start = time.time(); # Get LU factors; if ss_args['method'] == 'power':; if ss_args['solver'] == 'mkl':; lu = mkl_splu(L, max_iter_refine=ss_args['max_iter_refine'],; scaling_vectors=ss_args['scaling_vectors'],; weighted_matching=ss_args['weighted_matching']); else:; lu = splu(L, permc_spec=ss_args['permc_spec'],; diag_pivot_thresh=ss_args['diag_pivot_thresh'],; options=dict(ILU_MILU=ss_args['ILU_MILU'])). if settings.debug:; L_nnz = lu.L.nnz; U_nnz = lu.U.nnz; logger.debug('L NNZ: %i ; U NNZ: %i' % (L_nnz, U_nnz)); logger.debug('Fill factor: %f' % ((L_nnz+U_nnz)/orig_nnz)). it = 0; while (la.norm(L * v, np.inf) > tol) and (it < maxiter):; check = 0; if ss_args['method'] == 'power':; v = lu.solve(v); elif ss_args['method'] == 'power-gmres':; v, check = gmres(L, v, tol=mtol, atol=ss_args['matol'],; M=ss_args['M'], x0=ss_args['x0'],; restart=ss_args['restart'],; maxiter=ss_args['maxiter'],; callback=_iter_count, callback_type='legacy'); elif ss_args['method'] == 'power-lgmres':; v, check = lgmres(L, v, tol=mtol, atol=ss_args['matol'],; M=ss_args['M'], x0=ss_args['x0'],; maxiter=ss_args['maxiter'],; callback=_iter_count); elif ss_args['method'] == 'power-bicgstab':; v, check = bicgstab(L, v, tol",MatchSource.WIKI,docs/4.7/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/steadystate.html
https://qutip.org/docs/4.7/modules/qutip/steadystate.html:27604,Energy Efficiency,power,power,27604," \; ss_args['method'] in ['power-gmres',; 'power-lgmres',; 'power-bicgstab']:; ss_args['M'], ss_args = _iterative_precondition(L, int(np.sqrt(n)),; ss_args); if ss_args['M'] is None:; warnings.warn(""Preconditioning failed. Continuing without."",; UserWarning). ss_iters = {'iter': 0}. def _iter_count(r):; ss_iters['iter'] += 1; return. _power_start = time.time(); # Get LU factors; if ss_args['method'] == 'power':; if ss_args['solver'] == 'mkl':; lu = mkl_splu(L, max_iter_refine=ss_args['max_iter_refine'],; scaling_vectors=ss_args['scaling_vectors'],; weighted_matching=ss_args['weighted_matching']); else:; lu = splu(L, permc_spec=ss_args['permc_spec'],; diag_pivot_thresh=ss_args['diag_pivot_thresh'],; options=dict(ILU_MILU=ss_args['ILU_MILU'])). if settings.debug:; L_nnz = lu.L.nnz; U_nnz = lu.U.nnz; logger.debug('L NNZ: %i ; U NNZ: %i' % (L_nnz, U_nnz)); logger.debug('Fill factor: %f' % ((L_nnz+U_nnz)/orig_nnz)). it = 0; while (la.norm(L * v, np.inf) > tol) and (it < maxiter):; check = 0; if ss_args['method'] == 'power':; v = lu.solve(v); elif ss_args['method'] == 'power-gmres':; v, check = gmres(L, v, tol=mtol, atol=ss_args['matol'],; M=ss_args['M'], x0=ss_args['x0'],; restart=ss_args['restart'],; maxiter=ss_args['maxiter'],; callback=_iter_count, callback_type='legacy'); elif ss_args['method'] == 'power-lgmres':; v, check = lgmres(L, v, tol=mtol, atol=ss_args['matol'],; M=ss_args['M'], x0=ss_args['x0'],; maxiter=ss_args['maxiter'],; callback=_iter_count); elif ss_args['method'] == 'power-bicgstab':; v, check = bicgstab(L, v, tol=mtol, atol=ss_args['matol'],; M=ss_args['M'], x0=ss_args['x0'],; maxiter=ss_args['maxiter'],; callback=_iter_count); else:; raise Exception(""Invalid iterative solver method.""); if check > 0:; raise Exception(""{} failed to find solution in ""; ""{} iterations."".format(ss_args['method'],; check)); if check < 0:; raise Exception(""Breakdown in {}"".format(ss_args['method'])); v = v / la.norm(v, np.inf); it += 1; if ss_args['method'] == 'power' and s",MatchSource.WIKI,docs/4.7/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/steadystate.html
https://qutip.org/docs/4.7/modules/qutip/steadystate.html:27657,Energy Efficiency,power,power-gmres,27657,"ss_args['method'] == 'power':; if ss_args['solver'] == 'mkl':; lu = mkl_splu(L, max_iter_refine=ss_args['max_iter_refine'],; scaling_vectors=ss_args['scaling_vectors'],; weighted_matching=ss_args['weighted_matching']); else:; lu = splu(L, permc_spec=ss_args['permc_spec'],; diag_pivot_thresh=ss_args['diag_pivot_thresh'],; options=dict(ILU_MILU=ss_args['ILU_MILU'])). if settings.debug:; L_nnz = lu.L.nnz; U_nnz = lu.U.nnz; logger.debug('L NNZ: %i ; U NNZ: %i' % (L_nnz, U_nnz)); logger.debug('Fill factor: %f' % ((L_nnz+U_nnz)/orig_nnz)). it = 0; while (la.norm(L * v, np.inf) > tol) and (it < maxiter):; check = 0; if ss_args['method'] == 'power':; v = lu.solve(v); elif ss_args['method'] == 'power-gmres':; v, check = gmres(L, v, tol=mtol, atol=ss_args['matol'],; M=ss_args['M'], x0=ss_args['x0'],; restart=ss_args['restart'],; maxiter=ss_args['maxiter'],; callback=_iter_count, callback_type='legacy'); elif ss_args['method'] == 'power-lgmres':; v, check = lgmres(L, v, tol=mtol, atol=ss_args['matol'],; M=ss_args['M'], x0=ss_args['x0'],; maxiter=ss_args['maxiter'],; callback=_iter_count); elif ss_args['method'] == 'power-bicgstab':; v, check = bicgstab(L, v, tol=mtol, atol=ss_args['matol'],; M=ss_args['M'], x0=ss_args['x0'],; maxiter=ss_args['maxiter'],; callback=_iter_count); else:; raise Exception(""Invalid iterative solver method.""); if check > 0:; raise Exception(""{} failed to find solution in ""; ""{} iterations."".format(ss_args['method'],; check)); if check < 0:; raise Exception(""Breakdown in {}"".format(ss_args['method'])); v = v / la.norm(v, np.inf); it += 1; if ss_args['method'] == 'power' and ss_args['solver'] == 'mkl':; lu.delete(); if ss_args['return_info']:; ss_args['info']['max_iter_refine'] = ss_args['max_iter_refine']; ss_args['info']['scaling_vectors'] = ss_args['scaling_vectors']; ss_args['info']['weighted_matching'] = ss_args['weighted_matching']. if it >= maxiter:; raise Exception('Failed to find steady state after ' +; str(maxiter) + ' iterations'); _power_end ",MatchSource.WIKI,docs/4.7/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/steadystate.html
https://qutip.org/docs/4.7/modules/qutip/steadystate.html:27896,Energy Efficiency,power,power-lgmres,27896,"ss_args['method'] == 'power':; if ss_args['solver'] == 'mkl':; lu = mkl_splu(L, max_iter_refine=ss_args['max_iter_refine'],; scaling_vectors=ss_args['scaling_vectors'],; weighted_matching=ss_args['weighted_matching']); else:; lu = splu(L, permc_spec=ss_args['permc_spec'],; diag_pivot_thresh=ss_args['diag_pivot_thresh'],; options=dict(ILU_MILU=ss_args['ILU_MILU'])). if settings.debug:; L_nnz = lu.L.nnz; U_nnz = lu.U.nnz; logger.debug('L NNZ: %i ; U NNZ: %i' % (L_nnz, U_nnz)); logger.debug('Fill factor: %f' % ((L_nnz+U_nnz)/orig_nnz)). it = 0; while (la.norm(L * v, np.inf) > tol) and (it < maxiter):; check = 0; if ss_args['method'] == 'power':; v = lu.solve(v); elif ss_args['method'] == 'power-gmres':; v, check = gmres(L, v, tol=mtol, atol=ss_args['matol'],; M=ss_args['M'], x0=ss_args['x0'],; restart=ss_args['restart'],; maxiter=ss_args['maxiter'],; callback=_iter_count, callback_type='legacy'); elif ss_args['method'] == 'power-lgmres':; v, check = lgmres(L, v, tol=mtol, atol=ss_args['matol'],; M=ss_args['M'], x0=ss_args['x0'],; maxiter=ss_args['maxiter'],; callback=_iter_count); elif ss_args['method'] == 'power-bicgstab':; v, check = bicgstab(L, v, tol=mtol, atol=ss_args['matol'],; M=ss_args['M'], x0=ss_args['x0'],; maxiter=ss_args['maxiter'],; callback=_iter_count); else:; raise Exception(""Invalid iterative solver method.""); if check > 0:; raise Exception(""{} failed to find solution in ""; ""{} iterations."".format(ss_args['method'],; check)); if check < 0:; raise Exception(""Breakdown in {}"".format(ss_args['method'])); v = v / la.norm(v, np.inf); it += 1; if ss_args['method'] == 'power' and ss_args['solver'] == 'mkl':; lu.delete(); if ss_args['return_info']:; ss_args['info']['max_iter_refine'] = ss_args['max_iter_refine']; ss_args['info']['scaling_vectors'] = ss_args['scaling_vectors']; ss_args['info']['weighted_matching'] = ss_args['weighted_matching']. if it >= maxiter:; raise Exception('Failed to find steady state after ' +; str(maxiter) + ' iterations'); _power_end ",MatchSource.WIKI,docs/4.7/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/steadystate.html
https://qutip.org/docs/4.7/modules/qutip/steadystate.html:28084,Energy Efficiency,power,power-bicgstab,28084,"ss_args['method'] == 'power':; if ss_args['solver'] == 'mkl':; lu = mkl_splu(L, max_iter_refine=ss_args['max_iter_refine'],; scaling_vectors=ss_args['scaling_vectors'],; weighted_matching=ss_args['weighted_matching']); else:; lu = splu(L, permc_spec=ss_args['permc_spec'],; diag_pivot_thresh=ss_args['diag_pivot_thresh'],; options=dict(ILU_MILU=ss_args['ILU_MILU'])). if settings.debug:; L_nnz = lu.L.nnz; U_nnz = lu.U.nnz; logger.debug('L NNZ: %i ; U NNZ: %i' % (L_nnz, U_nnz)); logger.debug('Fill factor: %f' % ((L_nnz+U_nnz)/orig_nnz)). it = 0; while (la.norm(L * v, np.inf) > tol) and (it < maxiter):; check = 0; if ss_args['method'] == 'power':; v = lu.solve(v); elif ss_args['method'] == 'power-gmres':; v, check = gmres(L, v, tol=mtol, atol=ss_args['matol'],; M=ss_args['M'], x0=ss_args['x0'],; restart=ss_args['restart'],; maxiter=ss_args['maxiter'],; callback=_iter_count, callback_type='legacy'); elif ss_args['method'] == 'power-lgmres':; v, check = lgmres(L, v, tol=mtol, atol=ss_args['matol'],; M=ss_args['M'], x0=ss_args['x0'],; maxiter=ss_args['maxiter'],; callback=_iter_count); elif ss_args['method'] == 'power-bicgstab':; v, check = bicgstab(L, v, tol=mtol, atol=ss_args['matol'],; M=ss_args['M'], x0=ss_args['x0'],; maxiter=ss_args['maxiter'],; callback=_iter_count); else:; raise Exception(""Invalid iterative solver method.""); if check > 0:; raise Exception(""{} failed to find solution in ""; ""{} iterations."".format(ss_args['method'],; check)); if check < 0:; raise Exception(""Breakdown in {}"".format(ss_args['method'])); v = v / la.norm(v, np.inf); it += 1; if ss_args['method'] == 'power' and ss_args['solver'] == 'mkl':; lu.delete(); if ss_args['return_info']:; ss_args['info']['max_iter_refine'] = ss_args['max_iter_refine']; ss_args['info']['scaling_vectors'] = ss_args['scaling_vectors']; ss_args['info']['weighted_matching'] = ss_args['weighted_matching']. if it >= maxiter:; raise Exception('Failed to find steady state after ' +; str(maxiter) + ' iterations'); _power_end ",MatchSource.WIKI,docs/4.7/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/steadystate.html
https://qutip.org/docs/4.7/modules/qutip/steadystate.html:28566,Energy Efficiency,power,power,28566," check = 0; if ss_args['method'] == 'power':; v = lu.solve(v); elif ss_args['method'] == 'power-gmres':; v, check = gmres(L, v, tol=mtol, atol=ss_args['matol'],; M=ss_args['M'], x0=ss_args['x0'],; restart=ss_args['restart'],; maxiter=ss_args['maxiter'],; callback=_iter_count, callback_type='legacy'); elif ss_args['method'] == 'power-lgmres':; v, check = lgmres(L, v, tol=mtol, atol=ss_args['matol'],; M=ss_args['M'], x0=ss_args['x0'],; maxiter=ss_args['maxiter'],; callback=_iter_count); elif ss_args['method'] == 'power-bicgstab':; v, check = bicgstab(L, v, tol=mtol, atol=ss_args['matol'],; M=ss_args['M'], x0=ss_args['x0'],; maxiter=ss_args['maxiter'],; callback=_iter_count); else:; raise Exception(""Invalid iterative solver method.""); if check > 0:; raise Exception(""{} failed to find solution in ""; ""{} iterations."".format(ss_args['method'],; check)); if check < 0:; raise Exception(""Breakdown in {}"".format(ss_args['method'])); v = v / la.norm(v, np.inf); it += 1; if ss_args['method'] == 'power' and ss_args['solver'] == 'mkl':; lu.delete(); if ss_args['return_info']:; ss_args['info']['max_iter_refine'] = ss_args['max_iter_refine']; ss_args['info']['scaling_vectors'] = ss_args['scaling_vectors']; ss_args['info']['weighted_matching'] = ss_args['weighted_matching']. if it >= maxiter:; raise Exception('Failed to find steady state after ' +; str(maxiter) + ' iterations'); _power_end = time.time(); ss_args['info']['solution_time'] = _power_end-_power_start; ss_args['info']['iterations'] = it; if ss_args['return_info']:; ss_args['info']['residual_norm'] = la.norm(L*v, np.inf); if settings.debug:; logger.debug('Number of iterations: %i' % it). if ss_args['use_rcm']:; v = v[np.ix_(rev_perm,)]. # normalise according to type of problem; if sflag:; trow = v[::rhoss.shape[0]+1]; data = v / np.sum(trow); else:; data = data / la.norm(v). data = dense2D_to_fastcsr_fmode(vec2mat(data),; rhoss.shape[0],; rhoss.shape[0]); rhoss.data = 0.5 * (data + data.H); rhoss.isherm = True; if ss_args['",MatchSource.WIKI,docs/4.7/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/steadystate.html
https://qutip.org/docs/4.7/modules/qutip/steadystate.html:33168,Energy Efficiency,power,power,33168,"n operator. c_op_list : list; A list of collapse operators. return_info : bool, optional, default = False; Return a dictionary of solver-specific infomation about the; solution and how it was obtained. use_rcm : bool, optional, default = False; Use reverse Cuthill-Mckee reordering to minimize fill-in in the; LU factorization of the Liouvillian. use_wbm : bool, optional, default = False; Use Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to ``True`` by default when finding a preconditioner. weight : float, optional; Sets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user. method : str, default = 'iterative'; Tells the preconditioner what type of Liouvillian to build for; iLU factorization. For direct iterative methods use 'iterative'.; For power iterative methods use 'power'. permc_spec : str, optional, default='COLAMD'; Column ordering used internally by superLU for the; 'direct' LU decomposition method. Options include 'COLAMD' and; 'NATURAL'. If using RCM then this is set to 'NATURAL' automatically; unless explicitly specified. fill_factor : float, optional, default = 100; Specifies the fill ratio upper bound (>=1) of the iLU; preconditioner. Lower values save memory at the cost of longer; execution times and a possible singular factorization. drop_tol : float, optional, default = 1e-4; Sets the threshold for the magnitude of preconditioner; elements that should be dropped. Can be reduced for a courser; factorization at the cost of an increased number of iterations, and a; possible singular factorization. diag_pivot_thresh : float, optional, default = None; Sets the threshold between [0,1] for which diagonal; elements are considered acceptable pivot points when using a; preconditioner. A value of zero forces the pivot to be the diag",MatchSource.WIKI,docs/4.7/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/steadystate.html
https://qutip.org/docs/4.7/modules/qutip/steadystate.html:33197,Energy Efficiency,power,power,33197,"n operator. c_op_list : list; A list of collapse operators. return_info : bool, optional, default = False; Return a dictionary of solver-specific infomation about the; solution and how it was obtained. use_rcm : bool, optional, default = False; Use reverse Cuthill-Mckee reordering to minimize fill-in in the; LU factorization of the Liouvillian. use_wbm : bool, optional, default = False; Use Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to ``True`` by default when finding a preconditioner. weight : float, optional; Sets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user. method : str, default = 'iterative'; Tells the preconditioner what type of Liouvillian to build for; iLU factorization. For direct iterative methods use 'iterative'.; For power iterative methods use 'power'. permc_spec : str, optional, default='COLAMD'; Column ordering used internally by superLU for the; 'direct' LU decomposition method. Options include 'COLAMD' and; 'NATURAL'. If using RCM then this is set to 'NATURAL' automatically; unless explicitly specified. fill_factor : float, optional, default = 100; Specifies the fill ratio upper bound (>=1) of the iLU; preconditioner. Lower values save memory at the cost of longer; execution times and a possible singular factorization. drop_tol : float, optional, default = 1e-4; Sets the threshold for the magnitude of preconditioner; elements that should be dropped. Can be reduced for a courser; factorization at the cost of an increased number of iterations, and a; possible singular factorization. diag_pivot_thresh : float, optional, default = None; Sets the threshold between [0,1] for which diagonal; elements are considered acceptable pivot points when using a; preconditioner. A value of zero forces the pivot to be the diag",MatchSource.WIKI,docs/4.7/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/steadystate.html
https://qutip.org/docs/4.7/modules/qutip/steadystate.html:33825,Energy Efficiency,reduce,reduced,33825," linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user. method : str, default = 'iterative'; Tells the preconditioner what type of Liouvillian to build for; iLU factorization. For direct iterative methods use 'iterative'.; For power iterative methods use 'power'. permc_spec : str, optional, default='COLAMD'; Column ordering used internally by superLU for the; 'direct' LU decomposition method. Options include 'COLAMD' and; 'NATURAL'. If using RCM then this is set to 'NATURAL' automatically; unless explicitly specified. fill_factor : float, optional, default = 100; Specifies the fill ratio upper bound (>=1) of the iLU; preconditioner. Lower values save memory at the cost of longer; execution times and a possible singular factorization. drop_tol : float, optional, default = 1e-4; Sets the threshold for the magnitude of preconditioner; elements that should be dropped. Can be reduced for a courser; factorization at the cost of an increased number of iterations, and a; possible singular factorization. diag_pivot_thresh : float, optional, default = None; Sets the threshold between [0,1] for which diagonal; elements are considered acceptable pivot points when using a; preconditioner. A value of zero forces the pivot to be the diagonal; element. ILU_MILU : str, optional, default = 'smilu_2'; Selects the incomplete LU decomposition method algoithm used in; creating the preconditoner. Should only be used by advanced users. Returns; -------; lu : object; Returns a SuperLU object representing iLU preconditioner. info : dict, optional; Dictionary containing solver-specific information.; """"""; ss_args = _default_steadystate_args(); ss_args['method'] = 'iterative'; for key in kwargs.keys():; if key in ss_args.keys():; ss_args[key] = kwargs[key]; else:; raise TypeError(""Invalid keyword argument '"" + key +; ""' passed to steadystate.""). # Set column perm to NATURAL if using RCM and not specified by user; if ss_args['use_rcm'] and",MatchSource.WIKI,docs/4.7/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/steadystate.html
https://qutip.org/docs/4.7/modules/qutip/steadystate.html:35391,Energy Efficiency,power,power,35391,"-------; lu : object; Returns a SuperLU object representing iLU preconditioner. info : dict, optional; Dictionary containing solver-specific information.; """"""; ss_args = _default_steadystate_args(); ss_args['method'] = 'iterative'; for key in kwargs.keys():; if key in ss_args.keys():; ss_args[key] = kwargs[key]; else:; raise TypeError(""Invalid keyword argument '"" + key +; ""' passed to steadystate.""). # Set column perm to NATURAL if using RCM and not specified by user; if ss_args['use_rcm'] and ('permc_spec' not in kwargs.keys()):; ss_args['permc_spec'] = 'NATURAL'. L = _steadystate_setup(A, c_op_list); # Set weight parameter to avg abs val in L if not set explicitly; if 'weight' not in kwargs.keys():; ss_args['weight'] = np.mean(np.abs(L.data.data.max())); ss_args['info']['weight'] = ss_args['weight']. n = int(np.sqrt(L.shape[0])); if ss_args['method'] == 'iterative':; ss_list = _steadystate_LU_liouvillian(L, ss_args); L, perm, perm2, rev_perm, ss_args = ss_list; elif ss_args['method'] == 'power':; ss_list = _steadystate_power_liouvillian(L, ss_args); L, perm, perm2, rev_perm, ss_args = ss_list; else:; raise ValueError(""Invalid preconditioning method.""). M, ss_args = _iterative_precondition(L, n, ss_args). if ss_args['return_info']:; return M, ss_args['info']; else:; return M. def _pseudo_inverse_dense(L, rhoss, w=None, **pseudo_args):; """"""; Internal function for computing the pseudo inverse of an Liouvillian using; dense matrix methods. See pseudo_inverse for details.; """"""; rho_vec = np.transpose(mat2vec(rhoss.full())). tr_mat = tensor([identity(n) for n in L.dims[0][0]]); tr_vec = np.transpose(mat2vec(tr_mat.full())); N = np.prod(L.dims[0][0]); I = np.identity(N * N); P = np.kron(np.transpose(rho_vec), tr_vec); Q = I - P. if w is None:; L = L; else:; L = 1.0j*w*spre(tr_mat)+L. if pseudo_args['method'] == 'direct':; try:; LIQ = np.linalg.solve(L.full(), Q); except Exception:; LIQ = np.linalg.lstsq(L.full(), Q, rcond=None)[0]. R = np.dot(Q, LIQ). return Qobj(R, dims=",MatchSource.WIKI,docs/4.7/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/steadystate.html
https://qutip.org/docs/4.7/modules/qutip/steadystate.html:1673,Integrability,wrap,wrapped,1673," packaging.version import parse as _parse_version; import numpy as np; from numpy.linalg import svd; import scipy; import scipy.sparse as sp; import scipy.linalg as la; from scipy.sparse.linalg import (; use_solver, splu, spilu, eigs, LinearOperator, gmres, lgmres, bicgstab,; ); from qutip.qobj import Qobj, issuper, isoper. from qutip.superoperator import liouvillian, vec2mat, spre; from qutip.sparse import sp_permute, sp_bandwidth, sp_profile; from qutip.cy.spmath import zcsr_kron; from qutip.graph import weighted_bipartite_matching; from qutip import (mat2vec, tensor, identity, operator_to_vector); import qutip.settings as settings; from qutip.cy.spconvert import dense2D_to_fastcsr_fmode. import qutip.logging_utils; logger = qutip.logging_utils.get_logger('qutip.steadystate'); logger.setLevel('DEBUG'). # Load MKL spsolve if avaiable; if settings.has_mkl:; from qutip._mkl.spsolve import (mkl_splu, mkl_spsolve). def _eat_kwargs(function, names):; """"""; Return a wrapped version of `function` that simply removes any keyword; arguments with one of the given names.; """"""; @functools.wraps(function); def out(*args, **kwargs):; for name in names:; if name in kwargs:; del kwargs[name]; return function(*args, **kwargs); return out. def _rename_kwargs(function, names_pairs):; """"""; Return a wrapped version of `function` that rename any keyword; arguments from the first value of the pair, to the second.; """"""; @functools.wraps(function); def out(*args, **kwargs):; for old, new in names_pairs:; if old in kwargs:; kwargs[new] = kwargs.pop(old); return function(*args, **kwargs); return out. # From SciPy 1.4 onwards we need to pass the `callback_type='legacy'` argument; # to gmres to maintain the same behaviour we used to have. Since this should; # be the default behaviour, we use that in the main code and just ""eat"" the; # argument if passed to a lower version of SciPy that doesn't know about it.; # Similarly, SciPy < 1.1 does not recognise the `atol` keyword.; #; # Respective checks",MatchSource.WIKI,docs/4.7/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/steadystate.html
https://qutip.org/docs/4.7/modules/qutip/steadystate.html:1792,Integrability,wrap,wraps,1792,"; from scipy.sparse.linalg import (; use_solver, splu, spilu, eigs, LinearOperator, gmres, lgmres, bicgstab,; ); from qutip.qobj import Qobj, issuper, isoper. from qutip.superoperator import liouvillian, vec2mat, spre; from qutip.sparse import sp_permute, sp_bandwidth, sp_profile; from qutip.cy.spmath import zcsr_kron; from qutip.graph import weighted_bipartite_matching; from qutip import (mat2vec, tensor, identity, operator_to_vector); import qutip.settings as settings; from qutip.cy.spconvert import dense2D_to_fastcsr_fmode. import qutip.logging_utils; logger = qutip.logging_utils.get_logger('qutip.steadystate'); logger.setLevel('DEBUG'). # Load MKL spsolve if avaiable; if settings.has_mkl:; from qutip._mkl.spsolve import (mkl_splu, mkl_spsolve). def _eat_kwargs(function, names):; """"""; Return a wrapped version of `function` that simply removes any keyword; arguments with one of the given names.; """"""; @functools.wraps(function); def out(*args, **kwargs):; for name in names:; if name in kwargs:; del kwargs[name]; return function(*args, **kwargs); return out. def _rename_kwargs(function, names_pairs):; """"""; Return a wrapped version of `function` that rename any keyword; arguments from the first value of the pair, to the second.; """"""; @functools.wraps(function); def out(*args, **kwargs):; for old, new in names_pairs:; if old in kwargs:; kwargs[new] = kwargs.pop(old); return function(*args, **kwargs); return out. # From SciPy 1.4 onwards we need to pass the `callback_type='legacy'` argument; # to gmres to maintain the same behaviour we used to have. Since this should; # be the default behaviour, we use that in the main code and just ""eat"" the; # argument if passed to a lower version of SciPy that doesn't know about it.; # Similarly, SciPy < 1.1 does not recognise the `atol` keyword.; #; # Respective checks can be removed when SciPy version requirements are raised. if _parse_version(scipy.__version__) < _parse_version(""1.1""):; gmres = _eat_kwargs(gmres, ['atol', 'callbac",MatchSource.WIKI,docs/4.7/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/steadystate.html
https://qutip.org/docs/4.7/modules/qutip/steadystate.html:1998,Integrability,wrap,wrapped,1998,"rom qutip.superoperator import liouvillian, vec2mat, spre; from qutip.sparse import sp_permute, sp_bandwidth, sp_profile; from qutip.cy.spmath import zcsr_kron; from qutip.graph import weighted_bipartite_matching; from qutip import (mat2vec, tensor, identity, operator_to_vector); import qutip.settings as settings; from qutip.cy.spconvert import dense2D_to_fastcsr_fmode. import qutip.logging_utils; logger = qutip.logging_utils.get_logger('qutip.steadystate'); logger.setLevel('DEBUG'). # Load MKL spsolve if avaiable; if settings.has_mkl:; from qutip._mkl.spsolve import (mkl_splu, mkl_spsolve). def _eat_kwargs(function, names):; """"""; Return a wrapped version of `function` that simply removes any keyword; arguments with one of the given names.; """"""; @functools.wraps(function); def out(*args, **kwargs):; for name in names:; if name in kwargs:; del kwargs[name]; return function(*args, **kwargs); return out. def _rename_kwargs(function, names_pairs):; """"""; Return a wrapped version of `function` that rename any keyword; arguments from the first value of the pair, to the second.; """"""; @functools.wraps(function); def out(*args, **kwargs):; for old, new in names_pairs:; if old in kwargs:; kwargs[new] = kwargs.pop(old); return function(*args, **kwargs); return out. # From SciPy 1.4 onwards we need to pass the `callback_type='legacy'` argument; # to gmres to maintain the same behaviour we used to have. Since this should; # be the default behaviour, we use that in the main code and just ""eat"" the; # argument if passed to a lower version of SciPy that doesn't know about it.; # Similarly, SciPy < 1.1 does not recognise the `atol` keyword.; #; # Respective checks can be removed when SciPy version requirements are raised. if _parse_version(scipy.__version__) < _parse_version(""1.1""):; gmres = _eat_kwargs(gmres, ['atol', 'callback_type']); lgmres = _eat_kwargs(lgmres, ['atol']); bicgstab = _eat_kwargs(bicgstab, ['atol']); elif _parse_version(scipy.__version__) < _parse_version(""1.4""):;",MatchSource.WIKI,docs/4.7/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/steadystate.html
https://qutip.org/docs/4.7/modules/qutip/steadystate.html:2129,Integrability,wrap,wraps,2129,"from qutip.graph import weighted_bipartite_matching; from qutip import (mat2vec, tensor, identity, operator_to_vector); import qutip.settings as settings; from qutip.cy.spconvert import dense2D_to_fastcsr_fmode. import qutip.logging_utils; logger = qutip.logging_utils.get_logger('qutip.steadystate'); logger.setLevel('DEBUG'). # Load MKL spsolve if avaiable; if settings.has_mkl:; from qutip._mkl.spsolve import (mkl_splu, mkl_spsolve). def _eat_kwargs(function, names):; """"""; Return a wrapped version of `function` that simply removes any keyword; arguments with one of the given names.; """"""; @functools.wraps(function); def out(*args, **kwargs):; for name in names:; if name in kwargs:; del kwargs[name]; return function(*args, **kwargs); return out. def _rename_kwargs(function, names_pairs):; """"""; Return a wrapped version of `function` that rename any keyword; arguments from the first value of the pair, to the second.; """"""; @functools.wraps(function); def out(*args, **kwargs):; for old, new in names_pairs:; if old in kwargs:; kwargs[new] = kwargs.pop(old); return function(*args, **kwargs); return out. # From SciPy 1.4 onwards we need to pass the `callback_type='legacy'` argument; # to gmres to maintain the same behaviour we used to have. Since this should; # be the default behaviour, we use that in the main code and just ""eat"" the; # argument if passed to a lower version of SciPy that doesn't know about it.; # Similarly, SciPy < 1.1 does not recognise the `atol` keyword.; #; # Respective checks can be removed when SciPy version requirements are raised. if _parse_version(scipy.__version__) < _parse_version(""1.1""):; gmres = _eat_kwargs(gmres, ['atol', 'callback_type']); lgmres = _eat_kwargs(lgmres, ['atol']); bicgstab = _eat_kwargs(bicgstab, ['atol']); elif _parse_version(scipy.__version__) < _parse_version(""1.4""):; gmres = _eat_kwargs(gmres, ['callback_type']). # From SciPy 1.12, the `tol` keyword argument to iterative solvers was renamed; # to `rtol`.; if _parse_version(s",MatchSource.WIKI,docs/4.7/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/steadystate.html
https://qutip.org/docs/4.7/modules/qutip/steadystate.html:13545,Integrability,message,message,13545,"args['info']['wbm_time'] = _wbm_end-_wbm_start; if settings.debug:; wbm_band = sp_bandwidth(L)[0]; logger.debug('WBM bandwidth: %i' % wbm_band). if ss_args['use_rcm']:; if settings.debug:; logger.debug('Calculating Reverse Cuthill-Mckee ordering...'); _rcm_start = time.time(); perm2 = sp.csgraph.reverse_cuthill_mckee(L); _rcm_end = time.time(); rev_perm = np.argsort(perm2); L = sp_permute(L, perm2, perm2, form); ss_args['info']['perm'].append('rcm'); ss_args['info']['rcm_time'] = _rcm_end-_rcm_start; if settings.debug:; rcm_band = sp_bandwidth(L)[0]; rcm_pro = sp_profile(L)[0]; logger.debug('RCM bandwidth: %i' % rcm_band); logger.debug('Bandwidth reduction factor: %f' %; (old_band/rcm_band)); logger.debug('Profile reduction factor: %f' %; (old_pro/rcm_pro)); L.sort_indices(); return L, perm, perm2, rev_perm, ss_args. def steady(L, maxiter=10, tol=1e-12, itertol=1e-15, method='solve',; use_precond=False):; """"""; Deprecated. See steadystate instead.; """"""; message = ""steady has been deprecated, use steadystate instead""; warnings.warn(message, DeprecationWarning); return steadystate(L, [], maxiter=maxiter, tol=tol,; use_precond=use_precond). def _steadystate_direct_sparse(L, ss_args):; """"""; Direct solver that uses scipy sparse matrices; """"""; if settings.debug:; logger.debug('Starting direct LU solver.'). dims = L.dims[0]; n = int(np.sqrt(L.shape[0])); b = np.zeros(n ** 2, dtype=complex); b[0] = ss_args['weight']. if ss_args['solver'] == 'mkl':; has_mkl = 1; else:; has_mkl = 0. ss_lu_liouv_list = _steadystate_LU_liouvillian(L, ss_args, has_mkl); L, perm, perm2, rev_perm, ss_args = ss_lu_liouv_list; if np.any(perm):; b = b[np.ix_(perm,)]; if np.any(perm2):; b = b[np.ix_(perm2,)]. if ss_args['solver'] == 'scipy':; ss_args['info']['permc_spec'] = ss_args['permc_spec']; ss_args['info']['drop_tol'] = ss_args['drop_tol']; ss_args['info']['diag_pivot_thresh'] = ss_args['diag_pivot_thresh']; ss_args['info']['fill_factor'] = ss_args['fill_factor']; ss_args['info']['ILU_MILU'] = ss_",MatchSource.WIKI,docs/4.7/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/steadystate.html
https://qutip.org/docs/4.7/modules/qutip/steadystate.html:13624,Integrability,message,message,13624,"; logger.debug('WBM bandwidth: %i' % wbm_band). if ss_args['use_rcm']:; if settings.debug:; logger.debug('Calculating Reverse Cuthill-Mckee ordering...'); _rcm_start = time.time(); perm2 = sp.csgraph.reverse_cuthill_mckee(L); _rcm_end = time.time(); rev_perm = np.argsort(perm2); L = sp_permute(L, perm2, perm2, form); ss_args['info']['perm'].append('rcm'); ss_args['info']['rcm_time'] = _rcm_end-_rcm_start; if settings.debug:; rcm_band = sp_bandwidth(L)[0]; rcm_pro = sp_profile(L)[0]; logger.debug('RCM bandwidth: %i' % rcm_band); logger.debug('Bandwidth reduction factor: %f' %; (old_band/rcm_band)); logger.debug('Profile reduction factor: %f' %; (old_pro/rcm_pro)); L.sort_indices(); return L, perm, perm2, rev_perm, ss_args. def steady(L, maxiter=10, tol=1e-12, itertol=1e-15, method='solve',; use_precond=False):; """"""; Deprecated. See steadystate instead.; """"""; message = ""steady has been deprecated, use steadystate instead""; warnings.warn(message, DeprecationWarning); return steadystate(L, [], maxiter=maxiter, tol=tol,; use_precond=use_precond). def _steadystate_direct_sparse(L, ss_args):; """"""; Direct solver that uses scipy sparse matrices; """"""; if settings.debug:; logger.debug('Starting direct LU solver.'). dims = L.dims[0]; n = int(np.sqrt(L.shape[0])); b = np.zeros(n ** 2, dtype=complex); b[0] = ss_args['weight']. if ss_args['solver'] == 'mkl':; has_mkl = 1; else:; has_mkl = 0. ss_lu_liouv_list = _steadystate_LU_liouvillian(L, ss_args, has_mkl); L, perm, perm2, rev_perm, ss_args = ss_lu_liouv_list; if np.any(perm):; b = b[np.ix_(perm,)]; if np.any(perm2):; b = b[np.ix_(perm2,)]. if ss_args['solver'] == 'scipy':; ss_args['info']['permc_spec'] = ss_args['permc_spec']; ss_args['info']['drop_tol'] = ss_args['drop_tol']; ss_args['info']['diag_pivot_thresh'] = ss_args['diag_pivot_thresh']; ss_args['info']['fill_factor'] = ss_args['fill_factor']; ss_args['info']['ILU_MILU'] = ss_args['ILU_MILU']. if not ss_args['solver'] == 'mkl':; # Use superLU solver; orig_nnz = L.nnz; _di",MatchSource.WIKI,docs/4.7/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/steadystate.html
https://qutip.org/docs/4.7/modules/qutip/steadystate.html:29787,Integrability,depend,dependent,29787,"s_args['scaling_vectors']; ss_args['info']['weighted_matching'] = ss_args['weighted_matching']. if it >= maxiter:; raise Exception('Failed to find steady state after ' +; str(maxiter) + ' iterations'); _power_end = time.time(); ss_args['info']['solution_time'] = _power_end-_power_start; ss_args['info']['iterations'] = it; if ss_args['return_info']:; ss_args['info']['residual_norm'] = la.norm(L*v, np.inf); if settings.debug:; logger.debug('Number of iterations: %i' % it). if ss_args['use_rcm']:; v = v[np.ix_(rev_perm,)]. # normalise according to type of problem; if sflag:; trow = v[::rhoss.shape[0]+1]; data = v / np.sum(trow); else:; data = data / la.norm(v). data = dense2D_to_fastcsr_fmode(vec2mat(data),; rhoss.shape[0],; rhoss.shape[0]); rhoss.data = 0.5 * (data + data.H); rhoss.isherm = True; if ss_args['return_info']:; return rhoss, ss_args['info']; else:; return rhoss. def steadystate_floquet(H_0, c_ops, Op_t, w_d=1.0, n_it=3, sparse=False):; """"""; Calculates the effective steady state for a driven; system with a time-dependent cosinusoidal term:. .. math::. \\mathcal{\\hat{H}}(t) = \\hat{H}_0 +; \\mathcal{\\hat{O}} \\cos(\\omega_d t). Parameters; ----------; H_0 : :obj:`~qutip.Qobj`; A Hamiltonian or Liouvillian operator. c_ops : list; A list of collapse operators. Op_t : :obj:`~qutip.Qobj`; The the interaction operator which is multiplied by the cosine. w_d : float, default 1.0; The frequency of the drive. n_it : int, default 3; The number of iterations for the solver. sparse : bool, default False; Solve for the steady state using sparse algorithms.; Actually, dense seems to be faster. Returns; -------; dm : qobj; Steady state density matrix. .. note::; See: Sze Meng Tan,; https://copilot.caltech.edu/documents/16743/qousersguide.pdf,; Section (10.16); """"""; if sparse:; N = H_0.shape[0]. L_0 = liouvillian(H_0, c_ops).data.tocsc(); L_t = liouvillian(Op_t); L_p = (0.5 * L_t).data.tocsc(); # L_p and L_m correspond to the positive and negative; # frequency terms resp",MatchSource.WIKI,docs/4.7/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/steadystate.html
https://qutip.org/docs/4.7/modules/qutip/steadystate.html:6455,Performance,perform,perform,6455,"ts. return_info : bool, default False; Return a dictionary of solver-specific infomation about the solution; and how it was obtained. sparse : bool, default True; Solve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for 'smaller' systems. use_rcm : bool, default False; Use reverse Cuthill-Mckee reordering to minimize fill-in in the LU; factorization of the Liouvillian. use_wbm : bool, default False; Use Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to ``True`` by default when finding a preconditioner. weight : float, optional; Sets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user. max_iter_refine : int, default 10; MKL ONLY. Max. number of iterative refinements to perform. scaling_vectors : bool; MKL ONLY. Scale matrix to unit norm columns and rows. weighted_matching : bool; MKL ONLY. Use weighted matching to better condition diagonal. x0 : ndarray, optional; ITERATIVE ONLY. Initial guess for solution vector. maxiter : int, default 1000; ITERATIVE ONLY. Maximum number of iterations to perform. tol : float, default 1e-12; ITERATIVE ONLY. Tolerance used for terminating solver. mtol : float, optional; ITERATIVE 'power' methods ONLY. Tolerance for lu solve method. If None; given then ``max(0.1*tol, 1e-15)`` is used. matol : float, default 1e-15; ITERATIVE ONLY. Absolute tolerance for lu solve method. permc_spec : str, optional; ITERATIVE ONLY. Column ordering used internally by superLU for the; 'direct' LU decomposition method. Options include 'COLAMD' (default); and 'NATURAL'. If using RCM then this is set to 'NATURAL' automatically; unless explicitly specified. use_precond : bool, default False; ITERATIVE ONLY. Use an incomplete spar",MatchSource.WIKI,docs/4.7/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/steadystate.html
https://qutip.org/docs/4.7/modules/qutip/steadystate.html:6782,Performance,perform,perform,6782,"er' systems. use_rcm : bool, default False; Use reverse Cuthill-Mckee reordering to minimize fill-in in the LU; factorization of the Liouvillian. use_wbm : bool, default False; Use Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to ``True`` by default when finding a preconditioner. weight : float, optional; Sets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user. max_iter_refine : int, default 10; MKL ONLY. Max. number of iterative refinements to perform. scaling_vectors : bool; MKL ONLY. Scale matrix to unit norm columns and rows. weighted_matching : bool; MKL ONLY. Use weighted matching to better condition diagonal. x0 : ndarray, optional; ITERATIVE ONLY. Initial guess for solution vector. maxiter : int, default 1000; ITERATIVE ONLY. Maximum number of iterations to perform. tol : float, default 1e-12; ITERATIVE ONLY. Tolerance used for terminating solver. mtol : float, optional; ITERATIVE 'power' methods ONLY. Tolerance for lu solve method. If None; given then ``max(0.1*tol, 1e-15)`` is used. matol : float, default 1e-15; ITERATIVE ONLY. Absolute tolerance for lu solve method. permc_spec : str, optional; ITERATIVE ONLY. Column ordering used internally by superLU for the; 'direct' LU decomposition method. Options include 'COLAMD' (default); and 'NATURAL'. If using RCM then this is set to 'NATURAL' automatically; unless explicitly specified. use_precond : bool, default False; ITERATIVE ONLY. Use an incomplete sparse LU decomposition as a; preconditioner for the 'iterative' GMRES and BICG solvers. Speeds up; convergence time by orders of magnitude in many cases. M : {sparse matrix, dense matrix, LinearOperator}, optional; ITERATIVE ONLY. Preconditioner for A. The preconditioner should; approximate the inverse of A. Effective precondition",MatchSource.WIKI,docs/4.7/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/steadystate.html
https://qutip.org/docs/4.7/modules/qutip/steadystate.html:1426,Testability,log,logger,1426,"ity matrix of; open quantum systems defined by a Liouvillian or Hamiltonian and a list of; collapse operators.; """""". __all__ = ['steadystate', 'steady', 'steadystate_floquet',; 'build_preconditioner', 'pseudo_inverse']. import functools; import time; import warnings. from packaging.version import parse as _parse_version; import numpy as np; from numpy.linalg import svd; import scipy; import scipy.sparse as sp; import scipy.linalg as la; from scipy.sparse.linalg import (; use_solver, splu, spilu, eigs, LinearOperator, gmres, lgmres, bicgstab,; ); from qutip.qobj import Qobj, issuper, isoper. from qutip.superoperator import liouvillian, vec2mat, spre; from qutip.sparse import sp_permute, sp_bandwidth, sp_profile; from qutip.cy.spmath import zcsr_kron; from qutip.graph import weighted_bipartite_matching; from qutip import (mat2vec, tensor, identity, operator_to_vector); import qutip.settings as settings; from qutip.cy.spconvert import dense2D_to_fastcsr_fmode. import qutip.logging_utils; logger = qutip.logging_utils.get_logger('qutip.steadystate'); logger.setLevel('DEBUG'). # Load MKL spsolve if avaiable; if settings.has_mkl:; from qutip._mkl.spsolve import (mkl_splu, mkl_spsolve). def _eat_kwargs(function, names):; """"""; Return a wrapped version of `function` that simply removes any keyword; arguments with one of the given names.; """"""; @functools.wraps(function); def out(*args, **kwargs):; for name in names:; if name in kwargs:; del kwargs[name]; return function(*args, **kwargs); return out. def _rename_kwargs(function, names_pairs):; """"""; Return a wrapped version of `function` that rename any keyword; arguments from the first value of the pair, to the second.; """"""; @functools.wraps(function); def out(*args, **kwargs):; for old, new in names_pairs:; if old in kwargs:; kwargs[new] = kwargs.pop(old); return function(*args, **kwargs); return out. # From SciPy 1.4 onwards we need to pass the `callback_type='legacy'` argument; # to gmres to maintain the same behaviour we us",MatchSource.WIKI,docs/4.7/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/steadystate.html
https://qutip.org/docs/4.7/modules/qutip/steadystate.html:1488,Testability,log,logger,1488,"an or Hamiltonian and a list of; collapse operators.; """""". __all__ = ['steadystate', 'steady', 'steadystate_floquet',; 'build_preconditioner', 'pseudo_inverse']. import functools; import time; import warnings. from packaging.version import parse as _parse_version; import numpy as np; from numpy.linalg import svd; import scipy; import scipy.sparse as sp; import scipy.linalg as la; from scipy.sparse.linalg import (; use_solver, splu, spilu, eigs, LinearOperator, gmres, lgmres, bicgstab,; ); from qutip.qobj import Qobj, issuper, isoper. from qutip.superoperator import liouvillian, vec2mat, spre; from qutip.sparse import sp_permute, sp_bandwidth, sp_profile; from qutip.cy.spmath import zcsr_kron; from qutip.graph import weighted_bipartite_matching; from qutip import (mat2vec, tensor, identity, operator_to_vector); import qutip.settings as settings; from qutip.cy.spconvert import dense2D_to_fastcsr_fmode. import qutip.logging_utils; logger = qutip.logging_utils.get_logger('qutip.steadystate'); logger.setLevel('DEBUG'). # Load MKL spsolve if avaiable; if settings.has_mkl:; from qutip._mkl.spsolve import (mkl_splu, mkl_spsolve). def _eat_kwargs(function, names):; """"""; Return a wrapped version of `function` that simply removes any keyword; arguments with one of the given names.; """"""; @functools.wraps(function); def out(*args, **kwargs):; for name in names:; if name in kwargs:; del kwargs[name]; return function(*args, **kwargs); return out. def _rename_kwargs(function, names_pairs):; """"""; Return a wrapped version of `function` that rename any keyword; arguments from the first value of the pair, to the second.; """"""; @functools.wraps(function); def out(*args, **kwargs):; for old, new in names_pairs:; if old in kwargs:; kwargs[new] = kwargs.pop(old); return function(*args, **kwargs); return out. # From SciPy 1.4 onwards we need to pass the `callback_type='legacy'` argument; # to gmres to maintain the same behaviour we used to have. Since this should; # be the default behaviour,",MatchSource.WIKI,docs/4.7/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/steadystate.html
https://qutip.org/docs/4.7/modules/qutip/steadystate.html:12051,Testability,log,logger,12051,".'). def _steadystate_setup(A, c_op_list):; """"""Build Liouvillian (if necessary) and check input.; """"""; if isoper(A):; if len(c_op_list) > 0:; return liouvillian(A, c_op_list). raise TypeError('Cannot calculate the steady state for a ' +; 'non-dissipative system ' +; '(no collapse operators given)'); elif issuper(A):; return A; else:; raise TypeError('Solving for steady states requires ' +; 'Liouvillian (super) operators'). def _steadystate_LU_liouvillian(L, ss_args, has_mkl=0):; """"""Creates modified Liouvillian for LU based SS methods.; """"""; perm = None; perm2 = None; rev_perm = None; n = int(np.sqrt(L.shape[0])); form = 'csr'; if has_mkl:; L = L.data + sp.csr_matrix(; (ss_args['weight']*np.ones(n), (np.zeros(n), [nn * (n + 1); for nn in range(n)])), shape=(n ** 2, n ** 2)); else:; form = 'csc'; L = L.data.tocsc() + sp.csc_matrix(; (ss_args['weight']*np.ones(n), (np.zeros(n), [nn * (n + 1); for nn in range(n)])), shape=(n ** 2, n ** 2)). if settings.debug:; old_band = sp_bandwidth(L)[0]; old_pro = sp_profile(L)[0]; logger.debug('Orig. NNZ: %i' % L.nnz); if ss_args['use_rcm']:; logger.debug('Original bandwidth: %i' % old_band). if ss_args['use_wbm']:; if settings.debug:; logger.debug('Calculating Weighted Bipartite Matching ordering...'); _wbm_start = time.time(); with warnings.catch_warnings():; warnings.filterwarnings(; ""ignore"", ""qutip graph functions are deprecated"",; DeprecationWarning,; ); perm = weighted_bipartite_matching(L); _wbm_end = time.time(); L = sp_permute(L, perm, [], form); ss_args['info']['perm'].append('wbm'); ss_args['info']['wbm_time'] = _wbm_end-_wbm_start; if settings.debug:; wbm_band = sp_bandwidth(L)[0]; logger.debug('WBM bandwidth: %i' % wbm_band). if ss_args['use_rcm']:; if settings.debug:; logger.debug('Calculating Reverse Cuthill-Mckee ordering...'); _rcm_start = time.time(); perm2 = sp.csgraph.reverse_cuthill_mckee(L); _rcm_end = time.time(); rev_perm = np.argsort(perm2); L = sp_permute(L, perm2, perm2, form); ss_args['info']['perm'].app",MatchSource.WIKI,docs/4.7/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/steadystate.html
https://qutip.org/docs/4.7/modules/qutip/steadystate.html:12114,Testability,log,logger,12114,"nd check input.; """"""; if isoper(A):; if len(c_op_list) > 0:; return liouvillian(A, c_op_list). raise TypeError('Cannot calculate the steady state for a ' +; 'non-dissipative system ' +; '(no collapse operators given)'); elif issuper(A):; return A; else:; raise TypeError('Solving for steady states requires ' +; 'Liouvillian (super) operators'). def _steadystate_LU_liouvillian(L, ss_args, has_mkl=0):; """"""Creates modified Liouvillian for LU based SS methods.; """"""; perm = None; perm2 = None; rev_perm = None; n = int(np.sqrt(L.shape[0])); form = 'csr'; if has_mkl:; L = L.data + sp.csr_matrix(; (ss_args['weight']*np.ones(n), (np.zeros(n), [nn * (n + 1); for nn in range(n)])), shape=(n ** 2, n ** 2)); else:; form = 'csc'; L = L.data.tocsc() + sp.csc_matrix(; (ss_args['weight']*np.ones(n), (np.zeros(n), [nn * (n + 1); for nn in range(n)])), shape=(n ** 2, n ** 2)). if settings.debug:; old_band = sp_bandwidth(L)[0]; old_pro = sp_profile(L)[0]; logger.debug('Orig. NNZ: %i' % L.nnz); if ss_args['use_rcm']:; logger.debug('Original bandwidth: %i' % old_band). if ss_args['use_wbm']:; if settings.debug:; logger.debug('Calculating Weighted Bipartite Matching ordering...'); _wbm_start = time.time(); with warnings.catch_warnings():; warnings.filterwarnings(; ""ignore"", ""qutip graph functions are deprecated"",; DeprecationWarning,; ); perm = weighted_bipartite_matching(L); _wbm_end = time.time(); L = sp_permute(L, perm, [], form); ss_args['info']['perm'].append('wbm'); ss_args['info']['wbm_time'] = _wbm_end-_wbm_start; if settings.debug:; wbm_band = sp_bandwidth(L)[0]; logger.debug('WBM bandwidth: %i' % wbm_band). if ss_args['use_rcm']:; if settings.debug:; logger.debug('Calculating Reverse Cuthill-Mckee ordering...'); _rcm_start = time.time(); perm2 = sp.csgraph.reverse_cuthill_mckee(L); _rcm_end = time.time(); rev_perm = np.argsort(perm2); L = sp_permute(L, perm2, perm2, form); ss_args['info']['perm'].append('rcm'); ss_args['info']['rcm_time'] = _rcm_end-_rcm_start; if settings.debug:;",MatchSource.WIKI,docs/4.7/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/steadystate.html
https://qutip.org/docs/4.7/modules/qutip/steadystate.html:12209,Testability,log,logger,12209,"rror('Cannot calculate the steady state for a ' +; 'non-dissipative system ' +; '(no collapse operators given)'); elif issuper(A):; return A; else:; raise TypeError('Solving for steady states requires ' +; 'Liouvillian (super) operators'). def _steadystate_LU_liouvillian(L, ss_args, has_mkl=0):; """"""Creates modified Liouvillian for LU based SS methods.; """"""; perm = None; perm2 = None; rev_perm = None; n = int(np.sqrt(L.shape[0])); form = 'csr'; if has_mkl:; L = L.data + sp.csr_matrix(; (ss_args['weight']*np.ones(n), (np.zeros(n), [nn * (n + 1); for nn in range(n)])), shape=(n ** 2, n ** 2)); else:; form = 'csc'; L = L.data.tocsc() + sp.csc_matrix(; (ss_args['weight']*np.ones(n), (np.zeros(n), [nn * (n + 1); for nn in range(n)])), shape=(n ** 2, n ** 2)). if settings.debug:; old_band = sp_bandwidth(L)[0]; old_pro = sp_profile(L)[0]; logger.debug('Orig. NNZ: %i' % L.nnz); if ss_args['use_rcm']:; logger.debug('Original bandwidth: %i' % old_band). if ss_args['use_wbm']:; if settings.debug:; logger.debug('Calculating Weighted Bipartite Matching ordering...'); _wbm_start = time.time(); with warnings.catch_warnings():; warnings.filterwarnings(; ""ignore"", ""qutip graph functions are deprecated"",; DeprecationWarning,; ); perm = weighted_bipartite_matching(L); _wbm_end = time.time(); L = sp_permute(L, perm, [], form); ss_args['info']['perm'].append('wbm'); ss_args['info']['wbm_time'] = _wbm_end-_wbm_start; if settings.debug:; wbm_band = sp_bandwidth(L)[0]; logger.debug('WBM bandwidth: %i' % wbm_band). if ss_args['use_rcm']:; if settings.debug:; logger.debug('Calculating Reverse Cuthill-Mckee ordering...'); _rcm_start = time.time(); perm2 = sp.csgraph.reverse_cuthill_mckee(L); _rcm_end = time.time(); rev_perm = np.argsort(perm2); L = sp_permute(L, perm2, perm2, form); ss_args['info']['perm'].append('rcm'); ss_args['info']['rcm_time'] = _rcm_end-_rcm_start; if settings.debug:; rcm_band = sp_bandwidth(L)[0]; rcm_pro = sp_profile(L)[0]; logger.debug('RCM bandwidth: %i' % rcm_band); ",MatchSource.WIKI,docs/4.7/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/steadystate.html
https://qutip.org/docs/4.7/modules/qutip/steadystate.html:12677,Testability,log,logger,12677,"s_mkl:; L = L.data + sp.csr_matrix(; (ss_args['weight']*np.ones(n), (np.zeros(n), [nn * (n + 1); for nn in range(n)])), shape=(n ** 2, n ** 2)); else:; form = 'csc'; L = L.data.tocsc() + sp.csc_matrix(; (ss_args['weight']*np.ones(n), (np.zeros(n), [nn * (n + 1); for nn in range(n)])), shape=(n ** 2, n ** 2)). if settings.debug:; old_band = sp_bandwidth(L)[0]; old_pro = sp_profile(L)[0]; logger.debug('Orig. NNZ: %i' % L.nnz); if ss_args['use_rcm']:; logger.debug('Original bandwidth: %i' % old_band). if ss_args['use_wbm']:; if settings.debug:; logger.debug('Calculating Weighted Bipartite Matching ordering...'); _wbm_start = time.time(); with warnings.catch_warnings():; warnings.filterwarnings(; ""ignore"", ""qutip graph functions are deprecated"",; DeprecationWarning,; ); perm = weighted_bipartite_matching(L); _wbm_end = time.time(); L = sp_permute(L, perm, [], form); ss_args['info']['perm'].append('wbm'); ss_args['info']['wbm_time'] = _wbm_end-_wbm_start; if settings.debug:; wbm_band = sp_bandwidth(L)[0]; logger.debug('WBM bandwidth: %i' % wbm_band). if ss_args['use_rcm']:; if settings.debug:; logger.debug('Calculating Reverse Cuthill-Mckee ordering...'); _rcm_start = time.time(); perm2 = sp.csgraph.reverse_cuthill_mckee(L); _rcm_end = time.time(); rev_perm = np.argsort(perm2); L = sp_permute(L, perm2, perm2, form); ss_args['info']['perm'].append('rcm'); ss_args['info']['rcm_time'] = _rcm_end-_rcm_start; if settings.debug:; rcm_band = sp_bandwidth(L)[0]; rcm_pro = sp_profile(L)[0]; logger.debug('RCM bandwidth: %i' % rcm_band); logger.debug('Bandwidth reduction factor: %f' %; (old_band/rcm_band)); logger.debug('Profile reduction factor: %f' %; (old_pro/rcm_pro)); L.sort_indices(); return L, perm, perm2, rev_perm, ss_args. def steady(L, maxiter=10, tol=1e-12, itertol=1e-15, method='solve',; use_precond=False):; """"""; Deprecated. See steadystate instead.; """"""; message = ""steady has been deprecated, use steadystate instead""; warnings.warn(message, DeprecationWarning); return ",MatchSource.WIKI,docs/4.7/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/steadystate.html
https://qutip.org/docs/4.7/modules/qutip/steadystate.html:12767,Testability,log,logger,12767,"n range(n)])), shape=(n ** 2, n ** 2)); else:; form = 'csc'; L = L.data.tocsc() + sp.csc_matrix(; (ss_args['weight']*np.ones(n), (np.zeros(n), [nn * (n + 1); for nn in range(n)])), shape=(n ** 2, n ** 2)). if settings.debug:; old_band = sp_bandwidth(L)[0]; old_pro = sp_profile(L)[0]; logger.debug('Orig. NNZ: %i' % L.nnz); if ss_args['use_rcm']:; logger.debug('Original bandwidth: %i' % old_band). if ss_args['use_wbm']:; if settings.debug:; logger.debug('Calculating Weighted Bipartite Matching ordering...'); _wbm_start = time.time(); with warnings.catch_warnings():; warnings.filterwarnings(; ""ignore"", ""qutip graph functions are deprecated"",; DeprecationWarning,; ); perm = weighted_bipartite_matching(L); _wbm_end = time.time(); L = sp_permute(L, perm, [], form); ss_args['info']['perm'].append('wbm'); ss_args['info']['wbm_time'] = _wbm_end-_wbm_start; if settings.debug:; wbm_band = sp_bandwidth(L)[0]; logger.debug('WBM bandwidth: %i' % wbm_band). if ss_args['use_rcm']:; if settings.debug:; logger.debug('Calculating Reverse Cuthill-Mckee ordering...'); _rcm_start = time.time(); perm2 = sp.csgraph.reverse_cuthill_mckee(L); _rcm_end = time.time(); rev_perm = np.argsort(perm2); L = sp_permute(L, perm2, perm2, form); ss_args['info']['perm'].append('rcm'); ss_args['info']['rcm_time'] = _rcm_end-_rcm_start; if settings.debug:; rcm_band = sp_bandwidth(L)[0]; rcm_pro = sp_profile(L)[0]; logger.debug('RCM bandwidth: %i' % rcm_band); logger.debug('Bandwidth reduction factor: %f' %; (old_band/rcm_band)); logger.debug('Profile reduction factor: %f' %; (old_pro/rcm_pro)); L.sort_indices(); return L, perm, perm2, rev_perm, ss_args. def steady(L, maxiter=10, tol=1e-12, itertol=1e-15, method='solve',; use_precond=False):; """"""; Deprecated. See steadystate instead.; """"""; message = ""steady has been deprecated, use steadystate instead""; warnings.warn(message, DeprecationWarning); return steadystate(L, [], maxiter=maxiter, tol=tol,; use_precond=use_precond). def _steadystate_direct_sparse(L, ",MatchSource.WIKI,docs/4.7/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/steadystate.html
https://qutip.org/docs/4.7/modules/qutip/steadystate.html:13163,Testability,log,logger,13163,"nal bandwidth: %i' % old_band). if ss_args['use_wbm']:; if settings.debug:; logger.debug('Calculating Weighted Bipartite Matching ordering...'); _wbm_start = time.time(); with warnings.catch_warnings():; warnings.filterwarnings(; ""ignore"", ""qutip graph functions are deprecated"",; DeprecationWarning,; ); perm = weighted_bipartite_matching(L); _wbm_end = time.time(); L = sp_permute(L, perm, [], form); ss_args['info']['perm'].append('wbm'); ss_args['info']['wbm_time'] = _wbm_end-_wbm_start; if settings.debug:; wbm_band = sp_bandwidth(L)[0]; logger.debug('WBM bandwidth: %i' % wbm_band). if ss_args['use_rcm']:; if settings.debug:; logger.debug('Calculating Reverse Cuthill-Mckee ordering...'); _rcm_start = time.time(); perm2 = sp.csgraph.reverse_cuthill_mckee(L); _rcm_end = time.time(); rev_perm = np.argsort(perm2); L = sp_permute(L, perm2, perm2, form); ss_args['info']['perm'].append('rcm'); ss_args['info']['rcm_time'] = _rcm_end-_rcm_start; if settings.debug:; rcm_band = sp_bandwidth(L)[0]; rcm_pro = sp_profile(L)[0]; logger.debug('RCM bandwidth: %i' % rcm_band); logger.debug('Bandwidth reduction factor: %f' %; (old_band/rcm_band)); logger.debug('Profile reduction factor: %f' %; (old_pro/rcm_pro)); L.sort_indices(); return L, perm, perm2, rev_perm, ss_args. def steady(L, maxiter=10, tol=1e-12, itertol=1e-15, method='solve',; use_precond=False):; """"""; Deprecated. See steadystate instead.; """"""; message = ""steady has been deprecated, use steadystate instead""; warnings.warn(message, DeprecationWarning); return steadystate(L, [], maxiter=maxiter, tol=tol,; use_precond=use_precond). def _steadystate_direct_sparse(L, ss_args):; """"""; Direct solver that uses scipy sparse matrices; """"""; if settings.debug:; logger.debug('Starting direct LU solver.'). dims = L.dims[0]; n = int(np.sqrt(L.shape[0])); b = np.zeros(n ** 2, dtype=complex); b[0] = ss_args['weight']. if ss_args['solver'] == 'mkl':; has_mkl = 1; else:; has_mkl = 0. ss_lu_liouv_list = _steadystate_LU_liouvillian(L, ss_args,",MatchSource.WIKI,docs/4.7/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/steadystate.html
https://qutip.org/docs/4.7/modules/qutip/steadystate.html:13209,Testability,log,logger,13209,"ettings.debug:; logger.debug('Calculating Weighted Bipartite Matching ordering...'); _wbm_start = time.time(); with warnings.catch_warnings():; warnings.filterwarnings(; ""ignore"", ""qutip graph functions are deprecated"",; DeprecationWarning,; ); perm = weighted_bipartite_matching(L); _wbm_end = time.time(); L = sp_permute(L, perm, [], form); ss_args['info']['perm'].append('wbm'); ss_args['info']['wbm_time'] = _wbm_end-_wbm_start; if settings.debug:; wbm_band = sp_bandwidth(L)[0]; logger.debug('WBM bandwidth: %i' % wbm_band). if ss_args['use_rcm']:; if settings.debug:; logger.debug('Calculating Reverse Cuthill-Mckee ordering...'); _rcm_start = time.time(); perm2 = sp.csgraph.reverse_cuthill_mckee(L); _rcm_end = time.time(); rev_perm = np.argsort(perm2); L = sp_permute(L, perm2, perm2, form); ss_args['info']['perm'].append('rcm'); ss_args['info']['rcm_time'] = _rcm_end-_rcm_start; if settings.debug:; rcm_band = sp_bandwidth(L)[0]; rcm_pro = sp_profile(L)[0]; logger.debug('RCM bandwidth: %i' % rcm_band); logger.debug('Bandwidth reduction factor: %f' %; (old_band/rcm_band)); logger.debug('Profile reduction factor: %f' %; (old_pro/rcm_pro)); L.sort_indices(); return L, perm, perm2, rev_perm, ss_args. def steady(L, maxiter=10, tol=1e-12, itertol=1e-15, method='solve',; use_precond=False):; """"""; Deprecated. See steadystate instead.; """"""; message = ""steady has been deprecated, use steadystate instead""; warnings.warn(message, DeprecationWarning); return steadystate(L, [], maxiter=maxiter, tol=tol,; use_precond=use_precond). def _steadystate_direct_sparse(L, ss_args):; """"""; Direct solver that uses scipy sparse matrices; """"""; if settings.debug:; logger.debug('Starting direct LU solver.'). dims = L.dims[0]; n = int(np.sqrt(L.shape[0])); b = np.zeros(n ** 2, dtype=complex); b[0] = ss_args['weight']. if ss_args['solver'] == 'mkl':; has_mkl = 1; else:; has_mkl = 0. ss_lu_liouv_list = _steadystate_LU_liouvillian(L, ss_args, has_mkl); L, perm, perm2, rev_perm, ss_args = ss_lu_liouv_l",MatchSource.WIKI,docs/4.7/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/steadystate.html
https://qutip.org/docs/4.7/modules/qutip/steadystate.html:13280,Testability,log,logger,13280,"te Matching ordering...'); _wbm_start = time.time(); with warnings.catch_warnings():; warnings.filterwarnings(; ""ignore"", ""qutip graph functions are deprecated"",; DeprecationWarning,; ); perm = weighted_bipartite_matching(L); _wbm_end = time.time(); L = sp_permute(L, perm, [], form); ss_args['info']['perm'].append('wbm'); ss_args['info']['wbm_time'] = _wbm_end-_wbm_start; if settings.debug:; wbm_band = sp_bandwidth(L)[0]; logger.debug('WBM bandwidth: %i' % wbm_band). if ss_args['use_rcm']:; if settings.debug:; logger.debug('Calculating Reverse Cuthill-Mckee ordering...'); _rcm_start = time.time(); perm2 = sp.csgraph.reverse_cuthill_mckee(L); _rcm_end = time.time(); rev_perm = np.argsort(perm2); L = sp_permute(L, perm2, perm2, form); ss_args['info']['perm'].append('rcm'); ss_args['info']['rcm_time'] = _rcm_end-_rcm_start; if settings.debug:; rcm_band = sp_bandwidth(L)[0]; rcm_pro = sp_profile(L)[0]; logger.debug('RCM bandwidth: %i' % rcm_band); logger.debug('Bandwidth reduction factor: %f' %; (old_band/rcm_band)); logger.debug('Profile reduction factor: %f' %; (old_pro/rcm_pro)); L.sort_indices(); return L, perm, perm2, rev_perm, ss_args. def steady(L, maxiter=10, tol=1e-12, itertol=1e-15, method='solve',; use_precond=False):; """"""; Deprecated. See steadystate instead.; """"""; message = ""steady has been deprecated, use steadystate instead""; warnings.warn(message, DeprecationWarning); return steadystate(L, [], maxiter=maxiter, tol=tol,; use_precond=use_precond). def _steadystate_direct_sparse(L, ss_args):; """"""; Direct solver that uses scipy sparse matrices; """"""; if settings.debug:; logger.debug('Starting direct LU solver.'). dims = L.dims[0]; n = int(np.sqrt(L.shape[0])); b = np.zeros(n ** 2, dtype=complex); b[0] = ss_args['weight']. if ss_args['solver'] == 'mkl':; has_mkl = 1; else:; has_mkl = 0. ss_lu_liouv_list = _steadystate_LU_liouvillian(L, ss_args, has_mkl); L, perm, perm2, rev_perm, ss_args = ss_lu_liouv_list; if np.any(perm):; b = b[np.ix_(perm,)]; if np.any(perm",MatchSource.WIKI,docs/4.7/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/steadystate.html
https://qutip.org/docs/4.7/modules/qutip/steadystate.html:13855,Testability,log,logger,13855,"; perm2 = sp.csgraph.reverse_cuthill_mckee(L); _rcm_end = time.time(); rev_perm = np.argsort(perm2); L = sp_permute(L, perm2, perm2, form); ss_args['info']['perm'].append('rcm'); ss_args['info']['rcm_time'] = _rcm_end-_rcm_start; if settings.debug:; rcm_band = sp_bandwidth(L)[0]; rcm_pro = sp_profile(L)[0]; logger.debug('RCM bandwidth: %i' % rcm_band); logger.debug('Bandwidth reduction factor: %f' %; (old_band/rcm_band)); logger.debug('Profile reduction factor: %f' %; (old_pro/rcm_pro)); L.sort_indices(); return L, perm, perm2, rev_perm, ss_args. def steady(L, maxiter=10, tol=1e-12, itertol=1e-15, method='solve',; use_precond=False):; """"""; Deprecated. See steadystate instead.; """"""; message = ""steady has been deprecated, use steadystate instead""; warnings.warn(message, DeprecationWarning); return steadystate(L, [], maxiter=maxiter, tol=tol,; use_precond=use_precond). def _steadystate_direct_sparse(L, ss_args):; """"""; Direct solver that uses scipy sparse matrices; """"""; if settings.debug:; logger.debug('Starting direct LU solver.'). dims = L.dims[0]; n = int(np.sqrt(L.shape[0])); b = np.zeros(n ** 2, dtype=complex); b[0] = ss_args['weight']. if ss_args['solver'] == 'mkl':; has_mkl = 1; else:; has_mkl = 0. ss_lu_liouv_list = _steadystate_LU_liouvillian(L, ss_args, has_mkl); L, perm, perm2, rev_perm, ss_args = ss_lu_liouv_list; if np.any(perm):; b = b[np.ix_(perm,)]; if np.any(perm2):; b = b[np.ix_(perm2,)]. if ss_args['solver'] == 'scipy':; ss_args['info']['permc_spec'] = ss_args['permc_spec']; ss_args['info']['drop_tol'] = ss_args['drop_tol']; ss_args['info']['diag_pivot_thresh'] = ss_args['diag_pivot_thresh']; ss_args['info']['fill_factor'] = ss_args['fill_factor']; ss_args['info']['ILU_MILU'] = ss_args['ILU_MILU']. if not ss_args['solver'] == 'mkl':; # Use superLU solver; orig_nnz = L.nnz; _direct_start = time.time(); lu = splu(L, permc_spec=ss_args['permc_spec'],; diag_pivot_thresh=ss_args['diag_pivot_thresh'],; options=dict(ILU_MILU=ss_args['ILU_MILU'])); v = lu.solv",MatchSource.WIKI,docs/4.7/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/steadystate.html
https://qutip.org/docs/4.7/modules/qutip/steadystate.html:15183,Testability,log,logger,15183,"_lu_liouv_list; if np.any(perm):; b = b[np.ix_(perm,)]; if np.any(perm2):; b = b[np.ix_(perm2,)]. if ss_args['solver'] == 'scipy':; ss_args['info']['permc_spec'] = ss_args['permc_spec']; ss_args['info']['drop_tol'] = ss_args['drop_tol']; ss_args['info']['diag_pivot_thresh'] = ss_args['diag_pivot_thresh']; ss_args['info']['fill_factor'] = ss_args['fill_factor']; ss_args['info']['ILU_MILU'] = ss_args['ILU_MILU']. if not ss_args['solver'] == 'mkl':; # Use superLU solver; orig_nnz = L.nnz; _direct_start = time.time(); lu = splu(L, permc_spec=ss_args['permc_spec'],; diag_pivot_thresh=ss_args['diag_pivot_thresh'],; options=dict(ILU_MILU=ss_args['ILU_MILU'])); v = lu.solve(b); _direct_end = time.time(); ss_args['info']['solution_time'] = _direct_end - _direct_start; if (settings.debug or ss_args['return_info']):; L_nnz = lu.L.nnz; U_nnz = lu.U.nnz; ss_args['info']['l_nnz'] = L_nnz; ss_args['info']['u_nnz'] = U_nnz; ss_args['info']['lu_fill_factor'] = (L_nnz + U_nnz)/L.nnz; if settings.debug:; logger.debug('L NNZ: %i ; U NNZ: %i' % (L_nnz, U_nnz)); logger.debug('Fill factor: %f' % ((L_nnz + U_nnz)/orig_nnz)). else: # Use MKL solver; if len(ss_args['info']['perm']) != 0:; in_perm = np.arange(n**2, dtype=np.int32); else:; in_perm = None; _direct_start = time.time(); v = mkl_spsolve(L, b, perm=in_perm, verbose=ss_args['verbose'],; max_iter_refine=ss_args['max_iter_refine'],; scaling_vectors=ss_args['scaling_vectors'],; weighted_matching=ss_args['weighted_matching']); _direct_end = time.time(); ss_args['info']['solution_time'] = _direct_end-_direct_start. if ss_args['return_info']:; ss_args['info']['residual_norm'] = la.norm(b - L*v, np.inf); ss_args['info']['max_iter_refine'] = ss_args['max_iter_refine']; ss_args['info']['scaling_vectors'] = ss_args['scaling_vectors']; ss_args['info']['weighted_matching'] = ss_args['weighted_matching']. if ss_args['use_rcm']:; v = v[np.ix_(rev_perm,)]. data = dense2D_to_fastcsr_fmode(vec2mat(v), n, n); data = 0.5 * (data + data.H); if ss_args['",MatchSource.WIKI,docs/4.7/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/steadystate.html
https://qutip.org/docs/4.7/modules/qutip/steadystate.html:15239,Testability,log,logger,15239,"= b[np.ix_(perm,)]; if np.any(perm2):; b = b[np.ix_(perm2,)]. if ss_args['solver'] == 'scipy':; ss_args['info']['permc_spec'] = ss_args['permc_spec']; ss_args['info']['drop_tol'] = ss_args['drop_tol']; ss_args['info']['diag_pivot_thresh'] = ss_args['diag_pivot_thresh']; ss_args['info']['fill_factor'] = ss_args['fill_factor']; ss_args['info']['ILU_MILU'] = ss_args['ILU_MILU']. if not ss_args['solver'] == 'mkl':; # Use superLU solver; orig_nnz = L.nnz; _direct_start = time.time(); lu = splu(L, permc_spec=ss_args['permc_spec'],; diag_pivot_thresh=ss_args['diag_pivot_thresh'],; options=dict(ILU_MILU=ss_args['ILU_MILU'])); v = lu.solve(b); _direct_end = time.time(); ss_args['info']['solution_time'] = _direct_end - _direct_start; if (settings.debug or ss_args['return_info']):; L_nnz = lu.L.nnz; U_nnz = lu.U.nnz; ss_args['info']['l_nnz'] = L_nnz; ss_args['info']['u_nnz'] = U_nnz; ss_args['info']['lu_fill_factor'] = (L_nnz + U_nnz)/L.nnz; if settings.debug:; logger.debug('L NNZ: %i ; U NNZ: %i' % (L_nnz, U_nnz)); logger.debug('Fill factor: %f' % ((L_nnz + U_nnz)/orig_nnz)). else: # Use MKL solver; if len(ss_args['info']['perm']) != 0:; in_perm = np.arange(n**2, dtype=np.int32); else:; in_perm = None; _direct_start = time.time(); v = mkl_spsolve(L, b, perm=in_perm, verbose=ss_args['verbose'],; max_iter_refine=ss_args['max_iter_refine'],; scaling_vectors=ss_args['scaling_vectors'],; weighted_matching=ss_args['weighted_matching']); _direct_end = time.time(); ss_args['info']['solution_time'] = _direct_end-_direct_start. if ss_args['return_info']:; ss_args['info']['residual_norm'] = la.norm(b - L*v, np.inf); ss_args['info']['max_iter_refine'] = ss_args['max_iter_refine']; ss_args['info']['scaling_vectors'] = ss_args['scaling_vectors']; ss_args['info']['weighted_matching'] = ss_args['weighted_matching']. if ss_args['use_rcm']:; v = v[np.ix_(rev_perm,)]. data = dense2D_to_fastcsr_fmode(vec2mat(v), n, n); data = 0.5 * (data + data.H); if ss_args['return_info']:; return Qobj(data, d",MatchSource.WIKI,docs/4.7/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/steadystate.html
https://qutip.org/docs/4.7/modules/qutip/steadystate.html:16467,Testability,log,logger,16467,"_spsolve(L, b, perm=in_perm, verbose=ss_args['verbose'],; max_iter_refine=ss_args['max_iter_refine'],; scaling_vectors=ss_args['scaling_vectors'],; weighted_matching=ss_args['weighted_matching']); _direct_end = time.time(); ss_args['info']['solution_time'] = _direct_end-_direct_start. if ss_args['return_info']:; ss_args['info']['residual_norm'] = la.norm(b - L*v, np.inf); ss_args['info']['max_iter_refine'] = ss_args['max_iter_refine']; ss_args['info']['scaling_vectors'] = ss_args['scaling_vectors']; ss_args['info']['weighted_matching'] = ss_args['weighted_matching']. if ss_args['use_rcm']:; v = v[np.ix_(rev_perm,)]. data = dense2D_to_fastcsr_fmode(vec2mat(v), n, n); data = 0.5 * (data + data.H); if ss_args['return_info']:; return Qobj(data, dims=dims, isherm=True), ss_args['info']; else:; return Qobj(data, dims=dims, isherm=True). def _steadystate_direct_dense(L, ss_args):; """"""; Direct solver that uses numpy arrays. Suitable for small systems with few; states.; """"""; if settings.debug:; logger.debug('Starting direct dense solver.'). dims = L.dims[0]; n = int(np.sqrt(L.shape[0])); b = np.zeros(n ** 2); b[0] = ss_args['weight']. L = L.full(); L[0, :] += np.diag(ss_args['weight']*np.ones(n)).reshape(n ** 2); _dense_start = time.time(); v = np.linalg.solve(L, b); _dense_end = time.time(); ss_args['info']['solution_time'] = _dense_end-_dense_start; if ss_args['return_info']:; ss_args['info']['residual_norm'] = la.norm(b - L@v, np.inf); data = vec2mat(v); data = 0.5 * (data + data.conj().T). return Qobj(data, dims=dims, isherm=True). def _steadystate_eigen(L, ss_args):; """"""; Internal function for solving the steady state problem by; finding the eigenvector corresponding to the zero eigenvalue; of the Liouvillian using ARPACK.; """"""; ss_args['info'].pop('weight', None); if settings.debug:; logger.debug('Starting Eigen solver.'). dims = L.dims[0]; L = L.data.tocsc(). if ss_args['use_rcm']:; ss_args['info']['perm'].append('rcm'); if settings.debug:; old_band = sp_bandwidth(L)[0",MatchSource.WIKI,docs/4.7/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/steadystate.html
https://qutip.org/docs/4.7/modules/qutip/steadystate.html:17278,Testability,log,logger,17278,"(data, dims=dims, isherm=True). def _steadystate_direct_dense(L, ss_args):; """"""; Direct solver that uses numpy arrays. Suitable for small systems with few; states.; """"""; if settings.debug:; logger.debug('Starting direct dense solver.'). dims = L.dims[0]; n = int(np.sqrt(L.shape[0])); b = np.zeros(n ** 2); b[0] = ss_args['weight']. L = L.full(); L[0, :] += np.diag(ss_args['weight']*np.ones(n)).reshape(n ** 2); _dense_start = time.time(); v = np.linalg.solve(L, b); _dense_end = time.time(); ss_args['info']['solution_time'] = _dense_end-_dense_start; if ss_args['return_info']:; ss_args['info']['residual_norm'] = la.norm(b - L@v, np.inf); data = vec2mat(v); data = 0.5 * (data + data.conj().T). return Qobj(data, dims=dims, isherm=True). def _steadystate_eigen(L, ss_args):; """"""; Internal function for solving the steady state problem by; finding the eigenvector corresponding to the zero eigenvalue; of the Liouvillian using ARPACK.; """"""; ss_args['info'].pop('weight', None); if settings.debug:; logger.debug('Starting Eigen solver.'). dims = L.dims[0]; L = L.data.tocsc(). if ss_args['use_rcm']:; ss_args['info']['perm'].append('rcm'); if settings.debug:; old_band = sp_bandwidth(L)[0]; logger.debug('Original bandwidth: %i' % old_band); perm = sp.csgraph.reverse_cuthill_mckee(L); rev_perm = np.argsort(perm); L = sp_permute(L, perm, perm, 'csc'); if settings.debug:; rcm_band = sp_bandwidth(L)[0]; logger.debug('RCM bandwidth: %i' % rcm_band); logger.debug('Bandwidth reduction factor: %f' %; (old_band/rcm_band)). _eigen_start = time.time(); eigval, eigvec = eigs(L, k=1, sigma=1e-15, tol=ss_args['tol'],; which='LM', maxiter=ss_args['maxiter']); _eigen_end = time.time(); ss_args['info']['solution_time'] = _eigen_end - _eigen_start; if ss_args['return_info']:; ss_args['info']['residual_norm'] = la.norm(L*eigvec, np.inf); if ss_args['use_rcm']:; eigvec = eigvec[np.ix_(rev_perm,)]; _temp = vec2mat(eigvec); data = dense2D_to_fastcsr_fmode(_temp, _temp.shape[0], _temp.shape[1]); data = 0.5",MatchSource.WIKI,docs/4.7/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/steadystate.html
https://qutip.org/docs/4.7/modules/qutip/steadystate.html:17470,Testability,log,logger,17470,"ings.debug:; logger.debug('Starting direct dense solver.'). dims = L.dims[0]; n = int(np.sqrt(L.shape[0])); b = np.zeros(n ** 2); b[0] = ss_args['weight']. L = L.full(); L[0, :] += np.diag(ss_args['weight']*np.ones(n)).reshape(n ** 2); _dense_start = time.time(); v = np.linalg.solve(L, b); _dense_end = time.time(); ss_args['info']['solution_time'] = _dense_end-_dense_start; if ss_args['return_info']:; ss_args['info']['residual_norm'] = la.norm(b - L@v, np.inf); data = vec2mat(v); data = 0.5 * (data + data.conj().T). return Qobj(data, dims=dims, isherm=True). def _steadystate_eigen(L, ss_args):; """"""; Internal function for solving the steady state problem by; finding the eigenvector corresponding to the zero eigenvalue; of the Liouvillian using ARPACK.; """"""; ss_args['info'].pop('weight', None); if settings.debug:; logger.debug('Starting Eigen solver.'). dims = L.dims[0]; L = L.data.tocsc(). if ss_args['use_rcm']:; ss_args['info']['perm'].append('rcm'); if settings.debug:; old_band = sp_bandwidth(L)[0]; logger.debug('Original bandwidth: %i' % old_band); perm = sp.csgraph.reverse_cuthill_mckee(L); rev_perm = np.argsort(perm); L = sp_permute(L, perm, perm, 'csc'); if settings.debug:; rcm_band = sp_bandwidth(L)[0]; logger.debug('RCM bandwidth: %i' % rcm_band); logger.debug('Bandwidth reduction factor: %f' %; (old_band/rcm_band)). _eigen_start = time.time(); eigval, eigvec = eigs(L, k=1, sigma=1e-15, tol=ss_args['tol'],; which='LM', maxiter=ss_args['maxiter']); _eigen_end = time.time(); ss_args['info']['solution_time'] = _eigen_end - _eigen_start; if ss_args['return_info']:; ss_args['info']['residual_norm'] = la.norm(L*eigvec, np.inf); if ss_args['use_rcm']:; eigvec = eigvec[np.ix_(rev_perm,)]; _temp = vec2mat(eigvec); data = dense2D_to_fastcsr_fmode(_temp, _temp.shape[0], _temp.shape[1]); data = 0.5 * (data + data.H); out = Qobj(data, dims=dims, isherm=True); if ss_args['return_info']:; return out/out.tr(), ss_args['info']; else:; return out/out.tr(). def _iterative_preco",MatchSource.WIKI,docs/4.7/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/steadystate.html
https://qutip.org/docs/4.7/modules/qutip/steadystate.html:17683,Testability,log,logger,17683,"s(n)).reshape(n ** 2); _dense_start = time.time(); v = np.linalg.solve(L, b); _dense_end = time.time(); ss_args['info']['solution_time'] = _dense_end-_dense_start; if ss_args['return_info']:; ss_args['info']['residual_norm'] = la.norm(b - L@v, np.inf); data = vec2mat(v); data = 0.5 * (data + data.conj().T). return Qobj(data, dims=dims, isherm=True). def _steadystate_eigen(L, ss_args):; """"""; Internal function for solving the steady state problem by; finding the eigenvector corresponding to the zero eigenvalue; of the Liouvillian using ARPACK.; """"""; ss_args['info'].pop('weight', None); if settings.debug:; logger.debug('Starting Eigen solver.'). dims = L.dims[0]; L = L.data.tocsc(). if ss_args['use_rcm']:; ss_args['info']['perm'].append('rcm'); if settings.debug:; old_band = sp_bandwidth(L)[0]; logger.debug('Original bandwidth: %i' % old_band); perm = sp.csgraph.reverse_cuthill_mckee(L); rev_perm = np.argsort(perm); L = sp_permute(L, perm, perm, 'csc'); if settings.debug:; rcm_band = sp_bandwidth(L)[0]; logger.debug('RCM bandwidth: %i' % rcm_band); logger.debug('Bandwidth reduction factor: %f' %; (old_band/rcm_band)). _eigen_start = time.time(); eigval, eigvec = eigs(L, k=1, sigma=1e-15, tol=ss_args['tol'],; which='LM', maxiter=ss_args['maxiter']); _eigen_end = time.time(); ss_args['info']['solution_time'] = _eigen_end - _eigen_start; if ss_args['return_info']:; ss_args['info']['residual_norm'] = la.norm(L*eigvec, np.inf); if ss_args['use_rcm']:; eigvec = eigvec[np.ix_(rev_perm,)]; _temp = vec2mat(eigvec); data = dense2D_to_fastcsr_fmode(_temp, _temp.shape[0], _temp.shape[1]); data = 0.5 * (data + data.H); out = Qobj(data, dims=dims, isherm=True); if ss_args['return_info']:; return out/out.tr(), ss_args['info']; else:; return out/out.tr(). def _iterative_precondition(A, n, ss_args):; """"""; Internal function for preconditioning the steadystate problem for use; with iterative solvers.; """"""; if settings.debug:; logger.debug('Starting preconditioner.'); _precond_start = tim",MatchSource.WIKI,docs/4.7/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/steadystate.html
https://qutip.org/docs/4.7/modules/qutip/steadystate.html:17729,Testability,log,logger,17729,"e(); v = np.linalg.solve(L, b); _dense_end = time.time(); ss_args['info']['solution_time'] = _dense_end-_dense_start; if ss_args['return_info']:; ss_args['info']['residual_norm'] = la.norm(b - L@v, np.inf); data = vec2mat(v); data = 0.5 * (data + data.conj().T). return Qobj(data, dims=dims, isherm=True). def _steadystate_eigen(L, ss_args):; """"""; Internal function for solving the steady state problem by; finding the eigenvector corresponding to the zero eigenvalue; of the Liouvillian using ARPACK.; """"""; ss_args['info'].pop('weight', None); if settings.debug:; logger.debug('Starting Eigen solver.'). dims = L.dims[0]; L = L.data.tocsc(). if ss_args['use_rcm']:; ss_args['info']['perm'].append('rcm'); if settings.debug:; old_band = sp_bandwidth(L)[0]; logger.debug('Original bandwidth: %i' % old_band); perm = sp.csgraph.reverse_cuthill_mckee(L); rev_perm = np.argsort(perm); L = sp_permute(L, perm, perm, 'csc'); if settings.debug:; rcm_band = sp_bandwidth(L)[0]; logger.debug('RCM bandwidth: %i' % rcm_band); logger.debug('Bandwidth reduction factor: %f' %; (old_band/rcm_band)). _eigen_start = time.time(); eigval, eigvec = eigs(L, k=1, sigma=1e-15, tol=ss_args['tol'],; which='LM', maxiter=ss_args['maxiter']); _eigen_end = time.time(); ss_args['info']['solution_time'] = _eigen_end - _eigen_start; if ss_args['return_info']:; ss_args['info']['residual_norm'] = la.norm(L*eigvec, np.inf); if ss_args['use_rcm']:; eigvec = eigvec[np.ix_(rev_perm,)]; _temp = vec2mat(eigvec); data = dense2D_to_fastcsr_fmode(_temp, _temp.shape[0], _temp.shape[1]); data = 0.5 * (data + data.H); out = Qobj(data, dims=dims, isherm=True); if ss_args['return_info']:; return out/out.tr(), ss_args['info']; else:; return out/out.tr(). def _iterative_precondition(A, n, ss_args):; """"""; Internal function for preconditioning the steadystate problem for use; with iterative solvers.; """"""; if settings.debug:; logger.debug('Starting preconditioner.'); _precond_start = time.time(); try:; P = spilu(A, permc_spec=ss_arg",MatchSource.WIKI,docs/4.7/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/steadystate.html
https://qutip.org/docs/4.7/modules/qutip/steadystate.html:18605,Testability,log,logger,18605,"mute(L, perm, perm, 'csc'); if settings.debug:; rcm_band = sp_bandwidth(L)[0]; logger.debug('RCM bandwidth: %i' % rcm_band); logger.debug('Bandwidth reduction factor: %f' %; (old_band/rcm_band)). _eigen_start = time.time(); eigval, eigvec = eigs(L, k=1, sigma=1e-15, tol=ss_args['tol'],; which='LM', maxiter=ss_args['maxiter']); _eigen_end = time.time(); ss_args['info']['solution_time'] = _eigen_end - _eigen_start; if ss_args['return_info']:; ss_args['info']['residual_norm'] = la.norm(L*eigvec, np.inf); if ss_args['use_rcm']:; eigvec = eigvec[np.ix_(rev_perm,)]; _temp = vec2mat(eigvec); data = dense2D_to_fastcsr_fmode(_temp, _temp.shape[0], _temp.shape[1]); data = 0.5 * (data + data.H); out = Qobj(data, dims=dims, isherm=True); if ss_args['return_info']:; return out/out.tr(), ss_args['info']; else:; return out/out.tr(). def _iterative_precondition(A, n, ss_args):; """"""; Internal function for preconditioning the steadystate problem for use; with iterative solvers.; """"""; if settings.debug:; logger.debug('Starting preconditioner.'); _precond_start = time.time(); try:; P = spilu(A, permc_spec=ss_args['permc_spec'],; drop_tol=ss_args['drop_tol'],; diag_pivot_thresh=ss_args['diag_pivot_thresh'],; fill_factor=ss_args['fill_factor'],; options=dict(ILU_MILU=ss_args['ILU_MILU'])). M = LinearOperator((n ** 2, n ** 2), matvec=P.solve); _precond_end = time.time(); ss_args['info']['permc_spec'] = ss_args['permc_spec']; ss_args['info']['drop_tol'] = ss_args['drop_tol']; ss_args['info']['diag_pivot_thresh'] = ss_args['diag_pivot_thresh']; ss_args['info']['fill_factor'] = ss_args['fill_factor']; ss_args['info']['ILU_MILU'] = ss_args['ILU_MILU']; ss_args['info']['precond_time'] = _precond_end-_precond_start. if settings.debug or ss_args['return_info']:; if settings.debug:; logger.debug('Preconditioning succeeded.'); logger.debug('Precond. time: %f' %; (_precond_end - _precond_start)); L_nnz = P.L.nnz; U_nnz = P.U.nnz; ss_args['info']['l_nnz'] = L_nnz; ss_args['info']['u_nnz'] = U_nnz; ss",MatchSource.WIKI,docs/4.7/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/steadystate.html
https://qutip.org/docs/4.7/modules/qutip/steadystate.html:19387,Testability,log,logger,19387,"), ss_args['info']; else:; return out/out.tr(). def _iterative_precondition(A, n, ss_args):; """"""; Internal function for preconditioning the steadystate problem for use; with iterative solvers.; """"""; if settings.debug:; logger.debug('Starting preconditioner.'); _precond_start = time.time(); try:; P = spilu(A, permc_spec=ss_args['permc_spec'],; drop_tol=ss_args['drop_tol'],; diag_pivot_thresh=ss_args['diag_pivot_thresh'],; fill_factor=ss_args['fill_factor'],; options=dict(ILU_MILU=ss_args['ILU_MILU'])). M = LinearOperator((n ** 2, n ** 2), matvec=P.solve); _precond_end = time.time(); ss_args['info']['permc_spec'] = ss_args['permc_spec']; ss_args['info']['drop_tol'] = ss_args['drop_tol']; ss_args['info']['diag_pivot_thresh'] = ss_args['diag_pivot_thresh']; ss_args['info']['fill_factor'] = ss_args['fill_factor']; ss_args['info']['ILU_MILU'] = ss_args['ILU_MILU']; ss_args['info']['precond_time'] = _precond_end-_precond_start. if settings.debug or ss_args['return_info']:; if settings.debug:; logger.debug('Preconditioning succeeded.'); logger.debug('Precond. time: %f' %; (_precond_end - _precond_start)); L_nnz = P.L.nnz; U_nnz = P.U.nnz; ss_args['info']['l_nnz'] = L_nnz; ss_args['info']['u_nnz'] = U_nnz; ss_args['info']['ilu_fill_factor'] = (L_nnz+U_nnz)/A.nnz; e = np.ones(n ** 2, dtype=int); condest = la.norm(M*e, np.inf); ss_args['info']['ilu_condest'] = condest; if settings.debug:; logger.debug('L NNZ: %i ; U NNZ: %i' % (L_nnz, U_nnz)); logger.debug('Fill factor: %f' % ((L_nnz+U_nnz)/A.nnz)); logger.debug('iLU condest: %f' % condest). except Exception:; raise Exception(""Failed to build preconditioner. Try increasing "" +; ""fill_factor and/or drop_tol.""). return M, ss_args. def _steadystate_iterative(L, ss_args):; """"""; Iterative steady state solver using the GMRES, LGMRES, or BICGSTAB; algorithm and a sparse incomplete LU preconditioner.; """"""; ss_iters = {'iter': 0}. def _iter_count(r):; ss_iters['iter'] += 1; return. if settings.debug:; logger.debug('Starting %s solver.' ",MatchSource.WIKI,docs/4.7/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/steadystate.html
https://qutip.org/docs/4.7/modules/qutip/steadystate.html:19431,Testability,log,logger,19431,". def _iterative_precondition(A, n, ss_args):; """"""; Internal function for preconditioning the steadystate problem for use; with iterative solvers.; """"""; if settings.debug:; logger.debug('Starting preconditioner.'); _precond_start = time.time(); try:; P = spilu(A, permc_spec=ss_args['permc_spec'],; drop_tol=ss_args['drop_tol'],; diag_pivot_thresh=ss_args['diag_pivot_thresh'],; fill_factor=ss_args['fill_factor'],; options=dict(ILU_MILU=ss_args['ILU_MILU'])). M = LinearOperator((n ** 2, n ** 2), matvec=P.solve); _precond_end = time.time(); ss_args['info']['permc_spec'] = ss_args['permc_spec']; ss_args['info']['drop_tol'] = ss_args['drop_tol']; ss_args['info']['diag_pivot_thresh'] = ss_args['diag_pivot_thresh']; ss_args['info']['fill_factor'] = ss_args['fill_factor']; ss_args['info']['ILU_MILU'] = ss_args['ILU_MILU']; ss_args['info']['precond_time'] = _precond_end-_precond_start. if settings.debug or ss_args['return_info']:; if settings.debug:; logger.debug('Preconditioning succeeded.'); logger.debug('Precond. time: %f' %; (_precond_end - _precond_start)); L_nnz = P.L.nnz; U_nnz = P.U.nnz; ss_args['info']['l_nnz'] = L_nnz; ss_args['info']['u_nnz'] = U_nnz; ss_args['info']['ilu_fill_factor'] = (L_nnz+U_nnz)/A.nnz; e = np.ones(n ** 2, dtype=int); condest = la.norm(M*e, np.inf); ss_args['info']['ilu_condest'] = condest; if settings.debug:; logger.debug('L NNZ: %i ; U NNZ: %i' % (L_nnz, U_nnz)); logger.debug('Fill factor: %f' % ((L_nnz+U_nnz)/A.nnz)); logger.debug('iLU condest: %f' % condest). except Exception:; raise Exception(""Failed to build preconditioner. Try increasing "" +; ""fill_factor and/or drop_tol.""). return M, ss_args. def _steadystate_iterative(L, ss_args):; """"""; Iterative steady state solver using the GMRES, LGMRES, or BICGSTAB; algorithm and a sparse incomplete LU preconditioner.; """"""; ss_iters = {'iter': 0}. def _iter_count(r):; ss_iters['iter'] += 1; return. if settings.debug:; logger.debug('Starting %s solver.' % ss_args['method']). dims = L.dims[0]; n = in",MatchSource.WIKI,docs/4.7/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/steadystate.html
https://qutip.org/docs/4.7/modules/qutip/steadystate.html:19787,Testability,log,logger,19787,"s['diag_pivot_thresh'],; fill_factor=ss_args['fill_factor'],; options=dict(ILU_MILU=ss_args['ILU_MILU'])). M = LinearOperator((n ** 2, n ** 2), matvec=P.solve); _precond_end = time.time(); ss_args['info']['permc_spec'] = ss_args['permc_spec']; ss_args['info']['drop_tol'] = ss_args['drop_tol']; ss_args['info']['diag_pivot_thresh'] = ss_args['diag_pivot_thresh']; ss_args['info']['fill_factor'] = ss_args['fill_factor']; ss_args['info']['ILU_MILU'] = ss_args['ILU_MILU']; ss_args['info']['precond_time'] = _precond_end-_precond_start. if settings.debug or ss_args['return_info']:; if settings.debug:; logger.debug('Preconditioning succeeded.'); logger.debug('Precond. time: %f' %; (_precond_end - _precond_start)); L_nnz = P.L.nnz; U_nnz = P.U.nnz; ss_args['info']['l_nnz'] = L_nnz; ss_args['info']['u_nnz'] = U_nnz; ss_args['info']['ilu_fill_factor'] = (L_nnz+U_nnz)/A.nnz; e = np.ones(n ** 2, dtype=int); condest = la.norm(M*e, np.inf); ss_args['info']['ilu_condest'] = condest; if settings.debug:; logger.debug('L NNZ: %i ; U NNZ: %i' % (L_nnz, U_nnz)); logger.debug('Fill factor: %f' % ((L_nnz+U_nnz)/A.nnz)); logger.debug('iLU condest: %f' % condest). except Exception:; raise Exception(""Failed to build preconditioner. Try increasing "" +; ""fill_factor and/or drop_tol.""). return M, ss_args. def _steadystate_iterative(L, ss_args):; """"""; Iterative steady state solver using the GMRES, LGMRES, or BICGSTAB; algorithm and a sparse incomplete LU preconditioner.; """"""; ss_iters = {'iter': 0}. def _iter_count(r):; ss_iters['iter'] += 1; return. if settings.debug:; logger.debug('Starting %s solver.' % ss_args['method']). dims = L.dims[0]; n = int(np.sqrt(L.shape[0])); b = np.zeros(n ** 2); b[0] = ss_args['weight']. L, perm, perm2, rev_perm, ss_args = _steadystate_LU_liouvillian(L, ss_args); if np.any(perm):; b = b[np.ix_(perm,)]; if np.any(perm2):; b = b[np.ix_(perm2,)]. use_solver(assumeSortedIndices=True). if ss_args['M'] is None and ss_args['use_precond']:; ss_args['M'], ss_args = _iterati",MatchSource.WIKI,docs/4.7/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/steadystate.html
https://qutip.org/docs/4.7/modules/qutip/steadystate.html:19843,Testability,log,logger,19843,"=ss_args['fill_factor'],; options=dict(ILU_MILU=ss_args['ILU_MILU'])). M = LinearOperator((n ** 2, n ** 2), matvec=P.solve); _precond_end = time.time(); ss_args['info']['permc_spec'] = ss_args['permc_spec']; ss_args['info']['drop_tol'] = ss_args['drop_tol']; ss_args['info']['diag_pivot_thresh'] = ss_args['diag_pivot_thresh']; ss_args['info']['fill_factor'] = ss_args['fill_factor']; ss_args['info']['ILU_MILU'] = ss_args['ILU_MILU']; ss_args['info']['precond_time'] = _precond_end-_precond_start. if settings.debug or ss_args['return_info']:; if settings.debug:; logger.debug('Preconditioning succeeded.'); logger.debug('Precond. time: %f' %; (_precond_end - _precond_start)); L_nnz = P.L.nnz; U_nnz = P.U.nnz; ss_args['info']['l_nnz'] = L_nnz; ss_args['info']['u_nnz'] = U_nnz; ss_args['info']['ilu_fill_factor'] = (L_nnz+U_nnz)/A.nnz; e = np.ones(n ** 2, dtype=int); condest = la.norm(M*e, np.inf); ss_args['info']['ilu_condest'] = condest; if settings.debug:; logger.debug('L NNZ: %i ; U NNZ: %i' % (L_nnz, U_nnz)); logger.debug('Fill factor: %f' % ((L_nnz+U_nnz)/A.nnz)); logger.debug('iLU condest: %f' % condest). except Exception:; raise Exception(""Failed to build preconditioner. Try increasing "" +; ""fill_factor and/or drop_tol.""). return M, ss_args. def _steadystate_iterative(L, ss_args):; """"""; Iterative steady state solver using the GMRES, LGMRES, or BICGSTAB; algorithm and a sparse incomplete LU preconditioner.; """"""; ss_iters = {'iter': 0}. def _iter_count(r):; ss_iters['iter'] += 1; return. if settings.debug:; logger.debug('Starting %s solver.' % ss_args['method']). dims = L.dims[0]; n = int(np.sqrt(L.shape[0])); b = np.zeros(n ** 2); b[0] = ss_args['weight']. L, perm, perm2, rev_perm, ss_args = _steadystate_LU_liouvillian(L, ss_args); if np.any(perm):; b = b[np.ix_(perm,)]; if np.any(perm2):; b = b[np.ix_(perm2,)]. use_solver(assumeSortedIndices=True). if ss_args['M'] is None and ss_args['use_precond']:; ss_args['M'], ss_args = _iterative_precondition(L, n, ss_args); if ",MatchSource.WIKI,docs/4.7/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/steadystate.html
https://qutip.org/docs/4.7/modules/qutip/steadystate.html:19900,Testability,log,logger,19900,"earOperator((n ** 2, n ** 2), matvec=P.solve); _precond_end = time.time(); ss_args['info']['permc_spec'] = ss_args['permc_spec']; ss_args['info']['drop_tol'] = ss_args['drop_tol']; ss_args['info']['diag_pivot_thresh'] = ss_args['diag_pivot_thresh']; ss_args['info']['fill_factor'] = ss_args['fill_factor']; ss_args['info']['ILU_MILU'] = ss_args['ILU_MILU']; ss_args['info']['precond_time'] = _precond_end-_precond_start. if settings.debug or ss_args['return_info']:; if settings.debug:; logger.debug('Preconditioning succeeded.'); logger.debug('Precond. time: %f' %; (_precond_end - _precond_start)); L_nnz = P.L.nnz; U_nnz = P.U.nnz; ss_args['info']['l_nnz'] = L_nnz; ss_args['info']['u_nnz'] = U_nnz; ss_args['info']['ilu_fill_factor'] = (L_nnz+U_nnz)/A.nnz; e = np.ones(n ** 2, dtype=int); condest = la.norm(M*e, np.inf); ss_args['info']['ilu_condest'] = condest; if settings.debug:; logger.debug('L NNZ: %i ; U NNZ: %i' % (L_nnz, U_nnz)); logger.debug('Fill factor: %f' % ((L_nnz+U_nnz)/A.nnz)); logger.debug('iLU condest: %f' % condest). except Exception:; raise Exception(""Failed to build preconditioner. Try increasing "" +; ""fill_factor and/or drop_tol.""). return M, ss_args. def _steadystate_iterative(L, ss_args):; """"""; Iterative steady state solver using the GMRES, LGMRES, or BICGSTAB; algorithm and a sparse incomplete LU preconditioner.; """"""; ss_iters = {'iter': 0}. def _iter_count(r):; ss_iters['iter'] += 1; return. if settings.debug:; logger.debug('Starting %s solver.' % ss_args['method']). dims = L.dims[0]; n = int(np.sqrt(L.shape[0])); b = np.zeros(n ** 2); b[0] = ss_args['weight']. L, perm, perm2, rev_perm, ss_args = _steadystate_LU_liouvillian(L, ss_args); if np.any(perm):; b = b[np.ix_(perm,)]; if np.any(perm2):; b = b[np.ix_(perm2,)]. use_solver(assumeSortedIndices=True). if ss_args['M'] is None and ss_args['use_precond']:; ss_args['M'], ss_args = _iterative_precondition(L, n, ss_args); if ss_args['M'] is None:; warnings.warn(""Preconditioning failed. Continuing witho",MatchSource.WIKI,docs/4.7/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/steadystate.html
https://qutip.org/docs/4.7/modules/qutip/steadystate.html:20352,Testability,log,logger,20352,"return_info']:; if settings.debug:; logger.debug('Preconditioning succeeded.'); logger.debug('Precond. time: %f' %; (_precond_end - _precond_start)); L_nnz = P.L.nnz; U_nnz = P.U.nnz; ss_args['info']['l_nnz'] = L_nnz; ss_args['info']['u_nnz'] = U_nnz; ss_args['info']['ilu_fill_factor'] = (L_nnz+U_nnz)/A.nnz; e = np.ones(n ** 2, dtype=int); condest = la.norm(M*e, np.inf); ss_args['info']['ilu_condest'] = condest; if settings.debug:; logger.debug('L NNZ: %i ; U NNZ: %i' % (L_nnz, U_nnz)); logger.debug('Fill factor: %f' % ((L_nnz+U_nnz)/A.nnz)); logger.debug('iLU condest: %f' % condest). except Exception:; raise Exception(""Failed to build preconditioner. Try increasing "" +; ""fill_factor and/or drop_tol.""). return M, ss_args. def _steadystate_iterative(L, ss_args):; """"""; Iterative steady state solver using the GMRES, LGMRES, or BICGSTAB; algorithm and a sparse incomplete LU preconditioner.; """"""; ss_iters = {'iter': 0}. def _iter_count(r):; ss_iters['iter'] += 1; return. if settings.debug:; logger.debug('Starting %s solver.' % ss_args['method']). dims = L.dims[0]; n = int(np.sqrt(L.shape[0])); b = np.zeros(n ** 2); b[0] = ss_args['weight']. L, perm, perm2, rev_perm, ss_args = _steadystate_LU_liouvillian(L, ss_args); if np.any(perm):; b = b[np.ix_(perm,)]; if np.any(perm2):; b = b[np.ix_(perm2,)]. use_solver(assumeSortedIndices=True). if ss_args['M'] is None and ss_args['use_precond']:; ss_args['M'], ss_args = _iterative_precondition(L, n, ss_args); if ss_args['M'] is None:; warnings.warn(""Preconditioning failed. Continuing without."",; UserWarning). # Select iterative solver type; _iter_start = time.time(); if ss_args['method'] == 'iterative-gmres':; v, check = gmres(L, b, tol=ss_args['tol'], atol=ss_args['matol'],; M=ss_args['M'], x0=ss_args['x0'],; restart=ss_args['restart'],; maxiter=ss_args['maxiter'],; callback=_iter_count, callback_type='legacy'); elif ss_args['method'] == 'iterative-lgmres':; v, check = lgmres(L, b, tol=ss_args['tol'], atol=ss_args['matol'],; M=ss_a",MatchSource.WIKI,docs/4.7/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/steadystate.html
https://qutip.org/docs/4.7/modules/qutip/steadystate.html:22160,Testability,log,logger,22160,"ter=ss_args['maxiter'],; callback=_iter_count, callback_type='legacy'); elif ss_args['method'] == 'iterative-lgmres':; v, check = lgmres(L, b, tol=ss_args['tol'], atol=ss_args['matol'],; M=ss_args['M'], x0=ss_args['x0'],; maxiter=ss_args['maxiter'],; callback=_iter_count); elif ss_args['method'] == 'iterative-bicgstab':; v, check = bicgstab(L, b, tol=ss_args['tol'],; atol=ss_args['matol'],; M=ss_args['M'], x0=ss_args['x0'],; maxiter=ss_args['maxiter'],; callback=_iter_count); else:; raise Exception(""Invalid iterative solver method.""); _iter_end = time.time(). ss_args['info']['iter_time'] = _iter_end - _iter_start; if 'precond_time' in ss_args['info'].keys():; ss_args['info']['solution_time'] = (ss_args['info']['iter_time'] +; ss_args['info']['precond_time']); else:; ss_args['info']['solution_time'] = ss_args['info']['iter_time']; ss_args['info']['iterations'] = ss_iters['iter']; if ss_args['return_info']:; ss_args['info']['residual_norm'] = la.norm(b - L*v, np.inf). if settings.debug:; logger.debug('Number of Iterations: %i' % ss_iters['iter']); logger.debug('Iteration. time: %f' % (_iter_end - _iter_start)). if check > 0:; raise Exception(""Steadystate error: Did not reach tolerance after "" +; str(ss_args['maxiter']) + "" steps."" +; ""\nResidual norm: "" +; str(ss_args['info']['residual_norm'])). elif check < 0:; raise Exception(; ""Steadystate error: Failed with fatal error: "" + str(check) + "".""). if ss_args['use_rcm']:; v = v[np.ix_(rev_perm,)]. data = vec2mat(v); data = 0.5 * (data + data.conj().T); if ss_args['return_info']:; return Qobj(data, dims=dims, isherm=True), ss_args['info']; else:; return Qobj(data, dims=dims, isherm=True). def _steadystate_svd_dense(L, ss_args):; """"""; Find the steady state(s) of an open quantum system by solving for the; nullspace of the Liouvillian.; """"""; ss_args['info'].pop('weight', None); atol = 1e-12; rtol = 1e-12; if settings.debug:; logger.debug('Starting SVD solver.'); _svd_start = time.time(); u, s, vh = svd(L.full(), full_matrice",MatchSource.WIKI,docs/4.7/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/steadystate.html
https://qutip.org/docs/4.7/modules/qutip/steadystate.html:22221,Testability,log,logger,22221,"r_count, callback_type='legacy'); elif ss_args['method'] == 'iterative-lgmres':; v, check = lgmres(L, b, tol=ss_args['tol'], atol=ss_args['matol'],; M=ss_args['M'], x0=ss_args['x0'],; maxiter=ss_args['maxiter'],; callback=_iter_count); elif ss_args['method'] == 'iterative-bicgstab':; v, check = bicgstab(L, b, tol=ss_args['tol'],; atol=ss_args['matol'],; M=ss_args['M'], x0=ss_args['x0'],; maxiter=ss_args['maxiter'],; callback=_iter_count); else:; raise Exception(""Invalid iterative solver method.""); _iter_end = time.time(). ss_args['info']['iter_time'] = _iter_end - _iter_start; if 'precond_time' in ss_args['info'].keys():; ss_args['info']['solution_time'] = (ss_args['info']['iter_time'] +; ss_args['info']['precond_time']); else:; ss_args['info']['solution_time'] = ss_args['info']['iter_time']; ss_args['info']['iterations'] = ss_iters['iter']; if ss_args['return_info']:; ss_args['info']['residual_norm'] = la.norm(b - L*v, np.inf). if settings.debug:; logger.debug('Number of Iterations: %i' % ss_iters['iter']); logger.debug('Iteration. time: %f' % (_iter_end - _iter_start)). if check > 0:; raise Exception(""Steadystate error: Did not reach tolerance after "" +; str(ss_args['maxiter']) + "" steps."" +; ""\nResidual norm: "" +; str(ss_args['info']['residual_norm'])). elif check < 0:; raise Exception(; ""Steadystate error: Failed with fatal error: "" + str(check) + "".""). if ss_args['use_rcm']:; v = v[np.ix_(rev_perm,)]. data = vec2mat(v); data = 0.5 * (data + data.conj().T); if ss_args['return_info']:; return Qobj(data, dims=dims, isherm=True), ss_args['info']; else:; return Qobj(data, dims=dims, isherm=True). def _steadystate_svd_dense(L, ss_args):; """"""; Find the steady state(s) of an open quantum system by solving for the; nullspace of the Liouvillian.; """"""; ss_args['info'].pop('weight', None); atol = 1e-12; rtol = 1e-12; if settings.debug:; logger.debug('Starting SVD solver.'); _svd_start = time.time(); u, s, vh = svd(L.full(), full_matrices=False); tol = max(atol, rtol * s[0])",MatchSource.WIKI,docs/4.7/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/steadystate.html
https://qutip.org/docs/4.7/modules/qutip/steadystate.html:23059,Testability,log,logger,23059,"rgs['return_info']:; ss_args['info']['residual_norm'] = la.norm(b - L*v, np.inf). if settings.debug:; logger.debug('Number of Iterations: %i' % ss_iters['iter']); logger.debug('Iteration. time: %f' % (_iter_end - _iter_start)). if check > 0:; raise Exception(""Steadystate error: Did not reach tolerance after "" +; str(ss_args['maxiter']) + "" steps."" +; ""\nResidual norm: "" +; str(ss_args['info']['residual_norm'])). elif check < 0:; raise Exception(; ""Steadystate error: Failed with fatal error: "" + str(check) + "".""). if ss_args['use_rcm']:; v = v[np.ix_(rev_perm,)]. data = vec2mat(v); data = 0.5 * (data + data.conj().T); if ss_args['return_info']:; return Qobj(data, dims=dims, isherm=True), ss_args['info']; else:; return Qobj(data, dims=dims, isherm=True). def _steadystate_svd_dense(L, ss_args):; """"""; Find the steady state(s) of an open quantum system by solving for the; nullspace of the Liouvillian.; """"""; ss_args['info'].pop('weight', None); atol = 1e-12; rtol = 1e-12; if settings.debug:; logger.debug('Starting SVD solver.'); _svd_start = time.time(); u, s, vh = svd(L.full(), full_matrices=False); tol = max(atol, rtol * s[0]); nnz = (s >= tol).sum(); ns = vh[nnz:].conj().T; _svd_end = time.time(); ss_args['info']['solution_time'] = _svd_end-_svd_start; if ss_args['all_states']:; rhoss_list = []; for n in range(ns.shape[1]):; rhoss = Qobj(vec2mat(ns[:, n]), dims=L.dims[0]); rhoss_list.append(rhoss / rhoss.tr()); if ss_args['return_info']:; return rhoss_list, ss_args['info']; else:; if ss_args['return_info']:; return rhoss_list, ss_args['info']; else:; return rhoss_list; else:; rhoss = Qobj(vec2mat(ns[:, 0]), dims=L.dims[0]); return rhoss / rhoss.tr(). def _steadystate_power_liouvillian(L, ss_args, has_mkl=0):; """"""Creates modified Liouvillian for power based SS methods.; """"""; perm = None; perm2 = None; rev_perm = None; n = L.shape[0]; if ss_args['solver'] == 'mkl':; L = L.data - (1e-15) * sp.eye(n, n, format='csr'); kind = 'csr'; else:; L = L.data.tocsc() - (1e-15) * sp.e",MatchSource.WIKI,docs/4.7/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/steadystate.html
https://qutip.org/docs/4.7/modules/qutip/steadystate.html:24176,Testability,log,logger,24176,", full_matrices=False); tol = max(atol, rtol * s[0]); nnz = (s >= tol).sum(); ns = vh[nnz:].conj().T; _svd_end = time.time(); ss_args['info']['solution_time'] = _svd_end-_svd_start; if ss_args['all_states']:; rhoss_list = []; for n in range(ns.shape[1]):; rhoss = Qobj(vec2mat(ns[:, n]), dims=L.dims[0]); rhoss_list.append(rhoss / rhoss.tr()); if ss_args['return_info']:; return rhoss_list, ss_args['info']; else:; if ss_args['return_info']:; return rhoss_list, ss_args['info']; else:; return rhoss_list; else:; rhoss = Qobj(vec2mat(ns[:, 0]), dims=L.dims[0]); return rhoss / rhoss.tr(). def _steadystate_power_liouvillian(L, ss_args, has_mkl=0):; """"""Creates modified Liouvillian for power based SS methods.; """"""; perm = None; perm2 = None; rev_perm = None; n = L.shape[0]; if ss_args['solver'] == 'mkl':; L = L.data - (1e-15) * sp.eye(n, n, format='csr'); kind = 'csr'; else:; L = L.data.tocsc() - (1e-15) * sp.eye(n, n, format='csc'); kind = 'csc'; if settings.debug:; old_band = sp_bandwidth(L)[0]; old_pro = sp_profile(L)[0]; logger.debug('Original bandwidth: %i' % old_band); logger.debug('Original profile: %i' % old_pro). if ss_args['use_wbm']:; if settings.debug:; logger.debug('Calculating Weighted Bipartite Matching ordering...'); _wbm_start = time.time(); with warnings.catch_warnings():; warnings.filterwarnings(; ""ignore"", ""qutip graph functions are deprecated"",; DeprecationWarning,; ); perm = weighted_bipartite_matching(L); _wbm_end = time.time(); L = sp_permute(L, perm, [], kind); ss_args['info']['perm'].append('wbm'); ss_args['info']['wbm_time'] = _wbm_end-_wbm_start; if settings.debug:; wbm_band = sp_bandwidth(L)[0]; wbm_pro = sp_profile(L)[0]; logger.debug('WBM bandwidth: %i' % wbm_band); logger.debug('WBM profile: %i' % wbm_pro). if ss_args['use_rcm']:; if settings.debug:; logger.debug('Calculating Reverse Cuthill-Mckee ordering...'); ss_args['info']['perm'].append('rcm'); _rcm_start = time.time(); perm2 = sp.csgraph.reverse_cuthill_mckee(L); _rcm_end = time.time(); s",MatchSource.WIKI,docs/4.7/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/steadystate.html
https://qutip.org/docs/4.7/modules/qutip/steadystate.html:24227,Testability,log,logger,24227," >= tol).sum(); ns = vh[nnz:].conj().T; _svd_end = time.time(); ss_args['info']['solution_time'] = _svd_end-_svd_start; if ss_args['all_states']:; rhoss_list = []; for n in range(ns.shape[1]):; rhoss = Qobj(vec2mat(ns[:, n]), dims=L.dims[0]); rhoss_list.append(rhoss / rhoss.tr()); if ss_args['return_info']:; return rhoss_list, ss_args['info']; else:; if ss_args['return_info']:; return rhoss_list, ss_args['info']; else:; return rhoss_list; else:; rhoss = Qobj(vec2mat(ns[:, 0]), dims=L.dims[0]); return rhoss / rhoss.tr(). def _steadystate_power_liouvillian(L, ss_args, has_mkl=0):; """"""Creates modified Liouvillian for power based SS methods.; """"""; perm = None; perm2 = None; rev_perm = None; n = L.shape[0]; if ss_args['solver'] == 'mkl':; L = L.data - (1e-15) * sp.eye(n, n, format='csr'); kind = 'csr'; else:; L = L.data.tocsc() - (1e-15) * sp.eye(n, n, format='csc'); kind = 'csc'; if settings.debug:; old_band = sp_bandwidth(L)[0]; old_pro = sp_profile(L)[0]; logger.debug('Original bandwidth: %i' % old_band); logger.debug('Original profile: %i' % old_pro). if ss_args['use_wbm']:; if settings.debug:; logger.debug('Calculating Weighted Bipartite Matching ordering...'); _wbm_start = time.time(); with warnings.catch_warnings():; warnings.filterwarnings(; ""ignore"", ""qutip graph functions are deprecated"",; DeprecationWarning,; ); perm = weighted_bipartite_matching(L); _wbm_end = time.time(); L = sp_permute(L, perm, [], kind); ss_args['info']['perm'].append('wbm'); ss_args['info']['wbm_time'] = _wbm_end-_wbm_start; if settings.debug:; wbm_band = sp_bandwidth(L)[0]; wbm_pro = sp_profile(L)[0]; logger.debug('WBM bandwidth: %i' % wbm_band); logger.debug('WBM profile: %i' % wbm_pro). if ss_args['use_rcm']:; if settings.debug:; logger.debug('Calculating Reverse Cuthill-Mckee ordering...'); ss_args['info']['perm'].append('rcm'); _rcm_start = time.time(); perm2 = sp.csgraph.reverse_cuthill_mckee(L); _rcm_end = time.time(); ss_args['info']['rcm_time'] = _rcm_end-_rcm_start; rev_perm = np",MatchSource.WIKI,docs/4.7/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/steadystate.html
https://qutip.org/docs/4.7/modules/qutip/steadystate.html:24319,Testability,log,logger,24319,"vd_start; if ss_args['all_states']:; rhoss_list = []; for n in range(ns.shape[1]):; rhoss = Qobj(vec2mat(ns[:, n]), dims=L.dims[0]); rhoss_list.append(rhoss / rhoss.tr()); if ss_args['return_info']:; return rhoss_list, ss_args['info']; else:; if ss_args['return_info']:; return rhoss_list, ss_args['info']; else:; return rhoss_list; else:; rhoss = Qobj(vec2mat(ns[:, 0]), dims=L.dims[0]); return rhoss / rhoss.tr(). def _steadystate_power_liouvillian(L, ss_args, has_mkl=0):; """"""Creates modified Liouvillian for power based SS methods.; """"""; perm = None; perm2 = None; rev_perm = None; n = L.shape[0]; if ss_args['solver'] == 'mkl':; L = L.data - (1e-15) * sp.eye(n, n, format='csr'); kind = 'csr'; else:; L = L.data.tocsc() - (1e-15) * sp.eye(n, n, format='csc'); kind = 'csc'; if settings.debug:; old_band = sp_bandwidth(L)[0]; old_pro = sp_profile(L)[0]; logger.debug('Original bandwidth: %i' % old_band); logger.debug('Original profile: %i' % old_pro). if ss_args['use_wbm']:; if settings.debug:; logger.debug('Calculating Weighted Bipartite Matching ordering...'); _wbm_start = time.time(); with warnings.catch_warnings():; warnings.filterwarnings(; ""ignore"", ""qutip graph functions are deprecated"",; DeprecationWarning,; ); perm = weighted_bipartite_matching(L); _wbm_end = time.time(); L = sp_permute(L, perm, [], kind); ss_args['info']['perm'].append('wbm'); ss_args['info']['wbm_time'] = _wbm_end-_wbm_start; if settings.debug:; wbm_band = sp_bandwidth(L)[0]; wbm_pro = sp_profile(L)[0]; logger.debug('WBM bandwidth: %i' % wbm_band); logger.debug('WBM profile: %i' % wbm_pro). if ss_args['use_rcm']:; if settings.debug:; logger.debug('Calculating Reverse Cuthill-Mckee ordering...'); ss_args['info']['perm'].append('rcm'); _rcm_start = time.time(); perm2 = sp.csgraph.reverse_cuthill_mckee(L); _rcm_end = time.time(); ss_args['info']['rcm_time'] = _rcm_end-_rcm_start; rev_perm = np.argsort(perm2); L = sp_permute(L, perm2, perm2, kind); if settings.debug:; new_band = sp_bandwidth(L)[0]; new",MatchSource.WIKI,docs/4.7/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/steadystate.html
https://qutip.org/docs/4.7/modules/qutip/steadystate.html:24815,Testability,log,logger,24815,"mkl=0):; """"""Creates modified Liouvillian for power based SS methods.; """"""; perm = None; perm2 = None; rev_perm = None; n = L.shape[0]; if ss_args['solver'] == 'mkl':; L = L.data - (1e-15) * sp.eye(n, n, format='csr'); kind = 'csr'; else:; L = L.data.tocsc() - (1e-15) * sp.eye(n, n, format='csc'); kind = 'csc'; if settings.debug:; old_band = sp_bandwidth(L)[0]; old_pro = sp_profile(L)[0]; logger.debug('Original bandwidth: %i' % old_band); logger.debug('Original profile: %i' % old_pro). if ss_args['use_wbm']:; if settings.debug:; logger.debug('Calculating Weighted Bipartite Matching ordering...'); _wbm_start = time.time(); with warnings.catch_warnings():; warnings.filterwarnings(; ""ignore"", ""qutip graph functions are deprecated"",; DeprecationWarning,; ); perm = weighted_bipartite_matching(L); _wbm_end = time.time(); L = sp_permute(L, perm, [], kind); ss_args['info']['perm'].append('wbm'); ss_args['info']['wbm_time'] = _wbm_end-_wbm_start; if settings.debug:; wbm_band = sp_bandwidth(L)[0]; wbm_pro = sp_profile(L)[0]; logger.debug('WBM bandwidth: %i' % wbm_band); logger.debug('WBM profile: %i' % wbm_pro). if ss_args['use_rcm']:; if settings.debug:; logger.debug('Calculating Reverse Cuthill-Mckee ordering...'); ss_args['info']['perm'].append('rcm'); _rcm_start = time.time(); perm2 = sp.csgraph.reverse_cuthill_mckee(L); _rcm_end = time.time(); ss_args['info']['rcm_time'] = _rcm_end-_rcm_start; rev_perm = np.argsort(perm2); L = sp_permute(L, perm2, perm2, kind); if settings.debug:; new_band = sp_bandwidth(L)[0]; new_pro = sp_profile(L)[0]; logger.debug('RCM bandwidth: %i' % new_band); logger.debug('Bandwidth reduction factor: %f'; % (old_band/new_band)); logger.debug('RCM profile: %i' % new_pro); logger.debug('Profile reduction factor: %f'; % (old_pro/new_pro)); L.sort_indices(); return L, perm, perm2, rev_perm, ss_args. def _steadystate_power(L, ss_args):; """"""; Inverse power method for steady state solving.; """"""; ss_args['info'].pop('weight', None); if settings.debug:; lo",MatchSource.WIKI,docs/4.7/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/steadystate.html
https://qutip.org/docs/4.7/modules/qutip/steadystate.html:24861,Testability,log,logger,24861,"methods.; """"""; perm = None; perm2 = None; rev_perm = None; n = L.shape[0]; if ss_args['solver'] == 'mkl':; L = L.data - (1e-15) * sp.eye(n, n, format='csr'); kind = 'csr'; else:; L = L.data.tocsc() - (1e-15) * sp.eye(n, n, format='csc'); kind = 'csc'; if settings.debug:; old_band = sp_bandwidth(L)[0]; old_pro = sp_profile(L)[0]; logger.debug('Original bandwidth: %i' % old_band); logger.debug('Original profile: %i' % old_pro). if ss_args['use_wbm']:; if settings.debug:; logger.debug('Calculating Weighted Bipartite Matching ordering...'); _wbm_start = time.time(); with warnings.catch_warnings():; warnings.filterwarnings(; ""ignore"", ""qutip graph functions are deprecated"",; DeprecationWarning,; ); perm = weighted_bipartite_matching(L); _wbm_end = time.time(); L = sp_permute(L, perm, [], kind); ss_args['info']['perm'].append('wbm'); ss_args['info']['wbm_time'] = _wbm_end-_wbm_start; if settings.debug:; wbm_band = sp_bandwidth(L)[0]; wbm_pro = sp_profile(L)[0]; logger.debug('WBM bandwidth: %i' % wbm_band); logger.debug('WBM profile: %i' % wbm_pro). if ss_args['use_rcm']:; if settings.debug:; logger.debug('Calculating Reverse Cuthill-Mckee ordering...'); ss_args['info']['perm'].append('rcm'); _rcm_start = time.time(); perm2 = sp.csgraph.reverse_cuthill_mckee(L); _rcm_end = time.time(); ss_args['info']['rcm_time'] = _rcm_end-_rcm_start; rev_perm = np.argsort(perm2); L = sp_permute(L, perm2, perm2, kind); if settings.debug:; new_band = sp_bandwidth(L)[0]; new_pro = sp_profile(L)[0]; logger.debug('RCM bandwidth: %i' % new_band); logger.debug('Bandwidth reduction factor: %f'; % (old_band/new_band)); logger.debug('RCM profile: %i' % new_pro); logger.debug('Profile reduction factor: %f'; % (old_pro/new_pro)); L.sort_indices(); return L, perm, perm2, rev_perm, ss_args. def _steadystate_power(L, ss_args):; """"""; Inverse power method for steady state solving.; """"""; ss_args['info'].pop('weight', None); if settings.debug:; logger.debug('Starting iterative inverse-power method solver.'",MatchSource.WIKI,docs/4.7/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/steadystate.html
https://qutip.org/docs/4.7/modules/qutip/steadystate.html:24948,Testability,log,logger,24948,"l':; L = L.data - (1e-15) * sp.eye(n, n, format='csr'); kind = 'csr'; else:; L = L.data.tocsc() - (1e-15) * sp.eye(n, n, format='csc'); kind = 'csc'; if settings.debug:; old_band = sp_bandwidth(L)[0]; old_pro = sp_profile(L)[0]; logger.debug('Original bandwidth: %i' % old_band); logger.debug('Original profile: %i' % old_pro). if ss_args['use_wbm']:; if settings.debug:; logger.debug('Calculating Weighted Bipartite Matching ordering...'); _wbm_start = time.time(); with warnings.catch_warnings():; warnings.filterwarnings(; ""ignore"", ""qutip graph functions are deprecated"",; DeprecationWarning,; ); perm = weighted_bipartite_matching(L); _wbm_end = time.time(); L = sp_permute(L, perm, [], kind); ss_args['info']['perm'].append('wbm'); ss_args['info']['wbm_time'] = _wbm_end-_wbm_start; if settings.debug:; wbm_band = sp_bandwidth(L)[0]; wbm_pro = sp_profile(L)[0]; logger.debug('WBM bandwidth: %i' % wbm_band); logger.debug('WBM profile: %i' % wbm_pro). if ss_args['use_rcm']:; if settings.debug:; logger.debug('Calculating Reverse Cuthill-Mckee ordering...'); ss_args['info']['perm'].append('rcm'); _rcm_start = time.time(); perm2 = sp.csgraph.reverse_cuthill_mckee(L); _rcm_end = time.time(); ss_args['info']['rcm_time'] = _rcm_end-_rcm_start; rev_perm = np.argsort(perm2); L = sp_permute(L, perm2, perm2, kind); if settings.debug:; new_band = sp_bandwidth(L)[0]; new_pro = sp_profile(L)[0]; logger.debug('RCM bandwidth: %i' % new_band); logger.debug('Bandwidth reduction factor: %f'; % (old_band/new_band)); logger.debug('RCM profile: %i' % new_pro); logger.debug('Profile reduction factor: %f'; % (old_pro/new_pro)); L.sort_indices(); return L, perm, perm2, rev_perm, ss_args. def _steadystate_power(L, ss_args):; """"""; Inverse power method for steady state solving.; """"""; ss_args['info'].pop('weight', None); if settings.debug:; logger.debug('Starting iterative inverse-power method solver.'); tol = ss_args['tol']; mtol = ss_args['mtol']; if mtol is None:; mtol = max(0.1*tol, 1e-15); maxiter ",MatchSource.WIKI,docs/4.7/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/steadystate.html
https://qutip.org/docs/4.7/modules/qutip/steadystate.html:25344,Testability,log,logger,25344,"ug:; logger.debug('Calculating Weighted Bipartite Matching ordering...'); _wbm_start = time.time(); with warnings.catch_warnings():; warnings.filterwarnings(; ""ignore"", ""qutip graph functions are deprecated"",; DeprecationWarning,; ); perm = weighted_bipartite_matching(L); _wbm_end = time.time(); L = sp_permute(L, perm, [], kind); ss_args['info']['perm'].append('wbm'); ss_args['info']['wbm_time'] = _wbm_end-_wbm_start; if settings.debug:; wbm_band = sp_bandwidth(L)[0]; wbm_pro = sp_profile(L)[0]; logger.debug('WBM bandwidth: %i' % wbm_band); logger.debug('WBM profile: %i' % wbm_pro). if ss_args['use_rcm']:; if settings.debug:; logger.debug('Calculating Reverse Cuthill-Mckee ordering...'); ss_args['info']['perm'].append('rcm'); _rcm_start = time.time(); perm2 = sp.csgraph.reverse_cuthill_mckee(L); _rcm_end = time.time(); ss_args['info']['rcm_time'] = _rcm_end-_rcm_start; rev_perm = np.argsort(perm2); L = sp_permute(L, perm2, perm2, kind); if settings.debug:; new_band = sp_bandwidth(L)[0]; new_pro = sp_profile(L)[0]; logger.debug('RCM bandwidth: %i' % new_band); logger.debug('Bandwidth reduction factor: %f'; % (old_band/new_band)); logger.debug('RCM profile: %i' % new_pro); logger.debug('Profile reduction factor: %f'; % (old_pro/new_pro)); L.sort_indices(); return L, perm, perm2, rev_perm, ss_args. def _steadystate_power(L, ss_args):; """"""; Inverse power method for steady state solving.; """"""; ss_args['info'].pop('weight', None); if settings.debug:; logger.debug('Starting iterative inverse-power method solver.'); tol = ss_args['tol']; mtol = ss_args['mtol']; if mtol is None:; mtol = max(0.1*tol, 1e-15); maxiter = ss_args['maxiter']. use_solver(assumeSortedIndices=True); rhoss = Qobj(); sflag = issuper(L); if sflag:; rhoss.dims = L.dims[0]; else:; rhoss.dims = [L.dims[0], 1]; n = L.shape[0]; # Build Liouvillian; if ss_args['solver'] == 'mkl' and ss_args['method'] == 'power':; has_mkl = 1; else:; has_mkl = 0; L, perm, perm2, rev_perm, ss_args = _steadystate_power_liouvilli",MatchSource.WIKI,docs/4.7/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/steadystate.html
https://qutip.org/docs/4.7/modules/qutip/steadystate.html:25390,Testability,log,logger,25390,"rdering...'); _wbm_start = time.time(); with warnings.catch_warnings():; warnings.filterwarnings(; ""ignore"", ""qutip graph functions are deprecated"",; DeprecationWarning,; ); perm = weighted_bipartite_matching(L); _wbm_end = time.time(); L = sp_permute(L, perm, [], kind); ss_args['info']['perm'].append('wbm'); ss_args['info']['wbm_time'] = _wbm_end-_wbm_start; if settings.debug:; wbm_band = sp_bandwidth(L)[0]; wbm_pro = sp_profile(L)[0]; logger.debug('WBM bandwidth: %i' % wbm_band); logger.debug('WBM profile: %i' % wbm_pro). if ss_args['use_rcm']:; if settings.debug:; logger.debug('Calculating Reverse Cuthill-Mckee ordering...'); ss_args['info']['perm'].append('rcm'); _rcm_start = time.time(); perm2 = sp.csgraph.reverse_cuthill_mckee(L); _rcm_end = time.time(); ss_args['info']['rcm_time'] = _rcm_end-_rcm_start; rev_perm = np.argsort(perm2); L = sp_permute(L, perm2, perm2, kind); if settings.debug:; new_band = sp_bandwidth(L)[0]; new_pro = sp_profile(L)[0]; logger.debug('RCM bandwidth: %i' % new_band); logger.debug('Bandwidth reduction factor: %f'; % (old_band/new_band)); logger.debug('RCM profile: %i' % new_pro); logger.debug('Profile reduction factor: %f'; % (old_pro/new_pro)); L.sort_indices(); return L, perm, perm2, rev_perm, ss_args. def _steadystate_power(L, ss_args):; """"""; Inverse power method for steady state solving.; """"""; ss_args['info'].pop('weight', None); if settings.debug:; logger.debug('Starting iterative inverse-power method solver.'); tol = ss_args['tol']; mtol = ss_args['mtol']; if mtol is None:; mtol = max(0.1*tol, 1e-15); maxiter = ss_args['maxiter']. use_solver(assumeSortedIndices=True); rhoss = Qobj(); sflag = issuper(L); if sflag:; rhoss.dims = L.dims[0]; else:; rhoss.dims = [L.dims[0], 1]; n = L.shape[0]; # Build Liouvillian; if ss_args['solver'] == 'mkl' and ss_args['method'] == 'power':; has_mkl = 1; else:; has_mkl = 0; L, perm, perm2, rev_perm, ss_args = _steadystate_power_liouvillian(L,; ss_args,; has_mkl); orig_nnz = L.nnz; # start with al",MatchSource.WIKI,docs/4.7/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/steadystate.html
https://qutip.org/docs/4.7/modules/qutip/steadystate.html:25461,Testability,log,logger,25461,"h_warnings():; warnings.filterwarnings(; ""ignore"", ""qutip graph functions are deprecated"",; DeprecationWarning,; ); perm = weighted_bipartite_matching(L); _wbm_end = time.time(); L = sp_permute(L, perm, [], kind); ss_args['info']['perm'].append('wbm'); ss_args['info']['wbm_time'] = _wbm_end-_wbm_start; if settings.debug:; wbm_band = sp_bandwidth(L)[0]; wbm_pro = sp_profile(L)[0]; logger.debug('WBM bandwidth: %i' % wbm_band); logger.debug('WBM profile: %i' % wbm_pro). if ss_args['use_rcm']:; if settings.debug:; logger.debug('Calculating Reverse Cuthill-Mckee ordering...'); ss_args['info']['perm'].append('rcm'); _rcm_start = time.time(); perm2 = sp.csgraph.reverse_cuthill_mckee(L); _rcm_end = time.time(); ss_args['info']['rcm_time'] = _rcm_end-_rcm_start; rev_perm = np.argsort(perm2); L = sp_permute(L, perm2, perm2, kind); if settings.debug:; new_band = sp_bandwidth(L)[0]; new_pro = sp_profile(L)[0]; logger.debug('RCM bandwidth: %i' % new_band); logger.debug('Bandwidth reduction factor: %f'; % (old_band/new_band)); logger.debug('RCM profile: %i' % new_pro); logger.debug('Profile reduction factor: %f'; % (old_pro/new_pro)); L.sort_indices(); return L, perm, perm2, rev_perm, ss_args. def _steadystate_power(L, ss_args):; """"""; Inverse power method for steady state solving.; """"""; ss_args['info'].pop('weight', None); if settings.debug:; logger.debug('Starting iterative inverse-power method solver.'); tol = ss_args['tol']; mtol = ss_args['mtol']; if mtol is None:; mtol = max(0.1*tol, 1e-15); maxiter = ss_args['maxiter']. use_solver(assumeSortedIndices=True); rhoss = Qobj(); sflag = issuper(L); if sflag:; rhoss.dims = L.dims[0]; else:; rhoss.dims = [L.dims[0], 1]; n = L.shape[0]; # Build Liouvillian; if ss_args['solver'] == 'mkl' and ss_args['method'] == 'power':; has_mkl = 1; else:; has_mkl = 0; L, perm, perm2, rev_perm, ss_args = _steadystate_power_liouvillian(L,; ss_args,; has_mkl); orig_nnz = L.nnz; # start with all ones as RHS; v = np.ones(n, dtype=complex); if ss_args['u",MatchSource.WIKI,docs/4.7/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/steadystate.html
https://qutip.org/docs/4.7/modules/qutip/steadystate.html:25504,Testability,log,logger,25504," graph functions are deprecated"",; DeprecationWarning,; ); perm = weighted_bipartite_matching(L); _wbm_end = time.time(); L = sp_permute(L, perm, [], kind); ss_args['info']['perm'].append('wbm'); ss_args['info']['wbm_time'] = _wbm_end-_wbm_start; if settings.debug:; wbm_band = sp_bandwidth(L)[0]; wbm_pro = sp_profile(L)[0]; logger.debug('WBM bandwidth: %i' % wbm_band); logger.debug('WBM profile: %i' % wbm_pro). if ss_args['use_rcm']:; if settings.debug:; logger.debug('Calculating Reverse Cuthill-Mckee ordering...'); ss_args['info']['perm'].append('rcm'); _rcm_start = time.time(); perm2 = sp.csgraph.reverse_cuthill_mckee(L); _rcm_end = time.time(); ss_args['info']['rcm_time'] = _rcm_end-_rcm_start; rev_perm = np.argsort(perm2); L = sp_permute(L, perm2, perm2, kind); if settings.debug:; new_band = sp_bandwidth(L)[0]; new_pro = sp_profile(L)[0]; logger.debug('RCM bandwidth: %i' % new_band); logger.debug('Bandwidth reduction factor: %f'; % (old_band/new_band)); logger.debug('RCM profile: %i' % new_pro); logger.debug('Profile reduction factor: %f'; % (old_pro/new_pro)); L.sort_indices(); return L, perm, perm2, rev_perm, ss_args. def _steadystate_power(L, ss_args):; """"""; Inverse power method for steady state solving.; """"""; ss_args['info'].pop('weight', None); if settings.debug:; logger.debug('Starting iterative inverse-power method solver.'); tol = ss_args['tol']; mtol = ss_args['mtol']; if mtol is None:; mtol = max(0.1*tol, 1e-15); maxiter = ss_args['maxiter']. use_solver(assumeSortedIndices=True); rhoss = Qobj(); sflag = issuper(L); if sflag:; rhoss.dims = L.dims[0]; else:; rhoss.dims = [L.dims[0], 1]; n = L.shape[0]; # Build Liouvillian; if ss_args['solver'] == 'mkl' and ss_args['method'] == 'power':; has_mkl = 1; else:; has_mkl = 0; L, perm, perm2, rev_perm, ss_args = _steadystate_power_liouvillian(L,; ss_args,; has_mkl); orig_nnz = L.nnz; # start with all ones as RHS; v = np.ones(n, dtype=complex); if ss_args['use_rcm']:; v = v[np.ix_(perm2,)]. # Do preconditioning; i",MatchSource.WIKI,docs/4.7/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/steadystate.html
https://qutip.org/docs/4.7/modules/qutip/steadystate.html:25783,Testability,log,logger,25783,"[0]; wbm_pro = sp_profile(L)[0]; logger.debug('WBM bandwidth: %i' % wbm_band); logger.debug('WBM profile: %i' % wbm_pro). if ss_args['use_rcm']:; if settings.debug:; logger.debug('Calculating Reverse Cuthill-Mckee ordering...'); ss_args['info']['perm'].append('rcm'); _rcm_start = time.time(); perm2 = sp.csgraph.reverse_cuthill_mckee(L); _rcm_end = time.time(); ss_args['info']['rcm_time'] = _rcm_end-_rcm_start; rev_perm = np.argsort(perm2); L = sp_permute(L, perm2, perm2, kind); if settings.debug:; new_band = sp_bandwidth(L)[0]; new_pro = sp_profile(L)[0]; logger.debug('RCM bandwidth: %i' % new_band); logger.debug('Bandwidth reduction factor: %f'; % (old_band/new_band)); logger.debug('RCM profile: %i' % new_pro); logger.debug('Profile reduction factor: %f'; % (old_pro/new_pro)); L.sort_indices(); return L, perm, perm2, rev_perm, ss_args. def _steadystate_power(L, ss_args):; """"""; Inverse power method for steady state solving.; """"""; ss_args['info'].pop('weight', None); if settings.debug:; logger.debug('Starting iterative inverse-power method solver.'); tol = ss_args['tol']; mtol = ss_args['mtol']; if mtol is None:; mtol = max(0.1*tol, 1e-15); maxiter = ss_args['maxiter']. use_solver(assumeSortedIndices=True); rhoss = Qobj(); sflag = issuper(L); if sflag:; rhoss.dims = L.dims[0]; else:; rhoss.dims = [L.dims[0], 1]; n = L.shape[0]; # Build Liouvillian; if ss_args['solver'] == 'mkl' and ss_args['method'] == 'power':; has_mkl = 1; else:; has_mkl = 0; L, perm, perm2, rev_perm, ss_args = _steadystate_power_liouvillian(L,; ss_args,; has_mkl); orig_nnz = L.nnz; # start with all ones as RHS; v = np.ones(n, dtype=complex); if ss_args['use_rcm']:; v = v[np.ix_(perm2,)]. # Do preconditioning; if ss_args['solver'] == 'scipy':; if ss_args['M'] is None and ss_args['use_precond'] and \; ss_args['method'] in ['power-gmres',; 'power-lgmres',; 'power-bicgstab']:; ss_args['M'], ss_args = _iterative_precondition(L, int(np.sqrt(n)),; ss_args); if ss_args['M'] is None:; warnings.warn(""Precond",MatchSource.WIKI,docs/4.7/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/steadystate.html
https://qutip.org/docs/4.7/modules/qutip/steadystate.html:27386,Testability,log,logger,27386,"; v = np.ones(n, dtype=complex); if ss_args['use_rcm']:; v = v[np.ix_(perm2,)]. # Do preconditioning; if ss_args['solver'] == 'scipy':; if ss_args['M'] is None and ss_args['use_precond'] and \; ss_args['method'] in ['power-gmres',; 'power-lgmres',; 'power-bicgstab']:; ss_args['M'], ss_args = _iterative_precondition(L, int(np.sqrt(n)),; ss_args); if ss_args['M'] is None:; warnings.warn(""Preconditioning failed. Continuing without."",; UserWarning). ss_iters = {'iter': 0}. def _iter_count(r):; ss_iters['iter'] += 1; return. _power_start = time.time(); # Get LU factors; if ss_args['method'] == 'power':; if ss_args['solver'] == 'mkl':; lu = mkl_splu(L, max_iter_refine=ss_args['max_iter_refine'],; scaling_vectors=ss_args['scaling_vectors'],; weighted_matching=ss_args['weighted_matching']); else:; lu = splu(L, permc_spec=ss_args['permc_spec'],; diag_pivot_thresh=ss_args['diag_pivot_thresh'],; options=dict(ILU_MILU=ss_args['ILU_MILU'])). if settings.debug:; L_nnz = lu.L.nnz; U_nnz = lu.U.nnz; logger.debug('L NNZ: %i ; U NNZ: %i' % (L_nnz, U_nnz)); logger.debug('Fill factor: %f' % ((L_nnz+U_nnz)/orig_nnz)). it = 0; while (la.norm(L * v, np.inf) > tol) and (it < maxiter):; check = 0; if ss_args['method'] == 'power':; v = lu.solve(v); elif ss_args['method'] == 'power-gmres':; v, check = gmres(L, v, tol=mtol, atol=ss_args['matol'],; M=ss_args['M'], x0=ss_args['x0'],; restart=ss_args['restart'],; maxiter=ss_args['maxiter'],; callback=_iter_count, callback_type='legacy'); elif ss_args['method'] == 'power-lgmres':; v, check = lgmres(L, v, tol=mtol, atol=ss_args['matol'],; M=ss_args['M'], x0=ss_args['x0'],; maxiter=ss_args['maxiter'],; callback=_iter_count); elif ss_args['method'] == 'power-bicgstab':; v, check = bicgstab(L, v, tol=mtol, atol=ss_args['matol'],; M=ss_args['M'], x0=ss_args['x0'],; maxiter=ss_args['maxiter'],; callback=_iter_count); else:; raise Exception(""Invalid iterative solver method.""); if check > 0:; raise Exception(""{} failed to find solution in ""; ""{} iteration",MatchSource.WIKI,docs/4.7/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/steadystate.html
https://qutip.org/docs/4.7/modules/qutip/steadystate.html:27442,Testability,log,logger,27442,"f ss_args['use_rcm']:; v = v[np.ix_(perm2,)]. # Do preconditioning; if ss_args['solver'] == 'scipy':; if ss_args['M'] is None and ss_args['use_precond'] and \; ss_args['method'] in ['power-gmres',; 'power-lgmres',; 'power-bicgstab']:; ss_args['M'], ss_args = _iterative_precondition(L, int(np.sqrt(n)),; ss_args); if ss_args['M'] is None:; warnings.warn(""Preconditioning failed. Continuing without."",; UserWarning). ss_iters = {'iter': 0}. def _iter_count(r):; ss_iters['iter'] += 1; return. _power_start = time.time(); # Get LU factors; if ss_args['method'] == 'power':; if ss_args['solver'] == 'mkl':; lu = mkl_splu(L, max_iter_refine=ss_args['max_iter_refine'],; scaling_vectors=ss_args['scaling_vectors'],; weighted_matching=ss_args['weighted_matching']); else:; lu = splu(L, permc_spec=ss_args['permc_spec'],; diag_pivot_thresh=ss_args['diag_pivot_thresh'],; options=dict(ILU_MILU=ss_args['ILU_MILU'])). if settings.debug:; L_nnz = lu.L.nnz; U_nnz = lu.U.nnz; logger.debug('L NNZ: %i ; U NNZ: %i' % (L_nnz, U_nnz)); logger.debug('Fill factor: %f' % ((L_nnz+U_nnz)/orig_nnz)). it = 0; while (la.norm(L * v, np.inf) > tol) and (it < maxiter):; check = 0; if ss_args['method'] == 'power':; v = lu.solve(v); elif ss_args['method'] == 'power-gmres':; v, check = gmres(L, v, tol=mtol, atol=ss_args['matol'],; M=ss_args['M'], x0=ss_args['x0'],; restart=ss_args['restart'],; maxiter=ss_args['maxiter'],; callback=_iter_count, callback_type='legacy'); elif ss_args['method'] == 'power-lgmres':; v, check = lgmres(L, v, tol=mtol, atol=ss_args['matol'],; M=ss_args['M'], x0=ss_args['x0'],; maxiter=ss_args['maxiter'],; callback=_iter_count); elif ss_args['method'] == 'power-bicgstab':; v, check = bicgstab(L, v, tol=mtol, atol=ss_args['matol'],; M=ss_args['M'], x0=ss_args['x0'],; maxiter=ss_args['maxiter'],; callback=_iter_count); else:; raise Exception(""Invalid iterative solver method.""); if check > 0:; raise Exception(""{} failed to find solution in ""; ""{} iterations."".format(ss_args['method'],; che",MatchSource.WIKI,docs/4.7/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/steadystate.html
https://qutip.org/docs/4.7/modules/qutip/steadystate.html:29179,Testability,log,logger,29179,"x0=ss_args['x0'],; maxiter=ss_args['maxiter'],; callback=_iter_count); else:; raise Exception(""Invalid iterative solver method.""); if check > 0:; raise Exception(""{} failed to find solution in ""; ""{} iterations."".format(ss_args['method'],; check)); if check < 0:; raise Exception(""Breakdown in {}"".format(ss_args['method'])); v = v / la.norm(v, np.inf); it += 1; if ss_args['method'] == 'power' and ss_args['solver'] == 'mkl':; lu.delete(); if ss_args['return_info']:; ss_args['info']['max_iter_refine'] = ss_args['max_iter_refine']; ss_args['info']['scaling_vectors'] = ss_args['scaling_vectors']; ss_args['info']['weighted_matching'] = ss_args['weighted_matching']. if it >= maxiter:; raise Exception('Failed to find steady state after ' +; str(maxiter) + ' iterations'); _power_end = time.time(); ss_args['info']['solution_time'] = _power_end-_power_start; ss_args['info']['iterations'] = it; if ss_args['return_info']:; ss_args['info']['residual_norm'] = la.norm(L*v, np.inf); if settings.debug:; logger.debug('Number of iterations: %i' % it). if ss_args['use_rcm']:; v = v[np.ix_(rev_perm,)]. # normalise according to type of problem; if sflag:; trow = v[::rhoss.shape[0]+1]; data = v / np.sum(trow); else:; data = data / la.norm(v). data = dense2D_to_fastcsr_fmode(vec2mat(data),; rhoss.shape[0],; rhoss.shape[0]); rhoss.data = 0.5 * (data + data.H); rhoss.isherm = True; if ss_args['return_info']:; return rhoss, ss_args['info']; else:; return rhoss. def steadystate_floquet(H_0, c_ops, Op_t, w_d=1.0, n_it=3, sparse=False):; """"""; Calculates the effective steady state for a driven; system with a time-dependent cosinusoidal term:. .. math::. \\mathcal{\\hat{H}}(t) = \\hat{H}_0 +; \\mathcal{\\hat{O}} \\cos(\\omega_d t). Parameters; ----------; H_0 : :obj:`~qutip.Qobj`; A Hamiltonian or Liouvillian operator. c_ops : list; A list of collapse operators. Op_t : :obj:`~qutip.Qobj`; The the interaction operator which is multiplied by the cosine. w_d : float, default 1.0; The frequency of the d",MatchSource.WIKI,docs/4.7/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/steadystate.html
https://qutip.org/docs/4.7/modules/qutip/steadystate.html:1708,Usability,simpl,simply,1708," packaging.version import parse as _parse_version; import numpy as np; from numpy.linalg import svd; import scipy; import scipy.sparse as sp; import scipy.linalg as la; from scipy.sparse.linalg import (; use_solver, splu, spilu, eigs, LinearOperator, gmres, lgmres, bicgstab,; ); from qutip.qobj import Qobj, issuper, isoper. from qutip.superoperator import liouvillian, vec2mat, spre; from qutip.sparse import sp_permute, sp_bandwidth, sp_profile; from qutip.cy.spmath import zcsr_kron; from qutip.graph import weighted_bipartite_matching; from qutip import (mat2vec, tensor, identity, operator_to_vector); import qutip.settings as settings; from qutip.cy.spconvert import dense2D_to_fastcsr_fmode. import qutip.logging_utils; logger = qutip.logging_utils.get_logger('qutip.steadystate'); logger.setLevel('DEBUG'). # Load MKL spsolve if avaiable; if settings.has_mkl:; from qutip._mkl.spsolve import (mkl_splu, mkl_spsolve). def _eat_kwargs(function, names):; """"""; Return a wrapped version of `function` that simply removes any keyword; arguments with one of the given names.; """"""; @functools.wraps(function); def out(*args, **kwargs):; for name in names:; if name in kwargs:; del kwargs[name]; return function(*args, **kwargs); return out. def _rename_kwargs(function, names_pairs):; """"""; Return a wrapped version of `function` that rename any keyword; arguments from the first value of the pair, to the second.; """"""; @functools.wraps(function); def out(*args, **kwargs):; for old, new in names_pairs:; if old in kwargs:; kwargs[new] = kwargs.pop(old); return function(*args, **kwargs); return out. # From SciPy 1.4 onwards we need to pass the `callback_type='legacy'` argument; # to gmres to maintain the same behaviour we used to have. Since this should; # be the default behaviour, we use that in the main code and just ""eat"" the; # argument if passed to a lower version of SciPy that doesn't know about it.; # Similarly, SciPy < 1.1 does not recognise the `atol` keyword.; #; # Respective checks",MatchSource.WIKI,docs/4.7/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/steadystate.html
https://qutip.org/docs/4.7/modules/qutip/stochastic.html:1547,Availability,avail,available,1547,"bj, isket, isoper, issuper; from qutip.states import ket2dm; from qutip.solver import Result; from qutip.qobjevo import QobjEvo; from qutip.superoperator import spre, spost, mat2vec, liouvillian; from qutip.solver import Options; from qutip.parallel import serial_map; from qutip.ui.progressbar import TextProgressBar; from qutip.pdpsolve import main_ssepdpsolve, main_smepdpsolve. __all__ = ['ssesolve', 'photocurrent_sesolve', 'smepdpsolve',; 'smesolve', 'photocurrent_mesolve', 'ssepdpsolve',; 'stochastic_solvers', 'general_stochastic']. [docs]def stochastic_solvers():; # This docstring contains several literal backslash characters inside LaTeX; # blocks, but it cannot be declared as a raw string because we also need to; # use a line continuation. At one point we need a restructured text; # ""definition list"", where the heading _must_ be entirely on one line,; # however it will violate our line-length reporting if we do that.; """"""; This function is purely a reference point for documenting the available; stochastic solver methods, and takes no actions. Notes; -----; Available solvers for :obj:`~ssesolve` and :obj:`~smesolve`; euler-maruyama; A simple generalization of the Euler method for ordinary; differential equations to stochastic differential equations. Only; solver which could take non-commuting ``sc_ops``. *not tested*. - Order 0.5; - Code: ``'euler-maruyama'``, ``'euler'`` or ``0.5``. milstein; An order 1.0 strong Taylor scheme. Better approximate numerical; solution to stochastic differential equations. See eq. (2.9) of; chapter 12.2 of [1]_. - Order strong 1.0; - Code: ``'milstein'`` or ``1.0``. milstein-imp; An order 1.0 implicit strong Taylor scheme. Implicit Milstein; scheme for the numerical simulation of stiff stochastic; differential equations. - Order strong 1.0; - Code: ``'milstein-imp'``. predictor-corrector; Generalization of the trapezoidal method to stochastic differential; equations. More stable than explicit methods. See eq. (5.4) of; chapter 15.",MatchSource.WIKI,docs/4.7/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/stochastic.html
https://qutip.org/docs/4.7/modules/qutip/stochastic.html:9108,Availability,toler,tolerance,9108,"surement operators. The expected; format is a nested list with one measurement operator for each; stochastic increament, for each stochastic collapse operator. args : dict; Dictionary of parameters for time dependent systems. tol : float; Tolerance of the solver for implicit methods. ntraj : int; Number of trajectors. nsubsteps : int; Number of sub steps between each time-spep given in `times`. dW_factors : array; Array of length len(sc_ops), containing scaling factors for each; measurement operator in m_ops. solver : string; Name of the solver method to use for solving the stochastic; equations. Valid values are:. - order 1/2 algorithms: 'euler-maruyama', 'pc-euler', 'pc-euler-imp'; - order 1 algorithms: 'milstein', 'platen', 'milstein-imp', 'rouchon'; - order 3/2 algorithms: 'taylor1.5', 'taylor1.5-imp', 'explicit1.5'; - order 2 algorithms: 'taylor2.0'. See the documentation of :func:`~qutip.stochastic.stochastic_solvers`; for a description of the solvers. Implicit methods can adjust; tolerance via the kw 'tol'. Default is {'tol': 1e-6}. method : string ('homodyne', 'heterodyne'); The name of the type of measurement process that give rise to the; stochastic equation to solve. store_all_expect : bool (default False); Whether or not to store the e_ops expect values for all paths. store_measurement : bool (default False); Whether or not to store the measurement results in the; :class:`qutip.solver.Result` instance returned by the solver. noise : int, or 1D array of int, or 4D array of float; - int : seed of the noise; - 1D array : length = ntraj, seeds for each trajectories.; - 4D array : ``(ntraj, len(times), nsubsteps, len(sc_ops)*[1|2])``.; Vector for the noise, the len of the last dimensions is doubled for; solvers of order 1.5. This corresponds to results.noise. noiseDepth : int; Number of terms kept of the truncated series used to create the; noise used by taylor2.0 solver. normalize : bool; (default True for (photo)ssesolve, False for (photo)smesolve); Whether ",MatchSource.WIKI,docs/4.7/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/stochastic.html
https://qutip.org/docs/4.7/modules/qutip/stochastic.html:10217,Availability,error,errors,10217,"erodyne'); The name of the type of measurement process that give rise to the; stochastic equation to solve. store_all_expect : bool (default False); Whether or not to store the e_ops expect values for all paths. store_measurement : bool (default False); Whether or not to store the measurement results in the; :class:`qutip.solver.Result` instance returned by the solver. noise : int, or 1D array of int, or 4D array of float; - int : seed of the noise; - 1D array : length = ntraj, seeds for each trajectories.; - 4D array : ``(ntraj, len(times), nsubsteps, len(sc_ops)*[1|2])``.; Vector for the noise, the len of the last dimensions is doubled for; solvers of order 1.5. This corresponds to results.noise. noiseDepth : int; Number of terms kept of the truncated series used to create the; noise used by taylor2.0 solver. normalize : bool; (default True for (photo)ssesolve, False for (photo)smesolve); Whether or not to normalize the wave function during the evolution.; Normalizing density matrices introduce numerical errors. options : :class:`qutip.solver.Options`; Generic solver options. Only options.average_states and; options.store_states are used. map_func: function; A map function or managing the calls to single-trajactory solvers. map_kwargs: dictionary; Optional keyword arguments to the map_func function function. progress_bar : :class:`qutip.ui.BaseProgressBar`; Optional progress bar class instance.; """"""; def __init__(self, me, H=None, c_ops=[], sc_ops=[], state0=None,; e_ops=[], m_ops=None, store_all_expect=False,; store_measurement=False, dW_factors=None,; solver=None, method=""homodyne"", normalize=None,; times=None, nsubsteps=1, ntraj=1, tol=None,; generate_noise=None, noise=None,; progress_bar=None, map_func=None, map_kwargs=None,; args={}, options=None, noiseDepth=20):. if options is None:; options = Options(). if progress_bar is None:; progress_bar = TextProgressBar(). # System; # Cast to QobjEvo so the code has only one version for both the; # constant and time-d",MatchSource.WIKI,docs/4.7/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/stochastic.html
https://qutip.org/docs/4.7/modules/qutip/stochastic.html:40333,Availability,error,error,40333,"np.zeros((len(sso.e_ops), len(sso.times)), dtype=complex); res.measurement = []; res.solver = sso.solver_name; res.ntraj = sso.ntraj; res.num_expect = len(sso.e_ops). nt = sso.ntraj; task = _single_trajectory; map_kwargs = {'progress_bar': sso.progress_bar}; map_kwargs.update(sso.map_kwargs); task_args = (sso,); task_kwargs = {}. results = sso.map_func(task, list(range(sso.ntraj)),; task_args, task_kwargs, **map_kwargs); noise = []; for result in results:; states_list, dW, m, expect = result; if options.average_states or options.store_states:; res.states.append(states_list); noise.append(dW); res.measurement.append(m); res.expect += expect; res.ss += expect * expect; res.noise = np.stack(noise). if sso.store_all_expect:; paths_expect = []; for result in results:; paths_expect.append(result[3]); res.runs_expect = np.stack(paths_expect). # average density matrices (vectorized maybe); # ajgpitch 2019-10-25: np.any(res.states) seems to error; # I guess there may be a potential exception if there are no states?; # store individual trajectory states; if options.store_states:; res.traj_states = res.states; else:; res.traj_states = None; res.avg_states = None; if options.average_states:; avg_states_list = []; for n in range(len(res.times)):; if res.states[0][n].shape[1] == 1:; tslot_states = [; res.states[mm][n].proj().data; for mm in range(nt); ]; else:; tslot_states = [res.states[mm][n].data for mm in range(nt)]; if len(tslot_states) > 0:; state = Qobj(np.sum(tslot_states),; dims=[res.states[0][n].dims[0]] * 2).unit(); avg_states_list.append(state); # store average states; res.states = res.avg_states = avg_states_list. # average; res.expect = res.expect / nt. # standard error; if nt > 1:; res.se = (res.ss - nt * (res.expect ** 2)) / (nt * (nt - 1)); else:; res.se = None. # convert complex data to real if hermitian; res.expect = [np.real(res.expect[n, :]); if e.isherm else res.expect[n, :]; for n, e in enumerate(sso.e_ops)]. return res. def _single_trajectory(i, sso):; # On",MatchSource.WIKI,docs/4.7/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/stochastic.html
https://qutip.org/docs/4.7/modules/qutip/stochastic.html:41080,Availability,error,error,41080,"oise). if sso.store_all_expect:; paths_expect = []; for result in results:; paths_expect.append(result[3]); res.runs_expect = np.stack(paths_expect). # average density matrices (vectorized maybe); # ajgpitch 2019-10-25: np.any(res.states) seems to error; # I guess there may be a potential exception if there are no states?; # store individual trajectory states; if options.store_states:; res.traj_states = res.states; else:; res.traj_states = None; res.avg_states = None; if options.average_states:; avg_states_list = []; for n in range(len(res.times)):; if res.states[0][n].shape[1] == 1:; tslot_states = [; res.states[mm][n].proj().data; for mm in range(nt); ]; else:; tslot_states = [res.states[mm][n].data for mm in range(nt)]; if len(tslot_states) > 0:; state = Qobj(np.sum(tslot_states),; dims=[res.states[0][n].dims[0]] * 2).unit(); avg_states_list.append(state); # store average states; res.states = res.avg_states = avg_states_list. # average; res.expect = res.expect / nt. # standard error; if nt > 1:; res.se = (res.ss - nt * (res.expect ** 2)) / (nt * (nt - 1)); else:; res.se = None. # convert complex data to real if hermitian; res.expect = [np.real(res.expect[n, :]); if e.isherm else res.expect[n, :]; for n, e in enumerate(sso.e_ops)]. return res. def _single_trajectory(i, sso):; # Only one step?; ssolver = sso.solver_obj(); ssolver.set_solver(sso); result = ssolver.cy_sesolve_single_trajectory(i); return result. # The code for ssepdpsolve have been moved to the file pdpsolve.; # The call is still in stochastic for consistance.; [docs]def ssepdpsolve(H, psi0, times, c_ops, e_ops, **kwargs):; """"""; A stochastic (piecewse deterministic process) PDP solver for wavefunction; evolution. For most purposes, use :func:`qutip.mcsolve` instead for quantum; trajectory simulations. Parameters; ----------. H : :class:`qutip.Qobj`; System Hamiltonian. psi0 : :class:`qutip.Qobj`; Initial state vector (ket). times : *list* / *array*; List of times for :math:`t`. Must be uniformly space",MatchSource.WIKI,docs/4.7/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/stochastic.html
https://qutip.org/docs/4.7/modules/qutip/stochastic.html:39657,Deployability,update,update,39657,"t fit the initial state""); else:; if shape_op[0] != l_vec or shape_op[1] != l_vec:; raise Exception(""The size of the e_ops does ""; ""not fit the initial state""). if sso.m_ops is not None:; for op in sso.m_ops:; shape_op = op.shape; if sso.me:; if shape_op[0]**2 != l_vec or shape_op[1]**2 != l_vec:; raise Exception(""The size of the m_ops does ""; ""not fit the initial state""); else:; if shape_op[0] != l_vec or shape_op[1] != l_vec:; raise Exception(""The size of the m_ops does ""; ""not fit the initial state""). def _sesolve_generic(sso, options, progress_bar):; """"""; Internal function. See smesolve.; """"""; res = Result(); res.times = sso.times; res.expect = np.zeros((len(sso.e_ops), len(sso.times)), dtype=complex); res.ss = np.zeros((len(sso.e_ops), len(sso.times)), dtype=complex); res.measurement = []; res.solver = sso.solver_name; res.ntraj = sso.ntraj; res.num_expect = len(sso.e_ops). nt = sso.ntraj; task = _single_trajectory; map_kwargs = {'progress_bar': sso.progress_bar}; map_kwargs.update(sso.map_kwargs); task_args = (sso,); task_kwargs = {}. results = sso.map_func(task, list(range(sso.ntraj)),; task_args, task_kwargs, **map_kwargs); noise = []; for result in results:; states_list, dW, m, expect = result; if options.average_states or options.store_states:; res.states.append(states_list); noise.append(dW); res.measurement.append(m); res.expect += expect; res.ss += expect * expect; res.noise = np.stack(noise). if sso.store_all_expect:; paths_expect = []; for result in results:; paths_expect.append(result[3]); res.runs_expect = np.stack(paths_expect). # average density matrices (vectorized maybe); # ajgpitch 2019-10-25: np.any(res.states) seems to error; # I guess there may be a potential exception if there are no states?; # store individual trajectory states; if options.store_states:; res.traj_states = res.states; else:; res.traj_states = None; res.avg_states = None; if options.average_states:; avg_states_list = []; for n in range(len(res.times)):; if res.states[0][n].sh",MatchSource.WIKI,docs/4.7/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/stochastic.html
https://qutip.org/docs/4.7/modules/qutip/stochastic.html:44033,Deployability,update,updated,44033,"istic collapse operator which will contribute with a standard; Lindblad type of dissipation. e_ops : list of :class:`qutip.Qobj` / callback function single; single operator or list of operators for which to evaluate; expectation values. kwargs : *dictionary*; Optional keyword arguments. See; :class:`qutip.stochastic.StochasticSolverOptions`. Returns; -------. output: :class:`qutip.solver.Result`. An instance of the class :class:`qutip.solver.Result`. """"""; return main_ssepdpsolve(H, psi0, times, c_ops, e_ops, **kwargs). # The code for smepdpsolve have been moved to the file pdpsolve.; # The call is still in stochastic for consistance.; [docs]def smepdpsolve(H, rho0, times, c_ops, e_ops, **kwargs):; """"""; A stochastic (piecewse deterministic process) PDP solver for density matrix; evolution. Parameters; ----------. H : :class:`qutip.Qobj`; System Hamiltonian. rho0 : :class:`qutip.Qobj`; Initial density matrix. times : *list* / *array*; List of times for :math:`t`. Must be uniformly spaced. c_ops : list of :class:`qutip.Qobj`; Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation. sc_ops : list of :class:`qutip.Qobj`; List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined. e_ops : list of :class:`qutip.Qobj` / callback function single; single operator or list of operators for which to evaluate; expectation values. kwargs : *dictionary*; Optional keyword arguments. See; :class:`qutip.stochastic.StochasticSolverOptions`. Returns; -------. output: :class:`qutip.solver.Result`. An instance of the class :class:`qutip.solver.Result`. """"""; return main_smepdpsolve(H, rho0, times, c_ops, e_ops, **kwargs). © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/stochastic.html
https://qutip.org/docs/4.7/modules/qutip/stochastic.html:6775,Integrability,depend,dependent,6775," Feedback Control*, `arXiv:1410.5345 [quant-ph]; <https://arxiv.org/abs/1410.5345>`_, Phys. Rev. A 91, 012118,; (2015).; .. [4] Howard M. Wiseman, Gerard J. Milburn, *Quantum measurement and; control*.; """""". [docs]class StochasticSolverOptions:; """"""Class of options for stochastic solvers such as; :func:`qutip.stochastic.ssesolve`, :func:`qutip.stochastic.smesolve`, etc. The stochastic solvers :func:`qutip.stochastic.general_stochastic`,; :func:`qutip.stochastic.ssesolve`, :func:`qutip.stochastic.smesolve`,; :func:`qutip.stochastic.photocurrent_sesolve` and; :func:`qutip.stochastic.photocurrent_mesolve`; all take the same keyword arguments as; the constructor of these class, and internally they use these arguments to; construct an instance of this class, so it is rarely needed to explicitly; create an instance of this class. Within the attribute list, a ``time_dependent_object`` is either. - :class:`~qutip.Qobj`: a constant term; - 2-element list of ``[Qobj, time_dependence]``: a time-dependent term; where the ``Qobj`` will be multiplied by the time-dependent scalar. For more details on all allowed time-dependent objects, see the; documentation for :class:`~qutip.QobjEvo`. Attributes; ----------; H : time_dependent_object or list of time_dependent_object; System Hamiltonian in standard time-dependent list format. This is the; same as the argument that (e.g.) :func:`~qutip.mesolve` takes.; If this is a list of elements, they are summed. state0 : :class:`qutip.Qobj`; Initial state vector (ket) or density matrix. times : array_like of float; List of times for :math:`t`. Must be uniformly spaced. c_ops : list of time_dependent_object; List of deterministic collapse operators. Each element of the list is; a separate operator; unlike the Hamiltonian, there is no implicit; summation over the terms. sc_ops : list of time_dependent_object; List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the equ",MatchSource.WIKI,docs/4.7/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/stochastic.html
https://qutip.org/docs/4.7/modules/qutip/stochastic.html:6841,Integrability,depend,dependent,6841," Feedback Control*, `arXiv:1410.5345 [quant-ph]; <https://arxiv.org/abs/1410.5345>`_, Phys. Rev. A 91, 012118,; (2015).; .. [4] Howard M. Wiseman, Gerard J. Milburn, *Quantum measurement and; control*.; """""". [docs]class StochasticSolverOptions:; """"""Class of options for stochastic solvers such as; :func:`qutip.stochastic.ssesolve`, :func:`qutip.stochastic.smesolve`, etc. The stochastic solvers :func:`qutip.stochastic.general_stochastic`,; :func:`qutip.stochastic.ssesolve`, :func:`qutip.stochastic.smesolve`,; :func:`qutip.stochastic.photocurrent_sesolve` and; :func:`qutip.stochastic.photocurrent_mesolve`; all take the same keyword arguments as; the constructor of these class, and internally they use these arguments to; construct an instance of this class, so it is rarely needed to explicitly; create an instance of this class. Within the attribute list, a ``time_dependent_object`` is either. - :class:`~qutip.Qobj`: a constant term; - 2-element list of ``[Qobj, time_dependence]``: a time-dependent term; where the ``Qobj`` will be multiplied by the time-dependent scalar. For more details on all allowed time-dependent objects, see the; documentation for :class:`~qutip.QobjEvo`. Attributes; ----------; H : time_dependent_object or list of time_dependent_object; System Hamiltonian in standard time-dependent list format. This is the; same as the argument that (e.g.) :func:`~qutip.mesolve` takes.; If this is a list of elements, they are summed. state0 : :class:`qutip.Qobj`; Initial state vector (ket) or density matrix. times : array_like of float; List of times for :math:`t`. Must be uniformly spaced. c_ops : list of time_dependent_object; List of deterministic collapse operators. Each element of the list is; a separate operator; unlike the Hamiltonian, there is no implicit; summation over the terms. sc_ops : list of time_dependent_object; List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the equ",MatchSource.WIKI,docs/4.7/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/stochastic.html
https://qutip.org/docs/4.7/modules/qutip/stochastic.html:6896,Integrability,depend,dependent,6896,"ard M. Wiseman, Gerard J. Milburn, *Quantum measurement and; control*.; """""". [docs]class StochasticSolverOptions:; """"""Class of options for stochastic solvers such as; :func:`qutip.stochastic.ssesolve`, :func:`qutip.stochastic.smesolve`, etc. The stochastic solvers :func:`qutip.stochastic.general_stochastic`,; :func:`qutip.stochastic.ssesolve`, :func:`qutip.stochastic.smesolve`,; :func:`qutip.stochastic.photocurrent_sesolve` and; :func:`qutip.stochastic.photocurrent_mesolve`; all take the same keyword arguments as; the constructor of these class, and internally they use these arguments to; construct an instance of this class, so it is rarely needed to explicitly; create an instance of this class. Within the attribute list, a ``time_dependent_object`` is either. - :class:`~qutip.Qobj`: a constant term; - 2-element list of ``[Qobj, time_dependence]``: a time-dependent term; where the ``Qobj`` will be multiplied by the time-dependent scalar. For more details on all allowed time-dependent objects, see the; documentation for :class:`~qutip.QobjEvo`. Attributes; ----------; H : time_dependent_object or list of time_dependent_object; System Hamiltonian in standard time-dependent list format. This is the; same as the argument that (e.g.) :func:`~qutip.mesolve` takes.; If this is a list of elements, they are summed. state0 : :class:`qutip.Qobj`; Initial state vector (ket) or density matrix. times : array_like of float; List of times for :math:`t`. Must be uniformly spaced. c_ops : list of time_dependent_object; List of deterministic collapse operators. Each element of the list is; a separate operator; unlike the Hamiltonian, there is no implicit; summation over the terms. sc_ops : list of time_dependent_object; List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the equation of motion according to how the d1 and d2 functions; are defined. Each element of the list is a separate operator, like; ``c_o",MatchSource.WIKI,docs/4.7/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/stochastic.html
https://qutip.org/docs/4.7/modules/qutip/stochastic.html:7087,Integrability,depend,dependent,7087,"ions for stochastic solvers such as; :func:`qutip.stochastic.ssesolve`, :func:`qutip.stochastic.smesolve`, etc. The stochastic solvers :func:`qutip.stochastic.general_stochastic`,; :func:`qutip.stochastic.ssesolve`, :func:`qutip.stochastic.smesolve`,; :func:`qutip.stochastic.photocurrent_sesolve` and; :func:`qutip.stochastic.photocurrent_mesolve`; all take the same keyword arguments as; the constructor of these class, and internally they use these arguments to; construct an instance of this class, so it is rarely needed to explicitly; create an instance of this class. Within the attribute list, a ``time_dependent_object`` is either. - :class:`~qutip.Qobj`: a constant term; - 2-element list of ``[Qobj, time_dependence]``: a time-dependent term; where the ``Qobj`` will be multiplied by the time-dependent scalar. For more details on all allowed time-dependent objects, see the; documentation for :class:`~qutip.QobjEvo`. Attributes; ----------; H : time_dependent_object or list of time_dependent_object; System Hamiltonian in standard time-dependent list format. This is the; same as the argument that (e.g.) :func:`~qutip.mesolve` takes.; If this is a list of elements, they are summed. state0 : :class:`qutip.Qobj`; Initial state vector (ket) or density matrix. times : array_like of float; List of times for :math:`t`. Must be uniformly spaced. c_ops : list of time_dependent_object; List of deterministic collapse operators. Each element of the list is; a separate operator; unlike the Hamiltonian, there is no implicit; summation over the terms. sc_ops : list of time_dependent_object; List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the equation of motion according to how the d1 and d2 functions; are defined. Each element of the list is a separate operator, like; ``c_ops``. e_ops : list of :class:`qutip.Qobj`; Single operator or list of operators for which to evaluate; expectation values. m_ops :",MatchSource.WIKI,docs/4.7/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/stochastic.html
https://qutip.org/docs/4.7/modules/qutip/stochastic.html:8313,Integrability,depend,dependent,8313,"sity matrix. times : array_like of float; List of times for :math:`t`. Must be uniformly spaced. c_ops : list of time_dependent_object; List of deterministic collapse operators. Each element of the list is; a separate operator; unlike the Hamiltonian, there is no implicit; summation over the terms. sc_ops : list of time_dependent_object; List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the equation of motion according to how the d1 and d2 functions; are defined. Each element of the list is a separate operator, like; ``c_ops``. e_ops : list of :class:`qutip.Qobj`; Single operator or list of operators for which to evaluate; expectation values. m_ops : list of :class:`qutip.Qobj`; List of operators representing the measurement operators. The expected; format is a nested list with one measurement operator for each; stochastic increament, for each stochastic collapse operator. args : dict; Dictionary of parameters for time dependent systems. tol : float; Tolerance of the solver for implicit methods. ntraj : int; Number of trajectors. nsubsteps : int; Number of sub steps between each time-spep given in `times`. dW_factors : array; Array of length len(sc_ops), containing scaling factors for each; measurement operator in m_ops. solver : string; Name of the solver method to use for solving the stochastic; equations. Valid values are:. - order 1/2 algorithms: 'euler-maruyama', 'pc-euler', 'pc-euler-imp'; - order 1 algorithms: 'milstein', 'platen', 'milstein-imp', 'rouchon'; - order 3/2 algorithms: 'taylor1.5', 'taylor1.5-imp', 'explicit1.5'; - order 2 algorithms: 'taylor2.0'. See the documentation of :func:`~qutip.stochastic.stochastic_solvers`; for a description of the solvers. Implicit methods can adjust; tolerance via the kw 'tol'. Default is {'tol': 1e-6}. method : string ('homodyne', 'heterodyne'); The name of the type of measurement process that give rise to the; stochastic equation to so",MatchSource.WIKI,docs/4.7/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/stochastic.html
https://qutip.org/docs/4.7/modules/qutip/stochastic.html:11194,Integrability,depend,dependent,11194,"he evolution.; Normalizing density matrices introduce numerical errors. options : :class:`qutip.solver.Options`; Generic solver options. Only options.average_states and; options.store_states are used. map_func: function; A map function or managing the calls to single-trajactory solvers. map_kwargs: dictionary; Optional keyword arguments to the map_func function function. progress_bar : :class:`qutip.ui.BaseProgressBar`; Optional progress bar class instance.; """"""; def __init__(self, me, H=None, c_ops=[], sc_ops=[], state0=None,; e_ops=[], m_ops=None, store_all_expect=False,; store_measurement=False, dW_factors=None,; solver=None, method=""homodyne"", normalize=None,; times=None, nsubsteps=1, ntraj=1, tol=None,; generate_noise=None, noise=None,; progress_bar=None, map_func=None, map_kwargs=None,; args={}, options=None, noiseDepth=20):. if options is None:; options = Options(). if progress_bar is None:; progress_bar = TextProgressBar(). # System; # Cast to QobjEvo so the code has only one version for both the; # constant and time-dependent case.; self.me = me. if H is not None:; msg = ""The Hamiltonian format is not valid. ""; try:; self.H = QobjEvo(H, args=args, tlist=times,; e_ops=e_ops, state0=state0); except Exception as e:; raise ValueError(msg + str(e)) from e; else:; self.H = H. if sc_ops:; msg = (""The sc_ops format is not valid. Options are ""; ""[ Qobj / QobjEvo / [Qobj, coeff]]. ""); try:; self.sc_ops = [QobjEvo(op, args=args, tlist=times,; e_ops=e_ops, state0=state0); for op in sc_ops]; except Exception as e:; raise ValueError(msg + str(e)) from e; else:; self.sc_ops = sc_ops. if c_ops:; msg = (""The c_ops format is not valid. Options are ""; ""[ Qobj / QobjEvo / [Qobj, coeff]]. ""); try:; self.c_ops = [QobjEvo(op, args=args, tlist=times,; e_ops=e_ops, state0=state0); for op in c_ops]; except Exception as e:; raise ValueError(msg + str(e)) from e; else:; self.c_ops = c_ops. self.state0 = state0; self.rho0 = mat2vec(state0.full()).ravel(). # Observation. for e_op in e_op",MatchSource.WIKI,docs/4.7/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/stochastic.html
https://qutip.org/docs/4.7/modules/qutip/stochastic.html:17037,Integrability,depend,depending,17037,"ten', 'pc-euler', 'pc-euler-imp',; 'milstein', 'milstein-imp', 'rouchon', 'taylor1.5',; 'taylor1.5-imp', 'explicit1.5', 'taylor2.0',; ]; raise ValueError(""The solver should be one of {!r}"".format(known)). class StochasticSolverOptionsPhoto(StochasticSolverOptions):; """"""; Attributes; ----------. solver : string; Name of the solver method to use for solving the evolution; of the system.*; order 1 algorithms: 'euler'; order 2 algorithms: 'pred-corr'; In photocurrent evolution; """"""; def set_solver(self):; if self.solver in [None, 'euler', 1, 60]:; self.solver_code = 60; self.solver = 'euler'; elif self.solver in ['pred-corr', 'predictor-corrector', 110, 2]:; self.solver_code = 110; self.solver = 'pred-corr'; else:; raise Exception(""The solver should be one of "" +; ""[None, 'euler', 'predictor-corrector']""). [docs]def smesolve(H, rho0, times, c_ops=[], sc_ops=[], e_ops=[],; _safe_mode=True, args={}, **kwargs):; """"""; Solve stochastic master equation. Dispatch to specific solvers; depending on the value of the `solver` keyword argument. Parameters; ----------. H : :class:`qutip.Qobj`, or time dependent system.; System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. rho0 : :class:`qutip.Qobj`; Initial density matrix or state vector (ket). times : *list* / *array*; List of times for :math:`t`. Must be uniformly spaced. c_ops : list of :class:`qutip.Qobj`, or time dependent Qobjs.; Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation.; Can depend on time, see StochasticSolverOptions help for format. sc_ops : list of :class:`qutip.Qobj`, or time dependent Qobjs.; List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_ops : list of :class:`qutip.Qobj`; single operator or list of opera",MatchSource.WIKI,docs/4.7/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/stochastic.html
https://qutip.org/docs/4.7/modules/qutip/stochastic.html:17151,Integrability,depend,dependent,17151,", 'explicit1.5', 'taylor2.0',; ]; raise ValueError(""The solver should be one of {!r}"".format(known)). class StochasticSolverOptionsPhoto(StochasticSolverOptions):; """"""; Attributes; ----------. solver : string; Name of the solver method to use for solving the evolution; of the system.*; order 1 algorithms: 'euler'; order 2 algorithms: 'pred-corr'; In photocurrent evolution; """"""; def set_solver(self):; if self.solver in [None, 'euler', 1, 60]:; self.solver_code = 60; self.solver = 'euler'; elif self.solver in ['pred-corr', 'predictor-corrector', 110, 2]:; self.solver_code = 110; self.solver = 'pred-corr'; else:; raise Exception(""The solver should be one of "" +; ""[None, 'euler', 'predictor-corrector']""). [docs]def smesolve(H, rho0, times, c_ops=[], sc_ops=[], e_ops=[],; _safe_mode=True, args={}, **kwargs):; """"""; Solve stochastic master equation. Dispatch to specific solvers; depending on the value of the `solver` keyword argument. Parameters; ----------. H : :class:`qutip.Qobj`, or time dependent system.; System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. rho0 : :class:`qutip.Qobj`; Initial density matrix or state vector (ket). times : *list* / *array*; List of times for :math:`t`. Must be uniformly spaced. c_ops : list of :class:`qutip.Qobj`, or time dependent Qobjs.; Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation.; Can depend on time, see StochasticSolverOptions help for format. sc_ops : list of :class:`qutip.Qobj`, or time dependent Qobjs.; List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_ops : list of :class:`qutip.Qobj`; single operator or list of operators for which to evaluate; expectation values. kwargs : *dictionary*; Optional keyword arguments. See",MatchSource.WIKI,docs/4.7/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/stochastic.html
https://qutip.org/docs/4.7/modules/qutip/stochastic.html:17195,Integrability,depend,depend,17195,"be one of {!r}"".format(known)). class StochasticSolverOptionsPhoto(StochasticSolverOptions):; """"""; Attributes; ----------. solver : string; Name of the solver method to use for solving the evolution; of the system.*; order 1 algorithms: 'euler'; order 2 algorithms: 'pred-corr'; In photocurrent evolution; """"""; def set_solver(self):; if self.solver in [None, 'euler', 1, 60]:; self.solver_code = 60; self.solver = 'euler'; elif self.solver in ['pred-corr', 'predictor-corrector', 110, 2]:; self.solver_code = 110; self.solver = 'pred-corr'; else:; raise Exception(""The solver should be one of "" +; ""[None, 'euler', 'predictor-corrector']""). [docs]def smesolve(H, rho0, times, c_ops=[], sc_ops=[], e_ops=[],; _safe_mode=True, args={}, **kwargs):; """"""; Solve stochastic master equation. Dispatch to specific solvers; depending on the value of the `solver` keyword argument. Parameters; ----------. H : :class:`qutip.Qobj`, or time dependent system.; System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. rho0 : :class:`qutip.Qobj`; Initial density matrix or state vector (ket). times : *list* / *array*; List of times for :math:`t`. Must be uniformly spaced. c_ops : list of :class:`qutip.Qobj`, or time dependent Qobjs.; Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation.; Can depend on time, see StochasticSolverOptions help for format. sc_ops : list of :class:`qutip.Qobj`, or time dependent Qobjs.; List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_ops : list of :class:`qutip.Qobj`; single operator or list of operators for which to evaluate; expectation values. kwargs : *dictionary*; Optional keyword arguments. See; :class:`qutip.stochastic.StochasticSolverOptions`. Returns; -------.",MatchSource.WIKI,docs/4.7/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/stochastic.html
https://qutip.org/docs/4.7/modules/qutip/stochastic.html:17456,Integrability,depend,dependent,17456,"s: 'euler'; order 2 algorithms: 'pred-corr'; In photocurrent evolution; """"""; def set_solver(self):; if self.solver in [None, 'euler', 1, 60]:; self.solver_code = 60; self.solver = 'euler'; elif self.solver in ['pred-corr', 'predictor-corrector', 110, 2]:; self.solver_code = 110; self.solver = 'pred-corr'; else:; raise Exception(""The solver should be one of "" +; ""[None, 'euler', 'predictor-corrector']""). [docs]def smesolve(H, rho0, times, c_ops=[], sc_ops=[], e_ops=[],; _safe_mode=True, args={}, **kwargs):; """"""; Solve stochastic master equation. Dispatch to specific solvers; depending on the value of the `solver` keyword argument. Parameters; ----------. H : :class:`qutip.Qobj`, or time dependent system.; System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. rho0 : :class:`qutip.Qobj`; Initial density matrix or state vector (ket). times : *list* / *array*; List of times for :math:`t`. Must be uniformly spaced. c_ops : list of :class:`qutip.Qobj`, or time dependent Qobjs.; Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation.; Can depend on time, see StochasticSolverOptions help for format. sc_ops : list of :class:`qutip.Qobj`, or time dependent Qobjs.; List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_ops : list of :class:`qutip.Qobj`; single operator or list of operators for which to evaluate; expectation values. kwargs : *dictionary*; Optional keyword arguments. See; :class:`qutip.stochastic.StochasticSolverOptions`. Returns; -------. output: :class:`qutip.solver.Result`. An instance of the class :class:`qutip.solver.Result`. """"""; if ""method"" in kwargs and kwargs[""method""] == ""photocurrent"":; print(""stochastic solver with photocurrent method has been moved to ""; ""i",MatchSource.WIKI,docs/4.7/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/stochastic.html
https://qutip.org/docs/4.7/modules/qutip/stochastic.html:17580,Integrability,depend,depend,17580,"ver_code = 60; self.solver = 'euler'; elif self.solver in ['pred-corr', 'predictor-corrector', 110, 2]:; self.solver_code = 110; self.solver = 'pred-corr'; else:; raise Exception(""The solver should be one of "" +; ""[None, 'euler', 'predictor-corrector']""). [docs]def smesolve(H, rho0, times, c_ops=[], sc_ops=[], e_ops=[],; _safe_mode=True, args={}, **kwargs):; """"""; Solve stochastic master equation. Dispatch to specific solvers; depending on the value of the `solver` keyword argument. Parameters; ----------. H : :class:`qutip.Qobj`, or time dependent system.; System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. rho0 : :class:`qutip.Qobj`; Initial density matrix or state vector (ket). times : *list* / *array*; List of times for :math:`t`. Must be uniformly spaced. c_ops : list of :class:`qutip.Qobj`, or time dependent Qobjs.; Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation.; Can depend on time, see StochasticSolverOptions help for format. sc_ops : list of :class:`qutip.Qobj`, or time dependent Qobjs.; List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_ops : list of :class:`qutip.Qobj`; single operator or list of operators for which to evaluate; expectation values. kwargs : *dictionary*; Optional keyword arguments. See; :class:`qutip.stochastic.StochasticSolverOptions`. Returns; -------. output: :class:`qutip.solver.Result`. An instance of the class :class:`qutip.solver.Result`. """"""; if ""method"" in kwargs and kwargs[""method""] == ""photocurrent"":; print(""stochastic solver with photocurrent method has been moved to ""; ""it's own function: photocurrent_mesolve""); return photocurrent_mesolve(H, rho0, times, c_ops=c_ops, sc_ops=sc_ops,; e_ops=e_ops, _safe_mode=_safe_mode,",MatchSource.WIKI,docs/4.7/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/stochastic.html
https://qutip.org/docs/4.7/modules/qutip/stochastic.html:17687,Integrability,depend,dependent,17687,"or-corrector', 110, 2]:; self.solver_code = 110; self.solver = 'pred-corr'; else:; raise Exception(""The solver should be one of "" +; ""[None, 'euler', 'predictor-corrector']""). [docs]def smesolve(H, rho0, times, c_ops=[], sc_ops=[], e_ops=[],; _safe_mode=True, args={}, **kwargs):; """"""; Solve stochastic master equation. Dispatch to specific solvers; depending on the value of the `solver` keyword argument. Parameters; ----------. H : :class:`qutip.Qobj`, or time dependent system.; System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. rho0 : :class:`qutip.Qobj`; Initial density matrix or state vector (ket). times : *list* / *array*; List of times for :math:`t`. Must be uniformly spaced. c_ops : list of :class:`qutip.Qobj`, or time dependent Qobjs.; Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation.; Can depend on time, see StochasticSolverOptions help for format. sc_ops : list of :class:`qutip.Qobj`, or time dependent Qobjs.; List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_ops : list of :class:`qutip.Qobj`; single operator or list of operators for which to evaluate; expectation values. kwargs : *dictionary*; Optional keyword arguments. See; :class:`qutip.stochastic.StochasticSolverOptions`. Returns; -------. output: :class:`qutip.solver.Result`. An instance of the class :class:`qutip.solver.Result`. """"""; if ""method"" in kwargs and kwargs[""method""] == ""photocurrent"":; print(""stochastic solver with photocurrent method has been moved to ""; ""it's own function: photocurrent_mesolve""); return photocurrent_mesolve(H, rho0, times, c_ops=c_ops, sc_ops=sc_ops,; e_ops=e_ops, _safe_mode=_safe_mode,; args=args, **kwargs); if isket(rho0):; rho0 = ket2dm(rho0). if isinstance(e_ops",MatchSource.WIKI,docs/4.7/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/stochastic.html
https://qutip.org/docs/4.7/modules/qutip/stochastic.html:17920,Integrability,depend,depend,17920,"args={}, **kwargs):; """"""; Solve stochastic master equation. Dispatch to specific solvers; depending on the value of the `solver` keyword argument. Parameters; ----------. H : :class:`qutip.Qobj`, or time dependent system.; System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. rho0 : :class:`qutip.Qobj`; Initial density matrix or state vector (ket). times : *list* / *array*; List of times for :math:`t`. Must be uniformly spaced. c_ops : list of :class:`qutip.Qobj`, or time dependent Qobjs.; Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation.; Can depend on time, see StochasticSolverOptions help for format. sc_ops : list of :class:`qutip.Qobj`, or time dependent Qobjs.; List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_ops : list of :class:`qutip.Qobj`; single operator or list of operators for which to evaluate; expectation values. kwargs : *dictionary*; Optional keyword arguments. See; :class:`qutip.stochastic.StochasticSolverOptions`. Returns; -------. output: :class:`qutip.solver.Result`. An instance of the class :class:`qutip.solver.Result`. """"""; if ""method"" in kwargs and kwargs[""method""] == ""photocurrent"":; print(""stochastic solver with photocurrent method has been moved to ""; ""it's own function: photocurrent_mesolve""); return photocurrent_mesolve(H, rho0, times, c_ops=c_ops, sc_ops=sc_ops,; e_ops=e_ops, _safe_mode=_safe_mode,; args=args, **kwargs); if isket(rho0):; rho0 = ket2dm(rho0). if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None. sso = StochasticSolverOptions(True, H=H, state0=rho0, times=times,; c_ops=c_ops, sc_ops=sc_ops, e_ops=e_ops,; args=args, **kwargs). if _safe_mode:; _safety_checks(sso",MatchSource.WIKI,docs/4.7/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/stochastic.html
https://qutip.org/docs/4.7/modules/qutip/stochastic.html:21305,Integrability,depend,depending,21305," != len(sso.m_ops):; raise Exception(""The len of dW_factors is not the same as sc_ops""). elif sso.method == ""photocurrent"":; raise NotImplementedError(""Moved to 'photocurrent_mesolve'""). else:; raise Exception(""The method must be one of None, homodyne, heterodyne""). sso.ce_ops = [QobjEvo(spre(op)) for op in sso.e_ops]; sso.cm_ops = [QobjEvo(spre(op)) for op in sso.m_ops]. sso.LH.compile(); [op.compile() for op in sso.sops]; [op.compile() for op in sso.cm_ops]; [op.compile() for op in sso.ce_ops]. if sso.solver_code in [103, 153]:; sso.imp = 1 - sso.LH * 0.5; sso.imp.compile(). sso.solver_obj = SMESolver; sso.solver_name = ""smesolve_"" + sso.solver. res = _sesolve_generic(sso, sso.options, sso.progress_bar). if e_ops_dict:; res.expect = {e: res.expect[n]; for n, e in enumerate(e_ops_dict.keys())}; return res. [docs]def ssesolve(H, psi0, times, sc_ops=[], e_ops=[],; _safe_mode=True, args={}, **kwargs):; """"""; Solve stochastic schrodinger equation. Dispatch to specific solvers; depending on the value of the `solver` keyword argument. Parameters; ----------. H : :class:`qutip.Qobj`, or time dependent system.; System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. psi0 : :class:`qutip.Qobj`; State vector (ket). times : *list* / *array*; List of times for :math:`t`. Must be uniformly spaced. sc_ops : list of :class:`qutip.Qobj`, or time dependent Qobjs.; List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_ops : list of :class:`qutip.Qobj`; single operator or list of operators for which to evaluate; expectation values. kwargs : *dictionary*; Optional keyword arguments. See; :class:`qutip.stochastic.StochasticSolverOptions`. Returns; -------. output: :class:`qutip.solver.Result`. An instance of the class :class:`qutip.solver",MatchSource.WIKI,docs/4.7/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/stochastic.html
https://qutip.org/docs/4.7/modules/qutip/stochastic.html:21419,Integrability,depend,dependent,21419,"d == ""photocurrent"":; raise NotImplementedError(""Moved to 'photocurrent_mesolve'""). else:; raise Exception(""The method must be one of None, homodyne, heterodyne""). sso.ce_ops = [QobjEvo(spre(op)) for op in sso.e_ops]; sso.cm_ops = [QobjEvo(spre(op)) for op in sso.m_ops]. sso.LH.compile(); [op.compile() for op in sso.sops]; [op.compile() for op in sso.cm_ops]; [op.compile() for op in sso.ce_ops]. if sso.solver_code in [103, 153]:; sso.imp = 1 - sso.LH * 0.5; sso.imp.compile(). sso.solver_obj = SMESolver; sso.solver_name = ""smesolve_"" + sso.solver. res = _sesolve_generic(sso, sso.options, sso.progress_bar). if e_ops_dict:; res.expect = {e: res.expect[n]; for n, e in enumerate(e_ops_dict.keys())}; return res. [docs]def ssesolve(H, psi0, times, sc_ops=[], e_ops=[],; _safe_mode=True, args={}, **kwargs):; """"""; Solve stochastic schrodinger equation. Dispatch to specific solvers; depending on the value of the `solver` keyword argument. Parameters; ----------. H : :class:`qutip.Qobj`, or time dependent system.; System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. psi0 : :class:`qutip.Qobj`; State vector (ket). times : *list* / *array*; List of times for :math:`t`. Must be uniformly spaced. sc_ops : list of :class:`qutip.Qobj`, or time dependent Qobjs.; List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_ops : list of :class:`qutip.Qobj`; single operator or list of operators for which to evaluate; expectation values. kwargs : *dictionary*; Optional keyword arguments. See; :class:`qutip.stochastic.StochasticSolverOptions`. Returns; -------. output: :class:`qutip.solver.Result`. An instance of the class :class:`qutip.solver.Result`.; """"""; if ""method"" in kwargs and kwargs[""method""] == ""photocurrent"":; print(""stochastic solve",MatchSource.WIKI,docs/4.7/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/stochastic.html
https://qutip.org/docs/4.7/modules/qutip/stochastic.html:21463,Integrability,depend,depend,21463,"t_mesolve'""). else:; raise Exception(""The method must be one of None, homodyne, heterodyne""). sso.ce_ops = [QobjEvo(spre(op)) for op in sso.e_ops]; sso.cm_ops = [QobjEvo(spre(op)) for op in sso.m_ops]. sso.LH.compile(); [op.compile() for op in sso.sops]; [op.compile() for op in sso.cm_ops]; [op.compile() for op in sso.ce_ops]. if sso.solver_code in [103, 153]:; sso.imp = 1 - sso.LH * 0.5; sso.imp.compile(). sso.solver_obj = SMESolver; sso.solver_name = ""smesolve_"" + sso.solver. res = _sesolve_generic(sso, sso.options, sso.progress_bar). if e_ops_dict:; res.expect = {e: res.expect[n]; for n, e in enumerate(e_ops_dict.keys())}; return res. [docs]def ssesolve(H, psi0, times, sc_ops=[], e_ops=[],; _safe_mode=True, args={}, **kwargs):; """"""; Solve stochastic schrodinger equation. Dispatch to specific solvers; depending on the value of the `solver` keyword argument. Parameters; ----------. H : :class:`qutip.Qobj`, or time dependent system.; System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. psi0 : :class:`qutip.Qobj`; State vector (ket). times : *list* / *array*; List of times for :math:`t`. Must be uniformly spaced. sc_ops : list of :class:`qutip.Qobj`, or time dependent Qobjs.; List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_ops : list of :class:`qutip.Qobj`; single operator or list of operators for which to evaluate; expectation values. kwargs : *dictionary*; Optional keyword arguments. See; :class:`qutip.stochastic.StochasticSolverOptions`. Returns; -------. output: :class:`qutip.solver.Result`. An instance of the class :class:`qutip.solver.Result`.; """"""; if ""method"" in kwargs and kwargs[""method""] == ""photocurrent"":; print(""stochastic solver with photocurrent method has been moved to ""; ""it's own function: ph",MatchSource.WIKI,docs/4.7/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/stochastic.html
https://qutip.org/docs/4.7/modules/qutip/stochastic.html:21699,Integrability,depend,dependent,21699,"compile(); [op.compile() for op in sso.sops]; [op.compile() for op in sso.cm_ops]; [op.compile() for op in sso.ce_ops]. if sso.solver_code in [103, 153]:; sso.imp = 1 - sso.LH * 0.5; sso.imp.compile(). sso.solver_obj = SMESolver; sso.solver_name = ""smesolve_"" + sso.solver. res = _sesolve_generic(sso, sso.options, sso.progress_bar). if e_ops_dict:; res.expect = {e: res.expect[n]; for n, e in enumerate(e_ops_dict.keys())}; return res. [docs]def ssesolve(H, psi0, times, sc_ops=[], e_ops=[],; _safe_mode=True, args={}, **kwargs):; """"""; Solve stochastic schrodinger equation. Dispatch to specific solvers; depending on the value of the `solver` keyword argument. Parameters; ----------. H : :class:`qutip.Qobj`, or time dependent system.; System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. psi0 : :class:`qutip.Qobj`; State vector (ket). times : *list* / *array*; List of times for :math:`t`. Must be uniformly spaced. sc_ops : list of :class:`qutip.Qobj`, or time dependent Qobjs.; List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_ops : list of :class:`qutip.Qobj`; single operator or list of operators for which to evaluate; expectation values. kwargs : *dictionary*; Optional keyword arguments. See; :class:`qutip.stochastic.StochasticSolverOptions`. Returns; -------. output: :class:`qutip.solver.Result`. An instance of the class :class:`qutip.solver.Result`.; """"""; if ""method"" in kwargs and kwargs[""method""] == ""photocurrent"":; print(""stochastic solver with photocurrent method has been moved to ""; ""it's own function: photocurrent_sesolve""); return photocurrent_sesolve(H, psi0, times, sc_ops=sc_ops,; e_ops=e_ops, _safe_mode=_safe_mode,; args=args, **kwargs). if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in ",MatchSource.WIKI,docs/4.7/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/stochastic.html
https://qutip.org/docs/4.7/modules/qutip/stochastic.html:21932,Integrability,depend,depend,21932,"+ sso.solver. res = _sesolve_generic(sso, sso.options, sso.progress_bar). if e_ops_dict:; res.expect = {e: res.expect[n]; for n, e in enumerate(e_ops_dict.keys())}; return res. [docs]def ssesolve(H, psi0, times, sc_ops=[], e_ops=[],; _safe_mode=True, args={}, **kwargs):; """"""; Solve stochastic schrodinger equation. Dispatch to specific solvers; depending on the value of the `solver` keyword argument. Parameters; ----------. H : :class:`qutip.Qobj`, or time dependent system.; System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. psi0 : :class:`qutip.Qobj`; State vector (ket). times : *list* / *array*; List of times for :math:`t`. Must be uniformly spaced. sc_ops : list of :class:`qutip.Qobj`, or time dependent Qobjs.; List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_ops : list of :class:`qutip.Qobj`; single operator or list of operators for which to evaluate; expectation values. kwargs : *dictionary*; Optional keyword arguments. See; :class:`qutip.stochastic.StochasticSolverOptions`. Returns; -------. output: :class:`qutip.solver.Result`. An instance of the class :class:`qutip.solver.Result`.; """"""; if ""method"" in kwargs and kwargs[""method""] == ""photocurrent"":; print(""stochastic solver with photocurrent method has been moved to ""; ""it's own function: photocurrent_sesolve""); return photocurrent_sesolve(H, psi0, times, sc_ops=sc_ops,; e_ops=e_ops, _safe_mode=_safe_mode,; args=args, **kwargs). if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None. sso = StochasticSolverOptions(False, H=H, state0=psi0, times=times,; sc_ops=sc_ops, e_ops=e_ops,; args=args, **kwargs). if _safe_mode:; _safety_checks(sso). if sso.solver_code == 120:; raise Exception(""rouchon only w",MatchSource.WIKI,docs/4.7/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/stochastic.html
https://qutip.org/docs/4.7/modules/qutip/stochastic.html:27361,Integrability,depend,dependent,27361,"s2 += [spost(op.dag() * op2.dag())]. sso.ce_ops = [QobjEvo(spre(op)) for op in sso.e_ops]; sso.cm_ops = [QobjEvo(spre(op)) for op in sso.m_ops]; sso.preLH = spre(LH); sso.postLH = spost(LH.dag()). sso.preLH.compile(); sso.postLH.compile(); sso.pp.compile(); [op.compile() for op in sso.sops]; [op.compile() for op in sso.preops]; [op.compile() for op in sso.postops]; [op.compile() for op in sso.preops2]; [op.compile() for op in sso.postops2]; [op.compile() for op in sso.cm_ops]; [op.compile() for op in sso.ce_ops]. sso.solver_obj = PmSMESolver; sso.solver_name = ""smesolve_"" + sso.solver; res = _sesolve_generic(sso, sso.options, sso.progress_bar). if e_ops_dict:; res.expect = {e: res.expect[n]; for n, e in enumerate(e_ops_dict.keys())}. return res. [docs]def photocurrent_mesolve(H, rho0, times, c_ops=[], sc_ops=[], e_ops=[],; _safe_mode=True, args={}, **kwargs):; """"""; Solve stochastic master equation using the photocurrent method. Parameters; ----------. H : :class:`qutip.Qobj`, or time dependent system.; System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. rho0 : :class:`qutip.Qobj`; Initial density matrix or state vector (ket). times : *list* / *array*; List of times for :math:`t`. Must be uniformly spaced. c_ops : list of :class:`qutip.Qobj`, or time dependent Qobjs.; Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation.; Can depend on time, see StochasticSolverOptions help for format. sc_ops : list of :class:`qutip.Qobj`, or time dependent Qobjs.; List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_ops : list of :class:`qutip.Qobj` / callback function single; single operator or list of operators for which to evaluate; expectation values. kwargs : *dictionary*; Opti",MatchSource.WIKI,docs/4.7/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/stochastic.html
https://qutip.org/docs/4.7/modules/qutip/stochastic.html:27405,Integrability,depend,depend,27405,"or op in sso.e_ops]; sso.cm_ops = [QobjEvo(spre(op)) for op in sso.m_ops]; sso.preLH = spre(LH); sso.postLH = spost(LH.dag()). sso.preLH.compile(); sso.postLH.compile(); sso.pp.compile(); [op.compile() for op in sso.sops]; [op.compile() for op in sso.preops]; [op.compile() for op in sso.postops]; [op.compile() for op in sso.preops2]; [op.compile() for op in sso.postops2]; [op.compile() for op in sso.cm_ops]; [op.compile() for op in sso.ce_ops]. sso.solver_obj = PmSMESolver; sso.solver_name = ""smesolve_"" + sso.solver; res = _sesolve_generic(sso, sso.options, sso.progress_bar). if e_ops_dict:; res.expect = {e: res.expect[n]; for n, e in enumerate(e_ops_dict.keys())}. return res. [docs]def photocurrent_mesolve(H, rho0, times, c_ops=[], sc_ops=[], e_ops=[],; _safe_mode=True, args={}, **kwargs):; """"""; Solve stochastic master equation using the photocurrent method. Parameters; ----------. H : :class:`qutip.Qobj`, or time dependent system.; System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. rho0 : :class:`qutip.Qobj`; Initial density matrix or state vector (ket). times : *list* / *array*; List of times for :math:`t`. Must be uniformly spaced. c_ops : list of :class:`qutip.Qobj`, or time dependent Qobjs.; Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation.; Can depend on time, see StochasticSolverOptions help for format. sc_ops : list of :class:`qutip.Qobj`, or time dependent Qobjs.; List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_ops : list of :class:`qutip.Qobj` / callback function single; single operator or list of operators for which to evaluate; expectation values. kwargs : *dictionary*; Optional keyword arguments. See; :class:`qutip.stochastic.StochasticSolver",MatchSource.WIKI,docs/4.7/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/stochastic.html
https://qutip.org/docs/4.7/modules/qutip/stochastic.html:27666,Integrability,depend,dependent,27666,"() for op in sso.preops]; [op.compile() for op in sso.postops]; [op.compile() for op in sso.preops2]; [op.compile() for op in sso.postops2]; [op.compile() for op in sso.cm_ops]; [op.compile() for op in sso.ce_ops]. sso.solver_obj = PmSMESolver; sso.solver_name = ""smesolve_"" + sso.solver; res = _sesolve_generic(sso, sso.options, sso.progress_bar). if e_ops_dict:; res.expect = {e: res.expect[n]; for n, e in enumerate(e_ops_dict.keys())}. return res. [docs]def photocurrent_mesolve(H, rho0, times, c_ops=[], sc_ops=[], e_ops=[],; _safe_mode=True, args={}, **kwargs):; """"""; Solve stochastic master equation using the photocurrent method. Parameters; ----------. H : :class:`qutip.Qobj`, or time dependent system.; System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. rho0 : :class:`qutip.Qobj`; Initial density matrix or state vector (ket). times : *list* / *array*; List of times for :math:`t`. Must be uniformly spaced. c_ops : list of :class:`qutip.Qobj`, or time dependent Qobjs.; Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation.; Can depend on time, see StochasticSolverOptions help for format. sc_ops : list of :class:`qutip.Qobj`, or time dependent Qobjs.; List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_ops : list of :class:`qutip.Qobj` / callback function single; single operator or list of operators for which to evaluate; expectation values. kwargs : *dictionary*; Optional keyword arguments. See; :class:`qutip.stochastic.StochasticSolverOptions`. Returns; -------. output: :class:`qutip.solver.Result`. An instance of the class :class:`qutip.solver.Result`.; """"""; if isket(rho0):; rho0 = ket2dm(rho0). if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e",MatchSource.WIKI,docs/4.7/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/stochastic.html
https://qutip.org/docs/4.7/modules/qutip/stochastic.html:27790,Integrability,depend,depend,27790,"e() for op in sso.cm_ops]; [op.compile() for op in sso.ce_ops]. sso.solver_obj = PmSMESolver; sso.solver_name = ""smesolve_"" + sso.solver; res = _sesolve_generic(sso, sso.options, sso.progress_bar). if e_ops_dict:; res.expect = {e: res.expect[n]; for n, e in enumerate(e_ops_dict.keys())}. return res. [docs]def photocurrent_mesolve(H, rho0, times, c_ops=[], sc_ops=[], e_ops=[],; _safe_mode=True, args={}, **kwargs):; """"""; Solve stochastic master equation using the photocurrent method. Parameters; ----------. H : :class:`qutip.Qobj`, or time dependent system.; System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. rho0 : :class:`qutip.Qobj`; Initial density matrix or state vector (ket). times : *list* / *array*; List of times for :math:`t`. Must be uniformly spaced. c_ops : list of :class:`qutip.Qobj`, or time dependent Qobjs.; Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation.; Can depend on time, see StochasticSolverOptions help for format. sc_ops : list of :class:`qutip.Qobj`, or time dependent Qobjs.; List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_ops : list of :class:`qutip.Qobj` / callback function single; single operator or list of operators for which to evaluate; expectation values. kwargs : *dictionary*; Optional keyword arguments. See; :class:`qutip.stochastic.StochasticSolverOptions`. Returns; -------. output: :class:`qutip.solver.Result`. An instance of the class :class:`qutip.solver.Result`.; """"""; if isket(rho0):; rho0 = ket2dm(rho0). if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None. sso = StochasticSolverOptionsPhoto(True, H=H, state0=rho0, times=times,; c_ops=c_ops, sc_ops=sc_ops, e_ops=e",MatchSource.WIKI,docs/4.7/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/stochastic.html
https://qutip.org/docs/4.7/modules/qutip/stochastic.html:27897,Integrability,depend,dependent,27897," PmSMESolver; sso.solver_name = ""smesolve_"" + sso.solver; res = _sesolve_generic(sso, sso.options, sso.progress_bar). if e_ops_dict:; res.expect = {e: res.expect[n]; for n, e in enumerate(e_ops_dict.keys())}. return res. [docs]def photocurrent_mesolve(H, rho0, times, c_ops=[], sc_ops=[], e_ops=[],; _safe_mode=True, args={}, **kwargs):; """"""; Solve stochastic master equation using the photocurrent method. Parameters; ----------. H : :class:`qutip.Qobj`, or time dependent system.; System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. rho0 : :class:`qutip.Qobj`; Initial density matrix or state vector (ket). times : *list* / *array*; List of times for :math:`t`. Must be uniformly spaced. c_ops : list of :class:`qutip.Qobj`, or time dependent Qobjs.; Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation.; Can depend on time, see StochasticSolverOptions help for format. sc_ops : list of :class:`qutip.Qobj`, or time dependent Qobjs.; List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_ops : list of :class:`qutip.Qobj` / callback function single; single operator or list of operators for which to evaluate; expectation values. kwargs : *dictionary*; Optional keyword arguments. See; :class:`qutip.stochastic.StochasticSolverOptions`. Returns; -------. output: :class:`qutip.solver.Result`. An instance of the class :class:`qutip.solver.Result`.; """"""; if isket(rho0):; rho0 = ket2dm(rho0). if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None. sso = StochasticSolverOptionsPhoto(True, H=H, state0=rho0, times=times,; c_ops=c_ops, sc_ops=sc_ops, e_ops=e_ops,; args=args, **kwargs). if _safe_mode:; _safety_checks(sso). if sso.m_ops is",MatchSource.WIKI,docs/4.7/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/stochastic.html
https://qutip.org/docs/4.7/modules/qutip/stochastic.html:28130,Integrability,depend,depend,28130," times, c_ops=[], sc_ops=[], e_ops=[],; _safe_mode=True, args={}, **kwargs):; """"""; Solve stochastic master equation using the photocurrent method. Parameters; ----------. H : :class:`qutip.Qobj`, or time dependent system.; System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. rho0 : :class:`qutip.Qobj`; Initial density matrix or state vector (ket). times : *list* / *array*; List of times for :math:`t`. Must be uniformly spaced. c_ops : list of :class:`qutip.Qobj`, or time dependent Qobjs.; Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation.; Can depend on time, see StochasticSolverOptions help for format. sc_ops : list of :class:`qutip.Qobj`, or time dependent Qobjs.; List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_ops : list of :class:`qutip.Qobj` / callback function single; single operator or list of operators for which to evaluate; expectation values. kwargs : *dictionary*; Optional keyword arguments. See; :class:`qutip.stochastic.StochasticSolverOptions`. Returns; -------. output: :class:`qutip.solver.Result`. An instance of the class :class:`qutip.solver.Result`.; """"""; if isket(rho0):; rho0 = ket2dm(rho0). if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None. sso = StochasticSolverOptionsPhoto(True, H=H, state0=rho0, times=times,; c_ops=c_ops, sc_ops=sc_ops, e_ops=e_ops,; args=args, **kwargs). if _safe_mode:; _safety_checks(sso). if sso.m_ops is None:; sso.m_ops = [op * 0 for op in sso.sc_ops]; if not isinstance(sso.dW_factors, list):; sso.dW_factors = [1] * len(sso.sc_ops); elif len(sso.dW_factors) != len(sso.sc_ops):; raise Exception(""The len of dW_factors is not the same as sc_ops""). sso.solver_o",MatchSource.WIKI,docs/4.7/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/stochastic.html
https://qutip.org/docs/4.7/modules/qutip/stochastic.html:30178,Integrability,depend,dependent,30178,"solver_name = ""photocurrent_mesolve""; sso.LH = liouvillian(sso.H, c_ops=sso.c_ops) * sso.dt. def _prespostdag(op):; return spre(op) * spost(op.dag()). sso.sops = [[spre(op._cdc()) + spost(op._cdc()),; spre(op._cdc()),; op.apply(_prespostdag)._f_norm2()] for op in sso.sc_ops]; sso.ce_ops = [QobjEvo(spre(op)) for op in sso.e_ops]; sso.cm_ops = [QobjEvo(spre(op)) for op in sso.m_ops]. sso.LH.compile(); [[op.compile() for op in ops] for ops in sso.sops]; [op.compile() for op in sso.cm_ops]; [op.compile() for op in sso.ce_ops]. res = _sesolve_generic(sso, sso.options, sso.progress_bar); res.num_collapse = [np.count_nonzero(noise) for noise in res.noise]. if e_ops_dict:; res.expect = {e: res.expect[n]; for n, e in enumerate(e_ops_dict.keys())}. return res. [docs]def photocurrent_sesolve(H, psi0, times, sc_ops=[], e_ops=[],; _safe_mode=True, args={}, **kwargs):; """"""; Solve stochastic schrodinger equation using the photocurrent method. Parameters; ----------. H : :class:`qutip.Qobj`, or time dependent system.; System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. psi0 : :class:`qutip.Qobj`; Initial state vector (ket). times : *list* / *array*; List of times for :math:`t`. Must be uniformly spaced. sc_ops : list of :class:`qutip.Qobj`, or time dependent Qobjs.; List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_ops : list of :class:`qutip.Qobj` / callback function single; single operator or list of operators for which to evaluate; expectation values. kwargs : *dictionary*; Optional keyword arguments. See; :class:`qutip.stochastic.StochasticSolverOptions`. Returns; -------. output: :class:`qutip.solver.Result`. An instance of the class :class:`qutip.solver.Result`.; """"""; if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_",MatchSource.WIKI,docs/4.7/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/stochastic.html
https://qutip.org/docs/4.7/modules/qutip/stochastic.html:30222,Integrability,depend,depend,30222,"s=sso.c_ops) * sso.dt. def _prespostdag(op):; return spre(op) * spost(op.dag()). sso.sops = [[spre(op._cdc()) + spost(op._cdc()),; spre(op._cdc()),; op.apply(_prespostdag)._f_norm2()] for op in sso.sc_ops]; sso.ce_ops = [QobjEvo(spre(op)) for op in sso.e_ops]; sso.cm_ops = [QobjEvo(spre(op)) for op in sso.m_ops]. sso.LH.compile(); [[op.compile() for op in ops] for ops in sso.sops]; [op.compile() for op in sso.cm_ops]; [op.compile() for op in sso.ce_ops]. res = _sesolve_generic(sso, sso.options, sso.progress_bar); res.num_collapse = [np.count_nonzero(noise) for noise in res.noise]. if e_ops_dict:; res.expect = {e: res.expect[n]; for n, e in enumerate(e_ops_dict.keys())}. return res. [docs]def photocurrent_sesolve(H, psi0, times, sc_ops=[], e_ops=[],; _safe_mode=True, args={}, **kwargs):; """"""; Solve stochastic schrodinger equation using the photocurrent method. Parameters; ----------. H : :class:`qutip.Qobj`, or time dependent system.; System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. psi0 : :class:`qutip.Qobj`; Initial state vector (ket). times : *list* / *array*; List of times for :math:`t`. Must be uniformly spaced. sc_ops : list of :class:`qutip.Qobj`, or time dependent Qobjs.; List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_ops : list of :class:`qutip.Qobj` / callback function single; single operator or list of operators for which to evaluate; expectation values. kwargs : *dictionary*; Optional keyword arguments. See; :class:`qutip.stochastic.StochasticSolverOptions`. Returns; -------. output: :class:`qutip.solver.Result`. An instance of the class :class:`qutip.solver.Result`.; """"""; if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = list(e_ops.values()); else:; e_ops_dict = None. sso = Stochastic",MatchSource.WIKI,docs/4.7/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/stochastic.html
https://qutip.org/docs/4.7/modules/qutip/stochastic.html:30466,Integrability,depend,dependent,30466," = [QobjEvo(spre(op)) for op in sso.e_ops]; sso.cm_ops = [QobjEvo(spre(op)) for op in sso.m_ops]. sso.LH.compile(); [[op.compile() for op in ops] for ops in sso.sops]; [op.compile() for op in sso.cm_ops]; [op.compile() for op in sso.ce_ops]. res = _sesolve_generic(sso, sso.options, sso.progress_bar); res.num_collapse = [np.count_nonzero(noise) for noise in res.noise]. if e_ops_dict:; res.expect = {e: res.expect[n]; for n, e in enumerate(e_ops_dict.keys())}. return res. [docs]def photocurrent_sesolve(H, psi0, times, sc_ops=[], e_ops=[],; _safe_mode=True, args={}, **kwargs):; """"""; Solve stochastic schrodinger equation using the photocurrent method. Parameters; ----------. H : :class:`qutip.Qobj`, or time dependent system.; System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. psi0 : :class:`qutip.Qobj`; Initial state vector (ket). times : *list* / *array*; List of times for :math:`t`. Must be uniformly spaced. sc_ops : list of :class:`qutip.Qobj`, or time dependent Qobjs.; List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_ops : list of :class:`qutip.Qobj` / callback function single; single operator or list of operators for which to evaluate; expectation values. kwargs : *dictionary*; Optional keyword arguments. See; :class:`qutip.stochastic.StochasticSolverOptions`. Returns; -------. output: :class:`qutip.solver.Result`. An instance of the class :class:`qutip.solver.Result`.; """"""; if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = list(e_ops.values()); else:; e_ops_dict = None. sso = StochasticSolverOptionsPhoto(False, H=H, state0=psi0, times=times,; sc_ops=sc_ops, e_ops=e_ops,; args=args, **kwargs). if _safe_mode:; _safety_checks(sso). if sso.m_ops is None:; sso.m_ops = [op * 0 for op in sso.sc_ops]; if not",MatchSource.WIKI,docs/4.7/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/stochastic.html
https://qutip.org/docs/4.7/modules/qutip/stochastic.html:30699,Integrability,depend,depend,30699,"eric(sso, sso.options, sso.progress_bar); res.num_collapse = [np.count_nonzero(noise) for noise in res.noise]. if e_ops_dict:; res.expect = {e: res.expect[n]; for n, e in enumerate(e_ops_dict.keys())}. return res. [docs]def photocurrent_sesolve(H, psi0, times, sc_ops=[], e_ops=[],; _safe_mode=True, args={}, **kwargs):; """"""; Solve stochastic schrodinger equation using the photocurrent method. Parameters; ----------. H : :class:`qutip.Qobj`, or time dependent system.; System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. psi0 : :class:`qutip.Qobj`; Initial state vector (ket). times : *list* / *array*; List of times for :math:`t`. Must be uniformly spaced. sc_ops : list of :class:`qutip.Qobj`, or time dependent Qobjs.; List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_ops : list of :class:`qutip.Qobj` / callback function single; single operator or list of operators for which to evaluate; expectation values. kwargs : *dictionary*; Optional keyword arguments. See; :class:`qutip.stochastic.StochasticSolverOptions`. Returns; -------. output: :class:`qutip.solver.Result`. An instance of the class :class:`qutip.solver.Result`.; """"""; if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = list(e_ops.values()); else:; e_ops_dict = None. sso = StochasticSolverOptionsPhoto(False, H=H, state0=psi0, times=times,; sc_ops=sc_ops, e_ops=e_ops,; args=args, **kwargs). if _safe_mode:; _safety_checks(sso). if sso.m_ops is None:; sso.m_ops = [op * 0 for op in sso.sc_ops]; if not isinstance(sso.dW_factors, list):; sso.dW_factors = [1] * len(sso.sc_ops); elif len(sso.dW_factors) != len(sso.sc_ops):; raise Exception(""The len of dW_factors is not the same as sc_ops""). sso.solver_obj = PcSSESolver; sso.solver_name = ""photocurrent_sesolve",MatchSource.WIKI,docs/4.7/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/stochastic.html
https://qutip.org/docs/4.7/modules/qutip/stochastic.html:32532,Integrability,depend,depending,32532,"lif len(sso.dW_factors) != len(sso.sc_ops):; raise Exception(""The len of dW_factors is not the same as sc_ops""). sso.solver_obj = PcSSESolver; sso.solver_name = ""photocurrent_sesolve""; sso.sops = [[op, op._cdc()] for op in sso.sc_ops]; sso.LH = sso.H * (-1j*sso.dt); for ops in sso.sops:; sso.LH -= ops[0]._cdc()*0.5*sso.dt; sso.ce_ops = [QobjEvo(op) for op in sso.e_ops]; sso.cm_ops = [QobjEvo(op) for op in sso.m_ops]. sso.LH.compile(); [[op.compile() for op in ops] for ops in sso.sops]; [op.compile() for op in sso.cm_ops]; [op.compile() for op in sso.ce_ops]. res = _sesolve_generic(sso, sso.options, sso.progress_bar); res.num_collapse = [np.count_nonzero(noise) for noise in res.noise]. if e_ops_dict:; res.expect = {e: res.expect[n]; for n, e in enumerate(e_ops_dict.keys())}. return res. [docs]def general_stochastic(state0, times, d1, d2, e_ops=[], m_ops=[],; _safe_mode=True, len_d2=1, args={}, **kwargs):; """"""; Solve stochastic general equation. Dispatch to specific solvers; depending on the value of the `solver` keyword argument. Parameters; ----------. state0 : :class:`qutip.Qobj`; Initial state vector (ket) or density matrix as a vector. times : *list* / *array*; List of times for :math:`t`. Must be uniformly spaced. d1 : function, callable class; Function representing the deterministic evolution of the system. def d1(time (double), state (as a np.array vector)):; return 1d np.array. d2 : function, callable class; Function representing the stochastic evolution of the system. def d2(time (double), state (as a np.array vector)):; return 2d np.array (N_sc_ops, len(state0)). len_d2 : int; Number of output vector produced by d2. e_ops : list of :class:`qutip.Qobj`; single operator or list of operators for which to evaluate; expectation values.; Must be a superoperator if the state vector is a density matrix. kwargs : *dictionary*; Optional keyword arguments. See; :class:`qutip.stochastic.StochasticSolverOptions`. Returns; -------. output: :class:`qutip.solver.Result`; An",MatchSource.WIKI,docs/4.7/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/stochastic.html
https://qutip.org/docs/4.7/modules/qutip/stochastic.html:2377,Safety,predict,predictor-corrector,2377,"ill violate our line-length reporting if we do that.; """"""; This function is purely a reference point for documenting the available; stochastic solver methods, and takes no actions. Notes; -----; Available solvers for :obj:`~ssesolve` and :obj:`~smesolve`; euler-maruyama; A simple generalization of the Euler method for ordinary; differential equations to stochastic differential equations. Only; solver which could take non-commuting ``sc_ops``. *not tested*. - Order 0.5; - Code: ``'euler-maruyama'``, ``'euler'`` or ``0.5``. milstein; An order 1.0 strong Taylor scheme. Better approximate numerical; solution to stochastic differential equations. See eq. (2.9) of; chapter 12.2 of [1]_. - Order strong 1.0; - Code: ``'milstein'`` or ``1.0``. milstein-imp; An order 1.0 implicit strong Taylor scheme. Implicit Milstein; scheme for the numerical simulation of stiff stochastic; differential equations. - Order strong 1.0; - Code: ``'milstein-imp'``. predictor-corrector; Generalization of the trapezoidal method to stochastic differential; equations. More stable than explicit methods. See eq. (5.4) of; chapter 15.5 of [1]_. - Order strong 0.5, weak 1.0; - Codes to only correct the stochastic part (:math:`\\alpha=0`,; :math:`\\eta=1/2`): ``'pred-corr'``, ``'predictor-corrector'`` or; ``'pc-euler'``; - Codes to correct both the stochastic and deterministic parts; (:math:`\\alpha=1/2`, :math:`\\eta=1/2`): ``'pc-euler-imp'``,; ``'pc-euler-2'`` or ``'pred-corr-2'``. platen; Explicit scheme, creates the Milstein using finite differences; instead of analytic derivatives. Also contains some higher order; terms, thus converges better than Milstein while staying strong; order 1.0. Does not require derivatives, therefore usable by; :func:`~general_stochastic`. See eq. (7.47) of chapter 7 of [2]_. - Order strong 1.0, weak 2.0; - Code: ``'platen'``, ``'platen1'`` or ``'explicit1'``. rouchon; Scheme keeping the positivity of the density matrix; (:obj:`~smesolve` only). See eq. (4) with :math:`\\",MatchSource.WIKI,docs/4.7/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/stochastic.html
https://qutip.org/docs/4.7/modules/qutip/stochastic.html:2688,Safety,predict,predictor-corrector,2688,"hod for ordinary; differential equations to stochastic differential equations. Only; solver which could take non-commuting ``sc_ops``. *not tested*. - Order 0.5; - Code: ``'euler-maruyama'``, ``'euler'`` or ``0.5``. milstein; An order 1.0 strong Taylor scheme. Better approximate numerical; solution to stochastic differential equations. See eq. (2.9) of; chapter 12.2 of [1]_. - Order strong 1.0; - Code: ``'milstein'`` or ``1.0``. milstein-imp; An order 1.0 implicit strong Taylor scheme. Implicit Milstein; scheme for the numerical simulation of stiff stochastic; differential equations. - Order strong 1.0; - Code: ``'milstein-imp'``. predictor-corrector; Generalization of the trapezoidal method to stochastic differential; equations. More stable than explicit methods. See eq. (5.4) of; chapter 15.5 of [1]_. - Order strong 0.5, weak 1.0; - Codes to only correct the stochastic part (:math:`\\alpha=0`,; :math:`\\eta=1/2`): ``'pred-corr'``, ``'predictor-corrector'`` or; ``'pc-euler'``; - Codes to correct both the stochastic and deterministic parts; (:math:`\\alpha=1/2`, :math:`\\eta=1/2`): ``'pc-euler-imp'``,; ``'pc-euler-2'`` or ``'pred-corr-2'``. platen; Explicit scheme, creates the Milstein using finite differences; instead of analytic derivatives. Also contains some higher order; terms, thus converges better than Milstein while staying strong; order 1.0. Does not require derivatives, therefore usable by; :func:`~general_stochastic`. See eq. (7.47) of chapter 7 of [2]_. - Order strong 1.0, weak 2.0; - Code: ``'platen'``, ``'platen1'`` or ``'explicit1'``. rouchon; Scheme keeping the positivity of the density matrix; (:obj:`~smesolve` only). See eq. (4) with :math:`\\eta=1` of [3]_. - Order strong 1.0?; - Code: ``'rouchon'`` or ``'Rouchon'``. taylor1.5; Order 1.5 strong Taylor scheme. Solver with more terms of the; Ito-Taylor expansion. Default solver for :obj:`~smesolve` and; :obj:`~ssesolve`. See eq. (4.6) of chapter 10.4 of [1]_. - Order strong 1.5; - Code: ``'taylor1.5",MatchSource.WIKI,docs/4.7/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/stochastic.html
https://qutip.org/docs/4.7/modules/qutip/stochastic.html:5273,Safety,predict,predictor,5273,"1.5'``, ``'explicit15'`` or ``'platen15'``. taylor2.0; Order 2 strong Taylor scheme. Solver with more terms of the; Stratonovich expansion. See eq. (5.2) of chapter 10.5 of [1]_. - Order strong 2.0; - Code: ``'taylor2.0'``, ``'taylor20'`` or ``2.0``. All solvers, except taylor2.0, are usable in both smesolve and ssesolve; and for both heterodyne and homodyne. taylor2.0 only works for 1; stochastic operator independent of time with the homodyne method.; :func:`~general_stochastic` only accepts the derivative-free; solvers: ``'euler'``, ``'platen'`` and ``'explicit1.5'``. Available solvers for :obj:`~photocurrent_sesolve` and \; :obj:`~photocurrent_mesolve`; Photocurrent use ordinary differential equations between; stochastic ""jump/collapse"". euler; Euler method for ordinary differential equations between jumps.; Only one jump per time interval. Default solver. See eqs. (4.19); and (4.4) of chapter 4 of [4]_. - Order 1.0; - Code: ``'euler'``. predictor–corrector; predictor–corrector method (PECE) for ordinary differential; equations. Uses the Poisson distribution to obtain the number of; jumps at each timestep. - Order 2.0; - Code: ``'pred-corr'``. References; ----------; .. [1] Peter E. Kloeden and Exkhard Platen, *Numerical Solution of; Stochastic Differential Equations*.; .. [2] H.-P. Breuer and F. Petruccione, *The Theory of Open Quantum; Systems*.; .. [3] Pierre Rouchon and Jason F. Ralpha, *Efficient Quantum Filtering for; Quantum Feedback Control*, `arXiv:1410.5345 [quant-ph]; <https://arxiv.org/abs/1410.5345>`_, Phys. Rev. A 91, 012118,; (2015).; .. [4] Howard M. Wiseman, Gerard J. Milburn, *Quantum measurement and; control*.; """""". [docs]class StochasticSolverOptions:; """"""Class of options for stochastic solvers such as; :func:`qutip.stochastic.ssesolve`, :func:`qutip.stochastic.smesolve`, etc. The stochastic solvers :func:`qutip.stochastic.general_stochastic`,; :func:`qutip.stochastic.ssesolve`, :func:`qutip.stochastic.smesolve`,; :func:`qutip.stochastic.photoc",MatchSource.WIKI,docs/4.7/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/stochastic.html
https://qutip.org/docs/4.7/modules/qutip/stochastic.html:5294,Safety,predict,predictor,5294,"1.5'``, ``'explicit15'`` or ``'platen15'``. taylor2.0; Order 2 strong Taylor scheme. Solver with more terms of the; Stratonovich expansion. See eq. (5.2) of chapter 10.5 of [1]_. - Order strong 2.0; - Code: ``'taylor2.0'``, ``'taylor20'`` or ``2.0``. All solvers, except taylor2.0, are usable in both smesolve and ssesolve; and for both heterodyne and homodyne. taylor2.0 only works for 1; stochastic operator independent of time with the homodyne method.; :func:`~general_stochastic` only accepts the derivative-free; solvers: ``'euler'``, ``'platen'`` and ``'explicit1.5'``. Available solvers for :obj:`~photocurrent_sesolve` and \; :obj:`~photocurrent_mesolve`; Photocurrent use ordinary differential equations between; stochastic ""jump/collapse"". euler; Euler method for ordinary differential equations between jumps.; Only one jump per time interval. Default solver. See eqs. (4.19); and (4.4) of chapter 4 of [4]_. - Order 1.0; - Code: ``'euler'``. predictor–corrector; predictor–corrector method (PECE) for ordinary differential; equations. Uses the Poisson distribution to obtain the number of; jumps at each timestep. - Order 2.0; - Code: ``'pred-corr'``. References; ----------; .. [1] Peter E. Kloeden and Exkhard Platen, *Numerical Solution of; Stochastic Differential Equations*.; .. [2] H.-P. Breuer and F. Petruccione, *The Theory of Open Quantum; Systems*.; .. [3] Pierre Rouchon and Jason F. Ralpha, *Efficient Quantum Filtering for; Quantum Feedback Control*, `arXiv:1410.5345 [quant-ph]; <https://arxiv.org/abs/1410.5345>`_, Phys. Rev. A 91, 012118,; (2015).; .. [4] Howard M. Wiseman, Gerard J. Milburn, *Quantum measurement and; control*.; """""". [docs]class StochasticSolverOptions:; """"""Class of options for stochastic solvers such as; :func:`qutip.stochastic.ssesolve`, :func:`qutip.stochastic.smesolve`, etc. The stochastic solvers :func:`qutip.stochastic.general_stochastic`,; :func:`qutip.stochastic.ssesolve`, :func:`qutip.stochastic.smesolve`,; :func:`qutip.stochastic.photoc",MatchSource.WIKI,docs/4.7/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/stochastic.html
https://qutip.org/docs/4.7/modules/qutip/stochastic.html:14727,Safety,predict,predictor-corrector,14727,"; if noise.shape[1] < len(times):; raise ValueError(msg + ""shape[1] >= len(times)""); if noise.shape[2] < nsubsteps:; raise ValueError(msg + ""shape[2] >= nsubsteps""); if noise.shape[3] < len(self.sc_ops) * dw_len:; raise ValueError(msg + ""shape[3] >= len(self.sc_ops)"" +; dw_len_str); self.noise_type = 1; self.noise = noise. else:; self.noise = np.random.randint(0, 2**32, ntraj, dtype=np.uint32); self.noise_type = 0. # Map; self.progress_bar = progress_bar; if self.ntraj > 1 and map_func:; self.map_func = map_func; else:; self.map_func = serial_map; self.map_kwargs = map_kwargs if map_kwargs is not None else {}. # Other; self.options = options; self.args = args; self.set_solver(); self.p = noiseDepth. def set_solver(self):; if self.solver in ['euler-maruyama', 'euler', 50, 0.5]:; self.solver_code = 50; self.solver = 'euler-maruyama'; elif self.solver in ['platen', 'platen1', 'explicit1', 100]:; self.solver_code = 100; self.solver = 'platen'; elif self.solver in ['pred-corr', 'predictor-corrector',; 'pc-euler', 101]:; self.solver_code = 101; self.solver = 'pred-corr'; elif self.solver in ['milstein', 102, 1.0]:; self.solver_code = 102; self.solver = 'milstein'; elif self.solver in ['milstein-imp', 103]:; self.solver_code = 103; self.solver = 'milstein-imp'; elif self.solver in ['pred-corr-2', 'pc-euler-2', 'pc-euler-imp', 104]:; self.solver_code = 104; self.solver = 'pred-corr-2'; elif self.solver in ['Rouchon', 'rouchon', 120]:; self.solver_code = 120; self.solver = 'rouchon'; if not all((op.const for op in self.sc_ops)):; raise ValueError(""Rouchon only works with constant sc_ops""); elif self.solver in ['platen15', 'explicit1.5', 'explicit15', 150]:; self.solver_code = 150; self.solver = 'explicit1.5'; elif self.solver in ['taylor15', 'taylor1.5', None, 1.5, 152]:; self.solver_code = 152; self.solver = 'taylor1.5'; elif self.solver in ['taylor15-imp', 'taylor1.5-imp', 153]:; self.solver_code = 153; self.solver = 'taylor1.5-imp'; elif self.solver in ['taylor2.0', 'tayl",MatchSource.WIKI,docs/4.7/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/stochastic.html
https://qutip.org/docs/4.7/modules/qutip/stochastic.html:16680,Safety,predict,predictor-corrector,16680,"lor1.5-imp'; elif self.solver in ['taylor2.0', 'taylor20', 2.0, 202]:; self.solver_code = 202; self.solver = 'taylor2.0'; if not len(self.sc_ops) == 1 or \; not self.sc_ops[0].const or \; not self.method == ""homodyne"":; raise ValueError(; ""Taylor2.0 only works with 1 constant sc_ops and for""; "" homodyne method""; ); else:; known = [; None, 'euler-maruyama', 'platen', 'pc-euler', 'pc-euler-imp',; 'milstein', 'milstein-imp', 'rouchon', 'taylor1.5',; 'taylor1.5-imp', 'explicit1.5', 'taylor2.0',; ]; raise ValueError(""The solver should be one of {!r}"".format(known)). class StochasticSolverOptionsPhoto(StochasticSolverOptions):; """"""; Attributes; ----------. solver : string; Name of the solver method to use for solving the evolution; of the system.*; order 1 algorithms: 'euler'; order 2 algorithms: 'pred-corr'; In photocurrent evolution; """"""; def set_solver(self):; if self.solver in [None, 'euler', 1, 60]:; self.solver_code = 60; self.solver = 'euler'; elif self.solver in ['pred-corr', 'predictor-corrector', 110, 2]:; self.solver_code = 110; self.solver = 'pred-corr'; else:; raise Exception(""The solver should be one of "" +; ""[None, 'euler', 'predictor-corrector']""). [docs]def smesolve(H, rho0, times, c_ops=[], sc_ops=[], e_ops=[],; _safe_mode=True, args={}, **kwargs):; """"""; Solve stochastic master equation. Dispatch to specific solvers; depending on the value of the `solver` keyword argument. Parameters; ----------. H : :class:`qutip.Qobj`, or time dependent system.; System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. rho0 : :class:`qutip.Qobj`; Initial density matrix or state vector (ket). times : *list* / *array*; List of times for :math:`t`. Must be uniformly spaced. c_ops : list of :class:`qutip.Qobj`, or time dependent Qobjs.; Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation.; Can depend on time, see StochasticSolverOptions help for format. sc_ops : list of :class:`qutip.Qobj`, or time",MatchSource.WIKI,docs/4.7/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/stochastic.html
https://qutip.org/docs/4.7/modules/qutip/stochastic.html:16838,Safety,predict,predictor-corrector,16838,"r2.0'; if not len(self.sc_ops) == 1 or \; not self.sc_ops[0].const or \; not self.method == ""homodyne"":; raise ValueError(; ""Taylor2.0 only works with 1 constant sc_ops and for""; "" homodyne method""; ); else:; known = [; None, 'euler-maruyama', 'platen', 'pc-euler', 'pc-euler-imp',; 'milstein', 'milstein-imp', 'rouchon', 'taylor1.5',; 'taylor1.5-imp', 'explicit1.5', 'taylor2.0',; ]; raise ValueError(""The solver should be one of {!r}"".format(known)). class StochasticSolverOptionsPhoto(StochasticSolverOptions):; """"""; Attributes; ----------. solver : string; Name of the solver method to use for solving the evolution; of the system.*; order 1 algorithms: 'euler'; order 2 algorithms: 'pred-corr'; In photocurrent evolution; """"""; def set_solver(self):; if self.solver in [None, 'euler', 1, 60]:; self.solver_code = 60; self.solver = 'euler'; elif self.solver in ['pred-corr', 'predictor-corrector', 110, 2]:; self.solver_code = 110; self.solver = 'pred-corr'; else:; raise Exception(""The solver should be one of "" +; ""[None, 'euler', 'predictor-corrector']""). [docs]def smesolve(H, rho0, times, c_ops=[], sc_ops=[], e_ops=[],; _safe_mode=True, args={}, **kwargs):; """"""; Solve stochastic master equation. Dispatch to specific solvers; depending on the value of the `solver` keyword argument. Parameters; ----------. H : :class:`qutip.Qobj`, or time dependent system.; System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. rho0 : :class:`qutip.Qobj`; Initial density matrix or state vector (ket). times : *list* / *array*; List of times for :math:`t`. Must be uniformly spaced. c_ops : list of :class:`qutip.Qobj`, or time dependent Qobjs.; Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation.; Can depend on time, see StochasticSolverOptions help for format. sc_ops : list of :class:`qutip.Qobj`, or time dependent Qobjs.; List of stochastic collapse operators. Each stochastic collapse; operator will give a determinist",MatchSource.WIKI,docs/4.7/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/stochastic.html
https://qutip.org/docs/4.7/modules/qutip/stochastic.html:1878,Testability,test,tested,1878,"e import main_ssepdpsolve, main_smepdpsolve. __all__ = ['ssesolve', 'photocurrent_sesolve', 'smepdpsolve',; 'smesolve', 'photocurrent_mesolve', 'ssepdpsolve',; 'stochastic_solvers', 'general_stochastic']. [docs]def stochastic_solvers():; # This docstring contains several literal backslash characters inside LaTeX; # blocks, but it cannot be declared as a raw string because we also need to; # use a line continuation. At one point we need a restructured text; # ""definition list"", where the heading _must_ be entirely on one line,; # however it will violate our line-length reporting if we do that.; """"""; This function is purely a reference point for documenting the available; stochastic solver methods, and takes no actions. Notes; -----; Available solvers for :obj:`~ssesolve` and :obj:`~smesolve`; euler-maruyama; A simple generalization of the Euler method for ordinary; differential equations to stochastic differential equations. Only; solver which could take non-commuting ``sc_ops``. *not tested*. - Order 0.5; - Code: ``'euler-maruyama'``, ``'euler'`` or ``0.5``. milstein; An order 1.0 strong Taylor scheme. Better approximate numerical; solution to stochastic differential equations. See eq. (2.9) of; chapter 12.2 of [1]_. - Order strong 1.0; - Code: ``'milstein'`` or ``1.0``. milstein-imp; An order 1.0 implicit strong Taylor scheme. Implicit Milstein; scheme for the numerical simulation of stiff stochastic; differential equations. - Order strong 1.0; - Code: ``'milstein-imp'``. predictor-corrector; Generalization of the trapezoidal method to stochastic differential; equations. More stable than explicit methods. See eq. (5.4) of; chapter 15.5 of [1]_. - Order strong 0.5, weak 1.0; - Codes to only correct the stochastic part (:math:`\\alpha=0`,; :math:`\\eta=1/2`): ``'pred-corr'``, ``'predictor-corrector'`` or; ``'pc-euler'``; - Codes to correct both the stochastic and deterministic parts; (:math:`\\alpha=1/2`, :math:`\\eta=1/2`): ``'pc-euler-imp'``,; ``'pc-euler-2'`` or `",MatchSource.WIKI,docs/4.7/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/stochastic.html
https://qutip.org/docs/4.7/modules/qutip/stochastic.html:1700,Usability,simpl,simple,1700,"ost, mat2vec, liouvillian; from qutip.solver import Options; from qutip.parallel import serial_map; from qutip.ui.progressbar import TextProgressBar; from qutip.pdpsolve import main_ssepdpsolve, main_smepdpsolve. __all__ = ['ssesolve', 'photocurrent_sesolve', 'smepdpsolve',; 'smesolve', 'photocurrent_mesolve', 'ssepdpsolve',; 'stochastic_solvers', 'general_stochastic']. [docs]def stochastic_solvers():; # This docstring contains several literal backslash characters inside LaTeX; # blocks, but it cannot be declared as a raw string because we also need to; # use a line continuation. At one point we need a restructured text; # ""definition list"", where the heading _must_ be entirely on one line,; # however it will violate our line-length reporting if we do that.; """"""; This function is purely a reference point for documenting the available; stochastic solver methods, and takes no actions. Notes; -----; Available solvers for :obj:`~ssesolve` and :obj:`~smesolve`; euler-maruyama; A simple generalization of the Euler method for ordinary; differential equations to stochastic differential equations. Only; solver which could take non-commuting ``sc_ops``. *not tested*. - Order 0.5; - Code: ``'euler-maruyama'``, ``'euler'`` or ``0.5``. milstein; An order 1.0 strong Taylor scheme. Better approximate numerical; solution to stochastic differential equations. See eq. (2.9) of; chapter 12.2 of [1]_. - Order strong 1.0; - Code: ``'milstein'`` or ``1.0``. milstein-imp; An order 1.0 implicit strong Taylor scheme. Implicit Milstein; scheme for the numerical simulation of stiff stochastic; differential equations. - Order strong 1.0; - Code: ``'milstein-imp'``. predictor-corrector; Generalization of the trapezoidal method to stochastic differential; equations. More stable than explicit methods. See eq. (5.4) of; chapter 15.5 of [1]_. - Order strong 0.5, weak 1.0; - Codes to only correct the stochastic part (:math:`\\alpha=0`,; :math:`\\eta=1/2`): ``'pred-corr'``, ``'predictor-corrector'`` ",MatchSource.WIKI,docs/4.7/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/stochastic.html
https://qutip.org/docs/4.7/modules/qutip/stochastic.html:3151,Usability,usab,usable,3151,"stein'`` or ``1.0``. milstein-imp; An order 1.0 implicit strong Taylor scheme. Implicit Milstein; scheme for the numerical simulation of stiff stochastic; differential equations. - Order strong 1.0; - Code: ``'milstein-imp'``. predictor-corrector; Generalization of the trapezoidal method to stochastic differential; equations. More stable than explicit methods. See eq. (5.4) of; chapter 15.5 of [1]_. - Order strong 0.5, weak 1.0; - Codes to only correct the stochastic part (:math:`\\alpha=0`,; :math:`\\eta=1/2`): ``'pred-corr'``, ``'predictor-corrector'`` or; ``'pc-euler'``; - Codes to correct both the stochastic and deterministic parts; (:math:`\\alpha=1/2`, :math:`\\eta=1/2`): ``'pc-euler-imp'``,; ``'pc-euler-2'`` or ``'pred-corr-2'``. platen; Explicit scheme, creates the Milstein using finite differences; instead of analytic derivatives. Also contains some higher order; terms, thus converges better than Milstein while staying strong; order 1.0. Does not require derivatives, therefore usable by; :func:`~general_stochastic`. See eq. (7.47) of chapter 7 of [2]_. - Order strong 1.0, weak 2.0; - Code: ``'platen'``, ``'platen1'`` or ``'explicit1'``. rouchon; Scheme keeping the positivity of the density matrix; (:obj:`~smesolve` only). See eq. (4) with :math:`\\eta=1` of [3]_. - Order strong 1.0?; - Code: ``'rouchon'`` or ``'Rouchon'``. taylor1.5; Order 1.5 strong Taylor scheme. Solver with more terms of the; Ito-Taylor expansion. Default solver for :obj:`~smesolve` and; :obj:`~ssesolve`. See eq. (4.6) of chapter 10.4 of [1]_. - Order strong 1.5; - Code: ``'taylor1.5'``, ``'taylor15'``, ``1.5``, or ``None``. taylor1.5-imp; Order 1.5 implicit strong Taylor scheme. Implicit Taylor 1.5; (:math:`\\alpha = 1/2`, :math:`\\beta` doesn't matter). See eq.; (2.18) of chapter 12.2 of [1]_. - Order strong 1.5; - Code: ``'taylor1.5-imp'`` or ``'taylor15-imp'``. explicit1.5; Explicit order 1.5 strong schemes. Reproduce the order 1.5 strong; Taylor scheme using finite difference instea",MatchSource.WIKI,docs/4.7/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/stochastic.html
https://qutip.org/docs/4.7/modules/qutip/stochastic.html:4198,Usability,usab,usable,4198,"47) of chapter 7 of [2]_. - Order strong 1.0, weak 2.0; - Code: ``'platen'``, ``'platen1'`` or ``'explicit1'``. rouchon; Scheme keeping the positivity of the density matrix; (:obj:`~smesolve` only). See eq. (4) with :math:`\\eta=1` of [3]_. - Order strong 1.0?; - Code: ``'rouchon'`` or ``'Rouchon'``. taylor1.5; Order 1.5 strong Taylor scheme. Solver with more terms of the; Ito-Taylor expansion. Default solver for :obj:`~smesolve` and; :obj:`~ssesolve`. See eq. (4.6) of chapter 10.4 of [1]_. - Order strong 1.5; - Code: ``'taylor1.5'``, ``'taylor15'``, ``1.5``, or ``None``. taylor1.5-imp; Order 1.5 implicit strong Taylor scheme. Implicit Taylor 1.5; (:math:`\\alpha = 1/2`, :math:`\\beta` doesn't matter). See eq.; (2.18) of chapter 12.2 of [1]_. - Order strong 1.5; - Code: ``'taylor1.5-imp'`` or ``'taylor15-imp'``. explicit1.5; Explicit order 1.5 strong schemes. Reproduce the order 1.5 strong; Taylor scheme using finite difference instead of derivatives.; Slower than ``taylor15`` but usable by; :func:`~general_stochastic`. See eq. (2.13) of chapter 11.2 of; [1]_. - Order strong 1.5; - Code: ``'explicit1.5'``, ``'explicit15'`` or ``'platen15'``. taylor2.0; Order 2 strong Taylor scheme. Solver with more terms of the; Stratonovich expansion. See eq. (5.2) of chapter 10.5 of [1]_. - Order strong 2.0; - Code: ``'taylor2.0'``, ``'taylor20'`` or ``2.0``. All solvers, except taylor2.0, are usable in both smesolve and ssesolve; and for both heterodyne and homodyne. taylor2.0 only works for 1; stochastic operator independent of time with the homodyne method.; :func:`~general_stochastic` only accepts the derivative-free; solvers: ``'euler'``, ``'platen'`` and ``'explicit1.5'``. Available solvers for :obj:`~photocurrent_sesolve` and \; :obj:`~photocurrent_mesolve`; Photocurrent use ordinary differential equations between; stochastic ""jump/collapse"". euler; Euler method for ordinary differential equations between jumps.; Only one jump per time interval. Default solver. See eqs. (4.",MatchSource.WIKI,docs/4.7/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/stochastic.html
https://qutip.org/docs/4.7/modules/qutip/stochastic.html:4604,Usability,usab,usable,4604,"d; :obj:`~ssesolve`. See eq. (4.6) of chapter 10.4 of [1]_. - Order strong 1.5; - Code: ``'taylor1.5'``, ``'taylor15'``, ``1.5``, or ``None``. taylor1.5-imp; Order 1.5 implicit strong Taylor scheme. Implicit Taylor 1.5; (:math:`\\alpha = 1/2`, :math:`\\beta` doesn't matter). See eq.; (2.18) of chapter 12.2 of [1]_. - Order strong 1.5; - Code: ``'taylor1.5-imp'`` or ``'taylor15-imp'``. explicit1.5; Explicit order 1.5 strong schemes. Reproduce the order 1.5 strong; Taylor scheme using finite difference instead of derivatives.; Slower than ``taylor15`` but usable by; :func:`~general_stochastic`. See eq. (2.13) of chapter 11.2 of; [1]_. - Order strong 1.5; - Code: ``'explicit1.5'``, ``'explicit15'`` or ``'platen15'``. taylor2.0; Order 2 strong Taylor scheme. Solver with more terms of the; Stratonovich expansion. See eq. (5.2) of chapter 10.5 of [1]_. - Order strong 2.0; - Code: ``'taylor2.0'``, ``'taylor20'`` or ``2.0``. All solvers, except taylor2.0, are usable in both smesolve and ssesolve; and for both heterodyne and homodyne. taylor2.0 only works for 1; stochastic operator independent of time with the homodyne method.; :func:`~general_stochastic` only accepts the derivative-free; solvers: ``'euler'``, ``'platen'`` and ``'explicit1.5'``. Available solvers for :obj:`~photocurrent_sesolve` and \; :obj:`~photocurrent_mesolve`; Photocurrent use ordinary differential equations between; stochastic ""jump/collapse"". euler; Euler method for ordinary differential equations between jumps.; Only one jump per time interval. Default solver. See eqs. (4.19); and (4.4) of chapter 4 of [4]_. - Order 1.0; - Code: ``'euler'``. predictor–corrector; predictor–corrector method (PECE) for ordinary differential; equations. Uses the Poisson distribution to obtain the number of; jumps at each timestep. - Order 2.0; - Code: ``'pred-corr'``. References; ----------; .. [1] Peter E. Kloeden and Exkhard Platen, *Numerical Solution of; Stochastic Differential Equations*.; .. [2] H.-P. Breuer and F.",MatchSource.WIKI,docs/4.7/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/stochastic.html
https://qutip.org/docs/4.7/modules/qutip/stochastic.html:10586,Usability,progress bar,progress bar,10586,"array of int, or 4D array of float; - int : seed of the noise; - 1D array : length = ntraj, seeds for each trajectories.; - 4D array : ``(ntraj, len(times), nsubsteps, len(sc_ops)*[1|2])``.; Vector for the noise, the len of the last dimensions is doubled for; solvers of order 1.5. This corresponds to results.noise. noiseDepth : int; Number of terms kept of the truncated series used to create the; noise used by taylor2.0 solver. normalize : bool; (default True for (photo)ssesolve, False for (photo)smesolve); Whether or not to normalize the wave function during the evolution.; Normalizing density matrices introduce numerical errors. options : :class:`qutip.solver.Options`; Generic solver options. Only options.average_states and; options.store_states are used. map_func: function; A map function or managing the calls to single-trajactory solvers. map_kwargs: dictionary; Optional keyword arguments to the map_func function function. progress_bar : :class:`qutip.ui.BaseProgressBar`; Optional progress bar class instance.; """"""; def __init__(self, me, H=None, c_ops=[], sc_ops=[], state0=None,; e_ops=[], m_ops=None, store_all_expect=False,; store_measurement=False, dW_factors=None,; solver=None, method=""homodyne"", normalize=None,; times=None, nsubsteps=1, ntraj=1, tol=None,; generate_noise=None, noise=None,; progress_bar=None, map_func=None, map_kwargs=None,; args={}, options=None, noiseDepth=20):. if options is None:; options = Options(). if progress_bar is None:; progress_bar = TextProgressBar(). # System; # Cast to QobjEvo so the code has only one version for both the; # constant and time-dependent case.; self.me = me. if H is not None:; msg = ""The Hamiltonian format is not valid. ""; try:; self.H = QobjEvo(H, args=args, tlist=times,; e_ops=e_ops, state0=state0); except Exception as e:; raise ValueError(msg + str(e)) from e; else:; self.H = H. if sc_ops:; msg = (""The sc_ops format is not valid. Options are ""; ""[ Qobj / QobjEvo / [Qobj, coeff]]. ""); try:; self.sc_ops = [QobjEv",MatchSource.WIKI,docs/4.7/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/stochastic.html
https://qutip.org/docs/4.7/modules/qutip/superoperator.html:9879,Deployability,update,updated,9879," is not a quantum object'). if not A.isoper:; raise TypeError('Input is not a quantum operator'). S = Qobj(isherm=A.isherm, superrep='super'); S.dims = [[A.dims[0], A.dims[1]], [A.dims[0], A.dims[1]]]; S.data = zcsr_kron(A.data.T,; fast_identity(np.prod(A.shape[0]))); return S. [docs]def spre(A):; """"""Superoperator formed from pre-multiplication by operator A. Parameters; ----------; A : Qobj or QobjEvo; Quantum operator for pre-multiplication. Returns; --------; super :Qobj or QobjEvo; Superoperator formed from input quantum object.; """"""; if isinstance(A, QobjEvo):; return A.apply(spre). if not isinstance(A, Qobj):; raise TypeError('Input is not a quantum object'). if not A.isoper:; raise TypeError('Input is not a quantum operator'). S = Qobj(isherm=A.isherm, superrep='super'); S.dims = [[A.dims[0], A.dims[1]], [A.dims[0], A.dims[1]]]; S.data = zcsr_kron(fast_identity(np.prod(A.shape[1])), A.data); return S. def _drop_projected_dims(dims):; """"""; Eliminate subsystems that has been collapsed to only one state due to; a projection.; """"""; return [d for d in dims if d != 1]. [docs]def sprepost(A, B):; """"""Superoperator formed from pre-multiplication by operator A and post-; multiplication of operator B. Parameters; ----------; A : Qobj or QobjEvo; Quantum operator for pre-multiplication. B : Qobj or QobjEvo; Quantum operator for post-multiplication. Returns; --------; super : Qobj or QobjEvo; Superoperator formed from input quantum objects.; """"""; if isinstance(A, QobjEvo) or isinstance(B, QobjEvo):; return spre(A) * spost(B). else:; dims = [[_drop_projected_dims(A.dims[0]),; _drop_projected_dims(B.dims[1])],; [_drop_projected_dims(A.dims[1]),; _drop_projected_dims(B.dims[0])]]; data = zcsr_kron(B.data.T, A.data); return Qobj(data, dims=dims, superrep='super'). from qutip.qobjevo import QobjEvo. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/modules/qutip/superoperator.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/superoperator.html
https://qutip.org/docs/4.7/modules/qutip/superoperator.html:1038,Safety,avoid,avoids,1038,"n. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.superoperator. Source code for qutip.superoperator; __all__ = ['liouvillian', 'liouvillian_ref', 'lindblad_dissipator',; 'operator_to_vector', 'vector_to_operator', 'mat2vec', 'vec2mat',; 'vec2mat_index', 'mat2vec_index', 'spost', 'spre', 'sprepost']. import scipy.sparse as sp; import numpy as np; from qutip.qobj import Qobj; from qutip.fastsparse import fast_csr_matrix, fast_identity; from qutip.sparse import sp_reshape; from qutip.cy.spmath import zcsr_kron; from functools import partial. [docs]def liouvillian(H, c_ops=[], data_only=False, chi=None):; """"""Assembles the Liouvillian superoperator from a Hamiltonian; and a ``list`` of collapse operators. Like liouvillian, but with an; experimental implementation which avoids creating extra Qobj instances,; which can be advantageous for large systems. Parameters; ----------; H : Qobj or QobjEvo; System Hamiltonian. c_ops : array_like of Qobj or QobjEvo; A ``list`` or ``array`` of collapse operators. Returns; -------; L : Qobj or QobjEvo; Liouvillian superoperator. """"""; if isinstance(c_ops, (Qobj, QobjEvo)):; c_ops = [c_ops]; if chi and len(chi) != len(c_ops):; raise ValueError('chi must be a list with same length as c_ops'). h = None; if H is not None:; if isinstance(H, QobjEvo):; h = H.cte; else:; h = H; if h.isoper:; op_dims = h.dims; op_shape = h.shape; elif h.issuper:; op_dims = h.dims[0]; op_shape = [np.prod(op_dims[0]), np.prod(op_dims[0])]; else:; raise TypeError(""Invalid type for Hamiltonian.""); else:; # no hamiltonian given, pick system size from a collapse operator; if isinstance(c_ops, list) and len(c_ops) > 0:; if isinstance(c_ops[0], QobjEvo):; c = c_ops[0].cte; else:; c = c_ops[0]; if c.isoper:; op_dims = c.dims; op_shape = c.shape; elif c.issup",MatchSource.WIKI,docs/4.7/modules/qutip/superoperator.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/superoperator.html
https://qutip.org/docs/4.7/modules/qutip/superop_reps.html:9938,Availability,down,down,9938,"other subsystem dimensions.; """"""; nq = _nq(q_oper.dims); B = _pauli_basis(nq); # Force the basis change to match the dimensions of; # the input.; B.dims = q_oper.dims. # We normally should not multiply objects of different; # superreps, so Qobj warns about that. Here, however, we're actively; # converting between, so the superrep of B is irrelevant.; # To suppress warnings, we pretend that B is also a chi.; B.superrep = 'chi'. # The Chi matrix has tr(chi) == d², so we need to divide out; # by that to get back to the Choi form.; return Qobj((B * q_oper * B.dag()) / q_oper.shape[0], superrep='choi'). def _svd_u_to_kraus(U, S, d, dK, indims, outdims):; """"""; Given a partial isometry U and a vector of square-roots of singular values S; obtained from an SVD, produces the Kraus operators represented by U. Returns; -------; Ks : list of Qobj; Quantum objects represnting each of the Kraus operators.; """"""; # We use U * S since S is 1-index, such that this is equivalent to; # U . diag(S), but easier to write down.; Ks = list(map(Qobj, array(U * S).reshape((d, d, dK), order='F').transpose((2, 0, 1)))); for K in Ks:; K.dims = [outdims, indims]; return Ks. def _generalized_kraus(q_oper, thresh=1e-10):; # TODO: document!; # TODO: use this to generalize to_kraus to the case where U != V.; # This is critical for non-CP maps, as appear in (for example); # diamond norm differences between two CP maps.; if q_oper.type != ""super"" or q_oper.superrep != ""choi"":; raise ValueError(""Expected a Choi matrix, got a {} (superrep {})."".format(q_oper.type, q_oper.superrep)). # Remember the shape of the underlying space,; # as we'll need this to make Kraus operators later.; dL, dR = map(int, map(sqrt, q_oper.shape)); # Also remember the dims breakout.; out_dims, in_dims = q_oper.dims; out_left, out_right = out_dims; in_left, in_right = in_dims. # Find the SVD.; U, S, V = svd(q_oper.full()). # Truncate away the zero singular values, up to a threshold.; nonzero_idxs = S > thresh; dK = nonzero_idxs.sum",MatchSource.WIKI,docs/4.7/modules/qutip/superop_reps.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/superop_reps.html
https://qutip.org/docs/4.7/modules/qutip/superop_reps.html:17666,Availability,error,errors,17666,"per, tol=1e-9):; """"""; Converts a Qobj representing a quantum map to a list of quantum objects,; each representing an operator in the Kraus decomposition of the given map. Parameters; ----------; q_oper : Qobj; Superoperator to be converted to Kraus representation. If; ``q_oper`` is ``type=""oper""``, then it is taken to act by conjugation,; such that ``to_kraus(A) == to_kraus(sprepost(A, A.dag())) == [A]``. tol : Float; Optional threshold parameter for eigenvalues/Kraus ops to be discarded.; The default is to=1e-9. Returns; -------; kraus_ops : list of Qobj; A list of quantum objects, each representing a Kraus operator in the; decomposition of ``q_oper``. Raises; ------; TypeError: if the given quantum object is not a map, or cannot be; decomposed into Kraus operators.; """"""; if q_oper.type == 'super':; if q_oper.superrep in (""super"", ""chi""):; return to_kraus(to_choi(q_oper), tol); elif q_oper.superrep == 'choi':; return choi_to_kraus(q_oper, tol); elif q_oper.type == 'oper': # Assume unitary; return [q_oper]; else:; raise TypeError(; ""Conversion of Qobj with type = {0.type} ""; ""and superrep = {0.superrep} to Kraus decomposition not ""; ""supported."".format(q_oper); ). [docs]def to_stinespring(q_oper):; r""""""; Converts a Qobj representing a quantum map $\Lambda$ to a pair of partial isometries; $A$ and $B$ such that $\Lambda(X) = \Tr_2(A X B^\dagger)$ for all inputs $X$, where; the partial trace is taken over a a new index on the output dimensions of $A$ and $B$. For completely positive inputs, $A$ will always equal $B$ up to precision errors. Parameters; ----------; q_oper : Qobj; Superoperator to be converted to a Stinespring pair. Returns; -------; A, B : Qobj; Quantum objects representing each of the Stinespring matrices for the input Qobj.; """"""; return choi_to_stinespring(to_choi(q_oper)). © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/modules/qutip/superop_reps.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/superop_reps.html
https://qutip.org/docs/4.7/modules/qutip/superop_reps.html:18009,Deployability,update,updated,18009,"per, tol=1e-9):; """"""; Converts a Qobj representing a quantum map to a list of quantum objects,; each representing an operator in the Kraus decomposition of the given map. Parameters; ----------; q_oper : Qobj; Superoperator to be converted to Kraus representation. If; ``q_oper`` is ``type=""oper""``, then it is taken to act by conjugation,; such that ``to_kraus(A) == to_kraus(sprepost(A, A.dag())) == [A]``. tol : Float; Optional threshold parameter for eigenvalues/Kraus ops to be discarded.; The default is to=1e-9. Returns; -------; kraus_ops : list of Qobj; A list of quantum objects, each representing a Kraus operator in the; decomposition of ``q_oper``. Raises; ------; TypeError: if the given quantum object is not a map, or cannot be; decomposed into Kraus operators.; """"""; if q_oper.type == 'super':; if q_oper.superrep in (""super"", ""chi""):; return to_kraus(to_choi(q_oper), tol); elif q_oper.superrep == 'choi':; return choi_to_kraus(q_oper, tol); elif q_oper.type == 'oper': # Assume unitary; return [q_oper]; else:; raise TypeError(; ""Conversion of Qobj with type = {0.type} ""; ""and superrep = {0.superrep} to Kraus decomposition not ""; ""supported."".format(q_oper); ). [docs]def to_stinespring(q_oper):; r""""""; Converts a Qobj representing a quantum map $\Lambda$ to a pair of partial isometries; $A$ and $B$ such that $\Lambda(X) = \Tr_2(A X B^\dagger)$ for all inputs $X$, where; the partial trace is taken over a a new index on the output dimensions of $A$ and $B$. For completely positive inputs, $A$ will always equal $B$ up to precision errors. Parameters; ----------; q_oper : Qobj; Superoperator to be converted to a Stinespring pair. Returns; -------; A, B : Qobj; Quantum objects representing each of the Stinespring matrices for the input Qobj.; """"""; return choi_to_stinespring(to_choi(q_oper)). © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/modules/qutip/superop_reps.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/superop_reps.html
https://qutip.org/docs/4.7/modules/qutip/superop_reps.html:4296,Energy Efficiency,power,powers,4296,"main work of converting between representations,; # and are exposed below by other functions that add postconditions about types.; #; # TODO: handle type='kraus' as a three-index Qobj, rather than as a list?. def _super_tofrom_choi(q_oper):; """"""; We exploit that the basis transformation between Choi and supermatrix; representations squares to the identity, so that if we munge Qobj.type,; we can use the same function. Since this function doesn't respect :attr:`Qobj.type`, we mark it as; private; only those functions which wrap this in a way so as to preserve; type should be called externally.; """"""; data = q_oper.data.toarray(); dims = q_oper.dims; new_dims = [[dims[1][1], dims[0][1]], [dims[1][0], dims[0][0]]]; d0 = np.prod(np.ravel(new_dims[0])); d1 = np.prod(np.ravel(new_dims[1])); s0 = np.prod(dims[0][0]); s1 = np.prod(dims[1][1]); return Qobj(dims=new_dims,; inpt=data.reshape([s0, s1, s0, s1]).; transpose(3, 1, 2, 0).reshape((d0, d1))). def _isqubitdims(dims):; """"""Checks whether all entries in a dims list are integer powers of 2. Parameters; ----------; dims : nested list of ints; Dimensions to be checked. Returns; -------; isqubitdims : bool; True if and only if every member of the flattened dims; list is an integer power of 2.; """"""; return all([; 2**floor(log2(dim)) == dim; for dim in flatten(dims); ]). def _super_to_superpauli(q_oper):; """"""; Converts a superoperator in the column-stacking basis to; the Pauli basis (assuming qubit dimensions). This is an internal function, as QuTiP does not currently have; a way to mark that superoperators are represented in the Pauli; basis as opposed to the column-stacking basis; a Pauli-basis; ``type='super'`` would thus break other conversion functions.; """"""; # Ensure we start with a column-stacking-basis superoperator.; sqobj = to_super(q_oper); if not _isqubitdims(sqobj.dims):; raise ValueError(""Pauli basis is only defined for qubits.""); nq = int(log2(sqobj.shape[0]) / 2); B = _pauli_basis(nq) / sqrt(2**nq); # To do this, ",MatchSource.WIKI,docs/4.7/modules/qutip/superop_reps.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/superop_reps.html
https://qutip.org/docs/4.7/modules/qutip/superop_reps.html:4500,Energy Efficiency,power,power,4500,"her than as a list?. def _super_tofrom_choi(q_oper):; """"""; We exploit that the basis transformation between Choi and supermatrix; representations squares to the identity, so that if we munge Qobj.type,; we can use the same function. Since this function doesn't respect :attr:`Qobj.type`, we mark it as; private; only those functions which wrap this in a way so as to preserve; type should be called externally.; """"""; data = q_oper.data.toarray(); dims = q_oper.dims; new_dims = [[dims[1][1], dims[0][1]], [dims[1][0], dims[0][0]]]; d0 = np.prod(np.ravel(new_dims[0])); d1 = np.prod(np.ravel(new_dims[1])); s0 = np.prod(dims[0][0]); s1 = np.prod(dims[1][1]); return Qobj(dims=new_dims,; inpt=data.reshape([s0, s1, s0, s1]).; transpose(3, 1, 2, 0).reshape((d0, d1))). def _isqubitdims(dims):; """"""Checks whether all entries in a dims list are integer powers of 2. Parameters; ----------; dims : nested list of ints; Dimensions to be checked. Returns; -------; isqubitdims : bool; True if and only if every member of the flattened dims; list is an integer power of 2.; """"""; return all([; 2**floor(log2(dim)) == dim; for dim in flatten(dims); ]). def _super_to_superpauli(q_oper):; """"""; Converts a superoperator in the column-stacking basis to; the Pauli basis (assuming qubit dimensions). This is an internal function, as QuTiP does not currently have; a way to mark that superoperators are represented in the Pauli; basis as opposed to the column-stacking basis; a Pauli-basis; ``type='super'`` would thus break other conversion functions.; """"""; # Ensure we start with a column-stacking-basis superoperator.; sqobj = to_super(q_oper); if not _isqubitdims(sqobj.dims):; raise ValueError(""Pauli basis is only defined for qubits.""); nq = int(log2(sqobj.shape[0]) / 2); B = _pauli_basis(nq) / sqrt(2**nq); # To do this, we have to hack a bit and force the dims to match,; # since the _pauli_basis function makes different assumptions; # about indices than we need here.; B.dims = sqobj.dims; return (B.dag() ",MatchSource.WIKI,docs/4.7/modules/qutip/superop_reps.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/superop_reps.html
https://qutip.org/docs/4.7/modules/qutip/superop_reps.html:8294,Energy Efficiency,power,power,8294,"``, such that; ``choi.superrep == ""choi""``.; """"""; len_op = np.prod(kraus_ops[0].shape); # If Kraus ops have dims [M, N] in qutip notation (act on [N, N] density matrix and produce [M, M] d.m.),; # Choi matrix Hilbert space will be [[M, N], [M, N]] because Choi Hilbert space is (output space) x (input space).; choi_dims = [kraus_ops[0].dims] * 2; # transform a list of Qobj matrices list[sum_ij k_ij |i><j|]; # into an array of array vectors sum_ij k_ij |i, j>> = sum_I k_I |I>>; kraus_vectors = np.asarray(; [np.reshape(kraus_op.full(), len_op, ""F"") for kraus_op in kraus_ops]; ); # sum_{I} |k_I|^2 |I>><<I|; choi_array = np.tensordot(kraus_vectors, kraus_vectors.conj(), axes=([0], [0])); return Qobj(choi_array, choi_dims, superrep=""choi"", copy=False). [docs]def kraus_to_super(kraus_list):; """"""; Converts a list of Kraus operators and returns a super operator.; """"""; return choi_to_super(kraus_to_choi(kraus_list)). def _nq(dims):; dim = np.prod(dims[0][0]); nq = int(log2(dim)); if 2 ** nq != dim:; raise ValueError(""{} is not an integer power of 2."".format(dim)); return nq. [docs]def choi_to_chi(q_oper):; """"""; Converts a Choi matrix to a Chi matrix in the Pauli basis. NOTE: this is only supported for qubits right now. Need to extend to; Heisenberg-Weyl for other subsystem dimensions.; """"""; nq = _nq(q_oper.dims); B = _pauli_basis(nq); # Force the basis change to match the dimensions of; # the input.; B.dims = q_oper.dims; B.superrep = 'choi'. return Qobj(B.dag() * q_oper * B, superrep='chi'). [docs]def chi_to_choi(q_oper):; """"""; Converts a Chi matrix to a Choi matrix. NOTE: this is only supported for qubits right now. Need to extend to; Heisenberg-Weyl for other subsystem dimensions.; """"""; nq = _nq(q_oper.dims); B = _pauli_basis(nq); # Force the basis change to match the dimensions of; # the input.; B.dims = q_oper.dims. # We normally should not multiply objects of different; # superreps, so Qobj warns about that. Here, however, we're actively; # converting between, so the sup",MatchSource.WIKI,docs/4.7/modules/qutip/superop_reps.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/superop_reps.html
https://qutip.org/docs/4.7/modules/qutip/superop_reps.html:3787,Integrability,wrap,wrap,3787,"s slow as can be.; # TODO: Make this sparse. CSR format was causing problems for the [idx, :]; # slicing below.; B = zeros((4 ** nq, 4 ** nq), dtype=complex); dims = [[[2] * nq] * 2] * 2. for idx, op in enumerate(starmap(tensor,; product(_SINGLE_QUBIT_PAULI_BASIS,; repeat=nq))):; B[:, idx] = operator_to_vector(op).dag().full(). return Qobj(B, dims=dims). # PRIVATE CONVERSION FUNCTIONS ------------------------------------------------; # These functions handle the main work of converting between representations,; # and are exposed below by other functions that add postconditions about types.; #; # TODO: handle type='kraus' as a three-index Qobj, rather than as a list?. def _super_tofrom_choi(q_oper):; """"""; We exploit that the basis transformation between Choi and supermatrix; representations squares to the identity, so that if we munge Qobj.type,; we can use the same function. Since this function doesn't respect :attr:`Qobj.type`, we mark it as; private; only those functions which wrap this in a way so as to preserve; type should be called externally.; """"""; data = q_oper.data.toarray(); dims = q_oper.dims; new_dims = [[dims[1][1], dims[0][1]], [dims[1][0], dims[0][0]]]; d0 = np.prod(np.ravel(new_dims[0])); d1 = np.prod(np.ravel(new_dims[1])); s0 = np.prod(dims[0][0]); s1 = np.prod(dims[1][1]); return Qobj(dims=new_dims,; inpt=data.reshape([s0, s1, s0, s1]).; transpose(3, 1, 2, 0).reshape((d0, d1))). def _isqubitdims(dims):; """"""Checks whether all entries in a dims list are integer powers of 2. Parameters; ----------; dims : nested list of ints; Dimensions to be checked. Returns; -------; isqubitdims : bool; True if and only if every member of the flattened dims; list is an integer power of 2.; """"""; return all([; 2**floor(log2(dim)) == dim; for dim in flatten(dims); ]). def _super_to_superpauli(q_oper):; """"""; Converts a superoperator in the column-stacking basis to; the Pauli basis (assuming qubit dimensions). This is an internal function, as QuTiP does not currently hav",MatchSource.WIKI,docs/4.7/modules/qutip/superop_reps.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/superop_reps.html
https://qutip.org/docs/4.7/modules/qutip/superop_reps.html:8487,Modifiability,extend,extend,8487,"Hilbert space is (output space) x (input space).; choi_dims = [kraus_ops[0].dims] * 2; # transform a list of Qobj matrices list[sum_ij k_ij |i><j|]; # into an array of array vectors sum_ij k_ij |i, j>> = sum_I k_I |I>>; kraus_vectors = np.asarray(; [np.reshape(kraus_op.full(), len_op, ""F"") for kraus_op in kraus_ops]; ); # sum_{I} |k_I|^2 |I>><<I|; choi_array = np.tensordot(kraus_vectors, kraus_vectors.conj(), axes=([0], [0])); return Qobj(choi_array, choi_dims, superrep=""choi"", copy=False). [docs]def kraus_to_super(kraus_list):; """"""; Converts a list of Kraus operators and returns a super operator.; """"""; return choi_to_super(kraus_to_choi(kraus_list)). def _nq(dims):; dim = np.prod(dims[0][0]); nq = int(log2(dim)); if 2 ** nq != dim:; raise ValueError(""{} is not an integer power of 2."".format(dim)); return nq. [docs]def choi_to_chi(q_oper):; """"""; Converts a Choi matrix to a Chi matrix in the Pauli basis. NOTE: this is only supported for qubits right now. Need to extend to; Heisenberg-Weyl for other subsystem dimensions.; """"""; nq = _nq(q_oper.dims); B = _pauli_basis(nq); # Force the basis change to match the dimensions of; # the input.; B.dims = q_oper.dims; B.superrep = 'choi'. return Qobj(B.dag() * q_oper * B, superrep='chi'). [docs]def chi_to_choi(q_oper):; """"""; Converts a Chi matrix to a Choi matrix. NOTE: this is only supported for qubits right now. Need to extend to; Heisenberg-Weyl for other subsystem dimensions.; """"""; nq = _nq(q_oper.dims); B = _pauli_basis(nq); # Force the basis change to match the dimensions of; # the input.; B.dims = q_oper.dims. # We normally should not multiply objects of different; # superreps, so Qobj warns about that. Here, however, we're actively; # converting between, so the superrep of B is irrelevant.; # To suppress warnings, we pretend that B is also a chi.; B.superrep = 'chi'. # The Chi matrix has tr(chi) == d², so we need to divide out; # by that to get back to the Choi form.; return Qobj((B * q_oper * B.dag()) / q_oper.shape[0],",MatchSource.WIKI,docs/4.7/modules/qutip/superop_reps.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/superop_reps.html
https://qutip.org/docs/4.7/modules/qutip/superop_reps.html:8894,Modifiability,extend,extend,8894,"nj(), axes=([0], [0])); return Qobj(choi_array, choi_dims, superrep=""choi"", copy=False). [docs]def kraus_to_super(kraus_list):; """"""; Converts a list of Kraus operators and returns a super operator.; """"""; return choi_to_super(kraus_to_choi(kraus_list)). def _nq(dims):; dim = np.prod(dims[0][0]); nq = int(log2(dim)); if 2 ** nq != dim:; raise ValueError(""{} is not an integer power of 2."".format(dim)); return nq. [docs]def choi_to_chi(q_oper):; """"""; Converts a Choi matrix to a Chi matrix in the Pauli basis. NOTE: this is only supported for qubits right now. Need to extend to; Heisenberg-Weyl for other subsystem dimensions.; """"""; nq = _nq(q_oper.dims); B = _pauli_basis(nq); # Force the basis change to match the dimensions of; # the input.; B.dims = q_oper.dims; B.superrep = 'choi'. return Qobj(B.dag() * q_oper * B, superrep='chi'). [docs]def chi_to_choi(q_oper):; """"""; Converts a Chi matrix to a Choi matrix. NOTE: this is only supported for qubits right now. Need to extend to; Heisenberg-Weyl for other subsystem dimensions.; """"""; nq = _nq(q_oper.dims); B = _pauli_basis(nq); # Force the basis change to match the dimensions of; # the input.; B.dims = q_oper.dims. # We normally should not multiply objects of different; # superreps, so Qobj warns about that. Here, however, we're actively; # converting between, so the superrep of B is irrelevant.; # To suppress warnings, we pretend that B is also a chi.; B.superrep = 'chi'. # The Chi matrix has tr(chi) == d², so we need to divide out; # by that to get back to the Choi form.; return Qobj((B * q_oper * B.dag()) / q_oper.shape[0], superrep='choi'). def _svd_u_to_kraus(U, S, d, dK, indims, outdims):; """"""; Given a partial isometry U and a vector of square-roots of singular values S; obtained from an SVD, produces the Kraus operators represented by U. Returns; -------; Ks : list of Qobj; Quantum objects represnting each of the Kraus operators.; """"""; # We use U * S since S is 1-index, such that this is equivalent to; # U . diag(S), b",MatchSource.WIKI,docs/4.7/modules/qutip/superop_reps.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/superop_reps.html
https://qutip.org/docs/4.7/modules/qutip/superop_reps.html:1130,Safety,avoid,avoid,1130," Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.superop_reps. Source code for qutip.superop_reps; # -*- coding: utf-8 -*-; #; # This module was initially contributed by Ben Criger.; #; """"""; This module implements transformations between superoperator representations,; including supermatrix, Kraus, Choi and Chi (process) matrix formalisms.; """""". __all__ = ['super_to_choi', 'choi_to_super', 'choi_to_kraus', 'kraus_to_choi',; 'kraus_to_super', 'choi_to_chi', 'chi_to_choi', 'to_choi',; 'to_chi', 'to_super', 'to_kraus', 'to_stinespring'; ]. # Python Standard Library; from itertools import starmap, product. # NumPy/SciPy; from numpy.core.multiarray import array, zeros; from numpy.core.shape_base import hstack; from numpy.matrixlib.defmatrix import matrix; from numpy import sqrt, floor, log2; from numpy import dot; from scipy.linalg import eig, svd; # Needed to avoid conflict with itertools.product.; import numpy as np. # Other QuTiP functions and classes; from qutip.superoperator import vec2mat, operator_to_vector, sprepost; from qutip.operators import identity, sigmax, sigmay, sigmaz; from qutip.tensor import tensor, flatten; from qutip.qobj import Qobj; from qutip.states import basis. # SPECIFIC SUPEROPERATORS -----------------------------------------------------. def _dep_super(pe):; """"""; Returns the superoperator corresponding to qubit depolarization for a; given parameter pe. TODO: if this is going into production (hopefully it isn't) then check; CPTP, expand to arbitrary dimensional systems, etc.; """"""; return Qobj(dims=[[[2], [2]], [[2], [2]]],; inpt=array([[1. - pe / 2., 0., 0., pe / 2.],; [0., 1. - pe, 0., 0.],; [0., 0., 1. - pe, 0.],; [pe / 2., 0., 0., 1. - pe / 2.]])). def _dep_choi(pe):; """"""; Returns the choi matrix corresponding to qubit depolarization for a; given parameter pe. TODO: if this is going into production (hopefull",MatchSource.WIKI,docs/4.7/modules/qutip/superop_reps.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/superop_reps.html
https://qutip.org/docs/4.7/modules/qutip/superop_reps.html:3320,Security,expose,exposed,3320,"- pe / 2., 0., 0., 1. - pe],; [0., pe / 2., 0., 0.],; [0., 0., pe / 2., 0.],; [1. - pe, 0., 0., 1. - pe / 2.]]),; superrep='choi'). # CHANGE OF BASIS FUNCTIONS ---------------------------------------------------; # These functions find change of basis matrices, and are useful in converting; # between (for instance) Choi and chi matrices. At some point, these should; # probably be moved out to another module. _SINGLE_QUBIT_PAULI_BASIS = (identity(2), sigmax(), sigmay(), sigmaz()). def _pauli_basis(nq=1):; # NOTE: This is slow as can be.; # TODO: Make this sparse. CSR format was causing problems for the [idx, :]; # slicing below.; B = zeros((4 ** nq, 4 ** nq), dtype=complex); dims = [[[2] * nq] * 2] * 2. for idx, op in enumerate(starmap(tensor,; product(_SINGLE_QUBIT_PAULI_BASIS,; repeat=nq))):; B[:, idx] = operator_to_vector(op).dag().full(). return Qobj(B, dims=dims). # PRIVATE CONVERSION FUNCTIONS ------------------------------------------------; # These functions handle the main work of converting between representations,; # and are exposed below by other functions that add postconditions about types.; #; # TODO: handle type='kraus' as a three-index Qobj, rather than as a list?. def _super_tofrom_choi(q_oper):; """"""; We exploit that the basis transformation between Choi and supermatrix; representations squares to the identity, so that if we munge Qobj.type,; we can use the same function. Since this function doesn't respect :attr:`Qobj.type`, we mark it as; private; only those functions which wrap this in a way so as to preserve; type should be called externally.; """"""; data = q_oper.data.toarray(); dims = q_oper.dims; new_dims = [[dims[1][1], dims[0][1]], [dims[1][0], dims[0][0]]]; d0 = np.prod(np.ravel(new_dims[0])); d1 = np.prod(np.ravel(new_dims[1])); s0 = np.prod(dims[0][0]); s1 = np.prod(dims[1][1]); return Qobj(dims=new_dims,; inpt=data.reshape([s0, s1, s0, s1]).; transpose(3, 1, 2, 0).reshape((d0, d1))). def _isqubitdims(dims):; """"""Checks whether all entries ",MatchSource.WIKI,docs/4.7/modules/qutip/superop_reps.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/superop_reps.html
https://qutip.org/docs/4.7/modules/qutip/superop_reps.html:11580,Testability,assert,assert,11580,"p(int, map(sqrt, q_oper.shape)); # Also remember the dims breakout.; out_dims, in_dims = q_oper.dims; out_left, out_right = out_dims; in_left, in_right = in_dims. # Find the SVD.; U, S, V = svd(q_oper.full()). # Truncate away the zero singular values, up to a threshold.; nonzero_idxs = S > thresh; dK = nonzero_idxs.sum(); U = U[:, nonzero_idxs]; S = sqrt(S[nonzero_idxs]); # Since NumPy returns V and not V+, we need to take the dagger; # to get back to quantum info notation for Stinespring pairs.; V = V.conj().T[:, nonzero_idxs]. # Next, we convert each of U and V into Kraus operators.; # Finally, we want the Kraus index to be left-most so that we; # can map over it when making Qobjs.; # FIXME: does not preserve dims!; kU = _svd_u_to_kraus(U, S, dL, dK, out_right, out_left); kV = _svd_u_to_kraus(V, S, dL, dK, in_right, in_left). return kU, kV. def choi_to_stinespring(q_oper, thresh=1e-10):; # TODO: document!; kU, kV = _generalized_kraus(q_oper, thresh=thresh). assert(len(kU) == len(kV)); dK = len(kU); dL = kU[0].shape[0]; dR = kV[0].shape[1]; # Also remember the dims breakout.; out_dims, in_dims = q_oper.dims; out_left, out_right = out_dims; in_left, in_right = in_dims. A = Qobj(zeros((dK * dL, dL)), dims=[out_left + [dK], out_right + [1]]); B = Qobj(zeros((dK * dR, dR)), dims=[in_left + [dK], in_right + [1]]). for idx_kraus, (KL, KR) in enumerate(zip(kU, kV)):; A += tensor(KL, basis(dK, idx_kraus)); B += tensor(KR, basis(dK, idx_kraus)). # There is no input (right) Kraus index, so strip that off.; del A.dims[1][-1]; del B.dims[1][-1]. return A, B. # PUBLIC CONVERSION FUNCTIONS -------------------------------------------------; # These functions handle superoperator conversions in a way that preserves the; # correctness of Qobj.type, and in a way that automatically branches based on; # the input Qobj.type. [docs]def to_choi(q_oper):; """"""; Converts a Qobj representing a quantum map to the Choi representation,; such that the trace of the returned operator is equal to t",MatchSource.WIKI,docs/4.7/modules/qutip/superop_reps.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/superop_reps.html
https://qutip.org/docs/4.7/modules/qutip/tensor.html:2020,Availability,error,error,2020,"rgs : array_like; ``list`` or ``array`` of quantum objects for tensor product. Returns; -------; obj : qobj; A composite quantum object. Examples; --------; >>> tensor([sigmax(), sigmax()]) # doctest: +SKIP; Quantum object: dims = [[2, 2], [2, 2]], \; shape = [4, 4], type = oper, isHerm = True; Qobj data =; [[ 0.+0.j 0.+0.j 0.+0.j 1.+0.j]; [ 0.+0.j 0.+0.j 1.+0.j 0.+0.j]; [ 0.+0.j 1.+0.j 0.+0.j 0.+0.j]; [ 1.+0.j 0.+0.j 0.+0.j 0.+0.j]]; """""". if not args:; raise TypeError(""Requires at least one input argument""). if len(args) == 1 and isinstance(args[0], (list, np.ndarray)):; # this is the case when tensor is called on the form:; # tensor([q1, q2, q3, ...]); qlist = args[0]. elif len(args) == 1 and isinstance(args[0], Qobj):; # tensor is called with a single Qobj as an argument, do nothing; return args[0]. else:; # this is the case when tensor is called on the form:; # tensor(q1, q2, q3, ...); qlist = args. if not all([isinstance(q, Qobj) for q in qlist]):; # raise error if one of the inputs is not a quantum object; raise TypeError(""One of inputs is not a quantum object""). out = Qobj(). if qlist[0].issuper:; out.superrep = qlist[0].superrep; if not all([q.superrep == out.superrep for q in qlist]):; raise TypeError(""In tensor products of superroperators, all must"" +; ""have the same representation""). out.isherm = True; for n, q in enumerate(qlist):; if n == 0:; out.data = q.data; out.dims = q.dims; else:; out.data = zcsr_kron(out.data, q.data). out.dims = [out.dims[0] + q.dims[0], out.dims[1] + q.dims[1]]. out.isherm = out.isherm and q.isherm. if not out.isherm:; out._isherm = None. return out.tidyup() if qutip.settings.auto_tidyup else out. [docs]def super_tensor(*args):; """"""Calculates the tensor product of input superoperators, by tensoring; together the underlying Hilbert spaces on which each vectorized operator; acts. Parameters; ----------; args : array_like; ``list`` or ``array`` of quantum objects with ``type=""super""``. Returns; -------; obj : qobj; A composite quan",MatchSource.WIKI,docs/4.7/modules/qutip/tensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/tensor.html
https://qutip.org/docs/4.7/modules/qutip/tensor.html:10195,Deployability,update,updated,10195,"""""Contracts a qobj along one or more index pairs.; Note that this uses dense representations and thus; should *not* be used for very large Qobjs. Parameters; ----------. pairs : tuple; One or more tuples ``(i, j)`` indicating that the; ``i`` and ``j`` dimensions of the original qobj; should be contracted. Returns; -------. cqobj : Qobj; The original Qobj with all named index pairs contracted; away. """"""; # Record and label the original dims.; dims = qobj.dims; dims_idxs = enumerate_flat(dims); tensor_dims = dims_to_tensor_shape(dims). # Convert to dense first, since sparse won't support the reshaping we need.; qtens = qobj.data.toarray(). # Reshape by the flattened dims.; qtens = qtens.reshape(tensor_dims). # Contract out the indices from the flattened object.; # Note that we need to feed pairs through dims_idxs_to_tensor_idxs; # to ensure that we are contracting the right indices.; qtens = _tensor_contract_dense(qtens, *dims_idxs_to_tensor_idxs(dims, pairs)). # Remove the contracted indexes from dims so we know how to; # reshape back.; # This concerns dims, and not the tensor indices, so we need; # to make sure to use the original dims indices and not the ones; # generated by dims_to_* functions.; contracted_idxs = deep_remove(dims_idxs, *flatten(list(map(list, pairs)))); contracted_dims = unflatten(flatten(dims), contracted_idxs). # We don't need to check for tensor idxs versus dims idxs here,; # as column- versus row-stacking will never move an index for the; # vectorized operator spaces all the way from the left to the right.; l_mtx_dims, r_mtx_dims = map(np.prod, map(flatten, contracted_dims)). # Reshape back into a 2D matrix.; qmtx = qtens.reshape((l_mtx_dims, r_mtx_dims)). # Return back as a qobj.; return Qobj(qmtx, dims=contracted_dims, superrep=qobj.superrep). import qutip.states. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/modules/qutip/tensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/tensor.html
https://qutip.org/docs/4.7/modules/qutip/tensor.html:923,Integrability,depend,dependency,923,". qutip.tensor — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.tensor. Source code for qutip.tensor; """"""; Module for the creation of composite quantum objects via the tensor product.; """""". __all__ = [; 'tensor', 'super_tensor', 'composite', 'tensor_swap', 'tensor_contract'; ]. import numpy as np; import scipy.sparse as sp; from qutip.cy.spmath import zcsr_kron; from qutip.qobj import Qobj; from qutip.permute import reshuffle; from qutip.superoperator import operator_to_vector; from qutip.dimensions import (; flatten, enumerate_flat, unflatten, deep_remove,; dims_to_tensor_shape, dims_idxs_to_tensor_idxs; ). import qutip.settings; import qutip.superop_reps # Avoid circular dependency here. [docs]def tensor(*args):; """"""Calculates the tensor product of input operators. Parameters; ----------; args : array_like; ``list`` or ``array`` of quantum objects for tensor product. Returns; -------; obj : qobj; A composite quantum object. Examples; --------; >>> tensor([sigmax(), sigmax()]) # doctest: +SKIP; Quantum object: dims = [[2, 2], [2, 2]], \; shape = [4, 4], type = oper, isHerm = True; Qobj data =; [[ 0.+0.j 0.+0.j 0.+0.j 1.+0.j]; [ 0.+0.j 0.+0.j 1.+0.j 0.+0.j]; [ 0.+0.j 1.+0.j 0.+0.j 0.+0.j]; [ 1.+0.j 0.+0.j 0.+0.j 0.+0.j]]; """""". if not args:; raise TypeError(""Requires at least one input argument""). if len(args) == 1 and isinstance(args[0], (list, np.ndarray)):; # this is the case when tensor is called on the form:; # tensor([q1, q2, q3, ...]); qlist = args[0]. elif len(args) == 1 and isinstance(args[0], Qobj):; # tensor is called with a single Qobj as an argument, do nothing; return args[0]. else:; # this is the case when tensor is called on the form:; # tensor(q1, q2, q3, ...); qlist = args. if not all([isinstance(q, Qobj) for q in",MatchSource.WIKI,docs/4.7/modules/qutip/tensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/tensor.html
https://qutip.org/docs/4.7/modules/qutip/tensor.html:6335,Integrability,contract,contract,6335,"e already type=super, while it will; # promote unitaries to superunitaries.; return super_tensor(*map(qutip.superop_reps.to_super, args)). else:; # Everything's just an oper, so ordinary tensor products work.; return tensor(*args). elif all(map(_isketlike, args)):; # Ket-likes.; if any(arg.isoperket for arg in args):; # We have a vectorized operator, we we may need to promote; # something.; return super_tensor(*(; arg if arg.isoperket; else operator_to_vector(qutip.states.ket2dm(arg)); for arg in args; )). else:; # Everything's ordinary, so we can use the tensor product here.; return tensor(*args). elif all(map(_isbralike, args)):; # Turn into ket-likes and recurse.; return composite(*(arg.dag() for arg in args)).dag(). else:; raise TypeError(""Unsupported Qobj types [{}]."".format(; "", "".join(arg.type for arg in args); )). def _tensor_contract_single(arr, i, j):; """"""; Contracts a dense tensor along a single index pair.; """"""; if arr.shape[i] != arr.shape[j]:; raise ValueError(""Cannot contract over indices of different length.""); idxs = np.arange(arr.shape[i]); sl = tuple(slice(None, None, None); if idx not in (i, j) else idxs for idx in range(arr.ndim)); contract_at = i if j == i + 1 else 0; return np.sum(arr[sl], axis=contract_at). def _tensor_contract_dense(arr, *pairs):; """"""; Contracts a dense tensor along one or more index pairs,; keeping track of how the indices are relabeled by the removal; of other indices.; """"""; axis_idxs = list(range(arr.ndim)); for pair in pairs:; # axis_idxs.index effectively evaluates the mapping from; # original index labels to the labels after contraction.; arr = _tensor_contract_single(arr, *map(axis_idxs.index, pair)); list(map(axis_idxs.remove, pair)); return arr. def tensor_swap(q_oper, *pairs):; """"""Transposes one or more pairs of indices of a Qobj.; Note that this uses dense representations and thus; should *not* be used for very large Qobjs. Parameters; ----------. pairs : tuple; One or more tuples ``(i, j)`` indicating that the; `",MatchSource.WIKI,docs/4.7/modules/qutip/tensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/tensor.html
https://qutip.org/docs/4.7/modules/qutip/tensor.html:6937,Integrability,contract,contraction,6937,"e tensor product here.; return tensor(*args). elif all(map(_isbralike, args)):; # Turn into ket-likes and recurse.; return composite(*(arg.dag() for arg in args)).dag(). else:; raise TypeError(""Unsupported Qobj types [{}]."".format(; "", "".join(arg.type for arg in args); )). def _tensor_contract_single(arr, i, j):; """"""; Contracts a dense tensor along a single index pair.; """"""; if arr.shape[i] != arr.shape[j]:; raise ValueError(""Cannot contract over indices of different length.""); idxs = np.arange(arr.shape[i]); sl = tuple(slice(None, None, None); if idx not in (i, j) else idxs for idx in range(arr.ndim)); contract_at = i if j == i + 1 else 0; return np.sum(arr[sl], axis=contract_at). def _tensor_contract_dense(arr, *pairs):; """"""; Contracts a dense tensor along one or more index pairs,; keeping track of how the indices are relabeled by the removal; of other indices.; """"""; axis_idxs = list(range(arr.ndim)); for pair in pairs:; # axis_idxs.index effectively evaluates the mapping from; # original index labels to the labels after contraction.; arr = _tensor_contract_single(arr, *map(axis_idxs.index, pair)); list(map(axis_idxs.remove, pair)); return arr. def tensor_swap(q_oper, *pairs):; """"""Transposes one or more pairs of indices of a Qobj.; Note that this uses dense representations and thus; should *not* be used for very large Qobjs. Parameters; ----------. pairs : tuple; One or more tuples ``(i, j)`` indicating that the; ``i`` and ``j`` dimensions of the original qobj; should be swapped. Returns; -------. sqobj : Qobj; The original Qobj with all named index pairs swapped with each other; """"""; dims = q_oper.dims; tensor_pairs = dims_idxs_to_tensor_idxs(dims, pairs). data = q_oper.data.toarray(). # Reshape into tensor indices; data = data.reshape(dims_to_tensor_shape(dims)). # Now permute the dims list so we know how to get back.; flat_dims = flatten(dims); perm = list(range(len(flat_dims))); for i, j in pairs:; flat_dims[i], flat_dims[j] = flat_dims[j], flat_dims[i]; for i",MatchSource.WIKI,docs/4.7/modules/qutip/tensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/tensor.html
https://qutip.org/docs/4.7/modules/qutip/tensor.html:8591,Integrability,contract,contracted,8591,"ensor_pairs = dims_idxs_to_tensor_idxs(dims, pairs). data = q_oper.data.toarray(). # Reshape into tensor indices; data = data.reshape(dims_to_tensor_shape(dims)). # Now permute the dims list so we know how to get back.; flat_dims = flatten(dims); perm = list(range(len(flat_dims))); for i, j in pairs:; flat_dims[i], flat_dims[j] = flat_dims[j], flat_dims[i]; for i, j in tensor_pairs:; perm[i], perm[j] = perm[j], perm[i]; dims = unflatten(flat_dims, enumerate_flat(dims)). # Next, permute the actual indices of the dense tensor.; data = data.transpose(perm). # Reshape back, using the left and right of dims.; data = data.reshape(list(map(np.prod, dims))). return Qobj(inpt=data, dims=dims, superrep=q_oper.superrep). [docs]def tensor_contract(qobj, *pairs):; """"""Contracts a qobj along one or more index pairs.; Note that this uses dense representations and thus; should *not* be used for very large Qobjs. Parameters; ----------. pairs : tuple; One or more tuples ``(i, j)`` indicating that the; ``i`` and ``j`` dimensions of the original qobj; should be contracted. Returns; -------. cqobj : Qobj; The original Qobj with all named index pairs contracted; away. """"""; # Record and label the original dims.; dims = qobj.dims; dims_idxs = enumerate_flat(dims); tensor_dims = dims_to_tensor_shape(dims). # Convert to dense first, since sparse won't support the reshaping we need.; qtens = qobj.data.toarray(). # Reshape by the flattened dims.; qtens = qtens.reshape(tensor_dims). # Contract out the indices from the flattened object.; # Note that we need to feed pairs through dims_idxs_to_tensor_idxs; # to ensure that we are contracting the right indices.; qtens = _tensor_contract_dense(qtens, *dims_idxs_to_tensor_idxs(dims, pairs)). # Remove the contracted indexes from dims so we know how to; # reshape back.; # This concerns dims, and not the tensor indices, so we need; # to make sure to use the original dims indices and not the ones; # generated by dims_to_* functions.; contracted_idxs = dee",MatchSource.WIKI,docs/4.7/modules/qutip/tensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/tensor.html
https://qutip.org/docs/4.7/modules/qutip/tensor.html:8680,Integrability,contract,contracted,8680,".reshape(dims_to_tensor_shape(dims)). # Now permute the dims list so we know how to get back.; flat_dims = flatten(dims); perm = list(range(len(flat_dims))); for i, j in pairs:; flat_dims[i], flat_dims[j] = flat_dims[j], flat_dims[i]; for i, j in tensor_pairs:; perm[i], perm[j] = perm[j], perm[i]; dims = unflatten(flat_dims, enumerate_flat(dims)). # Next, permute the actual indices of the dense tensor.; data = data.transpose(perm). # Reshape back, using the left and right of dims.; data = data.reshape(list(map(np.prod, dims))). return Qobj(inpt=data, dims=dims, superrep=q_oper.superrep). [docs]def tensor_contract(qobj, *pairs):; """"""Contracts a qobj along one or more index pairs.; Note that this uses dense representations and thus; should *not* be used for very large Qobjs. Parameters; ----------. pairs : tuple; One or more tuples ``(i, j)`` indicating that the; ``i`` and ``j`` dimensions of the original qobj; should be contracted. Returns; -------. cqobj : Qobj; The original Qobj with all named index pairs contracted; away. """"""; # Record and label the original dims.; dims = qobj.dims; dims_idxs = enumerate_flat(dims); tensor_dims = dims_to_tensor_shape(dims). # Convert to dense first, since sparse won't support the reshaping we need.; qtens = qobj.data.toarray(). # Reshape by the flattened dims.; qtens = qtens.reshape(tensor_dims). # Contract out the indices from the flattened object.; # Note that we need to feed pairs through dims_idxs_to_tensor_idxs; # to ensure that we are contracting the right indices.; qtens = _tensor_contract_dense(qtens, *dims_idxs_to_tensor_idxs(dims, pairs)). # Remove the contracted indexes from dims so we know how to; # reshape back.; # This concerns dims, and not the tensor indices, so we need; # to make sure to use the original dims indices and not the ones; # generated by dims_to_* functions.; contracted_idxs = deep_remove(dims_idxs, *flatten(list(map(list, pairs)))); contracted_dims = unflatten(flatten(dims), contracted_idxs). # We don'",MatchSource.WIKI,docs/4.7/modules/qutip/tensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/tensor.html
https://qutip.org/docs/4.7/modules/qutip/tensor.html:9159,Integrability,contract,contracting,9159,"d right of dims.; data = data.reshape(list(map(np.prod, dims))). return Qobj(inpt=data, dims=dims, superrep=q_oper.superrep). [docs]def tensor_contract(qobj, *pairs):; """"""Contracts a qobj along one or more index pairs.; Note that this uses dense representations and thus; should *not* be used for very large Qobjs. Parameters; ----------. pairs : tuple; One or more tuples ``(i, j)`` indicating that the; ``i`` and ``j`` dimensions of the original qobj; should be contracted. Returns; -------. cqobj : Qobj; The original Qobj with all named index pairs contracted; away. """"""; # Record and label the original dims.; dims = qobj.dims; dims_idxs = enumerate_flat(dims); tensor_dims = dims_to_tensor_shape(dims). # Convert to dense first, since sparse won't support the reshaping we need.; qtens = qobj.data.toarray(). # Reshape by the flattened dims.; qtens = qtens.reshape(tensor_dims). # Contract out the indices from the flattened object.; # Note that we need to feed pairs through dims_idxs_to_tensor_idxs; # to ensure that we are contracting the right indices.; qtens = _tensor_contract_dense(qtens, *dims_idxs_to_tensor_idxs(dims, pairs)). # Remove the contracted indexes from dims so we know how to; # reshape back.; # This concerns dims, and not the tensor indices, so we need; # to make sure to use the original dims indices and not the ones; # generated by dims_to_* functions.; contracted_idxs = deep_remove(dims_idxs, *flatten(list(map(list, pairs)))); contracted_dims = unflatten(flatten(dims), contracted_idxs). # We don't need to check for tensor idxs versus dims idxs here,; # as column- versus row-stacking will never move an index for the; # vectorized operator spaces all the way from the left to the right.; l_mtx_dims, r_mtx_dims = map(np.prod, map(flatten, contracted_dims)). # Reshape back into a 2D matrix.; qmtx = qtens.reshape((l_mtx_dims, r_mtx_dims)). # Return back as a qobj.; return Qobj(qmtx, dims=contracted_dims, superrep=qobj.superrep). import qutip.states. © Copyright",MatchSource.WIKI,docs/4.7/modules/qutip/tensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/tensor.html
https://qutip.org/docs/4.7/modules/qutip/tensor.html:9283,Integrability,contract,contracted,9283,"""""Contracts a qobj along one or more index pairs.; Note that this uses dense representations and thus; should *not* be used for very large Qobjs. Parameters; ----------. pairs : tuple; One or more tuples ``(i, j)`` indicating that the; ``i`` and ``j`` dimensions of the original qobj; should be contracted. Returns; -------. cqobj : Qobj; The original Qobj with all named index pairs contracted; away. """"""; # Record and label the original dims.; dims = qobj.dims; dims_idxs = enumerate_flat(dims); tensor_dims = dims_to_tensor_shape(dims). # Convert to dense first, since sparse won't support the reshaping we need.; qtens = qobj.data.toarray(). # Reshape by the flattened dims.; qtens = qtens.reshape(tensor_dims). # Contract out the indices from the flattened object.; # Note that we need to feed pairs through dims_idxs_to_tensor_idxs; # to ensure that we are contracting the right indices.; qtens = _tensor_contract_dense(qtens, *dims_idxs_to_tensor_idxs(dims, pairs)). # Remove the contracted indexes from dims so we know how to; # reshape back.; # This concerns dims, and not the tensor indices, so we need; # to make sure to use the original dims indices and not the ones; # generated by dims_to_* functions.; contracted_idxs = deep_remove(dims_idxs, *flatten(list(map(list, pairs)))); contracted_dims = unflatten(flatten(dims), contracted_idxs). # We don't need to check for tensor idxs versus dims idxs here,; # as column- versus row-stacking will never move an index for the; # vectorized operator spaces all the way from the left to the right.; l_mtx_dims, r_mtx_dims = map(np.prod, map(flatten, contracted_dims)). # Reshape back into a 2D matrix.; qmtx = qtens.reshape((l_mtx_dims, r_mtx_dims)). # Return back as a qobj.; return Qobj(qmtx, dims=contracted_dims, superrep=qobj.superrep). import qutip.states. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/modules/qutip/tensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/tensor.html
https://qutip.org/docs/4.7/modules/qutip/three_level_atom.html:661,Deployability,configurat,configuration,661,". qutip.three_level_atom — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.three_level_atom. Source code for qutip.three_level_atom; r'''; This module provides functions that are useful for simulating the; three level atom with QuTiP. A three level atom (qutrit) has three states,; which are linked by dipole transitions so that 1 <-> 2 <-> 3.; Depending on there relative energies they are in the ladder, lambda or; vee configuration. The structure of the relevant operators is the same; for any of the three configurations::. Ladder: Lambda: Vee:; |two> |three>; -------|three> ------- -------; | / \ |one> /; | / \ ------- /; | / \ \ /; -------|two> / \ \ /; | / \ \ /; | / \ \ /; | / -------- \ /; -------|one> ------- |three> -------; |one> |two>. References; ----------; The naming of qutip operators follows the convention in [1]_ . .. [1] Shore, B. W., ""The Theory of Coherent Atomic Excitation"",; Wiley, 1990. Notes; -----; Contributed by Markus Baden, Oct. 07, 2011. '''. __all__ = ['three_level_basis', 'three_level_ops']. import numpy as np; from qutip.states import qutrit_basis. [docs]def three_level_basis():; ''' Basis states for a three level atom. Returns; -------; states : array; `array` of three level atom basis vectors. '''; # A three level atom has the same representation as a qutrit, i.e.; # three states; return qutrit_basis(). [docs]def three_level_ops():; ''' Operators for a three level system (qutrit). Returns; --------; ops : array; `array` of three level operators. '''; out = np.empty((5,), dtype=object); one, two, three = qutrit_basis(); # Note that the three level operators are different; # from the qutrit operators. A three level atom only; # has transitions 1 <-> 2 <-> 3, so we define the; # operators seperately from ",MatchSource.WIKI,docs/4.7/modules/qutip/three_level_atom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/three_level_atom.html
https://qutip.org/docs/4.7/modules/qutip/three_level_atom.html:750,Deployability,configurat,configurations,750,". qutip.three_level_atom — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.three_level_atom. Source code for qutip.three_level_atom; r'''; This module provides functions that are useful for simulating the; three level atom with QuTiP. A three level atom (qutrit) has three states,; which are linked by dipole transitions so that 1 <-> 2 <-> 3.; Depending on there relative energies they are in the ladder, lambda or; vee configuration. The structure of the relevant operators is the same; for any of the three configurations::. Ladder: Lambda: Vee:; |two> |three>; -------|three> ------- -------; | / \ |one> /; | / \ ------- /; | / \ \ /; -------|two> / \ \ /; | / \ \ /; | / \ \ /; | / -------- \ /; -------|one> ------- |three> -------; |one> |two>. References; ----------; The naming of qutip operators follows the convention in [1]_ . .. [1] Shore, B. W., ""The Theory of Coherent Atomic Excitation"",; Wiley, 1990. Notes; -----; Contributed by Markus Baden, Oct. 07, 2011. '''. __all__ = ['three_level_basis', 'three_level_ops']. import numpy as np; from qutip.states import qutrit_basis. [docs]def three_level_basis():; ''' Basis states for a three level atom. Returns; -------; states : array; `array` of three level atom basis vectors. '''; # A three level atom has the same representation as a qutrit, i.e.; # three states; return qutrit_basis(). [docs]def three_level_ops():; ''' Operators for a three level system (qutrit). Returns; --------; ops : array; `array` of three level operators. '''; out = np.empty((5,), dtype=object); one, two, three = qutrit_basis(); # Note that the three level operators are different; # from the qutrit operators. A three level atom only; # has transitions 1 <-> 2 <-> 3, so we define the; # operators seperately from ",MatchSource.WIKI,docs/4.7/modules/qutip/three_level_atom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/three_level_atom.html
https://qutip.org/docs/4.7/modules/qutip/three_level_atom.html:2245,Deployability,update,updated,2245,"or qutip.three_level_atom; r'''; This module provides functions that are useful for simulating the; three level atom with QuTiP. A three level atom (qutrit) has three states,; which are linked by dipole transitions so that 1 <-> 2 <-> 3.; Depending on there relative energies they are in the ladder, lambda or; vee configuration. The structure of the relevant operators is the same; for any of the three configurations::. Ladder: Lambda: Vee:; |two> |three>; -------|three> ------- -------; | / \ |one> /; | / \ ------- /; | / \ \ /; -------|two> / \ \ /; | / \ \ /; | / \ \ /; | / -------- \ /; -------|one> ------- |three> -------; |one> |two>. References; ----------; The naming of qutip operators follows the convention in [1]_ . .. [1] Shore, B. W., ""The Theory of Coherent Atomic Excitation"",; Wiley, 1990. Notes; -----; Contributed by Markus Baden, Oct. 07, 2011. '''. __all__ = ['three_level_basis', 'three_level_ops']. import numpy as np; from qutip.states import qutrit_basis. [docs]def three_level_basis():; ''' Basis states for a three level atom. Returns; -------; states : array; `array` of three level atom basis vectors. '''; # A three level atom has the same representation as a qutrit, i.e.; # three states; return qutrit_basis(). [docs]def three_level_ops():; ''' Operators for a three level system (qutrit). Returns; --------; ops : array; `array` of three level operators. '''; out = np.empty((5,), dtype=object); one, two, three = qutrit_basis(); # Note that the three level operators are different; # from the qutrit operators. A three level atom only; # has transitions 1 <-> 2 <-> 3, so we define the; # operators seperately from the qutrit code; out[0] = one * one.dag(); out[1] = two * two.dag(); out[2] = three * three.dag(); out[3] = one * two.dag(); out[4] = three * two.dag(); return out. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/modules/qutip/three_level_atom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/three_level_atom.html
https://qutip.org/docs/4.7/modules/qutip/three_level_atom.html:661,Modifiability,config,configuration,661,". qutip.three_level_atom — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.three_level_atom. Source code for qutip.three_level_atom; r'''; This module provides functions that are useful for simulating the; three level atom with QuTiP. A three level atom (qutrit) has three states,; which are linked by dipole transitions so that 1 <-> 2 <-> 3.; Depending on there relative energies they are in the ladder, lambda or; vee configuration. The structure of the relevant operators is the same; for any of the three configurations::. Ladder: Lambda: Vee:; |two> |three>; -------|three> ------- -------; | / \ |one> /; | / \ ------- /; | / \ \ /; -------|two> / \ \ /; | / \ \ /; | / \ \ /; | / -------- \ /; -------|one> ------- |three> -------; |one> |two>. References; ----------; The naming of qutip operators follows the convention in [1]_ . .. [1] Shore, B. W., ""The Theory of Coherent Atomic Excitation"",; Wiley, 1990. Notes; -----; Contributed by Markus Baden, Oct. 07, 2011. '''. __all__ = ['three_level_basis', 'three_level_ops']. import numpy as np; from qutip.states import qutrit_basis. [docs]def three_level_basis():; ''' Basis states for a three level atom. Returns; -------; states : array; `array` of three level atom basis vectors. '''; # A three level atom has the same representation as a qutrit, i.e.; # three states; return qutrit_basis(). [docs]def three_level_ops():; ''' Operators for a three level system (qutrit). Returns; --------; ops : array; `array` of three level operators. '''; out = np.empty((5,), dtype=object); one, two, three = qutrit_basis(); # Note that the three level operators are different; # from the qutrit operators. A three level atom only; # has transitions 1 <-> 2 <-> 3, so we define the; # operators seperately from ",MatchSource.WIKI,docs/4.7/modules/qutip/three_level_atom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/three_level_atom.html
https://qutip.org/docs/4.7/modules/qutip/three_level_atom.html:750,Modifiability,config,configurations,750,". qutip.three_level_atom — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.three_level_atom. Source code for qutip.three_level_atom; r'''; This module provides functions that are useful for simulating the; three level atom with QuTiP. A three level atom (qutrit) has three states,; which are linked by dipole transitions so that 1 <-> 2 <-> 3.; Depending on there relative energies they are in the ladder, lambda or; vee configuration. The structure of the relevant operators is the same; for any of the three configurations::. Ladder: Lambda: Vee:; |two> |three>; -------|three> ------- -------; | / \ |one> /; | / \ ------- /; | / \ \ /; -------|two> / \ \ /; | / \ \ /; | / \ \ /; | / -------- \ /; -------|one> ------- |three> -------; |one> |two>. References; ----------; The naming of qutip operators follows the convention in [1]_ . .. [1] Shore, B. W., ""The Theory of Coherent Atomic Excitation"",; Wiley, 1990. Notes; -----; Contributed by Markus Baden, Oct. 07, 2011. '''. __all__ = ['three_level_basis', 'three_level_ops']. import numpy as np; from qutip.states import qutrit_basis. [docs]def three_level_basis():; ''' Basis states for a three level atom. Returns; -------; states : array; `array` of three level atom basis vectors. '''; # A three level atom has the same representation as a qutrit, i.e.; # three states; return qutrit_basis(). [docs]def three_level_ops():; ''' Operators for a three level system (qutrit). Returns; --------; ops : array; `array` of three level operators. '''; out = np.empty((5,), dtype=object); one, two, three = qutrit_basis(); # Note that the three level operators are different; # from the qutrit operators. A three level atom only; # has transitions 1 <-> 2 <-> 3, so we define the; # operators seperately from ",MatchSource.WIKI,docs/4.7/modules/qutip/three_level_atom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/three_level_atom.html
https://qutip.org/docs/4.7/modules/qutip/tomography.html:4941,Deployability,update,updated,4941,"(alternative to the fig argument). threshold: float (None); Threshold for when bars of smaller height should be transparent. If; not set, all bars are colored according to the color map. Returns; -------; fig, ax : tuple; A tuple of the matplotlib figure and axes instances used to produce; the figure.; """""". if ax is None:; if fig is None:; fig = plt.figure(figsize=figsize); ax = fig.add_subplot(1, 1, 1, projection='3d', position=[0, 0, 1, 1]). xlabels = []; for inds in _index_permutations([len(lbls) for lbls in lbls_list]):; xlabels.append("""".join(; [lbls_list[k][inds[k]] for k in range(len(lbls_list))])). if not title:; title = r""$\chi$"". matrix_histogram_complex(chi, xlabels, xlabels, title=title, ax=ax,; threshold=threshold). return fig, ax. [docs]def qpt(U, op_basis_list):; """"""; Calculate the quantum process tomography chi matrix for a given (possibly; nonunitary) transformation matrix U, which transforms a density matrix in; vector form according to:. vec(rho) = U * vec(rho0). or. rho = vec2mat(U * mat2vec(rho0)). U can be calculated for an open quantum system using the QuTiP propagator; function. Parameters; ----------; U : Qobj; Transformation operator. Can be calculated using QuTiP propagator; function. op_basis_list : list; A list of Qobj's representing the basis states. Returns; -------; chi : array; QPT chi matrix. """""". E_ops = []; # loop over all index permutations; for inds in _index_permutations([len(ops) for ops in op_basis_list]):; # loop over all composite systems; E_op_list = [op_basis_list[k][inds[k]] for k in range(len(; op_basis_list))]; E_ops.append(tensor(E_op_list)). EE_ops = [spre(E1) * spost(E2.dag()) for E1 in E_ops for E2 in E_ops]. M = hstack([mat2vec(EE.full()) for EE in EE_ops]). Uvec = mat2vec(U.full()). chi_vec = la.solve(M, Uvec). return vec2mat(chi_vec). © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/modules/qutip/tomography.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/tomography.html
https://qutip.org/docs/4.7/modules/qutip/topology.html:2773,Deployability,update,updated,2773,"the two parameters and the third is the index of the; occupied bands. The fourth dimension holds the eigenfunctions. Returns; -------; b_curv : numpy ndarray; A two dimensional array of the discretized Berry curvature defined for; the values of the two parameters defined in the eigfs.; """"""; nparam0 = eigfs.shape[0]; nparam1 = eigfs.shape[1]; nocc = eigfs.shape[2]; b_curv = np.zeros((nparam0-1, nparam1-1), dtype=float). for i in range(nparam0-1):; for j in range(nparam1-1):; rect_prd = np.identity(nocc, dtype=complex); innP0 = np.zeros([nocc, nocc], dtype=complex); innP1 = np.zeros([nocc, nocc], dtype=complex); innP2 = np.zeros([nocc, nocc], dtype=complex); innP3 = np.zeros([nocc, nocc], dtype=complex). for k in range(nocc):; for l in range(nocc):; wf0 = eigfs[i, j, k, :]; wf1 = eigfs[i+1, j, l, :]; innP0[k, l] = np.dot(wf0.conjugate(), wf1). wf1 = eigfs[i+1, j, k, :]; wf2 = eigfs[i+1, j+1, l, :]; innP1[k, l] = np.dot(wf1.conjugate(), wf2). wf2 = eigfs[i+1, j+1, k, :]; wf3 = eigfs[i, j+1, l, :]; innP2[k, l] = np.dot(wf2.conjugate(), wf3). wf3 = eigfs[i, j+1, k, :]; wf0 = eigfs[i, j, l, :]; innP3[k, l] = np.dot(wf3.conjugate(), wf0). rect_prd = np.dot(rect_prd, innP0); rect_prd = np.dot(rect_prd, innP1); rect_prd = np.dot(rect_prd, innP2); rect_prd = np.dot(rect_prd, innP3). dett = np.linalg.det(rect_prd); curl_z = np.angle(dett); b_curv[i, j] = curl_z. return b_curv. [docs]def plot_berry_curvature(eigfs):; """"""Plots the discretized Berry curvature on the two dimensional grid; of parameters. The function works well for cases with no band mixing.""""""; b_curv = berry_curvature(eigfs); fig, ax = plt.subplots(); ax.imshow(b_curv, origin=""lower""); ax.set_title(""Berry curvature""); ax.set_xlabel(r""$Parameter0$""); ax.set_ylabel(r""$Parameter1$""); fig.tight_layout(); fig.savefig(""berry_curvature.pdf""). © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/modules/qutip/topology.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/topology.html
https://qutip.org/docs/4.7/modules/qutip/utilities.html:7665,Availability,avail,available,7665,"2 * (_kB / _h); return w_GHz. def _version2int(version_string):; str_list = version_string.split(; ""-dev"")[0].split(""rc"")[0].split(""a"")[0].split(""b"")[0].split(; ""post"")[0].split('.'); return sum([int(d if len(d) > 0 else 0) * (100 ** (3 - n)); for n, d in enumerate(str_list[:3])]). def _blas_info():; config = np.__config__; if hasattr(config, 'blas_ilp64_opt_info'):; blas_info = config.blas_ilp64_opt_info; elif hasattr(config, 'blas_opt_info'):; blas_info = config.blas_opt_info; else:; blas_info = {}; _has_lib_key = 'libraries' in blas_info.keys(); blas = None; if hasattr(config,'mkl_info') or \; (_has_lib_key and any('mkl' in lib for lib in blas_info['libraries'])):; blas = 'INTEL MKL'; elif hasattr(config,'openblas_info') or \; (_has_lib_key and any('openblas' in lib for lib in blas_info['libraries'])):; blas = 'OPENBLAS'; elif 'extra_link_args' in blas_info.keys() and ('-Wl,Accelerate' in blas_info['extra_link_args']):; blas = 'Accelerate'; else:; blas = 'Generic'; return blas. def available_cpu_count():; """"""; Get the number of cpus.; It tries to only get the number available to qutip.; """"""; import os; import multiprocessing; try:; import psutil; except ImportError:; psutil = None; num_cpu = 0. if 'QUTIP_NUM_PROCESSES' in os.environ:; # We consider QUTIP_NUM_PROCESSES=0 as unset.; num_cpu = int(os.environ['QUTIP_NUM_PROCESSES']). if num_cpu == 0 and 'SLURM_CPUS_PER_TASK' in os.environ:; num_cpu = int(os.environ['SLURM_CPUS_PER_TASK']). if num_cpu == 0 and hasattr(os, 'sched_getaffinity'):; num_cpu = len(os.sched_getaffinity(0)). if (; num_cpu == 0; and psutil is not None; and hasattr(psutil.Process(), ""cpu_affinity""); ):; num_cpu = len(psutil.Process().cpu_affinity()). if num_cpu == 0:; try:; num_cpu = multiprocessing.cpu_count(); except NotImplementedError:; pass. return num_cpu or 1. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/utilities.html
https://qutip.org/docs/4.7/modules/qutip/utilities.html:8478,Deployability,update,updated,8478,"2 * (_kB / _h); return w_GHz. def _version2int(version_string):; str_list = version_string.split(; ""-dev"")[0].split(""rc"")[0].split(""a"")[0].split(""b"")[0].split(; ""post"")[0].split('.'); return sum([int(d if len(d) > 0 else 0) * (100 ** (3 - n)); for n, d in enumerate(str_list[:3])]). def _blas_info():; config = np.__config__; if hasattr(config, 'blas_ilp64_opt_info'):; blas_info = config.blas_ilp64_opt_info; elif hasattr(config, 'blas_opt_info'):; blas_info = config.blas_opt_info; else:; blas_info = {}; _has_lib_key = 'libraries' in blas_info.keys(); blas = None; if hasattr(config,'mkl_info') or \; (_has_lib_key and any('mkl' in lib for lib in blas_info['libraries'])):; blas = 'INTEL MKL'; elif hasattr(config,'openblas_info') or \; (_has_lib_key and any('openblas' in lib for lib in blas_info['libraries'])):; blas = 'OPENBLAS'; elif 'extra_link_args' in blas_info.keys() and ('-Wl,Accelerate' in blas_info['extra_link_args']):; blas = 'Accelerate'; else:; blas = 'Generic'; return blas. def available_cpu_count():; """"""; Get the number of cpus.; It tries to only get the number available to qutip.; """"""; import os; import multiprocessing; try:; import psutil; except ImportError:; psutil = None; num_cpu = 0. if 'QUTIP_NUM_PROCESSES' in os.environ:; # We consider QUTIP_NUM_PROCESSES=0 as unset.; num_cpu = int(os.environ['QUTIP_NUM_PROCESSES']). if num_cpu == 0 and 'SLURM_CPUS_PER_TASK' in os.environ:; num_cpu = int(os.environ['SLURM_CPUS_PER_TASK']). if num_cpu == 0 and hasattr(os, 'sched_getaffinity'):; num_cpu = len(os.sched_getaffinity(0)). if (; num_cpu == 0; and psutil is not None; and hasattr(psutil.Process(), ""cpu_affinity""); ):; num_cpu = len(psutil.Process().cpu_affinity()). if num_cpu == 0:; try:; num_cpu = multiprocessing.cpu_count(); except NotImplementedError:; pass. return num_cpu or 1. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/utilities.html
https://qutip.org/docs/4.7/modules/qutip/utilities.html:3648,Energy Efficiency,energy,energy,3648,"+ j3))), np.int32); sign = (-1) ** (vmin + j2 + m2); for i,v in enumerate(range(vmin, vmax + 1)):; factor = s_factors[i,:]; _factorial_prod(j2 + j3 + m1 - v, factor); _factorial_prod(j1 - m1 + v, factor); _factorial_div(j3 - j1 + j2 - v, factor); _factorial_div(j3 + m3 - v, factor); _factorial_div(v + j1 - j2 - m3, factor); _factorial_div(v, factor); common_denominator = -np.min(s_factors, axis=0); numerators = s_factors + common_denominator; S = sum([(-1)**i * _to_long(vec) for i,vec in enumerate(numerators)]) * \; sign / _to_long(common_denominator); return C * S. # -----------------------------------------------------------------------------; # Functions for unit conversions; #; _e = 1.602176565e-19 # C; _kB = 1.3806488e-23 # J/K; _h = 6.62606957e-34 # Js. _unit_factor_tbl = {; # ""unit"": ""factor that convert argument from unit 'unit' to Joule""; ""J"": 1.0,; ""eV"": _e,; ""meV"": 1.0e-3 * _e,; ""GHz"": 1.0e9 * _h,; ""mK"": 1.0e-3 * _kB,; }. [docs]def convert_unit(value, orig=""meV"", to=""GHz""):; """"""; Convert an energy from unit `orig` to unit `to`. Parameters; ----------; value : float / array; The energy in the old unit. orig : string; The name of the original unit (""J"", ""eV"", ""meV"", ""GHz"", ""mK""). to : string; The name of the new unit (""J"", ""eV"", ""meV"", ""GHz"", ""mK""). Returns; -------; value_new_unit : float / array; The energy in the new unit.; """"""; if orig not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % orig). if to not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % to). return value * (_unit_factor_tbl[orig] / _unit_factor_tbl[to]). def convert_GHz_to_meV(w):; """"""; Convert an energy from unit GHz to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 GHz = 4.1357e-6 eV = 4.1357e-3 meV; w_meV = w * 4.1357e-3; return w_meV. def convert_meV_to_GHz(w):; """"""; Convert an energy from unit meV to unit GHz. Parameters; ----------; w : flo",MatchSource.WIKI,docs/4.7/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/utilities.html
https://qutip.org/docs/4.7/modules/qutip/utilities.html:3737,Energy Efficiency,energy,energy,3737,"+ 1)):; factor = s_factors[i,:]; _factorial_prod(j2 + j3 + m1 - v, factor); _factorial_prod(j1 - m1 + v, factor); _factorial_div(j3 - j1 + j2 - v, factor); _factorial_div(j3 + m3 - v, factor); _factorial_div(v + j1 - j2 - m3, factor); _factorial_div(v, factor); common_denominator = -np.min(s_factors, axis=0); numerators = s_factors + common_denominator; S = sum([(-1)**i * _to_long(vec) for i,vec in enumerate(numerators)]) * \; sign / _to_long(common_denominator); return C * S. # -----------------------------------------------------------------------------; # Functions for unit conversions; #; _e = 1.602176565e-19 # C; _kB = 1.3806488e-23 # J/K; _h = 6.62606957e-34 # Js. _unit_factor_tbl = {; # ""unit"": ""factor that convert argument from unit 'unit' to Joule""; ""J"": 1.0,; ""eV"": _e,; ""meV"": 1.0e-3 * _e,; ""GHz"": 1.0e9 * _h,; ""mK"": 1.0e-3 * _kB,; }. [docs]def convert_unit(value, orig=""meV"", to=""GHz""):; """"""; Convert an energy from unit `orig` to unit `to`. Parameters; ----------; value : float / array; The energy in the old unit. orig : string; The name of the original unit (""J"", ""eV"", ""meV"", ""GHz"", ""mK""). to : string; The name of the new unit (""J"", ""eV"", ""meV"", ""GHz"", ""mK""). Returns; -------; value_new_unit : float / array; The energy in the new unit.; """"""; if orig not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % orig). if to not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % to). return value * (_unit_factor_tbl[orig] / _unit_factor_tbl[to]). def convert_GHz_to_meV(w):; """"""; Convert an energy from unit GHz to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 GHz = 4.1357e-6 eV = 4.1357e-3 meV; w_meV = w * 4.1357e-3; return w_meV. def convert_meV_to_GHz(w):; """"""; Convert an energy from unit meV to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The en",MatchSource.WIKI,docs/4.7/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/utilities.html
https://qutip.org/docs/4.7/modules/qutip/utilities.html:3964,Energy Efficiency,energy,energy,3964,"factor); _factorial_div(v, factor); common_denominator = -np.min(s_factors, axis=0); numerators = s_factors + common_denominator; S = sum([(-1)**i * _to_long(vec) for i,vec in enumerate(numerators)]) * \; sign / _to_long(common_denominator); return C * S. # -----------------------------------------------------------------------------; # Functions for unit conversions; #; _e = 1.602176565e-19 # C; _kB = 1.3806488e-23 # J/K; _h = 6.62606957e-34 # Js. _unit_factor_tbl = {; # ""unit"": ""factor that convert argument from unit 'unit' to Joule""; ""J"": 1.0,; ""eV"": _e,; ""meV"": 1.0e-3 * _e,; ""GHz"": 1.0e9 * _h,; ""mK"": 1.0e-3 * _kB,; }. [docs]def convert_unit(value, orig=""meV"", to=""GHz""):; """"""; Convert an energy from unit `orig` to unit `to`. Parameters; ----------; value : float / array; The energy in the old unit. orig : string; The name of the original unit (""J"", ""eV"", ""meV"", ""GHz"", ""mK""). to : string; The name of the new unit (""J"", ""eV"", ""meV"", ""GHz"", ""mK""). Returns; -------; value_new_unit : float / array; The energy in the new unit.; """"""; if orig not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % orig). if to not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % to). return value * (_unit_factor_tbl[orig] / _unit_factor_tbl[to]). def convert_GHz_to_meV(w):; """"""; Convert an energy from unit GHz to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 GHz = 4.1357e-6 eV = 4.1357e-3 meV; w_meV = w * 4.1357e-3; return w_meV. def convert_meV_to_GHz(w):; """"""; Convert an energy from unit meV to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 meV = 1.0/4.1357e-3 GHz; w_GHz = w / 4.1357e-3; return w_GHz. def convert_J_to_meV(w):; """"""; Convert an energy from unit J to unit meV. Parameters; ----------; w : float / array; The energy in ",MatchSource.WIKI,docs/4.7/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/utilities.html
https://qutip.org/docs/4.7/modules/qutip/utilities.html:4260,Energy Efficiency,energy,energy,4260,"-----------------------------; # Functions for unit conversions; #; _e = 1.602176565e-19 # C; _kB = 1.3806488e-23 # J/K; _h = 6.62606957e-34 # Js. _unit_factor_tbl = {; # ""unit"": ""factor that convert argument from unit 'unit' to Joule""; ""J"": 1.0,; ""eV"": _e,; ""meV"": 1.0e-3 * _e,; ""GHz"": 1.0e9 * _h,; ""mK"": 1.0e-3 * _kB,; }. [docs]def convert_unit(value, orig=""meV"", to=""GHz""):; """"""; Convert an energy from unit `orig` to unit `to`. Parameters; ----------; value : float / array; The energy in the old unit. orig : string; The name of the original unit (""J"", ""eV"", ""meV"", ""GHz"", ""mK""). to : string; The name of the new unit (""J"", ""eV"", ""meV"", ""GHz"", ""mK""). Returns; -------; value_new_unit : float / array; The energy in the new unit.; """"""; if orig not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % orig). if to not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % to). return value * (_unit_factor_tbl[orig] / _unit_factor_tbl[to]). def convert_GHz_to_meV(w):; """"""; Convert an energy from unit GHz to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 GHz = 4.1357e-6 eV = 4.1357e-3 meV; w_meV = w * 4.1357e-3; return w_meV. def convert_meV_to_GHz(w):; """"""; Convert an energy from unit meV to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 meV = 1.0/4.1357e-3 GHz; w_GHz = w / 4.1357e-3; return w_GHz. def convert_J_to_meV(w):; """"""; Convert an energy from unit J to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_meV = 1000.0 * w / _e; return w_meV. def convert_meV_to_J(w):; """"""; Convert an energy from unit meV to unit J. Parameters; ----------; w : float / array; The energy in the old unit. Return",MatchSource.WIKI,docs/4.7/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/utilities.html
https://qutip.org/docs/4.7/modules/qutip/utilities.html:4341,Energy Efficiency,energy,energy,4341,".602176565e-19 # C; _kB = 1.3806488e-23 # J/K; _h = 6.62606957e-34 # Js. _unit_factor_tbl = {; # ""unit"": ""factor that convert argument from unit 'unit' to Joule""; ""J"": 1.0,; ""eV"": _e,; ""meV"": 1.0e-3 * _e,; ""GHz"": 1.0e9 * _h,; ""mK"": 1.0e-3 * _kB,; }. [docs]def convert_unit(value, orig=""meV"", to=""GHz""):; """"""; Convert an energy from unit `orig` to unit `to`. Parameters; ----------; value : float / array; The energy in the old unit. orig : string; The name of the original unit (""J"", ""eV"", ""meV"", ""GHz"", ""mK""). to : string; The name of the new unit (""J"", ""eV"", ""meV"", ""GHz"", ""mK""). Returns; -------; value_new_unit : float / array; The energy in the new unit.; """"""; if orig not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % orig). if to not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % to). return value * (_unit_factor_tbl[orig] / _unit_factor_tbl[to]). def convert_GHz_to_meV(w):; """"""; Convert an energy from unit GHz to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 GHz = 4.1357e-6 eV = 4.1357e-3 meV; w_meV = w * 4.1357e-3; return w_meV. def convert_meV_to_GHz(w):; """"""; Convert an energy from unit meV to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 meV = 1.0/4.1357e-3 GHz; w_GHz = w / 4.1357e-3; return w_GHz. def convert_J_to_meV(w):; """"""; Convert an energy from unit J to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_meV = 1000.0 * w / _e; return w_meV. def convert_meV_to_J(w):; """"""; Convert an energy from unit meV to unit J. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; #",MatchSource.WIKI,docs/4.7/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/utilities.html
https://qutip.org/docs/4.7/modules/qutip/utilities.html:4415,Energy Efficiency,energy,energy,4415,"_unit_factor_tbl = {; # ""unit"": ""factor that convert argument from unit 'unit' to Joule""; ""J"": 1.0,; ""eV"": _e,; ""meV"": 1.0e-3 * _e,; ""GHz"": 1.0e9 * _h,; ""mK"": 1.0e-3 * _kB,; }. [docs]def convert_unit(value, orig=""meV"", to=""GHz""):; """"""; Convert an energy from unit `orig` to unit `to`. Parameters; ----------; value : float / array; The energy in the old unit. orig : string; The name of the original unit (""J"", ""eV"", ""meV"", ""GHz"", ""mK""). to : string; The name of the new unit (""J"", ""eV"", ""meV"", ""GHz"", ""mK""). Returns; -------; value_new_unit : float / array; The energy in the new unit.; """"""; if orig not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % orig). if to not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % to). return value * (_unit_factor_tbl[orig] / _unit_factor_tbl[to]). def convert_GHz_to_meV(w):; """"""; Convert an energy from unit GHz to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 GHz = 4.1357e-6 eV = 4.1357e-3 meV; w_meV = w * 4.1357e-3; return w_meV. def convert_meV_to_GHz(w):; """"""; Convert an energy from unit meV to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 meV = 1.0/4.1357e-3 GHz; w_GHz = w / 4.1357e-3; return w_GHz. def convert_J_to_meV(w):; """"""; Convert an energy from unit J to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_meV = 1000.0 * w / _e; return w_meV. def convert_meV_to_J(w):; """"""; Convert an energy from unit meV to unit J. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_J = 0.001 * w * _e; return w_J. def convert_meV_t",MatchSource.WIKI,docs/4.7/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/utilities.html
https://qutip.org/docs/4.7/modules/qutip/utilities.html:4566,Energy Efficiency,energy,energy,4566,"1.0e-3 * _kB,; }. [docs]def convert_unit(value, orig=""meV"", to=""GHz""):; """"""; Convert an energy from unit `orig` to unit `to`. Parameters; ----------; value : float / array; The energy in the old unit. orig : string; The name of the original unit (""J"", ""eV"", ""meV"", ""GHz"", ""mK""). to : string; The name of the new unit (""J"", ""eV"", ""meV"", ""GHz"", ""mK""). Returns; -------; value_new_unit : float / array; The energy in the new unit.; """"""; if orig not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % orig). if to not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % to). return value * (_unit_factor_tbl[orig] / _unit_factor_tbl[to]). def convert_GHz_to_meV(w):; """"""; Convert an energy from unit GHz to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 GHz = 4.1357e-6 eV = 4.1357e-3 meV; w_meV = w * 4.1357e-3; return w_meV. def convert_meV_to_GHz(w):; """"""; Convert an energy from unit meV to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 meV = 1.0/4.1357e-3 GHz; w_GHz = w / 4.1357e-3; return w_GHz. def convert_J_to_meV(w):; """"""; Convert an energy from unit J to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_meV = 1000.0 * w / _e; return w_meV. def convert_meV_to_J(w):; """"""; Convert an energy from unit meV to unit J. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_J = 0.001 * w * _e; return w_J. def convert_meV_to_mK(w):; """"""; Convert an energy from unit meV to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit ",MatchSource.WIKI,docs/4.7/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/utilities.html
https://qutip.org/docs/4.7/modules/qutip/utilities.html:4647,Energy Efficiency,energy,energy,4647,"""; Convert an energy from unit `orig` to unit `to`. Parameters; ----------; value : float / array; The energy in the old unit. orig : string; The name of the original unit (""J"", ""eV"", ""meV"", ""GHz"", ""mK""). to : string; The name of the new unit (""J"", ""eV"", ""meV"", ""GHz"", ""mK""). Returns; -------; value_new_unit : float / array; The energy in the new unit.; """"""; if orig not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % orig). if to not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % to). return value * (_unit_factor_tbl[orig] / _unit_factor_tbl[to]). def convert_GHz_to_meV(w):; """"""; Convert an energy from unit GHz to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 GHz = 4.1357e-6 eV = 4.1357e-3 meV; w_meV = w * 4.1357e-3; return w_meV. def convert_meV_to_GHz(w):; """"""; Convert an energy from unit meV to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 meV = 1.0/4.1357e-3 GHz; w_GHz = w / 4.1357e-3; return w_GHz. def convert_J_to_meV(w):; """"""; Convert an energy from unit J to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_meV = 1000.0 * w / _e; return w_meV. def convert_meV_to_J(w):; """"""; Convert an energy from unit meV to unit J. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_J = 0.001 * w * _e; return w_J. def convert_meV_to_mK(w):; """"""; Convert an energy from unit meV to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 me",MatchSource.WIKI,docs/4.7/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/utilities.html
https://qutip.org/docs/4.7/modules/qutip/utilities.html:4721,Energy Efficiency,energy,energy,4721,"-; value : float / array; The energy in the old unit. orig : string; The name of the original unit (""J"", ""eV"", ""meV"", ""GHz"", ""mK""). to : string; The name of the new unit (""J"", ""eV"", ""meV"", ""GHz"", ""mK""). Returns; -------; value_new_unit : float / array; The energy in the new unit.; """"""; if orig not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % orig). if to not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % to). return value * (_unit_factor_tbl[orig] / _unit_factor_tbl[to]). def convert_GHz_to_meV(w):; """"""; Convert an energy from unit GHz to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 GHz = 4.1357e-6 eV = 4.1357e-3 meV; w_meV = w * 4.1357e-3; return w_meV. def convert_meV_to_GHz(w):; """"""; Convert an energy from unit meV to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 meV = 1.0/4.1357e-3 GHz; w_GHz = w / 4.1357e-3; return w_GHz. def convert_J_to_meV(w):; """"""; Convert an energy from unit J to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_meV = 1000.0 * w / _e; return w_meV. def convert_meV_to_J(w):; """"""; Convert an energy from unit meV to unit J. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_J = 0.001 * w * _e; return w_J. def convert_meV_to_mK(w):; """"""; Convert an energy from unit meV to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_mK = w / 0.0000861740; return w_mK. def convert_mK_to_meV(w):; """""";",MatchSource.WIKI,docs/4.7/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/utilities.html
https://qutip.org/docs/4.7/modules/qutip/utilities.html:4859,Energy Efficiency,energy,energy,4859,"he name of the new unit (""J"", ""eV"", ""meV"", ""GHz"", ""mK""). Returns; -------; value_new_unit : float / array; The energy in the new unit.; """"""; if orig not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % orig). if to not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % to). return value * (_unit_factor_tbl[orig] / _unit_factor_tbl[to]). def convert_GHz_to_meV(w):; """"""; Convert an energy from unit GHz to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 GHz = 4.1357e-6 eV = 4.1357e-3 meV; w_meV = w * 4.1357e-3; return w_meV. def convert_meV_to_GHz(w):; """"""; Convert an energy from unit meV to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 meV = 1.0/4.1357e-3 GHz; w_GHz = w / 4.1357e-3; return w_GHz. def convert_J_to_meV(w):; """"""; Convert an energy from unit J to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_meV = 1000.0 * w / _e; return w_meV. def convert_meV_to_J(w):; """"""; Convert an energy from unit meV to unit J. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_J = 0.001 * w * _e; return w_J. def convert_meV_to_mK(w):; """"""; Convert an energy from unit meV to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_mK = w / 0.0000861740; return w_mK. def convert_mK_to_meV(w):; """"""; Convert an energy from unit mK to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit :",MatchSource.WIKI,docs/4.7/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/utilities.html
https://qutip.org/docs/4.7/modules/qutip/utilities.html:4938,Energy Efficiency,energy,energy,4938,"-; value_new_unit : float / array; The energy in the new unit.; """"""; if orig not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % orig). if to not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % to). return value * (_unit_factor_tbl[orig] / _unit_factor_tbl[to]). def convert_GHz_to_meV(w):; """"""; Convert an energy from unit GHz to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 GHz = 4.1357e-6 eV = 4.1357e-3 meV; w_meV = w * 4.1357e-3; return w_meV. def convert_meV_to_GHz(w):; """"""; Convert an energy from unit meV to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 meV = 1.0/4.1357e-3 GHz; w_GHz = w / 4.1357e-3; return w_GHz. def convert_J_to_meV(w):; """"""; Convert an energy from unit J to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_meV = 1000.0 * w / _e; return w_meV. def convert_meV_to_J(w):; """"""; Convert an energy from unit meV to unit J. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_J = 0.001 * w * _e; return w_J. def convert_meV_to_mK(w):; """"""; Convert an energy from unit meV to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_mK = w / 0.0000861740; return w_mK. def convert_mK_to_meV(w):; """"""; Convert an energy from unit mK to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 m",MatchSource.WIKI,docs/4.7/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/utilities.html
https://qutip.org/docs/4.7/modules/qutip/utilities.html:5012,Energy Efficiency,energy,energy,5012,"rig not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % orig). if to not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % to). return value * (_unit_factor_tbl[orig] / _unit_factor_tbl[to]). def convert_GHz_to_meV(w):; """"""; Convert an energy from unit GHz to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 GHz = 4.1357e-6 eV = 4.1357e-3 meV; w_meV = w * 4.1357e-3; return w_meV. def convert_meV_to_GHz(w):; """"""; Convert an energy from unit meV to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 meV = 1.0/4.1357e-3 GHz; w_GHz = w / 4.1357e-3; return w_GHz. def convert_J_to_meV(w):; """"""; Convert an energy from unit J to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_meV = 1000.0 * w / _e; return w_meV. def convert_meV_to_J(w):; """"""; Convert an energy from unit meV to unit J. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_J = 0.001 * w * _e; return w_J. def convert_meV_to_mK(w):; """"""; Convert an energy from unit meV to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_mK = w / 0.0000861740; return w_mK. def convert_mK_to_meV(w):; """"""; Convert an energy from unit mK to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_meV = w * 0.0000861740; return w_meV. def convert_GHz_to_mK(w):; """,MatchSource.WIKI,docs/4.7/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/utilities.html
https://qutip.org/docs/4.7/modules/qutip/utilities.html:5145,Energy Efficiency,energy,energy,5145,"t %s"" % to). return value * (_unit_factor_tbl[orig] / _unit_factor_tbl[to]). def convert_GHz_to_meV(w):; """"""; Convert an energy from unit GHz to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 GHz = 4.1357e-6 eV = 4.1357e-3 meV; w_meV = w * 4.1357e-3; return w_meV. def convert_meV_to_GHz(w):; """"""; Convert an energy from unit meV to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 meV = 1.0/4.1357e-3 GHz; w_GHz = w / 4.1357e-3; return w_GHz. def convert_J_to_meV(w):; """"""; Convert an energy from unit J to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_meV = 1000.0 * w / _e; return w_meV. def convert_meV_to_J(w):; """"""; Convert an energy from unit meV to unit J. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_J = 0.001 * w * _e; return w_J. def convert_meV_to_mK(w):; """"""; Convert an energy from unit meV to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_mK = w / 0.0000861740; return w_mK. def convert_mK_to_meV(w):; """"""; Convert an energy from unit mK to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_meV = w * 0.0000861740; return w_meV. def convert_GHz_to_mK(w):; """"""; Convert an energy from unit GHz to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_ne",MatchSource.WIKI,docs/4.7/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/utilities.html
https://qutip.org/docs/4.7/modules/qutip/utilities.html:5224,Energy Efficiency,energy,energy,5224,"o]). def convert_GHz_to_meV(w):; """"""; Convert an energy from unit GHz to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 GHz = 4.1357e-6 eV = 4.1357e-3 meV; w_meV = w * 4.1357e-3; return w_meV. def convert_meV_to_GHz(w):; """"""; Convert an energy from unit meV to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 meV = 1.0/4.1357e-3 GHz; w_GHz = w / 4.1357e-3; return w_GHz. def convert_J_to_meV(w):; """"""; Convert an energy from unit J to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_meV = 1000.0 * w / _e; return w_meV. def convert_meV_to_J(w):; """"""; Convert an energy from unit meV to unit J. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_J = 0.001 * w * _e; return w_J. def convert_meV_to_mK(w):; """"""; Convert an energy from unit meV to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_mK = w / 0.0000861740; return w_mK. def convert_mK_to_meV(w):; """"""; Convert an energy from unit mK to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_meV = w * 0.0000861740; return w_meV. def convert_GHz_to_mK(w):; """"""; Convert an energy from unit GHz to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # h v [Hz] = kB",MatchSource.WIKI,docs/4.7/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/utilities.html
https://qutip.org/docs/4.7/modules/qutip/utilities.html:5298,Energy Efficiency,energy,energy,5298,"unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 GHz = 4.1357e-6 eV = 4.1357e-3 meV; w_meV = w * 4.1357e-3; return w_meV. def convert_meV_to_GHz(w):; """"""; Convert an energy from unit meV to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 meV = 1.0/4.1357e-3 GHz; w_GHz = w / 4.1357e-3; return w_GHz. def convert_J_to_meV(w):; """"""; Convert an energy from unit J to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_meV = 1000.0 * w / _e; return w_meV. def convert_meV_to_J(w):; """"""; Convert an energy from unit meV to unit J. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_J = 0.001 * w * _e; return w_J. def convert_meV_to_mK(w):; """"""; Convert an energy from unit meV to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_mK = w / 0.0000861740; return w_mK. def convert_mK_to_meV(w):; """"""; Convert an energy from unit mK to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_meV = w * 0.0000861740; return w_meV. def convert_GHz_to_mK(w):; """"""; Convert an energy from unit GHz to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # h v [Hz] = kB T [K]; # h 1e9 v [GHz] = kB 1e-3 T [mK]; # T [mK] = 1e12 * (h/kB) * v [",MatchSource.WIKI,docs/4.7/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/utilities.html
https://qutip.org/docs/4.7/modules/qutip/utilities.html:5427,Energy Efficiency,energy,energy,5427," in the new unit.; """"""; # 1 GHz = 4.1357e-6 eV = 4.1357e-3 meV; w_meV = w * 4.1357e-3; return w_meV. def convert_meV_to_GHz(w):; """"""; Convert an energy from unit meV to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 meV = 1.0/4.1357e-3 GHz; w_GHz = w / 4.1357e-3; return w_GHz. def convert_J_to_meV(w):; """"""; Convert an energy from unit J to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_meV = 1000.0 * w / _e; return w_meV. def convert_meV_to_J(w):; """"""; Convert an energy from unit meV to unit J. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_J = 0.001 * w * _e; return w_J. def convert_meV_to_mK(w):; """"""; Convert an energy from unit meV to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_mK = w / 0.0000861740; return w_mK. def convert_mK_to_meV(w):; """"""; Convert an energy from unit mK to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_meV = w * 0.0000861740; return w_meV. def convert_GHz_to_mK(w):; """"""; Convert an energy from unit GHz to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # h v [Hz] = kB T [K]; # h 1e9 v [GHz] = kB 1e-3 T [mK]; # T [mK] = 1e12 * (h/kB) * v [GHz]; w_mK = w * 1.0e12 * (_h / _kB); return w_mK. def convert_mK_to_GHz(w):; """"""; Convert an energy from unit mK to unit GHz. Parameters",MatchSource.WIKI,docs/4.7/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/utilities.html
https://qutip.org/docs/4.7/modules/qutip/utilities.html:5507,Energy Efficiency,energy,energy,5507," * 4.1357e-3; return w_meV. def convert_meV_to_GHz(w):; """"""; Convert an energy from unit meV to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 meV = 1.0/4.1357e-3 GHz; w_GHz = w / 4.1357e-3; return w_GHz. def convert_J_to_meV(w):; """"""; Convert an energy from unit J to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_meV = 1000.0 * w / _e; return w_meV. def convert_meV_to_J(w):; """"""; Convert an energy from unit meV to unit J. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_J = 0.001 * w * _e; return w_J. def convert_meV_to_mK(w):; """"""; Convert an energy from unit meV to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_mK = w / 0.0000861740; return w_mK. def convert_mK_to_meV(w):; """"""; Convert an energy from unit mK to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_meV = w * 0.0000861740; return w_meV. def convert_GHz_to_mK(w):; """"""; Convert an energy from unit GHz to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # h v [Hz] = kB T [K]; # h 1e9 v [GHz] = kB 1e-3 T [mK]; # T [mK] = 1e12 * (h/kB) * v [GHz]; w_mK = w * 1.0e12 * (_h / _kB); return w_mK. def convert_mK_to_GHz(w):; """"""; Convert an energy from unit mK to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; ----",MatchSource.WIKI,docs/4.7/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/utilities.html
https://qutip.org/docs/4.7/modules/qutip/utilities.html:5581,Energy Efficiency,energy,energy,5581,"nergy from unit meV to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 meV = 1.0/4.1357e-3 GHz; w_GHz = w / 4.1357e-3; return w_GHz. def convert_J_to_meV(w):; """"""; Convert an energy from unit J to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_meV = 1000.0 * w / _e; return w_meV. def convert_meV_to_J(w):; """"""; Convert an energy from unit meV to unit J. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_J = 0.001 * w * _e; return w_J. def convert_meV_to_mK(w):; """"""; Convert an energy from unit meV to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_mK = w / 0.0000861740; return w_mK. def convert_mK_to_meV(w):; """"""; Convert an energy from unit mK to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_meV = w * 0.0000861740; return w_meV. def convert_GHz_to_mK(w):; """"""; Convert an energy from unit GHz to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # h v [Hz] = kB T [K]; # h 1e9 v [GHz] = kB 1e-3 T [mK]; # T [mK] = 1e12 * (h/kB) * v [GHz]; w_mK = w * 1.0e12 * (_h / _kB); return w_mK. def convert_mK_to_GHz(w):; """"""; Convert an energy from unit mK to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit. """"""; w_GHz ",MatchSource.WIKI,docs/4.7/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/utilities.html
https://qutip.org/docs/4.7/modules/qutip/utilities.html:5719,Energy Efficiency,energy,energy,5719,"ay; The energy in the new unit.; """"""; # 1 meV = 1.0/4.1357e-3 GHz; w_GHz = w / 4.1357e-3; return w_GHz. def convert_J_to_meV(w):; """"""; Convert an energy from unit J to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_meV = 1000.0 * w / _e; return w_meV. def convert_meV_to_J(w):; """"""; Convert an energy from unit meV to unit J. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_J = 0.001 * w * _e; return w_J. def convert_meV_to_mK(w):; """"""; Convert an energy from unit meV to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_mK = w / 0.0000861740; return w_mK. def convert_mK_to_meV(w):; """"""; Convert an energy from unit mK to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_meV = w * 0.0000861740; return w_meV. def convert_GHz_to_mK(w):; """"""; Convert an energy from unit GHz to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # h v [Hz] = kB T [K]; # h 1e9 v [GHz] = kB 1e-3 T [mK]; # T [mK] = 1e12 * (h/kB) * v [GHz]; w_mK = w * 1.0e12 * (_h / _kB); return w_mK. def convert_mK_to_GHz(w):; """"""; Convert an energy from unit mK to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit. """"""; w_GHz = w * 1.0e-12 * (_kB / _h); return w_GHz. def _version2int(version_string):; str_list = version_string.split(; ""-dev"")[0].split(""rc"")[0].split(""a""",MatchSource.WIKI,docs/4.7/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/utilities.html
https://qutip.org/docs/4.7/modules/qutip/utilities.html:5799,Energy Efficiency,energy,energy,5799,"= w / 4.1357e-3; return w_GHz. def convert_J_to_meV(w):; """"""; Convert an energy from unit J to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_meV = 1000.0 * w / _e; return w_meV. def convert_meV_to_J(w):; """"""; Convert an energy from unit meV to unit J. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_J = 0.001 * w * _e; return w_J. def convert_meV_to_mK(w):; """"""; Convert an energy from unit meV to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_mK = w / 0.0000861740; return w_mK. def convert_mK_to_meV(w):; """"""; Convert an energy from unit mK to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_meV = w * 0.0000861740; return w_meV. def convert_GHz_to_mK(w):; """"""; Convert an energy from unit GHz to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # h v [Hz] = kB T [K]; # h 1e9 v [GHz] = kB 1e-3 T [mK]; # T [mK] = 1e12 * (h/kB) * v [GHz]; w_mK = w * 1.0e12 * (_h / _kB); return w_mK. def convert_mK_to_GHz(w):; """"""; Convert an energy from unit mK to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit. """"""; w_GHz = w * 1.0e-12 * (_kB / _h); return w_GHz. def _version2int(version_string):; str_list = version_string.split(; ""-dev"")[0].split(""rc"")[0].split(""a"")[0].split(""b"")[0].split(; ""post"")[0].split('.'); return sum([int(d if len",MatchSource.WIKI,docs/4.7/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/utilities.html
https://qutip.org/docs/4.7/modules/qutip/utilities.html:5873,Energy Efficiency,energy,energy,5873,"energy from unit J to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_meV = 1000.0 * w / _e; return w_meV. def convert_meV_to_J(w):; """"""; Convert an energy from unit meV to unit J. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_J = 0.001 * w * _e; return w_J. def convert_meV_to_mK(w):; """"""; Convert an energy from unit meV to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_mK = w / 0.0000861740; return w_mK. def convert_mK_to_meV(w):; """"""; Convert an energy from unit mK to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_meV = w * 0.0000861740; return w_meV. def convert_GHz_to_mK(w):; """"""; Convert an energy from unit GHz to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # h v [Hz] = kB T [K]; # h 1e9 v [GHz] = kB 1e-3 T [mK]; # T [mK] = 1e12 * (h/kB) * v [GHz]; w_mK = w * 1.0e12 * (_h / _kB); return w_mK. def convert_mK_to_GHz(w):; """"""; Convert an energy from unit mK to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit. """"""; w_GHz = w * 1.0e-12 * (_kB / _h); return w_GHz. def _version2int(version_string):; str_list = version_string.split(; ""-dev"")[0].split(""rc"")[0].split(""a"")[0].split(""b"")[0].split(; ""post"")[0].split('.'); return sum([int(d if len(d) > 0 else 0) * (100 ** (3 - n)); for n, d in enumerate(str_list[:3])]",MatchSource.WIKI,docs/4.7/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/utilities.html
https://qutip.org/docs/4.7/modules/qutip/utilities.html:6013,Energy Efficiency,energy,energy,6013," The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_meV = 1000.0 * w / _e; return w_meV. def convert_meV_to_J(w):; """"""; Convert an energy from unit meV to unit J. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_J = 0.001 * w * _e; return w_J. def convert_meV_to_mK(w):; """"""; Convert an energy from unit meV to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_mK = w / 0.0000861740; return w_mK. def convert_mK_to_meV(w):; """"""; Convert an energy from unit mK to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_meV = w * 0.0000861740; return w_meV. def convert_GHz_to_mK(w):; """"""; Convert an energy from unit GHz to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # h v [Hz] = kB T [K]; # h 1e9 v [GHz] = kB 1e-3 T [mK]; # T [mK] = 1e12 * (h/kB) * v [GHz]; w_mK = w * 1.0e12 * (_h / _kB); return w_mK. def convert_mK_to_GHz(w):; """"""; Convert an energy from unit mK to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit. """"""; w_GHz = w * 1.0e-12 * (_kB / _h); return w_GHz. def _version2int(version_string):; str_list = version_string.split(; ""-dev"")[0].split(""rc"")[0].split(""a"")[0].split(""b"")[0].split(; ""post"")[0].split('.'); return sum([int(d if len(d) > 0 else 0) * (100 ** (3 - n)); for n, d in enumerate(str_list[:3])]). def _blas_info():; config = np.__config__; if hasattr(config, 'blas_ilp64_opt_info'):; blas_info = config.blas_ilp64_opt_info; elif hasattr(confi",MatchSource.WIKI,docs/4.7/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/utilities.html
https://qutip.org/docs/4.7/modules/qutip/utilities.html:6093,Energy Efficiency,energy,energy,6093," w / _e; return w_meV. def convert_meV_to_J(w):; """"""; Convert an energy from unit meV to unit J. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_J = 0.001 * w * _e; return w_J. def convert_meV_to_mK(w):; """"""; Convert an energy from unit meV to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_mK = w / 0.0000861740; return w_mK. def convert_mK_to_meV(w):; """"""; Convert an energy from unit mK to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_meV = w * 0.0000861740; return w_meV. def convert_GHz_to_mK(w):; """"""; Convert an energy from unit GHz to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # h v [Hz] = kB T [K]; # h 1e9 v [GHz] = kB 1e-3 T [mK]; # T [mK] = 1e12 * (h/kB) * v [GHz]; w_mK = w * 1.0e12 * (_h / _kB); return w_mK. def convert_mK_to_GHz(w):; """"""; Convert an energy from unit mK to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit. """"""; w_GHz = w * 1.0e-12 * (_kB / _h); return w_GHz. def _version2int(version_string):; str_list = version_string.split(; ""-dev"")[0].split(""rc"")[0].split(""a"")[0].split(""b"")[0].split(; ""post"")[0].split('.'); return sum([int(d if len(d) > 0 else 0) * (100 ** (3 - n)); for n, d in enumerate(str_list[:3])]). def _blas_info():; config = np.__config__; if hasattr(config, 'blas_ilp64_opt_info'):; blas_info = config.blas_ilp64_opt_info; elif hasattr(config, 'blas_opt_info'):; blas_info = config.blas_opt_info; else:; blas_info =",MatchSource.WIKI,docs/4.7/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/utilities.html
https://qutip.org/docs/4.7/modules/qutip/utilities.html:6167,Energy Efficiency,energy,energy,6167,"rom unit meV to unit J. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_J = 0.001 * w * _e; return w_J. def convert_meV_to_mK(w):; """"""; Convert an energy from unit meV to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_mK = w / 0.0000861740; return w_mK. def convert_mK_to_meV(w):; """"""; Convert an energy from unit mK to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_meV = w * 0.0000861740; return w_meV. def convert_GHz_to_mK(w):; """"""; Convert an energy from unit GHz to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # h v [Hz] = kB T [K]; # h 1e9 v [GHz] = kB 1e-3 T [mK]; # T [mK] = 1e12 * (h/kB) * v [GHz]; w_mK = w * 1.0e12 * (_h / _kB); return w_mK. def convert_mK_to_GHz(w):; """"""; Convert an energy from unit mK to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit. """"""; w_GHz = w * 1.0e-12 * (_kB / _h); return w_GHz. def _version2int(version_string):; str_list = version_string.split(; ""-dev"")[0].split(""rc"")[0].split(""a"")[0].split(""b"")[0].split(; ""post"")[0].split('.'); return sum([int(d if len(d) > 0 else 0) * (100 ** (3 - n)); for n, d in enumerate(str_list[:3])]). def _blas_info():; config = np.__config__; if hasattr(config, 'blas_ilp64_opt_info'):; blas_info = config.blas_ilp64_opt_info; elif hasattr(config, 'blas_opt_info'):; blas_info = config.blas_opt_info; else:; blas_info = {}; _has_lib_key = 'libraries' in blas_info.keys(); blas = None; if has",MatchSource.WIKI,docs/4.7/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/utilities.html
https://qutip.org/docs/4.7/modules/qutip/utilities.html:6378,Energy Efficiency,energy,energy,6378,"return w_J. def convert_meV_to_mK(w):; """"""; Convert an energy from unit meV to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_mK = w / 0.0000861740; return w_mK. def convert_mK_to_meV(w):; """"""; Convert an energy from unit mK to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_meV = w * 0.0000861740; return w_meV. def convert_GHz_to_mK(w):; """"""; Convert an energy from unit GHz to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # h v [Hz] = kB T [K]; # h 1e9 v [GHz] = kB 1e-3 T [mK]; # T [mK] = 1e12 * (h/kB) * v [GHz]; w_mK = w * 1.0e12 * (_h / _kB); return w_mK. def convert_mK_to_GHz(w):; """"""; Convert an energy from unit mK to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit. """"""; w_GHz = w * 1.0e-12 * (_kB / _h); return w_GHz. def _version2int(version_string):; str_list = version_string.split(; ""-dev"")[0].split(""rc"")[0].split(""a"")[0].split(""b"")[0].split(; ""post"")[0].split('.'); return sum([int(d if len(d) > 0 else 0) * (100 ** (3 - n)); for n, d in enumerate(str_list[:3])]). def _blas_info():; config = np.__config__; if hasattr(config, 'blas_ilp64_opt_info'):; blas_info = config.blas_ilp64_opt_info; elif hasattr(config, 'blas_opt_info'):; blas_info = config.blas_opt_info; else:; blas_info = {}; _has_lib_key = 'libraries' in blas_info.keys(); blas = None; if hasattr(config,'mkl_info') or \; (_has_lib_key and any('mkl' in lib for lib in blas_info['libraries'])):; blas = 'INTEL MKL'; elif hasattr(config,'openblas_info') or \; (_has_lib_key and any('openblas' in lib for lib in bl",MatchSource.WIKI,docs/4.7/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/utilities.html
https://qutip.org/docs/4.7/modules/qutip/utilities.html:6458,Energy Efficiency,energy,energy,6458,"eV to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_mK = w / 0.0000861740; return w_mK. def convert_mK_to_meV(w):; """"""; Convert an energy from unit mK to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_meV = w * 0.0000861740; return w_meV. def convert_GHz_to_mK(w):; """"""; Convert an energy from unit GHz to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # h v [Hz] = kB T [K]; # h 1e9 v [GHz] = kB 1e-3 T [mK]; # T [mK] = 1e12 * (h/kB) * v [GHz]; w_mK = w * 1.0e12 * (_h / _kB); return w_mK. def convert_mK_to_GHz(w):; """"""; Convert an energy from unit mK to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit. """"""; w_GHz = w * 1.0e-12 * (_kB / _h); return w_GHz. def _version2int(version_string):; str_list = version_string.split(; ""-dev"")[0].split(""rc"")[0].split(""a"")[0].split(""b"")[0].split(; ""post"")[0].split('.'); return sum([int(d if len(d) > 0 else 0) * (100 ** (3 - n)); for n, d in enumerate(str_list[:3])]). def _blas_info():; config = np.__config__; if hasattr(config, 'blas_ilp64_opt_info'):; blas_info = config.blas_ilp64_opt_info; elif hasattr(config, 'blas_opt_info'):; blas_info = config.blas_opt_info; else:; blas_info = {}; _has_lib_key = 'libraries' in blas_info.keys(); blas = None; if hasattr(config,'mkl_info') or \; (_has_lib_key and any('mkl' in lib for lib in blas_info['libraries'])):; blas = 'INTEL MKL'; elif hasattr(config,'openblas_info') or \; (_has_lib_key and any('openblas' in lib for lib in blas_info['libraries'])):; blas = 'OPENBLAS'; elif 'extra_link_args' in blas",MatchSource.WIKI,docs/4.7/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/utilities.html
https://qutip.org/docs/4.7/modules/qutip/utilities.html:6532,Energy Efficiency,energy,energy,6532,"he old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_mK = w / 0.0000861740; return w_mK. def convert_mK_to_meV(w):; """"""; Convert an energy from unit mK to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_meV = w * 0.0000861740; return w_meV. def convert_GHz_to_mK(w):; """"""; Convert an energy from unit GHz to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # h v [Hz] = kB T [K]; # h 1e9 v [GHz] = kB 1e-3 T [mK]; # T [mK] = 1e12 * (h/kB) * v [GHz]; w_mK = w * 1.0e12 * (_h / _kB); return w_mK. def convert_mK_to_GHz(w):; """"""; Convert an energy from unit mK to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit. """"""; w_GHz = w * 1.0e-12 * (_kB / _h); return w_GHz. def _version2int(version_string):; str_list = version_string.split(; ""-dev"")[0].split(""rc"")[0].split(""a"")[0].split(""b"")[0].split(; ""post"")[0].split('.'); return sum([int(d if len(d) > 0 else 0) * (100 ** (3 - n)); for n, d in enumerate(str_list[:3])]). def _blas_info():; config = np.__config__; if hasattr(config, 'blas_ilp64_opt_info'):; blas_info = config.blas_ilp64_opt_info; elif hasattr(config, 'blas_opt_info'):; blas_info = config.blas_opt_info; else:; blas_info = {}; _has_lib_key = 'libraries' in blas_info.keys(); blas = None; if hasattr(config,'mkl_info') or \; (_has_lib_key and any('mkl' in lib for lib in blas_info['libraries'])):; blas = 'INTEL MKL'; elif hasattr(config,'openblas_info') or \; (_has_lib_key and any('openblas' in lib for lib in blas_info['libraries'])):; blas = 'OPENBLAS'; elif 'extra_link_args' in blas_info.keys() and ('-Wl,Accelerate' in blas_info['extra_link_args']):; bl",MatchSource.WIKI,docs/4.7/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/utilities.html
https://qutip.org/docs/4.7/modules/qutip/utilities.html:1550,Modifiability,coupling,coupling,1550,"docs]def n_thermal(w, w_th):; """"""; Return the number of photons in thermal equilibrium for an harmonic; oscillator mode with frequency 'w', at the temperature described by; 'w_th' where :math:`\\omega_{\\rm th} = k_BT/\\hbar`. Parameters; ----------. w : *float* or *array*; Frequency of the oscillator. w_th : *float*; The temperature in units of frequency (or the same units as `w`). Returns; -------. n_avg : *float* or *array*. Return the number of average photons in thermal equilibrium for a; an oscillator with the given frequency and temperature. """""". if isinstance(w, np.ndarray):; return 1.0 / (np.exp(w / w_th) - 1.0). else:; if (w_th > 0) and np.exp(w / w_th) != 1.0:; return 1.0 / (np.exp(w / w_th) - 1.0); else:; return 0.0. def _factorial_prod(N, arr):; arr[:int(N)] += 1. def _factorial_div(N, arr):; arr[:int(N)] -= 1. def _to_long(arr):; prod = 1; for i, v in enumerate(arr):; prod *= (i+1)**int(v); return prod. [docs]def clebsch(j1, j2, j3, m1, m2, m3):; """"""Calculates the Clebsch-Gordon coefficient; for coupling (j1,m1) and (j2,m2) to give (j3,m3). Parameters; ----------; j1 : float; Total angular momentum 1. j2 : float; Total angular momentum 2. j3 : float; Total angular momentum 3. m1 : float; z-component of angular momentum 1. m2 : float; z-component of angular momentum 2. m3 : float; z-component of angular momentum 3. Returns; -------; cg_coeff : float; Requested Clebsch-Gordan coefficient. """"""; if m3 != m1 + m2:; return 0; vmin = int(np.max([-j1 + j2 + m3, -j1 + m1, 0])); vmax = int(np.min([j2 + j3 + m1, j3 - j1 + j2, j3 + m3])). c_factor = np.zeros((int(j1 + j2 + j3 + 1)), np.int32); _factorial_prod(j3 + j1 - j2, c_factor); _factorial_prod(j3 - j1 + j2, c_factor); _factorial_prod(j1 + j2 - j3, c_factor); _factorial_prod(j3 + m3, c_factor); _factorial_prod(j3 - m3, c_factor); _factorial_div(j1 + j2 + j3 + 1, c_factor); _factorial_div(j1 - m1, c_factor); _factorial_div(j1 + m1, c_factor); _factorial_div(j2 - m2, c_factor); _factorial_div(j2 + m2, c_factor)",MatchSource.WIKI,docs/4.7/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/utilities.html
https://qutip.org/docs/4.7/modules/qutip/utilities.html:6881,Modifiability,config,config,6881,"gy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_meV = w * 0.0000861740; return w_meV. def convert_GHz_to_mK(w):; """"""; Convert an energy from unit GHz to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # h v [Hz] = kB T [K]; # h 1e9 v [GHz] = kB 1e-3 T [mK]; # T [mK] = 1e12 * (h/kB) * v [GHz]; w_mK = w * 1.0e12 * (_h / _kB); return w_mK. def convert_mK_to_GHz(w):; """"""; Convert an energy from unit mK to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit. """"""; w_GHz = w * 1.0e-12 * (_kB / _h); return w_GHz. def _version2int(version_string):; str_list = version_string.split(; ""-dev"")[0].split(""rc"")[0].split(""a"")[0].split(""b"")[0].split(; ""post"")[0].split('.'); return sum([int(d if len(d) > 0 else 0) * (100 ** (3 - n)); for n, d in enumerate(str_list[:3])]). def _blas_info():; config = np.__config__; if hasattr(config, 'blas_ilp64_opt_info'):; blas_info = config.blas_ilp64_opt_info; elif hasattr(config, 'blas_opt_info'):; blas_info = config.blas_opt_info; else:; blas_info = {}; _has_lib_key = 'libraries' in blas_info.keys(); blas = None; if hasattr(config,'mkl_info') or \; (_has_lib_key and any('mkl' in lib for lib in blas_info['libraries'])):; blas = 'INTEL MKL'; elif hasattr(config,'openblas_info') or \; (_has_lib_key and any('openblas' in lib for lib in blas_info['libraries'])):; blas = 'OPENBLAS'; elif 'extra_link_args' in blas_info.keys() and ('-Wl,Accelerate' in blas_info['extra_link_args']):; blas = 'Accelerate'; else:; blas = 'Generic'; return blas. def available_cpu_count():; """"""; Get the number of cpus.; It tries to only get the number available to qutip.; """"""; import os; import multiprocessing; try:; import psutil; except ImportError:; psutil = None; num_cpu = 0. if 'QUTIP_NUM_PROCESSES' in os.environ:; # We consider QUTIP_NUM_PROCESSES=0 as u",MatchSource.WIKI,docs/4.7/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/utilities.html
https://qutip.org/docs/4.7/modules/qutip/utilities.html:6916,Modifiability,config,config,6916,"w_meV = w * 0.0000861740; return w_meV. def convert_GHz_to_mK(w):; """"""; Convert an energy from unit GHz to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # h v [Hz] = kB T [K]; # h 1e9 v [GHz] = kB 1e-3 T [mK]; # T [mK] = 1e12 * (h/kB) * v [GHz]; w_mK = w * 1.0e12 * (_h / _kB); return w_mK. def convert_mK_to_GHz(w):; """"""; Convert an energy from unit mK to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit. """"""; w_GHz = w * 1.0e-12 * (_kB / _h); return w_GHz. def _version2int(version_string):; str_list = version_string.split(; ""-dev"")[0].split(""rc"")[0].split(""a"")[0].split(""b"")[0].split(; ""post"")[0].split('.'); return sum([int(d if len(d) > 0 else 0) * (100 ** (3 - n)); for n, d in enumerate(str_list[:3])]). def _blas_info():; config = np.__config__; if hasattr(config, 'blas_ilp64_opt_info'):; blas_info = config.blas_ilp64_opt_info; elif hasattr(config, 'blas_opt_info'):; blas_info = config.blas_opt_info; else:; blas_info = {}; _has_lib_key = 'libraries' in blas_info.keys(); blas = None; if hasattr(config,'mkl_info') or \; (_has_lib_key and any('mkl' in lib for lib in blas_info['libraries'])):; blas = 'INTEL MKL'; elif hasattr(config,'openblas_info') or \; (_has_lib_key and any('openblas' in lib for lib in blas_info['libraries'])):; blas = 'OPENBLAS'; elif 'extra_link_args' in blas_info.keys() and ('-Wl,Accelerate' in blas_info['extra_link_args']):; blas = 'Accelerate'; else:; blas = 'Generic'; return blas. def available_cpu_count():; """"""; Get the number of cpus.; It tries to only get the number available to qutip.; """"""; import os; import multiprocessing; try:; import psutil; except ImportError:; psutil = None; num_cpu = 0. if 'QUTIP_NUM_PROCESSES' in os.environ:; # We consider QUTIP_NUM_PROCESSES=0 as unset.; num_cpu = int(os.environ['QUTIP_NUM_PROCESSES']",MatchSource.WIKI,docs/4.7/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/utilities.html
https://qutip.org/docs/4.7/modules/qutip/utilities.html:6961,Modifiability,config,config,6961,"w_meV = w * 0.0000861740; return w_meV. def convert_GHz_to_mK(w):; """"""; Convert an energy from unit GHz to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # h v [Hz] = kB T [K]; # h 1e9 v [GHz] = kB 1e-3 T [mK]; # T [mK] = 1e12 * (h/kB) * v [GHz]; w_mK = w * 1.0e12 * (_h / _kB); return w_mK. def convert_mK_to_GHz(w):; """"""; Convert an energy from unit mK to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit. """"""; w_GHz = w * 1.0e-12 * (_kB / _h); return w_GHz. def _version2int(version_string):; str_list = version_string.split(; ""-dev"")[0].split(""rc"")[0].split(""a"")[0].split(""b"")[0].split(; ""post"")[0].split('.'); return sum([int(d if len(d) > 0 else 0) * (100 ** (3 - n)); for n, d in enumerate(str_list[:3])]). def _blas_info():; config = np.__config__; if hasattr(config, 'blas_ilp64_opt_info'):; blas_info = config.blas_ilp64_opt_info; elif hasattr(config, 'blas_opt_info'):; blas_info = config.blas_opt_info; else:; blas_info = {}; _has_lib_key = 'libraries' in blas_info.keys(); blas = None; if hasattr(config,'mkl_info') or \; (_has_lib_key and any('mkl' in lib for lib in blas_info['libraries'])):; blas = 'INTEL MKL'; elif hasattr(config,'openblas_info') or \; (_has_lib_key and any('openblas' in lib for lib in blas_info['libraries'])):; blas = 'OPENBLAS'; elif 'extra_link_args' in blas_info.keys() and ('-Wl,Accelerate' in blas_info['extra_link_args']):; blas = 'Accelerate'; else:; blas = 'Generic'; return blas. def available_cpu_count():; """"""; Get the number of cpus.; It tries to only get the number available to qutip.; """"""; import os; import multiprocessing; try:; import psutil; except ImportError:; psutil = None; num_cpu = 0. if 'QUTIP_NUM_PROCESSES' in os.environ:; # We consider QUTIP_NUM_PROCESSES=0 as unset.; num_cpu = int(os.environ['QUTIP_NUM_PROCESSES']",MatchSource.WIKI,docs/4.7/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/utilities.html
https://qutip.org/docs/4.7/modules/qutip/utilities.html:7002,Modifiability,config,config,7002,"t an energy from unit GHz to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # h v [Hz] = kB T [K]; # h 1e9 v [GHz] = kB 1e-3 T [mK]; # T [mK] = 1e12 * (h/kB) * v [GHz]; w_mK = w * 1.0e12 * (_h / _kB); return w_mK. def convert_mK_to_GHz(w):; """"""; Convert an energy from unit mK to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit. """"""; w_GHz = w * 1.0e-12 * (_kB / _h); return w_GHz. def _version2int(version_string):; str_list = version_string.split(; ""-dev"")[0].split(""rc"")[0].split(""a"")[0].split(""b"")[0].split(; ""post"")[0].split('.'); return sum([int(d if len(d) > 0 else 0) * (100 ** (3 - n)); for n, d in enumerate(str_list[:3])]). def _blas_info():; config = np.__config__; if hasattr(config, 'blas_ilp64_opt_info'):; blas_info = config.blas_ilp64_opt_info; elif hasattr(config, 'blas_opt_info'):; blas_info = config.blas_opt_info; else:; blas_info = {}; _has_lib_key = 'libraries' in blas_info.keys(); blas = None; if hasattr(config,'mkl_info') or \; (_has_lib_key and any('mkl' in lib for lib in blas_info['libraries'])):; blas = 'INTEL MKL'; elif hasattr(config,'openblas_info') or \; (_has_lib_key and any('openblas' in lib for lib in blas_info['libraries'])):; blas = 'OPENBLAS'; elif 'extra_link_args' in blas_info.keys() and ('-Wl,Accelerate' in blas_info['extra_link_args']):; blas = 'Accelerate'; else:; blas = 'Generic'; return blas. def available_cpu_count():; """"""; Get the number of cpus.; It tries to only get the number available to qutip.; """"""; import os; import multiprocessing; try:; import psutil; except ImportError:; psutil = None; num_cpu = 0. if 'QUTIP_NUM_PROCESSES' in os.environ:; # We consider QUTIP_NUM_PROCESSES=0 as unset.; num_cpu = int(os.environ['QUTIP_NUM_PROCESSES']). if num_cpu == 0 and 'SLURM_CPUS_PER_TASK' in os.environ:; num_cpu = int(os",MatchSource.WIKI,docs/4.7/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/utilities.html
https://qutip.org/docs/4.7/modules/qutip/utilities.html:7041,Modifiability,config,config,7041,"t an energy from unit GHz to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # h v [Hz] = kB T [K]; # h 1e9 v [GHz] = kB 1e-3 T [mK]; # T [mK] = 1e12 * (h/kB) * v [GHz]; w_mK = w * 1.0e12 * (_h / _kB); return w_mK. def convert_mK_to_GHz(w):; """"""; Convert an energy from unit mK to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit. """"""; w_GHz = w * 1.0e-12 * (_kB / _h); return w_GHz. def _version2int(version_string):; str_list = version_string.split(; ""-dev"")[0].split(""rc"")[0].split(""a"")[0].split(""b"")[0].split(; ""post"")[0].split('.'); return sum([int(d if len(d) > 0 else 0) * (100 ** (3 - n)); for n, d in enumerate(str_list[:3])]). def _blas_info():; config = np.__config__; if hasattr(config, 'blas_ilp64_opt_info'):; blas_info = config.blas_ilp64_opt_info; elif hasattr(config, 'blas_opt_info'):; blas_info = config.blas_opt_info; else:; blas_info = {}; _has_lib_key = 'libraries' in blas_info.keys(); blas = None; if hasattr(config,'mkl_info') or \; (_has_lib_key and any('mkl' in lib for lib in blas_info['libraries'])):; blas = 'INTEL MKL'; elif hasattr(config,'openblas_info') or \; (_has_lib_key and any('openblas' in lib for lib in blas_info['libraries'])):; blas = 'OPENBLAS'; elif 'extra_link_args' in blas_info.keys() and ('-Wl,Accelerate' in blas_info['extra_link_args']):; blas = 'Accelerate'; else:; blas = 'Generic'; return blas. def available_cpu_count():; """"""; Get the number of cpus.; It tries to only get the number available to qutip.; """"""; import os; import multiprocessing; try:; import psutil; except ImportError:; psutil = None; num_cpu = 0. if 'QUTIP_NUM_PROCESSES' in os.environ:; # We consider QUTIP_NUM_PROCESSES=0 as unset.; num_cpu = int(os.environ['QUTIP_NUM_PROCESSES']). if num_cpu == 0 and 'SLURM_CPUS_PER_TASK' in os.environ:; num_cpu = int(os",MatchSource.WIKI,docs/4.7/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/utilities.html
https://qutip.org/docs/4.7/modules/qutip/utilities.html:7158,Modifiability,config,config,7158," w_mK = w * 1.0e12 * (_h / _kB); return w_mK. def convert_mK_to_GHz(w):; """"""; Convert an energy from unit mK to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit. """"""; w_GHz = w * 1.0e-12 * (_kB / _h); return w_GHz. def _version2int(version_string):; str_list = version_string.split(; ""-dev"")[0].split(""rc"")[0].split(""a"")[0].split(""b"")[0].split(; ""post"")[0].split('.'); return sum([int(d if len(d) > 0 else 0) * (100 ** (3 - n)); for n, d in enumerate(str_list[:3])]). def _blas_info():; config = np.__config__; if hasattr(config, 'blas_ilp64_opt_info'):; blas_info = config.blas_ilp64_opt_info; elif hasattr(config, 'blas_opt_info'):; blas_info = config.blas_opt_info; else:; blas_info = {}; _has_lib_key = 'libraries' in blas_info.keys(); blas = None; if hasattr(config,'mkl_info') or \; (_has_lib_key and any('mkl' in lib for lib in blas_info['libraries'])):; blas = 'INTEL MKL'; elif hasattr(config,'openblas_info') or \; (_has_lib_key and any('openblas' in lib for lib in blas_info['libraries'])):; blas = 'OPENBLAS'; elif 'extra_link_args' in blas_info.keys() and ('-Wl,Accelerate' in blas_info['extra_link_args']):; blas = 'Accelerate'; else:; blas = 'Generic'; return blas. def available_cpu_count():; """"""; Get the number of cpus.; It tries to only get the number available to qutip.; """"""; import os; import multiprocessing; try:; import psutil; except ImportError:; psutil = None; num_cpu = 0. if 'QUTIP_NUM_PROCESSES' in os.environ:; # We consider QUTIP_NUM_PROCESSES=0 as unset.; num_cpu = int(os.environ['QUTIP_NUM_PROCESSES']). if num_cpu == 0 and 'SLURM_CPUS_PER_TASK' in os.environ:; num_cpu = int(os.environ['SLURM_CPUS_PER_TASK']). if num_cpu == 0 and hasattr(os, 'sched_getaffinity'):; num_cpu = len(os.sched_getaffinity(0)). if (; num_cpu == 0; and psutil is not None; and hasattr(psutil.Process(), ""cpu_affinity""); ):; num_cpu = len(psutil.Process().cpu_affinity()). if num_cp",MatchSource.WIKI,docs/4.7/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/utilities.html
https://qutip.org/docs/4.7/modules/qutip/utilities.html:7289,Modifiability,config,config,7289," w_mK = w * 1.0e12 * (_h / _kB); return w_mK. def convert_mK_to_GHz(w):; """"""; Convert an energy from unit mK to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit. """"""; w_GHz = w * 1.0e-12 * (_kB / _h); return w_GHz. def _version2int(version_string):; str_list = version_string.split(; ""-dev"")[0].split(""rc"")[0].split(""a"")[0].split(""b"")[0].split(; ""post"")[0].split('.'); return sum([int(d if len(d) > 0 else 0) * (100 ** (3 - n)); for n, d in enumerate(str_list[:3])]). def _blas_info():; config = np.__config__; if hasattr(config, 'blas_ilp64_opt_info'):; blas_info = config.blas_ilp64_opt_info; elif hasattr(config, 'blas_opt_info'):; blas_info = config.blas_opt_info; else:; blas_info = {}; _has_lib_key = 'libraries' in blas_info.keys(); blas = None; if hasattr(config,'mkl_info') or \; (_has_lib_key and any('mkl' in lib for lib in blas_info['libraries'])):; blas = 'INTEL MKL'; elif hasattr(config,'openblas_info') or \; (_has_lib_key and any('openblas' in lib for lib in blas_info['libraries'])):; blas = 'OPENBLAS'; elif 'extra_link_args' in blas_info.keys() and ('-Wl,Accelerate' in blas_info['extra_link_args']):; blas = 'Accelerate'; else:; blas = 'Generic'; return blas. def available_cpu_count():; """"""; Get the number of cpus.; It tries to only get the number available to qutip.; """"""; import os; import multiprocessing; try:; import psutil; except ImportError:; psutil = None; num_cpu = 0. if 'QUTIP_NUM_PROCESSES' in os.environ:; # We consider QUTIP_NUM_PROCESSES=0 as unset.; num_cpu = int(os.environ['QUTIP_NUM_PROCESSES']). if num_cpu == 0 and 'SLURM_CPUS_PER_TASK' in os.environ:; num_cpu = int(os.environ['SLURM_CPUS_PER_TASK']). if num_cpu == 0 and hasattr(os, 'sched_getaffinity'):; num_cpu = len(os.sched_getaffinity(0)). if (; num_cpu == 0; and psutil is not None; and hasattr(psutil.Process(), ""cpu_affinity""); ):; num_cpu = len(psutil.Process().cpu_affinity()). if num_cp",MatchSource.WIKI,docs/4.7/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/utilities.html
https://qutip.org/docs/4.7/modules/qutip/visualization.html:12193,Deployability,patch,patching,12193,"a, phi); xx = sin(thetam) * cos(phim); yy = sin(thetam) * sin(phim); zz = cos(thetam); r = array(abs(values)); ph = angle(values); # normalize color range based on phase angles in list ph; nrm = mpl.colors.Normalize(ph.min(), ph.max()). # plot with facecolors set to cm.jet colormap normalized to nrm; ax.plot_surface(r * xx, r * yy, r * zz, rstride=1, cstride=1,; facecolors=cm.jet(nrm(ph)), linewidth=0); # create new axes on plot for colorbar and shrink it a bit.; # pad shifts location of bar with repsect to the main plot; cax, kw = mpl.colorbar.make_axes(ax, shrink=.66, pad=.02). # create new colorbar in axes cax with cm jet and normalized to nrm like; # our facecolors; cb1 = mpl.colorbar.ColorbarBase(cax, cmap=cm.jet, norm=nrm); # add our colorbar label; cb1.set_label('Angle'). if save:; plt.savefig(""sphereplot.png""). return fig, ax. def _remove_margins(axis):; """"""; removes margins about z = 0 and improves the style; by monkey patching; """"""; def _get_coord_info_new(renderer):; mins, maxs, centers, deltas, tc, highs = \; _get_coord_info_old(renderer); mins += deltas / 4; maxs -= deltas / 4; return mins, maxs, centers, deltas, tc, highs. _get_coord_info_old = axis._get_coord_info; axis._get_coord_info = _get_coord_info_new. def _truncate_colormap(cmap, minval=0.0, maxval=1.0, n=100):; """"""; truncates portion of a colormap and returns the new one; """"""; if isinstance(cmap, str):; cmap = plt.get_cmap(cmap); new_cmap = mpl.colors.LinearSegmentedColormap.from_list(; 'trunc({n},{a:.2f},{b:.2f})'.format(; n=cmap.name, a=minval, b=maxval),; cmap(np.linspace(minval, maxval, n))); return new_cmap. def _stick_to_planes(stick, azim, ax, M, spacing):; """"""adjusts xlim and ylim in way that bars will; Stick to xz and yz planes; """"""; if stick is True:; azim = azim % 360; if 0 <= azim <= 90:; ax.set_ylim(1 - .5,); ax.set_xlim(1 - .5,); elif 90 < azim <= 180:; ax.set_ylim(1 - .5,); ax.set_xlim(0, M.shape[0] + (.5 - spacing)); elif 180 < azim <= 270:; ax.set_ylim(0, M.shape[1] + (.5 - sp",MatchSource.WIKI,docs/4.7/modules/qutip/visualization.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/visualization.html
https://qutip.org/docs/4.7/modules/qutip/visualization.html:13446,Deployability,update,updates,13446,"t_coord_info = _get_coord_info_new. def _truncate_colormap(cmap, minval=0.0, maxval=1.0, n=100):; """"""; truncates portion of a colormap and returns the new one; """"""; if isinstance(cmap, str):; cmap = plt.get_cmap(cmap); new_cmap = mpl.colors.LinearSegmentedColormap.from_list(; 'trunc({n},{a:.2f},{b:.2f})'.format(; n=cmap.name, a=minval, b=maxval),; cmap(np.linspace(minval, maxval, n))); return new_cmap. def _stick_to_planes(stick, azim, ax, M, spacing):; """"""adjusts xlim and ylim in way that bars will; Stick to xz and yz planes; """"""; if stick is True:; azim = azim % 360; if 0 <= azim <= 90:; ax.set_ylim(1 - .5,); ax.set_xlim(1 - .5,); elif 90 < azim <= 180:; ax.set_ylim(1 - .5,); ax.set_xlim(0, M.shape[0] + (.5 - spacing)); elif 180 < azim <= 270:; ax.set_ylim(0, M.shape[1] + (.5 - spacing)); ax.set_xlim(0, M.shape[0] + (.5 - spacing)); elif 270 < azim < 360:; ax.set_ylim(0, M.shape[1] + (.5 - spacing)); ax.set_xlim(1 - .5,). def _update_yaxis(spacing, M, ax, ylabels):; """"""; updates the y-axis; """"""; ytics = [x + (1 - (spacing / 2)) for x in range(M.shape[1])]; if parse_version(mpl.__version__) >= parse_version(""3.8""):; ax.axes.yaxis.set_major_locator(plt.FixedLocator(ytics)); else:; ax.axes.w_yaxis.set_major_locator(plt.FixedLocator(ytics)); if ylabels:; nylabels = len(ylabels); if nylabels != len(ytics):; raise ValueError(f""got {nylabels} ylabels but needed {len(ytics)}""); ax.set_yticklabels(ylabels); else:; ax.set_yticklabels([str(y + 1) for y in range(M.shape[1])]); ax.set_yticklabels([str(i) for i in range(M.shape[1])]); ax.tick_params(axis='y', labelsize=14); ax.set_yticks([y + (1 - (spacing / 2)) for y in range(M.shape[1])]). def _update_xaxis(spacing, M, ax, xlabels):; """"""; updates the x-axis; """"""; xtics = [x + (1 - (spacing / 2)) for x in range(M.shape[1])]; if parse_version(mpl.__version__) >= parse_version(""3.8""):; ax.axes.xaxis.set_major_locator(plt.FixedLocator(xtics)); else:; ax.axes.w_xaxis.set_major_locator(plt.FixedLocator(xtics)). if xlabels:; nxlabel",MatchSource.WIKI,docs/4.7/modules/qutip/visualization.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/visualization.html
https://qutip.org/docs/4.7/modules/qutip/visualization.html:14166,Deployability,update,updates,14166," spacing)); elif 180 < azim <= 270:; ax.set_ylim(0, M.shape[1] + (.5 - spacing)); ax.set_xlim(0, M.shape[0] + (.5 - spacing)); elif 270 < azim < 360:; ax.set_ylim(0, M.shape[1] + (.5 - spacing)); ax.set_xlim(1 - .5,). def _update_yaxis(spacing, M, ax, ylabels):; """"""; updates the y-axis; """"""; ytics = [x + (1 - (spacing / 2)) for x in range(M.shape[1])]; if parse_version(mpl.__version__) >= parse_version(""3.8""):; ax.axes.yaxis.set_major_locator(plt.FixedLocator(ytics)); else:; ax.axes.w_yaxis.set_major_locator(plt.FixedLocator(ytics)); if ylabels:; nylabels = len(ylabels); if nylabels != len(ytics):; raise ValueError(f""got {nylabels} ylabels but needed {len(ytics)}""); ax.set_yticklabels(ylabels); else:; ax.set_yticklabels([str(y + 1) for y in range(M.shape[1])]); ax.set_yticklabels([str(i) for i in range(M.shape[1])]); ax.tick_params(axis='y', labelsize=14); ax.set_yticks([y + (1 - (spacing / 2)) for y in range(M.shape[1])]). def _update_xaxis(spacing, M, ax, xlabels):; """"""; updates the x-axis; """"""; xtics = [x + (1 - (spacing / 2)) for x in range(M.shape[1])]; if parse_version(mpl.__version__) >= parse_version(""3.8""):; ax.axes.xaxis.set_major_locator(plt.FixedLocator(xtics)); else:; ax.axes.w_xaxis.set_major_locator(plt.FixedLocator(xtics)). if xlabels:; nxlabels = len(xlabels); if nxlabels != len(xtics):; raise ValueError(f""got {nxlabels} xlabels but needed {len(xtics)}""); ax.set_xticklabels(xlabels); else:; ax.set_xticklabels([str(x + 1) for x in range(M.shape[0])]); ax.set_xticklabels([str(i) for i in range(M.shape[0])]); ax.tick_params(axis='x', labelsize=14); ax.set_xticks([x + (1 - (spacing / 2)) for x in range(M.shape[0])]). def _update_zaxis(ax, z_min, z_max, zticks):; """"""; updates the z-axis; """"""; if parse_version(mpl.__version__) >= parse_version(""3.8""):; ax.axes.zaxis.set_major_locator(plt.IndexLocator(1, 0.5)); else:; ax.axes.w_zaxis.set_major_locator(plt.IndexLocator(1, 0.5)). if isinstance(zticks, list):; ax.set_zticks(zticks); ax.set_zlim3d([min(z_min, ",MatchSource.WIKI,docs/4.7/modules/qutip/visualization.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/visualization.html
https://qutip.org/docs/4.7/modules/qutip/visualization.html:14887,Deployability,update,updates,14887,"se:; ax.set_yticklabels([str(y + 1) for y in range(M.shape[1])]); ax.set_yticklabels([str(i) for i in range(M.shape[1])]); ax.tick_params(axis='y', labelsize=14); ax.set_yticks([y + (1 - (spacing / 2)) for y in range(M.shape[1])]). def _update_xaxis(spacing, M, ax, xlabels):; """"""; updates the x-axis; """"""; xtics = [x + (1 - (spacing / 2)) for x in range(M.shape[1])]; if parse_version(mpl.__version__) >= parse_version(""3.8""):; ax.axes.xaxis.set_major_locator(plt.FixedLocator(xtics)); else:; ax.axes.w_xaxis.set_major_locator(plt.FixedLocator(xtics)). if xlabels:; nxlabels = len(xlabels); if nxlabels != len(xtics):; raise ValueError(f""got {nxlabels} xlabels but needed {len(xtics)}""); ax.set_xticklabels(xlabels); else:; ax.set_xticklabels([str(x + 1) for x in range(M.shape[0])]); ax.set_xticklabels([str(i) for i in range(M.shape[0])]); ax.tick_params(axis='x', labelsize=14); ax.set_xticks([x + (1 - (spacing / 2)) for x in range(M.shape[0])]). def _update_zaxis(ax, z_min, z_max, zticks):; """"""; updates the z-axis; """"""; if parse_version(mpl.__version__) >= parse_version(""3.8""):; ax.axes.zaxis.set_major_locator(plt.IndexLocator(1, 0.5)); else:; ax.axes.w_zaxis.set_major_locator(plt.IndexLocator(1, 0.5)). if isinstance(zticks, list):; ax.set_zticks(zticks); ax.set_zlim3d([min(z_min, 0), z_max]). [docs]def matrix_histogram(M, xlabels=None, ylabels=None, title=None, limits=None,; colorbar=True, fig=None, ax=None, options=None):; """"""; Draw a histogram for the matrix M, with the given x and y labels and title. Parameters; ----------; M : Matrix of Qobj; The matrix to visualize. xlabels : list of strings; list of x labels. ylabels : list of strings; list of y labels. title : string; title of the plot (optional). limits : list/array with two float numbers; The z-axis limits [min, max] (optional). ax : a matplotlib axes instance; The axes context in which the plot will be drawn. colorbar : bool (default: True); show colorbar. options : dict; A dictionary containing extra options for",MatchSource.WIKI,docs/4.7/modules/qutip/visualization.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/visualization.html
https://qutip.org/docs/4.7/modules/qutip/visualization.html:18195,Deployability,update,update,18195,"default: 0.04); The fraction of the original axes between the colorbar; and the new image axes.; (i.e. the padding between the 3D figure and the colorbar). 'cbar_to_z' : bool (default: False); Whether to set the color of maximum and minimum z-values to the; maximum and minimum colors in the colorbar (True) or not (False). 'figsize' : tuple of two numbers; The size of the figure. Returns :; -------; fig, ax : tuple; A tuple of the matplotlib figure and axes instances used to produce; the figure. Raises; ------; ValueError; Input argument is not valid. """""". # default options; default_opts = {'figsize': None, 'cmap': 'jet', 'cmap_min': 0.,; 'cmap_max': 1., 'zticks': None, 'bars_spacing': 0.2,; 'bars_alpha': 1., 'bars_lw': 0.5, 'bars_edgecolor': 'k',; 'shade': False, 'azim': -35, 'elev': 35,; 'proj_type': 'ortho', 'stick': False,; 'cbar_pad': 0.04, 'cbar_to_z': False}. # update default_opts from input options; if options is None:; pass; elif isinstance(options, dict):; # check if keys in options dict are valid; if set(options) - set(default_opts):; raise ValueError(""invalid key(s) found in options: ""; f""{', '.join(set(options) - set(default_opts))}""); else:; # updating default options; default_opts.update(options); else:; raise ValueError(""options must be a dictionary""). if isinstance(M, Qobj):; # extract matrix data from Qobj; M = M.full(). n = np.size(M); xpos, ypos = np.meshgrid(range(M.shape[0]), range(M.shape[1])); xpos = xpos.T.flatten() + 0.5; ypos = ypos.T.flatten() + 0.5; zpos = np.zeros(n); dx = dy = (1 - default_opts['bars_spacing']) * np.ones(n); dz = np.real(M.flatten()). if isinstance(limits, list) and len(limits) == 2:; z_min = limits[0]; z_max = limits[1]; else:; z_min = min(dz); z_max = max(dz); if z_min == z_max:; z_min -= 0.1; z_max += 0.1. if default_opts['cbar_to_z']:; norm = mpl.colors.Normalize(min(dz), max(dz)); else:; norm = mpl.colors.Normalize(z_min, z_max); cmap = _truncate_colormap(default_opts['cmap'],; default_opts['cmap_min'],; default_op",MatchSource.WIKI,docs/4.7/modules/qutip/visualization.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/visualization.html
https://qutip.org/docs/4.7/modules/qutip/visualization.html:18529,Deployability,update,update,18529,"to the; maximum and minimum colors in the colorbar (True) or not (False). 'figsize' : tuple of two numbers; The size of the figure. Returns :; -------; fig, ax : tuple; A tuple of the matplotlib figure and axes instances used to produce; the figure. Raises; ------; ValueError; Input argument is not valid. """""". # default options; default_opts = {'figsize': None, 'cmap': 'jet', 'cmap_min': 0.,; 'cmap_max': 1., 'zticks': None, 'bars_spacing': 0.2,; 'bars_alpha': 1., 'bars_lw': 0.5, 'bars_edgecolor': 'k',; 'shade': False, 'azim': -35, 'elev': 35,; 'proj_type': 'ortho', 'stick': False,; 'cbar_pad': 0.04, 'cbar_to_z': False}. # update default_opts from input options; if options is None:; pass; elif isinstance(options, dict):; # check if keys in options dict are valid; if set(options) - set(default_opts):; raise ValueError(""invalid key(s) found in options: ""; f""{', '.join(set(options) - set(default_opts))}""); else:; # updating default options; default_opts.update(options); else:; raise ValueError(""options must be a dictionary""). if isinstance(M, Qobj):; # extract matrix data from Qobj; M = M.full(). n = np.size(M); xpos, ypos = np.meshgrid(range(M.shape[0]), range(M.shape[1])); xpos = xpos.T.flatten() + 0.5; ypos = ypos.T.flatten() + 0.5; zpos = np.zeros(n); dx = dy = (1 - default_opts['bars_spacing']) * np.ones(n); dz = np.real(M.flatten()). if isinstance(limits, list) and len(limits) == 2:; z_min = limits[0]; z_max = limits[1]; else:; z_min = min(dz); z_max = max(dz); if z_min == z_max:; z_min -= 0.1; z_max += 0.1. if default_opts['cbar_to_z']:; norm = mpl.colors.Normalize(min(dz), max(dz)); else:; norm = mpl.colors.Normalize(z_min, z_max); cmap = _truncate_colormap(default_opts['cmap'],; default_opts['cmap_min'],; default_opts['cmap_max']); colors = cmap(norm(dz)). if ax is None:; fig = plt.figure(figsize=default_opts['figsize']); ax = _axes3D(fig,; azim=default_opts['azim'] % 360,; elev=default_opts['elev'] % 360); ax.set_proj_type(default_opts['proj_type']). ax.bar3d(x",MatchSource.WIKI,docs/4.7/modules/qutip/visualization.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/visualization.html
https://qutip.org/docs/4.7/modules/qutip/visualization.html:48703,Deployability,update,updated,48703,"will be drawn. ax : a matplotlib axis instance; The axis context in which the plot will be drawn. figsize : (width, height); The size of the matplotlib figure (in inches) if it is to be created; (that is, if no 'fig' and 'ax' arguments are passed). Returns; -------; fig, ax : tuple; A tuple of the matplotlib figure and axes instances used to produce; the figure. """"""; if not isket(ket):; raise Exception(""Schmidt plot works only for pure states, i.e. kets.""). if not fig and not ax:; fig, ax = plt.subplots(1, 1, figsize=figsize). dim_list = ket.dims[0]. if splitting is None:; splitting = (len(dim_list) + 1) // 2. if isinstance(labels_iteration, int):; labels_iteration = labels_iteration, labels_iteration. ketdata = ket.full(). dim_list_y = dim_list[:splitting]; dim_list_x = dim_list[splitting:]. size_x = np.prod(dim_list_x); size_y = np.prod(dim_list_y). ketdata = ketdata.reshape((size_y, size_x)). dim_list_small_x = dim_list_x[:labels_iteration[1]]; dim_list_small_y = dim_list_y[:labels_iteration[0]]. quadrants_x = np.prod(dim_list_small_x); quadrants_y = np.prod(dim_list_small_y). ticks_x = [size_x / quadrants_x * (i + 0.5); for i in range(quadrants_x)]; ticks_y = [size_y / quadrants_y * (quadrants_y - i - 0.5); for i in range(quadrants_y)]. labels_x = [_sequence_to_latex(_index_to_sequence(i*size_x // quadrants_x,; dim_list=dim_list_x)); for i in range(quadrants_x)]; labels_y = [_sequence_to_latex(_index_to_sequence(i*size_y // quadrants_y,; dim_list=dim_list_y)); for i in range(quadrants_y)]. ax.set_xticks(ticks_x); ax.set_xticklabels(labels_x); ax.set_yticks(ticks_y); ax.set_yticklabels(labels_y); ax.set_xlabel(""last particles""); ax.set_ylabel(""first particles""). ax.imshow(complex_array_to_rgb(ketdata, theme=theme),; interpolation=""none"",; extent=(0, size_x, 0, size_y)). return fig, ax. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/modules/qutip/visualization.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/visualization.html
