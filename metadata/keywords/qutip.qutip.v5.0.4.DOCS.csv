id,quality_attribute,keyword,matched_word,match_idx,sentence,source,filename,author,repo,version,wiki,url
https://github.com/qutip/qutip/tree/v5.0.4/CODE_OF_CONDUCT.md:1849,Availability,avail,available,1849,"As contributors and maintainers of this project, and in the interest of fostering an open and welcoming community, we pledge to respect all people who contribute through reporting issues, posting feature requests, updating documentation, submitting pull requests or patches, and other activities. We are committed to making participation in this project a harassment-free experience for everyone, regardless of level of experience, gender, gender identity and expression, sexual orientation, disability, personal appearance, body size, race, ethnicity, age, religion, or nationality. Examples of unacceptable behavior by participants include:. * The use of sexualized language or imagery; * Personal attacks; * Trolling or insulting/derogatory comments; * Public or private harassment; * Publishing other's private information, such as physical or electronic addresses, without explicit permission; * Other unethical or unprofessional conduct. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct. By adopting this Code of Conduct, project maintainers commit themselves to fairly and consistently applying these principles to every aspect of managing this project. Project maintainers who do not follow or enforce the Code of Conduct may be permanently removed from the project team. This code of conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. . Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by opening an issue or contacting one or more of the project maintainers. . This Code of Conduct is adapted from the Contributor Covenant , version 1.2.0, available at https://www.contributor-covenant.org/version/1/2/0/code-of-conduct.html . [homepage]: https://contributor-covenant.org; [version]: https://contributor-covenant.org/version/1/2/; ",MatchSource.DOCS,CODE_OF_CONDUCT.md,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/CODE_OF_CONDUCT.md
https://github.com/qutip/qutip/tree/v5.0.4/CODE_OF_CONDUCT.md:306,Deployability,patch,patches,306,"# Contributor Covenant Code of Conduct. As contributors and maintainers of this project, and in the interest of fostering an open and welcoming community, we pledge to respect all people who contribute through reporting issues, posting feature requests, updating documentation, submitting pull requests or patches, and other activities. We are committed to making participation in this project a harassment-free experience for everyone, regardless of level of experience, gender, gender identity and expression, sexual orientation, disability, personal appearance, body size, race, ethnicity, age, religion, or nationality. Examples of unacceptable behavior by participants include:. * The use of sexualized language or imagery; * Personal attacks; * Trolling or insulting/derogatory comments; * Public or private harassment; * Publishing other's private information, such as physical or electronic addresses, without explicit permission; * Other unethical or unprofessional conduct. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct. By adopting this Code of Conduct, project maintainers commit themselves to fairly and consistently applying these principles to every aspect of managing this project. Project maintainers who do not follow or enforce the Code of Conduct may be permanently removed from the project team. This code of conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. . Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by opening an issue or contacting one or more of the project maintainers. . This Code of Conduct is adapted from the Contributor Covenant , version 1.2.0, available at https://www.contributor-covenant.org/version/1/2/0/code-of-conduct.html . [homepage]: https://contributor-covenant.org; [version]: https://",MatchSource.DOCS,CODE_OF_CONDUCT.md,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/CODE_OF_CONDUCT.md
https://github.com/qutip/qutip/tree/v5.0.4/CODE_OF_CONDUCT.md:1794,Energy Efficiency,adapt,adapted,1794,"As contributors and maintainers of this project, and in the interest of fostering an open and welcoming community, we pledge to respect all people who contribute through reporting issues, posting feature requests, updating documentation, submitting pull requests or patches, and other activities. We are committed to making participation in this project a harassment-free experience for everyone, regardless of level of experience, gender, gender identity and expression, sexual orientation, disability, personal appearance, body size, race, ethnicity, age, religion, or nationality. Examples of unacceptable behavior by participants include:. * The use of sexualized language or imagery; * Personal attacks; * Trolling or insulting/derogatory comments; * Public or private harassment; * Publishing other's private information, such as physical or electronic addresses, without explicit permission; * Other unethical or unprofessional conduct. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct. By adopting this Code of Conduct, project maintainers commit themselves to fairly and consistently applying these principles to every aspect of managing this project. Project maintainers who do not follow or enforce the Code of Conduct may be permanently removed from the project team. This code of conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. . Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by opening an issue or contacting one or more of the project maintainers. . This Code of Conduct is adapted from the Contributor Covenant , version 1.2.0, available at https://www.contributor-covenant.org/version/1/2/0/code-of-conduct.html . [homepage]: https://contributor-covenant.org; [version]: https://contributor-covenant.org/version/1/2/; ",MatchSource.DOCS,CODE_OF_CONDUCT.md,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/CODE_OF_CONDUCT.md
https://github.com/qutip/qutip/tree/v5.0.4/CODE_OF_CONDUCT.md:1794,Modifiability,adapt,adapted,1794,"As contributors and maintainers of this project, and in the interest of fostering an open and welcoming community, we pledge to respect all people who contribute through reporting issues, posting feature requests, updating documentation, submitting pull requests or patches, and other activities. We are committed to making participation in this project a harassment-free experience for everyone, regardless of level of experience, gender, gender identity and expression, sexual orientation, disability, personal appearance, body size, race, ethnicity, age, religion, or nationality. Examples of unacceptable behavior by participants include:. * The use of sexualized language or imagery; * Personal attacks; * Trolling or insulting/derogatory comments; * Public or private harassment; * Publishing other's private information, such as physical or electronic addresses, without explicit permission; * Other unethical or unprofessional conduct. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct. By adopting this Code of Conduct, project maintainers commit themselves to fairly and consistently applying these principles to every aspect of managing this project. Project maintainers who do not follow or enforce the Code of Conduct may be permanently removed from the project team. This code of conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. . Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by opening an issue or contacting one or more of the project maintainers. . This Code of Conduct is adapted from the Contributor Covenant , version 1.2.0, available at https://www.contributor-covenant.org/version/1/2/0/code-of-conduct.html . [homepage]: https://contributor-covenant.org; [version]: https://contributor-covenant.org/version/1/2/; ",MatchSource.DOCS,CODE_OF_CONDUCT.md,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/CODE_OF_CONDUCT.md
https://github.com/qutip/qutip/tree/v5.0.4/CODE_OF_CONDUCT.md:740,Security,attack,attacks,740,"# Contributor Covenant Code of Conduct. As contributors and maintainers of this project, and in the interest of fostering an open and welcoming community, we pledge to respect all people who contribute through reporting issues, posting feature requests, updating documentation, submitting pull requests or patches, and other activities. We are committed to making participation in this project a harassment-free experience for everyone, regardless of level of experience, gender, gender identity and expression, sexual orientation, disability, personal appearance, body size, race, ethnicity, age, religion, or nationality. Examples of unacceptable behavior by participants include:. * The use of sexualized language or imagery; * Personal attacks; * Trolling or insulting/derogatory comments; * Public or private harassment; * Publishing other's private information, such as physical or electronic addresses, without explicit permission; * Other unethical or unprofessional conduct. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct. By adopting this Code of Conduct, project maintainers commit themselves to fairly and consistently applying these principles to every aspect of managing this project. Project maintainers who do not follow or enforce the Code of Conduct may be permanently removed from the project team. This code of conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. . Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by opening an issue or contacting one or more of the project maintainers. . This Code of Conduct is adapted from the Contributor Covenant , version 1.2.0, available at https://www.contributor-covenant.org/version/1/2/0/code-of-conduct.html . [homepage]: https://contributor-covenant.org; [version]: https://",MatchSource.DOCS,CODE_OF_CONDUCT.md,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/CODE_OF_CONDUCT.md
https://github.com/qutip/qutip/tree/v5.0.4/README.md:1378,Availability,down,downloads,1378,"tps://github.com/boxili),; [J. Lishman](https://github.com/jakelishman),; [S. Cross](https://github.com/hodgestar),; [A. Galicia](https://github.com/AGaliciaMartinez),; [P. Menczel](https://github.com/pmenczel),; [P. Hopf](https://github.com/flowerthrower/),; [P. D. Nation](https://github.com/nonhermitian),; and [J. R. Johansson](https://github.com/jrjohansson). [![Build Status](https://github.com/qutip/qutip/actions/workflows/tests.yml/badge.svg?branch=master)](https://github.com/qutip/qutip/actions/workflows/tests.yml); [![Coverage Status](https://img.shields.io/coveralls/qutip/qutip.svg?logo=Coveralls)](https://coveralls.io/r/qutip/qutip); [![Maintainability](https://api.codeclimate.com/v1/badges/df502674f1dfa1f1b67a/maintainability)](https://codeclimate.com/github/qutip/qutip/maintainability); [![license](https://img.shields.io/badge/license-New%20BSD-blue.svg)](https://opensource.org/licenses/BSD-3-Clause); [![PyPi Downloads](https://img.shields.io/pypi/dm/qutip?label=downloads%20%7C%20pip&logo=PyPI)](https://pypi.org/project/qutip); [![Conda-Forge Downloads](https://img.shields.io/conda/dn/conda-forge/qutip?label=downloads%20%7C%20conda&logo=Conda-Forge)](https://anaconda.org/conda-forge/qutip). QuTiP is open-source software for simulating the dynamics of closed and open quantum systems.; It uses the excellent Numpy, Scipy, and Cython packages as numerical backends, and graphical output is provided by Matplotlib.; QuTiP aims to provide user-friendly and efficient numerical simulations of a wide variety of quantum mechanical problems, including those with Hamiltonians and/or collapse operators with arbitrary time-dependence, commonly found in a wide range of physics applications.; QuTiP is freely available for use and/or modification, and it can be used on all Unix-based platforms and on Windows.; Being free of any licensing fees, QuTiP is ideal for exploring quantum mechanics in research as well as in the classroom. Support; -------. [![Unitary Fund](https://i",MatchSource.DOCS,README.md,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/README.md
https://github.com/qutip/qutip/tree/v5.0.4/README.md:1527,Availability,down,downloads,1527,"AGaliciaMartinez),; [P. Menczel](https://github.com/pmenczel),; [P. Hopf](https://github.com/flowerthrower/),; [P. D. Nation](https://github.com/nonhermitian),; and [J. R. Johansson](https://github.com/jrjohansson). [![Build Status](https://github.com/qutip/qutip/actions/workflows/tests.yml/badge.svg?branch=master)](https://github.com/qutip/qutip/actions/workflows/tests.yml); [![Coverage Status](https://img.shields.io/coveralls/qutip/qutip.svg?logo=Coveralls)](https://coveralls.io/r/qutip/qutip); [![Maintainability](https://api.codeclimate.com/v1/badges/df502674f1dfa1f1b67a/maintainability)](https://codeclimate.com/github/qutip/qutip/maintainability); [![license](https://img.shields.io/badge/license-New%20BSD-blue.svg)](https://opensource.org/licenses/BSD-3-Clause); [![PyPi Downloads](https://img.shields.io/pypi/dm/qutip?label=downloads%20%7C%20pip&logo=PyPI)](https://pypi.org/project/qutip); [![Conda-Forge Downloads](https://img.shields.io/conda/dn/conda-forge/qutip?label=downloads%20%7C%20conda&logo=Conda-Forge)](https://anaconda.org/conda-forge/qutip). QuTiP is open-source software for simulating the dynamics of closed and open quantum systems.; It uses the excellent Numpy, Scipy, and Cython packages as numerical backends, and graphical output is provided by Matplotlib.; QuTiP aims to provide user-friendly and efficient numerical simulations of a wide variety of quantum mechanical problems, including those with Hamiltonians and/or collapse operators with arbitrary time-dependence, commonly found in a wide range of physics applications.; QuTiP is freely available for use and/or modification, and it can be used on all Unix-based platforms and on Windows.; Being free of any licensing fees, QuTiP is ideal for exploring quantum mechanics in research as well as in the classroom. Support; -------. [![Unitary Fund](https://img.shields.io/badge/Supported%20By-UNITARY%20FUND-brightgreen.svg?style=flat)](https://unitary.fund); [![Powered by NumFOCUS](https://img.shields.io/",MatchSource.DOCS,README.md,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/README.md
https://github.com/qutip/qutip/tree/v5.0.4/README.md:2121,Availability,avail,available,2121,"github/qutip/qutip/maintainability); [![license](https://img.shields.io/badge/license-New%20BSD-blue.svg)](https://opensource.org/licenses/BSD-3-Clause); [![PyPi Downloads](https://img.shields.io/pypi/dm/qutip?label=downloads%20%7C%20pip&logo=PyPI)](https://pypi.org/project/qutip); [![Conda-Forge Downloads](https://img.shields.io/conda/dn/conda-forge/qutip?label=downloads%20%7C%20conda&logo=Conda-Forge)](https://anaconda.org/conda-forge/qutip). QuTiP is open-source software for simulating the dynamics of closed and open quantum systems.; It uses the excellent Numpy, Scipy, and Cython packages as numerical backends, and graphical output is provided by Matplotlib.; QuTiP aims to provide user-friendly and efficient numerical simulations of a wide variety of quantum mechanical problems, including those with Hamiltonians and/or collapse operators with arbitrary time-dependence, commonly found in a wide range of physics applications.; QuTiP is freely available for use and/or modification, and it can be used on all Unix-based platforms and on Windows.; Being free of any licensing fees, QuTiP is ideal for exploring quantum mechanics in research as well as in the classroom. Support; -------. [![Unitary Fund](https://img.shields.io/badge/Supported%20By-UNITARY%20FUND-brightgreen.svg?style=flat)](https://unitary.fund); [![Powered by NumFOCUS](https://img.shields.io/badge/powered%20by-NumFOCUS-orange.svg?style=flat&colorA=E1523D&colorB=007D8A)](https://numfocus.org). We are proud to be affiliated with [Unitary Fund](https://unitary.fund) and [numFOCUS](https://numfocus.org). We are grateful for [Nori's lab](https://dml.riken.jp/) at RIKEN and [Blais' lab](https://www.physique.usherbrooke.ca/blais/) at the Institut Quantique; for providing developer positions to work on QuTiP. We also thank Google for supporting us by financing GSoC students to work on the QuTiP as well as [other supporting organizations](https://qutip.org/#supporting-organizations) that have been supporting QuTi",MatchSource.DOCS,README.md,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/README.md
https://github.com/qutip/qutip/tree/v5.0.4/README.md:3449,Availability,avail,available,3449,"y.fund); [![Powered by NumFOCUS](https://img.shields.io/badge/powered%20by-NumFOCUS-orange.svg?style=flat&colorA=E1523D&colorB=007D8A)](https://numfocus.org). We are proud to be affiliated with [Unitary Fund](https://unitary.fund) and [numFOCUS](https://numfocus.org). We are grateful for [Nori's lab](https://dml.riken.jp/) at RIKEN and [Blais' lab](https://www.physique.usherbrooke.ca/blais/) at the Institut Quantique; for providing developer positions to work on QuTiP. We also thank Google for supporting us by financing GSoC students to work on the QuTiP as well as [other supporting organizations](https://qutip.org/#supporting-organizations) that have been supporting QuTiP over the years. Installation; ------------. [![Pip Package](https://img.shields.io/pypi/v/qutip?logo=PyPI)](https://pypi.org/project/qutip); [![Conda-Forge Package](https://img.shields.io/conda/vn/conda-forge/qutip?logo=Conda-Forge)](https://anaconda.org/conda-forge/qutip). QuTiP is available on both `pip` and `conda` (the latter in the `conda-forge` channel).; You can install QuTiP from `pip` by doing. ```bash; pip install qutip; ```. to get the minimal installation.; You can instead use the target `qutip[full]` to install QuTiP with all its optional dependencies.; For more details, including instructions on how to build from source, see [the detailed installation guide in the documentation](https://qutip.readthedocs.io/en/stable/installation.html). All back releases are also available for download in the [releases section of this repository](https://github.com/qutip/qutip/releases), where you can also find per-version changelogs.; For the most complete set of release notes and changelogs for historic versions, see the [changelog](https://qutip.readthedocs.io/en/stable/changelog.html) section in the documentation. The pre-release of QuTiP 5.0 is available on PyPI and can be installed using pip:. ```bash; pip install --pre qutip; ```. This version breaks compatibility with QuTiP 4.7 in many small ",MatchSource.DOCS,README.md,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/README.md
https://github.com/qutip/qutip/tree/v5.0.4/README.md:3953,Availability,avail,available,3953,"r supporting us by financing GSoC students to work on the QuTiP as well as [other supporting organizations](https://qutip.org/#supporting-organizations) that have been supporting QuTiP over the years. Installation; ------------. [![Pip Package](https://img.shields.io/pypi/v/qutip?logo=PyPI)](https://pypi.org/project/qutip); [![Conda-Forge Package](https://img.shields.io/conda/vn/conda-forge/qutip?logo=Conda-Forge)](https://anaconda.org/conda-forge/qutip). QuTiP is available on both `pip` and `conda` (the latter in the `conda-forge` channel).; You can install QuTiP from `pip` by doing. ```bash; pip install qutip; ```. to get the minimal installation.; You can instead use the target `qutip[full]` to install QuTiP with all its optional dependencies.; For more details, including instructions on how to build from source, see [the detailed installation guide in the documentation](https://qutip.readthedocs.io/en/stable/installation.html). All back releases are also available for download in the [releases section of this repository](https://github.com/qutip/qutip/releases), where you can also find per-version changelogs.; For the most complete set of release notes and changelogs for historic versions, see the [changelog](https://qutip.readthedocs.io/en/stable/changelog.html) section in the documentation. The pre-release of QuTiP 5.0 is available on PyPI and can be installed using pip:. ```bash; pip install --pre qutip; ```. This version breaks compatibility with QuTiP 4.7 in many small ways.; Please see the [changelog](https://github.com/qutip/qutip/blob/master/doc/changelog.rst) for a list of changes, new features and deprecations.; This version should be fully working. If you find any bugs, confusing documentation or missing features, please create a GitHub issue. Documentation; -------------. [![Documentation Status - Latest](https://readthedocs.org/projects/qutip/badge/?version=latest)](https://qutip.readthedocs.io/en/latest/?badge=latest). The documentation for the late",MatchSource.DOCS,README.md,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/README.md
https://github.com/qutip/qutip/tree/v5.0.4/README.md:3967,Availability,down,download,3967,"r supporting us by financing GSoC students to work on the QuTiP as well as [other supporting organizations](https://qutip.org/#supporting-organizations) that have been supporting QuTiP over the years. Installation; ------------. [![Pip Package](https://img.shields.io/pypi/v/qutip?logo=PyPI)](https://pypi.org/project/qutip); [![Conda-Forge Package](https://img.shields.io/conda/vn/conda-forge/qutip?logo=Conda-Forge)](https://anaconda.org/conda-forge/qutip). QuTiP is available on both `pip` and `conda` (the latter in the `conda-forge` channel).; You can install QuTiP from `pip` by doing. ```bash; pip install qutip; ```. to get the minimal installation.; You can instead use the target `qutip[full]` to install QuTiP with all its optional dependencies.; For more details, including instructions on how to build from source, see [the detailed installation guide in the documentation](https://qutip.readthedocs.io/en/stable/installation.html). All back releases are also available for download in the [releases section of this repository](https://github.com/qutip/qutip/releases), where you can also find per-version changelogs.; For the most complete set of release notes and changelogs for historic versions, see the [changelog](https://qutip.readthedocs.io/en/stable/changelog.html) section in the documentation. The pre-release of QuTiP 5.0 is available on PyPI and can be installed using pip:. ```bash; pip install --pre qutip; ```. This version breaks compatibility with QuTiP 4.7 in many small ways.; Please see the [changelog](https://github.com/qutip/qutip/blob/master/doc/changelog.rst) for a list of changes, new features and deprecations.; This version should be fully working. If you find any bugs, confusing documentation or missing features, please create a GitHub issue. Documentation; -------------. [![Documentation Status - Latest](https://readthedocs.org/projects/qutip/badge/?version=latest)](https://qutip.readthedocs.io/en/latest/?badge=latest). The documentation for the late",MatchSource.DOCS,README.md,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/README.md
https://github.com/qutip/qutip/tree/v5.0.4/README.md:4330,Availability,avail,available,4330,"/conda/vn/conda-forge/qutip?logo=Conda-Forge)](https://anaconda.org/conda-forge/qutip). QuTiP is available on both `pip` and `conda` (the latter in the `conda-forge` channel).; You can install QuTiP from `pip` by doing. ```bash; pip install qutip; ```. to get the minimal installation.; You can instead use the target `qutip[full]` to install QuTiP with all its optional dependencies.; For more details, including instructions on how to build from source, see [the detailed installation guide in the documentation](https://qutip.readthedocs.io/en/stable/installation.html). All back releases are also available for download in the [releases section of this repository](https://github.com/qutip/qutip/releases), where you can also find per-version changelogs.; For the most complete set of release notes and changelogs for historic versions, see the [changelog](https://qutip.readthedocs.io/en/stable/changelog.html) section in the documentation. The pre-release of QuTiP 5.0 is available on PyPI and can be installed using pip:. ```bash; pip install --pre qutip; ```. This version breaks compatibility with QuTiP 4.7 in many small ways.; Please see the [changelog](https://github.com/qutip/qutip/blob/master/doc/changelog.rst) for a list of changes, new features and deprecations.; This version should be fully working. If you find any bugs, confusing documentation or missing features, please create a GitHub issue. Documentation; -------------. [![Documentation Status - Latest](https://readthedocs.org/projects/qutip/badge/?version=latest)](https://qutip.readthedocs.io/en/latest/?badge=latest). The documentation for the latest [stable release](https://qutip.readthedocs.io/en/latest/) and the [master](https://qutip.readthedocs.io/en/master/) branch is available for reading on Read The Docs. The documentation for official releases, in HTML and PDF formats, can be found in the [documentation section of the QuTiP website](https://qutip.org/documentation.html). The latest development documentat",MatchSource.DOCS,README.md,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/README.md
https://github.com/qutip/qutip/tree/v5.0.4/README.md:5110,Availability,avail,available,5110,"he most complete set of release notes and changelogs for historic versions, see the [changelog](https://qutip.readthedocs.io/en/stable/changelog.html) section in the documentation. The pre-release of QuTiP 5.0 is available on PyPI and can be installed using pip:. ```bash; pip install --pre qutip; ```. This version breaks compatibility with QuTiP 4.7 in many small ways.; Please see the [changelog](https://github.com/qutip/qutip/blob/master/doc/changelog.rst) for a list of changes, new features and deprecations.; This version should be fully working. If you find any bugs, confusing documentation or missing features, please create a GitHub issue. Documentation; -------------. [![Documentation Status - Latest](https://readthedocs.org/projects/qutip/badge/?version=latest)](https://qutip.readthedocs.io/en/latest/?badge=latest). The documentation for the latest [stable release](https://qutip.readthedocs.io/en/latest/) and the [master](https://qutip.readthedocs.io/en/master/) branch is available for reading on Read The Docs. The documentation for official releases, in HTML and PDF formats, can be found in the [documentation section of the QuTiP website](https://qutip.org/documentation.html). The latest development documentation is available in this repository in the `doc` folder. A [selection of demonstration notebooks is available](https://qutip.org/tutorials.html), which demonstrate some of the many features of QuTiP.; These are stored in the [qutip/qutip-tutorials repository](https://github.com/qutip/qutip-tutorials) here on GitHub. Contribute; ----------. You are most welcome to contribute to QuTiP development by forking this repository and sending pull requests, or filing bug reports at the [issues page](https://github.com/qutip/qutip/issues).; You can also help out with users' questions, or discuss proposed changes in the [QuTiP discussion group](https://groups.google.com/g/qutip).; All code contributions are acknowledged in the [contributors](https://qutip.readthedoc",MatchSource.DOCS,README.md,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/README.md
https://github.com/qutip/qutip/tree/v5.0.4/README.md:5360,Availability,avail,available,5360,"lled using pip:. ```bash; pip install --pre qutip; ```. This version breaks compatibility with QuTiP 4.7 in many small ways.; Please see the [changelog](https://github.com/qutip/qutip/blob/master/doc/changelog.rst) for a list of changes, new features and deprecations.; This version should be fully working. If you find any bugs, confusing documentation or missing features, please create a GitHub issue. Documentation; -------------. [![Documentation Status - Latest](https://readthedocs.org/projects/qutip/badge/?version=latest)](https://qutip.readthedocs.io/en/latest/?badge=latest). The documentation for the latest [stable release](https://qutip.readthedocs.io/en/latest/) and the [master](https://qutip.readthedocs.io/en/master/) branch is available for reading on Read The Docs. The documentation for official releases, in HTML and PDF formats, can be found in the [documentation section of the QuTiP website](https://qutip.org/documentation.html). The latest development documentation is available in this repository in the `doc` folder. A [selection of demonstration notebooks is available](https://qutip.org/tutorials.html), which demonstrate some of the many features of QuTiP.; These are stored in the [qutip/qutip-tutorials repository](https://github.com/qutip/qutip-tutorials) here on GitHub. Contribute; ----------. You are most welcome to contribute to QuTiP development by forking this repository and sending pull requests, or filing bug reports at the [issues page](https://github.com/qutip/qutip/issues).; You can also help out with users' questions, or discuss proposed changes in the [QuTiP discussion group](https://groups.google.com/g/qutip).; All code contributions are acknowledged in the [contributors](https://qutip.readthedocs.io/en/stable/contributors.html) section in the documentation. For more information, including technical advice, please see the [""contributing to QuTiP development"" section of the documentation](https://qutip.readthedocs.io/en/stable/development/",MatchSource.DOCS,README.md,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/README.md
https://github.com/qutip/qutip/tree/v5.0.4/README.md:5453,Availability,avail,available,5453,"patibility with QuTiP 4.7 in many small ways.; Please see the [changelog](https://github.com/qutip/qutip/blob/master/doc/changelog.rst) for a list of changes, new features and deprecations.; This version should be fully working. If you find any bugs, confusing documentation or missing features, please create a GitHub issue. Documentation; -------------. [![Documentation Status - Latest](https://readthedocs.org/projects/qutip/badge/?version=latest)](https://qutip.readthedocs.io/en/latest/?badge=latest). The documentation for the latest [stable release](https://qutip.readthedocs.io/en/latest/) and the [master](https://qutip.readthedocs.io/en/master/) branch is available for reading on Read The Docs. The documentation for official releases, in HTML and PDF formats, can be found in the [documentation section of the QuTiP website](https://qutip.org/documentation.html). The latest development documentation is available in this repository in the `doc` folder. A [selection of demonstration notebooks is available](https://qutip.org/tutorials.html), which demonstrate some of the many features of QuTiP.; These are stored in the [qutip/qutip-tutorials repository](https://github.com/qutip/qutip-tutorials) here on GitHub. Contribute; ----------. You are most welcome to contribute to QuTiP development by forking this repository and sending pull requests, or filing bug reports at the [issues page](https://github.com/qutip/qutip/issues).; You can also help out with users' questions, or discuss proposed changes in the [QuTiP discussion group](https://groups.google.com/g/qutip).; All code contributions are acknowledged in the [contributors](https://qutip.readthedocs.io/en/stable/contributors.html) section in the documentation. For more information, including technical advice, please see the [""contributing to QuTiP development"" section of the documentation](https://qutip.readthedocs.io/en/stable/development/contributing.html). Citing QuTiP; ------------. If you use QuTiP in your researc",MatchSource.DOCS,README.md,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/README.md
https://github.com/qutip/qutip/tree/v5.0.4/README.md:6494,Availability,avail,available,6494,"tip/blob/master/doc/changelog.rst) for a list of changes, new features and deprecations.; This version should be fully working. If you find any bugs, confusing documentation or missing features, please create a GitHub issue. Documentation; -------------. [![Documentation Status - Latest](https://readthedocs.org/projects/qutip/badge/?version=latest)](https://qutip.readthedocs.io/en/latest/?badge=latest). The documentation for the latest [stable release](https://qutip.readthedocs.io/en/latest/) and the [master](https://qutip.readthedocs.io/en/master/) branch is available for reading on Read The Docs. The documentation for official releases, in HTML and PDF formats, can be found in the [documentation section of the QuTiP website](https://qutip.org/documentation.html). The latest development documentation is available in this repository in the `doc` folder. A [selection of demonstration notebooks is available](https://qutip.org/tutorials.html), which demonstrate some of the many features of QuTiP.; These are stored in the [qutip/qutip-tutorials repository](https://github.com/qutip/qutip-tutorials) here on GitHub. Contribute; ----------. You are most welcome to contribute to QuTiP development by forking this repository and sending pull requests, or filing bug reports at the [issues page](https://github.com/qutip/qutip/issues).; You can also help out with users' questions, or discuss proposed changes in the [QuTiP discussion group](https://groups.google.com/g/qutip).; All code contributions are acknowledged in the [contributors](https://qutip.readthedocs.io/en/stable/contributors.html) section in the documentation. For more information, including technical advice, please see the [""contributing to QuTiP development"" section of the documentation](https://qutip.readthedocs.io/en/stable/development/contributing.html). Citing QuTiP; ------------. If you use QuTiP in your research, please cite the original QuTiP papers that are available [here](https://dml.riken.jp/?s=QuTiP).; ",MatchSource.DOCS,README.md,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/README.md
https://github.com/qutip/qutip/tree/v5.0.4/README.md:3537,Deployability,install,install,3537,"red%20by-NumFOCUS-orange.svg?style=flat&colorA=E1523D&colorB=007D8A)](https://numfocus.org). We are proud to be affiliated with [Unitary Fund](https://unitary.fund) and [numFOCUS](https://numfocus.org). We are grateful for [Nori's lab](https://dml.riken.jp/) at RIKEN and [Blais' lab](https://www.physique.usherbrooke.ca/blais/) at the Institut Quantique; for providing developer positions to work on QuTiP. We also thank Google for supporting us by financing GSoC students to work on the QuTiP as well as [other supporting organizations](https://qutip.org/#supporting-organizations) that have been supporting QuTiP over the years. Installation; ------------. [![Pip Package](https://img.shields.io/pypi/v/qutip?logo=PyPI)](https://pypi.org/project/qutip); [![Conda-Forge Package](https://img.shields.io/conda/vn/conda-forge/qutip?logo=Conda-Forge)](https://anaconda.org/conda-forge/qutip). QuTiP is available on both `pip` and `conda` (the latter in the `conda-forge` channel).; You can install QuTiP from `pip` by doing. ```bash; pip install qutip; ```. to get the minimal installation.; You can instead use the target `qutip[full]` to install QuTiP with all its optional dependencies.; For more details, including instructions on how to build from source, see [the detailed installation guide in the documentation](https://qutip.readthedocs.io/en/stable/installation.html). All back releases are also available for download in the [releases section of this repository](https://github.com/qutip/qutip/releases), where you can also find per-version changelogs.; For the most complete set of release notes and changelogs for historic versions, see the [changelog](https://qutip.readthedocs.io/en/stable/changelog.html) section in the documentation. The pre-release of QuTiP 5.0 is available on PyPI and can be installed using pip:. ```bash; pip install --pre qutip; ```. This version breaks compatibility with QuTiP 4.7 in many small ways.; Please see the [changelog](https://github.com/qutip/qutip/b",MatchSource.DOCS,README.md,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/README.md
https://github.com/qutip/qutip/tree/v5.0.4/README.md:3585,Deployability,install,install,3585,"t&colorA=E1523D&colorB=007D8A)](https://numfocus.org). We are proud to be affiliated with [Unitary Fund](https://unitary.fund) and [numFOCUS](https://numfocus.org). We are grateful for [Nori's lab](https://dml.riken.jp/) at RIKEN and [Blais' lab](https://www.physique.usherbrooke.ca/blais/) at the Institut Quantique; for providing developer positions to work on QuTiP. We also thank Google for supporting us by financing GSoC students to work on the QuTiP as well as [other supporting organizations](https://qutip.org/#supporting-organizations) that have been supporting QuTiP over the years. Installation; ------------. [![Pip Package](https://img.shields.io/pypi/v/qutip?logo=PyPI)](https://pypi.org/project/qutip); [![Conda-Forge Package](https://img.shields.io/conda/vn/conda-forge/qutip?logo=Conda-Forge)](https://anaconda.org/conda-forge/qutip). QuTiP is available on both `pip` and `conda` (the latter in the `conda-forge` channel).; You can install QuTiP from `pip` by doing. ```bash; pip install qutip; ```. to get the minimal installation.; You can instead use the target `qutip[full]` to install QuTiP with all its optional dependencies.; For more details, including instructions on how to build from source, see [the detailed installation guide in the documentation](https://qutip.readthedocs.io/en/stable/installation.html). All back releases are also available for download in the [releases section of this repository](https://github.com/qutip/qutip/releases), where you can also find per-version changelogs.; For the most complete set of release notes and changelogs for historic versions, see the [changelog](https://qutip.readthedocs.io/en/stable/changelog.html) section in the documentation. The pre-release of QuTiP 5.0 is available on PyPI and can be installed using pip:. ```bash; pip install --pre qutip; ```. This version breaks compatibility with QuTiP 4.7 in many small ways.; Please see the [changelog](https://github.com/qutip/qutip/blob/master/doc/changelog.rst) for a lis",MatchSource.DOCS,README.md,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/README.md
https://github.com/qutip/qutip/tree/v5.0.4/README.md:3624,Deployability,install,installation,3624,"ttps://numfocus.org). We are proud to be affiliated with [Unitary Fund](https://unitary.fund) and [numFOCUS](https://numfocus.org). We are grateful for [Nori's lab](https://dml.riken.jp/) at RIKEN and [Blais' lab](https://www.physique.usherbrooke.ca/blais/) at the Institut Quantique; for providing developer positions to work on QuTiP. We also thank Google for supporting us by financing GSoC students to work on the QuTiP as well as [other supporting organizations](https://qutip.org/#supporting-organizations) that have been supporting QuTiP over the years. Installation; ------------. [![Pip Package](https://img.shields.io/pypi/v/qutip?logo=PyPI)](https://pypi.org/project/qutip); [![Conda-Forge Package](https://img.shields.io/conda/vn/conda-forge/qutip?logo=Conda-Forge)](https://anaconda.org/conda-forge/qutip). QuTiP is available on both `pip` and `conda` (the latter in the `conda-forge` channel).; You can install QuTiP from `pip` by doing. ```bash; pip install qutip; ```. to get the minimal installation.; You can instead use the target `qutip[full]` to install QuTiP with all its optional dependencies.; For more details, including instructions on how to build from source, see [the detailed installation guide in the documentation](https://qutip.readthedocs.io/en/stable/installation.html). All back releases are also available for download in the [releases section of this repository](https://github.com/qutip/qutip/releases), where you can also find per-version changelogs.; For the most complete set of release notes and changelogs for historic versions, see the [changelog](https://qutip.readthedocs.io/en/stable/changelog.html) section in the documentation. The pre-release of QuTiP 5.0 is available on PyPI and can be installed using pip:. ```bash; pip install --pre qutip; ```. This version breaks compatibility with QuTiP 4.7 in many small ways.; Please see the [changelog](https://github.com/qutip/qutip/blob/master/doc/changelog.rst) for a list of changes, new features and de",MatchSource.DOCS,README.md,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/README.md
https://github.com/qutip/qutip/tree/v5.0.4/README.md:3687,Deployability,install,install,3687,"Fund](https://unitary.fund) and [numFOCUS](https://numfocus.org). We are grateful for [Nori's lab](https://dml.riken.jp/) at RIKEN and [Blais' lab](https://www.physique.usherbrooke.ca/blais/) at the Institut Quantique; for providing developer positions to work on QuTiP. We also thank Google for supporting us by financing GSoC students to work on the QuTiP as well as [other supporting organizations](https://qutip.org/#supporting-organizations) that have been supporting QuTiP over the years. Installation; ------------. [![Pip Package](https://img.shields.io/pypi/v/qutip?logo=PyPI)](https://pypi.org/project/qutip); [![Conda-Forge Package](https://img.shields.io/conda/vn/conda-forge/qutip?logo=Conda-Forge)](https://anaconda.org/conda-forge/qutip). QuTiP is available on both `pip` and `conda` (the latter in the `conda-forge` channel).; You can install QuTiP from `pip` by doing. ```bash; pip install qutip; ```. to get the minimal installation.; You can instead use the target `qutip[full]` to install QuTiP with all its optional dependencies.; For more details, including instructions on how to build from source, see [the detailed installation guide in the documentation](https://qutip.readthedocs.io/en/stable/installation.html). All back releases are also available for download in the [releases section of this repository](https://github.com/qutip/qutip/releases), where you can also find per-version changelogs.; For the most complete set of release notes and changelogs for historic versions, see the [changelog](https://qutip.readthedocs.io/en/stable/changelog.html) section in the documentation. The pre-release of QuTiP 5.0 is available on PyPI and can be installed using pip:. ```bash; pip install --pre qutip; ```. This version breaks compatibility with QuTiP 4.7 in many small ways.; Please see the [changelog](https://github.com/qutip/qutip/blob/master/doc/changelog.rst) for a list of changes, new features and deprecations.; This version should be fully working. If you find any",MatchSource.DOCS,README.md,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/README.md
https://github.com/qutip/qutip/tree/v5.0.4/README.md:3826,Deployability,install,installation,3826,"at RIKEN and [Blais' lab](https://www.physique.usherbrooke.ca/blais/) at the Institut Quantique; for providing developer positions to work on QuTiP. We also thank Google for supporting us by financing GSoC students to work on the QuTiP as well as [other supporting organizations](https://qutip.org/#supporting-organizations) that have been supporting QuTiP over the years. Installation; ------------. [![Pip Package](https://img.shields.io/pypi/v/qutip?logo=PyPI)](https://pypi.org/project/qutip); [![Conda-Forge Package](https://img.shields.io/conda/vn/conda-forge/qutip?logo=Conda-Forge)](https://anaconda.org/conda-forge/qutip). QuTiP is available on both `pip` and `conda` (the latter in the `conda-forge` channel).; You can install QuTiP from `pip` by doing. ```bash; pip install qutip; ```. to get the minimal installation.; You can instead use the target `qutip[full]` to install QuTiP with all its optional dependencies.; For more details, including instructions on how to build from source, see [the detailed installation guide in the documentation](https://qutip.readthedocs.io/en/stable/installation.html). All back releases are also available for download in the [releases section of this repository](https://github.com/qutip/qutip/releases), where you can also find per-version changelogs.; For the most complete set of release notes and changelogs for historic versions, see the [changelog](https://qutip.readthedocs.io/en/stable/changelog.html) section in the documentation. The pre-release of QuTiP 5.0 is available on PyPI and can be installed using pip:. ```bash; pip install --pre qutip; ```. This version breaks compatibility with QuTiP 4.7 in many small ways.; Please see the [changelog](https://github.com/qutip/qutip/blob/master/doc/changelog.rst) for a list of changes, new features and deprecations.; This version should be fully working. If you find any bugs, confusing documentation or missing features, please create a GitHub issue. Documentation; -------------. [![Documen",MatchSource.DOCS,README.md,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/README.md
https://github.com/qutip/qutip/tree/v5.0.4/README.md:3906,Deployability,install,installation,3906,"or providing developer positions to work on QuTiP. We also thank Google for supporting us by financing GSoC students to work on the QuTiP as well as [other supporting organizations](https://qutip.org/#supporting-organizations) that have been supporting QuTiP over the years. Installation; ------------. [![Pip Package](https://img.shields.io/pypi/v/qutip?logo=PyPI)](https://pypi.org/project/qutip); [![Conda-Forge Package](https://img.shields.io/conda/vn/conda-forge/qutip?logo=Conda-Forge)](https://anaconda.org/conda-forge/qutip). QuTiP is available on both `pip` and `conda` (the latter in the `conda-forge` channel).; You can install QuTiP from `pip` by doing. ```bash; pip install qutip; ```. to get the minimal installation.; You can instead use the target `qutip[full]` to install QuTiP with all its optional dependencies.; For more details, including instructions on how to build from source, see [the detailed installation guide in the documentation](https://qutip.readthedocs.io/en/stable/installation.html). All back releases are also available for download in the [releases section of this repository](https://github.com/qutip/qutip/releases), where you can also find per-version changelogs.; For the most complete set of release notes and changelogs for historic versions, see the [changelog](https://qutip.readthedocs.io/en/stable/changelog.html) section in the documentation. The pre-release of QuTiP 5.0 is available on PyPI and can be installed using pip:. ```bash; pip install --pre qutip; ```. This version breaks compatibility with QuTiP 4.7 in many small ways.; Please see the [changelog](https://github.com/qutip/qutip/blob/master/doc/changelog.rst) for a list of changes, new features and deprecations.; This version should be fully working. If you find any bugs, confusing documentation or missing features, please create a GitHub issue. Documentation; -------------. [![Documentation Status - Latest](https://readthedocs.org/projects/qutip/badge/?version=latest)](https://qu",MatchSource.DOCS,README.md,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/README.md
https://github.com/qutip/qutip/tree/v5.0.4/README.md:3935,Deployability,release,releases,3935,"r supporting us by financing GSoC students to work on the QuTiP as well as [other supporting organizations](https://qutip.org/#supporting-organizations) that have been supporting QuTiP over the years. Installation; ------------. [![Pip Package](https://img.shields.io/pypi/v/qutip?logo=PyPI)](https://pypi.org/project/qutip); [![Conda-Forge Package](https://img.shields.io/conda/vn/conda-forge/qutip?logo=Conda-Forge)](https://anaconda.org/conda-forge/qutip). QuTiP is available on both `pip` and `conda` (the latter in the `conda-forge` channel).; You can install QuTiP from `pip` by doing. ```bash; pip install qutip; ```. to get the minimal installation.; You can instead use the target `qutip[full]` to install QuTiP with all its optional dependencies.; For more details, including instructions on how to build from source, see [the detailed installation guide in the documentation](https://qutip.readthedocs.io/en/stable/installation.html). All back releases are also available for download in the [releases section of this repository](https://github.com/qutip/qutip/releases), where you can also find per-version changelogs.; For the most complete set of release notes and changelogs for historic versions, see the [changelog](https://qutip.readthedocs.io/en/stable/changelog.html) section in the documentation. The pre-release of QuTiP 5.0 is available on PyPI and can be installed using pip:. ```bash; pip install --pre qutip; ```. This version breaks compatibility with QuTiP 4.7 in many small ways.; Please see the [changelog](https://github.com/qutip/qutip/blob/master/doc/changelog.rst) for a list of changes, new features and deprecations.; This version should be fully working. If you find any bugs, confusing documentation or missing features, please create a GitHub issue. Documentation; -------------. [![Documentation Status - Latest](https://readthedocs.org/projects/qutip/badge/?version=latest)](https://qutip.readthedocs.io/en/latest/?badge=latest). The documentation for the late",MatchSource.DOCS,README.md,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/README.md
https://github.com/qutip/qutip/tree/v5.0.4/README.md:3984,Deployability,release,releases,3984,"r supporting us by financing GSoC students to work on the QuTiP as well as [other supporting organizations](https://qutip.org/#supporting-organizations) that have been supporting QuTiP over the years. Installation; ------------. [![Pip Package](https://img.shields.io/pypi/v/qutip?logo=PyPI)](https://pypi.org/project/qutip); [![Conda-Forge Package](https://img.shields.io/conda/vn/conda-forge/qutip?logo=Conda-Forge)](https://anaconda.org/conda-forge/qutip). QuTiP is available on both `pip` and `conda` (the latter in the `conda-forge` channel).; You can install QuTiP from `pip` by doing. ```bash; pip install qutip; ```. to get the minimal installation.; You can instead use the target `qutip[full]` to install QuTiP with all its optional dependencies.; For more details, including instructions on how to build from source, see [the detailed installation guide in the documentation](https://qutip.readthedocs.io/en/stable/installation.html). All back releases are also available for download in the [releases section of this repository](https://github.com/qutip/qutip/releases), where you can also find per-version changelogs.; For the most complete set of release notes and changelogs for historic versions, see the [changelog](https://qutip.readthedocs.io/en/stable/changelog.html) section in the documentation. The pre-release of QuTiP 5.0 is available on PyPI and can be installed using pip:. ```bash; pip install --pre qutip; ```. This version breaks compatibility with QuTiP 4.7 in many small ways.; Please see the [changelog](https://github.com/qutip/qutip/blob/master/doc/changelog.rst) for a list of changes, new features and deprecations.; This version should be fully working. If you find any bugs, confusing documentation or missing features, please create a GitHub issue. Documentation; -------------. [![Documentation Status - Latest](https://readthedocs.org/projects/qutip/badge/?version=latest)](https://qutip.readthedocs.io/en/latest/?badge=latest). The documentation for the late",MatchSource.DOCS,README.md,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/README.md
https://github.com/qutip/qutip/tree/v5.0.4/README.md:4052,Deployability,release,releases,4052,"organizations](https://qutip.org/#supporting-organizations) that have been supporting QuTiP over the years. Installation; ------------. [![Pip Package](https://img.shields.io/pypi/v/qutip?logo=PyPI)](https://pypi.org/project/qutip); [![Conda-Forge Package](https://img.shields.io/conda/vn/conda-forge/qutip?logo=Conda-Forge)](https://anaconda.org/conda-forge/qutip). QuTiP is available on both `pip` and `conda` (the latter in the `conda-forge` channel).; You can install QuTiP from `pip` by doing. ```bash; pip install qutip; ```. to get the minimal installation.; You can instead use the target `qutip[full]` to install QuTiP with all its optional dependencies.; For more details, including instructions on how to build from source, see [the detailed installation guide in the documentation](https://qutip.readthedocs.io/en/stable/installation.html). All back releases are also available for download in the [releases section of this repository](https://github.com/qutip/qutip/releases), where you can also find per-version changelogs.; For the most complete set of release notes and changelogs for historic versions, see the [changelog](https://qutip.readthedocs.io/en/stable/changelog.html) section in the documentation. The pre-release of QuTiP 5.0 is available on PyPI and can be installed using pip:. ```bash; pip install --pre qutip; ```. This version breaks compatibility with QuTiP 4.7 in many small ways.; Please see the [changelog](https://github.com/qutip/qutip/blob/master/doc/changelog.rst) for a list of changes, new features and deprecations.; This version should be fully working. If you find any bugs, confusing documentation or missing features, please create a GitHub issue. Documentation; -------------. [![Documentation Status - Latest](https://readthedocs.org/projects/qutip/badge/?version=latest)](https://qutip.readthedocs.io/en/latest/?badge=latest). The documentation for the latest [stable release](https://qutip.readthedocs.io/en/latest/) and the [master](https://qutip.",MatchSource.DOCS,README.md,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/README.md
https://github.com/qutip/qutip/tree/v5.0.4/README.md:4141,Deployability,release,release,4141,"r the years. Installation; ------------. [![Pip Package](https://img.shields.io/pypi/v/qutip?logo=PyPI)](https://pypi.org/project/qutip); [![Conda-Forge Package](https://img.shields.io/conda/vn/conda-forge/qutip?logo=Conda-Forge)](https://anaconda.org/conda-forge/qutip). QuTiP is available on both `pip` and `conda` (the latter in the `conda-forge` channel).; You can install QuTiP from `pip` by doing. ```bash; pip install qutip; ```. to get the minimal installation.; You can instead use the target `qutip[full]` to install QuTiP with all its optional dependencies.; For more details, including instructions on how to build from source, see [the detailed installation guide in the documentation](https://qutip.readthedocs.io/en/stable/installation.html). All back releases are also available for download in the [releases section of this repository](https://github.com/qutip/qutip/releases), where you can also find per-version changelogs.; For the most complete set of release notes and changelogs for historic versions, see the [changelog](https://qutip.readthedocs.io/en/stable/changelog.html) section in the documentation. The pre-release of QuTiP 5.0 is available on PyPI and can be installed using pip:. ```bash; pip install --pre qutip; ```. This version breaks compatibility with QuTiP 4.7 in many small ways.; Please see the [changelog](https://github.com/qutip/qutip/blob/master/doc/changelog.rst) for a list of changes, new features and deprecations.; This version should be fully working. If you find any bugs, confusing documentation or missing features, please create a GitHub issue. Documentation; -------------. [![Documentation Status - Latest](https://readthedocs.org/projects/qutip/badge/?version=latest)](https://qutip.readthedocs.io/en/latest/?badge=latest). The documentation for the latest [stable release](https://qutip.readthedocs.io/en/latest/) and the [master](https://qutip.readthedocs.io/en/master/) branch is available for reading on Read The Docs. The documentation f",MatchSource.DOCS,README.md,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/README.md
https://github.com/qutip/qutip/tree/v5.0.4/README.md:4306,Deployability,release,release,4306,"nda-Forge Package](https://img.shields.io/conda/vn/conda-forge/qutip?logo=Conda-Forge)](https://anaconda.org/conda-forge/qutip). QuTiP is available on both `pip` and `conda` (the latter in the `conda-forge` channel).; You can install QuTiP from `pip` by doing. ```bash; pip install qutip; ```. to get the minimal installation.; You can instead use the target `qutip[full]` to install QuTiP with all its optional dependencies.; For more details, including instructions on how to build from source, see [the detailed installation guide in the documentation](https://qutip.readthedocs.io/en/stable/installation.html). All back releases are also available for download in the [releases section of this repository](https://github.com/qutip/qutip/releases), where you can also find per-version changelogs.; For the most complete set of release notes and changelogs for historic versions, see the [changelog](https://qutip.readthedocs.io/en/stable/changelog.html) section in the documentation. The pre-release of QuTiP 5.0 is available on PyPI and can be installed using pip:. ```bash; pip install --pre qutip; ```. This version breaks compatibility with QuTiP 4.7 in many small ways.; Please see the [changelog](https://github.com/qutip/qutip/blob/master/doc/changelog.rst) for a list of changes, new features and deprecations.; This version should be fully working. If you find any bugs, confusing documentation or missing features, please create a GitHub issue. Documentation; -------------. [![Documentation Status - Latest](https://readthedocs.org/projects/qutip/badge/?version=latest)](https://qutip.readthedocs.io/en/latest/?badge=latest). The documentation for the latest [stable release](https://qutip.readthedocs.io/en/latest/) and the [master](https://qutip.readthedocs.io/en/master/) branch is available for reading on Read The Docs. The documentation for official releases, in HTML and PDF formats, can be found in the [documentation section of the QuTiP website](https://qutip.org/documentatio",MatchSource.DOCS,README.md,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/README.md
https://github.com/qutip/qutip/tree/v5.0.4/README.md:4359,Deployability,install,installed,4359,"/conda/vn/conda-forge/qutip?logo=Conda-Forge)](https://anaconda.org/conda-forge/qutip). QuTiP is available on both `pip` and `conda` (the latter in the `conda-forge` channel).; You can install QuTiP from `pip` by doing. ```bash; pip install qutip; ```. to get the minimal installation.; You can instead use the target `qutip[full]` to install QuTiP with all its optional dependencies.; For more details, including instructions on how to build from source, see [the detailed installation guide in the documentation](https://qutip.readthedocs.io/en/stable/installation.html). All back releases are also available for download in the [releases section of this repository](https://github.com/qutip/qutip/releases), where you can also find per-version changelogs.; For the most complete set of release notes and changelogs for historic versions, see the [changelog](https://qutip.readthedocs.io/en/stable/changelog.html) section in the documentation. The pre-release of QuTiP 5.0 is available on PyPI and can be installed using pip:. ```bash; pip install --pre qutip; ```. This version breaks compatibility with QuTiP 4.7 in many small ways.; Please see the [changelog](https://github.com/qutip/qutip/blob/master/doc/changelog.rst) for a list of changes, new features and deprecations.; This version should be fully working. If you find any bugs, confusing documentation or missing features, please create a GitHub issue. Documentation; -------------. [![Documentation Status - Latest](https://readthedocs.org/projects/qutip/badge/?version=latest)](https://qutip.readthedocs.io/en/latest/?badge=latest). The documentation for the latest [stable release](https://qutip.readthedocs.io/en/latest/) and the [master](https://qutip.readthedocs.io/en/master/) branch is available for reading on Read The Docs. The documentation for official releases, in HTML and PDF formats, can be found in the [documentation section of the QuTiP website](https://qutip.org/documentation.html). The latest development documentat",MatchSource.DOCS,README.md,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/README.md
https://github.com/qutip/qutip/tree/v5.0.4/README.md:4394,Deployability,install,install,4394,"https://anaconda.org/conda-forge/qutip). QuTiP is available on both `pip` and `conda` (the latter in the `conda-forge` channel).; You can install QuTiP from `pip` by doing. ```bash; pip install qutip; ```. to get the minimal installation.; You can instead use the target `qutip[full]` to install QuTiP with all its optional dependencies.; For more details, including instructions on how to build from source, see [the detailed installation guide in the documentation](https://qutip.readthedocs.io/en/stable/installation.html). All back releases are also available for download in the [releases section of this repository](https://github.com/qutip/qutip/releases), where you can also find per-version changelogs.; For the most complete set of release notes and changelogs for historic versions, see the [changelog](https://qutip.readthedocs.io/en/stable/changelog.html) section in the documentation. The pre-release of QuTiP 5.0 is available on PyPI and can be installed using pip:. ```bash; pip install --pre qutip; ```. This version breaks compatibility with QuTiP 4.7 in many small ways.; Please see the [changelog](https://github.com/qutip/qutip/blob/master/doc/changelog.rst) for a list of changes, new features and deprecations.; This version should be fully working. If you find any bugs, confusing documentation or missing features, please create a GitHub issue. Documentation; -------------. [![Documentation Status - Latest](https://readthedocs.org/projects/qutip/badge/?version=latest)](https://qutip.readthedocs.io/en/latest/?badge=latest). The documentation for the latest [stable release](https://qutip.readthedocs.io/en/latest/) and the [master](https://qutip.readthedocs.io/en/master/) branch is available for reading on Read The Docs. The documentation for official releases, in HTML and PDF formats, can be found in the [documentation section of the QuTiP website](https://qutip.org/documentation.html). The latest development documentation is available in this repository in the `doc",MatchSource.DOCS,README.md,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/README.md
https://github.com/qutip/qutip/tree/v5.0.4/README.md:4992,Deployability,release,release,4992," [releases section of this repository](https://github.com/qutip/qutip/releases), where you can also find per-version changelogs.; For the most complete set of release notes and changelogs for historic versions, see the [changelog](https://qutip.readthedocs.io/en/stable/changelog.html) section in the documentation. The pre-release of QuTiP 5.0 is available on PyPI and can be installed using pip:. ```bash; pip install --pre qutip; ```. This version breaks compatibility with QuTiP 4.7 in many small ways.; Please see the [changelog](https://github.com/qutip/qutip/blob/master/doc/changelog.rst) for a list of changes, new features and deprecations.; This version should be fully working. If you find any bugs, confusing documentation or missing features, please create a GitHub issue. Documentation; -------------. [![Documentation Status - Latest](https://readthedocs.org/projects/qutip/badge/?version=latest)](https://qutip.readthedocs.io/en/latest/?badge=latest). The documentation for the latest [stable release](https://qutip.readthedocs.io/en/latest/) and the [master](https://qutip.readthedocs.io/en/master/) branch is available for reading on Read The Docs. The documentation for official releases, in HTML and PDF formats, can be found in the [documentation section of the QuTiP website](https://qutip.org/documentation.html). The latest development documentation is available in this repository in the `doc` folder. A [selection of demonstration notebooks is available](https://qutip.org/tutorials.html), which demonstrate some of the many features of QuTiP.; These are stored in the [qutip/qutip-tutorials repository](https://github.com/qutip/qutip-tutorials) here on GitHub. Contribute; ----------. You are most welcome to contribute to QuTiP development by forking this repository and sending pull requests, or filing bug reports at the [issues page](https://github.com/qutip/qutip/issues).; You can also help out with users' questions, or discuss proposed changes in the [QuTiP discuss",MatchSource.DOCS,README.md,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/README.md
https://github.com/qutip/qutip/tree/v5.0.4/README.md:5181,Deployability,release,releases,5181,"utip.readthedocs.io/en/stable/changelog.html) section in the documentation. The pre-release of QuTiP 5.0 is available on PyPI and can be installed using pip:. ```bash; pip install --pre qutip; ```. This version breaks compatibility with QuTiP 4.7 in many small ways.; Please see the [changelog](https://github.com/qutip/qutip/blob/master/doc/changelog.rst) for a list of changes, new features and deprecations.; This version should be fully working. If you find any bugs, confusing documentation or missing features, please create a GitHub issue. Documentation; -------------. [![Documentation Status - Latest](https://readthedocs.org/projects/qutip/badge/?version=latest)](https://qutip.readthedocs.io/en/latest/?badge=latest). The documentation for the latest [stable release](https://qutip.readthedocs.io/en/latest/) and the [master](https://qutip.readthedocs.io/en/master/) branch is available for reading on Read The Docs. The documentation for official releases, in HTML and PDF formats, can be found in the [documentation section of the QuTiP website](https://qutip.org/documentation.html). The latest development documentation is available in this repository in the `doc` folder. A [selection of demonstration notebooks is available](https://qutip.org/tutorials.html), which demonstrate some of the many features of QuTiP.; These are stored in the [qutip/qutip-tutorials repository](https://github.com/qutip/qutip-tutorials) here on GitHub. Contribute; ----------. You are most welcome to contribute to QuTiP development by forking this repository and sending pull requests, or filing bug reports at the [issues page](https://github.com/qutip/qutip/issues).; You can also help out with users' questions, or discuss proposed changes in the [QuTiP discussion group](https://groups.google.com/g/qutip).; All code contributions are acknowledged in the [contributors](https://qutip.readthedocs.io/en/stable/contributors.html) section in the documentation. For more information, including technical",MatchSource.DOCS,README.md,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/README.md
https://github.com/qutip/qutip/tree/v5.0.4/README.md:1874,Energy Efficiency,efficient,efficient,1874,"lls/qutip/qutip.svg?logo=Coveralls)](https://coveralls.io/r/qutip/qutip); [![Maintainability](https://api.codeclimate.com/v1/badges/df502674f1dfa1f1b67a/maintainability)](https://codeclimate.com/github/qutip/qutip/maintainability); [![license](https://img.shields.io/badge/license-New%20BSD-blue.svg)](https://opensource.org/licenses/BSD-3-Clause); [![PyPi Downloads](https://img.shields.io/pypi/dm/qutip?label=downloads%20%7C%20pip&logo=PyPI)](https://pypi.org/project/qutip); [![Conda-Forge Downloads](https://img.shields.io/conda/dn/conda-forge/qutip?label=downloads%20%7C%20conda&logo=Conda-Forge)](https://anaconda.org/conda-forge/qutip). QuTiP is open-source software for simulating the dynamics of closed and open quantum systems.; It uses the excellent Numpy, Scipy, and Cython packages as numerical backends, and graphical output is provided by Matplotlib.; QuTiP aims to provide user-friendly and efficient numerical simulations of a wide variety of quantum mechanical problems, including those with Hamiltonians and/or collapse operators with arbitrary time-dependence, commonly found in a wide range of physics applications.; QuTiP is freely available for use and/or modification, and it can be used on all Unix-based platforms and on Windows.; Being free of any licensing fees, QuTiP is ideal for exploring quantum mechanics in research as well as in the classroom. Support; -------. [![Unitary Fund](https://img.shields.io/badge/Supported%20By-UNITARY%20FUND-brightgreen.svg?style=flat)](https://unitary.fund); [![Powered by NumFOCUS](https://img.shields.io/badge/powered%20by-NumFOCUS-orange.svg?style=flat&colorA=E1523D&colorB=007D8A)](https://numfocus.org). We are proud to be affiliated with [Unitary Fund](https://unitary.fund) and [numFOCUS](https://numfocus.org). We are grateful for [Nori's lab](https://dml.riken.jp/) at RIKEN and [Blais' lab](https://www.physique.usherbrooke.ca/blais/) at the Institut Quantique; for providing developer positions to work on QuTiP. We also tha",MatchSource.DOCS,README.md,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/README.md
https://github.com/qutip/qutip/tree/v5.0.4/README.md:2545,Energy Efficiency,power,powered,2545,"=Conda-Forge)](https://anaconda.org/conda-forge/qutip). QuTiP is open-source software for simulating the dynamics of closed and open quantum systems.; It uses the excellent Numpy, Scipy, and Cython packages as numerical backends, and graphical output is provided by Matplotlib.; QuTiP aims to provide user-friendly and efficient numerical simulations of a wide variety of quantum mechanical problems, including those with Hamiltonians and/or collapse operators with arbitrary time-dependence, commonly found in a wide range of physics applications.; QuTiP is freely available for use and/or modification, and it can be used on all Unix-based platforms and on Windows.; Being free of any licensing fees, QuTiP is ideal for exploring quantum mechanics in research as well as in the classroom. Support; -------. [![Unitary Fund](https://img.shields.io/badge/Supported%20By-UNITARY%20FUND-brightgreen.svg?style=flat)](https://unitary.fund); [![Powered by NumFOCUS](https://img.shields.io/badge/powered%20by-NumFOCUS-orange.svg?style=flat&colorA=E1523D&colorB=007D8A)](https://numfocus.org). We are proud to be affiliated with [Unitary Fund](https://unitary.fund) and [numFOCUS](https://numfocus.org). We are grateful for [Nori's lab](https://dml.riken.jp/) at RIKEN and [Blais' lab](https://www.physique.usherbrooke.ca/blais/) at the Institut Quantique; for providing developer positions to work on QuTiP. We also thank Google for supporting us by financing GSoC students to work on the QuTiP as well as [other supporting organizations](https://qutip.org/#supporting-organizations) that have been supporting QuTiP over the years. Installation; ------------. [![Pip Package](https://img.shields.io/pypi/v/qutip?logo=PyPI)](https://pypi.org/project/qutip); [![Conda-Forge Package](https://img.shields.io/conda/vn/conda-forge/qutip?logo=Conda-Forge)](https://anaconda.org/conda-forge/qutip). QuTiP is available on both `pip` and `conda` (the latter in the `conda-forge` channel).; You can install QuTiP from",MatchSource.DOCS,README.md,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/README.md
https://github.com/qutip/qutip/tree/v5.0.4/README.md:2036,Integrability,depend,dependence,2036,"lls/qutip/qutip.svg?logo=Coveralls)](https://coveralls.io/r/qutip/qutip); [![Maintainability](https://api.codeclimate.com/v1/badges/df502674f1dfa1f1b67a/maintainability)](https://codeclimate.com/github/qutip/qutip/maintainability); [![license](https://img.shields.io/badge/license-New%20BSD-blue.svg)](https://opensource.org/licenses/BSD-3-Clause); [![PyPi Downloads](https://img.shields.io/pypi/dm/qutip?label=downloads%20%7C%20pip&logo=PyPI)](https://pypi.org/project/qutip); [![Conda-Forge Downloads](https://img.shields.io/conda/dn/conda-forge/qutip?label=downloads%20%7C%20conda&logo=Conda-Forge)](https://anaconda.org/conda-forge/qutip). QuTiP is open-source software for simulating the dynamics of closed and open quantum systems.; It uses the excellent Numpy, Scipy, and Cython packages as numerical backends, and graphical output is provided by Matplotlib.; QuTiP aims to provide user-friendly and efficient numerical simulations of a wide variety of quantum mechanical problems, including those with Hamiltonians and/or collapse operators with arbitrary time-dependence, commonly found in a wide range of physics applications.; QuTiP is freely available for use and/or modification, and it can be used on all Unix-based platforms and on Windows.; Being free of any licensing fees, QuTiP is ideal for exploring quantum mechanics in research as well as in the classroom. Support; -------. [![Unitary Fund](https://img.shields.io/badge/Supported%20By-UNITARY%20FUND-brightgreen.svg?style=flat)](https://unitary.fund); [![Powered by NumFOCUS](https://img.shields.io/badge/powered%20by-NumFOCUS-orange.svg?style=flat&colorA=E1523D&colorB=007D8A)](https://numfocus.org). We are proud to be affiliated with [Unitary Fund](https://unitary.fund) and [numFOCUS](https://numfocus.org). We are grateful for [Nori's lab](https://dml.riken.jp/) at RIKEN and [Blais' lab](https://www.physique.usherbrooke.ca/blais/) at the Institut Quantique; for providing developer positions to work on QuTiP. We also tha",MatchSource.DOCS,README.md,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/README.md
https://github.com/qutip/qutip/tree/v5.0.4/README.md:3723,Integrability,depend,dependencies,3723,"Fund](https://unitary.fund) and [numFOCUS](https://numfocus.org). We are grateful for [Nori's lab](https://dml.riken.jp/) at RIKEN and [Blais' lab](https://www.physique.usherbrooke.ca/blais/) at the Institut Quantique; for providing developer positions to work on QuTiP. We also thank Google for supporting us by financing GSoC students to work on the QuTiP as well as [other supporting organizations](https://qutip.org/#supporting-organizations) that have been supporting QuTiP over the years. Installation; ------------. [![Pip Package](https://img.shields.io/pypi/v/qutip?logo=PyPI)](https://pypi.org/project/qutip); [![Conda-Forge Package](https://img.shields.io/conda/vn/conda-forge/qutip?logo=Conda-Forge)](https://anaconda.org/conda-forge/qutip). QuTiP is available on both `pip` and `conda` (the latter in the `conda-forge` channel).; You can install QuTiP from `pip` by doing. ```bash; pip install qutip; ```. to get the minimal installation.; You can instead use the target `qutip[full]` to install QuTiP with all its optional dependencies.; For more details, including instructions on how to build from source, see [the detailed installation guide in the documentation](https://qutip.readthedocs.io/en/stable/installation.html). All back releases are also available for download in the [releases section of this repository](https://github.com/qutip/qutip/releases), where you can also find per-version changelogs.; For the most complete set of release notes and changelogs for historic versions, see the [changelog](https://qutip.readthedocs.io/en/stable/changelog.html) section in the documentation. The pre-release of QuTiP 5.0 is available on PyPI and can be installed using pip:. ```bash; pip install --pre qutip; ```. This version breaks compatibility with QuTiP 4.7 in many small ways.; Please see the [changelog](https://github.com/qutip/qutip/blob/master/doc/changelog.rst) for a list of changes, new features and deprecations.; This version should be fully working. If you find any",MatchSource.DOCS,README.md,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/README.md
https://github.com/qutip/qutip/tree/v5.0.4/README.md:1120,Modifiability,maintainab,maintainability,1120,"nade](https://github.com/cgranade),; [A. Grimsmo](https://github.com/arnelg),; [N. Shammah](https://github.com/nathanshammah),; [S. Ahmed](https://github.com/quantshah),; [N. Lambert](https://github.com/nwlambert),; [E. Gigure](https://github.com/ericgig),; [B. Li](https://github.com/boxili),; [J. Lishman](https://github.com/jakelishman),; [S. Cross](https://github.com/hodgestar),; [A. Galicia](https://github.com/AGaliciaMartinez),; [P. Menczel](https://github.com/pmenczel),; [P. Hopf](https://github.com/flowerthrower/),; [P. D. Nation](https://github.com/nonhermitian),; and [J. R. Johansson](https://github.com/jrjohansson). [![Build Status](https://github.com/qutip/qutip/actions/workflows/tests.yml/badge.svg?branch=master)](https://github.com/qutip/qutip/actions/workflows/tests.yml); [![Coverage Status](https://img.shields.io/coveralls/qutip/qutip.svg?logo=Coveralls)](https://coveralls.io/r/qutip/qutip); [![Maintainability](https://api.codeclimate.com/v1/badges/df502674f1dfa1f1b67a/maintainability)](https://codeclimate.com/github/qutip/qutip/maintainability); [![license](https://img.shields.io/badge/license-New%20BSD-blue.svg)](https://opensource.org/licenses/BSD-3-Clause); [![PyPi Downloads](https://img.shields.io/pypi/dm/qutip?label=downloads%20%7C%20pip&logo=PyPI)](https://pypi.org/project/qutip); [![Conda-Forge Downloads](https://img.shields.io/conda/dn/conda-forge/qutip?label=downloads%20%7C%20conda&logo=Conda-Forge)](https://anaconda.org/conda-forge/qutip). QuTiP is open-source software for simulating the dynamics of closed and open quantum systems.; It uses the excellent Numpy, Scipy, and Cython packages as numerical backends, and graphical output is provided by Matplotlib.; QuTiP aims to provide user-friendly and efficient numerical simulations of a wide variety of quantum mechanical problems, including those with Hamiltonians and/or collapse operators with arbitrary time-dependence, commonly found in a wide range of physics applications.; QuTiP is freely a",MatchSource.DOCS,README.md,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/README.md
https://github.com/qutip/qutip/tree/v5.0.4/README.md:1181,Modifiability,maintainab,maintainability,1181,"arnelg),; [N. Shammah](https://github.com/nathanshammah),; [S. Ahmed](https://github.com/quantshah),; [N. Lambert](https://github.com/nwlambert),; [E. Gigure](https://github.com/ericgig),; [B. Li](https://github.com/boxili),; [J. Lishman](https://github.com/jakelishman),; [S. Cross](https://github.com/hodgestar),; [A. Galicia](https://github.com/AGaliciaMartinez),; [P. Menczel](https://github.com/pmenczel),; [P. Hopf](https://github.com/flowerthrower/),; [P. D. Nation](https://github.com/nonhermitian),; and [J. R. Johansson](https://github.com/jrjohansson). [![Build Status](https://github.com/qutip/qutip/actions/workflows/tests.yml/badge.svg?branch=master)](https://github.com/qutip/qutip/actions/workflows/tests.yml); [![Coverage Status](https://img.shields.io/coveralls/qutip/qutip.svg?logo=Coveralls)](https://coveralls.io/r/qutip/qutip); [![Maintainability](https://api.codeclimate.com/v1/badges/df502674f1dfa1f1b67a/maintainability)](https://codeclimate.com/github/qutip/qutip/maintainability); [![license](https://img.shields.io/badge/license-New%20BSD-blue.svg)](https://opensource.org/licenses/BSD-3-Clause); [![PyPi Downloads](https://img.shields.io/pypi/dm/qutip?label=downloads%20%7C%20pip&logo=PyPI)](https://pypi.org/project/qutip); [![Conda-Forge Downloads](https://img.shields.io/conda/dn/conda-forge/qutip?label=downloads%20%7C%20conda&logo=Conda-Forge)](https://anaconda.org/conda-forge/qutip). QuTiP is open-source software for simulating the dynamics of closed and open quantum systems.; It uses the excellent Numpy, Scipy, and Cython packages as numerical backends, and graphical output is provided by Matplotlib.; QuTiP aims to provide user-friendly and efficient numerical simulations of a wide variety of quantum mechanical problems, including those with Hamiltonians and/or collapse operators with arbitrary time-dependence, commonly found in a wide range of physics applications.; QuTiP is freely available for use and/or modification, and it can be used on all Unix-",MatchSource.DOCS,README.md,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/README.md
https://github.com/qutip/qutip/tree/v5.0.4/README.md:821,Testability,test,tests,821,"QuTiP: Quantum Toolbox in Python; ================================. [A. Pitchford](https://github.com/ajgpitch),; [C. Granade](https://github.com/cgranade),; [A. Grimsmo](https://github.com/arnelg),; [N. Shammah](https://github.com/nathanshammah),; [S. Ahmed](https://github.com/quantshah),; [N. Lambert](https://github.com/nwlambert),; [E. Gigure](https://github.com/ericgig),; [B. Li](https://github.com/boxili),; [J. Lishman](https://github.com/jakelishman),; [S. Cross](https://github.com/hodgestar),; [A. Galicia](https://github.com/AGaliciaMartinez),; [P. Menczel](https://github.com/pmenczel),; [P. Hopf](https://github.com/flowerthrower/),; [P. D. Nation](https://github.com/nonhermitian),; and [J. R. Johansson](https://github.com/jrjohansson). [![Build Status](https://github.com/qutip/qutip/actions/workflows/tests.yml/badge.svg?branch=master)](https://github.com/qutip/qutip/actions/workflows/tests.yml); [![Coverage Status](https://img.shields.io/coveralls/qutip/qutip.svg?logo=Coveralls)](https://coveralls.io/r/qutip/qutip); [![Maintainability](https://api.codeclimate.com/v1/badges/df502674f1dfa1f1b67a/maintainability)](https://codeclimate.com/github/qutip/qutip/maintainability); [![license](https://img.shields.io/badge/license-New%20BSD-blue.svg)](https://opensource.org/licenses/BSD-3-Clause); [![PyPi Downloads](https://img.shields.io/pypi/dm/qutip?label=downloads%20%7C%20pip&logo=PyPI)](https://pypi.org/project/qutip); [![Conda-Forge Downloads](https://img.shields.io/conda/dn/conda-forge/qutip?label=downloads%20%7C%20conda&logo=Conda-Forge)](https://anaconda.org/conda-forge/qutip). QuTiP is open-source software for simulating the dynamics of closed and open quantum systems.; It uses the excellent Numpy, Scipy, and Cython packages as numerical backends, and graphical output is provided by Matplotlib.; QuTiP aims to provide user-friendly and efficient numerical simulations of a wide variety of quantum mechanical problems, including those with Hamiltonians and/or coll",MatchSource.DOCS,README.md,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/README.md
https://github.com/qutip/qutip/tree/v5.0.4/README.md:906,Testability,test,tests,906,"QuTiP: Quantum Toolbox in Python; ================================. [A. Pitchford](https://github.com/ajgpitch),; [C. Granade](https://github.com/cgranade),; [A. Grimsmo](https://github.com/arnelg),; [N. Shammah](https://github.com/nathanshammah),; [S. Ahmed](https://github.com/quantshah),; [N. Lambert](https://github.com/nwlambert),; [E. Gigure](https://github.com/ericgig),; [B. Li](https://github.com/boxili),; [J. Lishman](https://github.com/jakelishman),; [S. Cross](https://github.com/hodgestar),; [A. Galicia](https://github.com/AGaliciaMartinez),; [P. Menczel](https://github.com/pmenczel),; [P. Hopf](https://github.com/flowerthrower/),; [P. D. Nation](https://github.com/nonhermitian),; and [J. R. Johansson](https://github.com/jrjohansson). [![Build Status](https://github.com/qutip/qutip/actions/workflows/tests.yml/badge.svg?branch=master)](https://github.com/qutip/qutip/actions/workflows/tests.yml); [![Coverage Status](https://img.shields.io/coveralls/qutip/qutip.svg?logo=Coveralls)](https://coveralls.io/r/qutip/qutip); [![Maintainability](https://api.codeclimate.com/v1/badges/df502674f1dfa1f1b67a/maintainability)](https://codeclimate.com/github/qutip/qutip/maintainability); [![license](https://img.shields.io/badge/license-New%20BSD-blue.svg)](https://opensource.org/licenses/BSD-3-Clause); [![PyPi Downloads](https://img.shields.io/pypi/dm/qutip?label=downloads%20%7C%20pip&logo=PyPI)](https://pypi.org/project/qutip); [![Conda-Forge Downloads](https://img.shields.io/conda/dn/conda-forge/qutip?label=downloads%20%7C%20conda&logo=Conda-Forge)](https://anaconda.org/conda-forge/qutip). QuTiP is open-source software for simulating the dynamics of closed and open quantum systems.; It uses the excellent Numpy, Scipy, and Cython packages as numerical backends, and graphical output is provided by Matplotlib.; QuTiP aims to provide user-friendly and efficient numerical simulations of a wide variety of quantum mechanical problems, including those with Hamiltonians and/or coll",MatchSource.DOCS,README.md,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/README.md
https://github.com/qutip/qutip/tree/v5.0.4/README.md:987,Testability,log,logo,987,"TiP: Quantum Toolbox in Python; ================================. [A. Pitchford](https://github.com/ajgpitch),; [C. Granade](https://github.com/cgranade),; [A. Grimsmo](https://github.com/arnelg),; [N. Shammah](https://github.com/nathanshammah),; [S. Ahmed](https://github.com/quantshah),; [N. Lambert](https://github.com/nwlambert),; [E. Gigure](https://github.com/ericgig),; [B. Li](https://github.com/boxili),; [J. Lishman](https://github.com/jakelishman),; [S. Cross](https://github.com/hodgestar),; [A. Galicia](https://github.com/AGaliciaMartinez),; [P. Menczel](https://github.com/pmenczel),; [P. Hopf](https://github.com/flowerthrower/),; [P. D. Nation](https://github.com/nonhermitian),; and [J. R. Johansson](https://github.com/jrjohansson). [![Build Status](https://github.com/qutip/qutip/actions/workflows/tests.yml/badge.svg?branch=master)](https://github.com/qutip/qutip/actions/workflows/tests.yml); [![Coverage Status](https://img.shields.io/coveralls/qutip/qutip.svg?logo=Coveralls)](https://coveralls.io/r/qutip/qutip); [![Maintainability](https://api.codeclimate.com/v1/badges/df502674f1dfa1f1b67a/maintainability)](https://codeclimate.com/github/qutip/qutip/maintainability); [![license](https://img.shields.io/badge/license-New%20BSD-blue.svg)](https://opensource.org/licenses/BSD-3-Clause); [![PyPi Downloads](https://img.shields.io/pypi/dm/qutip?label=downloads%20%7C%20pip&logo=PyPI)](https://pypi.org/project/qutip); [![Conda-Forge Downloads](https://img.shields.io/conda/dn/conda-forge/qutip?label=downloads%20%7C%20conda&logo=Conda-Forge)](https://anaconda.org/conda-forge/qutip). QuTiP is open-source software for simulating the dynamics of closed and open quantum systems.; It uses the excellent Numpy, Scipy, and Cython packages as numerical backends, and graphical output is provided by Matplotlib.; QuTiP aims to provide user-friendly and efficient numerical simulations of a wide variety of quantum mechanical problems, including those with Hamiltonians and/or collap",MatchSource.DOCS,README.md,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/README.md
https://github.com/qutip/qutip/tree/v5.0.4/README.md:1400,Testability,log,logo,1400,"tps://github.com/boxili),; [J. Lishman](https://github.com/jakelishman),; [S. Cross](https://github.com/hodgestar),; [A. Galicia](https://github.com/AGaliciaMartinez),; [P. Menczel](https://github.com/pmenczel),; [P. Hopf](https://github.com/flowerthrower/),; [P. D. Nation](https://github.com/nonhermitian),; and [J. R. Johansson](https://github.com/jrjohansson). [![Build Status](https://github.com/qutip/qutip/actions/workflows/tests.yml/badge.svg?branch=master)](https://github.com/qutip/qutip/actions/workflows/tests.yml); [![Coverage Status](https://img.shields.io/coveralls/qutip/qutip.svg?logo=Coveralls)](https://coveralls.io/r/qutip/qutip); [![Maintainability](https://api.codeclimate.com/v1/badges/df502674f1dfa1f1b67a/maintainability)](https://codeclimate.com/github/qutip/qutip/maintainability); [![license](https://img.shields.io/badge/license-New%20BSD-blue.svg)](https://opensource.org/licenses/BSD-3-Clause); [![PyPi Downloads](https://img.shields.io/pypi/dm/qutip?label=downloads%20%7C%20pip&logo=PyPI)](https://pypi.org/project/qutip); [![Conda-Forge Downloads](https://img.shields.io/conda/dn/conda-forge/qutip?label=downloads%20%7C%20conda&logo=Conda-Forge)](https://anaconda.org/conda-forge/qutip). QuTiP is open-source software for simulating the dynamics of closed and open quantum systems.; It uses the excellent Numpy, Scipy, and Cython packages as numerical backends, and graphical output is provided by Matplotlib.; QuTiP aims to provide user-friendly and efficient numerical simulations of a wide variety of quantum mechanical problems, including those with Hamiltonians and/or collapse operators with arbitrary time-dependence, commonly found in a wide range of physics applications.; QuTiP is freely available for use and/or modification, and it can be used on all Unix-based platforms and on Windows.; Being free of any licensing fees, QuTiP is ideal for exploring quantum mechanics in research as well as in the classroom. Support; -------. [![Unitary Fund](https://i",MatchSource.DOCS,README.md,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/README.md
https://github.com/qutip/qutip/tree/v5.0.4/README.md:1551,Testability,log,logo,1551,"AGaliciaMartinez),; [P. Menczel](https://github.com/pmenczel),; [P. Hopf](https://github.com/flowerthrower/),; [P. D. Nation](https://github.com/nonhermitian),; and [J. R. Johansson](https://github.com/jrjohansson). [![Build Status](https://github.com/qutip/qutip/actions/workflows/tests.yml/badge.svg?branch=master)](https://github.com/qutip/qutip/actions/workflows/tests.yml); [![Coverage Status](https://img.shields.io/coveralls/qutip/qutip.svg?logo=Coveralls)](https://coveralls.io/r/qutip/qutip); [![Maintainability](https://api.codeclimate.com/v1/badges/df502674f1dfa1f1b67a/maintainability)](https://codeclimate.com/github/qutip/qutip/maintainability); [![license](https://img.shields.io/badge/license-New%20BSD-blue.svg)](https://opensource.org/licenses/BSD-3-Clause); [![PyPi Downloads](https://img.shields.io/pypi/dm/qutip?label=downloads%20%7C%20pip&logo=PyPI)](https://pypi.org/project/qutip); [![Conda-Forge Downloads](https://img.shields.io/conda/dn/conda-forge/qutip?label=downloads%20%7C%20conda&logo=Conda-Forge)](https://anaconda.org/conda-forge/qutip). QuTiP is open-source software for simulating the dynamics of closed and open quantum systems.; It uses the excellent Numpy, Scipy, and Cython packages as numerical backends, and graphical output is provided by Matplotlib.; QuTiP aims to provide user-friendly and efficient numerical simulations of a wide variety of quantum mechanical problems, including those with Hamiltonians and/or collapse operators with arbitrary time-dependence, commonly found in a wide range of physics applications.; QuTiP is freely available for use and/or modification, and it can be used on all Unix-based platforms and on Windows.; Being free of any licensing fees, QuTiP is ideal for exploring quantum mechanics in research as well as in the classroom. Support; -------. [![Unitary Fund](https://img.shields.io/badge/Supported%20By-UNITARY%20FUND-brightgreen.svg?style=flat)](https://unitary.fund); [![Powered by NumFOCUS](https://img.shields.io/",MatchSource.DOCS,README.md,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/README.md
https://github.com/qutip/qutip/tree/v5.0.4/README.md:3261,Testability,log,logo,3261,"s ideal for exploring quantum mechanics in research as well as in the classroom. Support; -------. [![Unitary Fund](https://img.shields.io/badge/Supported%20By-UNITARY%20FUND-brightgreen.svg?style=flat)](https://unitary.fund); [![Powered by NumFOCUS](https://img.shields.io/badge/powered%20by-NumFOCUS-orange.svg?style=flat&colorA=E1523D&colorB=007D8A)](https://numfocus.org). We are proud to be affiliated with [Unitary Fund](https://unitary.fund) and [numFOCUS](https://numfocus.org). We are grateful for [Nori's lab](https://dml.riken.jp/) at RIKEN and [Blais' lab](https://www.physique.usherbrooke.ca/blais/) at the Institut Quantique; for providing developer positions to work on QuTiP. We also thank Google for supporting us by financing GSoC students to work on the QuTiP as well as [other supporting organizations](https://qutip.org/#supporting-organizations) that have been supporting QuTiP over the years. Installation; ------------. [![Pip Package](https://img.shields.io/pypi/v/qutip?logo=PyPI)](https://pypi.org/project/qutip); [![Conda-Forge Package](https://img.shields.io/conda/vn/conda-forge/qutip?logo=Conda-Forge)](https://anaconda.org/conda-forge/qutip). QuTiP is available on both `pip` and `conda` (the latter in the `conda-forge` channel).; You can install QuTiP from `pip` by doing. ```bash; pip install qutip; ```. to get the minimal installation.; You can instead use the target `qutip[full]` to install QuTiP with all its optional dependencies.; For more details, including instructions on how to build from source, see [the detailed installation guide in the documentation](https://qutip.readthedocs.io/en/stable/installation.html). All back releases are also available for download in the [releases section of this repository](https://github.com/qutip/qutip/releases), where you can also find per-version changelogs.; For the most complete set of release notes and changelogs for historic versions, see the [changelog](https://qutip.readthedocs.io/en/stable/changelog.html",MatchSource.DOCS,README.md,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/README.md
https://github.com/qutip/qutip/tree/v5.0.4/README.md:3380,Testability,log,logo,3380,"tps://img.shields.io/badge/Supported%20By-UNITARY%20FUND-brightgreen.svg?style=flat)](https://unitary.fund); [![Powered by NumFOCUS](https://img.shields.io/badge/powered%20by-NumFOCUS-orange.svg?style=flat&colorA=E1523D&colorB=007D8A)](https://numfocus.org). We are proud to be affiliated with [Unitary Fund](https://unitary.fund) and [numFOCUS](https://numfocus.org). We are grateful for [Nori's lab](https://dml.riken.jp/) at RIKEN and [Blais' lab](https://www.physique.usherbrooke.ca/blais/) at the Institut Quantique; for providing developer positions to work on QuTiP. We also thank Google for supporting us by financing GSoC students to work on the QuTiP as well as [other supporting organizations](https://qutip.org/#supporting-organizations) that have been supporting QuTiP over the years. Installation; ------------. [![Pip Package](https://img.shields.io/pypi/v/qutip?logo=PyPI)](https://pypi.org/project/qutip); [![Conda-Forge Package](https://img.shields.io/conda/vn/conda-forge/qutip?logo=Conda-Forge)](https://anaconda.org/conda-forge/qutip). QuTiP is available on both `pip` and `conda` (the latter in the `conda-forge` channel).; You can install QuTiP from `pip` by doing. ```bash; pip install qutip; ```. to get the minimal installation.; You can instead use the target `qutip[full]` to install QuTiP with all its optional dependencies.; For more details, including instructions on how to build from source, see [the detailed installation guide in the documentation](https://qutip.readthedocs.io/en/stable/installation.html). All back releases are also available for download in the [releases section of this repository](https://github.com/qutip/qutip/releases), where you can also find per-version changelogs.; For the most complete set of release notes and changelogs for historic versions, see the [changelog](https://qutip.readthedocs.io/en/stable/changelog.html) section in the documentation. The pre-release of QuTiP 5.0 is available on PyPI and can be installed using pip:. ``",MatchSource.DOCS,README.md,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/README.md
https://github.com/qutip/qutip/tree/v5.0.4/README.md:1856,Usability,user-friendly,user-friendly,1856,"lls/qutip/qutip.svg?logo=Coveralls)](https://coveralls.io/r/qutip/qutip); [![Maintainability](https://api.codeclimate.com/v1/badges/df502674f1dfa1f1b67a/maintainability)](https://codeclimate.com/github/qutip/qutip/maintainability); [![license](https://img.shields.io/badge/license-New%20BSD-blue.svg)](https://opensource.org/licenses/BSD-3-Clause); [![PyPi Downloads](https://img.shields.io/pypi/dm/qutip?label=downloads%20%7C%20pip&logo=PyPI)](https://pypi.org/project/qutip); [![Conda-Forge Downloads](https://img.shields.io/conda/dn/conda-forge/qutip?label=downloads%20%7C%20conda&logo=Conda-Forge)](https://anaconda.org/conda-forge/qutip). QuTiP is open-source software for simulating the dynamics of closed and open quantum systems.; It uses the excellent Numpy, Scipy, and Cython packages as numerical backends, and graphical output is provided by Matplotlib.; QuTiP aims to provide user-friendly and efficient numerical simulations of a wide variety of quantum mechanical problems, including those with Hamiltonians and/or collapse operators with arbitrary time-dependence, commonly found in a wide range of physics applications.; QuTiP is freely available for use and/or modification, and it can be used on all Unix-based platforms and on Windows.; Being free of any licensing fees, QuTiP is ideal for exploring quantum mechanics in research as well as in the classroom. Support; -------. [![Unitary Fund](https://img.shields.io/badge/Supported%20By-UNITARY%20FUND-brightgreen.svg?style=flat)](https://unitary.fund); [![Powered by NumFOCUS](https://img.shields.io/badge/powered%20by-NumFOCUS-orange.svg?style=flat&colorA=E1523D&colorB=007D8A)](https://numfocus.org). We are proud to be affiliated with [Unitary Fund](https://unitary.fund) and [numFOCUS](https://numfocus.org). We are grateful for [Nori's lab](https://dml.riken.jp/) at RIKEN and [Blais' lab](https://www.physique.usherbrooke.ca/blais/) at the Institut Quantique; for providing developer positions to work on QuTiP. We also tha",MatchSource.DOCS,README.md,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/README.md
https://github.com/qutip/qutip/tree/v5.0.4/README.md:3839,Usability,guid,guide,3839,"at RIKEN and [Blais' lab](https://www.physique.usherbrooke.ca/blais/) at the Institut Quantique; for providing developer positions to work on QuTiP. We also thank Google for supporting us by financing GSoC students to work on the QuTiP as well as [other supporting organizations](https://qutip.org/#supporting-organizations) that have been supporting QuTiP over the years. Installation; ------------. [![Pip Package](https://img.shields.io/pypi/v/qutip?logo=PyPI)](https://pypi.org/project/qutip); [![Conda-Forge Package](https://img.shields.io/conda/vn/conda-forge/qutip?logo=Conda-Forge)](https://anaconda.org/conda-forge/qutip). QuTiP is available on both `pip` and `conda` (the latter in the `conda-forge` channel).; You can install QuTiP from `pip` by doing. ```bash; pip install qutip; ```. to get the minimal installation.; You can instead use the target `qutip[full]` to install QuTiP with all its optional dependencies.; For more details, including instructions on how to build from source, see [the detailed installation guide in the documentation](https://qutip.readthedocs.io/en/stable/installation.html). All back releases are also available for download in the [releases section of this repository](https://github.com/qutip/qutip/releases), where you can also find per-version changelogs.; For the most complete set of release notes and changelogs for historic versions, see the [changelog](https://qutip.readthedocs.io/en/stable/changelog.html) section in the documentation. The pre-release of QuTiP 5.0 is available on PyPI and can be installed using pip:. ```bash; pip install --pre qutip; ```. This version breaks compatibility with QuTiP 4.7 in many small ways.; Please see the [changelog](https://github.com/qutip/qutip/blob/master/doc/changelog.rst) for a list of changes, new features and deprecations.; This version should be fully working. If you find any bugs, confusing documentation or missing features, please create a GitHub issue. Documentation; -------------. [![Documen",MatchSource.DOCS,README.md,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/README.md
https://github.com/qutip/qutip/tree/v5.0.4/.github/pull_request_template.md:611,Deployability,update,update,611,"**Checklist**; Thank you for contributing to QuTiP! Please make sure you have finished the following tasks before opening the PR. - [ ] Please read [Contributing to QuTiP Development](http://qutip.org/docs/latest/development/contributing.html); - [ ] Contributions to qutip should follow the [pep8 style](https://www.python.org/dev/peps/pep-0008/).; You can use [pycodestyle](http://pycodestyle.pycqa.org/en/latest/index.html) to check your code automatically; - [ ] Please add tests to cover your changes if applicable.; - [ ] If the behavior of the code has changed or new feature has been added, please also update the documentation in the `doc` folder, and the [notebook](https://github.com/qutip/qutip-tutorials). Feel free to ask if you are not sure.; - [ ] Include the changelog in a file named: `doc/changes/<PR number>.<type>` 'type' can be one of the following: feature, bugfix, doc, removal, misc, or deprecation (see [here](http://qutip.org/docs/latest/development/contributing.html#changelog-generation) for more information). Delete this checklist after you have completed all the tasks. If you have not finished them all, you can also open a [Draft Pull Request](https://github.blog/2019-02-14-introducing-draft-pull-requests/) to let the others know this on-going work and keep this checklist in the PR description. **Description**; Describe here the proposed change. **Related issues or PRs**; Please mention the related issues or PRs here. If the PR fixes an issue, use the keyword fix/fixes/fixed followed by the issue id, e.g. fix #1184",MatchSource.DOCS,.github/pull_request_template.md,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/.github/pull_request_template.md
https://github.com/qutip/qutip/tree/v5.0.4/.github/pull_request_template.md:478,Testability,test,tests,478,"**Checklist**; Thank you for contributing to QuTiP! Please make sure you have finished the following tasks before opening the PR. - [ ] Please read [Contributing to QuTiP Development](http://qutip.org/docs/latest/development/contributing.html); - [ ] Contributions to qutip should follow the [pep8 style](https://www.python.org/dev/peps/pep-0008/).; You can use [pycodestyle](http://pycodestyle.pycqa.org/en/latest/index.html) to check your code automatically; - [ ] Please add tests to cover your changes if applicable.; - [ ] If the behavior of the code has changed or new feature has been added, please also update the documentation in the `doc` folder, and the [notebook](https://github.com/qutip/qutip-tutorials). Feel free to ask if you are not sure.; - [ ] Include the changelog in a file named: `doc/changes/<PR number>.<type>` 'type' can be one of the following: feature, bugfix, doc, removal, misc, or deprecation (see [here](http://qutip.org/docs/latest/development/contributing.html#changelog-generation) for more information). Delete this checklist after you have completed all the tasks. If you have not finished them all, you can also open a [Draft Pull Request](https://github.blog/2019-02-14-introducing-draft-pull-requests/) to let the others know this on-going work and keep this checklist in the PR description. **Description**; Describe here the proposed change. **Related issues or PRs**; Please mention the related issues or PRs here. If the PR fixes an issue, use the keyword fix/fixes/fixed followed by the issue id, e.g. fix #1184",MatchSource.DOCS,.github/pull_request_template.md,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/.github/pull_request_template.md
https://github.com/qutip/qutip/tree/v5.0.4/doc/README.md:388,Deployability,install,install,388,"Repository for QuTiP documentation; ==================================. This repository contains the source files for the QuTiP documentation. For pre-built documentation, see https://www.qutip.org/documentation.html. Building; --------. The main Python requirements for the documentation are `sphinx`, `sphinx-gallery`, `sphinx_rtd_theme`, `numpydoc` and `ipython`.; You should build or install the version of QuTiP you want to build the documentation against in the same environment.; You will also need a sensible copy of `make`, and if you want to build the LaTeX documentation then also a `pdflatex` distribution.; As of 2021-04-20, the `conda` recipe for `sphinx_rtd_theme` is rather old compared to the `pip` version, so it's recommended to use a mostly `pip`-managed environment to do the documentation build. The simplest way to get a functional build environment is to use the `requirements.txt` file in this repository, which completely defines a known-good `pip` environment (tested on Python 3.8, but not necessarily limited to it).; If you typically use conda, the way to do this is; ```bash; $ conda create -n qutip-doc-build python=3.8; $ conda activate qutip-doc-build; $ pip install -r /path/to/qutip/doc/requirements.txt; ```; You will also need to build or install the main QuTiP library in the same environment.; If you simply want to build the documentation without editing the main library, you can install a release version of QuTiP with `pip install qutip`.; Otherwise, refer to [the main repository](https://github.com/qutip/qutip) for the current process to build from source.; You need to have the optional QuTiP dependency `Cython` to build the documentation, but this is included in this repository's `requirements.txt` so you do not need to do anything separately. After you have done this, you can effect the build with `make`.; The targets you might want are `html`, `latexpdf` and `clean`, which build the HTML pages, build the PDFs, and delete all built files respec",MatchSource.DOCS,doc/README.md,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/README.md
https://github.com/qutip/qutip/tree/v5.0.4/doc/README.md:1193,Deployability,install,install,1193,".org/documentation.html. Building; --------. The main Python requirements for the documentation are `sphinx`, `sphinx-gallery`, `sphinx_rtd_theme`, `numpydoc` and `ipython`.; You should build or install the version of QuTiP you want to build the documentation against in the same environment.; You will also need a sensible copy of `make`, and if you want to build the LaTeX documentation then also a `pdflatex` distribution.; As of 2021-04-20, the `conda` recipe for `sphinx_rtd_theme` is rather old compared to the `pip` version, so it's recommended to use a mostly `pip`-managed environment to do the documentation build. The simplest way to get a functional build environment is to use the `requirements.txt` file in this repository, which completely defines a known-good `pip` environment (tested on Python 3.8, but not necessarily limited to it).; If you typically use conda, the way to do this is; ```bash; $ conda create -n qutip-doc-build python=3.8; $ conda activate qutip-doc-build; $ pip install -r /path/to/qutip/doc/requirements.txt; ```; You will also need to build or install the main QuTiP library in the same environment.; If you simply want to build the documentation without editing the main library, you can install a release version of QuTiP with `pip install qutip`.; Otherwise, refer to [the main repository](https://github.com/qutip/qutip) for the current process to build from source.; You need to have the optional QuTiP dependency `Cython` to build the documentation, but this is included in this repository's `requirements.txt` so you do not need to do anything separately. After you have done this, you can effect the build with `make`.; The targets you might want are `html`, `latexpdf` and `clean`, which build the HTML pages, build the PDFs, and delete all built files respectively.; For example, to build the HTML files only, use; ```bash; $ make html; ```. *Note (2021-04-20):* the documentation build is currently broken on Windows due to incompatibilities in the ",MatchSource.DOCS,doc/README.md,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/README.md
https://github.com/qutip/qutip/tree/v5.0.4/doc/README.md:1277,Deployability,install,install,1277,"tion are `sphinx`, `sphinx-gallery`, `sphinx_rtd_theme`, `numpydoc` and `ipython`.; You should build or install the version of QuTiP you want to build the documentation against in the same environment.; You will also need a sensible copy of `make`, and if you want to build the LaTeX documentation then also a `pdflatex` distribution.; As of 2021-04-20, the `conda` recipe for `sphinx_rtd_theme` is rather old compared to the `pip` version, so it's recommended to use a mostly `pip`-managed environment to do the documentation build. The simplest way to get a functional build environment is to use the `requirements.txt` file in this repository, which completely defines a known-good `pip` environment (tested on Python 3.8, but not necessarily limited to it).; If you typically use conda, the way to do this is; ```bash; $ conda create -n qutip-doc-build python=3.8; $ conda activate qutip-doc-build; $ pip install -r /path/to/qutip/doc/requirements.txt; ```; You will also need to build or install the main QuTiP library in the same environment.; If you simply want to build the documentation without editing the main library, you can install a release version of QuTiP with `pip install qutip`.; Otherwise, refer to [the main repository](https://github.com/qutip/qutip) for the current process to build from source.; You need to have the optional QuTiP dependency `Cython` to build the documentation, but this is included in this repository's `requirements.txt` so you do not need to do anything separately. After you have done this, you can effect the build with `make`.; The targets you might want are `html`, `latexpdf` and `clean`, which build the HTML pages, build the PDFs, and delete all built files respectively.; For example, to build the HTML files only, use; ```bash; $ make html; ```. *Note (2021-04-20):* the documentation build is currently broken on Windows due to incompatibilities in the main library in multiprocessing components. Writing User Guides; -------------------. The u",MatchSource.DOCS,doc/README.md,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/README.md
https://github.com/qutip/qutip/tree/v5.0.4/doc/README.md:1422,Deployability,install,install,1422," of QuTiP you want to build the documentation against in the same environment.; You will also need a sensible copy of `make`, and if you want to build the LaTeX documentation then also a `pdflatex` distribution.; As of 2021-04-20, the `conda` recipe for `sphinx_rtd_theme` is rather old compared to the `pip` version, so it's recommended to use a mostly `pip`-managed environment to do the documentation build. The simplest way to get a functional build environment is to use the `requirements.txt` file in this repository, which completely defines a known-good `pip` environment (tested on Python 3.8, but not necessarily limited to it).; If you typically use conda, the way to do this is; ```bash; $ conda create -n qutip-doc-build python=3.8; $ conda activate qutip-doc-build; $ pip install -r /path/to/qutip/doc/requirements.txt; ```; You will also need to build or install the main QuTiP library in the same environment.; If you simply want to build the documentation without editing the main library, you can install a release version of QuTiP with `pip install qutip`.; Otherwise, refer to [the main repository](https://github.com/qutip/qutip) for the current process to build from source.; You need to have the optional QuTiP dependency `Cython` to build the documentation, but this is included in this repository's `requirements.txt` so you do not need to do anything separately. After you have done this, you can effect the build with `make`.; The targets you might want are `html`, `latexpdf` and `clean`, which build the HTML pages, build the PDFs, and delete all built files respectively.; For example, to build the HTML files only, use; ```bash; $ make html; ```. *Note (2021-04-20):* the documentation build is currently broken on Windows due to incompatibilities in the main library in multiprocessing components. Writing User Guides; -------------------. The user guide provides an overview of QuTiP's functionality. The guide is composed of individual reStructuredText (`.rst`) file",MatchSource.DOCS,doc/README.md,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/README.md
https://github.com/qutip/qutip/tree/v5.0.4/doc/README.md:1432,Deployability,release,release,1432," of QuTiP you want to build the documentation against in the same environment.; You will also need a sensible copy of `make`, and if you want to build the LaTeX documentation then also a `pdflatex` distribution.; As of 2021-04-20, the `conda` recipe for `sphinx_rtd_theme` is rather old compared to the `pip` version, so it's recommended to use a mostly `pip`-managed environment to do the documentation build. The simplest way to get a functional build environment is to use the `requirements.txt` file in this repository, which completely defines a known-good `pip` environment (tested on Python 3.8, but not necessarily limited to it).; If you typically use conda, the way to do this is; ```bash; $ conda create -n qutip-doc-build python=3.8; $ conda activate qutip-doc-build; $ pip install -r /path/to/qutip/doc/requirements.txt; ```; You will also need to build or install the main QuTiP library in the same environment.; If you simply want to build the documentation without editing the main library, you can install a release version of QuTiP with `pip install qutip`.; Otherwise, refer to [the main repository](https://github.com/qutip/qutip) for the current process to build from source.; You need to have the optional QuTiP dependency `Cython` to build the documentation, but this is included in this repository's `requirements.txt` so you do not need to do anything separately. After you have done this, you can effect the build with `make`.; The targets you might want are `html`, `latexpdf` and `clean`, which build the HTML pages, build the PDFs, and delete all built files respectively.; For example, to build the HTML files only, use; ```bash; $ make html; ```. *Note (2021-04-20):* the documentation build is currently broken on Windows due to incompatibilities in the main library in multiprocessing components. Writing User Guides; -------------------. The user guide provides an overview of QuTiP's functionality. The guide is composed of individual reStructuredText (`.rst`) file",MatchSource.DOCS,doc/README.md,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/README.md
https://github.com/qutip/qutip/tree/v5.0.4/doc/README.md:1467,Deployability,install,install,1467," of QuTiP you want to build the documentation against in the same environment.; You will also need a sensible copy of `make`, and if you want to build the LaTeX documentation then also a `pdflatex` distribution.; As of 2021-04-20, the `conda` recipe for `sphinx_rtd_theme` is rather old compared to the `pip` version, so it's recommended to use a mostly `pip`-managed environment to do the documentation build. The simplest way to get a functional build environment is to use the `requirements.txt` file in this repository, which completely defines a known-good `pip` environment (tested on Python 3.8, but not necessarily limited to it).; If you typically use conda, the way to do this is; ```bash; $ conda create -n qutip-doc-build python=3.8; $ conda activate qutip-doc-build; $ pip install -r /path/to/qutip/doc/requirements.txt; ```; You will also need to build or install the main QuTiP library in the same environment.; If you simply want to build the documentation without editing the main library, you can install a release version of QuTiP with `pip install qutip`.; Otherwise, refer to [the main repository](https://github.com/qutip/qutip) for the current process to build from source.; You need to have the optional QuTiP dependency `Cython` to build the documentation, but this is included in this repository's `requirements.txt` so you do not need to do anything separately. After you have done this, you can effect the build with `make`.; The targets you might want are `html`, `latexpdf` and `clean`, which build the HTML pages, build the PDFs, and delete all built files respectively.; For example, to build the HTML files only, use; ```bash; $ make html; ```. *Note (2021-04-20):* the documentation build is currently broken on Windows due to incompatibilities in the main library in multiprocessing components. Writing User Guides; -------------------. The user guide provides an overview of QuTiP's functionality. The guide is composed of individual reStructuredText (`.rst`) file",MatchSource.DOCS,doc/README.md,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/README.md
https://github.com/qutip/qutip/tree/v5.0.4/doc/README.md:1641,Integrability,depend,dependency,1641,"heme` is rather old compared to the `pip` version, so it's recommended to use a mostly `pip`-managed environment to do the documentation build. The simplest way to get a functional build environment is to use the `requirements.txt` file in this repository, which completely defines a known-good `pip` environment (tested on Python 3.8, but not necessarily limited to it).; If you typically use conda, the way to do this is; ```bash; $ conda create -n qutip-doc-build python=3.8; $ conda activate qutip-doc-build; $ pip install -r /path/to/qutip/doc/requirements.txt; ```; You will also need to build or install the main QuTiP library in the same environment.; If you simply want to build the documentation without editing the main library, you can install a release version of QuTiP with `pip install qutip`.; Otherwise, refer to [the main repository](https://github.com/qutip/qutip) for the current process to build from source.; You need to have the optional QuTiP dependency `Cython` to build the documentation, but this is included in this repository's `requirements.txt` so you do not need to do anything separately. After you have done this, you can effect the build with `make`.; The targets you might want are `html`, `latexpdf` and `clean`, which build the HTML pages, build the PDFs, and delete all built files respectively.; For example, to build the HTML files only, use; ```bash; $ make html; ```. *Note (2021-04-20):* the documentation build is currently broken on Windows due to incompatibilities in the main library in multiprocessing components. Writing User Guides; -------------------. The user guide provides an overview of QuTiP's functionality. The guide is composed of individual reStructuredText (`.rst`) files which each get rendered as a webpage. Each page typically tackles one area of functionality. To learn more about how to write `.rst` files, it is useful to follow the [Sphinx Guide](https://www.sphinx-doc.org/en/master/usage/index.html). The documentation build als",MatchSource.DOCS,doc/README.md,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/README.md
https://github.com/qutip/qutip/tree/v5.0.4/doc/README.md:3157,Modifiability,config,configured,3157," version of QuTiP with `pip install qutip`.; Otherwise, refer to [the main repository](https://github.com/qutip/qutip) for the current process to build from source.; You need to have the optional QuTiP dependency `Cython` to build the documentation, but this is included in this repository's `requirements.txt` so you do not need to do anything separately. After you have done this, you can effect the build with `make`.; The targets you might want are `html`, `latexpdf` and `clean`, which build the HTML pages, build the PDFs, and delete all built files respectively.; For example, to build the HTML files only, use; ```bash; $ make html; ```. *Note (2021-04-20):* the documentation build is currently broken on Windows due to incompatibilities in the main library in multiprocessing components. Writing User Guides; -------------------. The user guide provides an overview of QuTiP's functionality. The guide is composed of individual reStructuredText (`.rst`) files which each get rendered as a webpage. Each page typically tackles one area of functionality. To learn more about how to write `.rst` files, it is useful to follow the [Sphinx Guide](https://www.sphinx-doc.org/en/master/usage/index.html). The documentation build also utilizes a number of [Sphinx Extensions](https://www.sphinx-doc.org/en/master/usage/extensions/index.html) including but not limited to; [doctest](https://www.sphinx-doc.org/en/master/usage/extensions/doctest.html), [autodoc](https://www.sphinx-doc.org/en/master/usage/extensions/autodoc.html), [sphinx gallery](https://sphinx-gallery.github.io/stable/index.html), [plot](https://matthew-brett.github.io/nb2plots/nbplots.html#module-nb2plots.nbplots). Additional extensions can be configured in the `conf.py` file. Tests can also be run on examples in the documentation using the doctest extension; and plots are generated using the `plot` directive. For more specific; guidelines on how to incorporate code examples into the guide, refer to (insert reference).; ",MatchSource.DOCS,doc/README.md,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/README.md
https://github.com/qutip/qutip/tree/v5.0.4/doc/README.md:988,Testability,test,tested,988,"Repository for QuTiP documentation; ==================================. This repository contains the source files for the QuTiP documentation. For pre-built documentation, see https://www.qutip.org/documentation.html. Building; --------. The main Python requirements for the documentation are `sphinx`, `sphinx-gallery`, `sphinx_rtd_theme`, `numpydoc` and `ipython`.; You should build or install the version of QuTiP you want to build the documentation against in the same environment.; You will also need a sensible copy of `make`, and if you want to build the LaTeX documentation then also a `pdflatex` distribution.; As of 2021-04-20, the `conda` recipe for `sphinx_rtd_theme` is rather old compared to the `pip` version, so it's recommended to use a mostly `pip`-managed environment to do the documentation build. The simplest way to get a functional build environment is to use the `requirements.txt` file in this repository, which completely defines a known-good `pip` environment (tested on Python 3.8, but not necessarily limited to it).; If you typically use conda, the way to do this is; ```bash; $ conda create -n qutip-doc-build python=3.8; $ conda activate qutip-doc-build; $ pip install -r /path/to/qutip/doc/requirements.txt; ```; You will also need to build or install the main QuTiP library in the same environment.; If you simply want to build the documentation without editing the main library, you can install a release version of QuTiP with `pip install qutip`.; Otherwise, refer to [the main repository](https://github.com/qutip/qutip) for the current process to build from source.; You need to have the optional QuTiP dependency `Cython` to build the documentation, but this is included in this repository's `requirements.txt` so you do not need to do anything separately. After you have done this, you can effect the build with `make`.; The targets you might want are `html`, `latexpdf` and `clean`, which build the HTML pages, build the PDFs, and delete all built files respec",MatchSource.DOCS,doc/README.md,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/README.md
https://github.com/qutip/qutip/tree/v5.0.4/doc/README.md:822,Usability,simpl,simplest,822,"Repository for QuTiP documentation; ==================================. This repository contains the source files for the QuTiP documentation. For pre-built documentation, see https://www.qutip.org/documentation.html. Building; --------. The main Python requirements for the documentation are `sphinx`, `sphinx-gallery`, `sphinx_rtd_theme`, `numpydoc` and `ipython`.; You should build or install the version of QuTiP you want to build the documentation against in the same environment.; You will also need a sensible copy of `make`, and if you want to build the LaTeX documentation then also a `pdflatex` distribution.; As of 2021-04-20, the `conda` recipe for `sphinx_rtd_theme` is rather old compared to the `pip` version, so it's recommended to use a mostly `pip`-managed environment to do the documentation build. The simplest way to get a functional build environment is to use the `requirements.txt` file in this repository, which completely defines a known-good `pip` environment (tested on Python 3.8, but not necessarily limited to it).; If you typically use conda, the way to do this is; ```bash; $ conda create -n qutip-doc-build python=3.8; $ conda activate qutip-doc-build; $ pip install -r /path/to/qutip/doc/requirements.txt; ```; You will also need to build or install the main QuTiP library in the same environment.; If you simply want to build the documentation without editing the main library, you can install a release version of QuTiP with `pip install qutip`.; Otherwise, refer to [the main repository](https://github.com/qutip/qutip) for the current process to build from source.; You need to have the optional QuTiP dependency `Cython` to build the documentation, but this is included in this repository's `requirements.txt` so you do not need to do anything separately. After you have done this, you can effect the build with `make`.; The targets you might want are `html`, `latexpdf` and `clean`, which build the HTML pages, build the PDFs, and delete all built files respec",MatchSource.DOCS,doc/README.md,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/README.md
https://github.com/qutip/qutip/tree/v5.0.4/doc/README.md:1341,Usability,simpl,simply,1341," of QuTiP you want to build the documentation against in the same environment.; You will also need a sensible copy of `make`, and if you want to build the LaTeX documentation then also a `pdflatex` distribution.; As of 2021-04-20, the `conda` recipe for `sphinx_rtd_theme` is rather old compared to the `pip` version, so it's recommended to use a mostly `pip`-managed environment to do the documentation build. The simplest way to get a functional build environment is to use the `requirements.txt` file in this repository, which completely defines a known-good `pip` environment (tested on Python 3.8, but not necessarily limited to it).; If you typically use conda, the way to do this is; ```bash; $ conda create -n qutip-doc-build python=3.8; $ conda activate qutip-doc-build; $ pip install -r /path/to/qutip/doc/requirements.txt; ```; You will also need to build or install the main QuTiP library in the same environment.; If you simply want to build the documentation without editing the main library, you can install a release version of QuTiP with `pip install qutip`.; Otherwise, refer to [the main repository](https://github.com/qutip/qutip) for the current process to build from source.; You need to have the optional QuTiP dependency `Cython` to build the documentation, but this is included in this repository's `requirements.txt` so you do not need to do anything separately. After you have done this, you can effect the build with `make`.; The targets you might want are `html`, `latexpdf` and `clean`, which build the HTML pages, build the PDFs, and delete all built files respectively.; For example, to build the HTML files only, use; ```bash; $ make html; ```. *Note (2021-04-20):* the documentation build is currently broken on Windows due to incompatibilities in the main library in multiprocessing components. Writing User Guides; -------------------. The user guide provides an overview of QuTiP's functionality. The guide is composed of individual reStructuredText (`.rst`) file",MatchSource.DOCS,doc/README.md,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/README.md
https://github.com/qutip/qutip/tree/v5.0.4/doc/README.md:2288,Usability,guid,guide,2288,"n the same environment.; If you simply want to build the documentation without editing the main library, you can install a release version of QuTiP with `pip install qutip`.; Otherwise, refer to [the main repository](https://github.com/qutip/qutip) for the current process to build from source.; You need to have the optional QuTiP dependency `Cython` to build the documentation, but this is included in this repository's `requirements.txt` so you do not need to do anything separately. After you have done this, you can effect the build with `make`.; The targets you might want are `html`, `latexpdf` and `clean`, which build the HTML pages, build the PDFs, and delete all built files respectively.; For example, to build the HTML files only, use; ```bash; $ make html; ```. *Note (2021-04-20):* the documentation build is currently broken on Windows due to incompatibilities in the main library in multiprocessing components. Writing User Guides; -------------------. The user guide provides an overview of QuTiP's functionality. The guide is composed of individual reStructuredText (`.rst`) files which each get rendered as a webpage. Each page typically tackles one area of functionality. To learn more about how to write `.rst` files, it is useful to follow the [Sphinx Guide](https://www.sphinx-doc.org/en/master/usage/index.html). The documentation build also utilizes a number of [Sphinx Extensions](https://www.sphinx-doc.org/en/master/usage/extensions/index.html) including but not limited to; [doctest](https://www.sphinx-doc.org/en/master/usage/extensions/doctest.html), [autodoc](https://www.sphinx-doc.org/en/master/usage/extensions/autodoc.html), [sphinx gallery](https://sphinx-gallery.github.io/stable/index.html), [plot](https://matthew-brett.github.io/nb2plots/nbplots.html#module-nb2plots.nbplots). Additional extensions can be configured in the `conf.py` file. Tests can also be run on examples in the documentation using the doctest extension; and plots are generated using the ",MatchSource.DOCS,doc/README.md,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/README.md
https://github.com/qutip/qutip/tree/v5.0.4/doc/README.md:2345,Usability,guid,guide,2345,"cumentation without editing the main library, you can install a release version of QuTiP with `pip install qutip`.; Otherwise, refer to [the main repository](https://github.com/qutip/qutip) for the current process to build from source.; You need to have the optional QuTiP dependency `Cython` to build the documentation, but this is included in this repository's `requirements.txt` so you do not need to do anything separately. After you have done this, you can effect the build with `make`.; The targets you might want are `html`, `latexpdf` and `clean`, which build the HTML pages, build the PDFs, and delete all built files respectively.; For example, to build the HTML files only, use; ```bash; $ make html; ```. *Note (2021-04-20):* the documentation build is currently broken on Windows due to incompatibilities in the main library in multiprocessing components. Writing User Guides; -------------------. The user guide provides an overview of QuTiP's functionality. The guide is composed of individual reStructuredText (`.rst`) files which each get rendered as a webpage. Each page typically tackles one area of functionality. To learn more about how to write `.rst` files, it is useful to follow the [Sphinx Guide](https://www.sphinx-doc.org/en/master/usage/index.html). The documentation build also utilizes a number of [Sphinx Extensions](https://www.sphinx-doc.org/en/master/usage/extensions/index.html) including but not limited to; [doctest](https://www.sphinx-doc.org/en/master/usage/extensions/doctest.html), [autodoc](https://www.sphinx-doc.org/en/master/usage/extensions/autodoc.html), [sphinx gallery](https://sphinx-gallery.github.io/stable/index.html), [plot](https://matthew-brett.github.io/nb2plots/nbplots.html#module-nb2plots.nbplots). Additional extensions can be configured in the `conf.py` file. Tests can also be run on examples in the documentation using the doctest extension; and plots are generated using the `plot` directive. For more specific; guidelines on how to in",MatchSource.DOCS,doc/README.md,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/README.md
https://github.com/qutip/qutip/tree/v5.0.4/doc/README.md:2505,Usability,learn,learn,2505," version of QuTiP with `pip install qutip`.; Otherwise, refer to [the main repository](https://github.com/qutip/qutip) for the current process to build from source.; You need to have the optional QuTiP dependency `Cython` to build the documentation, but this is included in this repository's `requirements.txt` so you do not need to do anything separately. After you have done this, you can effect the build with `make`.; The targets you might want are `html`, `latexpdf` and `clean`, which build the HTML pages, build the PDFs, and delete all built files respectively.; For example, to build the HTML files only, use; ```bash; $ make html; ```. *Note (2021-04-20):* the documentation build is currently broken on Windows due to incompatibilities in the main library in multiprocessing components. Writing User Guides; -------------------. The user guide provides an overview of QuTiP's functionality. The guide is composed of individual reStructuredText (`.rst`) files which each get rendered as a webpage. Each page typically tackles one area of functionality. To learn more about how to write `.rst` files, it is useful to follow the [Sphinx Guide](https://www.sphinx-doc.org/en/master/usage/index.html). The documentation build also utilizes a number of [Sphinx Extensions](https://www.sphinx-doc.org/en/master/usage/extensions/index.html) including but not limited to; [doctest](https://www.sphinx-doc.org/en/master/usage/extensions/doctest.html), [autodoc](https://www.sphinx-doc.org/en/master/usage/extensions/autodoc.html), [sphinx gallery](https://sphinx-gallery.github.io/stable/index.html), [plot](https://matthew-brett.github.io/nb2plots/nbplots.html#module-nb2plots.nbplots). Additional extensions can be configured in the `conf.py` file. Tests can also be run on examples in the documentation using the doctest extension; and plots are generated using the `plot` directive. For more specific; guidelines on how to incorporate code examples into the guide, refer to (insert reference).; ",MatchSource.DOCS,doc/README.md,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/README.md
https://github.com/qutip/qutip/tree/v5.0.4/doc/README.md:3346,Usability,guid,guidelines,3346," version of QuTiP with `pip install qutip`.; Otherwise, refer to [the main repository](https://github.com/qutip/qutip) for the current process to build from source.; You need to have the optional QuTiP dependency `Cython` to build the documentation, but this is included in this repository's `requirements.txt` so you do not need to do anything separately. After you have done this, you can effect the build with `make`.; The targets you might want are `html`, `latexpdf` and `clean`, which build the HTML pages, build the PDFs, and delete all built files respectively.; For example, to build the HTML files only, use; ```bash; $ make html; ```. *Note (2021-04-20):* the documentation build is currently broken on Windows due to incompatibilities in the main library in multiprocessing components. Writing User Guides; -------------------. The user guide provides an overview of QuTiP's functionality. The guide is composed of individual reStructuredText (`.rst`) files which each get rendered as a webpage. Each page typically tackles one area of functionality. To learn more about how to write `.rst` files, it is useful to follow the [Sphinx Guide](https://www.sphinx-doc.org/en/master/usage/index.html). The documentation build also utilizes a number of [Sphinx Extensions](https://www.sphinx-doc.org/en/master/usage/extensions/index.html) including but not limited to; [doctest](https://www.sphinx-doc.org/en/master/usage/extensions/doctest.html), [autodoc](https://www.sphinx-doc.org/en/master/usage/extensions/autodoc.html), [sphinx gallery](https://sphinx-gallery.github.io/stable/index.html), [plot](https://matthew-brett.github.io/nb2plots/nbplots.html#module-nb2plots.nbplots). Additional extensions can be configured in the `conf.py` file. Tests can also be run on examples in the documentation using the doctest extension; and plots are generated using the `plot` directive. For more specific; guidelines on how to incorporate code examples into the guide, refer to (insert reference).; ",MatchSource.DOCS,doc/README.md,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/README.md
https://github.com/qutip/qutip/tree/v5.0.4/doc/README.md:3402,Usability,guid,guide,3402," version of QuTiP with `pip install qutip`.; Otherwise, refer to [the main repository](https://github.com/qutip/qutip) for the current process to build from source.; You need to have the optional QuTiP dependency `Cython` to build the documentation, but this is included in this repository's `requirements.txt` so you do not need to do anything separately. After you have done this, you can effect the build with `make`.; The targets you might want are `html`, `latexpdf` and `clean`, which build the HTML pages, build the PDFs, and delete all built files respectively.; For example, to build the HTML files only, use; ```bash; $ make html; ```. *Note (2021-04-20):* the documentation build is currently broken on Windows due to incompatibilities in the main library in multiprocessing components. Writing User Guides; -------------------. The user guide provides an overview of QuTiP's functionality. The guide is composed of individual reStructuredText (`.rst`) files which each get rendered as a webpage. Each page typically tackles one area of functionality. To learn more about how to write `.rst` files, it is useful to follow the [Sphinx Guide](https://www.sphinx-doc.org/en/master/usage/index.html). The documentation build also utilizes a number of [Sphinx Extensions](https://www.sphinx-doc.org/en/master/usage/extensions/index.html) including but not limited to; [doctest](https://www.sphinx-doc.org/en/master/usage/extensions/doctest.html), [autodoc](https://www.sphinx-doc.org/en/master/usage/extensions/autodoc.html), [sphinx gallery](https://sphinx-gallery.github.io/stable/index.html), [plot](https://matthew-brett.github.io/nb2plots/nbplots.html#module-nb2plots.nbplots). Additional extensions can be configured in the `conf.py` file. Tests can also be run on examples in the documentation using the doctest extension; and plots are generated using the `plot` directive. For more specific; guidelines on how to incorporate code examples into the guide, refer to (insert reference).; ",MatchSource.DOCS,doc/README.md,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/README.md
https://github.com/qutip/qutip/tree/v5.0.4/doc/biblio.rst:2709,Performance,optimiz,optimization,2709,"`1111.6950`. .. [dAless08]; D. dAlessandro, *Introduction to Quantum Control and Dynamics*, (Chapman & Hall/CRC, 2008). .. [Byrd95]; R. H. Byrd, P. Lu, J. Nocedal, and C. Zhu, *A Limited Memory Algorithm for Bound Constrained Optimization*, SIAM J. Sci. Comput. **16**, 1190 (1995). :doi:`10.1137/0916069`. .. [Flo12]; F. F. Floether, P. de Fouquieres, and S. G. Schirmer, *Robust quantum gates for open systems via optimal control: Markovian versus non-Markovian dynamics*, New J. Phys. **14**, 073023 (2012). :doi:`10.1088/1367-2630/14/7/073023`. .. [Lloyd14]; S. Lloyd and S. Montangero, *Information theoretical analysis of quantum optimal control*, Phys. Rev. Lett. **113**, 010502 (2014). :doi:`10.1103/PhysRevLett.113.010502`. .. [Doria11]; P. Doria, T. Calarco & S. Montangero, *Optimal Control Technique for Many-Body Quantum Dynamics*, Phys. Rev. Lett. **106**, 190501 (2011). :doi:`10.1103/PhysRevLett.106.190501`. .. [Caneva11]; T. Caneva, T. Calarco, & S. Montangero, *Chopped random-basis quantum optimization*, Phys. Rev. A **84**, 022326 (2011). :doi:`10.1103/PhysRevA.84.022326`. .. [Rach15]; N. Rach, M. M. Mller, T. Calarco, and S. Montangero, *Dressing the chopped-random-basis optimization: A bandwidth-limited access to the trap-free landscape*, Phys. Rev. A. **92**, 062343 (2015). :doi:`10.1103/PhysRevA.92.062343`. .. [Wis09]. Wiseman, H. M. & Milburn, G. J. *Quantum Measurement and Control*, (Cambridge University Press, 2009). .. [NKanej]. N Khaneja et. al. *Optimal control of coupled spin dynamics: Design of NMR pulse sequences by gradient ascent algorithms.* J. Magn. Reson. **172**, 296305 (2005). :doi:`10.1016/j.jmr.2004.11.004`. .. [Donvil22]; B. Donvil, P. Muratore-Ginanneschi, *Quantum trajectory framework for general time-local master equations*, Nat Commun **13**, 4140 (2022). :doi:`10.1038/s41467-022-31533-8`. .. [Abd19]; M. Abdelhafez, D. I. Schuster, J. Koch, *Gradient-based optimal control of open quantum systems using quantumtrajectories and autom",MatchSource.DOCS,doc/biblio.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/biblio.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/biblio.rst:2897,Performance,optimiz,optimization,2897,"apman & Hall/CRC, 2008). .. [Byrd95]; R. H. Byrd, P. Lu, J. Nocedal, and C. Zhu, *A Limited Memory Algorithm for Bound Constrained Optimization*, SIAM J. Sci. Comput. **16**, 1190 (1995). :doi:`10.1137/0916069`. .. [Flo12]; F. F. Floether, P. de Fouquieres, and S. G. Schirmer, *Robust quantum gates for open systems via optimal control: Markovian versus non-Markovian dynamics*, New J. Phys. **14**, 073023 (2012). :doi:`10.1088/1367-2630/14/7/073023`. .. [Lloyd14]; S. Lloyd and S. Montangero, *Information theoretical analysis of quantum optimal control*, Phys. Rev. Lett. **113**, 010502 (2014). :doi:`10.1103/PhysRevLett.113.010502`. .. [Doria11]; P. Doria, T. Calarco & S. Montangero, *Optimal Control Technique for Many-Body Quantum Dynamics*, Phys. Rev. Lett. **106**, 190501 (2011). :doi:`10.1103/PhysRevLett.106.190501`. .. [Caneva11]; T. Caneva, T. Calarco, & S. Montangero, *Chopped random-basis quantum optimization*, Phys. Rev. A **84**, 022326 (2011). :doi:`10.1103/PhysRevA.84.022326`. .. [Rach15]; N. Rach, M. M. Mller, T. Calarco, and S. Montangero, *Dressing the chopped-random-basis optimization: A bandwidth-limited access to the trap-free landscape*, Phys. Rev. A. **92**, 062343 (2015). :doi:`10.1103/PhysRevA.92.062343`. .. [Wis09]. Wiseman, H. M. & Milburn, G. J. *Quantum Measurement and Control*, (Cambridge University Press, 2009). .. [NKanej]. N Khaneja et. al. *Optimal control of coupled spin dynamics: Design of NMR pulse sequences by gradient ascent algorithms.* J. Magn. Reson. **172**, 296305 (2005). :doi:`10.1016/j.jmr.2004.11.004`. .. [Donvil22]; B. Donvil, P. Muratore-Ginanneschi, *Quantum trajectory framework for general time-local master equations*, Nat Commun **13**, 4140 (2022). :doi:`10.1038/s41467-022-31533-8`. .. [Abd19]; M. Abdelhafez, D. I. Schuster, J. Koch, *Gradient-based optimal control of open quantum systems using quantumtrajectories and automatic differentiation*, Phys. Rev. A **99**, 052327 (2019). :doi:`10.1103/PhysRevA.99.052327`.; ",MatchSource.DOCS,doc/biblio.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/biblio.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/biblio.rst:2931,Security,access,access,2931,"apman & Hall/CRC, 2008). .. [Byrd95]; R. H. Byrd, P. Lu, J. Nocedal, and C. Zhu, *A Limited Memory Algorithm for Bound Constrained Optimization*, SIAM J. Sci. Comput. **16**, 1190 (1995). :doi:`10.1137/0916069`. .. [Flo12]; F. F. Floether, P. de Fouquieres, and S. G. Schirmer, *Robust quantum gates for open systems via optimal control: Markovian versus non-Markovian dynamics*, New J. Phys. **14**, 073023 (2012). :doi:`10.1088/1367-2630/14/7/073023`. .. [Lloyd14]; S. Lloyd and S. Montangero, *Information theoretical analysis of quantum optimal control*, Phys. Rev. Lett. **113**, 010502 (2014). :doi:`10.1103/PhysRevLett.113.010502`. .. [Doria11]; P. Doria, T. Calarco & S. Montangero, *Optimal Control Technique for Many-Body Quantum Dynamics*, Phys. Rev. Lett. **106**, 190501 (2011). :doi:`10.1103/PhysRevLett.106.190501`. .. [Caneva11]; T. Caneva, T. Calarco, & S. Montangero, *Chopped random-basis quantum optimization*, Phys. Rev. A **84**, 022326 (2011). :doi:`10.1103/PhysRevA.84.022326`. .. [Rach15]; N. Rach, M. M. Mller, T. Calarco, and S. Montangero, *Dressing the chopped-random-basis optimization: A bandwidth-limited access to the trap-free landscape*, Phys. Rev. A. **92**, 062343 (2015). :doi:`10.1103/PhysRevA.92.062343`. .. [Wis09]. Wiseman, H. M. & Milburn, G. J. *Quantum Measurement and Control*, (Cambridge University Press, 2009). .. [NKanej]. N Khaneja et. al. *Optimal control of coupled spin dynamics: Design of NMR pulse sequences by gradient ascent algorithms.* J. Magn. Reson. **172**, 296305 (2005). :doi:`10.1016/j.jmr.2004.11.004`. .. [Donvil22]; B. Donvil, P. Muratore-Ginanneschi, *Quantum trajectory framework for general time-local master equations*, Nat Commun **13**, 4140 (2022). :doi:`10.1038/s41467-022-31533-8`. .. [Abd19]; M. Abdelhafez, D. I. Schuster, J. Koch, *Gradient-based optimal control of open quantum systems using quantumtrajectories and automatic differentiation*, Phys. Rev. A **99**, 052327 (2019). :doi:`10.1103/PhysRevA.99.052327`.; ",MatchSource.DOCS,doc/biblio.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/biblio.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:221,Availability,error,error,221,".. _changelog:. **********; Change Log; **********. .. towncrier release notes start. QuTiP 5.0.4 (2024-08-30); ========================. Micro release to add support for numpy 2.1. Bug Fixes; ---------. - Fixed rounding error in dicke_trace_function that resulted in negative eigenvalues. (#2466, by Andrey Nikitin). QuTiP 5.0.3 (2024-06-20); ========================. Micro release to add support for numpy 2. Bug Fixes; ---------. - Bug Fix in Process Matrix Rendering. (#2400, by Anush Venkatakrishnan); - Fix steadystate permutation being reversed. (#2443); - Add parallelizing support for `vernN` methods with `mcsolve`. (#2454 by Utkarsh). Documentation; -------------. - Added `qutip.core.gates` to apidoc/functions.rst and a Gates section to guide-states.rst. (#2441, by alan-nala). Miscellaneous; -------------. - Add support for numpy 2 (#2421, #2457); - Add support for scipy 1.14 (#2469). QuTiP 5.0.2 (2024-05-16); ========================. Bug Fixes; ---------. - Use CSR as the default for expand_operator (#2380, by BoxiLi); - Fix import of the partial_transpose function.; Ensures that the negativity function can handle both kets and density operators as input. (#2371, by vikas-chaudhary-2802); - Ensure that end_condition of mcsolve result doesn't say target tolerance reached when it hasn't (#2382, by magzpavz); - Fix two bugs in steadystate floquet solver, and adjust tests to be sensitive to this issue. (#2393, by Neill Lambert). Documentation; -------------. - Correct a mistake in the doc (#2401, by PositroniumJS); - Fix #2156: Correct a sample of code in the doc (#2409, by PositroniumJS). Miscellaneous; -------------. - Better metadata management in operators creation functions (#2388); - Implicitly set minimum python version to 3.9 (#2413); - Qobj.__eq__ uses core's settings rtol. (#2425); - Only normalize solver states when the initial state is already normalized. (#2427). QuTiP 5.0.1 (2024-04-03); ========================. Patch update fixing small issues with ",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:1279,Availability,toler,tolerance,1279,"drey Nikitin). QuTiP 5.0.3 (2024-06-20); ========================. Micro release to add support for numpy 2. Bug Fixes; ---------. - Bug Fix in Process Matrix Rendering. (#2400, by Anush Venkatakrishnan); - Fix steadystate permutation being reversed. (#2443); - Add parallelizing support for `vernN` methods with `mcsolve`. (#2454 by Utkarsh). Documentation; -------------. - Added `qutip.core.gates` to apidoc/functions.rst and a Gates section to guide-states.rst. (#2441, by alan-nala). Miscellaneous; -------------. - Add support for numpy 2 (#2421, #2457); - Add support for scipy 1.14 (#2469). QuTiP 5.0.2 (2024-05-16); ========================. Bug Fixes; ---------. - Use CSR as the default for expand_operator (#2380, by BoxiLi); - Fix import of the partial_transpose function.; Ensures that the negativity function can handle both kets and density operators as input. (#2371, by vikas-chaudhary-2802); - Ensure that end_condition of mcsolve result doesn't say target tolerance reached when it hasn't (#2382, by magzpavz); - Fix two bugs in steadystate floquet solver, and adjust tests to be sensitive to this issue. (#2393, by Neill Lambert). Documentation; -------------. - Correct a mistake in the doc (#2401, by PositroniumJS); - Fix #2156: Correct a sample of code in the doc (#2409, by PositroniumJS). Miscellaneous; -------------. - Better metadata management in operators creation functions (#2388); - Implicitly set minimum python version to 3.9 (#2413); - Qobj.__eq__ uses core's settings rtol. (#2425); - Only normalize solver states when the initial state is already normalized. (#2427). QuTiP 5.0.1 (2024-04-03); ========================. Patch update fixing small issues with v5.0.0 release. - Fix broken links in the documentation when migrating to readthedocs; - Fix readthedocs search feature; - Add setuptools to runtime compilation requirements; - Fix mcsolve documentation for open systems; - Fix OverFlowError in progress bars. QuTiP 5.0.0 (2024-03-26); =================",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:10436,Availability,avail,available,10436,"on installed, `#2110 <https://github.com/qutip/qutip/pull/2110>`); - Harsh Khilawala (Moved HTMLProgressBar from qutip/ipynbtools.py to qutip/ui/progressbar.py, `#2112 <https://github.com/qutip/qutip/pull/2112>`); - Avatar Srinidhi P V (Added new argument bc_type to take boundary conditions when creating QobjEvo, `#2114 <https://github.com/qutip/qutip/pull/2114>`); - Andrey Rakhubovsky (Fix types in docstring of projection(), `#2363 <https://github.com/qutip/qutip/pull/2363>`). Qobj changes; ------------. Previously ``Qobj`` data was stored in a SciPy-like sparse matrix. Now the; representation is flexible. Implementations for dense and sparse formats are; included in QuTiP and custom implementations are possible. QuTiP's performance; on dense states and operators is significantly improved as a result. Some highlights:. - The data is still acessible via the ``.data`` attribute, but is now an; instance of the underlying data type instead of a SciPy-like sparse matrix.; The operations available in ``qutip.core.data`` may be used on ``.data``,; regardless of the data type.; - ``Qobj`` with different data types may be mixed in arithmetic and other; operations. A sensible output type will be automatically determined.; - The new ``.to(...)`` method may be used to convert a ``Qobj`` from one data type; to another. E.g. ``.to(""dense"")`` will convert to the dense representation and; ``.to(""csr"")`` will convert to the sparse type.; - Many ``Qobj`` methods and methods that create ``Qobj`` now accepted a ``dtype``; parameter that allows the data type of the returned ``Qobj`` to specified.; - The new ``&`` operator may be used to obtain the tensor product.; - The new ``@`` operator may be used to obtain the matrix / operator product.; ``bar @ ket`` returns a scalar.; - The new ``.contract()`` method will collapse 1D subspaces of the dimensions of; the ``Qobj``.; - The new ``.logm()`` method returns the matrix logarithm of an operator.; - The methods ``.set_data``, ``.get_data``,",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:15089,Availability,avail,available,15089,"- Solver options are now supplied in an ordinary Python dict.; ``qutip.Options`` is deprecated and returns a dict for backwards; compatibility.; - A specific ODE integrator may be selected by supplying a; ``method`` option.; - Each solver provides a class interface. Creating an instance; of the class allows a solver to be run multiple times for the; same system without having to repeatedly reconstruct the; right-hand side of the ODE to be integrated.; - A ``QobjEvo`` instance is accepted for most operators, e.g.,; ``H``, ``c_ops``, ``e_ops``, ``a_ops``.; - The progress bar is now selected using the ``progress_bar`` option.; A new progess bar using the ``tqdm`` Python library is provided.; - Dynamic arguments, where the value of an operator depends on; the current state of the evolution interface reworked. Now a property of the; solver is to be used as an arguments:; ``args={""state"": MESolver.StateFeedback(default=rho0)}``. Integrators:. - The SciPy zvode integrator is available with the BDF and; Adams methods as ``bdf`` and ``adams``.; - The SciPy dop853 integrator (an eighth order Runge-Kutta method by; Dormand & Prince) is available as ``dop853``.; - The SciPy lsoda integrator is available as ``lsoda``.; - QuTiP's own implementation of Verner's ""most efficient"" Runge-Kutta methods; of order 7 and 9 are available as ``vern7`` and ``vern9``. See; http://people.math.sfu.ca/~jverner/ for a description of the methods.; - QuTiP's own implementation of a solver that directly diagonalizes the; the system to be integrated is available as ``diag``. It only works on; time-independent systems and is slow to setup, but once the diagonalization; is complete, it generates solutions very quickly.; - QuTiP's own implementatoin of an approximate Krylov subspace integrator is; available as ``krylov``. This integrator is only usable with ``sesolve``. Result class:. - A new ``.e_data`` attribute provides expectation values as a dictionary.; Unlike ``.expect``, the values are provided ",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:15249,Availability,avail,available,15249," dict for backwards; compatibility.; - A specific ODE integrator may be selected by supplying a; ``method`` option.; - Each solver provides a class interface. Creating an instance; of the class allows a solver to be run multiple times for the; same system without having to repeatedly reconstruct the; right-hand side of the ODE to be integrated.; - A ``QobjEvo`` instance is accepted for most operators, e.g.,; ``H``, ``c_ops``, ``e_ops``, ``a_ops``.; - The progress bar is now selected using the ``progress_bar`` option.; A new progess bar using the ``tqdm`` Python library is provided.; - Dynamic arguments, where the value of an operator depends on; the current state of the evolution interface reworked. Now a property of the; solver is to be used as an arguments:; ``args={""state"": MESolver.StateFeedback(default=rho0)}``. Integrators:. - The SciPy zvode integrator is available with the BDF and; Adams methods as ``bdf`` and ``adams``.; - The SciPy dop853 integrator (an eighth order Runge-Kutta method by; Dormand & Prince) is available as ``dop853``.; - The SciPy lsoda integrator is available as ``lsoda``.; - QuTiP's own implementation of Verner's ""most efficient"" Runge-Kutta methods; of order 7 and 9 are available as ``vern7`` and ``vern9``. See; http://people.math.sfu.ca/~jverner/ for a description of the methods.; - QuTiP's own implementation of a solver that directly diagonalizes the; the system to be integrated is available as ``diag``. It only works on; time-independent systems and is slow to setup, but once the diagonalization; is complete, it generates solutions very quickly.; - QuTiP's own implementatoin of an approximate Krylov subspace integrator is; available as ``krylov``. This integrator is only usable with ``sesolve``. Result class:. - A new ``.e_data`` attribute provides expectation values as a dictionary.; Unlike ``.expect``, the values are provided in a Python list rather than; a numpy array, which better supports non-numeric types.; - The contents of the ",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:15307,Availability,avail,available,15307,"plying a; ``method`` option.; - Each solver provides a class interface. Creating an instance; of the class allows a solver to be run multiple times for the; same system without having to repeatedly reconstruct the; right-hand side of the ODE to be integrated.; - A ``QobjEvo`` instance is accepted for most operators, e.g.,; ``H``, ``c_ops``, ``e_ops``, ``a_ops``.; - The progress bar is now selected using the ``progress_bar`` option.; A new progess bar using the ``tqdm`` Python library is provided.; - Dynamic arguments, where the value of an operator depends on; the current state of the evolution interface reworked. Now a property of the; solver is to be used as an arguments:; ``args={""state"": MESolver.StateFeedback(default=rho0)}``. Integrators:. - The SciPy zvode integrator is available with the BDF and; Adams methods as ``bdf`` and ``adams``.; - The SciPy dop853 integrator (an eighth order Runge-Kutta method by; Dormand & Prince) is available as ``dop853``.; - The SciPy lsoda integrator is available as ``lsoda``.; - QuTiP's own implementation of Verner's ""most efficient"" Runge-Kutta methods; of order 7 and 9 are available as ``vern7`` and ``vern9``. See; http://people.math.sfu.ca/~jverner/ for a description of the methods.; - QuTiP's own implementation of a solver that directly diagonalizes the; the system to be integrated is available as ``diag``. It only works on; time-independent systems and is slow to setup, but once the diagonalization; is complete, it generates solutions very quickly.; - QuTiP's own implementatoin of an approximate Krylov subspace integrator is; available as ``krylov``. This integrator is only usable with ``sesolve``. Result class:. - A new ``.e_data`` attribute provides expectation values as a dictionary.; Unlike ``.expect``, the values are provided in a Python list rather than; a numpy array, which better supports non-numeric types.; - The contents of the ``.stats`` attribute changed significantly and is; now more consistent across solvers. ",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:15432,Availability,avail,available,15432,"he class allows a solver to be run multiple times for the; same system without having to repeatedly reconstruct the; right-hand side of the ODE to be integrated.; - A ``QobjEvo`` instance is accepted for most operators, e.g.,; ``H``, ``c_ops``, ``e_ops``, ``a_ops``.; - The progress bar is now selected using the ``progress_bar`` option.; A new progess bar using the ``tqdm`` Python library is provided.; - Dynamic arguments, where the value of an operator depends on; the current state of the evolution interface reworked. Now a property of the; solver is to be used as an arguments:; ``args={""state"": MESolver.StateFeedback(default=rho0)}``. Integrators:. - The SciPy zvode integrator is available with the BDF and; Adams methods as ``bdf`` and ``adams``.; - The SciPy dop853 integrator (an eighth order Runge-Kutta method by; Dormand & Prince) is available as ``dop853``.; - The SciPy lsoda integrator is available as ``lsoda``.; - QuTiP's own implementation of Verner's ""most efficient"" Runge-Kutta methods; of order 7 and 9 are available as ``vern7`` and ``vern9``. See; http://people.math.sfu.ca/~jverner/ for a description of the methods.; - QuTiP's own implementation of a solver that directly diagonalizes the; the system to be integrated is available as ``diag``. It only works on; time-independent systems and is slow to setup, but once the diagonalization; is complete, it generates solutions very quickly.; - QuTiP's own implementatoin of an approximate Krylov subspace integrator is; available as ``krylov``. This integrator is only usable with ``sesolve``. Result class:. - A new ``.e_data`` attribute provides expectation values as a dictionary.; Unlike ``.expect``, the values are provided in a Python list rather than; a numpy array, which better supports non-numeric types.; - The contents of the ``.stats`` attribute changed significantly and is; now more consistent across solvers. Monte-Carlo Solver (mcsolve):. - The system, H, may now be a super-operator.; - The ``seed`` param",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:15650,Availability,avail,available,15650,"operators, e.g.,; ``H``, ``c_ops``, ``e_ops``, ``a_ops``.; - The progress bar is now selected using the ``progress_bar`` option.; A new progess bar using the ``tqdm`` Python library is provided.; - Dynamic arguments, where the value of an operator depends on; the current state of the evolution interface reworked. Now a property of the; solver is to be used as an arguments:; ``args={""state"": MESolver.StateFeedback(default=rho0)}``. Integrators:. - The SciPy zvode integrator is available with the BDF and; Adams methods as ``bdf`` and ``adams``.; - The SciPy dop853 integrator (an eighth order Runge-Kutta method by; Dormand & Prince) is available as ``dop853``.; - The SciPy lsoda integrator is available as ``lsoda``.; - QuTiP's own implementation of Verner's ""most efficient"" Runge-Kutta methods; of order 7 and 9 are available as ``vern7`` and ``vern9``. See; http://people.math.sfu.ca/~jverner/ for a description of the methods.; - QuTiP's own implementation of a solver that directly diagonalizes the; the system to be integrated is available as ``diag``. It only works on; time-independent systems and is slow to setup, but once the diagonalization; is complete, it generates solutions very quickly.; - QuTiP's own implementatoin of an approximate Krylov subspace integrator is; available as ``krylov``. This integrator is only usable with ``sesolve``. Result class:. - A new ``.e_data`` attribute provides expectation values as a dictionary.; Unlike ``.expect``, the values are provided in a Python list rather than; a numpy array, which better supports non-numeric types.; - The contents of the ``.stats`` attribute changed significantly and is; now more consistent across solvers. Monte-Carlo Solver (mcsolve):. - The system, H, may now be a super-operator.; - The ``seed`` parameter now supports supplying numpy ``SeedSequence`` or; ``Generator`` types.; - The new ``timeout`` and ``target_tol`` parameters allow the solver to exit; early if a timeout or target tolerance is reached.; -",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:15897,Availability,avail,available,15897,"he current state of the evolution interface reworked. Now a property of the; solver is to be used as an arguments:; ``args={""state"": MESolver.StateFeedback(default=rho0)}``. Integrators:. - The SciPy zvode integrator is available with the BDF and; Adams methods as ``bdf`` and ``adams``.; - The SciPy dop853 integrator (an eighth order Runge-Kutta method by; Dormand & Prince) is available as ``dop853``.; - The SciPy lsoda integrator is available as ``lsoda``.; - QuTiP's own implementation of Verner's ""most efficient"" Runge-Kutta methods; of order 7 and 9 are available as ``vern7`` and ``vern9``. See; http://people.math.sfu.ca/~jverner/ for a description of the methods.; - QuTiP's own implementation of a solver that directly diagonalizes the; the system to be integrated is available as ``diag``. It only works on; time-independent systems and is slow to setup, but once the diagonalization; is complete, it generates solutions very quickly.; - QuTiP's own implementatoin of an approximate Krylov subspace integrator is; available as ``krylov``. This integrator is only usable with ``sesolve``. Result class:. - A new ``.e_data`` attribute provides expectation values as a dictionary.; Unlike ``.expect``, the values are provided in a Python list rather than; a numpy array, which better supports non-numeric types.; - The contents of the ``.stats`` attribute changed significantly and is; now more consistent across solvers. Monte-Carlo Solver (mcsolve):. - The system, H, may now be a super-operator.; - The ``seed`` parameter now supports supplying numpy ``SeedSequence`` or; ``Generator`` types.; - The new ``timeout`` and ``target_tol`` parameters allow the solver to exit; early if a timeout or target tolerance is reached.; - The ntraj option no longer supports a list of numbers of trajectories.; Instead, just run the solver multiple times and use the class ``MCSolver``; if setting up the solver uses a significant amount of time.; - The ``map_func`` parameter has been replaced by t",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:16584,Availability,toler,tolerance,16584,"ods.; - QuTiP's own implementation of a solver that directly diagonalizes the; the system to be integrated is available as ``diag``. It only works on; time-independent systems and is slow to setup, but once the diagonalization; is complete, it generates solutions very quickly.; - QuTiP's own implementatoin of an approximate Krylov subspace integrator is; available as ``krylov``. This integrator is only usable with ``sesolve``. Result class:. - A new ``.e_data`` attribute provides expectation values as a dictionary.; Unlike ``.expect``, the values are provided in a Python list rather than; a numpy array, which better supports non-numeric types.; - The contents of the ``.stats`` attribute changed significantly and is; now more consistent across solvers. Monte-Carlo Solver (mcsolve):. - The system, H, may now be a super-operator.; - The ``seed`` parameter now supports supplying numpy ``SeedSequence`` or; ``Generator`` types.; - The new ``timeout`` and ``target_tol`` parameters allow the solver to exit; early if a timeout or target tolerance is reached.; - The ntraj option no longer supports a list of numbers of trajectories.; Instead, just run the solver multiple times and use the class ``MCSolver``; if setting up the solver uses a significant amount of time.; - The ``map_func`` parameter has been replaced by the ``map`` option.; - A loky based parallel map as been added.; - A mpi based parallel map as been added.; - The result returned by ``mcsolve`` now supports calculating photocurrents; and calculating the steady state over N trajectories.; - The old ``parfor`` parallel execution function has been removed from; ``qutip.parallel``. Use ``parallel_map``, ``loky_map`` or ``mpi_pmap`` instead.; - Added improved sampling options which converge much faster when the; probability of collapse is small. Non Markovian Monte-Carlo Solver (nm_mcsolve):. - New Monte-Carlo Solver supporting negative decay rates.; - Based on the influence martingale approach, Donvil et al., Nat Co",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:17638,Availability,avail,available,17638,"- The ntraj option no longer supports a list of numbers of trajectories.; Instead, just run the solver multiple times and use the class ``MCSolver``; if setting up the solver uses a significant amount of time.; - The ``map_func`` parameter has been replaced by the ``map`` option.; - A loky based parallel map as been added.; - A mpi based parallel map as been added.; - The result returned by ``mcsolve`` now supports calculating photocurrents; and calculating the steady state over N trajectories.; - The old ``parfor`` parallel execution function has been removed from; ``qutip.parallel``. Use ``parallel_map``, ``loky_map`` or ``mpi_pmap`` instead.; - Added improved sampling options which converge much faster when the; probability of collapse is small. Non Markovian Monte-Carlo Solver (nm_mcsolve):. - New Monte-Carlo Solver supporting negative decay rates.; - Based on the influence martingale approach, Donvil et al., Nat Commun 13, 4140 (2022).; - Most of the improvements made to the regular Monte-Carlo solver are also available here.; - The value of the influence martingale is available through the ``.trace`` attribute of the result. Stochastic Equation Solvers (ssesolve, smesolve). - Function call greatly changed: many keyword arguments are now options.; - m_ops and dW_factors are now changed from the default from the new class interface only.; - Use the same parallel maps as mcsolve: support for loky and mpi map added.; - End conditions ``timeout`` and ``target_tol`` added.; - The ``seed`` parameter now supports supplying numpy ``SeedSequence``.; - Wiener function is now available as a feedback. Bloch-Redfield Master Equation Solver (brmesolve):. - The ``a_ops`` and ``spectra`` support implementations been heavily reworked to; reuse the techniques from the new Coefficient and QobjEvo classes.; - The ``use_secular`` parameter has been removed. Use ``sec_cutoff=-1`` instead.; - The required tolerance is now read from ``qutip.settings``. Krylov Subspace Solver (krylovso",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:17698,Availability,avail,available,17698,", just run the solver multiple times and use the class ``MCSolver``; if setting up the solver uses a significant amount of time.; - The ``map_func`` parameter has been replaced by the ``map`` option.; - A loky based parallel map as been added.; - A mpi based parallel map as been added.; - The result returned by ``mcsolve`` now supports calculating photocurrents; and calculating the steady state over N trajectories.; - The old ``parfor`` parallel execution function has been removed from; ``qutip.parallel``. Use ``parallel_map``, ``loky_map`` or ``mpi_pmap`` instead.; - Added improved sampling options which converge much faster when the; probability of collapse is small. Non Markovian Monte-Carlo Solver (nm_mcsolve):. - New Monte-Carlo Solver supporting negative decay rates.; - Based on the influence martingale approach, Donvil et al., Nat Commun 13, 4140 (2022).; - Most of the improvements made to the regular Monte-Carlo solver are also available here.; - The value of the influence martingale is available through the ``.trace`` attribute of the result. Stochastic Equation Solvers (ssesolve, smesolve). - Function call greatly changed: many keyword arguments are now options.; - m_ops and dW_factors are now changed from the default from the new class interface only.; - Use the same parallel maps as mcsolve: support for loky and mpi map added.; - End conditions ``timeout`` and ``target_tol`` added.; - The ``seed`` parameter now supports supplying numpy ``SeedSequence``.; - Wiener function is now available as a feedback. Bloch-Redfield Master Equation Solver (brmesolve):. - The ``a_ops`` and ``spectra`` support implementations been heavily reworked to; reuse the techniques from the new Coefficient and QobjEvo classes.; - The ``use_secular`` parameter has been removed. Use ``sec_cutoff=-1`` instead.; - The required tolerance is now read from ``qutip.settings``. Krylov Subspace Solver (krylovsolve):. - The Krylov solver is now implemented using ``SESolver`` and the ``krylov",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:18204,Availability,avail,available,18204,"e ``parallel_map``, ``loky_map`` or ``mpi_pmap`` instead.; - Added improved sampling options which converge much faster when the; probability of collapse is small. Non Markovian Monte-Carlo Solver (nm_mcsolve):. - New Monte-Carlo Solver supporting negative decay rates.; - Based on the influence martingale approach, Donvil et al., Nat Commun 13, 4140 (2022).; - Most of the improvements made to the regular Monte-Carlo solver are also available here.; - The value of the influence martingale is available through the ``.trace`` attribute of the result. Stochastic Equation Solvers (ssesolve, smesolve). - Function call greatly changed: many keyword arguments are now options.; - m_ops and dW_factors are now changed from the default from the new class interface only.; - Use the same parallel maps as mcsolve: support for loky and mpi map added.; - End conditions ``timeout`` and ``target_tol`` added.; - The ``seed`` parameter now supports supplying numpy ``SeedSequence``.; - Wiener function is now available as a feedback. Bloch-Redfield Master Equation Solver (brmesolve):. - The ``a_ops`` and ``spectra`` support implementations been heavily reworked to; reuse the techniques from the new Coefficient and QobjEvo classes.; - The ``use_secular`` parameter has been removed. Use ``sec_cutoff=-1`` instead.; - The required tolerance is now read from ``qutip.settings``. Krylov Subspace Solver (krylovsolve):. - The Krylov solver is now implemented using ``SESolver`` and the ``krylov``; ODE integrator. The function ``krylovsolve`` is maintained for convenience; and now supports many more options.; - The ``sparse`` parameter has been removed. Supply a sparse ``Qobj`` for the; Hamiltonian instead. Floquet Solver (fsesolve and fmmesolve):. - The Floquet solver has been rewritten to use a new ``FloquetBasis`` class; which manages the transformations from lab to Floquet basis and back.; - Many of the internal methods used by the old Floquet solvers have; been removed. The Floquet tensor may st",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:18528,Availability,toler,tolerance,18528," Commun 13, 4140 (2022).; - Most of the improvements made to the regular Monte-Carlo solver are also available here.; - The value of the influence martingale is available through the ``.trace`` attribute of the result. Stochastic Equation Solvers (ssesolve, smesolve). - Function call greatly changed: many keyword arguments are now options.; - m_ops and dW_factors are now changed from the default from the new class interface only.; - Use the same parallel maps as mcsolve: support for loky and mpi map added.; - End conditions ``timeout`` and ``target_tol`` added.; - The ``seed`` parameter now supports supplying numpy ``SeedSequence``.; - Wiener function is now available as a feedback. Bloch-Redfield Master Equation Solver (brmesolve):. - The ``a_ops`` and ``spectra`` support implementations been heavily reworked to; reuse the techniques from the new Coefficient and QobjEvo classes.; - The ``use_secular`` parameter has been removed. Use ``sec_cutoff=-1`` instead.; - The required tolerance is now read from ``qutip.settings``. Krylov Subspace Solver (krylovsolve):. - The Krylov solver is now implemented using ``SESolver`` and the ``krylov``; ODE integrator. The function ``krylovsolve`` is maintained for convenience; and now supports many more options.; - The ``sparse`` parameter has been removed. Supply a sparse ``Qobj`` for the; Hamiltonian instead. Floquet Solver (fsesolve and fmmesolve):. - The Floquet solver has been rewritten to use a new ``FloquetBasis`` class; which manages the transformations from lab to Floquet basis and back.; - Many of the internal methods used by the old Floquet solvers have; been removed. The Floquet tensor may still be retried using; the function ``floquet_tensor``.; - The Floquet Markov Master Equation solver has had many changes and; new options added. The environment temperature may be specified using; ``w_th``, and the result states are stored in the lab basis and optionally; in the Floquet basis using ``store_floquet_state``.; - The sp",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:24558,Availability,toler,tolerance,24558,"he ``target`` parameter for; expanding the measurement operator removed. Used ``expand_operator``; to expand the operator instead.; - ``qutip.Bloch`` now supports applying colours per-point, state or vector in; ``add_point``, ``add_states``, and ``add_vectors``.; - Dimensions use a class instead of layered lists.; - Allow measurement functions to support degenerate operators.; - Add ``qeye_like`` and ``qzero_like``.; - Added fermionic annihilation and creation operators. QuTiP settings; --------------. Previously ``qutip.settings`` was an ordinary module. Now ``qutip.settings`` is; an instance of a settings class. All the runtime modifiable settings for; core operations are in ``qutip.settings.core``. The other settings are not; modifiable at runtime. - Removed ``load``. ``reset`` and ``save`` functions.; - Removed ``.debug``, ``.fortran``, ``.openmp_thresh``.; - New ``.compile`` stores the compilation options for compiled coefficients.; - New ``.core[""rtol""]`` core option gives the default relative tolerance used by QuTiP.; - The absolute tolerance setting ``.atol`` has been moved to ``.core[""atol""]``. Visualization; -------------. - Added arguments to ``plot_wigner`` and ``plot_wigner_fock_distribution`` to specify parameters for ``wigner``.; - Removed ``Bloch3D``. The same functionality is provided by ``Bloch``.; - Added ``fig``, ``ax`` and ``cmap`` keyword arguments to all visualization functions.; - Most visualization functions now respect the ``colorblind_safe`` setting.; - Added new functions to create animations from a list of ``Qobj`` or directly from solver results with saved states. Package reorganization; ----------------------. - ``qutip.qip`` has been moved into its own package, qutip-qip. Once installed, qutip-qip is available as either ``qutip.qip`` or ``qutip_qip``. Some widely useful gates have been retained in ``qutip.gates``.; - ``qutip.control`` has been moved to qutip-qtrl and once installed qutip-qtrl is available as either ``qutip.control`` o",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:24599,Availability,toler,tolerance,24599,"rator removed. Used ``expand_operator``; to expand the operator instead.; - ``qutip.Bloch`` now supports applying colours per-point, state or vector in; ``add_point``, ``add_states``, and ``add_vectors``.; - Dimensions use a class instead of layered lists.; - Allow measurement functions to support degenerate operators.; - Add ``qeye_like`` and ``qzero_like``.; - Added fermionic annihilation and creation operators. QuTiP settings; --------------. Previously ``qutip.settings`` was an ordinary module. Now ``qutip.settings`` is; an instance of a settings class. All the runtime modifiable settings for; core operations are in ``qutip.settings.core``. The other settings are not; modifiable at runtime. - Removed ``load``. ``reset`` and ``save`` functions.; - Removed ``.debug``, ``.fortran``, ``.openmp_thresh``.; - New ``.compile`` stores the compilation options for compiled coefficients.; - New ``.core[""rtol""]`` core option gives the default relative tolerance used by QuTiP.; - The absolute tolerance setting ``.atol`` has been moved to ``.core[""atol""]``. Visualization; -------------. - Added arguments to ``plot_wigner`` and ``plot_wigner_fock_distribution`` to specify parameters for ``wigner``.; - Removed ``Bloch3D``. The same functionality is provided by ``Bloch``.; - Added ``fig``, ``ax`` and ``cmap`` keyword arguments to all visualization functions.; - Most visualization functions now respect the ``colorblind_safe`` setting.; - Added new functions to create animations from a list of ``Qobj`` or directly from solver results with saved states. Package reorganization; ----------------------. - ``qutip.qip`` has been moved into its own package, qutip-qip. Once installed, qutip-qip is available as either ``qutip.qip`` or ``qutip_qip``. Some widely useful gates have been retained in ``qutip.gates``.; - ``qutip.control`` has been moved to qutip-qtrl and once installed qutip-qtrl is available as either ``qutip.control`` or ``qutip_qtrl``. Note that ``quitp_qtrl`` is provided pri",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:25305,Availability,avail,available,25305," - Removed ``load``. ``reset`` and ``save`` functions.; - Removed ``.debug``, ``.fortran``, ``.openmp_thresh``.; - New ``.compile`` stores the compilation options for compiled coefficients.; - New ``.core[""rtol""]`` core option gives the default relative tolerance used by QuTiP.; - The absolute tolerance setting ``.atol`` has been moved to ``.core[""atol""]``. Visualization; -------------. - Added arguments to ``plot_wigner`` and ``plot_wigner_fock_distribution`` to specify parameters for ``wigner``.; - Removed ``Bloch3D``. The same functionality is provided by ``Bloch``.; - Added ``fig``, ``ax`` and ``cmap`` keyword arguments to all visualization functions.; - Most visualization functions now respect the ``colorblind_safe`` setting.; - Added new functions to create animations from a list of ``Qobj`` or directly from solver results with saved states. Package reorganization; ----------------------. - ``qutip.qip`` has been moved into its own package, qutip-qip. Once installed, qutip-qip is available as either ``qutip.qip`` or ``qutip_qip``. Some widely useful gates have been retained in ``qutip.gates``.; - ``qutip.control`` has been moved to qutip-qtrl and once installed qutip-qtrl is available as either ``qutip.control`` or ``qutip_qtrl``. Note that ``quitp_qtrl`` is provided primarily for backwards compatibility. Improvements to optimal control will take place in the new ``qutip_qoc`` package.; - ``qutip.lattice`` has been moved into its own package, qutip-lattice. It is available from `<https://github.com/qutip/qutip-lattice>`.; - ``qutip.sparse`` has been removed. It contained the old sparse matrix representation and is replaced by the new implementation in ``qutip.data``.; - ``qutip.piqs`` functions are no longer available from the ``qutip`` namespace. They are accessible from ``qutip.piqs`` instead. Miscellaneous; -------------. - Support has been added for 64-bit integer sparse matrix indices, allowing; sparse matrices with up to 2**63 rows and columns. This supp",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:25504,Availability,avail,available,25504,"efficients.; - New ``.core[""rtol""]`` core option gives the default relative tolerance used by QuTiP.; - The absolute tolerance setting ``.atol`` has been moved to ``.core[""atol""]``. Visualization; -------------. - Added arguments to ``plot_wigner`` and ``plot_wigner_fock_distribution`` to specify parameters for ``wigner``.; - Removed ``Bloch3D``. The same functionality is provided by ``Bloch``.; - Added ``fig``, ``ax`` and ``cmap`` keyword arguments to all visualization functions.; - Most visualization functions now respect the ``colorblind_safe`` setting.; - Added new functions to create animations from a list of ``Qobj`` or directly from solver results with saved states. Package reorganization; ----------------------. - ``qutip.qip`` has been moved into its own package, qutip-qip. Once installed, qutip-qip is available as either ``qutip.qip`` or ``qutip_qip``. Some widely useful gates have been retained in ``qutip.gates``.; - ``qutip.control`` has been moved to qutip-qtrl and once installed qutip-qtrl is available as either ``qutip.control`` or ``qutip_qtrl``. Note that ``quitp_qtrl`` is provided primarily for backwards compatibility. Improvements to optimal control will take place in the new ``qutip_qoc`` package.; - ``qutip.lattice`` has been moved into its own package, qutip-lattice. It is available from `<https://github.com/qutip/qutip-lattice>`.; - ``qutip.sparse`` has been removed. It contained the old sparse matrix representation and is replaced by the new implementation in ``qutip.data``.; - ``qutip.piqs`` functions are no longer available from the ``qutip`` namespace. They are accessible from ``qutip.piqs`` instead. Miscellaneous; -------------. - Support has been added for 64-bit integer sparse matrix indices, allowing; sparse matrices with up to 2**63 rows and columns. This support needs to; be enabled at compilation time by calling ``setup.py`` and passing; ``--with-idxint-64``. Feature removals; ----------------. - Support for OpenMP has been removed.",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:25798,Availability,avail,available,25798,"Removed ``Bloch3D``. The same functionality is provided by ``Bloch``.; - Added ``fig``, ``ax`` and ``cmap`` keyword arguments to all visualization functions.; - Most visualization functions now respect the ``colorblind_safe`` setting.; - Added new functions to create animations from a list of ``Qobj`` or directly from solver results with saved states. Package reorganization; ----------------------. - ``qutip.qip`` has been moved into its own package, qutip-qip. Once installed, qutip-qip is available as either ``qutip.qip`` or ``qutip_qip``. Some widely useful gates have been retained in ``qutip.gates``.; - ``qutip.control`` has been moved to qutip-qtrl and once installed qutip-qtrl is available as either ``qutip.control`` or ``qutip_qtrl``. Note that ``quitp_qtrl`` is provided primarily for backwards compatibility. Improvements to optimal control will take place in the new ``qutip_qoc`` package.; - ``qutip.lattice`` has been moved into its own package, qutip-lattice. It is available from `<https://github.com/qutip/qutip-lattice>`.; - ``qutip.sparse`` has been removed. It contained the old sparse matrix representation and is replaced by the new implementation in ``qutip.data``.; - ``qutip.piqs`` functions are no longer available from the ``qutip`` namespace. They are accessible from ``qutip.piqs`` instead. Miscellaneous; -------------. - Support has been added for 64-bit integer sparse matrix indices, allowing; sparse matrices with up to 2**63 rows and columns. This support needs to; be enabled at compilation time by calling ``setup.py`` and passing; ``--with-idxint-64``. Feature removals; ----------------. - Support for OpenMP has been removed. If there is enough demand and a good plan for how to organize it, OpenMP support may return in a future QuTiP release.; - The ``qutip.parfor`` function has been removed. Use ``qutip.parallel_map`` instead.; - ``qutip.graph`` has been removed and replaced by SciPy's graph functions.; - ``qutip.topology`` has been removed. It co",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:26048,Availability,avail,available,26048,"d new functions to create animations from a list of ``Qobj`` or directly from solver results with saved states. Package reorganization; ----------------------. - ``qutip.qip`` has been moved into its own package, qutip-qip. Once installed, qutip-qip is available as either ``qutip.qip`` or ``qutip_qip``. Some widely useful gates have been retained in ``qutip.gates``.; - ``qutip.control`` has been moved to qutip-qtrl and once installed qutip-qtrl is available as either ``qutip.control`` or ``qutip_qtrl``. Note that ``quitp_qtrl`` is provided primarily for backwards compatibility. Improvements to optimal control will take place in the new ``qutip_qoc`` package.; - ``qutip.lattice`` has been moved into its own package, qutip-lattice. It is available from `<https://github.com/qutip/qutip-lattice>`.; - ``qutip.sparse`` has been removed. It contained the old sparse matrix representation and is replaced by the new implementation in ``qutip.data``.; - ``qutip.piqs`` functions are no longer available from the ``qutip`` namespace. They are accessible from ``qutip.piqs`` instead. Miscellaneous; -------------. - Support has been added for 64-bit integer sparse matrix indices, allowing; sparse matrices with up to 2**63 rows and columns. This support needs to; be enabled at compilation time by calling ``setup.py`` and passing; ``--with-idxint-64``. Feature removals; ----------------. - Support for OpenMP has been removed. If there is enough demand and a good plan for how to organize it, OpenMP support may return in a future QuTiP release.; - The ``qutip.parfor`` function has been removed. Use ``qutip.parallel_map`` instead.; - ``qutip.graph`` has been removed and replaced by SciPy's graph functions.; - ``qutip.topology`` has been removed. It contained only one function ``berry_curvature``.; - The ``~/.qutip/qutiprc`` config file is no longer supported. It contained settings for the OpenMP support.; - Deprecate ``three_level_atom``; - Deprecate ``orbital``. Changes from QuTiP 5.0.0",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:28337,Availability,error,errors,28337,"4-03-04); ==========================. Features; --------. - Create a Dimension class (#1996); - Add arguments of plot_wigner() and plot_wigner_fock_distribution() to specify parameters for wigner(). (#2057, by Kosuke Mizuno); - Restore feedback to solvers (#2210); - Added mpi_pmap, which uses the mpi4py module to run computations in parallel through the MPI interface. (#2296, by Paul); - Only pre-compute density matrices if keep_runs_results is False (#2303, by Matt Ord). Bug Fixes; ---------. - Add the possibility to customize point colors as in V4 and fix point plot behavior for 'l' style (#1974, by Daniel Moreno Galn); - Disabled broken ""improved sampling"" for `nm_mcsolve`. (#2234, by Paul); - Fixed result objects storing a reference to the solver through options._feedback. (#2262, by Paul); - Fixed simdiag not returning orthonormal eigenvectors. (#2269, by Sola85); - Fix LaTeX display of Qobj state in Jupyter cell outputs (#2272, by Edward Thomas); - Improved behavior of `parallel_map` and `loky_pmap` in the case of timeouts, errors or keyboard interrupts (#2280, by Paul); - Ignore deprecation warnings from cython 0.29.X in tests. (#2288); - Fixed two problems with the steady_state() solver in the HEOM method. (#2333). Miscellaneous; -------------. - Improve fidelity doc-string (#2257); - Improve documentation in guide/dynamics (#2271); - Improve states and operator parameters documentation. (#2289); - Rework `kraus_to_choi` making it faster (#2284, by Bogdan Reznychenko); - Remove Bloch3D: redundant to Bloch (#2306); - Allow tests to run without matplotlib and ipython. (#2311); - Add too small step warnings in fixed dt SODE solver (#2313); - Add `dtype` to `Qobj` and `QobjEvo` (#2325); - Fix typos in `expect` documentation (#2331, by gabbence95); - Allow measurement functions to support degenerate operators. (#2342). QuTiP 5.0.0a2 (2023-09-06); ==========================. Features; --------. - Add support for different spectra types for bloch_redfield_tensor (#",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:28811,Availability,redundant,redundant,28811,"ossibility to customize point colors as in V4 and fix point plot behavior for 'l' style (#1974, by Daniel Moreno Galn); - Disabled broken ""improved sampling"" for `nm_mcsolve`. (#2234, by Paul); - Fixed result objects storing a reference to the solver through options._feedback. (#2262, by Paul); - Fixed simdiag not returning orthonormal eigenvectors. (#2269, by Sola85); - Fix LaTeX display of Qobj state in Jupyter cell outputs (#2272, by Edward Thomas); - Improved behavior of `parallel_map` and `loky_pmap` in the case of timeouts, errors or keyboard interrupts (#2280, by Paul); - Ignore deprecation warnings from cython 0.29.X in tests. (#2288); - Fixed two problems with the steady_state() solver in the HEOM method. (#2333). Miscellaneous; -------------. - Improve fidelity doc-string (#2257); - Improve documentation in guide/dynamics (#2271); - Improve states and operator parameters documentation. (#2289); - Rework `kraus_to_choi` making it faster (#2284, by Bogdan Reznychenko); - Remove Bloch3D: redundant to Bloch (#2306); - Allow tests to run without matplotlib and ipython. (#2311); - Add too small step warnings in fixed dt SODE solver (#2313); - Add `dtype` to `Qobj` and `QobjEvo` (#2325); - Fix typos in `expect` documentation (#2331, by gabbence95); - Allow measurement functions to support degenerate operators. (#2342). QuTiP 5.0.0a2 (2023-09-06); ==========================. Features; --------. - Add support for different spectra types for bloch_redfield_tensor (#1951); - Improve qutip import times by setting logger names explicitly. (#1981, by Pieter Eendebak); - Change the order of parameters in expand_operator (#1991); - Add `svn` and `solve` to dispatched (#2002); - Added nm_mcsolve to provide support for Monte-Carlo simulations of master equations with possibly negative rates. The method implemented here is described in arXiv:2209.08958 [quant-ph]. (#2070 by pmenczel); - Add support for combining bosonic and fermionic HEOM baths (#2089); - Added __repr__ to ",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:31413,Availability,error,error,31413," and applied colorblind_safe to functions in visualization.py (#2170 by Yuji Tamakoshi); - Changed arguments and applied colorblind_safe to plot_wigner_sphere and matrix_histogram in visualization.py (#2193 by Yuji Tamakoshi); - Added Dia data layer which represents operators as multi-diagonal matrices. (#2196); - Added support for animated plots. (#2203 by Yuji Tamakoshi); - Improved sampling algorithm for mcsolve (#2218 by Daniel Weiss); - Added support for early termination of map functions. (#2222). Bug Fixes; ---------. - Add missing state transformation to floquet_markov_mesolve (#1952 by christian512); - Added default _isherm value (True) for momentum and position operators. (#2032 by Asier Galicia); - Changed qutip-notebooks to qutip-tutorials and fixed the typo in the link redirecting to the changelog section in the PR template. (#2107 by Valan Baptist Mathuranayagam); - Increase missing colorbar padding for matrix_histogram_complex() from 0 to 0.05. (#2181 by SJUW); - Raise error on insufficient memory. (#2224); - Fixed fallback to fsesolve call in fmmesolve (#2225). Removals; --------. - Remove qutip.control and replace with qutip_qtrl. (#2116); - Deleted _solve in countstat.py and used _data.solve. (#2120 by Yuji Tamakoshi); - Deprecate three_level_atom (#2221); - Deprecate orbital (#2223). Documentation; -------------. - Add a guide on Superoperators, Pauli Basis and Channel Contraction. (#1984 by christian512); - Added information on sec_cutoff to the documentation (#2136 by Gerardo Jose Suarez); - Added inherited members to API doc of MESolver, SMESolver, SSESolver, NonMarkovianMCSolver (#2167 by Cristian Emiliano Godinez Ramirez); - Corrected grammar in Bloch-Redfield master equation documentation (#2174 by Andrey Rakhubovsky). Miscellaneous; -------------. - Update scipy version requirement to 1.5+ (#1982 by Pieter Eendebak); - Added __all__ to qutip/measurements.py and qutip/core/semidefinite.py (#2103 by Rushiraj Gadhvi); - Restore towncrier check ",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:37896,Availability,avail,available,37896,"``, `#1712 <https://github.com/qutip/qutip/pull/1712>`, `#1748 <https://github.com/qutip/qutip/pull/1748>`, `#1788 <https://github.com/qutip/qutip/pull/1788>`); - Felipe Bivort Haiek (fixed inaccuracy in docstring of the dense implementation of negation, `#1608 <https://github.com/qutip/qutip/pull/1608/>`); - Rajath Shetty (added support for specifying colors for individual points, vectors and states display by `qutip.Bloch`, `#1335 <https://github.com/qutip/qutip/pull/1335>`). Qobj changes; ------------. Previously ``Qobj`` data was stored in a SciPy-like sparse matrix. Now the; representation is flexible. Implementations for dense and sparse formats are; included in QuTiP and custom implementations are possible. QuTiP's performance; on dense states and operators is significantly improved as a result. Some highlights:. - The data is still acessible via the ``.data`` attribute, but is now an; instance of the underlying data type instead of a SciPy-like sparse matrix.; The operations available in ``qutip.core.data`` may be used on ``.data``,; regardless of the data type.; - ``Qobj`` with different data types may be mixed in arithmetic and other; operations. A sensible output type will be automatically determined.; - The new ``.to(...)`` method may be used to convert a ``Qobj`` from one data type; to another. E.g. ``.to(""dense"")`` will convert to the dense representation and; ``.to(""csr"")`` will convert to the sparse type.; - Many ``Qobj`` methods and methods that create ``Qobj`` now accepted a ``dtype``; parameter that allows the data type of the returned ``Qobj`` to specified.; - The new ``&`` operator may be used to obtain the tensor product.; - The new ``@`` operator may be used to obtain the matrix / operator product.; ``bar @ ket`` returns a scalar.; - The new ``.contract()`` method will collapse 1D subspaces of the dimensions of; the ``Qobj``.; - The new ``.logm()`` method returns the matrix logarithm of an operator.; - The methods ``.set_data``, ``.get_data``,",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:41786,Availability,avail,available,41786,"ructor. A breakdown of highlights follows. All solvers:. - Solver options are now supplied in an ordinary Python dict.; ``qutip.Options`` is deprecated and returns a dict for backwards; compatibility.; - A specific ODE integrator may be selected by supplying a; ``method`` option.; - Each solver provides a class interface. Creating an instance; of the class allows a solver to be run multiple times for the; same system without having to repeatedly reconstruct the; right-hand side of the ODE to be integrated.; - A ``QobjEvo`` instance is accepted for most operators, e.g.,; ``H``, ``c_ops``, ``e_ops``, ``a_ops``.; - The progress bar is now selected using the ``progress_bar`` option.; A new progess bar using the ``tqdm`` Python library is provided.; - Dynamic arguments, where the value of an operator depends on; the current state of the evolution, have been removed. They; may be re-implemented later if there is demand for them. Integrators:. - The SciPy zvode integrator is available with the BDF and; Adams methods as ``bdf`` and ``adams``.; - The SciPy dop853 integrator (an eighth order Runge-Kutta method by; Dormand & Prince) is available as ``dop853``.; - The SciPy lsoda integrator is available as ``lsoda``.; - QuTiP's own implementation of Verner's ""most efficient"" Runge-Kutta methods; of order 7 and 9 are available as ``vern7`` and ``vern9``. See; http://people.math.sfu.ca/~jverner/ for a description of the methods.; - QuTiP's own implementation of a solver that directly diagonalizes the; the system to be integrated is available as ``diag``. It only works on; time-independent systems and is slow to setup, but once the diagonalization; is complete, it generates solutions very quickly.; - QuTiP's own implementatoin of an approximate Krylov subspace integrator is; available as ``krylov``. This integrator is only usable with ``sesolve``. Result class:. - A new ``.e_data`` attribute provides expectation values as a dictionary.; Unlike ``.expect``, the values are provided ",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:41946,Availability,avail,available,41946,"thon dict.; ``qutip.Options`` is deprecated and returns a dict for backwards; compatibility.; - A specific ODE integrator may be selected by supplying a; ``method`` option.; - Each solver provides a class interface. Creating an instance; of the class allows a solver to be run multiple times for the; same system without having to repeatedly reconstruct the; right-hand side of the ODE to be integrated.; - A ``QobjEvo`` instance is accepted for most operators, e.g.,; ``H``, ``c_ops``, ``e_ops``, ``a_ops``.; - The progress bar is now selected using the ``progress_bar`` option.; A new progess bar using the ``tqdm`` Python library is provided.; - Dynamic arguments, where the value of an operator depends on; the current state of the evolution, have been removed. They; may be re-implemented later if there is demand for them. Integrators:. - The SciPy zvode integrator is available with the BDF and; Adams methods as ``bdf`` and ``adams``.; - The SciPy dop853 integrator (an eighth order Runge-Kutta method by; Dormand & Prince) is available as ``dop853``.; - The SciPy lsoda integrator is available as ``lsoda``.; - QuTiP's own implementation of Verner's ""most efficient"" Runge-Kutta methods; of order 7 and 9 are available as ``vern7`` and ``vern9``. See; http://people.math.sfu.ca/~jverner/ for a description of the methods.; - QuTiP's own implementation of a solver that directly diagonalizes the; the system to be integrated is available as ``diag``. It only works on; time-independent systems and is slow to setup, but once the diagonalization; is complete, it generates solutions very quickly.; - QuTiP's own implementatoin of an approximate Krylov subspace integrator is; available as ``krylov``. This integrator is only usable with ``sesolve``. Result class:. - A new ``.e_data`` attribute provides expectation values as a dictionary.; Unlike ``.expect``, the values are provided in a Python list rather than; a numpy array, which better supports non-numeric types.; - The contents of the ",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:42004,Availability,avail,available,42004,"lity.; - A specific ODE integrator may be selected by supplying a; ``method`` option.; - Each solver provides a class interface. Creating an instance; of the class allows a solver to be run multiple times for the; same system without having to repeatedly reconstruct the; right-hand side of the ODE to be integrated.; - A ``QobjEvo`` instance is accepted for most operators, e.g.,; ``H``, ``c_ops``, ``e_ops``, ``a_ops``.; - The progress bar is now selected using the ``progress_bar`` option.; A new progess bar using the ``tqdm`` Python library is provided.; - Dynamic arguments, where the value of an operator depends on; the current state of the evolution, have been removed. They; may be re-implemented later if there is demand for them. Integrators:. - The SciPy zvode integrator is available with the BDF and; Adams methods as ``bdf`` and ``adams``.; - The SciPy dop853 integrator (an eighth order Runge-Kutta method by; Dormand & Prince) is available as ``dop853``.; - The SciPy lsoda integrator is available as ``lsoda``.; - QuTiP's own implementation of Verner's ""most efficient"" Runge-Kutta methods; of order 7 and 9 are available as ``vern7`` and ``vern9``. See; http://people.math.sfu.ca/~jverner/ for a description of the methods.; - QuTiP's own implementation of a solver that directly diagonalizes the; the system to be integrated is available as ``diag``. It only works on; time-independent systems and is slow to setup, but once the diagonalization; is complete, it generates solutions very quickly.; - QuTiP's own implementatoin of an approximate Krylov subspace integrator is; available as ``krylov``. This integrator is only usable with ``sesolve``. Result class:. - A new ``.e_data`` attribute provides expectation values as a dictionary.; Unlike ``.expect``, the values are provided in a Python list rather than; a numpy array, which better supports non-numeric types.; - The contents of the ``.stats`` attribute changed significantly and is; now more consistent across solvers. ",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:42129,Availability,avail,available,42129,"er provides a class interface. Creating an instance; of the class allows a solver to be run multiple times for the; same system without having to repeatedly reconstruct the; right-hand side of the ODE to be integrated.; - A ``QobjEvo`` instance is accepted for most operators, e.g.,; ``H``, ``c_ops``, ``e_ops``, ``a_ops``.; - The progress bar is now selected using the ``progress_bar`` option.; A new progess bar using the ``tqdm`` Python library is provided.; - Dynamic arguments, where the value of an operator depends on; the current state of the evolution, have been removed. They; may be re-implemented later if there is demand for them. Integrators:. - The SciPy zvode integrator is available with the BDF and; Adams methods as ``bdf`` and ``adams``.; - The SciPy dop853 integrator (an eighth order Runge-Kutta method by; Dormand & Prince) is available as ``dop853``.; - The SciPy lsoda integrator is available as ``lsoda``.; - QuTiP's own implementation of Verner's ""most efficient"" Runge-Kutta methods; of order 7 and 9 are available as ``vern7`` and ``vern9``. See; http://people.math.sfu.ca/~jverner/ for a description of the methods.; - QuTiP's own implementation of a solver that directly diagonalizes the; the system to be integrated is available as ``diag``. It only works on; time-independent systems and is slow to setup, but once the diagonalization; is complete, it generates solutions very quickly.; - QuTiP's own implementatoin of an approximate Krylov subspace integrator is; available as ``krylov``. This integrator is only usable with ``sesolve``. Result class:. - A new ``.e_data`` attribute provides expectation values as a dictionary.; Unlike ``.expect``, the values are provided in a Python list rather than; a numpy array, which better supports non-numeric types.; - The contents of the ``.stats`` attribute changed significantly and is; now more consistent across solvers. Monte-Carlo Solver (mcsolve):. - The system, H, may now be a super-operator.; - The ``seed`` param",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:42347,Availability,avail,available,42347,"tegrated.; - A ``QobjEvo`` instance is accepted for most operators, e.g.,; ``H``, ``c_ops``, ``e_ops``, ``a_ops``.; - The progress bar is now selected using the ``progress_bar`` option.; A new progess bar using the ``tqdm`` Python library is provided.; - Dynamic arguments, where the value of an operator depends on; the current state of the evolution, have been removed. They; may be re-implemented later if there is demand for them. Integrators:. - The SciPy zvode integrator is available with the BDF and; Adams methods as ``bdf`` and ``adams``.; - The SciPy dop853 integrator (an eighth order Runge-Kutta method by; Dormand & Prince) is available as ``dop853``.; - The SciPy lsoda integrator is available as ``lsoda``.; - QuTiP's own implementation of Verner's ""most efficient"" Runge-Kutta methods; of order 7 and 9 are available as ``vern7`` and ``vern9``. See; http://people.math.sfu.ca/~jverner/ for a description of the methods.; - QuTiP's own implementation of a solver that directly diagonalizes the; the system to be integrated is available as ``diag``. It only works on; time-independent systems and is slow to setup, but once the diagonalization; is complete, it generates solutions very quickly.; - QuTiP's own implementatoin of an approximate Krylov subspace integrator is; available as ``krylov``. This integrator is only usable with ``sesolve``. Result class:. - A new ``.e_data`` attribute provides expectation values as a dictionary.; Unlike ``.expect``, the values are provided in a Python list rather than; a numpy array, which better supports non-numeric types.; - The contents of the ``.stats`` attribute changed significantly and is; now more consistent across solvers. Monte-Carlo Solver (mcsolve):. - The system, H, may now be a super-operator.; - The ``seed`` parameter now supports supplying numpy ``SeedSequence`` or; ``Generator`` types.; - The new ``timeout`` and ``target_tol`` parameters allow the solver to exit; early if a timeout or target tolerance is reached.; -",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:42594,Availability,avail,available,42594,"c arguments, where the value of an operator depends on; the current state of the evolution, have been removed. They; may be re-implemented later if there is demand for them. Integrators:. - The SciPy zvode integrator is available with the BDF and; Adams methods as ``bdf`` and ``adams``.; - The SciPy dop853 integrator (an eighth order Runge-Kutta method by; Dormand & Prince) is available as ``dop853``.; - The SciPy lsoda integrator is available as ``lsoda``.; - QuTiP's own implementation of Verner's ""most efficient"" Runge-Kutta methods; of order 7 and 9 are available as ``vern7`` and ``vern9``. See; http://people.math.sfu.ca/~jverner/ for a description of the methods.; - QuTiP's own implementation of a solver that directly diagonalizes the; the system to be integrated is available as ``diag``. It only works on; time-independent systems and is slow to setup, but once the diagonalization; is complete, it generates solutions very quickly.; - QuTiP's own implementatoin of an approximate Krylov subspace integrator is; available as ``krylov``. This integrator is only usable with ``sesolve``. Result class:. - A new ``.e_data`` attribute provides expectation values as a dictionary.; Unlike ``.expect``, the values are provided in a Python list rather than; a numpy array, which better supports non-numeric types.; - The contents of the ``.stats`` attribute changed significantly and is; now more consistent across solvers. Monte-Carlo Solver (mcsolve):. - The system, H, may now be a super-operator.; - The ``seed`` parameter now supports supplying numpy ``SeedSequence`` or; ``Generator`` types.; - The new ``timeout`` and ``target_tol`` parameters allow the solver to exit; early if a timeout or target tolerance is reached.; - The ntraj option no longer supports a list of numbers of trajectories.; Instead, just run the solver multiple times and use the class ``MCSolver``; if setting up the solver uses a significant amount of time.; - The ``map_func`` parameter has been replaced by t",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:43281,Availability,toler,tolerance,43281,"ods.; - QuTiP's own implementation of a solver that directly diagonalizes the; the system to be integrated is available as ``diag``. It only works on; time-independent systems and is slow to setup, but once the diagonalization; is complete, it generates solutions very quickly.; - QuTiP's own implementatoin of an approximate Krylov subspace integrator is; available as ``krylov``. This integrator is only usable with ``sesolve``. Result class:. - A new ``.e_data`` attribute provides expectation values as a dictionary.; Unlike ``.expect``, the values are provided in a Python list rather than; a numpy array, which better supports non-numeric types.; - The contents of the ``.stats`` attribute changed significantly and is; now more consistent across solvers. Monte-Carlo Solver (mcsolve):. - The system, H, may now be a super-operator.; - The ``seed`` parameter now supports supplying numpy ``SeedSequence`` or; ``Generator`` types.; - The new ``timeout`` and ``target_tol`` parameters allow the solver to exit; early if a timeout or target tolerance is reached.; - The ntraj option no longer supports a list of numbers of trajectories.; Instead, just run the solver multiple times and use the class ``MCSolver``; if setting up the solver uses a significant amount of time.; - The ``map_func`` parameter has been replaced by the ``map`` option. In; addition to the existing ``serial`` and ``parallel`` values, the value; ``loky`` may be supplied to use the loky package to parallelize trajectories.; - The result returned by ``mcsolve`` now supports calculating photocurrents; and calculating the steady state over N trajectories.; - The old ``parfor`` parallel execution function has been removed from; ``qutip.parallel``. Use ``parallel_map`` or ``loky_map`` instead. Bloch-Redfield Master Equation Solver (brmesolve):. - The ``a_ops`` and ``spectra`` support implementaitons been heavily reworked to; reuse the techniques from the new Coefficient and QobjEvo classes.; - The ``use_secular`` par",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:44309,Availability,toler,tolerance,44309,"tion no longer supports a list of numbers of trajectories.; Instead, just run the solver multiple times and use the class ``MCSolver``; if setting up the solver uses a significant amount of time.; - The ``map_func`` parameter has been replaced by the ``map`` option. In; addition to the existing ``serial`` and ``parallel`` values, the value; ``loky`` may be supplied to use the loky package to parallelize trajectories.; - The result returned by ``mcsolve`` now supports calculating photocurrents; and calculating the steady state over N trajectories.; - The old ``parfor`` parallel execution function has been removed from; ``qutip.parallel``. Use ``parallel_map`` or ``loky_map`` instead. Bloch-Redfield Master Equation Solver (brmesolve):. - The ``a_ops`` and ``spectra`` support implementaitons been heavily reworked to; reuse the techniques from the new Coefficient and QobjEvo classes.; - The ``use_secular`` parameter has been removed. Use ``sec_cutoff=-1`` instead.; - The required tolerance is now read from ``qutip.settings``. Krylov Subspace Solver (krylovsolve):. - The Krylov solver is now implemented using ``SESolver`` and the ``krylov``; ODE integrator. The function ``krylovsolve`` is maintained for convenience; and now supports many more options.; - The ``sparse`` parameter has been removed. Supply a sparse ``Qobj`` for the; Hamiltonian instead. Floquet Solver (fsesolve and fmmesolve):. - The Floquet solver has been rewritten to use a new ``FloquetBasis`` class; which manages the transformations from lab to Floquet basis and back.; - Many of the internal methods used by the old Floquet solvers have; been removed. The Floquet tensor may still be retried using; the function ``floquet_tensor``.; - The Floquet Markov Master Equation solver has had many changes and; new options added. The environment temperature may be specified using; ``w_th``, and the result states are stored in the lab basis and optionally; in the Floquet basis using ``store_floquet_state``.; - The sp",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:49576,Availability,toler,tolerance,49576,"dm(distribution=""hs"")`` and ``rand_dm(distribution=""ginibre"")``; instead.; - The function ``rand_ket_haar`` has been removed. Use; ``rand_ket(distribution=""haar"")`` instead.; - The measurement functions have had the ``target`` parameter for; expanding the measurement operator removed. Used ``expand_operator``; to expand the operator instead.; - ``qutip.Bloch`` now supports applying colours per-point, state or vector in; ``add_point``, ``add_states``, and ``add_vectors``. QuTiP settings; --------------. Previously ``qutip.settings`` was an ordinary module. Now ``qutip.settings`` is; an instance of a settings class. All the runtime modifiable settings for; core operations are in ``qutip.settings.core``. The other settings are not; modifiable at runtime. - Removed ``load``. ``reset`` and ``save`` functions.; - Removed ``.debug``, ``.fortran``, ``.openmp_thresh``.; - New ``.compile`` stores the compilation options for compiled coefficients.; - New ``.core[""rtol""]`` core option gives the default relative tolerance used by QuTiP.; - The absolute tolerance setting ``.atol`` has been moved to ``.core[""atol""]``. Package reorganization; ----------------------. - ``qutip.qip`` has been moved into its own package, qutip-qip. Once installed, qutip-qip is available as either ``qutip.qip`` or ``qutip_qip``. Some widely useful gates have been retained in ``qutip.gates``.; - ``qutip.lattice`` has been moved into its own package, qutip-lattice. It is available from `<https://github.com/qutip/qutip-lattice>`.; - ``qutip.sparse`` has been removed. It contained the old sparse matrix representation and is replaced by the new implementation in ``qutip.data``.; - ``qutip.piqs`` functions are no longer available from the ``qutip`` namespace. They are accessible from ``qutip.piqs`` instead. Miscellaneous; -------------. - Support has been added for 64-bit integer sparse matrix indices, allowing; sparse matrices with up to 2**63 rows and columns. This support needs to; be enabled at compilati",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:49617,Availability,toler,tolerance,49617,"e"")``; instead.; - The function ``rand_ket_haar`` has been removed. Use; ``rand_ket(distribution=""haar"")`` instead.; - The measurement functions have had the ``target`` parameter for; expanding the measurement operator removed. Used ``expand_operator``; to expand the operator instead.; - ``qutip.Bloch`` now supports applying colours per-point, state or vector in; ``add_point``, ``add_states``, and ``add_vectors``. QuTiP settings; --------------. Previously ``qutip.settings`` was an ordinary module. Now ``qutip.settings`` is; an instance of a settings class. All the runtime modifiable settings for; core operations are in ``qutip.settings.core``. The other settings are not; modifiable at runtime. - Removed ``load``. ``reset`` and ``save`` functions.; - Removed ``.debug``, ``.fortran``, ``.openmp_thresh``.; - New ``.compile`` stores the compilation options for compiled coefficients.; - New ``.core[""rtol""]`` core option gives the default relative tolerance used by QuTiP.; - The absolute tolerance setting ``.atol`` has been moved to ``.core[""atol""]``. Package reorganization; ----------------------. - ``qutip.qip`` has been moved into its own package, qutip-qip. Once installed, qutip-qip is available as either ``qutip.qip`` or ``qutip_qip``. Some widely useful gates have been retained in ``qutip.gates``.; - ``qutip.lattice`` has been moved into its own package, qutip-lattice. It is available from `<https://github.com/qutip/qutip-lattice>`.; - ``qutip.sparse`` has been removed. It contained the old sparse matrix representation and is replaced by the new implementation in ``qutip.data``.; - ``qutip.piqs`` functions are no longer available from the ``qutip`` namespace. They are accessible from ``qutip.piqs`` instead. Miscellaneous; -------------. - Support has been added for 64-bit integer sparse matrix indices, allowing; sparse matrices with up to 2**63 rows and columns. This support needs to; be enabled at compilation time by calling ``setup.py`` and passing; ``--with-idxi",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:49823,Availability,avail,available,49823,"rement operator removed. Used ``expand_operator``; to expand the operator instead.; - ``qutip.Bloch`` now supports applying colours per-point, state or vector in; ``add_point``, ``add_states``, and ``add_vectors``. QuTiP settings; --------------. Previously ``qutip.settings`` was an ordinary module. Now ``qutip.settings`` is; an instance of a settings class. All the runtime modifiable settings for; core operations are in ``qutip.settings.core``. The other settings are not; modifiable at runtime. - Removed ``load``. ``reset`` and ``save`` functions.; - Removed ``.debug``, ``.fortran``, ``.openmp_thresh``.; - New ``.compile`` stores the compilation options for compiled coefficients.; - New ``.core[""rtol""]`` core option gives the default relative tolerance used by QuTiP.; - The absolute tolerance setting ``.atol`` has been moved to ``.core[""atol""]``. Package reorganization; ----------------------. - ``qutip.qip`` has been moved into its own package, qutip-qip. Once installed, qutip-qip is available as either ``qutip.qip`` or ``qutip_qip``. Some widely useful gates have been retained in ``qutip.gates``.; - ``qutip.lattice`` has been moved into its own package, qutip-lattice. It is available from `<https://github.com/qutip/qutip-lattice>`.; - ``qutip.sparse`` has been removed. It contained the old sparse matrix representation and is replaced by the new implementation in ``qutip.data``.; - ``qutip.piqs`` functions are no longer available from the ``qutip`` namespace. They are accessible from ``qutip.piqs`` instead. Miscellaneous; -------------. - Support has been added for 64-bit integer sparse matrix indices, allowing; sparse matrices with up to 2**63 rows and columns. This support needs to; be enabled at compilation time by calling ``setup.py`` and passing; ``--with-idxint-64``. Feature removals; ----------------. - Support for OpenMP has been removed. If there is enough demand and a good plan for how to organize it, OpenMP support may return in a future QuTiP release.;",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:50018,Availability,avail,available,50018,"ors``. QuTiP settings; --------------. Previously ``qutip.settings`` was an ordinary module. Now ``qutip.settings`` is; an instance of a settings class. All the runtime modifiable settings for; core operations are in ``qutip.settings.core``. The other settings are not; modifiable at runtime. - Removed ``load``. ``reset`` and ``save`` functions.; - Removed ``.debug``, ``.fortran``, ``.openmp_thresh``.; - New ``.compile`` stores the compilation options for compiled coefficients.; - New ``.core[""rtol""]`` core option gives the default relative tolerance used by QuTiP.; - The absolute tolerance setting ``.atol`` has been moved to ``.core[""atol""]``. Package reorganization; ----------------------. - ``qutip.qip`` has been moved into its own package, qutip-qip. Once installed, qutip-qip is available as either ``qutip.qip`` or ``qutip_qip``. Some widely useful gates have been retained in ``qutip.gates``.; - ``qutip.lattice`` has been moved into its own package, qutip-lattice. It is available from `<https://github.com/qutip/qutip-lattice>`.; - ``qutip.sparse`` has been removed. It contained the old sparse matrix representation and is replaced by the new implementation in ``qutip.data``.; - ``qutip.piqs`` functions are no longer available from the ``qutip`` namespace. They are accessible from ``qutip.piqs`` instead. Miscellaneous; -------------. - Support has been added for 64-bit integer sparse matrix indices, allowing; sparse matrices with up to 2**63 rows and columns. This support needs to; be enabled at compilation time by calling ``setup.py`` and passing; ``--with-idxint-64``. Feature removals; ----------------. - Support for OpenMP has been removed. If there is enough demand and a good plan for how to organize it, OpenMP support may return in a future QuTiP release.; - The ``qutip.parfor`` function has been removed. Use ``qutip.parallel_map`` instead.; - ``qutip.graph`` has been removed and replaced by SciPy's graph functions.; - ``qutip.topology`` has been removed. It co",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:50268,Availability,avail,available,50268,"The other settings are not; modifiable at runtime. - Removed ``load``. ``reset`` and ``save`` functions.; - Removed ``.debug``, ``.fortran``, ``.openmp_thresh``.; - New ``.compile`` stores the compilation options for compiled coefficients.; - New ``.core[""rtol""]`` core option gives the default relative tolerance used by QuTiP.; - The absolute tolerance setting ``.atol`` has been moved to ``.core[""atol""]``. Package reorganization; ----------------------. - ``qutip.qip`` has been moved into its own package, qutip-qip. Once installed, qutip-qip is available as either ``qutip.qip`` or ``qutip_qip``. Some widely useful gates have been retained in ``qutip.gates``.; - ``qutip.lattice`` has been moved into its own package, qutip-lattice. It is available from `<https://github.com/qutip/qutip-lattice>`.; - ``qutip.sparse`` has been removed. It contained the old sparse matrix representation and is replaced by the new implementation in ``qutip.data``.; - ``qutip.piqs`` functions are no longer available from the ``qutip`` namespace. They are accessible from ``qutip.piqs`` instead. Miscellaneous; -------------. - Support has been added for 64-bit integer sparse matrix indices, allowing; sparse matrices with up to 2**63 rows and columns. This support needs to; be enabled at compilation time by calling ``setup.py`` and passing; ``--with-idxint-64``. Feature removals; ----------------. - Support for OpenMP has been removed. If there is enough demand and a good plan for how to organize it, OpenMP support may return in a future QuTiP release.; - The ``qutip.parfor`` function has been removed. Use ``qutip.parallel_map`` instead.; - ``qutip.graph`` has been removed and replaced by SciPy's graph functions.; - ``qutip.topology`` has been removed. It contained only one function ``berry_curvature``.; - The ``~/.qutip/qutiprc`` config file is no longer supported. It contained settings for the OpenMP support. QuTiP 4.7.5 (2024-01-29); ========================. Patch release for QuTiP 4.7. It ",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:52273,Availability,error,error,52273,"QuTiP 4.7. It adds support for SciPy 1.12. Bug Fixes; ---------. - Remove use of scipy.<numpy-func> in parallel.py, incompatible with scipy==1.12 (#2305 by Evan McKinney). QuTiP 4.7.4 (2024-01-15); ========================. Bug Fixes; ---------. - Adapt to deprecation from matplotlib 3.8 (#2243, reported by Bogdan Reznychenko); - Fix name of temp files for removal after use. (#2251, reported by Qile Su); - Avoid integer overflow in Qobj creation. (#2252, reported by KianHwee-Lim); - Ignore DeprecationWarning from pyximport (#2287); - Add partial support and tests for python 3.12. (#2294). Miscellaneous; -------------. - Rework `choi_to_kraus`, making it rely on an eigenstates solver that can choose `eigh` if the Choi matrix is Hermitian, as it is more numerically stable. (#2276, by Bogdan Reznychenko); - Rework `kraus_to_choi`, making it faster (#2283, by Bogdan Reznychenko and Rafael Haenel). QuTiP 4.7.3 (2023-08-22); ========================. Bug Fixes; ---------. - Non-oper qobj + scalar raise an error. (#2208 reported by vikramkashyap); - Fixed issue where `extract_states` did not preserve hermiticity.; Fixed issue where `rand_herm` did not set the private attribute _isherm to True. (#2214 by AGaliciaMartinez); - ssesolve average states to density matrices (#2216 reported by BenjaminDAnjou). Miscellaneous; -------------. - Exclude cython 3.0.0 from requirement (#2204); - Run in no cython mode with cython >=3.0.0 (#2207). QuTiP 4.7.2 (2023-06-28); ========================. This is a bugfix release for QuTiP 4.7.X. It adds support for; numpy 1.25 and scipy 1.11. Bug Fixes; ---------; - Fix setting of sso.m_ops in heterodyne smesolver and passing through of sc_ops to photocurrent solver. (#2081 by Bogdan Reznychenko and Simon Cross); - Update calls to SciPy eigvalsh and eigsh to pass the range of eigenvalues to return using ``subset_by_index=``. (#2081 by Simon Cross); - Fixed bug where some matrices were wrongly found to be hermitian. (#2082 by AGaliciaMartinez). M",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:55489,Availability,error,error,55489,"or case where only the collapse operators are time dependent. (#1979); - Fix the hinton visualization method to plot the matrix instead of its transpose. (#2011); - Fix the hinton visualization method to take into account all the matrix coefficients to set the squares scale, instead of only the diagonal coefficients. (#2012); - Fix parsing of package versions in setup.py to support packaging 22.0. (#2037); - Add back .qu suffix to objects saved with qsave and loaded with qload. The suffix was accidentally removed in QuTiP 4.7.0. (#2038); - Add a default max_step to processors. (#2040). Documentation; -------------; - Add towncrier for managing the changelog. (#1927); - Update the version of numpy used to build documentation to 1.22.0. (#1940); - Clarify returned objects from bloch_redfield_tensor(). (#1950); - Update Floquet Markov solver docs. (#1958); - Update the roadmap and ideas to show completed work as of August 2022. (#1967). Miscellaneous; -------------; - Return TypeError instead of Exception for type error in sesolve argument. (#1924); - Add towncrier draft build of changelog to CI tests. (#1946); - Add Python 3.11 to builds. (#2041); - Simplify version parsing by using packaging.version.Version. (#2043); - Update builds to use cibuildwheel 2.11, and to build with manylinux2014 on Python 3.8 and 3.9, since numpy and SciPy no longer support manylinux2010 on those versions of Python. (#2047). Version 4.7.0 (April 13, 2022); ++++++++++++++++++++++++++++++. This release sees the addition of two new solvers -- ``qutip.krylovsolve`` based on the Krylov subspace approximation and ``qutip.nonmarkov.heom`` that reimplements the BoFiN HEOM solver. Bloch sphere rendering gained support for drawing arcs and lines on the sphere, and for setting the transparency of rendered points and vectors, Hinton plots gained support for specifying a coloring style, and matrix histograms gained better default colors and more flexible styling options. Other significant improvements ",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:59058,Availability,error,errors,59058," on the Bloch sphere. (`#1690 <https://github.com/qutip/qutip/pull/1690>`_ by Gaurav Saxena, Asier Galicia and Simon Cross); - Added transparency parameter to the add_point, add_vector and add_states methods in the Bloch and Bloch3d classes. (`#1837 <https://github.com/qutip/qutip/pull/1837>`_ by Xavier Spronken); - Support ``Path`` objects in ``qutip.fileio``. (`#1813 <https://github.com/qutip/qutip/pull/1813>`_ by Adri Labay); - Improved the weighting in steadystate solver, so that the default weight matches the documented behaviour and the dense solver applies the weights in the same manner as the sparse solver. (`#1275 <https://github.com/qutip/qutip/pull/1275>`_ and `#1802 <https://github.com/qutip/qutip/pull/1802>`_ by NS2 Group at LPS and Simon Cross); - Added a ``color_style`` option to the ``hinton`` plotting function. (`#1595 <https://github.com/qutip/qutip/issues/1595>`_ by Cassandra Granade); - Improved the scaling of ``floquet_master_equation_rates`` and ``floquet_master_equation_tensor`` and fixed transposition and basis change errors in ``floquet_master_equation_tensor`` and ``floquet_markov_mesolve``. (`#1248 <https://github.com/qutip/qutip/pull/1248>`_ by Camille Le Calonnec, Jake Lishman and Eric Gigure); - Removed ``linspace_with`` and ``view_methods`` from ``qutip.utilities``. For the former it is far better to use ``numpy.linspace`` and for the later Python's in-built ``help`` function or other tools. (`#1680 <https://github.com/qutip/qutip/pull/1680>`_ by Eric Gigure); - Added support for passing callable functions as ``e_ops`` to ``mesolve`` and ``sesolve``. (`#1655 <https://github.com/qutip/qutip/pull/1655>`_ by Marek Naroniak); - Added the function ``steadystate_floquet``, which returns the ""effective"" steadystate of a periodic driven system. (`#1660 <https://github.com/qutip/qutip/pull/1660>`_ by Alberto Mercurio); - Improved mcsolve memory efficiency by not storing final states when they are not needed. (`#1669 <https://github.com/quti",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:60369,Availability,error,error,60369,"tip.utilities``. For the former it is far better to use ``numpy.linspace`` and for the later Python's in-built ``help`` function or other tools. (`#1680 <https://github.com/qutip/qutip/pull/1680>`_ by Eric Gigure); - Added support for passing callable functions as ``e_ops`` to ``mesolve`` and ``sesolve``. (`#1655 <https://github.com/qutip/qutip/pull/1655>`_ by Marek Naroniak); - Added the function ``steadystate_floquet``, which returns the ""effective"" steadystate of a periodic driven system. (`#1660 <https://github.com/qutip/qutip/pull/1660>`_ by Alberto Mercurio); - Improved mcsolve memory efficiency by not storing final states when they are not needed. (`#1669 <https://github.com/qutip/qutip/pull/1669>`_ by Eric Gigure); - Improved the default colors and styling of matrix_histogram and provided additional styling options. (`#1573 <https://github.com/qutip/qutip/pull/1573>`_ and `#1628 <https://github.com/qutip/qutip/pull/1628>`_ by Mahdi Aslani); - Sped up ``state_number_enumerate``, ``state_number_index``, ``state_index_number``, and added some error checking. ``enr_state_dictionaries`` now returns a list for ``idx2state``. (`#1604 <https://github.com/qutip/qutip/pull/1604>`_ by Johannes Feist); - Added new Husimi Q algorithms, improving the speed for density matrices, and giving a near order-of-magnitude improvement when calculating the Q function for many different states, using the new ``qutip.QFunc`` class, instead of the ``qutip.qfunc`` function. (`#934 <https://github.com/qutip/qutip/pull/934>`_ and `#1583 <https://github.com/qutip/qutip/pull/1583>`_ by Daniel Weigand and Jake Lishman); - Updated licence holders with regards to new governance model, and remove extraneous licensing information from source files. (`#1579 <https://github.com/qutip/qutip/pull/1579>`_ by Jake Lishman); - Removed the vendored copy of LaTeX's qcircuit package which is GPL licensed. We now rely on the package being installed by user. It is installed by default with TexLive. (`#15",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:62188,Availability,toler,tolerance,62188,"it package which is GPL licensed. We now rely on the package being installed by user. It is installed by default with TexLive. (`#1580 <https://github.com/qutip/qutip/pull/1580>`_ by Jake Lishman); - The signatures of rand_ket and rand_ket_haar were changed to allow N (the size of the random ket) to be determined automatically when dims are specified. (`#1509 <https://github.com/qutip/qutip/pull/1509>`_ by Purva Thakre). Bug Fixes; ---------; - Fix circuit index used when plotting circuits with non-reversed states. (`#1847 <https://github.com/qutip/qutip/pull/1847>`_ by Christian Staufenbiel); - Changed implementation of ``qutip.orbital`` to use ``scipy.special.spy_harm`` to remove bugs in angle interpretation. (`#1844 <https://github.com/qutip/qutip/pull/1844>`_ by Christian Staufenbiel); - Fixed ``QobjEvo.tidyup`` to use ``settings.auto_tidyup_atol`` when removing small elements in sparse matrices. (`#1832 <https://github.com/qutip/qutip/pull/1832>`_ by Eric Gigure); - Ensured that tidyup's default tolerance is read from settings at each call. (`#1830 <https://github.com/qutip/qutip/pull/1830>`_ by Eric Gigure); - Fixed ``scipy.sparse`` deprecation warnings raised by ``qutip.fast_csr_matrix``. (`#1827 <https://github.com/qutip/qutip/pull/1827>`_ by Simon Cross); - Fixed rendering of vectors on the Bloch sphere when using matplotlib 3.5 and above. (`#1818 <https://github.com/qutip/qutip/pull/1818>`_ by Simon Cross); - Fixed the displaying of ``Lattice1d`` instances and their unit cells. Previously calling them raised exceptions in simple cases. (`#1819 <https://github.com/qutip/qutip/pull/1819>`_, `#1697 <https://github.com/qutip/qutip/pull/1697>`_ and `#1702 <https://github.com/qutip/qutip/pull/1702>`_ by Simon Cross and Saumya Biswas); - Fixed the displaying of the title for ``hinton`` and ``matrix_histogram`` plots when a title is given. Previously the supplied title was not displayed. (`#1707 <https://github.com/qutip/qutip/pull/1707>`_ by Vladimir Vargas-Cal",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:64309,Availability,error,errors,64309,", for example, the construction of qutrit circuits. (`#1807 <https://github.com/qutip/qutip/pull/1807>`_ by Boxi Li); - Fixed the checking of ``method`` and ``offset`` parameters in ``coherent`` and ``coherent_dm``. (`#1469 <https://github.com/qutip/qutip/pull/1469>`_ and `#1741 <https://github.com/qutip/qutip/pull/1741>`_ by Joseph Fox-Rabinovitz and Simon Cross); - Removed the Hamiltonian saved in the ``sesolve`` solver results. (`#1689 <https://github.com/qutip/qutip/pull/1689>`_ by Eric Gigure); - Fixed a bug in rand_herm with ``pos_def=True`` and ``density>0.5`` where the diagonal was incorrectly filled. (`#1562 <https://github.com/qutip/qutip/pull/1562>`_ by Eric Gigure). Documentation Improvements; --------------------------; - Added contributors image to the documentation. (`#1828 <https://github.com/qutip/qutip/pull/1828>`_ by Leonard Assis); - Fixed the Theory of Quantum Information bibliography link. (`#1840 <https://github.com/qutip/qutip/pull/1840>`_ by Anto Luketina); - Fixed minor grammar errors in the dynamics guide. (`#1822 <https://github.com/qutip/qutip/pull/1822>`_ by Victor Omole); - Fixed many small documentation typos. (`#1569 <https://github.com/qutip/qutip/pull/1569>`_ by Ashish Panigrahi); - Added Pulser to the list of libraries that use QuTiP. (`#1570 <https://github.com/qutip/qutip/pull/1570>`_ by Ashish Panigrahi); - Corrected typo in the states and operators guide. (`#1567 <https://github.com/qutip/qutip/pull/1567>`_ by Laurent Ajdnik); - Converted http links to https. (`#1555 <https://github.com/qutip/qutip/pull/1555>`_ by Jake Lishamn). Developer Changes; -----------------; - Add GitHub actions test run on windows-latest. (`#1853 <https://github.com/qutip/qutip/pull/1853>`_ and `#1855 <https://github.com/qutip/qutip/pull/1855>`_ by Simon Cross); - Bumped the version of pillow used to build documentation from 9.0.0 to 9.0.1. (`#1835 <https://github.com/qutip/qutip/pull/1835>`_ by dependabot); - Migrated the ``qutip.superop_reps`` test",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:67596,Availability,fault,faults,67596,"ter the initial 4.6.1 to match the actual release process. (`#1544 <https://github.com/qutip/qutip/pull/1544>`_ by Jake Lishman). Version 4.6.3 (February 9, 2022); ++++++++++++++++++++++++++++++++. This minor release adds support for numpy 1.22 and Python 3.10 and removes some blockers for running QuTiP on the Apple M1. The performance of the ``enr_destroy``, ``state_number_enumerate`` and ``hadamard_transform`` functions was drastically improved (up to 70x or 200x faster in some common cases), and support for the drift Hamiltonian was added to the ``qutip.qip`` ``Processor``. The ``qutip.hardware_info`` module was removed as part of adding support for the Apple M1. We hope the removal of this little-used module does not adversely affect many users -- it was largely unrelated to QuTiP's core functionality and its presence was a continual source of blockers to importing ``qutip`` on new or changed platforms. A new check on the dimensions of ``Qobj``'s were added to prevent segmentation faults when invalid shape and dimension combinations were passed to Cython code. In addition, there were many small bugfixes, documentation improvements, and improvements to our building and testing processes. Improvements; ------------; - The ``enr_destroy`` function was made ~200x faster in many simple cases. (`#1593 <https://github.com/qutip/qutip/pull/1593>`_ by Johannes Feist); - The ``state_number_enumerate`` function was made significantly faster. (`#1594 <https://github.com/qutip/qutip/pull/1594>`_ by Johannes Feist); - Added the missing drift Hamiltonian to the method run_analytically of ``Processor``. (`#1603 <https://github.com/qutip/qutip/pull/1603>`_ Boxi Li); - The ``hadamard_transform`` was made much faster, e.g., ~70x faster for N=10. (`#1688 <https://github.com/qutip/qutip/pull/1688>`_ by Asier Galicia); - Added support for computing the power of a scalar-like Qobj. (`#1692 <https://github.com/qutip/qutip/pull/1692>`_ by Asier Galicia); - Removed the ``hardware_info`` ",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:70439,Availability,error,errors,70439, Cross); - Fixed support for calculating the propagator for a superoperator without collapse operators. This functionality was not tested by the test suite and appears to have broken sometime during 2019. Tests have now been added and the code breakages fixed. (`#1588 <https://github.com/qutip/qutip/pull/1588>`_ by Simon Cross); - Fixed the ignoring of the random number seed passed to ``rand_dm`` in the case where ``pure`` was set to true. (`#1600 <https://github.com/qutip/qutip/pull/1600>`_ Pontus Wiksthl); - Fixed qutip.control.optimize_pulse support for sparse eigenvector decomposition with the Qobj oper_dtype (the Qobj oper_dtype is the default for large systems). (`#1621 <https://github.com/qutip/qutip/pull/1621>`_ by Simon Cross); - Removed qutip.control.optimize_pulse support for scipy.sparse.csr_matrix and generic ndarray-like matrices. Support for these was non-functional. (`#1621 <https://github.com/qutip/qutip/pull/1621>`_ by Simon Cross); - Fixed errors in the calculation of the Husimi spin_q_function and spin_wigner functions and added tests for them. (`#1632 <https://github.com/qutip/qutip/pull/1632>`_ by Mark Johnson); - Fixed setting of OpenMP compilation flag on Linux. Previously when compiling the OpenMP functions were compiled without parallelization. (`#1693 <https://github.com/qutip/qutip/pull/1693>`_ by Eric Gigure); - Fixed tracking the state of the Bloch sphere figure and axes to prevent exceptions during rendering. (`#1619 <https://github.com/qutip/qutip/pull/1619>`_ by Simon Cross); - Fixed compatibility with numpy configuration in numpy's 1.22.0 release. (`#1752 <https://github.com/qutip/qutip/pull/1752>`_ by Matthew Treinish); - Added dims checks for e_ops passed to solvers to prevent hanging the calling process when e_ops of the wrong dimensions were passed. (`#1778 <https://github.com/qutip/qutip/pull/1778>`_ by Eric Gigure); - Added a check in Qobj constructor that the respective members of data.shape cannot be larger than what the c,MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:71524,Availability,fault,fault,71524,"wigner functions and added tests for them. (`#1632 <https://github.com/qutip/qutip/pull/1632>`_ by Mark Johnson); - Fixed setting of OpenMP compilation flag on Linux. Previously when compiling the OpenMP functions were compiled without parallelization. (`#1693 <https://github.com/qutip/qutip/pull/1693>`_ by Eric Gigure); - Fixed tracking the state of the Bloch sphere figure and axes to prevent exceptions during rendering. (`#1619 <https://github.com/qutip/qutip/pull/1619>`_ by Simon Cross); - Fixed compatibility with numpy configuration in numpy's 1.22.0 release. (`#1752 <https://github.com/qutip/qutip/pull/1752>`_ by Matthew Treinish); - Added dims checks for e_ops passed to solvers to prevent hanging the calling process when e_ops of the wrong dimensions were passed. (`#1778 <https://github.com/qutip/qutip/pull/1778>`_ by Eric Gigure); - Added a check in Qobj constructor that the respective members of data.shape cannot be larger than what the corresponding dims could contain to prevent a segmentation fault caused by inconsistencies between dims and shapes. (`#1783 <https://github.com/qutip/qutip/pull/1783>`_, `#1785 <https://github.com/qutip/qutip/pull/1785>`_, `#1784 <https://github.com/qutip/qutip/pull/1784>`_ by Lajos Palanki & Eric Gigure). Documentation Improvements; --------------------------; - Added docs for the num_cbits parameter of the QubitCircuit class. (`#1652 <https://github.com/qutip/qutip/pull/1652>`_ by Jon Crall); - Fixed the parameters in the call to fsesolve in the Floquet guide. (`#1675 <https://github.com/qutip/qutip/pull/1675>`_ by Simon Cross); - Fixed the description of random number usage in the Monte Carlo solver guide. (`#1677 <https://github.com/qutip/qutip/pull/1677>`_ by Ian Thorvaldson); - Fixed the rendering of equation numbers in the documentation (they now appear on the right as expected, not above the equation). (`#1678 <https://github.com/qutip/qutip/pull/1678>`_ by Simon Cross); - Updated the installation requirements in t",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:79108,Availability,error,errors,79108,"d documentation version and release from the VERSION file. Version 4.6.1 (May 4, 2021); +++++++++++++++++++++++++++. This minor release fixes bugs in QIP gate definitions, fixes building from; the source tarball when git is not installed and works around an MKL; bug in versions of SciPy <= 1.4. It also adds the ``[full]`` pip install target so that ``pip install qutip[full]``; installs qutip and all of its optional and developer dependencies. Improvements; ------------; - Add the ``[full]`` pip install target (by **Jake Lishman**). Bug Fixes; ---------; - Work around pointer MKL eigh bug in SciPy <= 1.4 (by **Felipe Bivort Haiek**); - Fix berkeley, swapalpha and cz gate operations (by **Boxi Li**); - Expose the CPHASE control gate (by **Boxi Li**); - Fix building from the sdist when git is not installed (by **Jake Lishman**). Developer Changes; -----------------; - Move the qutip-doc documentation into the qutip repository (by **Jake Lishman**); - Fix warnings in documentation build (by **Jake Lishman**); - Fix warnings in pytest runs and make pytest treat warnings as errors (by **Jake Lishman**); - Add Simon Cross as author (by **Simon Cross**). Version 4.6.0 (April 11, 2021); ++++++++++++++++++++++++++++++. This release brings improvements for qubit circuits, including a pulse scheduler, measurement statistics, reading/writing OpenQASM and optimisations in the circuit simulations. This is the first release to have full binary wheel releases on pip; you can now do ``pip install qutip`` on almost any machine to get a correct version of the package without needing any compilers set up.; The support for Numpy 1.20 that was first added in QuTiP 4.5.3 is present in this version as well, and the same build considerations mentioned there apply here too.; If building using the now-supported PEP 517 mechanisms (e.g. ``python -mbuild /path/to/qutip``), all build dependencies will be correctly satisfied. Improvements; ------------; - **MAJOR** Add saving, loading and resetting",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:80880,Availability,error,error,80880,"p``), all build dependencies will be correctly satisfied. Improvements; ------------; - **MAJOR** Add saving, loading and resetting functionality to ``qutip.settings`` for easy re-configuration. (by **Eric Gigure**); - **MAJOR** Add a quantum gate scheduler in ``qutip.qip.scheduler``, to help parallelise the operations of quantum gates. This supports two scheduling modes: as late as possible, and as soon as possible. (by **Boxi Li**); - **MAJOR** Improved qubit circuit simulators, including OpenQASM support and performance optimisations. (by **Sidhant Saraogi**); - **MAJOR** Add tools for quantum measurements and their statistics. (by **Simon Cross** and **Sidhant Saraogi**); - Add support for Numpy 1.20. QuTiP should be compiled against a version of Numpy ``>= 1.16.6`` and ``< 1.20`` (note: does _not_ include 1.20 itself), but such an installation is compatible with any modern version of Numpy. Source installations from ``pip`` understand this constraint.; - Improve the error message when circuit plotting fails. (by **Boxi Li**); - Add support for parsing M1 Mac hardware information. (by **Xiaoliang Wu**); - Add more single-qubit gates and controlled gates. (by **Mateo Laguna** and **Martn Sande Costa**); - Support decomposition of ``X``, ``Y`` and ``Z`` gates in circuits. (by **Boxi Li**); - Refactor ``QubitCircuit.resolve_gate()`` (by **Martn Sande Costa**). Bug Fixes; ---------; - Fix ``dims`` in the returns from ``Qobj.eigenstates`` on superoperators. (by **Jake Lishman**); - Calling Numpy ufuncs on ``Qobj`` will now correctly raise a ``TypeError`` rather than returning a nonsense ``ndarray``. (by **Jake Lishman**); - Convert segfault into Python exception when creating too-large tensor products. (by **Jake Lishman**); - Correctly set ``num_collapse`` in the output of ``mesolve``. (by **Jake Lishman**); - Fix ``ptrace`` when all subspaces are being kept, or the subspaces are passed in order. (by **Jake Lishman**); - Fix sorting bug in ``Bloch3d.add_points()`",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:82076,Availability,toler,tolerance,82076,"ubit gates and controlled gates. (by **Mateo Laguna** and **Martn Sande Costa**); - Support decomposition of ``X``, ``Y`` and ``Z`` gates in circuits. (by **Boxi Li**); - Refactor ``QubitCircuit.resolve_gate()`` (by **Martn Sande Costa**). Bug Fixes; ---------; - Fix ``dims`` in the returns from ``Qobj.eigenstates`` on superoperators. (by **Jake Lishman**); - Calling Numpy ufuncs on ``Qobj`` will now correctly raise a ``TypeError`` rather than returning a nonsense ``ndarray``. (by **Jake Lishman**); - Convert segfault into Python exception when creating too-large tensor products. (by **Jake Lishman**); - Correctly set ``num_collapse`` in the output of ``mesolve``. (by **Jake Lishman**); - Fix ``ptrace`` when all subspaces are being kept, or the subspaces are passed in order. (by **Jake Lishman**); - Fix sorting bug in ``Bloch3d.add_points()``. (by **pschindler**); - Fix invalid string literals in docstrings and some unclosed files. (by **lie Gouzien**); - Fix Hermicity tests for matrices with values that are within the tolerance of 0. (by **Jake Lishman**); - Fix the trace norm being incorrectly reported as 0 for small matrices. (by **Jake Lishman**); - Fix issues with ``dnorm`` when using CVXPy 1.1 with sparse matrices. (by **Felipe Bivort Haiek**); - Fix segfaults in ``mesolve`` when passed a bad initial ``Qobj`` as the state. (by **Jake Lishman**); - Fix sparse matrix construction in PIQS when using Scipy 1.6.1. (by **Drew Parsons**); - Fix ``zspmv_openmp.cpp`` missing from the pip sdist. (by **Christoph Gohlke**); - Fix correlation functions throwing away imaginary components. (by **Asier Galicia Martinez**); - Fix ``QubitCircuit.add_circuit()`` for SWAP gate. (by **Canoming**); - Fix the broken LaTeX image conversion. (by **Jake Lishman**); - Fix gate resolution of the FREDKIN gate. (by **Bo Yang**); - Fix broken formatting in docstrings. (by **Jake Lishman**). Deprecations; ------------; - ``eseries``, ``essolve`` and ``ode2es`` are all deprecated, pending ",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:85427,Availability,error,error,85427,"ther changes relative to version 4.5.2. Users building from source should ensure that they build against Numpy versions >= 1.16.6 and < 1.20 (not including 1.20 itself), but after that or for those installing from conda, an installation will support any current Numpy version >= 1.16.6. Improvements; ------------; - Add support for Numpy 1.20. QuTiP should be compiled against a version of Numpy ``>= 1.16.6`` and ``< 1.20`` (note: does _not_ include 1.20 itself), but such an installation is compatible with any modern version of Numpy. Source installations from ``pip`` understand this constraint. Version 4.5.2 (July 14, 2020); +++++++++++++++++++++++++++++. This is predominantly a hot-fix release to add support for Scipy 1.5, due to changes in private sparse matrix functions that QuTiP also used. Improvements; ------------; - Add support for Scipy 1.5. (by **Jake Lishman**); - Improved speed of ``zcsr_inner``, which affects ``Qobj.overlap``. (by **Jake Lishman**); - Better error messages when installation requirements are not satisfied. (by **Eric Gigure**). Bug Fixes; ---------; - Fix ``zcsr_proj`` acting on matrices with unsorted indices. (by **Jake Lishman**); - Fix errors in Milstein's heterodyne. (by **Eric Gigure**); - Fix datatype bug in ``qutip.lattice`` module. (by **Boxi Li**); - Fix issues with ``eigh`` on Mac when using OpenBLAS. (by **Eric Gigure**). Developer Changes; -----------------; - Converted more of the codebase to PEP 8.; - Fix several instances of unsafe mutable default values and unsafe ``is`` comparisons. Version 4.5.1 (May 15, 2020); ++++++++++++++++++++++++++++. Improvements; ------------; - ``husimi`` and ``wigner`` now accept half-integer spin (by **maij**); - Better error messages for failed string coefficient compilation. (issue raised by **nohchangsuk**). Bug Fixes; ---------; - Safer naming for temporary files. (by **Eric Gigure**); - Fix ``clebsch`` function for half-integer (by **Thomas Walker**); - Fix ``randint``'s dtype to ``uin",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:85628,Availability,error,errors,85628," for those installing from conda, an installation will support any current Numpy version >= 1.16.6. Improvements; ------------; - Add support for Numpy 1.20. QuTiP should be compiled against a version of Numpy ``>= 1.16.6`` and ``< 1.20`` (note: does _not_ include 1.20 itself), but such an installation is compatible with any modern version of Numpy. Source installations from ``pip`` understand this constraint. Version 4.5.2 (July 14, 2020); +++++++++++++++++++++++++++++. This is predominantly a hot-fix release to add support for Scipy 1.5, due to changes in private sparse matrix functions that QuTiP also used. Improvements; ------------; - Add support for Scipy 1.5. (by **Jake Lishman**); - Improved speed of ``zcsr_inner``, which affects ``Qobj.overlap``. (by **Jake Lishman**); - Better error messages when installation requirements are not satisfied. (by **Eric Gigure**). Bug Fixes; ---------; - Fix ``zcsr_proj`` acting on matrices with unsorted indices. (by **Jake Lishman**); - Fix errors in Milstein's heterodyne. (by **Eric Gigure**); - Fix datatype bug in ``qutip.lattice`` module. (by **Boxi Li**); - Fix issues with ``eigh`` on Mac when using OpenBLAS. (by **Eric Gigure**). Developer Changes; -----------------; - Converted more of the codebase to PEP 8.; - Fix several instances of unsafe mutable default values and unsafe ``is`` comparisons. Version 4.5.1 (May 15, 2020); ++++++++++++++++++++++++++++. Improvements; ------------; - ``husimi`` and ``wigner`` now accept half-integer spin (by **maij**); - Better error messages for failed string coefficient compilation. (issue raised by **nohchangsuk**). Bug Fixes; ---------; - Safer naming for temporary files. (by **Eric Gigure**); - Fix ``clebsch`` function for half-integer (by **Thomas Walker**); - Fix ``randint``'s dtype to ``uint32`` for compatibility with Windows. (issue raised by **Boxi Li**); - Corrected stochastic's heterodyne's m_ops (by **eliegenois**); - Mac pool use spawn. (issue raised by **goerz**); -",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:86167,Availability,error,error,86167,"ease to add support for Scipy 1.5, due to changes in private sparse matrix functions that QuTiP also used. Improvements; ------------; - Add support for Scipy 1.5. (by **Jake Lishman**); - Improved speed of ``zcsr_inner``, which affects ``Qobj.overlap``. (by **Jake Lishman**); - Better error messages when installation requirements are not satisfied. (by **Eric Gigure**). Bug Fixes; ---------; - Fix ``zcsr_proj`` acting on matrices with unsorted indices. (by **Jake Lishman**); - Fix errors in Milstein's heterodyne. (by **Eric Gigure**); - Fix datatype bug in ``qutip.lattice`` module. (by **Boxi Li**); - Fix issues with ``eigh`` on Mac when using OpenBLAS. (by **Eric Gigure**). Developer Changes; -----------------; - Converted more of the codebase to PEP 8.; - Fix several instances of unsafe mutable default values and unsafe ``is`` comparisons. Version 4.5.1 (May 15, 2020); ++++++++++++++++++++++++++++. Improvements; ------------; - ``husimi`` and ``wigner`` now accept half-integer spin (by **maij**); - Better error messages for failed string coefficient compilation. (issue raised by **nohchangsuk**). Bug Fixes; ---------; - Safer naming for temporary files. (by **Eric Gigure**); - Fix ``clebsch`` function for half-integer (by **Thomas Walker**); - Fix ``randint``'s dtype to ``uint32`` for compatibility with Windows. (issue raised by **Boxi Li**); - Corrected stochastic's heterodyne's m_ops (by **eliegenois**); - Mac pool use spawn. (issue raised by **goerz**); - Fix typos in ``QobjEvo._shift``. (by **Eric Gigure**); - Fix warning on Travis CI. (by **Ivan Carvalho**). Deprecations; ------------; - ``qutip.graph`` functions will be deprecated in QuTiP 5.0 in favour of ``scipy.sparse.csgraph``. Developer Changes; -----------------; - Add Boxi Li to authors. (by **Alex Pitchford**); - Skip some tests that cause segfaults on Mac. (by **Nathan Shammah** and **Eric Gigure**); - Use Python 3.8 for testing on Mac and Linux. (by **Simon Cross** and **Eric Gigure**). Vers",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:89202,Availability,error,error,89202,"ed into more general dicke_trace (by **Nathan Shammah**). - Added option for specifying resolution in Bloch.save function (by **Tarun Raheja**). - Added information related to the value of hbar in `wigner` and `continuous_variables` (by **Nicolas Quesada**). - Updated requirements for `scipy 1.4` (by **Eric Gigure**). - Added previous lead developers to the qutip.about() message (by **Nathan Shammah**). - Added improvements to `Qobj` introducing the `inv` method and making the partial trace, `ptrace`, faster, keeping both sparse and dense methods (by **Eric Gigure**). - Allowed general callable objects to define a time-dependent Hamiltonian (by **Eric Gigure**). - Added feature so that `QobjEvo` no longer requires Cython for string coefficients (by **Eric Gigure**). - Updated authors list on Github and added `my binder` link (by **Nathan Shammah**). Bug Fixes; ---------. - Fixed `PolyDataMapper` construction for `Bloch3d` (by **Sam Griffiths**). - Fixed error checking for null matrix in essolve (by **Nathan Shammah**). - Fixed name collision for parallel propagator (by **Nathan Shammah**). - Fixed dimensional incongruence in `propagator` (by **Nathan Shammah**). - Fixed bug by rewriting clebsch function based on long integer fraction (by **Eric Gigure**). - Fixed bugs in QobjEvo's args depending on state and added solver tests using them (by **Eric Gigure**). - Fixed bug in `sesolve` calculation of average states when summing the timeslot states (by **Alex Pitchford**). - Fixed bug in `steadystate` solver by removing separate arguments for MKL and Scipy (by **Tarun Raheja**). - Fixed `Bloch.add_ponts` by setting `edgecolor = None` in `plot_points` (by **Nathan Shammah**). - Fixed error checking for null matrix in `essolve` solver affecting also `ode2es` (by **Peter Kirton**). - Removed unnecessary shebangs in .pyx and .pxd files (by **Samesh Lakhotia**). - Fixed `sesolve` and import of `os` in `codegen` (by **Alex Pitchford**). - Updated `plot_fock_distribution",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:89945,Availability,error,error,89945,"by **Eric Gigure**). - Updated authors list on Github and added `my binder` link (by **Nathan Shammah**). Bug Fixes; ---------. - Fixed `PolyDataMapper` construction for `Bloch3d` (by **Sam Griffiths**). - Fixed error checking for null matrix in essolve (by **Nathan Shammah**). - Fixed name collision for parallel propagator (by **Nathan Shammah**). - Fixed dimensional incongruence in `propagator` (by **Nathan Shammah**). - Fixed bug by rewriting clebsch function based on long integer fraction (by **Eric Gigure**). - Fixed bugs in QobjEvo's args depending on state and added solver tests using them (by **Eric Gigure**). - Fixed bug in `sesolve` calculation of average states when summing the timeslot states (by **Alex Pitchford**). - Fixed bug in `steadystate` solver by removing separate arguments for MKL and Scipy (by **Tarun Raheja**). - Fixed `Bloch.add_ponts` by setting `edgecolor = None` in `plot_points` (by **Nathan Shammah**). - Fixed error checking for null matrix in `essolve` solver affecting also `ode2es` (by **Peter Kirton**). - Removed unnecessary shebangs in .pyx and .pxd files (by **Samesh Lakhotia**). - Fixed `sesolve` and import of `os` in `codegen` (by **Alex Pitchford**). - Updated `plot_fock_distribution` by removing the offset value 0.4 in the plot (by **Rajiv-B**). Version 4.4.1 (August 29, 2019); +++++++++++++++++++++++++++++++. Improvements; ------------. - QobjEvo do not need to start from 0 anymore (by **Eric Gigure**). - Add a quantum object purity function (by **Nathan Shammah** and **Shahnawaz Ahmed**). - Add step function interpolation for array time-coefficient (by **Boxi Li**). - Generalize expand_oper for arbitrary dimensions, and new method for cyclic permutations of given target cubits (by **Boxi Li**). Bug Fixes; ---------. - Fixed the pickling but that made solver unable to run in parallel on Windows (Thank **lrunze** for reporting). - Removed warning when mesolve fall back on sesolve (by **Michael Goerz**). - Fixed dimension che",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:91951,Availability,avail,available,91951,"erz**). - Fixed dimension check and confusing documentation in random ket (by **Yariv Yanay**). - Fixed Qobj isherm not working after using Qobj.permute (Thank **llorz1207** for reporting). - Correlation functions call now properly handle multiple time dependant functions (Thank **taw181** for reporting). - Removed mutable default values in mesolve/sesolve (by **Michael Goerz**). - Fixed simdiag bug (Thank **Croydon-Brixton** for reporting). - Better support of constant QobjEvo (by **Boxi Li**). - Fixed potential cyclic import in the control module (by **Alexander Pitchford**). Version 4.4.0 (July 03, 2019); +++++++++++++++++++++++++++++. Improvements; ------------. - **MAJOR FEATURE**: Added methods and techniques to the stochastic solvers (by **Eric Gigure**) which allows to use a much broader set of solvers and much more efficiently. - **MAJOR FEATURE**: Optimization of the montecarlo solver (by **Eric Gigure**). Computation are faster in many cases. Collapse information available to time dependant information. - Added the QObjEvo class and methods (by **Eric Gigure**), which is used behind the scenes by the dynamical solvers, making the code more efficient and tidier. More built-in function available to string coefficients. - The coefficients can be made from interpolated array with variable timesteps and can obtain state information more easily. Time-dependant collapse operator can have multiple terms. - New wigner_transform and plot_wigner_sphere function. (by **Nithin Ramu**). - ptrace is faster and work on bigger systems, from 15 Qbits to 30 Qbits. - QIP module: added the possibility for user-defined gates, added the possibility to remove or add gates in any point of an already built circuit, added the molmer_sorensen gate, and fixed some bugs (by **Boxi Li**). - Added the quantum Hellinger distance to qutip.metrics (by **Wojciech Rzadkowski**). - Implemented possibility of choosing a random seed (by **Marek Marekyggdrasil**). - Added a code of conduct to",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:92177,Availability,avail,available,92177,"w properly handle multiple time dependant functions (Thank **taw181** for reporting). - Removed mutable default values in mesolve/sesolve (by **Michael Goerz**). - Fixed simdiag bug (Thank **Croydon-Brixton** for reporting). - Better support of constant QobjEvo (by **Boxi Li**). - Fixed potential cyclic import in the control module (by **Alexander Pitchford**). Version 4.4.0 (July 03, 2019); +++++++++++++++++++++++++++++. Improvements; ------------. - **MAJOR FEATURE**: Added methods and techniques to the stochastic solvers (by **Eric Gigure**) which allows to use a much broader set of solvers and much more efficiently. - **MAJOR FEATURE**: Optimization of the montecarlo solver (by **Eric Gigure**). Computation are faster in many cases. Collapse information available to time dependant information. - Added the QObjEvo class and methods (by **Eric Gigure**), which is used behind the scenes by the dynamical solvers, making the code more efficient and tidier. More built-in function available to string coefficients. - The coefficients can be made from interpolated array with variable timesteps and can obtain state information more easily. Time-dependant collapse operator can have multiple terms. - New wigner_transform and plot_wigner_sphere function. (by **Nithin Ramu**). - ptrace is faster and work on bigger systems, from 15 Qbits to 30 Qbits. - QIP module: added the possibility for user-defined gates, added the possibility to remove or add gates in any point of an already built circuit, added the molmer_sorensen gate, and fixed some bugs (by **Boxi Li**). - Added the quantum Hellinger distance to qutip.metrics (by **Wojciech Rzadkowski**). - Implemented possibility of choosing a random seed (by **Marek Marekyggdrasil**). - Added a code of conduct to Github. Bug Fixes; ---------. - Fixed bug that made QuTiP incompatible with SciPy 1.3. Version 4.3.0 (July 14, 2018); +++++++++++++++++++++++++++++. Improvements; ------------. - **MAJOR FEATURE**: Added the Permutational",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:94946,Availability,error,error,94946,"is now ~30x faster. - Added projector method to Qobj class. - Added fast projector method, ``Q.proj()``. - Computing matrix elements, ``Q.matrix_element`` is now ~10x faster. - Computing expectation values for ket vectors using ``expect`` is now ~10x faster. - ``Q.tr()`` is now faster for small Hilbert space dimensions. - Unitary operator evolution added to sesolve. - Use OPENMP for tidyup if installed. Bug Fixes; ---------. - Fixed bug that stopped simdiag working for python 3. - Fixed semidefinite cvxpy Variable and Parameter. - Fixed iterative lu solve atol keyword issue. - Fixed unitary op evolution rhs matrix in ssesolve. - Fixed interpolating function to return zero outside range. - Fixed dnorm complex casting bug. - Fixed control.io path checking issue. - Fixed ENR fock dimension. - Fixed hard coded options in propagator 'batch' mode. - Fixed bug in trace-norm for non-Hermitian operators. - Fixed bug related to args not being passed to coherence_function_g2. - Fixed MKL error checking dict key error. Version 4.2.0 (July 28, 2017); +++++++++++++++++++++++++++++. Improvements; ------------. - **MAJOR FEATURE**: Initial implementation of time-dependent Bloch-Redfield Solver. - Qobj tidyup is now an order of magnitude faster. - Time-dependent codegen now generates output NumPy arrays faster. - Improved calculation for analytic coefficients in coherent states (Sebastian Kramer). - Input array to correlation FFT method now checked for validity. - Function-based time-dependent mesolve and sesolve routines now faster. - Codegen now makes sure that division is done in C, as opposed to Python. - Can now set different controls for a each timeslot in quantum optimization.; This allows time-varying controls to be used in pulse optimisation. Bug Fixes; ---------. - rcsolve importing old Odeoptions Class rather than Options. - Non-int issue in spin Q and Wigner functions. - Qobj's should tidyup before determining isherm. - Fixed time-dependent RHS function loading on Win. - ",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:94970,Availability,error,error,94970,"is now ~30x faster. - Added projector method to Qobj class. - Added fast projector method, ``Q.proj()``. - Computing matrix elements, ``Q.matrix_element`` is now ~10x faster. - Computing expectation values for ket vectors using ``expect`` is now ~10x faster. - ``Q.tr()`` is now faster for small Hilbert space dimensions. - Unitary operator evolution added to sesolve. - Use OPENMP for tidyup if installed. Bug Fixes; ---------. - Fixed bug that stopped simdiag working for python 3. - Fixed semidefinite cvxpy Variable and Parameter. - Fixed iterative lu solve atol keyword issue. - Fixed unitary op evolution rhs matrix in ssesolve. - Fixed interpolating function to return zero outside range. - Fixed dnorm complex casting bug. - Fixed control.io path checking issue. - Fixed ENR fock dimension. - Fixed hard coded options in propagator 'batch' mode. - Fixed bug in trace-norm for non-Hermitian operators. - Fixed bug related to args not being passed to coherence_function_g2. - Fixed MKL error checking dict key error. Version 4.2.0 (July 28, 2017); +++++++++++++++++++++++++++++. Improvements; ------------. - **MAJOR FEATURE**: Initial implementation of time-dependent Bloch-Redfield Solver. - Qobj tidyup is now an order of magnitude faster. - Time-dependent codegen now generates output NumPy arrays faster. - Improved calculation for analytic coefficients in coherent states (Sebastian Kramer). - Input array to correlation FFT method now checked for validity. - Function-based time-dependent mesolve and sesolve routines now faster. - Codegen now makes sure that division is done in C, as opposed to Python. - Can now set different controls for a each timeslot in quantum optimization.; This allows time-varying controls to be used in pulse optimisation. Bug Fixes; ---------. - rcsolve importing old Odeoptions Class rather than Options. - Non-int issue in spin Q and Wigner functions. - Qobj's should tidyup before determining isherm. - Fixed time-dependent RHS function loading on Win. - ",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:96241,Availability,error,error,96241,"Py arrays faster. - Improved calculation for analytic coefficients in coherent states (Sebastian Kramer). - Input array to correlation FFT method now checked for validity. - Function-based time-dependent mesolve and sesolve routines now faster. - Codegen now makes sure that division is done in C, as opposed to Python. - Can now set different controls for a each timeslot in quantum optimization.; This allows time-varying controls to be used in pulse optimisation. Bug Fixes; ---------. - rcsolve importing old Odeoptions Class rather than Options. - Non-int issue in spin Q and Wigner functions. - Qobj's should tidyup before determining isherm. - Fixed time-dependent RHS function loading on Win. - Fixed several issues with compiling with Cython 0.26. - Liouvillian superoperators were hard setting isherm=True by default. - Fixed an issue with the solver safety checks when inputing a list with Python functions as time-dependence. - Fixed non-int issue in Wigner_cmap. - MKL solver error handling not working properly. Version 4.1.0 (March 10, 2017); ++++++++++++++++++++++++++++++. Improvements; ------------. *Core libraries*. - **MAJOR FEATURE**: QuTiP now works for Python 3.5+ on Windows using Visual Studio 2015. - **MAJOR FEATURE**: Cython and other low level code switched to C++ for MS Windows compatibility. - **MAJOR FEATURE**: Can now use interpolating cubic splines as time-dependent coefficients. - **MAJOR FEATURE**: Sparse matrix - vector multiplication now parallel using OPENMP. - Automatic tuning of OPENMP threading threshold. - Partial trace function is now up to 100x+ faster. - Hermitian verification now up to 100x+ faster. - Internal Qobj objects now created up to 60x faster. - Inplace conversion from COO -> CSR sparse formats (e.g. Memory efficiency improvement.). - Faster reverse Cuthill-Mckee and sparse one and inf norms. Bug Fixes; ---------. - Cleanup of temp. Cython files now more robust and working under Windows. Version 4.0.2 (January 5, 2017); +++++++++",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:97176,Availability,robust,robust,97176,"endence. - Fixed non-int issue in Wigner_cmap. - MKL solver error handling not working properly. Version 4.1.0 (March 10, 2017); ++++++++++++++++++++++++++++++. Improvements; ------------. *Core libraries*. - **MAJOR FEATURE**: QuTiP now works for Python 3.5+ on Windows using Visual Studio 2015. - **MAJOR FEATURE**: Cython and other low level code switched to C++ for MS Windows compatibility. - **MAJOR FEATURE**: Can now use interpolating cubic splines as time-dependent coefficients. - **MAJOR FEATURE**: Sparse matrix - vector multiplication now parallel using OPENMP. - Automatic tuning of OPENMP threading threshold. - Partial trace function is now up to 100x+ faster. - Hermitian verification now up to 100x+ faster. - Internal Qobj objects now created up to 60x faster. - Inplace conversion from COO -> CSR sparse formats (e.g. Memory efficiency improvement.). - Faster reverse Cuthill-Mckee and sparse one and inf norms. Bug Fixes; ---------. - Cleanup of temp. Cython files now more robust and working under Windows. Version 4.0.2 (January 5, 2017); +++++++++++++++++++++++++++++++. Bug Fixes; ---------; - td files no longer left behind by correlation tests; - Various fast sparse fixes. Version 4.0.0 (December 22, 2016); +++++++++++++++++++++++++++++++++. Improvements; ------------; *Core libraries*. - **MAJOR FEATURE**: Fast sparse: New subclass of csr_matrix added that overrides commonly used methods to avoid certain checks that incurr execution cost. All Qobj.data now fast_csr_matrix; - HEOM performance enhancements; - spmv now faster; - mcsolve codegen further optimised. *Control modules*. - Time dependent drift (through list of pwc dynamics generators); - memory optimisation options provided for control.dynamics. Bug Fixes; ---------. - recompilation of pyx files on first import removed; - tau array in control.pulseoptim funcs now works. Version 3.2.0 (Never officially released); +++++++++++++++++++++++++++++++++++++++++. New Features; ------------. *Core libraries*",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:103258,Availability,error,error,103258,"ad only). - propcomp functions. - ``compute_propagator`` now ``_compute_propagator``; - ``compute_diff_prop`` now ``_compute_diff_prop``; - ``compute_prop_grad`` now ``_compute_prop_grad``. - tslotcomp functions. - ``get_timeslot_for_fidelity_calc`` now ``_get_timeslot_for_fidelity_calc``. *Miscellaneous*. - QuTiP Travis CI tests now use the Anaconda distribution.; - The ``about`` box and ipynb ``version_table`` now display addition system information.; - Updated Cython cleanup to remove depreciation warning in sysconfig.; - Updated ipynb_parallel to look for ``ipyparallel`` module in V4 of the notebooks. Bug Fixes; ---------; - Fixes for countstat and psuedo-inverse functions; - Fixed Qobj division tests on 32-bit systems.; - Removed extra call to Python in time-dependent Cython code.; - Fixed issue with repeated Bloch sphere saving.; - Fixed T_0 triplet state not normalized properly. (**Fixed by Eric Hontz**); - Simplified compiler flags (support for ARM systems).; - Fixed a decoding error in ``qload``.; - Fixed issue using complex.h math and np.kind_t variables.; - Corrected output states mismatch for ``ntraj=1`` in the mcf90 solver.; - Qobj data is now copied by default to avoid a bug in multiplication. (**Fixed by Richard Brierley**); - Fixed bug overwriting ``hardware_info`` in ``__init__``. (**Fixed by Johannes Feist**); - Restored ability to explicity set Q.isherm, Q.type, and Q.superrep.; - Fixed integer depreciation warnings from NumPy.; - Qobj * (dense vec) would result in a recursive loop.; - Fixed args=None -> args={} in correlation functions to be compatible with mesolve.; - Fixed depreciation warnings in mcsolve.; - Fixed neagtive only real parts in ``rand_ket``.; - Fixed a complicated list-cast-map-list antipattern in super operator reps. (**Fixed by Stefan Krastanov**); - Fixed incorrect ``isherm`` for ``sigmam`` spin operator.; - Fixed the dims when using ``final_state_output`` in ``mesolve`` and ``sesolve``. Version 3.1.0 (January 1, 2015); ++++++",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:104789,Availability,avail,available,104789,"rgs={} in correlation functions to be compatible with mesolve.; - Fixed depreciation warnings in mcsolve.; - Fixed neagtive only real parts in ``rand_ket``.; - Fixed a complicated list-cast-map-list antipattern in super operator reps. (**Fixed by Stefan Krastanov**); - Fixed incorrect ``isherm`` for ``sigmam`` spin operator.; - Fixed the dims when using ``final_state_output`` in ``mesolve`` and ``sesolve``. Version 3.1.0 (January 1, 2015); +++++++++++++++++++++++++++++++. New Features; ------------. - **MAJOR FEATURE**: New module for quantum control (qutip.control).; - **NAMESPACE CHANGE**: QuTiP no longer exports symbols from NumPy and matplotlib, so those modules must now be explicitly imported when required.; - New module for counting statistics.; - Stochastic solvers now run trajectories in parallel.; - New superoperator and tensor manipulation functions; (super_tensor, composite, tensor_contract).; - New logging module for debugging (qutip.logging).; - New user-available API for parallelization (parallel_map).; - New enhanced (optional) text-based progressbar (qutip.ui.EnhancedTextProgressBar); - Faster Python based monte carlo solver (mcsolve).; - Support for progress bars in propagator function.; - Time-dependent Cython code now calls complex cmath functions.; - Random numbers seeds can now be reused for successive calls to mcsolve.; - The Bloch-Redfield master equation solver now supports optional Lindblad type collapse operators.; - Improved handling of ODE integration errors in mesolve.; - Improved correlation function module (for example, improved support for time-dependent problems).; - Improved parallelization of mcsolve (can now be interrupted easily, support for IPython.parallel, etc.); - Many performance improvements, and much internal code restructuring. Bug Fixes; ---------. - Cython build files for time-dependent string format now removed automatically.; - Fixed incorrect solution time from inverse-power method steady state solver.; - mcsolve now",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:105311,Availability,error,errors,105311,"-----------. - **MAJOR FEATURE**: New module for quantum control (qutip.control).; - **NAMESPACE CHANGE**: QuTiP no longer exports symbols from NumPy and matplotlib, so those modules must now be explicitly imported when required.; - New module for counting statistics.; - Stochastic solvers now run trajectories in parallel.; - New superoperator and tensor manipulation functions; (super_tensor, composite, tensor_contract).; - New logging module for debugging (qutip.logging).; - New user-available API for parallelization (parallel_map).; - New enhanced (optional) text-based progressbar (qutip.ui.EnhancedTextProgressBar); - Faster Python based monte carlo solver (mcsolve).; - Support for progress bars in propagator function.; - Time-dependent Cython code now calls complex cmath functions.; - Random numbers seeds can now be reused for successive calls to mcsolve.; - The Bloch-Redfield master equation solver now supports optional Lindblad type collapse operators.; - Improved handling of ODE integration errors in mesolve.; - Improved correlation function module (for example, improved support for time-dependent problems).; - Improved parallelization of mcsolve (can now be interrupted easily, support for IPython.parallel, etc.); - Many performance improvements, and much internal code restructuring. Bug Fixes; ---------. - Cython build files for time-dependent string format now removed automatically.; - Fixed incorrect solution time from inverse-power method steady state solver.; - mcsolve now supports `Options(store_states=True)`; - Fixed bug in `hadamard` gate function.; - Fixed compatibility issues with NumPy 1.9.0.; - Progressbar in mcsolve can now be suppressed.; - Fixed bug in `gate_expand_3toN`.; - Fixed bug for time-dependent problem (list string format) with multiple terms in coefficient to an operator. Version 3.0.1 (Aug 5, 2014); +++++++++++++++++++++++++++. Bug Fixes; ---------. - Fix bug in create(), which returned a Qobj with CSC data instead of CSR.; - Fix sever",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:106678,Availability,failure,failure,106678,"format now removed automatically.; - Fixed incorrect solution time from inverse-power method steady state solver.; - mcsolve now supports `Options(store_states=True)`; - Fixed bug in `hadamard` gate function.; - Fixed compatibility issues with NumPy 1.9.0.; - Progressbar in mcsolve can now be suppressed.; - Fixed bug in `gate_expand_3toN`.; - Fixed bug for time-dependent problem (list string format) with multiple terms in coefficient to an operator. Version 3.0.1 (Aug 5, 2014); +++++++++++++++++++++++++++. Bug Fixes; ---------. - Fix bug in create(), which returned a Qobj with CSC data instead of CSR.; - Fix several bugs in mcsolve: Incorrect storing of collapse times and collapse; operator records. Incorrect averaging of expectation values for different; trajectories when using only 1 CPU.; - Fix bug in parsing of time-dependent Hamiltonian/collapse operator arguments; that occurred when the args argument is not a dictionary.; - Fix bug in internal _version2int function that cause a failure when parsingthe version number of the Cython package.; -. Version 3.0.0 (July 17, 2014); +++++++++++++++++++++++++++++. New Features; ------------. - New module `qutip.stochastic` with stochastic master equation and stochastic; Schrdinger equation solvers. - Expanded steady state solvers. The function ``steady`` has been deprecated in; favor of ``steadystate``. The steadystate solver no longer use umfpack by; default. New pre-processing methods for reordering and balancing the linear; equation system used in direct solution of the steady state. - New module `qutip.qip` with utilities for quantum information processing,; including pre-defined quantum gates along with functions for expanding; arbitrary 1, 2, and 3 qubit gates to N qubit registers, circuit; representations, library of quantum algorithms, and basic physical models for; some common QIP architectures. - New module `qutip.distributions` with unified API for working with; distribution functions. - New format for defini",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:109593,Availability,avail,available,109593,"nt``. - The ``expect`` function now supports a list of operators, in addition to the; previously supported list of states. - Simplified creation of qubit states using ``ket`` function. - The module ``qutip.cyQ`` has been renamed to ``qutip.cy`` and the sparse; matrix-vector functions ``spmv`` and ``spmv1d`` has been combined into one; function ``spmv``. New functions for operating directly on the underlaying; sparse CSR data have been added (e.g., ``spmv_csr``). Performance; improvements. New and improved Cython functions for calculating expectation; values for state vectors, density matrices in matrix and vector form. - The ``concurrence`` function now supports both pure and mixed states. Added; function for calculating the entangling power of a two-qubit gate. - Added function for generating (generalized) Lindblad dissipator; superoperators. - New functions for generating Bell states, and singlet and triplet states. - QuTiP no longer contains the demos GUI. The examples are now available on the; QuTiP web site. The ``qutip.gui`` module has been renamed to ``qutip.ui`` and; does no longer contain graphical UI elements. New text-based and HTML-based; progressbar classes. - Support for harmonic oscillator operators/states in a Fock state basis that; does not start from zero (e.g., in the range [M,N+1]). Support for; eliminating and extracting states from Qobj instances (e.g., removing one; state from a two-qubit system to obtain a three-level system). - Support for time-dependent Hamiltonian and Liouvillian callback functions that; depend on the instantaneous state, which for example can be used for solving; master equations with mean field terms. Improvements; ------------. - Restructured and optimized implementation of Qobj, which now has; significantly lower memory footprint due to avoiding excessive copying of; internal matrix data. - The classes ``OdeData``, ``Odeoptions``, ``Odeconfig`` are now called; ``Result``, ``Options``, and ``Config``, respectively, and a",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:110602,Availability,avail,available,110602,"ontains the demos GUI. The examples are now available on the; QuTiP web site. The ``qutip.gui`` module has been renamed to ``qutip.ui`` and; does no longer contain graphical UI elements. New text-based and HTML-based; progressbar classes. - Support for harmonic oscillator operators/states in a Fock state basis that; does not start from zero (e.g., in the range [M,N+1]). Support for; eliminating and extracting states from Qobj instances (e.g., removing one; state from a two-qubit system to obtain a three-level system). - Support for time-dependent Hamiltonian and Liouvillian callback functions that; depend on the instantaneous state, which for example can be used for solving; master equations with mean field terms. Improvements; ------------. - Restructured and optimized implementation of Qobj, which now has; significantly lower memory footprint due to avoiding excessive copying of; internal matrix data. - The classes ``OdeData``, ``Odeoptions``, ``Odeconfig`` are now called; ``Result``, ``Options``, and ``Config``, respectively, and are available in; the module `qutip.solver`. - The ``squeez`` function has been renamed to ``squeeze``. - Better support for sparse matrices when calculating propagators using the; ``propagator`` function. - Improved Bloch sphere. - Restructured and improved the module ``qutip.sparse``, which now only; operates directly on sparse matrices (not on Qobj instances). - Improved and simplified implement of the ``tensor`` function. - Improved performance, major code cleanup (including namespace changes),; and numerous bug fixes. - Benchmark scripts improved and restructured. - QuTiP is now using continuous integration tests (TravisCI). Version 2.2.0 (March 01, 2013); ++++++++++++++++++++++++++++++. New Features; ------------. - **Added Support for Windows**. - New Bloch3d class for plotting 3D Bloch spheres using Mayavi. - Bloch sphere vectors now look like arrows. - Partial transpose function. - Continuos variable functions for calculating cor",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:118246,Availability,toler,tolerance,118246,"openmp flags from setup.py as new Mac Xcode compiler does not recognize them. - Qobj diag method now returns real array if all imaginary parts are zero. - Examples GUI now links to new documentation. - Fixed zero-dimensional array output from metrics module. Version 1.1.2 (October 27, 2011); ++++++++++++++++++++++++++++++++. Bug Fixes; ---------. - Fixed issue where Monte Carlo states were not output properly. Version 1.1.1 (October 25, 2011); ++++++++++++++++++++++++++++++++. **THIS POINT-RELEASE INCLUDES VASTLY IMPROVED TIME-INDEPENDENT MCSOLVE AND ODESOLVE PERFORMANCE**. New Functions; -------------. - Added linear entropy function. - Number of CPU's can now be changed. Bug Fixes; ---------. - Metrics no longer use dense matrices. - Fixed Bloch sphere grid issue with matplotlib 1.1. - Qobj trace operation uses only sparse matrices. - Fixed issue where GUI windows do not raise to front. Version 1.1.0 (October 04, 2011); ++++++++++++++++++++++++++++++++. **THIS RELEASE NOW REQUIRES THE GCC COMPILER TO BE INSTALLED**. New Functions; -------------. - tidyup function to remove small elements from a Qobj. - Added concurrence function. - Added simdiag for simultaneous diagonalization of operators. - Added eigenstates method returning eigenstates and eigenvalues to Qobj class. - Added fileio for saving and loading data sets and/or Qobj's. - Added hinton function for visualizing density matrices. Bug Fixes; ---------. - Switched Examples to new Signals method used in PySide 1.0.6+. - Switched ProgressBar to new Signals method. - Fixed memory issue in expm functions. - Fixed memory bug in isherm. - Made all Qobj data complex by default. - Reduced ODE tolerance levels in Odeoptions. - Fixed bug in ptrace where dense matrix was used instead of sparse. - Fixed issue where PyQt4 version would not be displayed in about box. - Fixed issue in Wigner where xvec was used twice (in place of yvec). Version 1.0.0 (July 29, 2011); +++++++++++++++++++++++++++++. - **Initial release.**; ",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:65,Deployability,release,release,65,".. _changelog:. **********; Change Log; **********. .. towncrier release notes start. QuTiP 5.0.4 (2024-08-30); ========================. Micro release to add support for numpy 2.1. Bug Fixes; ---------. - Fixed rounding error in dicke_trace_function that resulted in negative eigenvalues. (#2466, by Andrey Nikitin). QuTiP 5.0.3 (2024-06-20); ========================. Micro release to add support for numpy 2. Bug Fixes; ---------. - Bug Fix in Process Matrix Rendering. (#2400, by Anush Venkatakrishnan); - Fix steadystate permutation being reversed. (#2443); - Add parallelizing support for `vernN` methods with `mcsolve`. (#2454 by Utkarsh). Documentation; -------------. - Added `qutip.core.gates` to apidoc/functions.rst and a Gates section to guide-states.rst. (#2441, by alan-nala). Miscellaneous; -------------. - Add support for numpy 2 (#2421, #2457); - Add support for scipy 1.14 (#2469). QuTiP 5.0.2 (2024-05-16); ========================. Bug Fixes; ---------. - Use CSR as the default for expand_operator (#2380, by BoxiLi); - Fix import of the partial_transpose function.; Ensures that the negativity function can handle both kets and density operators as input. (#2371, by vikas-chaudhary-2802); - Ensure that end_condition of mcsolve result doesn't say target tolerance reached when it hasn't (#2382, by magzpavz); - Fix two bugs in steadystate floquet solver, and adjust tests to be sensitive to this issue. (#2393, by Neill Lambert). Documentation; -------------. - Correct a mistake in the doc (#2401, by PositroniumJS); - Fix #2156: Correct a sample of code in the doc (#2409, by PositroniumJS). Miscellaneous; -------------. - Better metadata management in operators creation functions (#2388); - Implicitly set minimum python version to 3.9 (#2413); - Qobj.__eq__ uses core's settings rtol. (#2425); - Only normalize solver states when the initial state is already normalized. (#2427). QuTiP 5.0.1 (2024-04-03); ========================. Patch update fixing small issues with ",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:144,Deployability,release,release,144,".. _changelog:. **********; Change Log; **********. .. towncrier release notes start. QuTiP 5.0.4 (2024-08-30); ========================. Micro release to add support for numpy 2.1. Bug Fixes; ---------. - Fixed rounding error in dicke_trace_function that resulted in negative eigenvalues. (#2466, by Andrey Nikitin). QuTiP 5.0.3 (2024-06-20); ========================. Micro release to add support for numpy 2. Bug Fixes; ---------. - Bug Fix in Process Matrix Rendering. (#2400, by Anush Venkatakrishnan); - Fix steadystate permutation being reversed. (#2443); - Add parallelizing support for `vernN` methods with `mcsolve`. (#2454 by Utkarsh). Documentation; -------------. - Added `qutip.core.gates` to apidoc/functions.rst and a Gates section to guide-states.rst. (#2441, by alan-nala). Miscellaneous; -------------. - Add support for numpy 2 (#2421, #2457); - Add support for scipy 1.14 (#2469). QuTiP 5.0.2 (2024-05-16); ========================. Bug Fixes; ---------. - Use CSR as the default for expand_operator (#2380, by BoxiLi); - Fix import of the partial_transpose function.; Ensures that the negativity function can handle both kets and density operators as input. (#2371, by vikas-chaudhary-2802); - Ensure that end_condition of mcsolve result doesn't say target tolerance reached when it hasn't (#2382, by magzpavz); - Fix two bugs in steadystate floquet solver, and adjust tests to be sensitive to this issue. (#2393, by Neill Lambert). Documentation; -------------. - Correct a mistake in the doc (#2401, by PositroniumJS); - Fix #2156: Correct a sample of code in the doc (#2409, by PositroniumJS). Miscellaneous; -------------. - Better metadata management in operators creation functions (#2388); - Implicitly set minimum python version to 3.9 (#2413); - Qobj.__eq__ uses core's settings rtol. (#2425); - Only normalize solver states when the initial state is already normalized. (#2427). QuTiP 5.0.1 (2024-04-03); ========================. Patch update fixing small issues with ",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:376,Deployability,release,release,376,".. _changelog:. **********; Change Log; **********. .. towncrier release notes start. QuTiP 5.0.4 (2024-08-30); ========================. Micro release to add support for numpy 2.1. Bug Fixes; ---------. - Fixed rounding error in dicke_trace_function that resulted in negative eigenvalues. (#2466, by Andrey Nikitin). QuTiP 5.0.3 (2024-06-20); ========================. Micro release to add support for numpy 2. Bug Fixes; ---------. - Bug Fix in Process Matrix Rendering. (#2400, by Anush Venkatakrishnan); - Fix steadystate permutation being reversed. (#2443); - Add parallelizing support for `vernN` methods with `mcsolve`. (#2454 by Utkarsh). Documentation; -------------. - Added `qutip.core.gates` to apidoc/functions.rst and a Gates section to guide-states.rst. (#2441, by alan-nala). Miscellaneous; -------------. - Add support for numpy 2 (#2421, #2457); - Add support for scipy 1.14 (#2469). QuTiP 5.0.2 (2024-05-16); ========================. Bug Fixes; ---------. - Use CSR as the default for expand_operator (#2380, by BoxiLi); - Fix import of the partial_transpose function.; Ensures that the negativity function can handle both kets and density operators as input. (#2371, by vikas-chaudhary-2802); - Ensure that end_condition of mcsolve result doesn't say target tolerance reached when it hasn't (#2382, by magzpavz); - Fix two bugs in steadystate floquet solver, and adjust tests to be sensitive to this issue. (#2393, by Neill Lambert). Documentation; -------------. - Correct a mistake in the doc (#2401, by PositroniumJS); - Fix #2156: Correct a sample of code in the doc (#2409, by PositroniumJS). Miscellaneous; -------------. - Better metadata management in operators creation functions (#2388); - Implicitly set minimum python version to 3.9 (#2413); - Qobj.__eq__ uses core's settings rtol. (#2425); - Only normalize solver states when the initial state is already normalized. (#2427). QuTiP 5.0.1 (2024-04-03); ========================. Patch update fixing small issues with ",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:1969,Deployability,update,update,1969,"SR as the default for expand_operator (#2380, by BoxiLi); - Fix import of the partial_transpose function.; Ensures that the negativity function can handle both kets and density operators as input. (#2371, by vikas-chaudhary-2802); - Ensure that end_condition of mcsolve result doesn't say target tolerance reached when it hasn't (#2382, by magzpavz); - Fix two bugs in steadystate floquet solver, and adjust tests to be sensitive to this issue. (#2393, by Neill Lambert). Documentation; -------------. - Correct a mistake in the doc (#2401, by PositroniumJS); - Fix #2156: Correct a sample of code in the doc (#2409, by PositroniumJS). Miscellaneous; -------------. - Better metadata management in operators creation functions (#2388); - Implicitly set minimum python version to 3.9 (#2413); - Qobj.__eq__ uses core's settings rtol. (#2425); - Only normalize solver states when the initial state is already normalized. (#2427). QuTiP 5.0.1 (2024-04-03); ========================. Patch update fixing small issues with v5.0.0 release. - Fix broken links in the documentation when migrating to readthedocs; - Fix readthedocs search feature; - Add setuptools to runtime compilation requirements; - Fix mcsolve documentation for open systems; - Fix OverFlowError in progress bars. QuTiP 5.0.0 (2024-03-26); ========================. QuTiP 5 is a redesign of many of the core components of QuTiP (``Qobj``,; ``QobjEvo``, solvers) to make them more consistent and more flexible. ``Qobj`` may now be stored in either sparse or dense representations,; and the two may be mixed sensibly as needed. ``QobjEvo`` is now used; consistently throughout QuTiP, and the implementation has been; substantially cleaned up. A new ``Coefficient`` class is used to; represent the time-dependent factors inside ``QobjEvo``. The solvers have been rewritten to work well with the new data layer; and the concept of ``Integrators`` which solve ODEs has been introduced.; In future, new data layers may provide their own ``Inte",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:2008,Deployability,release,release,2008,"_operator (#2380, by BoxiLi); - Fix import of the partial_transpose function.; Ensures that the negativity function can handle both kets and density operators as input. (#2371, by vikas-chaudhary-2802); - Ensure that end_condition of mcsolve result doesn't say target tolerance reached when it hasn't (#2382, by magzpavz); - Fix two bugs in steadystate floquet solver, and adjust tests to be sensitive to this issue. (#2393, by Neill Lambert). Documentation; -------------. - Correct a mistake in the doc (#2401, by PositroniumJS); - Fix #2156: Correct a sample of code in the doc (#2409, by PositroniumJS). Miscellaneous; -------------. - Better metadata management in operators creation functions (#2388); - Implicitly set minimum python version to 3.9 (#2413); - Qobj.__eq__ uses core's settings rtol. (#2425); - Only normalize solver states when the initial state is already normalized. (#2427). QuTiP 5.0.1 (2024-04-03); ========================. Patch update fixing small issues with v5.0.0 release. - Fix broken links in the documentation when migrating to readthedocs; - Fix readthedocs search feature; - Add setuptools to runtime compilation requirements; - Fix mcsolve documentation for open systems; - Fix OverFlowError in progress bars. QuTiP 5.0.0 (2024-03-26); ========================. QuTiP 5 is a redesign of many of the core components of QuTiP (``Qobj``,; ``QobjEvo``, solvers) to make them more consistent and more flexible. ``Qobj`` may now be stored in either sparse or dense representations,; and the two may be mixed sensibly as needed. ``QobjEvo`` is now used; consistently throughout QuTiP, and the implementation has been; substantially cleaned up. A new ``Coefficient`` class is used to; represent the time-dependent factors inside ``QobjEvo``. The solvers have been rewritten to work well with the new data layer; and the concept of ``Integrators`` which solve ODEs has been introduced.; In future, new data layers may provide their own ``Integrators``; specialized to th",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:3933,Deployability,update,updated,3933," new data layers may provide their own ``Integrators``; specialized to their representation of the underlying data. Much of the user-facing API of QuTiP remains familiar, but there have; had to be many small breaking changes. If we can make changes to; easy migrating code from QuTiP 4 to QuTiP 5, please let us know. An extensive list of changes follows. Contributors; ------------. QuTiP 5 has been a large effort by many people over the last three years. In particular:. - Jake Lishman led the implementation of the new data layer and coefficients.; - Eric Gigure led the implementation of the new QobjEvo interface and solvers.; - Boxi Li led the updating of QuTiP's QIP support and the creation of ``qutip_qip``. Other members of the QuTiP Admin team have been heavily involved in reviewing,; testing and designing QuTiP 5:. - Alexander Pitchford; - Asier Galicia; - Nathan Shammah; - Shahnawaz Ahmed; - Neill Lambert; - Simon Cross; - Paul Menczel. Two Google Summer of Code contributors updated the tutorials and benchmarks to; QuTiP 5:. - Christian Staufenbiel updated many of the tutorials (`<https://github.com/qutip/qutip-tutorials/>`).; - Xavier Sproken update the benchmarks (`<https://github.com/qutip/qutip-benchmark/>`). During an internship at RIKEN, Patrick Hopf created a new quantum control method and; improved the existing methods interface:. - Patrick Hopf created new quantum control package (`<https://github.com/qutip/qutip-qoc/>`). Four experimental data layers backends were written either as part of Google Summer; of Code or as separate projects. While these are still alpha quality, they helped; significantly to test the data layer API:. - ``qutip-tensorflow``: a TensorFlow backend by Asier Galicia (`<https://github.com/qutip/qutip-tensorflow>`); - ``qutip-cupy``: a CuPy GPU backend by Felipe Bivort Haiek (`<https://github.com/qutip/qutip-cupy/>`)`; - ``qutip-tensornetwork``: a TensorNetwork backend by Asier Galicia (`<https://github.com/qutip/qutip-tensornetwo",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:4008,Deployability,update,updated,4008,"esentation of the underlying data. Much of the user-facing API of QuTiP remains familiar, but there have; had to be many small breaking changes. If we can make changes to; easy migrating code from QuTiP 4 to QuTiP 5, please let us know. An extensive list of changes follows. Contributors; ------------. QuTiP 5 has been a large effort by many people over the last three years. In particular:. - Jake Lishman led the implementation of the new data layer and coefficients.; - Eric Gigure led the implementation of the new QobjEvo interface and solvers.; - Boxi Li led the updating of QuTiP's QIP support and the creation of ``qutip_qip``. Other members of the QuTiP Admin team have been heavily involved in reviewing,; testing and designing QuTiP 5:. - Alexander Pitchford; - Asier Galicia; - Nathan Shammah; - Shahnawaz Ahmed; - Neill Lambert; - Simon Cross; - Paul Menczel. Two Google Summer of Code contributors updated the tutorials and benchmarks to; QuTiP 5:. - Christian Staufenbiel updated many of the tutorials (`<https://github.com/qutip/qutip-tutorials/>`).; - Xavier Sproken update the benchmarks (`<https://github.com/qutip/qutip-benchmark/>`). During an internship at RIKEN, Patrick Hopf created a new quantum control method and; improved the existing methods interface:. - Patrick Hopf created new quantum control package (`<https://github.com/qutip/qutip-qoc/>`). Four experimental data layers backends were written either as part of Google Summer; of Code or as separate projects. While these are still alpha quality, they helped; significantly to test the data layer API:. - ``qutip-tensorflow``: a TensorFlow backend by Asier Galicia (`<https://github.com/qutip/qutip-tensorflow>`); - ``qutip-cupy``: a CuPy GPU backend by Felipe Bivort Haiek (`<https://github.com/qutip/qutip-cupy/>`)`; - ``qutip-tensornetwork``: a TensorNetwork backend by Asier Galicia (`<https://github.com/qutip/qutip-tensornetwork>`); - ``qutip-jax``: a JAX backend by Eric Gigure (`<https://github.com/qutip/",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:4105,Deployability,update,update,4105,"ere have; had to be many small breaking changes. If we can make changes to; easy migrating code from QuTiP 4 to QuTiP 5, please let us know. An extensive list of changes follows. Contributors; ------------. QuTiP 5 has been a large effort by many people over the last three years. In particular:. - Jake Lishman led the implementation of the new data layer and coefficients.; - Eric Gigure led the implementation of the new QobjEvo interface and solvers.; - Boxi Li led the updating of QuTiP's QIP support and the creation of ``qutip_qip``. Other members of the QuTiP Admin team have been heavily involved in reviewing,; testing and designing QuTiP 5:. - Alexander Pitchford; - Asier Galicia; - Nathan Shammah; - Shahnawaz Ahmed; - Neill Lambert; - Simon Cross; - Paul Menczel. Two Google Summer of Code contributors updated the tutorials and benchmarks to; QuTiP 5:. - Christian Staufenbiel updated many of the tutorials (`<https://github.com/qutip/qutip-tutorials/>`).; - Xavier Sproken update the benchmarks (`<https://github.com/qutip/qutip-benchmark/>`). During an internship at RIKEN, Patrick Hopf created a new quantum control method and; improved the existing methods interface:. - Patrick Hopf created new quantum control package (`<https://github.com/qutip/qutip-qoc/>`). Four experimental data layers backends were written either as part of Google Summer; of Code or as separate projects. While these are still alpha quality, they helped; significantly to test the data layer API:. - ``qutip-tensorflow``: a TensorFlow backend by Asier Galicia (`<https://github.com/qutip/qutip-tensorflow>`); - ``qutip-cupy``: a CuPy GPU backend by Felipe Bivort Haiek (`<https://github.com/qutip/qutip-cupy/>`)`; - ``qutip-tensornetwork``: a TensorNetwork backend by Asier Galicia (`<https://github.com/qutip/qutip-tensornetwork>`); - ``qutip-jax``: a JAX backend by Eric Gigure (`<https://github.com/qutip/qutip-jax/>`). Finally, Yuji Tamakoshi updated the visualization function and added animation; f",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:5059,Deployability,update,updated,5059,"oken update the benchmarks (`<https://github.com/qutip/qutip-benchmark/>`). During an internship at RIKEN, Patrick Hopf created a new quantum control method and; improved the existing methods interface:. - Patrick Hopf created new quantum control package (`<https://github.com/qutip/qutip-qoc/>`). Four experimental data layers backends were written either as part of Google Summer; of Code or as separate projects. While these are still alpha quality, they helped; significantly to test the data layer API:. - ``qutip-tensorflow``: a TensorFlow backend by Asier Galicia (`<https://github.com/qutip/qutip-tensorflow>`); - ``qutip-cupy``: a CuPy GPU backend by Felipe Bivort Haiek (`<https://github.com/qutip/qutip-cupy/>`)`; - ``qutip-tensornetwork``: a TensorNetwork backend by Asier Galicia (`<https://github.com/qutip/qutip-tensornetwork>`); - ``qutip-jax``: a JAX backend by Eric Gigure (`<https://github.com/qutip/qutip-jax/>`). Finally, Yuji Tamakoshi updated the visualization function and added animation; functions as part of Google Summer of Code project. We have also had many other contributors, whose specific contributions are; detailed below:. - Pieter Eendebak (updated the required SciPy to 1.5+, `#1982 <https://github.com/qutip/qutip/pull/1982>`).; - Pieter Eendebak (reduced import times by setting logger names, `#1981 <https://github.com/qutip/qutip/pull/1981>`); - Pieter Eendebak (Allow scipy 1.12 to be used with qutip, `#2354 <https://github.com/qutip/qutip/pull/2354>`); - Xavier Sproken (included C header files in the source distribution, `#1971 <https://github.com/qutip/qutip/pull/1971>`); - Christian Staufenbiel (added support for multiple collapse operators to the Floquet solver, `#1962 <https://github.com/qutip/qutip/pull/1962>`); - Christian Staufenbiel (fixed the basis used in the Floquet Master Equation solver, `#1952 <https://github.com/qutip/qutip/pull/1952>`); - Christian Staufenbiel (allowed the ``bloch_redfield_tensor`` function to accept strings and",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:5279,Deployability,update,updated,5279,"ethods interface:. - Patrick Hopf created new quantum control package (`<https://github.com/qutip/qutip-qoc/>`). Four experimental data layers backends were written either as part of Google Summer; of Code or as separate projects. While these are still alpha quality, they helped; significantly to test the data layer API:. - ``qutip-tensorflow``: a TensorFlow backend by Asier Galicia (`<https://github.com/qutip/qutip-tensorflow>`); - ``qutip-cupy``: a CuPy GPU backend by Felipe Bivort Haiek (`<https://github.com/qutip/qutip-cupy/>`)`; - ``qutip-tensornetwork``: a TensorNetwork backend by Asier Galicia (`<https://github.com/qutip/qutip-tensornetwork>`); - ``qutip-jax``: a JAX backend by Eric Gigure (`<https://github.com/qutip/qutip-jax/>`). Finally, Yuji Tamakoshi updated the visualization function and added animation; functions as part of Google Summer of Code project. We have also had many other contributors, whose specific contributions are; detailed below:. - Pieter Eendebak (updated the required SciPy to 1.5+, `#1982 <https://github.com/qutip/qutip/pull/1982>`).; - Pieter Eendebak (reduced import times by setting logger names, `#1981 <https://github.com/qutip/qutip/pull/1981>`); - Pieter Eendebak (Allow scipy 1.12 to be used with qutip, `#2354 <https://github.com/qutip/qutip/pull/2354>`); - Xavier Sproken (included C header files in the source distribution, `#1971 <https://github.com/qutip/qutip/pull/1971>`); - Christian Staufenbiel (added support for multiple collapse operators to the Floquet solver, `#1962 <https://github.com/qutip/qutip/pull/1962>`); - Christian Staufenbiel (fixed the basis used in the Floquet Master Equation solver, `#1952 <https://github.com/qutip/qutip/pull/1952>`); - Christian Staufenbiel (allowed the ``bloch_redfield_tensor`` function to accept strings and callables for `a_ops`, `#1951 <https://github.com/qutip/qutip/pull/1951>`); - Christian Staufenbiel (Add a guide on Superoperators, Pauli Basis and Channel Contraction, `#1984 <https:/",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:9441,Deployability,install,installed,9441," - Daniel Weiss (Improved sampling algorithm for mcsolve, `#2218 <https://github.com/qutip/qutip/pull/2218>`); - SJUW (Increase missing colorbar padding for matrix_histogram_complex() from 0 to 0.05, `#2181 <https://github.com/qutip/qutip/pull/2181>`); - Valan Baptist Mathuranayagam (Changed qutip-notebooks to qutip-tutorials and fixed the typo in the link redirecting to the changelog section in the PR template, `#2107 <https://github.com/qutip/qutip/pull/2107>`); - Gerardo Jose Suarez (Added information on sec_cutoff to the documentation, `#2136 <https://github.com/qutip/qutip/pull/2136>`); - Cristian Emiliano Godinez Ramirez (Added inherited members to API doc of MESolver, SMESolver, SSESolver, NonMarkovianMCSolver, `#2167 <https://github.com/qutip/qutip/pull/2167>`); - Andrey Rakhubovsky (Corrected grammar in Bloch-Redfield master equation documentation, `#2174 <https://github.com/qutip/qutip/pull/2174>`); - Rushiraj Gadhvi (qutip.ipynbtools.version_table() can now be called without Cython installed, `#2110 <https://github.com/qutip/qutip/pull/2110>`); - Harsh Khilawala (Moved HTMLProgressBar from qutip/ipynbtools.py to qutip/ui/progressbar.py, `#2112 <https://github.com/qutip/qutip/pull/2112>`); - Avatar Srinidhi P V (Added new argument bc_type to take boundary conditions when creating QobjEvo, `#2114 <https://github.com/qutip/qutip/pull/2114>`); - Andrey Rakhubovsky (Fix types in docstring of projection(), `#2363 <https://github.com/qutip/qutip/pull/2363>`). Qobj changes; ------------. Previously ``Qobj`` data was stored in a SciPy-like sparse matrix. Now the; representation is flexible. Implementations for dense and sparse formats are; included in QuTiP and custom implementations are possible. QuTiP's performance; on dense states and operators is significantly improved as a result. Some highlights:. - The data is still acessible via the ``.data`` attribute, but is now an; instance of the underlying data type instead of a SciPy-like sparse matrix.; The operation",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:12842,Deployability,update,updated,12842,"g time-dependent quantum objects has been; significantly expanded, standardized and extended. The time-dependent; coefficients are now represented using a new ``Coefficient`` type that; may be independently created and manipulated if required. Some highlights:. - The ``.compile()`` method has been removed. Coefficients specified as; strings are automatically compiled if possible and the compilation is; cached across different Python runs and instances.; - Mixing coefficient types within a single ``Qobj`` is now supported.; - Many new attributes were added to ``QobjEvo`` for convenience. Examples; include ``.dims``, ``.shape``, ``.superrep`` and ``.isconstant``.; - Many old attributes such as ``.cte``, ``.use_cython``, ``.type``, ``.const``,; and ``.coeff_file`` were removed.; - A new ``Spline`` coefficient supports spline interpolations of different; orders. The old ``Cubic_Spline`` coefficient has been removed.; - The new ``.arguments(...)`` method allows additional arguments to the; underlying coefficient functions to be updated.; - The ``_step_func_coeff`` argument has been replaced by the ``order``; parameter. ``_step_func_coeff=False`` is equivalent to ``order=3``.; ``_step_func_coeff=True`` is equivalent to ``order=0``. Higher values; of ``order`` gives spline interpolations of higher orders.; - The spline type can take ``bc_type`` to control the boundary conditions.; - QobjEvo can be creating from the multiplication of a Qobj with a coefficient:; ``oper * qutip.coefficient(f, args=args)`` is equivalent to; ``qutip.QobjEvo([[oper, f]], args=args)``.; - Coefficient function can be defined in a pythonic manner: ``def f(t, A, w)``.; The dictionary ``args`` second argument is no longer needed.; Function using the exact ``f(t, args)`` signature will use the old method for; backward compatibility. Solver changes; --------------. The solvers in QuTiP have been heavily reworked and standardized.; Under the hood solvers now make use of swappable ODE ``Integrators``.; M",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:14268,Deployability,integrat,integrator,14268," qutip.coefficient(f, args=args)`` is equivalent to; ``qutip.QobjEvo([[oper, f]], args=args)``.; - Coefficient function can be defined in a pythonic manner: ``def f(t, A, w)``.; The dictionary ``args`` second argument is no longer needed.; Function using the exact ``f(t, args)`` signature will use the old method for; backward compatibility. Solver changes; --------------. The solvers in QuTiP have been heavily reworked and standardized.; Under the hood solvers now make use of swappable ODE ``Integrators``.; Many ``Integrators`` are included (see the list below) and; custom implementations are possible. Solvers now consistently; accept a ``QobjEvo`` instance at the Hamiltonian or Liouvillian, or; any object which can be passed to the ``QobjEvo`` constructor. A breakdown of highlights follows. All solvers:. - Solver options are now supplied in an ordinary Python dict.; ``qutip.Options`` is deprecated and returns a dict for backwards; compatibility.; - A specific ODE integrator may be selected by supplying a; ``method`` option.; - Each solver provides a class interface. Creating an instance; of the class allows a solver to be run multiple times for the; same system without having to repeatedly reconstruct the; right-hand side of the ODE to be integrated.; - A ``QobjEvo`` instance is accepted for most operators, e.g.,; ``H``, ``c_ops``, ``e_ops``, ``a_ops``.; - The progress bar is now selected using the ``progress_bar`` option.; A new progess bar using the ``tqdm`` Python library is provided.; - Dynamic arguments, where the value of an operator depends on; the current state of the evolution interface reworked. Now a property of the; solver is to be used as an arguments:; ``args={""state"": MESolver.StateFeedback(default=rho0)}``. Integrators:. - The SciPy zvode integrator is available with the BDF and; Adams methods as ``bdf`` and ``adams``.; - The SciPy dop853 integrator (an eighth order Runge-Kutta method by; Dormand & Prince) is available as ``dop853``.; - The SciPy ls",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:14549,Deployability,integrat,integrated,14549," The dictionary ``args`` second argument is no longer needed.; Function using the exact ``f(t, args)`` signature will use the old method for; backward compatibility. Solver changes; --------------. The solvers in QuTiP have been heavily reworked and standardized.; Under the hood solvers now make use of swappable ODE ``Integrators``.; Many ``Integrators`` are included (see the list below) and; custom implementations are possible. Solvers now consistently; accept a ``QobjEvo`` instance at the Hamiltonian or Liouvillian, or; any object which can be passed to the ``QobjEvo`` constructor. A breakdown of highlights follows. All solvers:. - Solver options are now supplied in an ordinary Python dict.; ``qutip.Options`` is deprecated and returns a dict for backwards; compatibility.; - A specific ODE integrator may be selected by supplying a; ``method`` option.; - Each solver provides a class interface. Creating an instance; of the class allows a solver to be run multiple times for the; same system without having to repeatedly reconstruct the; right-hand side of the ODE to be integrated.; - A ``QobjEvo`` instance is accepted for most operators, e.g.,; ``H``, ``c_ops``, ``e_ops``, ``a_ops``.; - The progress bar is now selected using the ``progress_bar`` option.; A new progess bar using the ``tqdm`` Python library is provided.; - Dynamic arguments, where the value of an operator depends on; the current state of the evolution interface reworked. Now a property of the; solver is to be used as an arguments:; ``args={""state"": MESolver.StateFeedback(default=rho0)}``. Integrators:. - The SciPy zvode integrator is available with the BDF and; Adams methods as ``bdf`` and ``adams``.; - The SciPy dop853 integrator (an eighth order Runge-Kutta method by; Dormand & Prince) is available as ``dop853``.; - The SciPy lsoda integrator is available as ``lsoda``.; - QuTiP's own implementation of Verner's ""most efficient"" Runge-Kutta methods; of order 7 and 9 are available as ``vern7`` and ``vern9",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:15075,Deployability,integrat,integrator,15075,"- Solver options are now supplied in an ordinary Python dict.; ``qutip.Options`` is deprecated and returns a dict for backwards; compatibility.; - A specific ODE integrator may be selected by supplying a; ``method`` option.; - Each solver provides a class interface. Creating an instance; of the class allows a solver to be run multiple times for the; same system without having to repeatedly reconstruct the; right-hand side of the ODE to be integrated.; - A ``QobjEvo`` instance is accepted for most operators, e.g.,; ``H``, ``c_ops``, ``e_ops``, ``a_ops``.; - The progress bar is now selected using the ``progress_bar`` option.; A new progess bar using the ``tqdm`` Python library is provided.; - Dynamic arguments, where the value of an operator depends on; the current state of the evolution interface reworked. Now a property of the; solver is to be used as an arguments:; ``args={""state"": MESolver.StateFeedback(default=rho0)}``. Integrators:. - The SciPy zvode integrator is available with the BDF and; Adams methods as ``bdf`` and ``adams``.; - The SciPy dop853 integrator (an eighth order Runge-Kutta method by; Dormand & Prince) is available as ``dop853``.; - The SciPy lsoda integrator is available as ``lsoda``.; - QuTiP's own implementation of Verner's ""most efficient"" Runge-Kutta methods; of order 7 and 9 are available as ``vern7`` and ``vern9``. See; http://people.math.sfu.ca/~jverner/ for a description of the methods.; - QuTiP's own implementation of a solver that directly diagonalizes the; the system to be integrated is available as ``diag``. It only works on; time-independent systems and is slow to setup, but once the diagonalization; is complete, it generates solutions very quickly.; - QuTiP's own implementatoin of an approximate Krylov subspace integrator is; available as ``krylov``. This integrator is only usable with ``sesolve``. Result class:. - A new ``.e_data`` attribute provides expectation values as a dictionary.; Unlike ``.expect``, the values are provided ",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:15177,Deployability,integrat,integrator,15177," dict for backwards; compatibility.; - A specific ODE integrator may be selected by supplying a; ``method`` option.; - Each solver provides a class interface. Creating an instance; of the class allows a solver to be run multiple times for the; same system without having to repeatedly reconstruct the; right-hand side of the ODE to be integrated.; - A ``QobjEvo`` instance is accepted for most operators, e.g.,; ``H``, ``c_ops``, ``e_ops``, ``a_ops``.; - The progress bar is now selected using the ``progress_bar`` option.; A new progess bar using the ``tqdm`` Python library is provided.; - Dynamic arguments, where the value of an operator depends on; the current state of the evolution interface reworked. Now a property of the; solver is to be used as an arguments:; ``args={""state"": MESolver.StateFeedback(default=rho0)}``. Integrators:. - The SciPy zvode integrator is available with the BDF and; Adams methods as ``bdf`` and ``adams``.; - The SciPy dop853 integrator (an eighth order Runge-Kutta method by; Dormand & Prince) is available as ``dop853``.; - The SciPy lsoda integrator is available as ``lsoda``.; - QuTiP's own implementation of Verner's ""most efficient"" Runge-Kutta methods; of order 7 and 9 are available as ``vern7`` and ``vern9``. See; http://people.math.sfu.ca/~jverner/ for a description of the methods.; - QuTiP's own implementation of a solver that directly diagonalizes the; the system to be integrated is available as ``diag``. It only works on; time-independent systems and is slow to setup, but once the diagonalization; is complete, it generates solutions very quickly.; - QuTiP's own implementatoin of an approximate Krylov subspace integrator is; available as ``krylov``. This integrator is only usable with ``sesolve``. Result class:. - A new ``.e_data`` attribute provides expectation values as a dictionary.; Unlike ``.expect``, the values are provided in a Python list rather than; a numpy array, which better supports non-numeric types.; - The contents of the ",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:15293,Deployability,integrat,integrator,15293,"plying a; ``method`` option.; - Each solver provides a class interface. Creating an instance; of the class allows a solver to be run multiple times for the; same system without having to repeatedly reconstruct the; right-hand side of the ODE to be integrated.; - A ``QobjEvo`` instance is accepted for most operators, e.g.,; ``H``, ``c_ops``, ``e_ops``, ``a_ops``.; - The progress bar is now selected using the ``progress_bar`` option.; A new progess bar using the ``tqdm`` Python library is provided.; - Dynamic arguments, where the value of an operator depends on; the current state of the evolution interface reworked. Now a property of the; solver is to be used as an arguments:; ``args={""state"": MESolver.StateFeedback(default=rho0)}``. Integrators:. - The SciPy zvode integrator is available with the BDF and; Adams methods as ``bdf`` and ``adams``.; - The SciPy dop853 integrator (an eighth order Runge-Kutta method by; Dormand & Prince) is available as ``dop853``.; - The SciPy lsoda integrator is available as ``lsoda``.; - QuTiP's own implementation of Verner's ""most efficient"" Runge-Kutta methods; of order 7 and 9 are available as ``vern7`` and ``vern9``. See; http://people.math.sfu.ca/~jverner/ for a description of the methods.; - QuTiP's own implementation of a solver that directly diagonalizes the; the system to be integrated is available as ``diag``. It only works on; time-independent systems and is slow to setup, but once the diagonalization; is complete, it generates solutions very quickly.; - QuTiP's own implementatoin of an approximate Krylov subspace integrator is; available as ``krylov``. This integrator is only usable with ``sesolve``. Result class:. - A new ``.e_data`` attribute provides expectation values as a dictionary.; Unlike ``.expect``, the values are provided in a Python list rather than; a numpy array, which better supports non-numeric types.; - The contents of the ``.stats`` attribute changed significantly and is; now more consistent across solvers. ",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:15636,Deployability,integrat,integrated,15636,"operators, e.g.,; ``H``, ``c_ops``, ``e_ops``, ``a_ops``.; - The progress bar is now selected using the ``progress_bar`` option.; A new progess bar using the ``tqdm`` Python library is provided.; - Dynamic arguments, where the value of an operator depends on; the current state of the evolution interface reworked. Now a property of the; solver is to be used as an arguments:; ``args={""state"": MESolver.StateFeedback(default=rho0)}``. Integrators:. - The SciPy zvode integrator is available with the BDF and; Adams methods as ``bdf`` and ``adams``.; - The SciPy dop853 integrator (an eighth order Runge-Kutta method by; Dormand & Prince) is available as ``dop853``.; - The SciPy lsoda integrator is available as ``lsoda``.; - QuTiP's own implementation of Verner's ""most efficient"" Runge-Kutta methods; of order 7 and 9 are available as ``vern7`` and ``vern9``. See; http://people.math.sfu.ca/~jverner/ for a description of the methods.; - QuTiP's own implementation of a solver that directly diagonalizes the; the system to be integrated is available as ``diag``. It only works on; time-independent systems and is slow to setup, but once the diagonalization; is complete, it generates solutions very quickly.; - QuTiP's own implementatoin of an approximate Krylov subspace integrator is; available as ``krylov``. This integrator is only usable with ``sesolve``. Result class:. - A new ``.e_data`` attribute provides expectation values as a dictionary.; Unlike ``.expect``, the values are provided in a Python list rather than; a numpy array, which better supports non-numeric types.; - The contents of the ``.stats`` attribute changed significantly and is; now more consistent across solvers. Monte-Carlo Solver (mcsolve):. - The system, H, may now be a super-operator.; - The ``seed`` parameter now supports supplying numpy ``SeedSequence`` or; ``Generator`` types.; - The new ``timeout`` and ``target_tol`` parameters allow the solver to exit; early if a timeout or target tolerance is reached.; -",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:15882,Deployability,integrat,integrator,15882,"he current state of the evolution interface reworked. Now a property of the; solver is to be used as an arguments:; ``args={""state"": MESolver.StateFeedback(default=rho0)}``. Integrators:. - The SciPy zvode integrator is available with the BDF and; Adams methods as ``bdf`` and ``adams``.; - The SciPy dop853 integrator (an eighth order Runge-Kutta method by; Dormand & Prince) is available as ``dop853``.; - The SciPy lsoda integrator is available as ``lsoda``.; - QuTiP's own implementation of Verner's ""most efficient"" Runge-Kutta methods; of order 7 and 9 are available as ``vern7`` and ``vern9``. See; http://people.math.sfu.ca/~jverner/ for a description of the methods.; - QuTiP's own implementation of a solver that directly diagonalizes the; the system to be integrated is available as ``diag``. It only works on; time-independent systems and is slow to setup, but once the diagonalization; is complete, it generates solutions very quickly.; - QuTiP's own implementatoin of an approximate Krylov subspace integrator is; available as ``krylov``. This integrator is only usable with ``sesolve``. Result class:. - A new ``.e_data`` attribute provides expectation values as a dictionary.; Unlike ``.expect``, the values are provided in a Python list rather than; a numpy array, which better supports non-numeric types.; - The contents of the ``.stats`` attribute changed significantly and is; now more consistent across solvers. Monte-Carlo Solver (mcsolve):. - The system, H, may now be a super-operator.; - The ``seed`` parameter now supports supplying numpy ``SeedSequence`` or; ``Generator`` types.; - The new ``timeout`` and ``target_tol`` parameters allow the solver to exit; early if a timeout or target tolerance is reached.; - The ntraj option no longer supports a list of numbers of trajectories.; Instead, just run the solver multiple times and use the class ``MCSolver``; if setting up the solver uses a significant amount of time.; - The ``map_func`` parameter has been replaced by t",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:15927,Deployability,integrat,integrator,15927," solver is to be used as an arguments:; ``args={""state"": MESolver.StateFeedback(default=rho0)}``. Integrators:. - The SciPy zvode integrator is available with the BDF and; Adams methods as ``bdf`` and ``adams``.; - The SciPy dop853 integrator (an eighth order Runge-Kutta method by; Dormand & Prince) is available as ``dop853``.; - The SciPy lsoda integrator is available as ``lsoda``.; - QuTiP's own implementation of Verner's ""most efficient"" Runge-Kutta methods; of order 7 and 9 are available as ``vern7`` and ``vern9``. See; http://people.math.sfu.ca/~jverner/ for a description of the methods.; - QuTiP's own implementation of a solver that directly diagonalizes the; the system to be integrated is available as ``diag``. It only works on; time-independent systems and is slow to setup, but once the diagonalization; is complete, it generates solutions very quickly.; - QuTiP's own implementatoin of an approximate Krylov subspace integrator is; available as ``krylov``. This integrator is only usable with ``sesolve``. Result class:. - A new ``.e_data`` attribute provides expectation values as a dictionary.; Unlike ``.expect``, the values are provided in a Python list rather than; a numpy array, which better supports non-numeric types.; - The contents of the ``.stats`` attribute changed significantly and is; now more consistent across solvers. Monte-Carlo Solver (mcsolve):. - The system, H, may now be a super-operator.; - The ``seed`` parameter now supports supplying numpy ``SeedSequence`` or; ``Generator`` types.; - The new ``timeout`` and ``target_tol`` parameters allow the solver to exit; early if a timeout or target tolerance is reached.; - The ntraj option no longer supports a list of numbers of trajectories.; Instead, just run the solver multiple times and use the class ``MCSolver``; if setting up the solver uses a significant amount of time.; - The ``map_func`` parameter has been replaced by the ``map`` option.; - A loky based parallel map as been added.; - A mpi based",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:18696,Deployability,integrat,integrator,18696," value of the influence martingale is available through the ``.trace`` attribute of the result. Stochastic Equation Solvers (ssesolve, smesolve). - Function call greatly changed: many keyword arguments are now options.; - m_ops and dW_factors are now changed from the default from the new class interface only.; - Use the same parallel maps as mcsolve: support for loky and mpi map added.; - End conditions ``timeout`` and ``target_tol`` added.; - The ``seed`` parameter now supports supplying numpy ``SeedSequence``.; - Wiener function is now available as a feedback. Bloch-Redfield Master Equation Solver (brmesolve):. - The ``a_ops`` and ``spectra`` support implementations been heavily reworked to; reuse the techniques from the new Coefficient and QobjEvo classes.; - The ``use_secular`` parameter has been removed. Use ``sec_cutoff=-1`` instead.; - The required tolerance is now read from ``qutip.settings``. Krylov Subspace Solver (krylovsolve):. - The Krylov solver is now implemented using ``SESolver`` and the ``krylov``; ODE integrator. The function ``krylovsolve`` is maintained for convenience; and now supports many more options.; - The ``sparse`` parameter has been removed. Supply a sparse ``Qobj`` for the; Hamiltonian instead. Floquet Solver (fsesolve and fmmesolve):. - The Floquet solver has been rewritten to use a new ``FloquetBasis`` class; which manages the transformations from lab to Floquet basis and back.; - Many of the internal methods used by the old Floquet solvers have; been removed. The Floquet tensor may still be retried using; the function ``floquet_tensor``.; - The Floquet Markov Master Equation solver has had many changes and; new options added. The environment temperature may be specified using; ``w_th``, and the result states are stored in the lab basis and optionally; in the Floquet basis using ``store_floquet_state``.; - The spectra functions supplied to ``fmmesolve`` must now be vectorized; (i.e. accept and return numpy arrays for frequencies and ",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:20168,Deployability,integrat,integration,20168," tensor may still be retried using; the function ``floquet_tensor``.; - The Floquet Markov Master Equation solver has had many changes and; new options added. The environment temperature may be specified using; ``w_th``, and the result states are stored in the lab basis and optionally; in the Floquet basis using ``store_floquet_state``.; - The spectra functions supplied to ``fmmesolve`` must now be vectorized; (i.e. accept and return numpy arrays for frequencies and densities) and; must accept negative frequence (i.e. usually include a ``w > 0`` factor; so that the returned densities are zero for negative frequencies).; - The number of sidebands to keep, ``kmax`` may only be supplied when using; the ``FMESolver``; - The ``Tsteps`` parameter has been removed from both ``fsesolve`` and; ``fmmesolve``. The ``precompute`` option to ``FloquetBasis`` may be used; instead. Evolution of State Solver (essovle):. - The function ``essolve`` has been removed. Use the ``diag`` integration; method with ``sesolve`` or ``mesolve`` instead. Steady-state solvers (steadystate module):. - The ``method`` parameter and ``solver`` parameters have been separated. Previously; they were mixed together in the ``method`` parameter.; - The previous options are now passed as parameters to the steady state; solver and mostly passed through to the underlying SciPy functions.; - The logging and statistics have been removed. Correlation functions (correlation module):. - A new ``correlation_3op`` function has been added. It supports ``MESolver``; or ``BRMESolver``.; - The ``correlation``, ``correlation_4op``, and ``correlation_ss`` functions have been; removed.; - Support for calculating correlation with ``mcsolve`` has been removed. Propagators (propagator module):. - A class interface, ``qutip.Propagator``, has been added for propagators.; - Propagation of time-dependent systems is now supported using ``QobjEvo``.; - The ``unitary_mode`` and ``parallel`` options have been removed. Correlation spec",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:21560,Deployability,integrat,integrators,21560,"s.; - The logging and statistics have been removed. Correlation functions (correlation module):. - A new ``correlation_3op`` function has been added. It supports ``MESolver``; or ``BRMESolver``.; - The ``correlation``, ``correlation_4op``, and ``correlation_ss`` functions have been; removed.; - Support for calculating correlation with ``mcsolve`` has been removed. Propagators (propagator module):. - A class interface, ``qutip.Propagator``, has been added for propagators.; - Propagation of time-dependent systems is now supported using ``QobjEvo``.; - The ``unitary_mode`` and ``parallel`` options have been removed. Correlation spectra (spectrum module):. - The functions ``spectrum_ss`` and ``spectrum_pi`` have been removed and; are now internal functions.; - The ``use_pinv`` parameter for ``spectrum`` has been removed and the; functionality merged into the ``solver`` parameter. Use ``solver=""pi""``; instead. Hierarchical Equation of Motion Solver (HEOM). - Updated the solver to use the new QuTiP integrators and data layer.; - Updated all the HEOM tutorials to QuTiP 5.; - Added support for combining bosonic and fermionic baths.; - Sped up the construction of the RHS of the HEOM solver by a factor of 4x.; - As in QuTiP 4, the HEOM supports arbitrary spectral densities, bosonic and fermionic baths, Pde and Matsubara expansions of the correlation functions, calculating the Matsubara terminator and inspection of the ADOs (auxiliary density operators). QuTiP core; ----------. There have been numerous other small changes to core QuTiP features:. - ``qft(...)`` the function that returns the quantum Fourier; transform operator was moved from ``qutip.qip.algorithm`` into ``qutip``.; - The Bloch-Redfield solver tensor, ``brtensor``, has been moved into; ``qutip.core``. See the section above on the Bloch-Redfield solver; for details.; - The functions ``mat2vec`` and ``vec2mat`` for transforming states to and; from super-operator states have been renamed to ``stack_columns`` and; ",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:25281,Deployability,install,installed,25281," - Removed ``load``. ``reset`` and ``save`` functions.; - Removed ``.debug``, ``.fortran``, ``.openmp_thresh``.; - New ``.compile`` stores the compilation options for compiled coefficients.; - New ``.core[""rtol""]`` core option gives the default relative tolerance used by QuTiP.; - The absolute tolerance setting ``.atol`` has been moved to ``.core[""atol""]``. Visualization; -------------. - Added arguments to ``plot_wigner`` and ``plot_wigner_fock_distribution`` to specify parameters for ``wigner``.; - Removed ``Bloch3D``. The same functionality is provided by ``Bloch``.; - Added ``fig``, ``ax`` and ``cmap`` keyword arguments to all visualization functions.; - Most visualization functions now respect the ``colorblind_safe`` setting.; - Added new functions to create animations from a list of ``Qobj`` or directly from solver results with saved states. Package reorganization; ----------------------. - ``qutip.qip`` has been moved into its own package, qutip-qip. Once installed, qutip-qip is available as either ``qutip.qip`` or ``qutip_qip``. Some widely useful gates have been retained in ``qutip.gates``.; - ``qutip.control`` has been moved to qutip-qtrl and once installed qutip-qtrl is available as either ``qutip.control`` or ``qutip_qtrl``. Note that ``quitp_qtrl`` is provided primarily for backwards compatibility. Improvements to optimal control will take place in the new ``qutip_qoc`` package.; - ``qutip.lattice`` has been moved into its own package, qutip-lattice. It is available from `<https://github.com/qutip/qutip-lattice>`.; - ``qutip.sparse`` has been removed. It contained the old sparse matrix representation and is replaced by the new implementation in ``qutip.data``.; - ``qutip.piqs`` functions are no longer available from the ``qutip`` namespace. They are accessible from ``qutip.piqs`` instead. Miscellaneous; -------------. - Support has been added for 64-bit integer sparse matrix indices, allowing; sparse matrices with up to 2**63 rows and columns. This supp",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:25480,Deployability,install,installed,25480,"efficients.; - New ``.core[""rtol""]`` core option gives the default relative tolerance used by QuTiP.; - The absolute tolerance setting ``.atol`` has been moved to ``.core[""atol""]``. Visualization; -------------. - Added arguments to ``plot_wigner`` and ``plot_wigner_fock_distribution`` to specify parameters for ``wigner``.; - Removed ``Bloch3D``. The same functionality is provided by ``Bloch``.; - Added ``fig``, ``ax`` and ``cmap`` keyword arguments to all visualization functions.; - Most visualization functions now respect the ``colorblind_safe`` setting.; - Added new functions to create animations from a list of ``Qobj`` or directly from solver results with saved states. Package reorganization; ----------------------. - ``qutip.qip`` has been moved into its own package, qutip-qip. Once installed, qutip-qip is available as either ``qutip.qip`` or ``qutip_qip``. Some widely useful gates have been retained in ``qutip.gates``.; - ``qutip.control`` has been moved to qutip-qtrl and once installed qutip-qtrl is available as either ``qutip.control`` or ``qutip_qtrl``. Note that ``quitp_qtrl`` is provided primarily for backwards compatibility. Improvements to optimal control will take place in the new ``qutip_qoc`` package.; - ``qutip.lattice`` has been moved into its own package, qutip-lattice. It is available from `<https://github.com/qutip/qutip-lattice>`.; - ``qutip.sparse`` has been removed. It contained the old sparse matrix representation and is replaced by the new implementation in ``qutip.data``.; - ``qutip.piqs`` functions are no longer available from the ``qutip`` namespace. They are accessible from ``qutip.piqs`` instead. Miscellaneous; -------------. - Support has been added for 64-bit integer sparse matrix indices, allowing; sparse matrices with up to 2**63 rows and columns. This support needs to; be enabled at compilation time by calling ``setup.py`` and passing; ``--with-idxint-64``. Feature removals; ----------------. - Support for OpenMP has been removed.",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:26593,Deployability,release,release,26593," or ``qutip_qtrl``. Note that ``quitp_qtrl`` is provided primarily for backwards compatibility. Improvements to optimal control will take place in the new ``qutip_qoc`` package.; - ``qutip.lattice`` has been moved into its own package, qutip-lattice. It is available from `<https://github.com/qutip/qutip-lattice>`.; - ``qutip.sparse`` has been removed. It contained the old sparse matrix representation and is replaced by the new implementation in ``qutip.data``.; - ``qutip.piqs`` functions are no longer available from the ``qutip`` namespace. They are accessible from ``qutip.piqs`` instead. Miscellaneous; -------------. - Support has been added for 64-bit integer sparse matrix indices, allowing; sparse matrices with up to 2**63 rows and columns. This support needs to; be enabled at compilation time by calling ``setup.py`` and passing; ``--with-idxint-64``. Feature removals; ----------------. - Support for OpenMP has been removed. If there is enough demand and a good plan for how to organize it, OpenMP support may return in a future QuTiP release.; - The ``qutip.parfor`` function has been removed. Use ``qutip.parallel_map`` instead.; - ``qutip.graph`` has been removed and replaced by SciPy's graph functions.; - ``qutip.topology`` has been removed. It contained only one function ``berry_curvature``.; - The ``~/.qutip/qutiprc`` config file is no longer supported. It contained settings for the OpenMP support.; - Deprecate ``three_level_atom``; - Deprecate ``orbital``. Changes from QuTiP 5.0.0b1:; ---------------------------. Features; --------. - Add dtype to printed ouput of qobj (#2352 by Rochisha Agarwal). Miscellaneous; -------------. - Allow scipy 1.12 to be used with qutip. (#2354 by Pieter Eendebak). QuTiP 5.0.0b1 (2024-03-04); ==========================. Features; --------. - Create a Dimension class (#1996); - Add arguments of plot_wigner() and plot_wigner_fock_distribution() to specify parameters for wigner(). (#2057, by Kosuke Mizuno); - Restore feedback to solv",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:32492,Deployability,install,installed,32492,"emovals; --------. - Remove qutip.control and replace with qutip_qtrl. (#2116); - Deleted _solve in countstat.py and used _data.solve. (#2120 by Yuji Tamakoshi); - Deprecate three_level_atom (#2221); - Deprecate orbital (#2223). Documentation; -------------. - Add a guide on Superoperators, Pauli Basis and Channel Contraction. (#1984 by christian512); - Added information on sec_cutoff to the documentation (#2136 by Gerardo Jose Suarez); - Added inherited members to API doc of MESolver, SMESolver, SSESolver, NonMarkovianMCSolver (#2167 by Cristian Emiliano Godinez Ramirez); - Corrected grammar in Bloch-Redfield master equation documentation (#2174 by Andrey Rakhubovsky). Miscellaneous; -------------. - Update scipy version requirement to 1.5+ (#1982 by Pieter Eendebak); - Added __all__ to qutip/measurements.py and qutip/core/semidefinite.py (#2103 by Rushiraj Gadhvi); - Restore towncrier check (#2105); - qutip.ipynbtools.version_table() can now be called without Cython installed (#2110 by Rushiraj Gadhvi); - Moved HTMLProgressBar from qutip/ipynbtools.py to qutip/ui/progressbar.py (#2112 by Harsh Khilawala); - Added new argument bc_type to take boundary conditions when creating QobjEvo (#2114 by Avatar Srinidhi P V ); - Remove Windows build warning suppression. (#2119); - Optimize dispatcher by dispatching on positional only args. (#2135); - Clean semidefinite (#2138); - Migrate `transfertensor.py` to solver (#2142); - Add a test for progress_bar (#2150); - Enable cython 3 (#2151); - Added tests for visualization.py (#2192 by Yuji Tamakoshi); - Sorted arguments of sphereplot so that the order is similar to those of plot_spin_distribution (#2219 by Yuji Tamakoshi). Version 5.0.0a1 (February 7, 2023); ++++++++++++++++++++++++++++++++++. QuTiP 5 is a redesign of many of the core components of QuTiP (``Qobj``,; ``QobjEvo``, solvers) to make them more consistent and more flexible. ``Qobj`` may now be stored in either sparse or dense representations,; and the two may be mix",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:34879,Deployability,update,updated,34879,"ed.; In future, new data layers may provide their own ``Integrators``; specialized to their representation of the underlying data. Much of the user-facing API of QuTiP remains familiar, but there have; had to be many small breaking changes. If we can make changes to; easy migrating code from QuTiP 4 to QuTiP 5, please let us know. Any extensive list of changes follows. Contributors; ------------. QuTiP 5 has been a large effort by many people over the last three years. In particular:. - Jake Lishman led the implementation of the new data layer and coefficients.; - Eric Gigure led the implementation of the new QobjEvo interface and solvers.; - Boxi Li led the updating of QuTiP's QIP support and the creation of ``qutip_qip``. Other members of the QuTiP Admin team have been heavily involved in reviewing,; testing and designing QuTiP 5:. - Alexander Pitchford; - Asier Galicia; - Nathan Shammah; - Shahnawaz Ahmed; - Neill Lambert; - Simon Cross. Two Google Summer of Code contributors updated the tutorials and benchmarks to; QuTiP 5:. - Christian Staufenbiel updated many of the tutorials (`<https://github.com/qutip/qutip-tutorials/>`).; - Xavier Sproken update the benchmarks (`<https://github.com/qutip/qutip-benchmark/>`). Four experimental data layers backends were written either as part of Google Summer; of Code or as separate projects. While these are still alpha quality, the helped; significantly to test the data layer API:. - ``qutip-tensorflow``: a TensorFlow backend by Asier Galicia (`<https://github.com/qutip/qutip-tensorflow>`); - ``qutip-cupy``: a CuPy GPU backend by Felipe Bivort Haiek (`<https://github.com/qutip/qutip-cupy/>`)`; - ``qutip-tensornetwork``: a TensorNetwork backend by Asier Galicia (`<https://github.com/qutip/qutip-tensornetwork>`); - ``qutip-jax``: a JAX backend by Eric Gigure (`<https://github.com/qutip/qutip-jax/>`). We have also had many other contributors, whose specific contributions are; detailed below:. - Pieter Eendebak (updated the re",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:34954,Deployability,update,updated,34954,"d to their representation of the underlying data. Much of the user-facing API of QuTiP remains familiar, but there have; had to be many small breaking changes. If we can make changes to; easy migrating code from QuTiP 4 to QuTiP 5, please let us know. Any extensive list of changes follows. Contributors; ------------. QuTiP 5 has been a large effort by many people over the last three years. In particular:. - Jake Lishman led the implementation of the new data layer and coefficients.; - Eric Gigure led the implementation of the new QobjEvo interface and solvers.; - Boxi Li led the updating of QuTiP's QIP support and the creation of ``qutip_qip``. Other members of the QuTiP Admin team have been heavily involved in reviewing,; testing and designing QuTiP 5:. - Alexander Pitchford; - Asier Galicia; - Nathan Shammah; - Shahnawaz Ahmed; - Neill Lambert; - Simon Cross. Two Google Summer of Code contributors updated the tutorials and benchmarks to; QuTiP 5:. - Christian Staufenbiel updated many of the tutorials (`<https://github.com/qutip/qutip-tutorials/>`).; - Xavier Sproken update the benchmarks (`<https://github.com/qutip/qutip-benchmark/>`). Four experimental data layers backends were written either as part of Google Summer; of Code or as separate projects. While these are still alpha quality, the helped; significantly to test the data layer API:. - ``qutip-tensorflow``: a TensorFlow backend by Asier Galicia (`<https://github.com/qutip/qutip-tensorflow>`); - ``qutip-cupy``: a CuPy GPU backend by Felipe Bivort Haiek (`<https://github.com/qutip/qutip-cupy/>`)`; - ``qutip-tensornetwork``: a TensorNetwork backend by Asier Galicia (`<https://github.com/qutip/qutip-tensornetwork>`); - ``qutip-jax``: a JAX backend by Eric Gigure (`<https://github.com/qutip/qutip-jax/>`). We have also had many other contributors, whose specific contributions are; detailed below:. - Pieter Eendebak (updated the required SciPy to 1.4+, `#1982 <https://github.com/qutip/qutip/pull/1982>`).; - Piet",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:35051,Deployability,update,update,35051,"amiliar, but there have; had to be many small breaking changes. If we can make changes to; easy migrating code from QuTiP 4 to QuTiP 5, please let us know. Any extensive list of changes follows. Contributors; ------------. QuTiP 5 has been a large effort by many people over the last three years. In particular:. - Jake Lishman led the implementation of the new data layer and coefficients.; - Eric Gigure led the implementation of the new QobjEvo interface and solvers.; - Boxi Li led the updating of QuTiP's QIP support and the creation of ``qutip_qip``. Other members of the QuTiP Admin team have been heavily involved in reviewing,; testing and designing QuTiP 5:. - Alexander Pitchford; - Asier Galicia; - Nathan Shammah; - Shahnawaz Ahmed; - Neill Lambert; - Simon Cross. Two Google Summer of Code contributors updated the tutorials and benchmarks to; QuTiP 5:. - Christian Staufenbiel updated many of the tutorials (`<https://github.com/qutip/qutip-tutorials/>`).; - Xavier Sproken update the benchmarks (`<https://github.com/qutip/qutip-benchmark/>`). Four experimental data layers backends were written either as part of Google Summer; of Code or as separate projects. While these are still alpha quality, the helped; significantly to test the data layer API:. - ``qutip-tensorflow``: a TensorFlow backend by Asier Galicia (`<https://github.com/qutip/qutip-tensorflow>`); - ``qutip-cupy``: a CuPy GPU backend by Felipe Bivort Haiek (`<https://github.com/qutip/qutip-cupy/>`)`; - ``qutip-tensornetwork``: a TensorNetwork backend by Asier Galicia (`<https://github.com/qutip/qutip-tensornetwork>`); - ``qutip-jax``: a JAX backend by Eric Gigure (`<https://github.com/qutip/qutip-jax/>`). We have also had many other contributors, whose specific contributions are; detailed below:. - Pieter Eendebak (updated the required SciPy to 1.4+, `#1982 <https://github.com/qutip/qutip/pull/1982>`).; - Pieter Eendebak (reduced import times by setting logger names, `#1981 <https://github.com/qutip/quti",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:35870,Deployability,update,updated,35870,"rs updated the tutorials and benchmarks to; QuTiP 5:. - Christian Staufenbiel updated many of the tutorials (`<https://github.com/qutip/qutip-tutorials/>`).; - Xavier Sproken update the benchmarks (`<https://github.com/qutip/qutip-benchmark/>`). Four experimental data layers backends were written either as part of Google Summer; of Code or as separate projects. While these are still alpha quality, the helped; significantly to test the data layer API:. - ``qutip-tensorflow``: a TensorFlow backend by Asier Galicia (`<https://github.com/qutip/qutip-tensorflow>`); - ``qutip-cupy``: a CuPy GPU backend by Felipe Bivort Haiek (`<https://github.com/qutip/qutip-cupy/>`)`; - ``qutip-tensornetwork``: a TensorNetwork backend by Asier Galicia (`<https://github.com/qutip/qutip-tensornetwork>`); - ``qutip-jax``: a JAX backend by Eric Gigure (`<https://github.com/qutip/qutip-jax/>`). We have also had many other contributors, whose specific contributions are; detailed below:. - Pieter Eendebak (updated the required SciPy to 1.4+, `#1982 <https://github.com/qutip/qutip/pull/1982>`).; - Pieter Eendebak (reduced import times by setting logger names, `#1981 <https://github.com/qutip/qutip/pull/1981>`); - Xavier Sproken (included C header files in the source distribution, `#1971 <https://github.com/qutip/qutip/pull/1971>`); - Christian Staufenbiel (added support for multiple collapse operators to the Floquet solver, `#1962 <https://github.com/qutip/qutip/pull/1962>`); - Christian Staufenbiel (fixed the basis used in the Floquet Master Equation solver, `#1952 <https://github.com/qutip/qutip/pull/1952>`); - Christian Staufenbiel (allowed the ``bloch_redfield_tensor`` function to accept strings and callables for `a_ops`, `#1951 <https://github.com/qutip/qutip/pull/1951>`); - Henrique Silvro (allowed ``qutip_qip`` to be imported as ``qutip.qip``, `#1920 <https://github.com/qutip/qutip/pull/1920>`); - Florian Hopfmueller (added a vastly improved implementations of ``process_fidelity`` and `",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:40105,Deployability,update,updated,40105,"g time-dependent quantum objects has been; significantly expanded, standardized and extended. The time-dependent; coefficients are now represented using a new ``Coefficient`` type that; may be independently created and manipulated if required. Some highlights:. - The ``.compile()`` method has been removed. Coefficients specified as; strings are automatically compiled if possible and the compilation is; cached across different Python runs and instances.; - Mixing coefficient types within a single ``Qobj`` is now supported.; - Many new attributes were added to ``QobjEvo`` for convenience. Examples; include ``.dims``, ``.shape``, ``.superrep`` and ``.isconstant``.; - Many old attributes such as ``.cte``, ``.use_cython``, ``.type``, ``.const``,; and ``.coeff_file`` were removed.; - A new ``Spline`` coefficient supports spline interpolations of different; orders. The old ``Cubic_Spline`` coefficient has been removed.; - The new ``.arguments(...)`` method allows additional arguments to the; underlying coefficient functions to be updated.; - The ``_step_func_coeff`` argument has been replaced by the ``order``; parameter. ``_step_func_coeff=False`` is equivalent to ``order=3``.; ``_step_func_coeff=True`` is equivalent to ``order=0``. Higher values; of ``order`` gives spline interpolations of higher orders. Solver changes; --------------. The solvers in QuTiP have been heavily reworked and standardized.; Under the hood solvers now make use of swappable ODE ``Integrators``.; Many ``Integrators`` are included (see the list below) and; custom implementations are possible. Solvers now consistently; accept a ``QobjEvo`` instance at the Hamiltonian or Liouvillian, or; any object which can be passed to the ``QobjEvo`` constructor. A breakdown of highlights follows. All solvers:. - Solver options are now supplied in an ordinary Python dict.; ``qutip.Options`` is deprecated and returns a dict for backwards; compatibility.; - A specific ODE integrator may be selected by supplying a; `",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:41022,Deployability,integrat,integrator,41022,"onal arguments to the; underlying coefficient functions to be updated.; - The ``_step_func_coeff`` argument has been replaced by the ``order``; parameter. ``_step_func_coeff=False`` is equivalent to ``order=3``.; ``_step_func_coeff=True`` is equivalent to ``order=0``. Higher values; of ``order`` gives spline interpolations of higher orders. Solver changes; --------------. The solvers in QuTiP have been heavily reworked and standardized.; Under the hood solvers now make use of swappable ODE ``Integrators``.; Many ``Integrators`` are included (see the list below) and; custom implementations are possible. Solvers now consistently; accept a ``QobjEvo`` instance at the Hamiltonian or Liouvillian, or; any object which can be passed to the ``QobjEvo`` constructor. A breakdown of highlights follows. All solvers:. - Solver options are now supplied in an ordinary Python dict.; ``qutip.Options`` is deprecated and returns a dict for backwards; compatibility.; - A specific ODE integrator may be selected by supplying a; ``method`` option.; - Each solver provides a class interface. Creating an instance; of the class allows a solver to be run multiple times for the; same system without having to repeatedly reconstruct the; right-hand side of the ODE to be integrated.; - A ``QobjEvo`` instance is accepted for most operators, e.g.,; ``H``, ``c_ops``, ``e_ops``, ``a_ops``.; - The progress bar is now selected using the ``progress_bar`` option.; A new progess bar using the ``tqdm`` Python library is provided.; - Dynamic arguments, where the value of an operator depends on; the current state of the evolution, have been removed. They; may be re-implemented later if there is demand for them. Integrators:. - The SciPy zvode integrator is available with the BDF and; Adams methods as ``bdf`` and ``adams``.; - The SciPy dop853 integrator (an eighth order Runge-Kutta method by; Dormand & Prince) is available as ``dop853``.; - The SciPy lsoda integrator is available as ``lsoda``.; - QuTiP's own ",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:41303,Deployability,integrat,integrated,41303,"se`` is equivalent to ``order=3``.; ``_step_func_coeff=True`` is equivalent to ``order=0``. Higher values; of ``order`` gives spline interpolations of higher orders. Solver changes; --------------. The solvers in QuTiP have been heavily reworked and standardized.; Under the hood solvers now make use of swappable ODE ``Integrators``.; Many ``Integrators`` are included (see the list below) and; custom implementations are possible. Solvers now consistently; accept a ``QobjEvo`` instance at the Hamiltonian or Liouvillian, or; any object which can be passed to the ``QobjEvo`` constructor. A breakdown of highlights follows. All solvers:. - Solver options are now supplied in an ordinary Python dict.; ``qutip.Options`` is deprecated and returns a dict for backwards; compatibility.; - A specific ODE integrator may be selected by supplying a; ``method`` option.; - Each solver provides a class interface. Creating an instance; of the class allows a solver to be run multiple times for the; same system without having to repeatedly reconstruct the; right-hand side of the ODE to be integrated.; - A ``QobjEvo`` instance is accepted for most operators, e.g.,; ``H``, ``c_ops``, ``e_ops``, ``a_ops``.; - The progress bar is now selected using the ``progress_bar`` option.; A new progess bar using the ``tqdm`` Python library is provided.; - Dynamic arguments, where the value of an operator depends on; the current state of the evolution, have been removed. They; may be re-implemented later if there is demand for them. Integrators:. - The SciPy zvode integrator is available with the BDF and; Adams methods as ``bdf`` and ``adams``.; - The SciPy dop853 integrator (an eighth order Runge-Kutta method by; Dormand & Prince) is available as ``dop853``.; - The SciPy lsoda integrator is available as ``lsoda``.; - QuTiP's own implementation of Verner's ""most efficient"" Runge-Kutta methods; of order 7 and 9 are available as ``vern7`` and ``vern9``. See; http://people.math.sfu.ca/~jverner/ for a descri",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:41772,Deployability,integrat,integrator,41772,"ructor. A breakdown of highlights follows. All solvers:. - Solver options are now supplied in an ordinary Python dict.; ``qutip.Options`` is deprecated and returns a dict for backwards; compatibility.; - A specific ODE integrator may be selected by supplying a; ``method`` option.; - Each solver provides a class interface. Creating an instance; of the class allows a solver to be run multiple times for the; same system without having to repeatedly reconstruct the; right-hand side of the ODE to be integrated.; - A ``QobjEvo`` instance is accepted for most operators, e.g.,; ``H``, ``c_ops``, ``e_ops``, ``a_ops``.; - The progress bar is now selected using the ``progress_bar`` option.; A new progess bar using the ``tqdm`` Python library is provided.; - Dynamic arguments, where the value of an operator depends on; the current state of the evolution, have been removed. They; may be re-implemented later if there is demand for them. Integrators:. - The SciPy zvode integrator is available with the BDF and; Adams methods as ``bdf`` and ``adams``.; - The SciPy dop853 integrator (an eighth order Runge-Kutta method by; Dormand & Prince) is available as ``dop853``.; - The SciPy lsoda integrator is available as ``lsoda``.; - QuTiP's own implementation of Verner's ""most efficient"" Runge-Kutta methods; of order 7 and 9 are available as ``vern7`` and ``vern9``. See; http://people.math.sfu.ca/~jverner/ for a description of the methods.; - QuTiP's own implementation of a solver that directly diagonalizes the; the system to be integrated is available as ``diag``. It only works on; time-independent systems and is slow to setup, but once the diagonalization; is complete, it generates solutions very quickly.; - QuTiP's own implementatoin of an approximate Krylov subspace integrator is; available as ``krylov``. This integrator is only usable with ``sesolve``. Result class:. - A new ``.e_data`` attribute provides expectation values as a dictionary.; Unlike ``.expect``, the values are provided ",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:41874,Deployability,integrat,integrator,41874,"thon dict.; ``qutip.Options`` is deprecated and returns a dict for backwards; compatibility.; - A specific ODE integrator may be selected by supplying a; ``method`` option.; - Each solver provides a class interface. Creating an instance; of the class allows a solver to be run multiple times for the; same system without having to repeatedly reconstruct the; right-hand side of the ODE to be integrated.; - A ``QobjEvo`` instance is accepted for most operators, e.g.,; ``H``, ``c_ops``, ``e_ops``, ``a_ops``.; - The progress bar is now selected using the ``progress_bar`` option.; A new progess bar using the ``tqdm`` Python library is provided.; - Dynamic arguments, where the value of an operator depends on; the current state of the evolution, have been removed. They; may be re-implemented later if there is demand for them. Integrators:. - The SciPy zvode integrator is available with the BDF and; Adams methods as ``bdf`` and ``adams``.; - The SciPy dop853 integrator (an eighth order Runge-Kutta method by; Dormand & Prince) is available as ``dop853``.; - The SciPy lsoda integrator is available as ``lsoda``.; - QuTiP's own implementation of Verner's ""most efficient"" Runge-Kutta methods; of order 7 and 9 are available as ``vern7`` and ``vern9``. See; http://people.math.sfu.ca/~jverner/ for a description of the methods.; - QuTiP's own implementation of a solver that directly diagonalizes the; the system to be integrated is available as ``diag``. It only works on; time-independent systems and is slow to setup, but once the diagonalization; is complete, it generates solutions very quickly.; - QuTiP's own implementatoin of an approximate Krylov subspace integrator is; available as ``krylov``. This integrator is only usable with ``sesolve``. Result class:. - A new ``.e_data`` attribute provides expectation values as a dictionary.; Unlike ``.expect``, the values are provided in a Python list rather than; a numpy array, which better supports non-numeric types.; - The contents of the ",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:41990,Deployability,integrat,integrator,41990,"lity.; - A specific ODE integrator may be selected by supplying a; ``method`` option.; - Each solver provides a class interface. Creating an instance; of the class allows a solver to be run multiple times for the; same system without having to repeatedly reconstruct the; right-hand side of the ODE to be integrated.; - A ``QobjEvo`` instance is accepted for most operators, e.g.,; ``H``, ``c_ops``, ``e_ops``, ``a_ops``.; - The progress bar is now selected using the ``progress_bar`` option.; A new progess bar using the ``tqdm`` Python library is provided.; - Dynamic arguments, where the value of an operator depends on; the current state of the evolution, have been removed. They; may be re-implemented later if there is demand for them. Integrators:. - The SciPy zvode integrator is available with the BDF and; Adams methods as ``bdf`` and ``adams``.; - The SciPy dop853 integrator (an eighth order Runge-Kutta method by; Dormand & Prince) is available as ``dop853``.; - The SciPy lsoda integrator is available as ``lsoda``.; - QuTiP's own implementation of Verner's ""most efficient"" Runge-Kutta methods; of order 7 and 9 are available as ``vern7`` and ``vern9``. See; http://people.math.sfu.ca/~jverner/ for a description of the methods.; - QuTiP's own implementation of a solver that directly diagonalizes the; the system to be integrated is available as ``diag``. It only works on; time-independent systems and is slow to setup, but once the diagonalization; is complete, it generates solutions very quickly.; - QuTiP's own implementatoin of an approximate Krylov subspace integrator is; available as ``krylov``. This integrator is only usable with ``sesolve``. Result class:. - A new ``.e_data`` attribute provides expectation values as a dictionary.; Unlike ``.expect``, the values are provided in a Python list rather than; a numpy array, which better supports non-numeric types.; - The contents of the ``.stats`` attribute changed significantly and is; now more consistent across solvers. ",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:42333,Deployability,integrat,integrated,42333,"tegrated.; - A ``QobjEvo`` instance is accepted for most operators, e.g.,; ``H``, ``c_ops``, ``e_ops``, ``a_ops``.; - The progress bar is now selected using the ``progress_bar`` option.; A new progess bar using the ``tqdm`` Python library is provided.; - Dynamic arguments, where the value of an operator depends on; the current state of the evolution, have been removed. They; may be re-implemented later if there is demand for them. Integrators:. - The SciPy zvode integrator is available with the BDF and; Adams methods as ``bdf`` and ``adams``.; - The SciPy dop853 integrator (an eighth order Runge-Kutta method by; Dormand & Prince) is available as ``dop853``.; - The SciPy lsoda integrator is available as ``lsoda``.; - QuTiP's own implementation of Verner's ""most efficient"" Runge-Kutta methods; of order 7 and 9 are available as ``vern7`` and ``vern9``. See; http://people.math.sfu.ca/~jverner/ for a description of the methods.; - QuTiP's own implementation of a solver that directly diagonalizes the; the system to be integrated is available as ``diag``. It only works on; time-independent systems and is slow to setup, but once the diagonalization; is complete, it generates solutions very quickly.; - QuTiP's own implementatoin of an approximate Krylov subspace integrator is; available as ``krylov``. This integrator is only usable with ``sesolve``. Result class:. - A new ``.e_data`` attribute provides expectation values as a dictionary.; Unlike ``.expect``, the values are provided in a Python list rather than; a numpy array, which better supports non-numeric types.; - The contents of the ``.stats`` attribute changed significantly and is; now more consistent across solvers. Monte-Carlo Solver (mcsolve):. - The system, H, may now be a super-operator.; - The ``seed`` parameter now supports supplying numpy ``SeedSequence`` or; ``Generator`` types.; - The new ``timeout`` and ``target_tol`` parameters allow the solver to exit; early if a timeout or target tolerance is reached.; -",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:42579,Deployability,integrat,integrator,42579,"c arguments, where the value of an operator depends on; the current state of the evolution, have been removed. They; may be re-implemented later if there is demand for them. Integrators:. - The SciPy zvode integrator is available with the BDF and; Adams methods as ``bdf`` and ``adams``.; - The SciPy dop853 integrator (an eighth order Runge-Kutta method by; Dormand & Prince) is available as ``dop853``.; - The SciPy lsoda integrator is available as ``lsoda``.; - QuTiP's own implementation of Verner's ""most efficient"" Runge-Kutta methods; of order 7 and 9 are available as ``vern7`` and ``vern9``. See; http://people.math.sfu.ca/~jverner/ for a description of the methods.; - QuTiP's own implementation of a solver that directly diagonalizes the; the system to be integrated is available as ``diag``. It only works on; time-independent systems and is slow to setup, but once the diagonalization; is complete, it generates solutions very quickly.; - QuTiP's own implementatoin of an approximate Krylov subspace integrator is; available as ``krylov``. This integrator is only usable with ``sesolve``. Result class:. - A new ``.e_data`` attribute provides expectation values as a dictionary.; Unlike ``.expect``, the values are provided in a Python list rather than; a numpy array, which better supports non-numeric types.; - The contents of the ``.stats`` attribute changed significantly and is; now more consistent across solvers. Monte-Carlo Solver (mcsolve):. - The system, H, may now be a super-operator.; - The ``seed`` parameter now supports supplying numpy ``SeedSequence`` or; ``Generator`` types.; - The new ``timeout`` and ``target_tol`` parameters allow the solver to exit; early if a timeout or target tolerance is reached.; - The ntraj option no longer supports a list of numbers of trajectories.; Instead, just run the solver multiple times and use the class ``MCSolver``; if setting up the solver uses a significant amount of time.; - The ``map_func`` parameter has been replaced by t",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:42624,Deployability,integrat,integrator,42624," the evolution, have been removed. They; may be re-implemented later if there is demand for them. Integrators:. - The SciPy zvode integrator is available with the BDF and; Adams methods as ``bdf`` and ``adams``.; - The SciPy dop853 integrator (an eighth order Runge-Kutta method by; Dormand & Prince) is available as ``dop853``.; - The SciPy lsoda integrator is available as ``lsoda``.; - QuTiP's own implementation of Verner's ""most efficient"" Runge-Kutta methods; of order 7 and 9 are available as ``vern7`` and ``vern9``. See; http://people.math.sfu.ca/~jverner/ for a description of the methods.; - QuTiP's own implementation of a solver that directly diagonalizes the; the system to be integrated is available as ``diag``. It only works on; time-independent systems and is slow to setup, but once the diagonalization; is complete, it generates solutions very quickly.; - QuTiP's own implementatoin of an approximate Krylov subspace integrator is; available as ``krylov``. This integrator is only usable with ``sesolve``. Result class:. - A new ``.e_data`` attribute provides expectation values as a dictionary.; Unlike ``.expect``, the values are provided in a Python list rather than; a numpy array, which better supports non-numeric types.; - The contents of the ``.stats`` attribute changed significantly and is; now more consistent across solvers. Monte-Carlo Solver (mcsolve):. - The system, H, may now be a super-operator.; - The ``seed`` parameter now supports supplying numpy ``SeedSequence`` or; ``Generator`` types.; - The new ``timeout`` and ``target_tol`` parameters allow the solver to exit; early if a timeout or target tolerance is reached.; - The ntraj option no longer supports a list of numbers of trajectories.; Instead, just run the solver multiple times and use the class ``MCSolver``; if setting up the solver uses a significant amount of time.; - The ``map_func`` parameter has been replaced by the ``map`` option. In; addition to the existing ``serial`` and ``parallel`` v",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:44477,Deployability,integrat,integrator,44477,"`MCSolver``; if setting up the solver uses a significant amount of time.; - The ``map_func`` parameter has been replaced by the ``map`` option. In; addition to the existing ``serial`` and ``parallel`` values, the value; ``loky`` may be supplied to use the loky package to parallelize trajectories.; - The result returned by ``mcsolve`` now supports calculating photocurrents; and calculating the steady state over N trajectories.; - The old ``parfor`` parallel execution function has been removed from; ``qutip.parallel``. Use ``parallel_map`` or ``loky_map`` instead. Bloch-Redfield Master Equation Solver (brmesolve):. - The ``a_ops`` and ``spectra`` support implementaitons been heavily reworked to; reuse the techniques from the new Coefficient and QobjEvo classes.; - The ``use_secular`` parameter has been removed. Use ``sec_cutoff=-1`` instead.; - The required tolerance is now read from ``qutip.settings``. Krylov Subspace Solver (krylovsolve):. - The Krylov solver is now implemented using ``SESolver`` and the ``krylov``; ODE integrator. The function ``krylovsolve`` is maintained for convenience; and now supports many more options.; - The ``sparse`` parameter has been removed. Supply a sparse ``Qobj`` for the; Hamiltonian instead. Floquet Solver (fsesolve and fmmesolve):. - The Floquet solver has been rewritten to use a new ``FloquetBasis`` class; which manages the transformations from lab to Floquet basis and back.; - Many of the internal methods used by the old Floquet solvers have; been removed. The Floquet tensor may still be retried using; the function ``floquet_tensor``.; - The Floquet Markov Master Equation solver has had many changes and; new options added. The environment temperature may be specified using; ``w_th``, and the result states are stored in the lab basis and optionally; in the Floquet basis using ``store_floquet_state``.; - The spectra functions supplied to ``fmmesolve`` must now be vectorized; (i.e. accept and return numpy arrays for frequencies and ",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:45949,Deployability,integrat,integration,45949," tensor may still be retried using; the function ``floquet_tensor``.; - The Floquet Markov Master Equation solver has had many changes and; new options added. The environment temperature may be specified using; ``w_th``, and the result states are stored in the lab basis and optionally; in the Floquet basis using ``store_floquet_state``.; - The spectra functions supplied to ``fmmesolve`` must now be vectorized; (i.e. accept and return numpy arrays for frequencies and densities) and; must accept negative frequence (i.e. usually include a ``w > 0`` factor; so that the returned densities are zero for negative frequencies).; - The number of sidebands to keep, ``kmax`` may only be supplied when using; the ``FMESolver``; - The ``Tsteps`` parameter has been removed from both ``fsesolve`` and; ``fmmesolve``. The ``precompute`` option to ``FloquetBasis`` may be used; instead. Evolution of State Solver (essovle):. - The function ``essolve`` has been removed. Use the ``diag`` integration; method with ``sesolve`` or ``mesolve`` instead. Steady-state solvers (steadystate module):. - The ``method`` parameter and ``solver`` parameters have been separated. Previously; they were mixed together in the ``method`` parameter.; - The previous options are now passed as parameters to the steady state; solver and mostly passed through to the underlying SciPy functions.; - The logging and statistics have been removed. Correlation functions (correlation module):. - A new ``correlation_3op`` function has been added. It supports ``MESolver``; or ``BRMESolver``.; - The ``correlation``, ``correlation_4op``, and ``correlation_ss`` functions have been; removed.; - Support for calculating correlation with ``mcsolve`` has been removed. Propagators (propagator module):. - A class interface, ``qutip.Propagator``, has been added for propagators.; - Propagation of time-dependent systems is now supported using ``QobjEvo``.; - The ``unitary_mode`` and ``parallel`` options have been removed. Correlation spec",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:49799,Deployability,install,installed,49799,"rement operator removed. Used ``expand_operator``; to expand the operator instead.; - ``qutip.Bloch`` now supports applying colours per-point, state or vector in; ``add_point``, ``add_states``, and ``add_vectors``. QuTiP settings; --------------. Previously ``qutip.settings`` was an ordinary module. Now ``qutip.settings`` is; an instance of a settings class. All the runtime modifiable settings for; core operations are in ``qutip.settings.core``. The other settings are not; modifiable at runtime. - Removed ``load``. ``reset`` and ``save`` functions.; - Removed ``.debug``, ``.fortran``, ``.openmp_thresh``.; - New ``.compile`` stores the compilation options for compiled coefficients.; - New ``.core[""rtol""]`` core option gives the default relative tolerance used by QuTiP.; - The absolute tolerance setting ``.atol`` has been moved to ``.core[""atol""]``. Package reorganization; ----------------------. - ``qutip.qip`` has been moved into its own package, qutip-qip. Once installed, qutip-qip is available as either ``qutip.qip`` or ``qutip_qip``. Some widely useful gates have been retained in ``qutip.gates``.; - ``qutip.lattice`` has been moved into its own package, qutip-lattice. It is available from `<https://github.com/qutip/qutip-lattice>`.; - ``qutip.sparse`` has been removed. It contained the old sparse matrix representation and is replaced by the new implementation in ``qutip.data``.; - ``qutip.piqs`` functions are no longer available from the ``qutip`` namespace. They are accessible from ``qutip.piqs`` instead. Miscellaneous; -------------. - Support has been added for 64-bit integer sparse matrix indices, allowing; sparse matrices with up to 2**63 rows and columns. This support needs to; be enabled at compilation time by calling ``setup.py`` and passing; ``--with-idxint-64``. Feature removals; ----------------. - Support for OpenMP has been removed. If there is enough demand and a good plan for how to organize it, OpenMP support may return in a future QuTiP release.;",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:50813,Deployability,release,release,50813,"into its own package, qutip-qip. Once installed, qutip-qip is available as either ``qutip.qip`` or ``qutip_qip``. Some widely useful gates have been retained in ``qutip.gates``.; - ``qutip.lattice`` has been moved into its own package, qutip-lattice. It is available from `<https://github.com/qutip/qutip-lattice>`.; - ``qutip.sparse`` has been removed. It contained the old sparse matrix representation and is replaced by the new implementation in ``qutip.data``.; - ``qutip.piqs`` functions are no longer available from the ``qutip`` namespace. They are accessible from ``qutip.piqs`` instead. Miscellaneous; -------------. - Support has been added for 64-bit integer sparse matrix indices, allowing; sparse matrices with up to 2**63 rows and columns. This support needs to; be enabled at compilation time by calling ``setup.py`` and passing; ``--with-idxint-64``. Feature removals; ----------------. - Support for OpenMP has been removed. If there is enough demand and a good plan for how to organize it, OpenMP support may return in a future QuTiP release.; - The ``qutip.parfor`` function has been removed. Use ``qutip.parallel_map`` instead.; - ``qutip.graph`` has been removed and replaced by SciPy's graph functions.; - ``qutip.topology`` has been removed. It contained only one function ``berry_curvature``.; - The ``~/.qutip/qutiprc`` config file is no longer supported. It contained settings for the OpenMP support. QuTiP 4.7.5 (2024-01-29); ========================. Patch release for QuTiP 4.7. It adds support for SciPy 1.12. Bug Fixes; ---------. - Remove use of scipy.<numpy-func> in parallel.py, incompatible with scipy==1.12 (#2305 by Evan McKinney). QuTiP 4.7.4 (2024-01-15); ========================. Bug Fixes; ---------. - Adapt to deprecation from matplotlib 3.8 (#2243, reported by Bogdan Reznychenko); - Fix name of temp files for removal after use. (#2251, reported by Qile Su); - Avoid integer overflow in Qobj creation. (#2252, reported by KianHwee-Lim); - Ignore Deprecati",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:51246,Deployability,release,release,51246,"s are no longer available from the ``qutip`` namespace. They are accessible from ``qutip.piqs`` instead. Miscellaneous; -------------. - Support has been added for 64-bit integer sparse matrix indices, allowing; sparse matrices with up to 2**63 rows and columns. This support needs to; be enabled at compilation time by calling ``setup.py`` and passing; ``--with-idxint-64``. Feature removals; ----------------. - Support for OpenMP has been removed. If there is enough demand and a good plan for how to organize it, OpenMP support may return in a future QuTiP release.; - The ``qutip.parfor`` function has been removed. Use ``qutip.parallel_map`` instead.; - ``qutip.graph`` has been removed and replaced by SciPy's graph functions.; - ``qutip.topology`` has been removed. It contained only one function ``berry_curvature``.; - The ``~/.qutip/qutiprc`` config file is no longer supported. It contained settings for the OpenMP support. QuTiP 4.7.5 (2024-01-29); ========================. Patch release for QuTiP 4.7. It adds support for SciPy 1.12. Bug Fixes; ---------. - Remove use of scipy.<numpy-func> in parallel.py, incompatible with scipy==1.12 (#2305 by Evan McKinney). QuTiP 4.7.4 (2024-01-15); ========================. Bug Fixes; ---------. - Adapt to deprecation from matplotlib 3.8 (#2243, reported by Bogdan Reznychenko); - Fix name of temp files for removal after use. (#2251, reported by Qile Su); - Avoid integer overflow in Qobj creation. (#2252, reported by KianHwee-Lim); - Ignore DeprecationWarning from pyximport (#2287); - Add partial support and tests for python 3.12. (#2294). Miscellaneous; -------------. - Rework `choi_to_kraus`, making it rely on an eigenstates solver that can choose `eigh` if the Choi matrix is Hermitian, as it is more numerically stable. (#2276, by Bogdan Reznychenko); - Rework `kraus_to_choi`, making it faster (#2283, by Bogdan Reznychenko and Rafael Haenel). QuTiP 4.7.3 (2023-08-22); ========================. Bug Fixes; ---------. - Non-oper qob",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:52776,Deployability,release,release,52776,"pyximport (#2287); - Add partial support and tests for python 3.12. (#2294). Miscellaneous; -------------. - Rework `choi_to_kraus`, making it rely on an eigenstates solver that can choose `eigh` if the Choi matrix is Hermitian, as it is more numerically stable. (#2276, by Bogdan Reznychenko); - Rework `kraus_to_choi`, making it faster (#2283, by Bogdan Reznychenko and Rafael Haenel). QuTiP 4.7.3 (2023-08-22); ========================. Bug Fixes; ---------. - Non-oper qobj + scalar raise an error. (#2208 reported by vikramkashyap); - Fixed issue where `extract_states` did not preserve hermiticity.; Fixed issue where `rand_herm` did not set the private attribute _isherm to True. (#2214 by AGaliciaMartinez); - ssesolve average states to density matrices (#2216 reported by BenjaminDAnjou). Miscellaneous; -------------. - Exclude cython 3.0.0 from requirement (#2204); - Run in no cython mode with cython >=3.0.0 (#2207). QuTiP 4.7.2 (2023-06-28); ========================. This is a bugfix release for QuTiP 4.7.X. It adds support for; numpy 1.25 and scipy 1.11. Bug Fixes; ---------; - Fix setting of sso.m_ops in heterodyne smesolver and passing through of sc_ops to photocurrent solver. (#2081 by Bogdan Reznychenko and Simon Cross); - Update calls to SciPy eigvalsh and eigsh to pass the range of eigenvalues to return using ``subset_by_index=``. (#2081 by Simon Cross); - Fixed bug where some matrices were wrongly found to be hermitian. (#2082 by AGaliciaMartinez). Miscellaneous; -------------; - Fixed typo in stochastic.py (#2049, by eltociear); - `ptrace` always return density matrix (#2185, issue by udevd); - `mesolve` can support mixed callable and Qobj for `e_ops` (#2184 issue by balopat). Version 4.7.1 (December 11, 2022); +++++++++++++++++++++++++++++++++. This is a bugfix release for QuTiP 4.7.X. In addition to the minor fixes; listed below, the release adds builds for Python 3.11 and support for; packaging 22.0. Features; --------; - Improve qutip import times by se",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:53579,Deployability,release,release,53579,"llaneous; -------------. - Exclude cython 3.0.0 from requirement (#2204); - Run in no cython mode with cython >=3.0.0 (#2207). QuTiP 4.7.2 (2023-06-28); ========================. This is a bugfix release for QuTiP 4.7.X. It adds support for; numpy 1.25 and scipy 1.11. Bug Fixes; ---------; - Fix setting of sso.m_ops in heterodyne smesolver and passing through of sc_ops to photocurrent solver. (#2081 by Bogdan Reznychenko and Simon Cross); - Update calls to SciPy eigvalsh and eigsh to pass the range of eigenvalues to return using ``subset_by_index=``. (#2081 by Simon Cross); - Fixed bug where some matrices were wrongly found to be hermitian. (#2082 by AGaliciaMartinez). Miscellaneous; -------------; - Fixed typo in stochastic.py (#2049, by eltociear); - `ptrace` always return density matrix (#2185, issue by udevd); - `mesolve` can support mixed callable and Qobj for `e_ops` (#2184 issue by balopat). Version 4.7.1 (December 11, 2022); +++++++++++++++++++++++++++++++++. This is a bugfix release for QuTiP 4.7.X. In addition to the minor fixes; listed below, the release adds builds for Python 3.11 and support for; packaging 22.0. Features; --------; - Improve qutip import times by setting logger names explicitly. (#1980). Bug Fixes; ---------; - Change floquet_master_equation_rates(...) to use an adaptive number of time steps scaled by the number of sidebands, kmax. (#1961); - Change fidelity(A, B) to use the reduced fidelity formula for pure states which is more numerically efficient and accurate. (#1964); - Change ``brmesolve`` to raise an exception when ode integration is not successful. (#1965); - Backport fix for IPython helper Bloch._repr_svg_ from dev.major. Previously the print_figure function returned bytes, but since ipython/ipython#5452 (in 2014) it returns a Unicode string. This fix updates QuTiP's helper to match. (#1970); - Fix correlation for case where only the collapse operators are time dependent. (#1979); - Fix the hinton visualization method to plot t",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:53654,Deployability,release,release,53654,"(#2204); - Run in no cython mode with cython >=3.0.0 (#2207). QuTiP 4.7.2 (2023-06-28); ========================. This is a bugfix release for QuTiP 4.7.X. It adds support for; numpy 1.25 and scipy 1.11. Bug Fixes; ---------; - Fix setting of sso.m_ops in heterodyne smesolver and passing through of sc_ops to photocurrent solver. (#2081 by Bogdan Reznychenko and Simon Cross); - Update calls to SciPy eigvalsh and eigsh to pass the range of eigenvalues to return using ``subset_by_index=``. (#2081 by Simon Cross); - Fixed bug where some matrices were wrongly found to be hermitian. (#2082 by AGaliciaMartinez). Miscellaneous; -------------; - Fixed typo in stochastic.py (#2049, by eltociear); - `ptrace` always return density matrix (#2185, issue by udevd); - `mesolve` can support mixed callable and Qobj for `e_ops` (#2184 issue by balopat). Version 4.7.1 (December 11, 2022); +++++++++++++++++++++++++++++++++. This is a bugfix release for QuTiP 4.7.X. In addition to the minor fixes; listed below, the release adds builds for Python 3.11 and support for; packaging 22.0. Features; --------; - Improve qutip import times by setting logger names explicitly. (#1980). Bug Fixes; ---------; - Change floquet_master_equation_rates(...) to use an adaptive number of time steps scaled by the number of sidebands, kmax. (#1961); - Change fidelity(A, B) to use the reduced fidelity formula for pure states which is more numerically efficient and accurate. (#1964); - Change ``brmesolve`` to raise an exception when ode integration is not successful. (#1965); - Backport fix for IPython helper Bloch._repr_svg_ from dev.major. Previously the print_figure function returned bytes, but since ipython/ipython#5452 (in 2014) it returns a Unicode string. This fix updates QuTiP's helper to match. (#1970); - Fix correlation for case where only the collapse operators are time dependent. (#1979); - Fix the hinton visualization method to plot the matrix instead of its transpose. (#2011); - Fix the hinton vis",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:54162,Deployability,integrat,integration,54162,"y Simon Cross); - Fixed bug where some matrices were wrongly found to be hermitian. (#2082 by AGaliciaMartinez). Miscellaneous; -------------; - Fixed typo in stochastic.py (#2049, by eltociear); - `ptrace` always return density matrix (#2185, issue by udevd); - `mesolve` can support mixed callable and Qobj for `e_ops` (#2184 issue by balopat). Version 4.7.1 (December 11, 2022); +++++++++++++++++++++++++++++++++. This is a bugfix release for QuTiP 4.7.X. In addition to the minor fixes; listed below, the release adds builds for Python 3.11 and support for; packaging 22.0. Features; --------; - Improve qutip import times by setting logger names explicitly. (#1980). Bug Fixes; ---------; - Change floquet_master_equation_rates(...) to use an adaptive number of time steps scaled by the number of sidebands, kmax. (#1961); - Change fidelity(A, B) to use the reduced fidelity formula for pure states which is more numerically efficient and accurate. (#1964); - Change ``brmesolve`` to raise an exception when ode integration is not successful. (#1965); - Backport fix for IPython helper Bloch._repr_svg_ from dev.major. Previously the print_figure function returned bytes, but since ipython/ipython#5452 (in 2014) it returns a Unicode string. This fix updates QuTiP's helper to match. (#1970); - Fix correlation for case where only the collapse operators are time dependent. (#1979); - Fix the hinton visualization method to plot the matrix instead of its transpose. (#2011); - Fix the hinton visualization method to take into account all the matrix coefficients to set the squares scale, instead of only the diagonal coefficients. (#2012); - Fix parsing of package versions in setup.py to support packaging 22.0. (#2037); - Add back .qu suffix to objects saved with qsave and loaded with qload. The suffix was accidentally removed in QuTiP 4.7.0. (#2038); - Add a default max_step to processors. (#2040). Documentation; -------------; - Add towncrier for managing the changelog. (#1927); - Updat",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:54401,Deployability,update,updates,54401,"olve` can support mixed callable and Qobj for `e_ops` (#2184 issue by balopat). Version 4.7.1 (December 11, 2022); +++++++++++++++++++++++++++++++++. This is a bugfix release for QuTiP 4.7.X. In addition to the minor fixes; listed below, the release adds builds for Python 3.11 and support for; packaging 22.0. Features; --------; - Improve qutip import times by setting logger names explicitly. (#1980). Bug Fixes; ---------; - Change floquet_master_equation_rates(...) to use an adaptive number of time steps scaled by the number of sidebands, kmax. (#1961); - Change fidelity(A, B) to use the reduced fidelity formula for pure states which is more numerically efficient and accurate. (#1964); - Change ``brmesolve`` to raise an exception when ode integration is not successful. (#1965); - Backport fix for IPython helper Bloch._repr_svg_ from dev.major. Previously the print_figure function returned bytes, but since ipython/ipython#5452 (in 2014) it returns a Unicode string. This fix updates QuTiP's helper to match. (#1970); - Fix correlation for case where only the collapse operators are time dependent. (#1979); - Fix the hinton visualization method to plot the matrix instead of its transpose. (#2011); - Fix the hinton visualization method to take into account all the matrix coefficients to set the squares scale, instead of only the diagonal coefficients. (#2012); - Fix parsing of package versions in setup.py to support packaging 22.0. (#2037); - Add back .qu suffix to objects saved with qsave and loaded with qload. The suffix was accidentally removed in QuTiP 4.7.0. (#2038); - Add a default max_step to processors. (#2040). Documentation; -------------; - Add towncrier for managing the changelog. (#1927); - Update the version of numpy used to build documentation to 1.22.0. (#1940); - Clarify returned objects from bloch_redfield_tensor(). (#1950); - Update Floquet Markov solver docs. (#1958); - Update the roadmap and ideas to show completed work as of August 2022. (#1967). Mi",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:55956,Deployability,release,release,55956,"in QuTiP 4.7.0. (#2038); - Add a default max_step to processors. (#2040). Documentation; -------------; - Add towncrier for managing the changelog. (#1927); - Update the version of numpy used to build documentation to 1.22.0. (#1940); - Clarify returned objects from bloch_redfield_tensor(). (#1950); - Update Floquet Markov solver docs. (#1958); - Update the roadmap and ideas to show completed work as of August 2022. (#1967). Miscellaneous; -------------; - Return TypeError instead of Exception for type error in sesolve argument. (#1924); - Add towncrier draft build of changelog to CI tests. (#1946); - Add Python 3.11 to builds. (#2041); - Simplify version parsing by using packaging.version.Version. (#2043); - Update builds to use cibuildwheel 2.11, and to build with manylinux2014 on Python 3.8 and 3.9, since numpy and SciPy no longer support manylinux2010 on those versions of Python. (#2047). Version 4.7.0 (April 13, 2022); ++++++++++++++++++++++++++++++. This release sees the addition of two new solvers -- ``qutip.krylovsolve`` based on the Krylov subspace approximation and ``qutip.nonmarkov.heom`` that reimplements the BoFiN HEOM solver. Bloch sphere rendering gained support for drawing arcs and lines on the sphere, and for setting the transparency of rendered points and vectors, Hinton plots gained support for specifying a coloring style, and matrix histograms gained better default colors and more flexible styling options. Other significant improvements include better scaling of the Floquet solver, support for passing ``Path`` objects when saving and loading files, support for passing callable functions as ``e_ops`` to ``mesolve`` and ``sesolve``, and faster state number enumeration and Husimi Q functions. Import bugfixes include some bugs affecting plotting with matplotlib 3.5 and fixing support for qutrits (and other non-qubit) quantum circuits. The many other small improvements, bug fixes, documentation enhancements, and behind the scenese development changes ",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:57052,Deployability,release,releases,57052,"bspace approximation and ``qutip.nonmarkov.heom`` that reimplements the BoFiN HEOM solver. Bloch sphere rendering gained support for drawing arcs and lines on the sphere, and for setting the transparency of rendered points and vectors, Hinton plots gained support for specifying a coloring style, and matrix histograms gained better default colors and more flexible styling options. Other significant improvements include better scaling of the Floquet solver, support for passing ``Path`` objects when saving and loading files, support for passing callable functions as ``e_ops`` to ``mesolve`` and ``sesolve``, and faster state number enumeration and Husimi Q functions. Import bugfixes include some bugs affecting plotting with matplotlib 3.5 and fixing support for qutrits (and other non-qubit) quantum circuits. The many other small improvements, bug fixes, documentation enhancements, and behind the scenese development changes are included in the list below. QuTiP 4.7.X will be the last series of releases for QuTiP 4. Patch releases will continue for the 4.7.X series but the main development effort will move to QuTiP 5. The many, many contributors who filed issues, submitted or reviewed pull requests, and improved the documentation for this release are listed next to their contributions below. Thank you to all of you. Improvements; ------------; - **MAJOR** Added krylovsolve as a new solver based on krylov subspace approximation. (`#1739 <https://github.com/qutip/qutip/pull/1739>`_ by Emiliano Fortes); - **MAJOR** Imported BoFiN HEOM (https://github.com/tehruhn/bofin/) into QuTiP and replaced the HEOM solver with a compatibility wrapper around BoFiN bosonic solver. (`#1601 <https://github.com/qutip/qutip/pull/1601>`_, `#1726 <https://github.com/qutip/qutip/pull/1726>`_, and `#1724 <https://github.com/qutip/qutip/pull/1724>`_ by Simon Cross, Tarun Raheja and Neill Lambert); - **MAJOR** Added support for plotting lines and arcs on the Bloch sphere. (`#1690 <https://github.com",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:57080,Deployability,release,releases,57080,"om`` that reimplements the BoFiN HEOM solver. Bloch sphere rendering gained support for drawing arcs and lines on the sphere, and for setting the transparency of rendered points and vectors, Hinton plots gained support for specifying a coloring style, and matrix histograms gained better default colors and more flexible styling options. Other significant improvements include better scaling of the Floquet solver, support for passing ``Path`` objects when saving and loading files, support for passing callable functions as ``e_ops`` to ``mesolve`` and ``sesolve``, and faster state number enumeration and Husimi Q functions. Import bugfixes include some bugs affecting plotting with matplotlib 3.5 and fixing support for qutrits (and other non-qubit) quantum circuits. The many other small improvements, bug fixes, documentation enhancements, and behind the scenese development changes are included in the list below. QuTiP 4.7.X will be the last series of releases for QuTiP 4. Patch releases will continue for the 4.7.X series but the main development effort will move to QuTiP 5. The many, many contributors who filed issues, submitted or reviewed pull requests, and improved the documentation for this release are listed next to their contributions below. Thank you to all of you. Improvements; ------------; - **MAJOR** Added krylovsolve as a new solver based on krylov subspace approximation. (`#1739 <https://github.com/qutip/qutip/pull/1739>`_ by Emiliano Fortes); - **MAJOR** Imported BoFiN HEOM (https://github.com/tehruhn/bofin/) into QuTiP and replaced the HEOM solver with a compatibility wrapper around BoFiN bosonic solver. (`#1601 <https://github.com/qutip/qutip/pull/1601>`_, `#1726 <https://github.com/qutip/qutip/pull/1726>`_, and `#1724 <https://github.com/qutip/qutip/pull/1724>`_ by Simon Cross, Tarun Raheja and Neill Lambert); - **MAJOR** Added support for plotting lines and arcs on the Bloch sphere. (`#1690 <https://github.com/qutip/qutip/pull/1690>`_ by Gaurav Saxena, A",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:57301,Deployability,release,release,57301,"oints and vectors, Hinton plots gained support for specifying a coloring style, and matrix histograms gained better default colors and more flexible styling options. Other significant improvements include better scaling of the Floquet solver, support for passing ``Path`` objects when saving and loading files, support for passing callable functions as ``e_ops`` to ``mesolve`` and ``sesolve``, and faster state number enumeration and Husimi Q functions. Import bugfixes include some bugs affecting plotting with matplotlib 3.5 and fixing support for qutrits (and other non-qubit) quantum circuits. The many other small improvements, bug fixes, documentation enhancements, and behind the scenese development changes are included in the list below. QuTiP 4.7.X will be the last series of releases for QuTiP 4. Patch releases will continue for the 4.7.X series but the main development effort will move to QuTiP 5. The many, many contributors who filed issues, submitted or reviewed pull requests, and improved the documentation for this release are listed next to their contributions below. Thank you to all of you. Improvements; ------------; - **MAJOR** Added krylovsolve as a new solver based on krylov subspace approximation. (`#1739 <https://github.com/qutip/qutip/pull/1739>`_ by Emiliano Fortes); - **MAJOR** Imported BoFiN HEOM (https://github.com/tehruhn/bofin/) into QuTiP and replaced the HEOM solver with a compatibility wrapper around BoFiN bosonic solver. (`#1601 <https://github.com/qutip/qutip/pull/1601>`_, `#1726 <https://github.com/qutip/qutip/pull/1726>`_, and `#1724 <https://github.com/qutip/qutip/pull/1724>`_ by Simon Cross, Tarun Raheja and Neill Lambert); - **MAJOR** Added support for plotting lines and arcs on the Bloch sphere. (`#1690 <https://github.com/qutip/qutip/pull/1690>`_ by Gaurav Saxena, Asier Galicia and Simon Cross); - Added transparency parameter to the add_point, add_vector and add_states methods in the Bloch and Bloch3d classes. (`#1837 <https://github.c",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:61238,Deployability,install,installed,61238,"/qutip/pull/1628>`_ by Mahdi Aslani); - Sped up ``state_number_enumerate``, ``state_number_index``, ``state_index_number``, and added some error checking. ``enr_state_dictionaries`` now returns a list for ``idx2state``. (`#1604 <https://github.com/qutip/qutip/pull/1604>`_ by Johannes Feist); - Added new Husimi Q algorithms, improving the speed for density matrices, and giving a near order-of-magnitude improvement when calculating the Q function for many different states, using the new ``qutip.QFunc`` class, instead of the ``qutip.qfunc`` function. (`#934 <https://github.com/qutip/qutip/pull/934>`_ and `#1583 <https://github.com/qutip/qutip/pull/1583>`_ by Daniel Weigand and Jake Lishman); - Updated licence holders with regards to new governance model, and remove extraneous licensing information from source files. (`#1579 <https://github.com/qutip/qutip/pull/1579>`_ by Jake Lishman); - Removed the vendored copy of LaTeX's qcircuit package which is GPL licensed. We now rely on the package being installed by user. It is installed by default with TexLive. (`#1580 <https://github.com/qutip/qutip/pull/1580>`_ by Jake Lishman); - The signatures of rand_ket and rand_ket_haar were changed to allow N (the size of the random ket) to be determined automatically when dims are specified. (`#1509 <https://github.com/qutip/qutip/pull/1509>`_ by Purva Thakre). Bug Fixes; ---------; - Fix circuit index used when plotting circuits with non-reversed states. (`#1847 <https://github.com/qutip/qutip/pull/1847>`_ by Christian Staufenbiel); - Changed implementation of ``qutip.orbital`` to use ``scipy.special.spy_harm`` to remove bugs in angle interpretation. (`#1844 <https://github.com/qutip/qutip/pull/1844>`_ by Christian Staufenbiel); - Fixed ``QobjEvo.tidyup`` to use ``settings.auto_tidyup_atol`` when removing small elements in sparse matrices. (`#1832 <https://github.com/qutip/qutip/pull/1832>`_ by Eric Gigure); - Ensured that tidyup's default tolerance is read from settings at each ca",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:61263,Deployability,install,installed,61263,"p ``state_number_enumerate``, ``state_number_index``, ``state_index_number``, and added some error checking. ``enr_state_dictionaries`` now returns a list for ``idx2state``. (`#1604 <https://github.com/qutip/qutip/pull/1604>`_ by Johannes Feist); - Added new Husimi Q algorithms, improving the speed for density matrices, and giving a near order-of-magnitude improvement when calculating the Q function for many different states, using the new ``qutip.QFunc`` class, instead of the ``qutip.qfunc`` function. (`#934 <https://github.com/qutip/qutip/pull/934>`_ and `#1583 <https://github.com/qutip/qutip/pull/1583>`_ by Daniel Weigand and Jake Lishman); - Updated licence holders with regards to new governance model, and remove extraneous licensing information from source files. (`#1579 <https://github.com/qutip/qutip/pull/1579>`_ by Jake Lishman); - Removed the vendored copy of LaTeX's qcircuit package which is GPL licensed. We now rely on the package being installed by user. It is installed by default with TexLive. (`#1580 <https://github.com/qutip/qutip/pull/1580>`_ by Jake Lishman); - The signatures of rand_ket and rand_ket_haar were changed to allow N (the size of the random ket) to be determined automatically when dims are specified. (`#1509 <https://github.com/qutip/qutip/pull/1509>`_ by Purva Thakre). Bug Fixes; ---------; - Fix circuit index used when plotting circuits with non-reversed states. (`#1847 <https://github.com/qutip/qutip/pull/1847>`_ by Christian Staufenbiel); - Changed implementation of ``qutip.orbital`` to use ``scipy.special.spy_harm`` to remove bugs in angle interpretation. (`#1844 <https://github.com/qutip/qutip/pull/1844>`_ by Christian Staufenbiel); - Fixed ``QobjEvo.tidyup`` to use ``settings.auto_tidyup_atol`` when removing small elements in sparse matrices. (`#1832 <https://github.com/qutip/qutip/pull/1832>`_ by Eric Gigure); - Ensured that tidyup's default tolerance is read from settings at each call. (`#1830 <https://github.com/qutip/qutip/pul",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:65661,Deployability,configurat,configuration,65661,"- Corrected typo in the states and operators guide. (`#1567 <https://github.com/qutip/qutip/pull/1567>`_ by Laurent Ajdnik); - Converted http links to https. (`#1555 <https://github.com/qutip/qutip/pull/1555>`_ by Jake Lishamn). Developer Changes; -----------------; - Add GitHub actions test run on windows-latest. (`#1853 <https://github.com/qutip/qutip/pull/1853>`_ and `#1855 <https://github.com/qutip/qutip/pull/1855>`_ by Simon Cross); - Bumped the version of pillow used to build documentation from 9.0.0 to 9.0.1. (`#1835 <https://github.com/qutip/qutip/pull/1835>`_ by dependabot); - Migrated the ``qutip.superop_reps`` tests to pytest. (`#1825 <https://github.com/qutip/qutip/pull/1825>`_ by Felipe Bivort Haiek); - Migrated the ``qutip.steadystates`` tests to pytest. (`#1679 <https://github.com/qutip/qutip/pull/1679>`_ by Eric Gigure); - Changed the README.md CI badge to the GitHub Actions badge. (`#1581 <https://github.com/qutip/qutip/pull/1581>`_ by Jake Lishman); - Updated CodeClimate configuration to treat our Python source files as Python 3. (`#1577 <https://github.com/qutip/qutip/pull/1577>`_ by Jake Lishman); - Reduced cyclomatic complexity in ``qutip._mkl``. (`#1576 <https://github.com/qutip/qutip/pull/1576>`_ by Jake Lishman); - Fixed PEP8 warnings in ``qutip.control``, ``qutip.mcsolve``, ``qutip.random_objects``, and ``qutip.stochastic``. (`#1575 <https://github.com/qutip/qutip/pull/1575>`_ by Jake Lishman); - Bumped the version of urllib3 used to build documentation from 1.26.4 to 1.26.5. (`#1563 <https://github.com/qutip/qutip/pull/1563>`_ by dependabot); - Moved tests to GitHub Actions. (`#1551 <https://github.com/qutip/qutip/pull/1551>`_ by Jake Lishman); - The GitHub contributing guidelines were re-added and updated to point to the more complete guidelines in the documentation. (`#1549 <https://github.com/qutip/qutip/pull/1549>`_ by Jake Lishman); - The release documentation was reworked after the initial 4.6.1 to match the actual release process. (",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:66411,Deployability,update,updated,66411,"``qutip.steadystates`` tests to pytest. (`#1679 <https://github.com/qutip/qutip/pull/1679>`_ by Eric Gigure); - Changed the README.md CI badge to the GitHub Actions badge. (`#1581 <https://github.com/qutip/qutip/pull/1581>`_ by Jake Lishman); - Updated CodeClimate configuration to treat our Python source files as Python 3. (`#1577 <https://github.com/qutip/qutip/pull/1577>`_ by Jake Lishman); - Reduced cyclomatic complexity in ``qutip._mkl``. (`#1576 <https://github.com/qutip/qutip/pull/1576>`_ by Jake Lishman); - Fixed PEP8 warnings in ``qutip.control``, ``qutip.mcsolve``, ``qutip.random_objects``, and ``qutip.stochastic``. (`#1575 <https://github.com/qutip/qutip/pull/1575>`_ by Jake Lishman); - Bumped the version of urllib3 used to build documentation from 1.26.4 to 1.26.5. (`#1563 <https://github.com/qutip/qutip/pull/1563>`_ by dependabot); - Moved tests to GitHub Actions. (`#1551 <https://github.com/qutip/qutip/pull/1551>`_ by Jake Lishman); - The GitHub contributing guidelines were re-added and updated to point to the more complete guidelines in the documentation. (`#1549 <https://github.com/qutip/qutip/pull/1549>`_ by Jake Lishman); - The release documentation was reworked after the initial 4.6.1 to match the actual release process. (`#1544 <https://github.com/qutip/qutip/pull/1544>`_ by Jake Lishman). Version 4.6.3 (February 9, 2022); ++++++++++++++++++++++++++++++++. This minor release adds support for numpy 1.22 and Python 3.10 and removes some blockers for running QuTiP on the Apple M1. The performance of the ``enr_destroy``, ``state_number_enumerate`` and ``hadamard_transform`` functions was drastically improved (up to 70x or 200x faster in some common cases), and support for the drift Hamiltonian was added to the ``qutip.qip`` ``Processor``. The ``qutip.hardware_info`` module was removed as part of adding support for the Apple M1. We hope the removal of this little-used module does not adversely affect many users -- it was largely unrelated to QuTiP's c",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:66559,Deployability,release,release,66559," badge. (`#1581 <https://github.com/qutip/qutip/pull/1581>`_ by Jake Lishman); - Updated CodeClimate configuration to treat our Python source files as Python 3. (`#1577 <https://github.com/qutip/qutip/pull/1577>`_ by Jake Lishman); - Reduced cyclomatic complexity in ``qutip._mkl``. (`#1576 <https://github.com/qutip/qutip/pull/1576>`_ by Jake Lishman); - Fixed PEP8 warnings in ``qutip.control``, ``qutip.mcsolve``, ``qutip.random_objects``, and ``qutip.stochastic``. (`#1575 <https://github.com/qutip/qutip/pull/1575>`_ by Jake Lishman); - Bumped the version of urllib3 used to build documentation from 1.26.4 to 1.26.5. (`#1563 <https://github.com/qutip/qutip/pull/1563>`_ by dependabot); - Moved tests to GitHub Actions. (`#1551 <https://github.com/qutip/qutip/pull/1551>`_ by Jake Lishman); - The GitHub contributing guidelines were re-added and updated to point to the more complete guidelines in the documentation. (`#1549 <https://github.com/qutip/qutip/pull/1549>`_ by Jake Lishman); - The release documentation was reworked after the initial 4.6.1 to match the actual release process. (`#1544 <https://github.com/qutip/qutip/pull/1544>`_ by Jake Lishman). Version 4.6.3 (February 9, 2022); ++++++++++++++++++++++++++++++++. This minor release adds support for numpy 1.22 and Python 3.10 and removes some blockers for running QuTiP on the Apple M1. The performance of the ``enr_destroy``, ``state_number_enumerate`` and ``hadamard_transform`` functions was drastically improved (up to 70x or 200x faster in some common cases), and support for the drift Hamiltonian was added to the ``qutip.qip`` ``Processor``. The ``qutip.hardware_info`` module was removed as part of adding support for the Apple M1. We hope the removal of this little-used module does not adversely affect many users -- it was largely unrelated to QuTiP's core functionality and its presence was a continual source of blockers to importing ``qutip`` on new or changed platforms. A new check on the dimensions of ``Qobj``'s",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:66638,Deployability,release,release,66638,"n); - Updated CodeClimate configuration to treat our Python source files as Python 3. (`#1577 <https://github.com/qutip/qutip/pull/1577>`_ by Jake Lishman); - Reduced cyclomatic complexity in ``qutip._mkl``. (`#1576 <https://github.com/qutip/qutip/pull/1576>`_ by Jake Lishman); - Fixed PEP8 warnings in ``qutip.control``, ``qutip.mcsolve``, ``qutip.random_objects``, and ``qutip.stochastic``. (`#1575 <https://github.com/qutip/qutip/pull/1575>`_ by Jake Lishman); - Bumped the version of urllib3 used to build documentation from 1.26.4 to 1.26.5. (`#1563 <https://github.com/qutip/qutip/pull/1563>`_ by dependabot); - Moved tests to GitHub Actions. (`#1551 <https://github.com/qutip/qutip/pull/1551>`_ by Jake Lishman); - The GitHub contributing guidelines were re-added and updated to point to the more complete guidelines in the documentation. (`#1549 <https://github.com/qutip/qutip/pull/1549>`_ by Jake Lishman); - The release documentation was reworked after the initial 4.6.1 to match the actual release process. (`#1544 <https://github.com/qutip/qutip/pull/1544>`_ by Jake Lishman). Version 4.6.3 (February 9, 2022); ++++++++++++++++++++++++++++++++. This minor release adds support for numpy 1.22 and Python 3.10 and removes some blockers for running QuTiP on the Apple M1. The performance of the ``enr_destroy``, ``state_number_enumerate`` and ``hadamard_transform`` functions was drastically improved (up to 70x or 200x faster in some common cases), and support for the drift Hamiltonian was added to the ``qutip.qip`` ``Processor``. The ``qutip.hardware_info`` module was removed as part of adding support for the Apple M1. We hope the removal of this little-used module does not adversely affect many users -- it was largely unrelated to QuTiP's core functionality and its presence was a continual source of blockers to importing ``qutip`` on new or changed platforms. A new check on the dimensions of ``Qobj``'s were added to prevent segmentation faults when invalid shape and dimension",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:66805,Deployability,release,release,66805,"mplexity in ``qutip._mkl``. (`#1576 <https://github.com/qutip/qutip/pull/1576>`_ by Jake Lishman); - Fixed PEP8 warnings in ``qutip.control``, ``qutip.mcsolve``, ``qutip.random_objects``, and ``qutip.stochastic``. (`#1575 <https://github.com/qutip/qutip/pull/1575>`_ by Jake Lishman); - Bumped the version of urllib3 used to build documentation from 1.26.4 to 1.26.5. (`#1563 <https://github.com/qutip/qutip/pull/1563>`_ by dependabot); - Moved tests to GitHub Actions. (`#1551 <https://github.com/qutip/qutip/pull/1551>`_ by Jake Lishman); - The GitHub contributing guidelines were re-added and updated to point to the more complete guidelines in the documentation. (`#1549 <https://github.com/qutip/qutip/pull/1549>`_ by Jake Lishman); - The release documentation was reworked after the initial 4.6.1 to match the actual release process. (`#1544 <https://github.com/qutip/qutip/pull/1544>`_ by Jake Lishman). Version 4.6.3 (February 9, 2022); ++++++++++++++++++++++++++++++++. This minor release adds support for numpy 1.22 and Python 3.10 and removes some blockers for running QuTiP on the Apple M1. The performance of the ``enr_destroy``, ``state_number_enumerate`` and ``hadamard_transform`` functions was drastically improved (up to 70x or 200x faster in some common cases), and support for the drift Hamiltonian was added to the ``qutip.qip`` ``Processor``. The ``qutip.hardware_info`` module was removed as part of adding support for the Apple M1. We hope the removal of this little-used module does not adversely affect many users -- it was largely unrelated to QuTiP's core functionality and its presence was a continual source of blockers to importing ``qutip`` on new or changed platforms. A new check on the dimensions of ``Qobj``'s were added to prevent segmentation faults when invalid shape and dimension combinations were passed to Cython code. In addition, there were many small bugfixes, documentation improvements, and improvements to our building and testing processes. Improvemen",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:68693,Deployability,release,released,68693,"ition, there were many small bugfixes, documentation improvements, and improvements to our building and testing processes. Improvements; ------------; - The ``enr_destroy`` function was made ~200x faster in many simple cases. (`#1593 <https://github.com/qutip/qutip/pull/1593>`_ by Johannes Feist); - The ``state_number_enumerate`` function was made significantly faster. (`#1594 <https://github.com/qutip/qutip/pull/1594>`_ by Johannes Feist); - Added the missing drift Hamiltonian to the method run_analytically of ``Processor``. (`#1603 <https://github.com/qutip/qutip/pull/1603>`_ Boxi Li); - The ``hadamard_transform`` was made much faster, e.g., ~70x faster for N=10. (`#1688 <https://github.com/qutip/qutip/pull/1688>`_ by Asier Galicia); - Added support for computing the power of a scalar-like Qobj. (`#1692 <https://github.com/qutip/qutip/pull/1692>`_ by Asier Galicia); - Removed the ``hardware_info`` module. This module wasn't used inside QuTiP and regularly broke when new operating systems were released, and in particular prevented importing QuTiP on the Apple M1. (`#1754 <https://github.com/qutip/qutip/pull/1754>`_, `#1758 <https://github.com/qutip/qutip/pull/1758>`_ by Eric Gigure). Bug Fixes; ---------; - Fixed support for calculating the propagator of a density matrix with collapse operators. QuTiP 4.6.2 introduced extra sanity checks on the dimensions of inputs to mesolve (Fix mesolve segfault with bad initial state `#1459 <https://github.com/qutip/qutip/pull/1459>`_), but the propagator function's calls to mesolve violated these checks by supplying initial states with the dimensions incorrectly set. ``propagator`` now calls mesolve with the correct dimensions set on the initial state. (`#1588 <https://github.com/qutip/qutip/pull/1588>`_ by Simon Cross); - Fixed support for calculating the propagator for a superoperator without collapse operators. This functionality was not tested by the test suite and appears to have broken sometime during 2019. Tests have no",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:71034,Deployability,configurat,configuration,71034,"ze_pulse support for sparse eigenvector decomposition with the Qobj oper_dtype (the Qobj oper_dtype is the default for large systems). (`#1621 <https://github.com/qutip/qutip/pull/1621>`_ by Simon Cross); - Removed qutip.control.optimize_pulse support for scipy.sparse.csr_matrix and generic ndarray-like matrices. Support for these was non-functional. (`#1621 <https://github.com/qutip/qutip/pull/1621>`_ by Simon Cross); - Fixed errors in the calculation of the Husimi spin_q_function and spin_wigner functions and added tests for them. (`#1632 <https://github.com/qutip/qutip/pull/1632>`_ by Mark Johnson); - Fixed setting of OpenMP compilation flag on Linux. Previously when compiling the OpenMP functions were compiled without parallelization. (`#1693 <https://github.com/qutip/qutip/pull/1693>`_ by Eric Gigure); - Fixed tracking the state of the Bloch sphere figure and axes to prevent exceptions during rendering. (`#1619 <https://github.com/qutip/qutip/pull/1619>`_ by Simon Cross); - Fixed compatibility with numpy configuration in numpy's 1.22.0 release. (`#1752 <https://github.com/qutip/qutip/pull/1752>`_ by Matthew Treinish); - Added dims checks for e_ops passed to solvers to prevent hanging the calling process when e_ops of the wrong dimensions were passed. (`#1778 <https://github.com/qutip/qutip/pull/1778>`_ by Eric Gigure); - Added a check in Qobj constructor that the respective members of data.shape cannot be larger than what the corresponding dims could contain to prevent a segmentation fault caused by inconsistencies between dims and shapes. (`#1783 <https://github.com/qutip/qutip/pull/1783>`_, `#1785 <https://github.com/qutip/qutip/pull/1785>`_, `#1784 <https://github.com/qutip/qutip/pull/1784>`_ by Lajos Palanki & Eric Gigure). Documentation Improvements; --------------------------; - Added docs for the num_cbits parameter of the QubitCircuit class. (`#1652 <https://github.com/qutip/qutip/pull/1652>`_ by Jon Crall); - Fixed the parameters in the call to fses",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:71066,Deployability,release,release,71066,"e Qobj oper_dtype (the Qobj oper_dtype is the default for large systems). (`#1621 <https://github.com/qutip/qutip/pull/1621>`_ by Simon Cross); - Removed qutip.control.optimize_pulse support for scipy.sparse.csr_matrix and generic ndarray-like matrices. Support for these was non-functional. (`#1621 <https://github.com/qutip/qutip/pull/1621>`_ by Simon Cross); - Fixed errors in the calculation of the Husimi spin_q_function and spin_wigner functions and added tests for them. (`#1632 <https://github.com/qutip/qutip/pull/1632>`_ by Mark Johnson); - Fixed setting of OpenMP compilation flag on Linux. Previously when compiling the OpenMP functions were compiled without parallelization. (`#1693 <https://github.com/qutip/qutip/pull/1693>`_ by Eric Gigure); - Fixed tracking the state of the Bloch sphere figure and axes to prevent exceptions during rendering. (`#1619 <https://github.com/qutip/qutip/pull/1619>`_ by Simon Cross); - Fixed compatibility with numpy configuration in numpy's 1.22.0 release. (`#1752 <https://github.com/qutip/qutip/pull/1752>`_ by Matthew Treinish); - Added dims checks for e_ops passed to solvers to prevent hanging the calling process when e_ops of the wrong dimensions were passed. (`#1778 <https://github.com/qutip/qutip/pull/1778>`_ by Eric Gigure); - Added a check in Qobj constructor that the respective members of data.shape cannot be larger than what the corresponding dims could contain to prevent a segmentation fault caused by inconsistencies between dims and shapes. (`#1783 <https://github.com/qutip/qutip/pull/1783>`_, `#1785 <https://github.com/qutip/qutip/pull/1785>`_, `#1784 <https://github.com/qutip/qutip/pull/1784>`_ by Lajos Palanki & Eric Gigure). Documentation Improvements; --------------------------; - Added docs for the num_cbits parameter of the QubitCircuit class. (`#1652 <https://github.com/qutip/qutip/pull/1652>`_ by Jon Crall); - Fixed the parameters in the call to fsesolve in the Floquet guide. (`#1675 <https://github.com/qutip/",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:72474,Deployability,install,installation,72474,"ould contain to prevent a segmentation fault caused by inconsistencies between dims and shapes. (`#1783 <https://github.com/qutip/qutip/pull/1783>`_, `#1785 <https://github.com/qutip/qutip/pull/1785>`_, `#1784 <https://github.com/qutip/qutip/pull/1784>`_ by Lajos Palanki & Eric Gigure). Documentation Improvements; --------------------------; - Added docs for the num_cbits parameter of the QubitCircuit class. (`#1652 <https://github.com/qutip/qutip/pull/1652>`_ by Jon Crall); - Fixed the parameters in the call to fsesolve in the Floquet guide. (`#1675 <https://github.com/qutip/qutip/pull/1675>`_ by Simon Cross); - Fixed the description of random number usage in the Monte Carlo solver guide. (`#1677 <https://github.com/qutip/qutip/pull/1677>`_ by Ian Thorvaldson); - Fixed the rendering of equation numbers in the documentation (they now appear on the right as expected, not above the equation). (`#1678 <https://github.com/qutip/qutip/pull/1678>`_ by Simon Cross); - Updated the installation requirements in the documentation to match what is specified in setup.py. (`#1715 <https://github.com/qutip/qutip/pull/1715>`_ by Asier Galicia); - Fixed a typo in the ``chi_to_choi`` documentation. Previously the documentation mixed up chi and choi. (`#1731 <https://github.com/qutip/qutip/pull/1731>`_ by Pontus Wiksthl); - Improved the documentation for the stochastic equation solvers. Added links to notebooks with examples, API doumentation and external references. (`#1743 <https://github.com/qutip/qutip/pull/1743>`_ by Leonardo Assis); - Fixed a typo in ``qutip.settings`` in the settings guide. (`#1786 <https://github.com/qutip/qutip/pull/1786>`_ by Mahdi Aslani); - Made numerous small improvements to the text of the QuTiP basics guide. (`#1768 <https://github.com/qutip/qutip/pull/1768>`_ by Anna Naden); - Made a small phrasing improvement to the README. (`#1790 <https://github.com/qutip/qutip/pull/1790>`_ by Rita Abani). Developer Changes; -----------------; - Improved test cover",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:74995,Deployability,install,installed,74995,"ation from 8.2.0 to 9.0.0. (`#1654 <https://github.com/qutip/qutip/pull/1654>`_, `#1760 <https://github.com/qutip/qutip/pull/1760>`_ by dependabot); - Bumped the version of babel used to build documentation from 2.9.0 to 2.9.1. (`#1695 <https://github.com/qutip/qutip/pull/1695>`_ by dependabot); - Bumped the version of numpy used to build documentation from 1.19.5 to 1.21.0. (`#1767 <https://github.com/qutip/qutip/pull/1767>`_ by dependabot); - Bumped the version of ipython used to build documentation from 7.22.0 to 7.31.1. (`#1780 <https://github.com/qutip/qutip/pull/1780>`_ by dependabot); - Rename qutip.bib to CITATION.bib to enable GitHub's citation support. (`#1662 <https://github.com/qutip/qutip/pull/1662>`_ by Ashish Panigrahi); - Added tests for simdiags. (`#1681 <https://github.com/qutip/qutip/pull/1681>`_ by Eric Gigure); - Added support for specifying the numpy version in the CI test matrix. (`#1696 <https://github.com/qutip/qutip/pull/1696>`_ by Simon Cross); - Fixed the skipping of the dnorm metric tests if cvxpy is not installed. Previously all metrics tests were skipped by accident. (`#1704 <https://github.com/qutip/qutip/pull/1704>`_ by Florian Hopfmueller); - Added bug report, feature request and other options to the GitHub issue reporting template. (`#1728 <https://github.com/qutip/qutip/pull/1728>`_ by Aryaman Kolhe); - Updated the build process to support building on Python 3.10 by removing the build requirement for numpy < 1.20 and replacing it with a requirement on oldest-supported-numpy. (`#1747 <https://github.com/qutip/qutip/pull/1747>`_ by Simon Cross); - Updated the version of cibuildwheel used to build wheels to 2.3.0. (`#1747 <https://github.com/qutip/qutip/pull/1747>`_, `#1751 <https://github.com/qutip/qutip/pull/1751>`_ by Simon Cross); - Added project urls to linking to the source repository, issue tracker and documentation to setup.cfg. (`#1779 <https://github.com/qutip/qutip/pull/1779>`_ by Simon Cross); - Added a numpy 1.22 and Pyt",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:76414,Deployability,release,release,76414,">`_ by Simon Cross); - Updated the version of cibuildwheel used to build wheels to 2.3.0. (`#1747 <https://github.com/qutip/qutip/pull/1747>`_, `#1751 <https://github.com/qutip/qutip/pull/1751>`_ by Simon Cross); - Added project urls to linking to the source repository, issue tracker and documentation to setup.cfg. (`#1779 <https://github.com/qutip/qutip/pull/1779>`_ by Simon Cross); - Added a numpy 1.22 and Python 3.10 build to the CI test matrix. (`#1777 <https://github.com/qutip/qutip/pull/1777>`_ by Simon Cross); - Ignore deprecation warnings from SciPy 1.8.0 scipy.sparse.X imports in CI tests. (`#1797 <https://github.com/qutip/qutip/pull/1797>`_ by Simon Cross); - Add building of wheels for Python 3.10 to the cibuildwheel job. (`#1796 <https://github.com/qutip/qutip/pull/1796>`_ by Simon Cross). Version 4.6.2 (June 2, 2021); ++++++++++++++++++++++++++++. This minor release adds a function to calculate the quantum relative entropy, fixes a corner case in handling time-dependent Hamiltonians in ``mesolve`` and adds back support for a wider range of matplotlib versions when plotting or animating Bloch spheres. It also adds a section in the README listing the papers which should be referenced while citing QuTiP. Improvements; ------------; - Added a ""Citing QuTiP"" section to the README, containing a link to the QuTiP papers. (`#1554 <https://github.com/qutip/qutip/pull/1554>`_); - Added ``entropy_relative`` which returns the quantum relative entropy between two density matrices. (`#1553 <https://github.com/qutip/qutip/pull/1553>`_). Bug Fixes; ---------; - Fixed Bloch sphere distortion when using Matplotlib >= 3.3.0. (`#1496 <https://github.com/qutip/qutip/pull/1496>`_); - Removed use of integer-like floats in math.factorial since it is deprecated as of Python 3.9. (`#1550 <https://github.com/qutip/qutip/pull/1550>`_); - Simplified call to ffmpeg used in the the Bloch sphere animation tutorial to work with recent versions of ffmpeg. (`#1557 <https://github.com/quti",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:78051,Deployability,release,release,78051,"ices. (`#1553 <https://github.com/qutip/qutip/pull/1553>`_). Bug Fixes; ---------; - Fixed Bloch sphere distortion when using Matplotlib >= 3.3.0. (`#1496 <https://github.com/qutip/qutip/pull/1496>`_); - Removed use of integer-like floats in math.factorial since it is deprecated as of Python 3.9. (`#1550 <https://github.com/qutip/qutip/pull/1550>`_); - Simplified call to ffmpeg used in the the Bloch sphere animation tutorial to work with recent versions of ffmpeg. (`#1557 <https://github.com/qutip/qutip/pull/1557>`_); - Removed blitting in Bloch sphere FuncAnimation example. (`#1558 <https://github.com/qutip/qutip/pull/1558>`_); - Added a version checking condition to handle specific functionalities depending on the matplotlib version. (`#1556 <https://github.com/qutip/qutip/pull/1556>`_); - Fixed ``mesolve`` handling of time-dependent Hamiltonian with a custom tlist and ``c_ops``. (`#1561 <https://github.com/qutip/qutip/pull/1561>`_). Developer Changes; -----------------; - Read documentation version and release from the VERSION file. Version 4.6.1 (May 4, 2021); +++++++++++++++++++++++++++. This minor release fixes bugs in QIP gate definitions, fixes building from; the source tarball when git is not installed and works around an MKL; bug in versions of SciPy <= 1.4. It also adds the ``[full]`` pip install target so that ``pip install qutip[full]``; installs qutip and all of its optional and developer dependencies. Improvements; ------------; - Add the ``[full]`` pip install target (by **Jake Lishman**). Bug Fixes; ---------; - Work around pointer MKL eigh bug in SciPy <= 1.4 (by **Felipe Bivort Haiek**); - Fix berkeley, swapalpha and cz gate operations (by **Boxi Li**); - Expose the CPHASE control gate (by **Boxi Li**); - Fix building from the sdist when git is not installed (by **Jake Lishman**). Developer Changes; -----------------; - Move the qutip-doc documentation into the qutip repository (by **Jake Lishman**); - Fix warnings in documentation build (by **Jak",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:78151,Deployability,release,release,78151,"`_); - Removed use of integer-like floats in math.factorial since it is deprecated as of Python 3.9. (`#1550 <https://github.com/qutip/qutip/pull/1550>`_); - Simplified call to ffmpeg used in the the Bloch sphere animation tutorial to work with recent versions of ffmpeg. (`#1557 <https://github.com/qutip/qutip/pull/1557>`_); - Removed blitting in Bloch sphere FuncAnimation example. (`#1558 <https://github.com/qutip/qutip/pull/1558>`_); - Added a version checking condition to handle specific functionalities depending on the matplotlib version. (`#1556 <https://github.com/qutip/qutip/pull/1556>`_); - Fixed ``mesolve`` handling of time-dependent Hamiltonian with a custom tlist and ``c_ops``. (`#1561 <https://github.com/qutip/qutip/pull/1561>`_). Developer Changes; -----------------; - Read documentation version and release from the VERSION file. Version 4.6.1 (May 4, 2021); +++++++++++++++++++++++++++. This minor release fixes bugs in QIP gate definitions, fixes building from; the source tarball when git is not installed and works around an MKL; bug in versions of SciPy <= 1.4. It also adds the ``[full]`` pip install target so that ``pip install qutip[full]``; installs qutip and all of its optional and developer dependencies. Improvements; ------------; - Add the ``[full]`` pip install target (by **Jake Lishman**). Bug Fixes; ---------; - Work around pointer MKL eigh bug in SciPy <= 1.4 (by **Felipe Bivort Haiek**); - Fix berkeley, swapalpha and cz gate operations (by **Boxi Li**); - Expose the CPHASE control gate (by **Boxi Li**); - Fix building from the sdist when git is not installed (by **Jake Lishman**). Developer Changes; -----------------; - Move the qutip-doc documentation into the qutip repository (by **Jake Lishman**); - Fix warnings in documentation build (by **Jake Lishman**); - Fix warnings in pytest runs and make pytest treat warnings as errors (by **Jake Lishman**); - Add Simon Cross as author (by **Simon Cross**). Version 4.6.0 (April 11, 2021); ++++++++",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:78251,Deployability,install,installed,78251,"`_); - Removed use of integer-like floats in math.factorial since it is deprecated as of Python 3.9. (`#1550 <https://github.com/qutip/qutip/pull/1550>`_); - Simplified call to ffmpeg used in the the Bloch sphere animation tutorial to work with recent versions of ffmpeg. (`#1557 <https://github.com/qutip/qutip/pull/1557>`_); - Removed blitting in Bloch sphere FuncAnimation example. (`#1558 <https://github.com/qutip/qutip/pull/1558>`_); - Added a version checking condition to handle specific functionalities depending on the matplotlib version. (`#1556 <https://github.com/qutip/qutip/pull/1556>`_); - Fixed ``mesolve`` handling of time-dependent Hamiltonian with a custom tlist and ``c_ops``. (`#1561 <https://github.com/qutip/qutip/pull/1561>`_). Developer Changes; -----------------; - Read documentation version and release from the VERSION file. Version 4.6.1 (May 4, 2021); +++++++++++++++++++++++++++. This minor release fixes bugs in QIP gate definitions, fixes building from; the source tarball when git is not installed and works around an MKL; bug in versions of SciPy <= 1.4. It also adds the ``[full]`` pip install target so that ``pip install qutip[full]``; installs qutip and all of its optional and developer dependencies. Improvements; ------------; - Add the ``[full]`` pip install target (by **Jake Lishman**). Bug Fixes; ---------; - Work around pointer MKL eigh bug in SciPy <= 1.4 (by **Felipe Bivort Haiek**); - Fix berkeley, swapalpha and cz gate operations (by **Boxi Li**); - Expose the CPHASE control gate (by **Boxi Li**); - Fix building from the sdist when git is not installed (by **Jake Lishman**). Developer Changes; -----------------; - Move the qutip-doc documentation into the qutip repository (by **Jake Lishman**); - Fix warnings in documentation build (by **Jake Lishman**); - Fix warnings in pytest runs and make pytest treat warnings as errors (by **Jake Lishman**); - Add Simon Cross as author (by **Simon Cross**). Version 4.6.0 (April 11, 2021); ++++++++",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:78351,Deployability,install,install,78351,"ed call to ffmpeg used in the the Bloch sphere animation tutorial to work with recent versions of ffmpeg. (`#1557 <https://github.com/qutip/qutip/pull/1557>`_); - Removed blitting in Bloch sphere FuncAnimation example. (`#1558 <https://github.com/qutip/qutip/pull/1558>`_); - Added a version checking condition to handle specific functionalities depending on the matplotlib version. (`#1556 <https://github.com/qutip/qutip/pull/1556>`_); - Fixed ``mesolve`` handling of time-dependent Hamiltonian with a custom tlist and ``c_ops``. (`#1561 <https://github.com/qutip/qutip/pull/1561>`_). Developer Changes; -----------------; - Read documentation version and release from the VERSION file. Version 4.6.1 (May 4, 2021); +++++++++++++++++++++++++++. This minor release fixes bugs in QIP gate definitions, fixes building from; the source tarball when git is not installed and works around an MKL; bug in versions of SciPy <= 1.4. It also adds the ``[full]`` pip install target so that ``pip install qutip[full]``; installs qutip and all of its optional and developer dependencies. Improvements; ------------; - Add the ``[full]`` pip install target (by **Jake Lishman**). Bug Fixes; ---------; - Work around pointer MKL eigh bug in SciPy <= 1.4 (by **Felipe Bivort Haiek**); - Fix berkeley, swapalpha and cz gate operations (by **Boxi Li**); - Expose the CPHASE control gate (by **Boxi Li**); - Fix building from the sdist when git is not installed (by **Jake Lishman**). Developer Changes; -----------------; - Move the qutip-doc documentation into the qutip repository (by **Jake Lishman**); - Fix warnings in documentation build (by **Jake Lishman**); - Fix warnings in pytest runs and make pytest treat warnings as errors (by **Jake Lishman**); - Add Simon Cross as author (by **Simon Cross**). Version 4.6.0 (April 11, 2021); ++++++++++++++++++++++++++++++. This release brings improvements for qubit circuits, including a pulse scheduler, measurement statistics, reading/writing OpenQASM and optimis",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:78380,Deployability,install,install,78380,"ed call to ffmpeg used in the the Bloch sphere animation tutorial to work with recent versions of ffmpeg. (`#1557 <https://github.com/qutip/qutip/pull/1557>`_); - Removed blitting in Bloch sphere FuncAnimation example. (`#1558 <https://github.com/qutip/qutip/pull/1558>`_); - Added a version checking condition to handle specific functionalities depending on the matplotlib version. (`#1556 <https://github.com/qutip/qutip/pull/1556>`_); - Fixed ``mesolve`` handling of time-dependent Hamiltonian with a custom tlist and ``c_ops``. (`#1561 <https://github.com/qutip/qutip/pull/1561>`_). Developer Changes; -----------------; - Read documentation version and release from the VERSION file. Version 4.6.1 (May 4, 2021); +++++++++++++++++++++++++++. This minor release fixes bugs in QIP gate definitions, fixes building from; the source tarball when git is not installed and works around an MKL; bug in versions of SciPy <= 1.4. It also adds the ``[full]`` pip install target so that ``pip install qutip[full]``; installs qutip and all of its optional and developer dependencies. Improvements; ------------; - Add the ``[full]`` pip install target (by **Jake Lishman**). Bug Fixes; ---------; - Work around pointer MKL eigh bug in SciPy <= 1.4 (by **Felipe Bivort Haiek**); - Fix berkeley, swapalpha and cz gate operations (by **Boxi Li**); - Expose the CPHASE control gate (by **Boxi Li**); - Fix building from the sdist when git is not installed (by **Jake Lishman**). Developer Changes; -----------------; - Move the qutip-doc documentation into the qutip repository (by **Jake Lishman**); - Fix warnings in documentation build (by **Jake Lishman**); - Fix warnings in pytest runs and make pytest treat warnings as errors (by **Jake Lishman**); - Add Simon Cross as author (by **Simon Cross**). Version 4.6.0 (April 11, 2021); ++++++++++++++++++++++++++++++. This release brings improvements for qubit circuits, including a pulse scheduler, measurement statistics, reading/writing OpenQASM and optimis",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:78403,Deployability,install,installs,78403,"ed call to ffmpeg used in the the Bloch sphere animation tutorial to work with recent versions of ffmpeg. (`#1557 <https://github.com/qutip/qutip/pull/1557>`_); - Removed blitting in Bloch sphere FuncAnimation example. (`#1558 <https://github.com/qutip/qutip/pull/1558>`_); - Added a version checking condition to handle specific functionalities depending on the matplotlib version. (`#1556 <https://github.com/qutip/qutip/pull/1556>`_); - Fixed ``mesolve`` handling of time-dependent Hamiltonian with a custom tlist and ``c_ops``. (`#1561 <https://github.com/qutip/qutip/pull/1561>`_). Developer Changes; -----------------; - Read documentation version and release from the VERSION file. Version 4.6.1 (May 4, 2021); +++++++++++++++++++++++++++. This minor release fixes bugs in QIP gate definitions, fixes building from; the source tarball when git is not installed and works around an MKL; bug in versions of SciPy <= 1.4. It also adds the ``[full]`` pip install target so that ``pip install qutip[full]``; installs qutip and all of its optional and developer dependencies. Improvements; ------------; - Add the ``[full]`` pip install target (by **Jake Lishman**). Bug Fixes; ---------; - Work around pointer MKL eigh bug in SciPy <= 1.4 (by **Felipe Bivort Haiek**); - Fix berkeley, swapalpha and cz gate operations (by **Boxi Li**); - Expose the CPHASE control gate (by **Boxi Li**); - Fix building from the sdist when git is not installed (by **Jake Lishman**). Developer Changes; -----------------; - Move the qutip-doc documentation into the qutip repository (by **Jake Lishman**); - Fix warnings in documentation build (by **Jake Lishman**); - Fix warnings in pytest runs and make pytest treat warnings as errors (by **Jake Lishman**); - Add Simon Cross as author (by **Simon Cross**). Version 4.6.0 (April 11, 2021); ++++++++++++++++++++++++++++++. This release brings improvements for qubit circuits, including a pulse scheduler, measurement statistics, reading/writing OpenQASM and optimis",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:78523,Deployability,install,install,78523,"//github.com/qutip/qutip/pull/1557>`_); - Removed blitting in Bloch sphere FuncAnimation example. (`#1558 <https://github.com/qutip/qutip/pull/1558>`_); - Added a version checking condition to handle specific functionalities depending on the matplotlib version. (`#1556 <https://github.com/qutip/qutip/pull/1556>`_); - Fixed ``mesolve`` handling of time-dependent Hamiltonian with a custom tlist and ``c_ops``. (`#1561 <https://github.com/qutip/qutip/pull/1561>`_). Developer Changes; -----------------; - Read documentation version and release from the VERSION file. Version 4.6.1 (May 4, 2021); +++++++++++++++++++++++++++. This minor release fixes bugs in QIP gate definitions, fixes building from; the source tarball when git is not installed and works around an MKL; bug in versions of SciPy <= 1.4. It also adds the ``[full]`` pip install target so that ``pip install qutip[full]``; installs qutip and all of its optional and developer dependencies. Improvements; ------------; - Add the ``[full]`` pip install target (by **Jake Lishman**). Bug Fixes; ---------; - Work around pointer MKL eigh bug in SciPy <= 1.4 (by **Felipe Bivort Haiek**); - Fix berkeley, swapalpha and cz gate operations (by **Boxi Li**); - Expose the CPHASE control gate (by **Boxi Li**); - Fix building from the sdist when git is not installed (by **Jake Lishman**). Developer Changes; -----------------; - Move the qutip-doc documentation into the qutip repository (by **Jake Lishman**); - Fix warnings in documentation build (by **Jake Lishman**); - Fix warnings in pytest runs and make pytest treat warnings as errors (by **Jake Lishman**); - Add Simon Cross as author (by **Simon Cross**). Version 4.6.0 (April 11, 2021); ++++++++++++++++++++++++++++++. This release brings improvements for qubit circuits, including a pulse scheduler, measurement statistics, reading/writing OpenQASM and optimisations in the circuit simulations. This is the first release to have full binary wheel releases on pip; you can now do ``",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:78828,Deployability,install,installed,78828,"ng on the matplotlib version. (`#1556 <https://github.com/qutip/qutip/pull/1556>`_); - Fixed ``mesolve`` handling of time-dependent Hamiltonian with a custom tlist and ``c_ops``. (`#1561 <https://github.com/qutip/qutip/pull/1561>`_). Developer Changes; -----------------; - Read documentation version and release from the VERSION file. Version 4.6.1 (May 4, 2021); +++++++++++++++++++++++++++. This minor release fixes bugs in QIP gate definitions, fixes building from; the source tarball when git is not installed and works around an MKL; bug in versions of SciPy <= 1.4. It also adds the ``[full]`` pip install target so that ``pip install qutip[full]``; installs qutip and all of its optional and developer dependencies. Improvements; ------------; - Add the ``[full]`` pip install target (by **Jake Lishman**). Bug Fixes; ---------; - Work around pointer MKL eigh bug in SciPy <= 1.4 (by **Felipe Bivort Haiek**); - Fix berkeley, swapalpha and cz gate operations (by **Boxi Li**); - Expose the CPHASE control gate (by **Boxi Li**); - Fix building from the sdist when git is not installed (by **Jake Lishman**). Developer Changes; -----------------; - Move the qutip-doc documentation into the qutip repository (by **Jake Lishman**); - Fix warnings in documentation build (by **Jake Lishman**); - Fix warnings in pytest runs and make pytest treat warnings as errors (by **Jake Lishman**); - Add Simon Cross as author (by **Simon Cross**). Version 4.6.0 (April 11, 2021); ++++++++++++++++++++++++++++++. This release brings improvements for qubit circuits, including a pulse scheduler, measurement statistics, reading/writing OpenQASM and optimisations in the circuit simulations. This is the first release to have full binary wheel releases on pip; you can now do ``pip install qutip`` on almost any machine to get a correct version of the package without needing any compilers set up.; The support for Numpy 1.20 that was first added in QuTiP 4.5.3 is present in this version as well, and the sam",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:79257,Deployability,release,release,79257,"full]`` pip install target so that ``pip install qutip[full]``; installs qutip and all of its optional and developer dependencies. Improvements; ------------; - Add the ``[full]`` pip install target (by **Jake Lishman**). Bug Fixes; ---------; - Work around pointer MKL eigh bug in SciPy <= 1.4 (by **Felipe Bivort Haiek**); - Fix berkeley, swapalpha and cz gate operations (by **Boxi Li**); - Expose the CPHASE control gate (by **Boxi Li**); - Fix building from the sdist when git is not installed (by **Jake Lishman**). Developer Changes; -----------------; - Move the qutip-doc documentation into the qutip repository (by **Jake Lishman**); - Fix warnings in documentation build (by **Jake Lishman**); - Fix warnings in pytest runs and make pytest treat warnings as errors (by **Jake Lishman**); - Add Simon Cross as author (by **Simon Cross**). Version 4.6.0 (April 11, 2021); ++++++++++++++++++++++++++++++. This release brings improvements for qubit circuits, including a pulse scheduler, measurement statistics, reading/writing OpenQASM and optimisations in the circuit simulations. This is the first release to have full binary wheel releases on pip; you can now do ``pip install qutip`` on almost any machine to get a correct version of the package without needing any compilers set up.; The support for Numpy 1.20 that was first added in QuTiP 4.5.3 is present in this version as well, and the same build considerations mentioned there apply here too.; If building using the now-supported PEP 517 mechanisms (e.g. ``python -mbuild /path/to/qutip``), all build dependencies will be correctly satisfied. Improvements; ------------; - **MAJOR** Add saving, loading and resetting functionality to ``qutip.settings`` for easy re-configuration. (by **Eric Gigure**); - **MAJOR** Add a quantum gate scheduler in ``qutip.qip.scheduler``, to help parallelise the operations of quantum gates. This supports two scheduling modes: as late as possible, and as soon as possible. (by **Boxi Li**); - **MAJ",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:79447,Deployability,release,release,79447,"target (by **Jake Lishman**). Bug Fixes; ---------; - Work around pointer MKL eigh bug in SciPy <= 1.4 (by **Felipe Bivort Haiek**); - Fix berkeley, swapalpha and cz gate operations (by **Boxi Li**); - Expose the CPHASE control gate (by **Boxi Li**); - Fix building from the sdist when git is not installed (by **Jake Lishman**). Developer Changes; -----------------; - Move the qutip-doc documentation into the qutip repository (by **Jake Lishman**); - Fix warnings in documentation build (by **Jake Lishman**); - Fix warnings in pytest runs and make pytest treat warnings as errors (by **Jake Lishman**); - Add Simon Cross as author (by **Simon Cross**). Version 4.6.0 (April 11, 2021); ++++++++++++++++++++++++++++++. This release brings improvements for qubit circuits, including a pulse scheduler, measurement statistics, reading/writing OpenQASM and optimisations in the circuit simulations. This is the first release to have full binary wheel releases on pip; you can now do ``pip install qutip`` on almost any machine to get a correct version of the package without needing any compilers set up.; The support for Numpy 1.20 that was first added in QuTiP 4.5.3 is present in this version as well, and the same build considerations mentioned there apply here too.; If building using the now-supported PEP 517 mechanisms (e.g. ``python -mbuild /path/to/qutip``), all build dependencies will be correctly satisfied. Improvements; ------------; - **MAJOR** Add saving, loading and resetting functionality to ``qutip.settings`` for easy re-configuration. (by **Eric Gigure**); - **MAJOR** Add a quantum gate scheduler in ``qutip.qip.scheduler``, to help parallelise the operations of quantum gates. This supports two scheduling modes: as late as possible, and as soon as possible. (by **Boxi Li**); - **MAJOR** Improved qubit circuit simulators, including OpenQASM support and performance optimisations. (by **Sidhant Saraogi**); - **MAJOR** Add tools for quantum measurements and their statistics",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:79481,Deployability,release,releases,79481,"target (by **Jake Lishman**). Bug Fixes; ---------; - Work around pointer MKL eigh bug in SciPy <= 1.4 (by **Felipe Bivort Haiek**); - Fix berkeley, swapalpha and cz gate operations (by **Boxi Li**); - Expose the CPHASE control gate (by **Boxi Li**); - Fix building from the sdist when git is not installed (by **Jake Lishman**). Developer Changes; -----------------; - Move the qutip-doc documentation into the qutip repository (by **Jake Lishman**); - Fix warnings in documentation build (by **Jake Lishman**); - Fix warnings in pytest runs and make pytest treat warnings as errors (by **Jake Lishman**); - Add Simon Cross as author (by **Simon Cross**). Version 4.6.0 (April 11, 2021); ++++++++++++++++++++++++++++++. This release brings improvements for qubit circuits, including a pulse scheduler, measurement statistics, reading/writing OpenQASM and optimisations in the circuit simulations. This is the first release to have full binary wheel releases on pip; you can now do ``pip install qutip`` on almost any machine to get a correct version of the package without needing any compilers set up.; The support for Numpy 1.20 that was first added in QuTiP 4.5.3 is present in this version as well, and the same build considerations mentioned there apply here too.; If building using the now-supported PEP 517 mechanisms (e.g. ``python -mbuild /path/to/qutip``), all build dependencies will be correctly satisfied. Improvements; ------------; - **MAJOR** Add saving, loading and resetting functionality to ``qutip.settings`` for easy re-configuration. (by **Eric Gigure**); - **MAJOR** Add a quantum gate scheduler in ``qutip.qip.scheduler``, to help parallelise the operations of quantum gates. This supports two scheduling modes: as late as possible, and as soon as possible. (by **Boxi Li**); - **MAJOR** Improved qubit circuit simulators, including OpenQASM support and performance optimisations. (by **Sidhant Saraogi**); - **MAJOR** Add tools for quantum measurements and their statistics",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:79519,Deployability,install,install,79519,"target (by **Jake Lishman**). Bug Fixes; ---------; - Work around pointer MKL eigh bug in SciPy <= 1.4 (by **Felipe Bivort Haiek**); - Fix berkeley, swapalpha and cz gate operations (by **Boxi Li**); - Expose the CPHASE control gate (by **Boxi Li**); - Fix building from the sdist when git is not installed (by **Jake Lishman**). Developer Changes; -----------------; - Move the qutip-doc documentation into the qutip repository (by **Jake Lishman**); - Fix warnings in documentation build (by **Jake Lishman**); - Fix warnings in pytest runs and make pytest treat warnings as errors (by **Jake Lishman**); - Add Simon Cross as author (by **Simon Cross**). Version 4.6.0 (April 11, 2021); ++++++++++++++++++++++++++++++. This release brings improvements for qubit circuits, including a pulse scheduler, measurement statistics, reading/writing OpenQASM and optimisations in the circuit simulations. This is the first release to have full binary wheel releases on pip; you can now do ``pip install qutip`` on almost any machine to get a correct version of the package without needing any compilers set up.; The support for Numpy 1.20 that was first added in QuTiP 4.5.3 is present in this version as well, and the same build considerations mentioned there apply here too.; If building using the now-supported PEP 517 mechanisms (e.g. ``python -mbuild /path/to/qutip``), all build dependencies will be correctly satisfied. Improvements; ------------; - **MAJOR** Add saving, loading and resetting functionality to ``qutip.settings`` for easy re-configuration. (by **Eric Gigure**); - **MAJOR** Add a quantum gate scheduler in ``qutip.qip.scheduler``, to help parallelise the operations of quantum gates. This supports two scheduling modes: as late as possible, and as soon as possible. (by **Boxi Li**); - **MAJOR** Improved qubit circuit simulators, including OpenQASM support and performance optimisations. (by **Sidhant Saraogi**); - **MAJOR** Add tools for quantum measurements and their statistics",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:80073,Deployability,configurat,configuration,80073," runs and make pytest treat warnings as errors (by **Jake Lishman**); - Add Simon Cross as author (by **Simon Cross**). Version 4.6.0 (April 11, 2021); ++++++++++++++++++++++++++++++. This release brings improvements for qubit circuits, including a pulse scheduler, measurement statistics, reading/writing OpenQASM and optimisations in the circuit simulations. This is the first release to have full binary wheel releases on pip; you can now do ``pip install qutip`` on almost any machine to get a correct version of the package without needing any compilers set up.; The support for Numpy 1.20 that was first added in QuTiP 4.5.3 is present in this version as well, and the same build considerations mentioned there apply here too.; If building using the now-supported PEP 517 mechanisms (e.g. ``python -mbuild /path/to/qutip``), all build dependencies will be correctly satisfied. Improvements; ------------; - **MAJOR** Add saving, loading and resetting functionality to ``qutip.settings`` for easy re-configuration. (by **Eric Gigure**); - **MAJOR** Add a quantum gate scheduler in ``qutip.qip.scheduler``, to help parallelise the operations of quantum gates. This supports two scheduling modes: as late as possible, and as soon as possible. (by **Boxi Li**); - **MAJOR** Improved qubit circuit simulators, including OpenQASM support and performance optimisations. (by **Sidhant Saraogi**); - **MAJOR** Add tools for quantum measurements and their statistics. (by **Simon Cross** and **Sidhant Saraogi**); - Add support for Numpy 1.20. QuTiP should be compiled against a version of Numpy ``>= 1.16.6`` and ``< 1.20`` (note: does _not_ include 1.20 itself), but such an installation is compatible with any modern version of Numpy. Source installations from ``pip`` understand this constraint.; - Improve the error message when circuit plotting fails. (by **Boxi Li**); - Add support for parsing M1 Mac hardware information. (by **Xiaoliang Wu**); - Add more single-qubit gates and controlled gates",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:80742,Deployability,install,installation,80742,"erations mentioned there apply here too.; If building using the now-supported PEP 517 mechanisms (e.g. ``python -mbuild /path/to/qutip``), all build dependencies will be correctly satisfied. Improvements; ------------; - **MAJOR** Add saving, loading and resetting functionality to ``qutip.settings`` for easy re-configuration. (by **Eric Gigure**); - **MAJOR** Add a quantum gate scheduler in ``qutip.qip.scheduler``, to help parallelise the operations of quantum gates. This supports two scheduling modes: as late as possible, and as soon as possible. (by **Boxi Li**); - **MAJOR** Improved qubit circuit simulators, including OpenQASM support and performance optimisations. (by **Sidhant Saraogi**); - **MAJOR** Add tools for quantum measurements and their statistics. (by **Simon Cross** and **Sidhant Saraogi**); - Add support for Numpy 1.20. QuTiP should be compiled against a version of Numpy ``>= 1.16.6`` and ``< 1.20`` (note: does _not_ include 1.20 itself), but such an installation is compatible with any modern version of Numpy. Source installations from ``pip`` understand this constraint.; - Improve the error message when circuit plotting fails. (by **Boxi Li**); - Add support for parsing M1 Mac hardware information. (by **Xiaoliang Wu**); - Add more single-qubit gates and controlled gates. (by **Mateo Laguna** and **Martn Sande Costa**); - Support decomposition of ``X``, ``Y`` and ``Z`` gates in circuits. (by **Boxi Li**); - Refactor ``QubitCircuit.resolve_gate()`` (by **Martn Sande Costa**). Bug Fixes; ---------; - Fix ``dims`` in the returns from ``Qobj.eigenstates`` on superoperators. (by **Jake Lishman**); - Calling Numpy ufuncs on ``Qobj`` will now correctly raise a ``TypeError`` rather than returning a nonsense ``ndarray``. (by **Jake Lishman**); - Convert segfault into Python exception when creating too-large tensor products. (by **Jake Lishman**); - Correctly set ``num_collapse`` in the output of ``mesolve``. (by **Jake Lishman**); - Fix ``ptrace`` when al",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:80810,Deployability,install,installations,80810,"rted PEP 517 mechanisms (e.g. ``python -mbuild /path/to/qutip``), all build dependencies will be correctly satisfied. Improvements; ------------; - **MAJOR** Add saving, loading and resetting functionality to ``qutip.settings`` for easy re-configuration. (by **Eric Gigure**); - **MAJOR** Add a quantum gate scheduler in ``qutip.qip.scheduler``, to help parallelise the operations of quantum gates. This supports two scheduling modes: as late as possible, and as soon as possible. (by **Boxi Li**); - **MAJOR** Improved qubit circuit simulators, including OpenQASM support and performance optimisations. (by **Sidhant Saraogi**); - **MAJOR** Add tools for quantum measurements and their statistics. (by **Simon Cross** and **Sidhant Saraogi**); - Add support for Numpy 1.20. QuTiP should be compiled against a version of Numpy ``>= 1.16.6`` and ``< 1.20`` (note: does _not_ include 1.20 itself), but such an installation is compatible with any modern version of Numpy. Source installations from ``pip`` understand this constraint.; - Improve the error message when circuit plotting fails. (by **Boxi Li**); - Add support for parsing M1 Mac hardware information. (by **Xiaoliang Wu**); - Add more single-qubit gates and controlled gates. (by **Mateo Laguna** and **Martn Sande Costa**); - Support decomposition of ``X``, ``Y`` and ``Z`` gates in circuits. (by **Boxi Li**); - Refactor ``QubitCircuit.resolve_gate()`` (by **Martn Sande Costa**). Bug Fixes; ---------; - Fix ``dims`` in the returns from ``Qobj.eigenstates`` on superoperators. (by **Jake Lishman**); - Calling Numpy ufuncs on ``Qobj`` will now correctly raise a ``TypeError`` rather than returning a nonsense ``ndarray``. (by **Jake Lishman**); - Convert segfault into Python exception when creating too-large tensor products. (by **Jake Lishman**); - Correctly set ``num_collapse`` in the output of ``mesolve``. (by **Jake Lishman**); - Fix ``ptrace`` when all subspaces are being kept, or the subspaces are passed in order. (by **J",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:83405,Deployability,release,release,83405,"ad initial ``Qobj`` as the state. (by **Jake Lishman**); - Fix sparse matrix construction in PIQS when using Scipy 1.6.1. (by **Drew Parsons**); - Fix ``zspmv_openmp.cpp`` missing from the pip sdist. (by **Christoph Gohlke**); - Fix correlation functions throwing away imaginary components. (by **Asier Galicia Martinez**); - Fix ``QubitCircuit.add_circuit()`` for SWAP gate. (by **Canoming**); - Fix the broken LaTeX image conversion. (by **Jake Lishman**); - Fix gate resolution of the FREDKIN gate. (by **Bo Yang**); - Fix broken formatting in docstrings. (by **Jake Lishman**). Deprecations; ------------; - ``eseries``, ``essolve`` and ``ode2es`` are all deprecated, pending removal in QuTiP 5.0. These are legacy functions and classes that have been left unmaintained for a long time, and their functionality is now better achieved with ``QobjEvo`` or ``mesolve``. Developer Changes; -----------------; - **MAJOR** Overhaul of setup and packaging code to make it satisfy PEP 517, and move the build to a matrix on GitHub Actions in order to release binary wheels on pip for all major platforms and supported Python versions. (by **Jake Lishman**); - Default arguments in ``Qobj`` are now ``None`` rather than mutable types. (by **Jake Lishman**); - Fixed comsumable iterators being used to parametrise some tests, preventing the testing suite from being re-run within the same session. (by **Jake Lishman**); - Remove unused imports, simplify some floats and remove unnecessary list conversions. (by **jakobjakobson13**); - Improve Travis jobs matrix for specifying the testing containers. (by **Jake Lishman**); - Fix coverage reporting on Travis. (by **Jake Lishman**); - Added a ``pyproject.toml`` file. (by **Simon Humpohl** and **Eric Gigure**); - Add doctests to documentation. (by **Sidhant Saraogi**); - Fix all warnings in the documentation build. (by **Jake Lishman**). Version 4.5.3 (February 19, 2021); +++++++++++++++++++++++++++++++++. This patch release adds support for Numpy 1",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:84320,Deployability,patch,patch,84320,"EP 517, and move the build to a matrix on GitHub Actions in order to release binary wheels on pip for all major platforms and supported Python versions. (by **Jake Lishman**); - Default arguments in ``Qobj`` are now ``None`` rather than mutable types. (by **Jake Lishman**); - Fixed comsumable iterators being used to parametrise some tests, preventing the testing suite from being re-run within the same session. (by **Jake Lishman**); - Remove unused imports, simplify some floats and remove unnecessary list conversions. (by **jakobjakobson13**); - Improve Travis jobs matrix for specifying the testing containers. (by **Jake Lishman**); - Fix coverage reporting on Travis. (by **Jake Lishman**); - Added a ``pyproject.toml`` file. (by **Simon Humpohl** and **Eric Gigure**); - Add doctests to documentation. (by **Sidhant Saraogi**); - Fix all warnings in the documentation build. (by **Jake Lishman**). Version 4.5.3 (February 19, 2021); +++++++++++++++++++++++++++++++++. This patch release adds support for Numpy 1.20, made necessary by changes to how array-like objects are handled. There are no other changes relative to version 4.5.2. Users building from source should ensure that they build against Numpy versions >= 1.16.6 and < 1.20 (not including 1.20 itself), but after that or for those installing from conda, an installation will support any current Numpy version >= 1.16.6. Improvements; ------------; - Add support for Numpy 1.20. QuTiP should be compiled against a version of Numpy ``>= 1.16.6`` and ``< 1.20`` (note: does _not_ include 1.20 itself), but such an installation is compatible with any modern version of Numpy. Source installations from ``pip`` understand this constraint. Version 4.5.2 (July 14, 2020); +++++++++++++++++++++++++++++. This is predominantly a hot-fix release to add support for Scipy 1.5, due to changes in private sparse matrix functions that QuTiP also used. Improvements; ------------; - Add support for Scipy 1.5. (by **Jake Lishman**); - Improved",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:84326,Deployability,release,release,84326,"EP 517, and move the build to a matrix on GitHub Actions in order to release binary wheels on pip for all major platforms and supported Python versions. (by **Jake Lishman**); - Default arguments in ``Qobj`` are now ``None`` rather than mutable types. (by **Jake Lishman**); - Fixed comsumable iterators being used to parametrise some tests, preventing the testing suite from being re-run within the same session. (by **Jake Lishman**); - Remove unused imports, simplify some floats and remove unnecessary list conversions. (by **jakobjakobson13**); - Improve Travis jobs matrix for specifying the testing containers. (by **Jake Lishman**); - Fix coverage reporting on Travis. (by **Jake Lishman**); - Added a ``pyproject.toml`` file. (by **Simon Humpohl** and **Eric Gigure**); - Add doctests to documentation. (by **Sidhant Saraogi**); - Fix all warnings in the documentation build. (by **Jake Lishman**). Version 4.5.3 (February 19, 2021); +++++++++++++++++++++++++++++++++. This patch release adds support for Numpy 1.20, made necessary by changes to how array-like objects are handled. There are no other changes relative to version 4.5.2. Users building from source should ensure that they build against Numpy versions >= 1.16.6 and < 1.20 (not including 1.20 itself), but after that or for those installing from conda, an installation will support any current Numpy version >= 1.16.6. Improvements; ------------; - Add support for Numpy 1.20. QuTiP should be compiled against a version of Numpy ``>= 1.16.6`` and ``< 1.20`` (note: does _not_ include 1.20 itself), but such an installation is compatible with any modern version of Numpy. Source installations from ``pip`` understand this constraint. Version 4.5.2 (July 14, 2020); +++++++++++++++++++++++++++++. This is predominantly a hot-fix release to add support for Scipy 1.5, due to changes in private sparse matrix functions that QuTiP also used. Improvements; ------------; - Add support for Scipy 1.5. (by **Jake Lishman**); - Improved",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:84640,Deployability,install,installing,84640,"rise some tests, preventing the testing suite from being re-run within the same session. (by **Jake Lishman**); - Remove unused imports, simplify some floats and remove unnecessary list conversions. (by **jakobjakobson13**); - Improve Travis jobs matrix for specifying the testing containers. (by **Jake Lishman**); - Fix coverage reporting on Travis. (by **Jake Lishman**); - Added a ``pyproject.toml`` file. (by **Simon Humpohl** and **Eric Gigure**); - Add doctests to documentation. (by **Sidhant Saraogi**); - Fix all warnings in the documentation build. (by **Jake Lishman**). Version 4.5.3 (February 19, 2021); +++++++++++++++++++++++++++++++++. This patch release adds support for Numpy 1.20, made necessary by changes to how array-like objects are handled. There are no other changes relative to version 4.5.2. Users building from source should ensure that they build against Numpy versions >= 1.16.6 and < 1.20 (not including 1.20 itself), but after that or for those installing from conda, an installation will support any current Numpy version >= 1.16.6. Improvements; ------------; - Add support for Numpy 1.20. QuTiP should be compiled against a version of Numpy ``>= 1.16.6`` and ``< 1.20`` (note: does _not_ include 1.20 itself), but such an installation is compatible with any modern version of Numpy. Source installations from ``pip`` understand this constraint. Version 4.5.2 (July 14, 2020); +++++++++++++++++++++++++++++. This is predominantly a hot-fix release to add support for Scipy 1.5, due to changes in private sparse matrix functions that QuTiP also used. Improvements; ------------; - Add support for Scipy 1.5. (by **Jake Lishman**); - Improved speed of ``zcsr_inner``, which affects ``Qobj.overlap``. (by **Jake Lishman**); - Better error messages when installation requirements are not satisfied. (by **Eric Gigure**). Bug Fixes; ---------; - Fix ``zcsr_proj`` acting on matrices with unsorted indices. (by **Jake Lishman**); - Fix errors in Milstein's heterodyne. (",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:84666,Deployability,install,installation,84666,"rise some tests, preventing the testing suite from being re-run within the same session. (by **Jake Lishman**); - Remove unused imports, simplify some floats and remove unnecessary list conversions. (by **jakobjakobson13**); - Improve Travis jobs matrix for specifying the testing containers. (by **Jake Lishman**); - Fix coverage reporting on Travis. (by **Jake Lishman**); - Added a ``pyproject.toml`` file. (by **Simon Humpohl** and **Eric Gigure**); - Add doctests to documentation. (by **Sidhant Saraogi**); - Fix all warnings in the documentation build. (by **Jake Lishman**). Version 4.5.3 (February 19, 2021); +++++++++++++++++++++++++++++++++. This patch release adds support for Numpy 1.20, made necessary by changes to how array-like objects are handled. There are no other changes relative to version 4.5.2. Users building from source should ensure that they build against Numpy versions >= 1.16.6 and < 1.20 (not including 1.20 itself), but after that or for those installing from conda, an installation will support any current Numpy version >= 1.16.6. Improvements; ------------; - Add support for Numpy 1.20. QuTiP should be compiled against a version of Numpy ``>= 1.16.6`` and ``< 1.20`` (note: does _not_ include 1.20 itself), but such an installation is compatible with any modern version of Numpy. Source installations from ``pip`` understand this constraint. Version 4.5.2 (July 14, 2020); +++++++++++++++++++++++++++++. This is predominantly a hot-fix release to add support for Scipy 1.5, due to changes in private sparse matrix functions that QuTiP also used. Improvements; ------------; - Add support for Scipy 1.5. (by **Jake Lishman**); - Improved speed of ``zcsr_inner``, which affects ``Qobj.overlap``. (by **Jake Lishman**); - Better error messages when installation requirements are not satisfied. (by **Eric Gigure**). Bug Fixes; ---------; - Fix ``zcsr_proj`` acting on matrices with unsorted indices. (by **Jake Lishman**); - Fix errors in Milstein's heterodyne. (",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:84920,Deployability,install,installation,84920,"ing containers. (by **Jake Lishman**); - Fix coverage reporting on Travis. (by **Jake Lishman**); - Added a ``pyproject.toml`` file. (by **Simon Humpohl** and **Eric Gigure**); - Add doctests to documentation. (by **Sidhant Saraogi**); - Fix all warnings in the documentation build. (by **Jake Lishman**). Version 4.5.3 (February 19, 2021); +++++++++++++++++++++++++++++++++. This patch release adds support for Numpy 1.20, made necessary by changes to how array-like objects are handled. There are no other changes relative to version 4.5.2. Users building from source should ensure that they build against Numpy versions >= 1.16.6 and < 1.20 (not including 1.20 itself), but after that or for those installing from conda, an installation will support any current Numpy version >= 1.16.6. Improvements; ------------; - Add support for Numpy 1.20. QuTiP should be compiled against a version of Numpy ``>= 1.16.6`` and ``< 1.20`` (note: does _not_ include 1.20 itself), but such an installation is compatible with any modern version of Numpy. Source installations from ``pip`` understand this constraint. Version 4.5.2 (July 14, 2020); +++++++++++++++++++++++++++++. This is predominantly a hot-fix release to add support for Scipy 1.5, due to changes in private sparse matrix functions that QuTiP also used. Improvements; ------------; - Add support for Scipy 1.5. (by **Jake Lishman**); - Improved speed of ``zcsr_inner``, which affects ``Qobj.overlap``. (by **Jake Lishman**); - Better error messages when installation requirements are not satisfied. (by **Eric Gigure**). Bug Fixes; ---------; - Fix ``zcsr_proj`` acting on matrices with unsorted indices. (by **Jake Lishman**); - Fix errors in Milstein's heterodyne. (by **Eric Gigure**); - Fix datatype bug in ``qutip.lattice`` module. (by **Boxi Li**); - Fix issues with ``eigh`` on Mac when using OpenBLAS. (by **Eric Gigure**). Developer Changes; -----------------; - Converted more of the codebase to PEP 8.; - Fix several instances of u",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:84988,Deployability,install,installations,84988,". (by **Jake Lishman**); - Added a ``pyproject.toml`` file. (by **Simon Humpohl** and **Eric Gigure**); - Add doctests to documentation. (by **Sidhant Saraogi**); - Fix all warnings in the documentation build. (by **Jake Lishman**). Version 4.5.3 (February 19, 2021); +++++++++++++++++++++++++++++++++. This patch release adds support for Numpy 1.20, made necessary by changes to how array-like objects are handled. There are no other changes relative to version 4.5.2. Users building from source should ensure that they build against Numpy versions >= 1.16.6 and < 1.20 (not including 1.20 itself), but after that or for those installing from conda, an installation will support any current Numpy version >= 1.16.6. Improvements; ------------; - Add support for Numpy 1.20. QuTiP should be compiled against a version of Numpy ``>= 1.16.6`` and ``< 1.20`` (note: does _not_ include 1.20 itself), but such an installation is compatible with any modern version of Numpy. Source installations from ``pip`` understand this constraint. Version 4.5.2 (July 14, 2020); +++++++++++++++++++++++++++++. This is predominantly a hot-fix release to add support for Scipy 1.5, due to changes in private sparse matrix functions that QuTiP also used. Improvements; ------------; - Add support for Scipy 1.5. (by **Jake Lishman**); - Improved speed of ``zcsr_inner``, which affects ``Qobj.overlap``. (by **Jake Lishman**); - Better error messages when installation requirements are not satisfied. (by **Eric Gigure**). Bug Fixes; ---------; - Fix ``zcsr_proj`` acting on matrices with unsorted indices. (by **Jake Lishman**); - Fix errors in Milstein's heterodyne. (by **Eric Gigure**); - Fix datatype bug in ``qutip.lattice`` module. (by **Boxi Li**); - Fix issues with ``eigh`` on Mac when using OpenBLAS. (by **Eric Gigure**). Developer Changes; -----------------; - Converted more of the codebase to PEP 8.; - Fix several instances of unsafe mutable default values and unsafe ``is`` comparisons. Version 4.5.1",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:85137,Deployability,release,release,85137,"mentation. (by **Sidhant Saraogi**); - Fix all warnings in the documentation build. (by **Jake Lishman**). Version 4.5.3 (February 19, 2021); +++++++++++++++++++++++++++++++++. This patch release adds support for Numpy 1.20, made necessary by changes to how array-like objects are handled. There are no other changes relative to version 4.5.2. Users building from source should ensure that they build against Numpy versions >= 1.16.6 and < 1.20 (not including 1.20 itself), but after that or for those installing from conda, an installation will support any current Numpy version >= 1.16.6. Improvements; ------------; - Add support for Numpy 1.20. QuTiP should be compiled against a version of Numpy ``>= 1.16.6`` and ``< 1.20`` (note: does _not_ include 1.20 itself), but such an installation is compatible with any modern version of Numpy. Source installations from ``pip`` understand this constraint. Version 4.5.2 (July 14, 2020); +++++++++++++++++++++++++++++. This is predominantly a hot-fix release to add support for Scipy 1.5, due to changes in private sparse matrix functions that QuTiP also used. Improvements; ------------; - Add support for Scipy 1.5. (by **Jake Lishman**); - Improved speed of ``zcsr_inner``, which affects ``Qobj.overlap``. (by **Jake Lishman**); - Better error messages when installation requirements are not satisfied. (by **Eric Gigure**). Bug Fixes; ---------; - Fix ``zcsr_proj`` acting on matrices with unsorted indices. (by **Jake Lishman**); - Fix errors in Milstein's heterodyne. (by **Eric Gigure**); - Fix datatype bug in ``qutip.lattice`` module. (by **Boxi Li**); - Fix issues with ``eigh`` on Mac when using OpenBLAS. (by **Eric Gigure**). Developer Changes; -----------------; - Converted more of the codebase to PEP 8.; - Fix several instances of unsafe mutable default values and unsafe ``is`` comparisons. Version 4.5.1 (May 15, 2020); ++++++++++++++++++++++++++++. Improvements; ------------; - ``husimi`` and ``wigner`` now accept half-integer ",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:85447,Deployability,install,installation,85447,"ther changes relative to version 4.5.2. Users building from source should ensure that they build against Numpy versions >= 1.16.6 and < 1.20 (not including 1.20 itself), but after that or for those installing from conda, an installation will support any current Numpy version >= 1.16.6. Improvements; ------------; - Add support for Numpy 1.20. QuTiP should be compiled against a version of Numpy ``>= 1.16.6`` and ``< 1.20`` (note: does _not_ include 1.20 itself), but such an installation is compatible with any modern version of Numpy. Source installations from ``pip`` understand this constraint. Version 4.5.2 (July 14, 2020); +++++++++++++++++++++++++++++. This is predominantly a hot-fix release to add support for Scipy 1.5, due to changes in private sparse matrix functions that QuTiP also used. Improvements; ------------; - Add support for Scipy 1.5. (by **Jake Lishman**); - Improved speed of ``zcsr_inner``, which affects ``Qobj.overlap``. (by **Jake Lishman**); - Better error messages when installation requirements are not satisfied. (by **Eric Gigure**). Bug Fixes; ---------; - Fix ``zcsr_proj`` acting on matrices with unsorted indices. (by **Jake Lishman**); - Fix errors in Milstein's heterodyne. (by **Eric Gigure**); - Fix datatype bug in ``qutip.lattice`` module. (by **Boxi Li**); - Fix issues with ``eigh`` on Mac when using OpenBLAS. (by **Eric Gigure**). Developer Changes; -----------------; - Converted more of the codebase to PEP 8.; - Fix several instances of unsafe mutable default values and unsafe ``is`` comparisons. Version 4.5.1 (May 15, 2020); ++++++++++++++++++++++++++++. Improvements; ------------; - ``husimi`` and ``wigner`` now accept half-integer spin (by **maij**); - Better error messages for failed string coefficient compilation. (issue raised by **nohchangsuk**). Bug Fixes; ---------; - Safer naming for temporary files. (by **Eric Gigure**); - Fix ``clebsch`` function for half-integer (by **Thomas Walker**); - Fix ``randint``'s dtype to ``uin",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:93590,Deployability,configurat,configuration,93590,"bits to 30 Qbits. - QIP module: added the possibility for user-defined gates, added the possibility to remove or add gates in any point of an already built circuit, added the molmer_sorensen gate, and fixed some bugs (by **Boxi Li**). - Added the quantum Hellinger distance to qutip.metrics (by **Wojciech Rzadkowski**). - Implemented possibility of choosing a random seed (by **Marek Marekyggdrasil**). - Added a code of conduct to Github. Bug Fixes; ---------. - Fixed bug that made QuTiP incompatible with SciPy 1.3. Version 4.3.0 (July 14, 2018); +++++++++++++++++++++++++++++. Improvements; ------------. - **MAJOR FEATURE**: Added the Permutational Invariant Quantum Solver (PIQS) module (by **Nathan Shammah** and **Shahnawaz Ahmed**) which allows the simluation of large TLSs ensembles including collective and local Lindblad dissipation. Applications range from superradiance to spin squeezing. - **MAJOR FEATURE**: Added a photon scattering module (by **Ben Bartlett**) which can be used to study scattering in arbitrary driven systems coupled to some configuration of output waveguides. - Cubic_Spline functions as time-dependent arguments for the collapse operators in mesolve are now allowed. - Added a faster version of bloch_redfield_tensor, using components from the time-dependent version. About 3x+ faster for secular tensors, and 10x+ faster for non-secular tensors. - Computing Q.overlap() [inner product] is now ~30x faster. - Added projector method to Qobj class. - Added fast projector method, ``Q.proj()``. - Computing matrix elements, ``Q.matrix_element`` is now ~10x faster. - Computing expectation values for ket vectors using ``expect`` is now ~10x faster. - ``Q.tr()`` is now faster for small Hilbert space dimensions. - Unitary operator evolution added to sesolve. - Use OPENMP for tidyup if installed. Bug Fixes; ---------. - Fixed bug that stopped simdiag working for python 3. - Fixed semidefinite cvxpy Variable and Parameter. - Fixed iterative lu solve atol keyword",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:94350,Deployability,install,installed,94350,"e and local Lindblad dissipation. Applications range from superradiance to spin squeezing. - **MAJOR FEATURE**: Added a photon scattering module (by **Ben Bartlett**) which can be used to study scattering in arbitrary driven systems coupled to some configuration of output waveguides. - Cubic_Spline functions as time-dependent arguments for the collapse operators in mesolve are now allowed. - Added a faster version of bloch_redfield_tensor, using components from the time-dependent version. About 3x+ faster for secular tensors, and 10x+ faster for non-secular tensors. - Computing Q.overlap() [inner product] is now ~30x faster. - Added projector method to Qobj class. - Added fast projector method, ``Q.proj()``. - Computing matrix elements, ``Q.matrix_element`` is now ~10x faster. - Computing expectation values for ket vectors using ``expect`` is now ~10x faster. - ``Q.tr()`` is now faster for small Hilbert space dimensions. - Unitary operator evolution added to sesolve. - Use OPENMP for tidyup if installed. Bug Fixes; ---------. - Fixed bug that stopped simdiag working for python 3. - Fixed semidefinite cvxpy Variable and Parameter. - Fixed iterative lu solve atol keyword issue. - Fixed unitary op evolution rhs matrix in ssesolve. - Fixed interpolating function to return zero outside range. - Fixed dnorm complex casting bug. - Fixed control.io path checking issue. - Fixed ENR fock dimension. - Fixed hard coded options in propagator 'batch' mode. - Fixed bug in trace-norm for non-Hermitian operators. - Fixed bug related to args not being passed to coherence_function_g2. - Fixed MKL error checking dict key error. Version 4.2.0 (July 28, 2017); +++++++++++++++++++++++++++++. Improvements; ------------. - **MAJOR FEATURE**: Initial implementation of time-dependent Bloch-Redfield Solver. - Qobj tidyup is now an order of magnitude faster. - Time-dependent codegen now generates output NumPy arrays faster. - Improved calculation for analytic coefficients in coherent states (Se",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:98083,Deployability,release,released,98083,"nd inf norms. Bug Fixes; ---------. - Cleanup of temp. Cython files now more robust and working under Windows. Version 4.0.2 (January 5, 2017); +++++++++++++++++++++++++++++++. Bug Fixes; ---------; - td files no longer left behind by correlation tests; - Various fast sparse fixes. Version 4.0.0 (December 22, 2016); +++++++++++++++++++++++++++++++++. Improvements; ------------; *Core libraries*. - **MAJOR FEATURE**: Fast sparse: New subclass of csr_matrix added that overrides commonly used methods to avoid certain checks that incurr execution cost. All Qobj.data now fast_csr_matrix; - HEOM performance enhancements; - spmv now faster; - mcsolve codegen further optimised. *Control modules*. - Time dependent drift (through list of pwc dynamics generators); - memory optimisation options provided for control.dynamics. Bug Fixes; ---------. - recompilation of pyx files on first import removed; - tau array in control.pulseoptim funcs now works. Version 3.2.0 (Never officially released); +++++++++++++++++++++++++++++++++++++++++. New Features; ------------. *Core libraries*. - **MAJOR FEATURE**: Non-Markovian solvers: Hierarchy (**Added by Neill Lambert**), Memory-Cascade, and Transfer-Tensor methods.; - **MAJOR FEATURE**: Default steady state solver now up to 100x faster using the Intel Pardiso library under the Anaconda and Intel Python distributions.; - The default Wigner function now uses a Clenshaw summation algorithm to evaluate a polynomial series that is applicable for any number of exciations (previous limitation was ~50 quanta), and is ~3x faster than before. (**Added by Denis Vasilyev**); - Can now define a given eigen spectrum for random Hermitian and density operators.; - The Qobj ``expm`` method now uses the equivilent SciPy routine, and performs a much faster ``exp`` operation if the matrix is diagonal.; - One can now build zero operators using the ``qzero`` function. *Control modules*. - **MAJOR FEATURE**: CRAB algorithm added; This is an alternative to the G",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:100345,Deployability,configurat,configuration,100345,"isation.; See tutorial notebook for full information. Improvements; ------------; *Core libraries*. - Two-time correlation functions can now be calculated for fully time-dependent Hamiltonians and collapse operators. (**Added by Kevin Fischer**); - The code for the inverse-power method for the steady state solver has been simplified.; - Bloch-Redfield tensor creation is now up to an order of magnitude faster. (**Added by Johannes Feist**); - Q.transform now works properly for arrays directly from sp_eigs (or eig).; - Q.groundstate now checks for degeneracy.; - Added ``sinm`` and ``cosm`` methods to the Qobj class.; - Added ``charge`` and ``tunneling`` operators.; - Time-dependent Cython code is now easier to read and debug. *Control modules*. - The internal state / quantum operator data type can now be either Qobj or ndarray; Previous only ndarray was possible. This now opens up possibility of using Qobj methods in fidelity calculations; The attributes and functions that return these operators are now preceded by an underscore, to indicate that the data type could change depending on the configuration options.; In most cases these functions were for internal processing only anyway, and should have been 'private'.; Accessors to the properties that could be useful outside of the library have been added. These always return Qobj. If the internal operator data type is not Qobj, then there could be signicant overhead in the conversion, and so this should be avoided during pulse optimisation.; If custom sub-classes are developed that use Qobj properties and methods (e.g. partial trace), then it is very likely that it will be more efficient to set the internal data type to Qobj.; The internal operator data will be chosen automatically based on the size and sparsity of the dynamics generator. It can be forced by setting ``dynamics.oper_dtype = <type>``; Note this can be done by passing ``dyn_params={'oper_dtype':<type>}`` in any of the pulseoptim functions. Some other prope",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:105299,Deployability,integrat,integration,105299,"-----------. - **MAJOR FEATURE**: New module for quantum control (qutip.control).; - **NAMESPACE CHANGE**: QuTiP no longer exports symbols from NumPy and matplotlib, so those modules must now be explicitly imported when required.; - New module for counting statistics.; - Stochastic solvers now run trajectories in parallel.; - New superoperator and tensor manipulation functions; (super_tensor, composite, tensor_contract).; - New logging module for debugging (qutip.logging).; - New user-available API for parallelization (parallel_map).; - New enhanced (optional) text-based progressbar (qutip.ui.EnhancedTextProgressBar); - Faster Python based monte carlo solver (mcsolve).; - Support for progress bars in propagator function.; - Time-dependent Cython code now calls complex cmath functions.; - Random numbers seeds can now be reused for successive calls to mcsolve.; - The Bloch-Redfield master equation solver now supports optional Lindblad type collapse operators.; - Improved handling of ODE integration errors in mesolve.; - Improved correlation function module (for example, improved support for time-dependent problems).; - Improved parallelization of mcsolve (can now be interrupted easily, support for IPython.parallel, etc.); - Many performance improvements, and much internal code restructuring. Bug Fixes; ---------. - Cython build files for time-dependent string format now removed automatically.; - Fixed incorrect solution time from inverse-power method steady state solver.; - mcsolve now supports `Options(store_states=True)`; - Fixed bug in `hadamard` gate function.; - Fixed compatibility issues with NumPy 1.9.0.; - Progressbar in mcsolve can now be suppressed.; - Fixed bug in `gate_expand_3toN`.; - Fixed bug for time-dependent problem (list string format) with multiple terms in coefficient to an operator. Version 3.0.1 (Aug 5, 2014); +++++++++++++++++++++++++++. Bug Fixes; ---------. - Fix bug in create(), which returned a Qobj with CSC data instead of CSR.; - Fix sever",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:111195,Deployability,continuous,continuous,111195,"ple can be used for solving; master equations with mean field terms. Improvements; ------------. - Restructured and optimized implementation of Qobj, which now has; significantly lower memory footprint due to avoiding excessive copying of; internal matrix data. - The classes ``OdeData``, ``Odeoptions``, ``Odeconfig`` are now called; ``Result``, ``Options``, and ``Config``, respectively, and are available in; the module `qutip.solver`. - The ``squeez`` function has been renamed to ``squeeze``. - Better support for sparse matrices when calculating propagators using the; ``propagator`` function. - Improved Bloch sphere. - Restructured and improved the module ``qutip.sparse``, which now only; operates directly on sparse matrices (not on Qobj instances). - Improved and simplified implement of the ``tensor`` function. - Improved performance, major code cleanup (including namespace changes),; and numerous bug fixes. - Benchmark scripts improved and restructured. - QuTiP is now using continuous integration tests (TravisCI). Version 2.2.0 (March 01, 2013); ++++++++++++++++++++++++++++++. New Features; ------------. - **Added Support for Windows**. - New Bloch3d class for plotting 3D Bloch spheres using Mayavi. - Bloch sphere vectors now look like arrows. - Partial transpose function. - Continuos variable functions for calculating correlation and covariance; matrices, the Wigner covariance matrix and the logarithmic negativity for; for multimode fields in Fock basis. - The master-equation solver (mesolve) now accepts pre-constructed Liouvillian; terms, which makes it possible to solve master equations that are not on; the standard Lindblad form. - Optional Fortran Monte Carlo solver (mcsolve_f90) by Arne Grimsmo. - A module of tools for using QuTiP in IPython notebooks. - Increased performance of the steady state solver. - New Wigner colormap for highlighting negative values. - More graph styles to the visualization module. Bug Fixes; ---------. - Function based time-dependen",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:111206,Deployability,integrat,integration,111206,"ple can be used for solving; master equations with mean field terms. Improvements; ------------. - Restructured and optimized implementation of Qobj, which now has; significantly lower memory footprint due to avoiding excessive copying of; internal matrix data. - The classes ``OdeData``, ``Odeoptions``, ``Odeconfig`` are now called; ``Result``, ``Options``, and ``Config``, respectively, and are available in; the module `qutip.solver`. - The ``squeez`` function has been renamed to ``squeeze``. - Better support for sparse matrices when calculating propagators using the; ``propagator`` function. - Improved Bloch sphere. - Restructured and improved the module ``qutip.sparse``, which now only; operates directly on sparse matrices (not on Qobj instances). - Improved and simplified implement of the ``tensor`` function. - Improved performance, major code cleanup (including namespace changes),; and numerous bug fixes. - Benchmark scripts improved and restructured. - QuTiP is now using continuous integration tests (TravisCI). Version 2.2.0 (March 01, 2013); ++++++++++++++++++++++++++++++. New Features; ------------. - **Added Support for Windows**. - New Bloch3d class for plotting 3D Bloch spheres using Mayavi. - Bloch sphere vectors now look like arrows. - Partial transpose function. - Continuos variable functions for calculating correlation and covariance; matrices, the Wigner covariance matrix and the logarithmic negativity for; for multimode fields in Fock basis. - The master-equation solver (mesolve) now accepts pre-constructed Liouvillian; terms, which makes it possible to solve master equations that are not on; the standard Lindblad form. - Optional Fortran Monte Carlo solver (mcsolve_f90) by Arne Grimsmo. - A module of tools for using QuTiP in IPython notebooks. - Increased performance of the steady state solver. - New Wigner colormap for highlighting negative values. - More graph styles to the visualization module. Bug Fixes; ---------. - Function based time-dependen",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:112614,Deployability,install,installation,112614,"ovariance matrix and the logarithmic negativity for; for multimode fields in Fock basis. - The master-equation solver (mesolve) now accepts pre-constructed Liouvillian; terms, which makes it possible to solve master equations that are not on; the standard Lindblad form. - Optional Fortran Monte Carlo solver (mcsolve_f90) by Arne Grimsmo. - A module of tools for using QuTiP in IPython notebooks. - Increased performance of the steady state solver. - New Wigner colormap for highlighting negative values. - More graph styles to the visualization module. Bug Fixes; ---------. - Function based time-dependent Hamiltonians now keep the correct phase. - mcsolve no longer prints to the command line if ntraj=1. Version 2.1.0 (October 05, 2012); ++++++++++++++++++++++++++++++++. New Features; ------------. - New method for generating Wigner functions based on Laguerre polynomials. - coherent(), coherent_dm(), and thermal_dm() can now be expressed using analytic values. - Unittests now use nose and can be run after installation. - Added iswap and sqrt-iswap gates. - Functions for quantum process tomography. - Window icons are now set for Ubuntu application launcher. - The propagator function can now take a list of times as argument, and returns a list of corresponding propagators. Bug Fixes; ---------. - mesolver now correctly uses the user defined rhs_filename in Odeoptions(). - rhs_generate() now handles user defined filenames properly. - Density matrix returned by propagator_steadystate is now Hermitian. - eseries_value returns real list if all imag parts are zero. - mcsolver now gives correct results for strong damping rates. - Odeoptions now prints mc_avg correctly. - Do not check for PyObj in mcsolve when gui=False. - Eseries now correctly handles purely complex rates. - thermal_dm() function now uses truncated operator method. - Cython based time-dependence now Python 3 compatible. - Removed call to NSAutoPool on mac systems. - Progress bar now displays the correct number ",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:114012,Deployability,release,release,114012," handles user defined filenames properly. - Density matrix returned by propagator_steadystate is now Hermitian. - eseries_value returns real list if all imag parts are zero. - mcsolver now gives correct results for strong damping rates. - Odeoptions now prints mc_avg correctly. - Do not check for PyObj in mcsolve when gui=False. - Eseries now correctly handles purely complex rates. - thermal_dm() function now uses truncated operator method. - Cython based time-dependence now Python 3 compatible. - Removed call to NSAutoPool on mac systems. - Progress bar now displays the correct number of CPU's used. - Qobj.diag() returns reals if operator is Hermitian. - Text for progress bar on Linux systems is no longer cutoff. Version 2.0.0 (June 01, 2012); +++++++++++++++++++++++++++++. The second version of QuTiP has seen many improvements in the performance of the original code base, as well as the addition of several new routines supporting a wide range of functionality. Some of the highlights of this release include:. New Features; ------------. - QuTiP now includes solvers for both Floquet and Bloch-Redfield master equations. - The Lindblad master equation and Monte Carlo solvers allow for time-dependent collapse operators. - It is possible to automatically compile time-dependent problems into c-code using Cython (if installed). - Python functions can be used to create arbitrary time-dependent Hamiltonians and collapse operators. - Solvers now return Odedata objects containing all simulation results and parameters, simplifying the saving of simulation results. .. important:: This breaks compatibility with QuTiP version 1.x. - mesolve and mcsolve can reuse Hamiltonian data when only the initial state, or time-dependent arguments, need to be changed. - QuTiP includes functions for creating random quantum states and operators. - The generation and manipulation of quantum objects is now more efficient. - Quantum objects have basis transformation and matrix element calculations ",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:114336,Deployability,install,installed,114336,"heck for PyObj in mcsolve when gui=False. - Eseries now correctly handles purely complex rates. - thermal_dm() function now uses truncated operator method. - Cython based time-dependence now Python 3 compatible. - Removed call to NSAutoPool on mac systems. - Progress bar now displays the correct number of CPU's used. - Qobj.diag() returns reals if operator is Hermitian. - Text for progress bar on Linux systems is no longer cutoff. Version 2.0.0 (June 01, 2012); +++++++++++++++++++++++++++++. The second version of QuTiP has seen many improvements in the performance of the original code base, as well as the addition of several new routines supporting a wide range of functionality. Some of the highlights of this release include:. New Features; ------------. - QuTiP now includes solvers for both Floquet and Bloch-Redfield master equations. - The Lindblad master equation and Monte Carlo solvers allow for time-dependent collapse operators. - It is possible to automatically compile time-dependent problems into c-code using Cython (if installed). - Python functions can be used to create arbitrary time-dependent Hamiltonians and collapse operators. - Solvers now return Odedata objects containing all simulation results and parameters, simplifying the saving of simulation results. .. important:: This breaks compatibility with QuTiP version 1.x. - mesolve and mcsolve can reuse Hamiltonian data when only the initial state, or time-dependent arguments, need to be changed. - QuTiP includes functions for creating random quantum states and operators. - The generation and manipulation of quantum objects is now more efficient. - Quantum objects have basis transformation and matrix element calculations as built-in methods. - The quantum object eigensolver can use sparse solvers. - The partial-trace (ptrace) function is up to 20x faster. - The Bloch sphere can now be used with the Matplotlib animation function, and embedded as a subplot in a figure. - QuTiP has built-in functions for sav",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:115907,Deployability,install,installation,115907,"tion of quantum objects is now more efficient. - Quantum objects have basis transformation and matrix element calculations as built-in methods. - The quantum object eigensolver can use sparse solvers. - The partial-trace (ptrace) function is up to 20x faster. - The Bloch sphere can now be used with the Matplotlib animation function, and embedded as a subplot in a figure. - QuTiP has built-in functions for saving quantum objects and data arrays. - The steady-state solver has been further optimized for sparse matrices, and can handle much larger system Hamiltonians. - The steady-state solver can use the iterative bi-conjugate gradient method instead of a direct solver. - There are three new entropy functions for concurrence, mutual information, and conditional entropy. - Correlation functions have been combined under a single function. - The operator norm can now be set to trace, Frobius, one, or max norm. - Global QuTiP settings can now be modified. - QuTiP includes a collection of unit tests for verifying the installation. - Demos window now lets you copy and paste code from each example. Version 1.1.4 (May 28, 2012); ++++++++++++++++++++++++++++. Bug Fixes; ---------. - Fixed bug pointed out by Brendan Abolins. - Qobj.tr() returns zero-dim ndarray instead of float or complex. - Updated factorial import for scipy version 0.10+. Version 1.1.3 (November 21, 2011); +++++++++++++++++++++++++++++++++. New Functions; -------------. - Allow custom naming of Bloch sphere. Bug Fixes; ---------; - Fixed text alignment issues in AboutBox. - Added fix for SciPy V>0.10 where factorial was moved to scipy.misc module. - Added tidyup function to tensor function output. - Removed openmp flags from setup.py as new Mac Xcode compiler does not recognize them. - Qobj diag method now returns real array if all imaginary parts are zero. - Examples GUI now links to new documentation. - Fixed zero-dimensional array output from metrics module. Version 1.1.2 (October 27, 2011); +++++++++++++++",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:118562,Deployability,release,release,118562,"openmp flags from setup.py as new Mac Xcode compiler does not recognize them. - Qobj diag method now returns real array if all imaginary parts are zero. - Examples GUI now links to new documentation. - Fixed zero-dimensional array output from metrics module. Version 1.1.2 (October 27, 2011); ++++++++++++++++++++++++++++++++. Bug Fixes; ---------. - Fixed issue where Monte Carlo states were not output properly. Version 1.1.1 (October 25, 2011); ++++++++++++++++++++++++++++++++. **THIS POINT-RELEASE INCLUDES VASTLY IMPROVED TIME-INDEPENDENT MCSOLVE AND ODESOLVE PERFORMANCE**. New Functions; -------------. - Added linear entropy function. - Number of CPU's can now be changed. Bug Fixes; ---------. - Metrics no longer use dense matrices. - Fixed Bloch sphere grid issue with matplotlib 1.1. - Qobj trace operation uses only sparse matrices. - Fixed issue where GUI windows do not raise to front. Version 1.1.0 (October 04, 2011); ++++++++++++++++++++++++++++++++. **THIS RELEASE NOW REQUIRES THE GCC COMPILER TO BE INSTALLED**. New Functions; -------------. - tidyup function to remove small elements from a Qobj. - Added concurrence function. - Added simdiag for simultaneous diagonalization of operators. - Added eigenstates method returning eigenstates and eigenvalues to Qobj class. - Added fileio for saving and loading data sets and/or Qobj's. - Added hinton function for visualizing density matrices. Bug Fixes; ---------. - Switched Examples to new Signals method used in PySide 1.0.6+. - Switched ProgressBar to new Signals method. - Fixed memory issue in expm functions. - Fixed memory bug in isherm. - Made all Qobj data complex by default. - Reduced ODE tolerance levels in Odeoptions. - Fixed bug in ptrace where dense matrix was used instead of sparse. - Fixed issue where PyQt4 version would not be displayed in about box. - Fixed issue in Wigner where xvec was used twice (in place of yvec). Version 1.0.0 (July 29, 2011); +++++++++++++++++++++++++++++. - **Initial release.**; ",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:5388,Energy Efficiency,reduce,reduced,5388,"tal data layers backends were written either as part of Google Summer; of Code or as separate projects. While these are still alpha quality, they helped; significantly to test the data layer API:. - ``qutip-tensorflow``: a TensorFlow backend by Asier Galicia (`<https://github.com/qutip/qutip-tensorflow>`); - ``qutip-cupy``: a CuPy GPU backend by Felipe Bivort Haiek (`<https://github.com/qutip/qutip-cupy/>`)`; - ``qutip-tensornetwork``: a TensorNetwork backend by Asier Galicia (`<https://github.com/qutip/qutip-tensornetwork>`); - ``qutip-jax``: a JAX backend by Eric Gigure (`<https://github.com/qutip/qutip-jax/>`). Finally, Yuji Tamakoshi updated the visualization function and added animation; functions as part of Google Summer of Code project. We have also had many other contributors, whose specific contributions are; detailed below:. - Pieter Eendebak (updated the required SciPy to 1.5+, `#1982 <https://github.com/qutip/qutip/pull/1982>`).; - Pieter Eendebak (reduced import times by setting logger names, `#1981 <https://github.com/qutip/qutip/pull/1981>`); - Pieter Eendebak (Allow scipy 1.12 to be used with qutip, `#2354 <https://github.com/qutip/qutip/pull/2354>`); - Xavier Sproken (included C header files in the source distribution, `#1971 <https://github.com/qutip/qutip/pull/1971>`); - Christian Staufenbiel (added support for multiple collapse operators to the Floquet solver, `#1962 <https://github.com/qutip/qutip/pull/1962>`); - Christian Staufenbiel (fixed the basis used in the Floquet Master Equation solver, `#1952 <https://github.com/qutip/qutip/pull/1952>`); - Christian Staufenbiel (allowed the ``bloch_redfield_tensor`` function to accept strings and callables for `a_ops`, `#1951 <https://github.com/qutip/qutip/pull/1951>`); - Christian Staufenbiel (Add a guide on Superoperators, Pauli Basis and Channel Contraction, `#1984 <https://github.com/qutip/qutip/pull/1984>`); - Henrique Silvro (allowed ``qutip_qip`` to be imported as ``qutip.qip``, `#1920 <https:",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:15379,Energy Efficiency,efficient,efficient,15379,"he class allows a solver to be run multiple times for the; same system without having to repeatedly reconstruct the; right-hand side of the ODE to be integrated.; - A ``QobjEvo`` instance is accepted for most operators, e.g.,; ``H``, ``c_ops``, ``e_ops``, ``a_ops``.; - The progress bar is now selected using the ``progress_bar`` option.; A new progess bar using the ``tqdm`` Python library is provided.; - Dynamic arguments, where the value of an operator depends on; the current state of the evolution interface reworked. Now a property of the; solver is to be used as an arguments:; ``args={""state"": MESolver.StateFeedback(default=rho0)}``. Integrators:. - The SciPy zvode integrator is available with the BDF and; Adams methods as ``bdf`` and ``adams``.; - The SciPy dop853 integrator (an eighth order Runge-Kutta method by; Dormand & Prince) is available as ``dop853``.; - The SciPy lsoda integrator is available as ``lsoda``.; - QuTiP's own implementation of Verner's ""most efficient"" Runge-Kutta methods; of order 7 and 9 are available as ``vern7`` and ``vern9``. See; http://people.math.sfu.ca/~jverner/ for a description of the methods.; - QuTiP's own implementation of a solver that directly diagonalizes the; the system to be integrated is available as ``diag``. It only works on; time-independent systems and is slow to setup, but once the diagonalization; is complete, it generates solutions very quickly.; - QuTiP's own implementatoin of an approximate Krylov subspace integrator is; available as ``krylov``. This integrator is only usable with ``sesolve``. Result class:. - A new ``.e_data`` attribute provides expectation values as a dictionary.; Unlike ``.expect``, the values are provided in a Python list rather than; a numpy array, which better supports non-numeric types.; - The contents of the ``.stats`` attribute changed significantly and is; now more consistent across solvers. Monte-Carlo Solver (mcsolve):. - The system, H, may now be a super-operator.; - The ``seed`` param",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:35979,Energy Efficiency,reduce,reduced,35979,"om/qutip/qutip-tutorials/>`).; - Xavier Sproken update the benchmarks (`<https://github.com/qutip/qutip-benchmark/>`). Four experimental data layers backends were written either as part of Google Summer; of Code or as separate projects. While these are still alpha quality, the helped; significantly to test the data layer API:. - ``qutip-tensorflow``: a TensorFlow backend by Asier Galicia (`<https://github.com/qutip/qutip-tensorflow>`); - ``qutip-cupy``: a CuPy GPU backend by Felipe Bivort Haiek (`<https://github.com/qutip/qutip-cupy/>`)`; - ``qutip-tensornetwork``: a TensorNetwork backend by Asier Galicia (`<https://github.com/qutip/qutip-tensornetwork>`); - ``qutip-jax``: a JAX backend by Eric Gigure (`<https://github.com/qutip/qutip-jax/>`). We have also had many other contributors, whose specific contributions are; detailed below:. - Pieter Eendebak (updated the required SciPy to 1.4+, `#1982 <https://github.com/qutip/qutip/pull/1982>`).; - Pieter Eendebak (reduced import times by setting logger names, `#1981 <https://github.com/qutip/qutip/pull/1981>`); - Xavier Sproken (included C header files in the source distribution, `#1971 <https://github.com/qutip/qutip/pull/1971>`); - Christian Staufenbiel (added support for multiple collapse operators to the Floquet solver, `#1962 <https://github.com/qutip/qutip/pull/1962>`); - Christian Staufenbiel (fixed the basis used in the Floquet Master Equation solver, `#1952 <https://github.com/qutip/qutip/pull/1952>`); - Christian Staufenbiel (allowed the ``bloch_redfield_tensor`` function to accept strings and callables for `a_ops`, `#1951 <https://github.com/qutip/qutip/pull/1951>`); - Henrique Silvro (allowed ``qutip_qip`` to be imported as ``qutip.qip``, `#1920 <https://github.com/qutip/qutip/pull/1920>`); - Florian Hopfmueller (added a vastly improved implementations of ``process_fidelity`` and ``average_gate_fidelity``, `#1712 <https://github.com/qutip/qutip/pull/1712>`, `#1748 <https://github.com/qutip/qutip/pull/1748>",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:42076,Energy Efficiency,efficient,efficient,42076,"er provides a class interface. Creating an instance; of the class allows a solver to be run multiple times for the; same system without having to repeatedly reconstruct the; right-hand side of the ODE to be integrated.; - A ``QobjEvo`` instance is accepted for most operators, e.g.,; ``H``, ``c_ops``, ``e_ops``, ``a_ops``.; - The progress bar is now selected using the ``progress_bar`` option.; A new progess bar using the ``tqdm`` Python library is provided.; - Dynamic arguments, where the value of an operator depends on; the current state of the evolution, have been removed. They; may be re-implemented later if there is demand for them. Integrators:. - The SciPy zvode integrator is available with the BDF and; Adams methods as ``bdf`` and ``adams``.; - The SciPy dop853 integrator (an eighth order Runge-Kutta method by; Dormand & Prince) is available as ``dop853``.; - The SciPy lsoda integrator is available as ``lsoda``.; - QuTiP's own implementation of Verner's ""most efficient"" Runge-Kutta methods; of order 7 and 9 are available as ``vern7`` and ``vern9``. See; http://people.math.sfu.ca/~jverner/ for a description of the methods.; - QuTiP's own implementation of a solver that directly diagonalizes the; the system to be integrated is available as ``diag``. It only works on; time-independent systems and is slow to setup, but once the diagonalization; is complete, it generates solutions very quickly.; - QuTiP's own implementatoin of an approximate Krylov subspace integrator is; available as ``krylov``. This integrator is only usable with ``sesolve``. Result class:. - A new ``.e_data`` attribute provides expectation values as a dictionary.; Unlike ``.expect``, the values are provided in a Python list rather than; a numpy array, which better supports non-numeric types.; - The contents of the ``.stats`` attribute changed significantly and is; now more consistent across solvers. Monte-Carlo Solver (mcsolve):. - The system, H, may now be a super-operator.; - The ``seed`` param",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:53893,Energy Efficiency,adapt,adaptive,53893,"and passing through of sc_ops to photocurrent solver. (#2081 by Bogdan Reznychenko and Simon Cross); - Update calls to SciPy eigvalsh and eigsh to pass the range of eigenvalues to return using ``subset_by_index=``. (#2081 by Simon Cross); - Fixed bug where some matrices were wrongly found to be hermitian. (#2082 by AGaliciaMartinez). Miscellaneous; -------------; - Fixed typo in stochastic.py (#2049, by eltociear); - `ptrace` always return density matrix (#2185, issue by udevd); - `mesolve` can support mixed callable and Qobj for `e_ops` (#2184 issue by balopat). Version 4.7.1 (December 11, 2022); +++++++++++++++++++++++++++++++++. This is a bugfix release for QuTiP 4.7.X. In addition to the minor fixes; listed below, the release adds builds for Python 3.11 and support for; packaging 22.0. Features; --------; - Improve qutip import times by setting logger names explicitly. (#1980). Bug Fixes; ---------; - Change floquet_master_equation_rates(...) to use an adaptive number of time steps scaled by the number of sidebands, kmax. (#1961); - Change fidelity(A, B) to use the reduced fidelity formula for pure states which is more numerically efficient and accurate. (#1964); - Change ``brmesolve`` to raise an exception when ode integration is not successful. (#1965); - Backport fix for IPython helper Bloch._repr_svg_ from dev.major. Previously the print_figure function returned bytes, but since ipython/ipython#5452 (in 2014) it returns a Unicode string. This fix updates QuTiP's helper to match. (#1970); - Fix correlation for case where only the collapse operators are time dependent. (#1979); - Fix the hinton visualization method to plot the matrix instead of its transpose. (#2011); - Fix the hinton visualization method to take into account all the matrix coefficients to set the squares scale, instead of only the diagonal coefficients. (#2012); - Fix parsing of package versions in setup.py to support packaging 22.0. (#2037); - Add back .qu suffix to objects saved with qsave ",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:54008,Energy Efficiency,reduce,reduced,54008,"e calls to SciPy eigvalsh and eigsh to pass the range of eigenvalues to return using ``subset_by_index=``. (#2081 by Simon Cross); - Fixed bug where some matrices were wrongly found to be hermitian. (#2082 by AGaliciaMartinez). Miscellaneous; -------------; - Fixed typo in stochastic.py (#2049, by eltociear); - `ptrace` always return density matrix (#2185, issue by udevd); - `mesolve` can support mixed callable and Qobj for `e_ops` (#2184 issue by balopat). Version 4.7.1 (December 11, 2022); +++++++++++++++++++++++++++++++++. This is a bugfix release for QuTiP 4.7.X. In addition to the minor fixes; listed below, the release adds builds for Python 3.11 and support for; packaging 22.0. Features; --------; - Improve qutip import times by setting logger names explicitly. (#1980). Bug Fixes; ---------; - Change floquet_master_equation_rates(...) to use an adaptive number of time steps scaled by the number of sidebands, kmax. (#1961); - Change fidelity(A, B) to use the reduced fidelity formula for pure states which is more numerically efficient and accurate. (#1964); - Change ``brmesolve`` to raise an exception when ode integration is not successful. (#1965); - Backport fix for IPython helper Bloch._repr_svg_ from dev.major. Previously the print_figure function returned bytes, but since ipython/ipython#5452 (in 2014) it returns a Unicode string. This fix updates QuTiP's helper to match. (#1970); - Fix correlation for case where only the collapse operators are time dependent. (#1979); - Fix the hinton visualization method to plot the matrix instead of its transpose. (#2011); - Fix the hinton visualization method to take into account all the matrix coefficients to set the squares scale, instead of only the diagonal coefficients. (#2012); - Fix parsing of package versions in setup.py to support packaging 22.0. (#2037); - Add back .qu suffix to objects saved with qsave and loaded with qload. The suffix was accidentally removed in QuTiP 4.7.0. (#2038); - Add a default max_step ",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:54075,Energy Efficiency,efficient,efficient,54075,"e calls to SciPy eigvalsh and eigsh to pass the range of eigenvalues to return using ``subset_by_index=``. (#2081 by Simon Cross); - Fixed bug where some matrices were wrongly found to be hermitian. (#2082 by AGaliciaMartinez). Miscellaneous; -------------; - Fixed typo in stochastic.py (#2049, by eltociear); - `ptrace` always return density matrix (#2185, issue by udevd); - `mesolve` can support mixed callable and Qobj for `e_ops` (#2184 issue by balopat). Version 4.7.1 (December 11, 2022); +++++++++++++++++++++++++++++++++. This is a bugfix release for QuTiP 4.7.X. In addition to the minor fixes; listed below, the release adds builds for Python 3.11 and support for; packaging 22.0. Features; --------; - Improve qutip import times by setting logger names explicitly. (#1980). Bug Fixes; ---------; - Change floquet_master_equation_rates(...) to use an adaptive number of time steps scaled by the number of sidebands, kmax. (#1961); - Change fidelity(A, B) to use the reduced fidelity formula for pure states which is more numerically efficient and accurate. (#1964); - Change ``brmesolve`` to raise an exception when ode integration is not successful. (#1965); - Backport fix for IPython helper Bloch._repr_svg_ from dev.major. Previously the print_figure function returned bytes, but since ipython/ipython#5452 (in 2014) it returns a Unicode string. This fix updates QuTiP's helper to match. (#1970); - Fix correlation for case where only the collapse operators are time dependent. (#1979); - Fix the hinton visualization method to plot the matrix instead of its transpose. (#2011); - Fix the hinton visualization method to take into account all the matrix coefficients to set the squares scale, instead of only the diagonal coefficients. (#2012); - Fix parsing of package versions in setup.py to support packaging 22.0. (#2037); - Add back .qu suffix to objects saved with qsave and loaded with qload. The suffix was accidentally removed in QuTiP 4.7.0. (#2038); - Add a default max_step ",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:68463,Energy Efficiency,power,power,68463,"continual source of blockers to importing ``qutip`` on new or changed platforms. A new check on the dimensions of ``Qobj``'s were added to prevent segmentation faults when invalid shape and dimension combinations were passed to Cython code. In addition, there were many small bugfixes, documentation improvements, and improvements to our building and testing processes. Improvements; ------------; - The ``enr_destroy`` function was made ~200x faster in many simple cases. (`#1593 <https://github.com/qutip/qutip/pull/1593>`_ by Johannes Feist); - The ``state_number_enumerate`` function was made significantly faster. (`#1594 <https://github.com/qutip/qutip/pull/1594>`_ by Johannes Feist); - Added the missing drift Hamiltonian to the method run_analytically of ``Processor``. (`#1603 <https://github.com/qutip/qutip/pull/1603>`_ Boxi Li); - The ``hadamard_transform`` was made much faster, e.g., ~70x faster for N=10. (`#1688 <https://github.com/qutip/qutip/pull/1688>`_ by Asier Galicia); - Added support for computing the power of a scalar-like Qobj. (`#1692 <https://github.com/qutip/qutip/pull/1692>`_ by Asier Galicia); - Removed the ``hardware_info`` module. This module wasn't used inside QuTiP and regularly broke when new operating systems were released, and in particular prevented importing QuTiP on the Apple M1. (`#1754 <https://github.com/qutip/qutip/pull/1754>`_, `#1758 <https://github.com/qutip/qutip/pull/1758>`_ by Eric Gigure). Bug Fixes; ---------; - Fixed support for calculating the propagator of a density matrix with collapse operators. QuTiP 4.6.2 introduced extra sanity checks on the dimensions of inputs to mesolve (Fix mesolve segfault with bad initial state `#1459 <https://github.com/qutip/qutip/pull/1459>`_), but the propagator function's calls to mesolve violated these checks by supplying initial states with the dimensions incorrectly set. ``propagator`` now calls mesolve with the correct dimensions set on the initial state. (`#1588 <https://github.com/quti",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:79323,Energy Efficiency,schedul,scheduler,79323,"full]`` pip install target so that ``pip install qutip[full]``; installs qutip and all of its optional and developer dependencies. Improvements; ------------; - Add the ``[full]`` pip install target (by **Jake Lishman**). Bug Fixes; ---------; - Work around pointer MKL eigh bug in SciPy <= 1.4 (by **Felipe Bivort Haiek**); - Fix berkeley, swapalpha and cz gate operations (by **Boxi Li**); - Expose the CPHASE control gate (by **Boxi Li**); - Fix building from the sdist when git is not installed (by **Jake Lishman**). Developer Changes; -----------------; - Move the qutip-doc documentation into the qutip repository (by **Jake Lishman**); - Fix warnings in documentation build (by **Jake Lishman**); - Fix warnings in pytest runs and make pytest treat warnings as errors (by **Jake Lishman**); - Add Simon Cross as author (by **Simon Cross**). Version 4.6.0 (April 11, 2021); ++++++++++++++++++++++++++++++. This release brings improvements for qubit circuits, including a pulse scheduler, measurement statistics, reading/writing OpenQASM and optimisations in the circuit simulations. This is the first release to have full binary wheel releases on pip; you can now do ``pip install qutip`` on almost any machine to get a correct version of the package without needing any compilers set up.; The support for Numpy 1.20 that was first added in QuTiP 4.5.3 is present in this version as well, and the same build considerations mentioned there apply here too.; If building using the now-supported PEP 517 mechanisms (e.g. ``python -mbuild /path/to/qutip``), all build dependencies will be correctly satisfied. Improvements; ------------; - **MAJOR** Add saving, loading and resetting functionality to ``qutip.settings`` for easy re-configuration. (by **Eric Gigure**); - **MAJOR** Add a quantum gate scheduler in ``qutip.qip.scheduler``, to help parallelise the operations of quantum gates. This supports two scheduling modes: as late as possible, and as soon as possible. (by **Boxi Li**); - **MAJ",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:80142,Energy Efficiency,schedul,scheduler,80142," Lishman**); - Add Simon Cross as author (by **Simon Cross**). Version 4.6.0 (April 11, 2021); ++++++++++++++++++++++++++++++. This release brings improvements for qubit circuits, including a pulse scheduler, measurement statistics, reading/writing OpenQASM and optimisations in the circuit simulations. This is the first release to have full binary wheel releases on pip; you can now do ``pip install qutip`` on almost any machine to get a correct version of the package without needing any compilers set up.; The support for Numpy 1.20 that was first added in QuTiP 4.5.3 is present in this version as well, and the same build considerations mentioned there apply here too.; If building using the now-supported PEP 517 mechanisms (e.g. ``python -mbuild /path/to/qutip``), all build dependencies will be correctly satisfied. Improvements; ------------; - **MAJOR** Add saving, loading and resetting functionality to ``qutip.settings`` for easy re-configuration. (by **Eric Gigure**); - **MAJOR** Add a quantum gate scheduler in ``qutip.qip.scheduler``, to help parallelise the operations of quantum gates. This supports two scheduling modes: as late as possible, and as soon as possible. (by **Boxi Li**); - **MAJOR** Improved qubit circuit simulators, including OpenQASM support and performance optimisations. (by **Sidhant Saraogi**); - **MAJOR** Add tools for quantum measurements and their statistics. (by **Simon Cross** and **Sidhant Saraogi**); - Add support for Numpy 1.20. QuTiP should be compiled against a version of Numpy ``>= 1.16.6`` and ``< 1.20`` (note: does _not_ include 1.20 itself), but such an installation is compatible with any modern version of Numpy. Source installations from ``pip`` understand this constraint.; - Improve the error message when circuit plotting fails. (by **Boxi Li**); - Add support for parsing M1 Mac hardware information. (by **Xiaoliang Wu**); - Add more single-qubit gates and controlled gates. (by **Mateo Laguna** and **Martn Sande Costa**); - Su",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:80167,Energy Efficiency,schedul,scheduler,80167,".0 (April 11, 2021); ++++++++++++++++++++++++++++++. This release brings improvements for qubit circuits, including a pulse scheduler, measurement statistics, reading/writing OpenQASM and optimisations in the circuit simulations. This is the first release to have full binary wheel releases on pip; you can now do ``pip install qutip`` on almost any machine to get a correct version of the package without needing any compilers set up.; The support for Numpy 1.20 that was first added in QuTiP 4.5.3 is present in this version as well, and the same build considerations mentioned there apply here too.; If building using the now-supported PEP 517 mechanisms (e.g. ``python -mbuild /path/to/qutip``), all build dependencies will be correctly satisfied. Improvements; ------------; - **MAJOR** Add saving, loading and resetting functionality to ``qutip.settings`` for easy re-configuration. (by **Eric Gigure**); - **MAJOR** Add a quantum gate scheduler in ``qutip.qip.scheduler``, to help parallelise the operations of quantum gates. This supports two scheduling modes: as late as possible, and as soon as possible. (by **Boxi Li**); - **MAJOR** Improved qubit circuit simulators, including OpenQASM support and performance optimisations. (by **Sidhant Saraogi**); - **MAJOR** Add tools for quantum measurements and their statistics. (by **Simon Cross** and **Sidhant Saraogi**); - Add support for Numpy 1.20. QuTiP should be compiled against a version of Numpy ``>= 1.16.6`` and ``< 1.20`` (note: does _not_ include 1.20 itself), but such an installation is compatible with any modern version of Numpy. Source installations from ``pip`` understand this constraint.; - Improve the error message when circuit plotting fails. (by **Boxi Li**); - Add support for parsing M1 Mac hardware information. (by **Xiaoliang Wu**); - Add more single-qubit gates and controlled gates. (by **Mateo Laguna** and **Martn Sande Costa**); - Support decomposition of ``X``, ``Y`` and ``Z`` gates in circuits. (by **Boxi",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:80251,Energy Efficiency,schedul,scheduling,80251,"mprovements for qubit circuits, including a pulse scheduler, measurement statistics, reading/writing OpenQASM and optimisations in the circuit simulations. This is the first release to have full binary wheel releases on pip; you can now do ``pip install qutip`` on almost any machine to get a correct version of the package without needing any compilers set up.; The support for Numpy 1.20 that was first added in QuTiP 4.5.3 is present in this version as well, and the same build considerations mentioned there apply here too.; If building using the now-supported PEP 517 mechanisms (e.g. ``python -mbuild /path/to/qutip``), all build dependencies will be correctly satisfied. Improvements; ------------; - **MAJOR** Add saving, loading and resetting functionality to ``qutip.settings`` for easy re-configuration. (by **Eric Gigure**); - **MAJOR** Add a quantum gate scheduler in ``qutip.qip.scheduler``, to help parallelise the operations of quantum gates. This supports two scheduling modes: as late as possible, and as soon as possible. (by **Boxi Li**); - **MAJOR** Improved qubit circuit simulators, including OpenQASM support and performance optimisations. (by **Sidhant Saraogi**); - **MAJOR** Add tools for quantum measurements and their statistics. (by **Simon Cross** and **Sidhant Saraogi**); - Add support for Numpy 1.20. QuTiP should be compiled against a version of Numpy ``>= 1.16.6`` and ``< 1.20`` (note: does _not_ include 1.20 itself), but such an installation is compatible with any modern version of Numpy. Source installations from ``pip`` understand this constraint.; - Improve the error message when circuit plotting fails. (by **Boxi Li**); - Add support for parsing M1 Mac hardware information. (by **Xiaoliang Wu**); - Add more single-qubit gates and controlled gates. (by **Mateo Laguna** and **Martn Sande Costa**); - Support decomposition of ``X``, ``Y`` and ``Z`` gates in circuits. (by **Boxi Li**); - Refactor ``QubitCircuit.resolve_gate()`` (by **Martn Sande Cos",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:91797,Energy Efficiency,efficient,efficiently,91797,"ven target cubits (by **Boxi Li**). Bug Fixes; ---------. - Fixed the pickling but that made solver unable to run in parallel on Windows (Thank **lrunze** for reporting). - Removed warning when mesolve fall back on sesolve (by **Michael Goerz**). - Fixed dimension check and confusing documentation in random ket (by **Yariv Yanay**). - Fixed Qobj isherm not working after using Qobj.permute (Thank **llorz1207** for reporting). - Correlation functions call now properly handle multiple time dependant functions (Thank **taw181** for reporting). - Removed mutable default values in mesolve/sesolve (by **Michael Goerz**). - Fixed simdiag bug (Thank **Croydon-Brixton** for reporting). - Better support of constant QobjEvo (by **Boxi Li**). - Fixed potential cyclic import in the control module (by **Alexander Pitchford**). Version 4.4.0 (July 03, 2019); +++++++++++++++++++++++++++++. Improvements; ------------. - **MAJOR FEATURE**: Added methods and techniques to the stochastic solvers (by **Eric Gigure**) which allows to use a much broader set of solvers and much more efficiently. - **MAJOR FEATURE**: Optimization of the montecarlo solver (by **Eric Gigure**). Computation are faster in many cases. Collapse information available to time dependant information. - Added the QObjEvo class and methods (by **Eric Gigure**), which is used behind the scenes by the dynamical solvers, making the code more efficient and tidier. More built-in function available to string coefficients. - The coefficients can be made from interpolated array with variable timesteps and can obtain state information more easily. Time-dependant collapse operator can have multiple terms. - New wigner_transform and plot_wigner_sphere function. (by **Nithin Ramu**). - ptrace is faster and work on bigger systems, from 15 Qbits to 30 Qbits. - QIP module: added the possibility for user-defined gates, added the possibility to remove or add gates in any point of an already built circuit, added the molmer_sorensen gat",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:92132,Energy Efficiency,efficient,efficient,92132,"erm not working after using Qobj.permute (Thank **llorz1207** for reporting). - Correlation functions call now properly handle multiple time dependant functions (Thank **taw181** for reporting). - Removed mutable default values in mesolve/sesolve (by **Michael Goerz**). - Fixed simdiag bug (Thank **Croydon-Brixton** for reporting). - Better support of constant QobjEvo (by **Boxi Li**). - Fixed potential cyclic import in the control module (by **Alexander Pitchford**). Version 4.4.0 (July 03, 2019); +++++++++++++++++++++++++++++. Improvements; ------------. - **MAJOR FEATURE**: Added methods and techniques to the stochastic solvers (by **Eric Gigure**) which allows to use a much broader set of solvers and much more efficiently. - **MAJOR FEATURE**: Optimization of the montecarlo solver (by **Eric Gigure**). Computation are faster in many cases. Collapse information available to time dependant information. - Added the QObjEvo class and methods (by **Eric Gigure**), which is used behind the scenes by the dynamical solvers, making the code more efficient and tidier. More built-in function available to string coefficients. - The coefficients can be made from interpolated array with variable timesteps and can obtain state information more easily. Time-dependant collapse operator can have multiple terms. - New wigner_transform and plot_wigner_sphere function. (by **Nithin Ramu**). - ptrace is faster and work on bigger systems, from 15 Qbits to 30 Qbits. - QIP module: added the possibility for user-defined gates, added the possibility to remove or add gates in any point of an already built circuit, added the molmer_sorensen gate, and fixed some bugs (by **Boxi Li**). - Added the quantum Hellinger distance to qutip.metrics (by **Wojciech Rzadkowski**). - Implemented possibility of choosing a random seed (by **Marek Marekyggdrasil**). - Added a code of conduct to Github. Bug Fixes; ---------. - Fixed bug that made QuTiP incompatible with SciPy 1.3. Version 4.3.0 (July 14, ",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:99514,Energy Efficiency,power,power,99514,"aw summation algorithm to evaluate a polynomial series that is applicable for any number of exciations (previous limitation was ~50 quanta), and is ~3x faster than before. (**Added by Denis Vasilyev**); - Can now define a given eigen spectrum for random Hermitian and density operators.; - The Qobj ``expm`` method now uses the equivilent SciPy routine, and performs a much faster ``exp`` operation if the matrix is diagonal.; - One can now build zero operators using the ``qzero`` function. *Control modules*. - **MAJOR FEATURE**: CRAB algorithm added; This is an alternative to the GRAPE algorithm, which allows for analytical control functions, which means that experimental constraints can more easily be added into optimisation.; See tutorial notebook for full information. Improvements; ------------; *Core libraries*. - Two-time correlation functions can now be calculated for fully time-dependent Hamiltonians and collapse operators. (**Added by Kevin Fischer**); - The code for the inverse-power method for the steady state solver has been simplified.; - Bloch-Redfield tensor creation is now up to an order of magnitude faster. (**Added by Johannes Feist**); - Q.transform now works properly for arrays directly from sp_eigs (or eig).; - Q.groundstate now checks for degeneracy.; - Added ``sinm`` and ``cosm`` methods to the Qobj class.; - Added ``charge`` and ``tunneling`` operators.; - Time-dependent Cython code is now easier to read and debug. *Control modules*. - The internal state / quantum operator data type can now be either Qobj or ndarray; Previous only ndarray was possible. This now opens up possibility of using Qobj methods in fidelity calculations; The attributes and functions that return these operators are now preceded by an underscore, to indicate that the data type could change depending on the configuration options.; In most cases these functions were for internal processing only anyway, and should have been 'private'.; Accessors to the properties that could be ",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:99873,Energy Efficiency,charge,charge,99873,"uch faster ``exp`` operation if the matrix is diagonal.; - One can now build zero operators using the ``qzero`` function. *Control modules*. - **MAJOR FEATURE**: CRAB algorithm added; This is an alternative to the GRAPE algorithm, which allows for analytical control functions, which means that experimental constraints can more easily be added into optimisation.; See tutorial notebook for full information. Improvements; ------------; *Core libraries*. - Two-time correlation functions can now be calculated for fully time-dependent Hamiltonians and collapse operators. (**Added by Kevin Fischer**); - The code for the inverse-power method for the steady state solver has been simplified.; - Bloch-Redfield tensor creation is now up to an order of magnitude faster. (**Added by Johannes Feist**); - Q.transform now works properly for arrays directly from sp_eigs (or eig).; - Q.groundstate now checks for degeneracy.; - Added ``sinm`` and ``cosm`` methods to the Qobj class.; - Added ``charge`` and ``tunneling`` operators.; - Time-dependent Cython code is now easier to read and debug. *Control modules*. - The internal state / quantum operator data type can now be either Qobj or ndarray; Previous only ndarray was possible. This now opens up possibility of using Qobj methods in fidelity calculations; The attributes and functions that return these operators are now preceded by an underscore, to indicate that the data type could change depending on the configuration options.; In most cases these functions were for internal processing only anyway, and should have been 'private'.; Accessors to the properties that could be useful outside of the library have been added. These always return Qobj. If the internal operator data type is not Qobj, then there could be signicant overhead in the conversion, and so this should be avoided during pulse optimisation.; If custom sub-classes are developed that use Qobj properties and methods (e.g. partial trace), then it is very likely that it will be",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:100892,Energy Efficiency,efficient,efficient,100892," ``tunneling`` operators.; - Time-dependent Cython code is now easier to read and debug. *Control modules*. - The internal state / quantum operator data type can now be either Qobj or ndarray; Previous only ndarray was possible. This now opens up possibility of using Qobj methods in fidelity calculations; The attributes and functions that return these operators are now preceded by an underscore, to indicate that the data type could change depending on the configuration options.; In most cases these functions were for internal processing only anyway, and should have been 'private'.; Accessors to the properties that could be useful outside of the library have been added. These always return Qobj. If the internal operator data type is not Qobj, then there could be signicant overhead in the conversion, and so this should be avoided during pulse optimisation.; If custom sub-classes are developed that use Qobj properties and methods (e.g. partial trace), then it is very likely that it will be more efficient to set the internal data type to Qobj.; The internal operator data will be chosen automatically based on the size and sparsity of the dynamics generator. It can be forced by setting ``dynamics.oper_dtype = <type>``; Note this can be done by passing ``dyn_params={'oper_dtype':<type>}`` in any of the pulseoptim functions. Some other properties and methods were renamed at the same time. A full list is given here. - All modules; - function: ``set_log_level`` -> property: ``log_level``. - dynamics functions. - ``_init_lists`` now ``_init_evo``; - ``get_num_ctrls`` now property: ``num_ctrls``; - ``get_owd_evo_target`` now property: ``onto_evo_target``; - ``combine_dyn_gen`` now ``_combine_dyn_gen`` (no longer returns a value); - ``get_dyn_gen`` now ``_get_phased_dyn_gen``; - ``get_ctrl_den_gen`` now ``_get_phased_ctrl_dyn_gen``; - ``ensure_decomp_curr`` now ``_ensure_decomp_curr``; - ``spectral_decomp`` now ``_spectral_decomp``. - dynamics properties. - ``evo_init2t`` now ``_",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:105759,Energy Efficiency,power,power,105759,"bugging (qutip.logging).; - New user-available API for parallelization (parallel_map).; - New enhanced (optional) text-based progressbar (qutip.ui.EnhancedTextProgressBar); - Faster Python based monte carlo solver (mcsolve).; - Support for progress bars in propagator function.; - Time-dependent Cython code now calls complex cmath functions.; - Random numbers seeds can now be reused for successive calls to mcsolve.; - The Bloch-Redfield master equation solver now supports optional Lindblad type collapse operators.; - Improved handling of ODE integration errors in mesolve.; - Improved correlation function module (for example, improved support for time-dependent problems).; - Improved parallelization of mcsolve (can now be interrupted easily, support for IPython.parallel, etc.); - Many performance improvements, and much internal code restructuring. Bug Fixes; ---------. - Cython build files for time-dependent string format now removed automatically.; - Fixed incorrect solution time from inverse-power method steady state solver.; - mcsolve now supports `Options(store_states=True)`; - Fixed bug in `hadamard` gate function.; - Fixed compatibility issues with NumPy 1.9.0.; - Progressbar in mcsolve can now be suppressed.; - Fixed bug in `gate_expand_3toN`.; - Fixed bug for time-dependent problem (list string format) with multiple terms in coefficient to an operator. Version 3.0.1 (Aug 5, 2014); +++++++++++++++++++++++++++. Bug Fixes; ---------. - Fix bug in create(), which returned a Qobj with CSC data instead of CSR.; - Fix several bugs in mcsolve: Incorrect storing of collapse times and collapse; operator records. Incorrect averaging of expectation values for different; trajectories when using only 1 CPU.; - Fix bug in parsing of time-dependent Hamiltonian/collapse operator arguments; that occurred when the args argument is not a dictionary.; - Fix bug in internal _version2int function that cause a failure when parsingthe version number of the Cython package.; -. Version ",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:109344,Energy Efficiency,power,power,109344,"gner`` and ``plot_wigner_fock_distribution`` now supports 3D views; in addition to contour views. - New API and new functions for working with spin operators and states,; including for example ``spin_Jx``, ``spin_Jy``, ``spin_Jz`` and; ``spin_state``, ``spin_coherent``. - The ``expect`` function now supports a list of operators, in addition to the; previously supported list of states. - Simplified creation of qubit states using ``ket`` function. - The module ``qutip.cyQ`` has been renamed to ``qutip.cy`` and the sparse; matrix-vector functions ``spmv`` and ``spmv1d`` has been combined into one; function ``spmv``. New functions for operating directly on the underlaying; sparse CSR data have been added (e.g., ``spmv_csr``). Performance; improvements. New and improved Cython functions for calculating expectation; values for state vectors, density matrices in matrix and vector form. - The ``concurrence`` function now supports both pure and mixed states. Added; function for calculating the entangling power of a two-qubit gate. - Added function for generating (generalized) Lindblad dissipator; superoperators. - New functions for generating Bell states, and singlet and triplet states. - QuTiP no longer contains the demos GUI. The examples are now available on the; QuTiP web site. The ``qutip.gui`` module has been renamed to ``qutip.ui`` and; does no longer contain graphical UI elements. New text-based and HTML-based; progressbar classes. - Support for harmonic oscillator operators/states in a Fock state basis that; does not start from zero (e.g., in the range [M,N+1]). Support for; eliminating and extracting states from Qobj instances (e.g., removing one; state from a two-qubit system to obtain a three-level system). - Support for time-dependent Hamiltonian and Liouvillian callback functions that; depend on the instantaneous state, which for example can be used for solving; master equations with mean field terms. Improvements; ------------. - Restructured and optimized imp",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:114918,Energy Efficiency,efficient,efficient,114918," as well as the addition of several new routines supporting a wide range of functionality. Some of the highlights of this release include:. New Features; ------------. - QuTiP now includes solvers for both Floquet and Bloch-Redfield master equations. - The Lindblad master equation and Monte Carlo solvers allow for time-dependent collapse operators. - It is possible to automatically compile time-dependent problems into c-code using Cython (if installed). - Python functions can be used to create arbitrary time-dependent Hamiltonians and collapse operators. - Solvers now return Odedata objects containing all simulation results and parameters, simplifying the saving of simulation results. .. important:: This breaks compatibility with QuTiP version 1.x. - mesolve and mcsolve can reuse Hamiltonian data when only the initial state, or time-dependent arguments, need to be changed. - QuTiP includes functions for creating random quantum states and operators. - The generation and manipulation of quantum objects is now more efficient. - Quantum objects have basis transformation and matrix element calculations as built-in methods. - The quantum object eigensolver can use sparse solvers. - The partial-trace (ptrace) function is up to 20x faster. - The Bloch sphere can now be used with the Matplotlib animation function, and embedded as a subplot in a figure. - QuTiP has built-in functions for saving quantum objects and data arrays. - The steady-state solver has been further optimized for sparse matrices, and can handle much larger system Hamiltonians. - The steady-state solver can use the iterative bi-conjugate gradient method instead of a direct solver. - There are three new entropy functions for concurrence, mutual information, and conditional entropy. - Correlation functions have been combined under a single function. - The operator norm can now be set to trace, Frobius, one, or max norm. - Global QuTiP settings can now be modified. - QuTiP includes a collection of unit tests f",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:2746,Integrability,depend,dependent,2746,"t minimum python version to 3.9 (#2413); - Qobj.__eq__ uses core's settings rtol. (#2425); - Only normalize solver states when the initial state is already normalized. (#2427). QuTiP 5.0.1 (2024-04-03); ========================. Patch update fixing small issues with v5.0.0 release. - Fix broken links in the documentation when migrating to readthedocs; - Fix readthedocs search feature; - Add setuptools to runtime compilation requirements; - Fix mcsolve documentation for open systems; - Fix OverFlowError in progress bars. QuTiP 5.0.0 (2024-03-26); ========================. QuTiP 5 is a redesign of many of the core components of QuTiP (``Qobj``,; ``QobjEvo``, solvers) to make them more consistent and more flexible. ``Qobj`` may now be stored in either sparse or dense representations,; and the two may be mixed sensibly as needed. ``QobjEvo`` is now used; consistently throughout QuTiP, and the implementation has been; substantially cleaned up. A new ``Coefficient`` class is used to; represent the time-dependent factors inside ``QobjEvo``. The solvers have been rewritten to work well with the new data layer; and the concept of ``Integrators`` which solve ODEs has been introduced.; In future, new data layers may provide their own ``Integrators``; specialized to their representation of the underlying data. Much of the user-facing API of QuTiP remains familiar, but there have; had to be many small breaking changes. If we can make changes to; easy migrating code from QuTiP 4 to QuTiP 5, please let us know. An extensive list of changes follows. Contributors; ------------. QuTiP 5 has been a large effort by many people over the last three years. In particular:. - Jake Lishman led the implementation of the new data layer and coefficients.; - Eric Gigure led the implementation of the new QobjEvo interface and solvers.; - Boxi Li led the updating of QuTiP's QIP support and the creation of ``qutip_qip``. Other members of the QuTiP Admin team have been heavily involved in reviewing,",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:3548,Integrability,interface,interface,3548,"d the two may be mixed sensibly as needed. ``QobjEvo`` is now used; consistently throughout QuTiP, and the implementation has been; substantially cleaned up. A new ``Coefficient`` class is used to; represent the time-dependent factors inside ``QobjEvo``. The solvers have been rewritten to work well with the new data layer; and the concept of ``Integrators`` which solve ODEs has been introduced.; In future, new data layers may provide their own ``Integrators``; specialized to their representation of the underlying data. Much of the user-facing API of QuTiP remains familiar, but there have; had to be many small breaking changes. If we can make changes to; easy migrating code from QuTiP 4 to QuTiP 5, please let us know. An extensive list of changes follows. Contributors; ------------. QuTiP 5 has been a large effort by many people over the last three years. In particular:. - Jake Lishman led the implementation of the new data layer and coefficients.; - Eric Gigure led the implementation of the new QobjEvo interface and solvers.; - Boxi Li led the updating of QuTiP's QIP support and the creation of ``qutip_qip``. Other members of the QuTiP Admin team have been heavily involved in reviewing,; testing and designing QuTiP 5:. - Alexander Pitchford; - Asier Galicia; - Nathan Shammah; - Shahnawaz Ahmed; - Neill Lambert; - Simon Cross; - Paul Menczel. Two Google Summer of Code contributors updated the tutorials and benchmarks to; QuTiP 5:. - Christian Staufenbiel updated many of the tutorials (`<https://github.com/qutip/qutip-tutorials/>`).; - Xavier Sproken update the benchmarks (`<https://github.com/qutip/qutip-benchmark/>`). During an internship at RIKEN, Patrick Hopf created a new quantum control method and; improved the existing methods interface:. - Patrick Hopf created new quantum control package (`<https://github.com/qutip/qutip-qoc/>`). Four experimental data layers backends were written either as part of Google Summer; of Code or as separate projects. While these ar",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:4292,Integrability,interface,interface,4292,"ase let us know. An extensive list of changes follows. Contributors; ------------. QuTiP 5 has been a large effort by many people over the last three years. In particular:. - Jake Lishman led the implementation of the new data layer and coefficients.; - Eric Gigure led the implementation of the new QobjEvo interface and solvers.; - Boxi Li led the updating of QuTiP's QIP support and the creation of ``qutip_qip``. Other members of the QuTiP Admin team have been heavily involved in reviewing,; testing and designing QuTiP 5:. - Alexander Pitchford; - Asier Galicia; - Nathan Shammah; - Shahnawaz Ahmed; - Neill Lambert; - Simon Cross; - Paul Menczel. Two Google Summer of Code contributors updated the tutorials and benchmarks to; QuTiP 5:. - Christian Staufenbiel updated many of the tutorials (`<https://github.com/qutip/qutip-tutorials/>`).; - Xavier Sproken update the benchmarks (`<https://github.com/qutip/qutip-benchmark/>`). During an internship at RIKEN, Patrick Hopf created a new quantum control method and; improved the existing methods interface:. - Patrick Hopf created new quantum control package (`<https://github.com/qutip/qutip-qoc/>`). Four experimental data layers backends were written either as part of Google Summer; of Code or as separate projects. While these are still alpha quality, they helped; significantly to test the data layer API:. - ``qutip-tensorflow``: a TensorFlow backend by Asier Galicia (`<https://github.com/qutip/qutip-tensorflow>`); - ``qutip-cupy``: a CuPy GPU backend by Felipe Bivort Haiek (`<https://github.com/qutip/qutip-cupy/>`)`; - ``qutip-tensornetwork``: a TensorNetwork backend by Asier Galicia (`<https://github.com/qutip/qutip-tensornetwork>`); - ``qutip-jax``: a JAX backend by Eric Gigure (`<https://github.com/qutip/qutip-jax/>`). Finally, Yuji Tamakoshi updated the visualization function and added animation; functions as part of Google Summer of Code project. We have also had many other contributors, whose specific contributions a",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:11236,Integrability,contract,contract,11236,"ata is still acessible via the ``.data`` attribute, but is now an; instance of the underlying data type instead of a SciPy-like sparse matrix.; The operations available in ``qutip.core.data`` may be used on ``.data``,; regardless of the data type.; - ``Qobj`` with different data types may be mixed in arithmetic and other; operations. A sensible output type will be automatically determined.; - The new ``.to(...)`` method may be used to convert a ``Qobj`` from one data type; to another. E.g. ``.to(""dense"")`` will convert to the dense representation and; ``.to(""csr"")`` will convert to the sparse type.; - Many ``Qobj`` methods and methods that create ``Qobj`` now accepted a ``dtype``; parameter that allows the data type of the returned ``Qobj`` to specified.; - The new ``&`` operator may be used to obtain the tensor product.; - The new ``@`` operator may be used to obtain the matrix / operator product.; ``bar @ ket`` returns a scalar.; - The new ``.contract()`` method will collapse 1D subspaces of the dimensions of; the ``Qobj``.; - The new ``.logm()`` method returns the matrix logarithm of an operator.; - The methods ``.set_data``, ``.get_data``, ``.extract_state``, ``.eliminate_states``,; ``.evaluate`` and ``.check_isunitary`` have been removed.; - The property ``dtype`` return the representation of the data used.; - The new ``data_as`` allow to obtain the data as a common python formats:; numpy array, scipy sparse matrix, JAX Array, etc. QobjEvo changes; ---------------. The ``QobjEvo`` type for storing time-dependent quantum objects has been; significantly expanded, standardized and extended. The time-dependent; coefficients are now represented using a new ``Coefficient`` type that; may be independently created and manipulated if required. Some highlights:. - The ``.compile()`` method has been removed. Coefficients specified as; strings are automatically compiled if possible and the compilation is; cached across different Python runs and instances.; - Mixing coeffic",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:11810,Integrability,depend,dependent,11810,"; ``.to(""csr"")`` will convert to the sparse type.; - Many ``Qobj`` methods and methods that create ``Qobj`` now accepted a ``dtype``; parameter that allows the data type of the returned ``Qobj`` to specified.; - The new ``&`` operator may be used to obtain the tensor product.; - The new ``@`` operator may be used to obtain the matrix / operator product.; ``bar @ ket`` returns a scalar.; - The new ``.contract()`` method will collapse 1D subspaces of the dimensions of; the ``Qobj``.; - The new ``.logm()`` method returns the matrix logarithm of an operator.; - The methods ``.set_data``, ``.get_data``, ``.extract_state``, ``.eliminate_states``,; ``.evaluate`` and ``.check_isunitary`` have been removed.; - The property ``dtype`` return the representation of the data used.; - The new ``data_as`` allow to obtain the data as a common python formats:; numpy array, scipy sparse matrix, JAX Array, etc. QobjEvo changes; ---------------. The ``QobjEvo`` type for storing time-dependent quantum objects has been; significantly expanded, standardized and extended. The time-dependent; coefficients are now represented using a new ``Coefficient`` type that; may be independently created and manipulated if required. Some highlights:. - The ``.compile()`` method has been removed. Coefficients specified as; strings are automatically compiled if possible and the compilation is; cached across different Python runs and instances.; - Mixing coefficient types within a single ``Qobj`` is now supported.; - Many new attributes were added to ``QobjEvo`` for convenience. Examples; include ``.dims``, ``.shape``, ``.superrep`` and ``.isconstant``.; - Many old attributes such as ``.cte``, ``.use_cython``, ``.type``, ``.const``,; and ``.coeff_file`` were removed.; - A new ``Spline`` coefficient supports spline interpolations of different; orders. The old ``Cubic_Spline`` coefficient has been removed.; - The new ``.arguments(...)`` method allows additional arguments to the; underlying coefficient function",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:11906,Integrability,depend,dependent,11906,"meter that allows the data type of the returned ``Qobj`` to specified.; - The new ``&`` operator may be used to obtain the tensor product.; - The new ``@`` operator may be used to obtain the matrix / operator product.; ``bar @ ket`` returns a scalar.; - The new ``.contract()`` method will collapse 1D subspaces of the dimensions of; the ``Qobj``.; - The new ``.logm()`` method returns the matrix logarithm of an operator.; - The methods ``.set_data``, ``.get_data``, ``.extract_state``, ``.eliminate_states``,; ``.evaluate`` and ``.check_isunitary`` have been removed.; - The property ``dtype`` return the representation of the data used.; - The new ``data_as`` allow to obtain the data as a common python formats:; numpy array, scipy sparse matrix, JAX Array, etc. QobjEvo changes; ---------------. The ``QobjEvo`` type for storing time-dependent quantum objects has been; significantly expanded, standardized and extended. The time-dependent; coefficients are now represented using a new ``Coefficient`` type that; may be independently created and manipulated if required. Some highlights:. - The ``.compile()`` method has been removed. Coefficients specified as; strings are automatically compiled if possible and the compilation is; cached across different Python runs and instances.; - Mixing coefficient types within a single ``Qobj`` is now supported.; - Many new attributes were added to ``QobjEvo`` for convenience. Examples; include ``.dims``, ``.shape``, ``.superrep`` and ``.isconstant``.; - Many old attributes such as ``.cte``, ``.use_cython``, ``.type``, ``.const``,; and ``.coeff_file`` were removed.; - A new ``Spline`` coefficient supports spline interpolations of different; orders. The old ``Cubic_Spline`` coefficient has been removed.; - The new ``.arguments(...)`` method allows additional arguments to the; underlying coefficient functions to be updated.; - The ``_step_func_coeff`` argument has been replaced by the ``order``; parameter. ``_step_func_coeff=False`` is equiva",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:14268,Integrability,integrat,integrator,14268," qutip.coefficient(f, args=args)`` is equivalent to; ``qutip.QobjEvo([[oper, f]], args=args)``.; - Coefficient function can be defined in a pythonic manner: ``def f(t, A, w)``.; The dictionary ``args`` second argument is no longer needed.; Function using the exact ``f(t, args)`` signature will use the old method for; backward compatibility. Solver changes; --------------. The solvers in QuTiP have been heavily reworked and standardized.; Under the hood solvers now make use of swappable ODE ``Integrators``.; Many ``Integrators`` are included (see the list below) and; custom implementations are possible. Solvers now consistently; accept a ``QobjEvo`` instance at the Hamiltonian or Liouvillian, or; any object which can be passed to the ``QobjEvo`` constructor. A breakdown of highlights follows. All solvers:. - Solver options are now supplied in an ordinary Python dict.; ``qutip.Options`` is deprecated and returns a dict for backwards; compatibility.; - A specific ODE integrator may be selected by supplying a; ``method`` option.; - Each solver provides a class interface. Creating an instance; of the class allows a solver to be run multiple times for the; same system without having to repeatedly reconstruct the; right-hand side of the ODE to be integrated.; - A ``QobjEvo`` instance is accepted for most operators, e.g.,; ``H``, ``c_ops``, ``e_ops``, ``a_ops``.; - The progress bar is now selected using the ``progress_bar`` option.; A new progess bar using the ``tqdm`` Python library is provided.; - Dynamic arguments, where the value of an operator depends on; the current state of the evolution interface reworked. Now a property of the; solver is to be used as an arguments:; ``args={""state"": MESolver.StateFeedback(default=rho0)}``. Integrators:. - The SciPy zvode integrator is available with the BDF and; Adams methods as ``bdf`` and ``adams``.; - The SciPy dop853 integrator (an eighth order Runge-Kutta method by; Dormand & Prince) is available as ``dop853``.; - The SciPy ls",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:14362,Integrability,interface,interface,14362,"QobjEvo([[oper, f]], args=args)``.; - Coefficient function can be defined in a pythonic manner: ``def f(t, A, w)``.; The dictionary ``args`` second argument is no longer needed.; Function using the exact ``f(t, args)`` signature will use the old method for; backward compatibility. Solver changes; --------------. The solvers in QuTiP have been heavily reworked and standardized.; Under the hood solvers now make use of swappable ODE ``Integrators``.; Many ``Integrators`` are included (see the list below) and; custom implementations are possible. Solvers now consistently; accept a ``QobjEvo`` instance at the Hamiltonian or Liouvillian, or; any object which can be passed to the ``QobjEvo`` constructor. A breakdown of highlights follows. All solvers:. - Solver options are now supplied in an ordinary Python dict.; ``qutip.Options`` is deprecated and returns a dict for backwards; compatibility.; - A specific ODE integrator may be selected by supplying a; ``method`` option.; - Each solver provides a class interface. Creating an instance; of the class allows a solver to be run multiple times for the; same system without having to repeatedly reconstruct the; right-hand side of the ODE to be integrated.; - A ``QobjEvo`` instance is accepted for most operators, e.g.,; ``H``, ``c_ops``, ``e_ops``, ``a_ops``.; - The progress bar is now selected using the ``progress_bar`` option.; A new progess bar using the ``tqdm`` Python library is provided.; - Dynamic arguments, where the value of an operator depends on; the current state of the evolution interface reworked. Now a property of the; solver is to be used as an arguments:; ``args={""state"": MESolver.StateFeedback(default=rho0)}``. Integrators:. - The SciPy zvode integrator is available with the BDF and; Adams methods as ``bdf`` and ``adams``.; - The SciPy dop853 integrator (an eighth order Runge-Kutta method by; Dormand & Prince) is available as ``dop853``.; - The SciPy lsoda integrator is available as ``lsoda``.; - QuTiP's own imple",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:14549,Integrability,integrat,integrated,14549," The dictionary ``args`` second argument is no longer needed.; Function using the exact ``f(t, args)`` signature will use the old method for; backward compatibility. Solver changes; --------------. The solvers in QuTiP have been heavily reworked and standardized.; Under the hood solvers now make use of swappable ODE ``Integrators``.; Many ``Integrators`` are included (see the list below) and; custom implementations are possible. Solvers now consistently; accept a ``QobjEvo`` instance at the Hamiltonian or Liouvillian, or; any object which can be passed to the ``QobjEvo`` constructor. A breakdown of highlights follows. All solvers:. - Solver options are now supplied in an ordinary Python dict.; ``qutip.Options`` is deprecated and returns a dict for backwards; compatibility.; - A specific ODE integrator may be selected by supplying a; ``method`` option.; - Each solver provides a class interface. Creating an instance; of the class allows a solver to be run multiple times for the; same system without having to repeatedly reconstruct the; right-hand side of the ODE to be integrated.; - A ``QobjEvo`` instance is accepted for most operators, e.g.,; ``H``, ``c_ops``, ``e_ops``, ``a_ops``.; - The progress bar is now selected using the ``progress_bar`` option.; A new progess bar using the ``tqdm`` Python library is provided.; - Dynamic arguments, where the value of an operator depends on; the current state of the evolution interface reworked. Now a property of the; solver is to be used as an arguments:; ``args={""state"": MESolver.StateFeedback(default=rho0)}``. Integrators:. - The SciPy zvode integrator is available with the BDF and; Adams methods as ``bdf`` and ``adams``.; - The SciPy dop853 integrator (an eighth order Runge-Kutta method by; Dormand & Prince) is available as ``dop853``.; - The SciPy lsoda integrator is available as ``lsoda``.; - QuTiP's own implementation of Verner's ""most efficient"" Runge-Kutta methods; of order 7 and 9 are available as ``vern7`` and ``vern9",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:14856,Integrability,depend,depends,14856,"custom implementations are possible. Solvers now consistently; accept a ``QobjEvo`` instance at the Hamiltonian or Liouvillian, or; any object which can be passed to the ``QobjEvo`` constructor. A breakdown of highlights follows. All solvers:. - Solver options are now supplied in an ordinary Python dict.; ``qutip.Options`` is deprecated and returns a dict for backwards; compatibility.; - A specific ODE integrator may be selected by supplying a; ``method`` option.; - Each solver provides a class interface. Creating an instance; of the class allows a solver to be run multiple times for the; same system without having to repeatedly reconstruct the; right-hand side of the ODE to be integrated.; - A ``QobjEvo`` instance is accepted for most operators, e.g.,; ``H``, ``c_ops``, ``e_ops``, ``a_ops``.; - The progress bar is now selected using the ``progress_bar`` option.; A new progess bar using the ``tqdm`` Python library is provided.; - Dynamic arguments, where the value of an operator depends on; the current state of the evolution interface reworked. Now a property of the; solver is to be used as an arguments:; ``args={""state"": MESolver.StateFeedback(default=rho0)}``. Integrators:. - The SciPy zvode integrator is available with the BDF and; Adams methods as ``bdf`` and ``adams``.; - The SciPy dop853 integrator (an eighth order Runge-Kutta method by; Dormand & Prince) is available as ``dop853``.; - The SciPy lsoda integrator is available as ``lsoda``.; - QuTiP's own implementation of Verner's ""most efficient"" Runge-Kutta methods; of order 7 and 9 are available as ``vern7`` and ``vern9``. See; http://people.math.sfu.ca/~jverner/ for a description of the methods.; - QuTiP's own implementation of a solver that directly diagonalizes the; the system to be integrated is available as ``diag``. It only works on; time-independent systems and is slow to setup, but once the diagonalization; is complete, it generates solutions very quickly.; - QuTiP's own implementatoin of an approxim",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:14903,Integrability,interface,interface,14903,"custom implementations are possible. Solvers now consistently; accept a ``QobjEvo`` instance at the Hamiltonian or Liouvillian, or; any object which can be passed to the ``QobjEvo`` constructor. A breakdown of highlights follows. All solvers:. - Solver options are now supplied in an ordinary Python dict.; ``qutip.Options`` is deprecated and returns a dict for backwards; compatibility.; - A specific ODE integrator may be selected by supplying a; ``method`` option.; - Each solver provides a class interface. Creating an instance; of the class allows a solver to be run multiple times for the; same system without having to repeatedly reconstruct the; right-hand side of the ODE to be integrated.; - A ``QobjEvo`` instance is accepted for most operators, e.g.,; ``H``, ``c_ops``, ``e_ops``, ``a_ops``.; - The progress bar is now selected using the ``progress_bar`` option.; A new progess bar using the ``tqdm`` Python library is provided.; - Dynamic arguments, where the value of an operator depends on; the current state of the evolution interface reworked. Now a property of the; solver is to be used as an arguments:; ``args={""state"": MESolver.StateFeedback(default=rho0)}``. Integrators:. - The SciPy zvode integrator is available with the BDF and; Adams methods as ``bdf`` and ``adams``.; - The SciPy dop853 integrator (an eighth order Runge-Kutta method by; Dormand & Prince) is available as ``dop853``.; - The SciPy lsoda integrator is available as ``lsoda``.; - QuTiP's own implementation of Verner's ""most efficient"" Runge-Kutta methods; of order 7 and 9 are available as ``vern7`` and ``vern9``. See; http://people.math.sfu.ca/~jverner/ for a description of the methods.; - QuTiP's own implementation of a solver that directly diagonalizes the; the system to be integrated is available as ``diag``. It only works on; time-independent systems and is slow to setup, but once the diagonalization; is complete, it generates solutions very quickly.; - QuTiP's own implementatoin of an approxim",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:15075,Integrability,integrat,integrator,15075,"- Solver options are now supplied in an ordinary Python dict.; ``qutip.Options`` is deprecated and returns a dict for backwards; compatibility.; - A specific ODE integrator may be selected by supplying a; ``method`` option.; - Each solver provides a class interface. Creating an instance; of the class allows a solver to be run multiple times for the; same system without having to repeatedly reconstruct the; right-hand side of the ODE to be integrated.; - A ``QobjEvo`` instance is accepted for most operators, e.g.,; ``H``, ``c_ops``, ``e_ops``, ``a_ops``.; - The progress bar is now selected using the ``progress_bar`` option.; A new progess bar using the ``tqdm`` Python library is provided.; - Dynamic arguments, where the value of an operator depends on; the current state of the evolution interface reworked. Now a property of the; solver is to be used as an arguments:; ``args={""state"": MESolver.StateFeedback(default=rho0)}``. Integrators:. - The SciPy zvode integrator is available with the BDF and; Adams methods as ``bdf`` and ``adams``.; - The SciPy dop853 integrator (an eighth order Runge-Kutta method by; Dormand & Prince) is available as ``dop853``.; - The SciPy lsoda integrator is available as ``lsoda``.; - QuTiP's own implementation of Verner's ""most efficient"" Runge-Kutta methods; of order 7 and 9 are available as ``vern7`` and ``vern9``. See; http://people.math.sfu.ca/~jverner/ for a description of the methods.; - QuTiP's own implementation of a solver that directly diagonalizes the; the system to be integrated is available as ``diag``. It only works on; time-independent systems and is slow to setup, but once the diagonalization; is complete, it generates solutions very quickly.; - QuTiP's own implementatoin of an approximate Krylov subspace integrator is; available as ``krylov``. This integrator is only usable with ``sesolve``. Result class:. - A new ``.e_data`` attribute provides expectation values as a dictionary.; Unlike ``.expect``, the values are provided ",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:15177,Integrability,integrat,integrator,15177," dict for backwards; compatibility.; - A specific ODE integrator may be selected by supplying a; ``method`` option.; - Each solver provides a class interface. Creating an instance; of the class allows a solver to be run multiple times for the; same system without having to repeatedly reconstruct the; right-hand side of the ODE to be integrated.; - A ``QobjEvo`` instance is accepted for most operators, e.g.,; ``H``, ``c_ops``, ``e_ops``, ``a_ops``.; - The progress bar is now selected using the ``progress_bar`` option.; A new progess bar using the ``tqdm`` Python library is provided.; - Dynamic arguments, where the value of an operator depends on; the current state of the evolution interface reworked. Now a property of the; solver is to be used as an arguments:; ``args={""state"": MESolver.StateFeedback(default=rho0)}``. Integrators:. - The SciPy zvode integrator is available with the BDF and; Adams methods as ``bdf`` and ``adams``.; - The SciPy dop853 integrator (an eighth order Runge-Kutta method by; Dormand & Prince) is available as ``dop853``.; - The SciPy lsoda integrator is available as ``lsoda``.; - QuTiP's own implementation of Verner's ""most efficient"" Runge-Kutta methods; of order 7 and 9 are available as ``vern7`` and ``vern9``. See; http://people.math.sfu.ca/~jverner/ for a description of the methods.; - QuTiP's own implementation of a solver that directly diagonalizes the; the system to be integrated is available as ``diag``. It only works on; time-independent systems and is slow to setup, but once the diagonalization; is complete, it generates solutions very quickly.; - QuTiP's own implementatoin of an approximate Krylov subspace integrator is; available as ``krylov``. This integrator is only usable with ``sesolve``. Result class:. - A new ``.e_data`` attribute provides expectation values as a dictionary.; Unlike ``.expect``, the values are provided in a Python list rather than; a numpy array, which better supports non-numeric types.; - The contents of the ",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:15293,Integrability,integrat,integrator,15293,"plying a; ``method`` option.; - Each solver provides a class interface. Creating an instance; of the class allows a solver to be run multiple times for the; same system without having to repeatedly reconstruct the; right-hand side of the ODE to be integrated.; - A ``QobjEvo`` instance is accepted for most operators, e.g.,; ``H``, ``c_ops``, ``e_ops``, ``a_ops``.; - The progress bar is now selected using the ``progress_bar`` option.; A new progess bar using the ``tqdm`` Python library is provided.; - Dynamic arguments, where the value of an operator depends on; the current state of the evolution interface reworked. Now a property of the; solver is to be used as an arguments:; ``args={""state"": MESolver.StateFeedback(default=rho0)}``. Integrators:. - The SciPy zvode integrator is available with the BDF and; Adams methods as ``bdf`` and ``adams``.; - The SciPy dop853 integrator (an eighth order Runge-Kutta method by; Dormand & Prince) is available as ``dop853``.; - The SciPy lsoda integrator is available as ``lsoda``.; - QuTiP's own implementation of Verner's ""most efficient"" Runge-Kutta methods; of order 7 and 9 are available as ``vern7`` and ``vern9``. See; http://people.math.sfu.ca/~jverner/ for a description of the methods.; - QuTiP's own implementation of a solver that directly diagonalizes the; the system to be integrated is available as ``diag``. It only works on; time-independent systems and is slow to setup, but once the diagonalization; is complete, it generates solutions very quickly.; - QuTiP's own implementatoin of an approximate Krylov subspace integrator is; available as ``krylov``. This integrator is only usable with ``sesolve``. Result class:. - A new ``.e_data`` attribute provides expectation values as a dictionary.; Unlike ``.expect``, the values are provided in a Python list rather than; a numpy array, which better supports non-numeric types.; - The contents of the ``.stats`` attribute changed significantly and is; now more consistent across solvers. ",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:15636,Integrability,integrat,integrated,15636,"operators, e.g.,; ``H``, ``c_ops``, ``e_ops``, ``a_ops``.; - The progress bar is now selected using the ``progress_bar`` option.; A new progess bar using the ``tqdm`` Python library is provided.; - Dynamic arguments, where the value of an operator depends on; the current state of the evolution interface reworked. Now a property of the; solver is to be used as an arguments:; ``args={""state"": MESolver.StateFeedback(default=rho0)}``. Integrators:. - The SciPy zvode integrator is available with the BDF and; Adams methods as ``bdf`` and ``adams``.; - The SciPy dop853 integrator (an eighth order Runge-Kutta method by; Dormand & Prince) is available as ``dop853``.; - The SciPy lsoda integrator is available as ``lsoda``.; - QuTiP's own implementation of Verner's ""most efficient"" Runge-Kutta methods; of order 7 and 9 are available as ``vern7`` and ``vern9``. See; http://people.math.sfu.ca/~jverner/ for a description of the methods.; - QuTiP's own implementation of a solver that directly diagonalizes the; the system to be integrated is available as ``diag``. It only works on; time-independent systems and is slow to setup, but once the diagonalization; is complete, it generates solutions very quickly.; - QuTiP's own implementatoin of an approximate Krylov subspace integrator is; available as ``krylov``. This integrator is only usable with ``sesolve``. Result class:. - A new ``.e_data`` attribute provides expectation values as a dictionary.; Unlike ``.expect``, the values are provided in a Python list rather than; a numpy array, which better supports non-numeric types.; - The contents of the ``.stats`` attribute changed significantly and is; now more consistent across solvers. Monte-Carlo Solver (mcsolve):. - The system, H, may now be a super-operator.; - The ``seed`` parameter now supports supplying numpy ``SeedSequence`` or; ``Generator`` types.; - The new ``timeout`` and ``target_tol`` parameters allow the solver to exit; early if a timeout or target tolerance is reached.; -",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:15882,Integrability,integrat,integrator,15882,"he current state of the evolution interface reworked. Now a property of the; solver is to be used as an arguments:; ``args={""state"": MESolver.StateFeedback(default=rho0)}``. Integrators:. - The SciPy zvode integrator is available with the BDF and; Adams methods as ``bdf`` and ``adams``.; - The SciPy dop853 integrator (an eighth order Runge-Kutta method by; Dormand & Prince) is available as ``dop853``.; - The SciPy lsoda integrator is available as ``lsoda``.; - QuTiP's own implementation of Verner's ""most efficient"" Runge-Kutta methods; of order 7 and 9 are available as ``vern7`` and ``vern9``. See; http://people.math.sfu.ca/~jverner/ for a description of the methods.; - QuTiP's own implementation of a solver that directly diagonalizes the; the system to be integrated is available as ``diag``. It only works on; time-independent systems and is slow to setup, but once the diagonalization; is complete, it generates solutions very quickly.; - QuTiP's own implementatoin of an approximate Krylov subspace integrator is; available as ``krylov``. This integrator is only usable with ``sesolve``. Result class:. - A new ``.e_data`` attribute provides expectation values as a dictionary.; Unlike ``.expect``, the values are provided in a Python list rather than; a numpy array, which better supports non-numeric types.; - The contents of the ``.stats`` attribute changed significantly and is; now more consistent across solvers. Monte-Carlo Solver (mcsolve):. - The system, H, may now be a super-operator.; - The ``seed`` parameter now supports supplying numpy ``SeedSequence`` or; ``Generator`` types.; - The new ``timeout`` and ``target_tol`` parameters allow the solver to exit; early if a timeout or target tolerance is reached.; - The ntraj option no longer supports a list of numbers of trajectories.; Instead, just run the solver multiple times and use the class ``MCSolver``; if setting up the solver uses a significant amount of time.; - The ``map_func`` parameter has been replaced by t",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:15927,Integrability,integrat,integrator,15927," solver is to be used as an arguments:; ``args={""state"": MESolver.StateFeedback(default=rho0)}``. Integrators:. - The SciPy zvode integrator is available with the BDF and; Adams methods as ``bdf`` and ``adams``.; - The SciPy dop853 integrator (an eighth order Runge-Kutta method by; Dormand & Prince) is available as ``dop853``.; - The SciPy lsoda integrator is available as ``lsoda``.; - QuTiP's own implementation of Verner's ""most efficient"" Runge-Kutta methods; of order 7 and 9 are available as ``vern7`` and ``vern9``. See; http://people.math.sfu.ca/~jverner/ for a description of the methods.; - QuTiP's own implementation of a solver that directly diagonalizes the; the system to be integrated is available as ``diag``. It only works on; time-independent systems and is slow to setup, but once the diagonalization; is complete, it generates solutions very quickly.; - QuTiP's own implementatoin of an approximate Krylov subspace integrator is; available as ``krylov``. This integrator is only usable with ``sesolve``. Result class:. - A new ``.e_data`` attribute provides expectation values as a dictionary.; Unlike ``.expect``, the values are provided in a Python list rather than; a numpy array, which better supports non-numeric types.; - The contents of the ``.stats`` attribute changed significantly and is; now more consistent across solvers. Monte-Carlo Solver (mcsolve):. - The system, H, may now be a super-operator.; - The ``seed`` parameter now supports supplying numpy ``SeedSequence`` or; ``Generator`` types.; - The new ``timeout`` and ``target_tol`` parameters allow the solver to exit; early if a timeout or target tolerance is reached.; - The ntraj option no longer supports a list of numbers of trajectories.; Instead, just run the solver multiple times and use the class ``MCSolver``; if setting up the solver uses a significant amount of time.; - The ``map_func`` parameter has been replaced by the ``map`` option.; - A loky based parallel map as been added.; - A mpi based",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:17955,Integrability,interface,interface,17955," added.; - A mpi based parallel map as been added.; - The result returned by ``mcsolve`` now supports calculating photocurrents; and calculating the steady state over N trajectories.; - The old ``parfor`` parallel execution function has been removed from; ``qutip.parallel``. Use ``parallel_map``, ``loky_map`` or ``mpi_pmap`` instead.; - Added improved sampling options which converge much faster when the; probability of collapse is small. Non Markovian Monte-Carlo Solver (nm_mcsolve):. - New Monte-Carlo Solver supporting negative decay rates.; - Based on the influence martingale approach, Donvil et al., Nat Commun 13, 4140 (2022).; - Most of the improvements made to the regular Monte-Carlo solver are also available here.; - The value of the influence martingale is available through the ``.trace`` attribute of the result. Stochastic Equation Solvers (ssesolve, smesolve). - Function call greatly changed: many keyword arguments are now options.; - m_ops and dW_factors are now changed from the default from the new class interface only.; - Use the same parallel maps as mcsolve: support for loky and mpi map added.; - End conditions ``timeout`` and ``target_tol`` added.; - The ``seed`` parameter now supports supplying numpy ``SeedSequence``.; - Wiener function is now available as a feedback. Bloch-Redfield Master Equation Solver (brmesolve):. - The ``a_ops`` and ``spectra`` support implementations been heavily reworked to; reuse the techniques from the new Coefficient and QobjEvo classes.; - The ``use_secular`` parameter has been removed. Use ``sec_cutoff=-1`` instead.; - The required tolerance is now read from ``qutip.settings``. Krylov Subspace Solver (krylovsolve):. - The Krylov solver is now implemented using ``SESolver`` and the ``krylov``; ODE integrator. The function ``krylovsolve`` is maintained for convenience; and now supports many more options.; - The ``sparse`` parameter has been removed. Supply a sparse ``Qobj`` for the; Hamiltonian instead. Floquet Solver (fse",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:18696,Integrability,integrat,integrator,18696," value of the influence martingale is available through the ``.trace`` attribute of the result. Stochastic Equation Solvers (ssesolve, smesolve). - Function call greatly changed: many keyword arguments are now options.; - m_ops and dW_factors are now changed from the default from the new class interface only.; - Use the same parallel maps as mcsolve: support for loky and mpi map added.; - End conditions ``timeout`` and ``target_tol`` added.; - The ``seed`` parameter now supports supplying numpy ``SeedSequence``.; - Wiener function is now available as a feedback. Bloch-Redfield Master Equation Solver (brmesolve):. - The ``a_ops`` and ``spectra`` support implementations been heavily reworked to; reuse the techniques from the new Coefficient and QobjEvo classes.; - The ``use_secular`` parameter has been removed. Use ``sec_cutoff=-1`` instead.; - The required tolerance is now read from ``qutip.settings``. Krylov Subspace Solver (krylovsolve):. - The Krylov solver is now implemented using ``SESolver`` and the ``krylov``; ODE integrator. The function ``krylovsolve`` is maintained for convenience; and now supports many more options.; - The ``sparse`` parameter has been removed. Supply a sparse ``Qobj`` for the; Hamiltonian instead. Floquet Solver (fsesolve and fmmesolve):. - The Floquet solver has been rewritten to use a new ``FloquetBasis`` class; which manages the transformations from lab to Floquet basis and back.; - Many of the internal methods used by the old Floquet solvers have; been removed. The Floquet tensor may still be retried using; the function ``floquet_tensor``.; - The Floquet Markov Master Equation solver has had many changes and; new options added. The environment temperature may be specified using; ``w_th``, and the result states are stored in the lab basis and optionally; in the Floquet basis using ``store_floquet_state``.; - The spectra functions supplied to ``fmmesolve`` must now be vectorized; (i.e. accept and return numpy arrays for frequencies and ",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:20168,Integrability,integrat,integration,20168," tensor may still be retried using; the function ``floquet_tensor``.; - The Floquet Markov Master Equation solver has had many changes and; new options added. The environment temperature may be specified using; ``w_th``, and the result states are stored in the lab basis and optionally; in the Floquet basis using ``store_floquet_state``.; - The spectra functions supplied to ``fmmesolve`` must now be vectorized; (i.e. accept and return numpy arrays for frequencies and densities) and; must accept negative frequence (i.e. usually include a ``w > 0`` factor; so that the returned densities are zero for negative frequencies).; - The number of sidebands to keep, ``kmax`` may only be supplied when using; the ``FMESolver``; - The ``Tsteps`` parameter has been removed from both ``fsesolve`` and; ``fmmesolve``. The ``precompute`` option to ``FloquetBasis`` may be used; instead. Evolution of State Solver (essovle):. - The function ``essolve`` has been removed. Use the ``diag`` integration; method with ``sesolve`` or ``mesolve`` instead. Steady-state solvers (steadystate module):. - The ``method`` parameter and ``solver`` parameters have been separated. Previously; they were mixed together in the ``method`` parameter.; - The previous options are now passed as parameters to the steady state; solver and mostly passed through to the underlying SciPy functions.; - The logging and statistics have been removed. Correlation functions (correlation module):. - A new ``correlation_3op`` function has been added. It supports ``MESolver``; or ``BRMESolver``.; - The ``correlation``, ``correlation_4op``, and ``correlation_ss`` functions have been; removed.; - Support for calculating correlation with ``mcsolve`` has been removed. Propagators (propagator module):. - A class interface, ``qutip.Propagator``, has been added for propagators.; - Propagation of time-dependent systems is now supported using ``QobjEvo``.; - The ``unitary_mode`` and ``parallel`` options have been removed. Correlation spec",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:20963,Integrability,interface,interface,20963,"``fsesolve`` and; ``fmmesolve``. The ``precompute`` option to ``FloquetBasis`` may be used; instead. Evolution of State Solver (essovle):. - The function ``essolve`` has been removed. Use the ``diag`` integration; method with ``sesolve`` or ``mesolve`` instead. Steady-state solvers (steadystate module):. - The ``method`` parameter and ``solver`` parameters have been separated. Previously; they were mixed together in the ``method`` parameter.; - The previous options are now passed as parameters to the steady state; solver and mostly passed through to the underlying SciPy functions.; - The logging and statistics have been removed. Correlation functions (correlation module):. - A new ``correlation_3op`` function has been added. It supports ``MESolver``; or ``BRMESolver``.; - The ``correlation``, ``correlation_4op``, and ``correlation_ss`` functions have been; removed.; - Support for calculating correlation with ``mcsolve`` has been removed. Propagators (propagator module):. - A class interface, ``qutip.Propagator``, has been added for propagators.; - Propagation of time-dependent systems is now supported using ``QobjEvo``.; - The ``unitary_mode`` and ``parallel`` options have been removed. Correlation spectra (spectrum module):. - The functions ``spectrum_ss`` and ``spectrum_pi`` have been removed and; are now internal functions.; - The ``use_pinv`` parameter for ``spectrum`` has been removed and the; functionality merged into the ``solver`` parameter. Use ``solver=""pi""``; instead. Hierarchical Equation of Motion Solver (HEOM). - Updated the solver to use the new QuTiP integrators and data layer.; - Updated all the HEOM tutorials to QuTiP 5.; - Added support for combining bosonic and fermionic baths.; - Sped up the construction of the RHS of the HEOM solver by a factor of 4x.; - As in QuTiP 4, the HEOM supports arbitrary spectral densities, bosonic and fermionic baths, Pde and Matsubara expansions of the correlation functions, calculating the Matsubara terminator and ",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:21051,Integrability,depend,dependent,21051,"d. Evolution of State Solver (essovle):. - The function ``essolve`` has been removed. Use the ``diag`` integration; method with ``sesolve`` or ``mesolve`` instead. Steady-state solvers (steadystate module):. - The ``method`` parameter and ``solver`` parameters have been separated. Previously; they were mixed together in the ``method`` parameter.; - The previous options are now passed as parameters to the steady state; solver and mostly passed through to the underlying SciPy functions.; - The logging and statistics have been removed. Correlation functions (correlation module):. - A new ``correlation_3op`` function has been added. It supports ``MESolver``; or ``BRMESolver``.; - The ``correlation``, ``correlation_4op``, and ``correlation_ss`` functions have been; removed.; - Support for calculating correlation with ``mcsolve`` has been removed. Propagators (propagator module):. - A class interface, ``qutip.Propagator``, has been added for propagators.; - Propagation of time-dependent systems is now supported using ``QobjEvo``.; - The ``unitary_mode`` and ``parallel`` options have been removed. Correlation spectra (spectrum module):. - The functions ``spectrum_ss`` and ``spectrum_pi`` have been removed and; are now internal functions.; - The ``use_pinv`` parameter for ``spectrum`` has been removed and the; functionality merged into the ``solver`` parameter. Use ``solver=""pi""``; instead. Hierarchical Equation of Motion Solver (HEOM). - Updated the solver to use the new QuTiP integrators and data layer.; - Updated all the HEOM tutorials to QuTiP 5.; - Added support for combining bosonic and fermionic baths.; - Sped up the construction of the RHS of the HEOM solver by a factor of 4x.; - As in QuTiP 4, the HEOM supports arbitrary spectral densities, bosonic and fermionic baths, Pde and Matsubara expansions of the correlation functions, calculating the Matsubara terminator and inspection of the ADOs (auxiliary density operators). QuTiP core; ----------. There have been numer",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:21560,Integrability,integrat,integrators,21560,"s.; - The logging and statistics have been removed. Correlation functions (correlation module):. - A new ``correlation_3op`` function has been added. It supports ``MESolver``; or ``BRMESolver``.; - The ``correlation``, ``correlation_4op``, and ``correlation_ss`` functions have been; removed.; - Support for calculating correlation with ``mcsolve`` has been removed. Propagators (propagator module):. - A class interface, ``qutip.Propagator``, has been added for propagators.; - Propagation of time-dependent systems is now supported using ``QobjEvo``.; - The ``unitary_mode`` and ``parallel`` options have been removed. Correlation spectra (spectrum module):. - The functions ``spectrum_ss`` and ``spectrum_pi`` have been removed and; are now internal functions.; - The ``use_pinv`` parameter for ``spectrum`` has been removed and the; functionality merged into the ``solver`` parameter. Use ``solver=""pi""``; instead. Hierarchical Equation of Motion Solver (HEOM). - Updated the solver to use the new QuTiP integrators and data layer.; - Updated all the HEOM tutorials to QuTiP 5.; - Added support for combining bosonic and fermionic baths.; - Sped up the construction of the RHS of the HEOM solver by a factor of 4x.; - As in QuTiP 4, the HEOM supports arbitrary spectral densities, bosonic and fermionic baths, Pde and Matsubara expansions of the correlation functions, calculating the Matsubara terminator and inspection of the ADOs (auxiliary density operators). QuTiP core; ----------. There have been numerous other small changes to core QuTiP features:. - ``qft(...)`` the function that returns the quantum Fourier; transform operator was moved from ``qutip.qip.algorithm`` into ``qutip``.; - The Bloch-Redfield solver tensor, ``brtensor``, has been moved into; ``qutip.core``. See the section above on the Bloch-Redfield solver; for details.; - The functions ``mat2vec`` and ``vec2mat`` for transforming states to and; from super-operator states have been renamed to ``stack_columns`` and; ",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:27650,Integrability,interface,interface,27650," in a future QuTiP release.; - The ``qutip.parfor`` function has been removed. Use ``qutip.parallel_map`` instead.; - ``qutip.graph`` has been removed and replaced by SciPy's graph functions.; - ``qutip.topology`` has been removed. It contained only one function ``berry_curvature``.; - The ``~/.qutip/qutiprc`` config file is no longer supported. It contained settings for the OpenMP support.; - Deprecate ``three_level_atom``; - Deprecate ``orbital``. Changes from QuTiP 5.0.0b1:; ---------------------------. Features; --------. - Add dtype to printed ouput of qobj (#2352 by Rochisha Agarwal). Miscellaneous; -------------. - Allow scipy 1.12 to be used with qutip. (#2354 by Pieter Eendebak). QuTiP 5.0.0b1 (2024-03-04); ==========================. Features; --------. - Create a Dimension class (#1996); - Add arguments of plot_wigner() and plot_wigner_fock_distribution() to specify parameters for wigner(). (#2057, by Kosuke Mizuno); - Restore feedback to solvers (#2210); - Added mpi_pmap, which uses the mpi4py module to run computations in parallel through the MPI interface. (#2296, by Paul); - Only pre-compute density matrices if keep_runs_results is False (#2303, by Matt Ord). Bug Fixes; ---------. - Add the possibility to customize point colors as in V4 and fix point plot behavior for 'l' style (#1974, by Daniel Moreno Galn); - Disabled broken ""improved sampling"" for `nm_mcsolve`. (#2234, by Paul); - Fixed result objects storing a reference to the solver through options._feedback. (#2262, by Paul); - Fixed simdiag not returning orthonormal eigenvectors. (#2269, by Sola85); - Fix LaTeX display of Qobj state in Jupyter cell outputs (#2272, by Edward Thomas); - Improved behavior of `parallel_map` and `loky_pmap` in the case of timeouts, errors or keyboard interrupts (#2280, by Paul); - Ignore deprecation warnings from cython 0.29.X in tests. (#2288); - Fixed two problems with the steady_state() solver in the HEOM method. (#2333). Miscellaneous; -------------. - Improve ",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:30138,Integrability,interface,interface,30138,"rt degenerate operators. (#2342). QuTiP 5.0.0a2 (2023-09-06); ==========================. Features; --------. - Add support for different spectra types for bloch_redfield_tensor (#1951); - Improve qutip import times by setting logger names explicitly. (#1981, by Pieter Eendebak); - Change the order of parameters in expand_operator (#1991); - Add `svn` and `solve` to dispatched (#2002); - Added nm_mcsolve to provide support for Monte-Carlo simulations of master equations with possibly negative rates. The method implemented here is described in arXiv:2209.08958 [quant-ph]. (#2070 by pmenczel); - Add support for combining bosonic and fermionic HEOM baths (#2089); - Added __repr__ to QobjEvo (#2111 by lklivingstone); - Improve print(qutip.settings) by make it shorter (#2113 by tamakoshi2001); - Create the `trace_oper_ket` operation (#2126); - Speed up the construction of the RHS of the HEOM solver by a factor of 4x by converting the final step to Cython. (#2128); - Rewrite the stochastic solver to use the v5 solver interface. (#2131); - Add `Qobj.get` to extract underlying data in original format. (#2141); - Add qeye_like and qzero_like (#2153); - Add capacity to dispatch on ``Data`` (#2157); - Added fermionic annihilation and creation operators. (#2166 by khnikhil); - Changed arguments and applied colorblind_safe to functions in visualization.py (#2170 by Yuji Tamakoshi); - Changed arguments and applied colorblind_safe to plot_wigner_sphere and matrix_histogram in visualization.py (#2193 by Yuji Tamakoshi); - Added Dia data layer which represents operators as multi-diagonal matrices. (#2196); - Added support for animated plots. (#2203 by Yuji Tamakoshi); - Improved sampling algorithm for mcsolve (#2218 by Daniel Weiss); - Added support for early termination of map functions. (#2222). Bug Fixes; ---------. - Add missing state transformation to floquet_markov_mesolve (#1952 by christian512); - Added default _isherm value (True) for momentum and position operators. (#2032 ",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:33707,Integrability,depend,dependent,33707," creating QobjEvo (#2114 by Avatar Srinidhi P V ); - Remove Windows build warning suppression. (#2119); - Optimize dispatcher by dispatching on positional only args. (#2135); - Clean semidefinite (#2138); - Migrate `transfertensor.py` to solver (#2142); - Add a test for progress_bar (#2150); - Enable cython 3 (#2151); - Added tests for visualization.py (#2192 by Yuji Tamakoshi); - Sorted arguments of sphereplot so that the order is similar to those of plot_spin_distribution (#2219 by Yuji Tamakoshi). Version 5.0.0a1 (February 7, 2023); ++++++++++++++++++++++++++++++++++. QuTiP 5 is a redesign of many of the core components of QuTiP (``Qobj``,; ``QobjEvo``, solvers) to make them more consistent and more flexible. ``Qobj`` may now be stored in either sparse or dense representations,; and the two may be mixed sensibly as needed. ``QobjEvo`` is now used; consistently throughout QuTiP, and the implementation has been; substantially cleaned up. A new ``Coefficient`` class is used to; represent the time-dependent factors inside ``QobjEvo``. The solvers have been rewritten to work well with the new data layer; and the concept of ``Integrators`` which solve ODEs has been introduced.; In future, new data layers may provide their own ``Integrators``; specialized to their representation of the underlying data. Much of the user-facing API of QuTiP remains familiar, but there have; had to be many small breaking changes. If we can make changes to; easy migrating code from QuTiP 4 to QuTiP 5, please let us know. Any extensive list of changes follows. Contributors; ------------. QuTiP 5 has been a large effort by many people over the last three years. In particular:. - Jake Lishman led the implementation of the new data layer and coefficients.; - Eric Gigure led the implementation of the new QobjEvo interface and solvers.; - Boxi Li led the updating of QuTiP's QIP support and the creation of ``qutip_qip``. Other members of the QuTiP Admin team have been heavily involved in reviewing",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:34510,Integrability,interface,interface,34510," the two may be mixed sensibly as needed. ``QobjEvo`` is now used; consistently throughout QuTiP, and the implementation has been; substantially cleaned up. A new ``Coefficient`` class is used to; represent the time-dependent factors inside ``QobjEvo``. The solvers have been rewritten to work well with the new data layer; and the concept of ``Integrators`` which solve ODEs has been introduced.; In future, new data layers may provide their own ``Integrators``; specialized to their representation of the underlying data. Much of the user-facing API of QuTiP remains familiar, but there have; had to be many small breaking changes. If we can make changes to; easy migrating code from QuTiP 4 to QuTiP 5, please let us know. Any extensive list of changes follows. Contributors; ------------. QuTiP 5 has been a large effort by many people over the last three years. In particular:. - Jake Lishman led the implementation of the new data layer and coefficients.; - Eric Gigure led the implementation of the new QobjEvo interface and solvers.; - Boxi Li led the updating of QuTiP's QIP support and the creation of ``qutip_qip``. Other members of the QuTiP Admin team have been heavily involved in reviewing,; testing and designing QuTiP 5:. - Alexander Pitchford; - Asier Galicia; - Nathan Shammah; - Shahnawaz Ahmed; - Neill Lambert; - Simon Cross. Two Google Summer of Code contributors updated the tutorials and benchmarks to; QuTiP 5:. - Christian Staufenbiel updated many of the tutorials (`<https://github.com/qutip/qutip-tutorials/>`).; - Xavier Sproken update the benchmarks (`<https://github.com/qutip/qutip-benchmark/>`). Four experimental data layers backends were written either as part of Google Summer; of Code or as separate projects. While these are still alpha quality, the helped; significantly to test the data layer API:. - ``qutip-tensorflow``: a TensorFlow backend by Asier Galicia (`<https://github.com/qutip/qutip-tensorflow>`); - ``qutip-cupy``: a CuPy GPU backend by Felipe Bi",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:38696,Integrability,contract,contract,38696,"ata is still acessible via the ``.data`` attribute, but is now an; instance of the underlying data type instead of a SciPy-like sparse matrix.; The operations available in ``qutip.core.data`` may be used on ``.data``,; regardless of the data type.; - ``Qobj`` with different data types may be mixed in arithmetic and other; operations. A sensible output type will be automatically determined.; - The new ``.to(...)`` method may be used to convert a ``Qobj`` from one data type; to another. E.g. ``.to(""dense"")`` will convert to the dense representation and; ``.to(""csr"")`` will convert to the sparse type.; - Many ``Qobj`` methods and methods that create ``Qobj`` now accepted a ``dtype``; parameter that allows the data type of the returned ``Qobj`` to specified.; - The new ``&`` operator may be used to obtain the tensor product.; - The new ``@`` operator may be used to obtain the matrix / operator product.; ``bar @ ket`` returns a scalar.; - The new ``.contract()`` method will collapse 1D subspaces of the dimensions of; the ``Qobj``.; - The new ``.logm()`` method returns the matrix logarithm of an operator.; - The methods ``.set_data``, ``.get_data``, ``.extract_state``, ``.eliminate_states``,; ``.evaluate`` and ``.check_isunitary`` have been removed. QobjEvo changes; ---------------. The ``QobjEvo`` type for storing time-dependent quantum objects has been; significantly expanded, standardized and extended. The time-dependent; coefficients are now represented using a new ``Coefficient`` type that; may be independently created and manipulated if required. Some highlights:. - The ``.compile()`` method has been removed. Coefficients specified as; strings are automatically compiled if possible and the compilation is; cached across different Python runs and instances.; - Mixing coefficient types within a single ``Qobj`` is now supported.; - Many new attributes were added to ``QobjEvo`` for convenience. Examples; include ``.dims``, ``.shape``, ``.superrep`` and ``.isconstant``.; ",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:39073,Integrability,depend,dependent,39073,"will be automatically determined.; - The new ``.to(...)`` method may be used to convert a ``Qobj`` from one data type; to another. E.g. ``.to(""dense"")`` will convert to the dense representation and; ``.to(""csr"")`` will convert to the sparse type.; - Many ``Qobj`` methods and methods that create ``Qobj`` now accepted a ``dtype``; parameter that allows the data type of the returned ``Qobj`` to specified.; - The new ``&`` operator may be used to obtain the tensor product.; - The new ``@`` operator may be used to obtain the matrix / operator product.; ``bar @ ket`` returns a scalar.; - The new ``.contract()`` method will collapse 1D subspaces of the dimensions of; the ``Qobj``.; - The new ``.logm()`` method returns the matrix logarithm of an operator.; - The methods ``.set_data``, ``.get_data``, ``.extract_state``, ``.eliminate_states``,; ``.evaluate`` and ``.check_isunitary`` have been removed. QobjEvo changes; ---------------. The ``QobjEvo`` type for storing time-dependent quantum objects has been; significantly expanded, standardized and extended. The time-dependent; coefficients are now represented using a new ``Coefficient`` type that; may be independently created and manipulated if required. Some highlights:. - The ``.compile()`` method has been removed. Coefficients specified as; strings are automatically compiled if possible and the compilation is; cached across different Python runs and instances.; - Mixing coefficient types within a single ``Qobj`` is now supported.; - Many new attributes were added to ``QobjEvo`` for convenience. Examples; include ``.dims``, ``.shape``, ``.superrep`` and ``.isconstant``.; - Many old attributes such as ``.cte``, ``.use_cython``, ``.type``, ``.const``,; and ``.coeff_file`` were removed.; - A new ``Spline`` coefficient supports spline interpolations of different; orders. The old ``Cubic_Spline`` coefficient has been removed.; - The new ``.arguments(...)`` method allows additional arguments to the; underlying coefficient function",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:39169,Integrability,depend,dependent,39169,".to(""dense"")`` will convert to the dense representation and; ``.to(""csr"")`` will convert to the sparse type.; - Many ``Qobj`` methods and methods that create ``Qobj`` now accepted a ``dtype``; parameter that allows the data type of the returned ``Qobj`` to specified.; - The new ``&`` operator may be used to obtain the tensor product.; - The new ``@`` operator may be used to obtain the matrix / operator product.; ``bar @ ket`` returns a scalar.; - The new ``.contract()`` method will collapse 1D subspaces of the dimensions of; the ``Qobj``.; - The new ``.logm()`` method returns the matrix logarithm of an operator.; - The methods ``.set_data``, ``.get_data``, ``.extract_state``, ``.eliminate_states``,; ``.evaluate`` and ``.check_isunitary`` have been removed. QobjEvo changes; ---------------. The ``QobjEvo`` type for storing time-dependent quantum objects has been; significantly expanded, standardized and extended. The time-dependent; coefficients are now represented using a new ``Coefficient`` type that; may be independently created and manipulated if required. Some highlights:. - The ``.compile()`` method has been removed. Coefficients specified as; strings are automatically compiled if possible and the compilation is; cached across different Python runs and instances.; - Mixing coefficient types within a single ``Qobj`` is now supported.; - Many new attributes were added to ``QobjEvo`` for convenience. Examples; include ``.dims``, ``.shape``, ``.superrep`` and ``.isconstant``.; - Many old attributes such as ``.cte``, ``.use_cython``, ``.type``, ``.const``,; and ``.coeff_file`` were removed.; - A new ``Spline`` coefficient supports spline interpolations of different; orders. The old ``Cubic_Spline`` coefficient has been removed.; - The new ``.arguments(...)`` method allows additional arguments to the; underlying coefficient functions to be updated.; - The ``_step_func_coeff`` argument has been replaced by the ``order``; parameter. ``_step_func_coeff=False`` is equiva",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:41022,Integrability,integrat,integrator,41022,"onal arguments to the; underlying coefficient functions to be updated.; - The ``_step_func_coeff`` argument has been replaced by the ``order``; parameter. ``_step_func_coeff=False`` is equivalent to ``order=3``.; ``_step_func_coeff=True`` is equivalent to ``order=0``. Higher values; of ``order`` gives spline interpolations of higher orders. Solver changes; --------------. The solvers in QuTiP have been heavily reworked and standardized.; Under the hood solvers now make use of swappable ODE ``Integrators``.; Many ``Integrators`` are included (see the list below) and; custom implementations are possible. Solvers now consistently; accept a ``QobjEvo`` instance at the Hamiltonian or Liouvillian, or; any object which can be passed to the ``QobjEvo`` constructor. A breakdown of highlights follows. All solvers:. - Solver options are now supplied in an ordinary Python dict.; ``qutip.Options`` is deprecated and returns a dict for backwards; compatibility.; - A specific ODE integrator may be selected by supplying a; ``method`` option.; - Each solver provides a class interface. Creating an instance; of the class allows a solver to be run multiple times for the; same system without having to repeatedly reconstruct the; right-hand side of the ODE to be integrated.; - A ``QobjEvo`` instance is accepted for most operators, e.g.,; ``H``, ``c_ops``, ``e_ops``, ``a_ops``.; - The progress bar is now selected using the ``progress_bar`` option.; A new progess bar using the ``tqdm`` Python library is provided.; - Dynamic arguments, where the value of an operator depends on; the current state of the evolution, have been removed. They; may be re-implemented later if there is demand for them. Integrators:. - The SciPy zvode integrator is available with the BDF and; Adams methods as ``bdf`` and ``adams``.; - The SciPy dop853 integrator (an eighth order Runge-Kutta method by; Dormand & Prince) is available as ``dop853``.; - The SciPy lsoda integrator is available as ``lsoda``.; - QuTiP's own ",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:41116,Integrability,interface,interface,41116," updated.; - The ``_step_func_coeff`` argument has been replaced by the ``order``; parameter. ``_step_func_coeff=False`` is equivalent to ``order=3``.; ``_step_func_coeff=True`` is equivalent to ``order=0``. Higher values; of ``order`` gives spline interpolations of higher orders. Solver changes; --------------. The solvers in QuTiP have been heavily reworked and standardized.; Under the hood solvers now make use of swappable ODE ``Integrators``.; Many ``Integrators`` are included (see the list below) and; custom implementations are possible. Solvers now consistently; accept a ``QobjEvo`` instance at the Hamiltonian or Liouvillian, or; any object which can be passed to the ``QobjEvo`` constructor. A breakdown of highlights follows. All solvers:. - Solver options are now supplied in an ordinary Python dict.; ``qutip.Options`` is deprecated and returns a dict for backwards; compatibility.; - A specific ODE integrator may be selected by supplying a; ``method`` option.; - Each solver provides a class interface. Creating an instance; of the class allows a solver to be run multiple times for the; same system without having to repeatedly reconstruct the; right-hand side of the ODE to be integrated.; - A ``QobjEvo`` instance is accepted for most operators, e.g.,; ``H``, ``c_ops``, ``e_ops``, ``a_ops``.; - The progress bar is now selected using the ``progress_bar`` option.; A new progess bar using the ``tqdm`` Python library is provided.; - Dynamic arguments, where the value of an operator depends on; the current state of the evolution, have been removed. They; may be re-implemented later if there is demand for them. Integrators:. - The SciPy zvode integrator is available with the BDF and; Adams methods as ``bdf`` and ``adams``.; - The SciPy dop853 integrator (an eighth order Runge-Kutta method by; Dormand & Prince) is available as ``dop853``.; - The SciPy lsoda integrator is available as ``lsoda``.; - QuTiP's own implementation of Verner's ""most efficient"" Runge-Kutta method",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:41303,Integrability,integrat,integrated,41303,"se`` is equivalent to ``order=3``.; ``_step_func_coeff=True`` is equivalent to ``order=0``. Higher values; of ``order`` gives spline interpolations of higher orders. Solver changes; --------------. The solvers in QuTiP have been heavily reworked and standardized.; Under the hood solvers now make use of swappable ODE ``Integrators``.; Many ``Integrators`` are included (see the list below) and; custom implementations are possible. Solvers now consistently; accept a ``QobjEvo`` instance at the Hamiltonian or Liouvillian, or; any object which can be passed to the ``QobjEvo`` constructor. A breakdown of highlights follows. All solvers:. - Solver options are now supplied in an ordinary Python dict.; ``qutip.Options`` is deprecated and returns a dict for backwards; compatibility.; - A specific ODE integrator may be selected by supplying a; ``method`` option.; - Each solver provides a class interface. Creating an instance; of the class allows a solver to be run multiple times for the; same system without having to repeatedly reconstruct the; right-hand side of the ODE to be integrated.; - A ``QobjEvo`` instance is accepted for most operators, e.g.,; ``H``, ``c_ops``, ``e_ops``, ``a_ops``.; - The progress bar is now selected using the ``progress_bar`` option.; A new progess bar using the ``tqdm`` Python library is provided.; - Dynamic arguments, where the value of an operator depends on; the current state of the evolution, have been removed. They; may be re-implemented later if there is demand for them. Integrators:. - The SciPy zvode integrator is available with the BDF and; Adams methods as ``bdf`` and ``adams``.; - The SciPy dop853 integrator (an eighth order Runge-Kutta method by; Dormand & Prince) is available as ``dop853``.; - The SciPy lsoda integrator is available as ``lsoda``.; - QuTiP's own implementation of Verner's ""most efficient"" Runge-Kutta methods; of order 7 and 9 are available as ``vern7`` and ``vern9``. See; http://people.math.sfu.ca/~jverner/ for a descri",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:41610,Integrability,depend,depends,41610,"custom implementations are possible. Solvers now consistently; accept a ``QobjEvo`` instance at the Hamiltonian or Liouvillian, or; any object which can be passed to the ``QobjEvo`` constructor. A breakdown of highlights follows. All solvers:. - Solver options are now supplied in an ordinary Python dict.; ``qutip.Options`` is deprecated and returns a dict for backwards; compatibility.; - A specific ODE integrator may be selected by supplying a; ``method`` option.; - Each solver provides a class interface. Creating an instance; of the class allows a solver to be run multiple times for the; same system without having to repeatedly reconstruct the; right-hand side of the ODE to be integrated.; - A ``QobjEvo`` instance is accepted for most operators, e.g.,; ``H``, ``c_ops``, ``e_ops``, ``a_ops``.; - The progress bar is now selected using the ``progress_bar`` option.; A new progess bar using the ``tqdm`` Python library is provided.; - Dynamic arguments, where the value of an operator depends on; the current state of the evolution, have been removed. They; may be re-implemented later if there is demand for them. Integrators:. - The SciPy zvode integrator is available with the BDF and; Adams methods as ``bdf`` and ``adams``.; - The SciPy dop853 integrator (an eighth order Runge-Kutta method by; Dormand & Prince) is available as ``dop853``.; - The SciPy lsoda integrator is available as ``lsoda``.; - QuTiP's own implementation of Verner's ""most efficient"" Runge-Kutta methods; of order 7 and 9 are available as ``vern7`` and ``vern9``. See; http://people.math.sfu.ca/~jverner/ for a description of the methods.; - QuTiP's own implementation of a solver that directly diagonalizes the; the system to be integrated is available as ``diag``. It only works on; time-independent systems and is slow to setup, but once the diagonalization; is complete, it generates solutions very quickly.; - QuTiP's own implementatoin of an approximate Krylov subspace integrator is; available as ``krylov`",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:41772,Integrability,integrat,integrator,41772,"ructor. A breakdown of highlights follows. All solvers:. - Solver options are now supplied in an ordinary Python dict.; ``qutip.Options`` is deprecated and returns a dict for backwards; compatibility.; - A specific ODE integrator may be selected by supplying a; ``method`` option.; - Each solver provides a class interface. Creating an instance; of the class allows a solver to be run multiple times for the; same system without having to repeatedly reconstruct the; right-hand side of the ODE to be integrated.; - A ``QobjEvo`` instance is accepted for most operators, e.g.,; ``H``, ``c_ops``, ``e_ops``, ``a_ops``.; - The progress bar is now selected using the ``progress_bar`` option.; A new progess bar using the ``tqdm`` Python library is provided.; - Dynamic arguments, where the value of an operator depends on; the current state of the evolution, have been removed. They; may be re-implemented later if there is demand for them. Integrators:. - The SciPy zvode integrator is available with the BDF and; Adams methods as ``bdf`` and ``adams``.; - The SciPy dop853 integrator (an eighth order Runge-Kutta method by; Dormand & Prince) is available as ``dop853``.; - The SciPy lsoda integrator is available as ``lsoda``.; - QuTiP's own implementation of Verner's ""most efficient"" Runge-Kutta methods; of order 7 and 9 are available as ``vern7`` and ``vern9``. See; http://people.math.sfu.ca/~jverner/ for a description of the methods.; - QuTiP's own implementation of a solver that directly diagonalizes the; the system to be integrated is available as ``diag``. It only works on; time-independent systems and is slow to setup, but once the diagonalization; is complete, it generates solutions very quickly.; - QuTiP's own implementatoin of an approximate Krylov subspace integrator is; available as ``krylov``. This integrator is only usable with ``sesolve``. Result class:. - A new ``.e_data`` attribute provides expectation values as a dictionary.; Unlike ``.expect``, the values are provided ",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:41874,Integrability,integrat,integrator,41874,"thon dict.; ``qutip.Options`` is deprecated and returns a dict for backwards; compatibility.; - A specific ODE integrator may be selected by supplying a; ``method`` option.; - Each solver provides a class interface. Creating an instance; of the class allows a solver to be run multiple times for the; same system without having to repeatedly reconstruct the; right-hand side of the ODE to be integrated.; - A ``QobjEvo`` instance is accepted for most operators, e.g.,; ``H``, ``c_ops``, ``e_ops``, ``a_ops``.; - The progress bar is now selected using the ``progress_bar`` option.; A new progess bar using the ``tqdm`` Python library is provided.; - Dynamic arguments, where the value of an operator depends on; the current state of the evolution, have been removed. They; may be re-implemented later if there is demand for them. Integrators:. - The SciPy zvode integrator is available with the BDF and; Adams methods as ``bdf`` and ``adams``.; - The SciPy dop853 integrator (an eighth order Runge-Kutta method by; Dormand & Prince) is available as ``dop853``.; - The SciPy lsoda integrator is available as ``lsoda``.; - QuTiP's own implementation of Verner's ""most efficient"" Runge-Kutta methods; of order 7 and 9 are available as ``vern7`` and ``vern9``. See; http://people.math.sfu.ca/~jverner/ for a description of the methods.; - QuTiP's own implementation of a solver that directly diagonalizes the; the system to be integrated is available as ``diag``. It only works on; time-independent systems and is slow to setup, but once the diagonalization; is complete, it generates solutions very quickly.; - QuTiP's own implementatoin of an approximate Krylov subspace integrator is; available as ``krylov``. This integrator is only usable with ``sesolve``. Result class:. - A new ``.e_data`` attribute provides expectation values as a dictionary.; Unlike ``.expect``, the values are provided in a Python list rather than; a numpy array, which better supports non-numeric types.; - The contents of the ",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:41990,Integrability,integrat,integrator,41990,"lity.; - A specific ODE integrator may be selected by supplying a; ``method`` option.; - Each solver provides a class interface. Creating an instance; of the class allows a solver to be run multiple times for the; same system without having to repeatedly reconstruct the; right-hand side of the ODE to be integrated.; - A ``QobjEvo`` instance is accepted for most operators, e.g.,; ``H``, ``c_ops``, ``e_ops``, ``a_ops``.; - The progress bar is now selected using the ``progress_bar`` option.; A new progess bar using the ``tqdm`` Python library is provided.; - Dynamic arguments, where the value of an operator depends on; the current state of the evolution, have been removed. They; may be re-implemented later if there is demand for them. Integrators:. - The SciPy zvode integrator is available with the BDF and; Adams methods as ``bdf`` and ``adams``.; - The SciPy dop853 integrator (an eighth order Runge-Kutta method by; Dormand & Prince) is available as ``dop853``.; - The SciPy lsoda integrator is available as ``lsoda``.; - QuTiP's own implementation of Verner's ""most efficient"" Runge-Kutta methods; of order 7 and 9 are available as ``vern7`` and ``vern9``. See; http://people.math.sfu.ca/~jverner/ for a description of the methods.; - QuTiP's own implementation of a solver that directly diagonalizes the; the system to be integrated is available as ``diag``. It only works on; time-independent systems and is slow to setup, but once the diagonalization; is complete, it generates solutions very quickly.; - QuTiP's own implementatoin of an approximate Krylov subspace integrator is; available as ``krylov``. This integrator is only usable with ``sesolve``. Result class:. - A new ``.e_data`` attribute provides expectation values as a dictionary.; Unlike ``.expect``, the values are provided in a Python list rather than; a numpy array, which better supports non-numeric types.; - The contents of the ``.stats`` attribute changed significantly and is; now more consistent across solvers. ",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:42333,Integrability,integrat,integrated,42333,"tegrated.; - A ``QobjEvo`` instance is accepted for most operators, e.g.,; ``H``, ``c_ops``, ``e_ops``, ``a_ops``.; - The progress bar is now selected using the ``progress_bar`` option.; A new progess bar using the ``tqdm`` Python library is provided.; - Dynamic arguments, where the value of an operator depends on; the current state of the evolution, have been removed. They; may be re-implemented later if there is demand for them. Integrators:. - The SciPy zvode integrator is available with the BDF and; Adams methods as ``bdf`` and ``adams``.; - The SciPy dop853 integrator (an eighth order Runge-Kutta method by; Dormand & Prince) is available as ``dop853``.; - The SciPy lsoda integrator is available as ``lsoda``.; - QuTiP's own implementation of Verner's ""most efficient"" Runge-Kutta methods; of order 7 and 9 are available as ``vern7`` and ``vern9``. See; http://people.math.sfu.ca/~jverner/ for a description of the methods.; - QuTiP's own implementation of a solver that directly diagonalizes the; the system to be integrated is available as ``diag``. It only works on; time-independent systems and is slow to setup, but once the diagonalization; is complete, it generates solutions very quickly.; - QuTiP's own implementatoin of an approximate Krylov subspace integrator is; available as ``krylov``. This integrator is only usable with ``sesolve``. Result class:. - A new ``.e_data`` attribute provides expectation values as a dictionary.; Unlike ``.expect``, the values are provided in a Python list rather than; a numpy array, which better supports non-numeric types.; - The contents of the ``.stats`` attribute changed significantly and is; now more consistent across solvers. Monte-Carlo Solver (mcsolve):. - The system, H, may now be a super-operator.; - The ``seed`` parameter now supports supplying numpy ``SeedSequence`` or; ``Generator`` types.; - The new ``timeout`` and ``target_tol`` parameters allow the solver to exit; early if a timeout or target tolerance is reached.; -",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:42579,Integrability,integrat,integrator,42579,"c arguments, where the value of an operator depends on; the current state of the evolution, have been removed. They; may be re-implemented later if there is demand for them. Integrators:. - The SciPy zvode integrator is available with the BDF and; Adams methods as ``bdf`` and ``adams``.; - The SciPy dop853 integrator (an eighth order Runge-Kutta method by; Dormand & Prince) is available as ``dop853``.; - The SciPy lsoda integrator is available as ``lsoda``.; - QuTiP's own implementation of Verner's ""most efficient"" Runge-Kutta methods; of order 7 and 9 are available as ``vern7`` and ``vern9``. See; http://people.math.sfu.ca/~jverner/ for a description of the methods.; - QuTiP's own implementation of a solver that directly diagonalizes the; the system to be integrated is available as ``diag``. It only works on; time-independent systems and is slow to setup, but once the diagonalization; is complete, it generates solutions very quickly.; - QuTiP's own implementatoin of an approximate Krylov subspace integrator is; available as ``krylov``. This integrator is only usable with ``sesolve``. Result class:. - A new ``.e_data`` attribute provides expectation values as a dictionary.; Unlike ``.expect``, the values are provided in a Python list rather than; a numpy array, which better supports non-numeric types.; - The contents of the ``.stats`` attribute changed significantly and is; now more consistent across solvers. Monte-Carlo Solver (mcsolve):. - The system, H, may now be a super-operator.; - The ``seed`` parameter now supports supplying numpy ``SeedSequence`` or; ``Generator`` types.; - The new ``timeout`` and ``target_tol`` parameters allow the solver to exit; early if a timeout or target tolerance is reached.; - The ntraj option no longer supports a list of numbers of trajectories.; Instead, just run the solver multiple times and use the class ``MCSolver``; if setting up the solver uses a significant amount of time.; - The ``map_func`` parameter has been replaced by t",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:42624,Integrability,integrat,integrator,42624," the evolution, have been removed. They; may be re-implemented later if there is demand for them. Integrators:. - The SciPy zvode integrator is available with the BDF and; Adams methods as ``bdf`` and ``adams``.; - The SciPy dop853 integrator (an eighth order Runge-Kutta method by; Dormand & Prince) is available as ``dop853``.; - The SciPy lsoda integrator is available as ``lsoda``.; - QuTiP's own implementation of Verner's ""most efficient"" Runge-Kutta methods; of order 7 and 9 are available as ``vern7`` and ``vern9``. See; http://people.math.sfu.ca/~jverner/ for a description of the methods.; - QuTiP's own implementation of a solver that directly diagonalizes the; the system to be integrated is available as ``diag``. It only works on; time-independent systems and is slow to setup, but once the diagonalization; is complete, it generates solutions very quickly.; - QuTiP's own implementatoin of an approximate Krylov subspace integrator is; available as ``krylov``. This integrator is only usable with ``sesolve``. Result class:. - A new ``.e_data`` attribute provides expectation values as a dictionary.; Unlike ``.expect``, the values are provided in a Python list rather than; a numpy array, which better supports non-numeric types.; - The contents of the ``.stats`` attribute changed significantly and is; now more consistent across solvers. Monte-Carlo Solver (mcsolve):. - The system, H, may now be a super-operator.; - The ``seed`` parameter now supports supplying numpy ``SeedSequence`` or; ``Generator`` types.; - The new ``timeout`` and ``target_tol`` parameters allow the solver to exit; early if a timeout or target tolerance is reached.; - The ntraj option no longer supports a list of numbers of trajectories.; Instead, just run the solver multiple times and use the class ``MCSolver``; if setting up the solver uses a significant amount of time.; - The ``map_func`` parameter has been replaced by the ``map`` option. In; addition to the existing ``serial`` and ``parallel`` v",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:44477,Integrability,integrat,integrator,44477,"`MCSolver``; if setting up the solver uses a significant amount of time.; - The ``map_func`` parameter has been replaced by the ``map`` option. In; addition to the existing ``serial`` and ``parallel`` values, the value; ``loky`` may be supplied to use the loky package to parallelize trajectories.; - The result returned by ``mcsolve`` now supports calculating photocurrents; and calculating the steady state over N trajectories.; - The old ``parfor`` parallel execution function has been removed from; ``qutip.parallel``. Use ``parallel_map`` or ``loky_map`` instead. Bloch-Redfield Master Equation Solver (brmesolve):. - The ``a_ops`` and ``spectra`` support implementaitons been heavily reworked to; reuse the techniques from the new Coefficient and QobjEvo classes.; - The ``use_secular`` parameter has been removed. Use ``sec_cutoff=-1`` instead.; - The required tolerance is now read from ``qutip.settings``. Krylov Subspace Solver (krylovsolve):. - The Krylov solver is now implemented using ``SESolver`` and the ``krylov``; ODE integrator. The function ``krylovsolve`` is maintained for convenience; and now supports many more options.; - The ``sparse`` parameter has been removed. Supply a sparse ``Qobj`` for the; Hamiltonian instead. Floquet Solver (fsesolve and fmmesolve):. - The Floquet solver has been rewritten to use a new ``FloquetBasis`` class; which manages the transformations from lab to Floquet basis and back.; - Many of the internal methods used by the old Floquet solvers have; been removed. The Floquet tensor may still be retried using; the function ``floquet_tensor``.; - The Floquet Markov Master Equation solver has had many changes and; new options added. The environment temperature may be specified using; ``w_th``, and the result states are stored in the lab basis and optionally; in the Floquet basis using ``store_floquet_state``.; - The spectra functions supplied to ``fmmesolve`` must now be vectorized; (i.e. accept and return numpy arrays for frequencies and ",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:45949,Integrability,integrat,integration,45949," tensor may still be retried using; the function ``floquet_tensor``.; - The Floquet Markov Master Equation solver has had many changes and; new options added. The environment temperature may be specified using; ``w_th``, and the result states are stored in the lab basis and optionally; in the Floquet basis using ``store_floquet_state``.; - The spectra functions supplied to ``fmmesolve`` must now be vectorized; (i.e. accept and return numpy arrays for frequencies and densities) and; must accept negative frequence (i.e. usually include a ``w > 0`` factor; so that the returned densities are zero for negative frequencies).; - The number of sidebands to keep, ``kmax`` may only be supplied when using; the ``FMESolver``; - The ``Tsteps`` parameter has been removed from both ``fsesolve`` and; ``fmmesolve``. The ``precompute`` option to ``FloquetBasis`` may be used; instead. Evolution of State Solver (essovle):. - The function ``essolve`` has been removed. Use the ``diag`` integration; method with ``sesolve`` or ``mesolve`` instead. Steady-state solvers (steadystate module):. - The ``method`` parameter and ``solver`` parameters have been separated. Previously; they were mixed together in the ``method`` parameter.; - The previous options are now passed as parameters to the steady state; solver and mostly passed through to the underlying SciPy functions.; - The logging and statistics have been removed. Correlation functions (correlation module):. - A new ``correlation_3op`` function has been added. It supports ``MESolver``; or ``BRMESolver``.; - The ``correlation``, ``correlation_4op``, and ``correlation_ss`` functions have been; removed.; - Support for calculating correlation with ``mcsolve`` has been removed. Propagators (propagator module):. - A class interface, ``qutip.Propagator``, has been added for propagators.; - Propagation of time-dependent systems is now supported using ``QobjEvo``.; - The ``unitary_mode`` and ``parallel`` options have been removed. Correlation spec",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:46744,Integrability,interface,interface,46744,"``fsesolve`` and; ``fmmesolve``. The ``precompute`` option to ``FloquetBasis`` may be used; instead. Evolution of State Solver (essovle):. - The function ``essolve`` has been removed. Use the ``diag`` integration; method with ``sesolve`` or ``mesolve`` instead. Steady-state solvers (steadystate module):. - The ``method`` parameter and ``solver`` parameters have been separated. Previously; they were mixed together in the ``method`` parameter.; - The previous options are now passed as parameters to the steady state; solver and mostly passed through to the underlying SciPy functions.; - The logging and statistics have been removed. Correlation functions (correlation module):. - A new ``correlation_3op`` function has been added. It supports ``MESolver``; or ``BRMESolver``.; - The ``correlation``, ``correlation_4op``, and ``correlation_ss`` functions have been; removed.; - Support for calculating correlation with ``mcsolve`` has been removed. Propagators (propagator module):. - A class interface, ``qutip.Propagator``, has been added for propagators.; - Propagation of time-dependent systems is now supported using ``QobjEvo``.; - The ``unitary_mode`` and ``parallel`` options have been removed. Correlation spectra (spectrum module):. - The functions ``spectrum_ss`` and ``spectrum_pi`` have been removed and; are now internal functions.; - The ``use_pinv`` parameter for ``spectrum`` has been removed and the; functionality merged into the ``solver`` parameter. Use ``solver=""pi""``; instead. QuTiP core; ----------. There have been numerous other small changes to core QuTiP features:. - ``qft(...)`` the function that returns the quantum Fourier; transform operator was moved from ``qutip.qip.algorithm`` into ``qutip``.; - The Bloch-Redfield solver tensor, ``brtensor``, has been moved into; ``qutip.core``. See the section above on the Bloch-Redfield solver; for details.; - The functions ``mat2vec`` and ``vec2mat`` for transforming states to and; from super-operator states have been",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:46832,Integrability,depend,dependent,46832,"d. Evolution of State Solver (essovle):. - The function ``essolve`` has been removed. Use the ``diag`` integration; method with ``sesolve`` or ``mesolve`` instead. Steady-state solvers (steadystate module):. - The ``method`` parameter and ``solver`` parameters have been separated. Previously; they were mixed together in the ``method`` parameter.; - The previous options are now passed as parameters to the steady state; solver and mostly passed through to the underlying SciPy functions.; - The logging and statistics have been removed. Correlation functions (correlation module):. - A new ``correlation_3op`` function has been added. It supports ``MESolver``; or ``BRMESolver``.; - The ``correlation``, ``correlation_4op``, and ``correlation_ss`` functions have been; removed.; - Support for calculating correlation with ``mcsolve`` has been removed. Propagators (propagator module):. - A class interface, ``qutip.Propagator``, has been added for propagators.; - Propagation of time-dependent systems is now supported using ``QobjEvo``.; - The ``unitary_mode`` and ``parallel`` options have been removed. Correlation spectra (spectrum module):. - The functions ``spectrum_ss`` and ``spectrum_pi`` have been removed and; are now internal functions.; - The ``use_pinv`` parameter for ``spectrum`` has been removed and the; functionality merged into the ``solver`` parameter. Use ``solver=""pi""``; instead. QuTiP core; ----------. There have been numerous other small changes to core QuTiP features:. - ``qft(...)`` the function that returns the quantum Fourier; transform operator was moved from ``qutip.qip.algorithm`` into ``qutip``.; - The Bloch-Redfield solver tensor, ``brtensor``, has been moved into; ``qutip.core``. See the section above on the Bloch-Redfield solver; for details.; - The functions ``mat2vec`` and ``vec2mat`` for transforming states to and; from super-operator states have been renamed to ``stack_columns`` and; ``unstack_columns``.; - The function ``liouvillian_ref`` has bee",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:54162,Integrability,integrat,integration,54162,"y Simon Cross); - Fixed bug where some matrices were wrongly found to be hermitian. (#2082 by AGaliciaMartinez). Miscellaneous; -------------; - Fixed typo in stochastic.py (#2049, by eltociear); - `ptrace` always return density matrix (#2185, issue by udevd); - `mesolve` can support mixed callable and Qobj for `e_ops` (#2184 issue by balopat). Version 4.7.1 (December 11, 2022); +++++++++++++++++++++++++++++++++. This is a bugfix release for QuTiP 4.7.X. In addition to the minor fixes; listed below, the release adds builds for Python 3.11 and support for; packaging 22.0. Features; --------; - Improve qutip import times by setting logger names explicitly. (#1980). Bug Fixes; ---------; - Change floquet_master_equation_rates(...) to use an adaptive number of time steps scaled by the number of sidebands, kmax. (#1961); - Change fidelity(A, B) to use the reduced fidelity formula for pure states which is more numerically efficient and accurate. (#1964); - Change ``brmesolve`` to raise an exception when ode integration is not successful. (#1965); - Backport fix for IPython helper Bloch._repr_svg_ from dev.major. Previously the print_figure function returned bytes, but since ipython/ipython#5452 (in 2014) it returns a Unicode string. This fix updates QuTiP's helper to match. (#1970); - Fix correlation for case where only the collapse operators are time dependent. (#1979); - Fix the hinton visualization method to plot the matrix instead of its transpose. (#2011); - Fix the hinton visualization method to take into account all the matrix coefficients to set the squares scale, instead of only the diagonal coefficients. (#2012); - Fix parsing of package versions in setup.py to support packaging 22.0. (#2037); - Add back .qu suffix to objects saved with qsave and loaded with qload. The suffix was accidentally removed in QuTiP 4.7.0. (#2038); - Add a default max_step to processors. (#2040). Documentation; -------------; - Add towncrier for managing the changelog. (#1927); - Updat",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:54513,Integrability,depend,dependent,54513," by balopat). Version 4.7.1 (December 11, 2022); +++++++++++++++++++++++++++++++++. This is a bugfix release for QuTiP 4.7.X. In addition to the minor fixes; listed below, the release adds builds for Python 3.11 and support for; packaging 22.0. Features; --------; - Improve qutip import times by setting logger names explicitly. (#1980). Bug Fixes; ---------; - Change floquet_master_equation_rates(...) to use an adaptive number of time steps scaled by the number of sidebands, kmax. (#1961); - Change fidelity(A, B) to use the reduced fidelity formula for pure states which is more numerically efficient and accurate. (#1964); - Change ``brmesolve`` to raise an exception when ode integration is not successful. (#1965); - Backport fix for IPython helper Bloch._repr_svg_ from dev.major. Previously the print_figure function returned bytes, but since ipython/ipython#5452 (in 2014) it returns a Unicode string. This fix updates QuTiP's helper to match. (#1970); - Fix correlation for case where only the collapse operators are time dependent. (#1979); - Fix the hinton visualization method to plot the matrix instead of its transpose. (#2011); - Fix the hinton visualization method to take into account all the matrix coefficients to set the squares scale, instead of only the diagonal coefficients. (#2012); - Fix parsing of package versions in setup.py to support packaging 22.0. (#2037); - Add back .qu suffix to objects saved with qsave and loaded with qload. The suffix was accidentally removed in QuTiP 4.7.0. (#2038); - Add a default max_step to processors. (#2040). Documentation; -------------; - Add towncrier for managing the changelog. (#1927); - Update the version of numpy used to build documentation to 1.22.0. (#1940); - Clarify returned objects from bloch_redfield_tensor(). (#1950); - Update Floquet Markov solver docs. (#1958); - Update the roadmap and ideas to show completed work as of August 2022. (#1967). Miscellaneous; -------------; - Return TypeError instead of Exceptio",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:57697,Integrability,wrap,wrapper,57697,"te number enumeration and Husimi Q functions. Import bugfixes include some bugs affecting plotting with matplotlib 3.5 and fixing support for qutrits (and other non-qubit) quantum circuits. The many other small improvements, bug fixes, documentation enhancements, and behind the scenese development changes are included in the list below. QuTiP 4.7.X will be the last series of releases for QuTiP 4. Patch releases will continue for the 4.7.X series but the main development effort will move to QuTiP 5. The many, many contributors who filed issues, submitted or reviewed pull requests, and improved the documentation for this release are listed next to their contributions below. Thank you to all of you. Improvements; ------------; - **MAJOR** Added krylovsolve as a new solver based on krylov subspace approximation. (`#1739 <https://github.com/qutip/qutip/pull/1739>`_ by Emiliano Fortes); - **MAJOR** Imported BoFiN HEOM (https://github.com/tehruhn/bofin/) into QuTiP and replaced the HEOM solver with a compatibility wrapper around BoFiN bosonic solver. (`#1601 <https://github.com/qutip/qutip/pull/1601>`_, `#1726 <https://github.com/qutip/qutip/pull/1726>`_, and `#1724 <https://github.com/qutip/qutip/pull/1724>`_ by Simon Cross, Tarun Raheja and Neill Lambert); - **MAJOR** Added support for plotting lines and arcs on the Bloch sphere. (`#1690 <https://github.com/qutip/qutip/pull/1690>`_ by Gaurav Saxena, Asier Galicia and Simon Cross); - Added transparency parameter to the add_point, add_vector and add_states methods in the Bloch and Bloch3d classes. (`#1837 <https://github.com/qutip/qutip/pull/1837>`_ by Xavier Spronken); - Support ``Path`` objects in ``qutip.fileio``. (`#1813 <https://github.com/qutip/qutip/pull/1813>`_ by Adri Labay); - Improved the weighting in steadystate solver, so that the default weight matches the documented behaviour and the dense solver applies the weights in the same manner as the sparse solver. (`#1275 <https://github.com/qutip/qutip/pull/1275>`_",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:65234,Integrability,depend,dependabot,65234,"ub.com/qutip/qutip/pull/1840>`_ by Anto Luketina); - Fixed minor grammar errors in the dynamics guide. (`#1822 <https://github.com/qutip/qutip/pull/1822>`_ by Victor Omole); - Fixed many small documentation typos. (`#1569 <https://github.com/qutip/qutip/pull/1569>`_ by Ashish Panigrahi); - Added Pulser to the list of libraries that use QuTiP. (`#1570 <https://github.com/qutip/qutip/pull/1570>`_ by Ashish Panigrahi); - Corrected typo in the states and operators guide. (`#1567 <https://github.com/qutip/qutip/pull/1567>`_ by Laurent Ajdnik); - Converted http links to https. (`#1555 <https://github.com/qutip/qutip/pull/1555>`_ by Jake Lishamn). Developer Changes; -----------------; - Add GitHub actions test run on windows-latest. (`#1853 <https://github.com/qutip/qutip/pull/1853>`_ and `#1855 <https://github.com/qutip/qutip/pull/1855>`_ by Simon Cross); - Bumped the version of pillow used to build documentation from 9.0.0 to 9.0.1. (`#1835 <https://github.com/qutip/qutip/pull/1835>`_ by dependabot); - Migrated the ``qutip.superop_reps`` tests to pytest. (`#1825 <https://github.com/qutip/qutip/pull/1825>`_ by Felipe Bivort Haiek); - Migrated the ``qutip.steadystates`` tests to pytest. (`#1679 <https://github.com/qutip/qutip/pull/1679>`_ by Eric Gigure); - Changed the README.md CI badge to the GitHub Actions badge. (`#1581 <https://github.com/qutip/qutip/pull/1581>`_ by Jake Lishman); - Updated CodeClimate configuration to treat our Python source files as Python 3. (`#1577 <https://github.com/qutip/qutip/pull/1577>`_ by Jake Lishman); - Reduced cyclomatic complexity in ``qutip._mkl``. (`#1576 <https://github.com/qutip/qutip/pull/1576>`_ by Jake Lishman); - Fixed PEP8 warnings in ``qutip.control``, ``qutip.mcsolve``, ``qutip.random_objects``, and ``qutip.stochastic``. (`#1575 <https://github.com/qutip/qutip/pull/1575>`_ by Jake Lishman); - Bumped the version of urllib3 used to build documentation from 1.26.4 to 1.26.5. (`#1563 <https://github.com/qutip/qutip/pull/1563>`_ ",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:66239,Integrability,depend,dependabot,66239,"; - Migrated the ``qutip.superop_reps`` tests to pytest. (`#1825 <https://github.com/qutip/qutip/pull/1825>`_ by Felipe Bivort Haiek); - Migrated the ``qutip.steadystates`` tests to pytest. (`#1679 <https://github.com/qutip/qutip/pull/1679>`_ by Eric Gigure); - Changed the README.md CI badge to the GitHub Actions badge. (`#1581 <https://github.com/qutip/qutip/pull/1581>`_ by Jake Lishman); - Updated CodeClimate configuration to treat our Python source files as Python 3. (`#1577 <https://github.com/qutip/qutip/pull/1577>`_ by Jake Lishman); - Reduced cyclomatic complexity in ``qutip._mkl``. (`#1576 <https://github.com/qutip/qutip/pull/1576>`_ by Jake Lishman); - Fixed PEP8 warnings in ``qutip.control``, ``qutip.mcsolve``, ``qutip.random_objects``, and ``qutip.stochastic``. (`#1575 <https://github.com/qutip/qutip/pull/1575>`_ by Jake Lishman); - Bumped the version of urllib3 used to build documentation from 1.26.4 to 1.26.5. (`#1563 <https://github.com/qutip/qutip/pull/1563>`_ by dependabot); - Moved tests to GitHub Actions. (`#1551 <https://github.com/qutip/qutip/pull/1551>`_ by Jake Lishman); - The GitHub contributing guidelines were re-added and updated to point to the more complete guidelines in the documentation. (`#1549 <https://github.com/qutip/qutip/pull/1549>`_ by Jake Lishman); - The release documentation was reworked after the initial 4.6.1 to match the actual release process. (`#1544 <https://github.com/qutip/qutip/pull/1544>`_ by Jake Lishman). Version 4.6.3 (February 9, 2022); ++++++++++++++++++++++++++++++++. This minor release adds support for numpy 1.22 and Python 3.10 and removes some blockers for running QuTiP on the Apple M1. The performance of the ``enr_destroy``, ``state_number_enumerate`` and ``hadamard_transform`` functions was drastically improved (up to 70x or 200x faster in some common cases), and support for the drift Hamiltonian was added to the ``qutip.qip`` ``Processor``. The ``qutip.hardware_info`` module was removed as part of adding s",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:74081,Integrability,depend,dependabot,74081,"tps://github.com/qutip/qutip/pull/1786>`_ by Mahdi Aslani); - Made numerous small improvements to the text of the QuTiP basics guide. (`#1768 <https://github.com/qutip/qutip/pull/1768>`_ by Anna Naden); - Made a small phrasing improvement to the README. (`#1790 <https://github.com/qutip/qutip/pull/1790>`_ by Rita Abani). Developer Changes; -----------------; - Improved test coverage of states and operators functions. (`#1578 <https://github.com/qutip/qutip/pull/1578>`_ by Eric Gigure); - Fixed test_interpolate mcsolve use (`#1645 <https://github.com/qutip/qutip/pull/1645>`_ by Eric Gigure); - Ensured figure plots are explicitly closed during tests so that the test suite passes when run headless under Xvfb. (`#1648 <https://github.com/qutip/qutip/pull/1648>`_ by Simon Cross); - Bumped the version of pillow used to build documentation from 8.2.0 to 9.0.0. (`#1654 <https://github.com/qutip/qutip/pull/1654>`_, `#1760 <https://github.com/qutip/qutip/pull/1760>`_ by dependabot); - Bumped the version of babel used to build documentation from 2.9.0 to 2.9.1. (`#1695 <https://github.com/qutip/qutip/pull/1695>`_ by dependabot); - Bumped the version of numpy used to build documentation from 1.19.5 to 1.21.0. (`#1767 <https://github.com/qutip/qutip/pull/1767>`_ by dependabot); - Bumped the version of ipython used to build documentation from 7.22.0 to 7.31.1. (`#1780 <https://github.com/qutip/qutip/pull/1780>`_ by dependabot); - Rename qutip.bib to CITATION.bib to enable GitHub's citation support. (`#1662 <https://github.com/qutip/qutip/pull/1662>`_ by Ashish Panigrahi); - Added tests for simdiags. (`#1681 <https://github.com/qutip/qutip/pull/1681>`_ by Eric Gigure); - Added support for specifying the numpy version in the CI test matrix. (`#1696 <https://github.com/qutip/qutip/pull/1696>`_ by Simon Cross); - Fixed the skipping of the dnorm metric tests if cvxpy is not installed. Previously all metrics tests were skipped by accident. (`#1704 <https://github.com/qutip/qutip/pul",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:74229,Integrability,depend,dependabot,74229,"://github.com/qutip/qutip/pull/1768>`_ by Anna Naden); - Made a small phrasing improvement to the README. (`#1790 <https://github.com/qutip/qutip/pull/1790>`_ by Rita Abani). Developer Changes; -----------------; - Improved test coverage of states and operators functions. (`#1578 <https://github.com/qutip/qutip/pull/1578>`_ by Eric Gigure); - Fixed test_interpolate mcsolve use (`#1645 <https://github.com/qutip/qutip/pull/1645>`_ by Eric Gigure); - Ensured figure plots are explicitly closed during tests so that the test suite passes when run headless under Xvfb. (`#1648 <https://github.com/qutip/qutip/pull/1648>`_ by Simon Cross); - Bumped the version of pillow used to build documentation from 8.2.0 to 9.0.0. (`#1654 <https://github.com/qutip/qutip/pull/1654>`_, `#1760 <https://github.com/qutip/qutip/pull/1760>`_ by dependabot); - Bumped the version of babel used to build documentation from 2.9.0 to 2.9.1. (`#1695 <https://github.com/qutip/qutip/pull/1695>`_ by dependabot); - Bumped the version of numpy used to build documentation from 1.19.5 to 1.21.0. (`#1767 <https://github.com/qutip/qutip/pull/1767>`_ by dependabot); - Bumped the version of ipython used to build documentation from 7.22.0 to 7.31.1. (`#1780 <https://github.com/qutip/qutip/pull/1780>`_ by dependabot); - Rename qutip.bib to CITATION.bib to enable GitHub's citation support. (`#1662 <https://github.com/qutip/qutip/pull/1662>`_ by Ashish Panigrahi); - Added tests for simdiags. (`#1681 <https://github.com/qutip/qutip/pull/1681>`_ by Eric Gigure); - Added support for specifying the numpy version in the CI test matrix. (`#1696 <https://github.com/qutip/qutip/pull/1696>`_ by Simon Cross); - Fixed the skipping of the dnorm metric tests if cvxpy is not installed. Previously all metrics tests were skipped by accident. (`#1704 <https://github.com/qutip/qutip/pull/1704>`_ by Florian Hopfmueller); - Added bug report, feature request and other options to the GitHub issue reporting template. (`#1728 <https://gi",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:74379,Integrability,depend,dependabot,74379,"1790>`_ by Rita Abani). Developer Changes; -----------------; - Improved test coverage of states and operators functions. (`#1578 <https://github.com/qutip/qutip/pull/1578>`_ by Eric Gigure); - Fixed test_interpolate mcsolve use (`#1645 <https://github.com/qutip/qutip/pull/1645>`_ by Eric Gigure); - Ensured figure plots are explicitly closed during tests so that the test suite passes when run headless under Xvfb. (`#1648 <https://github.com/qutip/qutip/pull/1648>`_ by Simon Cross); - Bumped the version of pillow used to build documentation from 8.2.0 to 9.0.0. (`#1654 <https://github.com/qutip/qutip/pull/1654>`_, `#1760 <https://github.com/qutip/qutip/pull/1760>`_ by dependabot); - Bumped the version of babel used to build documentation from 2.9.0 to 2.9.1. (`#1695 <https://github.com/qutip/qutip/pull/1695>`_ by dependabot); - Bumped the version of numpy used to build documentation from 1.19.5 to 1.21.0. (`#1767 <https://github.com/qutip/qutip/pull/1767>`_ by dependabot); - Bumped the version of ipython used to build documentation from 7.22.0 to 7.31.1. (`#1780 <https://github.com/qutip/qutip/pull/1780>`_ by dependabot); - Rename qutip.bib to CITATION.bib to enable GitHub's citation support. (`#1662 <https://github.com/qutip/qutip/pull/1662>`_ by Ashish Panigrahi); - Added tests for simdiags. (`#1681 <https://github.com/qutip/qutip/pull/1681>`_ by Eric Gigure); - Added support for specifying the numpy version in the CI test matrix. (`#1696 <https://github.com/qutip/qutip/pull/1696>`_ by Simon Cross); - Fixed the skipping of the dnorm metric tests if cvxpy is not installed. Previously all metrics tests were skipped by accident. (`#1704 <https://github.com/qutip/qutip/pull/1704>`_ by Florian Hopfmueller); - Added bug report, feature request and other options to the GitHub issue reporting template. (`#1728 <https://github.com/qutip/qutip/pull/1728>`_ by Aryaman Kolhe); - Updated the build process to support building on Python 3.10 by removing the build requirement f",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:74531,Integrability,depend,dependabot,74531,"578 <https://github.com/qutip/qutip/pull/1578>`_ by Eric Gigure); - Fixed test_interpolate mcsolve use (`#1645 <https://github.com/qutip/qutip/pull/1645>`_ by Eric Gigure); - Ensured figure plots are explicitly closed during tests so that the test suite passes when run headless under Xvfb. (`#1648 <https://github.com/qutip/qutip/pull/1648>`_ by Simon Cross); - Bumped the version of pillow used to build documentation from 8.2.0 to 9.0.0. (`#1654 <https://github.com/qutip/qutip/pull/1654>`_, `#1760 <https://github.com/qutip/qutip/pull/1760>`_ by dependabot); - Bumped the version of babel used to build documentation from 2.9.0 to 2.9.1. (`#1695 <https://github.com/qutip/qutip/pull/1695>`_ by dependabot); - Bumped the version of numpy used to build documentation from 1.19.5 to 1.21.0. (`#1767 <https://github.com/qutip/qutip/pull/1767>`_ by dependabot); - Bumped the version of ipython used to build documentation from 7.22.0 to 7.31.1. (`#1780 <https://github.com/qutip/qutip/pull/1780>`_ by dependabot); - Rename qutip.bib to CITATION.bib to enable GitHub's citation support. (`#1662 <https://github.com/qutip/qutip/pull/1662>`_ by Ashish Panigrahi); - Added tests for simdiags. (`#1681 <https://github.com/qutip/qutip/pull/1681>`_ by Eric Gigure); - Added support for specifying the numpy version in the CI test matrix. (`#1696 <https://github.com/qutip/qutip/pull/1696>`_ by Simon Cross); - Fixed the skipping of the dnorm metric tests if cvxpy is not installed. Previously all metrics tests were skipped by accident. (`#1704 <https://github.com/qutip/qutip/pull/1704>`_ by Florian Hopfmueller); - Added bug report, feature request and other options to the GitHub issue reporting template. (`#1728 <https://github.com/qutip/qutip/pull/1728>`_ by Aryaman Kolhe); - Updated the build process to support building on Python 3.10 by removing the build requirement for numpy < 1.20 and replacing it with a requirement on oldest-supported-numpy. (`#1747 <https://github.com/qutip/qutip/pull/17",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:76518,Integrability,depend,dependent,76518,">`_ by Simon Cross); - Updated the version of cibuildwheel used to build wheels to 2.3.0. (`#1747 <https://github.com/qutip/qutip/pull/1747>`_, `#1751 <https://github.com/qutip/qutip/pull/1751>`_ by Simon Cross); - Added project urls to linking to the source repository, issue tracker and documentation to setup.cfg. (`#1779 <https://github.com/qutip/qutip/pull/1779>`_ by Simon Cross); - Added a numpy 1.22 and Python 3.10 build to the CI test matrix. (`#1777 <https://github.com/qutip/qutip/pull/1777>`_ by Simon Cross); - Ignore deprecation warnings from SciPy 1.8.0 scipy.sparse.X imports in CI tests. (`#1797 <https://github.com/qutip/qutip/pull/1797>`_ by Simon Cross); - Add building of wheels for Python 3.10 to the cibuildwheel job. (`#1796 <https://github.com/qutip/qutip/pull/1796>`_ by Simon Cross). Version 4.6.2 (June 2, 2021); ++++++++++++++++++++++++++++. This minor release adds a function to calculate the quantum relative entropy, fixes a corner case in handling time-dependent Hamiltonians in ``mesolve`` and adds back support for a wider range of matplotlib versions when plotting or animating Bloch spheres. It also adds a section in the README listing the papers which should be referenced while citing QuTiP. Improvements; ------------; - Added a ""Citing QuTiP"" section to the README, containing a link to the QuTiP papers. (`#1554 <https://github.com/qutip/qutip/pull/1554>`_); - Added ``entropy_relative`` which returns the quantum relative entropy between two density matrices. (`#1553 <https://github.com/qutip/qutip/pull/1553>`_). Bug Fixes; ---------; - Fixed Bloch sphere distortion when using Matplotlib >= 3.3.0. (`#1496 <https://github.com/qutip/qutip/pull/1496>`_); - Removed use of integer-like floats in math.factorial since it is deprecated as of Python 3.9. (`#1550 <https://github.com/qutip/qutip/pull/1550>`_); - Simplified call to ffmpeg used in the the Bloch sphere animation tutorial to work with recent versions of ffmpeg. (`#1557 <https://github.com/quti",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:77739,Integrability,depend,depending,77739," the papers which should be referenced while citing QuTiP. Improvements; ------------; - Added a ""Citing QuTiP"" section to the README, containing a link to the QuTiP papers. (`#1554 <https://github.com/qutip/qutip/pull/1554>`_); - Added ``entropy_relative`` which returns the quantum relative entropy between two density matrices. (`#1553 <https://github.com/qutip/qutip/pull/1553>`_). Bug Fixes; ---------; - Fixed Bloch sphere distortion when using Matplotlib >= 3.3.0. (`#1496 <https://github.com/qutip/qutip/pull/1496>`_); - Removed use of integer-like floats in math.factorial since it is deprecated as of Python 3.9. (`#1550 <https://github.com/qutip/qutip/pull/1550>`_); - Simplified call to ffmpeg used in the the Bloch sphere animation tutorial to work with recent versions of ffmpeg. (`#1557 <https://github.com/qutip/qutip/pull/1557>`_); - Removed blitting in Bloch sphere FuncAnimation example. (`#1558 <https://github.com/qutip/qutip/pull/1558>`_); - Added a version checking condition to handle specific functionalities depending on the matplotlib version. (`#1556 <https://github.com/qutip/qutip/pull/1556>`_); - Fixed ``mesolve`` handling of time-dependent Hamiltonian with a custom tlist and ``c_ops``. (`#1561 <https://github.com/qutip/qutip/pull/1561>`_). Developer Changes; -----------------; - Read documentation version and release from the VERSION file. Version 4.6.1 (May 4, 2021); +++++++++++++++++++++++++++. This minor release fixes bugs in QIP gate definitions, fixes building from; the source tarball when git is not installed and works around an MKL; bug in versions of SciPy <= 1.4. It also adds the ``[full]`` pip install target so that ``pip install qutip[full]``; installs qutip and all of its optional and developer dependencies. Improvements; ------------; - Add the ``[full]`` pip install target (by **Jake Lishman**). Bug Fixes; ---------; - Work around pointer MKL eigh bug in SciPy <= 1.4 (by **Felipe Bivort Haiek**); - Fix berkeley, swapalpha and cz gate oper",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:77868,Integrability,depend,dependent,77868,"he QuTiP papers. (`#1554 <https://github.com/qutip/qutip/pull/1554>`_); - Added ``entropy_relative`` which returns the quantum relative entropy between two density matrices. (`#1553 <https://github.com/qutip/qutip/pull/1553>`_). Bug Fixes; ---------; - Fixed Bloch sphere distortion when using Matplotlib >= 3.3.0. (`#1496 <https://github.com/qutip/qutip/pull/1496>`_); - Removed use of integer-like floats in math.factorial since it is deprecated as of Python 3.9. (`#1550 <https://github.com/qutip/qutip/pull/1550>`_); - Simplified call to ffmpeg used in the the Bloch sphere animation tutorial to work with recent versions of ffmpeg. (`#1557 <https://github.com/qutip/qutip/pull/1557>`_); - Removed blitting in Bloch sphere FuncAnimation example. (`#1558 <https://github.com/qutip/qutip/pull/1558>`_); - Added a version checking condition to handle specific functionalities depending on the matplotlib version. (`#1556 <https://github.com/qutip/qutip/pull/1556>`_); - Fixed ``mesolve`` handling of time-dependent Hamiltonian with a custom tlist and ``c_ops``. (`#1561 <https://github.com/qutip/qutip/pull/1561>`_). Developer Changes; -----------------; - Read documentation version and release from the VERSION file. Version 4.6.1 (May 4, 2021); +++++++++++++++++++++++++++. This minor release fixes bugs in QIP gate definitions, fixes building from; the source tarball when git is not installed and works around an MKL; bug in versions of SciPy <= 1.4. It also adds the ``[full]`` pip install target so that ``pip install qutip[full]``; installs qutip and all of its optional and developer dependencies. Improvements; ------------; - Add the ``[full]`` pip install target (by **Jake Lishman**). Bug Fixes; ---------; - Work around pointer MKL eigh bug in SciPy <= 1.4 (by **Felipe Bivort Haiek**); - Fix berkeley, swapalpha and cz gate operations (by **Boxi Li**); - Expose the CPHASE control gate (by **Boxi Li**); - Fix building from the sdist when git is not installed (by **Jake Lishman**). D",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:78456,Integrability,depend,dependencies,78456,"ed call to ffmpeg used in the the Bloch sphere animation tutorial to work with recent versions of ffmpeg. (`#1557 <https://github.com/qutip/qutip/pull/1557>`_); - Removed blitting in Bloch sphere FuncAnimation example. (`#1558 <https://github.com/qutip/qutip/pull/1558>`_); - Added a version checking condition to handle specific functionalities depending on the matplotlib version. (`#1556 <https://github.com/qutip/qutip/pull/1556>`_); - Fixed ``mesolve`` handling of time-dependent Hamiltonian with a custom tlist and ``c_ops``. (`#1561 <https://github.com/qutip/qutip/pull/1561>`_). Developer Changes; -----------------; - Read documentation version and release from the VERSION file. Version 4.6.1 (May 4, 2021); +++++++++++++++++++++++++++. This minor release fixes bugs in QIP gate definitions, fixes building from; the source tarball when git is not installed and works around an MKL; bug in versions of SciPy <= 1.4. It also adds the ``[full]`` pip install target so that ``pip install qutip[full]``; installs qutip and all of its optional and developer dependencies. Improvements; ------------; - Add the ``[full]`` pip install target (by **Jake Lishman**). Bug Fixes; ---------; - Work around pointer MKL eigh bug in SciPy <= 1.4 (by **Felipe Bivort Haiek**); - Fix berkeley, swapalpha and cz gate operations (by **Boxi Li**); - Expose the CPHASE control gate (by **Boxi Li**); - Fix building from the sdist when git is not installed (by **Jake Lishman**). Developer Changes; -----------------; - Move the qutip-doc documentation into the qutip repository (by **Jake Lishman**); - Fix warnings in documentation build (by **Jake Lishman**); - Fix warnings in pytest runs and make pytest treat warnings as errors (by **Jake Lishman**); - Add Simon Cross as author (by **Simon Cross**). Version 4.6.0 (April 11, 2021); ++++++++++++++++++++++++++++++. This release brings improvements for qubit circuits, including a pulse scheduler, measurement statistics, reading/writing OpenQASM and optimis",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:79909,Integrability,depend,dependencies,79909,"the qutip-doc documentation into the qutip repository (by **Jake Lishman**); - Fix warnings in documentation build (by **Jake Lishman**); - Fix warnings in pytest runs and make pytest treat warnings as errors (by **Jake Lishman**); - Add Simon Cross as author (by **Simon Cross**). Version 4.6.0 (April 11, 2021); ++++++++++++++++++++++++++++++. This release brings improvements for qubit circuits, including a pulse scheduler, measurement statistics, reading/writing OpenQASM and optimisations in the circuit simulations. This is the first release to have full binary wheel releases on pip; you can now do ``pip install qutip`` on almost any machine to get a correct version of the package without needing any compilers set up.; The support for Numpy 1.20 that was first added in QuTiP 4.5.3 is present in this version as well, and the same build considerations mentioned there apply here too.; If building using the now-supported PEP 517 mechanisms (e.g. ``python -mbuild /path/to/qutip``), all build dependencies will be correctly satisfied. Improvements; ------------; - **MAJOR** Add saving, loading and resetting functionality to ``qutip.settings`` for easy re-configuration. (by **Eric Gigure**); - **MAJOR** Add a quantum gate scheduler in ``qutip.qip.scheduler``, to help parallelise the operations of quantum gates. This supports two scheduling modes: as late as possible, and as soon as possible. (by **Boxi Li**); - **MAJOR** Improved qubit circuit simulators, including OpenQASM support and performance optimisations. (by **Sidhant Saraogi**); - **MAJOR** Add tools for quantum measurements and their statistics. (by **Simon Cross** and **Sidhant Saraogi**); - Add support for Numpy 1.20. QuTiP should be compiled against a version of Numpy ``>= 1.16.6`` and ``< 1.20`` (note: does _not_ include 1.20 itself), but such an installation is compatible with any modern version of Numpy. Source installations from ``pip`` understand this constraint.; - Improve the error message when circuit",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:80886,Integrability,message,message,80886,"p``), all build dependencies will be correctly satisfied. Improvements; ------------; - **MAJOR** Add saving, loading and resetting functionality to ``qutip.settings`` for easy re-configuration. (by **Eric Gigure**); - **MAJOR** Add a quantum gate scheduler in ``qutip.qip.scheduler``, to help parallelise the operations of quantum gates. This supports two scheduling modes: as late as possible, and as soon as possible. (by **Boxi Li**); - **MAJOR** Improved qubit circuit simulators, including OpenQASM support and performance optimisations. (by **Sidhant Saraogi**); - **MAJOR** Add tools for quantum measurements and their statistics. (by **Simon Cross** and **Sidhant Saraogi**); - Add support for Numpy 1.20. QuTiP should be compiled against a version of Numpy ``>= 1.16.6`` and ``< 1.20`` (note: does _not_ include 1.20 itself), but such an installation is compatible with any modern version of Numpy. Source installations from ``pip`` understand this constraint.; - Improve the error message when circuit plotting fails. (by **Boxi Li**); - Add support for parsing M1 Mac hardware information. (by **Xiaoliang Wu**); - Add more single-qubit gates and controlled gates. (by **Mateo Laguna** and **Martn Sande Costa**); - Support decomposition of ``X``, ``Y`` and ``Z`` gates in circuits. (by **Boxi Li**); - Refactor ``QubitCircuit.resolve_gate()`` (by **Martn Sande Costa**). Bug Fixes; ---------; - Fix ``dims`` in the returns from ``Qobj.eigenstates`` on superoperators. (by **Jake Lishman**); - Calling Numpy ufuncs on ``Qobj`` will now correctly raise a ``TypeError`` rather than returning a nonsense ``ndarray``. (by **Jake Lishman**); - Convert segfault into Python exception when creating too-large tensor products. (by **Jake Lishman**); - Correctly set ``num_collapse`` in the output of ``mesolve``. (by **Jake Lishman**); - Fix ``ptrace`` when all subspaces are being kept, or the subspaces are passed in order. (by **Jake Lishman**); - Fix sorting bug in ``Bloch3d.add_points()`",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:85433,Integrability,message,messages,85433,"ther changes relative to version 4.5.2. Users building from source should ensure that they build against Numpy versions >= 1.16.6 and < 1.20 (not including 1.20 itself), but after that or for those installing from conda, an installation will support any current Numpy version >= 1.16.6. Improvements; ------------; - Add support for Numpy 1.20. QuTiP should be compiled against a version of Numpy ``>= 1.16.6`` and ``< 1.20`` (note: does _not_ include 1.20 itself), but such an installation is compatible with any modern version of Numpy. Source installations from ``pip`` understand this constraint. Version 4.5.2 (July 14, 2020); +++++++++++++++++++++++++++++. This is predominantly a hot-fix release to add support for Scipy 1.5, due to changes in private sparse matrix functions that QuTiP also used. Improvements; ------------; - Add support for Scipy 1.5. (by **Jake Lishman**); - Improved speed of ``zcsr_inner``, which affects ``Qobj.overlap``. (by **Jake Lishman**); - Better error messages when installation requirements are not satisfied. (by **Eric Gigure**). Bug Fixes; ---------; - Fix ``zcsr_proj`` acting on matrices with unsorted indices. (by **Jake Lishman**); - Fix errors in Milstein's heterodyne. (by **Eric Gigure**); - Fix datatype bug in ``qutip.lattice`` module. (by **Boxi Li**); - Fix issues with ``eigh`` on Mac when using OpenBLAS. (by **Eric Gigure**). Developer Changes; -----------------; - Converted more of the codebase to PEP 8.; - Fix several instances of unsafe mutable default values and unsafe ``is`` comparisons. Version 4.5.1 (May 15, 2020); ++++++++++++++++++++++++++++. Improvements; ------------; - ``husimi`` and ``wigner`` now accept half-integer spin (by **maij**); - Better error messages for failed string coefficient compilation. (issue raised by **nohchangsuk**). Bug Fixes; ---------; - Safer naming for temporary files. (by **Eric Gigure**); - Fix ``clebsch`` function for half-integer (by **Thomas Walker**); - Fix ``randint``'s dtype to ``uin",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:86173,Integrability,message,messages,86173,"ease to add support for Scipy 1.5, due to changes in private sparse matrix functions that QuTiP also used. Improvements; ------------; - Add support for Scipy 1.5. (by **Jake Lishman**); - Improved speed of ``zcsr_inner``, which affects ``Qobj.overlap``. (by **Jake Lishman**); - Better error messages when installation requirements are not satisfied. (by **Eric Gigure**). Bug Fixes; ---------; - Fix ``zcsr_proj`` acting on matrices with unsorted indices. (by **Jake Lishman**); - Fix errors in Milstein's heterodyne. (by **Eric Gigure**); - Fix datatype bug in ``qutip.lattice`` module. (by **Boxi Li**); - Fix issues with ``eigh`` on Mac when using OpenBLAS. (by **Eric Gigure**). Developer Changes; -----------------; - Converted more of the codebase to PEP 8.; - Fix several instances of unsafe mutable default values and unsafe ``is`` comparisons. Version 4.5.1 (May 15, 2020); ++++++++++++++++++++++++++++. Improvements; ------------; - ``husimi`` and ``wigner`` now accept half-integer spin (by **maij**); - Better error messages for failed string coefficient compilation. (issue raised by **nohchangsuk**). Bug Fixes; ---------; - Safer naming for temporary files. (by **Eric Gigure**); - Fix ``clebsch`` function for half-integer (by **Thomas Walker**); - Fix ``randint``'s dtype to ``uint32`` for compatibility with Windows. (issue raised by **Boxi Li**); - Corrected stochastic's heterodyne's m_ops (by **eliegenois**); - Mac pool use spawn. (issue raised by **goerz**); - Fix typos in ``QobjEvo._shift``. (by **Eric Gigure**); - Fix warning on Travis CI. (by **Ivan Carvalho**). Deprecations; ------------; - ``qutip.graph`` functions will be deprecated in QuTiP 5.0 in favour of ``scipy.sparse.csgraph``. Developer Changes; -----------------; - Add Boxi Li to authors. (by **Alex Pitchford**); - Skip some tests that cause segfaults on Mac. (by **Nathan Shammah** and **Eric Gigure**); - Use Python 3.8 for testing on Mac and Linux. (by **Simon Cross** and **Eric Gigure**). Vers",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:88605,Integrability,message,message,88605,"oved duplicated test runners (by **Jake Lishman**). - Deprecated importing `qip` functions to the qutip namespace (by **Boxi Li**). - Added the possibility to define non-square superoperators relevant for quantum circuits (by **Arne Grimsmo** and **Josh Combes**). - Implicit tensor product for `qeye`, `qzero` and `basis` (by **Jake Lishman**). - QObjEvo no longer requires Cython for string coefficient (by **Eric Gigure**). - Added marked tests for faster tests in `testing.run()` and made faster OpenMP benchmarking in CI (by **Eric Gigure**). - Added entropy and purity for Dicke density matrices, refactored into more general dicke_trace (by **Nathan Shammah**). - Added option for specifying resolution in Bloch.save function (by **Tarun Raheja**). - Added information related to the value of hbar in `wigner` and `continuous_variables` (by **Nicolas Quesada**). - Updated requirements for `scipy 1.4` (by **Eric Gigure**). - Added previous lead developers to the qutip.about() message (by **Nathan Shammah**). - Added improvements to `Qobj` introducing the `inv` method and making the partial trace, `ptrace`, faster, keeping both sparse and dense methods (by **Eric Gigure**). - Allowed general callable objects to define a time-dependent Hamiltonian (by **Eric Gigure**). - Added feature so that `QobjEvo` no longer requires Cython for string coefficients (by **Eric Gigure**). - Updated authors list on Github and added `my binder` link (by **Nathan Shammah**). Bug Fixes; ---------. - Fixed `PolyDataMapper` construction for `Bloch3d` (by **Sam Griffiths**). - Fixed error checking for null matrix in essolve (by **Nathan Shammah**). - Fixed name collision for parallel propagator (by **Nathan Shammah**). - Fixed dimensional incongruence in `propagator` (by **Nathan Shammah**). - Fixed bug by rewriting clebsch function based on long integer fraction (by **Eric Gigure**). - Fixed bugs in QobjEvo's args depending on state and added solver tests using them (by **Eric Gigure**).",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:88859,Integrability,depend,dependent,88859,"smo** and **Josh Combes**). - Implicit tensor product for `qeye`, `qzero` and `basis` (by **Jake Lishman**). - QObjEvo no longer requires Cython for string coefficient (by **Eric Gigure**). - Added marked tests for faster tests in `testing.run()` and made faster OpenMP benchmarking in CI (by **Eric Gigure**). - Added entropy and purity for Dicke density matrices, refactored into more general dicke_trace (by **Nathan Shammah**). - Added option for specifying resolution in Bloch.save function (by **Tarun Raheja**). - Added information related to the value of hbar in `wigner` and `continuous_variables` (by **Nicolas Quesada**). - Updated requirements for `scipy 1.4` (by **Eric Gigure**). - Added previous lead developers to the qutip.about() message (by **Nathan Shammah**). - Added improvements to `Qobj` introducing the `inv` method and making the partial trace, `ptrace`, faster, keeping both sparse and dense methods (by **Eric Gigure**). - Allowed general callable objects to define a time-dependent Hamiltonian (by **Eric Gigure**). - Added feature so that `QobjEvo` no longer requires Cython for string coefficients (by **Eric Gigure**). - Updated authors list on Github and added `my binder` link (by **Nathan Shammah**). Bug Fixes; ---------. - Fixed `PolyDataMapper` construction for `Bloch3d` (by **Sam Griffiths**). - Fixed error checking for null matrix in essolve (by **Nathan Shammah**). - Fixed name collision for parallel propagator (by **Nathan Shammah**). - Fixed dimensional incongruence in `propagator` (by **Nathan Shammah**). - Fixed bug by rewriting clebsch function based on long integer fraction (by **Eric Gigure**). - Fixed bugs in QobjEvo's args depending on state and added solver tests using them (by **Eric Gigure**). - Fixed bug in `sesolve` calculation of average states when summing the timeslot states (by **Alex Pitchford**). - Fixed bug in `steadystate` solver by removing separate arguments for MKL and Scipy (by **Tarun Raheja**). - Fixed `Bloch.a",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:89542,Integrability,depend,depending,89542,"ious lead developers to the qutip.about() message (by **Nathan Shammah**). - Added improvements to `Qobj` introducing the `inv` method and making the partial trace, `ptrace`, faster, keeping both sparse and dense methods (by **Eric Gigure**). - Allowed general callable objects to define a time-dependent Hamiltonian (by **Eric Gigure**). - Added feature so that `QobjEvo` no longer requires Cython for string coefficients (by **Eric Gigure**). - Updated authors list on Github and added `my binder` link (by **Nathan Shammah**). Bug Fixes; ---------. - Fixed `PolyDataMapper` construction for `Bloch3d` (by **Sam Griffiths**). - Fixed error checking for null matrix in essolve (by **Nathan Shammah**). - Fixed name collision for parallel propagator (by **Nathan Shammah**). - Fixed dimensional incongruence in `propagator` (by **Nathan Shammah**). - Fixed bug by rewriting clebsch function based on long integer fraction (by **Eric Gigure**). - Fixed bugs in QobjEvo's args depending on state and added solver tests using them (by **Eric Gigure**). - Fixed bug in `sesolve` calculation of average states when summing the timeslot states (by **Alex Pitchford**). - Fixed bug in `steadystate` solver by removing separate arguments for MKL and Scipy (by **Tarun Raheja**). - Fixed `Bloch.add_ponts` by setting `edgecolor = None` in `plot_points` (by **Nathan Shammah**). - Fixed error checking for null matrix in `essolve` solver affecting also `ode2es` (by **Peter Kirton**). - Removed unnecessary shebangs in .pyx and .pxd files (by **Samesh Lakhotia**). - Fixed `sesolve` and import of `os` in `codegen` (by **Alex Pitchford**). - Updated `plot_fock_distribution` by removing the offset value 0.4 in the plot (by **Rajiv-B**). Version 4.4.1 (August 29, 2019); +++++++++++++++++++++++++++++++. Improvements; ------------. - QobjEvo do not need to start from 0 anymore (by **Eric Gigure**). - Add a quantum object purity function (by **Nathan Shammah** and **Shahnawaz Ahmed**). - Add step functi",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:91213,Integrability,depend,dependant,91213," `plot_fock_distribution` by removing the offset value 0.4 in the plot (by **Rajiv-B**). Version 4.4.1 (August 29, 2019); +++++++++++++++++++++++++++++++. Improvements; ------------. - QobjEvo do not need to start from 0 anymore (by **Eric Gigure**). - Add a quantum object purity function (by **Nathan Shammah** and **Shahnawaz Ahmed**). - Add step function interpolation for array time-coefficient (by **Boxi Li**). - Generalize expand_oper for arbitrary dimensions, and new method for cyclic permutations of given target cubits (by **Boxi Li**). Bug Fixes; ---------. - Fixed the pickling but that made solver unable to run in parallel on Windows (Thank **lrunze** for reporting). - Removed warning when mesolve fall back on sesolve (by **Michael Goerz**). - Fixed dimension check and confusing documentation in random ket (by **Yariv Yanay**). - Fixed Qobj isherm not working after using Qobj.permute (Thank **llorz1207** for reporting). - Correlation functions call now properly handle multiple time dependant functions (Thank **taw181** for reporting). - Removed mutable default values in mesolve/sesolve (by **Michael Goerz**). - Fixed simdiag bug (Thank **Croydon-Brixton** for reporting). - Better support of constant QobjEvo (by **Boxi Li**). - Fixed potential cyclic import in the control module (by **Alexander Pitchford**). Version 4.4.0 (July 03, 2019); +++++++++++++++++++++++++++++. Improvements; ------------. - **MAJOR FEATURE**: Added methods and techniques to the stochastic solvers (by **Eric Gigure**) which allows to use a much broader set of solvers and much more efficiently. - **MAJOR FEATURE**: Optimization of the montecarlo solver (by **Eric Gigure**). Computation are faster in many cases. Collapse information available to time dependant information. - Added the QObjEvo class and methods (by **Eric Gigure**), which is used behind the scenes by the dynamical solvers, making the code more efficient and tidier. More built-in function available to string coefficient",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:91969,Integrability,depend,dependant,91969,"erz**). - Fixed dimension check and confusing documentation in random ket (by **Yariv Yanay**). - Fixed Qobj isherm not working after using Qobj.permute (Thank **llorz1207** for reporting). - Correlation functions call now properly handle multiple time dependant functions (Thank **taw181** for reporting). - Removed mutable default values in mesolve/sesolve (by **Michael Goerz**). - Fixed simdiag bug (Thank **Croydon-Brixton** for reporting). - Better support of constant QobjEvo (by **Boxi Li**). - Fixed potential cyclic import in the control module (by **Alexander Pitchford**). Version 4.4.0 (July 03, 2019); +++++++++++++++++++++++++++++. Improvements; ------------. - **MAJOR FEATURE**: Added methods and techniques to the stochastic solvers (by **Eric Gigure**) which allows to use a much broader set of solvers and much more efficiently. - **MAJOR FEATURE**: Optimization of the montecarlo solver (by **Eric Gigure**). Computation are faster in many cases. Collapse information available to time dependant information. - Added the QObjEvo class and methods (by **Eric Gigure**), which is used behind the scenes by the dynamical solvers, making the code more efficient and tidier. More built-in function available to string coefficients. - The coefficients can be made from interpolated array with variable timesteps and can obtain state information more easily. Time-dependant collapse operator can have multiple terms. - New wigner_transform and plot_wigner_sphere function. (by **Nithin Ramu**). - ptrace is faster and work on bigger systems, from 15 Qbits to 30 Qbits. - QIP module: added the possibility for user-defined gates, added the possibility to remove or add gates in any point of an already built circuit, added the molmer_sorensen gate, and fixed some bugs (by **Boxi Li**). - Added the quantum Hellinger distance to qutip.metrics (by **Wojciech Rzadkowski**). - Implemented possibility of choosing a random seed (by **Marek Marekyggdrasil**). - Added a code of conduct to",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:92341,Integrability,depend,dependant,92341,"Thank **Croydon-Brixton** for reporting). - Better support of constant QobjEvo (by **Boxi Li**). - Fixed potential cyclic import in the control module (by **Alexander Pitchford**). Version 4.4.0 (July 03, 2019); +++++++++++++++++++++++++++++. Improvements; ------------. - **MAJOR FEATURE**: Added methods and techniques to the stochastic solvers (by **Eric Gigure**) which allows to use a much broader set of solvers and much more efficiently. - **MAJOR FEATURE**: Optimization of the montecarlo solver (by **Eric Gigure**). Computation are faster in many cases. Collapse information available to time dependant information. - Added the QObjEvo class and methods (by **Eric Gigure**), which is used behind the scenes by the dynamical solvers, making the code more efficient and tidier. More built-in function available to string coefficients. - The coefficients can be made from interpolated array with variable timesteps and can obtain state information more easily. Time-dependant collapse operator can have multiple terms. - New wigner_transform and plot_wigner_sphere function. (by **Nithin Ramu**). - ptrace is faster and work on bigger systems, from 15 Qbits to 30 Qbits. - QIP module: added the possibility for user-defined gates, added the possibility to remove or add gates in any point of an already built circuit, added the molmer_sorensen gate, and fixed some bugs (by **Boxi Li**). - Added the quantum Hellinger distance to qutip.metrics (by **Wojciech Rzadkowski**). - Implemented possibility of choosing a random seed (by **Marek Marekyggdrasil**). - Added a code of conduct to Github. Bug Fixes; ---------. - Fixed bug that made QuTiP incompatible with SciPy 1.3. Version 4.3.0 (July 14, 2018); +++++++++++++++++++++++++++++. Improvements; ------------. - **MAJOR FEATURE**: Added the Permutational Invariant Quantum Solver (PIQS) module (by **Nathan Shammah** and **Shahnawaz Ahmed**) which allows the simluation of large TLSs ensembles including collective and local Lindblad di",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:93659,Integrability,depend,dependent,93659,"uilt circuit, added the molmer_sorensen gate, and fixed some bugs (by **Boxi Li**). - Added the quantum Hellinger distance to qutip.metrics (by **Wojciech Rzadkowski**). - Implemented possibility of choosing a random seed (by **Marek Marekyggdrasil**). - Added a code of conduct to Github. Bug Fixes; ---------. - Fixed bug that made QuTiP incompatible with SciPy 1.3. Version 4.3.0 (July 14, 2018); +++++++++++++++++++++++++++++. Improvements; ------------. - **MAJOR FEATURE**: Added the Permutational Invariant Quantum Solver (PIQS) module (by **Nathan Shammah** and **Shahnawaz Ahmed**) which allows the simluation of large TLSs ensembles including collective and local Lindblad dissipation. Applications range from superradiance to spin squeezing. - **MAJOR FEATURE**: Added a photon scattering module (by **Ben Bartlett**) which can be used to study scattering in arbitrary driven systems coupled to some configuration of output waveguides. - Cubic_Spline functions as time-dependent arguments for the collapse operators in mesolve are now allowed. - Added a faster version of bloch_redfield_tensor, using components from the time-dependent version. About 3x+ faster for secular tensors, and 10x+ faster for non-secular tensors. - Computing Q.overlap() [inner product] is now ~30x faster. - Added projector method to Qobj class. - Added fast projector method, ``Q.proj()``. - Computing matrix elements, ``Q.matrix_element`` is now ~10x faster. - Computing expectation values for ket vectors using ``expect`` is now ~10x faster. - ``Q.tr()`` is now faster for small Hilbert space dimensions. - Unitary operator evolution added to sesolve. - Use OPENMP for tidyup if installed. Bug Fixes; ---------. - Fixed bug that stopped simdiag working for python 3. - Fixed semidefinite cvxpy Variable and Parameter. - Fixed iterative lu solve atol keyword issue. - Fixed unitary op evolution rhs matrix in ssesolve. - Fixed interpolating function to return zero outside range. - Fixed dnorm complex casting",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:93816,Integrability,depend,dependent,93816,"Hellinger distance to qutip.metrics (by **Wojciech Rzadkowski**). - Implemented possibility of choosing a random seed (by **Marek Marekyggdrasil**). - Added a code of conduct to Github. Bug Fixes; ---------. - Fixed bug that made QuTiP incompatible with SciPy 1.3. Version 4.3.0 (July 14, 2018); +++++++++++++++++++++++++++++. Improvements; ------------. - **MAJOR FEATURE**: Added the Permutational Invariant Quantum Solver (PIQS) module (by **Nathan Shammah** and **Shahnawaz Ahmed**) which allows the simluation of large TLSs ensembles including collective and local Lindblad dissipation. Applications range from superradiance to spin squeezing. - **MAJOR FEATURE**: Added a photon scattering module (by **Ben Bartlett**) which can be used to study scattering in arbitrary driven systems coupled to some configuration of output waveguides. - Cubic_Spline functions as time-dependent arguments for the collapse operators in mesolve are now allowed. - Added a faster version of bloch_redfield_tensor, using components from the time-dependent version. About 3x+ faster for secular tensors, and 10x+ faster for non-secular tensors. - Computing Q.overlap() [inner product] is now ~30x faster. - Added projector method to Qobj class. - Added fast projector method, ``Q.proj()``. - Computing matrix elements, ``Q.matrix_element`` is now ~10x faster. - Computing expectation values for ket vectors using ``expect`` is now ~10x faster. - ``Q.tr()`` is now faster for small Hilbert space dimensions. - Unitary operator evolution added to sesolve. - Use OPENMP for tidyup if installed. Bug Fixes; ---------. - Fixed bug that stopped simdiag working for python 3. - Fixed semidefinite cvxpy Variable and Parameter. - Fixed iterative lu solve atol keyword issue. - Fixed unitary op evolution rhs matrix in ssesolve. - Fixed interpolating function to return zero outside range. - Fixed dnorm complex casting bug. - Fixed control.io path checking issue. - Fixed ENR fock dimension. - Fixed hard coded options in p",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:95119,Integrability,depend,dependent,95119," is now ~10x faster. - Computing expectation values for ket vectors using ``expect`` is now ~10x faster. - ``Q.tr()`` is now faster for small Hilbert space dimensions. - Unitary operator evolution added to sesolve. - Use OPENMP for tidyup if installed. Bug Fixes; ---------. - Fixed bug that stopped simdiag working for python 3. - Fixed semidefinite cvxpy Variable and Parameter. - Fixed iterative lu solve atol keyword issue. - Fixed unitary op evolution rhs matrix in ssesolve. - Fixed interpolating function to return zero outside range. - Fixed dnorm complex casting bug. - Fixed control.io path checking issue. - Fixed ENR fock dimension. - Fixed hard coded options in propagator 'batch' mode. - Fixed bug in trace-norm for non-Hermitian operators. - Fixed bug related to args not being passed to coherence_function_g2. - Fixed MKL error checking dict key error. Version 4.2.0 (July 28, 2017); +++++++++++++++++++++++++++++. Improvements; ------------. - **MAJOR FEATURE**: Initial implementation of time-dependent Bloch-Redfield Solver. - Qobj tidyup is now an order of magnitude faster. - Time-dependent codegen now generates output NumPy arrays faster. - Improved calculation for analytic coefficients in coherent states (Sebastian Kramer). - Input array to correlation FFT method now checked for validity. - Function-based time-dependent mesolve and sesolve routines now faster. - Codegen now makes sure that division is done in C, as opposed to Python. - Can now set different controls for a each timeslot in quantum optimization.; This allows time-varying controls to be used in pulse optimisation. Bug Fixes; ---------. - rcsolve importing old Odeoptions Class rather than Options. - Non-int issue in spin Q and Wigner functions. - Qobj's should tidyup before determining isherm. - Fixed time-dependent RHS function loading on Win. - Fixed several issues with compiling with Cython 0.26. - Liouvillian superoperators were hard setting isherm=True by default. - Fixed an issue with the sol",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:95210,Integrability,depend,dependent,95210,"ster for small Hilbert space dimensions. - Unitary operator evolution added to sesolve. - Use OPENMP for tidyup if installed. Bug Fixes; ---------. - Fixed bug that stopped simdiag working for python 3. - Fixed semidefinite cvxpy Variable and Parameter. - Fixed iterative lu solve atol keyword issue. - Fixed unitary op evolution rhs matrix in ssesolve. - Fixed interpolating function to return zero outside range. - Fixed dnorm complex casting bug. - Fixed control.io path checking issue. - Fixed ENR fock dimension. - Fixed hard coded options in propagator 'batch' mode. - Fixed bug in trace-norm for non-Hermitian operators. - Fixed bug related to args not being passed to coherence_function_g2. - Fixed MKL error checking dict key error. Version 4.2.0 (July 28, 2017); +++++++++++++++++++++++++++++. Improvements; ------------. - **MAJOR FEATURE**: Initial implementation of time-dependent Bloch-Redfield Solver. - Qobj tidyup is now an order of magnitude faster. - Time-dependent codegen now generates output NumPy arrays faster. - Improved calculation for analytic coefficients in coherent states (Sebastian Kramer). - Input array to correlation FFT method now checked for validity. - Function-based time-dependent mesolve and sesolve routines now faster. - Codegen now makes sure that division is done in C, as opposed to Python. - Can now set different controls for a each timeslot in quantum optimization.; This allows time-varying controls to be used in pulse optimisation. Bug Fixes; ---------. - rcsolve importing old Odeoptions Class rather than Options. - Non-int issue in spin Q and Wigner functions. - Qobj's should tidyup before determining isherm. - Fixed time-dependent RHS function loading on Win. - Fixed several issues with compiling with Cython 0.26. - Liouvillian superoperators were hard setting isherm=True by default. - Fixed an issue with the solver safety checks when inputing a list with Python functions as time-dependence. - Fixed non-int issue in Wigner_cmap. - MKL so",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:95446,Integrability,depend,dependent,95446,"cvxpy Variable and Parameter. - Fixed iterative lu solve atol keyword issue. - Fixed unitary op evolution rhs matrix in ssesolve. - Fixed interpolating function to return zero outside range. - Fixed dnorm complex casting bug. - Fixed control.io path checking issue. - Fixed ENR fock dimension. - Fixed hard coded options in propagator 'batch' mode. - Fixed bug in trace-norm for non-Hermitian operators. - Fixed bug related to args not being passed to coherence_function_g2. - Fixed MKL error checking dict key error. Version 4.2.0 (July 28, 2017); +++++++++++++++++++++++++++++. Improvements; ------------. - **MAJOR FEATURE**: Initial implementation of time-dependent Bloch-Redfield Solver. - Qobj tidyup is now an order of magnitude faster. - Time-dependent codegen now generates output NumPy arrays faster. - Improved calculation for analytic coefficients in coherent states (Sebastian Kramer). - Input array to correlation FFT method now checked for validity. - Function-based time-dependent mesolve and sesolve routines now faster. - Codegen now makes sure that division is done in C, as opposed to Python. - Can now set different controls for a each timeslot in quantum optimization.; This allows time-varying controls to be used in pulse optimisation. Bug Fixes; ---------. - rcsolve importing old Odeoptions Class rather than Options. - Non-int issue in spin Q and Wigner functions. - Qobj's should tidyup before determining isherm. - Fixed time-dependent RHS function loading on Win. - Fixed several issues with compiling with Cython 0.26. - Liouvillian superoperators were hard setting isherm=True by default. - Fixed an issue with the solver safety checks when inputing a list with Python functions as time-dependence. - Fixed non-int issue in Wigner_cmap. - MKL solver error handling not working properly. Version 4.1.0 (March 10, 2017); ++++++++++++++++++++++++++++++. Improvements; ------------. *Core libraries*. - **MAJOR FEATURE**: QuTiP now works for Python 3.5+ on Windows using Vi",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:95476,Integrability,rout,routines,95476,"cvxpy Variable and Parameter. - Fixed iterative lu solve atol keyword issue. - Fixed unitary op evolution rhs matrix in ssesolve. - Fixed interpolating function to return zero outside range. - Fixed dnorm complex casting bug. - Fixed control.io path checking issue. - Fixed ENR fock dimension. - Fixed hard coded options in propagator 'batch' mode. - Fixed bug in trace-norm for non-Hermitian operators. - Fixed bug related to args not being passed to coherence_function_g2. - Fixed MKL error checking dict key error. Version 4.2.0 (July 28, 2017); +++++++++++++++++++++++++++++. Improvements; ------------. - **MAJOR FEATURE**: Initial implementation of time-dependent Bloch-Redfield Solver. - Qobj tidyup is now an order of magnitude faster. - Time-dependent codegen now generates output NumPy arrays faster. - Improved calculation for analytic coefficients in coherent states (Sebastian Kramer). - Input array to correlation FFT method now checked for validity. - Function-based time-dependent mesolve and sesolve routines now faster. - Codegen now makes sure that division is done in C, as opposed to Python. - Can now set different controls for a each timeslot in quantum optimization.; This allows time-varying controls to be used in pulse optimisation. Bug Fixes; ---------. - rcsolve importing old Odeoptions Class rather than Options. - Non-int issue in spin Q and Wigner functions. - Qobj's should tidyup before determining isherm. - Fixed time-dependent RHS function loading on Win. - Fixed several issues with compiling with Cython 0.26. - Liouvillian superoperators were hard setting isherm=True by default. - Fixed an issue with the solver safety checks when inputing a list with Python functions as time-dependence. - Fixed non-int issue in Wigner_cmap. - MKL solver error handling not working properly. Version 4.1.0 (March 10, 2017); ++++++++++++++++++++++++++++++. Improvements; ------------. *Core libraries*. - **MAJOR FEATURE**: QuTiP now works for Python 3.5+ on Windows using Vi",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:95914,Integrability,depend,dependent,95914,"ion_g2. - Fixed MKL error checking dict key error. Version 4.2.0 (July 28, 2017); +++++++++++++++++++++++++++++. Improvements; ------------. - **MAJOR FEATURE**: Initial implementation of time-dependent Bloch-Redfield Solver. - Qobj tidyup is now an order of magnitude faster. - Time-dependent codegen now generates output NumPy arrays faster. - Improved calculation for analytic coefficients in coherent states (Sebastian Kramer). - Input array to correlation FFT method now checked for validity. - Function-based time-dependent mesolve and sesolve routines now faster. - Codegen now makes sure that division is done in C, as opposed to Python. - Can now set different controls for a each timeslot in quantum optimization.; This allows time-varying controls to be used in pulse optimisation. Bug Fixes; ---------. - rcsolve importing old Odeoptions Class rather than Options. - Non-int issue in spin Q and Wigner functions. - Qobj's should tidyup before determining isherm. - Fixed time-dependent RHS function loading on Win. - Fixed several issues with compiling with Cython 0.26. - Liouvillian superoperators were hard setting isherm=True by default. - Fixed an issue with the solver safety checks when inputing a list with Python functions as time-dependence. - Fixed non-int issue in Wigner_cmap. - MKL solver error handling not working properly. Version 4.1.0 (March 10, 2017); ++++++++++++++++++++++++++++++. Improvements; ------------. *Core libraries*. - **MAJOR FEATURE**: QuTiP now works for Python 3.5+ on Windows using Visual Studio 2015. - **MAJOR FEATURE**: Cython and other low level code switched to C++ for MS Windows compatibility. - **MAJOR FEATURE**: Can now use interpolating cubic splines as time-dependent coefficients. - **MAJOR FEATURE**: Sparse matrix - vector multiplication now parallel using OPENMP. - Automatic tuning of OPENMP threading threshold. - Partial trace function is now up to 100x+ faster. - Hermitian verification now up to 100x+ faster. - Internal Qobj obj",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:96178,Integrability,depend,dependence,96178,"-Redfield Solver. - Qobj tidyup is now an order of magnitude faster. - Time-dependent codegen now generates output NumPy arrays faster. - Improved calculation for analytic coefficients in coherent states (Sebastian Kramer). - Input array to correlation FFT method now checked for validity. - Function-based time-dependent mesolve and sesolve routines now faster. - Codegen now makes sure that division is done in C, as opposed to Python. - Can now set different controls for a each timeslot in quantum optimization.; This allows time-varying controls to be used in pulse optimisation. Bug Fixes; ---------. - rcsolve importing old Odeoptions Class rather than Options. - Non-int issue in spin Q and Wigner functions. - Qobj's should tidyup before determining isherm. - Fixed time-dependent RHS function loading on Win. - Fixed several issues with compiling with Cython 0.26. - Liouvillian superoperators were hard setting isherm=True by default. - Fixed an issue with the solver safety checks when inputing a list with Python functions as time-dependence. - Fixed non-int issue in Wigner_cmap. - MKL solver error handling not working properly. Version 4.1.0 (March 10, 2017); ++++++++++++++++++++++++++++++. Improvements; ------------. *Core libraries*. - **MAJOR FEATURE**: QuTiP now works for Python 3.5+ on Windows using Visual Studio 2015. - **MAJOR FEATURE**: Cython and other low level code switched to C++ for MS Windows compatibility. - **MAJOR FEATURE**: Can now use interpolating cubic splines as time-dependent coefficients. - **MAJOR FEATURE**: Sparse matrix - vector multiplication now parallel using OPENMP. - Automatic tuning of OPENMP threading threshold. - Partial trace function is now up to 100x+ faster. - Hermitian verification now up to 100x+ faster. - Internal Qobj objects now created up to 60x faster. - Inplace conversion from COO -> CSR sparse formats (e.g. Memory efficiency improvement.). - Faster reverse Cuthill-Mckee and sparse one and inf norms. Bug Fixes; ---------.",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:96646,Integrability,depend,dependent,96646,"ot in quantum optimization.; This allows time-varying controls to be used in pulse optimisation. Bug Fixes; ---------. - rcsolve importing old Odeoptions Class rather than Options. - Non-int issue in spin Q and Wigner functions. - Qobj's should tidyup before determining isherm. - Fixed time-dependent RHS function loading on Win. - Fixed several issues with compiling with Cython 0.26. - Liouvillian superoperators were hard setting isherm=True by default. - Fixed an issue with the solver safety checks when inputing a list with Python functions as time-dependence. - Fixed non-int issue in Wigner_cmap. - MKL solver error handling not working properly. Version 4.1.0 (March 10, 2017); ++++++++++++++++++++++++++++++. Improvements; ------------. *Core libraries*. - **MAJOR FEATURE**: QuTiP now works for Python 3.5+ on Windows using Visual Studio 2015. - **MAJOR FEATURE**: Cython and other low level code switched to C++ for MS Windows compatibility. - **MAJOR FEATURE**: Can now use interpolating cubic splines as time-dependent coefficients. - **MAJOR FEATURE**: Sparse matrix - vector multiplication now parallel using OPENMP. - Automatic tuning of OPENMP threading threshold. - Partial trace function is now up to 100x+ faster. - Hermitian verification now up to 100x+ faster. - Internal Qobj objects now created up to 60x faster. - Inplace conversion from COO -> CSR sparse formats (e.g. Memory efficiency improvement.). - Faster reverse Cuthill-Mckee and sparse one and inf norms. Bug Fixes; ---------. - Cleanup of temp. Cython files now more robust and working under Windows. Version 4.0.2 (January 5, 2017); +++++++++++++++++++++++++++++++. Bug Fixes; ---------; - td files no longer left behind by correlation tests; - Various fast sparse fixes. Version 4.0.0 (December 22, 2016); +++++++++++++++++++++++++++++++++. Improvements; ------------; *Core libraries*. - **MAJOR FEATURE**: Fast sparse: New subclass of csr_matrix added that overrides commonly used methods to avoid certain chec",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:97804,Integrability,depend,dependent,97804,"r. - Hermitian verification now up to 100x+ faster. - Internal Qobj objects now created up to 60x faster. - Inplace conversion from COO -> CSR sparse formats (e.g. Memory efficiency improvement.). - Faster reverse Cuthill-Mckee and sparse one and inf norms. Bug Fixes; ---------. - Cleanup of temp. Cython files now more robust and working under Windows. Version 4.0.2 (January 5, 2017); +++++++++++++++++++++++++++++++. Bug Fixes; ---------; - td files no longer left behind by correlation tests; - Various fast sparse fixes. Version 4.0.0 (December 22, 2016); +++++++++++++++++++++++++++++++++. Improvements; ------------; *Core libraries*. - **MAJOR FEATURE**: Fast sparse: New subclass of csr_matrix added that overrides commonly used methods to avoid certain checks that incurr execution cost. All Qobj.data now fast_csr_matrix; - HEOM performance enhancements; - spmv now faster; - mcsolve codegen further optimised. *Control modules*. - Time dependent drift (through list of pwc dynamics generators); - memory optimisation options provided for control.dynamics. Bug Fixes; ---------. - recompilation of pyx files on first import removed; - tau array in control.pulseoptim funcs now works. Version 3.2.0 (Never officially released); +++++++++++++++++++++++++++++++++++++++++. New Features; ------------. *Core libraries*. - **MAJOR FEATURE**: Non-Markovian solvers: Hierarchy (**Added by Neill Lambert**), Memory-Cascade, and Transfer-Tensor methods.; - **MAJOR FEATURE**: Default steady state solver now up to 100x faster using the Intel Pardiso library under the Anaconda and Intel Python distributions.; - The default Wigner function now uses a Clenshaw summation algorithm to evaluate a polynomial series that is applicable for any number of exciations (previous limitation was ~50 quanta), and is ~3x faster than before. (**Added by Denis Vasilyev**); - Can now define a given eigen spectrum for random Hermitian and density operators.; - The Qobj ``expm`` method now uses the equivilent S",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:98860,Integrability,rout,routine,98860,"y optimisation options provided for control.dynamics. Bug Fixes; ---------. - recompilation of pyx files on first import removed; - tau array in control.pulseoptim funcs now works. Version 3.2.0 (Never officially released); +++++++++++++++++++++++++++++++++++++++++. New Features; ------------. *Core libraries*. - **MAJOR FEATURE**: Non-Markovian solvers: Hierarchy (**Added by Neill Lambert**), Memory-Cascade, and Transfer-Tensor methods.; - **MAJOR FEATURE**: Default steady state solver now up to 100x faster using the Intel Pardiso library under the Anaconda and Intel Python distributions.; - The default Wigner function now uses a Clenshaw summation algorithm to evaluate a polynomial series that is applicable for any number of exciations (previous limitation was ~50 quanta), and is ~3x faster than before. (**Added by Denis Vasilyev**); - Can now define a given eigen spectrum for random Hermitian and density operators.; - The Qobj ``expm`` method now uses the equivilent SciPy routine, and performs a much faster ``exp`` operation if the matrix is diagonal.; - One can now build zero operators using the ``qzero`` function. *Control modules*. - **MAJOR FEATURE**: CRAB algorithm added; This is an alternative to the GRAPE algorithm, which allows for analytical control functions, which means that experimental constraints can more easily be added into optimisation.; See tutorial notebook for full information. Improvements; ------------; *Core libraries*. - Two-time correlation functions can now be calculated for fully time-dependent Hamiltonians and collapse operators. (**Added by Kevin Fischer**); - The code for the inverse-power method for the steady state solver has been simplified.; - Bloch-Redfield tensor creation is now up to an order of magnitude faster. (**Added by Johannes Feist**); - Q.transform now works properly for arrays directly from sp_eigs (or eig).; - Q.groundstate now checks for degeneracy.; - Added ``sinm`` and ``cosm`` methods to the Qobj class.; - Added ",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:99410,Integrability,depend,dependent,99410,"el Pardiso library under the Anaconda and Intel Python distributions.; - The default Wigner function now uses a Clenshaw summation algorithm to evaluate a polynomial series that is applicable for any number of exciations (previous limitation was ~50 quanta), and is ~3x faster than before. (**Added by Denis Vasilyev**); - Can now define a given eigen spectrum for random Hermitian and density operators.; - The Qobj ``expm`` method now uses the equivilent SciPy routine, and performs a much faster ``exp`` operation if the matrix is diagonal.; - One can now build zero operators using the ``qzero`` function. *Control modules*. - **MAJOR FEATURE**: CRAB algorithm added; This is an alternative to the GRAPE algorithm, which allows for analytical control functions, which means that experimental constraints can more easily be added into optimisation.; See tutorial notebook for full information. Improvements; ------------; *Core libraries*. - Two-time correlation functions can now be calculated for fully time-dependent Hamiltonians and collapse operators. (**Added by Kevin Fischer**); - The code for the inverse-power method for the steady state solver has been simplified.; - Bloch-Redfield tensor creation is now up to an order of magnitude faster. (**Added by Johannes Feist**); - Q.transform now works properly for arrays directly from sp_eigs (or eig).; - Q.groundstate now checks for degeneracy.; - Added ``sinm`` and ``cosm`` methods to the Qobj class.; - Added ``charge`` and ``tunneling`` operators.; - Time-dependent Cython code is now easier to read and debug. *Control modules*. - The internal state / quantum operator data type can now be either Qobj or ndarray; Previous only ndarray was possible. This now opens up possibility of using Qobj methods in fidelity calculations; The attributes and functions that return these operators are now preceded by an underscore, to indicate that the data type could change depending on the configuration options.; In most cases these functions",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:99919,Integrability,depend,dependent,99919," - One can now build zero operators using the ``qzero`` function. *Control modules*. - **MAJOR FEATURE**: CRAB algorithm added; This is an alternative to the GRAPE algorithm, which allows for analytical control functions, which means that experimental constraints can more easily be added into optimisation.; See tutorial notebook for full information. Improvements; ------------; *Core libraries*. - Two-time correlation functions can now be calculated for fully time-dependent Hamiltonians and collapse operators. (**Added by Kevin Fischer**); - The code for the inverse-power method for the steady state solver has been simplified.; - Bloch-Redfield tensor creation is now up to an order of magnitude faster. (**Added by Johannes Feist**); - Q.transform now works properly for arrays directly from sp_eigs (or eig).; - Q.groundstate now checks for degeneracy.; - Added ``sinm`` and ``cosm`` methods to the Qobj class.; - Added ``charge`` and ``tunneling`` operators.; - Time-dependent Cython code is now easier to read and debug. *Control modules*. - The internal state / quantum operator data type can now be either Qobj or ndarray; Previous only ndarray was possible. This now opens up possibility of using Qobj methods in fidelity calculations; The attributes and functions that return these operators are now preceded by an underscore, to indicate that the data type could change depending on the configuration options.; In most cases these functions were for internal processing only anyway, and should have been 'private'.; Accessors to the properties that could be useful outside of the library have been added. These always return Qobj. If the internal operator data type is not Qobj, then there could be signicant overhead in the conversion, and so this should be avoided during pulse optimisation.; If custom sub-classes are developed that use Qobj properties and methods (e.g. partial trace), then it is very likely that it will be more efficient to set the internal data type to Qobj.; ",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:100328,Integrability,depend,depending,100328,"isation.; See tutorial notebook for full information. Improvements; ------------; *Core libraries*. - Two-time correlation functions can now be calculated for fully time-dependent Hamiltonians and collapse operators. (**Added by Kevin Fischer**); - The code for the inverse-power method for the steady state solver has been simplified.; - Bloch-Redfield tensor creation is now up to an order of magnitude faster. (**Added by Johannes Feist**); - Q.transform now works properly for arrays directly from sp_eigs (or eig).; - Q.groundstate now checks for degeneracy.; - Added ``sinm`` and ``cosm`` methods to the Qobj class.; - Added ``charge`` and ``tunneling`` operators.; - Time-dependent Cython code is now easier to read and debug. *Control modules*. - The internal state / quantum operator data type can now be either Qobj or ndarray; Previous only ndarray was possible. This now opens up possibility of using Qobj methods in fidelity calculations; The attributes and functions that return these operators are now preceded by an underscore, to indicate that the data type could change depending on the configuration options.; In most cases these functions were for internal processing only anyway, and should have been 'private'.; Accessors to the properties that could be useful outside of the library have been added. These always return Qobj. If the internal operator data type is not Qobj, then there could be signicant overhead in the conversion, and so this should be avoided during pulse optimisation.; If custom sub-classes are developed that use Qobj properties and methods (e.g. partial trace), then it is very likely that it will be more efficient to set the internal data type to Qobj.; The internal operator data will be chosen automatically based on the size and sparsity of the dynamics generator. It can be forced by setting ``dynamics.oper_dtype = <type>``; Note this can be done by passing ``dyn_params={'oper_dtype':<type>}`` in any of the pulseoptim functions. Some other prope",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:103031,Integrability,depend,dependent,103031,"vo`` as Qobj). - fidcomp properties. - ``uses_evo_t2end`` now ``uses_onwd_evo``; - ``uses_evo_t2targ`` now ``uses_onto_evo``; - ``set_phase_option`` function now property ``phase_option``. - propcomp properties. - ``grad_exact`` (now read only). - propcomp functions. - ``compute_propagator`` now ``_compute_propagator``; - ``compute_diff_prop`` now ``_compute_diff_prop``; - ``compute_prop_grad`` now ``_compute_prop_grad``. - tslotcomp functions. - ``get_timeslot_for_fidelity_calc`` now ``_get_timeslot_for_fidelity_calc``. *Miscellaneous*. - QuTiP Travis CI tests now use the Anaconda distribution.; - The ``about`` box and ipynb ``version_table`` now display addition system information.; - Updated Cython cleanup to remove depreciation warning in sysconfig.; - Updated ipynb_parallel to look for ``ipyparallel`` module in V4 of the notebooks. Bug Fixes; ---------; - Fixes for countstat and psuedo-inverse functions; - Fixed Qobj division tests on 32-bit systems.; - Removed extra call to Python in time-dependent Cython code.; - Fixed issue with repeated Bloch sphere saving.; - Fixed T_0 triplet state not normalized properly. (**Fixed by Eric Hontz**); - Simplified compiler flags (support for ARM systems).; - Fixed a decoding error in ``qload``.; - Fixed issue using complex.h math and np.kind_t variables.; - Corrected output states mismatch for ``ntraj=1`` in the mcf90 solver.; - Qobj data is now copied by default to avoid a bug in multiplication. (**Fixed by Richard Brierley**); - Fixed bug overwriting ``hardware_info`` in ``__init__``. (**Fixed by Johannes Feist**); - Restored ability to explicity set Q.isherm, Q.type, and Q.superrep.; - Fixed integer depreciation warnings from NumPy.; - Qobj * (dense vec) would result in a recursive loop.; - Fixed args=None -> args={} in correlation functions to be compatible with mesolve.; - Fixed depreciation warnings in mcsolve.; - Fixed neagtive only real parts in ``rand_ket``.; - Fixed a complicated list-cast-map-list antipattern in s",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:105038,Integrability,depend,dependent,105038,"Krastanov**); - Fixed incorrect ``isherm`` for ``sigmam`` spin operator.; - Fixed the dims when using ``final_state_output`` in ``mesolve`` and ``sesolve``. Version 3.1.0 (January 1, 2015); +++++++++++++++++++++++++++++++. New Features; ------------. - **MAJOR FEATURE**: New module for quantum control (qutip.control).; - **NAMESPACE CHANGE**: QuTiP no longer exports symbols from NumPy and matplotlib, so those modules must now be explicitly imported when required.; - New module for counting statistics.; - Stochastic solvers now run trajectories in parallel.; - New superoperator and tensor manipulation functions; (super_tensor, composite, tensor_contract).; - New logging module for debugging (qutip.logging).; - New user-available API for parallelization (parallel_map).; - New enhanced (optional) text-based progressbar (qutip.ui.EnhancedTextProgressBar); - Faster Python based monte carlo solver (mcsolve).; - Support for progress bars in propagator function.; - Time-dependent Cython code now calls complex cmath functions.; - Random numbers seeds can now be reused for successive calls to mcsolve.; - The Bloch-Redfield master equation solver now supports optional Lindblad type collapse operators.; - Improved handling of ODE integration errors in mesolve.; - Improved correlation function module (for example, improved support for time-dependent problems).; - Improved parallelization of mcsolve (can now be interrupted easily, support for IPython.parallel, etc.); - Many performance improvements, and much internal code restructuring. Bug Fixes; ---------. - Cython build files for time-dependent string format now removed automatically.; - Fixed incorrect solution time from inverse-power method steady state solver.; - mcsolve now supports `Options(store_states=True)`; - Fixed bug in `hadamard` gate function.; - Fixed compatibility issues with NumPy 1.9.0.; - Progressbar in mcsolve can now be suppressed.; - Fixed bug in `gate_expand_3toN`.; - Fixed bug for time-dependent problem (",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:105299,Integrability,integrat,integration,105299,"-----------. - **MAJOR FEATURE**: New module for quantum control (qutip.control).; - **NAMESPACE CHANGE**: QuTiP no longer exports symbols from NumPy and matplotlib, so those modules must now be explicitly imported when required.; - New module for counting statistics.; - Stochastic solvers now run trajectories in parallel.; - New superoperator and tensor manipulation functions; (super_tensor, composite, tensor_contract).; - New logging module for debugging (qutip.logging).; - New user-available API for parallelization (parallel_map).; - New enhanced (optional) text-based progressbar (qutip.ui.EnhancedTextProgressBar); - Faster Python based monte carlo solver (mcsolve).; - Support for progress bars in propagator function.; - Time-dependent Cython code now calls complex cmath functions.; - Random numbers seeds can now be reused for successive calls to mcsolve.; - The Bloch-Redfield master equation solver now supports optional Lindblad type collapse operators.; - Improved handling of ODE integration errors in mesolve.; - Improved correlation function module (for example, improved support for time-dependent problems).; - Improved parallelization of mcsolve (can now be interrupted easily, support for IPython.parallel, etc.); - Many performance improvements, and much internal code restructuring. Bug Fixes; ---------. - Cython build files for time-dependent string format now removed automatically.; - Fixed incorrect solution time from inverse-power method steady state solver.; - mcsolve now supports `Options(store_states=True)`; - Fixed bug in `hadamard` gate function.; - Fixed compatibility issues with NumPy 1.9.0.; - Progressbar in mcsolve can now be suppressed.; - Fixed bug in `gate_expand_3toN`.; - Fixed bug for time-dependent problem (list string format) with multiple terms in coefficient to an operator. Version 3.0.1 (Aug 5, 2014); +++++++++++++++++++++++++++. Bug Fixes; ---------. - Fix bug in create(), which returned a Qobj with CSC data instead of CSR.; - Fix sever",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:105410,Integrability,depend,dependent,105410,".; - **NAMESPACE CHANGE**: QuTiP no longer exports symbols from NumPy and matplotlib, so those modules must now be explicitly imported when required.; - New module for counting statistics.; - Stochastic solvers now run trajectories in parallel.; - New superoperator and tensor manipulation functions; (super_tensor, composite, tensor_contract).; - New logging module for debugging (qutip.logging).; - New user-available API for parallelization (parallel_map).; - New enhanced (optional) text-based progressbar (qutip.ui.EnhancedTextProgressBar); - Faster Python based monte carlo solver (mcsolve).; - Support for progress bars in propagator function.; - Time-dependent Cython code now calls complex cmath functions.; - Random numbers seeds can now be reused for successive calls to mcsolve.; - The Bloch-Redfield master equation solver now supports optional Lindblad type collapse operators.; - Improved handling of ODE integration errors in mesolve.; - Improved correlation function module (for example, improved support for time-dependent problems).; - Improved parallelization of mcsolve (can now be interrupted easily, support for IPython.parallel, etc.); - Many performance improvements, and much internal code restructuring. Bug Fixes; ---------. - Cython build files for time-dependent string format now removed automatically.; - Fixed incorrect solution time from inverse-power method steady state solver.; - mcsolve now supports `Options(store_states=True)`; - Fixed bug in `hadamard` gate function.; - Fixed compatibility issues with NumPy 1.9.0.; - Progressbar in mcsolve can now be suppressed.; - Fixed bug in `gate_expand_3toN`.; - Fixed bug for time-dependent problem (list string format) with multiple terms in coefficient to an operator. Version 3.0.1 (Aug 5, 2014); +++++++++++++++++++++++++++. Bug Fixes; ---------. - Fix bug in create(), which returned a Qobj with CSC data instead of CSR.; - Fix several bugs in mcsolve: Incorrect storing of collapse times and collapse; operator r",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:105662,Integrability,depend,dependent,105662,"nctions; (super_tensor, composite, tensor_contract).; - New logging module for debugging (qutip.logging).; - New user-available API for parallelization (parallel_map).; - New enhanced (optional) text-based progressbar (qutip.ui.EnhancedTextProgressBar); - Faster Python based monte carlo solver (mcsolve).; - Support for progress bars in propagator function.; - Time-dependent Cython code now calls complex cmath functions.; - Random numbers seeds can now be reused for successive calls to mcsolve.; - The Bloch-Redfield master equation solver now supports optional Lindblad type collapse operators.; - Improved handling of ODE integration errors in mesolve.; - Improved correlation function module (for example, improved support for time-dependent problems).; - Improved parallelization of mcsolve (can now be interrupted easily, support for IPython.parallel, etc.); - Many performance improvements, and much internal code restructuring. Bug Fixes; ---------. - Cython build files for time-dependent string format now removed automatically.; - Fixed incorrect solution time from inverse-power method steady state solver.; - mcsolve now supports `Options(store_states=True)`; - Fixed bug in `hadamard` gate function.; - Fixed compatibility issues with NumPy 1.9.0.; - Progressbar in mcsolve can now be suppressed.; - Fixed bug in `gate_expand_3toN`.; - Fixed bug for time-dependent problem (list string format) with multiple terms in coefficient to an operator. Version 3.0.1 (Aug 5, 2014); +++++++++++++++++++++++++++. Bug Fixes; ---------. - Fix bug in create(), which returned a Qobj with CSC data instead of CSR.; - Fix several bugs in mcsolve: Incorrect storing of collapse times and collapse; operator records. Incorrect averaging of expectation values for different; trajectories when using only 1 CPU.; - Fix bug in parsing of time-dependent Hamiltonian/collapse operator arguments; that occurred when the args argument is not a dictionary.; - Fix bug in internal _version2int function that ca",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:106043,Integrability,depend,dependent,106043,"x cmath functions.; - Random numbers seeds can now be reused for successive calls to mcsolve.; - The Bloch-Redfield master equation solver now supports optional Lindblad type collapse operators.; - Improved handling of ODE integration errors in mesolve.; - Improved correlation function module (for example, improved support for time-dependent problems).; - Improved parallelization of mcsolve (can now be interrupted easily, support for IPython.parallel, etc.); - Many performance improvements, and much internal code restructuring. Bug Fixes; ---------. - Cython build files for time-dependent string format now removed automatically.; - Fixed incorrect solution time from inverse-power method steady state solver.; - mcsolve now supports `Options(store_states=True)`; - Fixed bug in `hadamard` gate function.; - Fixed compatibility issues with NumPy 1.9.0.; - Progressbar in mcsolve can now be suppressed.; - Fixed bug in `gate_expand_3toN`.; - Fixed bug for time-dependent problem (list string format) with multiple terms in coefficient to an operator. Version 3.0.1 (Aug 5, 2014); +++++++++++++++++++++++++++. Bug Fixes; ---------. - Fix bug in create(), which returned a Qobj with CSC data instead of CSR.; - Fix several bugs in mcsolve: Incorrect storing of collapse times and collapse; operator records. Incorrect averaging of expectation values for different; trajectories when using only 1 CPU.; - Fix bug in parsing of time-dependent Hamiltonian/collapse operator arguments; that occurred when the args argument is not a dictionary.; - Fix bug in internal _version2int function that cause a failure when parsingthe version number of the Cython package.; -. Version 3.0.0 (July 17, 2014); +++++++++++++++++++++++++++++. New Features; ------------. - New module `qutip.stochastic` with stochastic master equation and stochastic; Schrdinger equation solvers. - Expanded steady state solvers. The function ``steady`` has been deprecated in; favor of ``steadystate``. The steadystate solver no",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:106511,Integrability,depend,dependent,106511,"formance improvements, and much internal code restructuring. Bug Fixes; ---------. - Cython build files for time-dependent string format now removed automatically.; - Fixed incorrect solution time from inverse-power method steady state solver.; - mcsolve now supports `Options(store_states=True)`; - Fixed bug in `hadamard` gate function.; - Fixed compatibility issues with NumPy 1.9.0.; - Progressbar in mcsolve can now be suppressed.; - Fixed bug in `gate_expand_3toN`.; - Fixed bug for time-dependent problem (list string format) with multiple terms in coefficient to an operator. Version 3.0.1 (Aug 5, 2014); +++++++++++++++++++++++++++. Bug Fixes; ---------. - Fix bug in create(), which returned a Qobj with CSC data instead of CSR.; - Fix several bugs in mcsolve: Incorrect storing of collapse times and collapse; operator records. Incorrect averaging of expectation values for different; trajectories when using only 1 CPU.; - Fix bug in parsing of time-dependent Hamiltonian/collapse operator arguments; that occurred when the args argument is not a dictionary.; - Fix bug in internal _version2int function that cause a failure when parsingthe version number of the Cython package.; -. Version 3.0.0 (July 17, 2014); +++++++++++++++++++++++++++++. New Features; ------------. - New module `qutip.stochastic` with stochastic master equation and stochastic; Schrdinger equation solvers. - Expanded steady state solvers. The function ``steady`` has been deprecated in; favor of ``steadystate``. The steadystate solver no longer use umfpack by; default. New pre-processing methods for reordering and balancing the linear; equation system used in direct solution of the steady state. - New module `qutip.qip` with utilities for quantum information processing,; including pre-defined quantum gates along with functions for expanding; arbitrary 1, 2, and 3 qubit gates to N qubit registers, circuit; representations, library of quantum algorithms, and basic physical models for; some common QIP arc",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:107687,Integrability,depend,dependent,107687,"ion 3.0.0 (July 17, 2014); +++++++++++++++++++++++++++++. New Features; ------------. - New module `qutip.stochastic` with stochastic master equation and stochastic; Schrdinger equation solvers. - Expanded steady state solvers. The function ``steady`` has been deprecated in; favor of ``steadystate``. The steadystate solver no longer use umfpack by; default. New pre-processing methods for reordering and balancing the linear; equation system used in direct solution of the steady state. - New module `qutip.qip` with utilities for quantum information processing,; including pre-defined quantum gates along with functions for expanding; arbitrary 1, 2, and 3 qubit gates to N qubit registers, circuit; representations, library of quantum algorithms, and basic physical models for; some common QIP architectures. - New module `qutip.distributions` with unified API for working with; distribution functions. - New format for defining time-dependent Hamiltonians and collapse operators,; using a pre-calculated numpy array that specifies the values of the; Qobj-coefficients for each time step. - New functions for working with different superoperator representations,; including Kraus and Chi representation. - New functions for visualizing quantum states using Qubism and Schimdt plots:; ``plot_qubism`` and ``plot_schmidt``. - Dynamics solver now support taking argument ``e_ops`` (expectation value; operators) in dictionary form. - Public plotting functions from the ``qutip.visualization`` module are now; prefixed with ``plot_`` (e.g., ``plot_fock_distribution``). The; ``plot_wigner`` and ``plot_wigner_fock_distribution`` now supports 3D views; in addition to contour views. - New API and new functions for working with spin operators and states,; including for example ``spin_Jx``, ``spin_Jy``, ``spin_Jz`` and; ``spin_state``, ``spin_coherent``. - The ``expect`` function now supports a list of operators, in addition to the; previously supported list of states. - Simplified creation of qu",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:110092,Integrability,depend,dependent,110092,"vectors, density matrices in matrix and vector form. - The ``concurrence`` function now supports both pure and mixed states. Added; function for calculating the entangling power of a two-qubit gate. - Added function for generating (generalized) Lindblad dissipator; superoperators. - New functions for generating Bell states, and singlet and triplet states. - QuTiP no longer contains the demos GUI. The examples are now available on the; QuTiP web site. The ``qutip.gui`` module has been renamed to ``qutip.ui`` and; does no longer contain graphical UI elements. New text-based and HTML-based; progressbar classes. - Support for harmonic oscillator operators/states in a Fock state basis that; does not start from zero (e.g., in the range [M,N+1]). Support for; eliminating and extracting states from Qobj instances (e.g., removing one; state from a two-qubit system to obtain a three-level system). - Support for time-dependent Hamiltonian and Liouvillian callback functions that; depend on the instantaneous state, which for example can be used for solving; master equations with mean field terms. Improvements; ------------. - Restructured and optimized implementation of Qobj, which now has; significantly lower memory footprint due to avoiding excessive copying of; internal matrix data. - The classes ``OdeData``, ``Odeoptions``, ``Odeconfig`` are now called; ``Result``, ``Options``, and ``Config``, respectively, and are available in; the module `qutip.solver`. - The ``squeez`` function has been renamed to ``squeeze``. - Better support for sparse matrices when calculating propagators using the; ``propagator`` function. - Improved Bloch sphere. - Restructured and improved the module ``qutip.sparse``, which now only; operates directly on sparse matrices (not on Qobj instances). - Improved and simplified implement of the ``tensor`` function. - Improved performance, major code cleanup (including namespace changes),; and numerous bug fixes. - Benchmark scripts improved and restructured",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:110155,Integrability,depend,depend,110155,"vectors, density matrices in matrix and vector form. - The ``concurrence`` function now supports both pure and mixed states. Added; function for calculating the entangling power of a two-qubit gate. - Added function for generating (generalized) Lindblad dissipator; superoperators. - New functions for generating Bell states, and singlet and triplet states. - QuTiP no longer contains the demos GUI. The examples are now available on the; QuTiP web site. The ``qutip.gui`` module has been renamed to ``qutip.ui`` and; does no longer contain graphical UI elements. New text-based and HTML-based; progressbar classes. - Support for harmonic oscillator operators/states in a Fock state basis that; does not start from zero (e.g., in the range [M,N+1]). Support for; eliminating and extracting states from Qobj instances (e.g., removing one; state from a two-qubit system to obtain a three-level system). - Support for time-dependent Hamiltonian and Liouvillian callback functions that; depend on the instantaneous state, which for example can be used for solving; master equations with mean field terms. Improvements; ------------. - Restructured and optimized implementation of Qobj, which now has; significantly lower memory footprint due to avoiding excessive copying of; internal matrix data. - The classes ``OdeData``, ``Odeoptions``, ``Odeconfig`` are now called; ``Result``, ``Options``, and ``Config``, respectively, and are available in; the module `qutip.solver`. - The ``squeez`` function has been renamed to ``squeeze``. - Better support for sparse matrices when calculating propagators using the; ``propagator`` function. - Improved Bloch sphere. - Restructured and improved the module ``qutip.sparse``, which now only; operates directly on sparse matrices (not on Qobj instances). - Improved and simplified implement of the ``tensor`` function. - Improved performance, major code cleanup (including namespace changes),; and numerous bug fixes. - Benchmark scripts improved and restructured",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:111206,Integrability,integrat,integration,111206,"ple can be used for solving; master equations with mean field terms. Improvements; ------------. - Restructured and optimized implementation of Qobj, which now has; significantly lower memory footprint due to avoiding excessive copying of; internal matrix data. - The classes ``OdeData``, ``Odeoptions``, ``Odeconfig`` are now called; ``Result``, ``Options``, and ``Config``, respectively, and are available in; the module `qutip.solver`. - The ``squeez`` function has been renamed to ``squeeze``. - Better support for sparse matrices when calculating propagators using the; ``propagator`` function. - Improved Bloch sphere. - Restructured and improved the module ``qutip.sparse``, which now only; operates directly on sparse matrices (not on Qobj instances). - Improved and simplified implement of the ``tensor`` function. - Improved performance, major code cleanup (including namespace changes),; and numerous bug fixes. - Benchmark scripts improved and restructured. - QuTiP is now using continuous integration tests (TravisCI). Version 2.2.0 (March 01, 2013); ++++++++++++++++++++++++++++++. New Features; ------------. - **Added Support for Windows**. - New Bloch3d class for plotting 3D Bloch spheres using Mayavi. - Bloch sphere vectors now look like arrows. - Partial transpose function. - Continuos variable functions for calculating correlation and covariance; matrices, the Wigner covariance matrix and the logarithmic negativity for; for multimode fields in Fock basis. - The master-equation solver (mesolve) now accepts pre-constructed Liouvillian; terms, which makes it possible to solve master equations that are not on; the standard Lindblad form. - Optional Fortran Monte Carlo solver (mcsolve_f90) by Arne Grimsmo. - A module of tools for using QuTiP in IPython notebooks. - Increased performance of the steady state solver. - New Wigner colormap for highlighting negative values. - More graph styles to the visualization module. Bug Fixes; ---------. - Function based time-dependen",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:112196,Integrability,depend,dependent,112196,"egration tests (TravisCI). Version 2.2.0 (March 01, 2013); ++++++++++++++++++++++++++++++. New Features; ------------. - **Added Support for Windows**. - New Bloch3d class for plotting 3D Bloch spheres using Mayavi. - Bloch sphere vectors now look like arrows. - Partial transpose function. - Continuos variable functions for calculating correlation and covariance; matrices, the Wigner covariance matrix and the logarithmic negativity for; for multimode fields in Fock basis. - The master-equation solver (mesolve) now accepts pre-constructed Liouvillian; terms, which makes it possible to solve master equations that are not on; the standard Lindblad form. - Optional Fortran Monte Carlo solver (mcsolve_f90) by Arne Grimsmo. - A module of tools for using QuTiP in IPython notebooks. - Increased performance of the steady state solver. - New Wigner colormap for highlighting negative values. - More graph styles to the visualization module. Bug Fixes; ---------. - Function based time-dependent Hamiltonians now keep the correct phase. - mcsolve no longer prints to the command line if ntraj=1. Version 2.1.0 (October 05, 2012); ++++++++++++++++++++++++++++++++. New Features; ------------. - New method for generating Wigner functions based on Laguerre polynomials. - coherent(), coherent_dm(), and thermal_dm() can now be expressed using analytic values. - Unittests now use nose and can be run after installation. - Added iswap and sqrt-iswap gates. - Functions for quantum process tomography. - Window icons are now set for Ubuntu application launcher. - The propagator function can now take a list of times as argument, and returns a list of corresponding propagators. Bug Fixes; ---------. - mesolver now correctly uses the user defined rhs_filename in Odeoptions(). - rhs_generate() now handles user defined filenames properly. - Density matrix returned by propagator_steadystate is now Hermitian. - eseries_value returns real list if all imag parts are zero. - mcsolver now gives correct res",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:113469,Integrability,depend,dependence,113469,". - coherent(), coherent_dm(), and thermal_dm() can now be expressed using analytic values. - Unittests now use nose and can be run after installation. - Added iswap and sqrt-iswap gates. - Functions for quantum process tomography. - Window icons are now set for Ubuntu application launcher. - The propagator function can now take a list of times as argument, and returns a list of corresponding propagators. Bug Fixes; ---------. - mesolver now correctly uses the user defined rhs_filename in Odeoptions(). - rhs_generate() now handles user defined filenames properly. - Density matrix returned by propagator_steadystate is now Hermitian. - eseries_value returns real list if all imag parts are zero. - mcsolver now gives correct results for strong damping rates. - Odeoptions now prints mc_avg correctly. - Do not check for PyObj in mcsolve when gui=False. - Eseries now correctly handles purely complex rates. - thermal_dm() function now uses truncated operator method. - Cython based time-dependence now Python 3 compatible. - Removed call to NSAutoPool on mac systems. - Progress bar now displays the correct number of CPU's used. - Qobj.diag() returns reals if operator is Hermitian. - Text for progress bar on Linux systems is no longer cutoff. Version 2.0.0 (June 01, 2012); +++++++++++++++++++++++++++++. The second version of QuTiP has seen many improvements in the performance of the original code base, as well as the addition of several new routines supporting a wide range of functionality. Some of the highlights of this release include:. New Features; ------------. - QuTiP now includes solvers for both Floquet and Bloch-Redfield master equations. - The Lindblad master equation and Monte Carlo solvers allow for time-dependent collapse operators. - It is possible to automatically compile time-dependent problems into c-code using Cython (if installed). - Python functions can be used to create arbitrary time-dependent Hamiltonians and collapse operators. - Solvers now return Oded",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:113930,Integrability,rout,routines,113930," Bug Fixes; ---------. - mesolver now correctly uses the user defined rhs_filename in Odeoptions(). - rhs_generate() now handles user defined filenames properly. - Density matrix returned by propagator_steadystate is now Hermitian. - eseries_value returns real list if all imag parts are zero. - mcsolver now gives correct results for strong damping rates. - Odeoptions now prints mc_avg correctly. - Do not check for PyObj in mcsolve when gui=False. - Eseries now correctly handles purely complex rates. - thermal_dm() function now uses truncated operator method. - Cython based time-dependence now Python 3 compatible. - Removed call to NSAutoPool on mac systems. - Progress bar now displays the correct number of CPU's used. - Qobj.diag() returns reals if operator is Hermitian. - Text for progress bar on Linux systems is no longer cutoff. Version 2.0.0 (June 01, 2012); +++++++++++++++++++++++++++++. The second version of QuTiP has seen many improvements in the performance of the original code base, as well as the addition of several new routines supporting a wide range of functionality. Some of the highlights of this release include:. New Features; ------------. - QuTiP now includes solvers for both Floquet and Bloch-Redfield master equations. - The Lindblad master equation and Monte Carlo solvers allow for time-dependent collapse operators. - It is possible to automatically compile time-dependent problems into c-code using Cython (if installed). - Python functions can be used to create arbitrary time-dependent Hamiltonians and collapse operators. - Solvers now return Odedata objects containing all simulation results and parameters, simplifying the saving of simulation results. .. important:: This breaks compatibility with QuTiP version 1.x. - mesolve and mcsolve can reuse Hamiltonian data when only the initial state, or time-dependent arguments, need to be changed. - QuTiP includes functions for creating random quantum states and operators. - The generation and manipulatio",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:114211,Integrability,depend,dependent,114211,"ow gives correct results for strong damping rates. - Odeoptions now prints mc_avg correctly. - Do not check for PyObj in mcsolve when gui=False. - Eseries now correctly handles purely complex rates. - thermal_dm() function now uses truncated operator method. - Cython based time-dependence now Python 3 compatible. - Removed call to NSAutoPool on mac systems. - Progress bar now displays the correct number of CPU's used. - Qobj.diag() returns reals if operator is Hermitian. - Text for progress bar on Linux systems is no longer cutoff. Version 2.0.0 (June 01, 2012); +++++++++++++++++++++++++++++. The second version of QuTiP has seen many improvements in the performance of the original code base, as well as the addition of several new routines supporting a wide range of functionality. Some of the highlights of this release include:. New Features; ------------. - QuTiP now includes solvers for both Floquet and Bloch-Redfield master equations. - The Lindblad master equation and Monte Carlo solvers allow for time-dependent collapse operators. - It is possible to automatically compile time-dependent problems into c-code using Cython (if installed). - Python functions can be used to create arbitrary time-dependent Hamiltonians and collapse operators. - Solvers now return Odedata objects containing all simulation results and parameters, simplifying the saving of simulation results. .. important:: This breaks compatibility with QuTiP version 1.x. - mesolve and mcsolve can reuse Hamiltonian data when only the initial state, or time-dependent arguments, need to be changed. - QuTiP includes functions for creating random quantum states and operators. - The generation and manipulation of quantum objects is now more efficient. - Quantum objects have basis transformation and matrix element calculations as built-in methods. - The quantum object eigensolver can use sparse solvers. - The partial-trace (ptrace) function is up to 20x faster. - The Bloch sphere can now be used with the Matp",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:114288,Integrability,depend,dependent,114288,"heck for PyObj in mcsolve when gui=False. - Eseries now correctly handles purely complex rates. - thermal_dm() function now uses truncated operator method. - Cython based time-dependence now Python 3 compatible. - Removed call to NSAutoPool on mac systems. - Progress bar now displays the correct number of CPU's used. - Qobj.diag() returns reals if operator is Hermitian. - Text for progress bar on Linux systems is no longer cutoff. Version 2.0.0 (June 01, 2012); +++++++++++++++++++++++++++++. The second version of QuTiP has seen many improvements in the performance of the original code base, as well as the addition of several new routines supporting a wide range of functionality. Some of the highlights of this release include:. New Features; ------------. - QuTiP now includes solvers for both Floquet and Bloch-Redfield master equations. - The Lindblad master equation and Monte Carlo solvers allow for time-dependent collapse operators. - It is possible to automatically compile time-dependent problems into c-code using Cython (if installed). - Python functions can be used to create arbitrary time-dependent Hamiltonians and collapse operators. - Solvers now return Odedata objects containing all simulation results and parameters, simplifying the saving of simulation results. .. important:: This breaks compatibility with QuTiP version 1.x. - mesolve and mcsolve can reuse Hamiltonian data when only the initial state, or time-dependent arguments, need to be changed. - QuTiP includes functions for creating random quantum states and operators. - The generation and manipulation of quantum objects is now more efficient. - Quantum objects have basis transformation and matrix element calculations as built-in methods. - The quantum object eigensolver can use sparse solvers. - The partial-trace (ptrace) function is up to 20x faster. - The Bloch sphere can now be used with the Matplotlib animation function, and embedded as a subplot in a figure. - QuTiP has built-in functions for sav",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:114404,Integrability,depend,dependent,114404,"_dm() function now uses truncated operator method. - Cython based time-dependence now Python 3 compatible. - Removed call to NSAutoPool on mac systems. - Progress bar now displays the correct number of CPU's used. - Qobj.diag() returns reals if operator is Hermitian. - Text for progress bar on Linux systems is no longer cutoff. Version 2.0.0 (June 01, 2012); +++++++++++++++++++++++++++++. The second version of QuTiP has seen many improvements in the performance of the original code base, as well as the addition of several new routines supporting a wide range of functionality. Some of the highlights of this release include:. New Features; ------------. - QuTiP now includes solvers for both Floquet and Bloch-Redfield master equations. - The Lindblad master equation and Monte Carlo solvers allow for time-dependent collapse operators. - It is possible to automatically compile time-dependent problems into c-code using Cython (if installed). - Python functions can be used to create arbitrary time-dependent Hamiltonians and collapse operators. - Solvers now return Odedata objects containing all simulation results and parameters, simplifying the saving of simulation results. .. important:: This breaks compatibility with QuTiP version 1.x. - mesolve and mcsolve can reuse Hamiltonian data when only the initial state, or time-dependent arguments, need to be changed. - QuTiP includes functions for creating random quantum states and operators. - The generation and manipulation of quantum objects is now more efficient. - Quantum objects have basis transformation and matrix element calculations as built-in methods. - The quantum object eigensolver can use sparse solvers. - The partial-trace (ptrace) function is up to 20x faster. - The Bloch sphere can now be used with the Matplotlib animation function, and embedded as a subplot in a figure. - QuTiP has built-in functions for saving quantum objects and data arrays. - The steady-state solver has been further optimized for sparse matr",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:114735,Integrability,depend,dependent,114735,"o longer cutoff. Version 2.0.0 (June 01, 2012); +++++++++++++++++++++++++++++. The second version of QuTiP has seen many improvements in the performance of the original code base, as well as the addition of several new routines supporting a wide range of functionality. Some of the highlights of this release include:. New Features; ------------. - QuTiP now includes solvers for both Floquet and Bloch-Redfield master equations. - The Lindblad master equation and Monte Carlo solvers allow for time-dependent collapse operators. - It is possible to automatically compile time-dependent problems into c-code using Cython (if installed). - Python functions can be used to create arbitrary time-dependent Hamiltonians and collapse operators. - Solvers now return Odedata objects containing all simulation results and parameters, simplifying the saving of simulation results. .. important:: This breaks compatibility with QuTiP version 1.x. - mesolve and mcsolve can reuse Hamiltonian data when only the initial state, or time-dependent arguments, need to be changed. - QuTiP includes functions for creating random quantum states and operators. - The generation and manipulation of quantum objects is now more efficient. - Quantum objects have basis transformation and matrix element calculations as built-in methods. - The quantum object eigensolver can use sparse solvers. - The partial-trace (ptrace) function is up to 20x faster. - The Bloch sphere can now be used with the Matplotlib animation function, and embedded as a subplot in a figure. - QuTiP has built-in functions for saving quantum objects and data arrays. - The steady-state solver has been further optimized for sparse matrices, and can handle much larger system Hamiltonians. - The steady-state solver can use the iterative bi-conjugate gradient method instead of a direct solver. - There are three new entropy functions for concurrence, mutual information, and conditional entropy. - Correlation functions have been combined under a s",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:2446,Modifiability,flexible,flexible,2446," adjust tests to be sensitive to this issue. (#2393, by Neill Lambert). Documentation; -------------. - Correct a mistake in the doc (#2401, by PositroniumJS); - Fix #2156: Correct a sample of code in the doc (#2409, by PositroniumJS). Miscellaneous; -------------. - Better metadata management in operators creation functions (#2388); - Implicitly set minimum python version to 3.9 (#2413); - Qobj.__eq__ uses core's settings rtol. (#2425); - Only normalize solver states when the initial state is already normalized. (#2427). QuTiP 5.0.1 (2024-04-03); ========================. Patch update fixing small issues with v5.0.0 release. - Fix broken links in the documentation when migrating to readthedocs; - Fix readthedocs search feature; - Add setuptools to runtime compilation requirements; - Fix mcsolve documentation for open systems; - Fix OverFlowError in progress bars. QuTiP 5.0.0 (2024-03-26); ========================. QuTiP 5 is a redesign of many of the core components of QuTiP (``Qobj``,; ``QobjEvo``, solvers) to make them more consistent and more flexible. ``Qobj`` may now be stored in either sparse or dense representations,; and the two may be mixed sensibly as needed. ``QobjEvo`` is now used; consistently throughout QuTiP, and the implementation has been; substantially cleaned up. A new ``Coefficient`` class is used to; represent the time-dependent factors inside ``QobjEvo``. The solvers have been rewritten to work well with the new data layer; and the concept of ``Integrators`` which solve ODEs has been introduced.; In future, new data layers may provide their own ``Integrators``; specialized to their representation of the underlying data. Much of the user-facing API of QuTiP remains familiar, but there have; had to be many small breaking changes. If we can make changes to; easy migrating code from QuTiP 4 to QuTiP 5, please let us know. An extensive list of changes follows. Contributors; ------------. QuTiP 5 has been a large effort by many people over the last ",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:2948,Modifiability,layers,layers,2948,"issues with v5.0.0 release. - Fix broken links in the documentation when migrating to readthedocs; - Fix readthedocs search feature; - Add setuptools to runtime compilation requirements; - Fix mcsolve documentation for open systems; - Fix OverFlowError in progress bars. QuTiP 5.0.0 (2024-03-26); ========================. QuTiP 5 is a redesign of many of the core components of QuTiP (``Qobj``,; ``QobjEvo``, solvers) to make them more consistent and more flexible. ``Qobj`` may now be stored in either sparse or dense representations,; and the two may be mixed sensibly as needed. ``QobjEvo`` is now used; consistently throughout QuTiP, and the implementation has been; substantially cleaned up. A new ``Coefficient`` class is used to; represent the time-dependent factors inside ``QobjEvo``. The solvers have been rewritten to work well with the new data layer; and the concept of ``Integrators`` which solve ODEs has been introduced.; In future, new data layers may provide their own ``Integrators``; specialized to their representation of the underlying data. Much of the user-facing API of QuTiP remains familiar, but there have; had to be many small breaking changes. If we can make changes to; easy migrating code from QuTiP 4 to QuTiP 5, please let us know. An extensive list of changes follows. Contributors; ------------. QuTiP 5 has been a large effort by many people over the last three years. In particular:. - Jake Lishman led the implementation of the new data layer and coefficients.; - Eric Gigure led the implementation of the new QobjEvo interface and solvers.; - Boxi Li led the updating of QuTiP's QIP support and the creation of ``qutip_qip``. Other members of the QuTiP Admin team have been heavily involved in reviewing,; testing and designing QuTiP 5:. - Alexander Pitchford; - Asier Galicia; - Nathan Shammah; - Shahnawaz Ahmed; - Neill Lambert; - Simon Cross; - Paul Menczel. Two Google Summer of Code contributors updated the tutorials and benchmarks to; QuTiP 5:. - Chri",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:4421,Modifiability,layers,layers,4421," new data layer and coefficients.; - Eric Gigure led the implementation of the new QobjEvo interface and solvers.; - Boxi Li led the updating of QuTiP's QIP support and the creation of ``qutip_qip``. Other members of the QuTiP Admin team have been heavily involved in reviewing,; testing and designing QuTiP 5:. - Alexander Pitchford; - Asier Galicia; - Nathan Shammah; - Shahnawaz Ahmed; - Neill Lambert; - Simon Cross; - Paul Menczel. Two Google Summer of Code contributors updated the tutorials and benchmarks to; QuTiP 5:. - Christian Staufenbiel updated many of the tutorials (`<https://github.com/qutip/qutip-tutorials/>`).; - Xavier Sproken update the benchmarks (`<https://github.com/qutip/qutip-benchmark/>`). During an internship at RIKEN, Patrick Hopf created a new quantum control method and; improved the existing methods interface:. - Patrick Hopf created new quantum control package (`<https://github.com/qutip/qutip-qoc/>`). Four experimental data layers backends were written either as part of Google Summer; of Code or as separate projects. While these are still alpha quality, they helped; significantly to test the data layer API:. - ``qutip-tensorflow``: a TensorFlow backend by Asier Galicia (`<https://github.com/qutip/qutip-tensorflow>`); - ``qutip-cupy``: a CuPy GPU backend by Felipe Bivort Haiek (`<https://github.com/qutip/qutip-cupy/>`)`; - ``qutip-tensornetwork``: a TensorNetwork backend by Asier Galicia (`<https://github.com/qutip/qutip-tensornetwork>`); - ``qutip-jax``: a JAX backend by Eric Gigure (`<https://github.com/qutip/qutip-jax/>`). Finally, Yuji Tamakoshi updated the visualization function and added animation; functions as part of Google Summer of Code project. We have also had many other contributors, whose specific contributions are; detailed below:. - Pieter Eendebak (updated the required SciPy to 1.5+, `#1982 <https://github.com/qutip/qutip/pull/1982>`).; - Pieter Eendebak (reduced import times by setting logger names, `#1981 <https://github",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:9075,Modifiability,inherit,inherited,9075,">`); - lklivingstone (Added __repr__ to QobjEvo, `#2111 <https://github.com/qutip/qutip/pull/2111>`); - Yuji Tamakoshi (Improve print(qutip.settings) by make it shorter, `#2113 <https://github.com/qutip/qutip/pull/2113>`); - khnikhil (Added fermionic annihilation and creation operators, `#2166 <https://github.com/qutip/qutip/pull/2166>`); - Daniel Weiss (Improved sampling algorithm for mcsolve, `#2218 <https://github.com/qutip/qutip/pull/2218>`); - SJUW (Increase missing colorbar padding for matrix_histogram_complex() from 0 to 0.05, `#2181 <https://github.com/qutip/qutip/pull/2181>`); - Valan Baptist Mathuranayagam (Changed qutip-notebooks to qutip-tutorials and fixed the typo in the link redirecting to the changelog section in the PR template, `#2107 <https://github.com/qutip/qutip/pull/2107>`); - Gerardo Jose Suarez (Added information on sec_cutoff to the documentation, `#2136 <https://github.com/qutip/qutip/pull/2136>`); - Cristian Emiliano Godinez Ramirez (Added inherited members to API doc of MESolver, SMESolver, SSESolver, NonMarkovianMCSolver, `#2167 <https://github.com/qutip/qutip/pull/2167>`); - Andrey Rakhubovsky (Corrected grammar in Bloch-Redfield master equation documentation, `#2174 <https://github.com/qutip/qutip/pull/2174>`); - Rushiraj Gadhvi (qutip.ipynbtools.version_table() can now be called without Cython installed, `#2110 <https://github.com/qutip/qutip/pull/2110>`); - Harsh Khilawala (Moved HTMLProgressBar from qutip/ipynbtools.py to qutip/ui/progressbar.py, `#2112 <https://github.com/qutip/qutip/pull/2112>`); - Avatar Srinidhi P V (Added new argument bc_type to take boundary conditions when creating QobjEvo, `#2114 <https://github.com/qutip/qutip/pull/2114>`); - Andrey Rakhubovsky (Fix types in docstring of projection(), `#2363 <https://github.com/qutip/qutip/pull/2363>`). Qobj changes; ------------. Previously ``Qobj`` data was stored in a SciPy-like sparse matrix. Now the; representation is flexible. Implementations for dense and sparse for",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:10043,Modifiability,flexible,flexible,10043," Cristian Emiliano Godinez Ramirez (Added inherited members to API doc of MESolver, SMESolver, SSESolver, NonMarkovianMCSolver, `#2167 <https://github.com/qutip/qutip/pull/2167>`); - Andrey Rakhubovsky (Corrected grammar in Bloch-Redfield master equation documentation, `#2174 <https://github.com/qutip/qutip/pull/2174>`); - Rushiraj Gadhvi (qutip.ipynbtools.version_table() can now be called without Cython installed, `#2110 <https://github.com/qutip/qutip/pull/2110>`); - Harsh Khilawala (Moved HTMLProgressBar from qutip/ipynbtools.py to qutip/ui/progressbar.py, `#2112 <https://github.com/qutip/qutip/pull/2112>`); - Avatar Srinidhi P V (Added new argument bc_type to take boundary conditions when creating QobjEvo, `#2114 <https://github.com/qutip/qutip/pull/2114>`); - Andrey Rakhubovsky (Fix types in docstring of projection(), `#2363 <https://github.com/qutip/qutip/pull/2363>`). Qobj changes; ------------. Previously ``Qobj`` data was stored in a SciPy-like sparse matrix. Now the; representation is flexible. Implementations for dense and sparse formats are; included in QuTiP and custom implementations are possible. QuTiP's performance; on dense states and operators is significantly improved as a result. Some highlights:. - The data is still acessible via the ``.data`` attribute, but is now an; instance of the underlying data type instead of a SciPy-like sparse matrix.; The operations available in ``qutip.core.data`` may be used on ``.data``,; regardless of the data type.; - ``Qobj`` with different data types may be mixed in arithmetic and other; operations. A sensible output type will be automatically determined.; - The new ``.to(...)`` method may be used to convert a ``Qobj`` from one data type; to another. E.g. ``.to(""dense"")`` will convert to the dense representation and; ``.to(""csr"")`` will convert to the sparse type.; - Many ``Qobj`` methods and methods that create ``Qobj`` now accepted a ``dtype``; parameter that allows the data type of the returned ``Qobj`` to spe",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:11887,Modifiability,extend,extended,11887,"; ``.to(""csr"")`` will convert to the sparse type.; - Many ``Qobj`` methods and methods that create ``Qobj`` now accepted a ``dtype``; parameter that allows the data type of the returned ``Qobj`` to specified.; - The new ``&`` operator may be used to obtain the tensor product.; - The new ``@`` operator may be used to obtain the matrix / operator product.; ``bar @ ket`` returns a scalar.; - The new ``.contract()`` method will collapse 1D subspaces of the dimensions of; the ``Qobj``.; - The new ``.logm()`` method returns the matrix logarithm of an operator.; - The methods ``.set_data``, ``.get_data``, ``.extract_state``, ``.eliminate_states``,; ``.evaluate`` and ``.check_isunitary`` have been removed.; - The property ``dtype`` return the representation of the data used.; - The new ``data_as`` allow to obtain the data as a common python formats:; numpy array, scipy sparse matrix, JAX Array, etc. QobjEvo changes; ---------------. The ``QobjEvo`` type for storing time-dependent quantum objects has been; significantly expanded, standardized and extended. The time-dependent; coefficients are now represented using a new ``Coefficient`` type that; may be independently created and manipulated if required. Some highlights:. - The ``.compile()`` method has been removed. Coefficients specified as; strings are automatically compiled if possible and the compilation is; cached across different Python runs and instances.; - Mixing coefficient types within a single ``Qobj`` is now supported.; - Many new attributes were added to ``QobjEvo`` for convenience. Examples; include ``.dims``, ``.shape``, ``.superrep`` and ``.isconstant``.; - Many old attributes such as ``.cte``, ``.use_cython``, ``.type``, ``.const``,; and ``.coeff_file`` were removed.; - A new ``Spline`` coefficient supports spline interpolations of different; orders. The old ``Cubic_Spline`` coefficient has been removed.; - The new ``.arguments(...)`` method allows additional arguments to the; underlying coefficient function",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:26886,Modifiability,config,config,26886,"It contained the old sparse matrix representation and is replaced by the new implementation in ``qutip.data``.; - ``qutip.piqs`` functions are no longer available from the ``qutip`` namespace. They are accessible from ``qutip.piqs`` instead. Miscellaneous; -------------. - Support has been added for 64-bit integer sparse matrix indices, allowing; sparse matrices with up to 2**63 rows and columns. This support needs to; be enabled at compilation time by calling ``setup.py`` and passing; ``--with-idxint-64``. Feature removals; ----------------. - Support for OpenMP has been removed. If there is enough demand and a good plan for how to organize it, OpenMP support may return in a future QuTiP release.; - The ``qutip.parfor`` function has been removed. Use ``qutip.parallel_map`` instead.; - ``qutip.graph`` has been removed and replaced by SciPy's graph functions.; - ``qutip.topology`` has been removed. It contained only one function ``berry_curvature``.; - The ``~/.qutip/qutiprc`` config file is no longer supported. It contained settings for the OpenMP support.; - Deprecate ``three_level_atom``; - Deprecate ``orbital``. Changes from QuTiP 5.0.0b1:; ---------------------------. Features; --------. - Add dtype to printed ouput of qobj (#2352 by Rochisha Agarwal). Miscellaneous; -------------. - Allow scipy 1.12 to be used with qutip. (#2354 by Pieter Eendebak). QuTiP 5.0.0b1 (2024-03-04); ==========================. Features; --------. - Create a Dimension class (#1996); - Add arguments of plot_wigner() and plot_wigner_fock_distribution() to specify parameters for wigner(). (#2057, by Kosuke Mizuno); - Restore feedback to solvers (#2210); - Added mpi_pmap, which uses the mpi4py module to run computations in parallel through the MPI interface. (#2296, by Paul); - Only pre-compute density matrices if keep_runs_results is False (#2303, by Matt Ord). Bug Fixes; ---------. - Add the possibility to customize point colors as in V4 and fix point plot behavior for 'l' style (#1974, ",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:31958,Modifiability,inherit,inherited,31958," by christian512); - Added default _isherm value (True) for momentum and position operators. (#2032 by Asier Galicia); - Changed qutip-notebooks to qutip-tutorials and fixed the typo in the link redirecting to the changelog section in the PR template. (#2107 by Valan Baptist Mathuranayagam); - Increase missing colorbar padding for matrix_histogram_complex() from 0 to 0.05. (#2181 by SJUW); - Raise error on insufficient memory. (#2224); - Fixed fallback to fsesolve call in fmmesolve (#2225). Removals; --------. - Remove qutip.control and replace with qutip_qtrl. (#2116); - Deleted _solve in countstat.py and used _data.solve. (#2120 by Yuji Tamakoshi); - Deprecate three_level_atom (#2221); - Deprecate orbital (#2223). Documentation; -------------. - Add a guide on Superoperators, Pauli Basis and Channel Contraction. (#1984 by christian512); - Added information on sec_cutoff to the documentation (#2136 by Gerardo Jose Suarez); - Added inherited members to API doc of MESolver, SMESolver, SSESolver, NonMarkovianMCSolver (#2167 by Cristian Emiliano Godinez Ramirez); - Corrected grammar in Bloch-Redfield master equation documentation (#2174 by Andrey Rakhubovsky). Miscellaneous; -------------. - Update scipy version requirement to 1.5+ (#1982 by Pieter Eendebak); - Added __all__ to qutip/measurements.py and qutip/core/semidefinite.py (#2103 by Rushiraj Gadhvi); - Restore towncrier check (#2105); - qutip.ipynbtools.version_table() can now be called without Cython installed (#2110 by Rushiraj Gadhvi); - Moved HTMLProgressBar from qutip/ipynbtools.py to qutip/ui/progressbar.py (#2112 by Harsh Khilawala); - Added new argument bc_type to take boundary conditions when creating QobjEvo (#2114 by Avatar Srinidhi P V ); - Remove Windows build warning suppression. (#2119); - Optimize dispatcher by dispatching on positional only args. (#2135); - Clean semidefinite (#2138); - Migrate `transfertensor.py` to solver (#2142); - Add a test for progress_bar (#2150); - Enable cython 3 (#2151",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:33407,Modifiability,flexible,flexible,33407,"/semidefinite.py (#2103 by Rushiraj Gadhvi); - Restore towncrier check (#2105); - qutip.ipynbtools.version_table() can now be called without Cython installed (#2110 by Rushiraj Gadhvi); - Moved HTMLProgressBar from qutip/ipynbtools.py to qutip/ui/progressbar.py (#2112 by Harsh Khilawala); - Added new argument bc_type to take boundary conditions when creating QobjEvo (#2114 by Avatar Srinidhi P V ); - Remove Windows build warning suppression. (#2119); - Optimize dispatcher by dispatching on positional only args. (#2135); - Clean semidefinite (#2138); - Migrate `transfertensor.py` to solver (#2142); - Add a test for progress_bar (#2150); - Enable cython 3 (#2151); - Added tests for visualization.py (#2192 by Yuji Tamakoshi); - Sorted arguments of sphereplot so that the order is similar to those of plot_spin_distribution (#2219 by Yuji Tamakoshi). Version 5.0.0a1 (February 7, 2023); ++++++++++++++++++++++++++++++++++. QuTiP 5 is a redesign of many of the core components of QuTiP (``Qobj``,; ``QobjEvo``, solvers) to make them more consistent and more flexible. ``Qobj`` may now be stored in either sparse or dense representations,; and the two may be mixed sensibly as needed. ``QobjEvo`` is now used; consistently throughout QuTiP, and the implementation has been; substantially cleaned up. A new ``Coefficient`` class is used to; represent the time-dependent factors inside ``QobjEvo``. The solvers have been rewritten to work well with the new data layer; and the concept of ``Integrators`` which solve ODEs has been introduced.; In future, new data layers may provide their own ``Integrators``; specialized to their representation of the underlying data. Much of the user-facing API of QuTiP remains familiar, but there have; had to be many small breaking changes. If we can make changes to; easy migrating code from QuTiP 4 to QuTiP 5, please let us know. Any extensive list of changes follows. Contributors; ------------. QuTiP 5 has been a large effort by many people over the last",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:33909,Modifiability,layers,layers,33909," Add a test for progress_bar (#2150); - Enable cython 3 (#2151); - Added tests for visualization.py (#2192 by Yuji Tamakoshi); - Sorted arguments of sphereplot so that the order is similar to those of plot_spin_distribution (#2219 by Yuji Tamakoshi). Version 5.0.0a1 (February 7, 2023); ++++++++++++++++++++++++++++++++++. QuTiP 5 is a redesign of many of the core components of QuTiP (``Qobj``,; ``QobjEvo``, solvers) to make them more consistent and more flexible. ``Qobj`` may now be stored in either sparse or dense representations,; and the two may be mixed sensibly as needed. ``QobjEvo`` is now used; consistently throughout QuTiP, and the implementation has been; substantially cleaned up. A new ``Coefficient`` class is used to; represent the time-dependent factors inside ``QobjEvo``. The solvers have been rewritten to work well with the new data layer; and the concept of ``Integrators`` which solve ODEs has been introduced.; In future, new data layers may provide their own ``Integrators``; specialized to their representation of the underlying data. Much of the user-facing API of QuTiP remains familiar, but there have; had to be many small breaking changes. If we can make changes to; easy migrating code from QuTiP 4 to QuTiP 5, please let us know. Any extensive list of changes follows. Contributors; ------------. QuTiP 5 has been a large effort by many people over the last three years. In particular:. - Jake Lishman led the implementation of the new data layer and coefficients.; - Eric Gigure led the implementation of the new QobjEvo interface and solvers.; - Boxi Li led the updating of QuTiP's QIP support and the creation of ``qutip_qip``. Other members of the QuTiP Admin team have been heavily involved in reviewing,; testing and designing QuTiP 5:. - Alexander Pitchford; - Asier Galicia; - Nathan Shammah; - Shahnawaz Ahmed; - Neill Lambert; - Simon Cross. Two Google Summer of Code contributors updated the tutorials and benchmarks to; QuTiP 5:. - Christian Staufenbi",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:35145,Modifiability,layers,layers,35145,"iP 4 to QuTiP 5, please let us know. Any extensive list of changes follows. Contributors; ------------. QuTiP 5 has been a large effort by many people over the last three years. In particular:. - Jake Lishman led the implementation of the new data layer and coefficients.; - Eric Gigure led the implementation of the new QobjEvo interface and solvers.; - Boxi Li led the updating of QuTiP's QIP support and the creation of ``qutip_qip``. Other members of the QuTiP Admin team have been heavily involved in reviewing,; testing and designing QuTiP 5:. - Alexander Pitchford; - Asier Galicia; - Nathan Shammah; - Shahnawaz Ahmed; - Neill Lambert; - Simon Cross. Two Google Summer of Code contributors updated the tutorials and benchmarks to; QuTiP 5:. - Christian Staufenbiel updated many of the tutorials (`<https://github.com/qutip/qutip-tutorials/>`).; - Xavier Sproken update the benchmarks (`<https://github.com/qutip/qutip-benchmark/>`). Four experimental data layers backends were written either as part of Google Summer; of Code or as separate projects. While these are still alpha quality, the helped; significantly to test the data layer API:. - ``qutip-tensorflow``: a TensorFlow backend by Asier Galicia (`<https://github.com/qutip/qutip-tensorflow>`); - ``qutip-cupy``: a CuPy GPU backend by Felipe Bivort Haiek (`<https://github.com/qutip/qutip-cupy/>`)`; - ``qutip-tensornetwork``: a TensorNetwork backend by Asier Galicia (`<https://github.com/qutip/qutip-tensornetwork>`); - ``qutip-jax``: a JAX backend by Eric Gigure (`<https://github.com/qutip/qutip-jax/>`). We have also had many other contributors, whose specific contributions are; detailed below:. - Pieter Eendebak (updated the required SciPy to 1.4+, `#1982 <https://github.com/qutip/qutip/pull/1982>`).; - Pieter Eendebak (reduced import times by setting logger names, `#1981 <https://github.com/qutip/qutip/pull/1981>`); - Xavier Sproken (included C header files in the source distribution, `#1971 <https://github.com/qutip",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:37503,Modifiability,flexible,flexible,37503,"tian Staufenbiel (allowed the ``bloch_redfield_tensor`` function to accept strings and callables for `a_ops`, `#1951 <https://github.com/qutip/qutip/pull/1951>`); - Henrique Silvro (allowed ``qutip_qip`` to be imported as ``qutip.qip``, `#1920 <https://github.com/qutip/qutip/pull/1920>`); - Florian Hopfmueller (added a vastly improved implementations of ``process_fidelity`` and ``average_gate_fidelity``, `#1712 <https://github.com/qutip/qutip/pull/1712>`, `#1748 <https://github.com/qutip/qutip/pull/1748>`, `#1788 <https://github.com/qutip/qutip/pull/1788>`); - Felipe Bivort Haiek (fixed inaccuracy in docstring of the dense implementation of negation, `#1608 <https://github.com/qutip/qutip/pull/1608/>`); - Rajath Shetty (added support for specifying colors for individual points, vectors and states display by `qutip.Bloch`, `#1335 <https://github.com/qutip/qutip/pull/1335>`). Qobj changes; ------------. Previously ``Qobj`` data was stored in a SciPy-like sparse matrix. Now the; representation is flexible. Implementations for dense and sparse formats are; included in QuTiP and custom implementations are possible. QuTiP's performance; on dense states and operators is significantly improved as a result. Some highlights:. - The data is still acessible via the ``.data`` attribute, but is now an; instance of the underlying data type instead of a SciPy-like sparse matrix.; The operations available in ``qutip.core.data`` may be used on ``.data``,; regardless of the data type.; - ``Qobj`` with different data types may be mixed in arithmetic and other; operations. A sensible output type will be automatically determined.; - The new ``.to(...)`` method may be used to convert a ``Qobj`` from one data type; to another. E.g. ``.to(""dense"")`` will convert to the dense representation and; ``.to(""csr"")`` will convert to the sparse type.; - Many ``Qobj`` methods and methods that create ``Qobj`` now accepted a ``dtype``; parameter that allows the data type of the returned ``Qobj`` to spe",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:39150,Modifiability,extend,extended,39150,"will be automatically determined.; - The new ``.to(...)`` method may be used to convert a ``Qobj`` from one data type; to another. E.g. ``.to(""dense"")`` will convert to the dense representation and; ``.to(""csr"")`` will convert to the sparse type.; - Many ``Qobj`` methods and methods that create ``Qobj`` now accepted a ``dtype``; parameter that allows the data type of the returned ``Qobj`` to specified.; - The new ``&`` operator may be used to obtain the tensor product.; - The new ``@`` operator may be used to obtain the matrix / operator product.; ``bar @ ket`` returns a scalar.; - The new ``.contract()`` method will collapse 1D subspaces of the dimensions of; the ``Qobj``.; - The new ``.logm()`` method returns the matrix logarithm of an operator.; - The methods ``.set_data``, ``.get_data``, ``.extract_state``, ``.eliminate_states``,; ``.evaluate`` and ``.check_isunitary`` have been removed. QobjEvo changes; ---------------. The ``QobjEvo`` type for storing time-dependent quantum objects has been; significantly expanded, standardized and extended. The time-dependent; coefficients are now represented using a new ``Coefficient`` type that; may be independently created and manipulated if required. Some highlights:. - The ``.compile()`` method has been removed. Coefficients specified as; strings are automatically compiled if possible and the compilation is; cached across different Python runs and instances.; - Mixing coefficient types within a single ``Qobj`` is now supported.; - Many new attributes were added to ``QobjEvo`` for convenience. Examples; include ``.dims``, ``.shape``, ``.superrep`` and ``.isconstant``.; - Many old attributes such as ``.cte``, ``.use_cython``, ``.type``, ``.const``,; and ``.coeff_file`` were removed.; - A new ``Spline`` coefficient supports spline interpolations of different; orders. The old ``Cubic_Spline`` coefficient has been removed.; - The new ``.arguments(...)`` method allows additional arguments to the; underlying coefficient function",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:51106,Modifiability,config,config,51106,"It contained the old sparse matrix representation and is replaced by the new implementation in ``qutip.data``.; - ``qutip.piqs`` functions are no longer available from the ``qutip`` namespace. They are accessible from ``qutip.piqs`` instead. Miscellaneous; -------------. - Support has been added for 64-bit integer sparse matrix indices, allowing; sparse matrices with up to 2**63 rows and columns. This support needs to; be enabled at compilation time by calling ``setup.py`` and passing; ``--with-idxint-64``. Feature removals; ----------------. - Support for OpenMP has been removed. If there is enough demand and a good plan for how to organize it, OpenMP support may return in a future QuTiP release.; - The ``qutip.parfor`` function has been removed. Use ``qutip.parallel_map`` instead.; - ``qutip.graph`` has been removed and replaced by SciPy's graph functions.; - ``qutip.topology`` has been removed. It contained only one function ``berry_curvature``.; - The ``~/.qutip/qutiprc`` config file is no longer supported. It contained settings for the OpenMP support. QuTiP 4.7.5 (2024-01-29); ========================. Patch release for QuTiP 4.7. It adds support for SciPy 1.12. Bug Fixes; ---------. - Remove use of scipy.<numpy-func> in parallel.py, incompatible with scipy==1.12 (#2305 by Evan McKinney). QuTiP 4.7.4 (2024-01-15); ========================. Bug Fixes; ---------. - Adapt to deprecation from matplotlib 3.8 (#2243, reported by Bogdan Reznychenko); - Fix name of temp files for removal after use. (#2251, reported by Qile Su); - Avoid integer overflow in Qobj creation. (#2252, reported by KianHwee-Lim); - Ignore DeprecationWarning from pyximport (#2287); - Add partial support and tests for python 3.12. (#2294). Miscellaneous; -------------. - Rework `choi_to_kraus`, making it rely on an eigenstates solver that can choose `eigh` if the Choi matrix is Hermitian, as it is more numerically stable. (#2276, by Bogdan Reznychenko); - Rework `kraus_to_choi`, making it faster (",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:53893,Modifiability,adapt,adaptive,53893,"and passing through of sc_ops to photocurrent solver. (#2081 by Bogdan Reznychenko and Simon Cross); - Update calls to SciPy eigvalsh and eigsh to pass the range of eigenvalues to return using ``subset_by_index=``. (#2081 by Simon Cross); - Fixed bug where some matrices were wrongly found to be hermitian. (#2082 by AGaliciaMartinez). Miscellaneous; -------------; - Fixed typo in stochastic.py (#2049, by eltociear); - `ptrace` always return density matrix (#2185, issue by udevd); - `mesolve` can support mixed callable and Qobj for `e_ops` (#2184 issue by balopat). Version 4.7.1 (December 11, 2022); +++++++++++++++++++++++++++++++++. This is a bugfix release for QuTiP 4.7.X. In addition to the minor fixes; listed below, the release adds builds for Python 3.11 and support for; packaging 22.0. Features; --------; - Improve qutip import times by setting logger names explicitly. (#1980). Bug Fixes; ---------; - Change floquet_master_equation_rates(...) to use an adaptive number of time steps scaled by the number of sidebands, kmax. (#1961); - Change fidelity(A, B) to use the reduced fidelity formula for pure states which is more numerically efficient and accurate. (#1964); - Change ``brmesolve`` to raise an exception when ode integration is not successful. (#1965); - Backport fix for IPython helper Bloch._repr_svg_ from dev.major. Previously the print_figure function returned bytes, but since ipython/ipython#5452 (in 2014) it returns a Unicode string. This fix updates QuTiP's helper to match. (#1970); - Fix correlation for case where only the collapse operators are time dependent. (#1979); - Fix the hinton visualization method to plot the matrix instead of its transpose. (#2011); - Fix the hinton visualization method to take into account all the matrix coefficients to set the squares scale, instead of only the diagonal coefficients. (#2012); - Fix parsing of package versions in setup.py to support packaging 22.0. (#2037); - Add back .qu suffix to objects saved with qsave ",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:56405,Modifiability,flexible,flexible,56405,"Update Floquet Markov solver docs. (#1958); - Update the roadmap and ideas to show completed work as of August 2022. (#1967). Miscellaneous; -------------; - Return TypeError instead of Exception for type error in sesolve argument. (#1924); - Add towncrier draft build of changelog to CI tests. (#1946); - Add Python 3.11 to builds. (#2041); - Simplify version parsing by using packaging.version.Version. (#2043); - Update builds to use cibuildwheel 2.11, and to build with manylinux2014 on Python 3.8 and 3.9, since numpy and SciPy no longer support manylinux2010 on those versions of Python. (#2047). Version 4.7.0 (April 13, 2022); ++++++++++++++++++++++++++++++. This release sees the addition of two new solvers -- ``qutip.krylovsolve`` based on the Krylov subspace approximation and ``qutip.nonmarkov.heom`` that reimplements the BoFiN HEOM solver. Bloch sphere rendering gained support for drawing arcs and lines on the sphere, and for setting the transparency of rendered points and vectors, Hinton plots gained support for specifying a coloring style, and matrix histograms gained better default colors and more flexible styling options. Other significant improvements include better scaling of the Floquet solver, support for passing ``Path`` objects when saving and loading files, support for passing callable functions as ``e_ops`` to ``mesolve`` and ``sesolve``, and faster state number enumeration and Husimi Q functions. Import bugfixes include some bugs affecting plotting with matplotlib 3.5 and fixing support for qutrits (and other non-qubit) quantum circuits. The many other small improvements, bug fixes, documentation enhancements, and behind the scenese development changes are included in the list below. QuTiP 4.7.X will be the last series of releases for QuTiP 4. Patch releases will continue for the 4.7.X series but the main development effort will move to QuTiP 5. The many, many contributors who filed issues, submitted or reviewed pull requests, and improved the docume",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:56924,Modifiability,enhance,enhancements,56924,"++++++++++++. This release sees the addition of two new solvers -- ``qutip.krylovsolve`` based on the Krylov subspace approximation and ``qutip.nonmarkov.heom`` that reimplements the BoFiN HEOM solver. Bloch sphere rendering gained support for drawing arcs and lines on the sphere, and for setting the transparency of rendered points and vectors, Hinton plots gained support for specifying a coloring style, and matrix histograms gained better default colors and more flexible styling options. Other significant improvements include better scaling of the Floquet solver, support for passing ``Path`` objects when saving and loading files, support for passing callable functions as ``e_ops`` to ``mesolve`` and ``sesolve``, and faster state number enumeration and Husimi Q functions. Import bugfixes include some bugs affecting plotting with matplotlib 3.5 and fixing support for qutrits (and other non-qubit) quantum circuits. The many other small improvements, bug fixes, documentation enhancements, and behind the scenese development changes are included in the list below. QuTiP 4.7.X will be the last series of releases for QuTiP 4. Patch releases will continue for the 4.7.X series but the main development effort will move to QuTiP 5. The many, many contributors who filed issues, submitted or reviewed pull requests, and improved the documentation for this release are listed next to their contributions below. Thank you to all of you. Improvements; ------------; - **MAJOR** Added krylovsolve as a new solver based on krylov subspace approximation. (`#1739 <https://github.com/qutip/qutip/pull/1739>`_ by Emiliano Fortes); - **MAJOR** Imported BoFiN HEOM (https://github.com/tehruhn/bofin/) into QuTiP and replaced the HEOM solver with a compatibility wrapper around BoFiN bosonic solver. (`#1601 <https://github.com/qutip/qutip/pull/1601>`_, `#1726 <https://github.com/qutip/qutip/pull/1726>`_, and `#1724 <https://github.com/qutip/qutip/pull/1724>`_ by Simon Cross, Tarun Raheja and Neill La",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:65661,Modifiability,config,configuration,65661,"- Corrected typo in the states and operators guide. (`#1567 <https://github.com/qutip/qutip/pull/1567>`_ by Laurent Ajdnik); - Converted http links to https. (`#1555 <https://github.com/qutip/qutip/pull/1555>`_ by Jake Lishamn). Developer Changes; -----------------; - Add GitHub actions test run on windows-latest. (`#1853 <https://github.com/qutip/qutip/pull/1853>`_ and `#1855 <https://github.com/qutip/qutip/pull/1855>`_ by Simon Cross); - Bumped the version of pillow used to build documentation from 9.0.0 to 9.0.1. (`#1835 <https://github.com/qutip/qutip/pull/1835>`_ by dependabot); - Migrated the ``qutip.superop_reps`` tests to pytest. (`#1825 <https://github.com/qutip/qutip/pull/1825>`_ by Felipe Bivort Haiek); - Migrated the ``qutip.steadystates`` tests to pytest. (`#1679 <https://github.com/qutip/qutip/pull/1679>`_ by Eric Gigure); - Changed the README.md CI badge to the GitHub Actions badge. (`#1581 <https://github.com/qutip/qutip/pull/1581>`_ by Jake Lishman); - Updated CodeClimate configuration to treat our Python source files as Python 3. (`#1577 <https://github.com/qutip/qutip/pull/1577>`_ by Jake Lishman); - Reduced cyclomatic complexity in ``qutip._mkl``. (`#1576 <https://github.com/qutip/qutip/pull/1576>`_ by Jake Lishman); - Fixed PEP8 warnings in ``qutip.control``, ``qutip.mcsolve``, ``qutip.random_objects``, and ``qutip.stochastic``. (`#1575 <https://github.com/qutip/qutip/pull/1575>`_ by Jake Lishman); - Bumped the version of urllib3 used to build documentation from 1.26.4 to 1.26.5. (`#1563 <https://github.com/qutip/qutip/pull/1563>`_ by dependabot); - Moved tests to GitHub Actions. (`#1551 <https://github.com/qutip/qutip/pull/1551>`_ by Jake Lishman); - The GitHub contributing guidelines were re-added and updated to point to the more complete guidelines in the documentation. (`#1549 <https://github.com/qutip/qutip/pull/1549>`_ by Jake Lishman); - The release documentation was reworked after the initial 4.6.1 to match the actual release process. (",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:71034,Modifiability,config,configuration,71034,"ze_pulse support for sparse eigenvector decomposition with the Qobj oper_dtype (the Qobj oper_dtype is the default for large systems). (`#1621 <https://github.com/qutip/qutip/pull/1621>`_ by Simon Cross); - Removed qutip.control.optimize_pulse support for scipy.sparse.csr_matrix and generic ndarray-like matrices. Support for these was non-functional. (`#1621 <https://github.com/qutip/qutip/pull/1621>`_ by Simon Cross); - Fixed errors in the calculation of the Husimi spin_q_function and spin_wigner functions and added tests for them. (`#1632 <https://github.com/qutip/qutip/pull/1632>`_ by Mark Johnson); - Fixed setting of OpenMP compilation flag on Linux. Previously when compiling the OpenMP functions were compiled without parallelization. (`#1693 <https://github.com/qutip/qutip/pull/1693>`_ by Eric Gigure); - Fixed tracking the state of the Bloch sphere figure and axes to prevent exceptions during rendering. (`#1619 <https://github.com/qutip/qutip/pull/1619>`_ by Simon Cross); - Fixed compatibility with numpy configuration in numpy's 1.22.0 release. (`#1752 <https://github.com/qutip/qutip/pull/1752>`_ by Matthew Treinish); - Added dims checks for e_ops passed to solvers to prevent hanging the calling process when e_ops of the wrong dimensions were passed. (`#1778 <https://github.com/qutip/qutip/pull/1778>`_ by Eric Gigure); - Added a check in Qobj constructor that the respective members of data.shape cannot be larger than what the corresponding dims could contain to prevent a segmentation fault caused by inconsistencies between dims and shapes. (`#1783 <https://github.com/qutip/qutip/pull/1783>`_, `#1785 <https://github.com/qutip/qutip/pull/1785>`_, `#1784 <https://github.com/qutip/qutip/pull/1784>`_ by Lajos Palanki & Eric Gigure). Documentation Improvements; --------------------------; - Added docs for the num_cbits parameter of the QubitCircuit class. (`#1652 <https://github.com/qutip/qutip/pull/1652>`_ by Jon Crall); - Fixed the parameters in the call to fses",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:80073,Modifiability,config,configuration,80073," runs and make pytest treat warnings as errors (by **Jake Lishman**); - Add Simon Cross as author (by **Simon Cross**). Version 4.6.0 (April 11, 2021); ++++++++++++++++++++++++++++++. This release brings improvements for qubit circuits, including a pulse scheduler, measurement statistics, reading/writing OpenQASM and optimisations in the circuit simulations. This is the first release to have full binary wheel releases on pip; you can now do ``pip install qutip`` on almost any machine to get a correct version of the package without needing any compilers set up.; The support for Numpy 1.20 that was first added in QuTiP 4.5.3 is present in this version as well, and the same build considerations mentioned there apply here too.; If building using the now-supported PEP 517 mechanisms (e.g. ``python -mbuild /path/to/qutip``), all build dependencies will be correctly satisfied. Improvements; ------------; - **MAJOR** Add saving, loading and resetting functionality to ``qutip.settings`` for easy re-configuration. (by **Eric Gigure**); - **MAJOR** Add a quantum gate scheduler in ``qutip.qip.scheduler``, to help parallelise the operations of quantum gates. This supports two scheduling modes: as late as possible, and as soon as possible. (by **Boxi Li**); - **MAJOR** Improved qubit circuit simulators, including OpenQASM support and performance optimisations. (by **Sidhant Saraogi**); - **MAJOR** Add tools for quantum measurements and their statistics. (by **Simon Cross** and **Sidhant Saraogi**); - Add support for Numpy 1.20. QuTiP should be compiled against a version of Numpy ``>= 1.16.6`` and ``< 1.20`` (note: does _not_ include 1.20 itself), but such an installation is compatible with any modern version of Numpy. Source installations from ``pip`` understand this constraint.; - Improve the error message when circuit plotting fails. (by **Boxi Li**); - Add support for parsing M1 Mac hardware information. (by **Xiaoliang Wu**); - Add more single-qubit gates and controlled gates",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:88222,Modifiability,refactor,refactored,88222,"-----; - **MAJOR FEATURE**: Added `qip.noise`, a module with pulse level description of quantum circuits allowing to model various types of noise and devices (by **Boxi Li**). - **MAJOR FEATURE**: Added `qip.lattice`, a module for the study of lattice dynamics in 1D (by **Saumya Biswas**). - Migrated testing from Nose to PyTest (by **Tarun Raheja**). - Optimized testing for PyTest and removed duplicated test runners (by **Jake Lishman**). - Deprecated importing `qip` functions to the qutip namespace (by **Boxi Li**). - Added the possibility to define non-square superoperators relevant for quantum circuits (by **Arne Grimsmo** and **Josh Combes**). - Implicit tensor product for `qeye`, `qzero` and `basis` (by **Jake Lishman**). - QObjEvo no longer requires Cython for string coefficient (by **Eric Gigure**). - Added marked tests for faster tests in `testing.run()` and made faster OpenMP benchmarking in CI (by **Eric Gigure**). - Added entropy and purity for Dicke density matrices, refactored into more general dicke_trace (by **Nathan Shammah**). - Added option for specifying resolution in Bloch.save function (by **Tarun Raheja**). - Added information related to the value of hbar in `wigner` and `continuous_variables` (by **Nicolas Quesada**). - Updated requirements for `scipy 1.4` (by **Eric Gigure**). - Added previous lead developers to the qutip.about() message (by **Nathan Shammah**). - Added improvements to `Qobj` introducing the `inv` method and making the partial trace, `ptrace`, faster, keeping both sparse and dense methods (by **Eric Gigure**). - Allowed general callable objects to define a time-dependent Hamiltonian (by **Eric Gigure**). - Added feature so that `QobjEvo` no longer requires Cython for string coefficients (by **Eric Gigure**). - Updated authors list on Github and added `my binder` link (by **Nathan Shammah**). Bug Fixes; ---------. - Fixed `PolyDataMapper` construction for `Bloch3d` (by **Sam Griffiths**). - Fixed error checking for null m",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:92271,Modifiability,variab,variable,92271,"oved mutable default values in mesolve/sesolve (by **Michael Goerz**). - Fixed simdiag bug (Thank **Croydon-Brixton** for reporting). - Better support of constant QobjEvo (by **Boxi Li**). - Fixed potential cyclic import in the control module (by **Alexander Pitchford**). Version 4.4.0 (July 03, 2019); +++++++++++++++++++++++++++++. Improvements; ------------. - **MAJOR FEATURE**: Added methods and techniques to the stochastic solvers (by **Eric Gigure**) which allows to use a much broader set of solvers and much more efficiently. - **MAJOR FEATURE**: Optimization of the montecarlo solver (by **Eric Gigure**). Computation are faster in many cases. Collapse information available to time dependant information. - Added the QObjEvo class and methods (by **Eric Gigure**), which is used behind the scenes by the dynamical solvers, making the code more efficient and tidier. More built-in function available to string coefficients. - The coefficients can be made from interpolated array with variable timesteps and can obtain state information more easily. Time-dependant collapse operator can have multiple terms. - New wigner_transform and plot_wigner_sphere function. (by **Nithin Ramu**). - ptrace is faster and work on bigger systems, from 15 Qbits to 30 Qbits. - QIP module: added the possibility for user-defined gates, added the possibility to remove or add gates in any point of an already built circuit, added the molmer_sorensen gate, and fixed some bugs (by **Boxi Li**). - Added the quantum Hellinger distance to qutip.metrics (by **Wojciech Rzadkowski**). - Implemented possibility of choosing a random seed (by **Marek Marekyggdrasil**). - Added a code of conduct to Github. Bug Fixes; ---------. - Fixed bug that made QuTiP incompatible with SciPy 1.3. Version 4.3.0 (July 14, 2018); +++++++++++++++++++++++++++++. Improvements; ------------. - **MAJOR FEATURE**: Added the Permutational Invariant Quantum Solver (PIQS) module (by **Nathan Shammah** and **Shahnawaz Ahmed**) whi",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:93590,Modifiability,config,configuration,93590,"bits to 30 Qbits. - QIP module: added the possibility for user-defined gates, added the possibility to remove or add gates in any point of an already built circuit, added the molmer_sorensen gate, and fixed some bugs (by **Boxi Li**). - Added the quantum Hellinger distance to qutip.metrics (by **Wojciech Rzadkowski**). - Implemented possibility of choosing a random seed (by **Marek Marekyggdrasil**). - Added a code of conduct to Github. Bug Fixes; ---------. - Fixed bug that made QuTiP incompatible with SciPy 1.3. Version 4.3.0 (July 14, 2018); +++++++++++++++++++++++++++++. Improvements; ------------. - **MAJOR FEATURE**: Added the Permutational Invariant Quantum Solver (PIQS) module (by **Nathan Shammah** and **Shahnawaz Ahmed**) which allows the simluation of large TLSs ensembles including collective and local Lindblad dissipation. Applications range from superradiance to spin squeezing. - **MAJOR FEATURE**: Added a photon scattering module (by **Ben Bartlett**) which can be used to study scattering in arbitrary driven systems coupled to some configuration of output waveguides. - Cubic_Spline functions as time-dependent arguments for the collapse operators in mesolve are now allowed. - Added a faster version of bloch_redfield_tensor, using components from the time-dependent version. About 3x+ faster for secular tensors, and 10x+ faster for non-secular tensors. - Computing Q.overlap() [inner product] is now ~30x faster. - Added projector method to Qobj class. - Added fast projector method, ``Q.proj()``. - Computing matrix elements, ``Q.matrix_element`` is now ~10x faster. - Computing expectation values for ket vectors using ``expect`` is now ~10x faster. - ``Q.tr()`` is now faster for small Hilbert space dimensions. - Unitary operator evolution added to sesolve. - Use OPENMP for tidyup if installed. Bug Fixes; ---------. - Fixed bug that stopped simdiag working for python 3. - Fixed semidefinite cvxpy Variable and Parameter. - Fixed iterative lu solve atol keyword",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:97708,Modifiability,enhance,enhancements,97708,"lication now parallel using OPENMP. - Automatic tuning of OPENMP threading threshold. - Partial trace function is now up to 100x+ faster. - Hermitian verification now up to 100x+ faster. - Internal Qobj objects now created up to 60x faster. - Inplace conversion from COO -> CSR sparse formats (e.g. Memory efficiency improvement.). - Faster reverse Cuthill-Mckee and sparse one and inf norms. Bug Fixes; ---------. - Cleanup of temp. Cython files now more robust and working under Windows. Version 4.0.2 (January 5, 2017); +++++++++++++++++++++++++++++++. Bug Fixes; ---------; - td files no longer left behind by correlation tests; - Various fast sparse fixes. Version 4.0.0 (December 22, 2016); +++++++++++++++++++++++++++++++++. Improvements; ------------; *Core libraries*. - **MAJOR FEATURE**: Fast sparse: New subclass of csr_matrix added that overrides commonly used methods to avoid certain checks that incurr execution cost. All Qobj.data now fast_csr_matrix; - HEOM performance enhancements; - spmv now faster; - mcsolve codegen further optimised. *Control modules*. - Time dependent drift (through list of pwc dynamics generators); - memory optimisation options provided for control.dynamics. Bug Fixes; ---------. - recompilation of pyx files on first import removed; - tau array in control.pulseoptim funcs now works. Version 3.2.0 (Never officially released); +++++++++++++++++++++++++++++++++++++++++. New Features; ------------. *Core libraries*. - **MAJOR FEATURE**: Non-Markovian solvers: Hierarchy (**Added by Neill Lambert**), Memory-Cascade, and Transfer-Tensor methods.; - **MAJOR FEATURE**: Default steady state solver now up to 100x faster using the Intel Pardiso library under the Anaconda and Intel Python distributions.; - The default Wigner function now uses a Clenshaw summation algorithm to evaluate a polynomial series that is applicable for any number of exciations (previous limitation was ~50 quanta), and is ~3x faster than before. (**Added by Denis Vasilyev**); - ",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:100345,Modifiability,config,configuration,100345,"isation.; See tutorial notebook for full information. Improvements; ------------; *Core libraries*. - Two-time correlation functions can now be calculated for fully time-dependent Hamiltonians and collapse operators. (**Added by Kevin Fischer**); - The code for the inverse-power method for the steady state solver has been simplified.; - Bloch-Redfield tensor creation is now up to an order of magnitude faster. (**Added by Johannes Feist**); - Q.transform now works properly for arrays directly from sp_eigs (or eig).; - Q.groundstate now checks for degeneracy.; - Added ``sinm`` and ``cosm`` methods to the Qobj class.; - Added ``charge`` and ``tunneling`` operators.; - Time-dependent Cython code is now easier to read and debug. *Control modules*. - The internal state / quantum operator data type can now be either Qobj or ndarray; Previous only ndarray was possible. This now opens up possibility of using Qobj methods in fidelity calculations; The attributes and functions that return these operators are now preceded by an underscore, to indicate that the data type could change depending on the configuration options.; In most cases these functions were for internal processing only anyway, and should have been 'private'.; Accessors to the properties that could be useful outside of the library have been added. These always return Qobj. If the internal operator data type is not Qobj, then there could be signicant overhead in the conversion, and so this should be avoided during pulse optimisation.; If custom sub-classes are developed that use Qobj properties and methods (e.g. partial trace), then it is very likely that it will be more efficient to set the internal data type to Qobj.; The internal operator data will be chosen automatically based on the size and sparsity of the dynamics generator. It can be forced by setting ``dynamics.oper_dtype = <type>``; Note this can be done by passing ``dyn_params={'oper_dtype':<type>}`` in any of the pulseoptim functions. Some other prope",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:103328,Modifiability,variab,variables,103328,"propagator``; - ``compute_diff_prop`` now ``_compute_diff_prop``; - ``compute_prop_grad`` now ``_compute_prop_grad``. - tslotcomp functions. - ``get_timeslot_for_fidelity_calc`` now ``_get_timeslot_for_fidelity_calc``. *Miscellaneous*. - QuTiP Travis CI tests now use the Anaconda distribution.; - The ``about`` box and ipynb ``version_table`` now display addition system information.; - Updated Cython cleanup to remove depreciation warning in sysconfig.; - Updated ipynb_parallel to look for ``ipyparallel`` module in V4 of the notebooks. Bug Fixes; ---------; - Fixes for countstat and psuedo-inverse functions; - Fixed Qobj division tests on 32-bit systems.; - Removed extra call to Python in time-dependent Cython code.; - Fixed issue with repeated Bloch sphere saving.; - Fixed T_0 triplet state not normalized properly. (**Fixed by Eric Hontz**); - Simplified compiler flags (support for ARM systems).; - Fixed a decoding error in ``qload``.; - Fixed issue using complex.h math and np.kind_t variables.; - Corrected output states mismatch for ``ntraj=1`` in the mcf90 solver.; - Qobj data is now copied by default to avoid a bug in multiplication. (**Fixed by Richard Brierley**); - Fixed bug overwriting ``hardware_info`` in ``__init__``. (**Fixed by Johannes Feist**); - Restored ability to explicity set Q.isherm, Q.type, and Q.superrep.; - Fixed integer depreciation warnings from NumPy.; - Qobj * (dense vec) would result in a recursive loop.; - Fixed args=None -> args={} in correlation functions to be compatible with mesolve.; - Fixed depreciation warnings in mcsolve.; - Fixed neagtive only real parts in ``rand_ket``.; - Fixed a complicated list-cast-map-list antipattern in super operator reps. (**Fixed by Stefan Krastanov**); - Fixed incorrect ``isherm`` for ``sigmam`` spin operator.; - Fixed the dims when using ``final_state_output`` in ``mesolve`` and ``sesolve``. Version 3.1.0 (January 1, 2015); +++++++++++++++++++++++++++++++. New Features; ------------. - **MAJOR FEATURE*",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:104846,Modifiability,enhance,enhanced,104846,"e.; - Fixed depreciation warnings in mcsolve.; - Fixed neagtive only real parts in ``rand_ket``.; - Fixed a complicated list-cast-map-list antipattern in super operator reps. (**Fixed by Stefan Krastanov**); - Fixed incorrect ``isherm`` for ``sigmam`` spin operator.; - Fixed the dims when using ``final_state_output`` in ``mesolve`` and ``sesolve``. Version 3.1.0 (January 1, 2015); +++++++++++++++++++++++++++++++. New Features; ------------. - **MAJOR FEATURE**: New module for quantum control (qutip.control).; - **NAMESPACE CHANGE**: QuTiP no longer exports symbols from NumPy and matplotlib, so those modules must now be explicitly imported when required.; - New module for counting statistics.; - Stochastic solvers now run trajectories in parallel.; - New superoperator and tensor manipulation functions; (super_tensor, composite, tensor_contract).; - New logging module for debugging (qutip.logging).; - New user-available API for parallelization (parallel_map).; - New enhanced (optional) text-based progressbar (qutip.ui.EnhancedTextProgressBar); - Faster Python based monte carlo solver (mcsolve).; - Support for progress bars in propagator function.; - Time-dependent Cython code now calls complex cmath functions.; - Random numbers seeds can now be reused for successive calls to mcsolve.; - The Bloch-Redfield master equation solver now supports optional Lindblad type collapse operators.; - Improved handling of ODE integration errors in mesolve.; - Improved correlation function module (for example, improved support for time-dependent problems).; - Improved parallelization of mcsolve (can now be interrupted easily, support for IPython.parallel, etc.); - Many performance improvements, and much internal code restructuring. Bug Fixes; ---------. - Cython build files for time-dependent string format now removed automatically.; - Fixed incorrect solution time from inverse-power method steady state solver.; - mcsolve now supports `Options(store_states=True)`; - Fixed bug in `hada",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:111512,Modifiability,variab,variable,111512,", and are available in; the module `qutip.solver`. - The ``squeez`` function has been renamed to ``squeeze``. - Better support for sparse matrices when calculating propagators using the; ``propagator`` function. - Improved Bloch sphere. - Restructured and improved the module ``qutip.sparse``, which now only; operates directly on sparse matrices (not on Qobj instances). - Improved and simplified implement of the ``tensor`` function. - Improved performance, major code cleanup (including namespace changes),; and numerous bug fixes. - Benchmark scripts improved and restructured. - QuTiP is now using continuous integration tests (TravisCI). Version 2.2.0 (March 01, 2013); ++++++++++++++++++++++++++++++. New Features; ------------. - **Added Support for Windows**. - New Bloch3d class for plotting 3D Bloch spheres using Mayavi. - Bloch sphere vectors now look like arrows. - Partial transpose function. - Continuos variable functions for calculating correlation and covariance; matrices, the Wigner covariance matrix and the logarithmic negativity for; for multimode fields in Fock basis. - The master-equation solver (mesolve) now accepts pre-constructed Liouvillian; terms, which makes it possible to solve master equations that are not on; the standard Lindblad form. - Optional Fortran Monte Carlo solver (mcsolve_f90) by Arne Grimsmo. - A module of tools for using QuTiP in IPython notebooks. - Increased performance of the steady state solver. - New Wigner colormap for highlighting negative values. - More graph styles to the visualization module. Bug Fixes; ---------. - Function based time-dependent Hamiltonians now keep the correct phase. - mcsolve no longer prints to the command line if ntraj=1. Version 2.1.0 (October 05, 2012); ++++++++++++++++++++++++++++++++. New Features; ------------. - New method for generating Wigner functions based on Laguerre polynomials. - coherent(), coherent_dm(), and thermal_dm() can now be expressed using analytic values. - Unittests now use nose",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:10170,Performance,perform,performance,10170,"167>`); - Andrey Rakhubovsky (Corrected grammar in Bloch-Redfield master equation documentation, `#2174 <https://github.com/qutip/qutip/pull/2174>`); - Rushiraj Gadhvi (qutip.ipynbtools.version_table() can now be called without Cython installed, `#2110 <https://github.com/qutip/qutip/pull/2110>`); - Harsh Khilawala (Moved HTMLProgressBar from qutip/ipynbtools.py to qutip/ui/progressbar.py, `#2112 <https://github.com/qutip/qutip/pull/2112>`); - Avatar Srinidhi P V (Added new argument bc_type to take boundary conditions when creating QobjEvo, `#2114 <https://github.com/qutip/qutip/pull/2114>`); - Andrey Rakhubovsky (Fix types in docstring of projection(), `#2363 <https://github.com/qutip/qutip/pull/2363>`). Qobj changes; ------------. Previously ``Qobj`` data was stored in a SciPy-like sparse matrix. Now the; representation is flexible. Implementations for dense and sparse formats are; included in QuTiP and custom implementations are possible. QuTiP's performance; on dense states and operators is significantly improved as a result. Some highlights:. - The data is still acessible via the ``.data`` attribute, but is now an; instance of the underlying data type instead of a SciPy-like sparse matrix.; The operations available in ``qutip.core.data`` may be used on ``.data``,; regardless of the data type.; - ``Qobj`` with different data types may be mixed in arithmetic and other; operations. A sensible output type will be automatically determined.; - The new ``.to(...)`` method may be used to convert a ``Qobj`` from one data type; to another. E.g. ``.to(""dense"")`` will convert to the dense representation and; ``.to(""csr"")`` will convert to the sparse type.; - Many ``Qobj`` methods and methods that create ``Qobj`` now accepted a ``dtype``; parameter that allows the data type of the returned ``Qobj`` to specified.; - The new ``&`` operator may be used to obtain the tensor product.; - The new ``@`` operator may be used to obtain the matrix / operator product.; ``bar @ ket`` re",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:12209,Performance,cache,cached,12209,"uct.; ``bar @ ket`` returns a scalar.; - The new ``.contract()`` method will collapse 1D subspaces of the dimensions of; the ``Qobj``.; - The new ``.logm()`` method returns the matrix logarithm of an operator.; - The methods ``.set_data``, ``.get_data``, ``.extract_state``, ``.eliminate_states``,; ``.evaluate`` and ``.check_isunitary`` have been removed.; - The property ``dtype`` return the representation of the data used.; - The new ``data_as`` allow to obtain the data as a common python formats:; numpy array, scipy sparse matrix, JAX Array, etc. QobjEvo changes; ---------------. The ``QobjEvo`` type for storing time-dependent quantum objects has been; significantly expanded, standardized and extended. The time-dependent; coefficients are now represented using a new ``Coefficient`` type that; may be independently created and manipulated if required. Some highlights:. - The ``.compile()`` method has been removed. Coefficients specified as; strings are automatically compiled if possible and the compilation is; cached across different Python runs and instances.; - Mixing coefficient types within a single ``Qobj`` is now supported.; - Many new attributes were added to ``QobjEvo`` for convenience. Examples; include ``.dims``, ``.shape``, ``.superrep`` and ``.isconstant``.; - Many old attributes such as ``.cte``, ``.use_cython``, ``.type``, ``.const``,; and ``.coeff_file`` were removed.; - A new ``Spline`` coefficient supports spline interpolations of different; orders. The old ``Cubic_Spline`` coefficient has been removed.; - The new ``.arguments(...)`` method allows additional arguments to the; underlying coefficient functions to be updated.; - The ``_step_func_coeff`` argument has been replaced by the ``order``; parameter. ``_step_func_coeff=False`` is equivalent to ``order=3``.; ``_step_func_coeff=True`` is equivalent to ``order=0``. Higher values; of ``order`` gives spline interpolations of higher orders.; - The spline type can take ``bc_type`` to control the boundar",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:24317,Performance,load,load,24317,"ed.; Use ``rand_dm(distribution=""hs"")`` and ``rand_dm(distribution=""ginibre"")``; instead.; - The function ``rand_ket_haar`` has been removed. Use; ``rand_ket(distribution=""haar"")`` instead.; - The measurement functions have had the ``target`` parameter for; expanding the measurement operator removed. Used ``expand_operator``; to expand the operator instead.; - ``qutip.Bloch`` now supports applying colours per-point, state or vector in; ``add_point``, ``add_states``, and ``add_vectors``.; - Dimensions use a class instead of layered lists.; - Allow measurement functions to support degenerate operators.; - Add ``qeye_like`` and ``qzero_like``.; - Added fermionic annihilation and creation operators. QuTiP settings; --------------. Previously ``qutip.settings`` was an ordinary module. Now ``qutip.settings`` is; an instance of a settings class. All the runtime modifiable settings for; core operations are in ``qutip.settings.core``. The other settings are not; modifiable at runtime. - Removed ``load``. ``reset`` and ``save`` functions.; - Removed ``.debug``, ``.fortran``, ``.openmp_thresh``.; - New ``.compile`` stores the compilation options for compiled coefficients.; - New ``.core[""rtol""]`` core option gives the default relative tolerance used by QuTiP.; - The absolute tolerance setting ``.atol`` has been moved to ``.core[""atol""]``. Visualization; -------------. - Added arguments to ``plot_wigner`` and ``plot_wigner_fock_distribution`` to specify parameters for ``wigner``.; - Removed ``Bloch3D``. The same functionality is provided by ``Bloch``.; - Added ``fig``, ``ax`` and ``cmap`` keyword arguments to all visualization functions.; - Most visualization functions now respect the ``colorblind_safe`` setting.; - Added new functions to create animations from a list of ``Qobj`` or directly from solver results with saved states. Package reorganization; ----------------------. - ``qutip.qip`` has been moved into its own package, qutip-qip. Once installed, qutip-qip is available",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:37630,Performance,perform,performance,37630," Silvro (allowed ``qutip_qip`` to be imported as ``qutip.qip``, `#1920 <https://github.com/qutip/qutip/pull/1920>`); - Florian Hopfmueller (added a vastly improved implementations of ``process_fidelity`` and ``average_gate_fidelity``, `#1712 <https://github.com/qutip/qutip/pull/1712>`, `#1748 <https://github.com/qutip/qutip/pull/1748>`, `#1788 <https://github.com/qutip/qutip/pull/1788>`); - Felipe Bivort Haiek (fixed inaccuracy in docstring of the dense implementation of negation, `#1608 <https://github.com/qutip/qutip/pull/1608/>`); - Rajath Shetty (added support for specifying colors for individual points, vectors and states display by `qutip.Bloch`, `#1335 <https://github.com/qutip/qutip/pull/1335>`). Qobj changes; ------------. Previously ``Qobj`` data was stored in a SciPy-like sparse matrix. Now the; representation is flexible. Implementations for dense and sparse formats are; included in QuTiP and custom implementations are possible. QuTiP's performance; on dense states and operators is significantly improved as a result. Some highlights:. - The data is still acessible via the ``.data`` attribute, but is now an; instance of the underlying data type instead of a SciPy-like sparse matrix.; The operations available in ``qutip.core.data`` may be used on ``.data``,; regardless of the data type.; - ``Qobj`` with different data types may be mixed in arithmetic and other; operations. A sensible output type will be automatically determined.; - The new ``.to(...)`` method may be used to convert a ``Qobj`` from one data type; to another. E.g. ``.to(""dense"")`` will convert to the dense representation and; ``.to(""csr"")`` will convert to the sparse type.; - Many ``Qobj`` methods and methods that create ``Qobj`` now accepted a ``dtype``; parameter that allows the data type of the returned ``Qobj`` to specified.; - The new ``&`` operator may be used to obtain the tensor product.; - The new ``@`` operator may be used to obtain the matrix / operator product.; ``bar @ ket`` re",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:39472,Performance,cache,cached,39472,"s the data type of the returned ``Qobj`` to specified.; - The new ``&`` operator may be used to obtain the tensor product.; - The new ``@`` operator may be used to obtain the matrix / operator product.; ``bar @ ket`` returns a scalar.; - The new ``.contract()`` method will collapse 1D subspaces of the dimensions of; the ``Qobj``.; - The new ``.logm()`` method returns the matrix logarithm of an operator.; - The methods ``.set_data``, ``.get_data``, ``.extract_state``, ``.eliminate_states``,; ``.evaluate`` and ``.check_isunitary`` have been removed. QobjEvo changes; ---------------. The ``QobjEvo`` type for storing time-dependent quantum objects has been; significantly expanded, standardized and extended. The time-dependent; coefficients are now represented using a new ``Coefficient`` type that; may be independently created and manipulated if required. Some highlights:. - The ``.compile()`` method has been removed. Coefficients specified as; strings are automatically compiled if possible and the compilation is; cached across different Python runs and instances.; - Mixing coefficient types within a single ``Qobj`` is now supported.; - Many new attributes were added to ``QobjEvo`` for convenience. Examples; include ``.dims``, ``.shape``, ``.superrep`` and ``.isconstant``.; - Many old attributes such as ``.cte``, ``.use_cython``, ``.type``, ``.const``,; and ``.coeff_file`` were removed.; - A new ``Spline`` coefficient supports spline interpolations of different; orders. The old ``Cubic_Spline`` coefficient has been removed.; - The new ``.arguments(...)`` method allows additional arguments to the; underlying coefficient functions to be updated.; - The ``_step_func_coeff`` argument has been replaced by the ``order``; parameter. ``_step_func_coeff=False`` is equivalent to ``order=3``.; ``_step_func_coeff=True`` is equivalent to ``order=0``. Higher values; of ``order`` gives spline interpolations of higher orders. Solver changes; --------------. The solvers in QuTiP have been",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:49335,Performance,load,load,49335,"explicit dimensions are required.; - The function ``rand_unitary_haar`` has been removed. Use; ``rand_unitary(distribution=""haar"")`` instead.; - The functions ``rand_dm_hs`` and ``rand_dm_ginibre`` have been removed.; Use ``rand_dm(distribution=""hs"")`` and ``rand_dm(distribution=""ginibre"")``; instead.; - The function ``rand_ket_haar`` has been removed. Use; ``rand_ket(distribution=""haar"")`` instead.; - The measurement functions have had the ``target`` parameter for; expanding the measurement operator removed. Used ``expand_operator``; to expand the operator instead.; - ``qutip.Bloch`` now supports applying colours per-point, state or vector in; ``add_point``, ``add_states``, and ``add_vectors``. QuTiP settings; --------------. Previously ``qutip.settings`` was an ordinary module. Now ``qutip.settings`` is; an instance of a settings class. All the runtime modifiable settings for; core operations are in ``qutip.settings.core``. The other settings are not; modifiable at runtime. - Removed ``load``. ``reset`` and ``save`` functions.; - Removed ``.debug``, ``.fortran``, ``.openmp_thresh``.; - New ``.compile`` stores the compilation options for compiled coefficients.; - New ``.core[""rtol""]`` core option gives the default relative tolerance used by QuTiP.; - The absolute tolerance setting ``.atol`` has been moved to ``.core[""atol""]``. Package reorganization; ----------------------. - ``qutip.qip`` has been moved into its own package, qutip-qip. Once installed, qutip-qip is available as either ``qutip.qip`` or ``qutip_qip``. Some widely useful gates have been retained in ``qutip.gates``.; - ``qutip.lattice`` has been moved into its own package, qutip-lattice. It is available from `<https://github.com/qutip/qutip-lattice>`.; - ``qutip.sparse`` has been removed. It contained the old sparse matrix representation and is replaced by the new implementation in ``qutip.data``.; - ``qutip.piqs`` functions are no longer available from the ``qutip`` namespace. They are accessible from",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:54926,Performance,load,loaded,54926,"me steps scaled by the number of sidebands, kmax. (#1961); - Change fidelity(A, B) to use the reduced fidelity formula for pure states which is more numerically efficient and accurate. (#1964); - Change ``brmesolve`` to raise an exception when ode integration is not successful. (#1965); - Backport fix for IPython helper Bloch._repr_svg_ from dev.major. Previously the print_figure function returned bytes, but since ipython/ipython#5452 (in 2014) it returns a Unicode string. This fix updates QuTiP's helper to match. (#1970); - Fix correlation for case where only the collapse operators are time dependent. (#1979); - Fix the hinton visualization method to plot the matrix instead of its transpose. (#2011); - Fix the hinton visualization method to take into account all the matrix coefficients to set the squares scale, instead of only the diagonal coefficients. (#2012); - Fix parsing of package versions in setup.py to support packaging 22.0. (#2037); - Add back .qu suffix to objects saved with qsave and loaded with qload. The suffix was accidentally removed in QuTiP 4.7.0. (#2038); - Add a default max_step to processors. (#2040). Documentation; -------------; - Add towncrier for managing the changelog. (#1927); - Update the version of numpy used to build documentation to 1.22.0. (#1940); - Clarify returned objects from bloch_redfield_tensor(). (#1950); - Update Floquet Markov solver docs. (#1958); - Update the roadmap and ideas to show completed work as of August 2022. (#1967). Miscellaneous; -------------; - Return TypeError instead of Exception for type error in sesolve argument. (#1924); - Add towncrier draft build of changelog to CI tests. (#1946); - Add Python 3.11 to builds. (#2041); - Simplify version parsing by using packaging.version.Version. (#2043); - Update builds to use cibuildwheel 2.11, and to build with manylinux2014 on Python 3.8 and 3.9, since numpy and SciPy no longer support manylinux2010 on those versions of Python. (#2047). Version 4.7.0 (April 13, 20",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:56561,Performance,load,loading,56561,"sts. (#1946); - Add Python 3.11 to builds. (#2041); - Simplify version parsing by using packaging.version.Version. (#2043); - Update builds to use cibuildwheel 2.11, and to build with manylinux2014 on Python 3.8 and 3.9, since numpy and SciPy no longer support manylinux2010 on those versions of Python. (#2047). Version 4.7.0 (April 13, 2022); ++++++++++++++++++++++++++++++. This release sees the addition of two new solvers -- ``qutip.krylovsolve`` based on the Krylov subspace approximation and ``qutip.nonmarkov.heom`` that reimplements the BoFiN HEOM solver. Bloch sphere rendering gained support for drawing arcs and lines on the sphere, and for setting the transparency of rendered points and vectors, Hinton plots gained support for specifying a coloring style, and matrix histograms gained better default colors and more flexible styling options. Other significant improvements include better scaling of the Floquet solver, support for passing ``Path`` objects when saving and loading files, support for passing callable functions as ``e_ops`` to ``mesolve`` and ``sesolve``, and faster state number enumeration and Husimi Q functions. Import bugfixes include some bugs affecting plotting with matplotlib 3.5 and fixing support for qutrits (and other non-qubit) quantum circuits. The many other small improvements, bug fixes, documentation enhancements, and behind the scenese development changes are included in the list below. QuTiP 4.7.X will be the last series of releases for QuTiP 4. Patch releases will continue for the 4.7.X series but the main development effort will move to QuTiP 5. The many, many contributors who filed issues, submitted or reviewed pull requests, and improved the documentation for this release are listed next to their contributions below. Thank you to all of you. Improvements; ------------; - **MAJOR** Added krylovsolve as a new solver based on krylov subspace approximation. (`#1739 <https://github.com/qutip/qutip/pull/1739>`_ by Emiliano Fortes); - **MAJ",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:66922,Performance,perform,performance,66922,"https://github.com/qutip/qutip/pull/1575>`_ by Jake Lishman); - Bumped the version of urllib3 used to build documentation from 1.26.4 to 1.26.5. (`#1563 <https://github.com/qutip/qutip/pull/1563>`_ by dependabot); - Moved tests to GitHub Actions. (`#1551 <https://github.com/qutip/qutip/pull/1551>`_ by Jake Lishman); - The GitHub contributing guidelines were re-added and updated to point to the more complete guidelines in the documentation. (`#1549 <https://github.com/qutip/qutip/pull/1549>`_ by Jake Lishman); - The release documentation was reworked after the initial 4.6.1 to match the actual release process. (`#1544 <https://github.com/qutip/qutip/pull/1544>`_ by Jake Lishman). Version 4.6.3 (February 9, 2022); ++++++++++++++++++++++++++++++++. This minor release adds support for numpy 1.22 and Python 3.10 and removes some blockers for running QuTiP on the Apple M1. The performance of the ``enr_destroy``, ``state_number_enumerate`` and ``hadamard_transform`` functions was drastically improved (up to 70x or 200x faster in some common cases), and support for the drift Hamiltonian was added to the ``qutip.qip`` ``Processor``. The ``qutip.hardware_info`` module was removed as part of adding support for the Apple M1. We hope the removal of this little-used module does not adversely affect many users -- it was largely unrelated to QuTiP's core functionality and its presence was a continual source of blockers to importing ``qutip`` on new or changed platforms. A new check on the dimensions of ``Qobj``'s were added to prevent segmentation faults when invalid shape and dimension combinations were passed to Cython code. In addition, there were many small bugfixes, documentation improvements, and improvements to our building and testing processes. Improvements; ------------; - The ``enr_destroy`` function was made ~200x faster in many simple cases. (`#1593 <https://github.com/qutip/qutip/pull/1593>`_ by Johannes Feist); - The ``state_number_enumerate`` function was made signi",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:80003,Performance,load,loading,80003," documentation build (by **Jake Lishman**); - Fix warnings in pytest runs and make pytest treat warnings as errors (by **Jake Lishman**); - Add Simon Cross as author (by **Simon Cross**). Version 4.6.0 (April 11, 2021); ++++++++++++++++++++++++++++++. This release brings improvements for qubit circuits, including a pulse scheduler, measurement statistics, reading/writing OpenQASM and optimisations in the circuit simulations. This is the first release to have full binary wheel releases on pip; you can now do ``pip install qutip`` on almost any machine to get a correct version of the package without needing any compilers set up.; The support for Numpy 1.20 that was first added in QuTiP 4.5.3 is present in this version as well, and the same build considerations mentioned there apply here too.; If building using the now-supported PEP 517 mechanisms (e.g. ``python -mbuild /path/to/qutip``), all build dependencies will be correctly satisfied. Improvements; ------------; - **MAJOR** Add saving, loading and resetting functionality to ``qutip.settings`` for easy re-configuration. (by **Eric Gigure**); - **MAJOR** Add a quantum gate scheduler in ``qutip.qip.scheduler``, to help parallelise the operations of quantum gates. This supports two scheduling modes: as late as possible, and as soon as possible. (by **Boxi Li**); - **MAJOR** Improved qubit circuit simulators, including OpenQASM support and performance optimisations. (by **Sidhant Saraogi**); - **MAJOR** Add tools for quantum measurements and their statistics. (by **Simon Cross** and **Sidhant Saraogi**); - Add support for Numpy 1.20. QuTiP should be compiled against a version of Numpy ``>= 1.16.6`` and ``< 1.20`` (note: does _not_ include 1.20 itself), but such an installation is compatible with any modern version of Numpy. Source installations from ``pip`` understand this constraint.; - Improve the error message when circuit plotting fails. (by **Boxi Li**); - Add support for parsing M1 Mac hardware information. (by ",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:80411,Performance,perform,performance,80411,"penQASM and optimisations in the circuit simulations. This is the first release to have full binary wheel releases on pip; you can now do ``pip install qutip`` on almost any machine to get a correct version of the package without needing any compilers set up.; The support for Numpy 1.20 that was first added in QuTiP 4.5.3 is present in this version as well, and the same build considerations mentioned there apply here too.; If building using the now-supported PEP 517 mechanisms (e.g. ``python -mbuild /path/to/qutip``), all build dependencies will be correctly satisfied. Improvements; ------------; - **MAJOR** Add saving, loading and resetting functionality to ``qutip.settings`` for easy re-configuration. (by **Eric Gigure**); - **MAJOR** Add a quantum gate scheduler in ``qutip.qip.scheduler``, to help parallelise the operations of quantum gates. This supports two scheduling modes: as late as possible, and as soon as possible. (by **Boxi Li**); - **MAJOR** Improved qubit circuit simulators, including OpenQASM support and performance optimisations. (by **Sidhant Saraogi**); - **MAJOR** Add tools for quantum measurements and their statistics. (by **Simon Cross** and **Sidhant Saraogi**); - Add support for Numpy 1.20. QuTiP should be compiled against a version of Numpy ``>= 1.16.6`` and ``< 1.20`` (note: does _not_ include 1.20 itself), but such an installation is compatible with any modern version of Numpy. Source installations from ``pip`` understand this constraint.; - Improve the error message when circuit plotting fails. (by **Boxi Li**); - Add support for parsing M1 Mac hardware information. (by **Xiaoliang Wu**); - Add more single-qubit gates and controlled gates. (by **Mateo Laguna** and **Martn Sande Costa**); - Support decomposition of ``X``, ``Y`` and ``Z`` gates in circuits. (by **Boxi Li**); - Refactor ``QubitCircuit.resolve_gate()`` (by **Martn Sande Costa**). Bug Fixes; ---------; - Fix ``dims`` in the returns from ``Qobj.eigenstates`` on superoperators.",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:95636,Performance,optimiz,optimization,95636," function to return zero outside range. - Fixed dnorm complex casting bug. - Fixed control.io path checking issue. - Fixed ENR fock dimension. - Fixed hard coded options in propagator 'batch' mode. - Fixed bug in trace-norm for non-Hermitian operators. - Fixed bug related to args not being passed to coherence_function_g2. - Fixed MKL error checking dict key error. Version 4.2.0 (July 28, 2017); +++++++++++++++++++++++++++++. Improvements; ------------. - **MAJOR FEATURE**: Initial implementation of time-dependent Bloch-Redfield Solver. - Qobj tidyup is now an order of magnitude faster. - Time-dependent codegen now generates output NumPy arrays faster. - Improved calculation for analytic coefficients in coherent states (Sebastian Kramer). - Input array to correlation FFT method now checked for validity. - Function-based time-dependent mesolve and sesolve routines now faster. - Codegen now makes sure that division is done in C, as opposed to Python. - Can now set different controls for a each timeslot in quantum optimization.; This allows time-varying controls to be used in pulse optimisation. Bug Fixes; ---------. - rcsolve importing old Odeoptions Class rather than Options. - Non-int issue in spin Q and Wigner functions. - Qobj's should tidyup before determining isherm. - Fixed time-dependent RHS function loading on Win. - Fixed several issues with compiling with Cython 0.26. - Liouvillian superoperators were hard setting isherm=True by default. - Fixed an issue with the solver safety checks when inputing a list with Python functions as time-dependence. - Fixed non-int issue in Wigner_cmap. - MKL solver error handling not working properly. Version 4.1.0 (March 10, 2017); ++++++++++++++++++++++++++++++. Improvements; ------------. *Core libraries*. - **MAJOR FEATURE**: QuTiP now works for Python 3.5+ on Windows using Visual Studio 2015. - **MAJOR FEATURE**: Cython and other low level code switched to C++ for MS Windows compatibility. - **MAJOR FEATURE**: Can now use ",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:95937,Performance,load,loading,95937,"ion_g2. - Fixed MKL error checking dict key error. Version 4.2.0 (July 28, 2017); +++++++++++++++++++++++++++++. Improvements; ------------. - **MAJOR FEATURE**: Initial implementation of time-dependent Bloch-Redfield Solver. - Qobj tidyup is now an order of magnitude faster. - Time-dependent codegen now generates output NumPy arrays faster. - Improved calculation for analytic coefficients in coherent states (Sebastian Kramer). - Input array to correlation FFT method now checked for validity. - Function-based time-dependent mesolve and sesolve routines now faster. - Codegen now makes sure that division is done in C, as opposed to Python. - Can now set different controls for a each timeslot in quantum optimization.; This allows time-varying controls to be used in pulse optimisation. Bug Fixes; ---------. - rcsolve importing old Odeoptions Class rather than Options. - Non-int issue in spin Q and Wigner functions. - Qobj's should tidyup before determining isherm. - Fixed time-dependent RHS function loading on Win. - Fixed several issues with compiling with Cython 0.26. - Liouvillian superoperators were hard setting isherm=True by default. - Fixed an issue with the solver safety checks when inputing a list with Python functions as time-dependence. - Fixed non-int issue in Wigner_cmap. - MKL solver error handling not working properly. Version 4.1.0 (March 10, 2017); ++++++++++++++++++++++++++++++. Improvements; ------------. *Core libraries*. - **MAJOR FEATURE**: QuTiP now works for Python 3.5+ on Windows using Visual Studio 2015. - **MAJOR FEATURE**: Cython and other low level code switched to C++ for MS Windows compatibility. - **MAJOR FEATURE**: Can now use interpolating cubic splines as time-dependent coefficients. - **MAJOR FEATURE**: Sparse matrix - vector multiplication now parallel using OPENMP. - Automatic tuning of OPENMP threading threshold. - Partial trace function is now up to 100x+ faster. - Hermitian verification now up to 100x+ faster. - Internal Qobj obj",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:97696,Performance,perform,performance,97696,"lication now parallel using OPENMP. - Automatic tuning of OPENMP threading threshold. - Partial trace function is now up to 100x+ faster. - Hermitian verification now up to 100x+ faster. - Internal Qobj objects now created up to 60x faster. - Inplace conversion from COO -> CSR sparse formats (e.g. Memory efficiency improvement.). - Faster reverse Cuthill-Mckee and sparse one and inf norms. Bug Fixes; ---------. - Cleanup of temp. Cython files now more robust and working under Windows. Version 4.0.2 (January 5, 2017); +++++++++++++++++++++++++++++++. Bug Fixes; ---------; - td files no longer left behind by correlation tests; - Various fast sparse fixes. Version 4.0.0 (December 22, 2016); +++++++++++++++++++++++++++++++++. Improvements; ------------; *Core libraries*. - **MAJOR FEATURE**: Fast sparse: New subclass of csr_matrix added that overrides commonly used methods to avoid certain checks that incurr execution cost. All Qobj.data now fast_csr_matrix; - HEOM performance enhancements; - spmv now faster; - mcsolve codegen further optimised. *Control modules*. - Time dependent drift (through list of pwc dynamics generators); - memory optimisation options provided for control.dynamics. Bug Fixes; ---------. - recompilation of pyx files on first import removed; - tau array in control.pulseoptim funcs now works. Version 3.2.0 (Never officially released); +++++++++++++++++++++++++++++++++++++++++. New Features; ------------. *Core libraries*. - **MAJOR FEATURE**: Non-Markovian solvers: Hierarchy (**Added by Neill Lambert**), Memory-Cascade, and Transfer-Tensor methods.; - **MAJOR FEATURE**: Default steady state solver now up to 100x faster using the Intel Pardiso library under the Anaconda and Intel Python distributions.; - The default Wigner function now uses a Clenshaw summation algorithm to evaluate a polynomial series that is applicable for any number of exciations (previous limitation was ~50 quanta), and is ~3x faster than before. (**Added by Denis Vasilyev**); - ",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:98873,Performance,perform,performs,98873,"y optimisation options provided for control.dynamics. Bug Fixes; ---------. - recompilation of pyx files on first import removed; - tau array in control.pulseoptim funcs now works. Version 3.2.0 (Never officially released); +++++++++++++++++++++++++++++++++++++++++. New Features; ------------. *Core libraries*. - **MAJOR FEATURE**: Non-Markovian solvers: Hierarchy (**Added by Neill Lambert**), Memory-Cascade, and Transfer-Tensor methods.; - **MAJOR FEATURE**: Default steady state solver now up to 100x faster using the Intel Pardiso library under the Anaconda and Intel Python distributions.; - The default Wigner function now uses a Clenshaw summation algorithm to evaluate a polynomial series that is applicable for any number of exciations (previous limitation was ~50 quanta), and is ~3x faster than before. (**Added by Denis Vasilyev**); - Can now define a given eigen spectrum for random Hermitian and density operators.; - The Qobj ``expm`` method now uses the equivilent SciPy routine, and performs a much faster ``exp`` operation if the matrix is diagonal.; - One can now build zero operators using the ``qzero`` function. *Control modules*. - **MAJOR FEATURE**: CRAB algorithm added; This is an alternative to the GRAPE algorithm, which allows for analytical control functions, which means that experimental constraints can more easily be added into optimisation.; See tutorial notebook for full information. Improvements; ------------; *Core libraries*. - Two-time correlation functions can now be calculated for fully time-dependent Hamiltonians and collapse operators. (**Added by Kevin Fischer**); - The code for the inverse-power method for the steady state solver has been simplified.; - Bloch-Redfield tensor creation is now up to an order of magnitude faster. (**Added by Johannes Feist**); - Q.transform now works properly for arrays directly from sp_eigs (or eig).; - Q.groundstate now checks for degeneracy.; - Added ``sinm`` and ``cosm`` methods to the Qobj class.; - Added ",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:105546,Performance,perform,performance,105546,"tochastic solvers now run trajectories in parallel.; - New superoperator and tensor manipulation functions; (super_tensor, composite, tensor_contract).; - New logging module for debugging (qutip.logging).; - New user-available API for parallelization (parallel_map).; - New enhanced (optional) text-based progressbar (qutip.ui.EnhancedTextProgressBar); - Faster Python based monte carlo solver (mcsolve).; - Support for progress bars in propagator function.; - Time-dependent Cython code now calls complex cmath functions.; - Random numbers seeds can now be reused for successive calls to mcsolve.; - The Bloch-Redfield master equation solver now supports optional Lindblad type collapse operators.; - Improved handling of ODE integration errors in mesolve.; - Improved correlation function module (for example, improved support for time-dependent problems).; - Improved parallelization of mcsolve (can now be interrupted easily, support for IPython.parallel, etc.); - Many performance improvements, and much internal code restructuring. Bug Fixes; ---------. - Cython build files for time-dependent string format now removed automatically.; - Fixed incorrect solution time from inverse-power method steady state solver.; - mcsolve now supports `Options(store_states=True)`; - Fixed bug in `hadamard` gate function.; - Fixed compatibility issues with NumPy 1.9.0.; - Progressbar in mcsolve can now be suppressed.; - Fixed bug in `gate_expand_3toN`.; - Fixed bug for time-dependent problem (list string format) with multiple terms in coefficient to an operator. Version 3.0.1 (Aug 5, 2014); +++++++++++++++++++++++++++. Bug Fixes; ---------. - Fix bug in create(), which returned a Qobj with CSC data instead of CSR.; - Fix several bugs in mcsolve: Incorrect storing of collapse times and collapse; operator records. Incorrect averaging of expectation values for different; trajectories when using only 1 CPU.; - Fix bug in parsing of time-dependent Hamiltonian/collapse operator arguments; that occurr",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:109233,Performance,concurren,concurrence,109233,"refixed with ``plot_`` (e.g., ``plot_fock_distribution``). The; ``plot_wigner`` and ``plot_wigner_fock_distribution`` now supports 3D views; in addition to contour views. - New API and new functions for working with spin operators and states,; including for example ``spin_Jx``, ``spin_Jy``, ``spin_Jz`` and; ``spin_state``, ``spin_coherent``. - The ``expect`` function now supports a list of operators, in addition to the; previously supported list of states. - Simplified creation of qubit states using ``ket`` function. - The module ``qutip.cyQ`` has been renamed to ``qutip.cy`` and the sparse; matrix-vector functions ``spmv`` and ``spmv1d`` has been combined into one; function ``spmv``. New functions for operating directly on the underlaying; sparse CSR data have been added (e.g., ``spmv_csr``). Performance; improvements. New and improved Cython functions for calculating expectation; values for state vectors, density matrices in matrix and vector form. - The ``concurrence`` function now supports both pure and mixed states. Added; function for calculating the entangling power of a two-qubit gate. - Added function for generating (generalized) Lindblad dissipator; superoperators. - New functions for generating Bell states, and singlet and triplet states. - QuTiP no longer contains the demos GUI. The examples are now available on the; QuTiP web site. The ``qutip.gui`` module has been renamed to ``qutip.ui`` and; does no longer contain graphical UI elements. New text-based and HTML-based; progressbar classes. - Support for harmonic oscillator operators/states in a Fock state basis that; does not start from zero (e.g., in the range [M,N+1]). Support for; eliminating and extracting states from Qobj instances (e.g., removing one; state from a two-qubit system to obtain a three-level system). - Support for time-dependent Hamiltonian and Liouvillian callback functions that; depend on the instantaneous state, which for example can be used for solving; master equations with mean ",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:110320,Performance,optimiz,optimized,110320,"ction for generating (generalized) Lindblad dissipator; superoperators. - New functions for generating Bell states, and singlet and triplet states. - QuTiP no longer contains the demos GUI. The examples are now available on the; QuTiP web site. The ``qutip.gui`` module has been renamed to ``qutip.ui`` and; does no longer contain graphical UI elements. New text-based and HTML-based; progressbar classes. - Support for harmonic oscillator operators/states in a Fock state basis that; does not start from zero (e.g., in the range [M,N+1]). Support for; eliminating and extracting states from Qobj instances (e.g., removing one; state from a two-qubit system to obtain a three-level system). - Support for time-dependent Hamiltonian and Liouvillian callback functions that; depend on the instantaneous state, which for example can be used for solving; master equations with mean field terms. Improvements; ------------. - Restructured and optimized implementation of Qobj, which now has; significantly lower memory footprint due to avoiding excessive copying of; internal matrix data. - The classes ``OdeData``, ``Odeoptions``, ``Odeconfig`` are now called; ``Result``, ``Options``, and ``Config``, respectively, and are available in; the module `qutip.solver`. - The ``squeez`` function has been renamed to ``squeeze``. - Better support for sparse matrices when calculating propagators using the; ``propagator`` function. - Improved Bloch sphere. - Restructured and improved the module ``qutip.sparse``, which now only; operates directly on sparse matrices (not on Qobj instances). - Improved and simplified implement of the ``tensor`` function. - Improved performance, major code cleanup (including namespace changes),; and numerous bug fixes. - Benchmark scripts improved and restructured. - QuTiP is now using continuous integration tests (TravisCI). Version 2.2.0 (March 01, 2013); ++++++++++++++++++++++++++++++. New Features; ------------. - **Added Support for Windows**. - New Bloch3d class fo",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:111039,Performance,perform,performance,111039,"upport for time-dependent Hamiltonian and Liouvillian callback functions that; depend on the instantaneous state, which for example can be used for solving; master equations with mean field terms. Improvements; ------------. - Restructured and optimized implementation of Qobj, which now has; significantly lower memory footprint due to avoiding excessive copying of; internal matrix data. - The classes ``OdeData``, ``Odeoptions``, ``Odeconfig`` are now called; ``Result``, ``Options``, and ``Config``, respectively, and are available in; the module `qutip.solver`. - The ``squeez`` function has been renamed to ``squeeze``. - Better support for sparse matrices when calculating propagators using the; ``propagator`` function. - Improved Bloch sphere. - Restructured and improved the module ``qutip.sparse``, which now only; operates directly on sparse matrices (not on Qobj instances). - Improved and simplified implement of the ``tensor`` function. - Improved performance, major code cleanup (including namespace changes),; and numerous bug fixes. - Benchmark scripts improved and restructured. - QuTiP is now using continuous integration tests (TravisCI). Version 2.2.0 (March 01, 2013); ++++++++++++++++++++++++++++++. New Features; ------------. - **Added Support for Windows**. - New Bloch3d class for plotting 3D Bloch spheres using Mayavi. - Bloch sphere vectors now look like arrows. - Partial transpose function. - Continuos variable functions for calculating correlation and covariance; matrices, the Wigner covariance matrix and the logarithmic negativity for; for multimode fields in Fock basis. - The master-equation solver (mesolve) now accepts pre-constructed Liouvillian; terms, which makes it possible to solve master equations that are not on; the standard Lindblad form. - Optional Fortran Monte Carlo solver (mcsolve_f90) by Arne Grimsmo. - A module of tools for using QuTiP in IPython notebooks. - Increased performance of the steady state solver. - New Wigner colormap for high",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:112007,Performance,perform,performance,112007,"nction. - Improved performance, major code cleanup (including namespace changes),; and numerous bug fixes. - Benchmark scripts improved and restructured. - QuTiP is now using continuous integration tests (TravisCI). Version 2.2.0 (March 01, 2013); ++++++++++++++++++++++++++++++. New Features; ------------. - **Added Support for Windows**. - New Bloch3d class for plotting 3D Bloch spheres using Mayavi. - Bloch sphere vectors now look like arrows. - Partial transpose function. - Continuos variable functions for calculating correlation and covariance; matrices, the Wigner covariance matrix and the logarithmic negativity for; for multimode fields in Fock basis. - The master-equation solver (mesolve) now accepts pre-constructed Liouvillian; terms, which makes it possible to solve master equations that are not on; the standard Lindblad form. - Optional Fortran Monte Carlo solver (mcsolve_f90) by Arne Grimsmo. - A module of tools for using QuTiP in IPython notebooks. - Increased performance of the steady state solver. - New Wigner colormap for highlighting negative values. - More graph styles to the visualization module. Bug Fixes; ---------. - Function based time-dependent Hamiltonians now keep the correct phase. - mcsolve no longer prints to the command line if ntraj=1. Version 2.1.0 (October 05, 2012); ++++++++++++++++++++++++++++++++. New Features; ------------. - New method for generating Wigner functions based on Laguerre polynomials. - coherent(), coherent_dm(), and thermal_dm() can now be expressed using analytic values. - Unittests now use nose and can be run after installation. - Added iswap and sqrt-iswap gates. - Functions for quantum process tomography. - Window icons are now set for Ubuntu application launcher. - The propagator function can now take a list of times as argument, and returns a list of corresponding propagators. Bug Fixes; ---------. - mesolver now correctly uses the user defined rhs_filename in Odeoptions(). - rhs_generate() now handles user de",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:113852,Performance,perform,performance,113852," Bug Fixes; ---------. - mesolver now correctly uses the user defined rhs_filename in Odeoptions(). - rhs_generate() now handles user defined filenames properly. - Density matrix returned by propagator_steadystate is now Hermitian. - eseries_value returns real list if all imag parts are zero. - mcsolver now gives correct results for strong damping rates. - Odeoptions now prints mc_avg correctly. - Do not check for PyObj in mcsolve when gui=False. - Eseries now correctly handles purely complex rates. - thermal_dm() function now uses truncated operator method. - Cython based time-dependence now Python 3 compatible. - Removed call to NSAutoPool on mac systems. - Progress bar now displays the correct number of CPU's used. - Qobj.diag() returns reals if operator is Hermitian. - Text for progress bar on Linux systems is no longer cutoff. Version 2.0.0 (June 01, 2012); +++++++++++++++++++++++++++++. The second version of QuTiP has seen many improvements in the performance of the original code base, as well as the addition of several new routines supporting a wide range of functionality. Some of the highlights of this release include:. New Features; ------------. - QuTiP now includes solvers for both Floquet and Bloch-Redfield master equations. - The Lindblad master equation and Monte Carlo solvers allow for time-dependent collapse operators. - It is possible to automatically compile time-dependent problems into c-code using Cython (if installed). - Python functions can be used to create arbitrary time-dependent Hamiltonians and collapse operators. - Solvers now return Odedata objects containing all simulation results and parameters, simplifying the saving of simulation results. .. important:: This breaks compatibility with QuTiP version 1.x. - mesolve and mcsolve can reuse Hamiltonian data when only the initial state, or time-dependent arguments, need to be changed. - QuTiP includes functions for creating random quantum states and operators. - The generation and manipulatio",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:115374,Performance,optimiz,optimized,115374,"bitrary time-dependent Hamiltonians and collapse operators. - Solvers now return Odedata objects containing all simulation results and parameters, simplifying the saving of simulation results. .. important:: This breaks compatibility with QuTiP version 1.x. - mesolve and mcsolve can reuse Hamiltonian data when only the initial state, or time-dependent arguments, need to be changed. - QuTiP includes functions for creating random quantum states and operators. - The generation and manipulation of quantum objects is now more efficient. - Quantum objects have basis transformation and matrix element calculations as built-in methods. - The quantum object eigensolver can use sparse solvers. - The partial-trace (ptrace) function is up to 20x faster. - The Bloch sphere can now be used with the Matplotlib animation function, and embedded as a subplot in a figure. - QuTiP has built-in functions for saving quantum objects and data arrays. - The steady-state solver has been further optimized for sparse matrices, and can handle much larger system Hamiltonians. - The steady-state solver can use the iterative bi-conjugate gradient method instead of a direct solver. - There are three new entropy functions for concurrence, mutual information, and conditional entropy. - Correlation functions have been combined under a single function. - The operator norm can now be set to trace, Frobius, one, or max norm. - Global QuTiP settings can now be modified. - QuTiP includes a collection of unit tests for verifying the installation. - Demos window now lets you copy and paste code from each example. Version 1.1.4 (May 28, 2012); ++++++++++++++++++++++++++++. Bug Fixes; ---------. - Fixed bug pointed out by Brendan Abolins. - Qobj.tr() returns zero-dim ndarray instead of float or complex. - Updated factorial import for scipy version 0.10+. Version 1.1.3 (November 21, 2011); +++++++++++++++++++++++++++++++++. New Functions; -------------. - Allow custom naming of Bloch sphere. Bug Fixes; ---------",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:115602,Performance,concurren,concurrence,115602,"ks compatibility with QuTiP version 1.x. - mesolve and mcsolve can reuse Hamiltonian data when only the initial state, or time-dependent arguments, need to be changed. - QuTiP includes functions for creating random quantum states and operators. - The generation and manipulation of quantum objects is now more efficient. - Quantum objects have basis transformation and matrix element calculations as built-in methods. - The quantum object eigensolver can use sparse solvers. - The partial-trace (ptrace) function is up to 20x faster. - The Bloch sphere can now be used with the Matplotlib animation function, and embedded as a subplot in a figure. - QuTiP has built-in functions for saving quantum objects and data arrays. - The steady-state solver has been further optimized for sparse matrices, and can handle much larger system Hamiltonians. - The steady-state solver can use the iterative bi-conjugate gradient method instead of a direct solver. - There are three new entropy functions for concurrence, mutual information, and conditional entropy. - Correlation functions have been combined under a single function. - The operator norm can now be set to trace, Frobius, one, or max norm. - Global QuTiP settings can now be modified. - QuTiP includes a collection of unit tests for verifying the installation. - Demos window now lets you copy and paste code from each example. Version 1.1.4 (May 28, 2012); ++++++++++++++++++++++++++++. Bug Fixes; ---------. - Fixed bug pointed out by Brendan Abolins. - Qobj.tr() returns zero-dim ndarray instead of float or complex. - Updated factorial import for scipy version 0.10+. Version 1.1.3 (November 21, 2011); +++++++++++++++++++++++++++++++++. New Functions; -------------. - Allow custom naming of Bloch sphere. Bug Fixes; ---------; - Fixed text alignment issues in AboutBox. - Added fix for SciPy V>0.10 where factorial was moved to scipy.misc module. - Added tidyup function to tensor function output. - Removed openmp flags from setup.py as new ",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:117702,Performance,concurren,concurrence,117702,"openmp flags from setup.py as new Mac Xcode compiler does not recognize them. - Qobj diag method now returns real array if all imaginary parts are zero. - Examples GUI now links to new documentation. - Fixed zero-dimensional array output from metrics module. Version 1.1.2 (October 27, 2011); ++++++++++++++++++++++++++++++++. Bug Fixes; ---------. - Fixed issue where Monte Carlo states were not output properly. Version 1.1.1 (October 25, 2011); ++++++++++++++++++++++++++++++++. **THIS POINT-RELEASE INCLUDES VASTLY IMPROVED TIME-INDEPENDENT MCSOLVE AND ODESOLVE PERFORMANCE**. New Functions; -------------. - Added linear entropy function. - Number of CPU's can now be changed. Bug Fixes; ---------. - Metrics no longer use dense matrices. - Fixed Bloch sphere grid issue with matplotlib 1.1. - Qobj trace operation uses only sparse matrices. - Fixed issue where GUI windows do not raise to front. Version 1.1.0 (October 04, 2011); ++++++++++++++++++++++++++++++++. **THIS RELEASE NOW REQUIRES THE GCC COMPILER TO BE INSTALLED**. New Functions; -------------. - tidyup function to remove small elements from a Qobj. - Added concurrence function. - Added simdiag for simultaneous diagonalization of operators. - Added eigenstates method returning eigenstates and eigenvalues to Qobj class. - Added fileio for saving and loading data sets and/or Qobj's. - Added hinton function for visualizing density matrices. Bug Fixes; ---------. - Switched Examples to new Signals method used in PySide 1.0.6+. - Switched ProgressBar to new Signals method. - Fixed memory issue in expm functions. - Fixed memory bug in isherm. - Made all Qobj data complex by default. - Reduced ODE tolerance levels in Odeoptions. - Fixed bug in ptrace where dense matrix was used instead of sparse. - Fixed issue where PyQt4 version would not be displayed in about box. - Fixed issue in Wigner where xvec was used twice (in place of yvec). Version 1.0.0 (July 29, 2011); +++++++++++++++++++++++++++++. - **Initial release.**; ",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:117897,Performance,load,loading,117897,"openmp flags from setup.py as new Mac Xcode compiler does not recognize them. - Qobj diag method now returns real array if all imaginary parts are zero. - Examples GUI now links to new documentation. - Fixed zero-dimensional array output from metrics module. Version 1.1.2 (October 27, 2011); ++++++++++++++++++++++++++++++++. Bug Fixes; ---------. - Fixed issue where Monte Carlo states were not output properly. Version 1.1.1 (October 25, 2011); ++++++++++++++++++++++++++++++++. **THIS POINT-RELEASE INCLUDES VASTLY IMPROVED TIME-INDEPENDENT MCSOLVE AND ODESOLVE PERFORMANCE**. New Functions; -------------. - Added linear entropy function. - Number of CPU's can now be changed. Bug Fixes; ---------. - Metrics no longer use dense matrices. - Fixed Bloch sphere grid issue with matplotlib 1.1. - Qobj trace operation uses only sparse matrices. - Fixed issue where GUI windows do not raise to front. Version 1.1.0 (October 04, 2011); ++++++++++++++++++++++++++++++++. **THIS RELEASE NOW REQUIRES THE GCC COMPILER TO BE INSTALLED**. New Functions; -------------. - tidyup function to remove small elements from a Qobj. - Added concurrence function. - Added simdiag for simultaneous diagonalization of operators. - Added eigenstates method returning eigenstates and eigenvalues to Qobj class. - Added fileio for saving and loading data sets and/or Qobj's. - Added hinton function for visualizing density matrices. Bug Fixes; ---------. - Switched Examples to new Signals method used in PySide 1.0.6+. - Switched ProgressBar to new Signals method. - Fixed memory issue in expm functions. - Fixed memory bug in isherm. - Made all Qobj data complex by default. - Reduced ODE tolerance levels in Odeoptions. - Fixed bug in ptrace where dense matrix was used instead of sparse. - Fixed issue where PyQt4 version would not be displayed in about box. - Fixed issue in Wigner where xvec was used twice (in place of yvec). Version 1.0.0 (July 29, 2011); +++++++++++++++++++++++++++++. - **Initial release.**; ",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:16489,Safety,timeout,timeout,16489,"ods.; - QuTiP's own implementation of a solver that directly diagonalizes the; the system to be integrated is available as ``diag``. It only works on; time-independent systems and is slow to setup, but once the diagonalization; is complete, it generates solutions very quickly.; - QuTiP's own implementatoin of an approximate Krylov subspace integrator is; available as ``krylov``. This integrator is only usable with ``sesolve``. Result class:. - A new ``.e_data`` attribute provides expectation values as a dictionary.; Unlike ``.expect``, the values are provided in a Python list rather than; a numpy array, which better supports non-numeric types.; - The contents of the ``.stats`` attribute changed significantly and is; now more consistent across solvers. Monte-Carlo Solver (mcsolve):. - The system, H, may now be a super-operator.; - The ``seed`` parameter now supports supplying numpy ``SeedSequence`` or; ``Generator`` types.; - The new ``timeout`` and ``target_tol`` parameters allow the solver to exit; early if a timeout or target tolerance is reached.; - The ntraj option no longer supports a list of numbers of trajectories.; Instead, just run the solver multiple times and use the class ``MCSolver``; if setting up the solver uses a significant amount of time.; - The ``map_func`` parameter has been replaced by the ``map`` option.; - A loky based parallel map as been added.; - A mpi based parallel map as been added.; - The result returned by ``mcsolve`` now supports calculating photocurrents; and calculating the steady state over N trajectories.; - The old ``parfor`` parallel execution function has been removed from; ``qutip.parallel``. Use ``parallel_map``, ``loky_map`` or ``mpi_pmap`` instead.; - Added improved sampling options which converge much faster when the; probability of collapse is small. Non Markovian Monte-Carlo Solver (nm_mcsolve):. - New Monte-Carlo Solver supporting negative decay rates.; - Based on the influence martingale approach, Donvil et al., Nat Co",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:16566,Safety,timeout,timeout,16566,"ods.; - QuTiP's own implementation of a solver that directly diagonalizes the; the system to be integrated is available as ``diag``. It only works on; time-independent systems and is slow to setup, but once the diagonalization; is complete, it generates solutions very quickly.; - QuTiP's own implementatoin of an approximate Krylov subspace integrator is; available as ``krylov``. This integrator is only usable with ``sesolve``. Result class:. - A new ``.e_data`` attribute provides expectation values as a dictionary.; Unlike ``.expect``, the values are provided in a Python list rather than; a numpy array, which better supports non-numeric types.; - The contents of the ``.stats`` attribute changed significantly and is; now more consistent across solvers. Monte-Carlo Solver (mcsolve):. - The system, H, may now be a super-operator.; - The ``seed`` parameter now supports supplying numpy ``SeedSequence`` or; ``Generator`` types.; - The new ``timeout`` and ``target_tol`` parameters allow the solver to exit; early if a timeout or target tolerance is reached.; - The ntraj option no longer supports a list of numbers of trajectories.; Instead, just run the solver multiple times and use the class ``MCSolver``; if setting up the solver uses a significant amount of time.; - The ``map_func`` parameter has been replaced by the ``map`` option.; - A loky based parallel map as been added.; - A mpi based parallel map as been added.; - The result returned by ``mcsolve`` now supports calculating photocurrents; and calculating the steady state over N trajectories.; - The old ``parfor`` parallel execution function has been removed from; ``qutip.parallel``. Use ``parallel_map``, ``loky_map`` or ``mpi_pmap`` instead.; - Added improved sampling options which converge much faster when the; probability of collapse is small. Non Markovian Monte-Carlo Solver (nm_mcsolve):. - New Monte-Carlo Solver supporting negative decay rates.; - Based on the influence martingale approach, Donvil et al., Nat Co",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:18069,Safety,timeout,timeout,18069,"ady state over N trajectories.; - The old ``parfor`` parallel execution function has been removed from; ``qutip.parallel``. Use ``parallel_map``, ``loky_map`` or ``mpi_pmap`` instead.; - Added improved sampling options which converge much faster when the; probability of collapse is small. Non Markovian Monte-Carlo Solver (nm_mcsolve):. - New Monte-Carlo Solver supporting negative decay rates.; - Based on the influence martingale approach, Donvil et al., Nat Commun 13, 4140 (2022).; - Most of the improvements made to the regular Monte-Carlo solver are also available here.; - The value of the influence martingale is available through the ``.trace`` attribute of the result. Stochastic Equation Solvers (ssesolve, smesolve). - Function call greatly changed: many keyword arguments are now options.; - m_ops and dW_factors are now changed from the default from the new class interface only.; - Use the same parallel maps as mcsolve: support for loky and mpi map added.; - End conditions ``timeout`` and ``target_tol`` added.; - The ``seed`` parameter now supports supplying numpy ``SeedSequence``.; - Wiener function is now available as a feedback. Bloch-Redfield Master Equation Solver (brmesolve):. - The ``a_ops`` and ``spectra`` support implementations been heavily reworked to; reuse the techniques from the new Coefficient and QobjEvo classes.; - The ``use_secular`` parameter has been removed. Use ``sec_cutoff=-1`` instead.; - The required tolerance is now read from ``qutip.settings``. Krylov Subspace Solver (krylovsolve):. - The Krylov solver is now implemented using ``SESolver`` and the ``krylov``; ODE integrator. The function ``krylovsolve`` is maintained for convenience; and now supports many more options.; - The ``sparse`` parameter has been removed. Supply a sparse ``Qobj`` for the; Hamiltonian instead. Floquet Solver (fsesolve and fmmesolve):. - The Floquet solver has been rewritten to use a new ``FloquetBasis`` class; which manages the transformations from lab to Floque",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:28327,Safety,timeout,timeouts,28327,"4-03-04); ==========================. Features; --------. - Create a Dimension class (#1996); - Add arguments of plot_wigner() and plot_wigner_fock_distribution() to specify parameters for wigner(). (#2057, by Kosuke Mizuno); - Restore feedback to solvers (#2210); - Added mpi_pmap, which uses the mpi4py module to run computations in parallel through the MPI interface. (#2296, by Paul); - Only pre-compute density matrices if keep_runs_results is False (#2303, by Matt Ord). Bug Fixes; ---------. - Add the possibility to customize point colors as in V4 and fix point plot behavior for 'l' style (#1974, by Daniel Moreno Galn); - Disabled broken ""improved sampling"" for `nm_mcsolve`. (#2234, by Paul); - Fixed result objects storing a reference to the solver through options._feedback. (#2262, by Paul); - Fixed simdiag not returning orthonormal eigenvectors. (#2269, by Sola85); - Fix LaTeX display of Qobj state in Jupyter cell outputs (#2272, by Edward Thomas); - Improved behavior of `parallel_map` and `loky_pmap` in the case of timeouts, errors or keyboard interrupts (#2280, by Paul); - Ignore deprecation warnings from cython 0.29.X in tests. (#2288); - Fixed two problems with the steady_state() solver in the HEOM method. (#2333). Miscellaneous; -------------. - Improve fidelity doc-string (#2257); - Improve documentation in guide/dynamics (#2271); - Improve states and operator parameters documentation. (#2289); - Rework `kraus_to_choi` making it faster (#2284, by Bogdan Reznychenko); - Remove Bloch3D: redundant to Bloch (#2306); - Allow tests to run without matplotlib and ipython. (#2311); - Add too small step warnings in fixed dt SODE solver (#2313); - Add `dtype` to `Qobj` and `QobjEvo` (#2325); - Fix typos in `expect` documentation (#2331, by gabbence95); - Allow measurement functions to support degenerate operators. (#2342). QuTiP 5.0.0a2 (2023-09-06); ==========================. Features; --------. - Add support for different spectra types for bloch_redfield_tensor (#",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:28811,Safety,redund,redundant,28811,"ossibility to customize point colors as in V4 and fix point plot behavior for 'l' style (#1974, by Daniel Moreno Galn); - Disabled broken ""improved sampling"" for `nm_mcsolve`. (#2234, by Paul); - Fixed result objects storing a reference to the solver through options._feedback. (#2262, by Paul); - Fixed simdiag not returning orthonormal eigenvectors. (#2269, by Sola85); - Fix LaTeX display of Qobj state in Jupyter cell outputs (#2272, by Edward Thomas); - Improved behavior of `parallel_map` and `loky_pmap` in the case of timeouts, errors or keyboard interrupts (#2280, by Paul); - Ignore deprecation warnings from cython 0.29.X in tests. (#2288); - Fixed two problems with the steady_state() solver in the HEOM method. (#2333). Miscellaneous; -------------. - Improve fidelity doc-string (#2257); - Improve documentation in guide/dynamics (#2271); - Improve states and operator parameters documentation. (#2289); - Rework `kraus_to_choi` making it faster (#2284, by Bogdan Reznychenko); - Remove Bloch3D: redundant to Bloch (#2306); - Allow tests to run without matplotlib and ipython. (#2311); - Add too small step warnings in fixed dt SODE solver (#2313); - Add `dtype` to `Qobj` and `QobjEvo` (#2325); - Fix typos in `expect` documentation (#2331, by gabbence95); - Allow measurement functions to support degenerate operators. (#2342). QuTiP 5.0.0a2 (2023-09-06); ==========================. Features; --------. - Add support for different spectra types for bloch_redfield_tensor (#1951); - Improve qutip import times by setting logger names explicitly. (#1981, by Pieter Eendebak); - Change the order of parameters in expand_operator (#1991); - Add `svn` and `solve` to dispatched (#2002); - Added nm_mcsolve to provide support for Monte-Carlo simulations of master equations with possibly negative rates. The method implemented here is described in arXiv:2209.08958 [quant-ph]. (#2070 by pmenczel); - Add support for combining bosonic and fermionic HEOM baths (#2089); - Added __repr__ to ",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:43186,Safety,timeout,timeout,43186,"ods.; - QuTiP's own implementation of a solver that directly diagonalizes the; the system to be integrated is available as ``diag``. It only works on; time-independent systems and is slow to setup, but once the diagonalization; is complete, it generates solutions very quickly.; - QuTiP's own implementatoin of an approximate Krylov subspace integrator is; available as ``krylov``. This integrator is only usable with ``sesolve``. Result class:. - A new ``.e_data`` attribute provides expectation values as a dictionary.; Unlike ``.expect``, the values are provided in a Python list rather than; a numpy array, which better supports non-numeric types.; - The contents of the ``.stats`` attribute changed significantly and is; now more consistent across solvers. Monte-Carlo Solver (mcsolve):. - The system, H, may now be a super-operator.; - The ``seed`` parameter now supports supplying numpy ``SeedSequence`` or; ``Generator`` types.; - The new ``timeout`` and ``target_tol`` parameters allow the solver to exit; early if a timeout or target tolerance is reached.; - The ntraj option no longer supports a list of numbers of trajectories.; Instead, just run the solver multiple times and use the class ``MCSolver``; if setting up the solver uses a significant amount of time.; - The ``map_func`` parameter has been replaced by the ``map`` option. In; addition to the existing ``serial`` and ``parallel`` values, the value; ``loky`` may be supplied to use the loky package to parallelize trajectories.; - The result returned by ``mcsolve`` now supports calculating photocurrents; and calculating the steady state over N trajectories.; - The old ``parfor`` parallel execution function has been removed from; ``qutip.parallel``. Use ``parallel_map`` or ``loky_map`` instead. Bloch-Redfield Master Equation Solver (brmesolve):. - The ``a_ops`` and ``spectra`` support implementaitons been heavily reworked to; reuse the techniques from the new Coefficient and QobjEvo classes.; - The ``use_secular`` par",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:43263,Safety,timeout,timeout,43263,"ods.; - QuTiP's own implementation of a solver that directly diagonalizes the; the system to be integrated is available as ``diag``. It only works on; time-independent systems and is slow to setup, but once the diagonalization; is complete, it generates solutions very quickly.; - QuTiP's own implementatoin of an approximate Krylov subspace integrator is; available as ``krylov``. This integrator is only usable with ``sesolve``. Result class:. - A new ``.e_data`` attribute provides expectation values as a dictionary.; Unlike ``.expect``, the values are provided in a Python list rather than; a numpy array, which better supports non-numeric types.; - The contents of the ``.stats`` attribute changed significantly and is; now more consistent across solvers. Monte-Carlo Solver (mcsolve):. - The system, H, may now be a super-operator.; - The ``seed`` parameter now supports supplying numpy ``SeedSequence`` or; ``Generator`` types.; - The new ``timeout`` and ``target_tol`` parameters allow the solver to exit; early if a timeout or target tolerance is reached.; - The ntraj option no longer supports a list of numbers of trajectories.; Instead, just run the solver multiple times and use the class ``MCSolver``; if setting up the solver uses a significant amount of time.; - The ``map_func`` parameter has been replaced by the ``map`` option. In; addition to the existing ``serial`` and ``parallel`` values, the value; ``loky`` may be supplied to use the loky package to parallelize trajectories.; - The result returned by ``mcsolve`` now supports calculating photocurrents; and calculating the steady state over N trajectories.; - The old ``parfor`` parallel execution function has been removed from; ``qutip.parallel``. Use ``parallel_map`` or ``loky_map`` instead. Bloch-Redfield Master Equation Solver (brmesolve):. - The ``a_ops`` and ``spectra`` support implementaitons been heavily reworked to; reuse the techniques from the new Coefficient and QobjEvo classes.; - The ``use_secular`` par",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:69031,Safety,sanity check,sanity checks,69031,"/qutip/qutip/pull/1594>`_ by Johannes Feist); - Added the missing drift Hamiltonian to the method run_analytically of ``Processor``. (`#1603 <https://github.com/qutip/qutip/pull/1603>`_ Boxi Li); - The ``hadamard_transform`` was made much faster, e.g., ~70x faster for N=10. (`#1688 <https://github.com/qutip/qutip/pull/1688>`_ by Asier Galicia); - Added support for computing the power of a scalar-like Qobj. (`#1692 <https://github.com/qutip/qutip/pull/1692>`_ by Asier Galicia); - Removed the ``hardware_info`` module. This module wasn't used inside QuTiP and regularly broke when new operating systems were released, and in particular prevented importing QuTiP on the Apple M1. (`#1754 <https://github.com/qutip/qutip/pull/1754>`_, `#1758 <https://github.com/qutip/qutip/pull/1758>`_ by Eric Gigure). Bug Fixes; ---------; - Fixed support for calculating the propagator of a density matrix with collapse operators. QuTiP 4.6.2 introduced extra sanity checks on the dimensions of inputs to mesolve (Fix mesolve segfault with bad initial state `#1459 <https://github.com/qutip/qutip/pull/1459>`_), but the propagator function's calls to mesolve violated these checks by supplying initial states with the dimensions incorrectly set. ``propagator`` now calls mesolve with the correct dimensions set on the initial state. (`#1588 <https://github.com/qutip/qutip/pull/1588>`_ by Simon Cross); - Fixed support for calculating the propagator for a superoperator without collapse operators. This functionality was not tested by the test suite and appears to have broken sometime during 2019. Tests have now been added and the code breakages fixed. (`#1588 <https://github.com/qutip/qutip/pull/1588>`_ by Simon Cross); - Fixed the ignoring of the random number seed passed to ``rand_dm`` in the case where ``pure`` was set to true. (`#1600 <https://github.com/qutip/qutip/pull/1600>`_ Pontus Wiksthl); - Fixed qutip.control.optimize_pulse support for sparse eigenvector decomposition with the Qobj oper_d",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:85937,Safety,unsafe,unsafe,85937,"any modern version of Numpy. Source installations from ``pip`` understand this constraint. Version 4.5.2 (July 14, 2020); +++++++++++++++++++++++++++++. This is predominantly a hot-fix release to add support for Scipy 1.5, due to changes in private sparse matrix functions that QuTiP also used. Improvements; ------------; - Add support for Scipy 1.5. (by **Jake Lishman**); - Improved speed of ``zcsr_inner``, which affects ``Qobj.overlap``. (by **Jake Lishman**); - Better error messages when installation requirements are not satisfied. (by **Eric Gigure**). Bug Fixes; ---------; - Fix ``zcsr_proj`` acting on matrices with unsorted indices. (by **Jake Lishman**); - Fix errors in Milstein's heterodyne. (by **Eric Gigure**); - Fix datatype bug in ``qutip.lattice`` module. (by **Boxi Li**); - Fix issues with ``eigh`` on Mac when using OpenBLAS. (by **Eric Gigure**). Developer Changes; -----------------; - Converted more of the codebase to PEP 8.; - Fix several instances of unsafe mutable default values and unsafe ``is`` comparisons. Version 4.5.1 (May 15, 2020); ++++++++++++++++++++++++++++. Improvements; ------------; - ``husimi`` and ``wigner`` now accept half-integer spin (by **maij**); - Better error messages for failed string coefficient compilation. (issue raised by **nohchangsuk**). Bug Fixes; ---------; - Safer naming for temporary files. (by **Eric Gigure**); - Fix ``clebsch`` function for half-integer (by **Thomas Walker**); - Fix ``randint``'s dtype to ``uint32`` for compatibility with Windows. (issue raised by **Boxi Li**); - Corrected stochastic's heterodyne's m_ops (by **eliegenois**); - Mac pool use spawn. (issue raised by **goerz**); - Fix typos in ``QobjEvo._shift``. (by **Eric Gigure**); - Fix warning on Travis CI. (by **Ivan Carvalho**). Deprecations; ------------; - ``qutip.graph`` functions will be deprecated in QuTiP 5.0 in favour of ``scipy.sparse.csgraph``. Developer Changes; -----------------; - Add Boxi Li to authors. (by **Alex Pitchford**);",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:85971,Safety,unsafe,unsafe,85971,"any modern version of Numpy. Source installations from ``pip`` understand this constraint. Version 4.5.2 (July 14, 2020); +++++++++++++++++++++++++++++. This is predominantly a hot-fix release to add support for Scipy 1.5, due to changes in private sparse matrix functions that QuTiP also used. Improvements; ------------; - Add support for Scipy 1.5. (by **Jake Lishman**); - Improved speed of ``zcsr_inner``, which affects ``Qobj.overlap``. (by **Jake Lishman**); - Better error messages when installation requirements are not satisfied. (by **Eric Gigure**). Bug Fixes; ---------; - Fix ``zcsr_proj`` acting on matrices with unsorted indices. (by **Jake Lishman**); - Fix errors in Milstein's heterodyne. (by **Eric Gigure**); - Fix datatype bug in ``qutip.lattice`` module. (by **Boxi Li**); - Fix issues with ``eigh`` on Mac when using OpenBLAS. (by **Eric Gigure**). Developer Changes; -----------------; - Converted more of the codebase to PEP 8.; - Fix several instances of unsafe mutable default values and unsafe ``is`` comparisons. Version 4.5.1 (May 15, 2020); ++++++++++++++++++++++++++++. Improvements; ------------; - ``husimi`` and ``wigner`` now accept half-integer spin (by **maij**); - Better error messages for failed string coefficient compilation. (issue raised by **nohchangsuk**). Bug Fixes; ---------; - Safer naming for temporary files. (by **Eric Gigure**); - Fix ``clebsch`` function for half-integer (by **Thomas Walker**); - Fix ``randint``'s dtype to ``uint32`` for compatibility with Windows. (issue raised by **Boxi Li**); - Corrected stochastic's heterodyne's m_ops (by **eliegenois**); - Mac pool use spawn. (issue raised by **goerz**); - Fix typos in ``QobjEvo._shift``. (by **Eric Gigure**); - Fix warning on Travis CI. (by **Ivan Carvalho**). Deprecations; ------------; - ``qutip.graph`` functions will be deprecated in QuTiP 5.0 in favour of ``scipy.sparse.csgraph``. Developer Changes; -----------------; - Add Boxi Li to authors. (by **Alex Pitchford**);",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:96113,Safety,safe,safety,96113,"-Redfield Solver. - Qobj tidyup is now an order of magnitude faster. - Time-dependent codegen now generates output NumPy arrays faster. - Improved calculation for analytic coefficients in coherent states (Sebastian Kramer). - Input array to correlation FFT method now checked for validity. - Function-based time-dependent mesolve and sesolve routines now faster. - Codegen now makes sure that division is done in C, as opposed to Python. - Can now set different controls for a each timeslot in quantum optimization.; This allows time-varying controls to be used in pulse optimisation. Bug Fixes; ---------. - rcsolve importing old Odeoptions Class rather than Options. - Non-int issue in spin Q and Wigner functions. - Qobj's should tidyup before determining isherm. - Fixed time-dependent RHS function loading on Win. - Fixed several issues with compiling with Cython 0.26. - Liouvillian superoperators were hard setting isherm=True by default. - Fixed an issue with the solver safety checks when inputing a list with Python functions as time-dependence. - Fixed non-int issue in Wigner_cmap. - MKL solver error handling not working properly. Version 4.1.0 (March 10, 2017); ++++++++++++++++++++++++++++++. Improvements; ------------. *Core libraries*. - **MAJOR FEATURE**: QuTiP now works for Python 3.5+ on Windows using Visual Studio 2015. - **MAJOR FEATURE**: Cython and other low level code switched to C++ for MS Windows compatibility. - **MAJOR FEATURE**: Can now use interpolating cubic splines as time-dependent coefficients. - **MAJOR FEATURE**: Sparse matrix - vector multiplication now parallel using OPENMP. - Automatic tuning of OPENMP threading threshold. - Partial trace function is now up to 100x+ faster. - Hermitian verification now up to 100x+ faster. - Internal Qobj objects now created up to 60x faster. - Inplace conversion from COO -> CSR sparse formats (e.g. Memory efficiency improvement.). - Faster reverse Cuthill-Mckee and sparse one and inf norms. Bug Fixes; ---------.",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:97605,Safety,avoid,avoid,97605,". - **MAJOR FEATURE**: Can now use interpolating cubic splines as time-dependent coefficients. - **MAJOR FEATURE**: Sparse matrix - vector multiplication now parallel using OPENMP. - Automatic tuning of OPENMP threading threshold. - Partial trace function is now up to 100x+ faster. - Hermitian verification now up to 100x+ faster. - Internal Qobj objects now created up to 60x faster. - Inplace conversion from COO -> CSR sparse formats (e.g. Memory efficiency improvement.). - Faster reverse Cuthill-Mckee and sparse one and inf norms. Bug Fixes; ---------. - Cleanup of temp. Cython files now more robust and working under Windows. Version 4.0.2 (January 5, 2017); +++++++++++++++++++++++++++++++. Bug Fixes; ---------; - td files no longer left behind by correlation tests; - Various fast sparse fixes. Version 4.0.0 (December 22, 2016); +++++++++++++++++++++++++++++++++. Improvements; ------------; *Core libraries*. - **MAJOR FEATURE**: Fast sparse: New subclass of csr_matrix added that overrides commonly used methods to avoid certain checks that incurr execution cost. All Qobj.data now fast_csr_matrix; - HEOM performance enhancements; - spmv now faster; - mcsolve codegen further optimised. *Control modules*. - Time dependent drift (through list of pwc dynamics generators); - memory optimisation options provided for control.dynamics. Bug Fixes; ---------. - recompilation of pyx files on first import removed; - tau array in control.pulseoptim funcs now works. Version 3.2.0 (Never officially released); +++++++++++++++++++++++++++++++++++++++++. New Features; ------------. *Core libraries*. - **MAJOR FEATURE**: Non-Markovian solvers: Hierarchy (**Added by Neill Lambert**), Memory-Cascade, and Transfer-Tensor methods.; - **MAJOR FEATURE**: Default steady state solver now up to 100x faster using the Intel Pardiso library under the Anaconda and Intel Python distributions.; - The default Wigner function now uses a Clenshaw summation algorithm to evaluate a polynomial series that ",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:100717,Safety,avoid,avoided,100717,"nnes Feist**); - Q.transform now works properly for arrays directly from sp_eigs (or eig).; - Q.groundstate now checks for degeneracy.; - Added ``sinm`` and ``cosm`` methods to the Qobj class.; - Added ``charge`` and ``tunneling`` operators.; - Time-dependent Cython code is now easier to read and debug. *Control modules*. - The internal state / quantum operator data type can now be either Qobj or ndarray; Previous only ndarray was possible. This now opens up possibility of using Qobj methods in fidelity calculations; The attributes and functions that return these operators are now preceded by an underscore, to indicate that the data type could change depending on the configuration options.; In most cases these functions were for internal processing only anyway, and should have been 'private'.; Accessors to the properties that could be useful outside of the library have been added. These always return Qobj. If the internal operator data type is not Qobj, then there could be signicant overhead in the conversion, and so this should be avoided during pulse optimisation.; If custom sub-classes are developed that use Qobj properties and methods (e.g. partial trace), then it is very likely that it will be more efficient to set the internal data type to Qobj.; The internal operator data will be chosen automatically based on the size and sparsity of the dynamics generator. It can be forced by setting ``dynamics.oper_dtype = <type>``; Note this can be done by passing ``dyn_params={'oper_dtype':<type>}`` in any of the pulseoptim functions. Some other properties and methods were renamed at the same time. A full list is given here. - All modules; - function: ``set_log_level`` -> property: ``log_level``. - dynamics functions. - ``_init_lists`` now ``_init_evo``; - ``get_num_ctrls`` now property: ``num_ctrls``; - ``get_owd_evo_target`` now property: ``onto_evo_target``; - ``combine_dyn_gen`` now ``_combine_dyn_gen`` (no longer returns a value); - ``get_dyn_gen`` now ``_get_phased_d",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:103453,Safety,avoid,avoid,103453,"- tslotcomp functions. - ``get_timeslot_for_fidelity_calc`` now ``_get_timeslot_for_fidelity_calc``. *Miscellaneous*. - QuTiP Travis CI tests now use the Anaconda distribution.; - The ``about`` box and ipynb ``version_table`` now display addition system information.; - Updated Cython cleanup to remove depreciation warning in sysconfig.; - Updated ipynb_parallel to look for ``ipyparallel`` module in V4 of the notebooks. Bug Fixes; ---------; - Fixes for countstat and psuedo-inverse functions; - Fixed Qobj division tests on 32-bit systems.; - Removed extra call to Python in time-dependent Cython code.; - Fixed issue with repeated Bloch sphere saving.; - Fixed T_0 triplet state not normalized properly. (**Fixed by Eric Hontz**); - Simplified compiler flags (support for ARM systems).; - Fixed a decoding error in ``qload``.; - Fixed issue using complex.h math and np.kind_t variables.; - Corrected output states mismatch for ``ntraj=1`` in the mcf90 solver.; - Qobj data is now copied by default to avoid a bug in multiplication. (**Fixed by Richard Brierley**); - Fixed bug overwriting ``hardware_info`` in ``__init__``. (**Fixed by Johannes Feist**); - Restored ability to explicity set Q.isherm, Q.type, and Q.superrep.; - Fixed integer depreciation warnings from NumPy.; - Qobj * (dense vec) would result in a recursive loop.; - Fixed args=None -> args={} in correlation functions to be compatible with mesolve.; - Fixed depreciation warnings in mcsolve.; - Fixed neagtive only real parts in ``rand_ket``.; - Fixed a complicated list-cast-map-list antipattern in super operator reps. (**Fixed by Stefan Krastanov**); - Fixed incorrect ``isherm`` for ``sigmam`` spin operator.; - Fixed the dims when using ``final_state_output`` in ``mesolve`` and ``sesolve``. Version 3.1.0 (January 1, 2015); +++++++++++++++++++++++++++++++. New Features; ------------. - **MAJOR FEATURE**: New module for quantum control (qutip.control).; - **NAMESPACE CHANGE**: QuTiP no longer exports symbols from NumP",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:110413,Safety,avoid,avoiding,110413,"ction for generating (generalized) Lindblad dissipator; superoperators. - New functions for generating Bell states, and singlet and triplet states. - QuTiP no longer contains the demos GUI. The examples are now available on the; QuTiP web site. The ``qutip.gui`` module has been renamed to ``qutip.ui`` and; does no longer contain graphical UI elements. New text-based and HTML-based; progressbar classes. - Support for harmonic oscillator operators/states in a Fock state basis that; does not start from zero (e.g., in the range [M,N+1]). Support for; eliminating and extracting states from Qobj instances (e.g., removing one; state from a two-qubit system to obtain a three-level system). - Support for time-dependent Hamiltonian and Liouvillian callback functions that; depend on the instantaneous state, which for example can be used for solving; master equations with mean field terms. Improvements; ------------. - Restructured and optimized implementation of Qobj, which now has; significantly lower memory footprint due to avoiding excessive copying of; internal matrix data. - The classes ``OdeData``, ``Odeoptions``, ``Odeconfig`` are now called; ``Result``, ``Options``, and ``Config``, respectively, and are available in; the module `qutip.solver`. - The ``squeez`` function has been renamed to ``squeeze``. - Better support for sparse matrices when calculating propagators using the; ``propagator`` function. - Improved Bloch sphere. - Restructured and improved the module ``qutip.sparse``, which now only; operates directly on sparse matrices (not on Qobj instances). - Improved and simplified implement of the ``tensor`` function. - Improved performance, major code cleanup (including namespace changes),; and numerous bug fixes. - Benchmark scripts improved and restructured. - QuTiP is now using continuous integration tests (TravisCI). Version 2.2.0 (March 01, 2013); ++++++++++++++++++++++++++++++. New Features; ------------. - **Added Support for Windows**. - New Bloch3d class fo",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:26097,Security,access,accessible,26097,"``Qobj`` or directly from solver results with saved states. Package reorganization; ----------------------. - ``qutip.qip`` has been moved into its own package, qutip-qip. Once installed, qutip-qip is available as either ``qutip.qip`` or ``qutip_qip``. Some widely useful gates have been retained in ``qutip.gates``.; - ``qutip.control`` has been moved to qutip-qtrl and once installed qutip-qtrl is available as either ``qutip.control`` or ``qutip_qtrl``. Note that ``quitp_qtrl`` is provided primarily for backwards compatibility. Improvements to optimal control will take place in the new ``qutip_qoc`` package.; - ``qutip.lattice`` has been moved into its own package, qutip-lattice. It is available from `<https://github.com/qutip/qutip-lattice>`.; - ``qutip.sparse`` has been removed. It contained the old sparse matrix representation and is replaced by the new implementation in ``qutip.data``.; - ``qutip.piqs`` functions are no longer available from the ``qutip`` namespace. They are accessible from ``qutip.piqs`` instead. Miscellaneous; -------------. - Support has been added for 64-bit integer sparse matrix indices, allowing; sparse matrices with up to 2**63 rows and columns. This support needs to; be enabled at compilation time by calling ``setup.py`` and passing; ``--with-idxint-64``. Feature removals; ----------------. - Support for OpenMP has been removed. If there is enough demand and a good plan for how to organize it, OpenMP support may return in a future QuTiP release.; - The ``qutip.parfor`` function has been removed. Use ``qutip.parallel_map`` instead.; - ``qutip.graph`` has been removed and replaced by SciPy's graph functions.; - ``qutip.topology`` has been removed. It contained only one function ``berry_curvature``.; - The ``~/.qutip/qutiprc`` config file is no longer supported. It contained settings for the OpenMP support.; - Deprecate ``three_level_atom``; - Deprecate ``orbital``. Changes from QuTiP 5.0.0b1:; ---------------------------. Features; --------",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:50317,Security,access,accessible,50317," Removed ``load``. ``reset`` and ``save`` functions.; - Removed ``.debug``, ``.fortran``, ``.openmp_thresh``.; - New ``.compile`` stores the compilation options for compiled coefficients.; - New ``.core[""rtol""]`` core option gives the default relative tolerance used by QuTiP.; - The absolute tolerance setting ``.atol`` has been moved to ``.core[""atol""]``. Package reorganization; ----------------------. - ``qutip.qip`` has been moved into its own package, qutip-qip. Once installed, qutip-qip is available as either ``qutip.qip`` or ``qutip_qip``. Some widely useful gates have been retained in ``qutip.gates``.; - ``qutip.lattice`` has been moved into its own package, qutip-lattice. It is available from `<https://github.com/qutip/qutip-lattice>`.; - ``qutip.sparse`` has been removed. It contained the old sparse matrix representation and is replaced by the new implementation in ``qutip.data``.; - ``qutip.piqs`` functions are no longer available from the ``qutip`` namespace. They are accessible from ``qutip.piqs`` instead. Miscellaneous; -------------. - Support has been added for 64-bit integer sparse matrix indices, allowing; sparse matrices with up to 2**63 rows and columns. This support needs to; be enabled at compilation time by calling ``setup.py`` and passing; ``--with-idxint-64``. Feature removals; ----------------. - Support for OpenMP has been removed. If there is enough demand and a good plan for how to organize it, OpenMP support may return in a future QuTiP release.; - The ``qutip.parfor`` function has been removed. Use ``qutip.parallel_map`` instead.; - ``qutip.graph`` has been removed and replaced by SciPy's graph functions.; - ``qutip.topology`` has been removed. It contained only one function ``berry_curvature``.; - The ``~/.qutip/qutiprc`` config file is no longer supported. It contained settings for the OpenMP support. QuTiP 4.7.5 (2024-01-29); ========================. Patch release for QuTiP 4.7. It adds support for SciPy 1.12. Bug Fixes; ---------. -",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:1391,Testability,test,tests,1391,"drey Nikitin). QuTiP 5.0.3 (2024-06-20); ========================. Micro release to add support for numpy 2. Bug Fixes; ---------. - Bug Fix in Process Matrix Rendering. (#2400, by Anush Venkatakrishnan); - Fix steadystate permutation being reversed. (#2443); - Add parallelizing support for `vernN` methods with `mcsolve`. (#2454 by Utkarsh). Documentation; -------------. - Added `qutip.core.gates` to apidoc/functions.rst and a Gates section to guide-states.rst. (#2441, by alan-nala). Miscellaneous; -------------. - Add support for numpy 2 (#2421, #2457); - Add support for scipy 1.14 (#2469). QuTiP 5.0.2 (2024-05-16); ========================. Bug Fixes; ---------. - Use CSR as the default for expand_operator (#2380, by BoxiLi); - Fix import of the partial_transpose function.; Ensures that the negativity function can handle both kets and density operators as input. (#2371, by vikas-chaudhary-2802); - Ensure that end_condition of mcsolve result doesn't say target tolerance reached when it hasn't (#2382, by magzpavz); - Fix two bugs in steadystate floquet solver, and adjust tests to be sensitive to this issue. (#2393, by Neill Lambert). Documentation; -------------. - Correct a mistake in the doc (#2401, by PositroniumJS); - Fix #2156: Correct a sample of code in the doc (#2409, by PositroniumJS). Miscellaneous; -------------. - Better metadata management in operators creation functions (#2388); - Implicitly set minimum python version to 3.9 (#2413); - Qobj.__eq__ uses core's settings rtol. (#2425); - Only normalize solver states when the initial state is already normalized. (#2427). QuTiP 5.0.1 (2024-04-03); ========================. Patch update fixing small issues with v5.0.0 release. - Fix broken links in the documentation when migrating to readthedocs; - Fix readthedocs search feature; - Add setuptools to runtime compilation requirements; - Fix mcsolve documentation for open systems; - Fix OverFlowError in progress bars. QuTiP 5.0.0 (2024-03-26); =================",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:3737,Testability,test,testing,3737,"ss is used to; represent the time-dependent factors inside ``QobjEvo``. The solvers have been rewritten to work well with the new data layer; and the concept of ``Integrators`` which solve ODEs has been introduced.; In future, new data layers may provide their own ``Integrators``; specialized to their representation of the underlying data. Much of the user-facing API of QuTiP remains familiar, but there have; had to be many small breaking changes. If we can make changes to; easy migrating code from QuTiP 4 to QuTiP 5, please let us know. An extensive list of changes follows. Contributors; ------------. QuTiP 5 has been a large effort by many people over the last three years. In particular:. - Jake Lishman led the implementation of the new data layer and coefficients.; - Eric Gigure led the implementation of the new QobjEvo interface and solvers.; - Boxi Li led the updating of QuTiP's QIP support and the creation of ``qutip_qip``. Other members of the QuTiP Admin team have been heavily involved in reviewing,; testing and designing QuTiP 5:. - Alexander Pitchford; - Asier Galicia; - Nathan Shammah; - Shahnawaz Ahmed; - Neill Lambert; - Simon Cross; - Paul Menczel. Two Google Summer of Code contributors updated the tutorials and benchmarks to; QuTiP 5:. - Christian Staufenbiel updated many of the tutorials (`<https://github.com/qutip/qutip-tutorials/>`).; - Xavier Sproken update the benchmarks (`<https://github.com/qutip/qutip-benchmark/>`). During an internship at RIKEN, Patrick Hopf created a new quantum control method and; improved the existing methods interface:. - Patrick Hopf created new quantum control package (`<https://github.com/qutip/qutip-qoc/>`). Four experimental data layers backends were written either as part of Google Summer; of Code or as separate projects. While these are still alpha quality, they helped; significantly to test the data layer API:. - ``qutip-tensorflow``: a TensorFlow backend by Asier Galicia (`<https://github.com/qutip/qutip-tensorf",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:3959,Testability,benchmark,benchmarks,3959," new data layers may provide their own ``Integrators``; specialized to their representation of the underlying data. Much of the user-facing API of QuTiP remains familiar, but there have; had to be many small breaking changes. If we can make changes to; easy migrating code from QuTiP 4 to QuTiP 5, please let us know. An extensive list of changes follows. Contributors; ------------. QuTiP 5 has been a large effort by many people over the last three years. In particular:. - Jake Lishman led the implementation of the new data layer and coefficients.; - Eric Gigure led the implementation of the new QobjEvo interface and solvers.; - Boxi Li led the updating of QuTiP's QIP support and the creation of ``qutip_qip``. Other members of the QuTiP Admin team have been heavily involved in reviewing,; testing and designing QuTiP 5:. - Alexander Pitchford; - Asier Galicia; - Nathan Shammah; - Shahnawaz Ahmed; - Neill Lambert; - Simon Cross; - Paul Menczel. Two Google Summer of Code contributors updated the tutorials and benchmarks to; QuTiP 5:. - Christian Staufenbiel updated many of the tutorials (`<https://github.com/qutip/qutip-tutorials/>`).; - Xavier Sproken update the benchmarks (`<https://github.com/qutip/qutip-benchmark/>`). During an internship at RIKEN, Patrick Hopf created a new quantum control method and; improved the existing methods interface:. - Patrick Hopf created new quantum control package (`<https://github.com/qutip/qutip-qoc/>`). Four experimental data layers backends were written either as part of Google Summer; of Code or as separate projects. While these are still alpha quality, they helped; significantly to test the data layer API:. - ``qutip-tensorflow``: a TensorFlow backend by Asier Galicia (`<https://github.com/qutip/qutip-tensorflow>`); - ``qutip-cupy``: a CuPy GPU backend by Felipe Bivort Haiek (`<https://github.com/qutip/qutip-cupy/>`)`; - ``qutip-tensornetwork``: a TensorNetwork backend by Asier Galicia (`<https://github.com/qutip/qutip-tensornetwo",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:4116,Testability,benchmark,benchmarks,4116,"ere have; had to be many small breaking changes. If we can make changes to; easy migrating code from QuTiP 4 to QuTiP 5, please let us know. An extensive list of changes follows. Contributors; ------------. QuTiP 5 has been a large effort by many people over the last three years. In particular:. - Jake Lishman led the implementation of the new data layer and coefficients.; - Eric Gigure led the implementation of the new QobjEvo interface and solvers.; - Boxi Li led the updating of QuTiP's QIP support and the creation of ``qutip_qip``. Other members of the QuTiP Admin team have been heavily involved in reviewing,; testing and designing QuTiP 5:. - Alexander Pitchford; - Asier Galicia; - Nathan Shammah; - Shahnawaz Ahmed; - Neill Lambert; - Simon Cross; - Paul Menczel. Two Google Summer of Code contributors updated the tutorials and benchmarks to; QuTiP 5:. - Christian Staufenbiel updated many of the tutorials (`<https://github.com/qutip/qutip-tutorials/>`).; - Xavier Sproken update the benchmarks (`<https://github.com/qutip/qutip-benchmark/>`). During an internship at RIKEN, Patrick Hopf created a new quantum control method and; improved the existing methods interface:. - Patrick Hopf created new quantum control package (`<https://github.com/qutip/qutip-qoc/>`). Four experimental data layers backends were written either as part of Google Summer; of Code or as separate projects. While these are still alpha quality, they helped; significantly to test the data layer API:. - ``qutip-tensorflow``: a TensorFlow backend by Asier Galicia (`<https://github.com/qutip/qutip-tensorflow>`); - ``qutip-cupy``: a CuPy GPU backend by Felipe Bivort Haiek (`<https://github.com/qutip/qutip-cupy/>`)`; - ``qutip-tensornetwork``: a TensorNetwork backend by Asier Galicia (`<https://github.com/qutip/qutip-tensornetwork>`); - ``qutip-jax``: a JAX backend by Eric Gigure (`<https://github.com/qutip/qutip-jax/>`). Finally, Yuji Tamakoshi updated the visualization function and added animation; f",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:4161,Testability,benchmark,benchmark,4161,"es. If we can make changes to; easy migrating code from QuTiP 4 to QuTiP 5, please let us know. An extensive list of changes follows. Contributors; ------------. QuTiP 5 has been a large effort by many people over the last three years. In particular:. - Jake Lishman led the implementation of the new data layer and coefficients.; - Eric Gigure led the implementation of the new QobjEvo interface and solvers.; - Boxi Li led the updating of QuTiP's QIP support and the creation of ``qutip_qip``. Other members of the QuTiP Admin team have been heavily involved in reviewing,; testing and designing QuTiP 5:. - Alexander Pitchford; - Asier Galicia; - Nathan Shammah; - Shahnawaz Ahmed; - Neill Lambert; - Simon Cross; - Paul Menczel. Two Google Summer of Code contributors updated the tutorials and benchmarks to; QuTiP 5:. - Christian Staufenbiel updated many of the tutorials (`<https://github.com/qutip/qutip-tutorials/>`).; - Xavier Sproken update the benchmarks (`<https://github.com/qutip/qutip-benchmark/>`). During an internship at RIKEN, Patrick Hopf created a new quantum control method and; improved the existing methods interface:. - Patrick Hopf created new quantum control package (`<https://github.com/qutip/qutip-qoc/>`). Four experimental data layers backends were written either as part of Google Summer; of Code or as separate projects. While these are still alpha quality, they helped; significantly to test the data layer API:. - ``qutip-tensorflow``: a TensorFlow backend by Asier Galicia (`<https://github.com/qutip/qutip-tensorflow>`); - ``qutip-cupy``: a CuPy GPU backend by Felipe Bivort Haiek (`<https://github.com/qutip/qutip-cupy/>`)`; - ``qutip-tensornetwork``: a TensorNetwork backend by Asier Galicia (`<https://github.com/qutip/qutip-tensornetwork>`); - ``qutip-jax``: a JAX backend by Eric Gigure (`<https://github.com/qutip/qutip-jax/>`). Finally, Yuji Tamakoshi updated the visualization function and added animation; functions as part of Google Summer of Code pr",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:4583,Testability,test,test,4583," solvers.; - Boxi Li led the updating of QuTiP's QIP support and the creation of ``qutip_qip``. Other members of the QuTiP Admin team have been heavily involved in reviewing,; testing and designing QuTiP 5:. - Alexander Pitchford; - Asier Galicia; - Nathan Shammah; - Shahnawaz Ahmed; - Neill Lambert; - Simon Cross; - Paul Menczel. Two Google Summer of Code contributors updated the tutorials and benchmarks to; QuTiP 5:. - Christian Staufenbiel updated many of the tutorials (`<https://github.com/qutip/qutip-tutorials/>`).; - Xavier Sproken update the benchmarks (`<https://github.com/qutip/qutip-benchmark/>`). During an internship at RIKEN, Patrick Hopf created a new quantum control method and; improved the existing methods interface:. - Patrick Hopf created new quantum control package (`<https://github.com/qutip/qutip-qoc/>`). Four experimental data layers backends were written either as part of Google Summer; of Code or as separate projects. While these are still alpha quality, they helped; significantly to test the data layer API:. - ``qutip-tensorflow``: a TensorFlow backend by Asier Galicia (`<https://github.com/qutip/qutip-tensorflow>`); - ``qutip-cupy``: a CuPy GPU backend by Felipe Bivort Haiek (`<https://github.com/qutip/qutip-cupy/>`)`; - ``qutip-tensornetwork``: a TensorNetwork backend by Asier Galicia (`<https://github.com/qutip/qutip-tensornetwork>`); - ``qutip-jax``: a JAX backend by Eric Gigure (`<https://github.com/qutip/qutip-jax/>`). Finally, Yuji Tamakoshi updated the visualization function and added animation; functions as part of Google Summer of Code project. We have also had many other contributors, whose specific contributions are; detailed below:. - Pieter Eendebak (updated the required SciPy to 1.5+, `#1982 <https://github.com/qutip/qutip/pull/1982>`).; - Pieter Eendebak (reduced import times by setting logger names, `#1981 <https://github.com/qutip/qutip/pull/1981>`); - Pieter Eendebak (Allow scipy 1.12 to be used with qutip, `#2354 <https://",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:5420,Testability,log,logger,5420,"tal data layers backends were written either as part of Google Summer; of Code or as separate projects. While these are still alpha quality, they helped; significantly to test the data layer API:. - ``qutip-tensorflow``: a TensorFlow backend by Asier Galicia (`<https://github.com/qutip/qutip-tensorflow>`); - ``qutip-cupy``: a CuPy GPU backend by Felipe Bivort Haiek (`<https://github.com/qutip/qutip-cupy/>`)`; - ``qutip-tensornetwork``: a TensorNetwork backend by Asier Galicia (`<https://github.com/qutip/qutip-tensornetwork>`); - ``qutip-jax``: a JAX backend by Eric Gigure (`<https://github.com/qutip/qutip-jax/>`). Finally, Yuji Tamakoshi updated the visualization function and added animation; functions as part of Google Summer of Code project. We have also had many other contributors, whose specific contributions are; detailed below:. - Pieter Eendebak (updated the required SciPy to 1.5+, `#1982 <https://github.com/qutip/qutip/pull/1982>`).; - Pieter Eendebak (reduced import times by setting logger names, `#1981 <https://github.com/qutip/qutip/pull/1981>`); - Pieter Eendebak (Allow scipy 1.12 to be used with qutip, `#2354 <https://github.com/qutip/qutip/pull/2354>`); - Xavier Sproken (included C header files in the source distribution, `#1971 <https://github.com/qutip/qutip/pull/1971>`); - Christian Staufenbiel (added support for multiple collapse operators to the Floquet solver, `#1962 <https://github.com/qutip/qutip/pull/1962>`); - Christian Staufenbiel (fixed the basis used in the Floquet Master Equation solver, `#1952 <https://github.com/qutip/qutip/pull/1952>`); - Christian Staufenbiel (allowed the ``bloch_redfield_tensor`` function to accept strings and callables for `a_ops`, `#1951 <https://github.com/qutip/qutip/pull/1951>`); - Christian Staufenbiel (Add a guide on Superoperators, Pauli Basis and Channel Contraction, `#1984 <https://github.com/qutip/qutip/pull/1984>`); - Henrique Silvro (allowed ``qutip_qip`` to be imported as ``qutip.qip``, `#1920 <https:",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:11333,Testability,log,logm,11333,"erlying data type instead of a SciPy-like sparse matrix.; The operations available in ``qutip.core.data`` may be used on ``.data``,; regardless of the data type.; - ``Qobj`` with different data types may be mixed in arithmetic and other; operations. A sensible output type will be automatically determined.; - The new ``.to(...)`` method may be used to convert a ``Qobj`` from one data type; to another. E.g. ``.to(""dense"")`` will convert to the dense representation and; ``.to(""csr"")`` will convert to the sparse type.; - Many ``Qobj`` methods and methods that create ``Qobj`` now accepted a ``dtype``; parameter that allows the data type of the returned ``Qobj`` to specified.; - The new ``&`` operator may be used to obtain the tensor product.; - The new ``@`` operator may be used to obtain the matrix / operator product.; ``bar @ ket`` returns a scalar.; - The new ``.contract()`` method will collapse 1D subspaces of the dimensions of; the ``Qobj``.; - The new ``.logm()`` method returns the matrix logarithm of an operator.; - The methods ``.set_data``, ``.get_data``, ``.extract_state``, ``.eliminate_states``,; ``.evaluate`` and ``.check_isunitary`` have been removed.; - The property ``dtype`` return the representation of the data used.; - The new ``data_as`` allow to obtain the data as a common python formats:; numpy array, scipy sparse matrix, JAX Array, etc. QobjEvo changes; ---------------. The ``QobjEvo`` type for storing time-dependent quantum objects has been; significantly expanded, standardized and extended. The time-dependent; coefficients are now represented using a new ``Coefficient`` type that; may be independently created and manipulated if required. Some highlights:. - The ``.compile()`` method has been removed. Coefficients specified as; strings are automatically compiled if possible and the compilation is; cached across different Python runs and instances.; - Mixing coefficient types within a single ``Qobj`` is now supported.; - Many new attributes were adde",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:11368,Testability,log,logarithm,11368,"erlying data type instead of a SciPy-like sparse matrix.; The operations available in ``qutip.core.data`` may be used on ``.data``,; regardless of the data type.; - ``Qobj`` with different data types may be mixed in arithmetic and other; operations. A sensible output type will be automatically determined.; - The new ``.to(...)`` method may be used to convert a ``Qobj`` from one data type; to another. E.g. ``.to(""dense"")`` will convert to the dense representation and; ``.to(""csr"")`` will convert to the sparse type.; - Many ``Qobj`` methods and methods that create ``Qobj`` now accepted a ``dtype``; parameter that allows the data type of the returned ``Qobj`` to specified.; - The new ``&`` operator may be used to obtain the tensor product.; - The new ``@`` operator may be used to obtain the matrix / operator product.; ``bar @ ket`` returns a scalar.; - The new ``.contract()`` method will collapse 1D subspaces of the dimensions of; the ``Qobj``.; - The new ``.logm()`` method returns the matrix logarithm of an operator.; - The methods ``.set_data``, ``.get_data``, ``.extract_state``, ``.eliminate_states``,; ``.evaluate`` and ``.check_isunitary`` have been removed.; - The property ``dtype`` return the representation of the data used.; - The new ``data_as`` allow to obtain the data as a common python formats:; numpy array, scipy sparse matrix, JAX Array, etc. QobjEvo changes; ---------------. The ``QobjEvo`` type for storing time-dependent quantum objects has been; significantly expanded, standardized and extended. The time-dependent; coefficients are now represented using a new ``Coefficient`` type that; may be independently created and manipulated if required. Some highlights:. - The ``.compile()`` method has been removed. Coefficients specified as; strings are automatically compiled if possible and the compilation is; cached across different Python runs and instances.; - Mixing coefficient types within a single ``Qobj`` is now supported.; - Many new attributes were adde",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:20562,Testability,log,logging,20562," must now be vectorized; (i.e. accept and return numpy arrays for frequencies and densities) and; must accept negative frequence (i.e. usually include a ``w > 0`` factor; so that the returned densities are zero for negative frequencies).; - The number of sidebands to keep, ``kmax`` may only be supplied when using; the ``FMESolver``; - The ``Tsteps`` parameter has been removed from both ``fsesolve`` and; ``fmmesolve``. The ``precompute`` option to ``FloquetBasis`` may be used; instead. Evolution of State Solver (essovle):. - The function ``essolve`` has been removed. Use the ``diag`` integration; method with ``sesolve`` or ``mesolve`` instead. Steady-state solvers (steadystate module):. - The ``method`` parameter and ``solver`` parameters have been separated. Previously; they were mixed together in the ``method`` parameter.; - The previous options are now passed as parameters to the steady state; solver and mostly passed through to the underlying SciPy functions.; - The logging and statistics have been removed. Correlation functions (correlation module):. - A new ``correlation_3op`` function has been added. It supports ``MESolver``; or ``BRMESolver``.; - The ``correlation``, ``correlation_4op``, and ``correlation_ss`` functions have been; removed.; - Support for calculating correlation with ``mcsolve`` has been removed. Propagators (propagator module):. - A class interface, ``qutip.Propagator``, has been added for propagators.; - Propagation of time-dependent systems is now supported using ``QobjEvo``.; - The ``unitary_mode`` and ``parallel`` options have been removed. Correlation spectra (spectrum module):. - The functions ``spectrum_ss`` and ``spectrum_pi`` have been removed and; are now internal functions.; - The ``use_pinv`` parameter for ``spectrum`` has been removed and the; functionality merged into the ``solver`` parameter. Use ``solver=""pi""``; instead. Hierarchical Equation of Motion Solver (HEOM). - Updated the solver to use the new QuTiP integrators and dat",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:28437,Testability,test,tests,28437,"_distribution() to specify parameters for wigner(). (#2057, by Kosuke Mizuno); - Restore feedback to solvers (#2210); - Added mpi_pmap, which uses the mpi4py module to run computations in parallel through the MPI interface. (#2296, by Paul); - Only pre-compute density matrices if keep_runs_results is False (#2303, by Matt Ord). Bug Fixes; ---------. - Add the possibility to customize point colors as in V4 and fix point plot behavior for 'l' style (#1974, by Daniel Moreno Galn); - Disabled broken ""improved sampling"" for `nm_mcsolve`. (#2234, by Paul); - Fixed result objects storing a reference to the solver through options._feedback. (#2262, by Paul); - Fixed simdiag not returning orthonormal eigenvectors. (#2269, by Sola85); - Fix LaTeX display of Qobj state in Jupyter cell outputs (#2272, by Edward Thomas); - Improved behavior of `parallel_map` and `loky_pmap` in the case of timeouts, errors or keyboard interrupts (#2280, by Paul); - Ignore deprecation warnings from cython 0.29.X in tests. (#2288); - Fixed two problems with the steady_state() solver in the HEOM method. (#2333). Miscellaneous; -------------. - Improve fidelity doc-string (#2257); - Improve documentation in guide/dynamics (#2271); - Improve states and operator parameters documentation. (#2289); - Rework `kraus_to_choi` making it faster (#2284, by Bogdan Reznychenko); - Remove Bloch3D: redundant to Bloch (#2306); - Allow tests to run without matplotlib and ipython. (#2311); - Add too small step warnings in fixed dt SODE solver (#2313); - Add `dtype` to `Qobj` and `QobjEvo` (#2325); - Fix typos in `expect` documentation (#2331, by gabbence95); - Allow measurement functions to support degenerate operators. (#2342). QuTiP 5.0.0a2 (2023-09-06); ==========================. Features; --------. - Add support for different spectra types for bloch_redfield_tensor (#1951); - Improve qutip import times by setting logger names explicitly. (#1981, by Pieter Eendebak); - Change the order of parameters in expand_ope",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:28847,Testability,test,tests,28847,"ossibility to customize point colors as in V4 and fix point plot behavior for 'l' style (#1974, by Daniel Moreno Galn); - Disabled broken ""improved sampling"" for `nm_mcsolve`. (#2234, by Paul); - Fixed result objects storing a reference to the solver through options._feedback. (#2262, by Paul); - Fixed simdiag not returning orthonormal eigenvectors. (#2269, by Sola85); - Fix LaTeX display of Qobj state in Jupyter cell outputs (#2272, by Edward Thomas); - Improved behavior of `parallel_map` and `loky_pmap` in the case of timeouts, errors or keyboard interrupts (#2280, by Paul); - Ignore deprecation warnings from cython 0.29.X in tests. (#2288); - Fixed two problems with the steady_state() solver in the HEOM method. (#2333). Miscellaneous; -------------. - Improve fidelity doc-string (#2257); - Improve documentation in guide/dynamics (#2271); - Improve states and operator parameters documentation. (#2289); - Rework `kraus_to_choi` making it faster (#2284, by Bogdan Reznychenko); - Remove Bloch3D: redundant to Bloch (#2306); - Allow tests to run without matplotlib and ipython. (#2311); - Add too small step warnings in fixed dt SODE solver (#2313); - Add `dtype` to `Qobj` and `QobjEvo` (#2325); - Fix typos in `expect` documentation (#2331, by gabbence95); - Allow measurement functions to support degenerate operators. (#2342). QuTiP 5.0.0a2 (2023-09-06); ==========================. Features; --------. - Add support for different spectra types for bloch_redfield_tensor (#1951); - Improve qutip import times by setting logger names explicitly. (#1981, by Pieter Eendebak); - Change the order of parameters in expand_operator (#1991); - Add `svn` and `solve` to dispatched (#2002); - Added nm_mcsolve to provide support for Monte-Carlo simulations of master equations with possibly negative rates. The method implemented here is described in arXiv:2209.08958 [quant-ph]. (#2070 by pmenczel); - Add support for combining bosonic and fermionic HEOM baths (#2089); - Added __repr__ to ",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:29338,Testability,log,logger,29338,"map` and `loky_pmap` in the case of timeouts, errors or keyboard interrupts (#2280, by Paul); - Ignore deprecation warnings from cython 0.29.X in tests. (#2288); - Fixed two problems with the steady_state() solver in the HEOM method. (#2333). Miscellaneous; -------------. - Improve fidelity doc-string (#2257); - Improve documentation in guide/dynamics (#2271); - Improve states and operator parameters documentation. (#2289); - Rework `kraus_to_choi` making it faster (#2284, by Bogdan Reznychenko); - Remove Bloch3D: redundant to Bloch (#2306); - Allow tests to run without matplotlib and ipython. (#2311); - Add too small step warnings in fixed dt SODE solver (#2313); - Add `dtype` to `Qobj` and `QobjEvo` (#2325); - Fix typos in `expect` documentation (#2331, by gabbence95); - Allow measurement functions to support degenerate operators. (#2342). QuTiP 5.0.0a2 (2023-09-06); ==========================. Features; --------. - Add support for different spectra types for bloch_redfield_tensor (#1951); - Improve qutip import times by setting logger names explicitly. (#1981, by Pieter Eendebak); - Change the order of parameters in expand_operator (#1991); - Add `svn` and `solve` to dispatched (#2002); - Added nm_mcsolve to provide support for Monte-Carlo simulations of master equations with possibly negative rates. The method implemented here is described in arXiv:2209.08958 [quant-ph]. (#2070 by pmenczel); - Add support for combining bosonic and fermionic HEOM baths (#2089); - Added __repr__ to QobjEvo (#2111 by lklivingstone); - Improve print(qutip.settings) by make it shorter (#2113 by tamakoshi2001); - Create the `trace_oper_ket` operation (#2126); - Speed up the construction of the RHS of the HEOM solver by a factor of 4x by converting the final step to Cython. (#2128); - Rewrite the stochastic solver to use the v5 solver interface. (#2131); - Add `Qobj.get` to extract underlying data in original format. (#2141); - Add qeye_like and qzero_like (#2153); - Add capacity to di",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:32957,Testability,test,test,32957," of MESolver, SMESolver, SSESolver, NonMarkovianMCSolver (#2167 by Cristian Emiliano Godinez Ramirez); - Corrected grammar in Bloch-Redfield master equation documentation (#2174 by Andrey Rakhubovsky). Miscellaneous; -------------. - Update scipy version requirement to 1.5+ (#1982 by Pieter Eendebak); - Added __all__ to qutip/measurements.py and qutip/core/semidefinite.py (#2103 by Rushiraj Gadhvi); - Restore towncrier check (#2105); - qutip.ipynbtools.version_table() can now be called without Cython installed (#2110 by Rushiraj Gadhvi); - Moved HTMLProgressBar from qutip/ipynbtools.py to qutip/ui/progressbar.py (#2112 by Harsh Khilawala); - Added new argument bc_type to take boundary conditions when creating QobjEvo (#2114 by Avatar Srinidhi P V ); - Remove Windows build warning suppression. (#2119); - Optimize dispatcher by dispatching on positional only args. (#2135); - Clean semidefinite (#2138); - Migrate `transfertensor.py` to solver (#2142); - Add a test for progress_bar (#2150); - Enable cython 3 (#2151); - Added tests for visualization.py (#2192 by Yuji Tamakoshi); - Sorted arguments of sphereplot so that the order is similar to those of plot_spin_distribution (#2219 by Yuji Tamakoshi). Version 5.0.0a1 (February 7, 2023); ++++++++++++++++++++++++++++++++++. QuTiP 5 is a redesign of many of the core components of QuTiP (``Qobj``,; ``QobjEvo``, solvers) to make them more consistent and more flexible. ``Qobj`` may now be stored in either sparse or dense representations,; and the two may be mixed sensibly as needed. ``QobjEvo`` is now used; consistently throughout QuTiP, and the implementation has been; substantially cleaned up. A new ``Coefficient`` class is used to; represent the time-dependent factors inside ``QobjEvo``. The solvers have been rewritten to work well with the new data layer; and the concept of ``Integrators`` which solve ODEs has been introduced.; In future, new data layers may provide their own ``Integrators``; specialized to their representat",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:33023,Testability,test,tests,33023," of MESolver, SMESolver, SSESolver, NonMarkovianMCSolver (#2167 by Cristian Emiliano Godinez Ramirez); - Corrected grammar in Bloch-Redfield master equation documentation (#2174 by Andrey Rakhubovsky). Miscellaneous; -------------. - Update scipy version requirement to 1.5+ (#1982 by Pieter Eendebak); - Added __all__ to qutip/measurements.py and qutip/core/semidefinite.py (#2103 by Rushiraj Gadhvi); - Restore towncrier check (#2105); - qutip.ipynbtools.version_table() can now be called without Cython installed (#2110 by Rushiraj Gadhvi); - Moved HTMLProgressBar from qutip/ipynbtools.py to qutip/ui/progressbar.py (#2112 by Harsh Khilawala); - Added new argument bc_type to take boundary conditions when creating QobjEvo (#2114 by Avatar Srinidhi P V ); - Remove Windows build warning suppression. (#2119); - Optimize dispatcher by dispatching on positional only args. (#2135); - Clean semidefinite (#2138); - Migrate `transfertensor.py` to solver (#2142); - Add a test for progress_bar (#2150); - Enable cython 3 (#2151); - Added tests for visualization.py (#2192 by Yuji Tamakoshi); - Sorted arguments of sphereplot so that the order is similar to those of plot_spin_distribution (#2219 by Yuji Tamakoshi). Version 5.0.0a1 (February 7, 2023); ++++++++++++++++++++++++++++++++++. QuTiP 5 is a redesign of many of the core components of QuTiP (``Qobj``,; ``QobjEvo``, solvers) to make them more consistent and more flexible. ``Qobj`` may now be stored in either sparse or dense representations,; and the two may be mixed sensibly as needed. ``QobjEvo`` is now used; consistently throughout QuTiP, and the implementation has been; substantially cleaned up. A new ``Coefficient`` class is used to; represent the time-dependent factors inside ``QobjEvo``. The solvers have been rewritten to work well with the new data layer; and the concept of ``Integrators`` which solve ODEs has been introduced.; In future, new data layers may provide their own ``Integrators``; specialized to their representat",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:34699,Testability,test,testing,34699,"s is used to; represent the time-dependent factors inside ``QobjEvo``. The solvers have been rewritten to work well with the new data layer; and the concept of ``Integrators`` which solve ODEs has been introduced.; In future, new data layers may provide their own ``Integrators``; specialized to their representation of the underlying data. Much of the user-facing API of QuTiP remains familiar, but there have; had to be many small breaking changes. If we can make changes to; easy migrating code from QuTiP 4 to QuTiP 5, please let us know. Any extensive list of changes follows. Contributors; ------------. QuTiP 5 has been a large effort by many people over the last three years. In particular:. - Jake Lishman led the implementation of the new data layer and coefficients.; - Eric Gigure led the implementation of the new QobjEvo interface and solvers.; - Boxi Li led the updating of QuTiP's QIP support and the creation of ``qutip_qip``. Other members of the QuTiP Admin team have been heavily involved in reviewing,; testing and designing QuTiP 5:. - Alexander Pitchford; - Asier Galicia; - Nathan Shammah; - Shahnawaz Ahmed; - Neill Lambert; - Simon Cross. Two Google Summer of Code contributors updated the tutorials and benchmarks to; QuTiP 5:. - Christian Staufenbiel updated many of the tutorials (`<https://github.com/qutip/qutip-tutorials/>`).; - Xavier Sproken update the benchmarks (`<https://github.com/qutip/qutip-benchmark/>`). Four experimental data layers backends were written either as part of Google Summer; of Code or as separate projects. While these are still alpha quality, the helped; significantly to test the data layer API:. - ``qutip-tensorflow``: a TensorFlow backend by Asier Galicia (`<https://github.com/qutip/qutip-tensorflow>`); - ``qutip-cupy``: a CuPy GPU backend by Felipe Bivort Haiek (`<https://github.com/qutip/qutip-cupy/>`)`; - ``qutip-tensornetwork``: a TensorNetwork backend by Asier Galicia (`<https://github.com/qutip/qutip-tensornetwork>`); - ``qu",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:34905,Testability,benchmark,benchmarks,34905,"ed.; In future, new data layers may provide their own ``Integrators``; specialized to their representation of the underlying data. Much of the user-facing API of QuTiP remains familiar, but there have; had to be many small breaking changes. If we can make changes to; easy migrating code from QuTiP 4 to QuTiP 5, please let us know. Any extensive list of changes follows. Contributors; ------------. QuTiP 5 has been a large effort by many people over the last three years. In particular:. - Jake Lishman led the implementation of the new data layer and coefficients.; - Eric Gigure led the implementation of the new QobjEvo interface and solvers.; - Boxi Li led the updating of QuTiP's QIP support and the creation of ``qutip_qip``. Other members of the QuTiP Admin team have been heavily involved in reviewing,; testing and designing QuTiP 5:. - Alexander Pitchford; - Asier Galicia; - Nathan Shammah; - Shahnawaz Ahmed; - Neill Lambert; - Simon Cross. Two Google Summer of Code contributors updated the tutorials and benchmarks to; QuTiP 5:. - Christian Staufenbiel updated many of the tutorials (`<https://github.com/qutip/qutip-tutorials/>`).; - Xavier Sproken update the benchmarks (`<https://github.com/qutip/qutip-benchmark/>`). Four experimental data layers backends were written either as part of Google Summer; of Code or as separate projects. While these are still alpha quality, the helped; significantly to test the data layer API:. - ``qutip-tensorflow``: a TensorFlow backend by Asier Galicia (`<https://github.com/qutip/qutip-tensorflow>`); - ``qutip-cupy``: a CuPy GPU backend by Felipe Bivort Haiek (`<https://github.com/qutip/qutip-cupy/>`)`; - ``qutip-tensornetwork``: a TensorNetwork backend by Asier Galicia (`<https://github.com/qutip/qutip-tensornetwork>`); - ``qutip-jax``: a JAX backend by Eric Gigure (`<https://github.com/qutip/qutip-jax/>`). We have also had many other contributors, whose specific contributions are; detailed below:. - Pieter Eendebak (updated the re",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:35062,Testability,benchmark,benchmarks,35062,"amiliar, but there have; had to be many small breaking changes. If we can make changes to; easy migrating code from QuTiP 4 to QuTiP 5, please let us know. Any extensive list of changes follows. Contributors; ------------. QuTiP 5 has been a large effort by many people over the last three years. In particular:. - Jake Lishman led the implementation of the new data layer and coefficients.; - Eric Gigure led the implementation of the new QobjEvo interface and solvers.; - Boxi Li led the updating of QuTiP's QIP support and the creation of ``qutip_qip``. Other members of the QuTiP Admin team have been heavily involved in reviewing,; testing and designing QuTiP 5:. - Alexander Pitchford; - Asier Galicia; - Nathan Shammah; - Shahnawaz Ahmed; - Neill Lambert; - Simon Cross. Two Google Summer of Code contributors updated the tutorials and benchmarks to; QuTiP 5:. - Christian Staufenbiel updated many of the tutorials (`<https://github.com/qutip/qutip-tutorials/>`).; - Xavier Sproken update the benchmarks (`<https://github.com/qutip/qutip-benchmark/>`). Four experimental data layers backends were written either as part of Google Summer; of Code or as separate projects. While these are still alpha quality, the helped; significantly to test the data layer API:. - ``qutip-tensorflow``: a TensorFlow backend by Asier Galicia (`<https://github.com/qutip/qutip-tensorflow>`); - ``qutip-cupy``: a CuPy GPU backend by Felipe Bivort Haiek (`<https://github.com/qutip/qutip-cupy/>`)`; - ``qutip-tensornetwork``: a TensorNetwork backend by Asier Galicia (`<https://github.com/qutip/qutip-tensornetwork>`); - ``qutip-jax``: a JAX backend by Eric Gigure (`<https://github.com/qutip/qutip-jax/>`). We have also had many other contributors, whose specific contributions are; detailed below:. - Pieter Eendebak (updated the required SciPy to 1.4+, `#1982 <https://github.com/qutip/qutip/pull/1982>`).; - Pieter Eendebak (reduced import times by setting logger names, `#1981 <https://github.com/qutip/quti",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:35107,Testability,benchmark,benchmark,35107," breaking changes. If we can make changes to; easy migrating code from QuTiP 4 to QuTiP 5, please let us know. Any extensive list of changes follows. Contributors; ------------. QuTiP 5 has been a large effort by many people over the last three years. In particular:. - Jake Lishman led the implementation of the new data layer and coefficients.; - Eric Gigure led the implementation of the new QobjEvo interface and solvers.; - Boxi Li led the updating of QuTiP's QIP support and the creation of ``qutip_qip``. Other members of the QuTiP Admin team have been heavily involved in reviewing,; testing and designing QuTiP 5:. - Alexander Pitchford; - Asier Galicia; - Nathan Shammah; - Shahnawaz Ahmed; - Neill Lambert; - Simon Cross. Two Google Summer of Code contributors updated the tutorials and benchmarks to; QuTiP 5:. - Christian Staufenbiel updated many of the tutorials (`<https://github.com/qutip/qutip-tutorials/>`).; - Xavier Sproken update the benchmarks (`<https://github.com/qutip/qutip-benchmark/>`). Four experimental data layers backends were written either as part of Google Summer; of Code or as separate projects. While these are still alpha quality, the helped; significantly to test the data layer API:. - ``qutip-tensorflow``: a TensorFlow backend by Asier Galicia (`<https://github.com/qutip/qutip-tensorflow>`); - ``qutip-cupy``: a CuPy GPU backend by Felipe Bivort Haiek (`<https://github.com/qutip/qutip-cupy/>`)`; - ``qutip-tensornetwork``: a TensorNetwork backend by Asier Galicia (`<https://github.com/qutip/qutip-tensornetwork>`); - ``qutip-jax``: a JAX backend by Eric Gigure (`<https://github.com/qutip/qutip-jax/>`). We have also had many other contributors, whose specific contributions are; detailed below:. - Pieter Eendebak (updated the required SciPy to 1.4+, `#1982 <https://github.com/qutip/qutip/pull/1982>`).; - Pieter Eendebak (reduced import times by setting logger names, `#1981 <https://github.com/qutip/qutip/pull/1981>`); - Xavier Sproken (included C",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:35306,Testability,test,test,35306,"uTiP 5 has been a large effort by many people over the last three years. In particular:. - Jake Lishman led the implementation of the new data layer and coefficients.; - Eric Gigure led the implementation of the new QobjEvo interface and solvers.; - Boxi Li led the updating of QuTiP's QIP support and the creation of ``qutip_qip``. Other members of the QuTiP Admin team have been heavily involved in reviewing,; testing and designing QuTiP 5:. - Alexander Pitchford; - Asier Galicia; - Nathan Shammah; - Shahnawaz Ahmed; - Neill Lambert; - Simon Cross. Two Google Summer of Code contributors updated the tutorials and benchmarks to; QuTiP 5:. - Christian Staufenbiel updated many of the tutorials (`<https://github.com/qutip/qutip-tutorials/>`).; - Xavier Sproken update the benchmarks (`<https://github.com/qutip/qutip-benchmark/>`). Four experimental data layers backends were written either as part of Google Summer; of Code or as separate projects. While these are still alpha quality, the helped; significantly to test the data layer API:. - ``qutip-tensorflow``: a TensorFlow backend by Asier Galicia (`<https://github.com/qutip/qutip-tensorflow>`); - ``qutip-cupy``: a CuPy GPU backend by Felipe Bivort Haiek (`<https://github.com/qutip/qutip-cupy/>`)`; - ``qutip-tensornetwork``: a TensorNetwork backend by Asier Galicia (`<https://github.com/qutip/qutip-tensornetwork>`); - ``qutip-jax``: a JAX backend by Eric Gigure (`<https://github.com/qutip/qutip-jax/>`). We have also had many other contributors, whose specific contributions are; detailed below:. - Pieter Eendebak (updated the required SciPy to 1.4+, `#1982 <https://github.com/qutip/qutip/pull/1982>`).; - Pieter Eendebak (reduced import times by setting logger names, `#1981 <https://github.com/qutip/qutip/pull/1981>`); - Xavier Sproken (included C header files in the source distribution, `#1971 <https://github.com/qutip/qutip/pull/1971>`); - Christian Staufenbiel (added support for multiple collapse operators to the Floque",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:36011,Testability,log,logger,36011,"om/qutip/qutip-tutorials/>`).; - Xavier Sproken update the benchmarks (`<https://github.com/qutip/qutip-benchmark/>`). Four experimental data layers backends were written either as part of Google Summer; of Code or as separate projects. While these are still alpha quality, the helped; significantly to test the data layer API:. - ``qutip-tensorflow``: a TensorFlow backend by Asier Galicia (`<https://github.com/qutip/qutip-tensorflow>`); - ``qutip-cupy``: a CuPy GPU backend by Felipe Bivort Haiek (`<https://github.com/qutip/qutip-cupy/>`)`; - ``qutip-tensornetwork``: a TensorNetwork backend by Asier Galicia (`<https://github.com/qutip/qutip-tensornetwork>`); - ``qutip-jax``: a JAX backend by Eric Gigure (`<https://github.com/qutip/qutip-jax/>`). We have also had many other contributors, whose specific contributions are; detailed below:. - Pieter Eendebak (updated the required SciPy to 1.4+, `#1982 <https://github.com/qutip/qutip/pull/1982>`).; - Pieter Eendebak (reduced import times by setting logger names, `#1981 <https://github.com/qutip/qutip/pull/1981>`); - Xavier Sproken (included C header files in the source distribution, `#1971 <https://github.com/qutip/qutip/pull/1971>`); - Christian Staufenbiel (added support for multiple collapse operators to the Floquet solver, `#1962 <https://github.com/qutip/qutip/pull/1962>`); - Christian Staufenbiel (fixed the basis used in the Floquet Master Equation solver, `#1952 <https://github.com/qutip/qutip/pull/1952>`); - Christian Staufenbiel (allowed the ``bloch_redfield_tensor`` function to accept strings and callables for `a_ops`, `#1951 <https://github.com/qutip/qutip/pull/1951>`); - Henrique Silvro (allowed ``qutip_qip`` to be imported as ``qutip.qip``, `#1920 <https://github.com/qutip/qutip/pull/1920>`); - Florian Hopfmueller (added a vastly improved implementations of ``process_fidelity`` and ``average_gate_fidelity``, `#1712 <https://github.com/qutip/qutip/pull/1712>`, `#1748 <https://github.com/qutip/qutip/pull/1748>",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:38793,Testability,log,logm,38793,"erlying data type instead of a SciPy-like sparse matrix.; The operations available in ``qutip.core.data`` may be used on ``.data``,; regardless of the data type.; - ``Qobj`` with different data types may be mixed in arithmetic and other; operations. A sensible output type will be automatically determined.; - The new ``.to(...)`` method may be used to convert a ``Qobj`` from one data type; to another. E.g. ``.to(""dense"")`` will convert to the dense representation and; ``.to(""csr"")`` will convert to the sparse type.; - Many ``Qobj`` methods and methods that create ``Qobj`` now accepted a ``dtype``; parameter that allows the data type of the returned ``Qobj`` to specified.; - The new ``&`` operator may be used to obtain the tensor product.; - The new ``@`` operator may be used to obtain the matrix / operator product.; ``bar @ ket`` returns a scalar.; - The new ``.contract()`` method will collapse 1D subspaces of the dimensions of; the ``Qobj``.; - The new ``.logm()`` method returns the matrix logarithm of an operator.; - The methods ``.set_data``, ``.get_data``, ``.extract_state``, ``.eliminate_states``,; ``.evaluate`` and ``.check_isunitary`` have been removed. QobjEvo changes; ---------------. The ``QobjEvo`` type for storing time-dependent quantum objects has been; significantly expanded, standardized and extended. The time-dependent; coefficients are now represented using a new ``Coefficient`` type that; may be independently created and manipulated if required. Some highlights:. - The ``.compile()`` method has been removed. Coefficients specified as; strings are automatically compiled if possible and the compilation is; cached across different Python runs and instances.; - Mixing coefficient types within a single ``Qobj`` is now supported.; - Many new attributes were added to ``QobjEvo`` for convenience. Examples; include ``.dims``, ``.shape``, ``.superrep`` and ``.isconstant``.; - Many old attributes such as ``.cte``, ``.use_cython``, ``.type``, ``.const``,; and `",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:38828,Testability,log,logarithm,38828,"erlying data type instead of a SciPy-like sparse matrix.; The operations available in ``qutip.core.data`` may be used on ``.data``,; regardless of the data type.; - ``Qobj`` with different data types may be mixed in arithmetic and other; operations. A sensible output type will be automatically determined.; - The new ``.to(...)`` method may be used to convert a ``Qobj`` from one data type; to another. E.g. ``.to(""dense"")`` will convert to the dense representation and; ``.to(""csr"")`` will convert to the sparse type.; - Many ``Qobj`` methods and methods that create ``Qobj`` now accepted a ``dtype``; parameter that allows the data type of the returned ``Qobj`` to specified.; - The new ``&`` operator may be used to obtain the tensor product.; - The new ``@`` operator may be used to obtain the matrix / operator product.; ``bar @ ket`` returns a scalar.; - The new ``.contract()`` method will collapse 1D subspaces of the dimensions of; the ``Qobj``.; - The new ``.logm()`` method returns the matrix logarithm of an operator.; - The methods ``.set_data``, ``.get_data``, ``.extract_state``, ``.eliminate_states``,; ``.evaluate`` and ``.check_isunitary`` have been removed. QobjEvo changes; ---------------. The ``QobjEvo`` type for storing time-dependent quantum objects has been; significantly expanded, standardized and extended. The time-dependent; coefficients are now represented using a new ``Coefficient`` type that; may be independently created and manipulated if required. Some highlights:. - The ``.compile()`` method has been removed. Coefficients specified as; strings are automatically compiled if possible and the compilation is; cached across different Python runs and instances.; - Mixing coefficient types within a single ``Qobj`` is now supported.; - Many new attributes were added to ``QobjEvo`` for convenience. Examples; include ``.dims``, ``.shape``, ``.superrep`` and ``.isconstant``.; - Many old attributes such as ``.cte``, ``.use_cython``, ``.type``, ``.const``,; and `",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:46343,Testability,log,logging,46343," must now be vectorized; (i.e. accept and return numpy arrays for frequencies and densities) and; must accept negative frequence (i.e. usually include a ``w > 0`` factor; so that the returned densities are zero for negative frequencies).; - The number of sidebands to keep, ``kmax`` may only be supplied when using; the ``FMESolver``; - The ``Tsteps`` parameter has been removed from both ``fsesolve`` and; ``fmmesolve``. The ``precompute`` option to ``FloquetBasis`` may be used; instead. Evolution of State Solver (essovle):. - The function ``essolve`` has been removed. Use the ``diag`` integration; method with ``sesolve`` or ``mesolve`` instead. Steady-state solvers (steadystate module):. - The ``method`` parameter and ``solver`` parameters have been separated. Previously; they were mixed together in the ``method`` parameter.; - The previous options are now passed as parameters to the steady state; solver and mostly passed through to the underlying SciPy functions.; - The logging and statistics have been removed. Correlation functions (correlation module):. - A new ``correlation_3op`` function has been added. It supports ``MESolver``; or ``BRMESolver``.; - The ``correlation``, ``correlation_4op``, and ``correlation_ss`` functions have been; removed.; - Support for calculating correlation with ``mcsolve`` has been removed. Propagators (propagator module):. - A class interface, ``qutip.Propagator``, has been added for propagators.; - Propagation of time-dependent systems is now supported using ``QobjEvo``.; - The ``unitary_mode`` and ``parallel`` options have been removed. Correlation spectra (spectrum module):. - The functions ``spectrum_ss`` and ``spectrum_pi`` have been removed and; are now internal functions.; - The ``use_pinv`` parameter for ``spectrum`` has been removed and the; functionality merged into the ``solver`` parameter. Use ``solver=""pi""``; instead. QuTiP core; ----------. There have been numerous other small changes to core QuTiP features:. - ``qft(...)``",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:51822,Testability,test,tests,51822,"P support may return in a future QuTiP release.; - The ``qutip.parfor`` function has been removed. Use ``qutip.parallel_map`` instead.; - ``qutip.graph`` has been removed and replaced by SciPy's graph functions.; - ``qutip.topology`` has been removed. It contained only one function ``berry_curvature``.; - The ``~/.qutip/qutiprc`` config file is no longer supported. It contained settings for the OpenMP support. QuTiP 4.7.5 (2024-01-29); ========================. Patch release for QuTiP 4.7. It adds support for SciPy 1.12. Bug Fixes; ---------. - Remove use of scipy.<numpy-func> in parallel.py, incompatible with scipy==1.12 (#2305 by Evan McKinney). QuTiP 4.7.4 (2024-01-15); ========================. Bug Fixes; ---------. - Adapt to deprecation from matplotlib 3.8 (#2243, reported by Bogdan Reznychenko); - Fix name of temp files for removal after use. (#2251, reported by Qile Su); - Avoid integer overflow in Qobj creation. (#2252, reported by KianHwee-Lim); - Ignore DeprecationWarning from pyximport (#2287); - Add partial support and tests for python 3.12. (#2294). Miscellaneous; -------------. - Rework `choi_to_kraus`, making it rely on an eigenstates solver that can choose `eigh` if the Choi matrix is Hermitian, as it is more numerically stable. (#2276, by Bogdan Reznychenko); - Rework `kraus_to_choi`, making it faster (#2283, by Bogdan Reznychenko and Rafael Haenel). QuTiP 4.7.3 (2023-08-22); ========================. Bug Fixes; ---------. - Non-oper qobj + scalar raise an error. (#2208 reported by vikramkashyap); - Fixed issue where `extract_states` did not preserve hermiticity.; Fixed issue where `rand_herm` did not set the private attribute _isherm to True. (#2214 by AGaliciaMartinez); - ssesolve average states to density matrices (#2216 reported by BenjaminDAnjou). Miscellaneous; -------------. - Exclude cython 3.0.0 from requirement (#2204); - Run in no cython mode with cython >=3.0.0 (#2207). QuTiP 4.7.2 (2023-06-28); ========================. This is a bugfix",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:53783,Testability,log,logger,53783,"is a bugfix release for QuTiP 4.7.X. It adds support for; numpy 1.25 and scipy 1.11. Bug Fixes; ---------; - Fix setting of sso.m_ops in heterodyne smesolver and passing through of sc_ops to photocurrent solver. (#2081 by Bogdan Reznychenko and Simon Cross); - Update calls to SciPy eigvalsh and eigsh to pass the range of eigenvalues to return using ``subset_by_index=``. (#2081 by Simon Cross); - Fixed bug where some matrices were wrongly found to be hermitian. (#2082 by AGaliciaMartinez). Miscellaneous; -------------; - Fixed typo in stochastic.py (#2049, by eltociear); - `ptrace` always return density matrix (#2185, issue by udevd); - `mesolve` can support mixed callable and Qobj for `e_ops` (#2184 issue by balopat). Version 4.7.1 (December 11, 2022); +++++++++++++++++++++++++++++++++. This is a bugfix release for QuTiP 4.7.X. In addition to the minor fixes; listed below, the release adds builds for Python 3.11 and support for; packaging 22.0. Features; --------; - Improve qutip import times by setting logger names explicitly. (#1980). Bug Fixes; ---------; - Change floquet_master_equation_rates(...) to use an adaptive number of time steps scaled by the number of sidebands, kmax. (#1961); - Change fidelity(A, B) to use the reduced fidelity formula for pure states which is more numerically efficient and accurate. (#1964); - Change ``brmesolve`` to raise an exception when ode integration is not successful. (#1965); - Backport fix for IPython helper Bloch._repr_svg_ from dev.major. Previously the print_figure function returned bytes, but since ipython/ipython#5452 (in 2014) it returns a Unicode string. This fix updates QuTiP's helper to match. (#1970); - Fix correlation for case where only the collapse operators are time dependent. (#1979); - Fix the hinton visualization method to plot the matrix instead of its transpose. (#2011); - Fix the hinton visualization method to take into account all the matrix coefficients to set the squares scale, instead of only the diagona",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:55572,Testability,test,tests,55572,"ton visualization method to plot the matrix instead of its transpose. (#2011); - Fix the hinton visualization method to take into account all the matrix coefficients to set the squares scale, instead of only the diagonal coefficients. (#2012); - Fix parsing of package versions in setup.py to support packaging 22.0. (#2037); - Add back .qu suffix to objects saved with qsave and loaded with qload. The suffix was accidentally removed in QuTiP 4.7.0. (#2038); - Add a default max_step to processors. (#2040). Documentation; -------------; - Add towncrier for managing the changelog. (#1927); - Update the version of numpy used to build documentation to 1.22.0. (#1940); - Clarify returned objects from bloch_redfield_tensor(). (#1950); - Update Floquet Markov solver docs. (#1958); - Update the roadmap and ideas to show completed work as of August 2022. (#1967). Miscellaneous; -------------; - Return TypeError instead of Exception for type error in sesolve argument. (#1924); - Add towncrier draft build of changelog to CI tests. (#1946); - Add Python 3.11 to builds. (#2041); - Simplify version parsing by using packaging.version.Version. (#2043); - Update builds to use cibuildwheel 2.11, and to build with manylinux2014 on Python 3.8 and 3.9, since numpy and SciPy no longer support manylinux2010 on those versions of Python. (#2047). Version 4.7.0 (April 13, 2022); ++++++++++++++++++++++++++++++. This release sees the addition of two new solvers -- ``qutip.krylovsolve`` based on the Krylov subspace approximation and ``qutip.nonmarkov.heom`` that reimplements the BoFiN HEOM solver. Bloch sphere rendering gained support for drawing arcs and lines on the sphere, and for setting the transparency of rendered points and vectors, Hinton plots gained support for specifying a coloring style, and matrix histograms gained better default colors and more flexible styling options. Other significant improvements include better scaling of the Floquet solver, support for passing ``Path`` objects wh",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:64944,Testability,test,test,64944,ub.com/qutip/qutip/pull/1562>`_ by Eric Gigure). Documentation Improvements; --------------------------; - Added contributors image to the documentation. (`#1828 <https://github.com/qutip/qutip/pull/1828>`_ by Leonard Assis); - Fixed the Theory of Quantum Information bibliography link. (`#1840 <https://github.com/qutip/qutip/pull/1840>`_ by Anto Luketina); - Fixed minor grammar errors in the dynamics guide. (`#1822 <https://github.com/qutip/qutip/pull/1822>`_ by Victor Omole); - Fixed many small documentation typos. (`#1569 <https://github.com/qutip/qutip/pull/1569>`_ by Ashish Panigrahi); - Added Pulser to the list of libraries that use QuTiP. (`#1570 <https://github.com/qutip/qutip/pull/1570>`_ by Ashish Panigrahi); - Corrected typo in the states and operators guide. (`#1567 <https://github.com/qutip/qutip/pull/1567>`_ by Laurent Ajdnik); - Converted http links to https. (`#1555 <https://github.com/qutip/qutip/pull/1555>`_ by Jake Lishamn). Developer Changes; -----------------; - Add GitHub actions test run on windows-latest. (`#1853 <https://github.com/qutip/qutip/pull/1853>`_ and `#1855 <https://github.com/qutip/qutip/pull/1855>`_ by Simon Cross); - Bumped the version of pillow used to build documentation from 9.0.0 to 9.0.1. (`#1835 <https://github.com/qutip/qutip/pull/1835>`_ by dependabot); - Migrated the ``qutip.superop_reps`` tests to pytest. (`#1825 <https://github.com/qutip/qutip/pull/1825>`_ by Felipe Bivort Haiek); - Migrated the ``qutip.steadystates`` tests to pytest. (`#1679 <https://github.com/qutip/qutip/pull/1679>`_ by Eric Gigure); - Changed the README.md CI badge to the GitHub Actions badge. (`#1581 <https://github.com/qutip/qutip/pull/1581>`_ by Jake Lishman); - Updated CodeClimate configuration to treat our Python source files as Python 3. (`#1577 <https://github.com/qutip/qutip/pull/1577>`_ by Jake Lishman); - Reduced cyclomatic complexity in ``qutip._mkl``. (`#1576 <https://github.com/qutip/qutip/pull/1576>`_ by Jake Lishman); - Fixed PEP8 w,MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:65285,Testability,test,tests,65285,"; - Fixed minor grammar errors in the dynamics guide. (`#1822 <https://github.com/qutip/qutip/pull/1822>`_ by Victor Omole); - Fixed many small documentation typos. (`#1569 <https://github.com/qutip/qutip/pull/1569>`_ by Ashish Panigrahi); - Added Pulser to the list of libraries that use QuTiP. (`#1570 <https://github.com/qutip/qutip/pull/1570>`_ by Ashish Panigrahi); - Corrected typo in the states and operators guide. (`#1567 <https://github.com/qutip/qutip/pull/1567>`_ by Laurent Ajdnik); - Converted http links to https. (`#1555 <https://github.com/qutip/qutip/pull/1555>`_ by Jake Lishamn). Developer Changes; -----------------; - Add GitHub actions test run on windows-latest. (`#1853 <https://github.com/qutip/qutip/pull/1853>`_ and `#1855 <https://github.com/qutip/qutip/pull/1855>`_ by Simon Cross); - Bumped the version of pillow used to build documentation from 9.0.0 to 9.0.1. (`#1835 <https://github.com/qutip/qutip/pull/1835>`_ by dependabot); - Migrated the ``qutip.superop_reps`` tests to pytest. (`#1825 <https://github.com/qutip/qutip/pull/1825>`_ by Felipe Bivort Haiek); - Migrated the ``qutip.steadystates`` tests to pytest. (`#1679 <https://github.com/qutip/qutip/pull/1679>`_ by Eric Gigure); - Changed the README.md CI badge to the GitHub Actions badge. (`#1581 <https://github.com/qutip/qutip/pull/1581>`_ by Jake Lishman); - Updated CodeClimate configuration to treat our Python source files as Python 3. (`#1577 <https://github.com/qutip/qutip/pull/1577>`_ by Jake Lishman); - Reduced cyclomatic complexity in ``qutip._mkl``. (`#1576 <https://github.com/qutip/qutip/pull/1576>`_ by Jake Lishman); - Fixed PEP8 warnings in ``qutip.control``, ``qutip.mcsolve``, ``qutip.random_objects``, and ``qutip.stochastic``. (`#1575 <https://github.com/qutip/qutip/pull/1575>`_ by Jake Lishman); - Bumped the version of urllib3 used to build documentation from 1.26.4 to 1.26.5. (`#1563 <https://github.com/qutip/qutip/pull/1563>`_ by dependabot); - Moved tests to GitHub Actions. (",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:65418,Testability,test,tests,65418,"many small documentation typos. (`#1569 <https://github.com/qutip/qutip/pull/1569>`_ by Ashish Panigrahi); - Added Pulser to the list of libraries that use QuTiP. (`#1570 <https://github.com/qutip/qutip/pull/1570>`_ by Ashish Panigrahi); - Corrected typo in the states and operators guide. (`#1567 <https://github.com/qutip/qutip/pull/1567>`_ by Laurent Ajdnik); - Converted http links to https. (`#1555 <https://github.com/qutip/qutip/pull/1555>`_ by Jake Lishamn). Developer Changes; -----------------; - Add GitHub actions test run on windows-latest. (`#1853 <https://github.com/qutip/qutip/pull/1853>`_ and `#1855 <https://github.com/qutip/qutip/pull/1855>`_ by Simon Cross); - Bumped the version of pillow used to build documentation from 9.0.0 to 9.0.1. (`#1835 <https://github.com/qutip/qutip/pull/1835>`_ by dependabot); - Migrated the ``qutip.superop_reps`` tests to pytest. (`#1825 <https://github.com/qutip/qutip/pull/1825>`_ by Felipe Bivort Haiek); - Migrated the ``qutip.steadystates`` tests to pytest. (`#1679 <https://github.com/qutip/qutip/pull/1679>`_ by Eric Gigure); - Changed the README.md CI badge to the GitHub Actions badge. (`#1581 <https://github.com/qutip/qutip/pull/1581>`_ by Jake Lishman); - Updated CodeClimate configuration to treat our Python source files as Python 3. (`#1577 <https://github.com/qutip/qutip/pull/1577>`_ by Jake Lishman); - Reduced cyclomatic complexity in ``qutip._mkl``. (`#1576 <https://github.com/qutip/qutip/pull/1576>`_ by Jake Lishman); - Fixed PEP8 warnings in ``qutip.control``, ``qutip.mcsolve``, ``qutip.random_objects``, and ``qutip.stochastic``. (`#1575 <https://github.com/qutip/qutip/pull/1575>`_ by Jake Lishman); - Bumped the version of urllib3 used to build documentation from 1.26.4 to 1.26.5. (`#1563 <https://github.com/qutip/qutip/pull/1563>`_ by dependabot); - Moved tests to GitHub Actions. (`#1551 <https://github.com/qutip/qutip/pull/1551>`_ by Jake Lishman); - The GitHub contributing guidelines were re-added and updated ",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:66260,Testability,test,tests,66260,"; - Migrated the ``qutip.superop_reps`` tests to pytest. (`#1825 <https://github.com/qutip/qutip/pull/1825>`_ by Felipe Bivort Haiek); - Migrated the ``qutip.steadystates`` tests to pytest. (`#1679 <https://github.com/qutip/qutip/pull/1679>`_ by Eric Gigure); - Changed the README.md CI badge to the GitHub Actions badge. (`#1581 <https://github.com/qutip/qutip/pull/1581>`_ by Jake Lishman); - Updated CodeClimate configuration to treat our Python source files as Python 3. (`#1577 <https://github.com/qutip/qutip/pull/1577>`_ by Jake Lishman); - Reduced cyclomatic complexity in ``qutip._mkl``. (`#1576 <https://github.com/qutip/qutip/pull/1576>`_ by Jake Lishman); - Fixed PEP8 warnings in ``qutip.control``, ``qutip.mcsolve``, ``qutip.random_objects``, and ``qutip.stochastic``. (`#1575 <https://github.com/qutip/qutip/pull/1575>`_ by Jake Lishman); - Bumped the version of urllib3 used to build documentation from 1.26.4 to 1.26.5. (`#1563 <https://github.com/qutip/qutip/pull/1563>`_ by dependabot); - Moved tests to GitHub Actions. (`#1551 <https://github.com/qutip/qutip/pull/1551>`_ by Jake Lishman); - The GitHub contributing guidelines were re-added and updated to point to the more complete guidelines in the documentation. (`#1549 <https://github.com/qutip/qutip/pull/1549>`_ by Jake Lishman); - The release documentation was reworked after the initial 4.6.1 to match the actual release process. (`#1544 <https://github.com/qutip/qutip/pull/1544>`_ by Jake Lishman). Version 4.6.3 (February 9, 2022); ++++++++++++++++++++++++++++++++. This minor release adds support for numpy 1.22 and Python 3.10 and removes some blockers for running QuTiP on the Apple M1. The performance of the ``enr_destroy``, ``state_number_enumerate`` and ``hadamard_transform`` functions was drastically improved (up to 70x or 200x faster in some common cases), and support for the drift Hamiltonian was added to the ``qutip.qip`` ``Processor``. The ``qutip.hardware_info`` module was removed as part of adding s",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:67787,Testability,test,testing,67787,"(February 9, 2022); ++++++++++++++++++++++++++++++++. This minor release adds support for numpy 1.22 and Python 3.10 and removes some blockers for running QuTiP on the Apple M1. The performance of the ``enr_destroy``, ``state_number_enumerate`` and ``hadamard_transform`` functions was drastically improved (up to 70x or 200x faster in some common cases), and support for the drift Hamiltonian was added to the ``qutip.qip`` ``Processor``. The ``qutip.hardware_info`` module was removed as part of adding support for the Apple M1. We hope the removal of this little-used module does not adversely affect many users -- it was largely unrelated to QuTiP's core functionality and its presence was a continual source of blockers to importing ``qutip`` on new or changed platforms. A new check on the dimensions of ``Qobj``'s were added to prevent segmentation faults when invalid shape and dimension combinations were passed to Cython code. In addition, there were many small bugfixes, documentation improvements, and improvements to our building and testing processes. Improvements; ------------; - The ``enr_destroy`` function was made ~200x faster in many simple cases. (`#1593 <https://github.com/qutip/qutip/pull/1593>`_ by Johannes Feist); - The ``state_number_enumerate`` function was made significantly faster. (`#1594 <https://github.com/qutip/qutip/pull/1594>`_ by Johannes Feist); - Added the missing drift Hamiltonian to the method run_analytically of ``Processor``. (`#1603 <https://github.com/qutip/qutip/pull/1603>`_ Boxi Li); - The ``hadamard_transform`` was made much faster, e.g., ~70x faster for N=10. (`#1688 <https://github.com/qutip/qutip/pull/1688>`_ by Asier Galicia); - Added support for computing the power of a scalar-like Qobj. (`#1692 <https://github.com/qutip/qutip/pull/1692>`_ by Asier Galicia); - Removed the ``hardware_info`` module. This module wasn't used inside QuTiP and regularly broke when new operating systems were released, and in particular prevented importing ",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:69596,Testability,test,tested,69596,"sn't used inside QuTiP and regularly broke when new operating systems were released, and in particular prevented importing QuTiP on the Apple M1. (`#1754 <https://github.com/qutip/qutip/pull/1754>`_, `#1758 <https://github.com/qutip/qutip/pull/1758>`_ by Eric Gigure). Bug Fixes; ---------; - Fixed support for calculating the propagator of a density matrix with collapse operators. QuTiP 4.6.2 introduced extra sanity checks on the dimensions of inputs to mesolve (Fix mesolve segfault with bad initial state `#1459 <https://github.com/qutip/qutip/pull/1459>`_), but the propagator function's calls to mesolve violated these checks by supplying initial states with the dimensions incorrectly set. ``propagator`` now calls mesolve with the correct dimensions set on the initial state. (`#1588 <https://github.com/qutip/qutip/pull/1588>`_ by Simon Cross); - Fixed support for calculating the propagator for a superoperator without collapse operators. This functionality was not tested by the test suite and appears to have broken sometime during 2019. Tests have now been added and the code breakages fixed. (`#1588 <https://github.com/qutip/qutip/pull/1588>`_ by Simon Cross); - Fixed the ignoring of the random number seed passed to ``rand_dm`` in the case where ``pure`` was set to true. (`#1600 <https://github.com/qutip/qutip/pull/1600>`_ Pontus Wiksthl); - Fixed qutip.control.optimize_pulse support for sparse eigenvector decomposition with the Qobj oper_dtype (the Qobj oper_dtype is the default for large systems). (`#1621 <https://github.com/qutip/qutip/pull/1621>`_ by Simon Cross); - Removed qutip.control.optimize_pulse support for scipy.sparse.csr_matrix and generic ndarray-like matrices. Support for these was non-functional. (`#1621 <https://github.com/qutip/qutip/pull/1621>`_ by Simon Cross); - Fixed errors in the calculation of the Husimi spin_q_function and spin_wigner functions and added tests for them. (`#1632 <https://github.com/qutip/qutip/pull/1632>`_ by Mark Johnson); -",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:69610,Testability,test,test,69610,"sn't used inside QuTiP and regularly broke when new operating systems were released, and in particular prevented importing QuTiP on the Apple M1. (`#1754 <https://github.com/qutip/qutip/pull/1754>`_, `#1758 <https://github.com/qutip/qutip/pull/1758>`_ by Eric Gigure). Bug Fixes; ---------; - Fixed support for calculating the propagator of a density matrix with collapse operators. QuTiP 4.6.2 introduced extra sanity checks on the dimensions of inputs to mesolve (Fix mesolve segfault with bad initial state `#1459 <https://github.com/qutip/qutip/pull/1459>`_), but the propagator function's calls to mesolve violated these checks by supplying initial states with the dimensions incorrectly set. ``propagator`` now calls mesolve with the correct dimensions set on the initial state. (`#1588 <https://github.com/qutip/qutip/pull/1588>`_ by Simon Cross); - Fixed support for calculating the propagator for a superoperator without collapse operators. This functionality was not tested by the test suite and appears to have broken sometime during 2019. Tests have now been added and the code breakages fixed. (`#1588 <https://github.com/qutip/qutip/pull/1588>`_ by Simon Cross); - Fixed the ignoring of the random number seed passed to ``rand_dm`` in the case where ``pure`` was set to true. (`#1600 <https://github.com/qutip/qutip/pull/1600>`_ Pontus Wiksthl); - Fixed qutip.control.optimize_pulse support for sparse eigenvector decomposition with the Qobj oper_dtype (the Qobj oper_dtype is the default for large systems). (`#1621 <https://github.com/qutip/qutip/pull/1621>`_ by Simon Cross); - Removed qutip.control.optimize_pulse support for scipy.sparse.csr_matrix and generic ndarray-like matrices. Support for these was non-functional. (`#1621 <https://github.com/qutip/qutip/pull/1621>`_ by Simon Cross); - Fixed errors in the calculation of the Husimi spin_q_function and spin_wigner functions and added tests for them. (`#1632 <https://github.com/qutip/qutip/pull/1632>`_ by Mark Johnson); -",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:70531,Testability,test,tests,70531, Cross); - Fixed support for calculating the propagator for a superoperator without collapse operators. This functionality was not tested by the test suite and appears to have broken sometime during 2019. Tests have now been added and the code breakages fixed. (`#1588 <https://github.com/qutip/qutip/pull/1588>`_ by Simon Cross); - Fixed the ignoring of the random number seed passed to ``rand_dm`` in the case where ``pure`` was set to true. (`#1600 <https://github.com/qutip/qutip/pull/1600>`_ Pontus Wiksthl); - Fixed qutip.control.optimize_pulse support for sparse eigenvector decomposition with the Qobj oper_dtype (the Qobj oper_dtype is the default for large systems). (`#1621 <https://github.com/qutip/qutip/pull/1621>`_ by Simon Cross); - Removed qutip.control.optimize_pulse support for scipy.sparse.csr_matrix and generic ndarray-like matrices. Support for these was non-functional. (`#1621 <https://github.com/qutip/qutip/pull/1621>`_ by Simon Cross); - Fixed errors in the calculation of the Husimi spin_q_function and spin_wigner functions and added tests for them. (`#1632 <https://github.com/qutip/qutip/pull/1632>`_ by Mark Johnson); - Fixed setting of OpenMP compilation flag on Linux. Previously when compiling the OpenMP functions were compiled without parallelization. (`#1693 <https://github.com/qutip/qutip/pull/1693>`_ by Eric Gigure); - Fixed tracking the state of the Bloch sphere figure and axes to prevent exceptions during rendering. (`#1619 <https://github.com/qutip/qutip/pull/1619>`_ by Simon Cross); - Fixed compatibility with numpy configuration in numpy's 1.22.0 release. (`#1752 <https://github.com/qutip/qutip/pull/1752>`_ by Matthew Treinish); - Added dims checks for e_ops passed to solvers to prevent hanging the calling process when e_ops of the wrong dimensions were passed. (`#1778 <https://github.com/qutip/qutip/pull/1778>`_ by Eric Gigure); - Added a check in Qobj constructor that the respective members of data.shape cannot be larger than what the c,MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:73476,Testability,test,test,73476,"nstallation requirements in the documentation to match what is specified in setup.py. (`#1715 <https://github.com/qutip/qutip/pull/1715>`_ by Asier Galicia); - Fixed a typo in the ``chi_to_choi`` documentation. Previously the documentation mixed up chi and choi. (`#1731 <https://github.com/qutip/qutip/pull/1731>`_ by Pontus Wiksthl); - Improved the documentation for the stochastic equation solvers. Added links to notebooks with examples, API doumentation and external references. (`#1743 <https://github.com/qutip/qutip/pull/1743>`_ by Leonardo Assis); - Fixed a typo in ``qutip.settings`` in the settings guide. (`#1786 <https://github.com/qutip/qutip/pull/1786>`_ by Mahdi Aslani); - Made numerous small improvements to the text of the QuTiP basics guide. (`#1768 <https://github.com/qutip/qutip/pull/1768>`_ by Anna Naden); - Made a small phrasing improvement to the README. (`#1790 <https://github.com/qutip/qutip/pull/1790>`_ by Rita Abani). Developer Changes; -----------------; - Improved test coverage of states and operators functions. (`#1578 <https://github.com/qutip/qutip/pull/1578>`_ by Eric Gigure); - Fixed test_interpolate mcsolve use (`#1645 <https://github.com/qutip/qutip/pull/1645>`_ by Eric Gigure); - Ensured figure plots are explicitly closed during tests so that the test suite passes when run headless under Xvfb. (`#1648 <https://github.com/qutip/qutip/pull/1648>`_ by Simon Cross); - Bumped the version of pillow used to build documentation from 8.2.0 to 9.0.0. (`#1654 <https://github.com/qutip/qutip/pull/1654>`_, `#1760 <https://github.com/qutip/qutip/pull/1760>`_ by dependabot); - Bumped the version of babel used to build documentation from 2.9.0 to 2.9.1. (`#1695 <https://github.com/qutip/qutip/pull/1695>`_ by dependabot); - Bumped the version of numpy used to build documentation from 1.19.5 to 1.21.0. (`#1767 <https://github.com/qutip/qutip/pull/1767>`_ by dependabot); - Bumped the version of ipython used to build documentation from 7.22.0 to 7.31.1. ",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:73756,Testability,test,tests,73756,"`#1731 <https://github.com/qutip/qutip/pull/1731>`_ by Pontus Wiksthl); - Improved the documentation for the stochastic equation solvers. Added links to notebooks with examples, API doumentation and external references. (`#1743 <https://github.com/qutip/qutip/pull/1743>`_ by Leonardo Assis); - Fixed a typo in ``qutip.settings`` in the settings guide. (`#1786 <https://github.com/qutip/qutip/pull/1786>`_ by Mahdi Aslani); - Made numerous small improvements to the text of the QuTiP basics guide. (`#1768 <https://github.com/qutip/qutip/pull/1768>`_ by Anna Naden); - Made a small phrasing improvement to the README. (`#1790 <https://github.com/qutip/qutip/pull/1790>`_ by Rita Abani). Developer Changes; -----------------; - Improved test coverage of states and operators functions. (`#1578 <https://github.com/qutip/qutip/pull/1578>`_ by Eric Gigure); - Fixed test_interpolate mcsolve use (`#1645 <https://github.com/qutip/qutip/pull/1645>`_ by Eric Gigure); - Ensured figure plots are explicitly closed during tests so that the test suite passes when run headless under Xvfb. (`#1648 <https://github.com/qutip/qutip/pull/1648>`_ by Simon Cross); - Bumped the version of pillow used to build documentation from 8.2.0 to 9.0.0. (`#1654 <https://github.com/qutip/qutip/pull/1654>`_, `#1760 <https://github.com/qutip/qutip/pull/1760>`_ by dependabot); - Bumped the version of babel used to build documentation from 2.9.0 to 2.9.1. (`#1695 <https://github.com/qutip/qutip/pull/1695>`_ by dependabot); - Bumped the version of numpy used to build documentation from 1.19.5 to 1.21.0. (`#1767 <https://github.com/qutip/qutip/pull/1767>`_ by dependabot); - Bumped the version of ipython used to build documentation from 7.22.0 to 7.31.1. (`#1780 <https://github.com/qutip/qutip/pull/1780>`_ by dependabot); - Rename qutip.bib to CITATION.bib to enable GitHub's citation support. (`#1662 <https://github.com/qutip/qutip/pull/1662>`_ by Ashish Panigrahi); - Added tests for simdiags. (`#1681 <https://git",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:73774,Testability,test,test,73774,"`#1731 <https://github.com/qutip/qutip/pull/1731>`_ by Pontus Wiksthl); - Improved the documentation for the stochastic equation solvers. Added links to notebooks with examples, API doumentation and external references. (`#1743 <https://github.com/qutip/qutip/pull/1743>`_ by Leonardo Assis); - Fixed a typo in ``qutip.settings`` in the settings guide. (`#1786 <https://github.com/qutip/qutip/pull/1786>`_ by Mahdi Aslani); - Made numerous small improvements to the text of the QuTiP basics guide. (`#1768 <https://github.com/qutip/qutip/pull/1768>`_ by Anna Naden); - Made a small phrasing improvement to the README. (`#1790 <https://github.com/qutip/qutip/pull/1790>`_ by Rita Abani). Developer Changes; -----------------; - Improved test coverage of states and operators functions. (`#1578 <https://github.com/qutip/qutip/pull/1578>`_ by Eric Gigure); - Fixed test_interpolate mcsolve use (`#1645 <https://github.com/qutip/qutip/pull/1645>`_ by Eric Gigure); - Ensured figure plots are explicitly closed during tests so that the test suite passes when run headless under Xvfb. (`#1648 <https://github.com/qutip/qutip/pull/1648>`_ by Simon Cross); - Bumped the version of pillow used to build documentation from 8.2.0 to 9.0.0. (`#1654 <https://github.com/qutip/qutip/pull/1654>`_, `#1760 <https://github.com/qutip/qutip/pull/1760>`_ by dependabot); - Bumped the version of babel used to build documentation from 2.9.0 to 2.9.1. (`#1695 <https://github.com/qutip/qutip/pull/1695>`_ by dependabot); - Bumped the version of numpy used to build documentation from 1.19.5 to 1.21.0. (`#1767 <https://github.com/qutip/qutip/pull/1767>`_ by dependabot); - Bumped the version of ipython used to build documentation from 7.22.0 to 7.31.1. (`#1780 <https://github.com/qutip/qutip/pull/1780>`_ by dependabot); - Rename qutip.bib to CITATION.bib to enable GitHub's citation support. (`#1662 <https://github.com/qutip/qutip/pull/1662>`_ by Ashish Panigrahi); - Added tests for simdiags. (`#1681 <https://git",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:74699,Testability,test,tests,74699,"645>`_ by Eric Gigure); - Ensured figure plots are explicitly closed during tests so that the test suite passes when run headless under Xvfb. (`#1648 <https://github.com/qutip/qutip/pull/1648>`_ by Simon Cross); - Bumped the version of pillow used to build documentation from 8.2.0 to 9.0.0. (`#1654 <https://github.com/qutip/qutip/pull/1654>`_, `#1760 <https://github.com/qutip/qutip/pull/1760>`_ by dependabot); - Bumped the version of babel used to build documentation from 2.9.0 to 2.9.1. (`#1695 <https://github.com/qutip/qutip/pull/1695>`_ by dependabot); - Bumped the version of numpy used to build documentation from 1.19.5 to 1.21.0. (`#1767 <https://github.com/qutip/qutip/pull/1767>`_ by dependabot); - Bumped the version of ipython used to build documentation from 7.22.0 to 7.31.1. (`#1780 <https://github.com/qutip/qutip/pull/1780>`_ by dependabot); - Rename qutip.bib to CITATION.bib to enable GitHub's citation support. (`#1662 <https://github.com/qutip/qutip/pull/1662>`_ by Ashish Panigrahi); - Added tests for simdiags. (`#1681 <https://github.com/qutip/qutip/pull/1681>`_ by Eric Gigure); - Added support for specifying the numpy version in the CI test matrix. (`#1696 <https://github.com/qutip/qutip/pull/1696>`_ by Simon Cross); - Fixed the skipping of the dnorm metric tests if cvxpy is not installed. Previously all metrics tests were skipped by accident. (`#1704 <https://github.com/qutip/qutip/pull/1704>`_ by Florian Hopfmueller); - Added bug report, feature request and other options to the GitHub issue reporting template. (`#1728 <https://github.com/qutip/qutip/pull/1728>`_ by Aryaman Kolhe); - Updated the build process to support building on Python 3.10 by removing the build requirement for numpy < 1.20 and replacing it with a requirement on oldest-supported-numpy. (`#1747 <https://github.com/qutip/qutip/pull/1747>`_ by Simon Cross); - Updated the version of cibuildwheel used to build wheels to 2.3.0. (`#1747 <https://github.com/qutip/qutip/pull/1747>`_, `#17",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:74849,Testability,test,test,74849,"eadless under Xvfb. (`#1648 <https://github.com/qutip/qutip/pull/1648>`_ by Simon Cross); - Bumped the version of pillow used to build documentation from 8.2.0 to 9.0.0. (`#1654 <https://github.com/qutip/qutip/pull/1654>`_, `#1760 <https://github.com/qutip/qutip/pull/1760>`_ by dependabot); - Bumped the version of babel used to build documentation from 2.9.0 to 2.9.1. (`#1695 <https://github.com/qutip/qutip/pull/1695>`_ by dependabot); - Bumped the version of numpy used to build documentation from 1.19.5 to 1.21.0. (`#1767 <https://github.com/qutip/qutip/pull/1767>`_ by dependabot); - Bumped the version of ipython used to build documentation from 7.22.0 to 7.31.1. (`#1780 <https://github.com/qutip/qutip/pull/1780>`_ by dependabot); - Rename qutip.bib to CITATION.bib to enable GitHub's citation support. (`#1662 <https://github.com/qutip/qutip/pull/1662>`_ by Ashish Panigrahi); - Added tests for simdiags. (`#1681 <https://github.com/qutip/qutip/pull/1681>`_ by Eric Gigure); - Added support for specifying the numpy version in the CI test matrix. (`#1696 <https://github.com/qutip/qutip/pull/1696>`_ by Simon Cross); - Fixed the skipping of the dnorm metric tests if cvxpy is not installed. Previously all metrics tests were skipped by accident. (`#1704 <https://github.com/qutip/qutip/pull/1704>`_ by Florian Hopfmueller); - Added bug report, feature request and other options to the GitHub issue reporting template. (`#1728 <https://github.com/qutip/qutip/pull/1728>`_ by Aryaman Kolhe); - Updated the build process to support building on Python 3.10 by removing the build requirement for numpy < 1.20 and replacing it with a requirement on oldest-supported-numpy. (`#1747 <https://github.com/qutip/qutip/pull/1747>`_ by Simon Cross); - Updated the version of cibuildwheel used to build wheels to 2.3.0. (`#1747 <https://github.com/qutip/qutip/pull/1747>`_, `#1751 <https://github.com/qutip/qutip/pull/1751>`_ by Simon Cross); - Added project urls to linking to the source repository, ",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:74973,Testability,test,tests,74973,"ation from 8.2.0 to 9.0.0. (`#1654 <https://github.com/qutip/qutip/pull/1654>`_, `#1760 <https://github.com/qutip/qutip/pull/1760>`_ by dependabot); - Bumped the version of babel used to build documentation from 2.9.0 to 2.9.1. (`#1695 <https://github.com/qutip/qutip/pull/1695>`_ by dependabot); - Bumped the version of numpy used to build documentation from 1.19.5 to 1.21.0. (`#1767 <https://github.com/qutip/qutip/pull/1767>`_ by dependabot); - Bumped the version of ipython used to build documentation from 7.22.0 to 7.31.1. (`#1780 <https://github.com/qutip/qutip/pull/1780>`_ by dependabot); - Rename qutip.bib to CITATION.bib to enable GitHub's citation support. (`#1662 <https://github.com/qutip/qutip/pull/1662>`_ by Ashish Panigrahi); - Added tests for simdiags. (`#1681 <https://github.com/qutip/qutip/pull/1681>`_ by Eric Gigure); - Added support for specifying the numpy version in the CI test matrix. (`#1696 <https://github.com/qutip/qutip/pull/1696>`_ by Simon Cross); - Fixed the skipping of the dnorm metric tests if cvxpy is not installed. Previously all metrics tests were skipped by accident. (`#1704 <https://github.com/qutip/qutip/pull/1704>`_ by Florian Hopfmueller); - Added bug report, feature request and other options to the GitHub issue reporting template. (`#1728 <https://github.com/qutip/qutip/pull/1728>`_ by Aryaman Kolhe); - Updated the build process to support building on Python 3.10 by removing the build requirement for numpy < 1.20 and replacing it with a requirement on oldest-supported-numpy. (`#1747 <https://github.com/qutip/qutip/pull/1747>`_ by Simon Cross); - Updated the version of cibuildwheel used to build wheels to 2.3.0. (`#1747 <https://github.com/qutip/qutip/pull/1747>`_, `#1751 <https://github.com/qutip/qutip/pull/1751>`_ by Simon Cross); - Added project urls to linking to the source repository, issue tracker and documentation to setup.cfg. (`#1779 <https://github.com/qutip/qutip/pull/1779>`_ by Simon Cross); - Added a numpy 1.22 and Pyt",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:75029,Testability,test,tests,75029," <https://github.com/qutip/qutip/pull/1760>`_ by dependabot); - Bumped the version of babel used to build documentation from 2.9.0 to 2.9.1. (`#1695 <https://github.com/qutip/qutip/pull/1695>`_ by dependabot); - Bumped the version of numpy used to build documentation from 1.19.5 to 1.21.0. (`#1767 <https://github.com/qutip/qutip/pull/1767>`_ by dependabot); - Bumped the version of ipython used to build documentation from 7.22.0 to 7.31.1. (`#1780 <https://github.com/qutip/qutip/pull/1780>`_ by dependabot); - Rename qutip.bib to CITATION.bib to enable GitHub's citation support. (`#1662 <https://github.com/qutip/qutip/pull/1662>`_ by Ashish Panigrahi); - Added tests for simdiags. (`#1681 <https://github.com/qutip/qutip/pull/1681>`_ by Eric Gigure); - Added support for specifying the numpy version in the CI test matrix. (`#1696 <https://github.com/qutip/qutip/pull/1696>`_ by Simon Cross); - Fixed the skipping of the dnorm metric tests if cvxpy is not installed. Previously all metrics tests were skipped by accident. (`#1704 <https://github.com/qutip/qutip/pull/1704>`_ by Florian Hopfmueller); - Added bug report, feature request and other options to the GitHub issue reporting template. (`#1728 <https://github.com/qutip/qutip/pull/1728>`_ by Aryaman Kolhe); - Updated the build process to support building on Python 3.10 by removing the build requirement for numpy < 1.20 and replacing it with a requirement on oldest-supported-numpy. (`#1747 <https://github.com/qutip/qutip/pull/1747>`_ by Simon Cross); - Updated the version of cibuildwheel used to build wheels to 2.3.0. (`#1747 <https://github.com/qutip/qutip/pull/1747>`_, `#1751 <https://github.com/qutip/qutip/pull/1751>`_ by Simon Cross); - Added project urls to linking to the source repository, issue tracker and documentation to setup.cfg. (`#1779 <https://github.com/qutip/qutip/pull/1779>`_ by Simon Cross); - Added a numpy 1.22 and Python 3.10 build to the CI test matrix. (`#1777 <https://github.com/qutip/qutip/pull/1777",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:75971,Testability,test,test,75971,"etric tests if cvxpy is not installed. Previously all metrics tests were skipped by accident. (`#1704 <https://github.com/qutip/qutip/pull/1704>`_ by Florian Hopfmueller); - Added bug report, feature request and other options to the GitHub issue reporting template. (`#1728 <https://github.com/qutip/qutip/pull/1728>`_ by Aryaman Kolhe); - Updated the build process to support building on Python 3.10 by removing the build requirement for numpy < 1.20 and replacing it with a requirement on oldest-supported-numpy. (`#1747 <https://github.com/qutip/qutip/pull/1747>`_ by Simon Cross); - Updated the version of cibuildwheel used to build wheels to 2.3.0. (`#1747 <https://github.com/qutip/qutip/pull/1747>`_, `#1751 <https://github.com/qutip/qutip/pull/1751>`_ by Simon Cross); - Added project urls to linking to the source repository, issue tracker and documentation to setup.cfg. (`#1779 <https://github.com/qutip/qutip/pull/1779>`_ by Simon Cross); - Added a numpy 1.22 and Python 3.10 build to the CI test matrix. (`#1777 <https://github.com/qutip/qutip/pull/1777>`_ by Simon Cross); - Ignore deprecation warnings from SciPy 1.8.0 scipy.sparse.X imports in CI tests. (`#1797 <https://github.com/qutip/qutip/pull/1797>`_ by Simon Cross); - Add building of wheels for Python 3.10 to the cibuildwheel job. (`#1796 <https://github.com/qutip/qutip/pull/1796>`_ by Simon Cross). Version 4.6.2 (June 2, 2021); ++++++++++++++++++++++++++++. This minor release adds a function to calculate the quantum relative entropy, fixes a corner case in handling time-dependent Hamiltonians in ``mesolve`` and adds back support for a wider range of matplotlib versions when plotting or animating Bloch spheres. It also adds a section in the README listing the papers which should be referenced while citing QuTiP. Improvements; ------------; - Added a ""Citing QuTiP"" section to the README, containing a link to the QuTiP papers. (`#1554 <https://github.com/qutip/qutip/pull/1554>`_); - Added ``entropy_relative`` which",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:76130,Testability,test,tests,76130,"Hopfmueller); - Added bug report, feature request and other options to the GitHub issue reporting template. (`#1728 <https://github.com/qutip/qutip/pull/1728>`_ by Aryaman Kolhe); - Updated the build process to support building on Python 3.10 by removing the build requirement for numpy < 1.20 and replacing it with a requirement on oldest-supported-numpy. (`#1747 <https://github.com/qutip/qutip/pull/1747>`_ by Simon Cross); - Updated the version of cibuildwheel used to build wheels to 2.3.0. (`#1747 <https://github.com/qutip/qutip/pull/1747>`_, `#1751 <https://github.com/qutip/qutip/pull/1751>`_ by Simon Cross); - Added project urls to linking to the source repository, issue tracker and documentation to setup.cfg. (`#1779 <https://github.com/qutip/qutip/pull/1779>`_ by Simon Cross); - Added a numpy 1.22 and Python 3.10 build to the CI test matrix. (`#1777 <https://github.com/qutip/qutip/pull/1777>`_ by Simon Cross); - Ignore deprecation warnings from SciPy 1.8.0 scipy.sparse.X imports in CI tests. (`#1797 <https://github.com/qutip/qutip/pull/1797>`_ by Simon Cross); - Add building of wheels for Python 3.10 to the cibuildwheel job. (`#1796 <https://github.com/qutip/qutip/pull/1796>`_ by Simon Cross). Version 4.6.2 (June 2, 2021); ++++++++++++++++++++++++++++. This minor release adds a function to calculate the quantum relative entropy, fixes a corner case in handling time-dependent Hamiltonians in ``mesolve`` and adds back support for a wider range of matplotlib versions when plotting or animating Bloch spheres. It also adds a section in the README listing the papers which should be referenced while citing QuTiP. Improvements; ------------; - Added a ""Citing QuTiP"" section to the README, containing a link to the QuTiP papers. (`#1554 <https://github.com/qutip/qutip/pull/1554>`_); - Added ``entropy_relative`` which returns the quantum relative entropy between two density matrices. (`#1553 <https://github.com/qutip/qutip/pull/1553>`_). Bug Fixes; ---------; - Fixed Bloc",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:82025,Testability,test,tests,82025,"ubit gates and controlled gates. (by **Mateo Laguna** and **Martn Sande Costa**); - Support decomposition of ``X``, ``Y`` and ``Z`` gates in circuits. (by **Boxi Li**); - Refactor ``QubitCircuit.resolve_gate()`` (by **Martn Sande Costa**). Bug Fixes; ---------; - Fix ``dims`` in the returns from ``Qobj.eigenstates`` on superoperators. (by **Jake Lishman**); - Calling Numpy ufuncs on ``Qobj`` will now correctly raise a ``TypeError`` rather than returning a nonsense ``ndarray``. (by **Jake Lishman**); - Convert segfault into Python exception when creating too-large tensor products. (by **Jake Lishman**); - Correctly set ``num_collapse`` in the output of ``mesolve``. (by **Jake Lishman**); - Fix ``ptrace`` when all subspaces are being kept, or the subspaces are passed in order. (by **Jake Lishman**); - Fix sorting bug in ``Bloch3d.add_points()``. (by **pschindler**); - Fix invalid string literals in docstrings and some unclosed files. (by **lie Gouzien**); - Fix Hermicity tests for matrices with values that are within the tolerance of 0. (by **Jake Lishman**); - Fix the trace norm being incorrectly reported as 0 for small matrices. (by **Jake Lishman**); - Fix issues with ``dnorm`` when using CVXPy 1.1 with sparse matrices. (by **Felipe Bivort Haiek**); - Fix segfaults in ``mesolve`` when passed a bad initial ``Qobj`` as the state. (by **Jake Lishman**); - Fix sparse matrix construction in PIQS when using Scipy 1.6.1. (by **Drew Parsons**); - Fix ``zspmv_openmp.cpp`` missing from the pip sdist. (by **Christoph Gohlke**); - Fix correlation functions throwing away imaginary components. (by **Asier Galicia Martinez**); - Fix ``QubitCircuit.add_circuit()`` for SWAP gate. (by **Canoming**); - Fix the broken LaTeX image conversion. (by **Jake Lishman**); - Fix gate resolution of the FREDKIN gate. (by **Bo Yang**); - Fix broken formatting in docstrings. (by **Jake Lishman**). Deprecations; ------------; - ``eseries``, ``essolve`` and ``ode2es`` are all deprecated, pending ",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:83671,Testability,test,tests,83671," Martinez**); - Fix ``QubitCircuit.add_circuit()`` for SWAP gate. (by **Canoming**); - Fix the broken LaTeX image conversion. (by **Jake Lishman**); - Fix gate resolution of the FREDKIN gate. (by **Bo Yang**); - Fix broken formatting in docstrings. (by **Jake Lishman**). Deprecations; ------------; - ``eseries``, ``essolve`` and ``ode2es`` are all deprecated, pending removal in QuTiP 5.0. These are legacy functions and classes that have been left unmaintained for a long time, and their functionality is now better achieved with ``QobjEvo`` or ``mesolve``. Developer Changes; -----------------; - **MAJOR** Overhaul of setup and packaging code to make it satisfy PEP 517, and move the build to a matrix on GitHub Actions in order to release binary wheels on pip for all major platforms and supported Python versions. (by **Jake Lishman**); - Default arguments in ``Qobj`` are now ``None`` rather than mutable types. (by **Jake Lishman**); - Fixed comsumable iterators being used to parametrise some tests, preventing the testing suite from being re-run within the same session. (by **Jake Lishman**); - Remove unused imports, simplify some floats and remove unnecessary list conversions. (by **jakobjakobson13**); - Improve Travis jobs matrix for specifying the testing containers. (by **Jake Lishman**); - Fix coverage reporting on Travis. (by **Jake Lishman**); - Added a ``pyproject.toml`` file. (by **Simon Humpohl** and **Eric Gigure**); - Add doctests to documentation. (by **Sidhant Saraogi**); - Fix all warnings in the documentation build. (by **Jake Lishman**). Version 4.5.3 (February 19, 2021); +++++++++++++++++++++++++++++++++. This patch release adds support for Numpy 1.20, made necessary by changes to how array-like objects are handled. There are no other changes relative to version 4.5.2. Users building from source should ensure that they build against Numpy versions >= 1.16.6 and < 1.20 (not including 1.20 itself), but after that or for those installing from conda, an in",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:83693,Testability,test,testing,83693," Martinez**); - Fix ``QubitCircuit.add_circuit()`` for SWAP gate. (by **Canoming**); - Fix the broken LaTeX image conversion. (by **Jake Lishman**); - Fix gate resolution of the FREDKIN gate. (by **Bo Yang**); - Fix broken formatting in docstrings. (by **Jake Lishman**). Deprecations; ------------; - ``eseries``, ``essolve`` and ``ode2es`` are all deprecated, pending removal in QuTiP 5.0. These are legacy functions and classes that have been left unmaintained for a long time, and their functionality is now better achieved with ``QobjEvo`` or ``mesolve``. Developer Changes; -----------------; - **MAJOR** Overhaul of setup and packaging code to make it satisfy PEP 517, and move the build to a matrix on GitHub Actions in order to release binary wheels on pip for all major platforms and supported Python versions. (by **Jake Lishman**); - Default arguments in ``Qobj`` are now ``None`` rather than mutable types. (by **Jake Lishman**); - Fixed comsumable iterators being used to parametrise some tests, preventing the testing suite from being re-run within the same session. (by **Jake Lishman**); - Remove unused imports, simplify some floats and remove unnecessary list conversions. (by **jakobjakobson13**); - Improve Travis jobs matrix for specifying the testing containers. (by **Jake Lishman**); - Fix coverage reporting on Travis. (by **Jake Lishman**); - Added a ``pyproject.toml`` file. (by **Simon Humpohl** and **Eric Gigure**); - Add doctests to documentation. (by **Sidhant Saraogi**); - Fix all warnings in the documentation build. (by **Jake Lishman**). Version 4.5.3 (February 19, 2021); +++++++++++++++++++++++++++++++++. This patch release adds support for Numpy 1.20, made necessary by changes to how array-like objects are handled. There are no other changes relative to version 4.5.2. Users building from source should ensure that they build against Numpy versions >= 1.16.6 and < 1.20 (not including 1.20 itself), but after that or for those installing from conda, an in",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:83934,Testability,test,testing,83934,"ocstrings. (by **Jake Lishman**). Deprecations; ------------; - ``eseries``, ``essolve`` and ``ode2es`` are all deprecated, pending removal in QuTiP 5.0. These are legacy functions and classes that have been left unmaintained for a long time, and their functionality is now better achieved with ``QobjEvo`` or ``mesolve``. Developer Changes; -----------------; - **MAJOR** Overhaul of setup and packaging code to make it satisfy PEP 517, and move the build to a matrix on GitHub Actions in order to release binary wheels on pip for all major platforms and supported Python versions. (by **Jake Lishman**); - Default arguments in ``Qobj`` are now ``None`` rather than mutable types. (by **Jake Lishman**); - Fixed comsumable iterators being used to parametrise some tests, preventing the testing suite from being re-run within the same session. (by **Jake Lishman**); - Remove unused imports, simplify some floats and remove unnecessary list conversions. (by **jakobjakobson13**); - Improve Travis jobs matrix for specifying the testing containers. (by **Jake Lishman**); - Fix coverage reporting on Travis. (by **Jake Lishman**); - Added a ``pyproject.toml`` file. (by **Simon Humpohl** and **Eric Gigure**); - Add doctests to documentation. (by **Sidhant Saraogi**); - Fix all warnings in the documentation build. (by **Jake Lishman**). Version 4.5.3 (February 19, 2021); +++++++++++++++++++++++++++++++++. This patch release adds support for Numpy 1.20, made necessary by changes to how array-like objects are handled. There are no other changes relative to version 4.5.2. Users building from source should ensure that they build against Numpy versions >= 1.16.6 and < 1.20 (not including 1.20 itself), but after that or for those installing from conda, an installation will support any current Numpy version >= 1.16.6. Improvements; ------------; - Add support for Numpy 1.20. QuTiP should be compiled against a version of Numpy ``>= 1.16.6`` and ``< 1.20`` (note: does _not_ include 1.20 itself)",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:86966,Testability,test,tests,86966,"es and unsafe ``is`` comparisons. Version 4.5.1 (May 15, 2020); ++++++++++++++++++++++++++++. Improvements; ------------; - ``husimi`` and ``wigner`` now accept half-integer spin (by **maij**); - Better error messages for failed string coefficient compilation. (issue raised by **nohchangsuk**). Bug Fixes; ---------; - Safer naming for temporary files. (by **Eric Gigure**); - Fix ``clebsch`` function for half-integer (by **Thomas Walker**); - Fix ``randint``'s dtype to ``uint32`` for compatibility with Windows. (issue raised by **Boxi Li**); - Corrected stochastic's heterodyne's m_ops (by **eliegenois**); - Mac pool use spawn. (issue raised by **goerz**); - Fix typos in ``QobjEvo._shift``. (by **Eric Gigure**); - Fix warning on Travis CI. (by **Ivan Carvalho**). Deprecations; ------------; - ``qutip.graph`` functions will be deprecated in QuTiP 5.0 in favour of ``scipy.sparse.csgraph``. Developer Changes; -----------------; - Add Boxi Li to authors. (by **Alex Pitchford**); - Skip some tests that cause segfaults on Mac. (by **Nathan Shammah** and **Eric Gigure**); - Use Python 3.8 for testing on Mac and Linux. (by **Simon Cross** and **Eric Gigure**). Version 4.5.0 (January 31, 2020); ++++++++++++++++++++++++++++++++. Improvements; ------------; - **MAJOR FEATURE**: Added `qip.noise`, a module with pulse level description of quantum circuits allowing to model various types of noise and devices (by **Boxi Li**). - **MAJOR FEATURE**: Added `qip.lattice`, a module for the study of lattice dynamics in 1D (by **Saumya Biswas**). - Migrated testing from Nose to PyTest (by **Tarun Raheja**). - Optimized testing for PyTest and removed duplicated test runners (by **Jake Lishman**). - Deprecated importing `qip` functions to the qutip namespace (by **Boxi Li**). - Added the possibility to define non-square superoperators relevant for quantum circuits (by **Arne Grimsmo** and **Josh Combes**). - Implicit tensor product for `qeye`, `qzero` and `basis` (by **Jake Lishman**). -",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:87068,Testability,test,testing,87068,"-------; - ``husimi`` and ``wigner`` now accept half-integer spin (by **maij**); - Better error messages for failed string coefficient compilation. (issue raised by **nohchangsuk**). Bug Fixes; ---------; - Safer naming for temporary files. (by **Eric Gigure**); - Fix ``clebsch`` function for half-integer (by **Thomas Walker**); - Fix ``randint``'s dtype to ``uint32`` for compatibility with Windows. (issue raised by **Boxi Li**); - Corrected stochastic's heterodyne's m_ops (by **eliegenois**); - Mac pool use spawn. (issue raised by **goerz**); - Fix typos in ``QobjEvo._shift``. (by **Eric Gigure**); - Fix warning on Travis CI. (by **Ivan Carvalho**). Deprecations; ------------; - ``qutip.graph`` functions will be deprecated in QuTiP 5.0 in favour of ``scipy.sparse.csgraph``. Developer Changes; -----------------; - Add Boxi Li to authors. (by **Alex Pitchford**); - Skip some tests that cause segfaults on Mac. (by **Nathan Shammah** and **Eric Gigure**); - Use Python 3.8 for testing on Mac and Linux. (by **Simon Cross** and **Eric Gigure**). Version 4.5.0 (January 31, 2020); ++++++++++++++++++++++++++++++++. Improvements; ------------; - **MAJOR FEATURE**: Added `qip.noise`, a module with pulse level description of quantum circuits allowing to model various types of noise and devices (by **Boxi Li**). - **MAJOR FEATURE**: Added `qip.lattice`, a module for the study of lattice dynamics in 1D (by **Saumya Biswas**). - Migrated testing from Nose to PyTest (by **Tarun Raheja**). - Optimized testing for PyTest and removed duplicated test runners (by **Jake Lishman**). - Deprecated importing `qip` functions to the qutip namespace (by **Boxi Li**). - Added the possibility to define non-square superoperators relevant for quantum circuits (by **Arne Grimsmo** and **Josh Combes**). - Implicit tensor product for `qeye`, `qzero` and `basis` (by **Jake Lishman**). - QObjEvo no longer requires Cython for string coefficient (by **Eric Gigure**). - Added marked tests for faster t",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:87528,Testability,test,testing,87528,"'s m_ops (by **eliegenois**); - Mac pool use spawn. (issue raised by **goerz**); - Fix typos in ``QobjEvo._shift``. (by **Eric Gigure**); - Fix warning on Travis CI. (by **Ivan Carvalho**). Deprecations; ------------; - ``qutip.graph`` functions will be deprecated in QuTiP 5.0 in favour of ``scipy.sparse.csgraph``. Developer Changes; -----------------; - Add Boxi Li to authors. (by **Alex Pitchford**); - Skip some tests that cause segfaults on Mac. (by **Nathan Shammah** and **Eric Gigure**); - Use Python 3.8 for testing on Mac and Linux. (by **Simon Cross** and **Eric Gigure**). Version 4.5.0 (January 31, 2020); ++++++++++++++++++++++++++++++++. Improvements; ------------; - **MAJOR FEATURE**: Added `qip.noise`, a module with pulse level description of quantum circuits allowing to model various types of noise and devices (by **Boxi Li**). - **MAJOR FEATURE**: Added `qip.lattice`, a module for the study of lattice dynamics in 1D (by **Saumya Biswas**). - Migrated testing from Nose to PyTest (by **Tarun Raheja**). - Optimized testing for PyTest and removed duplicated test runners (by **Jake Lishman**). - Deprecated importing `qip` functions to the qutip namespace (by **Boxi Li**). - Added the possibility to define non-square superoperators relevant for quantum circuits (by **Arne Grimsmo** and **Josh Combes**). - Implicit tensor product for `qeye`, `qzero` and `basis` (by **Jake Lishman**). - QObjEvo no longer requires Cython for string coefficient (by **Eric Gigure**). - Added marked tests for faster tests in `testing.run()` and made faster OpenMP benchmarking in CI (by **Eric Gigure**). - Added entropy and purity for Dicke density matrices, refactored into more general dicke_trace (by **Nathan Shammah**). - Added option for specifying resolution in Bloch.save function (by **Tarun Raheja**). - Added information related to the value of hbar in `wigner` and `continuous_variables` (by **Nicolas Quesada**). - Updated requirements for `scipy 1.4` (by **Eric Gigure*",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:87591,Testability,test,testing,87591,"**); - Fix typos in ``QobjEvo._shift``. (by **Eric Gigure**); - Fix warning on Travis CI. (by **Ivan Carvalho**). Deprecations; ------------; - ``qutip.graph`` functions will be deprecated in QuTiP 5.0 in favour of ``scipy.sparse.csgraph``. Developer Changes; -----------------; - Add Boxi Li to authors. (by **Alex Pitchford**); - Skip some tests that cause segfaults on Mac. (by **Nathan Shammah** and **Eric Gigure**); - Use Python 3.8 for testing on Mac and Linux. (by **Simon Cross** and **Eric Gigure**). Version 4.5.0 (January 31, 2020); ++++++++++++++++++++++++++++++++. Improvements; ------------; - **MAJOR FEATURE**: Added `qip.noise`, a module with pulse level description of quantum circuits allowing to model various types of noise and devices (by **Boxi Li**). - **MAJOR FEATURE**: Added `qip.lattice`, a module for the study of lattice dynamics in 1D (by **Saumya Biswas**). - Migrated testing from Nose to PyTest (by **Tarun Raheja**). - Optimized testing for PyTest and removed duplicated test runners (by **Jake Lishman**). - Deprecated importing `qip` functions to the qutip namespace (by **Boxi Li**). - Added the possibility to define non-square superoperators relevant for quantum circuits (by **Arne Grimsmo** and **Josh Combes**). - Implicit tensor product for `qeye`, `qzero` and `basis` (by **Jake Lishman**). - QObjEvo no longer requires Cython for string coefficient (by **Eric Gigure**). - Added marked tests for faster tests in `testing.run()` and made faster OpenMP benchmarking in CI (by **Eric Gigure**). - Added entropy and purity for Dicke density matrices, refactored into more general dicke_trace (by **Nathan Shammah**). - Added option for specifying resolution in Bloch.save function (by **Tarun Raheja**). - Added information related to the value of hbar in `wigner` and `continuous_variables` (by **Nicolas Quesada**). - Updated requirements for `scipy 1.4` (by **Eric Gigure**). - Added previous lead developers to the qutip.about() message (by **Nath",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:87633,Testability,test,test,87633,"**); - Fix typos in ``QobjEvo._shift``. (by **Eric Gigure**); - Fix warning on Travis CI. (by **Ivan Carvalho**). Deprecations; ------------; - ``qutip.graph`` functions will be deprecated in QuTiP 5.0 in favour of ``scipy.sparse.csgraph``. Developer Changes; -----------------; - Add Boxi Li to authors. (by **Alex Pitchford**); - Skip some tests that cause segfaults on Mac. (by **Nathan Shammah** and **Eric Gigure**); - Use Python 3.8 for testing on Mac and Linux. (by **Simon Cross** and **Eric Gigure**). Version 4.5.0 (January 31, 2020); ++++++++++++++++++++++++++++++++. Improvements; ------------; - **MAJOR FEATURE**: Added `qip.noise`, a module with pulse level description of quantum circuits allowing to model various types of noise and devices (by **Boxi Li**). - **MAJOR FEATURE**: Added `qip.lattice`, a module for the study of lattice dynamics in 1D (by **Saumya Biswas**). - Migrated testing from Nose to PyTest (by **Tarun Raheja**). - Optimized testing for PyTest and removed duplicated test runners (by **Jake Lishman**). - Deprecated importing `qip` functions to the qutip namespace (by **Boxi Li**). - Added the possibility to define non-square superoperators relevant for quantum circuits (by **Arne Grimsmo** and **Josh Combes**). - Implicit tensor product for `qeye`, `qzero` and `basis` (by **Jake Lishman**). - QObjEvo no longer requires Cython for string coefficient (by **Eric Gigure**). - Added marked tests for faster tests in `testing.run()` and made faster OpenMP benchmarking in CI (by **Eric Gigure**). - Added entropy and purity for Dicke density matrices, refactored into more general dicke_trace (by **Nathan Shammah**). - Added option for specifying resolution in Bloch.save function (by **Tarun Raheja**). - Added information related to the value of hbar in `wigner` and `continuous_variables` (by **Nicolas Quesada**). - Updated requirements for `scipy 1.4` (by **Eric Gigure**). - Added previous lead developers to the qutip.about() message (by **Nath",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:88060,Testability,test,tests,88060,"esting on Mac and Linux. (by **Simon Cross** and **Eric Gigure**). Version 4.5.0 (January 31, 2020); ++++++++++++++++++++++++++++++++. Improvements; ------------; - **MAJOR FEATURE**: Added `qip.noise`, a module with pulse level description of quantum circuits allowing to model various types of noise and devices (by **Boxi Li**). - **MAJOR FEATURE**: Added `qip.lattice`, a module for the study of lattice dynamics in 1D (by **Saumya Biswas**). - Migrated testing from Nose to PyTest (by **Tarun Raheja**). - Optimized testing for PyTest and removed duplicated test runners (by **Jake Lishman**). - Deprecated importing `qip` functions to the qutip namespace (by **Boxi Li**). - Added the possibility to define non-square superoperators relevant for quantum circuits (by **Arne Grimsmo** and **Josh Combes**). - Implicit tensor product for `qeye`, `qzero` and `basis` (by **Jake Lishman**). - QObjEvo no longer requires Cython for string coefficient (by **Eric Gigure**). - Added marked tests for faster tests in `testing.run()` and made faster OpenMP benchmarking in CI (by **Eric Gigure**). - Added entropy and purity for Dicke density matrices, refactored into more general dicke_trace (by **Nathan Shammah**). - Added option for specifying resolution in Bloch.save function (by **Tarun Raheja**). - Added information related to the value of hbar in `wigner` and `continuous_variables` (by **Nicolas Quesada**). - Updated requirements for `scipy 1.4` (by **Eric Gigure**). - Added previous lead developers to the qutip.about() message (by **Nathan Shammah**). - Added improvements to `Qobj` introducing the `inv` method and making the partial trace, `ptrace`, faster, keeping both sparse and dense methods (by **Eric Gigure**). - Allowed general callable objects to define a time-dependent Hamiltonian (by **Eric Gigure**). - Added feature so that `QobjEvo` no longer requires Cython for string coefficients (by **Eric Gigure**). - Updated authors list on Github and added `my binder` link",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:88077,Testability,test,tests,88077,"esting on Mac and Linux. (by **Simon Cross** and **Eric Gigure**). Version 4.5.0 (January 31, 2020); ++++++++++++++++++++++++++++++++. Improvements; ------------; - **MAJOR FEATURE**: Added `qip.noise`, a module with pulse level description of quantum circuits allowing to model various types of noise and devices (by **Boxi Li**). - **MAJOR FEATURE**: Added `qip.lattice`, a module for the study of lattice dynamics in 1D (by **Saumya Biswas**). - Migrated testing from Nose to PyTest (by **Tarun Raheja**). - Optimized testing for PyTest and removed duplicated test runners (by **Jake Lishman**). - Deprecated importing `qip` functions to the qutip namespace (by **Boxi Li**). - Added the possibility to define non-square superoperators relevant for quantum circuits (by **Arne Grimsmo** and **Josh Combes**). - Implicit tensor product for `qeye`, `qzero` and `basis` (by **Jake Lishman**). - QObjEvo no longer requires Cython for string coefficient (by **Eric Gigure**). - Added marked tests for faster tests in `testing.run()` and made faster OpenMP benchmarking in CI (by **Eric Gigure**). - Added entropy and purity for Dicke density matrices, refactored into more general dicke_trace (by **Nathan Shammah**). - Added option for specifying resolution in Bloch.save function (by **Tarun Raheja**). - Added information related to the value of hbar in `wigner` and `continuous_variables` (by **Nicolas Quesada**). - Updated requirements for `scipy 1.4` (by **Eric Gigure**). - Added previous lead developers to the qutip.about() message (by **Nathan Shammah**). - Added improvements to `Qobj` introducing the `inv` method and making the partial trace, `ptrace`, faster, keeping both sparse and dense methods (by **Eric Gigure**). - Allowed general callable objects to define a time-dependent Hamiltonian (by **Eric Gigure**). - Added feature so that `QobjEvo` no longer requires Cython for string coefficients (by **Eric Gigure**). - Updated authors list on Github and added `my binder` link",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:88087,Testability,test,testing,88087,"esting on Mac and Linux. (by **Simon Cross** and **Eric Gigure**). Version 4.5.0 (January 31, 2020); ++++++++++++++++++++++++++++++++. Improvements; ------------; - **MAJOR FEATURE**: Added `qip.noise`, a module with pulse level description of quantum circuits allowing to model various types of noise and devices (by **Boxi Li**). - **MAJOR FEATURE**: Added `qip.lattice`, a module for the study of lattice dynamics in 1D (by **Saumya Biswas**). - Migrated testing from Nose to PyTest (by **Tarun Raheja**). - Optimized testing for PyTest and removed duplicated test runners (by **Jake Lishman**). - Deprecated importing `qip` functions to the qutip namespace (by **Boxi Li**). - Added the possibility to define non-square superoperators relevant for quantum circuits (by **Arne Grimsmo** and **Josh Combes**). - Implicit tensor product for `qeye`, `qzero` and `basis` (by **Jake Lishman**). - QObjEvo no longer requires Cython for string coefficient (by **Eric Gigure**). - Added marked tests for faster tests in `testing.run()` and made faster OpenMP benchmarking in CI (by **Eric Gigure**). - Added entropy and purity for Dicke density matrices, refactored into more general dicke_trace (by **Nathan Shammah**). - Added option for specifying resolution in Bloch.save function (by **Tarun Raheja**). - Added information related to the value of hbar in `wigner` and `continuous_variables` (by **Nicolas Quesada**). - Updated requirements for `scipy 1.4` (by **Eric Gigure**). - Added previous lead developers to the qutip.about() message (by **Nathan Shammah**). - Added improvements to `Qobj` introducing the `inv` method and making the partial trace, `ptrace`, faster, keeping both sparse and dense methods (by **Eric Gigure**). - Allowed general callable objects to define a time-dependent Hamiltonian (by **Eric Gigure**). - Added feature so that `QobjEvo` no longer requires Cython for string coefficients (by **Eric Gigure**). - Updated authors list on Github and added `my binder` link",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:88125,Testability,benchmark,benchmarking,88125,"re**). Version 4.5.0 (January 31, 2020); ++++++++++++++++++++++++++++++++. Improvements; ------------; - **MAJOR FEATURE**: Added `qip.noise`, a module with pulse level description of quantum circuits allowing to model various types of noise and devices (by **Boxi Li**). - **MAJOR FEATURE**: Added `qip.lattice`, a module for the study of lattice dynamics in 1D (by **Saumya Biswas**). - Migrated testing from Nose to PyTest (by **Tarun Raheja**). - Optimized testing for PyTest and removed duplicated test runners (by **Jake Lishman**). - Deprecated importing `qip` functions to the qutip namespace (by **Boxi Li**). - Added the possibility to define non-square superoperators relevant for quantum circuits (by **Arne Grimsmo** and **Josh Combes**). - Implicit tensor product for `qeye`, `qzero` and `basis` (by **Jake Lishman**). - QObjEvo no longer requires Cython for string coefficient (by **Eric Gigure**). - Added marked tests for faster tests in `testing.run()` and made faster OpenMP benchmarking in CI (by **Eric Gigure**). - Added entropy and purity for Dicke density matrices, refactored into more general dicke_trace (by **Nathan Shammah**). - Added option for specifying resolution in Bloch.save function (by **Tarun Raheja**). - Added information related to the value of hbar in `wigner` and `continuous_variables` (by **Nicolas Quesada**). - Updated requirements for `scipy 1.4` (by **Eric Gigure**). - Added previous lead developers to the qutip.about() message (by **Nathan Shammah**). - Added improvements to `Qobj` introducing the `inv` method and making the partial trace, `ptrace`, faster, keeping both sparse and dense methods (by **Eric Gigure**). - Allowed general callable objects to define a time-dependent Hamiltonian (by **Eric Gigure**). - Added feature so that `QobjEvo` no longer requires Cython for string coefficients (by **Eric Gigure**). - Updated authors list on Github and added `my binder` link (by **Nathan Shammah**). Bug Fixes; ---------. - Fixed `Poly",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:89578,Testability,test,tests,89578,"ious lead developers to the qutip.about() message (by **Nathan Shammah**). - Added improvements to `Qobj` introducing the `inv` method and making the partial trace, `ptrace`, faster, keeping both sparse and dense methods (by **Eric Gigure**). - Allowed general callable objects to define a time-dependent Hamiltonian (by **Eric Gigure**). - Added feature so that `QobjEvo` no longer requires Cython for string coefficients (by **Eric Gigure**). - Updated authors list on Github and added `my binder` link (by **Nathan Shammah**). Bug Fixes; ---------. - Fixed `PolyDataMapper` construction for `Bloch3d` (by **Sam Griffiths**). - Fixed error checking for null matrix in essolve (by **Nathan Shammah**). - Fixed name collision for parallel propagator (by **Nathan Shammah**). - Fixed dimensional incongruence in `propagator` (by **Nathan Shammah**). - Fixed bug by rewriting clebsch function based on long integer fraction (by **Eric Gigure**). - Fixed bugs in QobjEvo's args depending on state and added solver tests using them (by **Eric Gigure**). - Fixed bug in `sesolve` calculation of average states when summing the timeslot states (by **Alex Pitchford**). - Fixed bug in `steadystate` solver by removing separate arguments for MKL and Scipy (by **Tarun Raheja**). - Fixed `Bloch.add_ponts` by setting `edgecolor = None` in `plot_points` (by **Nathan Shammah**). - Fixed error checking for null matrix in `essolve` solver affecting also `ode2es` (by **Peter Kirton**). - Removed unnecessary shebangs in .pyx and .pxd files (by **Samesh Lakhotia**). - Fixed `sesolve` and import of `os` in `codegen` (by **Alex Pitchford**). - Updated `plot_fock_distribution` by removing the offset value 0.4 in the plot (by **Rajiv-B**). Version 4.4.1 (August 29, 2019); +++++++++++++++++++++++++++++++. Improvements; ------------. - QobjEvo do not need to start from 0 anymore (by **Eric Gigure**). - Add a quantum object purity function (by **Nathan Shammah** and **Shahnawaz Ahmed**). - Add step functi",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:97346,Testability,test,tests,97346,"++++++++++++. Improvements; ------------. *Core libraries*. - **MAJOR FEATURE**: QuTiP now works for Python 3.5+ on Windows using Visual Studio 2015. - **MAJOR FEATURE**: Cython and other low level code switched to C++ for MS Windows compatibility. - **MAJOR FEATURE**: Can now use interpolating cubic splines as time-dependent coefficients. - **MAJOR FEATURE**: Sparse matrix - vector multiplication now parallel using OPENMP. - Automatic tuning of OPENMP threading threshold. - Partial trace function is now up to 100x+ faster. - Hermitian verification now up to 100x+ faster. - Internal Qobj objects now created up to 60x faster. - Inplace conversion from COO -> CSR sparse formats (e.g. Memory efficiency improvement.). - Faster reverse Cuthill-Mckee and sparse one and inf norms. Bug Fixes; ---------. - Cleanup of temp. Cython files now more robust and working under Windows. Version 4.0.2 (January 5, 2017); +++++++++++++++++++++++++++++++. Bug Fixes; ---------; - td files no longer left behind by correlation tests; - Various fast sparse fixes. Version 4.0.0 (December 22, 2016); +++++++++++++++++++++++++++++++++. Improvements; ------------; *Core libraries*. - **MAJOR FEATURE**: Fast sparse: New subclass of csr_matrix added that overrides commonly used methods to avoid certain checks that incurr execution cost. All Qobj.data now fast_csr_matrix; - HEOM performance enhancements; - spmv now faster; - mcsolve codegen further optimised. *Control modules*. - Time dependent drift (through list of pwc dynamics generators); - memory optimisation options provided for control.dynamics. Bug Fixes; ---------. - recompilation of pyx files on first import removed; - tau array in control.pulseoptim funcs now works. Version 3.2.0 (Never officially released); +++++++++++++++++++++++++++++++++++++++++. New Features; ------------. *Core libraries*. - **MAJOR FEATURE**: Non-Markovian solvers: Hierarchy (**Added by Neill Lambert**), Memory-Cascade, and Transfer-Tensor methods.; - **MAJOR FEATU",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:102583,Testability,test,tests,102583,_dyn_gen`` (no longer returns a value); - ``get_dyn_gen`` now ``_get_phased_dyn_gen``; - ``get_ctrl_den_gen`` now ``_get_phased_ctrl_dyn_gen``; - ``ensure_decomp_curr`` now ``_ensure_decomp_curr``; - ``spectral_decomp`` now ``_spectral_decomp``. - dynamics properties. - ``evo_init2t`` now ``_fwd_evo`` (``fwd_evo`` as Qobj); - ``evo_t2end`` now ``_onwd_evo`` (``onwd_evo`` as Qobj); - ``evo_t2targ`` now ``_onto_evo`` (``onto_evo`` as Qobj). - fidcomp properties. - ``uses_evo_t2end`` now ``uses_onwd_evo``; - ``uses_evo_t2targ`` now ``uses_onto_evo``; - ``set_phase_option`` function now property ``phase_option``. - propcomp properties. - ``grad_exact`` (now read only). - propcomp functions. - ``compute_propagator`` now ``_compute_propagator``; - ``compute_diff_prop`` now ``_compute_diff_prop``; - ``compute_prop_grad`` now ``_compute_prop_grad``. - tslotcomp functions. - ``get_timeslot_for_fidelity_calc`` now ``_get_timeslot_for_fidelity_calc``. *Miscellaneous*. - QuTiP Travis CI tests now use the Anaconda distribution.; - The ``about`` box and ipynb ``version_table`` now display addition system information.; - Updated Cython cleanup to remove depreciation warning in sysconfig.; - Updated ipynb_parallel to look for ``ipyparallel`` module in V4 of the notebooks. Bug Fixes; ---------; - Fixes for countstat and psuedo-inverse functions; - Fixed Qobj division tests on 32-bit systems.; - Removed extra call to Python in time-dependent Cython code.; - Fixed issue with repeated Bloch sphere saving.; - Fixed T_0 triplet state not normalized properly. (**Fixed by Eric Hontz**); - Simplified compiler flags (support for ARM systems).; - Fixed a decoding error in ``qload``.; - Fixed issue using complex.h math and np.kind_t variables.; - Corrected output states mismatch for ``ntraj=1`` in the mcf90 solver.; - Qobj data is now copied by default to avoid a bug in multiplication. (**Fixed by Richard Brierley**); - Fixed bug overwriting ``hardware_info`` in ``__init__``. (**Fixed by Johann,MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:102966,Testability,test,tests,102966,"end`` now ``_onwd_evo`` (``onwd_evo`` as Qobj); - ``evo_t2targ`` now ``_onto_evo`` (``onto_evo`` as Qobj). - fidcomp properties. - ``uses_evo_t2end`` now ``uses_onwd_evo``; - ``uses_evo_t2targ`` now ``uses_onto_evo``; - ``set_phase_option`` function now property ``phase_option``. - propcomp properties. - ``grad_exact`` (now read only). - propcomp functions. - ``compute_propagator`` now ``_compute_propagator``; - ``compute_diff_prop`` now ``_compute_diff_prop``; - ``compute_prop_grad`` now ``_compute_prop_grad``. - tslotcomp functions. - ``get_timeslot_for_fidelity_calc`` now ``_get_timeslot_for_fidelity_calc``. *Miscellaneous*. - QuTiP Travis CI tests now use the Anaconda distribution.; - The ``about`` box and ipynb ``version_table`` now display addition system information.; - Updated Cython cleanup to remove depreciation warning in sysconfig.; - Updated ipynb_parallel to look for ``ipyparallel`` module in V4 of the notebooks. Bug Fixes; ---------; - Fixes for countstat and psuedo-inverse functions; - Fixed Qobj division tests on 32-bit systems.; - Removed extra call to Python in time-dependent Cython code.; - Fixed issue with repeated Bloch sphere saving.; - Fixed T_0 triplet state not normalized properly. (**Fixed by Eric Hontz**); - Simplified compiler flags (support for ARM systems).; - Fixed a decoding error in ``qload``.; - Fixed issue using complex.h math and np.kind_t variables.; - Corrected output states mismatch for ``ntraj=1`` in the mcf90 solver.; - Qobj data is now copied by default to avoid a bug in multiplication. (**Fixed by Richard Brierley**); - Fixed bug overwriting ``hardware_info`` in ``__init__``. (**Fixed by Johannes Feist**); - Restored ability to explicity set Q.isherm, Q.type, and Q.superrep.; - Fixed integer depreciation warnings from NumPy.; - Qobj * (dense vec) would result in a recursive loop.; - Fixed args=None -> args={} in correlation functions to be compatible with mesolve.; - Fixed depreciation warnings in mcsolve.; - Fixed neagtive",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:104731,Testability,log,logging,104731,"vec) would result in a recursive loop.; - Fixed args=None -> args={} in correlation functions to be compatible with mesolve.; - Fixed depreciation warnings in mcsolve.; - Fixed neagtive only real parts in ``rand_ket``.; - Fixed a complicated list-cast-map-list antipattern in super operator reps. (**Fixed by Stefan Krastanov**); - Fixed incorrect ``isherm`` for ``sigmam`` spin operator.; - Fixed the dims when using ``final_state_output`` in ``mesolve`` and ``sesolve``. Version 3.1.0 (January 1, 2015); +++++++++++++++++++++++++++++++. New Features; ------------. - **MAJOR FEATURE**: New module for quantum control (qutip.control).; - **NAMESPACE CHANGE**: QuTiP no longer exports symbols from NumPy and matplotlib, so those modules must now be explicitly imported when required.; - New module for counting statistics.; - Stochastic solvers now run trajectories in parallel.; - New superoperator and tensor manipulation functions; (super_tensor, composite, tensor_contract).; - New logging module for debugging (qutip.logging).; - New user-available API for parallelization (parallel_map).; - New enhanced (optional) text-based progressbar (qutip.ui.EnhancedTextProgressBar); - Faster Python based monte carlo solver (mcsolve).; - Support for progress bars in propagator function.; - Time-dependent Cython code now calls complex cmath functions.; - Random numbers seeds can now be reused for successive calls to mcsolve.; - The Bloch-Redfield master equation solver now supports optional Lindblad type collapse operators.; - Improved handling of ODE integration errors in mesolve.; - Improved correlation function module (for example, improved support for time-dependent problems).; - Improved parallelization of mcsolve (can now be interrupted easily, support for IPython.parallel, etc.); - Many performance improvements, and much internal code restructuring. Bug Fixes; ---------. - Cython build files for time-dependent string format now removed automatically.; - Fixed incorrect solution time",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:104767,Testability,log,logging,104767,"ursive loop.; - Fixed args=None -> args={} in correlation functions to be compatible with mesolve.; - Fixed depreciation warnings in mcsolve.; - Fixed neagtive only real parts in ``rand_ket``.; - Fixed a complicated list-cast-map-list antipattern in super operator reps. (**Fixed by Stefan Krastanov**); - Fixed incorrect ``isherm`` for ``sigmam`` spin operator.; - Fixed the dims when using ``final_state_output`` in ``mesolve`` and ``sesolve``. Version 3.1.0 (January 1, 2015); +++++++++++++++++++++++++++++++. New Features; ------------. - **MAJOR FEATURE**: New module for quantum control (qutip.control).; - **NAMESPACE CHANGE**: QuTiP no longer exports symbols from NumPy and matplotlib, so those modules must now be explicitly imported when required.; - New module for counting statistics.; - Stochastic solvers now run trajectories in parallel.; - New superoperator and tensor manipulation functions; (super_tensor, composite, tensor_contract).; - New logging module for debugging (qutip.logging).; - New user-available API for parallelization (parallel_map).; - New enhanced (optional) text-based progressbar (qutip.ui.EnhancedTextProgressBar); - Faster Python based monte carlo solver (mcsolve).; - Support for progress bars in propagator function.; - Time-dependent Cython code now calls complex cmath functions.; - Random numbers seeds can now be reused for successive calls to mcsolve.; - The Bloch-Redfield master equation solver now supports optional Lindblad type collapse operators.; - Improved handling of ODE integration errors in mesolve.; - Improved correlation function module (for example, improved support for time-dependent problems).; - Improved parallelization of mcsolve (can now be interrupted easily, support for IPython.parallel, etc.); - Many performance improvements, and much internal code restructuring. Bug Fixes; ---------. - Cython build files for time-dependent string format now removed automatically.; - Fixed incorrect solution time from inverse-power method ",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:111218,Testability,test,tests,111218,"ple can be used for solving; master equations with mean field terms. Improvements; ------------. - Restructured and optimized implementation of Qobj, which now has; significantly lower memory footprint due to avoiding excessive copying of; internal matrix data. - The classes ``OdeData``, ``Odeoptions``, ``Odeconfig`` are now called; ``Result``, ``Options``, and ``Config``, respectively, and are available in; the module `qutip.solver`. - The ``squeez`` function has been renamed to ``squeeze``. - Better support for sparse matrices when calculating propagators using the; ``propagator`` function. - Improved Bloch sphere. - Restructured and improved the module ``qutip.sparse``, which now only; operates directly on sparse matrices (not on Qobj instances). - Improved and simplified implement of the ``tensor`` function. - Improved performance, major code cleanup (including namespace changes),; and numerous bug fixes. - Benchmark scripts improved and restructured. - QuTiP is now using continuous integration tests (TravisCI). Version 2.2.0 (March 01, 2013); ++++++++++++++++++++++++++++++. New Features; ------------. - **Added Support for Windows**. - New Bloch3d class for plotting 3D Bloch spheres using Mayavi. - Bloch sphere vectors now look like arrows. - Partial transpose function. - Continuos variable functions for calculating correlation and covariance; matrices, the Wigner covariance matrix and the logarithmic negativity for; for multimode fields in Fock basis. - The master-equation solver (mesolve) now accepts pre-constructed Liouvillian; terms, which makes it possible to solve master equations that are not on; the standard Lindblad form. - Optional Fortran Monte Carlo solver (mcsolve_f90) by Arne Grimsmo. - A module of tools for using QuTiP in IPython notebooks. - Increased performance of the steady state solver. - New Wigner colormap for highlighting negative values. - More graph styles to the visualization module. Bug Fixes; ---------. - Function based time-dependen",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:111622,Testability,log,logarithmic,111622,", and are available in; the module `qutip.solver`. - The ``squeez`` function has been renamed to ``squeeze``. - Better support for sparse matrices when calculating propagators using the; ``propagator`` function. - Improved Bloch sphere. - Restructured and improved the module ``qutip.sparse``, which now only; operates directly on sparse matrices (not on Qobj instances). - Improved and simplified implement of the ``tensor`` function. - Improved performance, major code cleanup (including namespace changes),; and numerous bug fixes. - Benchmark scripts improved and restructured. - QuTiP is now using continuous integration tests (TravisCI). Version 2.2.0 (March 01, 2013); ++++++++++++++++++++++++++++++. New Features; ------------. - **Added Support for Windows**. - New Bloch3d class for plotting 3D Bloch spheres using Mayavi. - Bloch sphere vectors now look like arrows. - Partial transpose function. - Continuos variable functions for calculating correlation and covariance; matrices, the Wigner covariance matrix and the logarithmic negativity for; for multimode fields in Fock basis. - The master-equation solver (mesolve) now accepts pre-constructed Liouvillian; terms, which makes it possible to solve master equations that are not on; the standard Lindblad form. - Optional Fortran Monte Carlo solver (mcsolve_f90) by Arne Grimsmo. - A module of tools for using QuTiP in IPython notebooks. - Increased performance of the steady state solver. - New Wigner colormap for highlighting negative values. - More graph styles to the visualization module. Bug Fixes; ---------. - Function based time-dependent Hamiltonians now keep the correct phase. - mcsolve no longer prints to the command line if ntraj=1. Version 2.1.0 (October 05, 2012); ++++++++++++++++++++++++++++++++. New Features; ------------. - New method for generating Wigner functions based on Laguerre polynomials. - coherent(), coherent_dm(), and thermal_dm() can now be expressed using analytic values. - Unittests now use nose",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:115883,Testability,test,tests,115883,"tion of quantum objects is now more efficient. - Quantum objects have basis transformation and matrix element calculations as built-in methods. - The quantum object eigensolver can use sparse solvers. - The partial-trace (ptrace) function is up to 20x faster. - The Bloch sphere can now be used with the Matplotlib animation function, and embedded as a subplot in a figure. - QuTiP has built-in functions for saving quantum objects and data arrays. - The steady-state solver has been further optimized for sparse matrices, and can handle much larger system Hamiltonians. - The steady-state solver can use the iterative bi-conjugate gradient method instead of a direct solver. - There are three new entropy functions for concurrence, mutual information, and conditional entropy. - Correlation functions have been combined under a single function. - The operator norm can now be set to trace, Frobius, one, or max norm. - Global QuTiP settings can now be modified. - QuTiP includes a collection of unit tests for verifying the installation. - Demos window now lets you copy and paste code from each example. Version 1.1.4 (May 28, 2012); ++++++++++++++++++++++++++++. Bug Fixes; ---------. - Fixed bug pointed out by Brendan Abolins. - Qobj.tr() returns zero-dim ndarray instead of float or complex. - Updated factorial import for scipy version 0.10+. Version 1.1.3 (November 21, 2011); +++++++++++++++++++++++++++++++++. New Functions; -------------. - Allow custom naming of Bloch sphere. Bug Fixes; ---------; - Fixed text alignment issues in AboutBox. - Added fix for SciPy V>0.10 where factorial was moved to scipy.misc module. - Added tidyup function to tensor function output. - Removed openmp flags from setup.py as new Mac Xcode compiler does not recognize them. - Qobj diag method now returns real array if all imaginary parts are zero. - Examples GUI now links to new documentation. - Fixed zero-dimensional array output from metrics module. Version 1.1.2 (October 27, 2011); +++++++++++++++",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:751,Usability,guid,guide-states,751,".. _changelog:. **********; Change Log; **********. .. towncrier release notes start. QuTiP 5.0.4 (2024-08-30); ========================. Micro release to add support for numpy 2.1. Bug Fixes; ---------. - Fixed rounding error in dicke_trace_function that resulted in negative eigenvalues. (#2466, by Andrey Nikitin). QuTiP 5.0.3 (2024-06-20); ========================. Micro release to add support for numpy 2. Bug Fixes; ---------. - Bug Fix in Process Matrix Rendering. (#2400, by Anush Venkatakrishnan); - Fix steadystate permutation being reversed. (#2443); - Add parallelizing support for `vernN` methods with `mcsolve`. (#2454 by Utkarsh). Documentation; -------------. - Added `qutip.core.gates` to apidoc/functions.rst and a Gates section to guide-states.rst. (#2441, by alan-nala). Miscellaneous; -------------. - Add support for numpy 2 (#2421, #2457); - Add support for scipy 1.14 (#2469). QuTiP 5.0.2 (2024-05-16); ========================. Bug Fixes; ---------. - Use CSR as the default for expand_operator (#2380, by BoxiLi); - Fix import of the partial_transpose function.; Ensures that the negativity function can handle both kets and density operators as input. (#2371, by vikas-chaudhary-2802); - Ensure that end_condition of mcsolve result doesn't say target tolerance reached when it hasn't (#2382, by magzpavz); - Fix two bugs in steadystate floquet solver, and adjust tests to be sensitive to this issue. (#2393, by Neill Lambert). Documentation; -------------. - Correct a mistake in the doc (#2401, by PositroniumJS); - Fix #2156: Correct a sample of code in the doc (#2409, by PositroniumJS). Miscellaneous; -------------. - Better metadata management in operators creation functions (#2388); - Implicitly set minimum python version to 3.9 (#2413); - Qobj.__eq__ uses core's settings rtol. (#2425); - Only normalize solver states when the initial state is already normalized. (#2427). QuTiP 5.0.1 (2024-04-03); ========================. Patch update fixing small issues with ",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:2245,Usability,progress bar,progress bars,2245," both kets and density operators as input. (#2371, by vikas-chaudhary-2802); - Ensure that end_condition of mcsolve result doesn't say target tolerance reached when it hasn't (#2382, by magzpavz); - Fix two bugs in steadystate floquet solver, and adjust tests to be sensitive to this issue. (#2393, by Neill Lambert). Documentation; -------------. - Correct a mistake in the doc (#2401, by PositroniumJS); - Fix #2156: Correct a sample of code in the doc (#2409, by PositroniumJS). Miscellaneous; -------------. - Better metadata management in operators creation functions (#2388); - Implicitly set minimum python version to 3.9 (#2413); - Qobj.__eq__ uses core's settings rtol. (#2425); - Only normalize solver states when the initial state is already normalized. (#2427). QuTiP 5.0.1 (2024-04-03); ========================. Patch update fixing small issues with v5.0.0 release. - Fix broken links in the documentation when migrating to readthedocs; - Fix readthedocs search feature; - Add setuptools to runtime compilation requirements; - Fix mcsolve documentation for open systems; - Fix OverFlowError in progress bars. QuTiP 5.0.0 (2024-03-26); ========================. QuTiP 5 is a redesign of many of the core components of QuTiP (``Qobj``,; ``QobjEvo``, solvers) to make them more consistent and more flexible. ``Qobj`` may now be stored in either sparse or dense representations,; and the two may be mixed sensibly as needed. ``QobjEvo`` is now used; consistently throughout QuTiP, and the implementation has been; substantially cleaned up. A new ``Coefficient`` class is used to; represent the time-dependent factors inside ``QobjEvo``. The solvers have been rewritten to work well with the new data layer; and the concept of ``Integrators`` which solve ODEs has been introduced.; In future, new data layers may provide their own ``Integrators``; specialized to their representation of the underlying data. Much of the user-facing API of QuTiP remains familiar, but there have; had to be man",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:6208,Usability,guid,guide,6208,"fic contributions are; detailed below:. - Pieter Eendebak (updated the required SciPy to 1.5+, `#1982 <https://github.com/qutip/qutip/pull/1982>`).; - Pieter Eendebak (reduced import times by setting logger names, `#1981 <https://github.com/qutip/qutip/pull/1981>`); - Pieter Eendebak (Allow scipy 1.12 to be used with qutip, `#2354 <https://github.com/qutip/qutip/pull/2354>`); - Xavier Sproken (included C header files in the source distribution, `#1971 <https://github.com/qutip/qutip/pull/1971>`); - Christian Staufenbiel (added support for multiple collapse operators to the Floquet solver, `#1962 <https://github.com/qutip/qutip/pull/1962>`); - Christian Staufenbiel (fixed the basis used in the Floquet Master Equation solver, `#1952 <https://github.com/qutip/qutip/pull/1952>`); - Christian Staufenbiel (allowed the ``bloch_redfield_tensor`` function to accept strings and callables for `a_ops`, `#1951 <https://github.com/qutip/qutip/pull/1951>`); - Christian Staufenbiel (Add a guide on Superoperators, Pauli Basis and Channel Contraction, `#1984 <https://github.com/qutip/qutip/pull/1984>`); - Henrique Silvro (allowed ``qutip_qip`` to be imported as ``qutip.qip``, `#1920 <https://github.com/qutip/qutip/pull/1920>`); - Florian Hopfmueller (added a vastly improved implementations of ``process_fidelity`` and ``average_gate_fidelity``, `#1712 <https://github.com/qutip/qutip/pull/1712>`, `#1748 <https://github.com/qutip/qutip/pull/1748>`, `#1788 <https://github.com/qutip/qutip/pull/1788>`); - Felipe Bivort Haiek (fixed inaccuracy in docstring of the dense implementation of negation, `#1608 <https://github.com/qutip/qutip/pull/1608/>`); - Rajath Shetty (added support for specifying colors for individual points, vectors and states display by `qutip.Bloch`, `#1335 <https://github.com/qutip/qutip/pull/1335>`); - Rochisha Agarwal (Add dtype to printed ouput of qobj, `#2352 <https://github.com/qutip/qutip/pull/2352>`); - Kosuke Mizuno (Add arguments of plot_wigner() and plot_wigner",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:14673,Usability,progress bar,progress bar,14673,"ly reworked and standardized.; Under the hood solvers now make use of swappable ODE ``Integrators``.; Many ``Integrators`` are included (see the list below) and; custom implementations are possible. Solvers now consistently; accept a ``QobjEvo`` instance at the Hamiltonian or Liouvillian, or; any object which can be passed to the ``QobjEvo`` constructor. A breakdown of highlights follows. All solvers:. - Solver options are now supplied in an ordinary Python dict.; ``qutip.Options`` is deprecated and returns a dict for backwards; compatibility.; - A specific ODE integrator may be selected by supplying a; ``method`` option.; - Each solver provides a class interface. Creating an instance; of the class allows a solver to be run multiple times for the; same system without having to repeatedly reconstruct the; right-hand side of the ODE to be integrated.; - A ``QobjEvo`` instance is accepted for most operators, e.g.,; ``H``, ``c_ops``, ``e_ops``, ``a_ops``.; - The progress bar is now selected using the ``progress_bar`` option.; A new progess bar using the ``tqdm`` Python library is provided.; - Dynamic arguments, where the value of an operator depends on; the current state of the evolution interface reworked. Now a property of the; solver is to be used as an arguments:; ``args={""state"": MESolver.StateFeedback(default=rho0)}``. Integrators:. - The SciPy zvode integrator is available with the BDF and; Adams methods as ``bdf`` and ``adams``.; - The SciPy dop853 integrator (an eighth order Runge-Kutta method by; Dormand & Prince) is available as ``dop853``.; - The SciPy lsoda integrator is available as ``lsoda``.; - QuTiP's own implementation of Verner's ""most efficient"" Runge-Kutta methods; of order 7 and 9 are available as ``vern7`` and ``vern9``. See; http://people.math.sfu.ca/~jverner/ for a description of the methods.; - QuTiP's own implementation of a solver that directly diagonalizes the; the system to be integrated is available as ``diag``. It only works on; time-indep",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:15946,Usability,usab,usable,15946," solver is to be used as an arguments:; ``args={""state"": MESolver.StateFeedback(default=rho0)}``. Integrators:. - The SciPy zvode integrator is available with the BDF and; Adams methods as ``bdf`` and ``adams``.; - The SciPy dop853 integrator (an eighth order Runge-Kutta method by; Dormand & Prince) is available as ``dop853``.; - The SciPy lsoda integrator is available as ``lsoda``.; - QuTiP's own implementation of Verner's ""most efficient"" Runge-Kutta methods; of order 7 and 9 are available as ``vern7`` and ``vern9``. See; http://people.math.sfu.ca/~jverner/ for a description of the methods.; - QuTiP's own implementation of a solver that directly diagonalizes the; the system to be integrated is available as ``diag``. It only works on; time-independent systems and is slow to setup, but once the diagonalization; is complete, it generates solutions very quickly.; - QuTiP's own implementatoin of an approximate Krylov subspace integrator is; available as ``krylov``. This integrator is only usable with ``sesolve``. Result class:. - A new ``.e_data`` attribute provides expectation values as a dictionary.; Unlike ``.expect``, the values are provided in a Python list rather than; a numpy array, which better supports non-numeric types.; - The contents of the ``.stats`` attribute changed significantly and is; now more consistent across solvers. Monte-Carlo Solver (mcsolve):. - The system, H, may now be a super-operator.; - The ``seed`` parameter now supports supplying numpy ``SeedSequence`` or; ``Generator`` types.; - The new ``timeout`` and ``target_tol`` parameters allow the solver to exit; early if a timeout or target tolerance is reached.; - The ntraj option no longer supports a list of numbers of trajectories.; Instead, just run the solver multiple times and use the class ``MCSolver``; if setting up the solver uses a significant amount of time.; - The ``map_func`` parameter has been replaced by the ``map`` option.; - A loky based parallel map as been added.; - A mpi based",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:18219,Usability,feedback,feedback,18219,"e ``parallel_map``, ``loky_map`` or ``mpi_pmap`` instead.; - Added improved sampling options which converge much faster when the; probability of collapse is small. Non Markovian Monte-Carlo Solver (nm_mcsolve):. - New Monte-Carlo Solver supporting negative decay rates.; - Based on the influence martingale approach, Donvil et al., Nat Commun 13, 4140 (2022).; - Most of the improvements made to the regular Monte-Carlo solver are also available here.; - The value of the influence martingale is available through the ``.trace`` attribute of the result. Stochastic Equation Solvers (ssesolve, smesolve). - Function call greatly changed: many keyword arguments are now options.; - m_ops and dW_factors are now changed from the default from the new class interface only.; - Use the same parallel maps as mcsolve: support for loky and mpi map added.; - End conditions ``timeout`` and ``target_tol`` added.; - The ``seed`` parameter now supports supplying numpy ``SeedSequence``.; - Wiener function is now available as a feedback. Bloch-Redfield Master Equation Solver (brmesolve):. - The ``a_ops`` and ``spectra`` support implementations been heavily reworked to; reuse the techniques from the new Coefficient and QobjEvo classes.; - The ``use_secular`` parameter has been removed. Use ``sec_cutoff=-1`` instead.; - The required tolerance is now read from ``qutip.settings``. Krylov Subspace Solver (krylovsolve):. - The Krylov solver is now implemented using ``SESolver`` and the ``krylov``; ODE integrator. The function ``krylovsolve`` is maintained for convenience; and now supports many more options.; - The ``sparse`` parameter has been removed. Supply a sparse ``Qobj`` for the; Hamiltonian instead. Floquet Solver (fsesolve and fmmesolve):. - The Floquet solver has been rewritten to use a new ``FloquetBasis`` class; which manages the transformations from lab to Floquet basis and back.; - Many of the internal methods used by the old Floquet solvers have; been removed. The Floquet tensor may st",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:27526,Usability,feedback,feedback,27526," in a future QuTiP release.; - The ``qutip.parfor`` function has been removed. Use ``qutip.parallel_map`` instead.; - ``qutip.graph`` has been removed and replaced by SciPy's graph functions.; - ``qutip.topology`` has been removed. It contained only one function ``berry_curvature``.; - The ``~/.qutip/qutiprc`` config file is no longer supported. It contained settings for the OpenMP support.; - Deprecate ``three_level_atom``; - Deprecate ``orbital``. Changes from QuTiP 5.0.0b1:; ---------------------------. Features; --------. - Add dtype to printed ouput of qobj (#2352 by Rochisha Agarwal). Miscellaneous; -------------. - Allow scipy 1.12 to be used with qutip. (#2354 by Pieter Eendebak). QuTiP 5.0.0b1 (2024-03-04); ==========================. Features; --------. - Create a Dimension class (#1996); - Add arguments of plot_wigner() and plot_wigner_fock_distribution() to specify parameters for wigner(). (#2057, by Kosuke Mizuno); - Restore feedback to solvers (#2210); - Added mpi_pmap, which uses the mpi4py module to run computations in parallel through the MPI interface. (#2296, by Paul); - Only pre-compute density matrices if keep_runs_results is False (#2303, by Matt Ord). Bug Fixes; ---------. - Add the possibility to customize point colors as in V4 and fix point plot behavior for 'l' style (#1974, by Daniel Moreno Galn); - Disabled broken ""improved sampling"" for `nm_mcsolve`. (#2234, by Paul); - Fixed result objects storing a reference to the solver through options._feedback. (#2262, by Paul); - Fixed simdiag not returning orthonormal eigenvectors. (#2269, by Sola85); - Fix LaTeX display of Qobj state in Jupyter cell outputs (#2272, by Edward Thomas); - Improved behavior of `parallel_map` and `loky_pmap` in the case of timeouts, errors or keyboard interrupts (#2280, by Paul); - Ignore deprecation warnings from cython 0.29.X in tests. (#2288); - Fixed two problems with the steady_state() solver in the HEOM method. (#2333). Miscellaneous; -------------. - Improve ",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:28630,Usability,guid,guide,28630,"rough the MPI interface. (#2296, by Paul); - Only pre-compute density matrices if keep_runs_results is False (#2303, by Matt Ord). Bug Fixes; ---------. - Add the possibility to customize point colors as in V4 and fix point plot behavior for 'l' style (#1974, by Daniel Moreno Galn); - Disabled broken ""improved sampling"" for `nm_mcsolve`. (#2234, by Paul); - Fixed result objects storing a reference to the solver through options._feedback. (#2262, by Paul); - Fixed simdiag not returning orthonormal eigenvectors. (#2269, by Sola85); - Fix LaTeX display of Qobj state in Jupyter cell outputs (#2272, by Edward Thomas); - Improved behavior of `parallel_map` and `loky_pmap` in the case of timeouts, errors or keyboard interrupts (#2280, by Paul); - Ignore deprecation warnings from cython 0.29.X in tests. (#2288); - Fixed two problems with the steady_state() solver in the HEOM method. (#2333). Miscellaneous; -------------. - Improve fidelity doc-string (#2257); - Improve documentation in guide/dynamics (#2271); - Improve states and operator parameters documentation. (#2289); - Rework `kraus_to_choi` making it faster (#2284, by Bogdan Reznychenko); - Remove Bloch3D: redundant to Bloch (#2306); - Allow tests to run without matplotlib and ipython. (#2311); - Add too small step warnings in fixed dt SODE solver (#2313); - Add `dtype` to `Qobj` and `QobjEvo` (#2325); - Fix typos in `expect` documentation (#2331, by gabbence95); - Allow measurement functions to support degenerate operators. (#2342). QuTiP 5.0.0a2 (2023-09-06); ==========================. Features; --------. - Add support for different spectra types for bloch_redfield_tensor (#1951); - Improve qutip import times by setting logger names explicitly. (#1981, by Pieter Eendebak); - Change the order of parameters in expand_operator (#1991); - Add `svn` and `solve` to dispatched (#2002); - Added nm_mcsolve to provide support for Monte-Carlo simulations of master equations with possibly negative rates. The method implement",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:31776,Usability,guid,guide,31776,"sampling algorithm for mcsolve (#2218 by Daniel Weiss); - Added support for early termination of map functions. (#2222). Bug Fixes; ---------. - Add missing state transformation to floquet_markov_mesolve (#1952 by christian512); - Added default _isherm value (True) for momentum and position operators. (#2032 by Asier Galicia); - Changed qutip-notebooks to qutip-tutorials and fixed the typo in the link redirecting to the changelog section in the PR template. (#2107 by Valan Baptist Mathuranayagam); - Increase missing colorbar padding for matrix_histogram_complex() from 0 to 0.05. (#2181 by SJUW); - Raise error on insufficient memory. (#2224); - Fixed fallback to fsesolve call in fmmesolve (#2225). Removals; --------. - Remove qutip.control and replace with qutip_qtrl. (#2116); - Deleted _solve in countstat.py and used _data.solve. (#2120 by Yuji Tamakoshi); - Deprecate three_level_atom (#2221); - Deprecate orbital (#2223). Documentation; -------------. - Add a guide on Superoperators, Pauli Basis and Channel Contraction. (#1984 by christian512); - Added information on sec_cutoff to the documentation (#2136 by Gerardo Jose Suarez); - Added inherited members to API doc of MESolver, SMESolver, SSESolver, NonMarkovianMCSolver (#2167 by Cristian Emiliano Godinez Ramirez); - Corrected grammar in Bloch-Redfield master equation documentation (#2174 by Andrey Rakhubovsky). Miscellaneous; -------------. - Update scipy version requirement to 1.5+ (#1982 by Pieter Eendebak); - Added __all__ to qutip/measurements.py and qutip/core/semidefinite.py (#2103 by Rushiraj Gadhvi); - Restore towncrier check (#2105); - qutip.ipynbtools.version_table() can now be called without Cython installed (#2110 by Rushiraj Gadhvi); - Moved HTMLProgressBar from qutip/ipynbtools.py to qutip/ui/progressbar.py (#2112 by Harsh Khilawala); - Added new argument bc_type to take boundary conditions when creating QobjEvo (#2114 by Avatar Srinidhi P V ); - Remove Windows build warning suppression. (#2119); - O",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:41427,Usability,progress bar,progress bar,41427,"ly reworked and standardized.; Under the hood solvers now make use of swappable ODE ``Integrators``.; Many ``Integrators`` are included (see the list below) and; custom implementations are possible. Solvers now consistently; accept a ``QobjEvo`` instance at the Hamiltonian or Liouvillian, or; any object which can be passed to the ``QobjEvo`` constructor. A breakdown of highlights follows. All solvers:. - Solver options are now supplied in an ordinary Python dict.; ``qutip.Options`` is deprecated and returns a dict for backwards; compatibility.; - A specific ODE integrator may be selected by supplying a; ``method`` option.; - Each solver provides a class interface. Creating an instance; of the class allows a solver to be run multiple times for the; same system without having to repeatedly reconstruct the; right-hand side of the ODE to be integrated.; - A ``QobjEvo`` instance is accepted for most operators, e.g.,; ``H``, ``c_ops``, ``e_ops``, ``a_ops``.; - The progress bar is now selected using the ``progress_bar`` option.; A new progess bar using the ``tqdm`` Python library is provided.; - Dynamic arguments, where the value of an operator depends on; the current state of the evolution, have been removed. They; may be re-implemented later if there is demand for them. Integrators:. - The SciPy zvode integrator is available with the BDF and; Adams methods as ``bdf`` and ``adams``.; - The SciPy dop853 integrator (an eighth order Runge-Kutta method by; Dormand & Prince) is available as ``dop853``.; - The SciPy lsoda integrator is available as ``lsoda``.; - QuTiP's own implementation of Verner's ""most efficient"" Runge-Kutta methods; of order 7 and 9 are available as ``vern7`` and ``vern9``. See; http://people.math.sfu.ca/~jverner/ for a description of the methods.; - QuTiP's own implementation of a solver that directly diagonalizes the; the system to be integrated is available as ``diag``. It only works on; time-independent systems and is slow to setup, but once the diagona",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:42643,Usability,usab,usable,42643," the evolution, have been removed. They; may be re-implemented later if there is demand for them. Integrators:. - The SciPy zvode integrator is available with the BDF and; Adams methods as ``bdf`` and ``adams``.; - The SciPy dop853 integrator (an eighth order Runge-Kutta method by; Dormand & Prince) is available as ``dop853``.; - The SciPy lsoda integrator is available as ``lsoda``.; - QuTiP's own implementation of Verner's ""most efficient"" Runge-Kutta methods; of order 7 and 9 are available as ``vern7`` and ``vern9``. See; http://people.math.sfu.ca/~jverner/ for a description of the methods.; - QuTiP's own implementation of a solver that directly diagonalizes the; the system to be integrated is available as ``diag``. It only works on; time-independent systems and is slow to setup, but once the diagonalization; is complete, it generates solutions very quickly.; - QuTiP's own implementatoin of an approximate Krylov subspace integrator is; available as ``krylov``. This integrator is only usable with ``sesolve``. Result class:. - A new ``.e_data`` attribute provides expectation values as a dictionary.; Unlike ``.expect``, the values are provided in a Python list rather than; a numpy array, which better supports non-numeric types.; - The contents of the ``.stats`` attribute changed significantly and is; now more consistent across solvers. Monte-Carlo Solver (mcsolve):. - The system, H, may now be a super-operator.; - The ``seed`` parameter now supports supplying numpy ``SeedSequence`` or; ``Generator`` types.; - The new ``timeout`` and ``target_tol`` parameters allow the solver to exit; early if a timeout or target tolerance is reached.; - The ntraj option no longer supports a list of numbers of trajectories.; Instead, just run the solver multiple times and use the class ``MCSolver``; if setting up the solver uses a significant amount of time.; - The ``map_func`` parameter has been replaced by the ``map`` option. In; addition to the existing ``serial`` and ``parallel`` v",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:62731,Usability,simpl,simple,62731,"b.com/qutip/qutip/pull/1847>`_ by Christian Staufenbiel); - Changed implementation of ``qutip.orbital`` to use ``scipy.special.spy_harm`` to remove bugs in angle interpretation. (`#1844 <https://github.com/qutip/qutip/pull/1844>`_ by Christian Staufenbiel); - Fixed ``QobjEvo.tidyup`` to use ``settings.auto_tidyup_atol`` when removing small elements in sparse matrices. (`#1832 <https://github.com/qutip/qutip/pull/1832>`_ by Eric Gigure); - Ensured that tidyup's default tolerance is read from settings at each call. (`#1830 <https://github.com/qutip/qutip/pull/1830>`_ by Eric Gigure); - Fixed ``scipy.sparse`` deprecation warnings raised by ``qutip.fast_csr_matrix``. (`#1827 <https://github.com/qutip/qutip/pull/1827>`_ by Simon Cross); - Fixed rendering of vectors on the Bloch sphere when using matplotlib 3.5 and above. (`#1818 <https://github.com/qutip/qutip/pull/1818>`_ by Simon Cross); - Fixed the displaying of ``Lattice1d`` instances and their unit cells. Previously calling them raised exceptions in simple cases. (`#1819 <https://github.com/qutip/qutip/pull/1819>`_, `#1697 <https://github.com/qutip/qutip/pull/1697>`_ and `#1702 <https://github.com/qutip/qutip/pull/1702>`_ by Simon Cross and Saumya Biswas); - Fixed the displaying of the title for ``hinton`` and ``matrix_histogram`` plots when a title is given. Previously the supplied title was not displayed. (`#1707 <https://github.com/qutip/qutip/pull/1707>`_ by Vladimir Vargas-Caldern); - Removed an incorrect check on the initial state dimensions in the ``QubitCircuit`` constructor. This allows, for example, the construction of qutrit circuits. (`#1807 <https://github.com/qutip/qutip/pull/1807>`_ by Boxi Li); - Fixed the checking of ``method`` and ``offset`` parameters in ``coherent`` and ``coherent_dm``. (`#1469 <https://github.com/qutip/qutip/pull/1469>`_ and `#1741 <https://github.com/qutip/qutip/pull/1741>`_ by Joseph Fox-Rabinovitz and Simon Cross); - Removed the Hamiltonian saved in the ``sesolve`` solver r",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:64332,Usability,guid,guide,64332,", for example, the construction of qutrit circuits. (`#1807 <https://github.com/qutip/qutip/pull/1807>`_ by Boxi Li); - Fixed the checking of ``method`` and ``offset`` parameters in ``coherent`` and ``coherent_dm``. (`#1469 <https://github.com/qutip/qutip/pull/1469>`_ and `#1741 <https://github.com/qutip/qutip/pull/1741>`_ by Joseph Fox-Rabinovitz and Simon Cross); - Removed the Hamiltonian saved in the ``sesolve`` solver results. (`#1689 <https://github.com/qutip/qutip/pull/1689>`_ by Eric Gigure); - Fixed a bug in rand_herm with ``pos_def=True`` and ``density>0.5`` where the diagonal was incorrectly filled. (`#1562 <https://github.com/qutip/qutip/pull/1562>`_ by Eric Gigure). Documentation Improvements; --------------------------; - Added contributors image to the documentation. (`#1828 <https://github.com/qutip/qutip/pull/1828>`_ by Leonard Assis); - Fixed the Theory of Quantum Information bibliography link. (`#1840 <https://github.com/qutip/qutip/pull/1840>`_ by Anto Luketina); - Fixed minor grammar errors in the dynamics guide. (`#1822 <https://github.com/qutip/qutip/pull/1822>`_ by Victor Omole); - Fixed many small documentation typos. (`#1569 <https://github.com/qutip/qutip/pull/1569>`_ by Ashish Panigrahi); - Added Pulser to the list of libraries that use QuTiP. (`#1570 <https://github.com/qutip/qutip/pull/1570>`_ by Ashish Panigrahi); - Corrected typo in the states and operators guide. (`#1567 <https://github.com/qutip/qutip/pull/1567>`_ by Laurent Ajdnik); - Converted http links to https. (`#1555 <https://github.com/qutip/qutip/pull/1555>`_ by Jake Lishamn). Developer Changes; -----------------; - Add GitHub actions test run on windows-latest. (`#1853 <https://github.com/qutip/qutip/pull/1853>`_ and `#1855 <https://github.com/qutip/qutip/pull/1855>`_ by Simon Cross); - Bumped the version of pillow used to build documentation from 9.0.0 to 9.0.1. (`#1835 <https://github.com/qutip/qutip/pull/1835>`_ by dependabot); - Migrated the ``qutip.superop_reps`` test",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:64701,Usability,guid,guide,64701,- Removed the Hamiltonian saved in the ``sesolve`` solver results. (`#1689 <https://github.com/qutip/qutip/pull/1689>`_ by Eric Gigure); - Fixed a bug in rand_herm with ``pos_def=True`` and ``density>0.5`` where the diagonal was incorrectly filled. (`#1562 <https://github.com/qutip/qutip/pull/1562>`_ by Eric Gigure). Documentation Improvements; --------------------------; - Added contributors image to the documentation. (`#1828 <https://github.com/qutip/qutip/pull/1828>`_ by Leonard Assis); - Fixed the Theory of Quantum Information bibliography link. (`#1840 <https://github.com/qutip/qutip/pull/1840>`_ by Anto Luketina); - Fixed minor grammar errors in the dynamics guide. (`#1822 <https://github.com/qutip/qutip/pull/1822>`_ by Victor Omole); - Fixed many small documentation typos. (`#1569 <https://github.com/qutip/qutip/pull/1569>`_ by Ashish Panigrahi); - Added Pulser to the list of libraries that use QuTiP. (`#1570 <https://github.com/qutip/qutip/pull/1570>`_ by Ashish Panigrahi); - Corrected typo in the states and operators guide. (`#1567 <https://github.com/qutip/qutip/pull/1567>`_ by Laurent Ajdnik); - Converted http links to https. (`#1555 <https://github.com/qutip/qutip/pull/1555>`_ by Jake Lishamn). Developer Changes; -----------------; - Add GitHub actions test run on windows-latest. (`#1853 <https://github.com/qutip/qutip/pull/1853>`_ and `#1855 <https://github.com/qutip/qutip/pull/1855>`_ by Simon Cross); - Bumped the version of pillow used to build documentation from 9.0.0 to 9.0.1. (`#1835 <https://github.com/qutip/qutip/pull/1835>`_ by dependabot); - Migrated the ``qutip.superop_reps`` tests to pytest. (`#1825 <https://github.com/qutip/qutip/pull/1825>`_ by Felipe Bivort Haiek); - Migrated the ``qutip.steadystates`` tests to pytest. (`#1679 <https://github.com/qutip/qutip/pull/1679>`_ by Eric Gigure); - Changed the README.md CI badge to the GitHub Actions badge. (`#1581 <https://github.com/qutip/qutip/pull/1581>`_ by Jake Lishman); - Updated CodeCli,MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:66382,Usability,guid,guidelines,66382,"``qutip.steadystates`` tests to pytest. (`#1679 <https://github.com/qutip/qutip/pull/1679>`_ by Eric Gigure); - Changed the README.md CI badge to the GitHub Actions badge. (`#1581 <https://github.com/qutip/qutip/pull/1581>`_ by Jake Lishman); - Updated CodeClimate configuration to treat our Python source files as Python 3. (`#1577 <https://github.com/qutip/qutip/pull/1577>`_ by Jake Lishman); - Reduced cyclomatic complexity in ``qutip._mkl``. (`#1576 <https://github.com/qutip/qutip/pull/1576>`_ by Jake Lishman); - Fixed PEP8 warnings in ``qutip.control``, ``qutip.mcsolve``, ``qutip.random_objects``, and ``qutip.stochastic``. (`#1575 <https://github.com/qutip/qutip/pull/1575>`_ by Jake Lishman); - Bumped the version of urllib3 used to build documentation from 1.26.4 to 1.26.5. (`#1563 <https://github.com/qutip/qutip/pull/1563>`_ by dependabot); - Moved tests to GitHub Actions. (`#1551 <https://github.com/qutip/qutip/pull/1551>`_ by Jake Lishman); - The GitHub contributing guidelines were re-added and updated to point to the more complete guidelines in the documentation. (`#1549 <https://github.com/qutip/qutip/pull/1549>`_ by Jake Lishman); - The release documentation was reworked after the initial 4.6.1 to match the actual release process. (`#1544 <https://github.com/qutip/qutip/pull/1544>`_ by Jake Lishman). Version 4.6.3 (February 9, 2022); ++++++++++++++++++++++++++++++++. This minor release adds support for numpy 1.22 and Python 3.10 and removes some blockers for running QuTiP on the Apple M1. The performance of the ``enr_destroy``, ``state_number_enumerate`` and ``hadamard_transform`` functions was drastically improved (up to 70x or 200x faster in some common cases), and support for the drift Hamiltonian was added to the ``qutip.qip`` ``Processor``. The ``qutip.hardware_info`` module was removed as part of adding support for the Apple M1. We hope the removal of this little-used module does not adversely affect many users -- it was largely unrelated to QuTiP's c",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:66449,Usability,guid,guidelines,66449,"``qutip.steadystates`` tests to pytest. (`#1679 <https://github.com/qutip/qutip/pull/1679>`_ by Eric Gigure); - Changed the README.md CI badge to the GitHub Actions badge. (`#1581 <https://github.com/qutip/qutip/pull/1581>`_ by Jake Lishman); - Updated CodeClimate configuration to treat our Python source files as Python 3. (`#1577 <https://github.com/qutip/qutip/pull/1577>`_ by Jake Lishman); - Reduced cyclomatic complexity in ``qutip._mkl``. (`#1576 <https://github.com/qutip/qutip/pull/1576>`_ by Jake Lishman); - Fixed PEP8 warnings in ``qutip.control``, ``qutip.mcsolve``, ``qutip.random_objects``, and ``qutip.stochastic``. (`#1575 <https://github.com/qutip/qutip/pull/1575>`_ by Jake Lishman); - Bumped the version of urllib3 used to build documentation from 1.26.4 to 1.26.5. (`#1563 <https://github.com/qutip/qutip/pull/1563>`_ by dependabot); - Moved tests to GitHub Actions. (`#1551 <https://github.com/qutip/qutip/pull/1551>`_ by Jake Lishman); - The GitHub contributing guidelines were re-added and updated to point to the more complete guidelines in the documentation. (`#1549 <https://github.com/qutip/qutip/pull/1549>`_ by Jake Lishman); - The release documentation was reworked after the initial 4.6.1 to match the actual release process. (`#1544 <https://github.com/qutip/qutip/pull/1544>`_ by Jake Lishman). Version 4.6.3 (February 9, 2022); ++++++++++++++++++++++++++++++++. This minor release adds support for numpy 1.22 and Python 3.10 and removes some blockers for running QuTiP on the Apple M1. The performance of the ``enr_destroy``, ``state_number_enumerate`` and ``hadamard_transform`` functions was drastically improved (up to 70x or 200x faster in some common cases), and support for the drift Hamiltonian was added to the ``qutip.qip`` ``Processor``. The ``qutip.hardware_info`` module was removed as part of adding support for the Apple M1. We hope the removal of this little-used module does not adversely affect many users -- it was largely unrelated to QuTiP's c",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:67895,Usability,simpl,simple,67895," and removes some blockers for running QuTiP on the Apple M1. The performance of the ``enr_destroy``, ``state_number_enumerate`` and ``hadamard_transform`` functions was drastically improved (up to 70x or 200x faster in some common cases), and support for the drift Hamiltonian was added to the ``qutip.qip`` ``Processor``. The ``qutip.hardware_info`` module was removed as part of adding support for the Apple M1. We hope the removal of this little-used module does not adversely affect many users -- it was largely unrelated to QuTiP's core functionality and its presence was a continual source of blockers to importing ``qutip`` on new or changed platforms. A new check on the dimensions of ``Qobj``'s were added to prevent segmentation faults when invalid shape and dimension combinations were passed to Cython code. In addition, there were many small bugfixes, documentation improvements, and improvements to our building and testing processes. Improvements; ------------; - The ``enr_destroy`` function was made ~200x faster in many simple cases. (`#1593 <https://github.com/qutip/qutip/pull/1593>`_ by Johannes Feist); - The ``state_number_enumerate`` function was made significantly faster. (`#1594 <https://github.com/qutip/qutip/pull/1594>`_ by Johannes Feist); - Added the missing drift Hamiltonian to the method run_analytically of ``Processor``. (`#1603 <https://github.com/qutip/qutip/pull/1603>`_ Boxi Li); - The ``hadamard_transform`` was made much faster, e.g., ~70x faster for N=10. (`#1688 <https://github.com/qutip/qutip/pull/1688>`_ by Asier Galicia); - Added support for computing the power of a scalar-like Qobj. (`#1692 <https://github.com/qutip/qutip/pull/1692>`_ by Asier Galicia); - Removed the ``hardware_info`` module. This module wasn't used inside QuTiP and regularly broke when new operating systems were released, and in particular prevented importing QuTiP on the Apple M1. (`#1754 <https://github.com/qutip/qutip/pull/1754>`_, `#1758 <https://github.com/qutip/qutip/",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:72028,Usability,guid,guide,72028,"19>`_ by Simon Cross); - Fixed compatibility with numpy configuration in numpy's 1.22.0 release. (`#1752 <https://github.com/qutip/qutip/pull/1752>`_ by Matthew Treinish); - Added dims checks for e_ops passed to solvers to prevent hanging the calling process when e_ops of the wrong dimensions were passed. (`#1778 <https://github.com/qutip/qutip/pull/1778>`_ by Eric Gigure); - Added a check in Qobj constructor that the respective members of data.shape cannot be larger than what the corresponding dims could contain to prevent a segmentation fault caused by inconsistencies between dims and shapes. (`#1783 <https://github.com/qutip/qutip/pull/1783>`_, `#1785 <https://github.com/qutip/qutip/pull/1785>`_, `#1784 <https://github.com/qutip/qutip/pull/1784>`_ by Lajos Palanki & Eric Gigure). Documentation Improvements; --------------------------; - Added docs for the num_cbits parameter of the QubitCircuit class. (`#1652 <https://github.com/qutip/qutip/pull/1652>`_ by Jon Crall); - Fixed the parameters in the call to fsesolve in the Floquet guide. (`#1675 <https://github.com/qutip/qutip/pull/1675>`_ by Simon Cross); - Fixed the description of random number usage in the Monte Carlo solver guide. (`#1677 <https://github.com/qutip/qutip/pull/1677>`_ by Ian Thorvaldson); - Fixed the rendering of equation numbers in the documentation (they now appear on the right as expected, not above the equation). (`#1678 <https://github.com/qutip/qutip/pull/1678>`_ by Simon Cross); - Updated the installation requirements in the documentation to match what is specified in setup.py. (`#1715 <https://github.com/qutip/qutip/pull/1715>`_ by Asier Galicia); - Fixed a typo in the ``chi_to_choi`` documentation. Previously the documentation mixed up chi and choi. (`#1731 <https://github.com/qutip/qutip/pull/1731>`_ by Pontus Wiksthl); - Improved the documentation for the stochastic equation solvers. Added links to notebooks with examples, API doumentation and external references. (`#1743 <https://g",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:72178,Usability,guid,guide,72178,"752>`_ by Matthew Treinish); - Added dims checks for e_ops passed to solvers to prevent hanging the calling process when e_ops of the wrong dimensions were passed. (`#1778 <https://github.com/qutip/qutip/pull/1778>`_ by Eric Gigure); - Added a check in Qobj constructor that the respective members of data.shape cannot be larger than what the corresponding dims could contain to prevent a segmentation fault caused by inconsistencies between dims and shapes. (`#1783 <https://github.com/qutip/qutip/pull/1783>`_, `#1785 <https://github.com/qutip/qutip/pull/1785>`_, `#1784 <https://github.com/qutip/qutip/pull/1784>`_ by Lajos Palanki & Eric Gigure). Documentation Improvements; --------------------------; - Added docs for the num_cbits parameter of the QubitCircuit class. (`#1652 <https://github.com/qutip/qutip/pull/1652>`_ by Jon Crall); - Fixed the parameters in the call to fsesolve in the Floquet guide. (`#1675 <https://github.com/qutip/qutip/pull/1675>`_ by Simon Cross); - Fixed the description of random number usage in the Monte Carlo solver guide. (`#1677 <https://github.com/qutip/qutip/pull/1677>`_ by Ian Thorvaldson); - Fixed the rendering of equation numbers in the documentation (they now appear on the right as expected, not above the equation). (`#1678 <https://github.com/qutip/qutip/pull/1678>`_ by Simon Cross); - Updated the installation requirements in the documentation to match what is specified in setup.py. (`#1715 <https://github.com/qutip/qutip/pull/1715>`_ by Asier Galicia); - Fixed a typo in the ``chi_to_choi`` documentation. Previously the documentation mixed up chi and choi. (`#1731 <https://github.com/qutip/qutip/pull/1731>`_ by Pontus Wiksthl); - Improved the documentation for the stochastic equation solvers. Added links to notebooks with examples, API doumentation and external references. (`#1743 <https://github.com/qutip/qutip/pull/1743>`_ by Leonardo Assis); - Fixed a typo in ``qutip.settings`` in the settings guide. (`#1786 <https://github.com/q",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:73086,Usability,guid,guide,73086,"pull/1675>`_ by Simon Cross); - Fixed the description of random number usage in the Monte Carlo solver guide. (`#1677 <https://github.com/qutip/qutip/pull/1677>`_ by Ian Thorvaldson); - Fixed the rendering of equation numbers in the documentation (they now appear on the right as expected, not above the equation). (`#1678 <https://github.com/qutip/qutip/pull/1678>`_ by Simon Cross); - Updated the installation requirements in the documentation to match what is specified in setup.py. (`#1715 <https://github.com/qutip/qutip/pull/1715>`_ by Asier Galicia); - Fixed a typo in the ``chi_to_choi`` documentation. Previously the documentation mixed up chi and choi. (`#1731 <https://github.com/qutip/qutip/pull/1731>`_ by Pontus Wiksthl); - Improved the documentation for the stochastic equation solvers. Added links to notebooks with examples, API doumentation and external references. (`#1743 <https://github.com/qutip/qutip/pull/1743>`_ by Leonardo Assis); - Fixed a typo in ``qutip.settings`` in the settings guide. (`#1786 <https://github.com/qutip/qutip/pull/1786>`_ by Mahdi Aslani); - Made numerous small improvements to the text of the QuTiP basics guide. (`#1768 <https://github.com/qutip/qutip/pull/1768>`_ by Anna Naden); - Made a small phrasing improvement to the README. (`#1790 <https://github.com/qutip/qutip/pull/1790>`_ by Rita Abani). Developer Changes; -----------------; - Improved test coverage of states and operators functions. (`#1578 <https://github.com/qutip/qutip/pull/1578>`_ by Eric Gigure); - Fixed test_interpolate mcsolve use (`#1645 <https://github.com/qutip/qutip/pull/1645>`_ by Eric Gigure); - Ensured figure plots are explicitly closed during tests so that the test suite passes when run headless under Xvfb. (`#1648 <https://github.com/qutip/qutip/pull/1648>`_ by Simon Cross); - Bumped the version of pillow used to build documentation from 8.2.0 to 9.0.0. (`#1654 <https://github.com/qutip/qutip/pull/1654>`_, `#1760 <https://github.com/qutip/qutip/pull/1760>`",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:73231,Usability,guid,guide,73231," guide. (`#1677 <https://github.com/qutip/qutip/pull/1677>`_ by Ian Thorvaldson); - Fixed the rendering of equation numbers in the documentation (they now appear on the right as expected, not above the equation). (`#1678 <https://github.com/qutip/qutip/pull/1678>`_ by Simon Cross); - Updated the installation requirements in the documentation to match what is specified in setup.py. (`#1715 <https://github.com/qutip/qutip/pull/1715>`_ by Asier Galicia); - Fixed a typo in the ``chi_to_choi`` documentation. Previously the documentation mixed up chi and choi. (`#1731 <https://github.com/qutip/qutip/pull/1731>`_ by Pontus Wiksthl); - Improved the documentation for the stochastic equation solvers. Added links to notebooks with examples, API doumentation and external references. (`#1743 <https://github.com/qutip/qutip/pull/1743>`_ by Leonardo Assis); - Fixed a typo in ``qutip.settings`` in the settings guide. (`#1786 <https://github.com/qutip/qutip/pull/1786>`_ by Mahdi Aslani); - Made numerous small improvements to the text of the QuTiP basics guide. (`#1768 <https://github.com/qutip/qutip/pull/1768>`_ by Anna Naden); - Made a small phrasing improvement to the README. (`#1790 <https://github.com/qutip/qutip/pull/1790>`_ by Rita Abani). Developer Changes; -----------------; - Improved test coverage of states and operators functions. (`#1578 <https://github.com/qutip/qutip/pull/1578>`_ by Eric Gigure); - Fixed test_interpolate mcsolve use (`#1645 <https://github.com/qutip/qutip/pull/1645>`_ by Eric Gigure); - Ensured figure plots are explicitly closed during tests so that the test suite passes when run headless under Xvfb. (`#1648 <https://github.com/qutip/qutip/pull/1648>`_ by Simon Cross); - Bumped the version of pillow used to build documentation from 8.2.0 to 9.0.0. (`#1654 <https://github.com/qutip/qutip/pull/1654>`_, `#1760 <https://github.com/qutip/qutip/pull/1760>`_ by dependabot); - Bumped the version of babel used to build documentation from 2.9.0 to 2.9.1. (`#1",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:83798,Usability,simpl,simplify,83798," Lishman**); - Fix gate resolution of the FREDKIN gate. (by **Bo Yang**); - Fix broken formatting in docstrings. (by **Jake Lishman**). Deprecations; ------------; - ``eseries``, ``essolve`` and ``ode2es`` are all deprecated, pending removal in QuTiP 5.0. These are legacy functions and classes that have been left unmaintained for a long time, and their functionality is now better achieved with ``QobjEvo`` or ``mesolve``. Developer Changes; -----------------; - **MAJOR** Overhaul of setup and packaging code to make it satisfy PEP 517, and move the build to a matrix on GitHub Actions in order to release binary wheels on pip for all major platforms and supported Python versions. (by **Jake Lishman**); - Default arguments in ``Qobj`` are now ``None`` rather than mutable types. (by **Jake Lishman**); - Fixed comsumable iterators being used to parametrise some tests, preventing the testing suite from being re-run within the same session. (by **Jake Lishman**); - Remove unused imports, simplify some floats and remove unnecessary list conversions. (by **jakobjakobson13**); - Improve Travis jobs matrix for specifying the testing containers. (by **Jake Lishman**); - Fix coverage reporting on Travis. (by **Jake Lishman**); - Added a ``pyproject.toml`` file. (by **Simon Humpohl** and **Eric Gigure**); - Add doctests to documentation. (by **Sidhant Saraogi**); - Fix all warnings in the documentation build. (by **Jake Lishman**). Version 4.5.3 (February 19, 2021); +++++++++++++++++++++++++++++++++. This patch release adds support for Numpy 1.20, made necessary by changes to how array-like objects are handled. There are no other changes relative to version 4.5.2. Users building from source should ensure that they build against Numpy versions >= 1.16.6 and < 1.20 (not including 1.20 itself), but after that or for those installing from conda, an installation will support any current Numpy version >= 1.16.6. Improvements; ------------; - Add support for Numpy 1.20. QuTiP should be c",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:99564,Usability,simpl,simplified,99564,"aw summation algorithm to evaluate a polynomial series that is applicable for any number of exciations (previous limitation was ~50 quanta), and is ~3x faster than before. (**Added by Denis Vasilyev**); - Can now define a given eigen spectrum for random Hermitian and density operators.; - The Qobj ``expm`` method now uses the equivilent SciPy routine, and performs a much faster ``exp`` operation if the matrix is diagonal.; - One can now build zero operators using the ``qzero`` function. *Control modules*. - **MAJOR FEATURE**: CRAB algorithm added; This is an alternative to the GRAPE algorithm, which allows for analytical control functions, which means that experimental constraints can more easily be added into optimisation.; See tutorial notebook for full information. Improvements; ------------; *Core libraries*. - Two-time correlation functions can now be calculated for fully time-dependent Hamiltonians and collapse operators. (**Added by Kevin Fischer**); - The code for the inverse-power method for the steady state solver has been simplified.; - Bloch-Redfield tensor creation is now up to an order of magnitude faster. (**Added by Johannes Feist**); - Q.transform now works properly for arrays directly from sp_eigs (or eig).; - Q.groundstate now checks for degeneracy.; - Added ``sinm`` and ``cosm`` methods to the Qobj class.; - Added ``charge`` and ``tunneling`` operators.; - Time-dependent Cython code is now easier to read and debug. *Control modules*. - The internal state / quantum operator data type can now be either Qobj or ndarray; Previous only ndarray was possible. This now opens up possibility of using Qobj methods in fidelity calculations; The attributes and functions that return these operators are now preceded by an underscore, to indicate that the data type could change depending on the configuration options.; In most cases these functions were for internal processing only anyway, and should have been 'private'.; Accessors to the properties that could be ",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:104992,Usability,progress bar,progress bars,104992,"ist antipattern in super operator reps. (**Fixed by Stefan Krastanov**); - Fixed incorrect ``isherm`` for ``sigmam`` spin operator.; - Fixed the dims when using ``final_state_output`` in ``mesolve`` and ``sesolve``. Version 3.1.0 (January 1, 2015); +++++++++++++++++++++++++++++++. New Features; ------------. - **MAJOR FEATURE**: New module for quantum control (qutip.control).; - **NAMESPACE CHANGE**: QuTiP no longer exports symbols from NumPy and matplotlib, so those modules must now be explicitly imported when required.; - New module for counting statistics.; - Stochastic solvers now run trajectories in parallel.; - New superoperator and tensor manipulation functions; (super_tensor, composite, tensor_contract).; - New logging module for debugging (qutip.logging).; - New user-available API for parallelization (parallel_map).; - New enhanced (optional) text-based progressbar (qutip.ui.EnhancedTextProgressBar); - Faster Python based monte carlo solver (mcsolve).; - Support for progress bars in propagator function.; - Time-dependent Cython code now calls complex cmath functions.; - Random numbers seeds can now be reused for successive calls to mcsolve.; - The Bloch-Redfield master equation solver now supports optional Lindblad type collapse operators.; - Improved handling of ODE integration errors in mesolve.; - Improved correlation function module (for example, improved support for time-dependent problems).; - Improved parallelization of mcsolve (can now be interrupted easily, support for IPython.parallel, etc.); - Many performance improvements, and much internal code restructuring. Bug Fixes; ---------. - Cython build files for time-dependent string format now removed automatically.; - Fixed incorrect solution time from inverse-power method steady state solver.; - mcsolve now supports `Options(store_states=True)`; - Fixed bug in `hadamard` gate function.; - Fixed compatibility issues with NumPy 1.9.0.; - Progressbar in mcsolve can now be suppressed.; - Fixed bug in `g",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:110979,Usability,simpl,simplified,110979," removing one; state from a two-qubit system to obtain a three-level system). - Support for time-dependent Hamiltonian and Liouvillian callback functions that; depend on the instantaneous state, which for example can be used for solving; master equations with mean field terms. Improvements; ------------. - Restructured and optimized implementation of Qobj, which now has; significantly lower memory footprint due to avoiding excessive copying of; internal matrix data. - The classes ``OdeData``, ``Odeoptions``, ``Odeconfig`` are now called; ``Result``, ``Options``, and ``Config``, respectively, and are available in; the module `qutip.solver`. - The ``squeez`` function has been renamed to ``squeeze``. - Better support for sparse matrices when calculating propagators using the; ``propagator`` function. - Improved Bloch sphere. - Restructured and improved the module ``qutip.sparse``, which now only; operates directly on sparse matrices (not on Qobj instances). - Improved and simplified implement of the ``tensor`` function. - Improved performance, major code cleanup (including namespace changes),; and numerous bug fixes. - Benchmark scripts improved and restructured. - QuTiP is now using continuous integration tests (TravisCI). Version 2.2.0 (March 01, 2013); ++++++++++++++++++++++++++++++. New Features; ------------. - **Added Support for Windows**. - New Bloch3d class for plotting 3D Bloch spheres using Mayavi. - Bloch sphere vectors now look like arrows. - Partial transpose function. - Continuos variable functions for calculating correlation and covariance; matrices, the Wigner covariance matrix and the logarithmic negativity for; for multimode fields in Fock basis. - The master-equation solver (mesolve) now accepts pre-constructed Liouvillian; terms, which makes it possible to solve master equations that are not on; the standard Lindblad form. - Optional Fortran Monte Carlo solver (mcsolve_f90) by Arne Grimsmo. - A module of tools for using QuTiP in IPython notebooks. ",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:113677,Usability,progress bar,progress bar,113677,"tomography. - Window icons are now set for Ubuntu application launcher. - The propagator function can now take a list of times as argument, and returns a list of corresponding propagators. Bug Fixes; ---------. - mesolver now correctly uses the user defined rhs_filename in Odeoptions(). - rhs_generate() now handles user defined filenames properly. - Density matrix returned by propagator_steadystate is now Hermitian. - eseries_value returns real list if all imag parts are zero. - mcsolver now gives correct results for strong damping rates. - Odeoptions now prints mc_avg correctly. - Do not check for PyObj in mcsolve when gui=False. - Eseries now correctly handles purely complex rates. - thermal_dm() function now uses truncated operator method. - Cython based time-dependence now Python 3 compatible. - Removed call to NSAutoPool on mac systems. - Progress bar now displays the correct number of CPU's used. - Qobj.diag() returns reals if operator is Hermitian. - Text for progress bar on Linux systems is no longer cutoff. Version 2.0.0 (June 01, 2012); +++++++++++++++++++++++++++++. The second version of QuTiP has seen many improvements in the performance of the original code base, as well as the addition of several new routines supporting a wide range of functionality. Some of the highlights of this release include:. New Features; ------------. - QuTiP now includes solvers for both Floquet and Bloch-Redfield master equations. - The Lindblad master equation and Monte Carlo solvers allow for time-dependent collapse operators. - It is possible to automatically compile time-dependent problems into c-code using Cython (if installed). - Python functions can be used to create arbitrary time-dependent Hamiltonians and collapse operators. - Solvers now return Odedata objects containing all simulation results and parameters, simplifying the saving of simulation results. .. important:: This breaks compatibility with QuTiP version 1.x. - mesolve and mcsolve can reuse Hamiltonian dat",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst:114538,Usability,simpl,simplifying,114538,"all to NSAutoPool on mac systems. - Progress bar now displays the correct number of CPU's used. - Qobj.diag() returns reals if operator is Hermitian. - Text for progress bar on Linux systems is no longer cutoff. Version 2.0.0 (June 01, 2012); +++++++++++++++++++++++++++++. The second version of QuTiP has seen many improvements in the performance of the original code base, as well as the addition of several new routines supporting a wide range of functionality. Some of the highlights of this release include:. New Features; ------------. - QuTiP now includes solvers for both Floquet and Bloch-Redfield master equations. - The Lindblad master equation and Monte Carlo solvers allow for time-dependent collapse operators. - It is possible to automatically compile time-dependent problems into c-code using Cython (if installed). - Python functions can be used to create arbitrary time-dependent Hamiltonians and collapse operators. - Solvers now return Odedata objects containing all simulation results and parameters, simplifying the saving of simulation results. .. important:: This breaks compatibility with QuTiP version 1.x. - mesolve and mcsolve can reuse Hamiltonian data when only the initial state, or time-dependent arguments, need to be changed. - QuTiP includes functions for creating random quantum states and operators. - The generation and manipulation of quantum objects is now more efficient. - Quantum objects have basis transformation and matrix element calculations as built-in methods. - The quantum object eigensolver can use sparse solvers. - The partial-trace (ptrace) function is up to 20x faster. - The Bloch sphere can now be used with the Matplotlib animation function, and embedded as a subplot in a figure. - QuTiP has built-in functions for saving quantum objects and data arrays. - The steady-state solver has been further optimized for sparse matrices, and can handle much larger system Hamiltonians. - The steady-state solver can use the iterative bi-conjugate gra",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/contributors.rst:253,Deployability,patch,patches,253,".. _developers:. ************; Developers; ************. .. plot::; :context: close-figs; :include-source: False. import json; import urllib.request. import numpy as np; import matplotlib.pyplot as plt. from matplotlib.path import Path; from matplotlib.patches import PathPatch; from matplotlib.textpath import TextPath; from matplotlib.collections import PolyCollection; from matplotlib.font_manager import FontProperties; import PIL. LINK_CONTRIBUTORS = ""https://api.github.com/repos/qutip/qutip/contributors""; LINK_LOGO = ""https://qutip.org/images/logo.png"". # font properties; FONT_SIZE = 6; FONT_FAMILY = ""DejaVu Sans"". # figures properties; FIGURE_SIZE = 8; AXIS_SIZE = 50; FONT_COLOR = ""black""; LOGO_SIZE = 40; LOGO_TRANSPARENCY = 0.5. # load the list of contributors from qutip/qutip repo; url_object = urllib.request.urlopen(LINK_CONTRIBUTORS); list_contributors = json.loads(url_object.read()); qutip_contributors = [element[""login""] for element in list_contributors]; qutip_contributors = [s.lower() for s in qutip_contributors]; text = "" "".join(qutip_contributors). # load the QuTiP logo; img = PIL.Image.open(urllib.request.urlopen(LINK_LOGO)). # code below was inspired in the following link:; # https://github.com/dynamicwebpaige/nanowrimo-2021/blob/main/15_VS_Code_contributors.ipynb. n = 100; A = np.linspace(np.pi, n * 2 * np.pi, 10_000); R = 5 + np.linspace(np.pi, n * 2 * np.pi, 10_000); T = np.stack([R * np.cos(A), R * np.sin(A)], axis=1); dx = np.cos(A) - R * np.sin(A); dy = np.sin(A) + R * np.cos(A); O = np.stack([-dy, dx], axis=1); O = O / (np.linalg.norm(O, axis=1)).reshape(len(O), 1). L = np.zeros(len(T)); np.cumsum(np.sqrt(((T[1:] - T[:-1]) ** 2).sum(axis=1)), out=L[1:]). path = TextPath(; (0, 0), text,; size=FONT_SIZE,; prop=FontProperties(family=FONT_FAMILY),; ). vertices = path.vertices; codes = path.codes. Vx, Vy = vertices[:, 0], vertices[:, 1]; X = np.interp(Vx, L, T[:, 0]) + Vy * np.interp(Vx, L, O[:, 0]); Y = np.interp(Vx, L, T[:, 1]) + Vy * np.interp(Vx,",MatchSource.DOCS,doc/contributors.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/contributors.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/contributors.rst:2176,Deployability,patch,patch,2176,"in the following link:; # https://github.com/dynamicwebpaige/nanowrimo-2021/blob/main/15_VS_Code_contributors.ipynb. n = 100; A = np.linspace(np.pi, n * 2 * np.pi, 10_000); R = 5 + np.linspace(np.pi, n * 2 * np.pi, 10_000); T = np.stack([R * np.cos(A), R * np.sin(A)], axis=1); dx = np.cos(A) - R * np.sin(A); dy = np.sin(A) + R * np.cos(A); O = np.stack([-dy, dx], axis=1); O = O / (np.linalg.norm(O, axis=1)).reshape(len(O), 1). L = np.zeros(len(T)); np.cumsum(np.sqrt(((T[1:] - T[:-1]) ** 2).sum(axis=1)), out=L[1:]). path = TextPath(; (0, 0), text,; size=FONT_SIZE,; prop=FontProperties(family=FONT_FAMILY),; ). vertices = path.vertices; codes = path.codes. Vx, Vy = vertices[:, 0], vertices[:, 1]; X = np.interp(Vx, L, T[:, 0]) + Vy * np.interp(Vx, L, O[:, 0]); Y = np.interp(Vx, L, T[:, 1]) + Vy * np.interp(Vx, L, O[:, 1]); vertices = np.stack([X, Y], axis=-1). path = Path(vertices, codes, closed=False). # creating figure; fig, ax = plt.subplots(figsize=(FIGURE_SIZE, FIGURE_SIZE)); patch = PathPatch(path, facecolor=FONT_COLOR, linewidth=0); ax.add_artist(patch); ax.set_xlim(-AXIS_SIZE, AXIS_SIZE), ax.set_xticks([]); ax.set_ylim(-AXIS_SIZE, AXIS_SIZE), ax.set_yticks([]). # add qutip logo; ax.imshow(img, alpha=LOGO_TRANSPARENCY,; extent=[-LOGO_SIZE,LOGO_SIZE, -LOGO_SIZE, LOGO_SIZE]). .. _developers-lead:. Lead Developers; ===============. - `Alex Pitchford <https://github.com/ajgpitch>`_; - `Nathan Shammah <https://nathanshammah.com/>`_; - `Shahnawaz Ahmed <http://sahmed.in/>`_; - `Neill Lambert <https://github.com/nwlambert>`_; - `Eric Gigure <https://github.com/Ericgig>`_; - `Boxi Li <https://github.com/BoxiLi>`_; - `Simon Cross <http://hodgestar.za.net/>`_; - `Asier Galicia <https://github.com/AGaliciaMartinez>`_. Past Lead Developers; ====================. - `Robert Johansson <https://jrjohansson.github.io/research.html>`_ (RIKEN); - `Paul Nation <https://www.korea.ac.kr/>`_ (Korea University); - `Chris Granade <https://www.cgranade.com>`_; - `Arne Grimsmo <https://www",MatchSource.DOCS,doc/contributors.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/contributors.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/contributors.rst:2250,Deployability,patch,patch,2250,"rimo-2021/blob/main/15_VS_Code_contributors.ipynb. n = 100; A = np.linspace(np.pi, n * 2 * np.pi, 10_000); R = 5 + np.linspace(np.pi, n * 2 * np.pi, 10_000); T = np.stack([R * np.cos(A), R * np.sin(A)], axis=1); dx = np.cos(A) - R * np.sin(A); dy = np.sin(A) + R * np.cos(A); O = np.stack([-dy, dx], axis=1); O = O / (np.linalg.norm(O, axis=1)).reshape(len(O), 1). L = np.zeros(len(T)); np.cumsum(np.sqrt(((T[1:] - T[:-1]) ** 2).sum(axis=1)), out=L[1:]). path = TextPath(; (0, 0), text,; size=FONT_SIZE,; prop=FontProperties(family=FONT_FAMILY),; ). vertices = path.vertices; codes = path.codes. Vx, Vy = vertices[:, 0], vertices[:, 1]; X = np.interp(Vx, L, T[:, 0]) + Vy * np.interp(Vx, L, O[:, 0]); Y = np.interp(Vx, L, T[:, 1]) + Vy * np.interp(Vx, L, O[:, 1]); vertices = np.stack([X, Y], axis=-1). path = Path(vertices, codes, closed=False). # creating figure; fig, ax = plt.subplots(figsize=(FIGURE_SIZE, FIGURE_SIZE)); patch = PathPatch(path, facecolor=FONT_COLOR, linewidth=0); ax.add_artist(patch); ax.set_xlim(-AXIS_SIZE, AXIS_SIZE), ax.set_xticks([]); ax.set_ylim(-AXIS_SIZE, AXIS_SIZE), ax.set_yticks([]). # add qutip logo; ax.imshow(img, alpha=LOGO_TRANSPARENCY,; extent=[-LOGO_SIZE,LOGO_SIZE, -LOGO_SIZE, LOGO_SIZE]). .. _developers-lead:. Lead Developers; ===============. - `Alex Pitchford <https://github.com/ajgpitch>`_; - `Nathan Shammah <https://nathanshammah.com/>`_; - `Shahnawaz Ahmed <http://sahmed.in/>`_; - `Neill Lambert <https://github.com/nwlambert>`_; - `Eric Gigure <https://github.com/Ericgig>`_; - `Boxi Li <https://github.com/BoxiLi>`_; - `Simon Cross <http://hodgestar.za.net/>`_; - `Asier Galicia <https://github.com/AGaliciaMartinez>`_. Past Lead Developers; ====================. - `Robert Johansson <https://jrjohansson.github.io/research.html>`_ (RIKEN); - `Paul Nation <https://www.korea.ac.kr/>`_ (Korea University); - `Chris Granade <https://www.cgranade.com>`_; - `Arne Grimsmo <https://www.sydney.edu.au/science/about/our-people/academic-staff/arne-grims",MatchSource.DOCS,doc/contributors.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/contributors.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/contributors.rst:745,Performance,load,load,745,".. _developers:. ************; Developers; ************. .. plot::; :context: close-figs; :include-source: False. import json; import urllib.request. import numpy as np; import matplotlib.pyplot as plt. from matplotlib.path import Path; from matplotlib.patches import PathPatch; from matplotlib.textpath import TextPath; from matplotlib.collections import PolyCollection; from matplotlib.font_manager import FontProperties; import PIL. LINK_CONTRIBUTORS = ""https://api.github.com/repos/qutip/qutip/contributors""; LINK_LOGO = ""https://qutip.org/images/logo.png"". # font properties; FONT_SIZE = 6; FONT_FAMILY = ""DejaVu Sans"". # figures properties; FIGURE_SIZE = 8; AXIS_SIZE = 50; FONT_COLOR = ""black""; LOGO_SIZE = 40; LOGO_TRANSPARENCY = 0.5. # load the list of contributors from qutip/qutip repo; url_object = urllib.request.urlopen(LINK_CONTRIBUTORS); list_contributors = json.loads(url_object.read()); qutip_contributors = [element[""login""] for element in list_contributors]; qutip_contributors = [s.lower() for s in qutip_contributors]; text = "" "".join(qutip_contributors). # load the QuTiP logo; img = PIL.Image.open(urllib.request.urlopen(LINK_LOGO)). # code below was inspired in the following link:; # https://github.com/dynamicwebpaige/nanowrimo-2021/blob/main/15_VS_Code_contributors.ipynb. n = 100; A = np.linspace(np.pi, n * 2 * np.pi, 10_000); R = 5 + np.linspace(np.pi, n * 2 * np.pi, 10_000); T = np.stack([R * np.cos(A), R * np.sin(A)], axis=1); dx = np.cos(A) - R * np.sin(A); dy = np.sin(A) + R * np.cos(A); O = np.stack([-dy, dx], axis=1); O = O / (np.linalg.norm(O, axis=1)).reshape(len(O), 1). L = np.zeros(len(T)); np.cumsum(np.sqrt(((T[1:] - T[:-1]) ** 2).sum(axis=1)), out=L[1:]). path = TextPath(; (0, 0), text,; size=FONT_SIZE,; prop=FontProperties(family=FONT_FAMILY),; ). vertices = path.vertices; codes = path.codes. Vx, Vy = vertices[:, 0], vertices[:, 1]; X = np.interp(Vx, L, T[:, 0]) + Vy * np.interp(Vx, L, O[:, 0]); Y = np.interp(Vx, L, T[:, 1]) + Vy * np.interp(Vx,",MatchSource.DOCS,doc/contributors.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/contributors.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/contributors.rst:879,Performance,load,loads,879,".. _developers:. ************; Developers; ************. .. plot::; :context: close-figs; :include-source: False. import json; import urllib.request. import numpy as np; import matplotlib.pyplot as plt. from matplotlib.path import Path; from matplotlib.patches import PathPatch; from matplotlib.textpath import TextPath; from matplotlib.collections import PolyCollection; from matplotlib.font_manager import FontProperties; import PIL. LINK_CONTRIBUTORS = ""https://api.github.com/repos/qutip/qutip/contributors""; LINK_LOGO = ""https://qutip.org/images/logo.png"". # font properties; FONT_SIZE = 6; FONT_FAMILY = ""DejaVu Sans"". # figures properties; FIGURE_SIZE = 8; AXIS_SIZE = 50; FONT_COLOR = ""black""; LOGO_SIZE = 40; LOGO_TRANSPARENCY = 0.5. # load the list of contributors from qutip/qutip repo; url_object = urllib.request.urlopen(LINK_CONTRIBUTORS); list_contributors = json.loads(url_object.read()); qutip_contributors = [element[""login""] for element in list_contributors]; qutip_contributors = [s.lower() for s in qutip_contributors]; text = "" "".join(qutip_contributors). # load the QuTiP logo; img = PIL.Image.open(urllib.request.urlopen(LINK_LOGO)). # code below was inspired in the following link:; # https://github.com/dynamicwebpaige/nanowrimo-2021/blob/main/15_VS_Code_contributors.ipynb. n = 100; A = np.linspace(np.pi, n * 2 * np.pi, 10_000); R = 5 + np.linspace(np.pi, n * 2 * np.pi, 10_000); T = np.stack([R * np.cos(A), R * np.sin(A)], axis=1); dx = np.cos(A) - R * np.sin(A); dy = np.sin(A) + R * np.cos(A); O = np.stack([-dy, dx], axis=1); O = O / (np.linalg.norm(O, axis=1)).reshape(len(O), 1). L = np.zeros(len(T)); np.cumsum(np.sqrt(((T[1:] - T[:-1]) ** 2).sum(axis=1)), out=L[1:]). path = TextPath(; (0, 0), text,; size=FONT_SIZE,; prop=FontProperties(family=FONT_FAMILY),; ). vertices = path.vertices; codes = path.codes. Vx, Vy = vertices[:, 0], vertices[:, 1]; X = np.interp(Vx, L, T[:, 0]) + Vy * np.interp(Vx, L, O[:, 0]); Y = np.interp(Vx, L, T[:, 1]) + Vy * np.interp(Vx,",MatchSource.DOCS,doc/contributors.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/contributors.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/contributors.rst:1080,Performance,load,load,1080,"lude-source: False. import json; import urllib.request. import numpy as np; import matplotlib.pyplot as plt. from matplotlib.path import Path; from matplotlib.patches import PathPatch; from matplotlib.textpath import TextPath; from matplotlib.collections import PolyCollection; from matplotlib.font_manager import FontProperties; import PIL. LINK_CONTRIBUTORS = ""https://api.github.com/repos/qutip/qutip/contributors""; LINK_LOGO = ""https://qutip.org/images/logo.png"". # font properties; FONT_SIZE = 6; FONT_FAMILY = ""DejaVu Sans"". # figures properties; FIGURE_SIZE = 8; AXIS_SIZE = 50; FONT_COLOR = ""black""; LOGO_SIZE = 40; LOGO_TRANSPARENCY = 0.5. # load the list of contributors from qutip/qutip repo; url_object = urllib.request.urlopen(LINK_CONTRIBUTORS); list_contributors = json.loads(url_object.read()); qutip_contributors = [element[""login""] for element in list_contributors]; qutip_contributors = [s.lower() for s in qutip_contributors]; text = "" "".join(qutip_contributors). # load the QuTiP logo; img = PIL.Image.open(urllib.request.urlopen(LINK_LOGO)). # code below was inspired in the following link:; # https://github.com/dynamicwebpaige/nanowrimo-2021/blob/main/15_VS_Code_contributors.ipynb. n = 100; A = np.linspace(np.pi, n * 2 * np.pi, 10_000); R = 5 + np.linspace(np.pi, n * 2 * np.pi, 10_000); T = np.stack([R * np.cos(A), R * np.sin(A)], axis=1); dx = np.cos(A) - R * np.sin(A); dy = np.sin(A) + R * np.cos(A); O = np.stack([-dy, dx], axis=1); O = O / (np.linalg.norm(O, axis=1)).reshape(len(O), 1). L = np.zeros(len(T)); np.cumsum(np.sqrt(((T[1:] - T[:-1]) ** 2).sum(axis=1)), out=L[1:]). path = TextPath(; (0, 0), text,; size=FONT_SIZE,; prop=FontProperties(family=FONT_FAMILY),; ). vertices = path.vertices; codes = path.codes. Vx, Vy = vertices[:, 0], vertices[:, 1]; X = np.interp(Vx, L, T[:, 0]) + Vy * np.interp(Vx, L, O[:, 0]); Y = np.interp(Vx, L, T[:, 1]) + Vy * np.interp(Vx, L, O[:, 1]); vertices = np.stack([X, Y], axis=-1). path = Path(vertices, codes, closed=False",MatchSource.DOCS,doc/contributors.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/contributors.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/contributors.rst:551,Testability,log,logo,551,".. _developers:. ************; Developers; ************. .. plot::; :context: close-figs; :include-source: False. import json; import urllib.request. import numpy as np; import matplotlib.pyplot as plt. from matplotlib.path import Path; from matplotlib.patches import PathPatch; from matplotlib.textpath import TextPath; from matplotlib.collections import PolyCollection; from matplotlib.font_manager import FontProperties; import PIL. LINK_CONTRIBUTORS = ""https://api.github.com/repos/qutip/qutip/contributors""; LINK_LOGO = ""https://qutip.org/images/logo.png"". # font properties; FONT_SIZE = 6; FONT_FAMILY = ""DejaVu Sans"". # figures properties; FIGURE_SIZE = 8; AXIS_SIZE = 50; FONT_COLOR = ""black""; LOGO_SIZE = 40; LOGO_TRANSPARENCY = 0.5. # load the list of contributors from qutip/qutip repo; url_object = urllib.request.urlopen(LINK_CONTRIBUTORS); list_contributors = json.loads(url_object.read()); qutip_contributors = [element[""login""] for element in list_contributors]; qutip_contributors = [s.lower() for s in qutip_contributors]; text = "" "".join(qutip_contributors). # load the QuTiP logo; img = PIL.Image.open(urllib.request.urlopen(LINK_LOGO)). # code below was inspired in the following link:; # https://github.com/dynamicwebpaige/nanowrimo-2021/blob/main/15_VS_Code_contributors.ipynb. n = 100; A = np.linspace(np.pi, n * 2 * np.pi, 10_000); R = 5 + np.linspace(np.pi, n * 2 * np.pi, 10_000); T = np.stack([R * np.cos(A), R * np.sin(A)], axis=1); dx = np.cos(A) - R * np.sin(A); dy = np.sin(A) + R * np.cos(A); O = np.stack([-dy, dx], axis=1); O = O / (np.linalg.norm(O, axis=1)).reshape(len(O), 1). L = np.zeros(len(T)); np.cumsum(np.sqrt(((T[1:] - T[:-1]) ** 2).sum(axis=1)), out=L[1:]). path = TextPath(; (0, 0), text,; size=FONT_SIZE,; prop=FontProperties(family=FONT_FAMILY),; ). vertices = path.vertices; codes = path.codes. Vx, Vy = vertices[:, 0], vertices[:, 1]; X = np.interp(Vx, L, T[:, 0]) + Vy * np.interp(Vx, L, O[:, 0]); Y = np.interp(Vx, L, T[:, 1]) + Vy * np.interp(Vx,",MatchSource.DOCS,doc/contributors.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/contributors.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/contributors.rst:936,Testability,log,login,936,".. _developers:. ************; Developers; ************. .. plot::; :context: close-figs; :include-source: False. import json; import urllib.request. import numpy as np; import matplotlib.pyplot as plt. from matplotlib.path import Path; from matplotlib.patches import PathPatch; from matplotlib.textpath import TextPath; from matplotlib.collections import PolyCollection; from matplotlib.font_manager import FontProperties; import PIL. LINK_CONTRIBUTORS = ""https://api.github.com/repos/qutip/qutip/contributors""; LINK_LOGO = ""https://qutip.org/images/logo.png"". # font properties; FONT_SIZE = 6; FONT_FAMILY = ""DejaVu Sans"". # figures properties; FIGURE_SIZE = 8; AXIS_SIZE = 50; FONT_COLOR = ""black""; LOGO_SIZE = 40; LOGO_TRANSPARENCY = 0.5. # load the list of contributors from qutip/qutip repo; url_object = urllib.request.urlopen(LINK_CONTRIBUTORS); list_contributors = json.loads(url_object.read()); qutip_contributors = [element[""login""] for element in list_contributors]; qutip_contributors = [s.lower() for s in qutip_contributors]; text = "" "".join(qutip_contributors). # load the QuTiP logo; img = PIL.Image.open(urllib.request.urlopen(LINK_LOGO)). # code below was inspired in the following link:; # https://github.com/dynamicwebpaige/nanowrimo-2021/blob/main/15_VS_Code_contributors.ipynb. n = 100; A = np.linspace(np.pi, n * 2 * np.pi, 10_000); R = 5 + np.linspace(np.pi, n * 2 * np.pi, 10_000); T = np.stack([R * np.cos(A), R * np.sin(A)], axis=1); dx = np.cos(A) - R * np.sin(A); dy = np.sin(A) + R * np.cos(A); O = np.stack([-dy, dx], axis=1); O = O / (np.linalg.norm(O, axis=1)).reshape(len(O), 1). L = np.zeros(len(T)); np.cumsum(np.sqrt(((T[1:] - T[:-1]) ** 2).sum(axis=1)), out=L[1:]). path = TextPath(; (0, 0), text,; size=FONT_SIZE,; prop=FontProperties(family=FONT_FAMILY),; ). vertices = path.vertices; codes = path.codes. Vx, Vy = vertices[:, 0], vertices[:, 1]; X = np.interp(Vx, L, T[:, 0]) + Vy * np.interp(Vx, L, O[:, 0]); Y = np.interp(Vx, L, T[:, 1]) + Vy * np.interp(Vx,",MatchSource.DOCS,doc/contributors.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/contributors.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/contributors.rst:1095,Testability,log,logo,1095,"lude-source: False. import json; import urllib.request. import numpy as np; import matplotlib.pyplot as plt. from matplotlib.path import Path; from matplotlib.patches import PathPatch; from matplotlib.textpath import TextPath; from matplotlib.collections import PolyCollection; from matplotlib.font_manager import FontProperties; import PIL. LINK_CONTRIBUTORS = ""https://api.github.com/repos/qutip/qutip/contributors""; LINK_LOGO = ""https://qutip.org/images/logo.png"". # font properties; FONT_SIZE = 6; FONT_FAMILY = ""DejaVu Sans"". # figures properties; FIGURE_SIZE = 8; AXIS_SIZE = 50; FONT_COLOR = ""black""; LOGO_SIZE = 40; LOGO_TRANSPARENCY = 0.5. # load the list of contributors from qutip/qutip repo; url_object = urllib.request.urlopen(LINK_CONTRIBUTORS); list_contributors = json.loads(url_object.read()); qutip_contributors = [element[""login""] for element in list_contributors]; qutip_contributors = [s.lower() for s in qutip_contributors]; text = "" "".join(qutip_contributors). # load the QuTiP logo; img = PIL.Image.open(urllib.request.urlopen(LINK_LOGO)). # code below was inspired in the following link:; # https://github.com/dynamicwebpaige/nanowrimo-2021/blob/main/15_VS_Code_contributors.ipynb. n = 100; A = np.linspace(np.pi, n * 2 * np.pi, 10_000); R = 5 + np.linspace(np.pi, n * 2 * np.pi, 10_000); T = np.stack([R * np.cos(A), R * np.sin(A)], axis=1); dx = np.cos(A) - R * np.sin(A); dy = np.sin(A) + R * np.cos(A); O = np.stack([-dy, dx], axis=1); O = O / (np.linalg.norm(O, axis=1)).reshape(len(O), 1). L = np.zeros(len(T)); np.cumsum(np.sqrt(((T[1:] - T[:-1]) ** 2).sum(axis=1)), out=L[1:]). path = TextPath(; (0, 0), text,; size=FONT_SIZE,; prop=FontProperties(family=FONT_FAMILY),; ). vertices = path.vertices; codes = path.codes. Vx, Vy = vertices[:, 0], vertices[:, 1]; X = np.interp(Vx, L, T[:, 0]) + Vy * np.interp(Vx, L, O[:, 0]); Y = np.interp(Vx, L, T[:, 1]) + Vy * np.interp(Vx, L, O[:, 1]); vertices = np.stack([X, Y], axis=-1). path = Path(vertices, codes, closed=False",MatchSource.DOCS,doc/contributors.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/contributors.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/contributors.rst:2380,Testability,log,logo,2380,"p.pi, n * 2 * np.pi, 10_000); T = np.stack([R * np.cos(A), R * np.sin(A)], axis=1); dx = np.cos(A) - R * np.sin(A); dy = np.sin(A) + R * np.cos(A); O = np.stack([-dy, dx], axis=1); O = O / (np.linalg.norm(O, axis=1)).reshape(len(O), 1). L = np.zeros(len(T)); np.cumsum(np.sqrt(((T[1:] - T[:-1]) ** 2).sum(axis=1)), out=L[1:]). path = TextPath(; (0, 0), text,; size=FONT_SIZE,; prop=FontProperties(family=FONT_FAMILY),; ). vertices = path.vertices; codes = path.codes. Vx, Vy = vertices[:, 0], vertices[:, 1]; X = np.interp(Vx, L, T[:, 0]) + Vy * np.interp(Vx, L, O[:, 0]); Y = np.interp(Vx, L, T[:, 1]) + Vy * np.interp(Vx, L, O[:, 1]); vertices = np.stack([X, Y], axis=-1). path = Path(vertices, codes, closed=False). # creating figure; fig, ax = plt.subplots(figsize=(FIGURE_SIZE, FIGURE_SIZE)); patch = PathPatch(path, facecolor=FONT_COLOR, linewidth=0); ax.add_artist(patch); ax.set_xlim(-AXIS_SIZE, AXIS_SIZE), ax.set_xticks([]); ax.set_ylim(-AXIS_SIZE, AXIS_SIZE), ax.set_yticks([]). # add qutip logo; ax.imshow(img, alpha=LOGO_TRANSPARENCY,; extent=[-LOGO_SIZE,LOGO_SIZE, -LOGO_SIZE, LOGO_SIZE]). .. _developers-lead:. Lead Developers; ===============. - `Alex Pitchford <https://github.com/ajgpitch>`_; - `Nathan Shammah <https://nathanshammah.com/>`_; - `Shahnawaz Ahmed <http://sahmed.in/>`_; - `Neill Lambert <https://github.com/nwlambert>`_; - `Eric Gigure <https://github.com/Ericgig>`_; - `Boxi Li <https://github.com/BoxiLi>`_; - `Simon Cross <http://hodgestar.za.net/>`_; - `Asier Galicia <https://github.com/AGaliciaMartinez>`_. Past Lead Developers; ====================. - `Robert Johansson <https://jrjohansson.github.io/research.html>`_ (RIKEN); - `Paul Nation <https://www.korea.ac.kr/>`_ (Korea University); - `Chris Granade <https://www.cgranade.com>`_; - `Arne Grimsmo <https://www.sydney.edu.au/science/about/our-people/academic-staff/arne-grimsmo.html>`_; - `Jake Lishman <https://binhbar.com>`_. .. _developers-contributors:. Contributors; ============. .. note::. 	Anyon",MatchSource.DOCS,doc/contributors.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/contributors.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/copyright.rst:566,Availability,avail,available,566,".. _copyright:. ***********************; Copyright and Licensing; ***********************. The text of this documentation is licensed under the `Creative Commons Attribution 3.0 Unported License <https://creativecommons.org/licenses/by/3.0/>`_.; Unless specifically indicated otherwise, all code samples, the source code of QuTiP, and its reproductions in this documentation, are licensed under the terms of the 3-clause BSD license, reproduced below. License Terms for Documentation Text; ====================================. The canonical form of this license is available at `https://creativecommons.org/licenses/by/3.0/ <https://creativecommons.org/licenses/by/3.0/>`_, which should be considered the binding version of this license.; It is reproduced here for convenience. .. include:: LICENSE_cc-by-3.0.txt. License Terms for Source Code of QuTiP and Code Samples; =======================================================. .. include:: ../LICENSE.txt; ",MatchSource.DOCS,doc/copyright.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/copyright.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/frontmatter.rst:255,Availability,avail,available,255,".. _frontmatter:. *************; Frontmatter; *************. .. _about-docs:. About This Documentation; ==========================. This document contains a user guide and automatically generated API documentation for QuTiP. A PDF version of this text is available at the `documentation page <https://qutip.org/documentation.html>`_. **For more information see the** `QuTiP project web page`_. .. _QuTiP project web page: https://qutip.org/. :Author: J.R. Johansson. :Author: P.D. Nation. :Author: Alexander Pitchford. :Author: Arne Grimsmo. :Author: Chris Grenade. :Author: Nathan Shammah. :Author: Shahnawaz Ahmed. :Author: Neill Lambert. :Author: Eric Giguere. :Author: Boxi Li. :Author: Jake Lishman. :Author: Simon Cross. :Author: Asier Galicia. :Author: Paul Menczel. :Author: Patrick Hopf. :release: |release|. :copyright:; The text of this documentation is licensed under the Creative Commons Attribution 3.0 Unported License.; All contained code samples, and the source code of QuTiP, are licensed under the 3-clause BSD licence.; Full details of the copyright notices can be found on the `Copyright and Licensing <copyright>`_ page of this documentation. .. _citing-qutip:. Citing This Project; ==========================. If you find this project useful, then please cite:. .. centered:: J. R. Johansson, P.D. Nation, and F. Nori, ""QuTiP 2: A Python framework for the dynamics of open quantum systems"", Comp. Phys. Comm. **184**, 1234 (2013). or. .. centered:: J. R. Johansson, P.D. Nation, and F. Nori, ""QuTiP: An open-source Python framework for the dynamics of open quantum systems"", Comp. Phys. Comm. **183**, 1760 (2012). which may also be downloaded from https://arxiv.org/abs/1211.6518 or https://arxiv.org/abs/1110.0573, respectively. .. _funding-qutip:. Funding; =======; QuTiP is developed under the auspice of the non-profit organizations:. .. _image-numfocus:. .. figure:: figures/NumFocus_logo.png; :width: 3in; :figclass: align-center. .. _image-unitaryfund:. .. figure:: figu",MatchSource.DOCS,doc/frontmatter.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/frontmatter.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/frontmatter.rst:1656,Availability,down,downloaded,1656,"e. :Author: Boxi Li. :Author: Jake Lishman. :Author: Simon Cross. :Author: Asier Galicia. :Author: Paul Menczel. :Author: Patrick Hopf. :release: |release|. :copyright:; The text of this documentation is licensed under the Creative Commons Attribution 3.0 Unported License.; All contained code samples, and the source code of QuTiP, are licensed under the 3-clause BSD licence.; Full details of the copyright notices can be found on the `Copyright and Licensing <copyright>`_ page of this documentation. .. _citing-qutip:. Citing This Project; ==========================. If you find this project useful, then please cite:. .. centered:: J. R. Johansson, P.D. Nation, and F. Nori, ""QuTiP 2: A Python framework for the dynamics of open quantum systems"", Comp. Phys. Comm. **184**, 1234 (2013). or. .. centered:: J. R. Johansson, P.D. Nation, and F. Nori, ""QuTiP: An open-source Python framework for the dynamics of open quantum systems"", Comp. Phys. Comm. **183**, 1760 (2012). which may also be downloaded from https://arxiv.org/abs/1211.6518 or https://arxiv.org/abs/1110.0573, respectively. .. _funding-qutip:. Funding; =======; QuTiP is developed under the auspice of the non-profit organizations:. .. _image-numfocus:. .. figure:: figures/NumFocus_logo.png; :width: 3in; :figclass: align-center. .. _image-unitaryfund:. .. figure:: figures/unitaryfund_logo.png; :width: 3in; :figclass: align-center. QuTiP was partially supported by. .. _image-jsps:. .. figure:: figures/jsps.jpg; :width: 2in; :figclass: align-center. .. _image-riken:. .. figure:: figures/riken-logo.png; 	:width: 1.5in; 	:figclass: align-center. .. _image-korea:. .. figure:: figures/korea-logo.png; 	:width: 2in; 	:figclass: align-center. .. figure:: figures/inst_quant_sher.png; 	:width: 2in; 	:figclass: align-center. .. _about:. About QuTiP; ===========. Every quantum system encountered in the real world is an open quantum system. For although much care is taken experimentally to eliminate the unwanted influence of exter",MatchSource.DOCS,doc/frontmatter.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/frontmatter.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/frontmatter.rst:4235,Availability,avail,available,4235,"ytical description of the system dynamics is not possible, and one must resort to numerical simulations of the equations of motion. In absence of a quantum computer, these simulations must be carried out using classical computing techniques, where the exponentially increasing dimensionality of the underlying Hilbert space severely limits the size of system that can be efficiently simulated. However, in many fields such as quantum optics, trapped ions, superconducting circuit devices, and most recently nanomechanical systems, it is possible to design systems using a small number of effective oscillator and spin components, excited by a limited number of quanta, that are amenable to classical simulation in a truncated Hilbert space. The Quantum Toolbox in Python, or QuTiP, is an open-source framework written in the Python programming language, designed for simulating the open quantum dynamics of systems such as those listed above. This framework distinguishes itself from other available software solutions in providing the following advantages:. * QuTiP relies entirely on open-source software. You are free to modify and use it as you wish with no licensing fees or limitations. * QuTiP is based on the Python scripting language, providing easy to read, fast code generation without the need to compile after modification. * The numerics underlying QuTiP are time-tested algorithms that run at C-code speeds, thanks to the `Numpy <https://numpy.org>`_, `Scipy <https://scipy.org>`_, and `Cython <https://cython.org>`_ libraries, and are based on many of the same algorithms used in propriety software. * QuTiP allows for solving the dynamics of Hamiltonians with (almost) arbitrary time-dependence, including collapse operators. * Time-dependent problems can be automatically compiled into C++-code at run-time for increased performance. * Takes advantage of the multiple processing cores found in essentially all modern computers. * QuTiP was designed from the start to require a minim",MatchSource.DOCS,doc/frontmatter.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/frontmatter.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/frontmatter.rst:7259,Availability,error,error,7259,"n of Krotov's method for quantum optimal control. :pyEPR: `pyEPR <https://pyepr-docs.readthedocs.io/en/latest/index.html>`_ interfaces classical distributed microwave analysis with that of quantum structures and hamiltonians by providing easy to use analysis function and automation for the design of quantum chips. :scQubits: `scQubits <https://scqubits.readthedocs.io/en/latest/>`_ is a Python library which provides a convenient way to simulate superconducting qubits by providing an interface to QuTiP. :SimulaQron: `SimulaQron <https://softwarequtech.github.io/SimulaQron/html/index.html>`_ is a distributed simulation of the end nodes in a quantum internet with the specific goal to explore application development. :QInfer: `QInfer <http://qinfer.org/>`_ is a library for working with sequential Monte Carlo methods for parameter estimation in quantum information. :QPtomographer: `QPtomographer <https://qptomographer.readthedocs.io/en/latest/>`_ derive quantum error bars for quantum processes in terms of the diamond norm to a reference quantum channel. :QuNetSim: `QuNetSim <https://tqsd.github.io/QuNetSim/intro.html>`_ is a quantum networking simulation framework to develop and test protocols for quantum networks. :qupulse: `qupulse <https://qupulse.readthedocs.io/en/latest/>`_ is a toolkit to facilitate experiments involving pulse driven state manipulation of physical qubits. :Pulser: `Pulser <https://pulser.readthedocs.io/en/latest/>`_ is a framework for composing, simulating and executing pulse sequences for neutral-atom quantum devices. Contributing to QuTiP; =====================. We welcome anyone who is interested in helping us make QuTiP the best package for simulating quantum systems.; There are :ref:`detailed instructions on how to contribute code and documentation <development-contributing>` in the developers' section of this guide.; You can also help out our users by answering questions in the `QuTiP discussion mailing list <https://groups.google.com/g/qutip>`",MatchSource.DOCS,doc/frontmatter.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/frontmatter.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/frontmatter.rst:798,Deployability,release,release,798,".. _frontmatter:. *************; Frontmatter; *************. .. _about-docs:. About This Documentation; ==========================. This document contains a user guide and automatically generated API documentation for QuTiP. A PDF version of this text is available at the `documentation page <https://qutip.org/documentation.html>`_. **For more information see the** `QuTiP project web page`_. .. _QuTiP project web page: https://qutip.org/. :Author: J.R. Johansson. :Author: P.D. Nation. :Author: Alexander Pitchford. :Author: Arne Grimsmo. :Author: Chris Grenade. :Author: Nathan Shammah. :Author: Shahnawaz Ahmed. :Author: Neill Lambert. :Author: Eric Giguere. :Author: Boxi Li. :Author: Jake Lishman. :Author: Simon Cross. :Author: Asier Galicia. :Author: Paul Menczel. :Author: Patrick Hopf. :release: |release|. :copyright:; The text of this documentation is licensed under the Creative Commons Attribution 3.0 Unported License.; All contained code samples, and the source code of QuTiP, are licensed under the 3-clause BSD licence.; Full details of the copyright notices can be found on the `Copyright and Licensing <copyright>`_ page of this documentation. .. _citing-qutip:. Citing This Project; ==========================. If you find this project useful, then please cite:. .. centered:: J. R. Johansson, P.D. Nation, and F. Nori, ""QuTiP 2: A Python framework for the dynamics of open quantum systems"", Comp. Phys. Comm. **184**, 1234 (2013). or. .. centered:: J. R. Johansson, P.D. Nation, and F. Nori, ""QuTiP: An open-source Python framework for the dynamics of open quantum systems"", Comp. Phys. Comm. **183**, 1760 (2012). which may also be downloaded from https://arxiv.org/abs/1211.6518 or https://arxiv.org/abs/1110.0573, respectively. .. _funding-qutip:. Funding; =======; QuTiP is developed under the auspice of the non-profit organizations:. .. _image-numfocus:. .. figure:: figures/NumFocus_logo.png; :width: 3in; :figclass: align-center. .. _image-unitaryfund:. .. figure:: figu",MatchSource.DOCS,doc/frontmatter.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/frontmatter.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/frontmatter.rst:808,Deployability,release,release,808,".. _frontmatter:. *************; Frontmatter; *************. .. _about-docs:. About This Documentation; ==========================. This document contains a user guide and automatically generated API documentation for QuTiP. A PDF version of this text is available at the `documentation page <https://qutip.org/documentation.html>`_. **For more information see the** `QuTiP project web page`_. .. _QuTiP project web page: https://qutip.org/. :Author: J.R. Johansson. :Author: P.D. Nation. :Author: Alexander Pitchford. :Author: Arne Grimsmo. :Author: Chris Grenade. :Author: Nathan Shammah. :Author: Shahnawaz Ahmed. :Author: Neill Lambert. :Author: Eric Giguere. :Author: Boxi Li. :Author: Jake Lishman. :Author: Simon Cross. :Author: Asier Galicia. :Author: Paul Menczel. :Author: Patrick Hopf. :release: |release|. :copyright:; The text of this documentation is licensed under the Creative Commons Attribution 3.0 Unported License.; All contained code samples, and the source code of QuTiP, are licensed under the 3-clause BSD licence.; Full details of the copyright notices can be found on the `Copyright and Licensing <copyright>`_ page of this documentation. .. _citing-qutip:. Citing This Project; ==========================. If you find this project useful, then please cite:. .. centered:: J. R. Johansson, P.D. Nation, and F. Nori, ""QuTiP 2: A Python framework for the dynamics of open quantum systems"", Comp. Phys. Comm. **184**, 1234 (2013). or. .. centered:: J. R. Johansson, P.D. Nation, and F. Nori, ""QuTiP: An open-source Python framework for the dynamics of open quantum systems"", Comp. Phys. Comm. **183**, 1760 (2012). which may also be downloaded from https://arxiv.org/abs/1211.6518 or https://arxiv.org/abs/1110.0573, respectively. .. _funding-qutip:. Funding; =======; QuTiP is developed under the auspice of the non-profit organizations:. .. _image-numfocus:. .. figure:: figures/NumFocus_logo.png; :width: 3in; :figclass: align-center. .. _image-unitaryfund:. .. figure:: figu",MatchSource.DOCS,doc/frontmatter.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/frontmatter.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/frontmatter.rst:5544,Deployability,release,release,5544,"ut the need to compile after modification. * The numerics underlying QuTiP are time-tested algorithms that run at C-code speeds, thanks to the `Numpy <https://numpy.org>`_, `Scipy <https://scipy.org>`_, and `Cython <https://cython.org>`_ libraries, and are based on many of the same algorithms used in propriety software. * QuTiP allows for solving the dynamics of Hamiltonians with (almost) arbitrary time-dependence, including collapse operators. * Time-dependent problems can be automatically compiled into C++-code at run-time for increased performance. * Takes advantage of the multiple processing cores found in essentially all modern computers. * QuTiP was designed from the start to require a minimal learning curve for those users who have experience using the popular quantum optics toolbox by Sze M. Tan. * Includes the ability to create high-quality plots, and animations, using the excellent `Matplotlib <https://matplotlib.org>`_ package. For detailed information about new features of each release of QuTiP, see the :ref:`changelog`. .. _plugin-qutip:. QuTiP Plugins; =============. Several libraries depend on QuTiP heavily making QuTiP a super-library. :Matsubara: `Matsubara <https://matsubara.readthedocs.io/en/latest/>`_ is a plugin to study the ultrastrong coupling regime with structured baths. :QNET: `QNET <https://qnet.readthedocs.io/en/latest/readme.html>`_ is a computer algebra package for quantum mechanics and photonic quantum networks. .. _libraries:. Libraries Using QuTiP; =====================. Several libraries rely on QuTiP for quantum physics or quantum information processing. Some of them are:. :Krotov: `Krotov <https://qucontrol.github.io/krotov/v1.2.0/01_overview.html>`_ focuses on the python implementation of Krotov's method for quantum optimal control. :pyEPR: `pyEPR <https://pyepr-docs.readthedocs.io/en/latest/index.html>`_ interfaces classical distributed microwave analysis with that of quantum structures and hamiltonians by providing easy to use ",MatchSource.DOCS,doc/frontmatter.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/frontmatter.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/frontmatter.rst:3616,Energy Efficiency,efficient,efficiently,3616,"system encountered in the real world is an open quantum system. For although much care is taken experimentally to eliminate the unwanted influence of external interactions, there remains, if ever so slight, a coupling between the system of interest and the external world. In addition, any measurement performed on the system necessarily involves coupling to the measuring device, therefore introducing an additional source of external influence. Consequently, developing the necessary tools, both theoretical and numerical, to account for the interactions between a system and its environment is an essential step in understanding the dynamics of practical quantum systems. In general, for all but the most basic of Hamiltonians, an analytical description of the system dynamics is not possible, and one must resort to numerical simulations of the equations of motion. In absence of a quantum computer, these simulations must be carried out using classical computing techniques, where the exponentially increasing dimensionality of the underlying Hilbert space severely limits the size of system that can be efficiently simulated. However, in many fields such as quantum optics, trapped ions, superconducting circuit devices, and most recently nanomechanical systems, it is possible to design systems using a small number of effective oscillator and spin components, excited by a limited number of quanta, that are amenable to classical simulation in a truncated Hilbert space. The Quantum Toolbox in Python, or QuTiP, is an open-source framework written in the Python programming language, designed for simulating the open quantum dynamics of systems such as those listed above. This framework distinguishes itself from other available software solutions in providing the following advantages:. * QuTiP relies entirely on open-source software. You are free to modify and use it as you wish with no licensing fees or limitations. * QuTiP is based on the Python scripting language, providing easy to ",MatchSource.DOCS,doc/frontmatter.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/frontmatter.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/frontmatter.rst:4946,Integrability,depend,dependence,4946,"amenable to classical simulation in a truncated Hilbert space. The Quantum Toolbox in Python, or QuTiP, is an open-source framework written in the Python programming language, designed for simulating the open quantum dynamics of systems such as those listed above. This framework distinguishes itself from other available software solutions in providing the following advantages:. * QuTiP relies entirely on open-source software. You are free to modify and use it as you wish with no licensing fees or limitations. * QuTiP is based on the Python scripting language, providing easy to read, fast code generation without the need to compile after modification. * The numerics underlying QuTiP are time-tested algorithms that run at C-code speeds, thanks to the `Numpy <https://numpy.org>`_, `Scipy <https://scipy.org>`_, and `Cython <https://cython.org>`_ libraries, and are based on many of the same algorithms used in propriety software. * QuTiP allows for solving the dynamics of Hamiltonians with (almost) arbitrary time-dependence, including collapse operators. * Time-dependent problems can be automatically compiled into C++-code at run-time for increased performance. * Takes advantage of the multiple processing cores found in essentially all modern computers. * QuTiP was designed from the start to require a minimal learning curve for those users who have experience using the popular quantum optics toolbox by Sze M. Tan. * Includes the ability to create high-quality plots, and animations, using the excellent `Matplotlib <https://matplotlib.org>`_ package. For detailed information about new features of each release of QuTiP, see the :ref:`changelog`. .. _plugin-qutip:. QuTiP Plugins; =============. Several libraries depend on QuTiP heavily making QuTiP a super-library. :Matsubara: `Matsubara <https://matsubara.readthedocs.io/en/latest/>`_ is a plugin to study the ultrastrong coupling regime with structured baths. :QNET: `QNET <https://qnet.readthedocs.io/en/latest/readme.html>`_ i",MatchSource.DOCS,doc/frontmatter.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/frontmatter.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/frontmatter.rst:4995,Integrability,depend,dependent,4995,"rce framework written in the Python programming language, designed for simulating the open quantum dynamics of systems such as those listed above. This framework distinguishes itself from other available software solutions in providing the following advantages:. * QuTiP relies entirely on open-source software. You are free to modify and use it as you wish with no licensing fees or limitations. * QuTiP is based on the Python scripting language, providing easy to read, fast code generation without the need to compile after modification. * The numerics underlying QuTiP are time-tested algorithms that run at C-code speeds, thanks to the `Numpy <https://numpy.org>`_, `Scipy <https://scipy.org>`_, and `Cython <https://cython.org>`_ libraries, and are based on many of the same algorithms used in propriety software. * QuTiP allows for solving the dynamics of Hamiltonians with (almost) arbitrary time-dependence, including collapse operators. * Time-dependent problems can be automatically compiled into C++-code at run-time for increased performance. * Takes advantage of the multiple processing cores found in essentially all modern computers. * QuTiP was designed from the start to require a minimal learning curve for those users who have experience using the popular quantum optics toolbox by Sze M. Tan. * Includes the ability to create high-quality plots, and animations, using the excellent `Matplotlib <https://matplotlib.org>`_ package. For detailed information about new features of each release of QuTiP, see the :ref:`changelog`. .. _plugin-qutip:. QuTiP Plugins; =============. Several libraries depend on QuTiP heavily making QuTiP a super-library. :Matsubara: `Matsubara <https://matsubara.readthedocs.io/en/latest/>`_ is a plugin to study the ultrastrong coupling regime with structured baths. :QNET: `QNET <https://qnet.readthedocs.io/en/latest/readme.html>`_ is a computer algebra package for quantum mechanics and photonic quantum networks. .. _libraries:. Libraries Using QuTi",MatchSource.DOCS,doc/frontmatter.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/frontmatter.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/frontmatter.rst:5655,Integrability,depend,depend,5655,"ks to the `Numpy <https://numpy.org>`_, `Scipy <https://scipy.org>`_, and `Cython <https://cython.org>`_ libraries, and are based on many of the same algorithms used in propriety software. * QuTiP allows for solving the dynamics of Hamiltonians with (almost) arbitrary time-dependence, including collapse operators. * Time-dependent problems can be automatically compiled into C++-code at run-time for increased performance. * Takes advantage of the multiple processing cores found in essentially all modern computers. * QuTiP was designed from the start to require a minimal learning curve for those users who have experience using the popular quantum optics toolbox by Sze M. Tan. * Includes the ability to create high-quality plots, and animations, using the excellent `Matplotlib <https://matplotlib.org>`_ package. For detailed information about new features of each release of QuTiP, see the :ref:`changelog`. .. _plugin-qutip:. QuTiP Plugins; =============. Several libraries depend on QuTiP heavily making QuTiP a super-library. :Matsubara: `Matsubara <https://matsubara.readthedocs.io/en/latest/>`_ is a plugin to study the ultrastrong coupling regime with structured baths. :QNET: `QNET <https://qnet.readthedocs.io/en/latest/readme.html>`_ is a computer algebra package for quantum mechanics and photonic quantum networks. .. _libraries:. Libraries Using QuTiP; =====================. Several libraries rely on QuTiP for quantum physics or quantum information processing. Some of them are:. :Krotov: `Krotov <https://qucontrol.github.io/krotov/v1.2.0/01_overview.html>`_ focuses on the python implementation of Krotov's method for quantum optimal control. :pyEPR: `pyEPR <https://pyepr-docs.readthedocs.io/en/latest/index.html>`_ interfaces classical distributed microwave analysis with that of quantum structures and hamiltonians by providing easy to use analysis function and automation for the design of quantum chips. :scQubits: `scQubits <https://scqubits.readthedocs.io/en/latest/>`_",MatchSource.DOCS,doc/frontmatter.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/frontmatter.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/frontmatter.rst:6413,Integrability,interface,interfaces,6413," information about new features of each release of QuTiP, see the :ref:`changelog`. .. _plugin-qutip:. QuTiP Plugins; =============. Several libraries depend on QuTiP heavily making QuTiP a super-library. :Matsubara: `Matsubara <https://matsubara.readthedocs.io/en/latest/>`_ is a plugin to study the ultrastrong coupling regime with structured baths. :QNET: `QNET <https://qnet.readthedocs.io/en/latest/readme.html>`_ is a computer algebra package for quantum mechanics and photonic quantum networks. .. _libraries:. Libraries Using QuTiP; =====================. Several libraries rely on QuTiP for quantum physics or quantum information processing. Some of them are:. :Krotov: `Krotov <https://qucontrol.github.io/krotov/v1.2.0/01_overview.html>`_ focuses on the python implementation of Krotov's method for quantum optimal control. :pyEPR: `pyEPR <https://pyepr-docs.readthedocs.io/en/latest/index.html>`_ interfaces classical distributed microwave analysis with that of quantum structures and hamiltonians by providing easy to use analysis function and automation for the design of quantum chips. :scQubits: `scQubits <https://scqubits.readthedocs.io/en/latest/>`_ is a Python library which provides a convenient way to simulate superconducting qubits by providing an interface to QuTiP. :SimulaQron: `SimulaQron <https://softwarequtech.github.io/SimulaQron/html/index.html>`_ is a distributed simulation of the end nodes in a quantum internet with the specific goal to explore application development. :QInfer: `QInfer <http://qinfer.org/>`_ is a library for working with sequential Monte Carlo methods for parameter estimation in quantum information. :QPtomographer: `QPtomographer <https://qptomographer.readthedocs.io/en/latest/>`_ derive quantum error bars for quantum processes in terms of the diamond norm to a reference quantum channel. :QuNetSim: `QuNetSim <https://tqsd.github.io/QuNetSim/intro.html>`_ is a quantum networking simulation framework to develop and test protocols for quant",MatchSource.DOCS,doc/frontmatter.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/frontmatter.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/frontmatter.rst:6776,Integrability,interface,interface,6776,subara <https://matsubara.readthedocs.io/en/latest/>`_ is a plugin to study the ultrastrong coupling regime with structured baths. :QNET: `QNET <https://qnet.readthedocs.io/en/latest/readme.html>`_ is a computer algebra package for quantum mechanics and photonic quantum networks. .. _libraries:. Libraries Using QuTiP; =====================. Several libraries rely on QuTiP for quantum physics or quantum information processing. Some of them are:. :Krotov: `Krotov <https://qucontrol.github.io/krotov/v1.2.0/01_overview.html>`_ focuses on the python implementation of Krotov's method for quantum optimal control. :pyEPR: `pyEPR <https://pyepr-docs.readthedocs.io/en/latest/index.html>`_ interfaces classical distributed microwave analysis with that of quantum structures and hamiltonians by providing easy to use analysis function and automation for the design of quantum chips. :scQubits: `scQubits <https://scqubits.readthedocs.io/en/latest/>`_ is a Python library which provides a convenient way to simulate superconducting qubits by providing an interface to QuTiP. :SimulaQron: `SimulaQron <https://softwarequtech.github.io/SimulaQron/html/index.html>`_ is a distributed simulation of the end nodes in a quantum internet with the specific goal to explore application development. :QInfer: `QInfer <http://qinfer.org/>`_ is a library for working with sequential Monte Carlo methods for parameter estimation in quantum information. :QPtomographer: `QPtomographer <https://qptomographer.readthedocs.io/en/latest/>`_ derive quantum error bars for quantum processes in terms of the diamond norm to a reference quantum channel. :QuNetSim: `QuNetSim <https://tqsd.github.io/QuNetSim/intro.html>`_ is a quantum networking simulation framework to develop and test protocols for quantum networks. :qupulse: `qupulse <https://qupulse.readthedocs.io/en/latest/>`_ is a toolkit to facilitate experiments involving pulse driven state manipulation of physical qubits. :Pulser: `Pulser <https://pulser.readthedo,MatchSource.DOCS,doc/frontmatter.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/frontmatter.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/frontmatter.rst:7486,Integrability,protocol,protocols,7486,"with that of quantum structures and hamiltonians by providing easy to use analysis function and automation for the design of quantum chips. :scQubits: `scQubits <https://scqubits.readthedocs.io/en/latest/>`_ is a Python library which provides a convenient way to simulate superconducting qubits by providing an interface to QuTiP. :SimulaQron: `SimulaQron <https://softwarequtech.github.io/SimulaQron/html/index.html>`_ is a distributed simulation of the end nodes in a quantum internet with the specific goal to explore application development. :QInfer: `QInfer <http://qinfer.org/>`_ is a library for working with sequential Monte Carlo methods for parameter estimation in quantum information. :QPtomographer: `QPtomographer <https://qptomographer.readthedocs.io/en/latest/>`_ derive quantum error bars for quantum processes in terms of the diamond norm to a reference quantum channel. :QuNetSim: `QuNetSim <https://tqsd.github.io/QuNetSim/intro.html>`_ is a quantum networking simulation framework to develop and test protocols for quantum networks. :qupulse: `qupulse <https://qupulse.readthedocs.io/en/latest/>`_ is a toolkit to facilitate experiments involving pulse driven state manipulation of physical qubits. :Pulser: `Pulser <https://pulser.readthedocs.io/en/latest/>`_ is a framework for composing, simulating and executing pulse sequences for neutral-atom quantum devices. Contributing to QuTiP; =====================. We welcome anyone who is interested in helping us make QuTiP the best package for simulating quantum systems.; There are :ref:`detailed instructions on how to contribute code and documentation <development-contributing>` in the developers' section of this guide.; You can also help out our users by answering questions in the `QuTiP discussion mailing list <https://groups.google.com/g/qutip>`_, or by raising issues in `the main GitHub repository <https://github.com/qutip/qutip>`_ if you find any bugs.; Anyone who contributes code will be duly recognized.; Even sma",MatchSource.DOCS,doc/frontmatter.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/frontmatter.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/frontmatter.rst:2716,Modifiability,coupling,coupling,2716,"tps://arxiv.org/abs/1211.6518 or https://arxiv.org/abs/1110.0573, respectively. .. _funding-qutip:. Funding; =======; QuTiP is developed under the auspice of the non-profit organizations:. .. _image-numfocus:. .. figure:: figures/NumFocus_logo.png; :width: 3in; :figclass: align-center. .. _image-unitaryfund:. .. figure:: figures/unitaryfund_logo.png; :width: 3in; :figclass: align-center. QuTiP was partially supported by. .. _image-jsps:. .. figure:: figures/jsps.jpg; :width: 2in; :figclass: align-center. .. _image-riken:. .. figure:: figures/riken-logo.png; 	:width: 1.5in; 	:figclass: align-center. .. _image-korea:. .. figure:: figures/korea-logo.png; 	:width: 2in; 	:figclass: align-center. .. figure:: figures/inst_quant_sher.png; 	:width: 2in; 	:figclass: align-center. .. _about:. About QuTiP; ===========. Every quantum system encountered in the real world is an open quantum system. For although much care is taken experimentally to eliminate the unwanted influence of external interactions, there remains, if ever so slight, a coupling between the system of interest and the external world. In addition, any measurement performed on the system necessarily involves coupling to the measuring device, therefore introducing an additional source of external influence. Consequently, developing the necessary tools, both theoretical and numerical, to account for the interactions between a system and its environment is an essential step in understanding the dynamics of practical quantum systems. In general, for all but the most basic of Hamiltonians, an analytical description of the system dynamics is not possible, and one must resort to numerical simulations of the equations of motion. In absence of a quantum computer, these simulations must be carried out using classical computing techniques, where the exponentially increasing dimensionality of the underlying Hilbert space severely limits the size of system that can be efficiently simulated. However, in many fields such as quan",MatchSource.DOCS,doc/frontmatter.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/frontmatter.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/frontmatter.rst:2854,Modifiability,coupling,coupling,2854,"_image-numfocus:. .. figure:: figures/NumFocus_logo.png; :width: 3in; :figclass: align-center. .. _image-unitaryfund:. .. figure:: figures/unitaryfund_logo.png; :width: 3in; :figclass: align-center. QuTiP was partially supported by. .. _image-jsps:. .. figure:: figures/jsps.jpg; :width: 2in; :figclass: align-center. .. _image-riken:. .. figure:: figures/riken-logo.png; 	:width: 1.5in; 	:figclass: align-center. .. _image-korea:. .. figure:: figures/korea-logo.png; 	:width: 2in; 	:figclass: align-center. .. figure:: figures/inst_quant_sher.png; 	:width: 2in; 	:figclass: align-center. .. _about:. About QuTiP; ===========. Every quantum system encountered in the real world is an open quantum system. For although much care is taken experimentally to eliminate the unwanted influence of external interactions, there remains, if ever so slight, a coupling between the system of interest and the external world. In addition, any measurement performed on the system necessarily involves coupling to the measuring device, therefore introducing an additional source of external influence. Consequently, developing the necessary tools, both theoretical and numerical, to account for the interactions between a system and its environment is an essential step in understanding the dynamics of practical quantum systems. In general, for all but the most basic of Hamiltonians, an analytical description of the system dynamics is not possible, and one must resort to numerical simulations of the equations of motion. In absence of a quantum computer, these simulations must be carried out using classical computing techniques, where the exponentially increasing dimensionality of the underlying Hilbert space severely limits the size of system that can be efficiently simulated. However, in many fields such as quantum optics, trapped ions, superconducting circuit devices, and most recently nanomechanical systems, it is possible to design systems using a small number of effective oscillator and spin com",MatchSource.DOCS,doc/frontmatter.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/frontmatter.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/frontmatter.rst:5785,Modifiability,plugin,plugin,5785," of the same algorithms used in propriety software. * QuTiP allows for solving the dynamics of Hamiltonians with (almost) arbitrary time-dependence, including collapse operators. * Time-dependent problems can be automatically compiled into C++-code at run-time for increased performance. * Takes advantage of the multiple processing cores found in essentially all modern computers. * QuTiP was designed from the start to require a minimal learning curve for those users who have experience using the popular quantum optics toolbox by Sze M. Tan. * Includes the ability to create high-quality plots, and animations, using the excellent `Matplotlib <https://matplotlib.org>`_ package. For detailed information about new features of each release of QuTiP, see the :ref:`changelog`. .. _plugin-qutip:. QuTiP Plugins; =============. Several libraries depend on QuTiP heavily making QuTiP a super-library. :Matsubara: `Matsubara <https://matsubara.readthedocs.io/en/latest/>`_ is a plugin to study the ultrastrong coupling regime with structured baths. :QNET: `QNET <https://qnet.readthedocs.io/en/latest/readme.html>`_ is a computer algebra package for quantum mechanics and photonic quantum networks. .. _libraries:. Libraries Using QuTiP; =====================. Several libraries rely on QuTiP for quantum physics or quantum information processing. Some of them are:. :Krotov: `Krotov <https://qucontrol.github.io/krotov/v1.2.0/01_overview.html>`_ focuses on the python implementation of Krotov's method for quantum optimal control. :pyEPR: `pyEPR <https://pyepr-docs.readthedocs.io/en/latest/index.html>`_ interfaces classical distributed microwave analysis with that of quantum structures and hamiltonians by providing easy to use analysis function and automation for the design of quantum chips. :scQubits: `scQubits <https://scqubits.readthedocs.io/en/latest/>`_ is a Python library which provides a convenient way to simulate superconducting qubits by providing an interface to QuTiP. :SimulaQron: ",MatchSource.DOCS,doc/frontmatter.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/frontmatter.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/frontmatter.rst:5817,Modifiability,coupling,coupling,5817," of the same algorithms used in propriety software. * QuTiP allows for solving the dynamics of Hamiltonians with (almost) arbitrary time-dependence, including collapse operators. * Time-dependent problems can be automatically compiled into C++-code at run-time for increased performance. * Takes advantage of the multiple processing cores found in essentially all modern computers. * QuTiP was designed from the start to require a minimal learning curve for those users who have experience using the popular quantum optics toolbox by Sze M. Tan. * Includes the ability to create high-quality plots, and animations, using the excellent `Matplotlib <https://matplotlib.org>`_ package. For detailed information about new features of each release of QuTiP, see the :ref:`changelog`. .. _plugin-qutip:. QuTiP Plugins; =============. Several libraries depend on QuTiP heavily making QuTiP a super-library. :Matsubara: `Matsubara <https://matsubara.readthedocs.io/en/latest/>`_ is a plugin to study the ultrastrong coupling regime with structured baths. :QNET: `QNET <https://qnet.readthedocs.io/en/latest/readme.html>`_ is a computer algebra package for quantum mechanics and photonic quantum networks. .. _libraries:. Libraries Using QuTiP; =====================. Several libraries rely on QuTiP for quantum physics or quantum information processing. Some of them are:. :Krotov: `Krotov <https://qucontrol.github.io/krotov/v1.2.0/01_overview.html>`_ focuses on the python implementation of Krotov's method for quantum optimal control. :pyEPR: `pyEPR <https://pyepr-docs.readthedocs.io/en/latest/index.html>`_ interfaces classical distributed microwave analysis with that of quantum structures and hamiltonians by providing easy to use analysis function and automation for the design of quantum chips. :scQubits: `scQubits <https://scqubits.readthedocs.io/en/latest/>`_ is a Python library which provides a convenient way to simulate superconducting qubits by providing an interface to QuTiP. :SimulaQron: ",MatchSource.DOCS,doc/frontmatter.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/frontmatter.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/frontmatter.rst:2809,Performance,perform,performed,2809,"_image-numfocus:. .. figure:: figures/NumFocus_logo.png; :width: 3in; :figclass: align-center. .. _image-unitaryfund:. .. figure:: figures/unitaryfund_logo.png; :width: 3in; :figclass: align-center. QuTiP was partially supported by. .. _image-jsps:. .. figure:: figures/jsps.jpg; :width: 2in; :figclass: align-center. .. _image-riken:. .. figure:: figures/riken-logo.png; 	:width: 1.5in; 	:figclass: align-center. .. _image-korea:. .. figure:: figures/korea-logo.png; 	:width: 2in; 	:figclass: align-center. .. figure:: figures/inst_quant_sher.png; 	:width: 2in; 	:figclass: align-center. .. _about:. About QuTiP; ===========. Every quantum system encountered in the real world is an open quantum system. For although much care is taken experimentally to eliminate the unwanted influence of external interactions, there remains, if ever so slight, a coupling between the system of interest and the external world. In addition, any measurement performed on the system necessarily involves coupling to the measuring device, therefore introducing an additional source of external influence. Consequently, developing the necessary tools, both theoretical and numerical, to account for the interactions between a system and its environment is an essential step in understanding the dynamics of practical quantum systems. In general, for all but the most basic of Hamiltonians, an analytical description of the system dynamics is not possible, and one must resort to numerical simulations of the equations of motion. In absence of a quantum computer, these simulations must be carried out using classical computing techniques, where the exponentially increasing dimensionality of the underlying Hilbert space severely limits the size of system that can be efficiently simulated. However, in many fields such as quantum optics, trapped ions, superconducting circuit devices, and most recently nanomechanical systems, it is possible to design systems using a small number of effective oscillator and spin com",MatchSource.DOCS,doc/frontmatter.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/frontmatter.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/frontmatter.rst:5084,Performance,perform,performance,5084,"rce framework written in the Python programming language, designed for simulating the open quantum dynamics of systems such as those listed above. This framework distinguishes itself from other available software solutions in providing the following advantages:. * QuTiP relies entirely on open-source software. You are free to modify and use it as you wish with no licensing fees or limitations. * QuTiP is based on the Python scripting language, providing easy to read, fast code generation without the need to compile after modification. * The numerics underlying QuTiP are time-tested algorithms that run at C-code speeds, thanks to the `Numpy <https://numpy.org>`_, `Scipy <https://scipy.org>`_, and `Cython <https://cython.org>`_ libraries, and are based on many of the same algorithms used in propriety software. * QuTiP allows for solving the dynamics of Hamiltonians with (almost) arbitrary time-dependence, including collapse operators. * Time-dependent problems can be automatically compiled into C++-code at run-time for increased performance. * Takes advantage of the multiple processing cores found in essentially all modern computers. * QuTiP was designed from the start to require a minimal learning curve for those users who have experience using the popular quantum optics toolbox by Sze M. Tan. * Includes the ability to create high-quality plots, and animations, using the excellent `Matplotlib <https://matplotlib.org>`_ package. For detailed information about new features of each release of QuTiP, see the :ref:`changelog`. .. _plugin-qutip:. QuTiP Plugins; =============. Several libraries depend on QuTiP heavily making QuTiP a super-library. :Matsubara: `Matsubara <https://matsubara.readthedocs.io/en/latest/>`_ is a plugin to study the ultrastrong coupling regime with structured baths. :QNET: `QNET <https://qnet.readthedocs.io/en/latest/readme.html>`_ is a computer algebra package for quantum mechanics and photonic quantum networks. .. _libraries:. Libraries Using QuTi",MatchSource.DOCS,doc/frontmatter.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/frontmatter.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/frontmatter.rst:2228,Testability,log,logo,2228,"=============. If you find this project useful, then please cite:. .. centered:: J. R. Johansson, P.D. Nation, and F. Nori, ""QuTiP 2: A Python framework for the dynamics of open quantum systems"", Comp. Phys. Comm. **184**, 1234 (2013). or. .. centered:: J. R. Johansson, P.D. Nation, and F. Nori, ""QuTiP: An open-source Python framework for the dynamics of open quantum systems"", Comp. Phys. Comm. **183**, 1760 (2012). which may also be downloaded from https://arxiv.org/abs/1211.6518 or https://arxiv.org/abs/1110.0573, respectively. .. _funding-qutip:. Funding; =======; QuTiP is developed under the auspice of the non-profit organizations:. .. _image-numfocus:. .. figure:: figures/NumFocus_logo.png; :width: 3in; :figclass: align-center. .. _image-unitaryfund:. .. figure:: figures/unitaryfund_logo.png; :width: 3in; :figclass: align-center. QuTiP was partially supported by. .. _image-jsps:. .. figure:: figures/jsps.jpg; :width: 2in; :figclass: align-center. .. _image-riken:. .. figure:: figures/riken-logo.png; 	:width: 1.5in; 	:figclass: align-center. .. _image-korea:. .. figure:: figures/korea-logo.png; 	:width: 2in; 	:figclass: align-center. .. figure:: figures/inst_quant_sher.png; 	:width: 2in; 	:figclass: align-center. .. _about:. About QuTiP; ===========. Every quantum system encountered in the real world is an open quantum system. For although much care is taken experimentally to eliminate the unwanted influence of external interactions, there remains, if ever so slight, a coupling between the system of interest and the external world. In addition, any measurement performed on the system necessarily involves coupling to the measuring device, therefore introducing an additional source of external influence. Consequently, developing the necessary tools, both theoretical and numerical, to account for the interactions between a system and its environment is an essential step in understanding the dynamics of practical quantum systems. In general, for all but the most basi",MatchSource.DOCS,doc/frontmatter.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/frontmatter.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/frontmatter.rst:2324,Testability,log,logo,2324,", P.D. Nation, and F. Nori, ""QuTiP 2: A Python framework for the dynamics of open quantum systems"", Comp. Phys. Comm. **184**, 1234 (2013). or. .. centered:: J. R. Johansson, P.D. Nation, and F. Nori, ""QuTiP: An open-source Python framework for the dynamics of open quantum systems"", Comp. Phys. Comm. **183**, 1760 (2012). which may also be downloaded from https://arxiv.org/abs/1211.6518 or https://arxiv.org/abs/1110.0573, respectively. .. _funding-qutip:. Funding; =======; QuTiP is developed under the auspice of the non-profit organizations:. .. _image-numfocus:. .. figure:: figures/NumFocus_logo.png; :width: 3in; :figclass: align-center. .. _image-unitaryfund:. .. figure:: figures/unitaryfund_logo.png; :width: 3in; :figclass: align-center. QuTiP was partially supported by. .. _image-jsps:. .. figure:: figures/jsps.jpg; :width: 2in; :figclass: align-center. .. _image-riken:. .. figure:: figures/riken-logo.png; 	:width: 1.5in; 	:figclass: align-center. .. _image-korea:. .. figure:: figures/korea-logo.png; 	:width: 2in; 	:figclass: align-center. .. figure:: figures/inst_quant_sher.png; 	:width: 2in; 	:figclass: align-center. .. _about:. About QuTiP; ===========. Every quantum system encountered in the real world is an open quantum system. For although much care is taken experimentally to eliminate the unwanted influence of external interactions, there remains, if ever so slight, a coupling between the system of interest and the external world. In addition, any measurement performed on the system necessarily involves coupling to the measuring device, therefore introducing an additional source of external influence. Consequently, developing the necessary tools, both theoretical and numerical, to account for the interactions between a system and its environment is an essential step in understanding the dynamics of practical quantum systems. In general, for all but the most basic of Hamiltonians, an analytical description of the system dynamics is not possible, and one mus",MatchSource.DOCS,doc/frontmatter.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/frontmatter.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/frontmatter.rst:4623,Testability,test,tested,4623,"ever, in many fields such as quantum optics, trapped ions, superconducting circuit devices, and most recently nanomechanical systems, it is possible to design systems using a small number of effective oscillator and spin components, excited by a limited number of quanta, that are amenable to classical simulation in a truncated Hilbert space. The Quantum Toolbox in Python, or QuTiP, is an open-source framework written in the Python programming language, designed for simulating the open quantum dynamics of systems such as those listed above. This framework distinguishes itself from other available software solutions in providing the following advantages:. * QuTiP relies entirely on open-source software. You are free to modify and use it as you wish with no licensing fees or limitations. * QuTiP is based on the Python scripting language, providing easy to read, fast code generation without the need to compile after modification. * The numerics underlying QuTiP are time-tested algorithms that run at C-code speeds, thanks to the `Numpy <https://numpy.org>`_, `Scipy <https://scipy.org>`_, and `Cython <https://cython.org>`_ libraries, and are based on many of the same algorithms used in propriety software. * QuTiP allows for solving the dynamics of Hamiltonians with (almost) arbitrary time-dependence, including collapse operators. * Time-dependent problems can be automatically compiled into C++-code at run-time for increased performance. * Takes advantage of the multiple processing cores found in essentially all modern computers. * QuTiP was designed from the start to require a minimal learning curve for those users who have experience using the popular quantum optics toolbox by Sze M. Tan. * Includes the ability to create high-quality plots, and animations, using the excellent `Matplotlib <https://matplotlib.org>`_ package. For detailed information about new features of each release of QuTiP, see the :ref:`changelog`. .. _plugin-qutip:. QuTiP Plugins; =============. Severa",MatchSource.DOCS,doc/frontmatter.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/frontmatter.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/frontmatter.rst:7481,Testability,test,test,7481,"with that of quantum structures and hamiltonians by providing easy to use analysis function and automation for the design of quantum chips. :scQubits: `scQubits <https://scqubits.readthedocs.io/en/latest/>`_ is a Python library which provides a convenient way to simulate superconducting qubits by providing an interface to QuTiP. :SimulaQron: `SimulaQron <https://softwarequtech.github.io/SimulaQron/html/index.html>`_ is a distributed simulation of the end nodes in a quantum internet with the specific goal to explore application development. :QInfer: `QInfer <http://qinfer.org/>`_ is a library for working with sequential Monte Carlo methods for parameter estimation in quantum information. :QPtomographer: `QPtomographer <https://qptomographer.readthedocs.io/en/latest/>`_ derive quantum error bars for quantum processes in terms of the diamond norm to a reference quantum channel. :QuNetSim: `QuNetSim <https://tqsd.github.io/QuNetSim/intro.html>`_ is a quantum networking simulation framework to develop and test protocols for quantum networks. :qupulse: `qupulse <https://qupulse.readthedocs.io/en/latest/>`_ is a toolkit to facilitate experiments involving pulse driven state manipulation of physical qubits. :Pulser: `Pulser <https://pulser.readthedocs.io/en/latest/>`_ is a framework for composing, simulating and executing pulse sequences for neutral-atom quantum devices. Contributing to QuTiP; =====================. We welcome anyone who is interested in helping us make QuTiP the best package for simulating quantum systems.; There are :ref:`detailed instructions on how to contribute code and documentation <development-contributing>` in the developers' section of this guide.; You can also help out our users by answering questions in the `QuTiP discussion mailing list <https://groups.google.com/g/qutip>`_, or by raising issues in `the main GitHub repository <https://github.com/qutip/qutip>`_ if you find any bugs.; Anyone who contributes code will be duly recognized.; Even sma",MatchSource.DOCS,doc/frontmatter.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/frontmatter.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/frontmatter.rst:162,Usability,guid,guide,162,".. _frontmatter:. *************; Frontmatter; *************. .. _about-docs:. About This Documentation; ==========================. This document contains a user guide and automatically generated API documentation for QuTiP. A PDF version of this text is available at the `documentation page <https://qutip.org/documentation.html>`_. **For more information see the** `QuTiP project web page`_. .. _QuTiP project web page: https://qutip.org/. :Author: J.R. Johansson. :Author: P.D. Nation. :Author: Alexander Pitchford. :Author: Arne Grimsmo. :Author: Chris Grenade. :Author: Nathan Shammah. :Author: Shahnawaz Ahmed. :Author: Neill Lambert. :Author: Eric Giguere. :Author: Boxi Li. :Author: Jake Lishman. :Author: Simon Cross. :Author: Asier Galicia. :Author: Paul Menczel. :Author: Patrick Hopf. :release: |release|. :copyright:; The text of this documentation is licensed under the Creative Commons Attribution 3.0 Unported License.; All contained code samples, and the source code of QuTiP, are licensed under the 3-clause BSD licence.; Full details of the copyright notices can be found on the `Copyright and Licensing <copyright>`_ page of this documentation. .. _citing-qutip:. Citing This Project; ==========================. If you find this project useful, then please cite:. .. centered:: J. R. Johansson, P.D. Nation, and F. Nori, ""QuTiP 2: A Python framework for the dynamics of open quantum systems"", Comp. Phys. Comm. **184**, 1234 (2013). or. .. centered:: J. R. Johansson, P.D. Nation, and F. Nori, ""QuTiP: An open-source Python framework for the dynamics of open quantum systems"", Comp. Phys. Comm. **183**, 1760 (2012). which may also be downloaded from https://arxiv.org/abs/1211.6518 or https://arxiv.org/abs/1110.0573, respectively. .. _funding-qutip:. Funding; =======; QuTiP is developed under the auspice of the non-profit organizations:. .. _image-numfocus:. .. figure:: figures/NumFocus_logo.png; :width: 3in; :figclass: align-center. .. _image-unitaryfund:. .. figure:: figu",MatchSource.DOCS,doc/frontmatter.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/frontmatter.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/frontmatter.rst:5248,Usability,learn,learning,5248,"oviding the following advantages:. * QuTiP relies entirely on open-source software. You are free to modify and use it as you wish with no licensing fees or limitations. * QuTiP is based on the Python scripting language, providing easy to read, fast code generation without the need to compile after modification. * The numerics underlying QuTiP are time-tested algorithms that run at C-code speeds, thanks to the `Numpy <https://numpy.org>`_, `Scipy <https://scipy.org>`_, and `Cython <https://cython.org>`_ libraries, and are based on many of the same algorithms used in propriety software. * QuTiP allows for solving the dynamics of Hamiltonians with (almost) arbitrary time-dependence, including collapse operators. * Time-dependent problems can be automatically compiled into C++-code at run-time for increased performance. * Takes advantage of the multiple processing cores found in essentially all modern computers. * QuTiP was designed from the start to require a minimal learning curve for those users who have experience using the popular quantum optics toolbox by Sze M. Tan. * Includes the ability to create high-quality plots, and animations, using the excellent `Matplotlib <https://matplotlib.org>`_ package. For detailed information about new features of each release of QuTiP, see the :ref:`changelog`. .. _plugin-qutip:. QuTiP Plugins; =============. Several libraries depend on QuTiP heavily making QuTiP a super-library. :Matsubara: `Matsubara <https://matsubara.readthedocs.io/en/latest/>`_ is a plugin to study the ultrastrong coupling regime with structured baths. :QNET: `QNET <https://qnet.readthedocs.io/en/latest/readme.html>`_ is a computer algebra package for quantum mechanics and photonic quantum networks. .. _libraries:. Libraries Using QuTiP; =====================. Several libraries rely on QuTiP for quantum physics or quantum information processing. Some of them are:. :Krotov: `Krotov <https://qucontrol.github.io/krotov/v1.2.0/01_overview.html>`_ focuses on the p",MatchSource.DOCS,doc/frontmatter.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/frontmatter.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/frontmatter.rst:8153,Usability,guid,guide,8153,"quantum chips. :scQubits: `scQubits <https://scqubits.readthedocs.io/en/latest/>`_ is a Python library which provides a convenient way to simulate superconducting qubits by providing an interface to QuTiP. :SimulaQron: `SimulaQron <https://softwarequtech.github.io/SimulaQron/html/index.html>`_ is a distributed simulation of the end nodes in a quantum internet with the specific goal to explore application development. :QInfer: `QInfer <http://qinfer.org/>`_ is a library for working with sequential Monte Carlo methods for parameter estimation in quantum information. :QPtomographer: `QPtomographer <https://qptomographer.readthedocs.io/en/latest/>`_ derive quantum error bars for quantum processes in terms of the diamond norm to a reference quantum channel. :QuNetSim: `QuNetSim <https://tqsd.github.io/QuNetSim/intro.html>`_ is a quantum networking simulation framework to develop and test protocols for quantum networks. :qupulse: `qupulse <https://qupulse.readthedocs.io/en/latest/>`_ is a toolkit to facilitate experiments involving pulse driven state manipulation of physical qubits. :Pulser: `Pulser <https://pulser.readthedocs.io/en/latest/>`_ is a framework for composing, simulating and executing pulse sequences for neutral-atom quantum devices. Contributing to QuTiP; =====================. We welcome anyone who is interested in helping us make QuTiP the best package for simulating quantum systems.; There are :ref:`detailed instructions on how to contribute code and documentation <development-contributing>` in the developers' section of this guide.; You can also help out our users by answering questions in the `QuTiP discussion mailing list <https://groups.google.com/g/qutip>`_, or by raising issues in `the main GitHub repository <https://github.com/qutip/qutip>`_ if you find any bugs.; Anyone who contributes code will be duly recognized.; Even small contributions are noted.; See :ref:`developers-contributors` for a list of people who have helped in one way or another.; ",MatchSource.DOCS,doc/frontmatter.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/frontmatter.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/index.rst:450,Deployability,install,installation,450,".. figure:: figures/logo.png; :align: center; :width: 7in. QuTiP: Quantum Toolbox in Python; ================================. This documentation contains a user guide and automatically generated API documentation for QuTiP.; For more information see the `QuTiP project web page <https://qutip.org/>`_.; Here, you can also find a collection of `tutorials for QuTiP <https://qutip.org/qutip-tutorials/>`_. .. toctree::; :maxdepth: 3. frontmatter.rst; installation.rst; guide/guide.rst; gallery/build/index.rst; apidoc/apidoc.rst. changelog.rst; contributors.rst; development/development.rst; biblio.rst; copyright.rst. Indices and tables; ====================. * :ref:`genindex`; * :ref:`modindex`; * :ref:`search`; ",MatchSource.DOCS,doc/index.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/index.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/index.rst:20,Testability,log,logo,20,".. figure:: figures/logo.png; :align: center; :width: 7in. QuTiP: Quantum Toolbox in Python; ================================. This documentation contains a user guide and automatically generated API documentation for QuTiP.; For more information see the `QuTiP project web page <https://qutip.org/>`_.; Here, you can also find a collection of `tutorials for QuTiP <https://qutip.org/qutip-tutorials/>`_. .. toctree::; :maxdepth: 3. frontmatter.rst; installation.rst; guide/guide.rst; gallery/build/index.rst; apidoc/apidoc.rst. changelog.rst; contributors.rst; development/development.rst; biblio.rst; copyright.rst. Indices and tables; ====================. * :ref:`genindex`; * :ref:`modindex`; * :ref:`search`; ",MatchSource.DOCS,doc/index.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/index.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/index.rst:162,Usability,guid,guide,162,".. figure:: figures/logo.png; :align: center; :width: 7in. QuTiP: Quantum Toolbox in Python; ================================. This documentation contains a user guide and automatically generated API documentation for QuTiP.; For more information see the `QuTiP project web page <https://qutip.org/>`_.; Here, you can also find a collection of `tutorials for QuTiP <https://qutip.org/qutip-tutorials/>`_. .. toctree::; :maxdepth: 3. frontmatter.rst; installation.rst; guide/guide.rst; gallery/build/index.rst; apidoc/apidoc.rst. changelog.rst; contributors.rst; development/development.rst; biblio.rst; copyright.rst. Indices and tables; ====================. * :ref:`genindex`; * :ref:`modindex`; * :ref:`search`; ",MatchSource.DOCS,doc/index.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/index.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/index.rst:468,Usability,guid,guide,468,".. figure:: figures/logo.png; :align: center; :width: 7in. QuTiP: Quantum Toolbox in Python; ================================. This documentation contains a user guide and automatically generated API documentation for QuTiP.; For more information see the `QuTiP project web page <https://qutip.org/>`_.; Here, you can also find a collection of `tutorials for QuTiP <https://qutip.org/qutip-tutorials/>`_. .. toctree::; :maxdepth: 3. frontmatter.rst; installation.rst; guide/guide.rst; gallery/build/index.rst; apidoc/apidoc.rst. changelog.rst; contributors.rst; development/development.rst; biblio.rst; copyright.rst. Indices and tables; ====================. * :ref:`genindex`; * :ref:`modindex`; * :ref:`search`; ",MatchSource.DOCS,doc/index.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/index.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/index.rst:474,Usability,guid,guide,474,".. figure:: figures/logo.png; :align: center; :width: 7in. QuTiP: Quantum Toolbox in Python; ================================. This documentation contains a user guide and automatically generated API documentation for QuTiP.; For more information see the `QuTiP project web page <https://qutip.org/>`_.; Here, you can also find a collection of `tutorials for QuTiP <https://qutip.org/qutip-tutorials/>`_. .. toctree::; :maxdepth: 3. frontmatter.rst; installation.rst; guide/guide.rst; gallery/build/index.rst; apidoc/apidoc.rst. changelog.rst; contributors.rst; development/development.rst; biblio.rst; copyright.rst. Indices and tables; ====================. * :ref:`genindex`; * :ref:`modindex`; * :ref:`search`; ",MatchSource.DOCS,doc/index.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/index.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:4420,Availability,avail,available,4420," bars back-end. |; +--------------------------+--------------+-----------------------------------------------------+. In addition, there are several additional packages that are not dependencies, but may give you a better programming experience.; `IPython <https://ipython.org/>`_ provides an improved text-based Python interpreter that is far more full-featured that the default interpreter, and runs in a terminal.; If you prefer a more graphical set-up, `Jupyter <https://jupyter.org/>`_ provides a notebook-style interface to mix code and mathematical notes together.; Alternatively, `Spyder <https://www.spyder-ide.org/>`_ is a free integrated development environment for Python, with several nice features for debugging code.; QuTiP will detect if it is being used within one of these richer environments, and various outputs will have enhanced formatting. .. _install-with-conda:. Installing with conda; =====================. If you already have your conda environment set up, and have the ``conda-forge`` channel available, then you can install QuTiP using:. .. code-block:: bash. conda install qutip. This will install the minimum set of dependences, but none of the optional packages. .. _adding-conda-forge:. Adding the conda-forge channel; ------------------------------. To install QuTiP from conda, you will need to add the conda-forge channel.; The following command adds this channel with lowest priority, so conda will still try and install all other packages normally:. .. code-block:: bash. conda config --append channels conda-forge. If you want to change the order of your channels later, you can edit your ``.condarc`` (user home folder) file manually, but it is recommended to keep ``defaults`` as the highest priority. .. _building-conda-environment:. New conda environments; ----------------------. The default Anaconda environment has all the Python packages needed for running QuTiP installed already, so you will only need to add the ``conda-forge`` channel and then inst",MatchSource.DOCS,doc/installation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:6150,Availability,avail,available,6150,". New conda environments; ----------------------. The default Anaconda environment has all the Python packages needed for running QuTiP installed already, so you will only need to add the ``conda-forge`` channel and then install the package.; If you have only installed Miniconda, or you want a completely clean virtual environment to install QuTiP in, the ``conda`` package manager provides a convenient way to do this. To create a conda environment for QuTiP called ``qutip-env``:. .. code-block:: bash. conda create -n qutip-env python qutip. This will automatically install all the necessary packages, and none of the optional packages.; You activate the new environment by running. .. code-block:: bash. conda activate qutip-env. You can also install any more optional packages you want with ``conda install``, for example ``matplotlib``, ``ipython`` or ``jupyter``. .. _install-from-source:. Installing from Source; ======================. Official releases of QuTiP are available from the download section on `the project's web pages <https://qutip.org/download.html>`_, and the latest source code is available in `our GitHub repository <https://github.com/qutip/qutip>`_.; In general we recommend users to use the latest stable release of QuTiP, but if you are interested in helping us out with development or wish to submit bug fixes, then use the latest development version from the GitHub repository. You can install from source by using the `Python-recommended PEP 517 procedure <build-pep517_>`_, or if you want more control or to have a development version, you can use the `low-level build procedure with setuptools <build-setuptools_>`_. .. _build-pep517:. PEP 517 Source Builds; ---------------------. The easiest way to build QuTiP from source is to use a PEP-517-compatible builder such as the ``build`` package available on ``pip``.; These will automatically install all build dependencies for you, and the ``pip`` installation step afterwards will install the minimum runtime depe",MatchSource.DOCS,doc/installation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:6169,Availability,down,download,6169,". New conda environments; ----------------------. The default Anaconda environment has all the Python packages needed for running QuTiP installed already, so you will only need to add the ``conda-forge`` channel and then install the package.; If you have only installed Miniconda, or you want a completely clean virtual environment to install QuTiP in, the ``conda`` package manager provides a convenient way to do this. To create a conda environment for QuTiP called ``qutip-env``:. .. code-block:: bash. conda create -n qutip-env python qutip. This will automatically install all the necessary packages, and none of the optional packages.; You activate the new environment by running. .. code-block:: bash. conda activate qutip-env. You can also install any more optional packages you want with ``conda install``, for example ``matplotlib``, ``ipython`` or ``jupyter``. .. _install-from-source:. Installing from Source; ======================. Official releases of QuTiP are available from the download section on `the project's web pages <https://qutip.org/download.html>`_, and the latest source code is available in `our GitHub repository <https://github.com/qutip/qutip>`_.; In general we recommend users to use the latest stable release of QuTiP, but if you are interested in helping us out with development or wish to submit bug fixes, then use the latest development version from the GitHub repository. You can install from source by using the `Python-recommended PEP 517 procedure <build-pep517_>`_, or if you want more control or to have a development version, you can use the `low-level build procedure with setuptools <build-setuptools_>`_. .. _build-pep517:. PEP 517 Source Builds; ---------------------. The easiest way to build QuTiP from source is to use a PEP-517-compatible builder such as the ``build`` package available on ``pip``.; These will automatically install all build dependencies for you, and the ``pip`` installation step afterwards will install the minimum runtime depe",MatchSource.DOCS,doc/installation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:6233,Availability,down,download,6233,"Anaconda environment has all the Python packages needed for running QuTiP installed already, so you will only need to add the ``conda-forge`` channel and then install the package.; If you have only installed Miniconda, or you want a completely clean virtual environment to install QuTiP in, the ``conda`` package manager provides a convenient way to do this. To create a conda environment for QuTiP called ``qutip-env``:. .. code-block:: bash. conda create -n qutip-env python qutip. This will automatically install all the necessary packages, and none of the optional packages.; You activate the new environment by running. .. code-block:: bash. conda activate qutip-env. You can also install any more optional packages you want with ``conda install``, for example ``matplotlib``, ``ipython`` or ``jupyter``. .. _install-from-source:. Installing from Source; ======================. Official releases of QuTiP are available from the download section on `the project's web pages <https://qutip.org/download.html>`_, and the latest source code is available in `our GitHub repository <https://github.com/qutip/qutip>`_.; In general we recommend users to use the latest stable release of QuTiP, but if you are interested in helping us out with development or wish to submit bug fixes, then use the latest development version from the GitHub repository. You can install from source by using the `Python-recommended PEP 517 procedure <build-pep517_>`_, or if you want more control or to have a development version, you can use the `low-level build procedure with setuptools <build-setuptools_>`_. .. _build-pep517:. PEP 517 Source Builds; ---------------------. The easiest way to build QuTiP from source is to use a PEP-517-compatible builder such as the ``build`` package available on ``pip``.; These will automatically install all build dependencies for you, and the ``pip`` installation step afterwards will install the minimum runtime dependencies.; You can do this by doing (for example). .. code-blo",MatchSource.DOCS,doc/installation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:6281,Availability,avail,available,6281,"ded for running QuTiP installed already, so you will only need to add the ``conda-forge`` channel and then install the package.; If you have only installed Miniconda, or you want a completely clean virtual environment to install QuTiP in, the ``conda`` package manager provides a convenient way to do this. To create a conda environment for QuTiP called ``qutip-env``:. .. code-block:: bash. conda create -n qutip-env python qutip. This will automatically install all the necessary packages, and none of the optional packages.; You activate the new environment by running. .. code-block:: bash. conda activate qutip-env. You can also install any more optional packages you want with ``conda install``, for example ``matplotlib``, ``ipython`` or ``jupyter``. .. _install-from-source:. Installing from Source; ======================. Official releases of QuTiP are available from the download section on `the project's web pages <https://qutip.org/download.html>`_, and the latest source code is available in `our GitHub repository <https://github.com/qutip/qutip>`_.; In general we recommend users to use the latest stable release of QuTiP, but if you are interested in helping us out with development or wish to submit bug fixes, then use the latest development version from the GitHub repository. You can install from source by using the `Python-recommended PEP 517 procedure <build-pep517_>`_, or if you want more control or to have a development version, you can use the `low-level build procedure with setuptools <build-setuptools_>`_. .. _build-pep517:. PEP 517 Source Builds; ---------------------. The easiest way to build QuTiP from source is to use a PEP-517-compatible builder such as the ``build`` package available on ``pip``.; These will automatically install all build dependencies for you, and the ``pip`` installation step afterwards will install the minimum runtime dependencies.; You can do this by doing (for example). .. code-block:: bash. pip install build; python -m build <path ",MatchSource.DOCS,doc/installation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:7004,Availability,avail,available,7004,"u want with ``conda install``, for example ``matplotlib``, ``ipython`` or ``jupyter``. .. _install-from-source:. Installing from Source; ======================. Official releases of QuTiP are available from the download section on `the project's web pages <https://qutip.org/download.html>`_, and the latest source code is available in `our GitHub repository <https://github.com/qutip/qutip>`_.; In general we recommend users to use the latest stable release of QuTiP, but if you are interested in helping us out with development or wish to submit bug fixes, then use the latest development version from the GitHub repository. You can install from source by using the `Python-recommended PEP 517 procedure <build-pep517_>`_, or if you want more control or to have a development version, you can use the `low-level build procedure with setuptools <build-setuptools_>`_. .. _build-pep517:. PEP 517 Source Builds; ---------------------. The easiest way to build QuTiP from source is to use a PEP-517-compatible builder such as the ``build`` package available on ``pip``.; These will automatically install all build dependencies for you, and the ``pip`` installation step afterwards will install the minimum runtime dependencies.; You can do this by doing (for example). .. code-block:: bash. pip install build; python -m build <path to qutip>; pip install <path to qutip>/dist/qutip-<version>.whl. The first command installs the reference PEP-517 build tool, the second effects the build and the third uses ``pip`` to install the built package.; You will need to replace ``<path to qutip>`` with the actual path to the QuTiP source code.; The string ``<version>`` will depend on the version of QuTiP, the version of Python and your operating system.; It will look something like ``4.6.0-cp39-cp39-manylinux1_x86_64``, but there should only be one ``.whl`` file in the ``dist/`` directory, which will be the correct one. .. _build-setuptools:. Direct Setuptools Source Builds; ---------------------------",MatchSource.DOCS,doc/installation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:8061,Availability,error,error-prone,8061,"ically install all build dependencies for you, and the ``pip`` installation step afterwards will install the minimum runtime dependencies.; You can do this by doing (for example). .. code-block:: bash. pip install build; python -m build <path to qutip>; pip install <path to qutip>/dist/qutip-<version>.whl. The first command installs the reference PEP-517 build tool, the second effects the build and the third uses ``pip`` to install the built package.; You will need to replace ``<path to qutip>`` with the actual path to the QuTiP source code.; The string ``<version>`` will depend on the version of QuTiP, the version of Python and your operating system.; It will look something like ``4.6.0-cp39-cp39-manylinux1_x86_64``, but there should only be one ``.whl`` file in the ``dist/`` directory, which will be the correct one. .. _build-setuptools:. Direct Setuptools Source Builds; -------------------------------. This is the method to have the greatest amount of control over the installation, but it the most error-prone and not recommended unless you know what you are doing.; You first need to have all the runtime dependencies installed.; The most up-to-date requirements will be listed in ``pyproject.toml`` file, in the ``build-system.requires`` key.; As of the 5.0.0 release, the build requirements can be installed with. .. code-block:: bash. pip install setuptools wheel packaging cython 'numpy<2.0.0' scipy. or similar with ``conda`` if you prefer.; You will also need to have a functional C++ compiler installed on your system.; This is likely already done for you if you are on Linux or macOS, but see the `section on Windows installations <install-on-windows_>`_ if that is your operating system. To install QuTiP from the source code run:. .. code-block:: bash. pip install . If you wish to contribute to the QuTiP project, then you will want to create your own fork of `the QuTiP git repository <https://github.com/qutip/qutip>`_, clone this to a local folder, and install it into",MatchSource.DOCS,doc/installation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:9297,Availability,avail,available,9297,".toml`` file, in the ``build-system.requires`` key.; As of the 5.0.0 release, the build requirements can be installed with. .. code-block:: bash. pip install setuptools wheel packaging cython 'numpy<2.0.0' scipy. or similar with ``conda`` if you prefer.; You will also need to have a functional C++ compiler installed on your system.; This is likely already done for you if you are on Linux or macOS, but see the `section on Windows installations <install-on-windows_>`_ if that is your operating system. To install QuTiP from the source code run:. .. code-block:: bash. pip install . If you wish to contribute to the QuTiP project, then you will want to create your own fork of `the QuTiP git repository <https://github.com/qutip/qutip>`_, clone this to a local folder, and install it into your Python environment using:. .. code-block:: bash. python setup.py develop. When you do ``import qutip`` in this environment, you will then load the code from your local fork, enabling you to edit the Python files and have the changes immediately available when you restart your Python interpreter, without needing to rebuild the package.; Note that if you change any Cython files, you will need to rerun the build command. You should not need to use ``sudo`` (or other superuser privileges) to install into a personal virtual environment; if it feels like you need it, there is a good chance that you are installing into the system Python environment instead. .. _install-on-windows:. Installation on Windows; =======================. As with other operating systems, the easiest method is to use ``pip install qutip``, or use the ``conda`` procedure described above.; If you want to build from source or use runtime compilation with Cython, you will need to have a working C++ compiler. You can `download the Visual Studio IDE from Microsoft <https://visualstudio.microsoft.com/downloads/>`_, which has a free Community edition containing a sufficient C++ compiler.; This is the recommended compiler toolc",MatchSource.DOCS,doc/installation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:10048,Availability,down,download,10048,". .. code-block:: bash. python setup.py develop. When you do ``import qutip`` in this environment, you will then load the code from your local fork, enabling you to edit the Python files and have the changes immediately available when you restart your Python interpreter, without needing to rebuild the package.; Note that if you change any Cython files, you will need to rerun the build command. You should not need to use ``sudo`` (or other superuser privileges) to install into a personal virtual environment; if it feels like you need it, there is a good chance that you are installing into the system Python environment instead. .. _install-on-windows:. Installation on Windows; =======================. As with other operating systems, the easiest method is to use ``pip install qutip``, or use the ``conda`` procedure described above.; If you want to build from source or use runtime compilation with Cython, you will need to have a working C++ compiler. You can `download the Visual Studio IDE from Microsoft <https://visualstudio.microsoft.com/downloads/>`_, which has a free Community edition containing a sufficient C++ compiler.; This is the recommended compiler toolchain on Windows.; When installing, be sure to select the following components:. - Windows ""X"" SDK (where ""X"" stands for your version: 7/8/8.1/10); - Visual Studio C++ build tools. You can then follow the `installation from source <install-from-source_>`_ section as normal. .. important::. In order to prevent issues with the ``PATH`` environment variable not containing the compiler and associated libraries, it is recommended to use the developer command prompt in the Visual Studio installation folder instead of the built-in command prompt. The Community edition of Visual Studio takes around 10GB of disk space.; If this is prohibitive for you, it is also possible to install `only the build tools and necessary SDKs <https://visualstudio.microsoft.com/visual-cpp-build-tools/>`_ instead, which should save about 2G",MatchSource.DOCS,doc/installation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:10130,Availability,down,downloads,10130,"ent, you will then load the code from your local fork, enabling you to edit the Python files and have the changes immediately available when you restart your Python interpreter, without needing to rebuild the package.; Note that if you change any Cython files, you will need to rerun the build command. You should not need to use ``sudo`` (or other superuser privileges) to install into a personal virtual environment; if it feels like you need it, there is a good chance that you are installing into the system Python environment instead. .. _install-on-windows:. Installation on Windows; =======================. As with other operating systems, the easiest method is to use ``pip install qutip``, or use the ``conda`` procedure described above.; If you want to build from source or use runtime compilation with Cython, you will need to have a working C++ compiler. You can `download the Visual Studio IDE from Microsoft <https://visualstudio.microsoft.com/downloads/>`_, which has a free Community edition containing a sufficient C++ compiler.; This is the recommended compiler toolchain on Windows.; When installing, be sure to select the following components:. - Windows ""X"" SDK (where ""X"" stands for your version: 7/8/8.1/10); - Visual Studio C++ build tools. You can then follow the `installation from source <install-from-source_>`_ section as normal. .. important::. In order to prevent issues with the ``PATH`` environment variable not containing the compiler and associated libraries, it is recommended to use the developer command prompt in the Visual Studio installation folder instead of the built-in command prompt. The Community edition of Visual Studio takes around 10GB of disk space.; If this is prohibitive for you, it is also possible to install `only the build tools and necessary SDKs <https://visualstudio.microsoft.com/visual-cpp-build-tools/>`_ instead, which should save about 2GB of space. .. _install-verify:. Verifying the Installation; ==========================. QuTiP ",MatchSource.DOCS,doc/installation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:11836,Availability,failure,failures,11836,"nt::. In order to prevent issues with the ``PATH`` environment variable not containing the compiler and associated libraries, it is recommended to use the developer command prompt in the Visual Studio installation folder instead of the built-in command prompt. The Community edition of Visual Studio takes around 10GB of disk space.; If this is prohibitive for you, it is also possible to install `only the build tools and necessary SDKs <https://visualstudio.microsoft.com/visual-cpp-build-tools/>`_ instead, which should save about 2GB of space. .. _install-verify:. Verifying the Installation; ==========================. QuTiP includes a collection of built-in test scripts to verify that an installation was successful.; To run the suite of tests scripts you must also have the ``pytest`` testing library.; After installing QuTiP, leave the installation directory and call:. .. code-block:: bash. pytest qutip/qutip/tests. This will take between 10 and 30 minutes, depending on your computer.; At the end, the testing report should report a success; it is normal for some tests to be skipped, and for some to be marked ""xfail"" in yellow.; Skips may be tests that do not run on your operating system, or tests of optional components that you have not installed the dependencies for.; If any failures or errors occur, please check that you have installed all of the required modules.; See the next section on how to check the installed versions of the QuTiP dependencies.; If these tests still fail, then head on over to the `QuTiP Discussion Board <https://groups.google.com/g/qutip>`_ or `the GitHub issues page <https://github.com/qutip/qutip/issues>`_ and post a message detailing your particular issue. .. _install-about:. Checking Version Information; ============================. QuTiP includes an ""about"" function for viewing information about QuTiP and the important dependencies installed on your system.; To view this information:. .. code-block:: python. import qutip; qutip.about(); ",MatchSource.DOCS,doc/installation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:11848,Availability,error,errors,11848,"nt::. In order to prevent issues with the ``PATH`` environment variable not containing the compiler and associated libraries, it is recommended to use the developer command prompt in the Visual Studio installation folder instead of the built-in command prompt. The Community edition of Visual Studio takes around 10GB of disk space.; If this is prohibitive for you, it is also possible to install `only the build tools and necessary SDKs <https://visualstudio.microsoft.com/visual-cpp-build-tools/>`_ instead, which should save about 2GB of space. .. _install-verify:. Verifying the Installation; ==========================. QuTiP includes a collection of built-in test scripts to verify that an installation was successful.; To run the suite of tests scripts you must also have the ``pytest`` testing library.; After installing QuTiP, leave the installation directory and call:. .. code-block:: bash. pytest qutip/qutip/tests. This will take between 10 and 30 minutes, depending on your computer.; At the end, the testing report should report a success; it is normal for some tests to be skipped, and for some to be marked ""xfail"" in yellow.; Skips may be tests that do not run on your operating system, or tests of optional components that you have not installed the dependencies for.; If any failures or errors occur, please check that you have installed all of the required modules.; See the next section on how to check the installed versions of the QuTiP dependencies.; If these tests still fail, then head on over to the `QuTiP Discussion Board <https://groups.google.com/g/qutip>`_ or `the GitHub issues page <https://github.com/qutip/qutip/issues>`_ and post a message detailing your particular issue. .. _install-about:. Checking Version Information; ============================. QuTiP includes an ""about"" function for viewing information about QuTiP and the important dependencies installed on your system.; To view this information:. .. code-block:: python. import qutip; qutip.about(); ",MatchSource.DOCS,doc/installation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:320,Deployability,install,install,320,".. This file can be edited using retext 6.1 https://github.com/retext-project/retext. .. _install:. **************; Installation; **************. .. _quick-start:. Quick Start; ===========. From QuTiP version 4.6 onwards, you should be able to get a working version of QuTiP with the standard. .. code-block:: bash. pip install qutip. It is not recommended to install any packages directly into the system Python environment; consider using ``pip`` or ``conda`` virtual environments to keep your operating system space clean, and to have more control over Python and other package versions. You do not need to worry about the details on the rest of this page unless this command did not work, but do also read the next section for the list of optional dependencies.; The rest of this page covers `installation directly from conda <install-with-conda_>`_, `installation from source <install-from-source_>`_, and `additional considerations when working on Windows <install-on-windows_>`_. .. _install-requires:. General Requirements; =====================. QuTiP depends on several open-source libraries for scientific computing in the Python programming language.; The following packages are currently required:. .. cssclass:: table-striped. +----------------+--------------+-----------------------------------------------------+; | Package | Version | Details |; +================+==============+=====================================================+; | **Python** | 3.9+ | 3.6+ for version 4.7 |; +----------------+--------------+-----------------------------------------------------+; | **NumPy** | 1.22+ <2.0 | 1.16+ for version 4.7 |; +----------------+--------------+-----------------------------------------------------+; | **SciPy** | 1.8+ | 1.0+ for version 4.7 |; +----------------+--------------+-----------------------------------------------------+. In addition, there are several optional packages that provide additional functionality:. .. cssclass:: table-striped. +--------------------",MatchSource.DOCS,doc/installation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:360,Deployability,install,install,360,".. This file can be edited using retext 6.1 https://github.com/retext-project/retext. .. _install:. **************; Installation; **************. .. _quick-start:. Quick Start; ===========. From QuTiP version 4.6 onwards, you should be able to get a working version of QuTiP with the standard. .. code-block:: bash. pip install qutip. It is not recommended to install any packages directly into the system Python environment; consider using ``pip`` or ``conda`` virtual environments to keep your operating system space clean, and to have more control over Python and other package versions. You do not need to worry about the details on the rest of this page unless this command did not work, but do also read the next section for the list of optional dependencies.; The rest of this page covers `installation directly from conda <install-with-conda_>`_, `installation from source <install-from-source_>`_, and `additional considerations when working on Windows <install-on-windows_>`_. .. _install-requires:. General Requirements; =====================. QuTiP depends on several open-source libraries for scientific computing in the Python programming language.; The following packages are currently required:. .. cssclass:: table-striped. +----------------+--------------+-----------------------------------------------------+; | Package | Version | Details |; +================+==============+=====================================================+; | **Python** | 3.9+ | 3.6+ for version 4.7 |; +----------------+--------------+-----------------------------------------------------+; | **NumPy** | 1.22+ <2.0 | 1.16+ for version 4.7 |; +----------------+--------------+-----------------------------------------------------+; | **SciPy** | 1.8+ | 1.0+ for version 4.7 |; +----------------+--------------+-----------------------------------------------------+. In addition, there are several optional packages that provide additional functionality:. .. cssclass:: table-striped. +--------------------",MatchSource.DOCS,doc/installation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:797,Deployability,install,installation,797,".. This file can be edited using retext 6.1 https://github.com/retext-project/retext. .. _install:. **************; Installation; **************. .. _quick-start:. Quick Start; ===========. From QuTiP version 4.6 onwards, you should be able to get a working version of QuTiP with the standard. .. code-block:: bash. pip install qutip. It is not recommended to install any packages directly into the system Python environment; consider using ``pip`` or ``conda`` virtual environments to keep your operating system space clean, and to have more control over Python and other package versions. You do not need to worry about the details on the rest of this page unless this command did not work, but do also read the next section for the list of optional dependencies.; The rest of this page covers `installation directly from conda <install-with-conda_>`_, `installation from source <install-from-source_>`_, and `additional considerations when working on Windows <install-on-windows_>`_. .. _install-requires:. General Requirements; =====================. QuTiP depends on several open-source libraries for scientific computing in the Python programming language.; The following packages are currently required:. .. cssclass:: table-striped. +----------------+--------------+-----------------------------------------------------+; | Package | Version | Details |; +================+==============+=====================================================+; | **Python** | 3.9+ | 3.6+ for version 4.7 |; +----------------+--------------+-----------------------------------------------------+; | **NumPy** | 1.22+ <2.0 | 1.16+ for version 4.7 |; +----------------+--------------+-----------------------------------------------------+; | **SciPy** | 1.8+ | 1.0+ for version 4.7 |; +----------------+--------------+-----------------------------------------------------+. In addition, there are several optional packages that provide additional functionality:. .. cssclass:: table-striped. +--------------------",MatchSource.DOCS,doc/installation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:831,Deployability,install,install-with-,831,".. This file can be edited using retext 6.1 https://github.com/retext-project/retext. .. _install:. **************; Installation; **************. .. _quick-start:. Quick Start; ===========. From QuTiP version 4.6 onwards, you should be able to get a working version of QuTiP with the standard. .. code-block:: bash. pip install qutip. It is not recommended to install any packages directly into the system Python environment; consider using ``pip`` or ``conda`` virtual environments to keep your operating system space clean, and to have more control over Python and other package versions. You do not need to worry about the details on the rest of this page unless this command did not work, but do also read the next section for the list of optional dependencies.; The rest of this page covers `installation directly from conda <install-with-conda_>`_, `installation from source <install-from-source_>`_, and `additional considerations when working on Windows <install-on-windows_>`_. .. _install-requires:. General Requirements; =====================. QuTiP depends on several open-source libraries for scientific computing in the Python programming language.; The following packages are currently required:. .. cssclass:: table-striped. +----------------+--------------+-----------------------------------------------------+; | Package | Version | Details |; +================+==============+=====================================================+; | **Python** | 3.9+ | 3.6+ for version 4.7 |; +----------------+--------------+-----------------------------------------------------+; | **NumPy** | 1.22+ <2.0 | 1.16+ for version 4.7 |; +----------------+--------------+-----------------------------------------------------+; | **SciPy** | 1.8+ | 1.0+ for version 4.7 |; +----------------+--------------+-----------------------------------------------------+. In addition, there are several optional packages that provide additional functionality:. .. cssclass:: table-striped. +--------------------",MatchSource.DOCS,doc/installation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:856,Deployability,install,installation,856,".. This file can be edited using retext 6.1 https://github.com/retext-project/retext. .. _install:. **************; Installation; **************. .. _quick-start:. Quick Start; ===========. From QuTiP version 4.6 onwards, you should be able to get a working version of QuTiP with the standard. .. code-block:: bash. pip install qutip. It is not recommended to install any packages directly into the system Python environment; consider using ``pip`` or ``conda`` virtual environments to keep your operating system space clean, and to have more control over Python and other package versions. You do not need to worry about the details on the rest of this page unless this command did not work, but do also read the next section for the list of optional dependencies.; The rest of this page covers `installation directly from conda <install-with-conda_>`_, `installation from source <install-from-source_>`_, and `additional considerations when working on Windows <install-on-windows_>`_. .. _install-requires:. General Requirements; =====================. QuTiP depends on several open-source libraries for scientific computing in the Python programming language.; The following packages are currently required:. .. cssclass:: table-striped. +----------------+--------------+-----------------------------------------------------+; | Package | Version | Details |; +================+==============+=====================================================+; | **Python** | 3.9+ | 3.6+ for version 4.7 |; +----------------+--------------+-----------------------------------------------------+; | **NumPy** | 1.22+ <2.0 | 1.16+ for version 4.7 |; +----------------+--------------+-----------------------------------------------------+; | **SciPy** | 1.8+ | 1.0+ for version 4.7 |; +----------------+--------------+-----------------------------------------------------+. In addition, there are several optional packages that provide additional functionality:. .. cssclass:: table-striped. +--------------------",MatchSource.DOCS,doc/installation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:882,Deployability,install,install-from-,882,".. This file can be edited using retext 6.1 https://github.com/retext-project/retext. .. _install:. **************; Installation; **************. .. _quick-start:. Quick Start; ===========. From QuTiP version 4.6 onwards, you should be able to get a working version of QuTiP with the standard. .. code-block:: bash. pip install qutip. It is not recommended to install any packages directly into the system Python environment; consider using ``pip`` or ``conda`` virtual environments to keep your operating system space clean, and to have more control over Python and other package versions. You do not need to worry about the details on the rest of this page unless this command did not work, but do also read the next section for the list of optional dependencies.; The rest of this page covers `installation directly from conda <install-with-conda_>`_, `installation from source <install-from-source_>`_, and `additional considerations when working on Windows <install-on-windows_>`_. .. _install-requires:. General Requirements; =====================. QuTiP depends on several open-source libraries for scientific computing in the Python programming language.; The following packages are currently required:. .. cssclass:: table-striped. +----------------+--------------+-----------------------------------------------------+; | Package | Version | Details |; +================+==============+=====================================================+; | **Python** | 3.9+ | 3.6+ for version 4.7 |; +----------------+--------------+-----------------------------------------------------+; | **NumPy** | 1.22+ <2.0 | 1.16+ for version 4.7 |; +----------------+--------------+-----------------------------------------------------+; | **SciPy** | 1.8+ | 1.0+ for version 4.7 |; +----------------+--------------+-----------------------------------------------------+. In addition, there are several optional packages that provide additional functionality:. .. cssclass:: table-striped. +--------------------",MatchSource.DOCS,doc/installation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:963,Deployability,install,install-on-,963,".. This file can be edited using retext 6.1 https://github.com/retext-project/retext. .. _install:. **************; Installation; **************. .. _quick-start:. Quick Start; ===========. From QuTiP version 4.6 onwards, you should be able to get a working version of QuTiP with the standard. .. code-block:: bash. pip install qutip. It is not recommended to install any packages directly into the system Python environment; consider using ``pip`` or ``conda`` virtual environments to keep your operating system space clean, and to have more control over Python and other package versions. You do not need to worry about the details on the rest of this page unless this command did not work, but do also read the next section for the list of optional dependencies.; The rest of this page covers `installation directly from conda <install-with-conda_>`_, `installation from source <install-from-source_>`_, and `additional considerations when working on Windows <install-on-windows_>`_. .. _install-requires:. General Requirements; =====================. QuTiP depends on several open-source libraries for scientific computing in the Python programming language.; The following packages are currently required:. .. cssclass:: table-striped. +----------------+--------------+-----------------------------------------------------+; | Package | Version | Details |; +================+==============+=====================================================+; | **Python** | 3.9+ | 3.6+ for version 4.7 |; +----------------+--------------+-----------------------------------------------------+; | **NumPy** | 1.22+ <2.0 | 1.16+ for version 4.7 |; +----------------+--------------+-----------------------------------------------------+; | **SciPy** | 1.8+ | 1.0+ for version 4.7 |; +----------------+--------------+-----------------------------------------------------+. In addition, there are several optional packages that provide additional functionality:. .. cssclass:: table-striped. +--------------------",MatchSource.DOCS,doc/installation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:4036,Deployability,integrat,integrated,4036," nice circuit drawings in IPython. |; +--------------------------+--------------+-----------------------------------------------------+; | ``loky``, ``mpi4py`` | | Extra parallel map back-ends. |; +--------------------------+--------------+-----------------------------------------------------+; | ``tqdm`` | | Extra progress bars back-end. |; +--------------------------+--------------+-----------------------------------------------------+. In addition, there are several additional packages that are not dependencies, but may give you a better programming experience.; `IPython <https://ipython.org/>`_ provides an improved text-based Python interpreter that is far more full-featured that the default interpreter, and runs in a terminal.; If you prefer a more graphical set-up, `Jupyter <https://jupyter.org/>`_ provides a notebook-style interface to mix code and mathematical notes together.; Alternatively, `Spyder <https://www.spyder-ide.org/>`_ is a free integrated development environment for Python, with several nice features for debugging code.; QuTiP will detect if it is being used within one of these richer environments, and various outputs will have enhanced formatting. .. _install-with-conda:. Installing with conda; =====================. If you already have your conda environment set up, and have the ``conda-forge`` channel available, then you can install QuTiP using:. .. code-block:: bash. conda install qutip. This will install the minimum set of dependences, but none of the optional packages. .. _adding-conda-forge:. Adding the conda-forge channel; ------------------------------. To install QuTiP from conda, you will need to add the conda-forge channel.; The following command adds this channel with lowest priority, so conda will still try and install all other packages normally:. .. code-block:: bash. conda config --append channels conda-forge. If you want to change the order of your channels later, you can edit your ``.condarc`` (user home folder) file manually, ",MatchSource.DOCS,doc/installation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:4444,Deployability,install,install,4444," bars back-end. |; +--------------------------+--------------+-----------------------------------------------------+. In addition, there are several additional packages that are not dependencies, but may give you a better programming experience.; `IPython <https://ipython.org/>`_ provides an improved text-based Python interpreter that is far more full-featured that the default interpreter, and runs in a terminal.; If you prefer a more graphical set-up, `Jupyter <https://jupyter.org/>`_ provides a notebook-style interface to mix code and mathematical notes together.; Alternatively, `Spyder <https://www.spyder-ide.org/>`_ is a free integrated development environment for Python, with several nice features for debugging code.; QuTiP will detect if it is being used within one of these richer environments, and various outputs will have enhanced formatting. .. _install-with-conda:. Installing with conda; =====================. If you already have your conda environment set up, and have the ``conda-forge`` channel available, then you can install QuTiP using:. .. code-block:: bash. conda install qutip. This will install the minimum set of dependences, but none of the optional packages. .. _adding-conda-forge:. Adding the conda-forge channel; ------------------------------. To install QuTiP from conda, you will need to add the conda-forge channel.; The following command adds this channel with lowest priority, so conda will still try and install all other packages normally:. .. code-block:: bash. conda config --append channels conda-forge. If you want to change the order of your channels later, you can edit your ``.condarc`` (user home folder) file manually, but it is recommended to keep ``defaults`` as the highest priority. .. _building-conda-environment:. New conda environments; ----------------------. The default Anaconda environment has all the Python packages needed for running QuTiP installed already, so you will only need to add the ``conda-forge`` channel and then inst",MatchSource.DOCS,doc/installation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:4494,Deployability,install,install,4494,"----------------+. In addition, there are several additional packages that are not dependencies, but may give you a better programming experience.; `IPython <https://ipython.org/>`_ provides an improved text-based Python interpreter that is far more full-featured that the default interpreter, and runs in a terminal.; If you prefer a more graphical set-up, `Jupyter <https://jupyter.org/>`_ provides a notebook-style interface to mix code and mathematical notes together.; Alternatively, `Spyder <https://www.spyder-ide.org/>`_ is a free integrated development environment for Python, with several nice features for debugging code.; QuTiP will detect if it is being used within one of these richer environments, and various outputs will have enhanced formatting. .. _install-with-conda:. Installing with conda; =====================. If you already have your conda environment set up, and have the ``conda-forge`` channel available, then you can install QuTiP using:. .. code-block:: bash. conda install qutip. This will install the minimum set of dependences, but none of the optional packages. .. _adding-conda-forge:. Adding the conda-forge channel; ------------------------------. To install QuTiP from conda, you will need to add the conda-forge channel.; The following command adds this channel with lowest priority, so conda will still try and install all other packages normally:. .. code-block:: bash. conda config --append channels conda-forge. If you want to change the order of your channels later, you can edit your ``.condarc`` (user home folder) file manually, but it is recommended to keep ``defaults`` as the highest priority. .. _building-conda-environment:. New conda environments; ----------------------. The default Anaconda environment has all the Python packages needed for running QuTiP installed already, so you will only need to add the ``conda-forge`` channel and then install the package.; If you have only installed Miniconda, or you want a completely clean virtual envir",MatchSource.DOCS,doc/installation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:4519,Deployability,install,install,4519,"itional packages that are not dependencies, but may give you a better programming experience.; `IPython <https://ipython.org/>`_ provides an improved text-based Python interpreter that is far more full-featured that the default interpreter, and runs in a terminal.; If you prefer a more graphical set-up, `Jupyter <https://jupyter.org/>`_ provides a notebook-style interface to mix code and mathematical notes together.; Alternatively, `Spyder <https://www.spyder-ide.org/>`_ is a free integrated development environment for Python, with several nice features for debugging code.; QuTiP will detect if it is being used within one of these richer environments, and various outputs will have enhanced formatting. .. _install-with-conda:. Installing with conda; =====================. If you already have your conda environment set up, and have the ``conda-forge`` channel available, then you can install QuTiP using:. .. code-block:: bash. conda install qutip. This will install the minimum set of dependences, but none of the optional packages. .. _adding-conda-forge:. Adding the conda-forge channel; ------------------------------. To install QuTiP from conda, you will need to add the conda-forge channel.; The following command adds this channel with lowest priority, so conda will still try and install all other packages normally:. .. code-block:: bash. conda config --append channels conda-forge. If you want to change the order of your channels later, you can edit your ``.condarc`` (user home folder) file manually, but it is recommended to keep ``defaults`` as the highest priority. .. _building-conda-environment:. New conda environments; ----------------------. The default Anaconda environment has all the Python packages needed for running QuTiP installed already, so you will only need to add the ``conda-forge`` channel and then install the package.; If you have only installed Miniconda, or you want a completely clean virtual environment to install QuTiP in, the ``conda`` package man",MatchSource.DOCS,doc/installation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:4686,Deployability,install,install,4686,"nterpreter that is far more full-featured that the default interpreter, and runs in a terminal.; If you prefer a more graphical set-up, `Jupyter <https://jupyter.org/>`_ provides a notebook-style interface to mix code and mathematical notes together.; Alternatively, `Spyder <https://www.spyder-ide.org/>`_ is a free integrated development environment for Python, with several nice features for debugging code.; QuTiP will detect if it is being used within one of these richer environments, and various outputs will have enhanced formatting. .. _install-with-conda:. Installing with conda; =====================. If you already have your conda environment set up, and have the ``conda-forge`` channel available, then you can install QuTiP using:. .. code-block:: bash. conda install qutip. This will install the minimum set of dependences, but none of the optional packages. .. _adding-conda-forge:. Adding the conda-forge channel; ------------------------------. To install QuTiP from conda, you will need to add the conda-forge channel.; The following command adds this channel with lowest priority, so conda will still try and install all other packages normally:. .. code-block:: bash. conda config --append channels conda-forge. If you want to change the order of your channels later, you can edit your ``.condarc`` (user home folder) file manually, but it is recommended to keep ``defaults`` as the highest priority. .. _building-conda-environment:. New conda environments; ----------------------. The default Anaconda environment has all the Python packages needed for running QuTiP installed already, so you will only need to add the ``conda-forge`` channel and then install the package.; If you have only installed Miniconda, or you want a completely clean virtual environment to install QuTiP in, the ``conda`` package manager provides a convenient way to do this. To create a conda environment for QuTiP called ``qutip-env``:. .. code-block:: bash. conda create -n qutip-env python qutip. T",MatchSource.DOCS,doc/installation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:4849,Deployability,install,install,4849,"u prefer a more graphical set-up, `Jupyter <https://jupyter.org/>`_ provides a notebook-style interface to mix code and mathematical notes together.; Alternatively, `Spyder <https://www.spyder-ide.org/>`_ is a free integrated development environment for Python, with several nice features for debugging code.; QuTiP will detect if it is being used within one of these richer environments, and various outputs will have enhanced formatting. .. _install-with-conda:. Installing with conda; =====================. If you already have your conda environment set up, and have the ``conda-forge`` channel available, then you can install QuTiP using:. .. code-block:: bash. conda install qutip. This will install the minimum set of dependences, but none of the optional packages. .. _adding-conda-forge:. Adding the conda-forge channel; ------------------------------. To install QuTiP from conda, you will need to add the conda-forge channel.; The following command adds this channel with lowest priority, so conda will still try and install all other packages normally:. .. code-block:: bash. conda config --append channels conda-forge. If you want to change the order of your channels later, you can edit your ``.condarc`` (user home folder) file manually, but it is recommended to keep ``defaults`` as the highest priority. .. _building-conda-environment:. New conda environments; ----------------------. The default Anaconda environment has all the Python packages needed for running QuTiP installed already, so you will only need to add the ``conda-forge`` channel and then install the package.; If you have only installed Miniconda, or you want a completely clean virtual environment to install QuTiP in, the ``conda`` package manager provides a convenient way to do this. To create a conda environment for QuTiP called ``qutip-env``:. .. code-block:: bash. conda create -n qutip-env python qutip. This will automatically install all the necessary packages, and none of the optional packages.; You act",MatchSource.DOCS,doc/installation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:5309,Deployability,install,installed,5309,"============. If you already have your conda environment set up, and have the ``conda-forge`` channel available, then you can install QuTiP using:. .. code-block:: bash. conda install qutip. This will install the minimum set of dependences, but none of the optional packages. .. _adding-conda-forge:. Adding the conda-forge channel; ------------------------------. To install QuTiP from conda, you will need to add the conda-forge channel.; The following command adds this channel with lowest priority, so conda will still try and install all other packages normally:. .. code-block:: bash. conda config --append channels conda-forge. If you want to change the order of your channels later, you can edit your ``.condarc`` (user home folder) file manually, but it is recommended to keep ``defaults`` as the highest priority. .. _building-conda-environment:. New conda environments; ----------------------. The default Anaconda environment has all the Python packages needed for running QuTiP installed already, so you will only need to add the ``conda-forge`` channel and then install the package.; If you have only installed Miniconda, or you want a completely clean virtual environment to install QuTiP in, the ``conda`` package manager provides a convenient way to do this. To create a conda environment for QuTiP called ``qutip-env``:. .. code-block:: bash. conda create -n qutip-env python qutip. This will automatically install all the necessary packages, and none of the optional packages.; You activate the new environment by running. .. code-block:: bash. conda activate qutip-env. You can also install any more optional packages you want with ``conda install``, for example ``matplotlib``, ``ipython`` or ``jupyter``. .. _install-from-source:. Installing from Source; ======================. Official releases of QuTiP are available from the download section on `the project's web pages <https://qutip.org/download.html>`_, and the latest source code is available in `our GitHub repository <",MatchSource.DOCS,doc/installation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:5394,Deployability,install,install,5394,"============. If you already have your conda environment set up, and have the ``conda-forge`` channel available, then you can install QuTiP using:. .. code-block:: bash. conda install qutip. This will install the minimum set of dependences, but none of the optional packages. .. _adding-conda-forge:. Adding the conda-forge channel; ------------------------------. To install QuTiP from conda, you will need to add the conda-forge channel.; The following command adds this channel with lowest priority, so conda will still try and install all other packages normally:. .. code-block:: bash. conda config --append channels conda-forge. If you want to change the order of your channels later, you can edit your ``.condarc`` (user home folder) file manually, but it is recommended to keep ``defaults`` as the highest priority. .. _building-conda-environment:. New conda environments; ----------------------. The default Anaconda environment has all the Python packages needed for running QuTiP installed already, so you will only need to add the ``conda-forge`` channel and then install the package.; If you have only installed Miniconda, or you want a completely clean virtual environment to install QuTiP in, the ``conda`` package manager provides a convenient way to do this. To create a conda environment for QuTiP called ``qutip-env``:. .. code-block:: bash. conda create -n qutip-env python qutip. This will automatically install all the necessary packages, and none of the optional packages.; You activate the new environment by running. .. code-block:: bash. conda activate qutip-env. You can also install any more optional packages you want with ``conda install``, for example ``matplotlib``, ``ipython`` or ``jupyter``. .. _install-from-source:. Installing from Source; ======================. Official releases of QuTiP are available from the download section on `the project's web pages <https://qutip.org/download.html>`_, and the latest source code is available in `our GitHub repository <",MatchSource.DOCS,doc/installation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:5433,Deployability,install,installed,5433,"utip. This will install the minimum set of dependences, but none of the optional packages. .. _adding-conda-forge:. Adding the conda-forge channel; ------------------------------. To install QuTiP from conda, you will need to add the conda-forge channel.; The following command adds this channel with lowest priority, so conda will still try and install all other packages normally:. .. code-block:: bash. conda config --append channels conda-forge. If you want to change the order of your channels later, you can edit your ``.condarc`` (user home folder) file manually, but it is recommended to keep ``defaults`` as the highest priority. .. _building-conda-environment:. New conda environments; ----------------------. The default Anaconda environment has all the Python packages needed for running QuTiP installed already, so you will only need to add the ``conda-forge`` channel and then install the package.; If you have only installed Miniconda, or you want a completely clean virtual environment to install QuTiP in, the ``conda`` package manager provides a convenient way to do this. To create a conda environment for QuTiP called ``qutip-env``:. .. code-block:: bash. conda create -n qutip-env python qutip. This will automatically install all the necessary packages, and none of the optional packages.; You activate the new environment by running. .. code-block:: bash. conda activate qutip-env. You can also install any more optional packages you want with ``conda install``, for example ``matplotlib``, ``ipython`` or ``jupyter``. .. _install-from-source:. Installing from Source; ======================. Official releases of QuTiP are available from the download section on `the project's web pages <https://qutip.org/download.html>`_, and the latest source code is available in `our GitHub repository <https://github.com/qutip/qutip>`_.; In general we recommend users to use the latest stable release of QuTiP, but if you are interested in helping us out with development or wish to submi",MatchSource.DOCS,doc/installation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:5508,Deployability,install,install,5508,"utip. This will install the minimum set of dependences, but none of the optional packages. .. _adding-conda-forge:. Adding the conda-forge channel; ------------------------------. To install QuTiP from conda, you will need to add the conda-forge channel.; The following command adds this channel with lowest priority, so conda will still try and install all other packages normally:. .. code-block:: bash. conda config --append channels conda-forge. If you want to change the order of your channels later, you can edit your ``.condarc`` (user home folder) file manually, but it is recommended to keep ``defaults`` as the highest priority. .. _building-conda-environment:. New conda environments; ----------------------. The default Anaconda environment has all the Python packages needed for running QuTiP installed already, so you will only need to add the ``conda-forge`` channel and then install the package.; If you have only installed Miniconda, or you want a completely clean virtual environment to install QuTiP in, the ``conda`` package manager provides a convenient way to do this. To create a conda environment for QuTiP called ``qutip-env``:. .. code-block:: bash. conda create -n qutip-env python qutip. This will automatically install all the necessary packages, and none of the optional packages.; You activate the new environment by running. .. code-block:: bash. conda activate qutip-env. You can also install any more optional packages you want with ``conda install``, for example ``matplotlib``, ``ipython`` or ``jupyter``. .. _install-from-source:. Installing from Source; ======================. Official releases of QuTiP are available from the download section on `the project's web pages <https://qutip.org/download.html>`_, and the latest source code is available in `our GitHub repository <https://github.com/qutip/qutip>`_.; In general we recommend users to use the latest stable release of QuTiP, but if you are interested in helping us out with development or wish to submi",MatchSource.DOCS,doc/installation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:5743,Deployability,install,install,5743,"llowing command adds this channel with lowest priority, so conda will still try and install all other packages normally:. .. code-block:: bash. conda config --append channels conda-forge. If you want to change the order of your channels later, you can edit your ``.condarc`` (user home folder) file manually, but it is recommended to keep ``defaults`` as the highest priority. .. _building-conda-environment:. New conda environments; ----------------------. The default Anaconda environment has all the Python packages needed for running QuTiP installed already, so you will only need to add the ``conda-forge`` channel and then install the package.; If you have only installed Miniconda, or you want a completely clean virtual environment to install QuTiP in, the ``conda`` package manager provides a convenient way to do this. To create a conda environment for QuTiP called ``qutip-env``:. .. code-block:: bash. conda create -n qutip-env python qutip. This will automatically install all the necessary packages, and none of the optional packages.; You activate the new environment by running. .. code-block:: bash. conda activate qutip-env. You can also install any more optional packages you want with ``conda install``, for example ``matplotlib``, ``ipython`` or ``jupyter``. .. _install-from-source:. Installing from Source; ======================. Official releases of QuTiP are available from the download section on `the project's web pages <https://qutip.org/download.html>`_, and the latest source code is available in `our GitHub repository <https://github.com/qutip/qutip>`_.; In general we recommend users to use the latest stable release of QuTiP, but if you are interested in helping us out with development or wish to submit bug fixes, then use the latest development version from the GitHub repository. You can install from source by using the `Python-recommended PEP 517 procedure <build-pep517_>`_, or if you want more control or to have a development version, you can use the `low-",MatchSource.DOCS,doc/installation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:5921,Deployability,install,install,5921,"the order of your channels later, you can edit your ``.condarc`` (user home folder) file manually, but it is recommended to keep ``defaults`` as the highest priority. .. _building-conda-environment:. New conda environments; ----------------------. The default Anaconda environment has all the Python packages needed for running QuTiP installed already, so you will only need to add the ``conda-forge`` channel and then install the package.; If you have only installed Miniconda, or you want a completely clean virtual environment to install QuTiP in, the ``conda`` package manager provides a convenient way to do this. To create a conda environment for QuTiP called ``qutip-env``:. .. code-block:: bash. conda create -n qutip-env python qutip. This will automatically install all the necessary packages, and none of the optional packages.; You activate the new environment by running. .. code-block:: bash. conda activate qutip-env. You can also install any more optional packages you want with ``conda install``, for example ``matplotlib``, ``ipython`` or ``jupyter``. .. _install-from-source:. Installing from Source; ======================. Official releases of QuTiP are available from the download section on `the project's web pages <https://qutip.org/download.html>`_, and the latest source code is available in `our GitHub repository <https://github.com/qutip/qutip>`_.; In general we recommend users to use the latest stable release of QuTiP, but if you are interested in helping us out with development or wish to submit bug fixes, then use the latest development version from the GitHub repository. You can install from source by using the `Python-recommended PEP 517 procedure <build-pep517_>`_, or if you want more control or to have a development version, you can use the `low-level build procedure with setuptools <build-setuptools_>`_. .. _build-pep517:. PEP 517 Source Builds; ---------------------. The easiest way to build QuTiP from source is to use a PEP-517-compatible builder su",MatchSource.DOCS,doc/installation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:5978,Deployability,install,install,5978,"the order of your channels later, you can edit your ``.condarc`` (user home folder) file manually, but it is recommended to keep ``defaults`` as the highest priority. .. _building-conda-environment:. New conda environments; ----------------------. The default Anaconda environment has all the Python packages needed for running QuTiP installed already, so you will only need to add the ``conda-forge`` channel and then install the package.; If you have only installed Miniconda, or you want a completely clean virtual environment to install QuTiP in, the ``conda`` package manager provides a convenient way to do this. To create a conda environment for QuTiP called ``qutip-env``:. .. code-block:: bash. conda create -n qutip-env python qutip. This will automatically install all the necessary packages, and none of the optional packages.; You activate the new environment by running. .. code-block:: bash. conda activate qutip-env. You can also install any more optional packages you want with ``conda install``, for example ``matplotlib``, ``ipython`` or ``jupyter``. .. _install-from-source:. Installing from Source; ======================. Official releases of QuTiP are available from the download section on `the project's web pages <https://qutip.org/download.html>`_, and the latest source code is available in `our GitHub repository <https://github.com/qutip/qutip>`_.; In general we recommend users to use the latest stable release of QuTiP, but if you are interested in helping us out with development or wish to submit bug fixes, then use the latest development version from the GitHub repository. You can install from source by using the `Python-recommended PEP 517 procedure <build-pep517_>`_, or if you want more control or to have a development version, you can use the `low-level build procedure with setuptools <build-setuptools_>`_. .. _build-pep517:. PEP 517 Source Builds; ---------------------. The easiest way to build QuTiP from source is to use a PEP-517-compatible builder su",MatchSource.DOCS,doc/installation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:6128,Deployability,release,releases,6128,". New conda environments; ----------------------. The default Anaconda environment has all the Python packages needed for running QuTiP installed already, so you will only need to add the ``conda-forge`` channel and then install the package.; If you have only installed Miniconda, or you want a completely clean virtual environment to install QuTiP in, the ``conda`` package manager provides a convenient way to do this. To create a conda environment for QuTiP called ``qutip-env``:. .. code-block:: bash. conda create -n qutip-env python qutip. This will automatically install all the necessary packages, and none of the optional packages.; You activate the new environment by running. .. code-block:: bash. conda activate qutip-env. You can also install any more optional packages you want with ``conda install``, for example ``matplotlib``, ``ipython`` or ``jupyter``. .. _install-from-source:. Installing from Source; ======================. Official releases of QuTiP are available from the download section on `the project's web pages <https://qutip.org/download.html>`_, and the latest source code is available in `our GitHub repository <https://github.com/qutip/qutip>`_.; In general we recommend users to use the latest stable release of QuTiP, but if you are interested in helping us out with development or wish to submit bug fixes, then use the latest development version from the GitHub repository. You can install from source by using the `Python-recommended PEP 517 procedure <build-pep517_>`_, or if you want more control or to have a development version, you can use the `low-level build procedure with setuptools <build-setuptools_>`_. .. _build-pep517:. PEP 517 Source Builds; ---------------------. The easiest way to build QuTiP from source is to use a PEP-517-compatible builder such as the ``build`` package available on ``pip``.; These will automatically install all build dependencies for you, and the ``pip`` installation step afterwards will install the minimum runtime depe",MatchSource.DOCS,doc/installation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:6409,Deployability,release,release,6409,"completely clean virtual environment to install QuTiP in, the ``conda`` package manager provides a convenient way to do this. To create a conda environment for QuTiP called ``qutip-env``:. .. code-block:: bash. conda create -n qutip-env python qutip. This will automatically install all the necessary packages, and none of the optional packages.; You activate the new environment by running. .. code-block:: bash. conda activate qutip-env. You can also install any more optional packages you want with ``conda install``, for example ``matplotlib``, ``ipython`` or ``jupyter``. .. _install-from-source:. Installing from Source; ======================. Official releases of QuTiP are available from the download section on `the project's web pages <https://qutip.org/download.html>`_, and the latest source code is available in `our GitHub repository <https://github.com/qutip/qutip>`_.; In general we recommend users to use the latest stable release of QuTiP, but if you are interested in helping us out with development or wish to submit bug fixes, then use the latest development version from the GitHub repository. You can install from source by using the `Python-recommended PEP 517 procedure <build-pep517_>`_, or if you want more control or to have a development version, you can use the `low-level build procedure with setuptools <build-setuptools_>`_. .. _build-pep517:. PEP 517 Source Builds; ---------------------. The easiest way to build QuTiP from source is to use a PEP-517-compatible builder such as the ``build`` package available on ``pip``.; These will automatically install all build dependencies for you, and the ``pip`` installation step afterwards will install the minimum runtime dependencies.; You can do this by doing (for example). .. code-block:: bash. pip install build; python -m build <path to qutip>; pip install <path to qutip>/dist/qutip-<version>.whl. The first command installs the reference PEP-517 build tool, the second effects the build and the third uses ``pip`",MatchSource.DOCS,doc/installation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:6593,Deployability,install,install,6593,"python qutip. This will automatically install all the necessary packages, and none of the optional packages.; You activate the new environment by running. .. code-block:: bash. conda activate qutip-env. You can also install any more optional packages you want with ``conda install``, for example ``matplotlib``, ``ipython`` or ``jupyter``. .. _install-from-source:. Installing from Source; ======================. Official releases of QuTiP are available from the download section on `the project's web pages <https://qutip.org/download.html>`_, and the latest source code is available in `our GitHub repository <https://github.com/qutip/qutip>`_.; In general we recommend users to use the latest stable release of QuTiP, but if you are interested in helping us out with development or wish to submit bug fixes, then use the latest development version from the GitHub repository. You can install from source by using the `Python-recommended PEP 517 procedure <build-pep517_>`_, or if you want more control or to have a development version, you can use the `low-level build procedure with setuptools <build-setuptools_>`_. .. _build-pep517:. PEP 517 Source Builds; ---------------------. The easiest way to build QuTiP from source is to use a PEP-517-compatible builder such as the ``build`` package available on ``pip``.; These will automatically install all build dependencies for you, and the ``pip`` installation step afterwards will install the minimum runtime dependencies.; You can do this by doing (for example). .. code-block:: bash. pip install build; python -m build <path to qutip>; pip install <path to qutip>/dist/qutip-<version>.whl. The first command installs the reference PEP-517 build tool, the second effects the build and the third uses ``pip`` to install the built package.; You will need to replace ``<path to qutip>`` with the actual path to the QuTiP source code.; The string ``<version>`` will depend on the version of QuTiP, the version of Python and your operating system.;",MatchSource.DOCS,doc/installation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:7052,Deployability,install,install,7052,"=============. Official releases of QuTiP are available from the download section on `the project's web pages <https://qutip.org/download.html>`_, and the latest source code is available in `our GitHub repository <https://github.com/qutip/qutip>`_.; In general we recommend users to use the latest stable release of QuTiP, but if you are interested in helping us out with development or wish to submit bug fixes, then use the latest development version from the GitHub repository. You can install from source by using the `Python-recommended PEP 517 procedure <build-pep517_>`_, or if you want more control or to have a development version, you can use the `low-level build procedure with setuptools <build-setuptools_>`_. .. _build-pep517:. PEP 517 Source Builds; ---------------------. The easiest way to build QuTiP from source is to use a PEP-517-compatible builder such as the ``build`` package available on ``pip``.; These will automatically install all build dependencies for you, and the ``pip`` installation step afterwards will install the minimum runtime dependencies.; You can do this by doing (for example). .. code-block:: bash. pip install build; python -m build <path to qutip>; pip install <path to qutip>/dist/qutip-<version>.whl. The first command installs the reference PEP-517 build tool, the second effects the build and the third uses ``pip`` to install the built package.; You will need to replace ``<path to qutip>`` with the actual path to the QuTiP source code.; The string ``<version>`` will depend on the version of QuTiP, the version of Python and your operating system.; It will look something like ``4.6.0-cp39-cp39-manylinux1_x86_64``, but there should only be one ``.whl`` file in the ``dist/`` directory, which will be the correct one. .. _build-setuptools:. Direct Setuptools Source Builds; -------------------------------. This is the method to have the greatest amount of control over the installation, but it the most error-prone and not recommended unless you ",MatchSource.DOCS,doc/installation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:7108,Deployability,install,installation,7108,"=============. Official releases of QuTiP are available from the download section on `the project's web pages <https://qutip.org/download.html>`_, and the latest source code is available in `our GitHub repository <https://github.com/qutip/qutip>`_.; In general we recommend users to use the latest stable release of QuTiP, but if you are interested in helping us out with development or wish to submit bug fixes, then use the latest development version from the GitHub repository. You can install from source by using the `Python-recommended PEP 517 procedure <build-pep517_>`_, or if you want more control or to have a development version, you can use the `low-level build procedure with setuptools <build-setuptools_>`_. .. _build-pep517:. PEP 517 Source Builds; ---------------------. The easiest way to build QuTiP from source is to use a PEP-517-compatible builder such as the ``build`` package available on ``pip``.; These will automatically install all build dependencies for you, and the ``pip`` installation step afterwards will install the minimum runtime dependencies.; You can do this by doing (for example). .. code-block:: bash. pip install build; python -m build <path to qutip>; pip install <path to qutip>/dist/qutip-<version>.whl. The first command installs the reference PEP-517 build tool, the second effects the build and the third uses ``pip`` to install the built package.; You will need to replace ``<path to qutip>`` with the actual path to the QuTiP source code.; The string ``<version>`` will depend on the version of QuTiP, the version of Python and your operating system.; It will look something like ``4.6.0-cp39-cp39-manylinux1_x86_64``, but there should only be one ``.whl`` file in the ``dist/`` directory, which will be the correct one. .. _build-setuptools:. Direct Setuptools Source Builds; -------------------------------. This is the method to have the greatest amount of control over the installation, but it the most error-prone and not recommended unless you ",MatchSource.DOCS,doc/installation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:7142,Deployability,install,install,7142,"=============. Official releases of QuTiP are available from the download section on `the project's web pages <https://qutip.org/download.html>`_, and the latest source code is available in `our GitHub repository <https://github.com/qutip/qutip>`_.; In general we recommend users to use the latest stable release of QuTiP, but if you are interested in helping us out with development or wish to submit bug fixes, then use the latest development version from the GitHub repository. You can install from source by using the `Python-recommended PEP 517 procedure <build-pep517_>`_, or if you want more control or to have a development version, you can use the `low-level build procedure with setuptools <build-setuptools_>`_. .. _build-pep517:. PEP 517 Source Builds; ---------------------. The easiest way to build QuTiP from source is to use a PEP-517-compatible builder such as the ``build`` package available on ``pip``.; These will automatically install all build dependencies for you, and the ``pip`` installation step afterwards will install the minimum runtime dependencies.; You can do this by doing (for example). .. code-block:: bash. pip install build; python -m build <path to qutip>; pip install <path to qutip>/dist/qutip-<version>.whl. The first command installs the reference PEP-517 build tool, the second effects the build and the third uses ``pip`` to install the built package.; You will need to replace ``<path to qutip>`` with the actual path to the QuTiP source code.; The string ``<version>`` will depend on the version of QuTiP, the version of Python and your operating system.; It will look something like ``4.6.0-cp39-cp39-manylinux1_x86_64``, but there should only be one ``.whl`` file in the ``dist/`` directory, which will be the correct one. .. _build-setuptools:. Direct Setuptools Source Builds; -------------------------------. This is the method to have the greatest amount of control over the installation, but it the most error-prone and not recommended unless you ",MatchSource.DOCS,doc/installation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:7251,Deployability,install,install,7251,"r GitHub repository <https://github.com/qutip/qutip>`_.; In general we recommend users to use the latest stable release of QuTiP, but if you are interested in helping us out with development or wish to submit bug fixes, then use the latest development version from the GitHub repository. You can install from source by using the `Python-recommended PEP 517 procedure <build-pep517_>`_, or if you want more control or to have a development version, you can use the `low-level build procedure with setuptools <build-setuptools_>`_. .. _build-pep517:. PEP 517 Source Builds; ---------------------. The easiest way to build QuTiP from source is to use a PEP-517-compatible builder such as the ``build`` package available on ``pip``.; These will automatically install all build dependencies for you, and the ``pip`` installation step afterwards will install the minimum runtime dependencies.; You can do this by doing (for example). .. code-block:: bash. pip install build; python -m build <path to qutip>; pip install <path to qutip>/dist/qutip-<version>.whl. The first command installs the reference PEP-517 build tool, the second effects the build and the third uses ``pip`` to install the built package.; You will need to replace ``<path to qutip>`` with the actual path to the QuTiP source code.; The string ``<version>`` will depend on the version of QuTiP, the version of Python and your operating system.; It will look something like ``4.6.0-cp39-cp39-manylinux1_x86_64``, but there should only be one ``.whl`` file in the ``dist/`` directory, which will be the correct one. .. _build-setuptools:. Direct Setuptools Source Builds; -------------------------------. This is the method to have the greatest amount of control over the installation, but it the most error-prone and not recommended unless you know what you are doing.; You first need to have all the runtime dependencies installed.; The most up-to-date requirements will be listed in ``pyproject.toml`` file, in the ``build-system.requi",MatchSource.DOCS,doc/installation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:7303,Deployability,install,install,7303,"r GitHub repository <https://github.com/qutip/qutip>`_.; In general we recommend users to use the latest stable release of QuTiP, but if you are interested in helping us out with development or wish to submit bug fixes, then use the latest development version from the GitHub repository. You can install from source by using the `Python-recommended PEP 517 procedure <build-pep517_>`_, or if you want more control or to have a development version, you can use the `low-level build procedure with setuptools <build-setuptools_>`_. .. _build-pep517:. PEP 517 Source Builds; ---------------------. The easiest way to build QuTiP from source is to use a PEP-517-compatible builder such as the ``build`` package available on ``pip``.; These will automatically install all build dependencies for you, and the ``pip`` installation step afterwards will install the minimum runtime dependencies.; You can do this by doing (for example). .. code-block:: bash. pip install build; python -m build <path to qutip>; pip install <path to qutip>/dist/qutip-<version>.whl. The first command installs the reference PEP-517 build tool, the second effects the build and the third uses ``pip`` to install the built package.; You will need to replace ``<path to qutip>`` with the actual path to the QuTiP source code.; The string ``<version>`` will depend on the version of QuTiP, the version of Python and your operating system.; It will look something like ``4.6.0-cp39-cp39-manylinux1_x86_64``, but there should only be one ``.whl`` file in the ``dist/`` directory, which will be the correct one. .. _build-setuptools:. Direct Setuptools Source Builds; -------------------------------. This is the method to have the greatest amount of control over the installation, but it the most error-prone and not recommended unless you know what you are doing.; You first need to have all the runtime dependencies installed.; The most up-to-date requirements will be listed in ``pyproject.toml`` file, in the ``build-system.requi",MatchSource.DOCS,doc/installation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:7371,Deployability,install,installs,7371,", but if you are interested in helping us out with development or wish to submit bug fixes, then use the latest development version from the GitHub repository. You can install from source by using the `Python-recommended PEP 517 procedure <build-pep517_>`_, or if you want more control or to have a development version, you can use the `low-level build procedure with setuptools <build-setuptools_>`_. .. _build-pep517:. PEP 517 Source Builds; ---------------------. The easiest way to build QuTiP from source is to use a PEP-517-compatible builder such as the ``build`` package available on ``pip``.; These will automatically install all build dependencies for you, and the ``pip`` installation step afterwards will install the minimum runtime dependencies.; You can do this by doing (for example). .. code-block:: bash. pip install build; python -m build <path to qutip>; pip install <path to qutip>/dist/qutip-<version>.whl. The first command installs the reference PEP-517 build tool, the second effects the build and the third uses ``pip`` to install the built package.; You will need to replace ``<path to qutip>`` with the actual path to the QuTiP source code.; The string ``<version>`` will depend on the version of QuTiP, the version of Python and your operating system.; It will look something like ``4.6.0-cp39-cp39-manylinux1_x86_64``, but there should only be one ``.whl`` file in the ``dist/`` directory, which will be the correct one. .. _build-setuptools:. Direct Setuptools Source Builds; -------------------------------. This is the method to have the greatest amount of control over the installation, but it the most error-prone and not recommended unless you know what you are doing.; You first need to have all the runtime dependencies installed.; The most up-to-date requirements will be listed in ``pyproject.toml`` file, in the ``build-system.requires`` key.; As of the 5.0.0 release, the build requirements can be installed with. .. code-block:: bash. pip install setuptools w",MatchSource.DOCS,doc/installation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:7473,Deployability,install,install,7473,", but if you are interested in helping us out with development or wish to submit bug fixes, then use the latest development version from the GitHub repository. You can install from source by using the `Python-recommended PEP 517 procedure <build-pep517_>`_, or if you want more control or to have a development version, you can use the `low-level build procedure with setuptools <build-setuptools_>`_. .. _build-pep517:. PEP 517 Source Builds; ---------------------. The easiest way to build QuTiP from source is to use a PEP-517-compatible builder such as the ``build`` package available on ``pip``.; These will automatically install all build dependencies for you, and the ``pip`` installation step afterwards will install the minimum runtime dependencies.; You can do this by doing (for example). .. code-block:: bash. pip install build; python -m build <path to qutip>; pip install <path to qutip>/dist/qutip-<version>.whl. The first command installs the reference PEP-517 build tool, the second effects the build and the third uses ``pip`` to install the built package.; You will need to replace ``<path to qutip>`` with the actual path to the QuTiP source code.; The string ``<version>`` will depend on the version of QuTiP, the version of Python and your operating system.; It will look something like ``4.6.0-cp39-cp39-manylinux1_x86_64``, but there should only be one ``.whl`` file in the ``dist/`` directory, which will be the correct one. .. _build-setuptools:. Direct Setuptools Source Builds; -------------------------------. This is the method to have the greatest amount of control over the installation, but it the most error-prone and not recommended unless you know what you are doing.; You first need to have all the runtime dependencies installed.; The most up-to-date requirements will be listed in ``pyproject.toml`` file, in the ``build-system.requires`` key.; As of the 5.0.0 release, the build requirements can be installed with. .. code-block:: bash. pip install setuptools w",MatchSource.DOCS,doc/installation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:8031,Deployability,install,installation,8031,"ically install all build dependencies for you, and the ``pip`` installation step afterwards will install the minimum runtime dependencies.; You can do this by doing (for example). .. code-block:: bash. pip install build; python -m build <path to qutip>; pip install <path to qutip>/dist/qutip-<version>.whl. The first command installs the reference PEP-517 build tool, the second effects the build and the third uses ``pip`` to install the built package.; You will need to replace ``<path to qutip>`` with the actual path to the QuTiP source code.; The string ``<version>`` will depend on the version of QuTiP, the version of Python and your operating system.; It will look something like ``4.6.0-cp39-cp39-manylinux1_x86_64``, but there should only be one ``.whl`` file in the ``dist/`` directory, which will be the correct one. .. _build-setuptools:. Direct Setuptools Source Builds; -------------------------------. This is the method to have the greatest amount of control over the installation, but it the most error-prone and not recommended unless you know what you are doing.; You first need to have all the runtime dependencies installed.; The most up-to-date requirements will be listed in ``pyproject.toml`` file, in the ``build-system.requires`` key.; As of the 5.0.0 release, the build requirements can be installed with. .. code-block:: bash. pip install setuptools wheel packaging cython 'numpy<2.0.0' scipy. or similar with ``conda`` if you prefer.; You will also need to have a functional C++ compiler installed on your system.; This is likely already done for you if you are on Linux or macOS, but see the `section on Windows installations <install-on-windows_>`_ if that is your operating system. To install QuTiP from the source code run:. .. code-block:: bash. pip install . If you wish to contribute to the QuTiP project, then you will want to create your own fork of `the QuTiP git repository <https://github.com/qutip/qutip>`_, clone this to a local folder, and install it into",MatchSource.DOCS,doc/installation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:8182,Deployability,install,installed,8182,"m runtime dependencies.; You can do this by doing (for example). .. code-block:: bash. pip install build; python -m build <path to qutip>; pip install <path to qutip>/dist/qutip-<version>.whl. The first command installs the reference PEP-517 build tool, the second effects the build and the third uses ``pip`` to install the built package.; You will need to replace ``<path to qutip>`` with the actual path to the QuTiP source code.; The string ``<version>`` will depend on the version of QuTiP, the version of Python and your operating system.; It will look something like ``4.6.0-cp39-cp39-manylinux1_x86_64``, but there should only be one ``.whl`` file in the ``dist/`` directory, which will be the correct one. .. _build-setuptools:. Direct Setuptools Source Builds; -------------------------------. This is the method to have the greatest amount of control over the installation, but it the most error-prone and not recommended unless you know what you are doing.; You first need to have all the runtime dependencies installed.; The most up-to-date requirements will be listed in ``pyproject.toml`` file, in the ``build-system.requires`` key.; As of the 5.0.0 release, the build requirements can be installed with. .. code-block:: bash. pip install setuptools wheel packaging cython 'numpy<2.0.0' scipy. or similar with ``conda`` if you prefer.; You will also need to have a functional C++ compiler installed on your system.; This is likely already done for you if you are on Linux or macOS, but see the `section on Windows installations <install-on-windows_>`_ if that is your operating system. To install QuTiP from the source code run:. .. code-block:: bash. pip install . If you wish to contribute to the QuTiP project, then you will want to create your own fork of `the QuTiP git repository <https://github.com/qutip/qutip>`_, clone this to a local folder, and install it into your Python environment using:. .. code-block:: bash. python setup.py develop. When you do ``import qutip`` in th",MatchSource.DOCS,doc/installation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:8325,Deployability,release,release,8325,". The first command installs the reference PEP-517 build tool, the second effects the build and the third uses ``pip`` to install the built package.; You will need to replace ``<path to qutip>`` with the actual path to the QuTiP source code.; The string ``<version>`` will depend on the version of QuTiP, the version of Python and your operating system.; It will look something like ``4.6.0-cp39-cp39-manylinux1_x86_64``, but there should only be one ``.whl`` file in the ``dist/`` directory, which will be the correct one. .. _build-setuptools:. Direct Setuptools Source Builds; -------------------------------. This is the method to have the greatest amount of control over the installation, but it the most error-prone and not recommended unless you know what you are doing.; You first need to have all the runtime dependencies installed.; The most up-to-date requirements will be listed in ``pyproject.toml`` file, in the ``build-system.requires`` key.; As of the 5.0.0 release, the build requirements can be installed with. .. code-block:: bash. pip install setuptools wheel packaging cython 'numpy<2.0.0' scipy. or similar with ``conda`` if you prefer.; You will also need to have a functional C++ compiler installed on your system.; This is likely already done for you if you are on Linux or macOS, but see the `section on Windows installations <install-on-windows_>`_ if that is your operating system. To install QuTiP from the source code run:. .. code-block:: bash. pip install . If you wish to contribute to the QuTiP project, then you will want to create your own fork of `the QuTiP git repository <https://github.com/qutip/qutip>`_, clone this to a local folder, and install it into your Python environment using:. .. code-block:: bash. python setup.py develop. When you do ``import qutip`` in this environment, you will then load the code from your local fork, enabling you to edit the Python files and have the changes immediately available when you restart your Python interpreter, wi",MatchSource.DOCS,doc/installation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:8364,Deployability,install,installed,8364,". The first command installs the reference PEP-517 build tool, the second effects the build and the third uses ``pip`` to install the built package.; You will need to replace ``<path to qutip>`` with the actual path to the QuTiP source code.; The string ``<version>`` will depend on the version of QuTiP, the version of Python and your operating system.; It will look something like ``4.6.0-cp39-cp39-manylinux1_x86_64``, but there should only be one ``.whl`` file in the ``dist/`` directory, which will be the correct one. .. _build-setuptools:. Direct Setuptools Source Builds; -------------------------------. This is the method to have the greatest amount of control over the installation, but it the most error-prone and not recommended unless you know what you are doing.; You first need to have all the runtime dependencies installed.; The most up-to-date requirements will be listed in ``pyproject.toml`` file, in the ``build-system.requires`` key.; As of the 5.0.0 release, the build requirements can be installed with. .. code-block:: bash. pip install setuptools wheel packaging cython 'numpy<2.0.0' scipy. or similar with ``conda`` if you prefer.; You will also need to have a functional C++ compiler installed on your system.; This is likely already done for you if you are on Linux or macOS, but see the `section on Windows installations <install-on-windows_>`_ if that is your operating system. To install QuTiP from the source code run:. .. code-block:: bash. pip install . If you wish to contribute to the QuTiP project, then you will want to create your own fork of `the QuTiP git repository <https://github.com/qutip/qutip>`_, clone this to a local folder, and install it into your Python environment using:. .. code-block:: bash. python setup.py develop. When you do ``import qutip`` in this environment, you will then load the code from your local fork, enabling you to edit the Python files and have the changes immediately available when you restart your Python interpreter, wi",MatchSource.DOCS,doc/installation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:8406,Deployability,install,install,8406,"cts the build and the third uses ``pip`` to install the built package.; You will need to replace ``<path to qutip>`` with the actual path to the QuTiP source code.; The string ``<version>`` will depend on the version of QuTiP, the version of Python and your operating system.; It will look something like ``4.6.0-cp39-cp39-manylinux1_x86_64``, but there should only be one ``.whl`` file in the ``dist/`` directory, which will be the correct one. .. _build-setuptools:. Direct Setuptools Source Builds; -------------------------------. This is the method to have the greatest amount of control over the installation, but it the most error-prone and not recommended unless you know what you are doing.; You first need to have all the runtime dependencies installed.; The most up-to-date requirements will be listed in ``pyproject.toml`` file, in the ``build-system.requires`` key.; As of the 5.0.0 release, the build requirements can be installed with. .. code-block:: bash. pip install setuptools wheel packaging cython 'numpy<2.0.0' scipy. or similar with ``conda`` if you prefer.; You will also need to have a functional C++ compiler installed on your system.; This is likely already done for you if you are on Linux or macOS, but see the `section on Windows installations <install-on-windows_>`_ if that is your operating system. To install QuTiP from the source code run:. .. code-block:: bash. pip install . If you wish to contribute to the QuTiP project, then you will want to create your own fork of `the QuTiP git repository <https://github.com/qutip/qutip>`_, clone this to a local folder, and install it into your Python environment using:. .. code-block:: bash. python setup.py develop. When you do ``import qutip`` in this environment, you will then load the code from your local fork, enabling you to edit the Python files and have the changes immediately available when you restart your Python interpreter, without needing to rebuild the package.; Note that if you change any Cython file",MatchSource.DOCS,doc/installation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:8564,Deployability,install,installed,8564,"h the actual path to the QuTiP source code.; The string ``<version>`` will depend on the version of QuTiP, the version of Python and your operating system.; It will look something like ``4.6.0-cp39-cp39-manylinux1_x86_64``, but there should only be one ``.whl`` file in the ``dist/`` directory, which will be the correct one. .. _build-setuptools:. Direct Setuptools Source Builds; -------------------------------. This is the method to have the greatest amount of control over the installation, but it the most error-prone and not recommended unless you know what you are doing.; You first need to have all the runtime dependencies installed.; The most up-to-date requirements will be listed in ``pyproject.toml`` file, in the ``build-system.requires`` key.; As of the 5.0.0 release, the build requirements can be installed with. .. code-block:: bash. pip install setuptools wheel packaging cython 'numpy<2.0.0' scipy. or similar with ``conda`` if you prefer.; You will also need to have a functional C++ compiler installed on your system.; This is likely already done for you if you are on Linux or macOS, but see the `section on Windows installations <install-on-windows_>`_ if that is your operating system. To install QuTiP from the source code run:. .. code-block:: bash. pip install . If you wish to contribute to the QuTiP project, then you will want to create your own fork of `the QuTiP git repository <https://github.com/qutip/qutip>`_, clone this to a local folder, and install it into your Python environment using:. .. code-block:: bash. python setup.py develop. When you do ``import qutip`` in this environment, you will then load the code from your local fork, enabling you to edit the Python files and have the changes immediately available when you restart your Python interpreter, without needing to rebuild the package.; Note that if you change any Cython files, you will need to rerun the build command. You should not need to use ``sudo`` (or other superuser privileges) to inst",MatchSource.DOCS,doc/installation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:8689,Deployability,install,installations,8689,"hon and your operating system.; It will look something like ``4.6.0-cp39-cp39-manylinux1_x86_64``, but there should only be one ``.whl`` file in the ``dist/`` directory, which will be the correct one. .. _build-setuptools:. Direct Setuptools Source Builds; -------------------------------. This is the method to have the greatest amount of control over the installation, but it the most error-prone and not recommended unless you know what you are doing.; You first need to have all the runtime dependencies installed.; The most up-to-date requirements will be listed in ``pyproject.toml`` file, in the ``build-system.requires`` key.; As of the 5.0.0 release, the build requirements can be installed with. .. code-block:: bash. pip install setuptools wheel packaging cython 'numpy<2.0.0' scipy. or similar with ``conda`` if you prefer.; You will also need to have a functional C++ compiler installed on your system.; This is likely already done for you if you are on Linux or macOS, but see the `section on Windows installations <install-on-windows_>`_ if that is your operating system. To install QuTiP from the source code run:. .. code-block:: bash. pip install . If you wish to contribute to the QuTiP project, then you will want to create your own fork of `the QuTiP git repository <https://github.com/qutip/qutip>`_, clone this to a local folder, and install it into your Python environment using:. .. code-block:: bash. python setup.py develop. When you do ``import qutip`` in this environment, you will then load the code from your local fork, enabling you to edit the Python files and have the changes immediately available when you restart your Python interpreter, without needing to rebuild the package.; Note that if you change any Cython files, you will need to rerun the build command. You should not need to use ``sudo`` (or other superuser privileges) to install into a personal virtual environment; if it feels like you need it, there is a good chance that you are installing into the",MatchSource.DOCS,doc/installation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:8704,Deployability,install,install-on-,8704,"hon and your operating system.; It will look something like ``4.6.0-cp39-cp39-manylinux1_x86_64``, but there should only be one ``.whl`` file in the ``dist/`` directory, which will be the correct one. .. _build-setuptools:. Direct Setuptools Source Builds; -------------------------------. This is the method to have the greatest amount of control over the installation, but it the most error-prone and not recommended unless you know what you are doing.; You first need to have all the runtime dependencies installed.; The most up-to-date requirements will be listed in ``pyproject.toml`` file, in the ``build-system.requires`` key.; As of the 5.0.0 release, the build requirements can be installed with. .. code-block:: bash. pip install setuptools wheel packaging cython 'numpy<2.0.0' scipy. or similar with ``conda`` if you prefer.; You will also need to have a functional C++ compiler installed on your system.; This is likely already done for you if you are on Linux or macOS, but see the `section on Windows installations <install-on-windows_>`_ if that is your operating system. To install QuTiP from the source code run:. .. code-block:: bash. pip install . If you wish to contribute to the QuTiP project, then you will want to create your own fork of `the QuTiP git repository <https://github.com/qutip/qutip>`_, clone this to a local folder, and install it into your Python environment using:. .. code-block:: bash. python setup.py develop. When you do ``import qutip`` in this environment, you will then load the code from your local fork, enabling you to edit the Python files and have the changes immediately available when you restart your Python interpreter, without needing to rebuild the package.; Note that if you change any Cython files, you will need to rerun the build command. You should not need to use ``sudo`` (or other superuser privileges) to install into a personal virtual environment; if it feels like you need it, there is a good chance that you are installing into the",MatchSource.DOCS,doc/installation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:8764,Deployability,install,install,8764," should only be one ``.whl`` file in the ``dist/`` directory, which will be the correct one. .. _build-setuptools:. Direct Setuptools Source Builds; -------------------------------. This is the method to have the greatest amount of control over the installation, but it the most error-prone and not recommended unless you know what you are doing.; You first need to have all the runtime dependencies installed.; The most up-to-date requirements will be listed in ``pyproject.toml`` file, in the ``build-system.requires`` key.; As of the 5.0.0 release, the build requirements can be installed with. .. code-block:: bash. pip install setuptools wheel packaging cython 'numpy<2.0.0' scipy. or similar with ``conda`` if you prefer.; You will also need to have a functional C++ compiler installed on your system.; This is likely already done for you if you are on Linux or macOS, but see the `section on Windows installations <install-on-windows_>`_ if that is your operating system. To install QuTiP from the source code run:. .. code-block:: bash. pip install . If you wish to contribute to the QuTiP project, then you will want to create your own fork of `the QuTiP git repository <https://github.com/qutip/qutip>`_, clone this to a local folder, and install it into your Python environment using:. .. code-block:: bash. python setup.py develop. When you do ``import qutip`` in this environment, you will then load the code from your local fork, enabling you to edit the Python files and have the changes immediately available when you restart your Python interpreter, without needing to rebuild the package.; Note that if you change any Cython files, you will need to rerun the build command. You should not need to use ``sudo`` (or other superuser privileges) to install into a personal virtual environment; if it feels like you need it, there is a good chance that you are installing into the system Python environment instead. .. _install-on-windows:. Installation on Windows; =====================",MatchSource.DOCS,doc/installation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:8831,Deployability,install,install,8831,"directory, which will be the correct one. .. _build-setuptools:. Direct Setuptools Source Builds; -------------------------------. This is the method to have the greatest amount of control over the installation, but it the most error-prone and not recommended unless you know what you are doing.; You first need to have all the runtime dependencies installed.; The most up-to-date requirements will be listed in ``pyproject.toml`` file, in the ``build-system.requires`` key.; As of the 5.0.0 release, the build requirements can be installed with. .. code-block:: bash. pip install setuptools wheel packaging cython 'numpy<2.0.0' scipy. or similar with ``conda`` if you prefer.; You will also need to have a functional C++ compiler installed on your system.; This is likely already done for you if you are on Linux or macOS, but see the `section on Windows installations <install-on-windows_>`_ if that is your operating system. To install QuTiP from the source code run:. .. code-block:: bash. pip install . If you wish to contribute to the QuTiP project, then you will want to create your own fork of `the QuTiP git repository <https://github.com/qutip/qutip>`_, clone this to a local folder, and install it into your Python environment using:. .. code-block:: bash. python setup.py develop. When you do ``import qutip`` in this environment, you will then load the code from your local fork, enabling you to edit the Python files and have the changes immediately available when you restart your Python interpreter, without needing to rebuild the package.; Note that if you change any Cython files, you will need to rerun the build command. You should not need to use ``sudo`` (or other superuser privileges) to install into a personal virtual environment; if it feels like you need it, there is a good chance that you are installing into the system Python environment instead. .. _install-on-windows:. Installation on Windows; =======================. As with other operating systems, the easiest me",MatchSource.DOCS,doc/installation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:9031,Deployability,install,install,9031,"the installation, but it the most error-prone and not recommended unless you know what you are doing.; You first need to have all the runtime dependencies installed.; The most up-to-date requirements will be listed in ``pyproject.toml`` file, in the ``build-system.requires`` key.; As of the 5.0.0 release, the build requirements can be installed with. .. code-block:: bash. pip install setuptools wheel packaging cython 'numpy<2.0.0' scipy. or similar with ``conda`` if you prefer.; You will also need to have a functional C++ compiler installed on your system.; This is likely already done for you if you are on Linux or macOS, but see the `section on Windows installations <install-on-windows_>`_ if that is your operating system. To install QuTiP from the source code run:. .. code-block:: bash. pip install . If you wish to contribute to the QuTiP project, then you will want to create your own fork of `the QuTiP git repository <https://github.com/qutip/qutip>`_, clone this to a local folder, and install it into your Python environment using:. .. code-block:: bash. python setup.py develop. When you do ``import qutip`` in this environment, you will then load the code from your local fork, enabling you to edit the Python files and have the changes immediately available when you restart your Python interpreter, without needing to rebuild the package.; Note that if you change any Cython files, you will need to rerun the build command. You should not need to use ``sudo`` (or other superuser privileges) to install into a personal virtual environment; if it feels like you need it, there is a good chance that you are installing into the system Python environment instead. .. _install-on-windows:. Installation on Windows; =======================. As with other operating systems, the easiest method is to use ``pip install qutip``, or use the ``conda`` procedure described above.; If you want to build from source or use runtime compilation with Cython, you will need to have a working C++",MatchSource.DOCS,doc/installation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:9545,Deployability,install,install,9545,"This is likely already done for you if you are on Linux or macOS, but see the `section on Windows installations <install-on-windows_>`_ if that is your operating system. To install QuTiP from the source code run:. .. code-block:: bash. pip install . If you wish to contribute to the QuTiP project, then you will want to create your own fork of `the QuTiP git repository <https://github.com/qutip/qutip>`_, clone this to a local folder, and install it into your Python environment using:. .. code-block:: bash. python setup.py develop. When you do ``import qutip`` in this environment, you will then load the code from your local fork, enabling you to edit the Python files and have the changes immediately available when you restart your Python interpreter, without needing to rebuild the package.; Note that if you change any Cython files, you will need to rerun the build command. You should not need to use ``sudo`` (or other superuser privileges) to install into a personal virtual environment; if it feels like you need it, there is a good chance that you are installing into the system Python environment instead. .. _install-on-windows:. Installation on Windows; =======================. As with other operating systems, the easiest method is to use ``pip install qutip``, or use the ``conda`` procedure described above.; If you want to build from source or use runtime compilation with Cython, you will need to have a working C++ compiler. You can `download the Visual Studio IDE from Microsoft <https://visualstudio.microsoft.com/downloads/>`_, which has a free Community edition containing a sufficient C++ compiler.; This is the recommended compiler toolchain on Windows.; When installing, be sure to select the following components:. - Windows ""X"" SDK (where ""X"" stands for your version: 7/8/8.1/10); - Visual Studio C++ build tools. You can then follow the `installation from source <install-from-source_>`_ section as normal. .. important::. In order to prevent issues with the ``PATH`` ",MatchSource.DOCS,doc/installation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:9656,Deployability,install,installing,9656,"This is likely already done for you if you are on Linux or macOS, but see the `section on Windows installations <install-on-windows_>`_ if that is your operating system. To install QuTiP from the source code run:. .. code-block:: bash. pip install . If you wish to contribute to the QuTiP project, then you will want to create your own fork of `the QuTiP git repository <https://github.com/qutip/qutip>`_, clone this to a local folder, and install it into your Python environment using:. .. code-block:: bash. python setup.py develop. When you do ``import qutip`` in this environment, you will then load the code from your local fork, enabling you to edit the Python files and have the changes immediately available when you restart your Python interpreter, without needing to rebuild the package.; Note that if you change any Cython files, you will need to rerun the build command. You should not need to use ``sudo`` (or other superuser privileges) to install into a personal virtual environment; if it feels like you need it, there is a good chance that you are installing into the system Python environment instead. .. _install-on-windows:. Installation on Windows; =======================. As with other operating systems, the easiest method is to use ``pip install qutip``, or use the ``conda`` procedure described above.; If you want to build from source or use runtime compilation with Cython, you will need to have a working C++ compiler. You can `download the Visual Studio IDE from Microsoft <https://visualstudio.microsoft.com/downloads/>`_, which has a free Community edition containing a sufficient C++ compiler.; This is the recommended compiler toolchain on Windows.; When installing, be sure to select the following components:. - Windows ""X"" SDK (where ""X"" stands for your version: 7/8/8.1/10); - Visual Studio C++ build tools. You can then follow the `installation from source <install-from-source_>`_ section as normal. .. important::. In order to prevent issues with the ``PATH`` ",MatchSource.DOCS,doc/installation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:9854,Deployability,install,install,9854,"h to contribute to the QuTiP project, then you will want to create your own fork of `the QuTiP git repository <https://github.com/qutip/qutip>`_, clone this to a local folder, and install it into your Python environment using:. .. code-block:: bash. python setup.py develop. When you do ``import qutip`` in this environment, you will then load the code from your local fork, enabling you to edit the Python files and have the changes immediately available when you restart your Python interpreter, without needing to rebuild the package.; Note that if you change any Cython files, you will need to rerun the build command. You should not need to use ``sudo`` (or other superuser privileges) to install into a personal virtual environment; if it feels like you need it, there is a good chance that you are installing into the system Python environment instead. .. _install-on-windows:. Installation on Windows; =======================. As with other operating systems, the easiest method is to use ``pip install qutip``, or use the ``conda`` procedure described above.; If you want to build from source or use runtime compilation with Cython, you will need to have a working C++ compiler. You can `download the Visual Studio IDE from Microsoft <https://visualstudio.microsoft.com/downloads/>`_, which has a free Community edition containing a sufficient C++ compiler.; This is the recommended compiler toolchain on Windows.; When installing, be sure to select the following components:. - Windows ""X"" SDK (where ""X"" stands for your version: 7/8/8.1/10); - Visual Studio C++ build tools. You can then follow the `installation from source <install-from-source_>`_ section as normal. .. important::. In order to prevent issues with the ``PATH`` environment variable not containing the compiler and associated libraries, it is recommended to use the developer command prompt in the Visual Studio installation folder instead of the built-in command prompt. The Community edition of Visual Studio takes aroun",MatchSource.DOCS,doc/installation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:10280,Deployability,install,installing,10280,"le when you restart your Python interpreter, without needing to rebuild the package.; Note that if you change any Cython files, you will need to rerun the build command. You should not need to use ``sudo`` (or other superuser privileges) to install into a personal virtual environment; if it feels like you need it, there is a good chance that you are installing into the system Python environment instead. .. _install-on-windows:. Installation on Windows; =======================. As with other operating systems, the easiest method is to use ``pip install qutip``, or use the ``conda`` procedure described above.; If you want to build from source or use runtime compilation with Cython, you will need to have a working C++ compiler. You can `download the Visual Studio IDE from Microsoft <https://visualstudio.microsoft.com/downloads/>`_, which has a free Community edition containing a sufficient C++ compiler.; This is the recommended compiler toolchain on Windows.; When installing, be sure to select the following components:. - Windows ""X"" SDK (where ""X"" stands for your version: 7/8/8.1/10); - Visual Studio C++ build tools. You can then follow the `installation from source <install-from-source_>`_ section as normal. .. important::. In order to prevent issues with the ``PATH`` environment variable not containing the compiler and associated libraries, it is recommended to use the developer command prompt in the Visual Studio installation folder instead of the built-in command prompt. The Community edition of Visual Studio takes around 10GB of disk space.; If this is prohibitive for you, it is also possible to install `only the build tools and necessary SDKs <https://visualstudio.microsoft.com/visual-cpp-build-tools/>`_ instead, which should save about 2GB of space. .. _install-verify:. Verifying the Installation; ==========================. QuTiP includes a collection of built-in test scripts to verify that an installation was successful.; To run the suite of tests scripts you ",MatchSource.DOCS,doc/installation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:10462,Deployability,install,installation,10462,"d not need to use ``sudo`` (or other superuser privileges) to install into a personal virtual environment; if it feels like you need it, there is a good chance that you are installing into the system Python environment instead. .. _install-on-windows:. Installation on Windows; =======================. As with other operating systems, the easiest method is to use ``pip install qutip``, or use the ``conda`` procedure described above.; If you want to build from source or use runtime compilation with Cython, you will need to have a working C++ compiler. You can `download the Visual Studio IDE from Microsoft <https://visualstudio.microsoft.com/downloads/>`_, which has a free Community edition containing a sufficient C++ compiler.; This is the recommended compiler toolchain on Windows.; When installing, be sure to select the following components:. - Windows ""X"" SDK (where ""X"" stands for your version: 7/8/8.1/10); - Visual Studio C++ build tools. You can then follow the `installation from source <install-from-source_>`_ section as normal. .. important::. In order to prevent issues with the ``PATH`` environment variable not containing the compiler and associated libraries, it is recommended to use the developer command prompt in the Visual Studio installation folder instead of the built-in command prompt. The Community edition of Visual Studio takes around 10GB of disk space.; If this is prohibitive for you, it is also possible to install `only the build tools and necessary SDKs <https://visualstudio.microsoft.com/visual-cpp-build-tools/>`_ instead, which should save about 2GB of space. .. _install-verify:. Verifying the Installation; ==========================. QuTiP includes a collection of built-in test scripts to verify that an installation was successful.; To run the suite of tests scripts you must also have the ``pytest`` testing library.; After installing QuTiP, leave the installation directory and call:. .. code-block:: bash. pytest qutip/qutip/tests. This will take",MatchSource.DOCS,doc/installation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:10488,Deployability,install,install-from-,10488,"d not need to use ``sudo`` (or other superuser privileges) to install into a personal virtual environment; if it feels like you need it, there is a good chance that you are installing into the system Python environment instead. .. _install-on-windows:. Installation on Windows; =======================. As with other operating systems, the easiest method is to use ``pip install qutip``, or use the ``conda`` procedure described above.; If you want to build from source or use runtime compilation with Cython, you will need to have a working C++ compiler. You can `download the Visual Studio IDE from Microsoft <https://visualstudio.microsoft.com/downloads/>`_, which has a free Community edition containing a sufficient C++ compiler.; This is the recommended compiler toolchain on Windows.; When installing, be sure to select the following components:. - Windows ""X"" SDK (where ""X"" stands for your version: 7/8/8.1/10); - Visual Studio C++ build tools. You can then follow the `installation from source <install-from-source_>`_ section as normal. .. important::. In order to prevent issues with the ``PATH`` environment variable not containing the compiler and associated libraries, it is recommended to use the developer command prompt in the Visual Studio installation folder instead of the built-in command prompt. The Community edition of Visual Studio takes around 10GB of disk space.; If this is prohibitive for you, it is also possible to install `only the build tools and necessary SDKs <https://visualstudio.microsoft.com/visual-cpp-build-tools/>`_ instead, which should save about 2GB of space. .. _install-verify:. Verifying the Installation; ==========================. QuTiP includes a collection of built-in test scripts to verify that an installation was successful.; To run the suite of tests scripts you must also have the ``pytest`` testing library.; After installing QuTiP, leave the installation directory and call:. .. code-block:: bash. pytest qutip/qutip/tests. This will take",MatchSource.DOCS,doc/installation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:10742,Deployability,install,installation,10742,"he system Python environment instead. .. _install-on-windows:. Installation on Windows; =======================. As with other operating systems, the easiest method is to use ``pip install qutip``, or use the ``conda`` procedure described above.; If you want to build from source or use runtime compilation with Cython, you will need to have a working C++ compiler. You can `download the Visual Studio IDE from Microsoft <https://visualstudio.microsoft.com/downloads/>`_, which has a free Community edition containing a sufficient C++ compiler.; This is the recommended compiler toolchain on Windows.; When installing, be sure to select the following components:. - Windows ""X"" SDK (where ""X"" stands for your version: 7/8/8.1/10); - Visual Studio C++ build tools. You can then follow the `installation from source <install-from-source_>`_ section as normal. .. important::. In order to prevent issues with the ``PATH`` environment variable not containing the compiler and associated libraries, it is recommended to use the developer command prompt in the Visual Studio installation folder instead of the built-in command prompt. The Community edition of Visual Studio takes around 10GB of disk space.; If this is prohibitive for you, it is also possible to install `only the build tools and necessary SDKs <https://visualstudio.microsoft.com/visual-cpp-build-tools/>`_ instead, which should save about 2GB of space. .. _install-verify:. Verifying the Installation; ==========================. QuTiP includes a collection of built-in test scripts to verify that an installation was successful.; To run the suite of tests scripts you must also have the ``pytest`` testing library.; After installing QuTiP, leave the installation directory and call:. .. code-block:: bash. pytest qutip/qutip/tests. This will take between 10 and 30 minutes, depending on your computer.; At the end, the testing report should report a success; it is normal for some tests to be skipped, and for some to be marked ""xfail"" i",MatchSource.DOCS,doc/installation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:10930,Deployability,install,install,10930,"ild from source or use runtime compilation with Cython, you will need to have a working C++ compiler. You can `download the Visual Studio IDE from Microsoft <https://visualstudio.microsoft.com/downloads/>`_, which has a free Community edition containing a sufficient C++ compiler.; This is the recommended compiler toolchain on Windows.; When installing, be sure to select the following components:. - Windows ""X"" SDK (where ""X"" stands for your version: 7/8/8.1/10); - Visual Studio C++ build tools. You can then follow the `installation from source <install-from-source_>`_ section as normal. .. important::. In order to prevent issues with the ``PATH`` environment variable not containing the compiler and associated libraries, it is recommended to use the developer command prompt in the Visual Studio installation folder instead of the built-in command prompt. The Community edition of Visual Studio takes around 10GB of disk space.; If this is prohibitive for you, it is also possible to install `only the build tools and necessary SDKs <https://visualstudio.microsoft.com/visual-cpp-build-tools/>`_ instead, which should save about 2GB of space. .. _install-verify:. Verifying the Installation; ==========================. QuTiP includes a collection of built-in test scripts to verify that an installation was successful.; To run the suite of tests scripts you must also have the ``pytest`` testing library.; After installing QuTiP, leave the installation directory and call:. .. code-block:: bash. pytest qutip/qutip/tests. This will take between 10 and 30 minutes, depending on your computer.; At the end, the testing report should report a success; it is normal for some tests to be skipped, and for some to be marked ""xfail"" in yellow.; Skips may be tests that do not run on your operating system, or tests of optional components that you have not installed the dependencies for.; If any failures or errors occur, please check that you have installed all of the required modules.; See the ",MatchSource.DOCS,doc/installation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:11237,Deployability,install,installation,11237,"r.; This is the recommended compiler toolchain on Windows.; When installing, be sure to select the following components:. - Windows ""X"" SDK (where ""X"" stands for your version: 7/8/8.1/10); - Visual Studio C++ build tools. You can then follow the `installation from source <install-from-source_>`_ section as normal. .. important::. In order to prevent issues with the ``PATH`` environment variable not containing the compiler and associated libraries, it is recommended to use the developer command prompt in the Visual Studio installation folder instead of the built-in command prompt. The Community edition of Visual Studio takes around 10GB of disk space.; If this is prohibitive for you, it is also possible to install `only the build tools and necessary SDKs <https://visualstudio.microsoft.com/visual-cpp-build-tools/>`_ instead, which should save about 2GB of space. .. _install-verify:. Verifying the Installation; ==========================. QuTiP includes a collection of built-in test scripts to verify that an installation was successful.; To run the suite of tests scripts you must also have the ``pytest`` testing library.; After installing QuTiP, leave the installation directory and call:. .. code-block:: bash. pytest qutip/qutip/tests. This will take between 10 and 30 minutes, depending on your computer.; At the end, the testing report should report a success; it is normal for some tests to be skipped, and for some to be marked ""xfail"" in yellow.; Skips may be tests that do not run on your operating system, or tests of optional components that you have not installed the dependencies for.; If any failures or errors occur, please check that you have installed all of the required modules.; See the next section on how to check the installed versions of the QuTiP dependencies.; If these tests still fail, then head on over to the `QuTiP Discussion Board <https://groups.google.com/g/qutip>`_ or `the GitHub issues page <https://github.com/qutip/qutip/issues>`_ and post a mess",MatchSource.DOCS,doc/installation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:11359,Deployability,install,installing,11359,"sion: 7/8/8.1/10); - Visual Studio C++ build tools. You can then follow the `installation from source <install-from-source_>`_ section as normal. .. important::. In order to prevent issues with the ``PATH`` environment variable not containing the compiler and associated libraries, it is recommended to use the developer command prompt in the Visual Studio installation folder instead of the built-in command prompt. The Community edition of Visual Studio takes around 10GB of disk space.; If this is prohibitive for you, it is also possible to install `only the build tools and necessary SDKs <https://visualstudio.microsoft.com/visual-cpp-build-tools/>`_ instead, which should save about 2GB of space. .. _install-verify:. Verifying the Installation; ==========================. QuTiP includes a collection of built-in test scripts to verify that an installation was successful.; To run the suite of tests scripts you must also have the ``pytest`` testing library.; After installing QuTiP, leave the installation directory and call:. .. code-block:: bash. pytest qutip/qutip/tests. This will take between 10 and 30 minutes, depending on your computer.; At the end, the testing report should report a success; it is normal for some tests to be skipped, and for some to be marked ""xfail"" in yellow.; Skips may be tests that do not run on your operating system, or tests of optional components that you have not installed the dependencies for.; If any failures or errors occur, please check that you have installed all of the required modules.; See the next section on how to check the installed versions of the QuTiP dependencies.; If these tests still fail, then head on over to the `QuTiP Discussion Board <https://groups.google.com/g/qutip>`_ or `the GitHub issues page <https://github.com/qutip/qutip/issues>`_ and post a message detailing your particular issue. .. _install-about:. Checking Version Information; ============================. QuTiP includes an ""about"" function for viewing informa",MatchSource.DOCS,doc/installation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:11387,Deployability,install,installation,11387,"sion: 7/8/8.1/10); - Visual Studio C++ build tools. You can then follow the `installation from source <install-from-source_>`_ section as normal. .. important::. In order to prevent issues with the ``PATH`` environment variable not containing the compiler and associated libraries, it is recommended to use the developer command prompt in the Visual Studio installation folder instead of the built-in command prompt. The Community edition of Visual Studio takes around 10GB of disk space.; If this is prohibitive for you, it is also possible to install `only the build tools and necessary SDKs <https://visualstudio.microsoft.com/visual-cpp-build-tools/>`_ instead, which should save about 2GB of space. .. _install-verify:. Verifying the Installation; ==========================. QuTiP includes a collection of built-in test scripts to verify that an installation was successful.; To run the suite of tests scripts you must also have the ``pytest`` testing library.; After installing QuTiP, leave the installation directory and call:. .. code-block:: bash. pytest qutip/qutip/tests. This will take between 10 and 30 minutes, depending on your computer.; At the end, the testing report should report a success; it is normal for some tests to be skipped, and for some to be marked ""xfail"" in yellow.; Skips may be tests that do not run on your operating system, or tests of optional components that you have not installed the dependencies for.; If any failures or errors occur, please check that you have installed all of the required modules.; See the next section on how to check the installed versions of the QuTiP dependencies.; If these tests still fail, then head on over to the `QuTiP Discussion Board <https://groups.google.com/g/qutip>`_ or `the GitHub issues page <https://github.com/qutip/qutip/issues>`_ and post a message detailing your particular issue. .. _install-about:. Checking Version Information; ============================. QuTiP includes an ""about"" function for viewing informa",MatchSource.DOCS,doc/installation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:11796,Deployability,install,installed,11796,"nt::. In order to prevent issues with the ``PATH`` environment variable not containing the compiler and associated libraries, it is recommended to use the developer command prompt in the Visual Studio installation folder instead of the built-in command prompt. The Community edition of Visual Studio takes around 10GB of disk space.; If this is prohibitive for you, it is also possible to install `only the build tools and necessary SDKs <https://visualstudio.microsoft.com/visual-cpp-build-tools/>`_ instead, which should save about 2GB of space. .. _install-verify:. Verifying the Installation; ==========================. QuTiP includes a collection of built-in test scripts to verify that an installation was successful.; To run the suite of tests scripts you must also have the ``pytest`` testing library.; After installing QuTiP, leave the installation directory and call:. .. code-block:: bash. pytest qutip/qutip/tests. This will take between 10 and 30 minutes, depending on your computer.; At the end, the testing report should report a success; it is normal for some tests to be skipped, and for some to be marked ""xfail"" in yellow.; Skips may be tests that do not run on your operating system, or tests of optional components that you have not installed the dependencies for.; If any failures or errors occur, please check that you have installed all of the required modules.; See the next section on how to check the installed versions of the QuTiP dependencies.; If these tests still fail, then head on over to the `QuTiP Discussion Board <https://groups.google.com/g/qutip>`_ or `the GitHub issues page <https://github.com/qutip/qutip/issues>`_ and post a message detailing your particular issue. .. _install-about:. Checking Version Information; ============================. QuTiP includes an ""about"" function for viewing information about QuTiP and the important dependencies installed on your system.; To view this information:. .. code-block:: python. import qutip; qutip.about(); ",MatchSource.DOCS,doc/installation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:11889,Deployability,install,installed,11889,"nt::. In order to prevent issues with the ``PATH`` environment variable not containing the compiler and associated libraries, it is recommended to use the developer command prompt in the Visual Studio installation folder instead of the built-in command prompt. The Community edition of Visual Studio takes around 10GB of disk space.; If this is prohibitive for you, it is also possible to install `only the build tools and necessary SDKs <https://visualstudio.microsoft.com/visual-cpp-build-tools/>`_ instead, which should save about 2GB of space. .. _install-verify:. Verifying the Installation; ==========================. QuTiP includes a collection of built-in test scripts to verify that an installation was successful.; To run the suite of tests scripts you must also have the ``pytest`` testing library.; After installing QuTiP, leave the installation directory and call:. .. code-block:: bash. pytest qutip/qutip/tests. This will take between 10 and 30 minutes, depending on your computer.; At the end, the testing report should report a success; it is normal for some tests to be skipped, and for some to be marked ""xfail"" in yellow.; Skips may be tests that do not run on your operating system, or tests of optional components that you have not installed the dependencies for.; If any failures or errors occur, please check that you have installed all of the required modules.; See the next section on how to check the installed versions of the QuTiP dependencies.; If these tests still fail, then head on over to the `QuTiP Discussion Board <https://groups.google.com/g/qutip>`_ or `the GitHub issues page <https://github.com/qutip/qutip/issues>`_ and post a message detailing your particular issue. .. _install-about:. Checking Version Information; ============================. QuTiP includes an ""about"" function for viewing information about QuTiP and the important dependencies installed on your system.; To view this information:. .. code-block:: python. import qutip; qutip.about(); ",MatchSource.DOCS,doc/installation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:11970,Deployability,install,installed,11970,"nt::. In order to prevent issues with the ``PATH`` environment variable not containing the compiler and associated libraries, it is recommended to use the developer command prompt in the Visual Studio installation folder instead of the built-in command prompt. The Community edition of Visual Studio takes around 10GB of disk space.; If this is prohibitive for you, it is also possible to install `only the build tools and necessary SDKs <https://visualstudio.microsoft.com/visual-cpp-build-tools/>`_ instead, which should save about 2GB of space. .. _install-verify:. Verifying the Installation; ==========================. QuTiP includes a collection of built-in test scripts to verify that an installation was successful.; To run the suite of tests scripts you must also have the ``pytest`` testing library.; After installing QuTiP, leave the installation directory and call:. .. code-block:: bash. pytest qutip/qutip/tests. This will take between 10 and 30 minutes, depending on your computer.; At the end, the testing report should report a success; it is normal for some tests to be skipped, and for some to be marked ""xfail"" in yellow.; Skips may be tests that do not run on your operating system, or tests of optional components that you have not installed the dependencies for.; If any failures or errors occur, please check that you have installed all of the required modules.; See the next section on how to check the installed versions of the QuTiP dependencies.; If these tests still fail, then head on over to the `QuTiP Discussion Board <https://groups.google.com/g/qutip>`_ or `the GitHub issues page <https://github.com/qutip/qutip/issues>`_ and post a message detailing your particular issue. .. _install-about:. Checking Version Information; ============================. QuTiP includes an ""about"" function for viewing information about QuTiP and the important dependencies installed on your system.; To view this information:. .. code-block:: python. import qutip; qutip.about(); ",MatchSource.DOCS,doc/installation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:12434,Deployability,install,installed,12434,"nt::. In order to prevent issues with the ``PATH`` environment variable not containing the compiler and associated libraries, it is recommended to use the developer command prompt in the Visual Studio installation folder instead of the built-in command prompt. The Community edition of Visual Studio takes around 10GB of disk space.; If this is prohibitive for you, it is also possible to install `only the build tools and necessary SDKs <https://visualstudio.microsoft.com/visual-cpp-build-tools/>`_ instead, which should save about 2GB of space. .. _install-verify:. Verifying the Installation; ==========================. QuTiP includes a collection of built-in test scripts to verify that an installation was successful.; To run the suite of tests scripts you must also have the ``pytest`` testing library.; After installing QuTiP, leave the installation directory and call:. .. code-block:: bash. pytest qutip/qutip/tests. This will take between 10 and 30 minutes, depending on your computer.; At the end, the testing report should report a success; it is normal for some tests to be skipped, and for some to be marked ""xfail"" in yellow.; Skips may be tests that do not run on your operating system, or tests of optional components that you have not installed the dependencies for.; If any failures or errors occur, please check that you have installed all of the required modules.; See the next section on how to check the installed versions of the QuTiP dependencies.; If these tests still fail, then head on over to the `QuTiP Discussion Board <https://groups.google.com/g/qutip>`_ or `the GitHub issues page <https://github.com/qutip/qutip/issues>`_ and post a message detailing your particular issue. .. _install-about:. Checking Version Information; ============================. QuTiP includes an ""about"" function for viewing information about QuTiP and the important dependencies installed on your system.; To view this information:. .. code-block:: python. import qutip; qutip.about(); ",MatchSource.DOCS,doc/installation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:752,Integrability,depend,dependencies,752,".. This file can be edited using retext 6.1 https://github.com/retext-project/retext. .. _install:. **************; Installation; **************. .. _quick-start:. Quick Start; ===========. From QuTiP version 4.6 onwards, you should be able to get a working version of QuTiP with the standard. .. code-block:: bash. pip install qutip. It is not recommended to install any packages directly into the system Python environment; consider using ``pip`` or ``conda`` virtual environments to keep your operating system space clean, and to have more control over Python and other package versions. You do not need to worry about the details on the rest of this page unless this command did not work, but do also read the next section for the list of optional dependencies.; The rest of this page covers `installation directly from conda <install-with-conda_>`_, `installation from source <install-from-source_>`_, and `additional considerations when working on Windows <install-on-windows_>`_. .. _install-requires:. General Requirements; =====================. QuTiP depends on several open-source libraries for scientific computing in the Python programming language.; The following packages are currently required:. .. cssclass:: table-striped. +----------------+--------------+-----------------------------------------------------+; | Package | Version | Details |; +================+==============+=====================================================+; | **Python** | 3.9+ | 3.6+ for version 4.7 |; +----------------+--------------+-----------------------------------------------------+; | **NumPy** | 1.22+ <2.0 | 1.16+ for version 4.7 |; +----------------+--------------+-----------------------------------------------------+; | **SciPy** | 1.8+ | 1.0+ for version 4.7 |; +----------------+--------------+-----------------------------------------------------+. In addition, there are several optional packages that provide additional functionality:. .. cssclass:: table-striped. +--------------------",MatchSource.DOCS,doc/installation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:1061,Integrability,depend,depends,1061,"******; Installation; **************. .. _quick-start:. Quick Start; ===========. From QuTiP version 4.6 onwards, you should be able to get a working version of QuTiP with the standard. .. code-block:: bash. pip install qutip. It is not recommended to install any packages directly into the system Python environment; consider using ``pip`` or ``conda`` virtual environments to keep your operating system space clean, and to have more control over Python and other package versions. You do not need to worry about the details on the rest of this page unless this command did not work, but do also read the next section for the list of optional dependencies.; The rest of this page covers `installation directly from conda <install-with-conda_>`_, `installation from source <install-from-source_>`_, and `additional considerations when working on Windows <install-on-windows_>`_. .. _install-requires:. General Requirements; =====================. QuTiP depends on several open-source libraries for scientific computing in the Python programming language.; The following packages are currently required:. .. cssclass:: table-striped. +----------------+--------------+-----------------------------------------------------+; | Package | Version | Details |; +================+==============+=====================================================+; | **Python** | 3.9+ | 3.6+ for version 4.7 |; +----------------+--------------+-----------------------------------------------------+; | **NumPy** | 1.22+ <2.0 | 1.16+ for version 4.7 |; +----------------+--------------+-----------------------------------------------------+; | **SciPy** | 1.8+ | 1.0+ for version 4.7 |; +----------------+--------------+-----------------------------------------------------+. In addition, there are several optional packages that provide additional functionality:. .. cssclass:: table-striped. +--------------------------+--------------+-----------------------------------------------------+; | Package | Version | Details",MatchSource.DOCS,doc/installation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:2434,Integrability,depend,dependent,2434,"==========+; | **Python** | 3.9+ | 3.6+ for version 4.7 |; +----------------+--------------+-----------------------------------------------------+; | **NumPy** | 1.22+ <2.0 | 1.16+ for version 4.7 |; +----------------+--------------+-----------------------------------------------------+; | **SciPy** | 1.8+ | 1.0+ for version 4.7 |; +----------------+--------------+-----------------------------------------------------+. In addition, there are several optional packages that provide additional functionality:. .. cssclass:: table-striped. +--------------------------+--------------+-----------------------------------------------------+; | Package | Version | Details |; +==========================+==============+=====================================================+; | ``matplotlib`` | 1.2.1+ | Needed for all visualisation tasks. |; +--------------------------+--------------+-----------------------------------------------------+; | ``cython`` | 0.29.20+ | Needed for compiling some time-dependent |; | ``setuptools`` | | Hamiltonians. Cython needs a working C++ compiler. |; | ``filelock`` | | |; +--------------------------+--------------+-----------------------------------------------------+; | ``cvxpy`` | 1.0+ | Needed to calculate diamond norms. |; +--------------------------+--------------+-----------------------------------------------------+; | ``pytest``, | 5.3+ | For running the test suite. |; | ``pytest-rerunfailures`` | | |; +--------------------------+--------------+-----------------------------------------------------+; | LaTeX | TeXLive 2009+| Needed if using LaTeX in matplotlib figures, or for |; | | | nice circuit drawings in IPython. |; +--------------------------+--------------+-----------------------------------------------------+; | ``loky``, ``mpi4py`` | | Extra parallel map back-ends. |; +--------------------------+--------------+-----------------------------------------------------+; | ``tqdm`` | | Extra progress bars back-end. |; +---------------------",MatchSource.DOCS,doc/installation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:3580,Integrability,depend,dependencies,3580,"-------+-----------------------------------------------------+; | ``cvxpy`` | 1.0+ | Needed to calculate diamond norms. |; +--------------------------+--------------+-----------------------------------------------------+; | ``pytest``, | 5.3+ | For running the test suite. |; | ``pytest-rerunfailures`` | | |; +--------------------------+--------------+-----------------------------------------------------+; | LaTeX | TeXLive 2009+| Needed if using LaTeX in matplotlib figures, or for |; | | | nice circuit drawings in IPython. |; +--------------------------+--------------+-----------------------------------------------------+; | ``loky``, ``mpi4py`` | | Extra parallel map back-ends. |; +--------------------------+--------------+-----------------------------------------------------+; | ``tqdm`` | | Extra progress bars back-end. |; +--------------------------+--------------+-----------------------------------------------------+. In addition, there are several additional packages that are not dependencies, but may give you a better programming experience.; `IPython <https://ipython.org/>`_ provides an improved text-based Python interpreter that is far more full-featured that the default interpreter, and runs in a terminal.; If you prefer a more graphical set-up, `Jupyter <https://jupyter.org/>`_ provides a notebook-style interface to mix code and mathematical notes together.; Alternatively, `Spyder <https://www.spyder-ide.org/>`_ is a free integrated development environment for Python, with several nice features for debugging code.; QuTiP will detect if it is being used within one of these richer environments, and various outputs will have enhanced formatting. .. _install-with-conda:. Installing with conda; =====================. If you already have your conda environment set up, and have the ``conda-forge`` channel available, then you can install QuTiP using:. .. code-block:: bash. conda install qutip. This will install the minimum set of dependences, but none of the opti",MatchSource.DOCS,doc/installation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:3915,Integrability,interface,interface,3915,"------+-----------------------------------------------------+; | LaTeX | TeXLive 2009+| Needed if using LaTeX in matplotlib figures, or for |; | | | nice circuit drawings in IPython. |; +--------------------------+--------------+-----------------------------------------------------+; | ``loky``, ``mpi4py`` | | Extra parallel map back-ends. |; +--------------------------+--------------+-----------------------------------------------------+; | ``tqdm`` | | Extra progress bars back-end. |; +--------------------------+--------------+-----------------------------------------------------+. In addition, there are several additional packages that are not dependencies, but may give you a better programming experience.; `IPython <https://ipython.org/>`_ provides an improved text-based Python interpreter that is far more full-featured that the default interpreter, and runs in a terminal.; If you prefer a more graphical set-up, `Jupyter <https://jupyter.org/>`_ provides a notebook-style interface to mix code and mathematical notes together.; Alternatively, `Spyder <https://www.spyder-ide.org/>`_ is a free integrated development environment for Python, with several nice features for debugging code.; QuTiP will detect if it is being used within one of these richer environments, and various outputs will have enhanced formatting. .. _install-with-conda:. Installing with conda; =====================. If you already have your conda environment set up, and have the ``conda-forge`` channel available, then you can install QuTiP using:. .. code-block:: bash. conda install qutip. This will install the minimum set of dependences, but none of the optional packages. .. _adding-conda-forge:. Adding the conda-forge channel; ------------------------------. To install QuTiP from conda, you will need to add the conda-forge channel.; The following command adds this channel with lowest priority, so conda will still try and install all other packages normally:. .. code-block:: bash. conda config --a",MatchSource.DOCS,doc/installation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:4036,Integrability,integrat,integrated,4036," nice circuit drawings in IPython. |; +--------------------------+--------------+-----------------------------------------------------+; | ``loky``, ``mpi4py`` | | Extra parallel map back-ends. |; +--------------------------+--------------+-----------------------------------------------------+; | ``tqdm`` | | Extra progress bars back-end. |; +--------------------------+--------------+-----------------------------------------------------+. In addition, there are several additional packages that are not dependencies, but may give you a better programming experience.; `IPython <https://ipython.org/>`_ provides an improved text-based Python interpreter that is far more full-featured that the default interpreter, and runs in a terminal.; If you prefer a more graphical set-up, `Jupyter <https://jupyter.org/>`_ provides a notebook-style interface to mix code and mathematical notes together.; Alternatively, `Spyder <https://www.spyder-ide.org/>`_ is a free integrated development environment for Python, with several nice features for debugging code.; QuTiP will detect if it is being used within one of these richer environments, and various outputs will have enhanced formatting. .. _install-with-conda:. Installing with conda; =====================. If you already have your conda environment set up, and have the ``conda-forge`` channel available, then you can install QuTiP using:. .. code-block:: bash. conda install qutip. This will install the minimum set of dependences, but none of the optional packages. .. _adding-conda-forge:. Adding the conda-forge channel; ------------------------------. To install QuTiP from conda, you will need to add the conda-forge channel.; The following command adds this channel with lowest priority, so conda will still try and install all other packages normally:. .. code-block:: bash. conda config --append channels conda-forge. If you want to change the order of your channels later, you can edit your ``.condarc`` (user home folder) file manually, ",MatchSource.DOCS,doc/installation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:4546,Integrability,depend,dependences,4546,"itional packages that are not dependencies, but may give you a better programming experience.; `IPython <https://ipython.org/>`_ provides an improved text-based Python interpreter that is far more full-featured that the default interpreter, and runs in a terminal.; If you prefer a more graphical set-up, `Jupyter <https://jupyter.org/>`_ provides a notebook-style interface to mix code and mathematical notes together.; Alternatively, `Spyder <https://www.spyder-ide.org/>`_ is a free integrated development environment for Python, with several nice features for debugging code.; QuTiP will detect if it is being used within one of these richer environments, and various outputs will have enhanced formatting. .. _install-with-conda:. Installing with conda; =====================. If you already have your conda environment set up, and have the ``conda-forge`` channel available, then you can install QuTiP using:. .. code-block:: bash. conda install qutip. This will install the minimum set of dependences, but none of the optional packages. .. _adding-conda-forge:. Adding the conda-forge channel; ------------------------------. To install QuTiP from conda, you will need to add the conda-forge channel.; The following command adds this channel with lowest priority, so conda will still try and install all other packages normally:. .. code-block:: bash. conda config --append channels conda-forge. If you want to change the order of your channels later, you can edit your ``.condarc`` (user home folder) file manually, but it is recommended to keep ``defaults`` as the highest priority. .. _building-conda-environment:. New conda environments; ----------------------. The default Anaconda environment has all the Python packages needed for running QuTiP installed already, so you will only need to add the ``conda-forge`` channel and then install the package.; If you have only installed Miniconda, or you want a completely clean virtual environment to install QuTiP in, the ``conda`` package man",MatchSource.DOCS,doc/installation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:7070,Integrability,depend,dependencies,7070,"=============. Official releases of QuTiP are available from the download section on `the project's web pages <https://qutip.org/download.html>`_, and the latest source code is available in `our GitHub repository <https://github.com/qutip/qutip>`_.; In general we recommend users to use the latest stable release of QuTiP, but if you are interested in helping us out with development or wish to submit bug fixes, then use the latest development version from the GitHub repository. You can install from source by using the `Python-recommended PEP 517 procedure <build-pep517_>`_, or if you want more control or to have a development version, you can use the `low-level build procedure with setuptools <build-setuptools_>`_. .. _build-pep517:. PEP 517 Source Builds; ---------------------. The easiest way to build QuTiP from source is to use a PEP-517-compatible builder such as the ``build`` package available on ``pip``.; These will automatically install all build dependencies for you, and the ``pip`` installation step afterwards will install the minimum runtime dependencies.; You can do this by doing (for example). .. code-block:: bash. pip install build; python -m build <path to qutip>; pip install <path to qutip>/dist/qutip-<version>.whl. The first command installs the reference PEP-517 build tool, the second effects the build and the third uses ``pip`` to install the built package.; You will need to replace ``<path to qutip>`` with the actual path to the QuTiP source code.; The string ``<version>`` will depend on the version of QuTiP, the version of Python and your operating system.; It will look something like ``4.6.0-cp39-cp39-manylinux1_x86_64``, but there should only be one ``.whl`` file in the ``dist/`` directory, which will be the correct one. .. _build-setuptools:. Direct Setuptools Source Builds; -------------------------------. This is the method to have the greatest amount of control over the installation, but it the most error-prone and not recommended unless you ",MatchSource.DOCS,doc/installation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:7170,Integrability,depend,dependencies,7170,"=============. Official releases of QuTiP are available from the download section on `the project's web pages <https://qutip.org/download.html>`_, and the latest source code is available in `our GitHub repository <https://github.com/qutip/qutip>`_.; In general we recommend users to use the latest stable release of QuTiP, but if you are interested in helping us out with development or wish to submit bug fixes, then use the latest development version from the GitHub repository. You can install from source by using the `Python-recommended PEP 517 procedure <build-pep517_>`_, or if you want more control or to have a development version, you can use the `low-level build procedure with setuptools <build-setuptools_>`_. .. _build-pep517:. PEP 517 Source Builds; ---------------------. The easiest way to build QuTiP from source is to use a PEP-517-compatible builder such as the ``build`` package available on ``pip``.; These will automatically install all build dependencies for you, and the ``pip`` installation step afterwards will install the minimum runtime dependencies.; You can do this by doing (for example). .. code-block:: bash. pip install build; python -m build <path to qutip>; pip install <path to qutip>/dist/qutip-<version>.whl. The first command installs the reference PEP-517 build tool, the second effects the build and the third uses ``pip`` to install the built package.; You will need to replace ``<path to qutip>`` with the actual path to the QuTiP source code.; The string ``<version>`` will depend on the version of QuTiP, the version of Python and your operating system.; It will look something like ``4.6.0-cp39-cp39-manylinux1_x86_64``, but there should only be one ``.whl`` file in the ``dist/`` directory, which will be the correct one. .. _build-setuptools:. Direct Setuptools Source Builds; -------------------------------. This is the method to have the greatest amount of control over the installation, but it the most error-prone and not recommended unless you ",MatchSource.DOCS,doc/installation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:7624,Integrability,depend,depend,7624,"P 517 procedure <build-pep517_>`_, or if you want more control or to have a development version, you can use the `low-level build procedure with setuptools <build-setuptools_>`_. .. _build-pep517:. PEP 517 Source Builds; ---------------------. The easiest way to build QuTiP from source is to use a PEP-517-compatible builder such as the ``build`` package available on ``pip``.; These will automatically install all build dependencies for you, and the ``pip`` installation step afterwards will install the minimum runtime dependencies.; You can do this by doing (for example). .. code-block:: bash. pip install build; python -m build <path to qutip>; pip install <path to qutip>/dist/qutip-<version>.whl. The first command installs the reference PEP-517 build tool, the second effects the build and the third uses ``pip`` to install the built package.; You will need to replace ``<path to qutip>`` with the actual path to the QuTiP source code.; The string ``<version>`` will depend on the version of QuTiP, the version of Python and your operating system.; It will look something like ``4.6.0-cp39-cp39-manylinux1_x86_64``, but there should only be one ``.whl`` file in the ``dist/`` directory, which will be the correct one. .. _build-setuptools:. Direct Setuptools Source Builds; -------------------------------. This is the method to have the greatest amount of control over the installation, but it the most error-prone and not recommended unless you know what you are doing.; You first need to have all the runtime dependencies installed.; The most up-to-date requirements will be listed in ``pyproject.toml`` file, in the ``build-system.requires`` key.; As of the 5.0.0 release, the build requirements can be installed with. .. code-block:: bash. pip install setuptools wheel packaging cython 'numpy<2.0.0' scipy. or similar with ``conda`` if you prefer.; You will also need to have a functional C++ compiler installed on your system.; This is likely already done for you if you are on Linux o",MatchSource.DOCS,doc/installation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:8169,Integrability,depend,dependencies,8169,"m runtime dependencies.; You can do this by doing (for example). .. code-block:: bash. pip install build; python -m build <path to qutip>; pip install <path to qutip>/dist/qutip-<version>.whl. The first command installs the reference PEP-517 build tool, the second effects the build and the third uses ``pip`` to install the built package.; You will need to replace ``<path to qutip>`` with the actual path to the QuTiP source code.; The string ``<version>`` will depend on the version of QuTiP, the version of Python and your operating system.; It will look something like ``4.6.0-cp39-cp39-manylinux1_x86_64``, but there should only be one ``.whl`` file in the ``dist/`` directory, which will be the correct one. .. _build-setuptools:. Direct Setuptools Source Builds; -------------------------------. This is the method to have the greatest amount of control over the installation, but it the most error-prone and not recommended unless you know what you are doing.; You first need to have all the runtime dependencies installed.; The most up-to-date requirements will be listed in ``pyproject.toml`` file, in the ``build-system.requires`` key.; As of the 5.0.0 release, the build requirements can be installed with. .. code-block:: bash. pip install setuptools wheel packaging cython 'numpy<2.0.0' scipy. or similar with ``conda`` if you prefer.; You will also need to have a functional C++ compiler installed on your system.; This is likely already done for you if you are on Linux or macOS, but see the `section on Windows installations <install-on-windows_>`_ if that is your operating system. To install QuTiP from the source code run:. .. code-block:: bash. pip install . If you wish to contribute to the QuTiP project, then you will want to create your own fork of `the QuTiP git repository <https://github.com/qutip/qutip>`_, clone this to a local folder, and install it into your Python environment using:. .. code-block:: bash. python setup.py develop. When you do ``import qutip`` in th",MatchSource.DOCS,doc/installation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:11511,Integrability,depend,depending,11511,"urce_>`_ section as normal. .. important::. In order to prevent issues with the ``PATH`` environment variable not containing the compiler and associated libraries, it is recommended to use the developer command prompt in the Visual Studio installation folder instead of the built-in command prompt. The Community edition of Visual Studio takes around 10GB of disk space.; If this is prohibitive for you, it is also possible to install `only the build tools and necessary SDKs <https://visualstudio.microsoft.com/visual-cpp-build-tools/>`_ instead, which should save about 2GB of space. .. _install-verify:. Verifying the Installation; ==========================. QuTiP includes a collection of built-in test scripts to verify that an installation was successful.; To run the suite of tests scripts you must also have the ``pytest`` testing library.; After installing QuTiP, leave the installation directory and call:. .. code-block:: bash. pytest qutip/qutip/tests. This will take between 10 and 30 minutes, depending on your computer.; At the end, the testing report should report a success; it is normal for some tests to be skipped, and for some to be marked ""xfail"" in yellow.; Skips may be tests that do not run on your operating system, or tests of optional components that you have not installed the dependencies for.; If any failures or errors occur, please check that you have installed all of the required modules.; See the next section on how to check the installed versions of the QuTiP dependencies.; If these tests still fail, then head on over to the `QuTiP Discussion Board <https://groups.google.com/g/qutip>`_ or `the GitHub issues page <https://github.com/qutip/qutip/issues>`_ and post a message detailing your particular issue. .. _install-about:. Checking Version Information; ============================. QuTiP includes an ""about"" function for viewing information about QuTiP and the important dependencies installed on your system.; To view this information:. .. code-block::",MatchSource.DOCS,doc/installation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:11810,Integrability,depend,dependencies,11810,"nt::. In order to prevent issues with the ``PATH`` environment variable not containing the compiler and associated libraries, it is recommended to use the developer command prompt in the Visual Studio installation folder instead of the built-in command prompt. The Community edition of Visual Studio takes around 10GB of disk space.; If this is prohibitive for you, it is also possible to install `only the build tools and necessary SDKs <https://visualstudio.microsoft.com/visual-cpp-build-tools/>`_ instead, which should save about 2GB of space. .. _install-verify:. Verifying the Installation; ==========================. QuTiP includes a collection of built-in test scripts to verify that an installation was successful.; To run the suite of tests scripts you must also have the ``pytest`` testing library.; After installing QuTiP, leave the installation directory and call:. .. code-block:: bash. pytest qutip/qutip/tests. This will take between 10 and 30 minutes, depending on your computer.; At the end, the testing report should report a success; it is normal for some tests to be skipped, and for some to be marked ""xfail"" in yellow.; Skips may be tests that do not run on your operating system, or tests of optional components that you have not installed the dependencies for.; If any failures or errors occur, please check that you have installed all of the required modules.; See the next section on how to check the installed versions of the QuTiP dependencies.; If these tests still fail, then head on over to the `QuTiP Discussion Board <https://groups.google.com/g/qutip>`_ or `the GitHub issues page <https://github.com/qutip/qutip/issues>`_ and post a message detailing your particular issue. .. _install-about:. Checking Version Information; ============================. QuTiP includes an ""about"" function for viewing information about QuTiP and the important dependencies installed on your system.; To view this information:. .. code-block:: python. import qutip; qutip.about(); ",MatchSource.DOCS,doc/installation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:12002,Integrability,depend,dependencies,12002,"nt::. In order to prevent issues with the ``PATH`` environment variable not containing the compiler and associated libraries, it is recommended to use the developer command prompt in the Visual Studio installation folder instead of the built-in command prompt. The Community edition of Visual Studio takes around 10GB of disk space.; If this is prohibitive for you, it is also possible to install `only the build tools and necessary SDKs <https://visualstudio.microsoft.com/visual-cpp-build-tools/>`_ instead, which should save about 2GB of space. .. _install-verify:. Verifying the Installation; ==========================. QuTiP includes a collection of built-in test scripts to verify that an installation was successful.; To run the suite of tests scripts you must also have the ``pytest`` testing library.; After installing QuTiP, leave the installation directory and call:. .. code-block:: bash. pytest qutip/qutip/tests. This will take between 10 and 30 minutes, depending on your computer.; At the end, the testing report should report a success; it is normal for some tests to be skipped, and for some to be marked ""xfail"" in yellow.; Skips may be tests that do not run on your operating system, or tests of optional components that you have not installed the dependencies for.; If any failures or errors occur, please check that you have installed all of the required modules.; See the next section on how to check the installed versions of the QuTiP dependencies.; If these tests still fail, then head on over to the `QuTiP Discussion Board <https://groups.google.com/g/qutip>`_ or `the GitHub issues page <https://github.com/qutip/qutip/issues>`_ and post a message detailing your particular issue. .. _install-about:. Checking Version Information; ============================. QuTiP includes an ""about"" function for viewing information about QuTiP and the important dependencies installed on your system.; To view this information:. .. code-block:: python. import qutip; qutip.about(); ",MatchSource.DOCS,doc/installation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:12211,Integrability,message,message,12211,"nt::. In order to prevent issues with the ``PATH`` environment variable not containing the compiler and associated libraries, it is recommended to use the developer command prompt in the Visual Studio installation folder instead of the built-in command prompt. The Community edition of Visual Studio takes around 10GB of disk space.; If this is prohibitive for you, it is also possible to install `only the build tools and necessary SDKs <https://visualstudio.microsoft.com/visual-cpp-build-tools/>`_ instead, which should save about 2GB of space. .. _install-verify:. Verifying the Installation; ==========================. QuTiP includes a collection of built-in test scripts to verify that an installation was successful.; To run the suite of tests scripts you must also have the ``pytest`` testing library.; After installing QuTiP, leave the installation directory and call:. .. code-block:: bash. pytest qutip/qutip/tests. This will take between 10 and 30 minutes, depending on your computer.; At the end, the testing report should report a success; it is normal for some tests to be skipped, and for some to be marked ""xfail"" in yellow.; Skips may be tests that do not run on your operating system, or tests of optional components that you have not installed the dependencies for.; If any failures or errors occur, please check that you have installed all of the required modules.; See the next section on how to check the installed versions of the QuTiP dependencies.; If these tests still fail, then head on over to the `QuTiP Discussion Board <https://groups.google.com/g/qutip>`_ or `the GitHub issues page <https://github.com/qutip/qutip/issues>`_ and post a message detailing your particular issue. .. _install-about:. Checking Version Information; ============================. QuTiP includes an ""about"" function for viewing information about QuTiP and the important dependencies installed on your system.; To view this information:. .. code-block:: python. import qutip; qutip.about(); ",MatchSource.DOCS,doc/installation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:12421,Integrability,depend,dependencies,12421,"nt::. In order to prevent issues with the ``PATH`` environment variable not containing the compiler and associated libraries, it is recommended to use the developer command prompt in the Visual Studio installation folder instead of the built-in command prompt. The Community edition of Visual Studio takes around 10GB of disk space.; If this is prohibitive for you, it is also possible to install `only the build tools and necessary SDKs <https://visualstudio.microsoft.com/visual-cpp-build-tools/>`_ instead, which should save about 2GB of space. .. _install-verify:. Verifying the Installation; ==========================. QuTiP includes a collection of built-in test scripts to verify that an installation was successful.; To run the suite of tests scripts you must also have the ``pytest`` testing library.; After installing QuTiP, leave the installation directory and call:. .. code-block:: bash. pytest qutip/qutip/tests. This will take between 10 and 30 minutes, depending on your computer.; At the end, the testing report should report a success; it is normal for some tests to be skipped, and for some to be marked ""xfail"" in yellow.; Skips may be tests that do not run on your operating system, or tests of optional components that you have not installed the dependencies for.; If any failures or errors occur, please check that you have installed all of the required modules.; See the next section on how to check the installed versions of the QuTiP dependencies.; If these tests still fail, then head on over to the `QuTiP Discussion Board <https://groups.google.com/g/qutip>`_ or `the GitHub issues page <https://github.com/qutip/qutip/issues>`_ and post a message detailing your particular issue. .. _install-about:. Checking Version Information; ============================. QuTiP includes an ""about"" function for viewing information about QuTiP and the important dependencies installed on your system.; To view this information:. .. code-block:: python. import qutip; qutip.about(); ",MatchSource.DOCS,doc/installation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:4240,Modifiability,enhance,enhanced,4240,"-------------+; | ``loky``, ``mpi4py`` | | Extra parallel map back-ends. |; +--------------------------+--------------+-----------------------------------------------------+; | ``tqdm`` | | Extra progress bars back-end. |; +--------------------------+--------------+-----------------------------------------------------+. In addition, there are several additional packages that are not dependencies, but may give you a better programming experience.; `IPython <https://ipython.org/>`_ provides an improved text-based Python interpreter that is far more full-featured that the default interpreter, and runs in a terminal.; If you prefer a more graphical set-up, `Jupyter <https://jupyter.org/>`_ provides a notebook-style interface to mix code and mathematical notes together.; Alternatively, `Spyder <https://www.spyder-ide.org/>`_ is a free integrated development environment for Python, with several nice features for debugging code.; QuTiP will detect if it is being used within one of these richer environments, and various outputs will have enhanced formatting. .. _install-with-conda:. Installing with conda; =====================. If you already have your conda environment set up, and have the ``conda-forge`` channel available, then you can install QuTiP using:. .. code-block:: bash. conda install qutip. This will install the minimum set of dependences, but none of the optional packages. .. _adding-conda-forge:. Adding the conda-forge channel; ------------------------------. To install QuTiP from conda, you will need to add the conda-forge channel.; The following command adds this channel with lowest priority, so conda will still try and install all other packages normally:. .. code-block:: bash. conda config --append channels conda-forge. If you want to change the order of your channels later, you can edit your ``.condarc`` (user home folder) file manually, but it is recommended to keep ``defaults`` as the highest priority. .. _building-conda-environment:. New conda environmen",MatchSource.DOCS,doc/installation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:4915,Modifiability,config,config,4915,"x code and mathematical notes together.; Alternatively, `Spyder <https://www.spyder-ide.org/>`_ is a free integrated development environment for Python, with several nice features for debugging code.; QuTiP will detect if it is being used within one of these richer environments, and various outputs will have enhanced formatting. .. _install-with-conda:. Installing with conda; =====================. If you already have your conda environment set up, and have the ``conda-forge`` channel available, then you can install QuTiP using:. .. code-block:: bash. conda install qutip. This will install the minimum set of dependences, but none of the optional packages. .. _adding-conda-forge:. Adding the conda-forge channel; ------------------------------. To install QuTiP from conda, you will need to add the conda-forge channel.; The following command adds this channel with lowest priority, so conda will still try and install all other packages normally:. .. code-block:: bash. conda config --append channels conda-forge. If you want to change the order of your channels later, you can edit your ``.condarc`` (user home folder) file manually, but it is recommended to keep ``defaults`` as the highest priority. .. _building-conda-environment:. New conda environments; ----------------------. The default Anaconda environment has all the Python packages needed for running QuTiP installed already, so you will only need to add the ``conda-forge`` channel and then install the package.; If you have only installed Miniconda, or you want a completely clean virtual environment to install QuTiP in, the ``conda`` package manager provides a convenient way to do this. To create a conda environment for QuTiP called ``qutip-env``:. .. code-block:: bash. conda create -n qutip-env python qutip. This will automatically install all the necessary packages, and none of the optional packages.; You activate the new environment by running. .. code-block:: bash. conda activate qutip-env. You can also install a",MatchSource.DOCS,doc/installation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:10604,Modifiability,variab,variable,10604,"he system Python environment instead. .. _install-on-windows:. Installation on Windows; =======================. As with other operating systems, the easiest method is to use ``pip install qutip``, or use the ``conda`` procedure described above.; If you want to build from source or use runtime compilation with Cython, you will need to have a working C++ compiler. You can `download the Visual Studio IDE from Microsoft <https://visualstudio.microsoft.com/downloads/>`_, which has a free Community edition containing a sufficient C++ compiler.; This is the recommended compiler toolchain on Windows.; When installing, be sure to select the following components:. - Windows ""X"" SDK (where ""X"" stands for your version: 7/8/8.1/10); - Visual Studio C++ build tools. You can then follow the `installation from source <install-from-source_>`_ section as normal. .. important::. In order to prevent issues with the ``PATH`` environment variable not containing the compiler and associated libraries, it is recommended to use the developer command prompt in the Visual Studio installation folder instead of the built-in command prompt. The Community edition of Visual Studio takes around 10GB of disk space.; If this is prohibitive for you, it is also possible to install `only the build tools and necessary SDKs <https://visualstudio.microsoft.com/visual-cpp-build-tools/>`_ instead, which should save about 2GB of space. .. _install-verify:. Verifying the Installation; ==========================. QuTiP includes a collection of built-in test scripts to verify that an installation was successful.; To run the suite of tests scripts you must also have the ``pytest`` testing library.; After installing QuTiP, leave the installation directory and call:. .. code-block:: bash. pytest qutip/qutip/tests. This will take between 10 and 30 minutes, depending on your computer.; At the end, the testing report should report a success; it is normal for some tests to be skipped, and for some to be marked ""xfail"" i",MatchSource.DOCS,doc/installation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:9190,Performance,load,load,9190,".toml`` file, in the ``build-system.requires`` key.; As of the 5.0.0 release, the build requirements can be installed with. .. code-block:: bash. pip install setuptools wheel packaging cython 'numpy<2.0.0' scipy. or similar with ``conda`` if you prefer.; You will also need to have a functional C++ compiler installed on your system.; This is likely already done for you if you are on Linux or macOS, but see the `section on Windows installations <install-on-windows_>`_ if that is your operating system. To install QuTiP from the source code run:. .. code-block:: bash. pip install . If you wish to contribute to the QuTiP project, then you will want to create your own fork of `the QuTiP git repository <https://github.com/qutip/qutip>`_, clone this to a local folder, and install it into your Python environment using:. .. code-block:: bash. python setup.py develop. When you do ``import qutip`` in this environment, you will then load the code from your local fork, enabling you to edit the Python files and have the changes immediately available when you restart your Python interpreter, without needing to rebuild the package.; Note that if you change any Cython files, you will need to rerun the build command. You should not need to use ``sudo`` (or other superuser privileges) to install into a personal virtual environment; if it feels like you need it, there is a good chance that you are installing into the system Python environment instead. .. _install-on-windows:. Installation on Windows; =======================. As with other operating systems, the easiest method is to use ``pip install qutip``, or use the ``conda`` procedure described above.; If you want to build from source or use runtime compilation with Cython, you will need to have a working C++ compiler. You can `download the Visual Studio IDE from Microsoft <https://visualstudio.microsoft.com/downloads/>`_, which has a free Community edition containing a sufficient C++ compiler.; This is the recommended compiler toolc",MatchSource.DOCS,doc/installation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:4142,Safety,detect,detect,4142,"-------------+; | ``loky``, ``mpi4py`` | | Extra parallel map back-ends. |; +--------------------------+--------------+-----------------------------------------------------+; | ``tqdm`` | | Extra progress bars back-end. |; +--------------------------+--------------+-----------------------------------------------------+. In addition, there are several additional packages that are not dependencies, but may give you a better programming experience.; `IPython <https://ipython.org/>`_ provides an improved text-based Python interpreter that is far more full-featured that the default interpreter, and runs in a terminal.; If you prefer a more graphical set-up, `Jupyter <https://jupyter.org/>`_ provides a notebook-style interface to mix code and mathematical notes together.; Alternatively, `Spyder <https://www.spyder-ide.org/>`_ is a free integrated development environment for Python, with several nice features for debugging code.; QuTiP will detect if it is being used within one of these richer environments, and various outputs will have enhanced formatting. .. _install-with-conda:. Installing with conda; =====================. If you already have your conda environment set up, and have the ``conda-forge`` channel available, then you can install QuTiP using:. .. code-block:: bash. conda install qutip. This will install the minimum set of dependences, but none of the optional packages. .. _adding-conda-forge:. Adding the conda-forge channel; ------------------------------. To install QuTiP from conda, you will need to add the conda-forge channel.; The following command adds this channel with lowest priority, so conda will still try and install all other packages normally:. .. code-block:: bash. conda config --append channels conda-forge. If you want to change the order of your channels later, you can edit your ``.condarc`` (user home folder) file manually, but it is recommended to keep ``defaults`` as the highest priority. .. _building-conda-environment:. New conda environmen",MatchSource.DOCS,doc/installation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:2840,Testability,test,test,2840,"------------------------+. In addition, there are several optional packages that provide additional functionality:. .. cssclass:: table-striped. +--------------------------+--------------+-----------------------------------------------------+; | Package | Version | Details |; +==========================+==============+=====================================================+; | ``matplotlib`` | 1.2.1+ | Needed for all visualisation tasks. |; +--------------------------+--------------+-----------------------------------------------------+; | ``cython`` | 0.29.20+ | Needed for compiling some time-dependent |; | ``setuptools`` | | Hamiltonians. Cython needs a working C++ compiler. |; | ``filelock`` | | |; +--------------------------+--------------+-----------------------------------------------------+; | ``cvxpy`` | 1.0+ | Needed to calculate diamond norms. |; +--------------------------+--------------+-----------------------------------------------------+; | ``pytest``, | 5.3+ | For running the test suite. |; | ``pytest-rerunfailures`` | | |; +--------------------------+--------------+-----------------------------------------------------+; | LaTeX | TeXLive 2009+| Needed if using LaTeX in matplotlib figures, or for |; | | | nice circuit drawings in IPython. |; +--------------------------+--------------+-----------------------------------------------------+; | ``loky``, ``mpi4py`` | | Extra parallel map back-ends. |; +--------------------------+--------------+-----------------------------------------------------+; | ``tqdm`` | | Extra progress bars back-end. |; +--------------------------+--------------+-----------------------------------------------------+. In addition, there are several additional packages that are not dependencies, but may give you a better programming experience.; `IPython <https://ipython.org/>`_ provides an improved text-based Python interpreter that is far more full-featured that the default interpreter, and runs in a terminal.; If you prefer a mor",MatchSource.DOCS,doc/installation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:11206,Testability,test,test,11206,"r.; This is the recommended compiler toolchain on Windows.; When installing, be sure to select the following components:. - Windows ""X"" SDK (where ""X"" stands for your version: 7/8/8.1/10); - Visual Studio C++ build tools. You can then follow the `installation from source <install-from-source_>`_ section as normal. .. important::. In order to prevent issues with the ``PATH`` environment variable not containing the compiler and associated libraries, it is recommended to use the developer command prompt in the Visual Studio installation folder instead of the built-in command prompt. The Community edition of Visual Studio takes around 10GB of disk space.; If this is prohibitive for you, it is also possible to install `only the build tools and necessary SDKs <https://visualstudio.microsoft.com/visual-cpp-build-tools/>`_ instead, which should save about 2GB of space. .. _install-verify:. Verifying the Installation; ==========================. QuTiP includes a collection of built-in test scripts to verify that an installation was successful.; To run the suite of tests scripts you must also have the ``pytest`` testing library.; After installing QuTiP, leave the installation directory and call:. .. code-block:: bash. pytest qutip/qutip/tests. This will take between 10 and 30 minutes, depending on your computer.; At the end, the testing report should report a success; it is normal for some tests to be skipped, and for some to be marked ""xfail"" in yellow.; Skips may be tests that do not run on your operating system, or tests of optional components that you have not installed the dependencies for.; If any failures or errors occur, please check that you have installed all of the required modules.; See the next section on how to check the installed versions of the QuTiP dependencies.; If these tests still fail, then head on over to the `QuTiP Discussion Board <https://groups.google.com/g/qutip>`_ or `the GitHub issues page <https://github.com/qutip/qutip/issues>`_ and post a mess",MatchSource.DOCS,doc/installation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:11287,Testability,test,tests,11287,"t the following components:. - Windows ""X"" SDK (where ""X"" stands for your version: 7/8/8.1/10); - Visual Studio C++ build tools. You can then follow the `installation from source <install-from-source_>`_ section as normal. .. important::. In order to prevent issues with the ``PATH`` environment variable not containing the compiler and associated libraries, it is recommended to use the developer command prompt in the Visual Studio installation folder instead of the built-in command prompt. The Community edition of Visual Studio takes around 10GB of disk space.; If this is prohibitive for you, it is also possible to install `only the build tools and necessary SDKs <https://visualstudio.microsoft.com/visual-cpp-build-tools/>`_ instead, which should save about 2GB of space. .. _install-verify:. Verifying the Installation; ==========================. QuTiP includes a collection of built-in test scripts to verify that an installation was successful.; To run the suite of tests scripts you must also have the ``pytest`` testing library.; After installing QuTiP, leave the installation directory and call:. .. code-block:: bash. pytest qutip/qutip/tests. This will take between 10 and 30 minutes, depending on your computer.; At the end, the testing report should report a success; it is normal for some tests to be skipped, and for some to be marked ""xfail"" in yellow.; Skips may be tests that do not run on your operating system, or tests of optional components that you have not installed the dependencies for.; If any failures or errors occur, please check that you have installed all of the required modules.; See the next section on how to check the installed versions of the QuTiP dependencies.; If these tests still fail, then head on over to the `QuTiP Discussion Board <https://groups.google.com/g/qutip>`_ or `the GitHub issues page <https://github.com/qutip/qutip/issues>`_ and post a message detailing your particular issue. .. _install-about:. Checking Version Information; ======",MatchSource.DOCS,doc/installation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:11335,Testability,test,testing,11335,"t the following components:. - Windows ""X"" SDK (where ""X"" stands for your version: 7/8/8.1/10); - Visual Studio C++ build tools. You can then follow the `installation from source <install-from-source_>`_ section as normal. .. important::. In order to prevent issues with the ``PATH`` environment variable not containing the compiler and associated libraries, it is recommended to use the developer command prompt in the Visual Studio installation folder instead of the built-in command prompt. The Community edition of Visual Studio takes around 10GB of disk space.; If this is prohibitive for you, it is also possible to install `only the build tools and necessary SDKs <https://visualstudio.microsoft.com/visual-cpp-build-tools/>`_ instead, which should save about 2GB of space. .. _install-verify:. Verifying the Installation; ==========================. QuTiP includes a collection of built-in test scripts to verify that an installation was successful.; To run the suite of tests scripts you must also have the ``pytest`` testing library.; After installing QuTiP, leave the installation directory and call:. .. code-block:: bash. pytest qutip/qutip/tests. This will take between 10 and 30 minutes, depending on your computer.; At the end, the testing report should report a success; it is normal for some tests to be skipped, and for some to be marked ""xfail"" in yellow.; Skips may be tests that do not run on your operating system, or tests of optional components that you have not installed the dependencies for.; If any failures or errors occur, please check that you have installed all of the required modules.; See the next section on how to check the installed versions of the QuTiP dependencies.; If these tests still fail, then head on over to the `QuTiP Discussion Board <https://groups.google.com/g/qutip>`_ or `the GitHub issues page <https://github.com/qutip/qutip/issues>`_ and post a message detailing your particular issue. .. _install-about:. Checking Version Information; ======",MatchSource.DOCS,doc/installation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:11462,Testability,test,tests,11462,"w the `installation from source <install-from-source_>`_ section as normal. .. important::. In order to prevent issues with the ``PATH`` environment variable not containing the compiler and associated libraries, it is recommended to use the developer command prompt in the Visual Studio installation folder instead of the built-in command prompt. The Community edition of Visual Studio takes around 10GB of disk space.; If this is prohibitive for you, it is also possible to install `only the build tools and necessary SDKs <https://visualstudio.microsoft.com/visual-cpp-build-tools/>`_ instead, which should save about 2GB of space. .. _install-verify:. Verifying the Installation; ==========================. QuTiP includes a collection of built-in test scripts to verify that an installation was successful.; To run the suite of tests scripts you must also have the ``pytest`` testing library.; After installing QuTiP, leave the installation directory and call:. .. code-block:: bash. pytest qutip/qutip/tests. This will take between 10 and 30 minutes, depending on your computer.; At the end, the testing report should report a success; it is normal for some tests to be skipped, and for some to be marked ""xfail"" in yellow.; Skips may be tests that do not run on your operating system, or tests of optional components that you have not installed the dependencies for.; If any failures or errors occur, please check that you have installed all of the required modules.; See the next section on how to check the installed versions of the QuTiP dependencies.; If these tests still fail, then head on over to the `QuTiP Discussion Board <https://groups.google.com/g/qutip>`_ or `the GitHub issues page <https://github.com/qutip/qutip/issues>`_ and post a message detailing your particular issue. .. _install-about:. Checking Version Information; ============================. QuTiP includes an ""about"" function for viewing information about QuTiP and the important dependencies installed on your sys",MatchSource.DOCS,doc/installation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:11556,Testability,test,testing,11556,"nt::. In order to prevent issues with the ``PATH`` environment variable not containing the compiler and associated libraries, it is recommended to use the developer command prompt in the Visual Studio installation folder instead of the built-in command prompt. The Community edition of Visual Studio takes around 10GB of disk space.; If this is prohibitive for you, it is also possible to install `only the build tools and necessary SDKs <https://visualstudio.microsoft.com/visual-cpp-build-tools/>`_ instead, which should save about 2GB of space. .. _install-verify:. Verifying the Installation; ==========================. QuTiP includes a collection of built-in test scripts to verify that an installation was successful.; To run the suite of tests scripts you must also have the ``pytest`` testing library.; After installing QuTiP, leave the installation directory and call:. .. code-block:: bash. pytest qutip/qutip/tests. This will take between 10 and 30 minutes, depending on your computer.; At the end, the testing report should report a success; it is normal for some tests to be skipped, and for some to be marked ""xfail"" in yellow.; Skips may be tests that do not run on your operating system, or tests of optional components that you have not installed the dependencies for.; If any failures or errors occur, please check that you have installed all of the required modules.; See the next section on how to check the installed versions of the QuTiP dependencies.; If these tests still fail, then head on over to the `QuTiP Discussion Board <https://groups.google.com/g/qutip>`_ or `the GitHub issues page <https://github.com/qutip/qutip/issues>`_ and post a message detailing your particular issue. .. _install-about:. Checking Version Information; ============================. QuTiP includes an ""about"" function for viewing information about QuTiP and the important dependencies installed on your system.; To view this information:. .. code-block:: python. import qutip; qutip.about(); ",MatchSource.DOCS,doc/installation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:11618,Testability,test,tests,11618,"nt::. In order to prevent issues with the ``PATH`` environment variable not containing the compiler and associated libraries, it is recommended to use the developer command prompt in the Visual Studio installation folder instead of the built-in command prompt. The Community edition of Visual Studio takes around 10GB of disk space.; If this is prohibitive for you, it is also possible to install `only the build tools and necessary SDKs <https://visualstudio.microsoft.com/visual-cpp-build-tools/>`_ instead, which should save about 2GB of space. .. _install-verify:. Verifying the Installation; ==========================. QuTiP includes a collection of built-in test scripts to verify that an installation was successful.; To run the suite of tests scripts you must also have the ``pytest`` testing library.; After installing QuTiP, leave the installation directory and call:. .. code-block:: bash. pytest qutip/qutip/tests. This will take between 10 and 30 minutes, depending on your computer.; At the end, the testing report should report a success; it is normal for some tests to be skipped, and for some to be marked ""xfail"" in yellow.; Skips may be tests that do not run on your operating system, or tests of optional components that you have not installed the dependencies for.; If any failures or errors occur, please check that you have installed all of the required modules.; See the next section on how to check the installed versions of the QuTiP dependencies.; If these tests still fail, then head on over to the `QuTiP Discussion Board <https://groups.google.com/g/qutip>`_ or `the GitHub issues page <https://github.com/qutip/qutip/issues>`_ and post a message detailing your particular issue. .. _install-about:. Checking Version Information; ============================. QuTiP includes an ""about"" function for viewing information about QuTiP and the important dependencies installed on your system.; To view this information:. .. code-block:: python. import qutip; qutip.about(); ",MatchSource.DOCS,doc/installation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:11698,Testability,test,tests,11698,"nt::. In order to prevent issues with the ``PATH`` environment variable not containing the compiler and associated libraries, it is recommended to use the developer command prompt in the Visual Studio installation folder instead of the built-in command prompt. The Community edition of Visual Studio takes around 10GB of disk space.; If this is prohibitive for you, it is also possible to install `only the build tools and necessary SDKs <https://visualstudio.microsoft.com/visual-cpp-build-tools/>`_ instead, which should save about 2GB of space. .. _install-verify:. Verifying the Installation; ==========================. QuTiP includes a collection of built-in test scripts to verify that an installation was successful.; To run the suite of tests scripts you must also have the ``pytest`` testing library.; After installing QuTiP, leave the installation directory and call:. .. code-block:: bash. pytest qutip/qutip/tests. This will take between 10 and 30 minutes, depending on your computer.; At the end, the testing report should report a success; it is normal for some tests to be skipped, and for some to be marked ""xfail"" in yellow.; Skips may be tests that do not run on your operating system, or tests of optional components that you have not installed the dependencies for.; If any failures or errors occur, please check that you have installed all of the required modules.; See the next section on how to check the installed versions of the QuTiP dependencies.; If these tests still fail, then head on over to the `QuTiP Discussion Board <https://groups.google.com/g/qutip>`_ or `the GitHub issues page <https://github.com/qutip/qutip/issues>`_ and post a message detailing your particular issue. .. _install-about:. Checking Version Information; ============================. QuTiP includes an ""about"" function for viewing information about QuTiP and the important dependencies installed on your system.; To view this information:. .. code-block:: python. import qutip; qutip.about(); ",MatchSource.DOCS,doc/installation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:11749,Testability,test,tests,11749,"nt::. In order to prevent issues with the ``PATH`` environment variable not containing the compiler and associated libraries, it is recommended to use the developer command prompt in the Visual Studio installation folder instead of the built-in command prompt. The Community edition of Visual Studio takes around 10GB of disk space.; If this is prohibitive for you, it is also possible to install `only the build tools and necessary SDKs <https://visualstudio.microsoft.com/visual-cpp-build-tools/>`_ instead, which should save about 2GB of space. .. _install-verify:. Verifying the Installation; ==========================. QuTiP includes a collection of built-in test scripts to verify that an installation was successful.; To run the suite of tests scripts you must also have the ``pytest`` testing library.; After installing QuTiP, leave the installation directory and call:. .. code-block:: bash. pytest qutip/qutip/tests. This will take between 10 and 30 minutes, depending on your computer.; At the end, the testing report should report a success; it is normal for some tests to be skipped, and for some to be marked ""xfail"" in yellow.; Skips may be tests that do not run on your operating system, or tests of optional components that you have not installed the dependencies for.; If any failures or errors occur, please check that you have installed all of the required modules.; See the next section on how to check the installed versions of the QuTiP dependencies.; If these tests still fail, then head on over to the `QuTiP Discussion Board <https://groups.google.com/g/qutip>`_ or `the GitHub issues page <https://github.com/qutip/qutip/issues>`_ and post a message detailing your particular issue. .. _install-about:. Checking Version Information; ============================. QuTiP includes an ""about"" function for viewing information about QuTiP and the important dependencies installed on your system.; To view this information:. .. code-block:: python. import qutip; qutip.about(); ",MatchSource.DOCS,doc/installation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:12026,Testability,test,tests,12026,"nt::. In order to prevent issues with the ``PATH`` environment variable not containing the compiler and associated libraries, it is recommended to use the developer command prompt in the Visual Studio installation folder instead of the built-in command prompt. The Community edition of Visual Studio takes around 10GB of disk space.; If this is prohibitive for you, it is also possible to install `only the build tools and necessary SDKs <https://visualstudio.microsoft.com/visual-cpp-build-tools/>`_ instead, which should save about 2GB of space. .. _install-verify:. Verifying the Installation; ==========================. QuTiP includes a collection of built-in test scripts to verify that an installation was successful.; To run the suite of tests scripts you must also have the ``pytest`` testing library.; After installing QuTiP, leave the installation directory and call:. .. code-block:: bash. pytest qutip/qutip/tests. This will take between 10 and 30 minutes, depending on your computer.; At the end, the testing report should report a success; it is normal for some tests to be skipped, and for some to be marked ""xfail"" in yellow.; Skips may be tests that do not run on your operating system, or tests of optional components that you have not installed the dependencies for.; If any failures or errors occur, please check that you have installed all of the required modules.; See the next section on how to check the installed versions of the QuTiP dependencies.; If these tests still fail, then head on over to the `QuTiP Discussion Board <https://groups.google.com/g/qutip>`_ or `the GitHub issues page <https://github.com/qutip/qutip/issues>`_ and post a message detailing your particular issue. .. _install-about:. Checking Version Information; ============================. QuTiP includes an ""about"" function for viewing information about QuTiP and the important dependencies installed on your system.; To view this information:. .. code-block:: python. import qutip; qutip.about(); ",MatchSource.DOCS,doc/installation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst:3390,Usability,progress bar,progress bars,3390,"-----------------------------------+; | ``cython`` | 0.29.20+ | Needed for compiling some time-dependent |; | ``setuptools`` | | Hamiltonians. Cython needs a working C++ compiler. |; | ``filelock`` | | |; +--------------------------+--------------+-----------------------------------------------------+; | ``cvxpy`` | 1.0+ | Needed to calculate diamond norms. |; +--------------------------+--------------+-----------------------------------------------------+; | ``pytest``, | 5.3+ | For running the test suite. |; | ``pytest-rerunfailures`` | | |; +--------------------------+--------------+-----------------------------------------------------+; | LaTeX | TeXLive 2009+| Needed if using LaTeX in matplotlib figures, or for |; | | | nice circuit drawings in IPython. |; +--------------------------+--------------+-----------------------------------------------------+; | ``loky``, ``mpi4py`` | | Extra parallel map back-ends. |; +--------------------------+--------------+-----------------------------------------------------+; | ``tqdm`` | | Extra progress bars back-end. |; +--------------------------+--------------+-----------------------------------------------------+. In addition, there are several additional packages that are not dependencies, but may give you a better programming experience.; `IPython <https://ipython.org/>`_ provides an improved text-based Python interpreter that is far more full-featured that the default interpreter, and runs in a terminal.; If you prefer a more graphical set-up, `Jupyter <https://jupyter.org/>`_ provides a notebook-style interface to mix code and mathematical notes together.; Alternatively, `Spyder <https://www.spyder-ide.org/>`_ is a free integrated development environment for Python, with several nice features for debugging code.; QuTiP will detect if it is being used within one of these richer environments, and various outputs will have enhanced formatting. .. _install-with-conda:. Installing with conda; =====================. If you a",MatchSource.DOCS,doc/installation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/classes.rst:2843,Deployability,integrat,integrator,2843,heom.Bath; :members:. .. autoclass:: qutip.solver.heom.BosonicBath; :members:. .. autoclass:: qutip.solver.heom.DrudeLorentzBath; :members:. .. autoclass:: qutip.solver.heom.DrudeLorentzPadeBath; :members:. .. autoclass:: qutip.solver.heom.UnderDampedBath; :members:. .. autoclass:: qutip.solver.heom.FermionicBath; :members:. .. autoclass:: qutip.solver.heom.LorentzianBath; :members:. .. autoclass:: qutip.solver.heom.LorentzianPadeBath; :members:. .. autoclass:: qutip.solver.heom.HierarchyADOs; :members:. .. autoclass:: qutip.solver.heom.HierarchyADOsState; :members:. .. autoclass:: qutip.solver.heom.HEOMResult; :members:. .. _classes-stochastic:. Stochastic Solver; -----------------. .. autoclass:: qutip.solver.stochastic.SMESolver; :members:; :inherited-members:; :exclude-members: add_integrator. .. autoclass:: qutip.solver.stochastic.SSESolver; :members:; :inherited-members:; :exclude-members: add_integrator. .. _classes-ode:. Integrator; ----------. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipyAdams; :members: options. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipyBDF; :members: options. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipylsoda; :members: options. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipyDop853; :members: options. .. autoclass:: qutip.solver.integrator.qutip_integrator.IntegratorVern7; :members: options. .. autoclass:: qutip.solver.integrator.qutip_integrator.IntegratorVern9; :members: options. .. autoclass:: qutip.solver.integrator.qutip_integrator.IntegratorDiag; :members: options. .. autoclass:: qutip.solver.integrator.krylov.IntegratorKrylov; :members: options. .. _classes-sode:. Stochastic Integrator; ---------------------. .. autoclass:: qutip.solver.sode.rouchon.RouchonSODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.EulerSODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Milstein_SODE; :members: options. .,MatchSource.DOCS,doc/apidoc/classes.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/classes.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/classes.rst:2940,Deployability,integrat,integrator,2940,ip.solver.heom.DrudeLorentzBath; :members:. .. autoclass:: qutip.solver.heom.DrudeLorentzPadeBath; :members:. .. autoclass:: qutip.solver.heom.UnderDampedBath; :members:. .. autoclass:: qutip.solver.heom.FermionicBath; :members:. .. autoclass:: qutip.solver.heom.LorentzianBath; :members:. .. autoclass:: qutip.solver.heom.LorentzianPadeBath; :members:. .. autoclass:: qutip.solver.heom.HierarchyADOs; :members:. .. autoclass:: qutip.solver.heom.HierarchyADOsState; :members:. .. autoclass:: qutip.solver.heom.HEOMResult; :members:. .. _classes-stochastic:. Stochastic Solver; -----------------. .. autoclass:: qutip.solver.stochastic.SMESolver; :members:; :inherited-members:; :exclude-members: add_integrator. .. autoclass:: qutip.solver.stochastic.SSESolver; :members:; :inherited-members:; :exclude-members: add_integrator. .. _classes-ode:. Integrator; ----------. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipyAdams; :members: options. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipyBDF; :members: options. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipylsoda; :members: options. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipyDop853; :members: options. .. autoclass:: qutip.solver.integrator.qutip_integrator.IntegratorVern7; :members: options. .. autoclass:: qutip.solver.integrator.qutip_integrator.IntegratorVern9; :members: options. .. autoclass:: qutip.solver.integrator.qutip_integrator.IntegratorDiag; :members: options. .. autoclass:: qutip.solver.integrator.krylov.IntegratorKrylov; :members: options. .. _classes-sode:. Stochastic Integrator; ---------------------. .. autoclass:: qutip.solver.sode.rouchon.RouchonSODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.EulerSODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Milstein_SODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Taylor1_5_SODE; :members: options. .. autoclass:: qutip,MatchSource.DOCS,doc/apidoc/classes.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/classes.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/classes.rst:3035,Deployability,integrat,integrator,3035,th; :members:. .. autoclass:: qutip.solver.heom.UnderDampedBath; :members:. .. autoclass:: qutip.solver.heom.FermionicBath; :members:. .. autoclass:: qutip.solver.heom.LorentzianBath; :members:. .. autoclass:: qutip.solver.heom.LorentzianPadeBath; :members:. .. autoclass:: qutip.solver.heom.HierarchyADOs; :members:. .. autoclass:: qutip.solver.heom.HierarchyADOsState; :members:. .. autoclass:: qutip.solver.heom.HEOMResult; :members:. .. _classes-stochastic:. Stochastic Solver; -----------------. .. autoclass:: qutip.solver.stochastic.SMESolver; :members:; :inherited-members:; :exclude-members: add_integrator. .. autoclass:: qutip.solver.stochastic.SSESolver; :members:; :inherited-members:; :exclude-members: add_integrator. .. _classes-ode:. Integrator; ----------. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipyAdams; :members: options. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipyBDF; :members: options. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipylsoda; :members: options. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipyDop853; :members: options. .. autoclass:: qutip.solver.integrator.qutip_integrator.IntegratorVern7; :members: options. .. autoclass:: qutip.solver.integrator.qutip_integrator.IntegratorVern9; :members: options. .. autoclass:: qutip.solver.integrator.qutip_integrator.IntegratorDiag; :members: options. .. autoclass:: qutip.solver.integrator.krylov.IntegratorKrylov; :members: options. .. _classes-sode:. Stochastic Integrator; ---------------------. .. autoclass:: qutip.solver.sode.rouchon.RouchonSODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.EulerSODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Milstein_SODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Taylor1_5_SODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Implicit_Milstein_SODE; :members: options. .. autoclass:: qutip.solver.s,MatchSource.DOCS,doc/apidoc/classes.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/classes.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/classes.rst:3132,Deployability,integrat,integrator,3132,solver.heom.FermionicBath; :members:. .. autoclass:: qutip.solver.heom.LorentzianBath; :members:. .. autoclass:: qutip.solver.heom.LorentzianPadeBath; :members:. .. autoclass:: qutip.solver.heom.HierarchyADOs; :members:. .. autoclass:: qutip.solver.heom.HierarchyADOsState; :members:. .. autoclass:: qutip.solver.heom.HEOMResult; :members:. .. _classes-stochastic:. Stochastic Solver; -----------------. .. autoclass:: qutip.solver.stochastic.SMESolver; :members:; :inherited-members:; :exclude-members: add_integrator. .. autoclass:: qutip.solver.stochastic.SSESolver; :members:; :inherited-members:; :exclude-members: add_integrator. .. _classes-ode:. Integrator; ----------. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipyAdams; :members: options. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipyBDF; :members: options. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipylsoda; :members: options. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipyDop853; :members: options. .. autoclass:: qutip.solver.integrator.qutip_integrator.IntegratorVern7; :members: options. .. autoclass:: qutip.solver.integrator.qutip_integrator.IntegratorVern9; :members: options. .. autoclass:: qutip.solver.integrator.qutip_integrator.IntegratorDiag; :members: options. .. autoclass:: qutip.solver.integrator.krylov.IntegratorKrylov; :members: options. .. _classes-sode:. Stochastic Integrator; ---------------------. .. autoclass:: qutip.solver.sode.rouchon.RouchonSODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.EulerSODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Milstein_SODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Taylor1_5_SODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Implicit_Milstein_SODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Implicit_Taylor1_5_SODE; :members: options. .. autoclass:: qutip.solver.sode.sode.P,MatchSource.DOCS,doc/apidoc/classes.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/classes.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/classes.rst:3230,Deployability,integrat,integrator,3230,.. autoclass:: qutip.solver.heom.LorentzianPadeBath; :members:. .. autoclass:: qutip.solver.heom.HierarchyADOs; :members:. .. autoclass:: qutip.solver.heom.HierarchyADOsState; :members:. .. autoclass:: qutip.solver.heom.HEOMResult; :members:. .. _classes-stochastic:. Stochastic Solver; -----------------. .. autoclass:: qutip.solver.stochastic.SMESolver; :members:; :inherited-members:; :exclude-members: add_integrator. .. autoclass:: qutip.solver.stochastic.SSESolver; :members:; :inherited-members:; :exclude-members: add_integrator. .. _classes-ode:. Integrator; ----------. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipyAdams; :members: options. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipyBDF; :members: options. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipylsoda; :members: options. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipyDop853; :members: options. .. autoclass:: qutip.solver.integrator.qutip_integrator.IntegratorVern7; :members: options. .. autoclass:: qutip.solver.integrator.qutip_integrator.IntegratorVern9; :members: options. .. autoclass:: qutip.solver.integrator.qutip_integrator.IntegratorDiag; :members: options. .. autoclass:: qutip.solver.integrator.krylov.IntegratorKrylov; :members: options. .. _classes-sode:. Stochastic Integrator; ---------------------. .. autoclass:: qutip.solver.sode.rouchon.RouchonSODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.EulerSODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Milstein_SODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Taylor1_5_SODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Implicit_Milstein_SODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Implicit_Taylor1_5_SODE; :members: options. .. autoclass:: qutip.solver.sode.sode.PlatenSODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Explicit1_5_SODE; :member,MatchSource.DOCS,doc/apidoc/classes.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/classes.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/classes.rst:3322,Deployability,integrat,integrator,3322,heom.HierarchyADOs; :members:. .. autoclass:: qutip.solver.heom.HierarchyADOsState; :members:. .. autoclass:: qutip.solver.heom.HEOMResult; :members:. .. _classes-stochastic:. Stochastic Solver; -----------------. .. autoclass:: qutip.solver.stochastic.SMESolver; :members:; :inherited-members:; :exclude-members: add_integrator. .. autoclass:: qutip.solver.stochastic.SSESolver; :members:; :inherited-members:; :exclude-members: add_integrator. .. _classes-ode:. Integrator; ----------. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipyAdams; :members: options. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipyBDF; :members: options. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipylsoda; :members: options. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipyDop853; :members: options. .. autoclass:: qutip.solver.integrator.qutip_integrator.IntegratorVern7; :members: options. .. autoclass:: qutip.solver.integrator.qutip_integrator.IntegratorVern9; :members: options. .. autoclass:: qutip.solver.integrator.qutip_integrator.IntegratorDiag; :members: options. .. autoclass:: qutip.solver.integrator.krylov.IntegratorKrylov; :members: options. .. _classes-sode:. Stochastic Integrator; ---------------------. .. autoclass:: qutip.solver.sode.rouchon.RouchonSODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.EulerSODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Milstein_SODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Taylor1_5_SODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Implicit_Milstein_SODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Implicit_Taylor1_5_SODE; :members: options. .. autoclass:: qutip.solver.sode.sode.PlatenSODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Explicit1_5_SODE; :members: options. .. autoclass:: qutip.solver.sode.sode.PredCorr_SODE; :members: options. .. _clas,MatchSource.DOCS,doc/apidoc/classes.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/classes.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/classes.rst:3414,Deployability,integrat,integrator,3414,:. .. autoclass:: qutip.solver.heom.HEOMResult; :members:. .. _classes-stochastic:. Stochastic Solver; -----------------. .. autoclass:: qutip.solver.stochastic.SMESolver; :members:; :inherited-members:; :exclude-members: add_integrator. .. autoclass:: qutip.solver.stochastic.SSESolver; :members:; :inherited-members:; :exclude-members: add_integrator. .. _classes-ode:. Integrator; ----------. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipyAdams; :members: options. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipyBDF; :members: options. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipylsoda; :members: options. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipyDop853; :members: options. .. autoclass:: qutip.solver.integrator.qutip_integrator.IntegratorVern7; :members: options. .. autoclass:: qutip.solver.integrator.qutip_integrator.IntegratorVern9; :members: options. .. autoclass:: qutip.solver.integrator.qutip_integrator.IntegratorDiag; :members: options. .. autoclass:: qutip.solver.integrator.krylov.IntegratorKrylov; :members: options. .. _classes-sode:. Stochastic Integrator; ---------------------. .. autoclass:: qutip.solver.sode.rouchon.RouchonSODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.EulerSODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Milstein_SODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Taylor1_5_SODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Implicit_Milstein_SODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Implicit_Taylor1_5_SODE; :members: options. .. autoclass:: qutip.solver.sode.sode.PlatenSODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Explicit1_5_SODE; :members: options. .. autoclass:: qutip.solver.sode.sode.PredCorr_SODE; :members: options. .. _classes-odeoptions:. Solver Options and Results; ---------------------------. .. autoclass:: qut,MatchSource.DOCS,doc/apidoc/classes.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/classes.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/classes.rst:3505,Deployability,integrat,integrator,3505,"tic Solver; -----------------. .. autoclass:: qutip.solver.stochastic.SMESolver; :members:; :inherited-members:; :exclude-members: add_integrator. .. autoclass:: qutip.solver.stochastic.SSESolver; :members:; :inherited-members:; :exclude-members: add_integrator. .. _classes-ode:. Integrator; ----------. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipyAdams; :members: options. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipyBDF; :members: options. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipylsoda; :members: options. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipyDop853; :members: options. .. autoclass:: qutip.solver.integrator.qutip_integrator.IntegratorVern7; :members: options. .. autoclass:: qutip.solver.integrator.qutip_integrator.IntegratorVern9; :members: options. .. autoclass:: qutip.solver.integrator.qutip_integrator.IntegratorDiag; :members: options. .. autoclass:: qutip.solver.integrator.krylov.IntegratorKrylov; :members: options. .. _classes-sode:. Stochastic Integrator; ---------------------. .. autoclass:: qutip.solver.sode.rouchon.RouchonSODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.EulerSODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Milstein_SODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Taylor1_5_SODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Implicit_Milstein_SODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Implicit_Taylor1_5_SODE; :members: options. .. autoclass:: qutip.solver.sode.sode.PlatenSODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Explicit1_5_SODE; :members: options. .. autoclass:: qutip.solver.sode.sode.PredCorr_SODE; :members: options. .. _classes-odeoptions:. Solver Options and Results; ---------------------------. .. autoclass:: qutip.solver.result.Result; :members:; :inherited-members:; :exclude-members: add_processor, a",MatchSource.DOCS,doc/apidoc/classes.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/classes.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/classes.rst:2843,Integrability,integrat,integrator,2843,heom.Bath; :members:. .. autoclass:: qutip.solver.heom.BosonicBath; :members:. .. autoclass:: qutip.solver.heom.DrudeLorentzBath; :members:. .. autoclass:: qutip.solver.heom.DrudeLorentzPadeBath; :members:. .. autoclass:: qutip.solver.heom.UnderDampedBath; :members:. .. autoclass:: qutip.solver.heom.FermionicBath; :members:. .. autoclass:: qutip.solver.heom.LorentzianBath; :members:. .. autoclass:: qutip.solver.heom.LorentzianPadeBath; :members:. .. autoclass:: qutip.solver.heom.HierarchyADOs; :members:. .. autoclass:: qutip.solver.heom.HierarchyADOsState; :members:. .. autoclass:: qutip.solver.heom.HEOMResult; :members:. .. _classes-stochastic:. Stochastic Solver; -----------------. .. autoclass:: qutip.solver.stochastic.SMESolver; :members:; :inherited-members:; :exclude-members: add_integrator. .. autoclass:: qutip.solver.stochastic.SSESolver; :members:; :inherited-members:; :exclude-members: add_integrator. .. _classes-ode:. Integrator; ----------. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipyAdams; :members: options. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipyBDF; :members: options. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipylsoda; :members: options. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipyDop853; :members: options. .. autoclass:: qutip.solver.integrator.qutip_integrator.IntegratorVern7; :members: options. .. autoclass:: qutip.solver.integrator.qutip_integrator.IntegratorVern9; :members: options. .. autoclass:: qutip.solver.integrator.qutip_integrator.IntegratorDiag; :members: options. .. autoclass:: qutip.solver.integrator.krylov.IntegratorKrylov; :members: options. .. _classes-sode:. Stochastic Integrator; ---------------------. .. autoclass:: qutip.solver.sode.rouchon.RouchonSODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.EulerSODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Milstein_SODE; :members: options. .,MatchSource.DOCS,doc/apidoc/classes.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/classes.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/classes.rst:2940,Integrability,integrat,integrator,2940,ip.solver.heom.DrudeLorentzBath; :members:. .. autoclass:: qutip.solver.heom.DrudeLorentzPadeBath; :members:. .. autoclass:: qutip.solver.heom.UnderDampedBath; :members:. .. autoclass:: qutip.solver.heom.FermionicBath; :members:. .. autoclass:: qutip.solver.heom.LorentzianBath; :members:. .. autoclass:: qutip.solver.heom.LorentzianPadeBath; :members:. .. autoclass:: qutip.solver.heom.HierarchyADOs; :members:. .. autoclass:: qutip.solver.heom.HierarchyADOsState; :members:. .. autoclass:: qutip.solver.heom.HEOMResult; :members:. .. _classes-stochastic:. Stochastic Solver; -----------------. .. autoclass:: qutip.solver.stochastic.SMESolver; :members:; :inherited-members:; :exclude-members: add_integrator. .. autoclass:: qutip.solver.stochastic.SSESolver; :members:; :inherited-members:; :exclude-members: add_integrator. .. _classes-ode:. Integrator; ----------. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipyAdams; :members: options. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipyBDF; :members: options. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipylsoda; :members: options. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipyDop853; :members: options. .. autoclass:: qutip.solver.integrator.qutip_integrator.IntegratorVern7; :members: options. .. autoclass:: qutip.solver.integrator.qutip_integrator.IntegratorVern9; :members: options. .. autoclass:: qutip.solver.integrator.qutip_integrator.IntegratorDiag; :members: options. .. autoclass:: qutip.solver.integrator.krylov.IntegratorKrylov; :members: options. .. _classes-sode:. Stochastic Integrator; ---------------------. .. autoclass:: qutip.solver.sode.rouchon.RouchonSODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.EulerSODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Milstein_SODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Taylor1_5_SODE; :members: options. .. autoclass:: qutip,MatchSource.DOCS,doc/apidoc/classes.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/classes.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/classes.rst:3035,Integrability,integrat,integrator,3035,th; :members:. .. autoclass:: qutip.solver.heom.UnderDampedBath; :members:. .. autoclass:: qutip.solver.heom.FermionicBath; :members:. .. autoclass:: qutip.solver.heom.LorentzianBath; :members:. .. autoclass:: qutip.solver.heom.LorentzianPadeBath; :members:. .. autoclass:: qutip.solver.heom.HierarchyADOs; :members:. .. autoclass:: qutip.solver.heom.HierarchyADOsState; :members:. .. autoclass:: qutip.solver.heom.HEOMResult; :members:. .. _classes-stochastic:. Stochastic Solver; -----------------. .. autoclass:: qutip.solver.stochastic.SMESolver; :members:; :inherited-members:; :exclude-members: add_integrator. .. autoclass:: qutip.solver.stochastic.SSESolver; :members:; :inherited-members:; :exclude-members: add_integrator. .. _classes-ode:. Integrator; ----------. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipyAdams; :members: options. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipyBDF; :members: options. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipylsoda; :members: options. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipyDop853; :members: options. .. autoclass:: qutip.solver.integrator.qutip_integrator.IntegratorVern7; :members: options. .. autoclass:: qutip.solver.integrator.qutip_integrator.IntegratorVern9; :members: options. .. autoclass:: qutip.solver.integrator.qutip_integrator.IntegratorDiag; :members: options. .. autoclass:: qutip.solver.integrator.krylov.IntegratorKrylov; :members: options. .. _classes-sode:. Stochastic Integrator; ---------------------. .. autoclass:: qutip.solver.sode.rouchon.RouchonSODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.EulerSODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Milstein_SODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Taylor1_5_SODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Implicit_Milstein_SODE; :members: options. .. autoclass:: qutip.solver.s,MatchSource.DOCS,doc/apidoc/classes.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/classes.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/classes.rst:3132,Integrability,integrat,integrator,3132,solver.heom.FermionicBath; :members:. .. autoclass:: qutip.solver.heom.LorentzianBath; :members:. .. autoclass:: qutip.solver.heom.LorentzianPadeBath; :members:. .. autoclass:: qutip.solver.heom.HierarchyADOs; :members:. .. autoclass:: qutip.solver.heom.HierarchyADOsState; :members:. .. autoclass:: qutip.solver.heom.HEOMResult; :members:. .. _classes-stochastic:. Stochastic Solver; -----------------. .. autoclass:: qutip.solver.stochastic.SMESolver; :members:; :inherited-members:; :exclude-members: add_integrator. .. autoclass:: qutip.solver.stochastic.SSESolver; :members:; :inherited-members:; :exclude-members: add_integrator. .. _classes-ode:. Integrator; ----------. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipyAdams; :members: options. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipyBDF; :members: options. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipylsoda; :members: options. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipyDop853; :members: options. .. autoclass:: qutip.solver.integrator.qutip_integrator.IntegratorVern7; :members: options. .. autoclass:: qutip.solver.integrator.qutip_integrator.IntegratorVern9; :members: options. .. autoclass:: qutip.solver.integrator.qutip_integrator.IntegratorDiag; :members: options. .. autoclass:: qutip.solver.integrator.krylov.IntegratorKrylov; :members: options. .. _classes-sode:. Stochastic Integrator; ---------------------. .. autoclass:: qutip.solver.sode.rouchon.RouchonSODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.EulerSODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Milstein_SODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Taylor1_5_SODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Implicit_Milstein_SODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Implicit_Taylor1_5_SODE; :members: options. .. autoclass:: qutip.solver.sode.sode.P,MatchSource.DOCS,doc/apidoc/classes.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/classes.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/classes.rst:3230,Integrability,integrat,integrator,3230,.. autoclass:: qutip.solver.heom.LorentzianPadeBath; :members:. .. autoclass:: qutip.solver.heom.HierarchyADOs; :members:. .. autoclass:: qutip.solver.heom.HierarchyADOsState; :members:. .. autoclass:: qutip.solver.heom.HEOMResult; :members:. .. _classes-stochastic:. Stochastic Solver; -----------------. .. autoclass:: qutip.solver.stochastic.SMESolver; :members:; :inherited-members:; :exclude-members: add_integrator. .. autoclass:: qutip.solver.stochastic.SSESolver; :members:; :inherited-members:; :exclude-members: add_integrator. .. _classes-ode:. Integrator; ----------. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipyAdams; :members: options. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipyBDF; :members: options. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipylsoda; :members: options. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipyDop853; :members: options. .. autoclass:: qutip.solver.integrator.qutip_integrator.IntegratorVern7; :members: options. .. autoclass:: qutip.solver.integrator.qutip_integrator.IntegratorVern9; :members: options. .. autoclass:: qutip.solver.integrator.qutip_integrator.IntegratorDiag; :members: options. .. autoclass:: qutip.solver.integrator.krylov.IntegratorKrylov; :members: options. .. _classes-sode:. Stochastic Integrator; ---------------------. .. autoclass:: qutip.solver.sode.rouchon.RouchonSODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.EulerSODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Milstein_SODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Taylor1_5_SODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Implicit_Milstein_SODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Implicit_Taylor1_5_SODE; :members: options. .. autoclass:: qutip.solver.sode.sode.PlatenSODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Explicit1_5_SODE; :member,MatchSource.DOCS,doc/apidoc/classes.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/classes.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/classes.rst:3322,Integrability,integrat,integrator,3322,heom.HierarchyADOs; :members:. .. autoclass:: qutip.solver.heom.HierarchyADOsState; :members:. .. autoclass:: qutip.solver.heom.HEOMResult; :members:. .. _classes-stochastic:. Stochastic Solver; -----------------. .. autoclass:: qutip.solver.stochastic.SMESolver; :members:; :inherited-members:; :exclude-members: add_integrator. .. autoclass:: qutip.solver.stochastic.SSESolver; :members:; :inherited-members:; :exclude-members: add_integrator. .. _classes-ode:. Integrator; ----------. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipyAdams; :members: options. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipyBDF; :members: options. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipylsoda; :members: options. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipyDop853; :members: options. .. autoclass:: qutip.solver.integrator.qutip_integrator.IntegratorVern7; :members: options. .. autoclass:: qutip.solver.integrator.qutip_integrator.IntegratorVern9; :members: options. .. autoclass:: qutip.solver.integrator.qutip_integrator.IntegratorDiag; :members: options. .. autoclass:: qutip.solver.integrator.krylov.IntegratorKrylov; :members: options. .. _classes-sode:. Stochastic Integrator; ---------------------. .. autoclass:: qutip.solver.sode.rouchon.RouchonSODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.EulerSODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Milstein_SODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Taylor1_5_SODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Implicit_Milstein_SODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Implicit_Taylor1_5_SODE; :members: options. .. autoclass:: qutip.solver.sode.sode.PlatenSODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Explicit1_5_SODE; :members: options. .. autoclass:: qutip.solver.sode.sode.PredCorr_SODE; :members: options. .. _clas,MatchSource.DOCS,doc/apidoc/classes.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/classes.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/classes.rst:3414,Integrability,integrat,integrator,3414,:. .. autoclass:: qutip.solver.heom.HEOMResult; :members:. .. _classes-stochastic:. Stochastic Solver; -----------------. .. autoclass:: qutip.solver.stochastic.SMESolver; :members:; :inherited-members:; :exclude-members: add_integrator. .. autoclass:: qutip.solver.stochastic.SSESolver; :members:; :inherited-members:; :exclude-members: add_integrator. .. _classes-ode:. Integrator; ----------. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipyAdams; :members: options. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipyBDF; :members: options. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipylsoda; :members: options. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipyDop853; :members: options. .. autoclass:: qutip.solver.integrator.qutip_integrator.IntegratorVern7; :members: options. .. autoclass:: qutip.solver.integrator.qutip_integrator.IntegratorVern9; :members: options. .. autoclass:: qutip.solver.integrator.qutip_integrator.IntegratorDiag; :members: options. .. autoclass:: qutip.solver.integrator.krylov.IntegratorKrylov; :members: options. .. _classes-sode:. Stochastic Integrator; ---------------------. .. autoclass:: qutip.solver.sode.rouchon.RouchonSODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.EulerSODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Milstein_SODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Taylor1_5_SODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Implicit_Milstein_SODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Implicit_Taylor1_5_SODE; :members: options. .. autoclass:: qutip.solver.sode.sode.PlatenSODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Explicit1_5_SODE; :members: options. .. autoclass:: qutip.solver.sode.sode.PredCorr_SODE; :members: options. .. _classes-odeoptions:. Solver Options and Results; ---------------------------. .. autoclass:: qut,MatchSource.DOCS,doc/apidoc/classes.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/classes.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/classes.rst:3505,Integrability,integrat,integrator,3505,"tic Solver; -----------------. .. autoclass:: qutip.solver.stochastic.SMESolver; :members:; :inherited-members:; :exclude-members: add_integrator. .. autoclass:: qutip.solver.stochastic.SSESolver; :members:; :inherited-members:; :exclude-members: add_integrator. .. _classes-ode:. Integrator; ----------. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipyAdams; :members: options. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipyBDF; :members: options. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipylsoda; :members: options. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipyDop853; :members: options. .. autoclass:: qutip.solver.integrator.qutip_integrator.IntegratorVern7; :members: options. .. autoclass:: qutip.solver.integrator.qutip_integrator.IntegratorVern9; :members: options. .. autoclass:: qutip.solver.integrator.qutip_integrator.IntegratorDiag; :members: options. .. autoclass:: qutip.solver.integrator.krylov.IntegratorKrylov; :members: options. .. _classes-sode:. Stochastic Integrator; ---------------------. .. autoclass:: qutip.solver.sode.rouchon.RouchonSODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.EulerSODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Milstein_SODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Taylor1_5_SODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Implicit_Milstein_SODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Implicit_Taylor1_5_SODE; :members: options. .. autoclass:: qutip.solver.sode.sode.PlatenSODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Explicit1_5_SODE; :members: options. .. autoclass:: qutip.solver.sode.sode.PredCorr_SODE; :members: options. .. _classes-odeoptions:. Solver Options and Results; ---------------------------. .. autoclass:: qutip.solver.result.Result; :members:; :inherited-members:; :exclude-members: add_processor, a",MatchSource.DOCS,doc/apidoc/classes.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/classes.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/classes.rst:568,Modifiability,inherit,inherited-members,568,.. _classes:. ***************; Classes; ***************. .. _classes-qobj:. Qobj; --------------. .. autoclass:: qutip.core.qobj.Qobj; :members:; :special-members: __call__. .. _classes-qobjevo:. QobjEvo; --------------. .. autoclass:: qutip.core.cy.qobjevo.QobjEvo; :members:; :special-members: __call__. .. _classes-bloch:. Bloch sphere; ---------------. .. autoclass:: qutip.bloch.Bloch; :members:. Distributions; -------------. .. autoclass:: qutip.QFunc; :members:. .. _classes-solver:. Solvers; -------. .. autoclass:: qutip.solver.sesolve.SESolver; :members:; :inherited-members:; :show-inheritance:; :exclude-members: add_integrator. .. autoclass:: qutip.solver.mesolve.MESolver; :members:; :inherited-members:; :show-inheritance:; :exclude-members: add_integrator. .. autoclass:: qutip.solver.brmesolve.BRSolver; :members:; :inherited-members:; :show-inheritance:; :exclude-members: add_integrator. .. autoclass:: qutip.solver.floquet.FMESolver; :members:; :inherited-members:; :show-inheritance:; :exclude-members: add_integrator. .. autoclass:: qutip.solver.floquet.FloquetBasis; :members:. .. autoclass:: qutip.solver.propagator.Propagator; :members:; :inherited-members:; :special-members: __call__. .. _classes-monte-carlo-solver:. Monte Carlo Solvers; -------------------. .. autoclass:: qutip.solver.mcsolve.MCSolver; :members:; :inherited-members:; :show-inheritance:; :exclude-members: add_integrator. .. autoclass:: qutip.solver.nm_mcsolve.NonMarkovianMCSolver; :members:; :inherited-members:; :show-inheritance:; :exclude-members: add_integrator. .. _classes-non_markov_heom:. Non-Markovian HEOM Solver; -------------------------. .. autoclass:: qutip.solver.heom.HEOMSolver; :members:. .. autoclass:: qutip.solver.heom.HSolverDL; :members:. .. autoclass:: qutip.solver.heom.BathExponent; :members:. .. autoclass:: qutip.solver.heom.Bath; :members:. .. autoclass:: qutip.solver.heom.BosonicBath; :members:. .. autoclass:: qutip.solver.heom.DrudeLorentzBath; :members:. .. autoclass,MatchSource.DOCS,doc/apidoc/classes.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/classes.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/classes.rst:594,Modifiability,inherit,inheritance,594,.. _classes:. ***************; Classes; ***************. .. _classes-qobj:. Qobj; --------------. .. autoclass:: qutip.core.qobj.Qobj; :members:; :special-members: __call__. .. _classes-qobjevo:. QobjEvo; --------------. .. autoclass:: qutip.core.cy.qobjevo.QobjEvo; :members:; :special-members: __call__. .. _classes-bloch:. Bloch sphere; ---------------. .. autoclass:: qutip.bloch.Bloch; :members:. Distributions; -------------. .. autoclass:: qutip.QFunc; :members:. .. _classes-solver:. Solvers; -------. .. autoclass:: qutip.solver.sesolve.SESolver; :members:; :inherited-members:; :show-inheritance:; :exclude-members: add_integrator. .. autoclass:: qutip.solver.mesolve.MESolver; :members:; :inherited-members:; :show-inheritance:; :exclude-members: add_integrator. .. autoclass:: qutip.solver.brmesolve.BRSolver; :members:; :inherited-members:; :show-inheritance:; :exclude-members: add_integrator. .. autoclass:: qutip.solver.floquet.FMESolver; :members:; :inherited-members:; :show-inheritance:; :exclude-members: add_integrator. .. autoclass:: qutip.solver.floquet.FloquetBasis; :members:. .. autoclass:: qutip.solver.propagator.Propagator; :members:; :inherited-members:; :special-members: __call__. .. _classes-monte-carlo-solver:. Monte Carlo Solvers; -------------------. .. autoclass:: qutip.solver.mcsolve.MCSolver; :members:; :inherited-members:; :show-inheritance:; :exclude-members: add_integrator. .. autoclass:: qutip.solver.nm_mcsolve.NonMarkovianMCSolver; :members:; :inherited-members:; :show-inheritance:; :exclude-members: add_integrator. .. _classes-non_markov_heom:. Non-Markovian HEOM Solver; -------------------------. .. autoclass:: qutip.solver.heom.HEOMSolver; :members:. .. autoclass:: qutip.solver.heom.HSolverDL; :members:. .. autoclass:: qutip.solver.heom.BathExponent; :members:. .. autoclass:: qutip.solver.heom.Bath; :members:. .. autoclass:: qutip.solver.heom.BosonicBath; :members:. .. autoclass:: qutip.solver.heom.DrudeLorentzBath; :members:. .. autoclass,MatchSource.DOCS,doc/apidoc/classes.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/classes.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/classes.rst:700,Modifiability,inherit,inherited-members,700,.. _classes:. ***************; Classes; ***************. .. _classes-qobj:. Qobj; --------------. .. autoclass:: qutip.core.qobj.Qobj; :members:; :special-members: __call__. .. _classes-qobjevo:. QobjEvo; --------------. .. autoclass:: qutip.core.cy.qobjevo.QobjEvo; :members:; :special-members: __call__. .. _classes-bloch:. Bloch sphere; ---------------. .. autoclass:: qutip.bloch.Bloch; :members:. Distributions; -------------. .. autoclass:: qutip.QFunc; :members:. .. _classes-solver:. Solvers; -------. .. autoclass:: qutip.solver.sesolve.SESolver; :members:; :inherited-members:; :show-inheritance:; :exclude-members: add_integrator. .. autoclass:: qutip.solver.mesolve.MESolver; :members:; :inherited-members:; :show-inheritance:; :exclude-members: add_integrator. .. autoclass:: qutip.solver.brmesolve.BRSolver; :members:; :inherited-members:; :show-inheritance:; :exclude-members: add_integrator. .. autoclass:: qutip.solver.floquet.FMESolver; :members:; :inherited-members:; :show-inheritance:; :exclude-members: add_integrator. .. autoclass:: qutip.solver.floquet.FloquetBasis; :members:. .. autoclass:: qutip.solver.propagator.Propagator; :members:; :inherited-members:; :special-members: __call__. .. _classes-monte-carlo-solver:. Monte Carlo Solvers; -------------------. .. autoclass:: qutip.solver.mcsolve.MCSolver; :members:; :inherited-members:; :show-inheritance:; :exclude-members: add_integrator. .. autoclass:: qutip.solver.nm_mcsolve.NonMarkovianMCSolver; :members:; :inherited-members:; :show-inheritance:; :exclude-members: add_integrator. .. _classes-non_markov_heom:. Non-Markovian HEOM Solver; -------------------------. .. autoclass:: qutip.solver.heom.HEOMSolver; :members:. .. autoclass:: qutip.solver.heom.HSolverDL; :members:. .. autoclass:: qutip.solver.heom.BathExponent; :members:. .. autoclass:: qutip.solver.heom.Bath; :members:. .. autoclass:: qutip.solver.heom.BosonicBath; :members:. .. autoclass:: qutip.solver.heom.DrudeLorentzBath; :members:. .. autoclass,MatchSource.DOCS,doc/apidoc/classes.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/classes.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/classes.rst:726,Modifiability,inherit,inheritance,726,.. _classes:. ***************; Classes; ***************. .. _classes-qobj:. Qobj; --------------. .. autoclass:: qutip.core.qobj.Qobj; :members:; :special-members: __call__. .. _classes-qobjevo:. QobjEvo; --------------. .. autoclass:: qutip.core.cy.qobjevo.QobjEvo; :members:; :special-members: __call__. .. _classes-bloch:. Bloch sphere; ---------------. .. autoclass:: qutip.bloch.Bloch; :members:. Distributions; -------------. .. autoclass:: qutip.QFunc; :members:. .. _classes-solver:. Solvers; -------. .. autoclass:: qutip.solver.sesolve.SESolver; :members:; :inherited-members:; :show-inheritance:; :exclude-members: add_integrator. .. autoclass:: qutip.solver.mesolve.MESolver; :members:; :inherited-members:; :show-inheritance:; :exclude-members: add_integrator. .. autoclass:: qutip.solver.brmesolve.BRSolver; :members:; :inherited-members:; :show-inheritance:; :exclude-members: add_integrator. .. autoclass:: qutip.solver.floquet.FMESolver; :members:; :inherited-members:; :show-inheritance:; :exclude-members: add_integrator. .. autoclass:: qutip.solver.floquet.FloquetBasis; :members:. .. autoclass:: qutip.solver.propagator.Propagator; :members:; :inherited-members:; :special-members: __call__. .. _classes-monte-carlo-solver:. Monte Carlo Solvers; -------------------. .. autoclass:: qutip.solver.mcsolve.MCSolver; :members:; :inherited-members:; :show-inheritance:; :exclude-members: add_integrator. .. autoclass:: qutip.solver.nm_mcsolve.NonMarkovianMCSolver; :members:; :inherited-members:; :show-inheritance:; :exclude-members: add_integrator. .. _classes-non_markov_heom:. Non-Markovian HEOM Solver; -------------------------. .. autoclass:: qutip.solver.heom.HEOMSolver; :members:. .. autoclass:: qutip.solver.heom.HSolverDL; :members:. .. autoclass:: qutip.solver.heom.BathExponent; :members:. .. autoclass:: qutip.solver.heom.Bath; :members:. .. autoclass:: qutip.solver.heom.BosonicBath; :members:. .. autoclass:: qutip.solver.heom.DrudeLorentzBath; :members:. .. autoclass,MatchSource.DOCS,doc/apidoc/classes.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/classes.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/classes.rst:834,Modifiability,inherit,inherited-members,834,.. _classes:. ***************; Classes; ***************. .. _classes-qobj:. Qobj; --------------. .. autoclass:: qutip.core.qobj.Qobj; :members:; :special-members: __call__. .. _classes-qobjevo:. QobjEvo; --------------. .. autoclass:: qutip.core.cy.qobjevo.QobjEvo; :members:; :special-members: __call__. .. _classes-bloch:. Bloch sphere; ---------------. .. autoclass:: qutip.bloch.Bloch; :members:. Distributions; -------------. .. autoclass:: qutip.QFunc; :members:. .. _classes-solver:. Solvers; -------. .. autoclass:: qutip.solver.sesolve.SESolver; :members:; :inherited-members:; :show-inheritance:; :exclude-members: add_integrator. .. autoclass:: qutip.solver.mesolve.MESolver; :members:; :inherited-members:; :show-inheritance:; :exclude-members: add_integrator. .. autoclass:: qutip.solver.brmesolve.BRSolver; :members:; :inherited-members:; :show-inheritance:; :exclude-members: add_integrator. .. autoclass:: qutip.solver.floquet.FMESolver; :members:; :inherited-members:; :show-inheritance:; :exclude-members: add_integrator. .. autoclass:: qutip.solver.floquet.FloquetBasis; :members:. .. autoclass:: qutip.solver.propagator.Propagator; :members:; :inherited-members:; :special-members: __call__. .. _classes-monte-carlo-solver:. Monte Carlo Solvers; -------------------. .. autoclass:: qutip.solver.mcsolve.MCSolver; :members:; :inherited-members:; :show-inheritance:; :exclude-members: add_integrator. .. autoclass:: qutip.solver.nm_mcsolve.NonMarkovianMCSolver; :members:; :inherited-members:; :show-inheritance:; :exclude-members: add_integrator. .. _classes-non_markov_heom:. Non-Markovian HEOM Solver; -------------------------. .. autoclass:: qutip.solver.heom.HEOMSolver; :members:. .. autoclass:: qutip.solver.heom.HSolverDL; :members:. .. autoclass:: qutip.solver.heom.BathExponent; :members:. .. autoclass:: qutip.solver.heom.Bath; :members:. .. autoclass:: qutip.solver.heom.BosonicBath; :members:. .. autoclass:: qutip.solver.heom.DrudeLorentzBath; :members:. .. autoclass,MatchSource.DOCS,doc/apidoc/classes.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/classes.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/classes.rst:860,Modifiability,inherit,inheritance,860,.. _classes:. ***************; Classes; ***************. .. _classes-qobj:. Qobj; --------------. .. autoclass:: qutip.core.qobj.Qobj; :members:; :special-members: __call__. .. _classes-qobjevo:. QobjEvo; --------------. .. autoclass:: qutip.core.cy.qobjevo.QobjEvo; :members:; :special-members: __call__. .. _classes-bloch:. Bloch sphere; ---------------. .. autoclass:: qutip.bloch.Bloch; :members:. Distributions; -------------. .. autoclass:: qutip.QFunc; :members:. .. _classes-solver:. Solvers; -------. .. autoclass:: qutip.solver.sesolve.SESolver; :members:; :inherited-members:; :show-inheritance:; :exclude-members: add_integrator. .. autoclass:: qutip.solver.mesolve.MESolver; :members:; :inherited-members:; :show-inheritance:; :exclude-members: add_integrator. .. autoclass:: qutip.solver.brmesolve.BRSolver; :members:; :inherited-members:; :show-inheritance:; :exclude-members: add_integrator. .. autoclass:: qutip.solver.floquet.FMESolver; :members:; :inherited-members:; :show-inheritance:; :exclude-members: add_integrator. .. autoclass:: qutip.solver.floquet.FloquetBasis; :members:. .. autoclass:: qutip.solver.propagator.Propagator; :members:; :inherited-members:; :special-members: __call__. .. _classes-monte-carlo-solver:. Monte Carlo Solvers; -------------------. .. autoclass:: qutip.solver.mcsolve.MCSolver; :members:; :inherited-members:; :show-inheritance:; :exclude-members: add_integrator. .. autoclass:: qutip.solver.nm_mcsolve.NonMarkovianMCSolver; :members:; :inherited-members:; :show-inheritance:; :exclude-members: add_integrator. .. _classes-non_markov_heom:. Non-Markovian HEOM Solver; -------------------------. .. autoclass:: qutip.solver.heom.HEOMSolver; :members:. .. autoclass:: qutip.solver.heom.HSolverDL; :members:. .. autoclass:: qutip.solver.heom.BathExponent; :members:. .. autoclass:: qutip.solver.heom.Bath; :members:. .. autoclass:: qutip.solver.heom.BosonicBath; :members:. .. autoclass:: qutip.solver.heom.DrudeLorentzBath; :members:. .. autoclass,MatchSource.DOCS,doc/apidoc/classes.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/classes.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/classes.rst:967,Modifiability,inherit,inherited-members,967,.. _classes:. ***************; Classes; ***************. .. _classes-qobj:. Qobj; --------------. .. autoclass:: qutip.core.qobj.Qobj; :members:; :special-members: __call__. .. _classes-qobjevo:. QobjEvo; --------------. .. autoclass:: qutip.core.cy.qobjevo.QobjEvo; :members:; :special-members: __call__. .. _classes-bloch:. Bloch sphere; ---------------. .. autoclass:: qutip.bloch.Bloch; :members:. Distributions; -------------. .. autoclass:: qutip.QFunc; :members:. .. _classes-solver:. Solvers; -------. .. autoclass:: qutip.solver.sesolve.SESolver; :members:; :inherited-members:; :show-inheritance:; :exclude-members: add_integrator. .. autoclass:: qutip.solver.mesolve.MESolver; :members:; :inherited-members:; :show-inheritance:; :exclude-members: add_integrator. .. autoclass:: qutip.solver.brmesolve.BRSolver; :members:; :inherited-members:; :show-inheritance:; :exclude-members: add_integrator. .. autoclass:: qutip.solver.floquet.FMESolver; :members:; :inherited-members:; :show-inheritance:; :exclude-members: add_integrator. .. autoclass:: qutip.solver.floquet.FloquetBasis; :members:. .. autoclass:: qutip.solver.propagator.Propagator; :members:; :inherited-members:; :special-members: __call__. .. _classes-monte-carlo-solver:. Monte Carlo Solvers; -------------------. .. autoclass:: qutip.solver.mcsolve.MCSolver; :members:; :inherited-members:; :show-inheritance:; :exclude-members: add_integrator. .. autoclass:: qutip.solver.nm_mcsolve.NonMarkovianMCSolver; :members:; :inherited-members:; :show-inheritance:; :exclude-members: add_integrator. .. _classes-non_markov_heom:. Non-Markovian HEOM Solver; -------------------------. .. autoclass:: qutip.solver.heom.HEOMSolver; :members:. .. autoclass:: qutip.solver.heom.HSolverDL; :members:. .. autoclass:: qutip.solver.heom.BathExponent; :members:. .. autoclass:: qutip.solver.heom.Bath; :members:. .. autoclass:: qutip.solver.heom.BosonicBath; :members:. .. autoclass:: qutip.solver.heom.DrudeLorentzBath; :members:. .. autoclass,MatchSource.DOCS,doc/apidoc/classes.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/classes.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/classes.rst:993,Modifiability,inherit,inheritance,993,.. _classes:. ***************; Classes; ***************. .. _classes-qobj:. Qobj; --------------. .. autoclass:: qutip.core.qobj.Qobj; :members:; :special-members: __call__. .. _classes-qobjevo:. QobjEvo; --------------. .. autoclass:: qutip.core.cy.qobjevo.QobjEvo; :members:; :special-members: __call__. .. _classes-bloch:. Bloch sphere; ---------------. .. autoclass:: qutip.bloch.Bloch; :members:. Distributions; -------------. .. autoclass:: qutip.QFunc; :members:. .. _classes-solver:. Solvers; -------. .. autoclass:: qutip.solver.sesolve.SESolver; :members:; :inherited-members:; :show-inheritance:; :exclude-members: add_integrator. .. autoclass:: qutip.solver.mesolve.MESolver; :members:; :inherited-members:; :show-inheritance:; :exclude-members: add_integrator. .. autoclass:: qutip.solver.brmesolve.BRSolver; :members:; :inherited-members:; :show-inheritance:; :exclude-members: add_integrator. .. autoclass:: qutip.solver.floquet.FMESolver; :members:; :inherited-members:; :show-inheritance:; :exclude-members: add_integrator. .. autoclass:: qutip.solver.floquet.FloquetBasis; :members:. .. autoclass:: qutip.solver.propagator.Propagator; :members:; :inherited-members:; :special-members: __call__. .. _classes-monte-carlo-solver:. Monte Carlo Solvers; -------------------. .. autoclass:: qutip.solver.mcsolve.MCSolver; :members:; :inherited-members:; :show-inheritance:; :exclude-members: add_integrator. .. autoclass:: qutip.solver.nm_mcsolve.NonMarkovianMCSolver; :members:; :inherited-members:; :show-inheritance:; :exclude-members: add_integrator. .. _classes-non_markov_heom:. Non-Markovian HEOM Solver; -------------------------. .. autoclass:: qutip.solver.heom.HEOMSolver; :members:. .. autoclass:: qutip.solver.heom.HSolverDL; :members:. .. autoclass:: qutip.solver.heom.BathExponent; :members:. .. autoclass:: qutip.solver.heom.Bath; :members:. .. autoclass:: qutip.solver.heom.BosonicBath; :members:. .. autoclass:: qutip.solver.heom.DrudeLorentzBath; :members:. .. autoclass,MatchSource.DOCS,doc/apidoc/classes.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/classes.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/classes.rst:1165,Modifiability,inherit,inherited-members,1165, _classes-qobjevo:. QobjEvo; --------------. .. autoclass:: qutip.core.cy.qobjevo.QobjEvo; :members:; :special-members: __call__. .. _classes-bloch:. Bloch sphere; ---------------. .. autoclass:: qutip.bloch.Bloch; :members:. Distributions; -------------. .. autoclass:: qutip.QFunc; :members:. .. _classes-solver:. Solvers; -------. .. autoclass:: qutip.solver.sesolve.SESolver; :members:; :inherited-members:; :show-inheritance:; :exclude-members: add_integrator. .. autoclass:: qutip.solver.mesolve.MESolver; :members:; :inherited-members:; :show-inheritance:; :exclude-members: add_integrator. .. autoclass:: qutip.solver.brmesolve.BRSolver; :members:; :inherited-members:; :show-inheritance:; :exclude-members: add_integrator. .. autoclass:: qutip.solver.floquet.FMESolver; :members:; :inherited-members:; :show-inheritance:; :exclude-members: add_integrator. .. autoclass:: qutip.solver.floquet.FloquetBasis; :members:. .. autoclass:: qutip.solver.propagator.Propagator; :members:; :inherited-members:; :special-members: __call__. .. _classes-monte-carlo-solver:. Monte Carlo Solvers; -------------------. .. autoclass:: qutip.solver.mcsolve.MCSolver; :members:; :inherited-members:; :show-inheritance:; :exclude-members: add_integrator. .. autoclass:: qutip.solver.nm_mcsolve.NonMarkovianMCSolver; :members:; :inherited-members:; :show-inheritance:; :exclude-members: add_integrator. .. _classes-non_markov_heom:. Non-Markovian HEOM Solver; -------------------------. .. autoclass:: qutip.solver.heom.HEOMSolver; :members:. .. autoclass:: qutip.solver.heom.HSolverDL; :members:. .. autoclass:: qutip.solver.heom.BathExponent; :members:. .. autoclass:: qutip.solver.heom.Bath; :members:. .. autoclass:: qutip.solver.heom.BosonicBath; :members:. .. autoclass:: qutip.solver.heom.DrudeLorentzBath; :members:. .. autoclass:: qutip.solver.heom.DrudeLorentzPadeBath; :members:. .. autoclass:: qutip.solver.heom.UnderDampedBath; :members:. .. autoclass:: qutip.solver.heom.FermionicBath; :members:. ..,MatchSource.DOCS,doc/apidoc/classes.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/classes.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/classes.rst:1346,Modifiability,inherit,inherited-members,1346, qutip.bloch.Bloch; :members:. Distributions; -------------. .. autoclass:: qutip.QFunc; :members:. .. _classes-solver:. Solvers; -------. .. autoclass:: qutip.solver.sesolve.SESolver; :members:; :inherited-members:; :show-inheritance:; :exclude-members: add_integrator. .. autoclass:: qutip.solver.mesolve.MESolver; :members:; :inherited-members:; :show-inheritance:; :exclude-members: add_integrator. .. autoclass:: qutip.solver.brmesolve.BRSolver; :members:; :inherited-members:; :show-inheritance:; :exclude-members: add_integrator. .. autoclass:: qutip.solver.floquet.FMESolver; :members:; :inherited-members:; :show-inheritance:; :exclude-members: add_integrator. .. autoclass:: qutip.solver.floquet.FloquetBasis; :members:. .. autoclass:: qutip.solver.propagator.Propagator; :members:; :inherited-members:; :special-members: __call__. .. _classes-monte-carlo-solver:. Monte Carlo Solvers; -------------------. .. autoclass:: qutip.solver.mcsolve.MCSolver; :members:; :inherited-members:; :show-inheritance:; :exclude-members: add_integrator. .. autoclass:: qutip.solver.nm_mcsolve.NonMarkovianMCSolver; :members:; :inherited-members:; :show-inheritance:; :exclude-members: add_integrator. .. _classes-non_markov_heom:. Non-Markovian HEOM Solver; -------------------------. .. autoclass:: qutip.solver.heom.HEOMSolver; :members:. .. autoclass:: qutip.solver.heom.HSolverDL; :members:. .. autoclass:: qutip.solver.heom.BathExponent; :members:. .. autoclass:: qutip.solver.heom.Bath; :members:. .. autoclass:: qutip.solver.heom.BosonicBath; :members:. .. autoclass:: qutip.solver.heom.DrudeLorentzBath; :members:. .. autoclass:: qutip.solver.heom.DrudeLorentzPadeBath; :members:. .. autoclass:: qutip.solver.heom.UnderDampedBath; :members:. .. autoclass:: qutip.solver.heom.FermionicBath; :members:. .. autoclass:: qutip.solver.heom.LorentzianBath; :members:. .. autoclass:: qutip.solver.heom.LorentzianPadeBath; :members:. .. autoclass:: qutip.solver.heom.HierarchyADOs; :members:. .. autoclass::,MatchSource.DOCS,doc/apidoc/classes.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/classes.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/classes.rst:1372,Modifiability,inherit,inheritance,1372, qutip.bloch.Bloch; :members:. Distributions; -------------. .. autoclass:: qutip.QFunc; :members:. .. _classes-solver:. Solvers; -------. .. autoclass:: qutip.solver.sesolve.SESolver; :members:; :inherited-members:; :show-inheritance:; :exclude-members: add_integrator. .. autoclass:: qutip.solver.mesolve.MESolver; :members:; :inherited-members:; :show-inheritance:; :exclude-members: add_integrator. .. autoclass:: qutip.solver.brmesolve.BRSolver; :members:; :inherited-members:; :show-inheritance:; :exclude-members: add_integrator. .. autoclass:: qutip.solver.floquet.FMESolver; :members:; :inherited-members:; :show-inheritance:; :exclude-members: add_integrator. .. autoclass:: qutip.solver.floquet.FloquetBasis; :members:. .. autoclass:: qutip.solver.propagator.Propagator; :members:; :inherited-members:; :special-members: __call__. .. _classes-monte-carlo-solver:. Monte Carlo Solvers; -------------------. .. autoclass:: qutip.solver.mcsolve.MCSolver; :members:; :inherited-members:; :show-inheritance:; :exclude-members: add_integrator. .. autoclass:: qutip.solver.nm_mcsolve.NonMarkovianMCSolver; :members:; :inherited-members:; :show-inheritance:; :exclude-members: add_integrator. .. _classes-non_markov_heom:. Non-Markovian HEOM Solver; -------------------------. .. autoclass:: qutip.solver.heom.HEOMSolver; :members:. .. autoclass:: qutip.solver.heom.HSolverDL; :members:. .. autoclass:: qutip.solver.heom.BathExponent; :members:. .. autoclass:: qutip.solver.heom.Bath; :members:. .. autoclass:: qutip.solver.heom.BosonicBath; :members:. .. autoclass:: qutip.solver.heom.DrudeLorentzBath; :members:. .. autoclass:: qutip.solver.heom.DrudeLorentzPadeBath; :members:. .. autoclass:: qutip.solver.heom.UnderDampedBath; :members:. .. autoclass:: qutip.solver.heom.FermionicBath; :members:. .. autoclass:: qutip.solver.heom.LorentzianBath; :members:. .. autoclass:: qutip.solver.heom.LorentzianPadeBath; :members:. .. autoclass:: qutip.solver.heom.HierarchyADOs; :members:. .. autoclass::,MatchSource.DOCS,doc/apidoc/classes.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/classes.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/classes.rst:1493,Modifiability,inherit,inherited-members,1493, autoclass:: qutip.solver.sesolve.SESolver; :members:; :inherited-members:; :show-inheritance:; :exclude-members: add_integrator. .. autoclass:: qutip.solver.mesolve.MESolver; :members:; :inherited-members:; :show-inheritance:; :exclude-members: add_integrator. .. autoclass:: qutip.solver.brmesolve.BRSolver; :members:; :inherited-members:; :show-inheritance:; :exclude-members: add_integrator. .. autoclass:: qutip.solver.floquet.FMESolver; :members:; :inherited-members:; :show-inheritance:; :exclude-members: add_integrator. .. autoclass:: qutip.solver.floquet.FloquetBasis; :members:. .. autoclass:: qutip.solver.propagator.Propagator; :members:; :inherited-members:; :special-members: __call__. .. _classes-monte-carlo-solver:. Monte Carlo Solvers; -------------------. .. autoclass:: qutip.solver.mcsolve.MCSolver; :members:; :inherited-members:; :show-inheritance:; :exclude-members: add_integrator. .. autoclass:: qutip.solver.nm_mcsolve.NonMarkovianMCSolver; :members:; :inherited-members:; :show-inheritance:; :exclude-members: add_integrator. .. _classes-non_markov_heom:. Non-Markovian HEOM Solver; -------------------------. .. autoclass:: qutip.solver.heom.HEOMSolver; :members:. .. autoclass:: qutip.solver.heom.HSolverDL; :members:. .. autoclass:: qutip.solver.heom.BathExponent; :members:. .. autoclass:: qutip.solver.heom.Bath; :members:. .. autoclass:: qutip.solver.heom.BosonicBath; :members:. .. autoclass:: qutip.solver.heom.DrudeLorentzBath; :members:. .. autoclass:: qutip.solver.heom.DrudeLorentzPadeBath; :members:. .. autoclass:: qutip.solver.heom.UnderDampedBath; :members:. .. autoclass:: qutip.solver.heom.FermionicBath; :members:. .. autoclass:: qutip.solver.heom.LorentzianBath; :members:. .. autoclass:: qutip.solver.heom.LorentzianPadeBath; :members:. .. autoclass:: qutip.solver.heom.HierarchyADOs; :members:. .. autoclass:: qutip.solver.heom.HierarchyADOsState; :members:. .. autoclass:: qutip.solver.heom.HEOMResult; :members:. .. _classes-stochastic:. Stochastic,MatchSource.DOCS,doc/apidoc/classes.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/classes.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/classes.rst:1519,Modifiability,inherit,inheritance,1519, autoclass:: qutip.solver.sesolve.SESolver; :members:; :inherited-members:; :show-inheritance:; :exclude-members: add_integrator. .. autoclass:: qutip.solver.mesolve.MESolver; :members:; :inherited-members:; :show-inheritance:; :exclude-members: add_integrator. .. autoclass:: qutip.solver.brmesolve.BRSolver; :members:; :inherited-members:; :show-inheritance:; :exclude-members: add_integrator. .. autoclass:: qutip.solver.floquet.FMESolver; :members:; :inherited-members:; :show-inheritance:; :exclude-members: add_integrator. .. autoclass:: qutip.solver.floquet.FloquetBasis; :members:. .. autoclass:: qutip.solver.propagator.Propagator; :members:; :inherited-members:; :special-members: __call__. .. _classes-monte-carlo-solver:. Monte Carlo Solvers; -------------------. .. autoclass:: qutip.solver.mcsolve.MCSolver; :members:; :inherited-members:; :show-inheritance:; :exclude-members: add_integrator. .. autoclass:: qutip.solver.nm_mcsolve.NonMarkovianMCSolver; :members:; :inherited-members:; :show-inheritance:; :exclude-members: add_integrator. .. _classes-non_markov_heom:. Non-Markovian HEOM Solver; -------------------------. .. autoclass:: qutip.solver.heom.HEOMSolver; :members:. .. autoclass:: qutip.solver.heom.HSolverDL; :members:. .. autoclass:: qutip.solver.heom.BathExponent; :members:. .. autoclass:: qutip.solver.heom.Bath; :members:. .. autoclass:: qutip.solver.heom.BosonicBath; :members:. .. autoclass:: qutip.solver.heom.DrudeLorentzBath; :members:. .. autoclass:: qutip.solver.heom.DrudeLorentzPadeBath; :members:. .. autoclass:: qutip.solver.heom.UnderDampedBath; :members:. .. autoclass:: qutip.solver.heom.FermionicBath; :members:. .. autoclass:: qutip.solver.heom.LorentzianBath; :members:. .. autoclass:: qutip.solver.heom.LorentzianPadeBath; :members:. .. autoclass:: qutip.solver.heom.HierarchyADOs; :members:. .. autoclass:: qutip.solver.heom.HierarchyADOsState; :members:. .. autoclass:: qutip.solver.heom.HEOMResult; :members:. .. _classes-stochastic:. Stochastic,MatchSource.DOCS,doc/apidoc/classes.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/classes.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/classes.rst:2603,Modifiability,inherit,inherited-members,2603,lver; -------------------------. .. autoclass:: qutip.solver.heom.HEOMSolver; :members:. .. autoclass:: qutip.solver.heom.HSolverDL; :members:. .. autoclass:: qutip.solver.heom.BathExponent; :members:. .. autoclass:: qutip.solver.heom.Bath; :members:. .. autoclass:: qutip.solver.heom.BosonicBath; :members:. .. autoclass:: qutip.solver.heom.DrudeLorentzBath; :members:. .. autoclass:: qutip.solver.heom.DrudeLorentzPadeBath; :members:. .. autoclass:: qutip.solver.heom.UnderDampedBath; :members:. .. autoclass:: qutip.solver.heom.FermionicBath; :members:. .. autoclass:: qutip.solver.heom.LorentzianBath; :members:. .. autoclass:: qutip.solver.heom.LorentzianPadeBath; :members:. .. autoclass:: qutip.solver.heom.HierarchyADOs; :members:. .. autoclass:: qutip.solver.heom.HierarchyADOsState; :members:. .. autoclass:: qutip.solver.heom.HEOMResult; :members:. .. _classes-stochastic:. Stochastic Solver; -----------------. .. autoclass:: qutip.solver.stochastic.SMESolver; :members:; :inherited-members:; :exclude-members: add_integrator. .. autoclass:: qutip.solver.stochastic.SSESolver; :members:; :inherited-members:; :exclude-members: add_integrator. .. _classes-ode:. Integrator; ----------. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipyAdams; :members: options. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipyBDF; :members: options. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipylsoda; :members: options. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipyDop853; :members: options. .. autoclass:: qutip.solver.integrator.qutip_integrator.IntegratorVern7; :members: options. .. autoclass:: qutip.solver.integrator.qutip_integrator.IntegratorVern9; :members: options. .. autoclass:: qutip.solver.integrator.qutip_integrator.IntegratorDiag; :members: options. .. autoclass:: qutip.solver.integrator.krylov.IntegratorKrylov; :members: options. .. _classes-sode:. Stochastic Integrator; ----------------,MatchSource.DOCS,doc/apidoc/classes.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/classes.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/classes.rst:2719,Modifiability,inherit,inherited-members,2719,.heom.HSolverDL; :members:. .. autoclass:: qutip.solver.heom.BathExponent; :members:. .. autoclass:: qutip.solver.heom.Bath; :members:. .. autoclass:: qutip.solver.heom.BosonicBath; :members:. .. autoclass:: qutip.solver.heom.DrudeLorentzBath; :members:. .. autoclass:: qutip.solver.heom.DrudeLorentzPadeBath; :members:. .. autoclass:: qutip.solver.heom.UnderDampedBath; :members:. .. autoclass:: qutip.solver.heom.FermionicBath; :members:. .. autoclass:: qutip.solver.heom.LorentzianBath; :members:. .. autoclass:: qutip.solver.heom.LorentzianPadeBath; :members:. .. autoclass:: qutip.solver.heom.HierarchyADOs; :members:. .. autoclass:: qutip.solver.heom.HierarchyADOsState; :members:. .. autoclass:: qutip.solver.heom.HEOMResult; :members:. .. _classes-stochastic:. Stochastic Solver; -----------------. .. autoclass:: qutip.solver.stochastic.SMESolver; :members:; :inherited-members:; :exclude-members: add_integrator. .. autoclass:: qutip.solver.stochastic.SSESolver; :members:; :inherited-members:; :exclude-members: add_integrator. .. _classes-ode:. Integrator; ----------. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipyAdams; :members: options. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipyBDF; :members: options. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipylsoda; :members: options. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipyDop853; :members: options. .. autoclass:: qutip.solver.integrator.qutip_integrator.IntegratorVern7; :members: options. .. autoclass:: qutip.solver.integrator.qutip_integrator.IntegratorVern9; :members: options. .. autoclass:: qutip.solver.integrator.qutip_integrator.IntegratorDiag; :members: options. .. autoclass:: qutip.solver.integrator.krylov.IntegratorKrylov; :members: options. .. _classes-sode:. Stochastic Integrator; ---------------------. .. autoclass:: qutip.solver.sode.rouchon.RouchonSODE; :members: options. .. autoclass:: qutip.solver.sode.ito,MatchSource.DOCS,doc/apidoc/classes.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/classes.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/classes.rst:4457,Modifiability,inherit,inherited-members,4457,". .. autoclass:: qutip.solver.integrator.krylov.IntegratorKrylov; :members: options. .. _classes-sode:. Stochastic Integrator; ---------------------. .. autoclass:: qutip.solver.sode.rouchon.RouchonSODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.EulerSODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Milstein_SODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Taylor1_5_SODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Implicit_Milstein_SODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Implicit_Taylor1_5_SODE; :members: options. .. autoclass:: qutip.solver.sode.sode.PlatenSODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Explicit1_5_SODE; :members: options. .. autoclass:: qutip.solver.sode.sode.PredCorr_SODE; :members: options. .. _classes-odeoptions:. Solver Options and Results; ---------------------------. .. autoclass:: qutip.solver.result.Result; :members:; :inherited-members:; :exclude-members: add_processor, add. .. autoclass:: qutip.solver.result.MultiTrajResult; :members:; :inherited-members:; :exclude-members: add_processor, add, add_end_condition. .. autoclass:: qutip.solver.result.McResult; :members:; :inherited-members:; :exclude-members: add_processor, add, add_end_condition. .. autoclass:: qutip.solver.result.NmmcResult; :members:; :inherited-members:; :exclude-members: add_processor, add, add_end_condition. .. _classes-piqs:. Permutational Invariance; ------------------------. .. autoclass:: qutip.piqs.piqs.Dicke; :members:. .. autoclass:: qutip.piqs.piqs.Pim; :members:. .. _classes-distributions:. Distribution functions; ----------------------. .. autoclass:: qutip.distributions.Distribution; :members:. ..; Docstrings are empty... .. autoclass:: qutip.distributions.WignerDistribution; :members:. .. autoclass:: qutip.distributions.QDistribution; :members:. .. autoclass:: qutip.distributions.TwoModeQuadratureCorrelation; :members:. .. autoclass:: q",MatchSource.DOCS,doc/apidoc/classes.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/classes.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/classes.rst:4579,Modifiability,inherit,inherited-members,4579,"---------------------. .. autoclass:: qutip.solver.sode.rouchon.RouchonSODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.EulerSODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Milstein_SODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Taylor1_5_SODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Implicit_Milstein_SODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Implicit_Taylor1_5_SODE; :members: options. .. autoclass:: qutip.solver.sode.sode.PlatenSODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Explicit1_5_SODE; :members: options. .. autoclass:: qutip.solver.sode.sode.PredCorr_SODE; :members: options. .. _classes-odeoptions:. Solver Options and Results; ---------------------------. .. autoclass:: qutip.solver.result.Result; :members:; :inherited-members:; :exclude-members: add_processor, add. .. autoclass:: qutip.solver.result.MultiTrajResult; :members:; :inherited-members:; :exclude-members: add_processor, add, add_end_condition. .. autoclass:: qutip.solver.result.McResult; :members:; :inherited-members:; :exclude-members: add_processor, add, add_end_condition. .. autoclass:: qutip.solver.result.NmmcResult; :members:; :inherited-members:; :exclude-members: add_processor, add, add_end_condition. .. _classes-piqs:. Permutational Invariance; ------------------------. .. autoclass:: qutip.piqs.piqs.Dicke; :members:. .. autoclass:: qutip.piqs.piqs.Pim; :members:. .. _classes-distributions:. Distribution functions; ----------------------. .. autoclass:: qutip.distributions.Distribution; :members:. ..; Docstrings are empty... .. autoclass:: qutip.distributions.WignerDistribution; :members:. .. autoclass:: qutip.distributions.QDistribution; :members:. .. autoclass:: qutip.distributions.TwoModeQuadratureCorrelation; :members:. .. autoclass:: qutip.distributions.HarmonicOscillatorWaveFunction; :members:. .. autoclass:: qutip.distributions.HarmonicOscillatorProbabilityF",MatchSource.DOCS,doc/apidoc/classes.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/classes.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/classes.rst:4713,Modifiability,inherit,inherited-members,4713,". .. autoclass:: qutip.solver.sode.rouchon.RouchonSODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.EulerSODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Milstein_SODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Taylor1_5_SODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Implicit_Milstein_SODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Implicit_Taylor1_5_SODE; :members: options. .. autoclass:: qutip.solver.sode.sode.PlatenSODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Explicit1_5_SODE; :members: options. .. autoclass:: qutip.solver.sode.sode.PredCorr_SODE; :members: options. .. _classes-odeoptions:. Solver Options and Results; ---------------------------. .. autoclass:: qutip.solver.result.Result; :members:; :inherited-members:; :exclude-members: add_processor, add. .. autoclass:: qutip.solver.result.MultiTrajResult; :members:; :inherited-members:; :exclude-members: add_processor, add, add_end_condition. .. autoclass:: qutip.solver.result.McResult; :members:; :inherited-members:; :exclude-members: add_processor, add, add_end_condition. .. autoclass:: qutip.solver.result.NmmcResult; :members:; :inherited-members:; :exclude-members: add_processor, add, add_end_condition. .. _classes-piqs:. Permutational Invariance; ------------------------. .. autoclass:: qutip.piqs.piqs.Dicke; :members:. .. autoclass:: qutip.piqs.piqs.Pim; :members:. .. _classes-distributions:. Distribution functions; ----------------------. .. autoclass:: qutip.distributions.Distribution; :members:. ..; Docstrings are empty... .. autoclass:: qutip.distributions.WignerDistribution; :members:. .. autoclass:: qutip.distributions.QDistribution; :members:. .. autoclass:: qutip.distributions.TwoModeQuadratureCorrelation; :members:. .. autoclass:: qutip.distributions.HarmonicOscillatorWaveFunction; :members:. .. autoclass:: qutip.distributions.HarmonicOscillatorProbabilityFunction; :members:; ",MatchSource.DOCS,doc/apidoc/classes.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/classes.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/classes.rst:4849,Modifiability,inherit,inherited-members,4849,". .. autoclass:: qutip.solver.sode.rouchon.RouchonSODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.EulerSODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Milstein_SODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Taylor1_5_SODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Implicit_Milstein_SODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Implicit_Taylor1_5_SODE; :members: options. .. autoclass:: qutip.solver.sode.sode.PlatenSODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Explicit1_5_SODE; :members: options. .. autoclass:: qutip.solver.sode.sode.PredCorr_SODE; :members: options. .. _classes-odeoptions:. Solver Options and Results; ---------------------------. .. autoclass:: qutip.solver.result.Result; :members:; :inherited-members:; :exclude-members: add_processor, add. .. autoclass:: qutip.solver.result.MultiTrajResult; :members:; :inherited-members:; :exclude-members: add_processor, add, add_end_condition. .. autoclass:: qutip.solver.result.McResult; :members:; :inherited-members:; :exclude-members: add_processor, add, add_end_condition. .. autoclass:: qutip.solver.result.NmmcResult; :members:; :inherited-members:; :exclude-members: add_processor, add, add_end_condition. .. _classes-piqs:. Permutational Invariance; ------------------------. .. autoclass:: qutip.piqs.piqs.Dicke; :members:. .. autoclass:: qutip.piqs.piqs.Pim; :members:. .. _classes-distributions:. Distribution functions; ----------------------. .. autoclass:: qutip.distributions.Distribution; :members:. ..; Docstrings are empty... .. autoclass:: qutip.distributions.WignerDistribution; :members:. .. autoclass:: qutip.distributions.QDistribution; :members:. .. autoclass:: qutip.distributions.TwoModeQuadratureCorrelation; :members:. .. autoclass:: qutip.distributions.HarmonicOscillatorWaveFunction; :members:. .. autoclass:: qutip.distributions.HarmonicOscillatorProbabilityFunction; :members:; ",MatchSource.DOCS,doc/apidoc/classes.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/classes.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/functions.rst:643,Energy Efficiency,charge,charge,643,".. _functions:. ***************; Functions; ***************. Manipulation and Creation of States and Operators; =================================================. Quantum States; --------------. .. automodule:: qutip.core.states; :members: basis, bell_state, bra, coherent, coherent_dm, fock, fock_dm, ghz_state, maximally_mixed_dm, ket, ket2dm, phase_basis, projection, qutrit_basis, singlet_state, spin_state, spin_coherent, state_number_enumerate, state_number_index, state_index_number, state_number_qobj, thermal_dm, triplet_states, w_state, zero_ket. Quantum Operators; -----------------. .. automodule:: qutip.core.operators; :members: charge, commutator, create, destroy, displace, fcreate, fdestroy, jmat, num, qeye, identity, momentum, phase, position, qdiags, qutrit_ops, qzero, sigmam, sigmap, sigmax, sigmay, sigmaz, spin_Jx, spin_Jy, spin_Jz, spin_Jm, spin_Jp, squeeze, squeezing, tunneling, qeye_like, qzero_like. Quantum Gates; -----------------. .. automodule:: qutip.core.gates; :members: rx, ry, rz, sqrtnot, snot, phasegate, qrot, cy_gate, cz_gate, s_gate, t_gate, cs_gate, ct_gate, cphase, cnot, csign, berkeley, swapalpha, swap, iswap, sqrtswap, sqrtiswap, fredkin, molmer_sorensen, toffoli, hadamard_transform, qubit_clifford_group, globalphase; . Energy Restricted Operators; ---------------------------. .. automodule:: qutip.core.energy_restricted; :members: enr_state_dictionaries, enr_thermal_dm, enr_fock, enr_destroy, enr_identity. .. _functions-rand:. Quantum Objects; ---------------. .. automodule:: qutip.core.qobj; :members: ptrace, issuper, isoper, isoperket, isoperbra, isket, isbra, isherm. Random Operators and States; ---------------------------. .. automodule:: qutip.random_objects; :members: rand_dm, rand_herm, rand_ket, rand_stochastic, rand_unitary, rand_super, rand_super_bcsz, rand_kraus_map. Superoperators and Liouvillians; -------------------------------. .. automodule:: qutip.core.superoperator; :members: operator_to_vector, vector_to_operator, li",MatchSource.DOCS,doc/apidoc/functions.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/functions.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/functions.rst:4809,Integrability,depend,dependent,4809,"==. Schrdinger Equation; --------------------. .. automodule:: qutip.solver.sesolve; :members: sesolve. Master Equation; ---------------. .. automodule:: qutip.solver.mesolve; :members: mesolve. Monte Carlo Evolution; ---------------------. .. automodule:: qutip.solver.mcsolve; :members: mcsolve. .. automodule:: qutip.solver.nm_mcsolve; :members: nm_mcsolve. Krylov Subspace Solver; ----------------------. .. automodule:: qutip.solver.krylovsolve; :members: krylovsolve. Bloch-Redfield Master Equation; ------------------------------. .. automodule:: qutip.solver.brmesolve; :members: brmesolve. Floquet States and Floquet-Markov Master Equation; -------------------------------------------------. .. automodule:: qutip.solver.floquet; :members: fmmesolve, fsesolve, floquet_tensor. Stochastic Schrdinger Equation and Master Equation; ---------------------------------------------------. .. automodule:: qutip.solver.stochastic; :members: ssesolve, smesolve. Constructing time dependent systems; -----------------------------------. .. automodule:: qutip.core.coefficient; :members: coefficient. Hierarchical Equations of Motion; --------------------------------. .. automodule:: qutip.solver.heom; :members: heomsolve. Correlation Functions; ---------------------. .. automodule:: qutip.solver.correlation; :members: correlation_2op_1t, correlation_2op_2t, correlation_3op_1t, correlation_3op_2t, correlation_3op, coherence_function_g1, coherence_function_g2. .. automodule:: qutip.solver.spectrum; :members: spectrum, spectrum_correlation_fft. Steady-state Solvers; --------------------. .. automodule:: qutip.solver.steadystate; :members: steadystate, pseudo_inverse, steadystate_floquet; :undoc-members:. Propagators; -----------. .. automodule:: qutip.solver.propagator; :members: propagator, propagator_steadystate; :undoc-members:. Scattering in Quantum Optical Systems; -------------------------------------. .. automodule:: qutip.solver.scattering; :members: temporal_basis_vector, temp",MatchSource.DOCS,doc/apidoc/functions.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/functions.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/functions.rst:2940,Performance,concurren,concurrence,2940," vector_to_operator, liouvillian, spost, spre, sprepost, lindblad_dissipator. Superoperator Representations; -----------------------------. .. automodule:: qutip.core.superop_reps; :members: kraus_to_choi, kraus_to_super, to_choi, to_chi, to_super, to_kraus, to_stinespring; :undoc-members:. Operators and Superoperator Dimensions; --------------------------------------. .. automodule:: qutip.core.dimensions; :members: to_tensor_rep, from_tensor_rep. Functions acting on states and operators; ========================================. Expectation Values; ------------------. .. automodule:: qutip.core.expect; :members: expect, variance. Tensor; ------. .. automodule:: qutip.core.tensor; :members: tensor, super_tensor, composite, tensor_contract. Partial Transpose; -----------------. .. automodule:: qutip.partial_transpose; :members: partial_transpose. .. _functions-entropy:. Entropy Functions; -----------------. .. automodule:: qutip.entropy; :members: concurrence, entropy_conditional, entropy_linear, entropy_mutual, entropy_relative, entropy_vn. Density Matrix Metrics; ----------------------. .. automodule:: qutip.core.metrics; :members: fidelity, tracedist, bures_dist, bures_angle, hellinger_dist, hilbert_dist, average_gate_fidelity, process_fidelity, unitarity, dnorm. Continuous Variables; --------------------. .. automodule:: qutip.continuous_variables; :members: correlation_matrix, covariance_matrix, correlation_matrix_field, correlation_matrix_quadrature, wigner_covariance_matrix, logarithmic_negativity. Measurement; ===========. Measurement of quantum states; -----------------------------. .. automodule:: qutip.measurement; :members: measure, measure_povm, measure_observable, measurement_statistics, measurement_statistics_observable, measurement_statistics_povm. Dynamics and Time-Evolution; ===========================. Schrdinger Equation; --------------------. .. automodule:: qutip.solver.sesolve; :members: sesolve. Master Equation; ---------------. .. automodul",MatchSource.DOCS,doc/apidoc/functions.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/functions.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/functions.rst:2254,Usability,undo,undoc-members,2254,"ffoli, hadamard_transform, qubit_clifford_group, globalphase; . Energy Restricted Operators; ---------------------------. .. automodule:: qutip.core.energy_restricted; :members: enr_state_dictionaries, enr_thermal_dm, enr_fock, enr_destroy, enr_identity. .. _functions-rand:. Quantum Objects; ---------------. .. automodule:: qutip.core.qobj; :members: ptrace, issuper, isoper, isoperket, isoperbra, isket, isbra, isherm. Random Operators and States; ---------------------------. .. automodule:: qutip.random_objects; :members: rand_dm, rand_herm, rand_ket, rand_stochastic, rand_unitary, rand_super, rand_super_bcsz, rand_kraus_map. Superoperators and Liouvillians; -------------------------------. .. automodule:: qutip.core.superoperator; :members: operator_to_vector, vector_to_operator, liouvillian, spost, spre, sprepost, lindblad_dissipator. Superoperator Representations; -----------------------------. .. automodule:: qutip.core.superop_reps; :members: kraus_to_choi, kraus_to_super, to_choi, to_chi, to_super, to_kraus, to_stinespring; :undoc-members:. Operators and Superoperator Dimensions; --------------------------------------. .. automodule:: qutip.core.dimensions; :members: to_tensor_rep, from_tensor_rep. Functions acting on states and operators; ========================================. Expectation Values; ------------------. .. automodule:: qutip.core.expect; :members: expect, variance. Tensor; ------. .. automodule:: qutip.core.tensor; :members: tensor, super_tensor, composite, tensor_contract. Partial Transpose; -----------------. .. automodule:: qutip.partial_transpose; :members: partial_transpose. .. _functions-entropy:. Entropy Functions; -----------------. .. automodule:: qutip.entropy; :members: concurrence, entropy_conditional, entropy_linear, entropy_mutual, entropy_relative, entropy_vn. Density Matrix Metrics; ----------------------. .. automodule:: qutip.core.metrics; :members: fidelity, tracedist, bures_dist, bures_angle, hellinger_dist, hilbert_dist, a",MatchSource.DOCS,doc/apidoc/functions.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/functions.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/functions.rst:5525,Usability,undo,undoc-members,5525,"--------------------------------. .. automodule:: qutip.solver.floquet; :members: fmmesolve, fsesolve, floquet_tensor. Stochastic Schrdinger Equation and Master Equation; ---------------------------------------------------. .. automodule:: qutip.solver.stochastic; :members: ssesolve, smesolve. Constructing time dependent systems; -----------------------------------. .. automodule:: qutip.core.coefficient; :members: coefficient. Hierarchical Equations of Motion; --------------------------------. .. automodule:: qutip.solver.heom; :members: heomsolve. Correlation Functions; ---------------------. .. automodule:: qutip.solver.correlation; :members: correlation_2op_1t, correlation_2op_2t, correlation_3op_1t, correlation_3op_2t, correlation_3op, coherence_function_g1, coherence_function_g2. .. automodule:: qutip.solver.spectrum; :members: spectrum, spectrum_correlation_fft. Steady-state Solvers; --------------------. .. automodule:: qutip.solver.steadystate; :members: steadystate, pseudo_inverse, steadystate_floquet; :undoc-members:. Propagators; -----------. .. automodule:: qutip.solver.propagator; :members: propagator, propagator_steadystate; :undoc-members:. Scattering in Quantum Optical Systems; -------------------------------------. .. automodule:: qutip.solver.scattering; :members: temporal_basis_vector, temporal_scattered_state, scattering_probability; :undoc-members:. Permutational Invariance; ------------------------. .. automodule:: qutip.piqs.piqs; :members: num_dicke_states, num_dicke_ladders, num_tls, isdiagonal, dicke_blocks, dicke_blocks_full, dicke_function_trace, purity_dicke, entropy_vn_dicke, state_degeneracy, m_degeneracy, energy_degeneracy, ap, am, spin_algebra, jspin, collapse_uncoupled, dicke_basis, dicke, excited, superradiant, css, ghz, ground, identity_uncoupled, block_matrix, tau_column,. Visualization; ===============. Pseudoprobability Functions; ---------------------------. .. automodule:: qutip.wigner; :members: qfunc, spin_q_function, spin",MatchSource.DOCS,doc/apidoc/functions.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/functions.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/functions.rst:5655,Usability,undo,undoc-members,5655,"ger Equation and Master Equation; ---------------------------------------------------. .. automodule:: qutip.solver.stochastic; :members: ssesolve, smesolve. Constructing time dependent systems; -----------------------------------. .. automodule:: qutip.core.coefficient; :members: coefficient. Hierarchical Equations of Motion; --------------------------------. .. automodule:: qutip.solver.heom; :members: heomsolve. Correlation Functions; ---------------------. .. automodule:: qutip.solver.correlation; :members: correlation_2op_1t, correlation_2op_2t, correlation_3op_1t, correlation_3op_2t, correlation_3op, coherence_function_g1, coherence_function_g2. .. automodule:: qutip.solver.spectrum; :members: spectrum, spectrum_correlation_fft. Steady-state Solvers; --------------------. .. automodule:: qutip.solver.steadystate; :members: steadystate, pseudo_inverse, steadystate_floquet; :undoc-members:. Propagators; -----------. .. automodule:: qutip.solver.propagator; :members: propagator, propagator_steadystate; :undoc-members:. Scattering in Quantum Optical Systems; -------------------------------------. .. automodule:: qutip.solver.scattering; :members: temporal_basis_vector, temporal_scattered_state, scattering_probability; :undoc-members:. Permutational Invariance; ------------------------. .. automodule:: qutip.piqs.piqs; :members: num_dicke_states, num_dicke_ladders, num_tls, isdiagonal, dicke_blocks, dicke_blocks_full, dicke_function_trace, purity_dicke, entropy_vn_dicke, state_degeneracy, m_degeneracy, energy_degeneracy, ap, am, spin_algebra, jspin, collapse_uncoupled, dicke_basis, dicke, excited, superradiant, css, ghz, ground, identity_uncoupled, block_matrix, tau_column,. Visualization; ===============. Pseudoprobability Functions; ---------------------------. .. automodule:: qutip.wigner; :members: qfunc, spin_q_function, spin_wigner, wigner. Graphs and Visualization; ------------------------. .. automodule:: qutip.visualization; :members: hinton, matrix_histog",MatchSource.DOCS,doc/apidoc/functions.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/functions.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/functions.rst:5874,Usability,undo,undoc-members,5874,"------------------------------. .. automodule:: qutip.core.coefficient; :members: coefficient. Hierarchical Equations of Motion; --------------------------------. .. automodule:: qutip.solver.heom; :members: heomsolve. Correlation Functions; ---------------------. .. automodule:: qutip.solver.correlation; :members: correlation_2op_1t, correlation_2op_2t, correlation_3op_1t, correlation_3op_2t, correlation_3op, coherence_function_g1, coherence_function_g2. .. automodule:: qutip.solver.spectrum; :members: spectrum, spectrum_correlation_fft. Steady-state Solvers; --------------------. .. automodule:: qutip.solver.steadystate; :members: steadystate, pseudo_inverse, steadystate_floquet; :undoc-members:. Propagators; -----------. .. automodule:: qutip.solver.propagator; :members: propagator, propagator_steadystate; :undoc-members:. Scattering in Quantum Optical Systems; -------------------------------------. .. automodule:: qutip.solver.scattering; :members: temporal_basis_vector, temporal_scattered_state, scattering_probability; :undoc-members:. Permutational Invariance; ------------------------. .. automodule:: qutip.piqs.piqs; :members: num_dicke_states, num_dicke_ladders, num_tls, isdiagonal, dicke_blocks, dicke_blocks_full, dicke_function_trace, purity_dicke, entropy_vn_dicke, state_degeneracy, m_degeneracy, energy_degeneracy, ap, am, spin_algebra, jspin, collapse_uncoupled, dicke_basis, dicke, excited, superradiant, css, ghz, ground, identity_uncoupled, block_matrix, tau_column,. Visualization; ===============. Pseudoprobability Functions; ---------------------------. .. automodule:: qutip.wigner; :members: qfunc, spin_q_function, spin_wigner, wigner. Graphs and Visualization; ------------------------. .. automodule:: qutip.visualization; :members: hinton, matrix_histogram, plot_energy_levels, plot_fock_distribution, plot_wigner, sphereplot, plot_schmidt, plot_qubism, plot_expectation_values, plot_wigner_sphere, plot_spin_distribution; :undoc-members:. .. automodule:",MatchSource.DOCS,doc/apidoc/functions.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/functions.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/functions.rst:6804,Usability,undo,undoc-members,6804,"stems; -------------------------------------. .. automodule:: qutip.solver.scattering; :members: temporal_basis_vector, temporal_scattered_state, scattering_probability; :undoc-members:. Permutational Invariance; ------------------------. .. automodule:: qutip.piqs.piqs; :members: num_dicke_states, num_dicke_ladders, num_tls, isdiagonal, dicke_blocks, dicke_blocks_full, dicke_function_trace, purity_dicke, entropy_vn_dicke, state_degeneracy, m_degeneracy, energy_degeneracy, ap, am, spin_algebra, jspin, collapse_uncoupled, dicke_basis, dicke, excited, superradiant, css, ghz, ground, identity_uncoupled, block_matrix, tau_column,. Visualization; ===============. Pseudoprobability Functions; ---------------------------. .. automodule:: qutip.wigner; :members: qfunc, spin_q_function, spin_wigner, wigner. Graphs and Visualization; ------------------------. .. automodule:: qutip.visualization; :members: hinton, matrix_histogram, plot_energy_levels, plot_fock_distribution, plot_wigner, sphereplot, plot_schmidt, plot_qubism, plot_expectation_values, plot_wigner_sphere, plot_spin_distribution; :undoc-members:. .. automodule:: qutip.animation; :members: anim_hinton, anim_matrix_histogram, anim_fock_distribution, anim_wigner, anim_sphereplot, anim_schmidt, anim_qubism, anim_wigner_sphere, anim_spin_distribution. .. automodule:: qutip.matplotlib_utilities; :members: wigner_cmap, complex_phase_cmap. Quantum Process Tomography; --------------------------. .. automodule:: qutip.tomography; :members: qpt, qpt_plot, qpt_plot_combined; :undoc-members:. .. _functions-non_markov:. Non-Markovian Solvers; =====================. .. automodule:: qutip.solver.nonmarkov.transfertensor; :members: ttmsolve. Utility Functions; =================. .. _functions-utilities:. Utility Functions; -----------------. .. automodule:: qutip.utilities; :members: n_thermal, clebsch, convert_unit. .. _functions-fileio:. File I/O Functions; ------------------. .. automodule:: qutip.fileio; :members: file_data_r",MatchSource.DOCS,doc/apidoc/functions.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/functions.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/functions.rst:7246,Usability,undo,undoc-members,7246,"cke, state_degeneracy, m_degeneracy, energy_degeneracy, ap, am, spin_algebra, jspin, collapse_uncoupled, dicke_basis, dicke, excited, superradiant, css, ghz, ground, identity_uncoupled, block_matrix, tau_column,. Visualization; ===============. Pseudoprobability Functions; ---------------------------. .. automodule:: qutip.wigner; :members: qfunc, spin_q_function, spin_wigner, wigner. Graphs and Visualization; ------------------------. .. automodule:: qutip.visualization; :members: hinton, matrix_histogram, plot_energy_levels, plot_fock_distribution, plot_wigner, sphereplot, plot_schmidt, plot_qubism, plot_expectation_values, plot_wigner_sphere, plot_spin_distribution; :undoc-members:. .. automodule:: qutip.animation; :members: anim_hinton, anim_matrix_histogram, anim_fock_distribution, anim_wigner, anim_sphereplot, anim_schmidt, anim_qubism, anim_wigner_sphere, anim_spin_distribution. .. automodule:: qutip.matplotlib_utilities; :members: wigner_cmap, complex_phase_cmap. Quantum Process Tomography; --------------------------. .. automodule:: qutip.tomography; :members: qpt, qpt_plot, qpt_plot_combined; :undoc-members:. .. _functions-non_markov:. Non-Markovian Solvers; =====================. .. automodule:: qutip.solver.nonmarkov.transfertensor; :members: ttmsolve. Utility Functions; =================. .. _functions-utilities:. Utility Functions; -----------------. .. automodule:: qutip.utilities; :members: n_thermal, clebsch, convert_unit. .. _functions-fileio:. File I/O Functions; ------------------. .. automodule:: qutip.fileio; :members: file_data_read, file_data_store, qload, qsave. .. _functions-parallel:. Parallelization; ---------------. .. automodule:: qutip.solver.parallel; :members: parallel_map, serial_map, loky_pmap, mpi_pmap. .. _functions-ipython:. IPython Notebook Tools; ----------------------. .. automodule:: qutip.ipynbtools; :members: version_table. .. _functions-misc:. Miscellaneous; -------------. .. automodule:: qutip; :members: about, simdiag; ",MatchSource.DOCS,doc/apidoc/functions.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/functions.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:6213,Availability,reliab,reliably,6213,"rpreter, you should be able to ``import qutip`` from anywhere as long as the correct Python environment is active.; Any changes you make to the Python files in the git repository should be immediately present if you restart your Python interpreter and re-import ``qutip``. On the first run, the setup command will compile many C++ extension modules built from Cython sources (files ending ``.pxd`` and ``.pyx``).; Generally the low-level linear algebra routines that QuTiP uses are written in these files, not in pure Python.; Unlike Python files, changes you make to Cython files will not appear until you run ``python setup.py develop`` again; you will only need to re-run this if you are changing Cython files.; Cython will detect and compile only the files that have been changed, so this command will be faster on subsequent runs. .. note::. When undertaking Cython development, the reason we use ``python setup.py develop`` instead of ``pip install -e .`` is because Cython's changed-file detection does not reliably work in the latter.; ``pip`` tends to build in temporary virtual environments, which often makes Cython think its core library files have been updated, triggering a complete, slow rebuild of everything. .. note::. QuTiP follows `NEP29`_ when selecting the supported version of its dependencies.; To see which versions are planned to be supported in the next release, please refer to the :ref:`release roadmap`.; These coincide with the versions employed for testing in continuous integration. In the event of a feature requiring a version upgrade of python or a dependency, it will be considered appropriately in the pull request.; In any case, python and dependency upgrades will only happen in mayor or minor versions of QuTiP, not in a patch. .. _NEP29: https://numpy.org/neps/nep-0029-deprecation_policy.html. Code Style; ----------. The biggest concern you should always have is to make it easy for your code to be read and understood by the person who comes next. All new ",MatchSource.DOCS,doc/development/contributing.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:7419,Availability,avail,available,7419,"ported version of its dependencies.; To see which versions are planned to be supported in the next release, please refer to the :ref:`release roadmap`.; These coincide with the versions employed for testing in continuous integration. In the event of a feature requiring a version upgrade of python or a dependency, it will be considered appropriately in the pull request.; In any case, python and dependency upgrades will only happen in mayor or minor versions of QuTiP, not in a patch. .. _NEP29: https://numpy.org/neps/nep-0029-deprecation_policy.html. Code Style; ----------. The biggest concern you should always have is to make it easy for your code to be read and understood by the person who comes next. All new contributions must follow `PEP 8 style <https://peps.python.org/pep-0008/>`_; all pull requests will be passed through a linter that will complain if you violate it.; You should use the ``pycodestyle`` package locally (available on ``pip``) to test you satisfy the requirements before you push your commits, since this is rather faster than pushing 10 different commits trying to fix minor niggles.; Keep in mind that there is quite a lot of freedom in this style, especially when it comes to line breaks.; If a line is too long, consider the *best* way to split it up with the aim of making the code readable, not just the first thing that doesn't generate a warning. Try to stay consistent with the style of the surrounding code.; This includes using the same variable names, especially if they are function arguments, even if these ""break"" PEP 8 guidelines.; *Do not* change existing parameter, attribute or method names to ""match"" PEP 8; these are breaking user-facing changes, and cannot be made except in a new major release of QuTiP. Other than this, general ""good-practice"" Python standards apply: try not to duplicate code; try to keep functions short, descriptively-named and side-effect free; provide a docstring for every new function; and so on. Documenting; ----------",MatchSource.DOCS,doc/development/contributing.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:9527,Availability,failure,failures,9527,"evant documentation if needed.; If you are making a bug fix, or other relatively minor changes, you will probably only need to make sure that the docstrings of the modified functions and classes are up-to-date; changes here will propagate through to the documentation the next time it is built.; Be sure to follow the |numpydoc|_ when writing docstrings.; All docstrings will be parsed as reStructuredText, and will form the API documentation section of the documentation. .. |numpydoc| replace:: Numpy documentation standards (``numpydoc``); .. _numpydoc: https://numpydoc.readthedocs.io/en/latest/format.html. Testing; -------. We use ``pytest`` as our test runner.; The base way to run every test is ::. pytest /path/to/repo/qutip/tests. This will take around 10 to 30 minutes, depending on your computer and how many of the optional requirements you have installed.; It is normal for some tests to be marked as ""skip"" or ""xfail"" in yellow; these are not problems.; True failures will appear in red and be called ""fail"" or ""error"". While prototyping and making changes, you might want to use some of the filtering features of ``pytest``.; Instead of passing the whole ``tests`` directory to the ``pytest`` command, you can also pass a list of files.; You can also use the ``-k`` selector to only run tests whose names include a particular pattern, for example ::. pytest qutip/tests/test_qobj.py -k ""expm"". to run the tests of :meth:`Qobj.expm`. Changelog Generation; --------------------. We use ``towncrier`` for tracking changes and generating a changelog.; When making a pull request, we require that you add a towncrier entry along with the code changes.; You should create a file named ``<PR number>.<change type>`` in the ``doc/changes`` directory, where the PR number should be substituted for ``<PR number>``, and ``<change type>`` is either ``feature``, ``bugfix``, ``doc``, ``removal``, ``misc``, or ``deprecation``,; depending on the type of change included in the PR. You can also crea",MatchSource.DOCS,doc/development/contributing.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:9580,Availability,error,error,9580,"evant documentation if needed.; If you are making a bug fix, or other relatively minor changes, you will probably only need to make sure that the docstrings of the modified functions and classes are up-to-date; changes here will propagate through to the documentation the next time it is built.; Be sure to follow the |numpydoc|_ when writing docstrings.; All docstrings will be parsed as reStructuredText, and will form the API documentation section of the documentation. .. |numpydoc| replace:: Numpy documentation standards (``numpydoc``); .. _numpydoc: https://numpydoc.readthedocs.io/en/latest/format.html. Testing; -------. We use ``pytest`` as our test runner.; The base way to run every test is ::. pytest /path/to/repo/qutip/tests. This will take around 10 to 30 minutes, depending on your computer and how many of the optional requirements you have installed.; It is normal for some tests to be marked as ""skip"" or ""xfail"" in yellow; these are not problems.; True failures will appear in red and be called ""fail"" or ""error"". While prototyping and making changes, you might want to use some of the filtering features of ``pytest``.; Instead of passing the whole ``tests`` directory to the ``pytest`` command, you can also pass a list of files.; You can also use the ``-k`` selector to only run tests whose names include a particular pattern, for example ::. pytest qutip/tests/test_qobj.py -k ""expm"". to run the tests of :meth:`Qobj.expm`. Changelog Generation; --------------------. We use ``towncrier`` for tracking changes and generating a changelog.; When making a pull request, we require that you add a towncrier entry along with the code changes.; You should create a file named ``<PR number>.<change type>`` in the ``doc/changes`` directory, where the PR number should be substituted for ``<PR number>``, and ``<change type>`` is either ``feature``, ``bugfix``, ``doc``, ``removal``, ``misc``, or ``deprecation``,; depending on the type of change included in the PR. You can also crea",MatchSource.DOCS,doc/development/contributing.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:11590,Availability,down,down,11590,"y installing ``towncrier`` and running. towncrier create <PR number>.<change type>. Running this will create a file in the ``doc/changes`` directory with a filename corresponding to the argument you passed to ``towncrier create``.; In this file, you should add a short description of the changes that the PR introduces. .. _contributing-docs:. Documentation: qutip/qutip (doc directory); ==========================================. The core library is in the `qutip/qutip repository on GitHub, inside the doc directory <https://github.com/qutip/qutip>`_. Building; --------. The documentation is built using ``sphinx``, ``matplotlib`` and ``numpydoc``, with several additional extensions including ``sphinx-gallery`` and ``sphinx-rtd-theme``.; The most up-to-date instructions and dependencies will be in the ``README.md`` file of the documentation directory.; You can see the rendered version of this file simply by going to the `documentation GitHub page <https://github.com/qutip/qutip/tree/master/doc>`_ and scrolling down. Building the documentation can be a little finnicky on occasion.; You likely will want to keep a separate Python environment to build the documentation in, because some of the dependencies can have tight requirements that may conflict with your favourite tools for Python development.; We recommend creating an empty ``conda`` environment containing only Python with ::. conda create -n qutip-doc python=3.8. and install all further dependencies with ``pip``.; There is a ``requirements.txt`` file in the repository root that fixes all package versions exactly into a known-good configuration for a completely empty environment, using ::. pip install -r requirements.txt. This known-good configuration was intended for Python 3.8, though in principle it is possible that other Python versions will work. .. note::. We recommend you use ``pip`` to install dependencies for the documentation rather than ``conda`` because several necessary packages can be slower to update t",MatchSource.DOCS,doc/development/contributing.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:12624,Availability,avail,available,12624,"ge <https://github.com/qutip/qutip/tree/master/doc>`_ and scrolling down. Building the documentation can be a little finnicky on occasion.; You likely will want to keep a separate Python environment to build the documentation in, because some of the dependencies can have tight requirements that may conflict with your favourite tools for Python development.; We recommend creating an empty ``conda`` environment containing only Python with ::. conda create -n qutip-doc python=3.8. and install all further dependencies with ``pip``.; There is a ``requirements.txt`` file in the repository root that fixes all package versions exactly into a known-good configuration for a completely empty environment, using ::. pip install -r requirements.txt. This known-good configuration was intended for Python 3.8, though in principle it is possible that other Python versions will work. .. note::. We recommend you use ``pip`` to install dependencies for the documentation rather than ``conda`` because several necessary packages can be slower to update their ``conda`` recipes, so suitable versions may not be available. The documentation build includes running many components of the main QuTiP library to generate figures and to test the output, and to generate all the API documentation.; You therefore need to have a version of QuTiP available in the same Python environment.; If you are only interested in updating the users' guide, you can use a release version of QuTiP, for example by running ``pip install qutip``.; If you are also modifying the main library, you need to make your development version accessible in this environment.; See the `above section on building QuTiP <contributing-qutip_>`_ for more details, though the ``requirements.txt`` file will have already installed all the build requirements, so you should be able to simply run ::. python setup.py develop. in the main library repository. The documentation is built by running the ``make`` command.; There are several targets to b",MatchSource.DOCS,doc/development/contributing.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:12852,Availability,avail,available,12852,"te tools for Python development.; We recommend creating an empty ``conda`` environment containing only Python with ::. conda create -n qutip-doc python=3.8. and install all further dependencies with ``pip``.; There is a ``requirements.txt`` file in the repository root that fixes all package versions exactly into a known-good configuration for a completely empty environment, using ::. pip install -r requirements.txt. This known-good configuration was intended for Python 3.8, though in principle it is possible that other Python versions will work. .. note::. We recommend you use ``pip`` to install dependencies for the documentation rather than ``conda`` because several necessary packages can be slower to update their ``conda`` recipes, so suitable versions may not be available. The documentation build includes running many components of the main QuTiP library to generate figures and to test the output, and to generate all the API documentation.; You therefore need to have a version of QuTiP available in the same Python environment.; If you are only interested in updating the users' guide, you can use a release version of QuTiP, for example by running ``pip install qutip``.; If you are also modifying the main library, you need to make your development version accessible in this environment.; See the `above section on building QuTiP <contributing-qutip_>`_ for more details, though the ``requirements.txt`` file will have already installed all the build requirements, so you should be able to simply run ::. python setup.py develop. in the main library repository. The documentation is built by running the ``make`` command.; There are several targets to build, but the most useful will be ``html`` to build the webpage documentation, ``latexpdf`` to build the PDF documentation (you will also need a full ``pdflatex`` installation), and ``clean`` to remove all built files.; The most important command you will want to run is ::. make html. You should re-run this any time you make ",MatchSource.DOCS,doc/development/contributing.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:14026,Availability,failure,failure,14026," library, you need to make your development version accessible in this environment.; See the `above section on building QuTiP <contributing-qutip_>`_ for more details, though the ``requirements.txt`` file will have already installed all the build requirements, so you should be able to simply run ::. python setup.py develop. in the main library repository. The documentation is built by running the ``make`` command.; There are several targets to build, but the most useful will be ``html`` to build the webpage documentation, ``latexpdf`` to build the PDF documentation (you will also need a full ``pdflatex`` installation), and ``clean`` to remove all built files.; The most important command you will want to run is ::. make html. You should re-run this any time you make changes, and it should only update files that have been changed. .. important::; The documentation build includes running almost all the optional features of QuTiP.; If you get failure messages in red, make sure you have installed all of the optional dependencies for the main library. The HTML files will be placed in the ``_build/html`` directory.; You can open the file ``_build/html/index.html`` in your web browser to check the output. Code Style; ----------. All user guide pages and docstrings are parsed by Sphinx using reStructuredText.; There is a general `Sphinx usage guide <https://www.sphinx-doc.org/en/master/usage/index.html>`_, which has a lot of information that can sometimes be a little tricky to follow.; It may be easier just to look at other ``.rst`` files already in the documentation to copy the different styles. .. note::; reStructuredText is a very different language to the Markdown that you might be familiar with.; It's always worth checking your work in a web browser to make sure it's appeared the way you intended. Testing; -------. There are unfortunately no automated tests for the documentation.; You should ensure that no errors appeared in red when you ran ``make html``.; Try not to in",MatchSource.DOCS,doc/development/contributing.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:15009,Availability,error,errors,15009,"hould be able to simply run ::. python setup.py develop. in the main library repository. The documentation is built by running the ``make`` command.; There are several targets to build, but the most useful will be ``html`` to build the webpage documentation, ``latexpdf`` to build the PDF documentation (you will also need a full ``pdflatex`` installation), and ``clean`` to remove all built files.; The most important command you will want to run is ::. make html. You should re-run this any time you make changes, and it should only update files that have been changed. .. important::; The documentation build includes running almost all the optional features of QuTiP.; If you get failure messages in red, make sure you have installed all of the optional dependencies for the main library. The HTML files will be placed in the ``_build/html`` directory.; You can open the file ``_build/html/index.html`` in your web browser to check the output. Code Style; ----------. All user guide pages and docstrings are parsed by Sphinx using reStructuredText.; There is a general `Sphinx usage guide <https://www.sphinx-doc.org/en/master/usage/index.html>`_, which has a lot of information that can sometimes be a little tricky to follow.; It may be easier just to look at other ``.rst`` files already in the documentation to copy the different styles. .. note::; reStructuredText is a very different language to the Markdown that you might be familiar with.; It's always worth checking your work in a web browser to make sure it's appeared the way you intended. Testing; -------. There are unfortunately no automated tests for the documentation.; You should ensure that no errors appeared in red when you ran ``make html``.; Try not to introduce any new warnings during the build process.; The main test is to open the HTML pages you have built (open ``_build/html/index.html`` in your web browser), and click through to the relevant pages to make sure everything has rendered the way you expected it to.; ",MatchSource.DOCS,doc/development/contributing.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:2631,Deployability,update,update,2631,"u can check your changes work sensibly.; #. Run the tests for the repository (if it has them).; #. Push the changes to your fork (``git push -u origin <branch-name>``). You won't be able to push to the main QuTiP repositories directly.; #. Go to the GitHub website for the repository you are contributing to, click on the ""Pull Requests"" tab, click the ""New Pull Request"" button, and follow the instructions there. Once the pull request is created, some members of the QuTiP admin team will review the code to make sure it is suitable for inclusion in the library, to check the programming, and to ensure everything meets our standards.; For some repositories, several automated tests will run whenever you create or modify a pull request; in general these will be the same tests you can run locally, and all tests are required to pass online before your changes are merged.; There may be some feedback and possibly some requested changes.; You can add more commits to address these, and push them to the relevant branch of your fork to update the pull request. The rest of this document covers programming standards, and particular considerations for some of the more complicated repositories. .. _contributing-qutip:. Core Library: qutip/qutip; =========================. The core library is in the `qutip/qutip repository on GitHub <https://github.com/qutip/qutip>`_. Building; --------. Building the core library from source is typically a bit more difficult than simply installing the package for regular use.; You will most likely want to do this in a clean Python environment so that you do not compromise a working installation of a release version, for example by starting from ::. conda create -n qutip-dev python. :ref:`Complete instructions for the build <install>` are elsewhere in this guide, however beware that you will need to follow the :ref:`installation from source using setuptools section <build-setuptools>`, not the general installation.; You will need all the *build* and *te",MatchSource.DOCS,doc/development/contributing.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:3069,Deployability,install,installing,3069,"e members of the QuTiP admin team will review the code to make sure it is suitable for inclusion in the library, to check the programming, and to ensure everything meets our standards.; For some repositories, several automated tests will run whenever you create or modify a pull request; in general these will be the same tests you can run locally, and all tests are required to pass online before your changes are merged.; There may be some feedback and possibly some requested changes.; You can add more commits to address these, and push them to the relevant branch of your fork to update the pull request. The rest of this document covers programming standards, and particular considerations for some of the more complicated repositories. .. _contributing-qutip:. Core Library: qutip/qutip; =========================. The core library is in the `qutip/qutip repository on GitHub <https://github.com/qutip/qutip>`_. Building; --------. Building the core library from source is typically a bit more difficult than simply installing the package for regular use.; You will most likely want to do this in a clean Python environment so that you do not compromise a working installation of a release version, for example by starting from ::. conda create -n qutip-dev python. :ref:`Complete instructions for the build <install>` are elsewhere in this guide, however beware that you will need to follow the :ref:`installation from source using setuptools section <build-setuptools>`, not the general installation.; You will need all the *build* and *tests* ""optional"" requirements for the package.; The build requirements can be found in the |pyproject.toml file|_, and the testing requirements are in the ``tests`` key of the ``options.extras_require`` section of |setup.cfg|_.; You will also need the requirements for any optional features you want to test as well. .. |pyproject.toml file| replace:: ``pyproject.toml`` file; .. _pyproject.toml file: https://github.com/qutip/qutip/blob/master/pyprojec",MatchSource.DOCS,doc/development/contributing.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:3217,Deployability,install,installation,3217,"re everything meets our standards.; For some repositories, several automated tests will run whenever you create or modify a pull request; in general these will be the same tests you can run locally, and all tests are required to pass online before your changes are merged.; There may be some feedback and possibly some requested changes.; You can add more commits to address these, and push them to the relevant branch of your fork to update the pull request. The rest of this document covers programming standards, and particular considerations for some of the more complicated repositories. .. _contributing-qutip:. Core Library: qutip/qutip; =========================. The core library is in the `qutip/qutip repository on GitHub <https://github.com/qutip/qutip>`_. Building; --------. Building the core library from source is typically a bit more difficult than simply installing the package for regular use.; You will most likely want to do this in a clean Python environment so that you do not compromise a working installation of a release version, for example by starting from ::. conda create -n qutip-dev python. :ref:`Complete instructions for the build <install>` are elsewhere in this guide, however beware that you will need to follow the :ref:`installation from source using setuptools section <build-setuptools>`, not the general installation.; You will need all the *build* and *tests* ""optional"" requirements for the package.; The build requirements can be found in the |pyproject.toml file|_, and the testing requirements are in the ``tests`` key of the ``options.extras_require`` section of |setup.cfg|_.; You will also need the requirements for any optional features you want to test as well. .. |pyproject.toml file| replace:: ``pyproject.toml`` file; .. _pyproject.toml file: https://github.com/qutip/qutip/blob/master/pyproject.toml; .. |setup.cfg| replace:: ``setup.cfg``; .. _setup.cfg: https://github.com/qutip/qutip/blob/master/setup.cfg. Refer to the main instructions fo",MatchSource.DOCS,doc/development/contributing.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:3235,Deployability,release,release,3235,"re everything meets our standards.; For some repositories, several automated tests will run whenever you create or modify a pull request; in general these will be the same tests you can run locally, and all tests are required to pass online before your changes are merged.; There may be some feedback and possibly some requested changes.; You can add more commits to address these, and push them to the relevant branch of your fork to update the pull request. The rest of this document covers programming standards, and particular considerations for some of the more complicated repositories. .. _contributing-qutip:. Core Library: qutip/qutip; =========================. The core library is in the `qutip/qutip repository on GitHub <https://github.com/qutip/qutip>`_. Building; --------. Building the core library from source is typically a bit more difficult than simply installing the package for regular use.; You will most likely want to do this in a clean Python environment so that you do not compromise a working installation of a release version, for example by starting from ::. conda create -n qutip-dev python. :ref:`Complete instructions for the build <install>` are elsewhere in this guide, however beware that you will need to follow the :ref:`installation from source using setuptools section <build-setuptools>`, not the general installation.; You will need all the *build* and *tests* ""optional"" requirements for the package.; The build requirements can be found in the |pyproject.toml file|_, and the testing requirements are in the ``tests`` key of the ``options.extras_require`` section of |setup.cfg|_.; You will also need the requirements for any optional features you want to test as well. .. |pyproject.toml file| replace:: ``pyproject.toml`` file; .. _pyproject.toml file: https://github.com/qutip/qutip/blob/master/pyproject.toml; .. |setup.cfg| replace:: ``setup.cfg``; .. _setup.cfg: https://github.com/qutip/qutip/blob/master/setup.cfg. Refer to the main instructions fo",MatchSource.DOCS,doc/development/contributing.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:3362,Deployability,install,install,3362," before your changes are merged.; There may be some feedback and possibly some requested changes.; You can add more commits to address these, and push them to the relevant branch of your fork to update the pull request. The rest of this document covers programming standards, and particular considerations for some of the more complicated repositories. .. _contributing-qutip:. Core Library: qutip/qutip; =========================. The core library is in the `qutip/qutip repository on GitHub <https://github.com/qutip/qutip>`_. Building; --------. Building the core library from source is typically a bit more difficult than simply installing the package for regular use.; You will most likely want to do this in a clean Python environment so that you do not compromise a working installation of a release version, for example by starting from ::. conda create -n qutip-dev python. :ref:`Complete instructions for the build <install>` are elsewhere in this guide, however beware that you will need to follow the :ref:`installation from source using setuptools section <build-setuptools>`, not the general installation.; You will need all the *build* and *tests* ""optional"" requirements for the package.; The build requirements can be found in the |pyproject.toml file|_, and the testing requirements are in the ``tests`` key of the ``options.extras_require`` section of |setup.cfg|_.; You will also need the requirements for any optional features you want to test as well. .. |pyproject.toml file| replace:: ``pyproject.toml`` file; .. _pyproject.toml file: https://github.com/qutip/qutip/blob/master/pyproject.toml; .. |setup.cfg| replace:: ``setup.cfg``; .. _setup.cfg: https://github.com/qutip/qutip/blob/master/setup.cfg. Refer to the main instructions for the most up-to-date version, however as of version 4.6 the requirements can be installed into a conda environment with ::. conda install setuptools wheel numpy scipy cython packaging pytest pytest-rerunfailures. Note that ``qutip`` should ",MatchSource.DOCS,doc/development/contributing.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:3455,Deployability,install,installation,3455," before your changes are merged.; There may be some feedback and possibly some requested changes.; You can add more commits to address these, and push them to the relevant branch of your fork to update the pull request. The rest of this document covers programming standards, and particular considerations for some of the more complicated repositories. .. _contributing-qutip:. Core Library: qutip/qutip; =========================. The core library is in the `qutip/qutip repository on GitHub <https://github.com/qutip/qutip>`_. Building; --------. Building the core library from source is typically a bit more difficult than simply installing the package for regular use.; You will most likely want to do this in a clean Python environment so that you do not compromise a working installation of a release version, for example by starting from ::. conda create -n qutip-dev python. :ref:`Complete instructions for the build <install>` are elsewhere in this guide, however beware that you will need to follow the :ref:`installation from source using setuptools section <build-setuptools>`, not the general installation.; You will need all the *build* and *tests* ""optional"" requirements for the package.; The build requirements can be found in the |pyproject.toml file|_, and the testing requirements are in the ``tests`` key of the ``options.extras_require`` section of |setup.cfg|_.; You will also need the requirements for any optional features you want to test as well. .. |pyproject.toml file| replace:: ``pyproject.toml`` file; .. _pyproject.toml file: https://github.com/qutip/qutip/blob/master/pyproject.toml; .. |setup.cfg| replace:: ``setup.cfg``; .. _setup.cfg: https://github.com/qutip/qutip/blob/master/setup.cfg. Refer to the main instructions for the most up-to-date version, however as of version 4.6 the requirements can be installed into a conda environment with ::. conda install setuptools wheel numpy scipy cython packaging pytest pytest-rerunfailures. Note that ``qutip`` should ",MatchSource.DOCS,doc/development/contributing.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:3542,Deployability,install,installation,3542," before your changes are merged.; There may be some feedback and possibly some requested changes.; You can add more commits to address these, and push them to the relevant branch of your fork to update the pull request. The rest of this document covers programming standards, and particular considerations for some of the more complicated repositories. .. _contributing-qutip:. Core Library: qutip/qutip; =========================. The core library is in the `qutip/qutip repository on GitHub <https://github.com/qutip/qutip>`_. Building; --------. Building the core library from source is typically a bit more difficult than simply installing the package for regular use.; You will most likely want to do this in a clean Python environment so that you do not compromise a working installation of a release version, for example by starting from ::. conda create -n qutip-dev python. :ref:`Complete instructions for the build <install>` are elsewhere in this guide, however beware that you will need to follow the :ref:`installation from source using setuptools section <build-setuptools>`, not the general installation.; You will need all the *build* and *tests* ""optional"" requirements for the package.; The build requirements can be found in the |pyproject.toml file|_, and the testing requirements are in the ``tests`` key of the ``options.extras_require`` section of |setup.cfg|_.; You will also need the requirements for any optional features you want to test as well. .. |pyproject.toml file| replace:: ``pyproject.toml`` file; .. _pyproject.toml file: https://github.com/qutip/qutip/blob/master/pyproject.toml; .. |setup.cfg| replace:: ``setup.cfg``; .. _setup.cfg: https://github.com/qutip/qutip/blob/master/setup.cfg. Refer to the main instructions for the most up-to-date version, however as of version 4.6 the requirements can be installed into a conda environment with ::. conda install setuptools wheel numpy scipy cython packaging pytest pytest-rerunfailures. Note that ``qutip`` should ",MatchSource.DOCS,doc/development/contributing.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:4277,Deployability,install,installed,4277,"conda create -n qutip-dev python. :ref:`Complete instructions for the build <install>` are elsewhere in this guide, however beware that you will need to follow the :ref:`installation from source using setuptools section <build-setuptools>`, not the general installation.; You will need all the *build* and *tests* ""optional"" requirements for the package.; The build requirements can be found in the |pyproject.toml file|_, and the testing requirements are in the ``tests`` key of the ``options.extras_require`` section of |setup.cfg|_.; You will also need the requirements for any optional features you want to test as well. .. |pyproject.toml file| replace:: ``pyproject.toml`` file; .. _pyproject.toml file: https://github.com/qutip/qutip/blob/master/pyproject.toml; .. |setup.cfg| replace:: ``setup.cfg``; .. _setup.cfg: https://github.com/qutip/qutip/blob/master/setup.cfg. Refer to the main instructions for the most up-to-date version, however as of version 4.6 the requirements can be installed into a conda environment with ::. conda install setuptools wheel numpy scipy cython packaging pytest pytest-rerunfailures. Note that ``qutip`` should *not* be installed with ``conda install``. .. note::; If you prefer, you can also use ``pip`` to install all the dependencies.; We typically recommend ``conda`` when doing main-library development because it is easier to switch low-level packages around like BLAS implementations, but if this doesn't mean anything to you, feel free to use ``pip``. You will need to make sure you have a functioning C++ compiler to build QuTiP.; If you are on Linux or Mac, this is likely already done for you, however if you are on Windows, refer to the :ref:`Windows installation <install-on-windows>` section of the installation guide. The command to build QuTiP in editable mode is ::. python setup.py develop. from the repository directory.; If you now load up a Python interpreter, you should be able to ``import qutip`` from anywhere as long as the correct Py",MatchSource.DOCS,doc/development/contributing.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:4327,Deployability,install,install,4327,"stall>` are elsewhere in this guide, however beware that you will need to follow the :ref:`installation from source using setuptools section <build-setuptools>`, not the general installation.; You will need all the *build* and *tests* ""optional"" requirements for the package.; The build requirements can be found in the |pyproject.toml file|_, and the testing requirements are in the ``tests`` key of the ``options.extras_require`` section of |setup.cfg|_.; You will also need the requirements for any optional features you want to test as well. .. |pyproject.toml file| replace:: ``pyproject.toml`` file; .. _pyproject.toml file: https://github.com/qutip/qutip/blob/master/pyproject.toml; .. |setup.cfg| replace:: ``setup.cfg``; .. _setup.cfg: https://github.com/qutip/qutip/blob/master/setup.cfg. Refer to the main instructions for the most up-to-date version, however as of version 4.6 the requirements can be installed into a conda environment with ::. conda install setuptools wheel numpy scipy cython packaging pytest pytest-rerunfailures. Note that ``qutip`` should *not* be installed with ``conda install``. .. note::; If you prefer, you can also use ``pip`` to install all the dependencies.; We typically recommend ``conda`` when doing main-library development because it is easier to switch low-level packages around like BLAS implementations, but if this doesn't mean anything to you, feel free to use ``pip``. You will need to make sure you have a functioning C++ compiler to build QuTiP.; If you are on Linux or Mac, this is likely already done for you, however if you are on Windows, refer to the :ref:`Windows installation <install-on-windows>` section of the installation guide. The command to build QuTiP in editable mode is ::. python setup.py develop. from the repository directory.; If you now load up a Python interpreter, you should be able to ``import qutip`` from anywhere as long as the correct Python environment is active.; Any changes you make to the Python files in the gi",MatchSource.DOCS,doc/development/contributing.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:4446,Deployability,install,installed,4446," the :ref:`installation from source using setuptools section <build-setuptools>`, not the general installation.; You will need all the *build* and *tests* ""optional"" requirements for the package.; The build requirements can be found in the |pyproject.toml file|_, and the testing requirements are in the ``tests`` key of the ``options.extras_require`` section of |setup.cfg|_.; You will also need the requirements for any optional features you want to test as well. .. |pyproject.toml file| replace:: ``pyproject.toml`` file; .. _pyproject.toml file: https://github.com/qutip/qutip/blob/master/pyproject.toml; .. |setup.cfg| replace:: ``setup.cfg``; .. _setup.cfg: https://github.com/qutip/qutip/blob/master/setup.cfg. Refer to the main instructions for the most up-to-date version, however as of version 4.6 the requirements can be installed into a conda environment with ::. conda install setuptools wheel numpy scipy cython packaging pytest pytest-rerunfailures. Note that ``qutip`` should *not* be installed with ``conda install``. .. note::; If you prefer, you can also use ``pip`` to install all the dependencies.; We typically recommend ``conda`` when doing main-library development because it is easier to switch low-level packages around like BLAS implementations, but if this doesn't mean anything to you, feel free to use ``pip``. You will need to make sure you have a functioning C++ compiler to build QuTiP.; If you are on Linux or Mac, this is likely already done for you, however if you are on Windows, refer to the :ref:`Windows installation <install-on-windows>` section of the installation guide. The command to build QuTiP in editable mode is ::. python setup.py develop. from the repository directory.; If you now load up a Python interpreter, you should be able to ``import qutip`` from anywhere as long as the correct Python environment is active.; Any changes you make to the Python files in the git repository should be immediately present if you restart your Python interpret",MatchSource.DOCS,doc/development/contributing.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:4469,Deployability,install,install,4469," the :ref:`installation from source using setuptools section <build-setuptools>`, not the general installation.; You will need all the *build* and *tests* ""optional"" requirements for the package.; The build requirements can be found in the |pyproject.toml file|_, and the testing requirements are in the ``tests`` key of the ``options.extras_require`` section of |setup.cfg|_.; You will also need the requirements for any optional features you want to test as well. .. |pyproject.toml file| replace:: ``pyproject.toml`` file; .. _pyproject.toml file: https://github.com/qutip/qutip/blob/master/pyproject.toml; .. |setup.cfg| replace:: ``setup.cfg``; .. _setup.cfg: https://github.com/qutip/qutip/blob/master/setup.cfg. Refer to the main instructions for the most up-to-date version, however as of version 4.6 the requirements can be installed into a conda environment with ::. conda install setuptools wheel numpy scipy cython packaging pytest pytest-rerunfailures. Note that ``qutip`` should *not* be installed with ``conda install``. .. note::; If you prefer, you can also use ``pip`` to install all the dependencies.; We typically recommend ``conda`` when doing main-library development because it is easier to switch low-level packages around like BLAS implementations, but if this doesn't mean anything to you, feel free to use ``pip``. You will need to make sure you have a functioning C++ compiler to build QuTiP.; If you are on Linux or Mac, this is likely already done for you, however if you are on Windows, refer to the :ref:`Windows installation <install-on-windows>` section of the installation guide. The command to build QuTiP in editable mode is ::. python setup.py develop. from the repository directory.; If you now load up a Python interpreter, you should be able to ``import qutip`` from anywhere as long as the correct Python environment is active.; Any changes you make to the Python files in the git repository should be immediately present if you restart your Python interpret",MatchSource.DOCS,doc/development/contributing.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:4534,Deployability,install,install,4534,">`, not the general installation.; You will need all the *build* and *tests* ""optional"" requirements for the package.; The build requirements can be found in the |pyproject.toml file|_, and the testing requirements are in the ``tests`` key of the ``options.extras_require`` section of |setup.cfg|_.; You will also need the requirements for any optional features you want to test as well. .. |pyproject.toml file| replace:: ``pyproject.toml`` file; .. _pyproject.toml file: https://github.com/qutip/qutip/blob/master/pyproject.toml; .. |setup.cfg| replace:: ``setup.cfg``; .. _setup.cfg: https://github.com/qutip/qutip/blob/master/setup.cfg. Refer to the main instructions for the most up-to-date version, however as of version 4.6 the requirements can be installed into a conda environment with ::. conda install setuptools wheel numpy scipy cython packaging pytest pytest-rerunfailures. Note that ``qutip`` should *not* be installed with ``conda install``. .. note::; If you prefer, you can also use ``pip`` to install all the dependencies.; We typically recommend ``conda`` when doing main-library development because it is easier to switch low-level packages around like BLAS implementations, but if this doesn't mean anything to you, feel free to use ``pip``. You will need to make sure you have a functioning C++ compiler to build QuTiP.; If you are on Linux or Mac, this is likely already done for you, however if you are on Windows, refer to the :ref:`Windows installation <install-on-windows>` section of the installation guide. The command to build QuTiP in editable mode is ::. python setup.py develop. from the repository directory.; If you now load up a Python interpreter, you should be able to ``import qutip`` from anywhere as long as the correct Python environment is active.; Any changes you make to the Python files in the git repository should be immediately present if you restart your Python interpreter and re-import ``qutip``. On the first run, the setup command will compile ma",MatchSource.DOCS,doc/development/contributing.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:4989,Deployability,install,installation,4989,"`` file; .. _pyproject.toml file: https://github.com/qutip/qutip/blob/master/pyproject.toml; .. |setup.cfg| replace:: ``setup.cfg``; .. _setup.cfg: https://github.com/qutip/qutip/blob/master/setup.cfg. Refer to the main instructions for the most up-to-date version, however as of version 4.6 the requirements can be installed into a conda environment with ::. conda install setuptools wheel numpy scipy cython packaging pytest pytest-rerunfailures. Note that ``qutip`` should *not* be installed with ``conda install``. .. note::; If you prefer, you can also use ``pip`` to install all the dependencies.; We typically recommend ``conda`` when doing main-library development because it is easier to switch low-level packages around like BLAS implementations, but if this doesn't mean anything to you, feel free to use ``pip``. You will need to make sure you have a functioning C++ compiler to build QuTiP.; If you are on Linux or Mac, this is likely already done for you, however if you are on Windows, refer to the :ref:`Windows installation <install-on-windows>` section of the installation guide. The command to build QuTiP in editable mode is ::. python setup.py develop. from the repository directory.; If you now load up a Python interpreter, you should be able to ``import qutip`` from anywhere as long as the correct Python environment is active.; Any changes you make to the Python files in the git repository should be immediately present if you restart your Python interpreter and re-import ``qutip``. On the first run, the setup command will compile many C++ extension modules built from Cython sources (files ending ``.pxd`` and ``.pyx``).; Generally the low-level linear algebra routines that QuTiP uses are written in these files, not in pure Python.; Unlike Python files, changes you make to Cython files will not appear until you run ``python setup.py develop`` again; you will only need to re-run this if you are changing Cython files.; Cython will detect and compile only the files t",MatchSource.DOCS,doc/development/contributing.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:5003,Deployability,install,install-on-windows,5003,"`` file; .. _pyproject.toml file: https://github.com/qutip/qutip/blob/master/pyproject.toml; .. |setup.cfg| replace:: ``setup.cfg``; .. _setup.cfg: https://github.com/qutip/qutip/blob/master/setup.cfg. Refer to the main instructions for the most up-to-date version, however as of version 4.6 the requirements can be installed into a conda environment with ::. conda install setuptools wheel numpy scipy cython packaging pytest pytest-rerunfailures. Note that ``qutip`` should *not* be installed with ``conda install``. .. note::; If you prefer, you can also use ``pip`` to install all the dependencies.; We typically recommend ``conda`` when doing main-library development because it is easier to switch low-level packages around like BLAS implementations, but if this doesn't mean anything to you, feel free to use ``pip``. You will need to make sure you have a functioning C++ compiler to build QuTiP.; If you are on Linux or Mac, this is likely already done for you, however if you are on Windows, refer to the :ref:`Windows installation <install-on-windows>` section of the installation guide. The command to build QuTiP in editable mode is ::. python setup.py develop. from the repository directory.; If you now load up a Python interpreter, you should be able to ``import qutip`` from anywhere as long as the correct Python environment is active.; Any changes you make to the Python files in the git repository should be immediately present if you restart your Python interpreter and re-import ``qutip``. On the first run, the setup command will compile many C++ extension modules built from Cython sources (files ending ``.pxd`` and ``.pyx``).; Generally the low-level linear algebra routines that QuTiP uses are written in these files, not in pure Python.; Unlike Python files, changes you make to Cython files will not appear until you run ``python setup.py develop`` again; you will only need to re-run this if you are changing Cython files.; Cython will detect and compile only the files t",MatchSource.DOCS,doc/development/contributing.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:5039,Deployability,install,installation,5039,"`` file; .. _pyproject.toml file: https://github.com/qutip/qutip/blob/master/pyproject.toml; .. |setup.cfg| replace:: ``setup.cfg``; .. _setup.cfg: https://github.com/qutip/qutip/blob/master/setup.cfg. Refer to the main instructions for the most up-to-date version, however as of version 4.6 the requirements can be installed into a conda environment with ::. conda install setuptools wheel numpy scipy cython packaging pytest pytest-rerunfailures. Note that ``qutip`` should *not* be installed with ``conda install``. .. note::; If you prefer, you can also use ``pip`` to install all the dependencies.; We typically recommend ``conda`` when doing main-library development because it is easier to switch low-level packages around like BLAS implementations, but if this doesn't mean anything to you, feel free to use ``pip``. You will need to make sure you have a functioning C++ compiler to build QuTiP.; If you are on Linux or Mac, this is likely already done for you, however if you are on Windows, refer to the :ref:`Windows installation <install-on-windows>` section of the installation guide. The command to build QuTiP in editable mode is ::. python setup.py develop. from the repository directory.; If you now load up a Python interpreter, you should be able to ``import qutip`` from anywhere as long as the correct Python environment is active.; Any changes you make to the Python files in the git repository should be immediately present if you restart your Python interpreter and re-import ``qutip``. On the first run, the setup command will compile many C++ extension modules built from Cython sources (files ending ``.pxd`` and ``.pyx``).; Generally the low-level linear algebra routines that QuTiP uses are written in these files, not in pure Python.; Unlike Python files, changes you make to Cython files will not appear until you run ``python setup.py develop`` again; you will only need to re-run this if you are changing Cython files.; Cython will detect and compile only the files t",MatchSource.DOCS,doc/development/contributing.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:6146,Deployability,install,install,6146,"om the repository directory.; If you now load up a Python interpreter, you should be able to ``import qutip`` from anywhere as long as the correct Python environment is active.; Any changes you make to the Python files in the git repository should be immediately present if you restart your Python interpreter and re-import ``qutip``. On the first run, the setup command will compile many C++ extension modules built from Cython sources (files ending ``.pxd`` and ``.pyx``).; Generally the low-level linear algebra routines that QuTiP uses are written in these files, not in pure Python.; Unlike Python files, changes you make to Cython files will not appear until you run ``python setup.py develop`` again; you will only need to re-run this if you are changing Cython files.; Cython will detect and compile only the files that have been changed, so this command will be faster on subsequent runs. .. note::. When undertaking Cython development, the reason we use ``python setup.py develop`` instead of ``pip install -e .`` is because Cython's changed-file detection does not reliably work in the latter.; ``pip`` tends to build in temporary virtual environments, which often makes Cython think its core library files have been updated, triggering a complete, slow rebuild of everything. .. note::. QuTiP follows `NEP29`_ when selecting the supported version of its dependencies.; To see which versions are planned to be supported in the next release, please refer to the :ref:`release roadmap`.; These coincide with the versions employed for testing in continuous integration. In the event of a feature requiring a version upgrade of python or a dependency, it will be considered appropriately in the pull request.; In any case, python and dependency upgrades will only happen in mayor or minor versions of QuTiP, not in a patch. .. _NEP29: https://numpy.org/neps/nep-0029-deprecation_policy.html. Code Style; ----------. The biggest concern you should always have is to make it easy for your code t",MatchSource.DOCS,doc/development/contributing.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:6365,Deployability,update,updated,6365,"ake to the Python files in the git repository should be immediately present if you restart your Python interpreter and re-import ``qutip``. On the first run, the setup command will compile many C++ extension modules built from Cython sources (files ending ``.pxd`` and ``.pyx``).; Generally the low-level linear algebra routines that QuTiP uses are written in these files, not in pure Python.; Unlike Python files, changes you make to Cython files will not appear until you run ``python setup.py develop`` again; you will only need to re-run this if you are changing Cython files.; Cython will detect and compile only the files that have been changed, so this command will be faster on subsequent runs. .. note::. When undertaking Cython development, the reason we use ``python setup.py develop`` instead of ``pip install -e .`` is because Cython's changed-file detection does not reliably work in the latter.; ``pip`` tends to build in temporary virtual environments, which often makes Cython think its core library files have been updated, triggering a complete, slow rebuild of everything. .. note::. QuTiP follows `NEP29`_ when selecting the supported version of its dependencies.; To see which versions are planned to be supported in the next release, please refer to the :ref:`release roadmap`.; These coincide with the versions employed for testing in continuous integration. In the event of a feature requiring a version upgrade of python or a dependency, it will be considered appropriately in the pull request.; In any case, python and dependency upgrades will only happen in mayor or minor versions of QuTiP, not in a patch. .. _NEP29: https://numpy.org/neps/nep-0029-deprecation_policy.html. Code Style; ----------. The biggest concern you should always have is to make it easy for your code to be read and understood by the person who comes next. All new contributions must follow `PEP 8 style <https://peps.python.org/pep-0008/>`_; all pull requests will be passed through a linter that ",MatchSource.DOCS,doc/development/contributing.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:6580,Deployability,release,release,6580,"(files ending ``.pxd`` and ``.pyx``).; Generally the low-level linear algebra routines that QuTiP uses are written in these files, not in pure Python.; Unlike Python files, changes you make to Cython files will not appear until you run ``python setup.py develop`` again; you will only need to re-run this if you are changing Cython files.; Cython will detect and compile only the files that have been changed, so this command will be faster on subsequent runs. .. note::. When undertaking Cython development, the reason we use ``python setup.py develop`` instead of ``pip install -e .`` is because Cython's changed-file detection does not reliably work in the latter.; ``pip`` tends to build in temporary virtual environments, which often makes Cython think its core library files have been updated, triggering a complete, slow rebuild of everything. .. note::. QuTiP follows `NEP29`_ when selecting the supported version of its dependencies.; To see which versions are planned to be supported in the next release, please refer to the :ref:`release roadmap`.; These coincide with the versions employed for testing in continuous integration. In the event of a feature requiring a version upgrade of python or a dependency, it will be considered appropriately in the pull request.; In any case, python and dependency upgrades will only happen in mayor or minor versions of QuTiP, not in a patch. .. _NEP29: https://numpy.org/neps/nep-0029-deprecation_policy.html. Code Style; ----------. The biggest concern you should always have is to make it easy for your code to be read and understood by the person who comes next. All new contributions must follow `PEP 8 style <https://peps.python.org/pep-0008/>`_; all pull requests will be passed through a linter that will complain if you violate it.; You should use the ``pycodestyle`` package locally (available on ``pip``) to test you satisfy the requirements before you push your commits, since this is rather faster than pushing 10 different commits tryi",MatchSource.DOCS,doc/development/contributing.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:6615,Deployability,release,release,6615,"(files ending ``.pxd`` and ``.pyx``).; Generally the low-level linear algebra routines that QuTiP uses are written in these files, not in pure Python.; Unlike Python files, changes you make to Cython files will not appear until you run ``python setup.py develop`` again; you will only need to re-run this if you are changing Cython files.; Cython will detect and compile only the files that have been changed, so this command will be faster on subsequent runs. .. note::. When undertaking Cython development, the reason we use ``python setup.py develop`` instead of ``pip install -e .`` is because Cython's changed-file detection does not reliably work in the latter.; ``pip`` tends to build in temporary virtual environments, which often makes Cython think its core library files have been updated, triggering a complete, slow rebuild of everything. .. note::. QuTiP follows `NEP29`_ when selecting the supported version of its dependencies.; To see which versions are planned to be supported in the next release, please refer to the :ref:`release roadmap`.; These coincide with the versions employed for testing in continuous integration. In the event of a feature requiring a version upgrade of python or a dependency, it will be considered appropriately in the pull request.; In any case, python and dependency upgrades will only happen in mayor or minor versions of QuTiP, not in a patch. .. _NEP29: https://numpy.org/neps/nep-0029-deprecation_policy.html. Code Style; ----------. The biggest concern you should always have is to make it easy for your code to be read and understood by the person who comes next. All new contributions must follow `PEP 8 style <https://peps.python.org/pep-0008/>`_; all pull requests will be passed through a linter that will complain if you violate it.; You should use the ``pycodestyle`` package locally (available on ``pip``) to test you satisfy the requirements before you push your commits, since this is rather faster than pushing 10 different commits tryi",MatchSource.DOCS,doc/development/contributing.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:6691,Deployability,continuous,continuous,6691,"ses are written in these files, not in pure Python.; Unlike Python files, changes you make to Cython files will not appear until you run ``python setup.py develop`` again; you will only need to re-run this if you are changing Cython files.; Cython will detect and compile only the files that have been changed, so this command will be faster on subsequent runs. .. note::. When undertaking Cython development, the reason we use ``python setup.py develop`` instead of ``pip install -e .`` is because Cython's changed-file detection does not reliably work in the latter.; ``pip`` tends to build in temporary virtual environments, which often makes Cython think its core library files have been updated, triggering a complete, slow rebuild of everything. .. note::. QuTiP follows `NEP29`_ when selecting the supported version of its dependencies.; To see which versions are planned to be supported in the next release, please refer to the :ref:`release roadmap`.; These coincide with the versions employed for testing in continuous integration. In the event of a feature requiring a version upgrade of python or a dependency, it will be considered appropriately in the pull request.; In any case, python and dependency upgrades will only happen in mayor or minor versions of QuTiP, not in a patch. .. _NEP29: https://numpy.org/neps/nep-0029-deprecation_policy.html. Code Style; ----------. The biggest concern you should always have is to make it easy for your code to be read and understood by the person who comes next. All new contributions must follow `PEP 8 style <https://peps.python.org/pep-0008/>`_; all pull requests will be passed through a linter that will complain if you violate it.; You should use the ``pycodestyle`` package locally (available on ``pip``) to test you satisfy the requirements before you push your commits, since this is rather faster than pushing 10 different commits trying to fix minor niggles.; Keep in mind that there is quite a lot of freedom in this style, especial",MatchSource.DOCS,doc/development/contributing.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:6702,Deployability,integrat,integration,6702,"ses are written in these files, not in pure Python.; Unlike Python files, changes you make to Cython files will not appear until you run ``python setup.py develop`` again; you will only need to re-run this if you are changing Cython files.; Cython will detect and compile only the files that have been changed, so this command will be faster on subsequent runs. .. note::. When undertaking Cython development, the reason we use ``python setup.py develop`` instead of ``pip install -e .`` is because Cython's changed-file detection does not reliably work in the latter.; ``pip`` tends to build in temporary virtual environments, which often makes Cython think its core library files have been updated, triggering a complete, slow rebuild of everything. .. note::. QuTiP follows `NEP29`_ when selecting the supported version of its dependencies.; To see which versions are planned to be supported in the next release, please refer to the :ref:`release roadmap`.; These coincide with the versions employed for testing in continuous integration. In the event of a feature requiring a version upgrade of python or a dependency, it will be considered appropriately in the pull request.; In any case, python and dependency upgrades will only happen in mayor or minor versions of QuTiP, not in a patch. .. _NEP29: https://numpy.org/neps/nep-0029-deprecation_policy.html. Code Style; ----------. The biggest concern you should always have is to make it easy for your code to be read and understood by the person who comes next. All new contributions must follow `PEP 8 style <https://peps.python.org/pep-0008/>`_; all pull requests will be passed through a linter that will complain if you violate it.; You should use the ``pycodestyle`` package locally (available on ``pip``) to test you satisfy the requirements before you push your commits, since this is rather faster than pushing 10 different commits trying to fix minor niggles.; Keep in mind that there is quite a lot of freedom in this style, especial",MatchSource.DOCS,doc/development/contributing.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:6761,Deployability,upgrade,upgrade,6761,"l not appear until you run ``python setup.py develop`` again; you will only need to re-run this if you are changing Cython files.; Cython will detect and compile only the files that have been changed, so this command will be faster on subsequent runs. .. note::. When undertaking Cython development, the reason we use ``python setup.py develop`` instead of ``pip install -e .`` is because Cython's changed-file detection does not reliably work in the latter.; ``pip`` tends to build in temporary virtual environments, which often makes Cython think its core library files have been updated, triggering a complete, slow rebuild of everything. .. note::. QuTiP follows `NEP29`_ when selecting the supported version of its dependencies.; To see which versions are planned to be supported in the next release, please refer to the :ref:`release roadmap`.; These coincide with the versions employed for testing in continuous integration. In the event of a feature requiring a version upgrade of python or a dependency, it will be considered appropriately in the pull request.; In any case, python and dependency upgrades will only happen in mayor or minor versions of QuTiP, not in a patch. .. _NEP29: https://numpy.org/neps/nep-0029-deprecation_policy.html. Code Style; ----------. The biggest concern you should always have is to make it easy for your code to be read and understood by the person who comes next. All new contributions must follow `PEP 8 style <https://peps.python.org/pep-0008/>`_; all pull requests will be passed through a linter that will complain if you violate it.; You should use the ``pycodestyle`` package locally (available on ``pip``) to test you satisfy the requirements before you push your commits, since this is rather faster than pushing 10 different commits trying to fix minor niggles.; Keep in mind that there is quite a lot of freedom in this style, especially when it comes to line breaks.; If a line is too long, consider the *best* way to split it up with the aim o",MatchSource.DOCS,doc/development/contributing.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:6889,Deployability,upgrade,upgrades,6889,"es.; Cython will detect and compile only the files that have been changed, so this command will be faster on subsequent runs. .. note::. When undertaking Cython development, the reason we use ``python setup.py develop`` instead of ``pip install -e .`` is because Cython's changed-file detection does not reliably work in the latter.; ``pip`` tends to build in temporary virtual environments, which often makes Cython think its core library files have been updated, triggering a complete, slow rebuild of everything. .. note::. QuTiP follows `NEP29`_ when selecting the supported version of its dependencies.; To see which versions are planned to be supported in the next release, please refer to the :ref:`release roadmap`.; These coincide with the versions employed for testing in continuous integration. In the event of a feature requiring a version upgrade of python or a dependency, it will be considered appropriately in the pull request.; In any case, python and dependency upgrades will only happen in mayor or minor versions of QuTiP, not in a patch. .. _NEP29: https://numpy.org/neps/nep-0029-deprecation_policy.html. Code Style; ----------. The biggest concern you should always have is to make it easy for your code to be read and understood by the person who comes next. All new contributions must follow `PEP 8 style <https://peps.python.org/pep-0008/>`_; all pull requests will be passed through a linter that will complain if you violate it.; You should use the ``pycodestyle`` package locally (available on ``pip``) to test you satisfy the requirements before you push your commits, since this is rather faster than pushing 10 different commits trying to fix minor niggles.; Keep in mind that there is quite a lot of freedom in this style, especially when it comes to line breaks.; If a line is too long, consider the *best* way to split it up with the aim of making the code readable, not just the first thing that doesn't generate a warning. Try to stay consistent with the style of ",MatchSource.DOCS,doc/development/contributing.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:6961,Deployability,patch,patch,6961,"es.; Cython will detect and compile only the files that have been changed, so this command will be faster on subsequent runs. .. note::. When undertaking Cython development, the reason we use ``python setup.py develop`` instead of ``pip install -e .`` is because Cython's changed-file detection does not reliably work in the latter.; ``pip`` tends to build in temporary virtual environments, which often makes Cython think its core library files have been updated, triggering a complete, slow rebuild of everything. .. note::. QuTiP follows `NEP29`_ when selecting the supported version of its dependencies.; To see which versions are planned to be supported in the next release, please refer to the :ref:`release roadmap`.; These coincide with the versions employed for testing in continuous integration. In the event of a feature requiring a version upgrade of python or a dependency, it will be considered appropriately in the pull request.; In any case, python and dependency upgrades will only happen in mayor or minor versions of QuTiP, not in a patch. .. _NEP29: https://numpy.org/neps/nep-0029-deprecation_policy.html. Code Style; ----------. The biggest concern you should always have is to make it easy for your code to be read and understood by the person who comes next. All new contributions must follow `PEP 8 style <https://peps.python.org/pep-0008/>`_; all pull requests will be passed through a linter that will complain if you violate it.; You should use the ``pycodestyle`` package locally (available on ``pip``) to test you satisfy the requirements before you push your commits, since this is rather faster than pushing 10 different commits trying to fix minor niggles.; Keep in mind that there is quite a lot of freedom in this style, especially when it comes to line breaks.; If a line is too long, consider the *best* way to split it up with the aim of making the code readable, not just the first thing that doesn't generate a warning. Try to stay consistent with the style of ",MatchSource.DOCS,doc/development/contributing.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:8223,Deployability,release,release,8223," understood by the person who comes next. All new contributions must follow `PEP 8 style <https://peps.python.org/pep-0008/>`_; all pull requests will be passed through a linter that will complain if you violate it.; You should use the ``pycodestyle`` package locally (available on ``pip``) to test you satisfy the requirements before you push your commits, since this is rather faster than pushing 10 different commits trying to fix minor niggles.; Keep in mind that there is quite a lot of freedom in this style, especially when it comes to line breaks.; If a line is too long, consider the *best* way to split it up with the aim of making the code readable, not just the first thing that doesn't generate a warning. Try to stay consistent with the style of the surrounding code.; This includes using the same variable names, especially if they are function arguments, even if these ""break"" PEP 8 guidelines.; *Do not* change existing parameter, attribute or method names to ""match"" PEP 8; these are breaking user-facing changes, and cannot be made except in a new major release of QuTiP. Other than this, general ""good-practice"" Python standards apply: try not to duplicate code; try to keep functions short, descriptively-named and side-effect free; provide a docstring for every new function; and so on. Documenting; -----------. When you make changes in the core library, you should update the relevant documentation if needed.; If you are making a bug fix, or other relatively minor changes, you will probably only need to make sure that the docstrings of the modified functions and classes are up-to-date; changes here will propagate through to the documentation the next time it is built.; Be sure to follow the |numpydoc|_ when writing docstrings.; All docstrings will be parsed as reStructuredText, and will form the API documentation section of the documentation. .. |numpydoc| replace:: Numpy documentation standards (``numpydoc``); .. _numpydoc: https://numpydoc.readthedocs.io/en/lates",MatchSource.DOCS,doc/development/contributing.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:8539,Deployability,update,update,8539,"er than pushing 10 different commits trying to fix minor niggles.; Keep in mind that there is quite a lot of freedom in this style, especially when it comes to line breaks.; If a line is too long, consider the *best* way to split it up with the aim of making the code readable, not just the first thing that doesn't generate a warning. Try to stay consistent with the style of the surrounding code.; This includes using the same variable names, especially if they are function arguments, even if these ""break"" PEP 8 guidelines.; *Do not* change existing parameter, attribute or method names to ""match"" PEP 8; these are breaking user-facing changes, and cannot be made except in a new major release of QuTiP. Other than this, general ""good-practice"" Python standards apply: try not to duplicate code; try to keep functions short, descriptively-named and side-effect free; provide a docstring for every new function; and so on. Documenting; -----------. When you make changes in the core library, you should update the relevant documentation if needed.; If you are making a bug fix, or other relatively minor changes, you will probably only need to make sure that the docstrings of the modified functions and classes are up-to-date; changes here will propagate through to the documentation the next time it is built.; Be sure to follow the |numpydoc|_ when writing docstrings.; All docstrings will be parsed as reStructuredText, and will form the API documentation section of the documentation. .. |numpydoc| replace:: Numpy documentation standards (``numpydoc``); .. _numpydoc: https://numpydoc.readthedocs.io/en/latest/format.html. Testing; -------. We use ``pytest`` as our test runner.; The base way to run every test is ::. pytest /path/to/repo/qutip/tests. This will take around 10 to 30 minutes, depending on your computer and how many of the optional requirements you have installed.; It is normal for some tests to be marked as ""skip"" or ""xfail"" in yellow; these are not problems.; True failure",MatchSource.DOCS,doc/development/contributing.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:9412,Deployability,install,installed,9412,"ort, descriptively-named and side-effect free; provide a docstring for every new function; and so on. Documenting; -----------. When you make changes in the core library, you should update the relevant documentation if needed.; If you are making a bug fix, or other relatively minor changes, you will probably only need to make sure that the docstrings of the modified functions and classes are up-to-date; changes here will propagate through to the documentation the next time it is built.; Be sure to follow the |numpydoc|_ when writing docstrings.; All docstrings will be parsed as reStructuredText, and will form the API documentation section of the documentation. .. |numpydoc| replace:: Numpy documentation standards (``numpydoc``); .. _numpydoc: https://numpydoc.readthedocs.io/en/latest/format.html. Testing; -------. We use ``pytest`` as our test runner.; The base way to run every test is ::. pytest /path/to/repo/qutip/tests. This will take around 10 to 30 minutes, depending on your computer and how many of the optional requirements you have installed.; It is normal for some tests to be marked as ""skip"" or ""xfail"" in yellow; these are not problems.; True failures will appear in red and be called ""fail"" or ""error"". While prototyping and making changes, you might want to use some of the filtering features of ``pytest``.; Instead of passing the whole ``tests`` directory to the ``pytest`` command, you can also pass a list of files.; You can also use the ``-k`` selector to only run tests whose names include a particular pattern, for example ::. pytest qutip/tests/test_qobj.py -k ""expm"". to run the tests of :meth:`Qobj.expm`. Changelog Generation; --------------------. We use ``towncrier`` for tracking changes and generating a changelog.; When making a pull request, we require that you add a towncrier entry along with the code changes.; You should create a file named ``<PR number>.<change type>`` in the ``doc/changes`` directory, where the PR number should be substituted for ",MatchSource.DOCS,doc/development/contributing.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:10570,Deployability,install,installing,10570,"ail"" or ""error"". While prototyping and making changes, you might want to use some of the filtering features of ``pytest``.; Instead of passing the whole ``tests`` directory to the ``pytest`` command, you can also pass a list of files.; You can also use the ``-k`` selector to only run tests whose names include a particular pattern, for example ::. pytest qutip/tests/test_qobj.py -k ""expm"". to run the tests of :meth:`Qobj.expm`. Changelog Generation; --------------------. We use ``towncrier`` for tracking changes and generating a changelog.; When making a pull request, we require that you add a towncrier entry along with the code changes.; You should create a file named ``<PR number>.<change type>`` in the ``doc/changes`` directory, where the PR number should be substituted for ``<PR number>``, and ``<change type>`` is either ``feature``, ``bugfix``, ``doc``, ``removal``, ``misc``, or ``deprecation``,; depending on the type of change included in the PR. You can also create this file by installing ``towncrier`` and running. towncrier create <PR number>.<change type>. Running this will create a file in the ``doc/changes`` directory with a filename corresponding to the argument you passed to ``towncrier create``.; In this file, you should add a short description of the changes that the PR introduces. .. _contributing-docs:. Documentation: qutip/qutip (doc directory); ==========================================. The core library is in the `qutip/qutip repository on GitHub, inside the doc directory <https://github.com/qutip/qutip>`_. Building; --------. The documentation is built using ``sphinx``, ``matplotlib`` and ``numpydoc``, with several additional extensions including ``sphinx-gallery`` and ``sphinx-rtd-theme``.; The most up-to-date instructions and dependencies will be in the ``README.md`` file of the documentation directory.; You can see the rendered version of this file simply by going to the `documentation GitHub page <https://github.com/qutip/qutip/tree/master/doc",MatchSource.DOCS,doc/development/contributing.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:12009,Deployability,install,install,12009,"utip/qutip repository on GitHub, inside the doc directory <https://github.com/qutip/qutip>`_. Building; --------. The documentation is built using ``sphinx``, ``matplotlib`` and ``numpydoc``, with several additional extensions including ``sphinx-gallery`` and ``sphinx-rtd-theme``.; The most up-to-date instructions and dependencies will be in the ``README.md`` file of the documentation directory.; You can see the rendered version of this file simply by going to the `documentation GitHub page <https://github.com/qutip/qutip/tree/master/doc>`_ and scrolling down. Building the documentation can be a little finnicky on occasion.; You likely will want to keep a separate Python environment to build the documentation in, because some of the dependencies can have tight requirements that may conflict with your favourite tools for Python development.; We recommend creating an empty ``conda`` environment containing only Python with ::. conda create -n qutip-doc python=3.8. and install all further dependencies with ``pip``.; There is a ``requirements.txt`` file in the repository root that fixes all package versions exactly into a known-good configuration for a completely empty environment, using ::. pip install -r requirements.txt. This known-good configuration was intended for Python 3.8, though in principle it is possible that other Python versions will work. .. note::. We recommend you use ``pip`` to install dependencies for the documentation rather than ``conda`` because several necessary packages can be slower to update their ``conda`` recipes, so suitable versions may not be available. The documentation build includes running many components of the main QuTiP library to generate figures and to test the output, and to generate all the API documentation.; You therefore need to have a version of QuTiP available in the same Python environment.; If you are only interested in updating the users' guide, you can use a release version of QuTiP, for example by running ``pip install q",MatchSource.DOCS,doc/development/contributing.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:12175,Deployability,configurat,configuration,12175,"on is built using ``sphinx``, ``matplotlib`` and ``numpydoc``, with several additional extensions including ``sphinx-gallery`` and ``sphinx-rtd-theme``.; The most up-to-date instructions and dependencies will be in the ``README.md`` file of the documentation directory.; You can see the rendered version of this file simply by going to the `documentation GitHub page <https://github.com/qutip/qutip/tree/master/doc>`_ and scrolling down. Building the documentation can be a little finnicky on occasion.; You likely will want to keep a separate Python environment to build the documentation in, because some of the dependencies can have tight requirements that may conflict with your favourite tools for Python development.; We recommend creating an empty ``conda`` environment containing only Python with ::. conda create -n qutip-doc python=3.8. and install all further dependencies with ``pip``.; There is a ``requirements.txt`` file in the repository root that fixes all package versions exactly into a known-good configuration for a completely empty environment, using ::. pip install -r requirements.txt. This known-good configuration was intended for Python 3.8, though in principle it is possible that other Python versions will work. .. note::. We recommend you use ``pip`` to install dependencies for the documentation rather than ``conda`` because several necessary packages can be slower to update their ``conda`` recipes, so suitable versions may not be available. The documentation build includes running many components of the main QuTiP library to generate figures and to test the output, and to generate all the API documentation.; You therefore need to have a version of QuTiP available in the same Python environment.; If you are only interested in updating the users' guide, you can use a release version of QuTiP, for example by running ``pip install qutip``.; If you are also modifying the main library, you need to make your development version accessible in this environment.; S",MatchSource.DOCS,doc/development/contributing.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:12239,Deployability,install,install,12239,"ensions including ``sphinx-gallery`` and ``sphinx-rtd-theme``.; The most up-to-date instructions and dependencies will be in the ``README.md`` file of the documentation directory.; You can see the rendered version of this file simply by going to the `documentation GitHub page <https://github.com/qutip/qutip/tree/master/doc>`_ and scrolling down. Building the documentation can be a little finnicky on occasion.; You likely will want to keep a separate Python environment to build the documentation in, because some of the dependencies can have tight requirements that may conflict with your favourite tools for Python development.; We recommend creating an empty ``conda`` environment containing only Python with ::. conda create -n qutip-doc python=3.8. and install all further dependencies with ``pip``.; There is a ``requirements.txt`` file in the repository root that fixes all package versions exactly into a known-good configuration for a completely empty environment, using ::. pip install -r requirements.txt. This known-good configuration was intended for Python 3.8, though in principle it is possible that other Python versions will work. .. note::. We recommend you use ``pip`` to install dependencies for the documentation rather than ``conda`` because several necessary packages can be slower to update their ``conda`` recipes, so suitable versions may not be available. The documentation build includes running many components of the main QuTiP library to generate figures and to test the output, and to generate all the API documentation.; You therefore need to have a version of QuTiP available in the same Python environment.; If you are only interested in updating the users' guide, you can use a release version of QuTiP, for example by running ``pip install qutip``.; If you are also modifying the main library, you need to make your development version accessible in this environment.; See the `above section on building QuTiP <contributing-qutip_>`_ for more details, though t",MatchSource.DOCS,doc/development/contributing.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:12284,Deployability,configurat,configuration,12284,"nx-rtd-theme``.; The most up-to-date instructions and dependencies will be in the ``README.md`` file of the documentation directory.; You can see the rendered version of this file simply by going to the `documentation GitHub page <https://github.com/qutip/qutip/tree/master/doc>`_ and scrolling down. Building the documentation can be a little finnicky on occasion.; You likely will want to keep a separate Python environment to build the documentation in, because some of the dependencies can have tight requirements that may conflict with your favourite tools for Python development.; We recommend creating an empty ``conda`` environment containing only Python with ::. conda create -n qutip-doc python=3.8. and install all further dependencies with ``pip``.; There is a ``requirements.txt`` file in the repository root that fixes all package versions exactly into a known-good configuration for a completely empty environment, using ::. pip install -r requirements.txt. This known-good configuration was intended for Python 3.8, though in principle it is possible that other Python versions will work. .. note::. We recommend you use ``pip`` to install dependencies for the documentation rather than ``conda`` because several necessary packages can be slower to update their ``conda`` recipes, so suitable versions may not be available. The documentation build includes running many components of the main QuTiP library to generate figures and to test the output, and to generate all the API documentation.; You therefore need to have a version of QuTiP available in the same Python environment.; If you are only interested in updating the users' guide, you can use a release version of QuTiP, for example by running ``pip install qutip``.; If you are also modifying the main library, you need to make your development version accessible in this environment.; See the `above section on building QuTiP <contributing-qutip_>`_ for more details, though the ``requirements.txt`` file will have already ",MatchSource.DOCS,doc/development/contributing.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:12443,Deployability,install,install,12443,"ge <https://github.com/qutip/qutip/tree/master/doc>`_ and scrolling down. Building the documentation can be a little finnicky on occasion.; You likely will want to keep a separate Python environment to build the documentation in, because some of the dependencies can have tight requirements that may conflict with your favourite tools for Python development.; We recommend creating an empty ``conda`` environment containing only Python with ::. conda create -n qutip-doc python=3.8. and install all further dependencies with ``pip``.; There is a ``requirements.txt`` file in the repository root that fixes all package versions exactly into a known-good configuration for a completely empty environment, using ::. pip install -r requirements.txt. This known-good configuration was intended for Python 3.8, though in principle it is possible that other Python versions will work. .. note::. We recommend you use ``pip`` to install dependencies for the documentation rather than ``conda`` because several necessary packages can be slower to update their ``conda`` recipes, so suitable versions may not be available. The documentation build includes running many components of the main QuTiP library to generate figures and to test the output, and to generate all the API documentation.; You therefore need to have a version of QuTiP available in the same Python environment.; If you are only interested in updating the users' guide, you can use a release version of QuTiP, for example by running ``pip install qutip``.; If you are also modifying the main library, you need to make your development version accessible in this environment.; See the `above section on building QuTiP <contributing-qutip_>`_ for more details, though the ``requirements.txt`` file will have already installed all the build requirements, so you should be able to simply run ::. python setup.py develop. in the main library repository. The documentation is built by running the ``make`` command.; There are several targets to b",MatchSource.DOCS,doc/development/contributing.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:12560,Deployability,update,update,12560,"ge <https://github.com/qutip/qutip/tree/master/doc>`_ and scrolling down. Building the documentation can be a little finnicky on occasion.; You likely will want to keep a separate Python environment to build the documentation in, because some of the dependencies can have tight requirements that may conflict with your favourite tools for Python development.; We recommend creating an empty ``conda`` environment containing only Python with ::. conda create -n qutip-doc python=3.8. and install all further dependencies with ``pip``.; There is a ``requirements.txt`` file in the repository root that fixes all package versions exactly into a known-good configuration for a completely empty environment, using ::. pip install -r requirements.txt. This known-good configuration was intended for Python 3.8, though in principle it is possible that other Python versions will work. .. note::. We recommend you use ``pip`` to install dependencies for the documentation rather than ``conda`` because several necessary packages can be slower to update their ``conda`` recipes, so suitable versions may not be available. The documentation build includes running many components of the main QuTiP library to generate figures and to test the output, and to generate all the API documentation.; You therefore need to have a version of QuTiP available in the same Python environment.; If you are only interested in updating the users' guide, you can use a release version of QuTiP, for example by running ``pip install qutip``.; If you are also modifying the main library, you need to make your development version accessible in this environment.; See the `above section on building QuTiP <contributing-qutip_>`_ for more details, though the ``requirements.txt`` file will have already installed all the build requirements, so you should be able to simply run ::. python setup.py develop. in the main library repository. The documentation is built by running the ``make`` command.; There are several targets to b",MatchSource.DOCS,doc/development/contributing.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:12966,Deployability,release,release,12966,". conda create -n qutip-doc python=3.8. and install all further dependencies with ``pip``.; There is a ``requirements.txt`` file in the repository root that fixes all package versions exactly into a known-good configuration for a completely empty environment, using ::. pip install -r requirements.txt. This known-good configuration was intended for Python 3.8, though in principle it is possible that other Python versions will work. .. note::. We recommend you use ``pip`` to install dependencies for the documentation rather than ``conda`` because several necessary packages can be slower to update their ``conda`` recipes, so suitable versions may not be available. The documentation build includes running many components of the main QuTiP library to generate figures and to test the output, and to generate all the API documentation.; You therefore need to have a version of QuTiP available in the same Python environment.; If you are only interested in updating the users' guide, you can use a release version of QuTiP, for example by running ``pip install qutip``.; If you are also modifying the main library, you need to make your development version accessible in this environment.; See the `above section on building QuTiP <contributing-qutip_>`_ for more details, though the ``requirements.txt`` file will have already installed all the build requirements, so you should be able to simply run ::. python setup.py develop. in the main library repository. The documentation is built by running the ``make`` command.; There are several targets to build, but the most useful will be ``html`` to build the webpage documentation, ``latexpdf`` to build the PDF documentation (you will also need a full ``pdflatex`` installation), and ``clean`` to remove all built files.; The most important command you will want to run is ::. make html. You should re-run this any time you make changes, and it should only update files that have been changed. .. important::; The documentation build includes ru",MatchSource.DOCS,doc/development/contributing.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:13021,Deployability,install,install,13021,". conda create -n qutip-doc python=3.8. and install all further dependencies with ``pip``.; There is a ``requirements.txt`` file in the repository root that fixes all package versions exactly into a known-good configuration for a completely empty environment, using ::. pip install -r requirements.txt. This known-good configuration was intended for Python 3.8, though in principle it is possible that other Python versions will work. .. note::. We recommend you use ``pip`` to install dependencies for the documentation rather than ``conda`` because several necessary packages can be slower to update their ``conda`` recipes, so suitable versions may not be available. The documentation build includes running many components of the main QuTiP library to generate figures and to test the output, and to generate all the API documentation.; You therefore need to have a version of QuTiP available in the same Python environment.; If you are only interested in updating the users' guide, you can use a release version of QuTiP, for example by running ``pip install qutip``.; If you are also modifying the main library, you need to make your development version accessible in this environment.; See the `above section on building QuTiP <contributing-qutip_>`_ for more details, though the ``requirements.txt`` file will have already installed all the build requirements, so you should be able to simply run ::. python setup.py develop. in the main library repository. The documentation is built by running the ``make`` command.; There are several targets to build, but the most useful will be ``html`` to build the webpage documentation, ``latexpdf`` to build the PDF documentation (you will also need a full ``pdflatex`` installation), and ``clean`` to remove all built files.; The most important command you will want to run is ::. make html. You should re-run this any time you make changes, and it should only update files that have been changed. .. important::; The documentation build includes ru",MatchSource.DOCS,doc/development/contributing.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:13296,Deployability,install,installed,13296,"n 3.8, though in principle it is possible that other Python versions will work. .. note::. We recommend you use ``pip`` to install dependencies for the documentation rather than ``conda`` because several necessary packages can be slower to update their ``conda`` recipes, so suitable versions may not be available. The documentation build includes running many components of the main QuTiP library to generate figures and to test the output, and to generate all the API documentation.; You therefore need to have a version of QuTiP available in the same Python environment.; If you are only interested in updating the users' guide, you can use a release version of QuTiP, for example by running ``pip install qutip``.; If you are also modifying the main library, you need to make your development version accessible in this environment.; See the `above section on building QuTiP <contributing-qutip_>`_ for more details, though the ``requirements.txt`` file will have already installed all the build requirements, so you should be able to simply run ::. python setup.py develop. in the main library repository. The documentation is built by running the ``make`` command.; There are several targets to build, but the most useful will be ``html`` to build the webpage documentation, ``latexpdf`` to build the PDF documentation (you will also need a full ``pdflatex`` installation), and ``clean`` to remove all built files.; The most important command you will want to run is ::. make html. You should re-run this any time you make changes, and it should only update files that have been changed. .. important::; The documentation build includes running almost all the optional features of QuTiP.; If you get failure messages in red, make sure you have installed all of the optional dependencies for the main library. The HTML files will be placed in the ``_build/html`` directory.; You can open the file ``_build/html/index.html`` in your web browser to check the output. Code Style; ----------. All us",MatchSource.DOCS,doc/development/contributing.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:13685,Deployability,install,installation,13685,"y not be available. The documentation build includes running many components of the main QuTiP library to generate figures and to test the output, and to generate all the API documentation.; You therefore need to have a version of QuTiP available in the same Python environment.; If you are only interested in updating the users' guide, you can use a release version of QuTiP, for example by running ``pip install qutip``.; If you are also modifying the main library, you need to make your development version accessible in this environment.; See the `above section on building QuTiP <contributing-qutip_>`_ for more details, though the ``requirements.txt`` file will have already installed all the build requirements, so you should be able to simply run ::. python setup.py develop. in the main library repository. The documentation is built by running the ``make`` command.; There are several targets to build, but the most useful will be ``html`` to build the webpage documentation, ``latexpdf`` to build the PDF documentation (you will also need a full ``pdflatex`` installation), and ``clean`` to remove all built files.; The most important command you will want to run is ::. make html. You should re-run this any time you make changes, and it should only update files that have been changed. .. important::; The documentation build includes running almost all the optional features of QuTiP.; If you get failure messages in red, make sure you have installed all of the optional dependencies for the main library. The HTML files will be placed in the ``_build/html`` directory.; You can open the file ``_build/html/index.html`` in your web browser to check the output. Code Style; ----------. All user guide pages and docstrings are parsed by Sphinx using reStructuredText.; There is a general `Sphinx usage guide <https://www.sphinx-doc.org/en/master/usage/index.html>`_, which has a lot of information that can sometimes be a little tricky to follow.; It may be easier just to look at other `",MatchSource.DOCS,doc/development/contributing.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:13877,Deployability,update,update,13877,"e in the same Python environment.; If you are only interested in updating the users' guide, you can use a release version of QuTiP, for example by running ``pip install qutip``.; If you are also modifying the main library, you need to make your development version accessible in this environment.; See the `above section on building QuTiP <contributing-qutip_>`_ for more details, though the ``requirements.txt`` file will have already installed all the build requirements, so you should be able to simply run ::. python setup.py develop. in the main library repository. The documentation is built by running the ``make`` command.; There are several targets to build, but the most useful will be ``html`` to build the webpage documentation, ``latexpdf`` to build the PDF documentation (you will also need a full ``pdflatex`` installation), and ``clean`` to remove all built files.; The most important command you will want to run is ::. make html. You should re-run this any time you make changes, and it should only update files that have been changed. .. important::; The documentation build includes running almost all the optional features of QuTiP.; If you get failure messages in red, make sure you have installed all of the optional dependencies for the main library. The HTML files will be placed in the ``_build/html`` directory.; You can open the file ``_build/html/index.html`` in your web browser to check the output. Code Style; ----------. All user guide pages and docstrings are parsed by Sphinx using reStructuredText.; There is a general `Sphinx usage guide <https://www.sphinx-doc.org/en/master/usage/index.html>`_, which has a lot of information that can sometimes be a little tricky to follow.; It may be easier just to look at other ``.rst`` files already in the documentation to copy the different styles. .. note::; reStructuredText is a very different language to the Markdown that you might be familiar with.; It's always worth checking your work in a web browser to make sur",MatchSource.DOCS,doc/development/contributing.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:14070,Deployability,install,installed,14070," library, you need to make your development version accessible in this environment.; See the `above section on building QuTiP <contributing-qutip_>`_ for more details, though the ``requirements.txt`` file will have already installed all the build requirements, so you should be able to simply run ::. python setup.py develop. in the main library repository. The documentation is built by running the ``make`` command.; There are several targets to build, but the most useful will be ``html`` to build the webpage documentation, ``latexpdf`` to build the PDF documentation (you will also need a full ``pdflatex`` installation), and ``clean`` to remove all built files.; The most important command you will want to run is ::. make html. You should re-run this any time you make changes, and it should only update files that have been changed. .. important::; The documentation build includes running almost all the optional features of QuTiP.; If you get failure messages in red, make sure you have installed all of the optional dependencies for the main library. The HTML files will be placed in the ``_build/html`` directory.; You can open the file ``_build/html/index.html`` in your web browser to check the output. Code Style; ----------. All user guide pages and docstrings are parsed by Sphinx using reStructuredText.; There is a general `Sphinx usage guide <https://www.sphinx-doc.org/en/master/usage/index.html>`_, which has a lot of information that can sometimes be a little tricky to follow.; It may be easier just to look at other ``.rst`` files already in the documentation to copy the different styles. .. note::; reStructuredText is a very different language to the Markdown that you might be familiar with.; It's always worth checking your work in a web browser to make sure it's appeared the way you intended. Testing; -------. There are unfortunately no automated tests for the documentation.; You should ensure that no errors appeared in red when you ran ``make html``.; Try not to in",MatchSource.DOCS,doc/development/contributing.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:4550,Integrability,depend,dependencies,4550,">`, not the general installation.; You will need all the *build* and *tests* ""optional"" requirements for the package.; The build requirements can be found in the |pyproject.toml file|_, and the testing requirements are in the ``tests`` key of the ``options.extras_require`` section of |setup.cfg|_.; You will also need the requirements for any optional features you want to test as well. .. |pyproject.toml file| replace:: ``pyproject.toml`` file; .. _pyproject.toml file: https://github.com/qutip/qutip/blob/master/pyproject.toml; .. |setup.cfg| replace:: ``setup.cfg``; .. _setup.cfg: https://github.com/qutip/qutip/blob/master/setup.cfg. Refer to the main instructions for the most up-to-date version, however as of version 4.6 the requirements can be installed into a conda environment with ::. conda install setuptools wheel numpy scipy cython packaging pytest pytest-rerunfailures. Note that ``qutip`` should *not* be installed with ``conda install``. .. note::; If you prefer, you can also use ``pip`` to install all the dependencies.; We typically recommend ``conda`` when doing main-library development because it is easier to switch low-level packages around like BLAS implementations, but if this doesn't mean anything to you, feel free to use ``pip``. You will need to make sure you have a functioning C++ compiler to build QuTiP.; If you are on Linux or Mac, this is likely already done for you, however if you are on Windows, refer to the :ref:`Windows installation <install-on-windows>` section of the installation guide. The command to build QuTiP in editable mode is ::. python setup.py develop. from the repository directory.; If you now load up a Python interpreter, you should be able to ``import qutip`` from anywhere as long as the correct Python environment is active.; Any changes you make to the Python files in the git repository should be immediately present if you restart your Python interpreter and re-import ``qutip``. On the first run, the setup command will compile ma",MatchSource.DOCS,doc/development/contributing.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:5652,Integrability,rout,routines,5652,"w-level packages around like BLAS implementations, but if this doesn't mean anything to you, feel free to use ``pip``. You will need to make sure you have a functioning C++ compiler to build QuTiP.; If you are on Linux or Mac, this is likely already done for you, however if you are on Windows, refer to the :ref:`Windows installation <install-on-windows>` section of the installation guide. The command to build QuTiP in editable mode is ::. python setup.py develop. from the repository directory.; If you now load up a Python interpreter, you should be able to ``import qutip`` from anywhere as long as the correct Python environment is active.; Any changes you make to the Python files in the git repository should be immediately present if you restart your Python interpreter and re-import ``qutip``. On the first run, the setup command will compile many C++ extension modules built from Cython sources (files ending ``.pxd`` and ``.pyx``).; Generally the low-level linear algebra routines that QuTiP uses are written in these files, not in pure Python.; Unlike Python files, changes you make to Cython files will not appear until you run ``python setup.py develop`` again; you will only need to re-run this if you are changing Cython files.; Cython will detect and compile only the files that have been changed, so this command will be faster on subsequent runs. .. note::. When undertaking Cython development, the reason we use ``python setup.py develop`` instead of ``pip install -e .`` is because Cython's changed-file detection does not reliably work in the latter.; ``pip`` tends to build in temporary virtual environments, which often makes Cython think its core library files have been updated, triggering a complete, slow rebuild of everything. .. note::. QuTiP follows `NEP29`_ when selecting the supported version of its dependencies.; To see which versions are planned to be supported in the next release, please refer to the :ref:`release roadmap`.; These coincide with the versions e",MatchSource.DOCS,doc/development/contributing.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:6503,Integrability,depend,dependencies,6503,"the first run, the setup command will compile many C++ extension modules built from Cython sources (files ending ``.pxd`` and ``.pyx``).; Generally the low-level linear algebra routines that QuTiP uses are written in these files, not in pure Python.; Unlike Python files, changes you make to Cython files will not appear until you run ``python setup.py develop`` again; you will only need to re-run this if you are changing Cython files.; Cython will detect and compile only the files that have been changed, so this command will be faster on subsequent runs. .. note::. When undertaking Cython development, the reason we use ``python setup.py develop`` instead of ``pip install -e .`` is because Cython's changed-file detection does not reliably work in the latter.; ``pip`` tends to build in temporary virtual environments, which often makes Cython think its core library files have been updated, triggering a complete, slow rebuild of everything. .. note::. QuTiP follows `NEP29`_ when selecting the supported version of its dependencies.; To see which versions are planned to be supported in the next release, please refer to the :ref:`release roadmap`.; These coincide with the versions employed for testing in continuous integration. In the event of a feature requiring a version upgrade of python or a dependency, it will be considered appropriately in the pull request.; In any case, python and dependency upgrades will only happen in mayor or minor versions of QuTiP, not in a patch. .. _NEP29: https://numpy.org/neps/nep-0029-deprecation_policy.html. Code Style; ----------. The biggest concern you should always have is to make it easy for your code to be read and understood by the person who comes next. All new contributions must follow `PEP 8 style <https://peps.python.org/pep-0008/>`_; all pull requests will be passed through a linter that will complain if you violate it.; You should use the ``pycodestyle`` package locally (available on ``pip``) to test you satisfy the requirement",MatchSource.DOCS,doc/development/contributing.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:6702,Integrability,integrat,integration,6702,"ses are written in these files, not in pure Python.; Unlike Python files, changes you make to Cython files will not appear until you run ``python setup.py develop`` again; you will only need to re-run this if you are changing Cython files.; Cython will detect and compile only the files that have been changed, so this command will be faster on subsequent runs. .. note::. When undertaking Cython development, the reason we use ``python setup.py develop`` instead of ``pip install -e .`` is because Cython's changed-file detection does not reliably work in the latter.; ``pip`` tends to build in temporary virtual environments, which often makes Cython think its core library files have been updated, triggering a complete, slow rebuild of everything. .. note::. QuTiP follows `NEP29`_ when selecting the supported version of its dependencies.; To see which versions are planned to be supported in the next release, please refer to the :ref:`release roadmap`.; These coincide with the versions employed for testing in continuous integration. In the event of a feature requiring a version upgrade of python or a dependency, it will be considered appropriately in the pull request.; In any case, python and dependency upgrades will only happen in mayor or minor versions of QuTiP, not in a patch. .. _NEP29: https://numpy.org/neps/nep-0029-deprecation_policy.html. Code Style; ----------. The biggest concern you should always have is to make it easy for your code to be read and understood by the person who comes next. All new contributions must follow `PEP 8 style <https://peps.python.org/pep-0008/>`_; all pull requests will be passed through a linter that will complain if you violate it.; You should use the ``pycodestyle`` package locally (available on ``pip``) to test you satisfy the requirements before you push your commits, since this is rather faster than pushing 10 different commits trying to fix minor niggles.; Keep in mind that there is quite a lot of freedom in this style, especial",MatchSource.DOCS,doc/development/contributing.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:6784,Integrability,depend,dependency,6784,"l not appear until you run ``python setup.py develop`` again; you will only need to re-run this if you are changing Cython files.; Cython will detect and compile only the files that have been changed, so this command will be faster on subsequent runs. .. note::. When undertaking Cython development, the reason we use ``python setup.py develop`` instead of ``pip install -e .`` is because Cython's changed-file detection does not reliably work in the latter.; ``pip`` tends to build in temporary virtual environments, which often makes Cython think its core library files have been updated, triggering a complete, slow rebuild of everything. .. note::. QuTiP follows `NEP29`_ when selecting the supported version of its dependencies.; To see which versions are planned to be supported in the next release, please refer to the :ref:`release roadmap`.; These coincide with the versions employed for testing in continuous integration. In the event of a feature requiring a version upgrade of python or a dependency, it will be considered appropriately in the pull request.; In any case, python and dependency upgrades will only happen in mayor or minor versions of QuTiP, not in a patch. .. _NEP29: https://numpy.org/neps/nep-0029-deprecation_policy.html. Code Style; ----------. The biggest concern you should always have is to make it easy for your code to be read and understood by the person who comes next. All new contributions must follow `PEP 8 style <https://peps.python.org/pep-0008/>`_; all pull requests will be passed through a linter that will complain if you violate it.; You should use the ``pycodestyle`` package locally (available on ``pip``) to test you satisfy the requirements before you push your commits, since this is rather faster than pushing 10 different commits trying to fix minor niggles.; Keep in mind that there is quite a lot of freedom in this style, especially when it comes to line breaks.; If a line is too long, consider the *best* way to split it up with the aim o",MatchSource.DOCS,doc/development/contributing.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:6878,Integrability,depend,dependency,6878,"es.; Cython will detect and compile only the files that have been changed, so this command will be faster on subsequent runs. .. note::. When undertaking Cython development, the reason we use ``python setup.py develop`` instead of ``pip install -e .`` is because Cython's changed-file detection does not reliably work in the latter.; ``pip`` tends to build in temporary virtual environments, which often makes Cython think its core library files have been updated, triggering a complete, slow rebuild of everything. .. note::. QuTiP follows `NEP29`_ when selecting the supported version of its dependencies.; To see which versions are planned to be supported in the next release, please refer to the :ref:`release roadmap`.; These coincide with the versions employed for testing in continuous integration. In the event of a feature requiring a version upgrade of python or a dependency, it will be considered appropriately in the pull request.; In any case, python and dependency upgrades will only happen in mayor or minor versions of QuTiP, not in a patch. .. _NEP29: https://numpy.org/neps/nep-0029-deprecation_policy.html. Code Style; ----------. The biggest concern you should always have is to make it easy for your code to be read and understood by the person who comes next. All new contributions must follow `PEP 8 style <https://peps.python.org/pep-0008/>`_; all pull requests will be passed through a linter that will complain if you violate it.; You should use the ``pycodestyle`` package locally (available on ``pip``) to test you satisfy the requirements before you push your commits, since this is rather faster than pushing 10 different commits trying to fix minor niggles.; Keep in mind that there is quite a lot of freedom in this style, especially when it comes to line breaks.; If a line is too long, consider the *best* way to split it up with the aim of making the code readable, not just the first thing that doesn't generate a warning. Try to stay consistent with the style of ",MatchSource.DOCS,doc/development/contributing.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:9334,Integrability,depend,depending,9334,"ort, descriptively-named and side-effect free; provide a docstring for every new function; and so on. Documenting; -----------. When you make changes in the core library, you should update the relevant documentation if needed.; If you are making a bug fix, or other relatively minor changes, you will probably only need to make sure that the docstrings of the modified functions and classes are up-to-date; changes here will propagate through to the documentation the next time it is built.; Be sure to follow the |numpydoc|_ when writing docstrings.; All docstrings will be parsed as reStructuredText, and will form the API documentation section of the documentation. .. |numpydoc| replace:: Numpy documentation standards (``numpydoc``); .. _numpydoc: https://numpydoc.readthedocs.io/en/latest/format.html. Testing; -------. We use ``pytest`` as our test runner.; The base way to run every test is ::. pytest /path/to/repo/qutip/tests. This will take around 10 to 30 minutes, depending on your computer and how many of the optional requirements you have installed.; It is normal for some tests to be marked as ""skip"" or ""xfail"" in yellow; these are not problems.; True failures will appear in red and be called ""fail"" or ""error"". While prototyping and making changes, you might want to use some of the filtering features of ``pytest``.; Instead of passing the whole ``tests`` directory to the ``pytest`` command, you can also pass a list of files.; You can also use the ``-k`` selector to only run tests whose names include a particular pattern, for example ::. pytest qutip/tests/test_qobj.py -k ""expm"". to run the tests of :meth:`Qobj.expm`. Changelog Generation; --------------------. We use ``towncrier`` for tracking changes and generating a changelog.; When making a pull request, we require that you add a towncrier entry along with the code changes.; You should create a file named ``<PR number>.<change type>`` in the ``doc/changes`` directory, where the PR number should be substituted for ",MatchSource.DOCS,doc/development/contributing.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:10485,Integrability,depend,depending,10485,"nts you have installed.; It is normal for some tests to be marked as ""skip"" or ""xfail"" in yellow; these are not problems.; True failures will appear in red and be called ""fail"" or ""error"". While prototyping and making changes, you might want to use some of the filtering features of ``pytest``.; Instead of passing the whole ``tests`` directory to the ``pytest`` command, you can also pass a list of files.; You can also use the ``-k`` selector to only run tests whose names include a particular pattern, for example ::. pytest qutip/tests/test_qobj.py -k ""expm"". to run the tests of :meth:`Qobj.expm`. Changelog Generation; --------------------. We use ``towncrier`` for tracking changes and generating a changelog.; When making a pull request, we require that you add a towncrier entry along with the code changes.; You should create a file named ``<PR number>.<change type>`` in the ``doc/changes`` directory, where the PR number should be substituted for ``<PR number>``, and ``<change type>`` is either ``feature``, ``bugfix``, ``doc``, ``removal``, ``misc``, or ``deprecation``,; depending on the type of change included in the PR. You can also create this file by installing ``towncrier`` and running. towncrier create <PR number>.<change type>. Running this will create a file in the ``doc/changes`` directory with a filename corresponding to the argument you passed to ``towncrier create``.; In this file, you should add a short description of the changes that the PR introduces. .. _contributing-docs:. Documentation: qutip/qutip (doc directory); ==========================================. The core library is in the `qutip/qutip repository on GitHub, inside the doc directory <https://github.com/qutip/qutip>`_. Building; --------. The documentation is built using ``sphinx``, ``matplotlib`` and ``numpydoc``, with several additional extensions including ``sphinx-gallery`` and ``sphinx-rtd-theme``.; The most up-to-date instructions and dependencies will be in the ``README.md`` file of ",MatchSource.DOCS,doc/development/contributing.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:11349,Integrability,depend,dependencies,11349,"tuted for ``<PR number>``, and ``<change type>`` is either ``feature``, ``bugfix``, ``doc``, ``removal``, ``misc``, or ``deprecation``,; depending on the type of change included in the PR. You can also create this file by installing ``towncrier`` and running. towncrier create <PR number>.<change type>. Running this will create a file in the ``doc/changes`` directory with a filename corresponding to the argument you passed to ``towncrier create``.; In this file, you should add a short description of the changes that the PR introduces. .. _contributing-docs:. Documentation: qutip/qutip (doc directory); ==========================================. The core library is in the `qutip/qutip repository on GitHub, inside the doc directory <https://github.com/qutip/qutip>`_. Building; --------. The documentation is built using ``sphinx``, ``matplotlib`` and ``numpydoc``, with several additional extensions including ``sphinx-gallery`` and ``sphinx-rtd-theme``.; The most up-to-date instructions and dependencies will be in the ``README.md`` file of the documentation directory.; You can see the rendered version of this file simply by going to the `documentation GitHub page <https://github.com/qutip/qutip/tree/master/doc>`_ and scrolling down. Building the documentation can be a little finnicky on occasion.; You likely will want to keep a separate Python environment to build the documentation in, because some of the dependencies can have tight requirements that may conflict with your favourite tools for Python development.; We recommend creating an empty ``conda`` environment containing only Python with ::. conda create -n qutip-doc python=3.8. and install all further dependencies with ``pip``.; There is a ``requirements.txt`` file in the repository root that fixes all package versions exactly into a known-good configuration for a completely empty environment, using ::. pip install -r requirements.txt. This known-good configuration was intended for Python 3.8, though in principle i",MatchSource.DOCS,doc/development/contributing.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:11772,Integrability,depend,dependencies,11772,"sed to ``towncrier create``.; In this file, you should add a short description of the changes that the PR introduces. .. _contributing-docs:. Documentation: qutip/qutip (doc directory); ==========================================. The core library is in the `qutip/qutip repository on GitHub, inside the doc directory <https://github.com/qutip/qutip>`_. Building; --------. The documentation is built using ``sphinx``, ``matplotlib`` and ``numpydoc``, with several additional extensions including ``sphinx-gallery`` and ``sphinx-rtd-theme``.; The most up-to-date instructions and dependencies will be in the ``README.md`` file of the documentation directory.; You can see the rendered version of this file simply by going to the `documentation GitHub page <https://github.com/qutip/qutip/tree/master/doc>`_ and scrolling down. Building the documentation can be a little finnicky on occasion.; You likely will want to keep a separate Python environment to build the documentation in, because some of the dependencies can have tight requirements that may conflict with your favourite tools for Python development.; We recommend creating an empty ``conda`` environment containing only Python with ::. conda create -n qutip-doc python=3.8. and install all further dependencies with ``pip``.; There is a ``requirements.txt`` file in the repository root that fixes all package versions exactly into a known-good configuration for a completely empty environment, using ::. pip install -r requirements.txt. This known-good configuration was intended for Python 3.8, though in principle it is possible that other Python versions will work. .. note::. We recommend you use ``pip`` to install dependencies for the documentation rather than ``conda`` because several necessary packages can be slower to update their ``conda`` recipes, so suitable versions may not be available. The documentation build includes running many components of the main QuTiP library to generate figures and to test the output, and to g",MatchSource.DOCS,doc/development/contributing.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:12029,Integrability,depend,dependencies,12029,"utip/qutip repository on GitHub, inside the doc directory <https://github.com/qutip/qutip>`_. Building; --------. The documentation is built using ``sphinx``, ``matplotlib`` and ``numpydoc``, with several additional extensions including ``sphinx-gallery`` and ``sphinx-rtd-theme``.; The most up-to-date instructions and dependencies will be in the ``README.md`` file of the documentation directory.; You can see the rendered version of this file simply by going to the `documentation GitHub page <https://github.com/qutip/qutip/tree/master/doc>`_ and scrolling down. Building the documentation can be a little finnicky on occasion.; You likely will want to keep a separate Python environment to build the documentation in, because some of the dependencies can have tight requirements that may conflict with your favourite tools for Python development.; We recommend creating an empty ``conda`` environment containing only Python with ::. conda create -n qutip-doc python=3.8. and install all further dependencies with ``pip``.; There is a ``requirements.txt`` file in the repository root that fixes all package versions exactly into a known-good configuration for a completely empty environment, using ::. pip install -r requirements.txt. This known-good configuration was intended for Python 3.8, though in principle it is possible that other Python versions will work. .. note::. We recommend you use ``pip`` to install dependencies for the documentation rather than ``conda`` because several necessary packages can be slower to update their ``conda`` recipes, so suitable versions may not be available. The documentation build includes running many components of the main QuTiP library to generate figures and to test the output, and to generate all the API documentation.; You therefore need to have a version of QuTiP available in the same Python environment.; If you are only interested in updating the users' guide, you can use a release version of QuTiP, for example by running ``pip install q",MatchSource.DOCS,doc/development/contributing.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:12451,Integrability,depend,dependencies,12451,"ge <https://github.com/qutip/qutip/tree/master/doc>`_ and scrolling down. Building the documentation can be a little finnicky on occasion.; You likely will want to keep a separate Python environment to build the documentation in, because some of the dependencies can have tight requirements that may conflict with your favourite tools for Python development.; We recommend creating an empty ``conda`` environment containing only Python with ::. conda create -n qutip-doc python=3.8. and install all further dependencies with ``pip``.; There is a ``requirements.txt`` file in the repository root that fixes all package versions exactly into a known-good configuration for a completely empty environment, using ::. pip install -r requirements.txt. This known-good configuration was intended for Python 3.8, though in principle it is possible that other Python versions will work. .. note::. We recommend you use ``pip`` to install dependencies for the documentation rather than ``conda`` because several necessary packages can be slower to update their ``conda`` recipes, so suitable versions may not be available. The documentation build includes running many components of the main QuTiP library to generate figures and to test the output, and to generate all the API documentation.; You therefore need to have a version of QuTiP available in the same Python environment.; If you are only interested in updating the users' guide, you can use a release version of QuTiP, for example by running ``pip install qutip``.; If you are also modifying the main library, you need to make your development version accessible in this environment.; See the `above section on building QuTiP <contributing-qutip_>`_ for more details, though the ``requirements.txt`` file will have already installed all the build requirements, so you should be able to simply run ::. python setup.py develop. in the main library repository. The documentation is built by running the ``make`` command.; There are several targets to b",MatchSource.DOCS,doc/development/contributing.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:14034,Integrability,message,messages,14034," library, you need to make your development version accessible in this environment.; See the `above section on building QuTiP <contributing-qutip_>`_ for more details, though the ``requirements.txt`` file will have already installed all the build requirements, so you should be able to simply run ::. python setup.py develop. in the main library repository. The documentation is built by running the ``make`` command.; There are several targets to build, but the most useful will be ``html`` to build the webpage documentation, ``latexpdf`` to build the PDF documentation (you will also need a full ``pdflatex`` installation), and ``clean`` to remove all built files.; The most important command you will want to run is ::. make html. You should re-run this any time you make changes, and it should only update files that have been changed. .. important::; The documentation build includes running almost all the optional features of QuTiP.; If you get failure messages in red, make sure you have installed all of the optional dependencies for the main library. The HTML files will be placed in the ``_build/html`` directory.; You can open the file ``_build/html/index.html`` in your web browser to check the output. Code Style; ----------. All user guide pages and docstrings are parsed by Sphinx using reStructuredText.; There is a general `Sphinx usage guide <https://www.sphinx-doc.org/en/master/usage/index.html>`_, which has a lot of information that can sometimes be a little tricky to follow.; It may be easier just to look at other ``.rst`` files already in the documentation to copy the different styles. .. note::; reStructuredText is a very different language to the Markdown that you might be familiar with.; It's always worth checking your work in a web browser to make sure it's appeared the way you intended. Testing; -------. There are unfortunately no automated tests for the documentation.; You should ensure that no errors appeared in red when you ran ``make html``.; Try not to in",MatchSource.DOCS,doc/development/contributing.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:14100,Integrability,depend,dependencies,14100," library, you need to make your development version accessible in this environment.; See the `above section on building QuTiP <contributing-qutip_>`_ for more details, though the ``requirements.txt`` file will have already installed all the build requirements, so you should be able to simply run ::. python setup.py develop. in the main library repository. The documentation is built by running the ``make`` command.; There are several targets to build, but the most useful will be ``html`` to build the webpage documentation, ``latexpdf`` to build the PDF documentation (you will also need a full ``pdflatex`` installation), and ``clean`` to remove all built files.; The most important command you will want to run is ::. make html. You should re-run this any time you make changes, and it should only update files that have been changed. .. important::; The documentation build includes running almost all the optional features of QuTiP.; If you get failure messages in red, make sure you have installed all of the optional dependencies for the main library. The HTML files will be placed in the ``_build/html`` directory.; You can open the file ``_build/html/index.html`` in your web browser to check the output. Code Style; ----------. All user guide pages and docstrings are parsed by Sphinx using reStructuredText.; There is a general `Sphinx usage guide <https://www.sphinx-doc.org/en/master/usage/index.html>`_, which has a lot of information that can sometimes be a little tricky to follow.; It may be easier just to look at other ``.rst`` files already in the documentation to copy the different styles. .. note::; reStructuredText is a very different language to the Markdown that you might be familiar with.; It's always worth checking your work in a web browser to make sure it's appeared the way you intended. Testing; -------. There are unfortunately no automated tests for the documentation.; You should ensure that no errors appeared in red when you ran ``make html``.; Try not to in",MatchSource.DOCS,doc/development/contributing.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:7962,Modifiability,variab,variable,7962,"g/neps/nep-0029-deprecation_policy.html. Code Style; ----------. The biggest concern you should always have is to make it easy for your code to be read and understood by the person who comes next. All new contributions must follow `PEP 8 style <https://peps.python.org/pep-0008/>`_; all pull requests will be passed through a linter that will complain if you violate it.; You should use the ``pycodestyle`` package locally (available on ``pip``) to test you satisfy the requirements before you push your commits, since this is rather faster than pushing 10 different commits trying to fix minor niggles.; Keep in mind that there is quite a lot of freedom in this style, especially when it comes to line breaks.; If a line is too long, consider the *best* way to split it up with the aim of making the code readable, not just the first thing that doesn't generate a warning. Try to stay consistent with the style of the surrounding code.; This includes using the same variable names, especially if they are function arguments, even if these ""break"" PEP 8 guidelines.; *Do not* change existing parameter, attribute or method names to ""match"" PEP 8; these are breaking user-facing changes, and cannot be made except in a new major release of QuTiP. Other than this, general ""good-practice"" Python standards apply: try not to duplicate code; try to keep functions short, descriptively-named and side-effect free; provide a docstring for every new function; and so on. Documenting; -----------. When you make changes in the core library, you should update the relevant documentation if needed.; If you are making a bug fix, or other relatively minor changes, you will probably only need to make sure that the docstrings of the modified functions and classes are up-to-date; changes here will propagate through to the documentation the next time it is built.; Be sure to follow the |numpydoc|_ when writing docstrings.; All docstrings will be parsed as reStructuredText, and will form the API documentation ",MatchSource.DOCS,doc/development/contributing.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:12175,Modifiability,config,configuration,12175,"on is built using ``sphinx``, ``matplotlib`` and ``numpydoc``, with several additional extensions including ``sphinx-gallery`` and ``sphinx-rtd-theme``.; The most up-to-date instructions and dependencies will be in the ``README.md`` file of the documentation directory.; You can see the rendered version of this file simply by going to the `documentation GitHub page <https://github.com/qutip/qutip/tree/master/doc>`_ and scrolling down. Building the documentation can be a little finnicky on occasion.; You likely will want to keep a separate Python environment to build the documentation in, because some of the dependencies can have tight requirements that may conflict with your favourite tools for Python development.; We recommend creating an empty ``conda`` environment containing only Python with ::. conda create -n qutip-doc python=3.8. and install all further dependencies with ``pip``.; There is a ``requirements.txt`` file in the repository root that fixes all package versions exactly into a known-good configuration for a completely empty environment, using ::. pip install -r requirements.txt. This known-good configuration was intended for Python 3.8, though in principle it is possible that other Python versions will work. .. note::. We recommend you use ``pip`` to install dependencies for the documentation rather than ``conda`` because several necessary packages can be slower to update their ``conda`` recipes, so suitable versions may not be available. The documentation build includes running many components of the main QuTiP library to generate figures and to test the output, and to generate all the API documentation.; You therefore need to have a version of QuTiP available in the same Python environment.; If you are only interested in updating the users' guide, you can use a release version of QuTiP, for example by running ``pip install qutip``.; If you are also modifying the main library, you need to make your development version accessible in this environment.; S",MatchSource.DOCS,doc/development/contributing.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:12284,Modifiability,config,configuration,12284,"nx-rtd-theme``.; The most up-to-date instructions and dependencies will be in the ``README.md`` file of the documentation directory.; You can see the rendered version of this file simply by going to the `documentation GitHub page <https://github.com/qutip/qutip/tree/master/doc>`_ and scrolling down. Building the documentation can be a little finnicky on occasion.; You likely will want to keep a separate Python environment to build the documentation in, because some of the dependencies can have tight requirements that may conflict with your favourite tools for Python development.; We recommend creating an empty ``conda`` environment containing only Python with ::. conda create -n qutip-doc python=3.8. and install all further dependencies with ``pip``.; There is a ``requirements.txt`` file in the repository root that fixes all package versions exactly into a known-good configuration for a completely empty environment, using ::. pip install -r requirements.txt. This known-good configuration was intended for Python 3.8, though in principle it is possible that other Python versions will work. .. note::. We recommend you use ``pip`` to install dependencies for the documentation rather than ``conda`` because several necessary packages can be slower to update their ``conda`` recipes, so suitable versions may not be available. The documentation build includes running many components of the main QuTiP library to generate figures and to test the output, and to generate all the API documentation.; You therefore need to have a version of QuTiP available in the same Python environment.; If you are only interested in updating the users' guide, you can use a release version of QuTiP, for example by running ``pip install qutip``.; If you are also modifying the main library, you need to make your development version accessible in this environment.; See the `above section on building QuTiP <contributing-qutip_>`_ for more details, though the ``requirements.txt`` file will have already ",MatchSource.DOCS,doc/development/contributing.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:5178,Performance,load,load,5178,"f version 4.6 the requirements can be installed into a conda environment with ::. conda install setuptools wheel numpy scipy cython packaging pytest pytest-rerunfailures. Note that ``qutip`` should *not* be installed with ``conda install``. .. note::; If you prefer, you can also use ``pip`` to install all the dependencies.; We typically recommend ``conda`` when doing main-library development because it is easier to switch low-level packages around like BLAS implementations, but if this doesn't mean anything to you, feel free to use ``pip``. You will need to make sure you have a functioning C++ compiler to build QuTiP.; If you are on Linux or Mac, this is likely already done for you, however if you are on Windows, refer to the :ref:`Windows installation <install-on-windows>` section of the installation guide. The command to build QuTiP in editable mode is ::. python setup.py develop. from the repository directory.; If you now load up a Python interpreter, you should be able to ``import qutip`` from anywhere as long as the correct Python environment is active.; Any changes you make to the Python files in the git repository should be immediately present if you restart your Python interpreter and re-import ``qutip``. On the first run, the setup command will compile many C++ extension modules built from Cython sources (files ending ``.pxd`` and ``.pyx``).; Generally the low-level linear algebra routines that QuTiP uses are written in these files, not in pure Python.; Unlike Python files, changes you make to Cython files will not appear until you run ``python setup.py develop`` again; you will only need to re-run this if you are changing Cython files.; Cython will detect and compile only the files that have been changed, so this command will be faster on subsequent runs. .. note::. When undertaking Cython development, the reason we use ``python setup.py develop`` instead of ``pip install -e .`` is because Cython's changed-file detection does not reliably work in the latte",MatchSource.DOCS,doc/development/contributing.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:5926,Safety,detect,detect,5926,"e :ref:`Windows installation <install-on-windows>` section of the installation guide. The command to build QuTiP in editable mode is ::. python setup.py develop. from the repository directory.; If you now load up a Python interpreter, you should be able to ``import qutip`` from anywhere as long as the correct Python environment is active.; Any changes you make to the Python files in the git repository should be immediately present if you restart your Python interpreter and re-import ``qutip``. On the first run, the setup command will compile many C++ extension modules built from Cython sources (files ending ``.pxd`` and ``.pyx``).; Generally the low-level linear algebra routines that QuTiP uses are written in these files, not in pure Python.; Unlike Python files, changes you make to Cython files will not appear until you run ``python setup.py develop`` again; you will only need to re-run this if you are changing Cython files.; Cython will detect and compile only the files that have been changed, so this command will be faster on subsequent runs. .. note::. When undertaking Cython development, the reason we use ``python setup.py develop`` instead of ``pip install -e .`` is because Cython's changed-file detection does not reliably work in the latter.; ``pip`` tends to build in temporary virtual environments, which often makes Cython think its core library files have been updated, triggering a complete, slow rebuild of everything. .. note::. QuTiP follows `NEP29`_ when selecting the supported version of its dependencies.; To see which versions are planned to be supported in the next release, please refer to the :ref:`release roadmap`.; These coincide with the versions employed for testing in continuous integration. In the event of a feature requiring a version upgrade of python or a dependency, it will be considered appropriately in the pull request.; In any case, python and dependency upgrades will only happen in mayor or minor versions of QuTiP, not in a patch. .. _N",MatchSource.DOCS,doc/development/contributing.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:6194,Safety,detect,detection,6194,"rpreter, you should be able to ``import qutip`` from anywhere as long as the correct Python environment is active.; Any changes you make to the Python files in the git repository should be immediately present if you restart your Python interpreter and re-import ``qutip``. On the first run, the setup command will compile many C++ extension modules built from Cython sources (files ending ``.pxd`` and ``.pyx``).; Generally the low-level linear algebra routines that QuTiP uses are written in these files, not in pure Python.; Unlike Python files, changes you make to Cython files will not appear until you run ``python setup.py develop`` again; you will only need to re-run this if you are changing Cython files.; Cython will detect and compile only the files that have been changed, so this command will be faster on subsequent runs. .. note::. When undertaking Cython development, the reason we use ``python setup.py develop`` instead of ``pip install -e .`` is because Cython's changed-file detection does not reliably work in the latter.; ``pip`` tends to build in temporary virtual environments, which often makes Cython think its core library files have been updated, triggering a complete, slow rebuild of everything. .. note::. QuTiP follows `NEP29`_ when selecting the supported version of its dependencies.; To see which versions are planned to be supported in the next release, please refer to the :ref:`release roadmap`.; These coincide with the versions employed for testing in continuous integration. In the event of a feature requiring a version upgrade of python or a dependency, it will be considered appropriately in the pull request.; In any case, python and dependency upgrades will only happen in mayor or minor versions of QuTiP, not in a patch. .. _NEP29: https://numpy.org/neps/nep-0029-deprecation_policy.html. Code Style; ----------. The biggest concern you should always have is to make it easy for your code to be read and understood by the person who comes next. All new ",MatchSource.DOCS,doc/development/contributing.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:13125,Security,access,accessible,13125," the repository root that fixes all package versions exactly into a known-good configuration for a completely empty environment, using ::. pip install -r requirements.txt. This known-good configuration was intended for Python 3.8, though in principle it is possible that other Python versions will work. .. note::. We recommend you use ``pip`` to install dependencies for the documentation rather than ``conda`` because several necessary packages can be slower to update their ``conda`` recipes, so suitable versions may not be available. The documentation build includes running many components of the main QuTiP library to generate figures and to test the output, and to generate all the API documentation.; You therefore need to have a version of QuTiP available in the same Python environment.; If you are only interested in updating the users' guide, you can use a release version of QuTiP, for example by running ``pip install qutip``.; If you are also modifying the main library, you need to make your development version accessible in this environment.; See the `above section on building QuTiP <contributing-qutip_>`_ for more details, though the ``requirements.txt`` file will have already installed all the build requirements, so you should be able to simply run ::. python setup.py develop. in the main library repository. The documentation is built by running the ``make`` command.; There are several targets to build, but the most useful will be ``html`` to build the webpage documentation, ``latexpdf`` to build the PDF documentation (you will also need a full ``pdflatex`` installation), and ``clean`` to remove all built files.; The most important command you will want to run is ::. make html. You should re-run this any time you make changes, and it should only update files that have been changed. .. important::; The documentation build includes running almost all the optional features of QuTiP.; If you get failure messages in red, make sure you have installed all of the option",MatchSource.DOCS,doc/development/contributing.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:601,Testability,test,testing,601,".. _development-contributing:. *********************************; Contributing to QuTiP Development; *********************************. Quick Start; ===========. QuTiP is developed through wide collaboration using the ``git`` version-control system, with the main repositories hosted in the `qutip organisation on GitHub <https://github.com/qutip>`_.; You will need to be familiar with ``git`` as a tool, and the `GitHub Flow <https://docs.github.com/en/get-started/quickstart/github-flow>`_ workflow for branching and making pull requests.; The exact details of environment set-up, build process and testing vary by repository and are discussed below, however in overview, the steps to contribute are:. #. Consider creating an issue on the GitHub page of the relevant repository, describing the change you think should be made and why, so we can discuss details with you and make sure it is appropriate.; #. (If this is your first contribution.) Make a fork of the relevant repository on GitHub and clone it to your local computer. Also add our copy as a remote (``git remote add qutip https://github.com/qutip/<repo>``); #. Begin on the ``master`` branch (``git checkout master``), and pull in changes from the main QuTiP repository to make sure you have an up-to-date copy (``git pull qutip master``).; #. Switch to a new ``git`` branch (``git checkout -b <branch-name>``).; #. Make the changes you want to make, then create some commits with short, descriptive names (``git add <files>`` then ``git commit``).; #. Follow the build process for this repository to build the final result so you can check your changes work sensibly.; #. Run the tests for the repository (if it has them).; #. Push the changes to your fork (``git push -u origin <branch-name>``). You won't be able to push to the main QuTiP repositories directly.; #. Go to the GitHub website for the repository you are contributing to, click on the ""Pull Requests"" tab, click the ""New Pull Request"" button, and follow the instructions",MatchSource.DOCS,doc/development/contributing.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:1646,Testability,test,tests,1646,"n overview, the steps to contribute are:. #. Consider creating an issue on the GitHub page of the relevant repository, describing the change you think should be made and why, so we can discuss details with you and make sure it is appropriate.; #. (If this is your first contribution.) Make a fork of the relevant repository on GitHub and clone it to your local computer. Also add our copy as a remote (``git remote add qutip https://github.com/qutip/<repo>``); #. Begin on the ``master`` branch (``git checkout master``), and pull in changes from the main QuTiP repository to make sure you have an up-to-date copy (``git pull qutip master``).; #. Switch to a new ``git`` branch (``git checkout -b <branch-name>``).; #. Make the changes you want to make, then create some commits with short, descriptive names (``git add <files>`` then ``git commit``).; #. Follow the build process for this repository to build the final result so you can check your changes work sensibly.; #. Run the tests for the repository (if it has them).; #. Push the changes to your fork (``git push -u origin <branch-name>``). You won't be able to push to the main QuTiP repositories directly.; #. Go to the GitHub website for the repository you are contributing to, click on the ""Pull Requests"" tab, click the ""New Pull Request"" button, and follow the instructions there. Once the pull request is created, some members of the QuTiP admin team will review the code to make sure it is suitable for inclusion in the library, to check the programming, and to ensure everything meets our standards.; For some repositories, several automated tests will run whenever you create or modify a pull request; in general these will be the same tests you can run locally, and all tests are required to pass online before your changes are merged.; There may be some feedback and possibly some requested changes.; You can add more commits to address these, and push them to the relevant branch of your fork to update the pull request. The res",MatchSource.DOCS,doc/development/contributing.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:2273,Testability,test,tests,2273,"eckout -b <branch-name>``).; #. Make the changes you want to make, then create some commits with short, descriptive names (``git add <files>`` then ``git commit``).; #. Follow the build process for this repository to build the final result so you can check your changes work sensibly.; #. Run the tests for the repository (if it has them).; #. Push the changes to your fork (``git push -u origin <branch-name>``). You won't be able to push to the main QuTiP repositories directly.; #. Go to the GitHub website for the repository you are contributing to, click on the ""Pull Requests"" tab, click the ""New Pull Request"" button, and follow the instructions there. Once the pull request is created, some members of the QuTiP admin team will review the code to make sure it is suitable for inclusion in the library, to check the programming, and to ensure everything meets our standards.; For some repositories, several automated tests will run whenever you create or modify a pull request; in general these will be the same tests you can run locally, and all tests are required to pass online before your changes are merged.; There may be some feedback and possibly some requested changes.; You can add more commits to address these, and push them to the relevant branch of your fork to update the pull request. The rest of this document covers programming standards, and particular considerations for some of the more complicated repositories. .. _contributing-qutip:. Core Library: qutip/qutip; =========================. The core library is in the `qutip/qutip repository on GitHub <https://github.com/qutip/qutip>`_. Building; --------. Building the core library from source is typically a bit more difficult than simply installing the package for regular use.; You will most likely want to do this in a clean Python environment so that you do not compromise a working installation of a release version, for example by starting from ::. conda create -n qutip-dev python. :ref:`Complete instructions fo",MatchSource.DOCS,doc/development/contributing.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:2368,Testability,test,tests,2368,"eckout -b <branch-name>``).; #. Make the changes you want to make, then create some commits with short, descriptive names (``git add <files>`` then ``git commit``).; #. Follow the build process for this repository to build the final result so you can check your changes work sensibly.; #. Run the tests for the repository (if it has them).; #. Push the changes to your fork (``git push -u origin <branch-name>``). You won't be able to push to the main QuTiP repositories directly.; #. Go to the GitHub website for the repository you are contributing to, click on the ""Pull Requests"" tab, click the ""New Pull Request"" button, and follow the instructions there. Once the pull request is created, some members of the QuTiP admin team will review the code to make sure it is suitable for inclusion in the library, to check the programming, and to ensure everything meets our standards.; For some repositories, several automated tests will run whenever you create or modify a pull request; in general these will be the same tests you can run locally, and all tests are required to pass online before your changes are merged.; There may be some feedback and possibly some requested changes.; You can add more commits to address these, and push them to the relevant branch of your fork to update the pull request. The rest of this document covers programming standards, and particular considerations for some of the more complicated repositories. .. _contributing-qutip:. Core Library: qutip/qutip; =========================. The core library is in the `qutip/qutip repository on GitHub <https://github.com/qutip/qutip>`_. Building; --------. Building the core library from source is typically a bit more difficult than simply installing the package for regular use.; You will most likely want to do this in a clean Python environment so that you do not compromise a working installation of a release version, for example by starting from ::. conda create -n qutip-dev python. :ref:`Complete instructions fo",MatchSource.DOCS,doc/development/contributing.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:2403,Testability,test,tests,2403,"eckout -b <branch-name>``).; #. Make the changes you want to make, then create some commits with short, descriptive names (``git add <files>`` then ``git commit``).; #. Follow the build process for this repository to build the final result so you can check your changes work sensibly.; #. Run the tests for the repository (if it has them).; #. Push the changes to your fork (``git push -u origin <branch-name>``). You won't be able to push to the main QuTiP repositories directly.; #. Go to the GitHub website for the repository you are contributing to, click on the ""Pull Requests"" tab, click the ""New Pull Request"" button, and follow the instructions there. Once the pull request is created, some members of the QuTiP admin team will review the code to make sure it is suitable for inclusion in the library, to check the programming, and to ensure everything meets our standards.; For some repositories, several automated tests will run whenever you create or modify a pull request; in general these will be the same tests you can run locally, and all tests are required to pass online before your changes are merged.; There may be some feedback and possibly some requested changes.; You can add more commits to address these, and push them to the relevant branch of your fork to update the pull request. The rest of this document covers programming standards, and particular considerations for some of the more complicated repositories. .. _contributing-qutip:. Core Library: qutip/qutip; =========================. The core library is in the `qutip/qutip repository on GitHub <https://github.com/qutip/qutip>`_. Building; --------. Building the core library from source is typically a bit more difficult than simply installing the package for regular use.; You will most likely want to do this in a clean Python environment so that you do not compromise a working installation of a release version, for example by starting from ::. conda create -n qutip-dev python. :ref:`Complete instructions fo",MatchSource.DOCS,doc/development/contributing.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:3592,Testability,test,tests,3592,"e relevant branch of your fork to update the pull request. The rest of this document covers programming standards, and particular considerations for some of the more complicated repositories. .. _contributing-qutip:. Core Library: qutip/qutip; =========================. The core library is in the `qutip/qutip repository on GitHub <https://github.com/qutip/qutip>`_. Building; --------. Building the core library from source is typically a bit more difficult than simply installing the package for regular use.; You will most likely want to do this in a clean Python environment so that you do not compromise a working installation of a release version, for example by starting from ::. conda create -n qutip-dev python. :ref:`Complete instructions for the build <install>` are elsewhere in this guide, however beware that you will need to follow the :ref:`installation from source using setuptools section <build-setuptools>`, not the general installation.; You will need all the *build* and *tests* ""optional"" requirements for the package.; The build requirements can be found in the |pyproject.toml file|_, and the testing requirements are in the ``tests`` key of the ``options.extras_require`` section of |setup.cfg|_.; You will also need the requirements for any optional features you want to test as well. .. |pyproject.toml file| replace:: ``pyproject.toml`` file; .. _pyproject.toml file: https://github.com/qutip/qutip/blob/master/pyproject.toml; .. |setup.cfg| replace:: ``setup.cfg``; .. _setup.cfg: https://github.com/qutip/qutip/blob/master/setup.cfg. Refer to the main instructions for the most up-to-date version, however as of version 4.6 the requirements can be installed into a conda environment with ::. conda install setuptools wheel numpy scipy cython packaging pytest pytest-rerunfailures. Note that ``qutip`` should *not* be installed with ``conda install``. .. note::; If you prefer, you can also use ``pip`` to install all the dependencies.; We typically recommend ``conda``",MatchSource.DOCS,doc/development/contributing.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:3716,Testability,test,testing,3716,"ions for some of the more complicated repositories. .. _contributing-qutip:. Core Library: qutip/qutip; =========================. The core library is in the `qutip/qutip repository on GitHub <https://github.com/qutip/qutip>`_. Building; --------. Building the core library from source is typically a bit more difficult than simply installing the package for regular use.; You will most likely want to do this in a clean Python environment so that you do not compromise a working installation of a release version, for example by starting from ::. conda create -n qutip-dev python. :ref:`Complete instructions for the build <install>` are elsewhere in this guide, however beware that you will need to follow the :ref:`installation from source using setuptools section <build-setuptools>`, not the general installation.; You will need all the *build* and *tests* ""optional"" requirements for the package.; The build requirements can be found in the |pyproject.toml file|_, and the testing requirements are in the ``tests`` key of the ``options.extras_require`` section of |setup.cfg|_.; You will also need the requirements for any optional features you want to test as well. .. |pyproject.toml file| replace:: ``pyproject.toml`` file; .. _pyproject.toml file: https://github.com/qutip/qutip/blob/master/pyproject.toml; .. |setup.cfg| replace:: ``setup.cfg``; .. _setup.cfg: https://github.com/qutip/qutip/blob/master/setup.cfg. Refer to the main instructions for the most up-to-date version, however as of version 4.6 the requirements can be installed into a conda environment with ::. conda install setuptools wheel numpy scipy cython packaging pytest pytest-rerunfailures. Note that ``qutip`` should *not* be installed with ``conda install``. .. note::; If you prefer, you can also use ``pip`` to install all the dependencies.; We typically recommend ``conda`` when doing main-library development because it is easier to switch low-level packages around like BLAS implementations, but if this doesn't",MatchSource.DOCS,doc/development/contributing.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:3750,Testability,test,tests,3750,"ions for some of the more complicated repositories. .. _contributing-qutip:. Core Library: qutip/qutip; =========================. The core library is in the `qutip/qutip repository on GitHub <https://github.com/qutip/qutip>`_. Building; --------. Building the core library from source is typically a bit more difficult than simply installing the package for regular use.; You will most likely want to do this in a clean Python environment so that you do not compromise a working installation of a release version, for example by starting from ::. conda create -n qutip-dev python. :ref:`Complete instructions for the build <install>` are elsewhere in this guide, however beware that you will need to follow the :ref:`installation from source using setuptools section <build-setuptools>`, not the general installation.; You will need all the *build* and *tests* ""optional"" requirements for the package.; The build requirements can be found in the |pyproject.toml file|_, and the testing requirements are in the ``tests`` key of the ``options.extras_require`` section of |setup.cfg|_.; You will also need the requirements for any optional features you want to test as well. .. |pyproject.toml file| replace:: ``pyproject.toml`` file; .. _pyproject.toml file: https://github.com/qutip/qutip/blob/master/pyproject.toml; .. |setup.cfg| replace:: ``setup.cfg``; .. _setup.cfg: https://github.com/qutip/qutip/blob/master/setup.cfg. Refer to the main instructions for the most up-to-date version, however as of version 4.6 the requirements can be installed into a conda environment with ::. conda install setuptools wheel numpy scipy cython packaging pytest pytest-rerunfailures. Note that ``qutip`` should *not* be installed with ``conda install``. .. note::; If you prefer, you can also use ``pip`` to install all the dependencies.; We typically recommend ``conda`` when doing main-library development because it is easier to switch low-level packages around like BLAS implementations, but if this doesn't",MatchSource.DOCS,doc/development/contributing.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:3896,Testability,test,test,3896,"==. The core library is in the `qutip/qutip repository on GitHub <https://github.com/qutip/qutip>`_. Building; --------. Building the core library from source is typically a bit more difficult than simply installing the package for regular use.; You will most likely want to do this in a clean Python environment so that you do not compromise a working installation of a release version, for example by starting from ::. conda create -n qutip-dev python. :ref:`Complete instructions for the build <install>` are elsewhere in this guide, however beware that you will need to follow the :ref:`installation from source using setuptools section <build-setuptools>`, not the general installation.; You will need all the *build* and *tests* ""optional"" requirements for the package.; The build requirements can be found in the |pyproject.toml file|_, and the testing requirements are in the ``tests`` key of the ``options.extras_require`` section of |setup.cfg|_.; You will also need the requirements for any optional features you want to test as well. .. |pyproject.toml file| replace:: ``pyproject.toml`` file; .. _pyproject.toml file: https://github.com/qutip/qutip/blob/master/pyproject.toml; .. |setup.cfg| replace:: ``setup.cfg``; .. _setup.cfg: https://github.com/qutip/qutip/blob/master/setup.cfg. Refer to the main instructions for the most up-to-date version, however as of version 4.6 the requirements can be installed into a conda environment with ::. conda install setuptools wheel numpy scipy cython packaging pytest pytest-rerunfailures. Note that ``qutip`` should *not* be installed with ``conda install``. .. note::; If you prefer, you can also use ``pip`` to install all the dependencies.; We typically recommend ``conda`` when doing main-library development because it is easier to switch low-level packages around like BLAS implementations, but if this doesn't mean anything to you, feel free to use ``pip``. You will need to make sure you have a functioning C++ compiler to build QuTiP.;",MatchSource.DOCS,doc/development/contributing.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:6680,Testability,test,testing,6680,"ses are written in these files, not in pure Python.; Unlike Python files, changes you make to Cython files will not appear until you run ``python setup.py develop`` again; you will only need to re-run this if you are changing Cython files.; Cython will detect and compile only the files that have been changed, so this command will be faster on subsequent runs. .. note::. When undertaking Cython development, the reason we use ``python setup.py develop`` instead of ``pip install -e .`` is because Cython's changed-file detection does not reliably work in the latter.; ``pip`` tends to build in temporary virtual environments, which often makes Cython think its core library files have been updated, triggering a complete, slow rebuild of everything. .. note::. QuTiP follows `NEP29`_ when selecting the supported version of its dependencies.; To see which versions are planned to be supported in the next release, please refer to the :ref:`release roadmap`.; These coincide with the versions employed for testing in continuous integration. In the event of a feature requiring a version upgrade of python or a dependency, it will be considered appropriately in the pull request.; In any case, python and dependency upgrades will only happen in mayor or minor versions of QuTiP, not in a patch. .. _NEP29: https://numpy.org/neps/nep-0029-deprecation_policy.html. Code Style; ----------. The biggest concern you should always have is to make it easy for your code to be read and understood by the person who comes next. All new contributions must follow `PEP 8 style <https://peps.python.org/pep-0008/>`_; all pull requests will be passed through a linter that will complain if you violate it.; You should use the ``pycodestyle`` package locally (available on ``pip``) to test you satisfy the requirements before you push your commits, since this is rather faster than pushing 10 different commits trying to fix minor niggles.; Keep in mind that there is quite a lot of freedom in this style, especial",MatchSource.DOCS,doc/development/contributing.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:7444,Testability,test,test,7444,"ported version of its dependencies.; To see which versions are planned to be supported in the next release, please refer to the :ref:`release roadmap`.; These coincide with the versions employed for testing in continuous integration. In the event of a feature requiring a version upgrade of python or a dependency, it will be considered appropriately in the pull request.; In any case, python and dependency upgrades will only happen in mayor or minor versions of QuTiP, not in a patch. .. _NEP29: https://numpy.org/neps/nep-0029-deprecation_policy.html. Code Style; ----------. The biggest concern you should always have is to make it easy for your code to be read and understood by the person who comes next. All new contributions must follow `PEP 8 style <https://peps.python.org/pep-0008/>`_; all pull requests will be passed through a linter that will complain if you violate it.; You should use the ``pycodestyle`` package locally (available on ``pip``) to test you satisfy the requirements before you push your commits, since this is rather faster than pushing 10 different commits trying to fix minor niggles.; Keep in mind that there is quite a lot of freedom in this style, especially when it comes to line breaks.; If a line is too long, consider the *best* way to split it up with the aim of making the code readable, not just the first thing that doesn't generate a warning. Try to stay consistent with the style of the surrounding code.; This includes using the same variable names, especially if they are function arguments, even if these ""break"" PEP 8 guidelines.; *Do not* change existing parameter, attribute or method names to ""match"" PEP 8; these are breaking user-facing changes, and cannot be made except in a new major release of QuTiP. Other than this, general ""good-practice"" Python standards apply: try not to duplicate code; try to keep functions short, descriptively-named and side-effect free; provide a docstring for every new function; and so on. Documenting; ----------",MatchSource.DOCS,doc/development/contributing.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:9208,Testability,test,test,9208,"except in a new major release of QuTiP. Other than this, general ""good-practice"" Python standards apply: try not to duplicate code; try to keep functions short, descriptively-named and side-effect free; provide a docstring for every new function; and so on. Documenting; -----------. When you make changes in the core library, you should update the relevant documentation if needed.; If you are making a bug fix, or other relatively minor changes, you will probably only need to make sure that the docstrings of the modified functions and classes are up-to-date; changes here will propagate through to the documentation the next time it is built.; Be sure to follow the |numpydoc|_ when writing docstrings.; All docstrings will be parsed as reStructuredText, and will form the API documentation section of the documentation. .. |numpydoc| replace:: Numpy documentation standards (``numpydoc``); .. _numpydoc: https://numpydoc.readthedocs.io/en/latest/format.html. Testing; -------. We use ``pytest`` as our test runner.; The base way to run every test is ::. pytest /path/to/repo/qutip/tests. This will take around 10 to 30 minutes, depending on your computer and how many of the optional requirements you have installed.; It is normal for some tests to be marked as ""skip"" or ""xfail"" in yellow; these are not problems.; True failures will appear in red and be called ""fail"" or ""error"". While prototyping and making changes, you might want to use some of the filtering features of ``pytest``.; Instead of passing the whole ``tests`` directory to the ``pytest`` command, you can also pass a list of files.; You can also use the ``-k`` selector to only run tests whose names include a particular pattern, for example ::. pytest qutip/tests/test_qobj.py -k ""expm"". to run the tests of :meth:`Qobj.expm`. Changelog Generation; --------------------. We use ``towncrier`` for tracking changes and generating a changelog.; When making a pull request, we require that you add a towncrier entry along with the",MatchSource.DOCS,doc/development/contributing.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:9248,Testability,test,test,9248,". Other than this, general ""good-practice"" Python standards apply: try not to duplicate code; try to keep functions short, descriptively-named and side-effect free; provide a docstring for every new function; and so on. Documenting; -----------. When you make changes in the core library, you should update the relevant documentation if needed.; If you are making a bug fix, or other relatively minor changes, you will probably only need to make sure that the docstrings of the modified functions and classes are up-to-date; changes here will propagate through to the documentation the next time it is built.; Be sure to follow the |numpydoc|_ when writing docstrings.; All docstrings will be parsed as reStructuredText, and will form the API documentation section of the documentation. .. |numpydoc| replace:: Numpy documentation standards (``numpydoc``); .. _numpydoc: https://numpydoc.readthedocs.io/en/latest/format.html. Testing; -------. We use ``pytest`` as our test runner.; The base way to run every test is ::. pytest /path/to/repo/qutip/tests. This will take around 10 to 30 minutes, depending on your computer and how many of the optional requirements you have installed.; It is normal for some tests to be marked as ""skip"" or ""xfail"" in yellow; these are not problems.; True failures will appear in red and be called ""fail"" or ""error"". While prototyping and making changes, you might want to use some of the filtering features of ``pytest``.; Instead of passing the whole ``tests`` directory to the ``pytest`` command, you can also pass a list of files.; You can also use the ``-k`` selector to only run tests whose names include a particular pattern, for example ::. pytest qutip/tests/test_qobj.py -k ""expm"". to run the tests of :meth:`Qobj.expm`. Changelog Generation; --------------------. We use ``towncrier`` for tracking changes and generating a changelog.; When making a pull request, we require that you add a towncrier entry along with the code changes.; You should create a fil",MatchSource.DOCS,doc/development/contributing.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:9287,Testability,test,tests,9287,"tice"" Python standards apply: try not to duplicate code; try to keep functions short, descriptively-named and side-effect free; provide a docstring for every new function; and so on. Documenting; -----------. When you make changes in the core library, you should update the relevant documentation if needed.; If you are making a bug fix, or other relatively minor changes, you will probably only need to make sure that the docstrings of the modified functions and classes are up-to-date; changes here will propagate through to the documentation the next time it is built.; Be sure to follow the |numpydoc|_ when writing docstrings.; All docstrings will be parsed as reStructuredText, and will form the API documentation section of the documentation. .. |numpydoc| replace:: Numpy documentation standards (``numpydoc``); .. _numpydoc: https://numpydoc.readthedocs.io/en/latest/format.html. Testing; -------. We use ``pytest`` as our test runner.; The base way to run every test is ::. pytest /path/to/repo/qutip/tests. This will take around 10 to 30 minutes, depending on your computer and how many of the optional requirements you have installed.; It is normal for some tests to be marked as ""skip"" or ""xfail"" in yellow; these are not problems.; True failures will appear in red and be called ""fail"" or ""error"". While prototyping and making changes, you might want to use some of the filtering features of ``pytest``.; Instead of passing the whole ``tests`` directory to the ``pytest`` command, you can also pass a list of files.; You can also use the ``-k`` selector to only run tests whose names include a particular pattern, for example ::. pytest qutip/tests/test_qobj.py -k ""expm"". to run the tests of :meth:`Qobj.expm`. Changelog Generation; --------------------. We use ``towncrier`` for tracking changes and generating a changelog.; When making a pull request, we require that you add a towncrier entry along with the code changes.; You should create a file named ``<PR number>.<change type>`",MatchSource.DOCS,doc/development/contributing.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:9446,Testability,test,tests,9446," -----------. When you make changes in the core library, you should update the relevant documentation if needed.; If you are making a bug fix, or other relatively minor changes, you will probably only need to make sure that the docstrings of the modified functions and classes are up-to-date; changes here will propagate through to the documentation the next time it is built.; Be sure to follow the |numpydoc|_ when writing docstrings.; All docstrings will be parsed as reStructuredText, and will form the API documentation section of the documentation. .. |numpydoc| replace:: Numpy documentation standards (``numpydoc``); .. _numpydoc: https://numpydoc.readthedocs.io/en/latest/format.html. Testing; -------. We use ``pytest`` as our test runner.; The base way to run every test is ::. pytest /path/to/repo/qutip/tests. This will take around 10 to 30 minutes, depending on your computer and how many of the optional requirements you have installed.; It is normal for some tests to be marked as ""skip"" or ""xfail"" in yellow; these are not problems.; True failures will appear in red and be called ""fail"" or ""error"". While prototyping and making changes, you might want to use some of the filtering features of ``pytest``.; Instead of passing the whole ``tests`` directory to the ``pytest`` command, you can also pass a list of files.; You can also use the ``-k`` selector to only run tests whose names include a particular pattern, for example ::. pytest qutip/tests/test_qobj.py -k ""expm"". to run the tests of :meth:`Qobj.expm`. Changelog Generation; --------------------. We use ``towncrier`` for tracking changes and generating a changelog.; When making a pull request, we require that you add a towncrier entry along with the code changes.; You should create a file named ``<PR number>.<change type>`` in the ``doc/changes`` directory, where the PR number should be substituted for ``<PR number>``, and ``<change type>`` is either ``feature``, ``bugfix``, ``doc``, ``removal``, ``misc``, or ``de",MatchSource.DOCS,doc/development/contributing.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:9726,Testability,test,tests,9726,"re up-to-date; changes here will propagate through to the documentation the next time it is built.; Be sure to follow the |numpydoc|_ when writing docstrings.; All docstrings will be parsed as reStructuredText, and will form the API documentation section of the documentation. .. |numpydoc| replace:: Numpy documentation standards (``numpydoc``); .. _numpydoc: https://numpydoc.readthedocs.io/en/latest/format.html. Testing; -------. We use ``pytest`` as our test runner.; The base way to run every test is ::. pytest /path/to/repo/qutip/tests. This will take around 10 to 30 minutes, depending on your computer and how many of the optional requirements you have installed.; It is normal for some tests to be marked as ""skip"" or ""xfail"" in yellow; these are not problems.; True failures will appear in red and be called ""fail"" or ""error"". While prototyping and making changes, you might want to use some of the filtering features of ``pytest``.; Instead of passing the whole ``tests`` directory to the ``pytest`` command, you can also pass a list of files.; You can also use the ``-k`` selector to only run tests whose names include a particular pattern, for example ::. pytest qutip/tests/test_qobj.py -k ""expm"". to run the tests of :meth:`Qobj.expm`. Changelog Generation; --------------------. We use ``towncrier`` for tracking changes and generating a changelog.; When making a pull request, we require that you add a towncrier entry along with the code changes.; You should create a file named ``<PR number>.<change type>`` in the ``doc/changes`` directory, where the PR number should be substituted for ``<PR number>``, and ``<change type>`` is either ``feature``, ``bugfix``, ``doc``, ``removal``, ``misc``, or ``deprecation``,; depending on the type of change included in the PR. You can also create this file by installing ``towncrier`` and running. towncrier create <PR number>.<change type>. Running this will create a file in the ``doc/changes`` directory with a filename corresponding to",MatchSource.DOCS,doc/development/contributing.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:9856,Testability,test,tests,9856,"llow the |numpydoc|_ when writing docstrings.; All docstrings will be parsed as reStructuredText, and will form the API documentation section of the documentation. .. |numpydoc| replace:: Numpy documentation standards (``numpydoc``); .. _numpydoc: https://numpydoc.readthedocs.io/en/latest/format.html. Testing; -------. We use ``pytest`` as our test runner.; The base way to run every test is ::. pytest /path/to/repo/qutip/tests. This will take around 10 to 30 minutes, depending on your computer and how many of the optional requirements you have installed.; It is normal for some tests to be marked as ""skip"" or ""xfail"" in yellow; these are not problems.; True failures will appear in red and be called ""fail"" or ""error"". While prototyping and making changes, you might want to use some of the filtering features of ``pytest``.; Instead of passing the whole ``tests`` directory to the ``pytest`` command, you can also pass a list of files.; You can also use the ``-k`` selector to only run tests whose names include a particular pattern, for example ::. pytest qutip/tests/test_qobj.py -k ""expm"". to run the tests of :meth:`Qobj.expm`. Changelog Generation; --------------------. We use ``towncrier`` for tracking changes and generating a changelog.; When making a pull request, we require that you add a towncrier entry along with the code changes.; You should create a file named ``<PR number>.<change type>`` in the ``doc/changes`` directory, where the PR number should be substituted for ``<PR number>``, and ``<change type>`` is either ``feature``, ``bugfix``, ``doc``, ``removal``, ``misc``, or ``deprecation``,; depending on the type of change included in the PR. You can also create this file by installing ``towncrier`` and running. towncrier create <PR number>.<change type>. Running this will create a file in the ``doc/changes`` directory with a filename corresponding to the argument you passed to ``towncrier create``.; In this file, you should add a short description of the change",MatchSource.DOCS,doc/development/contributing.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:9933,Testability,test,tests,9933,"rsed as reStructuredText, and will form the API documentation section of the documentation. .. |numpydoc| replace:: Numpy documentation standards (``numpydoc``); .. _numpydoc: https://numpydoc.readthedocs.io/en/latest/format.html. Testing; -------. We use ``pytest`` as our test runner.; The base way to run every test is ::. pytest /path/to/repo/qutip/tests. This will take around 10 to 30 minutes, depending on your computer and how many of the optional requirements you have installed.; It is normal for some tests to be marked as ""skip"" or ""xfail"" in yellow; these are not problems.; True failures will appear in red and be called ""fail"" or ""error"". While prototyping and making changes, you might want to use some of the filtering features of ``pytest``.; Instead of passing the whole ``tests`` directory to the ``pytest`` command, you can also pass a list of files.; You can also use the ``-k`` selector to only run tests whose names include a particular pattern, for example ::. pytest qutip/tests/test_qobj.py -k ""expm"". to run the tests of :meth:`Qobj.expm`. Changelog Generation; --------------------. We use ``towncrier`` for tracking changes and generating a changelog.; When making a pull request, we require that you add a towncrier entry along with the code changes.; You should create a file named ``<PR number>.<change type>`` in the ``doc/changes`` directory, where the PR number should be substituted for ``<PR number>``, and ``<change type>`` is either ``feature``, ``bugfix``, ``doc``, ``removal``, ``misc``, or ``deprecation``,; depending on the type of change included in the PR. You can also create this file by installing ``towncrier`` and running. towncrier create <PR number>.<change type>. Running this will create a file in the ``doc/changes`` directory with a filename corresponding to the argument you passed to ``towncrier create``.; In this file, you should add a short description of the changes that the PR introduces. .. _contributing-docs:. Documentation: qutip/q",MatchSource.DOCS,doc/development/contributing.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:9974,Testability,test,tests,9974,"API documentation section of the documentation. .. |numpydoc| replace:: Numpy documentation standards (``numpydoc``); .. _numpydoc: https://numpydoc.readthedocs.io/en/latest/format.html. Testing; -------. We use ``pytest`` as our test runner.; The base way to run every test is ::. pytest /path/to/repo/qutip/tests. This will take around 10 to 30 minutes, depending on your computer and how many of the optional requirements you have installed.; It is normal for some tests to be marked as ""skip"" or ""xfail"" in yellow; these are not problems.; True failures will appear in red and be called ""fail"" or ""error"". While prototyping and making changes, you might want to use some of the filtering features of ``pytest``.; Instead of passing the whole ``tests`` directory to the ``pytest`` command, you can also pass a list of files.; You can also use the ``-k`` selector to only run tests whose names include a particular pattern, for example ::. pytest qutip/tests/test_qobj.py -k ""expm"". to run the tests of :meth:`Qobj.expm`. Changelog Generation; --------------------. We use ``towncrier`` for tracking changes and generating a changelog.; When making a pull request, we require that you add a towncrier entry along with the code changes.; You should create a file named ``<PR number>.<change type>`` in the ``doc/changes`` directory, where the PR number should be substituted for ``<PR number>``, and ``<change type>`` is either ``feature``, ``bugfix``, ``doc``, ``removal``, ``misc``, or ``deprecation``,; depending on the type of change included in the PR. You can also create this file by installing ``towncrier`` and running. towncrier create <PR number>.<change type>. Running this will create a file in the ``doc/changes`` directory with a filename corresponding to the argument you passed to ``towncrier create``.; In this file, you should add a short description of the changes that the PR introduces. .. _contributing-docs:. Documentation: qutip/qutip (doc directory); =======================",MatchSource.DOCS,doc/development/contributing.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:12745,Testability,test,test,12745,"t to build the documentation in, because some of the dependencies can have tight requirements that may conflict with your favourite tools for Python development.; We recommend creating an empty ``conda`` environment containing only Python with ::. conda create -n qutip-doc python=3.8. and install all further dependencies with ``pip``.; There is a ``requirements.txt`` file in the repository root that fixes all package versions exactly into a known-good configuration for a completely empty environment, using ::. pip install -r requirements.txt. This known-good configuration was intended for Python 3.8, though in principle it is possible that other Python versions will work. .. note::. We recommend you use ``pip`` to install dependencies for the documentation rather than ``conda`` because several necessary packages can be slower to update their ``conda`` recipes, so suitable versions may not be available. The documentation build includes running many components of the main QuTiP library to generate figures and to test the output, and to generate all the API documentation.; You therefore need to have a version of QuTiP available in the same Python environment.; If you are only interested in updating the users' guide, you can use a release version of QuTiP, for example by running ``pip install qutip``.; If you are also modifying the main library, you need to make your development version accessible in this environment.; See the `above section on building QuTiP <contributing-qutip_>`_ for more details, though the ``requirements.txt`` file will have already installed all the build requirements, so you should be able to simply run ::. python setup.py develop. in the main library repository. The documentation is built by running the ``make`` command.; There are several targets to build, but the most useful will be ``html`` to build the webpage documentation, ``latexpdf`` to build the PDF documentation (you will also need a full ``pdflatex`` installation), and ``clean`` to re",MatchSource.DOCS,doc/development/contributing.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:14953,Testability,test,tests,14953,"hould be able to simply run ::. python setup.py develop. in the main library repository. The documentation is built by running the ``make`` command.; There are several targets to build, but the most useful will be ``html`` to build the webpage documentation, ``latexpdf`` to build the PDF documentation (you will also need a full ``pdflatex`` installation), and ``clean`` to remove all built files.; The most important command you will want to run is ::. make html. You should re-run this any time you make changes, and it should only update files that have been changed. .. important::; The documentation build includes running almost all the optional features of QuTiP.; If you get failure messages in red, make sure you have installed all of the optional dependencies for the main library. The HTML files will be placed in the ``_build/html`` directory.; You can open the file ``_build/html/index.html`` in your web browser to check the output. Code Style; ----------. All user guide pages and docstrings are parsed by Sphinx using reStructuredText.; There is a general `Sphinx usage guide <https://www.sphinx-doc.org/en/master/usage/index.html>`_, which has a lot of information that can sometimes be a little tricky to follow.; It may be easier just to look at other ``.rst`` files already in the documentation to copy the different styles. .. note::; reStructuredText is a very different language to the Markdown that you might be familiar with.; It's always worth checking your work in a web browser to make sure it's appeared the way you intended. Testing; -------. There are unfortunately no automated tests for the documentation.; You should ensure that no errors appeared in red when you ran ``make html``.; Try not to introduce any new warnings during the build process.; The main test is to open the HTML pages you have built (open ``_build/html/index.html`` in your web browser), and click through to the relevant pages to make sure everything has rendered the way you expected it to.; ",MatchSource.DOCS,doc/development/contributing.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:15135,Testability,test,test,15135,"hould be able to simply run ::. python setup.py develop. in the main library repository. The documentation is built by running the ``make`` command.; There are several targets to build, but the most useful will be ``html`` to build the webpage documentation, ``latexpdf`` to build the PDF documentation (you will also need a full ``pdflatex`` installation), and ``clean`` to remove all built files.; The most important command you will want to run is ::. make html. You should re-run this any time you make changes, and it should only update files that have been changed. .. important::; The documentation build includes running almost all the optional features of QuTiP.; If you get failure messages in red, make sure you have installed all of the optional dependencies for the main library. The HTML files will be placed in the ``_build/html`` directory.; You can open the file ``_build/html/index.html`` in your web browser to check the output. Code Style; ----------. All user guide pages and docstrings are parsed by Sphinx using reStructuredText.; There is a general `Sphinx usage guide <https://www.sphinx-doc.org/en/master/usage/index.html>`_, which has a lot of information that can sometimes be a little tricky to follow.; It may be easier just to look at other ``.rst`` files already in the documentation to copy the different styles. .. note::; reStructuredText is a very different language to the Markdown that you might be familiar with.; It's always worth checking your work in a web browser to make sure it's appeared the way you intended. Testing; -------. There are unfortunately no automated tests for the documentation.; You should ensure that no errors appeared in red when you ran ``make html``.; Try not to introduce any new warnings during the build process.; The main test is to open the HTML pages you have built (open ``_build/html/index.html`` in your web browser), and click through to the relevant pages to make sure everything has rendered the way you expected it to.; ",MatchSource.DOCS,doc/development/contributing.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:2488,Usability,feedback,feedback,2488,"it commit``).; #. Follow the build process for this repository to build the final result so you can check your changes work sensibly.; #. Run the tests for the repository (if it has them).; #. Push the changes to your fork (``git push -u origin <branch-name>``). You won't be able to push to the main QuTiP repositories directly.; #. Go to the GitHub website for the repository you are contributing to, click on the ""Pull Requests"" tab, click the ""New Pull Request"" button, and follow the instructions there. Once the pull request is created, some members of the QuTiP admin team will review the code to make sure it is suitable for inclusion in the library, to check the programming, and to ensure everything meets our standards.; For some repositories, several automated tests will run whenever you create or modify a pull request; in general these will be the same tests you can run locally, and all tests are required to pass online before your changes are merged.; There may be some feedback and possibly some requested changes.; You can add more commits to address these, and push them to the relevant branch of your fork to update the pull request. The rest of this document covers programming standards, and particular considerations for some of the more complicated repositories. .. _contributing-qutip:. Core Library: qutip/qutip; =========================. The core library is in the `qutip/qutip repository on GitHub <https://github.com/qutip/qutip>`_. Building; --------. Building the core library from source is typically a bit more difficult than simply installing the package for regular use.; You will most likely want to do this in a clean Python environment so that you do not compromise a working installation of a release version, for example by starting from ::. conda create -n qutip-dev python. :ref:`Complete instructions for the build <install>` are elsewhere in this guide, however beware that you will need to follow the :ref:`installation from source using setuptools sect",MatchSource.DOCS,doc/development/contributing.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:3062,Usability,simpl,simply,3062,"e members of the QuTiP admin team will review the code to make sure it is suitable for inclusion in the library, to check the programming, and to ensure everything meets our standards.; For some repositories, several automated tests will run whenever you create or modify a pull request; in general these will be the same tests you can run locally, and all tests are required to pass online before your changes are merged.; There may be some feedback and possibly some requested changes.; You can add more commits to address these, and push them to the relevant branch of your fork to update the pull request. The rest of this document covers programming standards, and particular considerations for some of the more complicated repositories. .. _contributing-qutip:. Core Library: qutip/qutip; =========================. The core library is in the `qutip/qutip repository on GitHub <https://github.com/qutip/qutip>`_. Building; --------. Building the core library from source is typically a bit more difficult than simply installing the package for regular use.; You will most likely want to do this in a clean Python environment so that you do not compromise a working installation of a release version, for example by starting from ::. conda create -n qutip-dev python. :ref:`Complete instructions for the build <install>` are elsewhere in this guide, however beware that you will need to follow the :ref:`installation from source using setuptools section <build-setuptools>`, not the general installation.; You will need all the *build* and *tests* ""optional"" requirements for the package.; The build requirements can be found in the |pyproject.toml file|_, and the testing requirements are in the ``tests`` key of the ``options.extras_require`` section of |setup.cfg|_.; You will also need the requirements for any optional features you want to test as well. .. |pyproject.toml file| replace:: ``pyproject.toml`` file; .. _pyproject.toml file: https://github.com/qutip/qutip/blob/master/pyprojec",MatchSource.DOCS,doc/development/contributing.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:3394,Usability,guid,guide,3394," before your changes are merged.; There may be some feedback and possibly some requested changes.; You can add more commits to address these, and push them to the relevant branch of your fork to update the pull request. The rest of this document covers programming standards, and particular considerations for some of the more complicated repositories. .. _contributing-qutip:. Core Library: qutip/qutip; =========================. The core library is in the `qutip/qutip repository on GitHub <https://github.com/qutip/qutip>`_. Building; --------. Building the core library from source is typically a bit more difficult than simply installing the package for regular use.; You will most likely want to do this in a clean Python environment so that you do not compromise a working installation of a release version, for example by starting from ::. conda create -n qutip-dev python. :ref:`Complete instructions for the build <install>` are elsewhere in this guide, however beware that you will need to follow the :ref:`installation from source using setuptools section <build-setuptools>`, not the general installation.; You will need all the *build* and *tests* ""optional"" requirements for the package.; The build requirements can be found in the |pyproject.toml file|_, and the testing requirements are in the ``tests`` key of the ``options.extras_require`` section of |setup.cfg|_.; You will also need the requirements for any optional features you want to test as well. .. |pyproject.toml file| replace:: ``pyproject.toml`` file; .. _pyproject.toml file: https://github.com/qutip/qutip/blob/master/pyproject.toml; .. |setup.cfg| replace:: ``setup.cfg``; .. _setup.cfg: https://github.com/qutip/qutip/blob/master/setup.cfg. Refer to the main instructions for the most up-to-date version, however as of version 4.6 the requirements can be installed into a conda environment with ::. conda install setuptools wheel numpy scipy cython packaging pytest pytest-rerunfailures. Note that ``qutip`` should ",MatchSource.DOCS,doc/development/contributing.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:5052,Usability,guid,guide,5052,"`` file; .. _pyproject.toml file: https://github.com/qutip/qutip/blob/master/pyproject.toml; .. |setup.cfg| replace:: ``setup.cfg``; .. _setup.cfg: https://github.com/qutip/qutip/blob/master/setup.cfg. Refer to the main instructions for the most up-to-date version, however as of version 4.6 the requirements can be installed into a conda environment with ::. conda install setuptools wheel numpy scipy cython packaging pytest pytest-rerunfailures. Note that ``qutip`` should *not* be installed with ``conda install``. .. note::; If you prefer, you can also use ``pip`` to install all the dependencies.; We typically recommend ``conda`` when doing main-library development because it is easier to switch low-level packages around like BLAS implementations, but if this doesn't mean anything to you, feel free to use ``pip``. You will need to make sure you have a functioning C++ compiler to build QuTiP.; If you are on Linux or Mac, this is likely already done for you, however if you are on Windows, refer to the :ref:`Windows installation <install-on-windows>` section of the installation guide. The command to build QuTiP in editable mode is ::. python setup.py develop. from the repository directory.; If you now load up a Python interpreter, you should be able to ``import qutip`` from anywhere as long as the correct Python environment is active.; Any changes you make to the Python files in the git repository should be immediately present if you restart your Python interpreter and re-import ``qutip``. On the first run, the setup command will compile many C++ extension modules built from Cython sources (files ending ``.pxd`` and ``.pyx``).; Generally the low-level linear algebra routines that QuTiP uses are written in these files, not in pure Python.; Unlike Python files, changes you make to Cython files will not appear until you run ``python setup.py develop`` again; you will only need to re-run this if you are changing Cython files.; Cython will detect and compile only the files t",MatchSource.DOCS,doc/development/contributing.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:8049,Usability,guid,guidelines,8049,"g/neps/nep-0029-deprecation_policy.html. Code Style; ----------. The biggest concern you should always have is to make it easy for your code to be read and understood by the person who comes next. All new contributions must follow `PEP 8 style <https://peps.python.org/pep-0008/>`_; all pull requests will be passed through a linter that will complain if you violate it.; You should use the ``pycodestyle`` package locally (available on ``pip``) to test you satisfy the requirements before you push your commits, since this is rather faster than pushing 10 different commits trying to fix minor niggles.; Keep in mind that there is quite a lot of freedom in this style, especially when it comes to line breaks.; If a line is too long, consider the *best* way to split it up with the aim of making the code readable, not just the first thing that doesn't generate a warning. Try to stay consistent with the style of the surrounding code.; This includes using the same variable names, especially if they are function arguments, even if these ""break"" PEP 8 guidelines.; *Do not* change existing parameter, attribute or method names to ""match"" PEP 8; these are breaking user-facing changes, and cannot be made except in a new major release of QuTiP. Other than this, general ""good-practice"" Python standards apply: try not to duplicate code; try to keep functions short, descriptively-named and side-effect free; provide a docstring for every new function; and so on. Documenting; -----------. When you make changes in the core library, you should update the relevant documentation if needed.; If you are making a bug fix, or other relatively minor changes, you will probably only need to make sure that the docstrings of the modified functions and classes are up-to-date; changes here will propagate through to the documentation the next time it is built.; Be sure to follow the |numpydoc|_ when writing docstrings.; All docstrings will be parsed as reStructuredText, and will form the API documentation ",MatchSource.DOCS,doc/development/contributing.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:11475,Usability,simpl,simply,11475," depending on the type of change included in the PR. You can also create this file by installing ``towncrier`` and running. towncrier create <PR number>.<change type>. Running this will create a file in the ``doc/changes`` directory with a filename corresponding to the argument you passed to ``towncrier create``.; In this file, you should add a short description of the changes that the PR introduces. .. _contributing-docs:. Documentation: qutip/qutip (doc directory); ==========================================. The core library is in the `qutip/qutip repository on GitHub, inside the doc directory <https://github.com/qutip/qutip>`_. Building; --------. The documentation is built using ``sphinx``, ``matplotlib`` and ``numpydoc``, with several additional extensions including ``sphinx-gallery`` and ``sphinx-rtd-theme``.; The most up-to-date instructions and dependencies will be in the ``README.md`` file of the documentation directory.; You can see the rendered version of this file simply by going to the `documentation GitHub page <https://github.com/qutip/qutip/tree/master/doc>`_ and scrolling down. Building the documentation can be a little finnicky on occasion.; You likely will want to keep a separate Python environment to build the documentation in, because some of the dependencies can have tight requirements that may conflict with your favourite tools for Python development.; We recommend creating an empty ``conda`` environment containing only Python with ::. conda create -n qutip-doc python=3.8. and install all further dependencies with ``pip``.; There is a ``requirements.txt`` file in the repository root that fixes all package versions exactly into a known-good configuration for a completely empty environment, using ::. pip install -r requirements.txt. This known-good configuration was intended for Python 3.8, though in principle it is possible that other Python versions will work. .. note::. We recommend you use ``pip`` to install dependencies for the documentatio",MatchSource.DOCS,doc/development/contributing.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:12945,Usability,guid,guide,12945,". conda create -n qutip-doc python=3.8. and install all further dependencies with ``pip``.; There is a ``requirements.txt`` file in the repository root that fixes all package versions exactly into a known-good configuration for a completely empty environment, using ::. pip install -r requirements.txt. This known-good configuration was intended for Python 3.8, though in principle it is possible that other Python versions will work. .. note::. We recommend you use ``pip`` to install dependencies for the documentation rather than ``conda`` because several necessary packages can be slower to update their ``conda`` recipes, so suitable versions may not be available. The documentation build includes running many components of the main QuTiP library to generate figures and to test the output, and to generate all the API documentation.; You therefore need to have a version of QuTiP available in the same Python environment.; If you are only interested in updating the users' guide, you can use a release version of QuTiP, for example by running ``pip install qutip``.; If you are also modifying the main library, you need to make your development version accessible in this environment.; See the `above section on building QuTiP <contributing-qutip_>`_ for more details, though the ``requirements.txt`` file will have already installed all the build requirements, so you should be able to simply run ::. python setup.py develop. in the main library repository. The documentation is built by running the ``make`` command.; There are several targets to build, but the most useful will be ``html`` to build the webpage documentation, ``latexpdf`` to build the PDF documentation (you will also need a full ``pdflatex`` installation), and ``clean`` to remove all built files.; The most important command you will want to run is ::. make html. You should re-run this any time you make changes, and it should only update files that have been changed. .. important::; The documentation build includes ru",MatchSource.DOCS,doc/development/contributing.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:13359,Usability,simpl,simply,13359,"n 3.8, though in principle it is possible that other Python versions will work. .. note::. We recommend you use ``pip`` to install dependencies for the documentation rather than ``conda`` because several necessary packages can be slower to update their ``conda`` recipes, so suitable versions may not be available. The documentation build includes running many components of the main QuTiP library to generate figures and to test the output, and to generate all the API documentation.; You therefore need to have a version of QuTiP available in the same Python environment.; If you are only interested in updating the users' guide, you can use a release version of QuTiP, for example by running ``pip install qutip``.; If you are also modifying the main library, you need to make your development version accessible in this environment.; See the `above section on building QuTiP <contributing-qutip_>`_ for more details, though the ``requirements.txt`` file will have already installed all the build requirements, so you should be able to simply run ::. python setup.py develop. in the main library repository. The documentation is built by running the ``make`` command.; There are several targets to build, but the most useful will be ``html`` to build the webpage documentation, ``latexpdf`` to build the PDF documentation (you will also need a full ``pdflatex`` installation), and ``clean`` to remove all built files.; The most important command you will want to run is ::. make html. You should re-run this any time you make changes, and it should only update files that have been changed. .. important::; The documentation build includes running almost all the optional features of QuTiP.; If you get failure messages in red, make sure you have installed all of the optional dependencies for the main library. The HTML files will be placed in the ``_build/html`` directory.; You can open the file ``_build/html/index.html`` in your web browser to check the output. Code Style; ----------. All us",MatchSource.DOCS,doc/development/contributing.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:14323,Usability,guid,guide,14323,"hould be able to simply run ::. python setup.py develop. in the main library repository. The documentation is built by running the ``make`` command.; There are several targets to build, but the most useful will be ``html`` to build the webpage documentation, ``latexpdf`` to build the PDF documentation (you will also need a full ``pdflatex`` installation), and ``clean`` to remove all built files.; The most important command you will want to run is ::. make html. You should re-run this any time you make changes, and it should only update files that have been changed. .. important::; The documentation build includes running almost all the optional features of QuTiP.; If you get failure messages in red, make sure you have installed all of the optional dependencies for the main library. The HTML files will be placed in the ``_build/html`` directory.; You can open the file ``_build/html/index.html`` in your web browser to check the output. Code Style; ----------. All user guide pages and docstrings are parsed by Sphinx using reStructuredText.; There is a general `Sphinx usage guide <https://www.sphinx-doc.org/en/master/usage/index.html>`_, which has a lot of information that can sometimes be a little tricky to follow.; It may be easier just to look at other ``.rst`` files already in the documentation to copy the different styles. .. note::; reStructuredText is a very different language to the Markdown that you might be familiar with.; It's always worth checking your work in a web browser to make sure it's appeared the way you intended. Testing; -------. There are unfortunately no automated tests for the documentation.; You should ensure that no errors appeared in red when you ran ``make html``.; Try not to introduce any new warnings during the build process.; The main test is to open the HTML pages you have built (open ``_build/html/index.html`` in your web browser), and click through to the relevant pages to make sure everything has rendered the way you expected it to.; ",MatchSource.DOCS,doc/development/contributing.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst:14429,Usability,guid,guide,14429,"hould be able to simply run ::. python setup.py develop. in the main library repository. The documentation is built by running the ``make`` command.; There are several targets to build, but the most useful will be ``html`` to build the webpage documentation, ``latexpdf`` to build the PDF documentation (you will also need a full ``pdflatex`` installation), and ``clean`` to remove all built files.; The most important command you will want to run is ::. make html. You should re-run this any time you make changes, and it should only update files that have been changed. .. important::; The documentation build includes running almost all the optional features of QuTiP.; If you get failure messages in red, make sure you have installed all of the optional dependencies for the main library. The HTML files will be placed in the ``_build/html`` directory.; You can open the file ``_build/html/index.html`` in your web browser to check the output. Code Style; ----------. All user guide pages and docstrings are parsed by Sphinx using reStructuredText.; There is a general `Sphinx usage guide <https://www.sphinx-doc.org/en/master/usage/index.html>`_, which has a lot of information that can sometimes be a little tricky to follow.; It may be easier just to look at other ``.rst`` files already in the documentation to copy the different styles. .. note::; reStructuredText is a very different language to the Markdown that you might be familiar with.; It's always worth checking your work in a web browser to make sure it's appeared the way you intended. Testing; -------. There are unfortunately no automated tests for the documentation.; You should ensure that no errors appeared in red when you ran ``make html``.; Try not to introduce any new warnings during the build process.; The main test is to open the HTML pages you have built (open ``_build/html/index.html`` in your web browser), and click through to the relevant pages to make sure everything has rendered the way you expected it to.; ",MatchSource.DOCS,doc/development/contributing.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/development.rst:199,Deployability,release,releases,199,".. _development:. *************************; Development Documentation; *************************. This chapter covers the development of QuTiP and its subpackages, including; a roadmap for upcoming releases and ideas for future improvements. .. toctree::; :maxdepth: 3. contributing.rst; roadmap.rst; ideas.rst; docs.rst; release_distribution.rst; ",MatchSource.DOCS,doc/development/development.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/development.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/docs.rst:1018,Modifiability,config,configured,1018,".rst:. ************************************; Working with the QuTiP Documentation; ************************************. The user guide provides an overview of QuTiP's functionality.; The guide is composed of individual reStructuredText (``.rst``) files which each get rendered as a webpage.; Each page typically tackles one area of functionality.; To learn more about how to write ``.rst`` files, it is useful to follow the `sphinx guide <https://www.sphinx-doc.org/en/master/usage/index.html>`_. The documentation build also utilizes a number of; `Sphinx Extensions <https://www.sphinx-doc.org/en/master/usage/extensions/index.html>`_; including but not limited to; `doctest <https://www.sphinx-doc.org/en/master/usage/extensions/doctest.html>`_,; `autodoc <https://www.sphinx-doc.org/en/master/usage/extensions/autodoc.html>`_,; `sphinx gallery <https://sphinx-gallery.github.io/stable/index.html>`_ and; `plot <https://matplotlib.org/3.1.1/devel/plot_directive.html>`_.; Additional extensions can be configured in the `conf.py <https://github.com/qutip/qutip/blob/master/doc/conf.py>`_ file. .. _directives.rst:. Directives; ==========. There are two Sphinx directives that can be used to write code examples in the user guide:. - `Doctest <https://www.sphinx-doc.org/en/master/usage/extensions/doctest.html>`_; - `Plot <https://matplotlib.org/3.1.1/devel/plot_directive.html>`_. For a more comprehensive account of the usage of each directive, please refer to their individual pages. Here we outline some general guidelines on how to these directives while making a user guide. Doctest; -------. The doctest directive enables tests on interactive code examples.; The simplest way to do this is by specifying a prompt along with its respective output: ::. .. doctest::. >>> a = 2; >>> a; 2. This is rendered in the documentation as follows:. .. doctest::. >>> a = 2; >>> a; 2. While specifying code examples under the ``.. doctest::`` directive, either all statements must be specified by the ``>>",MatchSource.DOCS,doc/development/docs.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/docs.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/docs.rst:1645,Testability,test,tests,1645,">`_; including but not limited to; `doctest <https://www.sphinx-doc.org/en/master/usage/extensions/doctest.html>`_,; `autodoc <https://www.sphinx-doc.org/en/master/usage/extensions/autodoc.html>`_,; `sphinx gallery <https://sphinx-gallery.github.io/stable/index.html>`_ and; `plot <https://matplotlib.org/3.1.1/devel/plot_directive.html>`_.; Additional extensions can be configured in the `conf.py <https://github.com/qutip/qutip/blob/master/doc/conf.py>`_ file. .. _directives.rst:. Directives; ==========. There are two Sphinx directives that can be used to write code examples in the user guide:. - `Doctest <https://www.sphinx-doc.org/en/master/usage/extensions/doctest.html>`_; - `Plot <https://matplotlib.org/3.1.1/devel/plot_directive.html>`_. For a more comprehensive account of the usage of each directive, please refer to their individual pages. Here we outline some general guidelines on how to these directives while making a user guide. Doctest; -------. The doctest directive enables tests on interactive code examples.; The simplest way to do this is by specifying a prompt along with its respective output: ::. .. doctest::. >>> a = 2; >>> a; 2. This is rendered in the documentation as follows:. .. doctest::. >>> a = 2; >>> a; 2. While specifying code examples under the ``.. doctest::`` directive, either all statements must be specified by the ``>>>`` prompt or without it.; For every prompt, any potential corresponding output must be specified immediately after it.; This directive is ideally used when there are a number of examples that need to be checked in quick succession. A different way to specify code examples (and test them) is using the associated ``.. testcode::`` directive which is effectively a code block: ::. .. testcode::. a = 2; print(a). followed by its results.; The result can be specified with the ``.. testoutput::`` block: ::. .. testoutput::. 2. The advantage of the ``testcode`` directive is that it is a lot simpler to; specify and amenable to copyi",MatchSource.DOCS,doc/development/docs.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/docs.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/docs.rst:2294,Testability,test,test,2294,"master/usage/extensions/doctest.html>`_; - `Plot <https://matplotlib.org/3.1.1/devel/plot_directive.html>`_. For a more comprehensive account of the usage of each directive, please refer to their individual pages. Here we outline some general guidelines on how to these directives while making a user guide. Doctest; -------. The doctest directive enables tests on interactive code examples.; The simplest way to do this is by specifying a prompt along with its respective output: ::. .. doctest::. >>> a = 2; >>> a; 2. This is rendered in the documentation as follows:. .. doctest::. >>> a = 2; >>> a; 2. While specifying code examples under the ``.. doctest::`` directive, either all statements must be specified by the ``>>>`` prompt or without it.; For every prompt, any potential corresponding output must be specified immediately after it.; This directive is ideally used when there are a number of examples that need to be checked in quick succession. A different way to specify code examples (and test them) is using the associated ``.. testcode::`` directive which is effectively a code block: ::. .. testcode::. a = 2; print(a). followed by its results.; The result can be specified with the ``.. testoutput::`` block: ::. .. testoutput::. 2. The advantage of the ``testcode`` directive is that it is a lot simpler to; specify and amenable to copying the code to clipboard. Usually, tests are; more easily specified with this directive as the input and output are; specified in different blocks. The rendering is neater too. .. note::; The ``doctest`` and ``testcode`` directives should not be assumed to; have the same namespace. **Output:**. .. testcode::. a = 2; print(a). .. testoutput::. 2. A few notes on using the doctest extension:. - By default, each ``testcode`` and ``doctest`` block is run in a fresh namespace.; To share a common namespace, we can specify a common group across the blocks; (within a single ``.rst`` file). For example, ::. .. doctest:: [group_name]. >>> a = 2. ",MatchSource.DOCS,doc/development/docs.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/docs.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/docs.rst:2334,Testability,test,testcode,2334,"1.1/devel/plot_directive.html>`_. For a more comprehensive account of the usage of each directive, please refer to their individual pages. Here we outline some general guidelines on how to these directives while making a user guide. Doctest; -------. The doctest directive enables tests on interactive code examples.; The simplest way to do this is by specifying a prompt along with its respective output: ::. .. doctest::. >>> a = 2; >>> a; 2. This is rendered in the documentation as follows:. .. doctest::. >>> a = 2; >>> a; 2. While specifying code examples under the ``.. doctest::`` directive, either all statements must be specified by the ``>>>`` prompt or without it.; For every prompt, any potential corresponding output must be specified immediately after it.; This directive is ideally used when there are a number of examples that need to be checked in quick succession. A different way to specify code examples (and test them) is using the associated ``.. testcode::`` directive which is effectively a code block: ::. .. testcode::. a = 2; print(a). followed by its results.; The result can be specified with the ``.. testoutput::`` block: ::. .. testoutput::. 2. The advantage of the ``testcode`` directive is that it is a lot simpler to; specify and amenable to copying the code to clipboard. Usually, tests are; more easily specified with this directive as the input and output are; specified in different blocks. The rendering is neater too. .. note::; The ``doctest`` and ``testcode`` directives should not be assumed to; have the same namespace. **Output:**. .. testcode::. a = 2; print(a). .. testoutput::. 2. A few notes on using the doctest extension:. - By default, each ``testcode`` and ``doctest`` block is run in a fresh namespace.; To share a common namespace, we can specify a common group across the blocks; (within a single ``.rst`` file). For example, ::. .. doctest:: [group_name]. >>> a = 2. can be followed by some explanation followed by another code block; sharin",MatchSource.DOCS,doc/development/docs.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/docs.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/docs.rst:2399,Testability,test,testcode,2399,"more comprehensive account of the usage of each directive, please refer to their individual pages. Here we outline some general guidelines on how to these directives while making a user guide. Doctest; -------. The doctest directive enables tests on interactive code examples.; The simplest way to do this is by specifying a prompt along with its respective output: ::. .. doctest::. >>> a = 2; >>> a; 2. This is rendered in the documentation as follows:. .. doctest::. >>> a = 2; >>> a; 2. While specifying code examples under the ``.. doctest::`` directive, either all statements must be specified by the ``>>>`` prompt or without it.; For every prompt, any potential corresponding output must be specified immediately after it.; This directive is ideally used when there are a number of examples that need to be checked in quick succession. A different way to specify code examples (and test them) is using the associated ``.. testcode::`` directive which is effectively a code block: ::. .. testcode::. a = 2; print(a). followed by its results.; The result can be specified with the ``.. testoutput::`` block: ::. .. testoutput::. 2. The advantage of the ``testcode`` directive is that it is a lot simpler to; specify and amenable to copying the code to clipboard. Usually, tests are; more easily specified with this directive as the input and output are; specified in different blocks. The rendering is neater too. .. note::; The ``doctest`` and ``testcode`` directives should not be assumed to; have the same namespace. **Output:**. .. testcode::. a = 2; print(a). .. testoutput::. 2. A few notes on using the doctest extension:. - By default, each ``testcode`` and ``doctest`` block is run in a fresh namespace.; To share a common namespace, we can specify a common group across the blocks; (within a single ``.rst`` file). For example, ::. .. doctest:: [group_name]. >>> a = 2. can be followed by some explanation followed by another code block; sharing the same namespace ::. .. doctest:: [g",MatchSource.DOCS,doc/development/docs.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/docs.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/docs.rst:2496,Testability,test,testoutput,2496,"we outline some general guidelines on how to these directives while making a user guide. Doctest; -------. The doctest directive enables tests on interactive code examples.; The simplest way to do this is by specifying a prompt along with its respective output: ::. .. doctest::. >>> a = 2; >>> a; 2. This is rendered in the documentation as follows:. .. doctest::. >>> a = 2; >>> a; 2. While specifying code examples under the ``.. doctest::`` directive, either all statements must be specified by the ``>>>`` prompt or without it.; For every prompt, any potential corresponding output must be specified immediately after it.; This directive is ideally used when there are a number of examples that need to be checked in quick succession. A different way to specify code examples (and test them) is using the associated ``.. testcode::`` directive which is effectively a code block: ::. .. testcode::. a = 2; print(a). followed by its results.; The result can be specified with the ``.. testoutput::`` block: ::. .. testoutput::. 2. The advantage of the ``testcode`` directive is that it is a lot simpler to; specify and amenable to copying the code to clipboard. Usually, tests are; more easily specified with this directive as the input and output are; specified in different blocks. The rendering is neater too. .. note::; The ``doctest`` and ``testcode`` directives should not be assumed to; have the same namespace. **Output:**. .. testcode::. a = 2; print(a). .. testoutput::. 2. A few notes on using the doctest extension:. - By default, each ``testcode`` and ``doctest`` block is run in a fresh namespace.; To share a common namespace, we can specify a common group across the blocks; (within a single ``.rst`` file). For example, ::. .. doctest:: [group_name]. >>> a = 2. can be followed by some explanation followed by another code block; sharing the same namespace ::. .. doctest:: [group_name]. >>> print(a); 2. - To only print the code blocks (or the output), use the option ``+SKIP`` t",MatchSource.DOCS,doc/development/docs.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/docs.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/docs.rst:2525,Testability,test,testoutput,2525," guidelines on how to these directives while making a user guide. Doctest; -------. The doctest directive enables tests on interactive code examples.; The simplest way to do this is by specifying a prompt along with its respective output: ::. .. doctest::. >>> a = 2; >>> a; 2. This is rendered in the documentation as follows:. .. doctest::. >>> a = 2; >>> a; 2. While specifying code examples under the ``.. doctest::`` directive, either all statements must be specified by the ``>>>`` prompt or without it.; For every prompt, any potential corresponding output must be specified immediately after it.; This directive is ideally used when there are a number of examples that need to be checked in quick succession. A different way to specify code examples (and test them) is using the associated ``.. testcode::`` directive which is effectively a code block: ::. .. testcode::. a = 2; print(a). followed by its results.; The result can be specified with the ``.. testoutput::`` block: ::. .. testoutput::. 2. The advantage of the ``testcode`` directive is that it is a lot simpler to; specify and amenable to copying the code to clipboard. Usually, tests are; more easily specified with this directive as the input and output are; specified in different blocks. The rendering is neater too. .. note::; The ``doctest`` and ``testcode`` directives should not be assumed to; have the same namespace. **Output:**. .. testcode::. a = 2; print(a). .. testoutput::. 2. A few notes on using the doctest extension:. - By default, each ``testcode`` and ``doctest`` block is run in a fresh namespace.; To share a common namespace, we can specify a common group across the blocks; (within a single ``.rst`` file). For example, ::. .. doctest:: [group_name]. >>> a = 2. can be followed by some explanation followed by another code block; sharing the same namespace ::. .. doctest:: [group_name]. >>> print(a); 2. - To only print the code blocks (or the output), use the option ``+SKIP`` to; specify the block wi",MatchSource.DOCS,doc/development/docs.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/docs.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/docs.rst:2565,Testability,test,testcode,2565,"-------. The doctest directive enables tests on interactive code examples.; The simplest way to do this is by specifying a prompt along with its respective output: ::. .. doctest::. >>> a = 2; >>> a; 2. This is rendered in the documentation as follows:. .. doctest::. >>> a = 2; >>> a; 2. While specifying code examples under the ``.. doctest::`` directive, either all statements must be specified by the ``>>>`` prompt or without it.; For every prompt, any potential corresponding output must be specified immediately after it.; This directive is ideally used when there are a number of examples that need to be checked in quick succession. A different way to specify code examples (and test them) is using the associated ``.. testcode::`` directive which is effectively a code block: ::. .. testcode::. a = 2; print(a). followed by its results.; The result can be specified with the ``.. testoutput::`` block: ::. .. testoutput::. 2. The advantage of the ``testcode`` directive is that it is a lot simpler to; specify and amenable to copying the code to clipboard. Usually, tests are; more easily specified with this directive as the input and output are; specified in different blocks. The rendering is neater too. .. note::; The ``doctest`` and ``testcode`` directives should not be assumed to; have the same namespace. **Output:**. .. testcode::. a = 2; print(a). .. testoutput::. 2. A few notes on using the doctest extension:. - By default, each ``testcode`` and ``doctest`` block is run in a fresh namespace.; To share a common namespace, we can specify a common group across the blocks; (within a single ``.rst`` file). For example, ::. .. doctest:: [group_name]. >>> a = 2. can be followed by some explanation followed by another code block; sharing the same namespace ::. .. doctest:: [group_name]. >>> print(a); 2. - To only print the code blocks (or the output), use the option ``+SKIP`` to; specify the block without the code being tested when running ``make doctest``. - To check the re",MatchSource.DOCS,doc/development/docs.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/docs.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/docs.rst:2682,Testability,test,tests,2682,"pt along with its respective output: ::. .. doctest::. >>> a = 2; >>> a; 2. This is rendered in the documentation as follows:. .. doctest::. >>> a = 2; >>> a; 2. While specifying code examples under the ``.. doctest::`` directive, either all statements must be specified by the ``>>>`` prompt or without it.; For every prompt, any potential corresponding output must be specified immediately after it.; This directive is ideally used when there are a number of examples that need to be checked in quick succession. A different way to specify code examples (and test them) is using the associated ``.. testcode::`` directive which is effectively a code block: ::. .. testcode::. a = 2; print(a). followed by its results.; The result can be specified with the ``.. testoutput::`` block: ::. .. testoutput::. 2. The advantage of the ``testcode`` directive is that it is a lot simpler to; specify and amenable to copying the code to clipboard. Usually, tests are; more easily specified with this directive as the input and output are; specified in different blocks. The rendering is neater too. .. note::; The ``doctest`` and ``testcode`` directives should not be assumed to; have the same namespace. **Output:**. .. testcode::. a = 2; print(a). .. testoutput::. 2. A few notes on using the doctest extension:. - By default, each ``testcode`` and ``doctest`` block is run in a fresh namespace.; To share a common namespace, we can specify a common group across the blocks; (within a single ``.rst`` file). For example, ::. .. doctest:: [group_name]. >>> a = 2. can be followed by some explanation followed by another code block; sharing the same namespace ::. .. doctest:: [group_name]. >>> print(a); 2. - To only print the code blocks (or the output), use the option ``+SKIP`` to; specify the block without the code being tested when running ``make doctest``. - To check the result of a ``Qobj`` output, it is useful to make sure that; spacing irregularities between the expected and actual output are i",MatchSource.DOCS,doc/development/docs.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/docs.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/docs.rst:2857,Testability,test,testcode,2857," a = 2; >>> a; 2. While specifying code examples under the ``.. doctest::`` directive, either all statements must be specified by the ``>>>`` prompt or without it.; For every prompt, any potential corresponding output must be specified immediately after it.; This directive is ideally used when there are a number of examples that need to be checked in quick succession. A different way to specify code examples (and test them) is using the associated ``.. testcode::`` directive which is effectively a code block: ::. .. testcode::. a = 2; print(a). followed by its results.; The result can be specified with the ``.. testoutput::`` block: ::. .. testoutput::. 2. The advantage of the ``testcode`` directive is that it is a lot simpler to; specify and amenable to copying the code to clipboard. Usually, tests are; more easily specified with this directive as the input and output are; specified in different blocks. The rendering is neater too. .. note::; The ``doctest`` and ``testcode`` directives should not be assumed to; have the same namespace. **Output:**. .. testcode::. a = 2; print(a). .. testoutput::. 2. A few notes on using the doctest extension:. - By default, each ``testcode`` and ``doctest`` block is run in a fresh namespace.; To share a common namespace, we can specify a common group across the blocks; (within a single ``.rst`` file). For example, ::. .. doctest:: [group_name]. >>> a = 2. can be followed by some explanation followed by another code block; sharing the same namespace ::. .. doctest:: [group_name]. >>> print(a); 2. - To only print the code blocks (or the output), use the option ``+SKIP`` to; specify the block without the code being tested when running ``make doctest``. - To check the result of a ``Qobj`` output, it is useful to make sure that; spacing irregularities between the expected and actual output are ignored.; For that, we can use the option ``+NORMALIZE_WHITESPACE``. Plot; ----. Since the doctest directive cannot render matplotlib figures, we ",MatchSource.DOCS,doc/development/docs.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/docs.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/docs.rst:2946,Testability,test,testcode,2946,"` directive, either all statements must be specified by the ``>>>`` prompt or without it.; For every prompt, any potential corresponding output must be specified immediately after it.; This directive is ideally used when there are a number of examples that need to be checked in quick succession. A different way to specify code examples (and test them) is using the associated ``.. testcode::`` directive which is effectively a code block: ::. .. testcode::. a = 2; print(a). followed by its results.; The result can be specified with the ``.. testoutput::`` block: ::. .. testoutput::. 2. The advantage of the ``testcode`` directive is that it is a lot simpler to; specify and amenable to copying the code to clipboard. Usually, tests are; more easily specified with this directive as the input and output are; specified in different blocks. The rendering is neater too. .. note::; The ``doctest`` and ``testcode`` directives should not be assumed to; have the same namespace. **Output:**. .. testcode::. a = 2; print(a). .. testoutput::. 2. A few notes on using the doctest extension:. - By default, each ``testcode`` and ``doctest`` block is run in a fresh namespace.; To share a common namespace, we can specify a common group across the blocks; (within a single ``.rst`` file). For example, ::. .. doctest:: [group_name]. >>> a = 2. can be followed by some explanation followed by another code block; sharing the same namespace ::. .. doctest:: [group_name]. >>> print(a); 2. - To only print the code blocks (or the output), use the option ``+SKIP`` to; specify the block without the code being tested when running ``make doctest``. - To check the result of a ``Qobj`` output, it is useful to make sure that; spacing irregularities between the expected and actual output are ignored.; For that, we can use the option ``+NORMALIZE_WHITESPACE``. Plot; ----. Since the doctest directive cannot render matplotlib figures, we use Matplotlib's; `Plot <https://matplotlib.org/3.1.1/devel/plot_directiv",MatchSource.DOCS,doc/development/docs.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/docs.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/docs.rst:2978,Testability,test,testoutput,2978,"s must be specified by the ``>>>`` prompt or without it.; For every prompt, any potential corresponding output must be specified immediately after it.; This directive is ideally used when there are a number of examples that need to be checked in quick succession. A different way to specify code examples (and test them) is using the associated ``.. testcode::`` directive which is effectively a code block: ::. .. testcode::. a = 2; print(a). followed by its results.; The result can be specified with the ``.. testoutput::`` block: ::. .. testoutput::. 2. The advantage of the ``testcode`` directive is that it is a lot simpler to; specify and amenable to copying the code to clipboard. Usually, tests are; more easily specified with this directive as the input and output are; specified in different blocks. The rendering is neater too. .. note::; The ``doctest`` and ``testcode`` directives should not be assumed to; have the same namespace. **Output:**. .. testcode::. a = 2; print(a). .. testoutput::. 2. A few notes on using the doctest extension:. - By default, each ``testcode`` and ``doctest`` block is run in a fresh namespace.; To share a common namespace, we can specify a common group across the blocks; (within a single ``.rst`` file). For example, ::. .. doctest:: [group_name]. >>> a = 2. can be followed by some explanation followed by another code block; sharing the same namespace ::. .. doctest:: [group_name]. >>> print(a); 2. - To only print the code blocks (or the output), use the option ``+SKIP`` to; specify the block without the code being tested when running ``make doctest``. - To check the result of a ``Qobj`` output, it is useful to make sure that; spacing irregularities between the expected and actual output are ignored.; For that, we can use the option ``+NORMALIZE_WHITESPACE``. Plot; ----. Since the doctest directive cannot render matplotlib figures, we use Matplotlib's; `Plot <https://matplotlib.org/3.1.1/devel/plot_directive.html>`_; directive when renderi",MatchSource.DOCS,doc/development/docs.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/docs.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/docs.rst:3061,Testability,test,testcode,3061,"ponding output must be specified immediately after it.; This directive is ideally used when there are a number of examples that need to be checked in quick succession. A different way to specify code examples (and test them) is using the associated ``.. testcode::`` directive which is effectively a code block: ::. .. testcode::. a = 2; print(a). followed by its results.; The result can be specified with the ``.. testoutput::`` block: ::. .. testoutput::. 2. The advantage of the ``testcode`` directive is that it is a lot simpler to; specify and amenable to copying the code to clipboard. Usually, tests are; more easily specified with this directive as the input and output are; specified in different blocks. The rendering is neater too. .. note::; The ``doctest`` and ``testcode`` directives should not be assumed to; have the same namespace. **Output:**. .. testcode::. a = 2; print(a). .. testoutput::. 2. A few notes on using the doctest extension:. - By default, each ``testcode`` and ``doctest`` block is run in a fresh namespace.; To share a common namespace, we can specify a common group across the blocks; (within a single ``.rst`` file). For example, ::. .. doctest:: [group_name]. >>> a = 2. can be followed by some explanation followed by another code block; sharing the same namespace ::. .. doctest:: [group_name]. >>> print(a); 2. - To only print the code blocks (or the output), use the option ``+SKIP`` to; specify the block without the code being tested when running ``make doctest``. - To check the result of a ``Qobj`` output, it is useful to make sure that; spacing irregularities between the expected and actual output are ignored.; For that, we can use the option ``+NORMALIZE_WHITESPACE``. Plot; ----. Since the doctest directive cannot render matplotlib figures, we use Matplotlib's; `Plot <https://matplotlib.org/3.1.1/devel/plot_directive.html>`_; directive when rendering to LaTeX or HTML. The plot directive can also be used in the doctest format. In this case,; wh",MatchSource.DOCS,doc/development/docs.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/docs.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/docs.rst:3552,Testability,test,tested,3552," block: ::. .. testoutput::. 2. The advantage of the ``testcode`` directive is that it is a lot simpler to; specify and amenable to copying the code to clipboard. Usually, tests are; more easily specified with this directive as the input and output are; specified in different blocks. The rendering is neater too. .. note::; The ``doctest`` and ``testcode`` directives should not be assumed to; have the same namespace. **Output:**. .. testcode::. a = 2; print(a). .. testoutput::. 2. A few notes on using the doctest extension:. - By default, each ``testcode`` and ``doctest`` block is run in a fresh namespace.; To share a common namespace, we can specify a common group across the blocks; (within a single ``.rst`` file). For example, ::. .. doctest:: [group_name]. >>> a = 2. can be followed by some explanation followed by another code block; sharing the same namespace ::. .. doctest:: [group_name]. >>> print(a); 2. - To only print the code blocks (or the output), use the option ``+SKIP`` to; specify the block without the code being tested when running ``make doctest``. - To check the result of a ``Qobj`` output, it is useful to make sure that; spacing irregularities between the expected and actual output are ignored.; For that, we can use the option ``+NORMALIZE_WHITESPACE``. Plot; ----. Since the doctest directive cannot render matplotlib figures, we use Matplotlib's; `Plot <https://matplotlib.org/3.1.1/devel/plot_directive.html>`_; directive when rendering to LaTeX or HTML. The plot directive can also be used in the doctest format. In this case,; when running doctests (which is enabled by specifying all statements with the; ``>>>`` prompts), tests also include those specified under the plot directive. **Example:**; ::. First we specify some data:. .. plot::. >>> import numpy as np; >>> x = np.linspace(0, 2 * np.pi, 1000); >>> x[:10] # doctest: +NORMALIZE_WHITESPACE; array([ 0. , 0.00628947, 0.01257895, 0.01886842, 0.0251579 ,; 0.03144737, 0.03773685, 0.04402632, 0.050315",MatchSource.DOCS,doc/development/docs.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/docs.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/docs.rst:4176,Testability,test,tests,4176,"ce, we can specify a common group across the blocks; (within a single ``.rst`` file). For example, ::. .. doctest:: [group_name]. >>> a = 2. can be followed by some explanation followed by another code block; sharing the same namespace ::. .. doctest:: [group_name]. >>> print(a); 2. - To only print the code blocks (or the output), use the option ``+SKIP`` to; specify the block without the code being tested when running ``make doctest``. - To check the result of a ``Qobj`` output, it is useful to make sure that; spacing irregularities between the expected and actual output are ignored.; For that, we can use the option ``+NORMALIZE_WHITESPACE``. Plot; ----. Since the doctest directive cannot render matplotlib figures, we use Matplotlib's; `Plot <https://matplotlib.org/3.1.1/devel/plot_directive.html>`_; directive when rendering to LaTeX or HTML. The plot directive can also be used in the doctest format. In this case,; when running doctests (which is enabled by specifying all statements with the; ``>>>`` prompts), tests also include those specified under the plot directive. **Example:**; ::. First we specify some data:. .. plot::. >>> import numpy as np; >>> x = np.linspace(0, 2 * np.pi, 1000); >>> x[:10] # doctest: +NORMALIZE_WHITESPACE; array([ 0. , 0.00628947, 0.01257895, 0.01886842, 0.0251579 ,; 0.03144737, 0.03773685, 0.04402632, 0.0503158 , 0.05660527]). .. plot::; :context:. >>> import matplotlib.pyplot as plt; >>> plt.plot(x, np.sin(x)); [...]. Note the use of the ``NORMALIZE_WHITESPACE`` option to ensure that the; multiline output matches. **Render:**. .. plot::. >>> import numpy as np; >>> x = np.linspace(0, 2 * np.pi, 1000); >>> x[:10] # doctest: +SKIP; array([ 0. , 0.00628947, 0.01257895, 0.01886842, 0.0251579 ,; 0.03144737, 0.03773685, 0.04402632, 0.0503158 , 0.05660527]); >>> import matplotlib.pyplot as plt; >>> plt.plot(x, np.sin(x)); [...]. A few notes on using the plot directive:. - A useful argument to specify in plot blocks is that of ``context`` whic",MatchSource.DOCS,doc/development/docs.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/docs.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/docs.rst:5926,Testability,test,testing,5926,"unning doctests (which is enabled by specifying all statements with the; ``>>>`` prompts), tests also include those specified under the plot directive. **Example:**; ::. First we specify some data:. .. plot::. >>> import numpy as np; >>> x = np.linspace(0, 2 * np.pi, 1000); >>> x[:10] # doctest: +NORMALIZE_WHITESPACE; array([ 0. , 0.00628947, 0.01257895, 0.01886842, 0.0251579 ,; 0.03144737, 0.03773685, 0.04402632, 0.0503158 , 0.05660527]). .. plot::; :context:. >>> import matplotlib.pyplot as plt; >>> plt.plot(x, np.sin(x)); [...]. Note the use of the ``NORMALIZE_WHITESPACE`` option to ensure that the; multiline output matches. **Render:**. .. plot::. >>> import numpy as np; >>> x = np.linspace(0, 2 * np.pi, 1000); >>> x[:10] # doctest: +SKIP; array([ 0. , 0.00628947, 0.01257895, 0.01886842, 0.0251579 ,; 0.03144737, 0.03773685, 0.04402632, 0.0503158 , 0.05660527]); >>> import matplotlib.pyplot as plt; >>> plt.plot(x, np.sin(x)); [...]. A few notes on using the plot directive:. - A useful argument to specify in plot blocks is that of ``context`` which ensures; that the code is being run in the namespace of the previous plot block within the; same file. - By default, each rendered figure in one plot block (when using ``:context:``); is carried over to the next block. - When the ``context`` argument is specified with the ``reset`` option; as ``:context: reset``, the namespace is reset to a new one and all figures are; erased. - When the ``context`` argument is specified with the ``close-figs`` option; as ``:context: reset``, the namespace is reset to a new one and all figures are; erased. The Plot directive cannot be used in conjunction with Doctest because they do not; share the same namespace when used in the same file.; Since Plot can also be used in doctest mode, in; the case where code examples require both testing and rendering figures, it is; easier to use the Plot directive. To learn more about each directive, it is useful; to refer to their individual pages.; ",MatchSource.DOCS,doc/development/docs.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/docs.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/docs.rst:144,Usability,guid,guide,144,".. _user_guide.rst:. ************************************; Working with the QuTiP Documentation; ************************************. The user guide provides an overview of QuTiP's functionality.; The guide is composed of individual reStructuredText (``.rst``) files which each get rendered as a webpage.; Each page typically tackles one area of functionality.; To learn more about how to write ``.rst`` files, it is useful to follow the `sphinx guide <https://www.sphinx-doc.org/en/master/usage/index.html>`_. The documentation build also utilizes a number of; `Sphinx Extensions <https://www.sphinx-doc.org/en/master/usage/extensions/index.html>`_; including but not limited to; `doctest <https://www.sphinx-doc.org/en/master/usage/extensions/doctest.html>`_,; `autodoc <https://www.sphinx-doc.org/en/master/usage/extensions/autodoc.html>`_,; `sphinx gallery <https://sphinx-gallery.github.io/stable/index.html>`_ and; `plot <https://matplotlib.org/3.1.1/devel/plot_directive.html>`_.; Additional extensions can be configured in the `conf.py <https://github.com/qutip/qutip/blob/master/doc/conf.py>`_ file. .. _directives.rst:. Directives; ==========. There are two Sphinx directives that can be used to write code examples in the user guide:. - `Doctest <https://www.sphinx-doc.org/en/master/usage/extensions/doctest.html>`_; - `Plot <https://matplotlib.org/3.1.1/devel/plot_directive.html>`_. For a more comprehensive account of the usage of each directive, please refer to their individual pages. Here we outline some general guidelines on how to these directives while making a user guide. Doctest; -------. The doctest directive enables tests on interactive code examples.; The simplest way to do this is by specifying a prompt along with its respective output: ::. .. doctest::. >>> a = 2; >>> a; 2. This is rendered in the documentation as follows:. .. doctest::. >>> a = 2; >>> a; 2. While specifying code examples under the ``.. doctest::`` directive, either all statements must be specifi",MatchSource.DOCS,doc/development/docs.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/docs.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/docs.rst:202,Usability,guid,guide,202,".. _user_guide.rst:. ************************************; Working with the QuTiP Documentation; ************************************. The user guide provides an overview of QuTiP's functionality.; The guide is composed of individual reStructuredText (``.rst``) files which each get rendered as a webpage.; Each page typically tackles one area of functionality.; To learn more about how to write ``.rst`` files, it is useful to follow the `sphinx guide <https://www.sphinx-doc.org/en/master/usage/index.html>`_. The documentation build also utilizes a number of; `Sphinx Extensions <https://www.sphinx-doc.org/en/master/usage/extensions/index.html>`_; including but not limited to; `doctest <https://www.sphinx-doc.org/en/master/usage/extensions/doctest.html>`_,; `autodoc <https://www.sphinx-doc.org/en/master/usage/extensions/autodoc.html>`_,; `sphinx gallery <https://sphinx-gallery.github.io/stable/index.html>`_ and; `plot <https://matplotlib.org/3.1.1/devel/plot_directive.html>`_.; Additional extensions can be configured in the `conf.py <https://github.com/qutip/qutip/blob/master/doc/conf.py>`_ file. .. _directives.rst:. Directives; ==========. There are two Sphinx directives that can be used to write code examples in the user guide:. - `Doctest <https://www.sphinx-doc.org/en/master/usage/extensions/doctest.html>`_; - `Plot <https://matplotlib.org/3.1.1/devel/plot_directive.html>`_. For a more comprehensive account of the usage of each directive, please refer to their individual pages. Here we outline some general guidelines on how to these directives while making a user guide. Doctest; -------. The doctest directive enables tests on interactive code examples.; The simplest way to do this is by specifying a prompt along with its respective output: ::. .. doctest::. >>> a = 2; >>> a; 2. This is rendered in the documentation as follows:. .. doctest::. >>> a = 2; >>> a; 2. While specifying code examples under the ``.. doctest::`` directive, either all statements must be specifi",MatchSource.DOCS,doc/development/docs.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/docs.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/docs.rst:366,Usability,learn,learn,366,".. _user_guide.rst:. ************************************; Working with the QuTiP Documentation; ************************************. The user guide provides an overview of QuTiP's functionality.; The guide is composed of individual reStructuredText (``.rst``) files which each get rendered as a webpage.; Each page typically tackles one area of functionality.; To learn more about how to write ``.rst`` files, it is useful to follow the `sphinx guide <https://www.sphinx-doc.org/en/master/usage/index.html>`_. The documentation build also utilizes a number of; `Sphinx Extensions <https://www.sphinx-doc.org/en/master/usage/extensions/index.html>`_; including but not limited to; `doctest <https://www.sphinx-doc.org/en/master/usage/extensions/doctest.html>`_,; `autodoc <https://www.sphinx-doc.org/en/master/usage/extensions/autodoc.html>`_,; `sphinx gallery <https://sphinx-gallery.github.io/stable/index.html>`_ and; `plot <https://matplotlib.org/3.1.1/devel/plot_directive.html>`_.; Additional extensions can be configured in the `conf.py <https://github.com/qutip/qutip/blob/master/doc/conf.py>`_ file. .. _directives.rst:. Directives; ==========. There are two Sphinx directives that can be used to write code examples in the user guide:. - `Doctest <https://www.sphinx-doc.org/en/master/usage/extensions/doctest.html>`_; - `Plot <https://matplotlib.org/3.1.1/devel/plot_directive.html>`_. For a more comprehensive account of the usage of each directive, please refer to their individual pages. Here we outline some general guidelines on how to these directives while making a user guide. Doctest; -------. The doctest directive enables tests on interactive code examples.; The simplest way to do this is by specifying a prompt along with its respective output: ::. .. doctest::. >>> a = 2; >>> a; 2. This is rendered in the documentation as follows:. .. doctest::. >>> a = 2; >>> a; 2. While specifying code examples under the ``.. doctest::`` directive, either all statements must be specifi",MatchSource.DOCS,doc/development/docs.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/docs.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/docs.rst:447,Usability,guid,guide,447,".. _user_guide.rst:. ************************************; Working with the QuTiP Documentation; ************************************. The user guide provides an overview of QuTiP's functionality.; The guide is composed of individual reStructuredText (``.rst``) files which each get rendered as a webpage.; Each page typically tackles one area of functionality.; To learn more about how to write ``.rst`` files, it is useful to follow the `sphinx guide <https://www.sphinx-doc.org/en/master/usage/index.html>`_. The documentation build also utilizes a number of; `Sphinx Extensions <https://www.sphinx-doc.org/en/master/usage/extensions/index.html>`_; including but not limited to; `doctest <https://www.sphinx-doc.org/en/master/usage/extensions/doctest.html>`_,; `autodoc <https://www.sphinx-doc.org/en/master/usage/extensions/autodoc.html>`_,; `sphinx gallery <https://sphinx-gallery.github.io/stable/index.html>`_ and; `plot <https://matplotlib.org/3.1.1/devel/plot_directive.html>`_.; Additional extensions can be configured in the `conf.py <https://github.com/qutip/qutip/blob/master/doc/conf.py>`_ file. .. _directives.rst:. Directives; ==========. There are two Sphinx directives that can be used to write code examples in the user guide:. - `Doctest <https://www.sphinx-doc.org/en/master/usage/extensions/doctest.html>`_; - `Plot <https://matplotlib.org/3.1.1/devel/plot_directive.html>`_. For a more comprehensive account of the usage of each directive, please refer to their individual pages. Here we outline some general guidelines on how to these directives while making a user guide. Doctest; -------. The doctest directive enables tests on interactive code examples.; The simplest way to do this is by specifying a prompt along with its respective output: ::. .. doctest::. >>> a = 2; >>> a; 2. This is rendered in the documentation as follows:. .. doctest::. >>> a = 2; >>> a; 2. While specifying code examples under the ``.. doctest::`` directive, either all statements must be specifi",MatchSource.DOCS,doc/development/docs.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/docs.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/docs.rst:1239,Usability,guid,guide,1239,"e guide is composed of individual reStructuredText (``.rst``) files which each get rendered as a webpage.; Each page typically tackles one area of functionality.; To learn more about how to write ``.rst`` files, it is useful to follow the `sphinx guide <https://www.sphinx-doc.org/en/master/usage/index.html>`_. The documentation build also utilizes a number of; `Sphinx Extensions <https://www.sphinx-doc.org/en/master/usage/extensions/index.html>`_; including but not limited to; `doctest <https://www.sphinx-doc.org/en/master/usage/extensions/doctest.html>`_,; `autodoc <https://www.sphinx-doc.org/en/master/usage/extensions/autodoc.html>`_,; `sphinx gallery <https://sphinx-gallery.github.io/stable/index.html>`_ and; `plot <https://matplotlib.org/3.1.1/devel/plot_directive.html>`_.; Additional extensions can be configured in the `conf.py <https://github.com/qutip/qutip/blob/master/doc/conf.py>`_ file. .. _directives.rst:. Directives; ==========. There are two Sphinx directives that can be used to write code examples in the user guide:. - `Doctest <https://www.sphinx-doc.org/en/master/usage/extensions/doctest.html>`_; - `Plot <https://matplotlib.org/3.1.1/devel/plot_directive.html>`_. For a more comprehensive account of the usage of each directive, please refer to their individual pages. Here we outline some general guidelines on how to these directives while making a user guide. Doctest; -------. The doctest directive enables tests on interactive code examples.; The simplest way to do this is by specifying a prompt along with its respective output: ::. .. doctest::. >>> a = 2; >>> a; 2. This is rendered in the documentation as follows:. .. doctest::. >>> a = 2; >>> a; 2. While specifying code examples under the ``.. doctest::`` directive, either all statements must be specified by the ``>>>`` prompt or without it.; For every prompt, any potential corresponding output must be specified immediately after it.; This directive is ideally used when there are a number of exampl",MatchSource.DOCS,doc/development/docs.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/docs.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/docs.rst:1532,Usability,guid,guidelines,1532," a number of; `Sphinx Extensions <https://www.sphinx-doc.org/en/master/usage/extensions/index.html>`_; including but not limited to; `doctest <https://www.sphinx-doc.org/en/master/usage/extensions/doctest.html>`_,; `autodoc <https://www.sphinx-doc.org/en/master/usage/extensions/autodoc.html>`_,; `sphinx gallery <https://sphinx-gallery.github.io/stable/index.html>`_ and; `plot <https://matplotlib.org/3.1.1/devel/plot_directive.html>`_.; Additional extensions can be configured in the `conf.py <https://github.com/qutip/qutip/blob/master/doc/conf.py>`_ file. .. _directives.rst:. Directives; ==========. There are two Sphinx directives that can be used to write code examples in the user guide:. - `Doctest <https://www.sphinx-doc.org/en/master/usage/extensions/doctest.html>`_; - `Plot <https://matplotlib.org/3.1.1/devel/plot_directive.html>`_. For a more comprehensive account of the usage of each directive, please refer to their individual pages. Here we outline some general guidelines on how to these directives while making a user guide. Doctest; -------. The doctest directive enables tests on interactive code examples.; The simplest way to do this is by specifying a prompt along with its respective output: ::. .. doctest::. >>> a = 2; >>> a; 2. This is rendered in the documentation as follows:. .. doctest::. >>> a = 2; >>> a; 2. While specifying code examples under the ``.. doctest::`` directive, either all statements must be specified by the ``>>>`` prompt or without it.; For every prompt, any potential corresponding output must be specified immediately after it.; This directive is ideally used when there are a number of examples that need to be checked in quick succession. A different way to specify code examples (and test them) is using the associated ``.. testcode::`` directive which is effectively a code block: ::. .. testcode::. a = 2; print(a). followed by its results.; The result can be specified with the ``.. testoutput::`` block: ::. .. testoutput::. 2. The adv",MatchSource.DOCS,doc/development/docs.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/docs.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/docs.rst:1590,Usability,guid,guide,1590," a number of; `Sphinx Extensions <https://www.sphinx-doc.org/en/master/usage/extensions/index.html>`_; including but not limited to; `doctest <https://www.sphinx-doc.org/en/master/usage/extensions/doctest.html>`_,; `autodoc <https://www.sphinx-doc.org/en/master/usage/extensions/autodoc.html>`_,; `sphinx gallery <https://sphinx-gallery.github.io/stable/index.html>`_ and; `plot <https://matplotlib.org/3.1.1/devel/plot_directive.html>`_.; Additional extensions can be configured in the `conf.py <https://github.com/qutip/qutip/blob/master/doc/conf.py>`_ file. .. _directives.rst:. Directives; ==========. There are two Sphinx directives that can be used to write code examples in the user guide:. - `Doctest <https://www.sphinx-doc.org/en/master/usage/extensions/doctest.html>`_; - `Plot <https://matplotlib.org/3.1.1/devel/plot_directive.html>`_. For a more comprehensive account of the usage of each directive, please refer to their individual pages. Here we outline some general guidelines on how to these directives while making a user guide. Doctest; -------. The doctest directive enables tests on interactive code examples.; The simplest way to do this is by specifying a prompt along with its respective output: ::. .. doctest::. >>> a = 2; >>> a; 2. This is rendered in the documentation as follows:. .. doctest::. >>> a = 2; >>> a; 2. While specifying code examples under the ``.. doctest::`` directive, either all statements must be specified by the ``>>>`` prompt or without it.; For every prompt, any potential corresponding output must be specified immediately after it.; This directive is ideally used when there are a number of examples that need to be checked in quick succession. A different way to specify code examples (and test them) is using the associated ``.. testcode::`` directive which is effectively a code block: ::. .. testcode::. a = 2; print(a). followed by its results.; The result can be specified with the ``.. testoutput::`` block: ::. .. testoutput::. 2. The adv",MatchSource.DOCS,doc/development/docs.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/docs.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/docs.rst:1686,Usability,simpl,simplest,1686,"er/usage/extensions/doctest.html>`_,; `autodoc <https://www.sphinx-doc.org/en/master/usage/extensions/autodoc.html>`_,; `sphinx gallery <https://sphinx-gallery.github.io/stable/index.html>`_ and; `plot <https://matplotlib.org/3.1.1/devel/plot_directive.html>`_.; Additional extensions can be configured in the `conf.py <https://github.com/qutip/qutip/blob/master/doc/conf.py>`_ file. .. _directives.rst:. Directives; ==========. There are two Sphinx directives that can be used to write code examples in the user guide:. - `Doctest <https://www.sphinx-doc.org/en/master/usage/extensions/doctest.html>`_; - `Plot <https://matplotlib.org/3.1.1/devel/plot_directive.html>`_. For a more comprehensive account of the usage of each directive, please refer to their individual pages. Here we outline some general guidelines on how to these directives while making a user guide. Doctest; -------. The doctest directive enables tests on interactive code examples.; The simplest way to do this is by specifying a prompt along with its respective output: ::. .. doctest::. >>> a = 2; >>> a; 2. This is rendered in the documentation as follows:. .. doctest::. >>> a = 2; >>> a; 2. While specifying code examples under the ``.. doctest::`` directive, either all statements must be specified by the ``>>>`` prompt or without it.; For every prompt, any potential corresponding output must be specified immediately after it.; This directive is ideally used when there are a number of examples that need to be checked in quick succession. A different way to specify code examples (and test them) is using the associated ``.. testcode::`` directive which is effectively a code block: ::. .. testcode::. a = 2; print(a). followed by its results.; The result can be specified with the ``.. testoutput::`` block: ::. .. testoutput::. 2. The advantage of the ``testcode`` directive is that it is a lot simpler to; specify and amenable to copying the code to clipboard. Usually, tests are; more easily specified with this di",MatchSource.DOCS,doc/development/docs.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/docs.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/docs.rst:2606,Usability,simpl,simpler,2606,"-------. The doctest directive enables tests on interactive code examples.; The simplest way to do this is by specifying a prompt along with its respective output: ::. .. doctest::. >>> a = 2; >>> a; 2. This is rendered in the documentation as follows:. .. doctest::. >>> a = 2; >>> a; 2. While specifying code examples under the ``.. doctest::`` directive, either all statements must be specified by the ``>>>`` prompt or without it.; For every prompt, any potential corresponding output must be specified immediately after it.; This directive is ideally used when there are a number of examples that need to be checked in quick succession. A different way to specify code examples (and test them) is using the associated ``.. testcode::`` directive which is effectively a code block: ::. .. testcode::. a = 2; print(a). followed by its results.; The result can be specified with the ``.. testoutput::`` block: ::. .. testoutput::. 2. The advantage of the ``testcode`` directive is that it is a lot simpler to; specify and amenable to copying the code to clipboard. Usually, tests are; more easily specified with this directive as the input and output are; specified in different blocks. The rendering is neater too. .. note::; The ``doctest`` and ``testcode`` directives should not be assumed to; have the same namespace. **Output:**. .. testcode::. a = 2; print(a). .. testoutput::. 2. A few notes on using the doctest extension:. - By default, each ``testcode`` and ``doctest`` block is run in a fresh namespace.; To share a common namespace, we can specify a common group across the blocks; (within a single ``.rst`` file). For example, ::. .. doctest:: [group_name]. >>> a = 2. can be followed by some explanation followed by another code block; sharing the same namespace ::. .. doctest:: [group_name]. >>> print(a); 2. - To only print the code blocks (or the output), use the option ``+SKIP`` to; specify the block without the code being tested when running ``make doctest``. - To check the re",MatchSource.DOCS,doc/development/docs.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/docs.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/docs.rst:6001,Usability,learn,learn,6001,"unning doctests (which is enabled by specifying all statements with the; ``>>>`` prompts), tests also include those specified under the plot directive. **Example:**; ::. First we specify some data:. .. plot::. >>> import numpy as np; >>> x = np.linspace(0, 2 * np.pi, 1000); >>> x[:10] # doctest: +NORMALIZE_WHITESPACE; array([ 0. , 0.00628947, 0.01257895, 0.01886842, 0.0251579 ,; 0.03144737, 0.03773685, 0.04402632, 0.0503158 , 0.05660527]). .. plot::; :context:. >>> import matplotlib.pyplot as plt; >>> plt.plot(x, np.sin(x)); [...]. Note the use of the ``NORMALIZE_WHITESPACE`` option to ensure that the; multiline output matches. **Render:**. .. plot::. >>> import numpy as np; >>> x = np.linspace(0, 2 * np.pi, 1000); >>> x[:10] # doctest: +SKIP; array([ 0. , 0.00628947, 0.01257895, 0.01886842, 0.0251579 ,; 0.03144737, 0.03773685, 0.04402632, 0.0503158 , 0.05660527]); >>> import matplotlib.pyplot as plt; >>> plt.plot(x, np.sin(x)); [...]. A few notes on using the plot directive:. - A useful argument to specify in plot blocks is that of ``context`` which ensures; that the code is being run in the namespace of the previous plot block within the; same file. - By default, each rendered figure in one plot block (when using ``:context:``); is carried over to the next block. - When the ``context`` argument is specified with the ``reset`` option; as ``:context: reset``, the namespace is reset to a new one and all figures are; erased. - When the ``context`` argument is specified with the ``close-figs`` option; as ``:context: reset``, the namespace is reset to a new one and all figures are; erased. The Plot directive cannot be used in conjunction with Doctest because they do not; share the same namespace when used in the same file.; Since Plot can also be used in doctest mode, in; the case where code examples require both testing and rendering figures, it is; easier to use the Plot directive. To learn more about each directive, it is useful; to refer to their individual pages.; ",MatchSource.DOCS,doc/development/docs.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/docs.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas.rst:341,Availability,error,error-mitigation,341,".. _development_ideas:. **********************************; Ideas for future QuTiP development; **********************************. Ideas for significant new features are listed here. For the general roadmap,; see :doc:`roadmap`. .. toctree::; :maxdepth: 1. ideas/qutip-interactive.rst; ideas/pulse-level-quantum-circuits.rst; ideas/quantum-error-mitigation.rst; ideas/heom-gpu.rst. Google Summer of Code; =====================. Many possible extensions and improvements to QuTiP have been documented as; part of `Google Summer of Code <https://summerofcode.withgoogle.com/>`_:. * `GSoC 2021 <https://github.com/qutip/qutip/wiki/Google-Summer-of-Code-2021/>`_; * `GSoC 2022 <https://github.com/qutip/qutip/wiki/Google-Summer-of-Code-2022/>`_. Completed Projects; ==================. These projects have been completed:. .. toctree::; :maxdepth: 1. ideas/tensorflow-data-backend.rst; ",MatchSource.DOCS,doc/development/ideas.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:11924,Availability,down,download,11924," #. Push this branch to your fork, and make a pull request against the release branch.; On GitHub in the PR screen, you will need to change the ""Base"" branch to ``qutip-4.6.X`` (or whatever version), because GitHub will default to making it against ``master``.; It should be quite clear if you have forgotten to do this, because there will probably be many merge conflicts.; Once the tests have passed and you have another admin's approval, merge the PR. You should now see that the ``qutip-4.6.X`` (or whatever) branch on GitHub has been updated, and now includes all the changes you have just made.; If you have made a mistake, feel free to make additonal PRs to rectify the situation. You are now ready to actually perform the release.; Go to deploy_. .. _deploy:. Build Release Distribution and Deploy; +++++++++++++++++++++++++++++++++++++. This step builds the source (sdist) and binary (wheel) distributions, and uploads them to PyPI (pip).; You will also be able to download the built files yourself in order to upload them to the QuTiP website. Build and Deploy; ----------------. This is handled entirely by a GitHub Action.; Go to the `""Actions"" tab at the top of the QuTiP code repository <https://github.com/qutip/qutip/actions>`_.; Click on the ""Build wheels, optionally deploy to PyPI"" action in the left-hand sidebar.; Click the ""Run workflow"" dropdown in the header notification; it should look like the image below. .. image:: ../figures/release_guide_run_build_workflow.png. - Use the drop-down menu to choose the branch or tag you want to release from.; This should be called ``qutip-4.5.X`` or similar, depending on what you made earlier.; This must *never* be ``master``.; - To make the release to PyPI, type the branch name (e.g. ``qutip-4.5.X``) into the ""Confirm chosen branch name [...]"" field.; You *may* leave this field blank to skip the deployment and only build the package.; - (Special circumstances) If for some reason you need to override the version number (for exa",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:12459,Availability,down,down,12459,"s been updated, and now includes all the changes you have just made.; If you have made a mistake, feel free to make additonal PRs to rectify the situation. You are now ready to actually perform the release.; Go to deploy_. .. _deploy:. Build Release Distribution and Deploy; +++++++++++++++++++++++++++++++++++++. This step builds the source (sdist) and binary (wheel) distributions, and uploads them to PyPI (pip).; You will also be able to download the built files yourself in order to upload them to the QuTiP website. Build and Deploy; ----------------. This is handled entirely by a GitHub Action.; Go to the `""Actions"" tab at the top of the QuTiP code repository <https://github.com/qutip/qutip/actions>`_.; Click on the ""Build wheels, optionally deploy to PyPI"" action in the left-hand sidebar.; Click the ""Run workflow"" dropdown in the header notification; it should look like the image below. .. image:: ../figures/release_guide_run_build_workflow.png. - Use the drop-down menu to choose the branch or tag you want to release from.; This should be called ``qutip-4.5.X`` or similar, depending on what you made earlier.; This must *never* be ``master``.; - To make the release to PyPI, type the branch name (e.g. ``qutip-4.5.X``) into the ""Confirm chosen branch name [...]"" field.; You *may* leave this field blank to skip the deployment and only build the package.; - (Special circumstances) If for some reason you need to override the version number (for example if the previous deployment to PyPI only partially succeeded), you can type a valid Python version identifier into the ""Override version number"" field.; You probably do not need to do this.; The mechanism is designed to make alpha-testing major upgrades with nightly releases easier.; For even a bugfix release, you should commit the change to the ``VERSION`` file.; - Click the lower ""Run workflow"" to perform the build and deployment. At this point, the deployment will take care of itself.; It should take between 30 minutes a",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:13531,Availability,avail,available,13531,"ease from.; This should be called ``qutip-4.5.X`` or similar, depending on what you made earlier.; This must *never* be ``master``.; - To make the release to PyPI, type the branch name (e.g. ``qutip-4.5.X``) into the ""Confirm chosen branch name [...]"" field.; You *may* leave this field blank to skip the deployment and only build the package.; - (Special circumstances) If for some reason you need to override the version number (for example if the previous deployment to PyPI only partially succeeded), you can type a valid Python version identifier into the ""Override version number"" field.; You probably do not need to do this.; The mechanism is designed to make alpha-testing major upgrades with nightly releases easier.; For even a bugfix release, you should commit the change to the ``VERSION`` file.; - Click the lower ""Run workflow"" to perform the build and deployment. At this point, the deployment will take care of itself.; It should take between 30 minutes and an hour, after which the new version will be available for install by ``pip install qutip``.; You should see the new version appear on `QuTiP's PyPI page <https://pypi.org/project/qutip>`_. Download Built Files; --------------------. When the build is complete, click into its summary screen.; This is the main screen used to both monitor the build and see its output, and should look like the below image on a success. .. image:: ../figures/release_guide_after_workflow.png. The built binary wheels and the source distribution are the ""build artifacts"" at the bottom.; You need to download both the wheels and the source distribution.; Save them on your computer, and unzip both files; you should have many wheel ``qutip-*.whl`` files, and two sdist files: ``qutip-*.tar.gz`` and ``qutip-*.zip``.; These are the same files that have just been uploaded to PyPI. Monitoring Progress (optional); ------------------------------. While the build is in progress, you can monitor its progress by clicking on its entry in the list be",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:14068,Availability,down,download,14068,"ion number"" field.; You probably do not need to do this.; The mechanism is designed to make alpha-testing major upgrades with nightly releases easier.; For even a bugfix release, you should commit the change to the ``VERSION`` file.; - Click the lower ""Run workflow"" to perform the build and deployment. At this point, the deployment will take care of itself.; It should take between 30 minutes and an hour, after which the new version will be available for install by ``pip install qutip``.; You should see the new version appear on `QuTiP's PyPI page <https://pypi.org/project/qutip>`_. Download Built Files; --------------------. When the build is complete, click into its summary screen.; This is the main screen used to both monitor the build and see its output, and should look like the below image on a success. .. image:: ../figures/release_guide_after_workflow.png. The built binary wheels and the source distribution are the ""build artifacts"" at the bottom.; You need to download both the wheels and the source distribution.; Save them on your computer, and unzip both files; you should have many wheel ``qutip-*.whl`` files, and two sdist files: ``qutip-*.tar.gz`` and ``qutip-*.zip``.; These are the same files that have just been uploaded to PyPI. Monitoring Progress (optional); ------------------------------. While the build is in progress, you can monitor its progress by clicking on its entry in the list below the ""Run workflow"" button.; You should see several subjobs, like the completed screen, except they might not yet be completed. The ""Verify PyPI deployment confirmation"" should get ticked, no matter what.; If it fails, you have forgotten to choose the correct branch in the drop-down menu or you made a typo when confirming the correct branch, and you will need to restart this step.; You can check that the deployment instruction has been understood by clicking the ""Verify PyPI deployment confirmation"" job, and opening the ""Compare confirmation to current reference"" sub",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:14794,Availability,down,down,14794," to both monitor the build and see its output, and should look like the below image on a success. .. image:: ../figures/release_guide_after_workflow.png. The built binary wheels and the source distribution are the ""build artifacts"" at the bottom.; You need to download both the wheels and the source distribution.; Save them on your computer, and unzip both files; you should have many wheel ``qutip-*.whl`` files, and two sdist files: ``qutip-*.tar.gz`` and ``qutip-*.zip``.; These are the same files that have just been uploaded to PyPI. Monitoring Progress (optional); ------------------------------. While the build is in progress, you can monitor its progress by clicking on its entry in the list below the ""Run workflow"" button.; You should see several subjobs, like the completed screen, except they might not yet be completed. The ""Verify PyPI deployment confirmation"" should get ticked, no matter what.; If it fails, you have forgotten to choose the correct branch in the drop-down menu or you made a typo when confirming the correct branch, and you will need to restart this step.; You can check that the deployment instruction has been understood by clicking the ""Verify PyPI deployment confirmation"" job, and opening the ""Compare confirmation to current reference"" subjob.; You will see a message saying ""Built wheels will be deployed"" if you typed in the confirmation, or ""Only building wheels"" if you did not.; If you see ""Only building wheels"" but you meant to deploy the release to PyPI, you can cancel the workflow and re-run it after typing the confirmation. .. _github:. Making a Release on GitHub; ++++++++++++++++++++++++++. This is all done through `the ""Releases"" section <https://github.com/qutip/qutip/releases>`_ of the ``qutip/qutip`` repository on GitHub. - Click the ""Draft a new release"" button.; - Choose the correct branch for your release (e.g. ``qutip-4.5.X``) in the drop-down.; - For the tag name, use ``v<your-version>``, where the version matches the contents of ",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:15715,Availability,down,down,15715,"tter what.; If it fails, you have forgotten to choose the correct branch in the drop-down menu or you made a typo when confirming the correct branch, and you will need to restart this step.; You can check that the deployment instruction has been understood by clicking the ""Verify PyPI deployment confirmation"" job, and opening the ""Compare confirmation to current reference"" subjob.; You will see a message saying ""Built wheels will be deployed"" if you typed in the confirmation, or ""Only building wheels"" if you did not.; If you see ""Only building wheels"" but you meant to deploy the release to PyPI, you can cancel the workflow and re-run it after typing the confirmation. .. _github:. Making a Release on GitHub; ++++++++++++++++++++++++++. This is all done through `the ""Releases"" section <https://github.com/qutip/qutip/releases>`_ of the ``qutip/qutip`` repository on GitHub. - Click the ""Draft a new release"" button.; - Choose the correct branch for your release (e.g. ``qutip-4.5.X``) in the drop-down.; - For the tag name, use ``v<your-version>``, where the version matches the contents of the ``VERSION`` file.; In other words, if you are releasing a micro version 4.5.3, use ``v4.5.3`` as the tag, or if you are releasing major version 5.0.0, use ``v5.0.0``.; - The title is ""QuTiP <your-version>"", e.g. ""QuTiP 4.6.0"".; - For the description, write a short (~two-line for a patch release) summary of the reason for this release, and note down any particular user-facing changes that need special attention.; Underneath, put the changelog you wrote when you did the documentation release.; Note that there may be some syntax differences between the ``.rst`` file of the changelog and the Markdown of this description field (for example, GitHub's markdown typically maintains hard-wrap linebreaks, which is probably not what you wanted).; - Drag-and-drop all the ``qutip-*.whl``, ``qutip-*.tar.gz`` and ``qutip-*.zip`` files you got after the build step into the assets box.; You may need t",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:16159,Availability,down,down,16159,"eels will be deployed"" if you typed in the confirmation, or ""Only building wheels"" if you did not.; If you see ""Only building wheels"" but you meant to deploy the release to PyPI, you can cancel the workflow and re-run it after typing the confirmation. .. _github:. Making a Release on GitHub; ++++++++++++++++++++++++++. This is all done through `the ""Releases"" section <https://github.com/qutip/qutip/releases>`_ of the ``qutip/qutip`` repository on GitHub. - Click the ""Draft a new release"" button.; - Choose the correct branch for your release (e.g. ``qutip-4.5.X``) in the drop-down.; - For the tag name, use ``v<your-version>``, where the version matches the contents of the ``VERSION`` file.; In other words, if you are releasing a micro version 4.5.3, use ``v4.5.3`` as the tag, or if you are releasing major version 5.0.0, use ``v5.0.0``.; - The title is ""QuTiP <your-version>"", e.g. ""QuTiP 4.6.0"".; - For the description, write a short (~two-line for a patch release) summary of the reason for this release, and note down any particular user-facing changes that need special attention.; Underneath, put the changelog you wrote when you did the documentation release.; Note that there may be some syntax differences between the ``.rst`` file of the changelog and the Markdown of this description field (for example, GitHub's markdown typically maintains hard-wrap linebreaks, which is probably not what you wanted).; - Drag-and-drop all the ``qutip-*.whl``, ``qutip-*.tar.gz`` and ``qutip-*.zip`` files you got after the build step into the assets box.; You may need to unzip the files ``wheels.zip`` and ``sdist.zip`` to find them if you haven't already; **don't** upload those two zip files. Click on the ""Publish release"" button to finalise. .. _web:. Website; +++++++. This assumes that qutip.github.io has already been forked and familiarity with the website updating workflow.; The documentation need not be updated for every patch release. HTML File Updates; -----------------. - Edit ",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:17135,Availability,down,download,17135,"r this release, and note down any particular user-facing changes that need special attention.; Underneath, put the changelog you wrote when you did the documentation release.; Note that there may be some syntax differences between the ``.rst`` file of the changelog and the Markdown of this description field (for example, GitHub's markdown typically maintains hard-wrap linebreaks, which is probably not what you wanted).; - Drag-and-drop all the ``qutip-*.whl``, ``qutip-*.tar.gz`` and ``qutip-*.zip`` files you got after the build step into the assets box.; You may need to unzip the files ``wheels.zip`` and ``sdist.zip`` to find them if you haven't already; **don't** upload those two zip files. Click on the ""Publish release"" button to finalise. .. _web:. Website; +++++++. This assumes that qutip.github.io has already been forked and familiarity with the website updating workflow.; The documentation need not be updated for every patch release. HTML File Updates; -----------------. - Edit ``download.html``. * The 'Latest release' version and date should be updated.; * The tar.gz and zip links need to have their micro release numbers updated in their filenames, labels and trackEvent javascript.; These links should point to the ""Source code"" links that appeared when you made in the GitHub Releases section.; They should look something like ``https://github.com/qutip/qutip/archive/refs/tags/v4.6.0.tar.gz``.; * For a minor or major release links to the last micro release of the previous version will need to be moved (copied) to the 'Previous releases' section. - Edit ``_includes/sidebar.html``. * Add the new version and release date. Only actively developed version should be listed. Micro replace the previous entry but the last major can be kept.; * Link to the installation instruction, documentation, source code and changelog should be updated. - Edit ``documentation.html``. * For major and minor release, the previous release tags should be moved (copied) to the 'Previous rel",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:18632,Availability,down,downloaded,18632,"need to be moved (copied) to the 'Previous releases' section. - Edit ``_includes/sidebar.html``. * Add the new version and release date. Only actively developed version should be listed. Micro replace the previous entry but the last major can be kept.; * Link to the installation instruction, documentation, source code and changelog should be updated. - Edit ``documentation.html``. * For major and minor release, the previous release tags should be moved (copied) to the 'Previous releases' section and the links to the readthedocs of the new version added the to 'Latest releases' section. .. _cforge:. Conda Forge; +++++++++++. If not done previously then fork the `qutip-feedstock <https://github.com/conda-forge/qutip-feedstock>`_. Checkout a new branch on your fork, e.g. ::. $ git checkout -b version-4.0.2. Find the sha256 checksum for the tarball that the GitHub web interface generated when you produced the release called ""Source code"".; This is *not* the sdist that you downloaded earlier, it's a new file that GitHub labels ""Source code"".; When you download it, though, it will have a name that *looks* like it's the sdist ::. $ openssl sha256 qutip-4.0.2.tar.gz. Edit the ``recipe/meta.yaml`` file.; Change the version at the top of the file, and update the sha256 checksum.; Check that the recipe package version requirements at least match those in ``setup.cfg``, and that any changes to the build process are reflected in ``meta.yml``.; Also ensure that the build number is reset ::. build:; number: 0. Push changes to your fork, e.g. ::. $ git push --set-upstream origin version-4.0.2. Make a Pull Request.; This will trigger tests of the package build process. If (when) the tests pass, the PR can be merged, which will trigger the upload of the packages to the conda-forge channel.; To test the packages, add the conda-forge channel with lowest priority ::. $ conda config --append channels conda-forge. This should mean that the prerequistes come from the default channel, but t",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:18712,Availability,down,download,18712,"leases' section. - Edit ``_includes/sidebar.html``. * Add the new version and release date. Only actively developed version should be listed. Micro replace the previous entry but the last major can be kept.; * Link to the installation instruction, documentation, source code and changelog should be updated. - Edit ``documentation.html``. * For major and minor release, the previous release tags should be moved (copied) to the 'Previous releases' section and the links to the readthedocs of the new version added the to 'Latest releases' section. .. _cforge:. Conda Forge; +++++++++++. If not done previously then fork the `qutip-feedstock <https://github.com/conda-forge/qutip-feedstock>`_. Checkout a new branch on your fork, e.g. ::. $ git checkout -b version-4.0.2. Find the sha256 checksum for the tarball that the GitHub web interface generated when you produced the release called ""Source code"".; This is *not* the sdist that you downloaded earlier, it's a new file that GitHub labels ""Source code"".; When you download it, though, it will have a name that *looks* like it's the sdist ::. $ openssl sha256 qutip-4.0.2.tar.gz. Edit the ``recipe/meta.yaml`` file.; Change the version at the top of the file, and update the sha256 checksum.; Check that the recipe package version requirements at least match those in ``setup.cfg``, and that any changes to the build process are reflected in ``meta.yml``.; Also ensure that the build number is reset ::. build:; number: 0. Push changes to your fork, e.g. ::. $ git push --set-upstream origin version-4.0.2. Make a Pull Request.; This will trigger tests of the package build process. If (when) the tests pass, the PR can be merged, which will trigger the upload of the packages to the conda-forge channel.; To test the packages, add the conda-forge channel with lowest priority ::. $ conda config --append channels conda-forge. This should mean that the prerequistes come from the default channel, but the qutip packages are found in conda-forge.; ",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:255,Deployability,update,updates,255,".. This file was created using retext 6.1 https://github.com/retext-project/retext. .. _release_distribution:. ************************; Release and Distribution; ************************. Preamble; ++++++++. This document covers the process for managing updates to the current minor release and making new releases.; Within this document, the git remote ``upstream`` refers to the main QuTiP organsiation repository, and ``origin`` refers to your personal fork. In short, the steps you need to take are:. 1. Prepare the release branch (see git_).; 2. Run the ""Build wheels, optionally deploy to PyPI"" GitHub action to build binary and source packages and upload them to PyPI (see deploy_).; 3. Create a GitHub release and uploaded the built files to it (see github_).; 4. Update `qutip.org <https://qutip.org/>`_ with the new links and documentation (web_).; 5. Update the conda feedstock, deploying the package to ``conda`` (cforge_). .. _git:. Setting Up The Release Branch; +++++++++++++++++++++++++++++. In this step you will prepare a git branch on the main QuTiP repository that has the state of the code that is going to be released.; This procedure is quite different if you are releasing a new minor or major version compared to if you are making a bugfix patch release.; For a new minor or major version, do update-changelog_ and then jump to release_.; For a bug fix to an existing release, do update-changelog_ and then jump to bugfix_. Changes that are not backwards-compatible may only be made in a major release.; New features that do not affect backwards-compatibility can be made in a minor release.; Bug fix releases should be small, only fix bugs, and not introduce any new features. There are a few steps that *should* have been kept up-to-date during day-to-day development, but might not be quite accurate.; For every change that is going to be part of your release, make sure that:. - The user guide in the documentation is updated with any new features, or changes to existing",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:284,Deployability,release,release,284,".. This file was created using retext 6.1 https://github.com/retext-project/retext. .. _release_distribution:. ************************; Release and Distribution; ************************. Preamble; ++++++++. This document covers the process for managing updates to the current minor release and making new releases.; Within this document, the git remote ``upstream`` refers to the main QuTiP organsiation repository, and ``origin`` refers to your personal fork. In short, the steps you need to take are:. 1. Prepare the release branch (see git_).; 2. Run the ""Build wheels, optionally deploy to PyPI"" GitHub action to build binary and source packages and upload them to PyPI (see deploy_).; 3. Create a GitHub release and uploaded the built files to it (see github_).; 4. Update `qutip.org <https://qutip.org/>`_ with the new links and documentation (web_).; 5. Update the conda feedstock, deploying the package to ``conda`` (cforge_). .. _git:. Setting Up The Release Branch; +++++++++++++++++++++++++++++. In this step you will prepare a git branch on the main QuTiP repository that has the state of the code that is going to be released.; This procedure is quite different if you are releasing a new minor or major version compared to if you are making a bugfix patch release.; For a new minor or major version, do update-changelog_ and then jump to release_.; For a bug fix to an existing release, do update-changelog_ and then jump to bugfix_. Changes that are not backwards-compatible may only be made in a major release.; New features that do not affect backwards-compatibility can be made in a minor release.; Bug fix releases should be small, only fix bugs, and not introduce any new features. There are a few steps that *should* have been kept up-to-date during day-to-day development, but might not be quite accurate.; For every change that is going to be part of your release, make sure that:. - The user guide in the documentation is updated with any new features, or changes to existing",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:307,Deployability,release,releases,307,".. This file was created using retext 6.1 https://github.com/retext-project/retext. .. _release_distribution:. ************************; Release and Distribution; ************************. Preamble; ++++++++. This document covers the process for managing updates to the current minor release and making new releases.; Within this document, the git remote ``upstream`` refers to the main QuTiP organsiation repository, and ``origin`` refers to your personal fork. In short, the steps you need to take are:. 1. Prepare the release branch (see git_).; 2. Run the ""Build wheels, optionally deploy to PyPI"" GitHub action to build binary and source packages and upload them to PyPI (see deploy_).; 3. Create a GitHub release and uploaded the built files to it (see github_).; 4. Update `qutip.org <https://qutip.org/>`_ with the new links and documentation (web_).; 5. Update the conda feedstock, deploying the package to ``conda`` (cforge_). .. _git:. Setting Up The Release Branch; +++++++++++++++++++++++++++++. In this step you will prepare a git branch on the main QuTiP repository that has the state of the code that is going to be released.; This procedure is quite different if you are releasing a new minor or major version compared to if you are making a bugfix patch release.; For a new minor or major version, do update-changelog_ and then jump to release_.; For a bug fix to an existing release, do update-changelog_ and then jump to bugfix_. Changes that are not backwards-compatible may only be made in a major release.; New features that do not affect backwards-compatibility can be made in a minor release.; Bug fix releases should be small, only fix bugs, and not introduce any new features. There are a few steps that *should* have been kept up-to-date during day-to-day development, but might not be quite accurate.; For every change that is going to be part of your release, make sure that:. - The user guide in the documentation is updated with any new features, or changes to existing",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:521,Deployability,release,release,521,".. This file was created using retext 6.1 https://github.com/retext-project/retext. .. _release_distribution:. ************************; Release and Distribution; ************************. Preamble; ++++++++. This document covers the process for managing updates to the current minor release and making new releases.; Within this document, the git remote ``upstream`` refers to the main QuTiP organsiation repository, and ``origin`` refers to your personal fork. In short, the steps you need to take are:. 1. Prepare the release branch (see git_).; 2. Run the ""Build wheels, optionally deploy to PyPI"" GitHub action to build binary and source packages and upload them to PyPI (see deploy_).; 3. Create a GitHub release and uploaded the built files to it (see github_).; 4. Update `qutip.org <https://qutip.org/>`_ with the new links and documentation (web_).; 5. Update the conda feedstock, deploying the package to ``conda`` (cforge_). .. _git:. Setting Up The Release Branch; +++++++++++++++++++++++++++++. In this step you will prepare a git branch on the main QuTiP repository that has the state of the code that is going to be released.; This procedure is quite different if you are releasing a new minor or major version compared to if you are making a bugfix patch release.; For a new minor or major version, do update-changelog_ and then jump to release_.; For a bug fix to an existing release, do update-changelog_ and then jump to bugfix_. Changes that are not backwards-compatible may only be made in a major release.; New features that do not affect backwards-compatibility can be made in a minor release.; Bug fix releases should be small, only fix bugs, and not introduce any new features. There are a few steps that *should* have been kept up-to-date during day-to-day development, but might not be quite accurate.; For every change that is going to be part of your release, make sure that:. - The user guide in the documentation is updated with any new features, or changes to existing",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:586,Deployability,deploy,deploy,586,".. This file was created using retext 6.1 https://github.com/retext-project/retext. .. _release_distribution:. ************************; Release and Distribution; ************************. Preamble; ++++++++. This document covers the process for managing updates to the current minor release and making new releases.; Within this document, the git remote ``upstream`` refers to the main QuTiP organsiation repository, and ``origin`` refers to your personal fork. In short, the steps you need to take are:. 1. Prepare the release branch (see git_).; 2. Run the ""Build wheels, optionally deploy to PyPI"" GitHub action to build binary and source packages and upload them to PyPI (see deploy_).; 3. Create a GitHub release and uploaded the built files to it (see github_).; 4. Update `qutip.org <https://qutip.org/>`_ with the new links and documentation (web_).; 5. Update the conda feedstock, deploying the package to ``conda`` (cforge_). .. _git:. Setting Up The Release Branch; +++++++++++++++++++++++++++++. In this step you will prepare a git branch on the main QuTiP repository that has the state of the code that is going to be released.; This procedure is quite different if you are releasing a new minor or major version compared to if you are making a bugfix patch release.; For a new minor or major version, do update-changelog_ and then jump to release_.; For a bug fix to an existing release, do update-changelog_ and then jump to bugfix_. Changes that are not backwards-compatible may only be made in a major release.; New features that do not affect backwards-compatibility can be made in a minor release.; Bug fix releases should be small, only fix bugs, and not introduce any new features. There are a few steps that *should* have been kept up-to-date during day-to-day development, but might not be quite accurate.; For every change that is going to be part of your release, make sure that:. - The user guide in the documentation is updated with any new features, or changes to existing",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:711,Deployability,release,release,711,".. This file was created using retext 6.1 https://github.com/retext-project/retext. .. _release_distribution:. ************************; Release and Distribution; ************************. Preamble; ++++++++. This document covers the process for managing updates to the current minor release and making new releases.; Within this document, the git remote ``upstream`` refers to the main QuTiP organsiation repository, and ``origin`` refers to your personal fork. In short, the steps you need to take are:. 1. Prepare the release branch (see git_).; 2. Run the ""Build wheels, optionally deploy to PyPI"" GitHub action to build binary and source packages and upload them to PyPI (see deploy_).; 3. Create a GitHub release and uploaded the built files to it (see github_).; 4. Update `qutip.org <https://qutip.org/>`_ with the new links and documentation (web_).; 5. Update the conda feedstock, deploying the package to ``conda`` (cforge_). .. _git:. Setting Up The Release Branch; +++++++++++++++++++++++++++++. In this step you will prepare a git branch on the main QuTiP repository that has the state of the code that is going to be released.; This procedure is quite different if you are releasing a new minor or major version compared to if you are making a bugfix patch release.; For a new minor or major version, do update-changelog_ and then jump to release_.; For a bug fix to an existing release, do update-changelog_ and then jump to bugfix_. Changes that are not backwards-compatible may only be made in a major release.; New features that do not affect backwards-compatibility can be made in a minor release.; Bug fix releases should be small, only fix bugs, and not introduce any new features. There are a few steps that *should* have been kept up-to-date during day-to-day development, but might not be quite accurate.; For every change that is going to be part of your release, make sure that:. - The user guide in the documentation is updated with any new features, or changes to existing",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:891,Deployability,deploy,deploying,891,".. This file was created using retext 6.1 https://github.com/retext-project/retext. .. _release_distribution:. ************************; Release and Distribution; ************************. Preamble; ++++++++. This document covers the process for managing updates to the current minor release and making new releases.; Within this document, the git remote ``upstream`` refers to the main QuTiP organsiation repository, and ``origin`` refers to your personal fork. In short, the steps you need to take are:. 1. Prepare the release branch (see git_).; 2. Run the ""Build wheels, optionally deploy to PyPI"" GitHub action to build binary and source packages and upload them to PyPI (see deploy_).; 3. Create a GitHub release and uploaded the built files to it (see github_).; 4. Update `qutip.org <https://qutip.org/>`_ with the new links and documentation (web_).; 5. Update the conda feedstock, deploying the package to ``conda`` (cforge_). .. _git:. Setting Up The Release Branch; +++++++++++++++++++++++++++++. In this step you will prepare a git branch on the main QuTiP repository that has the state of the code that is going to be released.; This procedure is quite different if you are releasing a new minor or major version compared to if you are making a bugfix patch release.; For a new minor or major version, do update-changelog_ and then jump to release_.; For a bug fix to an existing release, do update-changelog_ and then jump to bugfix_. Changes that are not backwards-compatible may only be made in a major release.; New features that do not affect backwards-compatibility can be made in a minor release.; Bug fix releases should be small, only fix bugs, and not introduce any new features. There are a few steps that *should* have been kept up-to-date during day-to-day development, but might not be quite accurate.; For every change that is going to be part of your release, make sure that:. - The user guide in the documentation is updated with any new features, or changes to existing",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:1132,Deployability,release,released,1132,"t/retext. .. _release_distribution:. ************************; Release and Distribution; ************************. Preamble; ++++++++. This document covers the process for managing updates to the current minor release and making new releases.; Within this document, the git remote ``upstream`` refers to the main QuTiP organsiation repository, and ``origin`` refers to your personal fork. In short, the steps you need to take are:. 1. Prepare the release branch (see git_).; 2. Run the ""Build wheels, optionally deploy to PyPI"" GitHub action to build binary and source packages and upload them to PyPI (see deploy_).; 3. Create a GitHub release and uploaded the built files to it (see github_).; 4. Update `qutip.org <https://qutip.org/>`_ with the new links and documentation (web_).; 5. Update the conda feedstock, deploying the package to ``conda`` (cforge_). .. _git:. Setting Up The Release Branch; +++++++++++++++++++++++++++++. In this step you will prepare a git branch on the main QuTiP repository that has the state of the code that is going to be released.; This procedure is quite different if you are releasing a new minor or major version compared to if you are making a bugfix patch release.; For a new minor or major version, do update-changelog_ and then jump to release_.; For a bug fix to an existing release, do update-changelog_ and then jump to bugfix_. Changes that are not backwards-compatible may only be made in a major release.; New features that do not affect backwards-compatibility can be made in a minor release.; Bug fix releases should be small, only fix bugs, and not introduce any new features. There are a few steps that *should* have been kept up-to-date during day-to-day development, but might not be quite accurate.; For every change that is going to be part of your release, make sure that:. - The user guide in the documentation is updated with any new features, or changes to existing features.; - Any new API classes or functions have entries in a suitable ",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:1266,Deployability,patch,patch,1266,"his document covers the process for managing updates to the current minor release and making new releases.; Within this document, the git remote ``upstream`` refers to the main QuTiP organsiation repository, and ``origin`` refers to your personal fork. In short, the steps you need to take are:. 1. Prepare the release branch (see git_).; 2. Run the ""Build wheels, optionally deploy to PyPI"" GitHub action to build binary and source packages and upload them to PyPI (see deploy_).; 3. Create a GitHub release and uploaded the built files to it (see github_).; 4. Update `qutip.org <https://qutip.org/>`_ with the new links and documentation (web_).; 5. Update the conda feedstock, deploying the package to ``conda`` (cforge_). .. _git:. Setting Up The Release Branch; +++++++++++++++++++++++++++++. In this step you will prepare a git branch on the main QuTiP repository that has the state of the code that is going to be released.; This procedure is quite different if you are releasing a new minor or major version compared to if you are making a bugfix patch release.; For a new minor or major version, do update-changelog_ and then jump to release_.; For a bug fix to an existing release, do update-changelog_ and then jump to bugfix_. Changes that are not backwards-compatible may only be made in a major release.; New features that do not affect backwards-compatibility can be made in a minor release.; Bug fix releases should be small, only fix bugs, and not introduce any new features. There are a few steps that *should* have been kept up-to-date during day-to-day development, but might not be quite accurate.; For every change that is going to be part of your release, make sure that:. - The user guide in the documentation is updated with any new features, or changes to existing features.; - Any new API classes or functions have entries in a suitable RST file in ``doc/apidoc``.; - Any new or changed docstrings are up-to-date and render correctly in the API documentation. Please make a",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:1272,Deployability,release,release,1272,"his document covers the process for managing updates to the current minor release and making new releases.; Within this document, the git remote ``upstream`` refers to the main QuTiP organsiation repository, and ``origin`` refers to your personal fork. In short, the steps you need to take are:. 1. Prepare the release branch (see git_).; 2. Run the ""Build wheels, optionally deploy to PyPI"" GitHub action to build binary and source packages and upload them to PyPI (see deploy_).; 3. Create a GitHub release and uploaded the built files to it (see github_).; 4. Update `qutip.org <https://qutip.org/>`_ with the new links and documentation (web_).; 5. Update the conda feedstock, deploying the package to ``conda`` (cforge_). .. _git:. Setting Up The Release Branch; +++++++++++++++++++++++++++++. In this step you will prepare a git branch on the main QuTiP repository that has the state of the code that is going to be released.; This procedure is quite different if you are releasing a new minor or major version compared to if you are making a bugfix patch release.; For a new minor or major version, do update-changelog_ and then jump to release_.; For a bug fix to an existing release, do update-changelog_ and then jump to bugfix_. Changes that are not backwards-compatible may only be made in a major release.; New features that do not affect backwards-compatibility can be made in a minor release.; Bug fix releases should be small, only fix bugs, and not introduce any new features. There are a few steps that *should* have been kept up-to-date during day-to-day development, but might not be quite accurate.; For every change that is going to be part of your release, make sure that:. - The user guide in the documentation is updated with any new features, or changes to existing features.; - Any new API classes or functions have entries in a suitable RST file in ``doc/apidoc``.; - Any new or changed docstrings are up-to-date and render correctly in the API documentation. Please make a",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:1319,Deployability,update,update-,1319,"hin this document, the git remote ``upstream`` refers to the main QuTiP organsiation repository, and ``origin`` refers to your personal fork. In short, the steps you need to take are:. 1. Prepare the release branch (see git_).; 2. Run the ""Build wheels, optionally deploy to PyPI"" GitHub action to build binary and source packages and upload them to PyPI (see deploy_).; 3. Create a GitHub release and uploaded the built files to it (see github_).; 4. Update `qutip.org <https://qutip.org/>`_ with the new links and documentation (web_).; 5. Update the conda feedstock, deploying the package to ``conda`` (cforge_). .. _git:. Setting Up The Release Branch; +++++++++++++++++++++++++++++. In this step you will prepare a git branch on the main QuTiP repository that has the state of the code that is going to be released.; This procedure is quite different if you are releasing a new minor or major version compared to if you are making a bugfix patch release.; For a new minor or major version, do update-changelog_ and then jump to release_.; For a bug fix to an existing release, do update-changelog_ and then jump to bugfix_. Changes that are not backwards-compatible may only be made in a major release.; New features that do not affect backwards-compatibility can be made in a minor release.; Bug fix releases should be small, only fix bugs, and not introduce any new features. There are a few steps that *should* have been kept up-to-date during day-to-day development, but might not be quite accurate.; For every change that is going to be part of your release, make sure that:. - The user guide in the documentation is updated with any new features, or changes to existing features.; - Any new API classes or functions have entries in a suitable RST file in ``doc/apidoc``.; - Any new or changed docstrings are up-to-date and render correctly in the API documentation. Please make a normal PR to ``master`` correcting anything missing from these points and have it merged before you begin the ",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:1394,Deployability,release,release,1394,"repository, and ``origin`` refers to your personal fork. In short, the steps you need to take are:. 1. Prepare the release branch (see git_).; 2. Run the ""Build wheels, optionally deploy to PyPI"" GitHub action to build binary and source packages and upload them to PyPI (see deploy_).; 3. Create a GitHub release and uploaded the built files to it (see github_).; 4. Update `qutip.org <https://qutip.org/>`_ with the new links and documentation (web_).; 5. Update the conda feedstock, deploying the package to ``conda`` (cforge_). .. _git:. Setting Up The Release Branch; +++++++++++++++++++++++++++++. In this step you will prepare a git branch on the main QuTiP repository that has the state of the code that is going to be released.; This procedure is quite different if you are releasing a new minor or major version compared to if you are making a bugfix patch release.; For a new minor or major version, do update-changelog_ and then jump to release_.; For a bug fix to an existing release, do update-changelog_ and then jump to bugfix_. Changes that are not backwards-compatible may only be made in a major release.; New features that do not affect backwards-compatibility can be made in a minor release.; Bug fix releases should be small, only fix bugs, and not introduce any new features. There are a few steps that *should* have been kept up-to-date during day-to-day development, but might not be quite accurate.; For every change that is going to be part of your release, make sure that:. - The user guide in the documentation is updated with any new features, or changes to existing features.; - Any new API classes or functions have entries in a suitable RST file in ``doc/apidoc``.; - Any new or changed docstrings are up-to-date and render correctly in the API documentation. Please make a normal PR to ``master`` correcting anything missing from these points and have it merged before you begin the release, if necessary. .. _update-requirement:. Updating the Requirements; ---------",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:1406,Deployability,update,update-,1406,"repository, and ``origin`` refers to your personal fork. In short, the steps you need to take are:. 1. Prepare the release branch (see git_).; 2. Run the ""Build wheels, optionally deploy to PyPI"" GitHub action to build binary and source packages and upload them to PyPI (see deploy_).; 3. Create a GitHub release and uploaded the built files to it (see github_).; 4. Update `qutip.org <https://qutip.org/>`_ with the new links and documentation (web_).; 5. Update the conda feedstock, deploying the package to ``conda`` (cforge_). .. _git:. Setting Up The Release Branch; +++++++++++++++++++++++++++++. In this step you will prepare a git branch on the main QuTiP repository that has the state of the code that is going to be released.; This procedure is quite different if you are releasing a new minor or major version compared to if you are making a bugfix patch release.; For a new minor or major version, do update-changelog_ and then jump to release_.; For a bug fix to an existing release, do update-changelog_ and then jump to bugfix_. Changes that are not backwards-compatible may only be made in a major release.; New features that do not affect backwards-compatibility can be made in a minor release.; Bug fix releases should be small, only fix bugs, and not introduce any new features. There are a few steps that *should* have been kept up-to-date during day-to-day development, but might not be quite accurate.; For every change that is going to be part of your release, make sure that:. - The user guide in the documentation is updated with any new features, or changes to existing features.; - Any new API classes or functions have entries in a suitable RST file in ``doc/apidoc``.; - Any new or changed docstrings are up-to-date and render correctly in the API documentation. Please make a normal PR to ``master`` correcting anything missing from these points and have it merged before you begin the release, if necessary. .. _update-requirement:. Updating the Requirements; ---------",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:1520,Deployability,release,release,1520,"eed to take are:. 1. Prepare the release branch (see git_).; 2. Run the ""Build wheels, optionally deploy to PyPI"" GitHub action to build binary and source packages and upload them to PyPI (see deploy_).; 3. Create a GitHub release and uploaded the built files to it (see github_).; 4. Update `qutip.org <https://qutip.org/>`_ with the new links and documentation (web_).; 5. Update the conda feedstock, deploying the package to ``conda`` (cforge_). .. _git:. Setting Up The Release Branch; +++++++++++++++++++++++++++++. In this step you will prepare a git branch on the main QuTiP repository that has the state of the code that is going to be released.; This procedure is quite different if you are releasing a new minor or major version compared to if you are making a bugfix patch release.; For a new minor or major version, do update-changelog_ and then jump to release_.; For a bug fix to an existing release, do update-changelog_ and then jump to bugfix_. Changes that are not backwards-compatible may only be made in a major release.; New features that do not affect backwards-compatibility can be made in a minor release.; Bug fix releases should be small, only fix bugs, and not introduce any new features. There are a few steps that *should* have been kept up-to-date during day-to-day development, but might not be quite accurate.; For every change that is going to be part of your release, make sure that:. - The user guide in the documentation is updated with any new features, or changes to existing features.; - Any new API classes or functions have entries in a suitable RST file in ``doc/apidoc``.; - Any new or changed docstrings are up-to-date and render correctly in the API documentation. Please make a normal PR to ``master`` correcting anything missing from these points and have it merged before you begin the release, if necessary. .. _update-requirement:. Updating the Requirements; -------------------------. Ensure that QuTiP's tests pass on the oldest version supported in",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:1609,Deployability,release,release,1609,"s, optionally deploy to PyPI"" GitHub action to build binary and source packages and upload them to PyPI (see deploy_).; 3. Create a GitHub release and uploaded the built files to it (see github_).; 4. Update `qutip.org <https://qutip.org/>`_ with the new links and documentation (web_).; 5. Update the conda feedstock, deploying the package to ``conda`` (cforge_). .. _git:. Setting Up The Release Branch; +++++++++++++++++++++++++++++. In this step you will prepare a git branch on the main QuTiP repository that has the state of the code that is going to be released.; This procedure is quite different if you are releasing a new minor or major version compared to if you are making a bugfix patch release.; For a new minor or major version, do update-changelog_ and then jump to release_.; For a bug fix to an existing release, do update-changelog_ and then jump to bugfix_. Changes that are not backwards-compatible may only be made in a major release.; New features that do not affect backwards-compatibility can be made in a minor release.; Bug fix releases should be small, only fix bugs, and not introduce any new features. There are a few steps that *should* have been kept up-to-date during day-to-day development, but might not be quite accurate.; For every change that is going to be part of your release, make sure that:. - The user guide in the documentation is updated with any new features, or changes to existing features.; - Any new API classes or functions have entries in a suitable RST file in ``doc/apidoc``.; - Any new or changed docstrings are up-to-date and render correctly in the API documentation. Please make a normal PR to ``master`` correcting anything missing from these points and have it merged before you begin the release, if necessary. .. _update-requirement:. Updating the Requirements; -------------------------. Ensure that QuTiP's tests pass on the oldest version supported in the requirements.; On major and minor version, requirements can be adjusted upwards",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:1627,Deployability,release,releases,1627,"ad them to PyPI (see deploy_).; 3. Create a GitHub release and uploaded the built files to it (see github_).; 4. Update `qutip.org <https://qutip.org/>`_ with the new links and documentation (web_).; 5. Update the conda feedstock, deploying the package to ``conda`` (cforge_). .. _git:. Setting Up The Release Branch; +++++++++++++++++++++++++++++. In this step you will prepare a git branch on the main QuTiP repository that has the state of the code that is going to be released.; This procedure is quite different if you are releasing a new minor or major version compared to if you are making a bugfix patch release.; For a new minor or major version, do update-changelog_ and then jump to release_.; For a bug fix to an existing release, do update-changelog_ and then jump to bugfix_. Changes that are not backwards-compatible may only be made in a major release.; New features that do not affect backwards-compatibility can be made in a minor release.; Bug fix releases should be small, only fix bugs, and not introduce any new features. There are a few steps that *should* have been kept up-to-date during day-to-day development, but might not be quite accurate.; For every change that is going to be part of your release, make sure that:. - The user guide in the documentation is updated with any new features, or changes to existing features.; - Any new API classes or functions have entries in a suitable RST file in ``doc/apidoc``.; - Any new or changed docstrings are up-to-date and render correctly in the API documentation. Please make a normal PR to ``master`` correcting anything missing from these points and have it merged before you begin the release, if necessary. .. _update-requirement:. Updating the Requirements; -------------------------. Ensure that QuTiP's tests pass on the oldest version supported in the requirements.; On major and minor version, requirements can be adjusted upwards, but patch release must not change minimum requirements.; We follow `NEP29`_ for minim",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:1881,Deployability,release,release,1881,"te the conda feedstock, deploying the package to ``conda`` (cforge_). .. _git:. Setting Up The Release Branch; +++++++++++++++++++++++++++++. In this step you will prepare a git branch on the main QuTiP repository that has the state of the code that is going to be released.; This procedure is quite different if you are releasing a new minor or major version compared to if you are making a bugfix patch release.; For a new minor or major version, do update-changelog_ and then jump to release_.; For a bug fix to an existing release, do update-changelog_ and then jump to bugfix_. Changes that are not backwards-compatible may only be made in a major release.; New features that do not affect backwards-compatibility can be made in a minor release.; Bug fix releases should be small, only fix bugs, and not introduce any new features. There are a few steps that *should* have been kept up-to-date during day-to-day development, but might not be quite accurate.; For every change that is going to be part of your release, make sure that:. - The user guide in the documentation is updated with any new features, or changes to existing features.; - Any new API classes or functions have entries in a suitable RST file in ``doc/apidoc``.; - Any new or changed docstrings are up-to-date and render correctly in the API documentation. Please make a normal PR to ``master`` correcting anything missing from these points and have it merged before you begin the release, if necessary. .. _update-requirement:. Updating the Requirements; -------------------------. Ensure that QuTiP's tests pass on the oldest version supported in the requirements.; On major and minor version, requirements can be adjusted upwards, but patch release must not change minimum requirements.; We follow `NEP29`_ for minimum supported versions ::. - All minor versions of Python released 42 months prior to the project, and at minimum the two latest minor versions.; - All minor versions of numpy and scipy released in the 24 mont",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:1948,Deployability,update,updated,1948,"The Release Branch; +++++++++++++++++++++++++++++. In this step you will prepare a git branch on the main QuTiP repository that has the state of the code that is going to be released.; This procedure is quite different if you are releasing a new minor or major version compared to if you are making a bugfix patch release.; For a new minor or major version, do update-changelog_ and then jump to release_.; For a bug fix to an existing release, do update-changelog_ and then jump to bugfix_. Changes that are not backwards-compatible may only be made in a major release.; New features that do not affect backwards-compatibility can be made in a minor release.; Bug fix releases should be small, only fix bugs, and not introduce any new features. There are a few steps that *should* have been kept up-to-date during day-to-day development, but might not be quite accurate.; For every change that is going to be part of your release, make sure that:. - The user guide in the documentation is updated with any new features, or changes to existing features.; - Any new API classes or functions have entries in a suitable RST file in ``doc/apidoc``.; - Any new or changed docstrings are up-to-date and render correctly in the API documentation. Please make a normal PR to ``master`` correcting anything missing from these points and have it merged before you begin the release, if necessary. .. _update-requirement:. Updating the Requirements; -------------------------. Ensure that QuTiP's tests pass on the oldest version supported in the requirements.; On major and minor version, requirements can be adjusted upwards, but patch release must not change minimum requirements.; We follow `NEP29`_ for minimum supported versions ::. - All minor versions of Python released 42 months prior to the project, and at minimum the two latest minor versions.; - All minor versions of numpy and scipy released in the 24 months prior to the project, and at minimum the last three minor versions. If dependency versio",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:2322,Deployability,release,release,2322,"h release.; For a new minor or major version, do update-changelog_ and then jump to release_.; For a bug fix to an existing release, do update-changelog_ and then jump to bugfix_. Changes that are not backwards-compatible may only be made in a major release.; New features that do not affect backwards-compatibility can be made in a minor release.; Bug fix releases should be small, only fix bugs, and not introduce any new features. There are a few steps that *should* have been kept up-to-date during day-to-day development, but might not be quite accurate.; For every change that is going to be part of your release, make sure that:. - The user guide in the documentation is updated with any new features, or changes to existing features.; - Any new API classes or functions have entries in a suitable RST file in ``doc/apidoc``.; - Any new or changed docstrings are up-to-date and render correctly in the API documentation. Please make a normal PR to ``master`` correcting anything missing from these points and have it merged before you begin the release, if necessary. .. _update-requirement:. Updating the Requirements; -------------------------. Ensure that QuTiP's tests pass on the oldest version supported in the requirements.; On major and minor version, requirements can be adjusted upwards, but patch release must not change minimum requirements.; We follow `NEP29`_ for minimum supported versions ::. - All minor versions of Python released 42 months prior to the project, and at minimum the two latest minor versions.; - All minor versions of numpy and scipy released in the 24 months prior to the project, and at minimum the last three minor versions. If dependency versions need to be updated, update them in the master branch. The following files may need to be updated: `.github/workflows/tests.yml`, `setup.cfg` and `roadmap.rst`. Finally, ensure that PyPI wheels and conda builds cover at least these versions. .. _NEP29: https://numpy.org/neps/nep-0029-deprecation_policy.html. ",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:2579,Deployability,patch,patch,2579,"rds-compatibility can be made in a minor release.; Bug fix releases should be small, only fix bugs, and not introduce any new features. There are a few steps that *should* have been kept up-to-date during day-to-day development, but might not be quite accurate.; For every change that is going to be part of your release, make sure that:. - The user guide in the documentation is updated with any new features, or changes to existing features.; - Any new API classes or functions have entries in a suitable RST file in ``doc/apidoc``.; - Any new or changed docstrings are up-to-date and render correctly in the API documentation. Please make a normal PR to ``master`` correcting anything missing from these points and have it merged before you begin the release, if necessary. .. _update-requirement:. Updating the Requirements; -------------------------. Ensure that QuTiP's tests pass on the oldest version supported in the requirements.; On major and minor version, requirements can be adjusted upwards, but patch release must not change minimum requirements.; We follow `NEP29`_ for minimum supported versions ::. - All minor versions of Python released 42 months prior to the project, and at minimum the two latest minor versions.; - All minor versions of numpy and scipy released in the 24 months prior to the project, and at minimum the last three minor versions. If dependency versions need to be updated, update them in the master branch. The following files may need to be updated: `.github/workflows/tests.yml`, `setup.cfg` and `roadmap.rst`. Finally, ensure that PyPI wheels and conda builds cover at least these versions. .. _NEP29: https://numpy.org/neps/nep-0029-deprecation_policy.html. .. _update-changelog:. Updating the Changelog; ----------------------. This needs to be done no matter what type of release is being made. #. Create a new branch to use to make a pull request.; #. Update the changelog using ``towncrier``:. towncrier build --version=<version-number>. Where ``<versi",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:2585,Deployability,release,release,2585,"rds-compatibility can be made in a minor release.; Bug fix releases should be small, only fix bugs, and not introduce any new features. There are a few steps that *should* have been kept up-to-date during day-to-day development, but might not be quite accurate.; For every change that is going to be part of your release, make sure that:. - The user guide in the documentation is updated with any new features, or changes to existing features.; - Any new API classes or functions have entries in a suitable RST file in ``doc/apidoc``.; - Any new or changed docstrings are up-to-date and render correctly in the API documentation. Please make a normal PR to ``master`` correcting anything missing from these points and have it merged before you begin the release, if necessary. .. _update-requirement:. Updating the Requirements; -------------------------. Ensure that QuTiP's tests pass on the oldest version supported in the requirements.; On major and minor version, requirements can be adjusted upwards, but patch release must not change minimum requirements.; We follow `NEP29`_ for minimum supported versions ::. - All minor versions of Python released 42 months prior to the project, and at minimum the two latest minor versions.; - All minor versions of numpy and scipy released in the 24 months prior to the project, and at minimum the last three minor versions. If dependency versions need to be updated, update them in the master branch. The following files may need to be updated: `.github/workflows/tests.yml`, `setup.cfg` and `roadmap.rst`. Finally, ensure that PyPI wheels and conda builds cover at least these versions. .. _NEP29: https://numpy.org/neps/nep-0029-deprecation_policy.html. .. _update-changelog:. Updating the Changelog; ----------------------. This needs to be done no matter what type of release is being made. #. Create a new branch to use to make a pull request.; #. Update the changelog using ``towncrier``:. towncrier build --version=<version-number>. Where ``<versi",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:2717,Deployability,release,released,2717," been kept up-to-date during day-to-day development, but might not be quite accurate.; For every change that is going to be part of your release, make sure that:. - The user guide in the documentation is updated with any new features, or changes to existing features.; - Any new API classes or functions have entries in a suitable RST file in ``doc/apidoc``.; - Any new or changed docstrings are up-to-date and render correctly in the API documentation. Please make a normal PR to ``master`` correcting anything missing from these points and have it merged before you begin the release, if necessary. .. _update-requirement:. Updating the Requirements; -------------------------. Ensure that QuTiP's tests pass on the oldest version supported in the requirements.; On major and minor version, requirements can be adjusted upwards, but patch release must not change minimum requirements.; We follow `NEP29`_ for minimum supported versions ::. - All minor versions of Python released 42 months prior to the project, and at minimum the two latest minor versions.; - All minor versions of numpy and scipy released in the 24 months prior to the project, and at minimum the last three minor versions. If dependency versions need to be updated, update them in the master branch. The following files may need to be updated: `.github/workflows/tests.yml`, `setup.cfg` and `roadmap.rst`. Finally, ensure that PyPI wheels and conda builds cover at least these versions. .. _NEP29: https://numpy.org/neps/nep-0029-deprecation_policy.html. .. _update-changelog:. Updating the Changelog; ----------------------. This needs to be done no matter what type of release is being made. #. Create a new branch to use to make a pull request.; #. Update the changelog using ``towncrier``:. towncrier build --version=<version-number>. Where ``<version-number>`` is the expected version number of the release. #. Make a pull request on the main ``qutip/qutip`` repository with this changelog, and get other members of the adm",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:2845,Deployability,release,released,2845,"rt of your release, make sure that:. - The user guide in the documentation is updated with any new features, or changes to existing features.; - Any new API classes or functions have entries in a suitable RST file in ``doc/apidoc``.; - Any new or changed docstrings are up-to-date and render correctly in the API documentation. Please make a normal PR to ``master`` correcting anything missing from these points and have it merged before you begin the release, if necessary. .. _update-requirement:. Updating the Requirements; -------------------------. Ensure that QuTiP's tests pass on the oldest version supported in the requirements.; On major and minor version, requirements can be adjusted upwards, but patch release must not change minimum requirements.; We follow `NEP29`_ for minimum supported versions ::. - All minor versions of Python released 42 months prior to the project, and at minimum the two latest minor versions.; - All minor versions of numpy and scipy released in the 24 months prior to the project, and at minimum the last three minor versions. If dependency versions need to be updated, update them in the master branch. The following files may need to be updated: `.github/workflows/tests.yml`, `setup.cfg` and `roadmap.rst`. Finally, ensure that PyPI wheels and conda builds cover at least these versions. .. _NEP29: https://numpy.org/neps/nep-0029-deprecation_policy.html. .. _update-changelog:. Updating the Changelog; ----------------------. This needs to be done no matter what type of release is being made. #. Create a new branch to use to make a pull request.; #. Update the changelog using ``towncrier``:. towncrier build --version=<version-number>. Where ``<version-number>`` is the expected version number of the release. #. Make a pull request on the main ``qutip/qutip`` repository with this changelog, and get other members of the admin team to approve it.; #. Merge this into ``master``. Now jump to release_ if you are making a major or minor release, or bugf",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:2973,Deployability,update,updated,2973,"s, or changes to existing features.; - Any new API classes or functions have entries in a suitable RST file in ``doc/apidoc``.; - Any new or changed docstrings are up-to-date and render correctly in the API documentation. Please make a normal PR to ``master`` correcting anything missing from these points and have it merged before you begin the release, if necessary. .. _update-requirement:. Updating the Requirements; -------------------------. Ensure that QuTiP's tests pass on the oldest version supported in the requirements.; On major and minor version, requirements can be adjusted upwards, but patch release must not change minimum requirements.; We follow `NEP29`_ for minimum supported versions ::. - All minor versions of Python released 42 months prior to the project, and at minimum the two latest minor versions.; - All minor versions of numpy and scipy released in the 24 months prior to the project, and at minimum the last three minor versions. If dependency versions need to be updated, update them in the master branch. The following files may need to be updated: `.github/workflows/tests.yml`, `setup.cfg` and `roadmap.rst`. Finally, ensure that PyPI wheels and conda builds cover at least these versions. .. _NEP29: https://numpy.org/neps/nep-0029-deprecation_policy.html. .. _update-changelog:. Updating the Changelog; ----------------------. This needs to be done no matter what type of release is being made. #. Create a new branch to use to make a pull request.; #. Update the changelog using ``towncrier``:. towncrier build --version=<version-number>. Where ``<version-number>`` is the expected version number of the release. #. Make a pull request on the main ``qutip/qutip`` repository with this changelog, and get other members of the admin team to approve it.; #. Merge this into ``master``. Now jump to release_ if you are making a major or minor release, or bugfix_ if you are only fixing bugs in a previous release. .. _release:. Create a New Minor or Major Release; ",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:2982,Deployability,update,update,2982,"s, or changes to existing features.; - Any new API classes or functions have entries in a suitable RST file in ``doc/apidoc``.; - Any new or changed docstrings are up-to-date and render correctly in the API documentation. Please make a normal PR to ``master`` correcting anything missing from these points and have it merged before you begin the release, if necessary. .. _update-requirement:. Updating the Requirements; -------------------------. Ensure that QuTiP's tests pass on the oldest version supported in the requirements.; On major and minor version, requirements can be adjusted upwards, but patch release must not change minimum requirements.; We follow `NEP29`_ for minimum supported versions ::. - All minor versions of Python released 42 months prior to the project, and at minimum the two latest minor versions.; - All minor versions of numpy and scipy released in the 24 months prior to the project, and at minimum the last three minor versions. If dependency versions need to be updated, update them in the master branch. The following files may need to be updated: `.github/workflows/tests.yml`, `setup.cfg` and `roadmap.rst`. Finally, ensure that PyPI wheels and conda builds cover at least these versions. .. _NEP29: https://numpy.org/neps/nep-0029-deprecation_policy.html. .. _update-changelog:. Updating the Changelog; ----------------------. This needs to be done no matter what type of release is being made. #. Create a new branch to use to make a pull request.; #. Update the changelog using ``towncrier``:. towncrier build --version=<version-number>. Where ``<version-number>`` is the expected version number of the release. #. Make a pull request on the main ``qutip/qutip`` repository with this changelog, and get other members of the admin team to approve it.; #. Merge this into ``master``. Now jump to release_ if you are making a major or minor release, or bugfix_ if you are only fixing bugs in a previous release. .. _release:. Create a New Minor or Major Release; ",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:3051,Deployability,update,updated,3051,"functions have entries in a suitable RST file in ``doc/apidoc``.; - Any new or changed docstrings are up-to-date and render correctly in the API documentation. Please make a normal PR to ``master`` correcting anything missing from these points and have it merged before you begin the release, if necessary. .. _update-requirement:. Updating the Requirements; -------------------------. Ensure that QuTiP's tests pass on the oldest version supported in the requirements.; On major and minor version, requirements can be adjusted upwards, but patch release must not change minimum requirements.; We follow `NEP29`_ for minimum supported versions ::. - All minor versions of Python released 42 months prior to the project, and at minimum the two latest minor versions.; - All minor versions of numpy and scipy released in the 24 months prior to the project, and at minimum the last three minor versions. If dependency versions need to be updated, update them in the master branch. The following files may need to be updated: `.github/workflows/tests.yml`, `setup.cfg` and `roadmap.rst`. Finally, ensure that PyPI wheels and conda builds cover at least these versions. .. _NEP29: https://numpy.org/neps/nep-0029-deprecation_policy.html. .. _update-changelog:. Updating the Changelog; ----------------------. This needs to be done no matter what type of release is being made. #. Create a new branch to use to make a pull request.; #. Update the changelog using ``towncrier``:. towncrier build --version=<version-number>. Where ``<version-number>`` is the expected version number of the release. #. Make a pull request on the main ``qutip/qutip`` repository with this changelog, and get other members of the admin team to approve it.; #. Merge this into ``master``. Now jump to release_ if you are making a major or minor release, or bugfix_ if you are only fixing bugs in a previous release. .. _release:. Create a New Minor or Major Release; -----------------------------------. This involves making a ne",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:3387,Deployability,release,release,3387,"ing the Requirements; -------------------------. Ensure that QuTiP's tests pass on the oldest version supported in the requirements.; On major and minor version, requirements can be adjusted upwards, but patch release must not change minimum requirements.; We follow `NEP29`_ for minimum supported versions ::. - All minor versions of Python released 42 months prior to the project, and at minimum the two latest minor versions.; - All minor versions of numpy and scipy released in the 24 months prior to the project, and at minimum the last three minor versions. If dependency versions need to be updated, update them in the master branch. The following files may need to be updated: `.github/workflows/tests.yml`, `setup.cfg` and `roadmap.rst`. Finally, ensure that PyPI wheels and conda builds cover at least these versions. .. _NEP29: https://numpy.org/neps/nep-0029-deprecation_policy.html. .. _update-changelog:. Updating the Changelog; ----------------------. This needs to be done no matter what type of release is being made. #. Create a new branch to use to make a pull request.; #. Update the changelog using ``towncrier``:. towncrier build --version=<version-number>. Where ``<version-number>`` is the expected version number of the release. #. Make a pull request on the main ``qutip/qutip`` repository with this changelog, and get other members of the admin team to approve it.; #. Merge this into ``master``. Now jump to release_ if you are making a major or minor release, or bugfix_ if you are only fixing bugs in a previous release. .. _release:. Create a New Minor or Major Release; -----------------------------------. This involves making a new branch to hold the release and adding some commits to set the code into ""release"" mode.; This release should be done by branching directly off the ``master`` branch at its current head. #. On your machine, make sure your copy of ``master`` is up-to-date (``git checkout master; git pull upstream master``).; This should at least invol",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:3620,Deployability,release,release,3620,"e must not change minimum requirements.; We follow `NEP29`_ for minimum supported versions ::. - All minor versions of Python released 42 months prior to the project, and at minimum the two latest minor versions.; - All minor versions of numpy and scipy released in the 24 months prior to the project, and at minimum the last three minor versions. If dependency versions need to be updated, update them in the master branch. The following files may need to be updated: `.github/workflows/tests.yml`, `setup.cfg` and `roadmap.rst`. Finally, ensure that PyPI wheels and conda builds cover at least these versions. .. _NEP29: https://numpy.org/neps/nep-0029-deprecation_policy.html. .. _update-changelog:. Updating the Changelog; ----------------------. This needs to be done no matter what type of release is being made. #. Create a new branch to use to make a pull request.; #. Update the changelog using ``towncrier``:. towncrier build --version=<version-number>. Where ``<version-number>`` is the expected version number of the release. #. Make a pull request on the main ``qutip/qutip`` repository with this changelog, and get other members of the admin team to approve it.; #. Merge this into ``master``. Now jump to release_ if you are making a major or minor release, or bugfix_ if you are only fixing bugs in a previous release. .. _release:. Create a New Minor or Major Release; -----------------------------------. This involves making a new branch to hold the release and adding some commits to set the code into ""release"" mode.; This release should be done by branching directly off the ``master`` branch at its current head. #. On your machine, make sure your copy of ``master`` is up-to-date (``git checkout master; git pull upstream master``).; This should at least involve fetching the changelog PR that you just made.; Now create a new branch off a commit in ``master`` that has the state of the code you want to release.; The command is ``git checkout -b qutip-<major>.<minor>.X``, fo",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:3855,Deployability,release,release,3855,"24 months prior to the project, and at minimum the last three minor versions. If dependency versions need to be updated, update them in the master branch. The following files may need to be updated: `.github/workflows/tests.yml`, `setup.cfg` and `roadmap.rst`. Finally, ensure that PyPI wheels and conda builds cover at least these versions. .. _NEP29: https://numpy.org/neps/nep-0029-deprecation_policy.html. .. _update-changelog:. Updating the Changelog; ----------------------. This needs to be done no matter what type of release is being made. #. Create a new branch to use to make a pull request.; #. Update the changelog using ``towncrier``:. towncrier build --version=<version-number>. Where ``<version-number>`` is the expected version number of the release. #. Make a pull request on the main ``qutip/qutip`` repository with this changelog, and get other members of the admin team to approve it.; #. Merge this into ``master``. Now jump to release_ if you are making a major or minor release, or bugfix_ if you are only fixing bugs in a previous release. .. _release:. Create a New Minor or Major Release; -----------------------------------. This involves making a new branch to hold the release and adding some commits to set the code into ""release"" mode.; This release should be done by branching directly off the ``master`` branch at its current head. #. On your machine, make sure your copy of ``master`` is up-to-date (``git checkout master; git pull upstream master``).; This should at least involve fetching the changelog PR that you just made.; Now create a new branch off a commit in ``master`` that has the state of the code you want to release.; The command is ``git checkout -b qutip-<major>.<minor>.X``, for example ``qutip-4.7.X``.; This branch name will be public, and must follow this format.; #. Push the new branch (with no commits in it relative to ``master``) to the main ``qutip/qutip`` repository (``git push upstream qutip-4.7.X``).; Creating a branch is one of the o",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:3917,Deployability,release,release,3917,"24 months prior to the project, and at minimum the last three minor versions. If dependency versions need to be updated, update them in the master branch. The following files may need to be updated: `.github/workflows/tests.yml`, `setup.cfg` and `roadmap.rst`. Finally, ensure that PyPI wheels and conda builds cover at least these versions. .. _NEP29: https://numpy.org/neps/nep-0029-deprecation_policy.html. .. _update-changelog:. Updating the Changelog; ----------------------. This needs to be done no matter what type of release is being made. #. Create a new branch to use to make a pull request.; #. Update the changelog using ``towncrier``:. towncrier build --version=<version-number>. Where ``<version-number>`` is the expected version number of the release. #. Make a pull request on the main ``qutip/qutip`` repository with this changelog, and get other members of the admin team to approve it.; #. Merge this into ``master``. Now jump to release_ if you are making a major or minor release, or bugfix_ if you are only fixing bugs in a previous release. .. _release:. Create a New Minor or Major Release; -----------------------------------. This involves making a new branch to hold the release and adding some commits to set the code into ""release"" mode.; This release should be done by branching directly off the ``master`` branch at its current head. #. On your machine, make sure your copy of ``master`` is up-to-date (``git checkout master; git pull upstream master``).; This should at least involve fetching the changelog PR that you just made.; Now create a new branch off a commit in ``master`` that has the state of the code you want to release.; The command is ``git checkout -b qutip-<major>.<minor>.X``, for example ``qutip-4.7.X``.; This branch name will be public, and must follow this format.; #. Push the new branch (with no commits in it relative to ``master``) to the main ``qutip/qutip`` repository (``git push upstream qutip-4.7.X``).; Creating a branch is one of the o",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:4060,Deployability,release,release,4060,"orkflows/tests.yml`, `setup.cfg` and `roadmap.rst`. Finally, ensure that PyPI wheels and conda builds cover at least these versions. .. _NEP29: https://numpy.org/neps/nep-0029-deprecation_policy.html. .. _update-changelog:. Updating the Changelog; ----------------------. This needs to be done no matter what type of release is being made. #. Create a new branch to use to make a pull request.; #. Update the changelog using ``towncrier``:. towncrier build --version=<version-number>. Where ``<version-number>`` is the expected version number of the release. #. Make a pull request on the main ``qutip/qutip`` repository with this changelog, and get other members of the admin team to approve it.; #. Merge this into ``master``. Now jump to release_ if you are making a major or minor release, or bugfix_ if you are only fixing bugs in a previous release. .. _release:. Create a New Minor or Major Release; -----------------------------------. This involves making a new branch to hold the release and adding some commits to set the code into ""release"" mode.; This release should be done by branching directly off the ``master`` branch at its current head. #. On your machine, make sure your copy of ``master`` is up-to-date (``git checkout master; git pull upstream master``).; This should at least involve fetching the changelog PR that you just made.; Now create a new branch off a commit in ``master`` that has the state of the code you want to release.; The command is ``git checkout -b qutip-<major>.<minor>.X``, for example ``qutip-4.7.X``.; This branch name will be public, and must follow this format.; #. Push the new branch (with no commits in it relative to ``master``) to the main ``qutip/qutip`` repository (``git push upstream qutip-4.7.X``).; Creating a branch is one of the only situations in which it is ok to push to ``qutip/qutip`` without making a pull request.; #. Create a second new branch, which will be pushed to your fork and used to make a pull request against the ``qutip-",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:4114,Deployability,release,release,4114,"orkflows/tests.yml`, `setup.cfg` and `roadmap.rst`. Finally, ensure that PyPI wheels and conda builds cover at least these versions. .. _NEP29: https://numpy.org/neps/nep-0029-deprecation_policy.html. .. _update-changelog:. Updating the Changelog; ----------------------. This needs to be done no matter what type of release is being made. #. Create a new branch to use to make a pull request.; #. Update the changelog using ``towncrier``:. towncrier build --version=<version-number>. Where ``<version-number>`` is the expected version number of the release. #. Make a pull request on the main ``qutip/qutip`` repository with this changelog, and get other members of the admin team to approve it.; #. Merge this into ``master``. Now jump to release_ if you are making a major or minor release, or bugfix_ if you are only fixing bugs in a previous release. .. _release:. Create a New Minor or Major Release; -----------------------------------. This involves making a new branch to hold the release and adding some commits to set the code into ""release"" mode.; This release should be done by branching directly off the ``master`` branch at its current head. #. On your machine, make sure your copy of ``master`` is up-to-date (``git checkout master; git pull upstream master``).; This should at least involve fetching the changelog PR that you just made.; Now create a new branch off a commit in ``master`` that has the state of the code you want to release.; The command is ``git checkout -b qutip-<major>.<minor>.X``, for example ``qutip-4.7.X``.; This branch name will be public, and must follow this format.; #. Push the new branch (with no commits in it relative to ``master``) to the main ``qutip/qutip`` repository (``git push upstream qutip-4.7.X``).; Creating a branch is one of the only situations in which it is ok to push to ``qutip/qutip`` without making a pull request.; #. Create a second new branch, which will be pushed to your fork and used to make a pull request against the ``qutip-",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:4135,Deployability,release,release,4135," at least these versions. .. _NEP29: https://numpy.org/neps/nep-0029-deprecation_policy.html. .. _update-changelog:. Updating the Changelog; ----------------------. This needs to be done no matter what type of release is being made. #. Create a new branch to use to make a pull request.; #. Update the changelog using ``towncrier``:. towncrier build --version=<version-number>. Where ``<version-number>`` is the expected version number of the release. #. Make a pull request on the main ``qutip/qutip`` repository with this changelog, and get other members of the admin team to approve it.; #. Merge this into ``master``. Now jump to release_ if you are making a major or minor release, or bugfix_ if you are only fixing bugs in a previous release. .. _release:. Create a New Minor or Major Release; -----------------------------------. This involves making a new branch to hold the release and adding some commits to set the code into ""release"" mode.; This release should be done by branching directly off the ``master`` branch at its current head. #. On your machine, make sure your copy of ``master`` is up-to-date (``git checkout master; git pull upstream master``).; This should at least involve fetching the changelog PR that you just made.; Now create a new branch off a commit in ``master`` that has the state of the code you want to release.; The command is ``git checkout -b qutip-<major>.<minor>.X``, for example ``qutip-4.7.X``.; This branch name will be public, and must follow this format.; #. Push the new branch (with no commits in it relative to ``master``) to the main ``qutip/qutip`` repository (``git push upstream qutip-4.7.X``).; Creating a branch is one of the only situations in which it is ok to push to ``qutip/qutip`` without making a pull request.; #. Create a second new branch, which will be pushed to your fork and used to make a pull request against the ``qutip-<major>.<minor>.X`` branch on ``qutip/qutip`` you just created.; You can call this branch whatever you lik",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:4519,Deployability,release,release,4519,"the changelog using ``towncrier``:. towncrier build --version=<version-number>. Where ``<version-number>`` is the expected version number of the release. #. Make a pull request on the main ``qutip/qutip`` repository with this changelog, and get other members of the admin team to approve it.; #. Merge this into ``master``. Now jump to release_ if you are making a major or minor release, or bugfix_ if you are only fixing bugs in a previous release. .. _release:. Create a New Minor or Major Release; -----------------------------------. This involves making a new branch to hold the release and adding some commits to set the code into ""release"" mode.; This release should be done by branching directly off the ``master`` branch at its current head. #. On your machine, make sure your copy of ``master`` is up-to-date (``git checkout master; git pull upstream master``).; This should at least involve fetching the changelog PR that you just made.; Now create a new branch off a commit in ``master`` that has the state of the code you want to release.; The command is ``git checkout -b qutip-<major>.<minor>.X``, for example ``qutip-4.7.X``.; This branch name will be public, and must follow this format.; #. Push the new branch (with no commits in it relative to ``master``) to the main ``qutip/qutip`` repository (``git push upstream qutip-4.7.X``).; Creating a branch is one of the only situations in which it is ok to push to ``qutip/qutip`` without making a pull request.; #. Create a second new branch, which will be pushed to your fork and used to make a pull request against the ``qutip-<major>.<minor>.X`` branch on ``qutip/qutip`` you just created.; You can call this branch whatever you like because it is not going to the main repository, for example ``git checkout -b prepare-qutip-4.7.0``.; #. - Change the ``VERSION`` file to contain the new version number exactly, removing the ``.dev`` suffix.; For example, if you are releasing the first release of the minor 4.7 track, set ``VERSI",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:5432,Deployability,release,release,5432,"de.; Now create a new branch off a commit in ``master`` that has the state of the code you want to release.; The command is ``git checkout -b qutip-<major>.<minor>.X``, for example ``qutip-4.7.X``.; This branch name will be public, and must follow this format.; #. Push the new branch (with no commits in it relative to ``master``) to the main ``qutip/qutip`` repository (``git push upstream qutip-4.7.X``).; Creating a branch is one of the only situations in which it is ok to push to ``qutip/qutip`` without making a pull request.; #. Create a second new branch, which will be pushed to your fork and used to make a pull request against the ``qutip-<major>.<minor>.X`` branch on ``qutip/qutip`` you just created.; You can call this branch whatever you like because it is not going to the main repository, for example ``git checkout -b prepare-qutip-4.7.0``.; #. - Change the ``VERSION`` file to contain the new version number exactly, removing the ``.dev`` suffix.; For example, if you are releasing the first release of the minor 4.7 track, set ``VERSION`` to contain the string ``4.7.0``.; (*Special circumstances*: if you are making an alpha, beta or release candidate release, append a ``.a<n>``, ``.b<n>`` or ``.rc<n>`` to the version string, where ``<n>`` is an integer starting from 0 that counts how many of that pre-release track there have been.); - Edit ``setup.cfg`` by changing the ""Development Status"" line in the ``classifiers`` section to ::. Development Status :: 5 - Production/Stable. Commit both changes (``git add VERSION setup.cfg; git commit -m ""Set release mode for 4.7.0""``), and then push them to your fork (``git push -u origin prepare-qutip-4.7.0``); #. Using GitHub, make a pull request to the release branch (e.g. ``qutip-4.7.X``) using this branch that you just created.; You will need to change the ""base branch"" in the pull request, because GitHub will always try to make the PR against ``master`` at first.; When the tests have passed, merge this in.; #. Finally, b",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:5576,Deployability,release,release,5576,"utip-<major>.<minor>.X``, for example ``qutip-4.7.X``.; This branch name will be public, and must follow this format.; #. Push the new branch (with no commits in it relative to ``master``) to the main ``qutip/qutip`` repository (``git push upstream qutip-4.7.X``).; Creating a branch is one of the only situations in which it is ok to push to ``qutip/qutip`` without making a pull request.; #. Create a second new branch, which will be pushed to your fork and used to make a pull request against the ``qutip-<major>.<minor>.X`` branch on ``qutip/qutip`` you just created.; You can call this branch whatever you like because it is not going to the main repository, for example ``git checkout -b prepare-qutip-4.7.0``.; #. - Change the ``VERSION`` file to contain the new version number exactly, removing the ``.dev`` suffix.; For example, if you are releasing the first release of the minor 4.7 track, set ``VERSION`` to contain the string ``4.7.0``.; (*Special circumstances*: if you are making an alpha, beta or release candidate release, append a ``.a<n>``, ``.b<n>`` or ``.rc<n>`` to the version string, where ``<n>`` is an integer starting from 0 that counts how many of that pre-release track there have been.); - Edit ``setup.cfg`` by changing the ""Development Status"" line in the ``classifiers`` section to ::. Development Status :: 5 - Production/Stable. Commit both changes (``git add VERSION setup.cfg; git commit -m ""Set release mode for 4.7.0""``), and then push them to your fork (``git push -u origin prepare-qutip-4.7.0``); #. Using GitHub, make a pull request to the release branch (e.g. ``qutip-4.7.X``) using this branch that you just created.; You will need to change the ""base branch"" in the pull request, because GitHub will always try to make the PR against ``master`` at first.; When the tests have passed, merge this in.; #. Finally, back on ``master``, make a new pull request that changes the ``VERSION`` file to be ``<next-expected-version>.dev``, for example ``4.8.0.dev``.;",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:5594,Deployability,release,release,5594,"utip-<major>.<minor>.X``, for example ``qutip-4.7.X``.; This branch name will be public, and must follow this format.; #. Push the new branch (with no commits in it relative to ``master``) to the main ``qutip/qutip`` repository (``git push upstream qutip-4.7.X``).; Creating a branch is one of the only situations in which it is ok to push to ``qutip/qutip`` without making a pull request.; #. Create a second new branch, which will be pushed to your fork and used to make a pull request against the ``qutip-<major>.<minor>.X`` branch on ``qutip/qutip`` you just created.; You can call this branch whatever you like because it is not going to the main repository, for example ``git checkout -b prepare-qutip-4.7.0``.; #. - Change the ``VERSION`` file to contain the new version number exactly, removing the ``.dev`` suffix.; For example, if you are releasing the first release of the minor 4.7 track, set ``VERSION`` to contain the string ``4.7.0``.; (*Special circumstances*: if you are making an alpha, beta or release candidate release, append a ``.a<n>``, ``.b<n>`` or ``.rc<n>`` to the version string, where ``<n>`` is an integer starting from 0 that counts how many of that pre-release track there have been.); - Edit ``setup.cfg`` by changing the ""Development Status"" line in the ``classifiers`` section to ::. Development Status :: 5 - Production/Stable. Commit both changes (``git add VERSION setup.cfg; git commit -m ""Set release mode for 4.7.0""``), and then push them to your fork (``git push -u origin prepare-qutip-4.7.0``); #. Using GitHub, make a pull request to the release branch (e.g. ``qutip-4.7.X``) using this branch that you just created.; You will need to change the ""base branch"" in the pull request, because GitHub will always try to make the PR against ``master`` at first.; When the tests have passed, merge this in.; #. Finally, back on ``master``, make a new pull request that changes the ``VERSION`` file to be ``<next-expected-version>.dev``, for example ``4.8.0.dev``.;",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:5747,Deployability,release,release,5747,"th no commits in it relative to ``master``) to the main ``qutip/qutip`` repository (``git push upstream qutip-4.7.X``).; Creating a branch is one of the only situations in which it is ok to push to ``qutip/qutip`` without making a pull request.; #. Create a second new branch, which will be pushed to your fork and used to make a pull request against the ``qutip-<major>.<minor>.X`` branch on ``qutip/qutip`` you just created.; You can call this branch whatever you like because it is not going to the main repository, for example ``git checkout -b prepare-qutip-4.7.0``.; #. - Change the ``VERSION`` file to contain the new version number exactly, removing the ``.dev`` suffix.; For example, if you are releasing the first release of the minor 4.7 track, set ``VERSION`` to contain the string ``4.7.0``.; (*Special circumstances*: if you are making an alpha, beta or release candidate release, append a ``.a<n>``, ``.b<n>`` or ``.rc<n>`` to the version string, where ``<n>`` is an integer starting from 0 that counts how many of that pre-release track there have been.); - Edit ``setup.cfg`` by changing the ""Development Status"" line in the ``classifiers`` section to ::. Development Status :: 5 - Production/Stable. Commit both changes (``git add VERSION setup.cfg; git commit -m ""Set release mode for 4.7.0""``), and then push them to your fork (``git push -u origin prepare-qutip-4.7.0``); #. Using GitHub, make a pull request to the release branch (e.g. ``qutip-4.7.X``) using this branch that you just created.; You will need to change the ""base branch"" in the pull request, because GitHub will always try to make the PR against ``master`` at first.; When the tests have passed, merge this in.; #. Finally, back on ``master``, make a new pull request that changes the ``VERSION`` file to be ``<next-expected-version>.dev``, for example ``4.8.0.dev``.; The ""Development Status"" in ``setup.cfg`` on ``master`` should not have changed, and should be ::. Development Status :: 2 - Pre-Alpha. because",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:5995,Deployability,release,release,5995,"ill be pushed to your fork and used to make a pull request against the ``qutip-<major>.<minor>.X`` branch on ``qutip/qutip`` you just created.; You can call this branch whatever you like because it is not going to the main repository, for example ``git checkout -b prepare-qutip-4.7.0``.; #. - Change the ``VERSION`` file to contain the new version number exactly, removing the ``.dev`` suffix.; For example, if you are releasing the first release of the minor 4.7 track, set ``VERSION`` to contain the string ``4.7.0``.; (*Special circumstances*: if you are making an alpha, beta or release candidate release, append a ``.a<n>``, ``.b<n>`` or ``.rc<n>`` to the version string, where ``<n>`` is an integer starting from 0 that counts how many of that pre-release track there have been.); - Edit ``setup.cfg`` by changing the ""Development Status"" line in the ``classifiers`` section to ::. Development Status :: 5 - Production/Stable. Commit both changes (``git add VERSION setup.cfg; git commit -m ""Set release mode for 4.7.0""``), and then push them to your fork (``git push -u origin prepare-qutip-4.7.0``); #. Using GitHub, make a pull request to the release branch (e.g. ``qutip-4.7.X``) using this branch that you just created.; You will need to change the ""base branch"" in the pull request, because GitHub will always try to make the PR against ``master`` at first.; When the tests have passed, merge this in.; #. Finally, back on ``master``, make a new pull request that changes the ``VERSION`` file to be ``<next-expected-version>.dev``, for example ``4.8.0.dev``.; The ""Development Status"" in ``setup.cfg`` on ``master`` should not have changed, and should be ::. Development Status :: 2 - Pre-Alpha. because ``master`` is never directly released. You should now have a branch that you can see on the GitHub website that is called ``qutip-4.7.X`` (or whatever minor version), and the state of the code in it should be exactly what you want to release as the new minor release.; If you notice y",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:6145,Deployability,release,release,6145,".; You can call this branch whatever you like because it is not going to the main repository, for example ``git checkout -b prepare-qutip-4.7.0``.; #. - Change the ``VERSION`` file to contain the new version number exactly, removing the ``.dev`` suffix.; For example, if you are releasing the first release of the minor 4.7 track, set ``VERSION`` to contain the string ``4.7.0``.; (*Special circumstances*: if you are making an alpha, beta or release candidate release, append a ``.a<n>``, ``.b<n>`` or ``.rc<n>`` to the version string, where ``<n>`` is an integer starting from 0 that counts how many of that pre-release track there have been.); - Edit ``setup.cfg`` by changing the ""Development Status"" line in the ``classifiers`` section to ::. Development Status :: 5 - Production/Stable. Commit both changes (``git add VERSION setup.cfg; git commit -m ""Set release mode for 4.7.0""``), and then push them to your fork (``git push -u origin prepare-qutip-4.7.0``); #. Using GitHub, make a pull request to the release branch (e.g. ``qutip-4.7.X``) using this branch that you just created.; You will need to change the ""base branch"" in the pull request, because GitHub will always try to make the PR against ``master`` at first.; When the tests have passed, merge this in.; #. Finally, back on ``master``, make a new pull request that changes the ``VERSION`` file to be ``<next-expected-version>.dev``, for example ``4.8.0.dev``.; The ""Development Status"" in ``setup.cfg`` on ``master`` should not have changed, and should be ::. Development Status :: 2 - Pre-Alpha. because ``master`` is never directly released. You should now have a branch that you can see on the GitHub website that is called ``qutip-4.7.X`` (or whatever minor version), and the state of the code in it should be exactly what you want to release as the new minor release.; If you notice you have made a mistake, you can make additional pull requests to the release branch to fix it.; ``master`` should look pretty similar, excep",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:6738,Deployability,release,released,6738,"ts how many of that pre-release track there have been.); - Edit ``setup.cfg`` by changing the ""Development Status"" line in the ``classifiers`` section to ::. Development Status :: 5 - Production/Stable. Commit both changes (``git add VERSION setup.cfg; git commit -m ""Set release mode for 4.7.0""``), and then push them to your fork (``git push -u origin prepare-qutip-4.7.0``); #. Using GitHub, make a pull request to the release branch (e.g. ``qutip-4.7.X``) using this branch that you just created.; You will need to change the ""base branch"" in the pull request, because GitHub will always try to make the PR against ``master`` at first.; When the tests have passed, merge this in.; #. Finally, back on ``master``, make a new pull request that changes the ``VERSION`` file to be ``<next-expected-version>.dev``, for example ``4.8.0.dev``.; The ""Development Status"" in ``setup.cfg`` on ``master`` should not have changed, and should be ::. Development Status :: 2 - Pre-Alpha. because ``master`` is never directly released. You should now have a branch that you can see on the GitHub website that is called ``qutip-4.7.X`` (or whatever minor version), and the state of the code in it should be exactly what you want to release as the new minor release.; If you notice you have made a mistake, you can make additional pull requests to the release branch to fix it.; ``master`` should look pretty similar, except the ``VERSION`` will be higher and have a ``.dev`` suffix, and the ""Development Status"" in ``setup.cfg`` will be different. * Activate the readthedocs build for the newly created version branch and set it as the latest. You are now ready to actually perform the release.; Go to deploy_. .. _bugfix:. Create a Bug Fix Release; ------------------------. In this you will modify an already-released branch by ""cherry-picking"" one or more pull requests that have been merged to ``master`` (including your new changelog), and bump the ""patch"" part of the version number. #. On your machine, mak",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:6943,Deployability,release,release,6943,"oduction/Stable. Commit both changes (``git add VERSION setup.cfg; git commit -m ""Set release mode for 4.7.0""``), and then push them to your fork (``git push -u origin prepare-qutip-4.7.0``); #. Using GitHub, make a pull request to the release branch (e.g. ``qutip-4.7.X``) using this branch that you just created.; You will need to change the ""base branch"" in the pull request, because GitHub will always try to make the PR against ``master`` at first.; When the tests have passed, merge this in.; #. Finally, back on ``master``, make a new pull request that changes the ``VERSION`` file to be ``<next-expected-version>.dev``, for example ``4.8.0.dev``.; The ""Development Status"" in ``setup.cfg`` on ``master`` should not have changed, and should be ::. Development Status :: 2 - Pre-Alpha. because ``master`` is never directly released. You should now have a branch that you can see on the GitHub website that is called ``qutip-4.7.X`` (or whatever minor version), and the state of the code in it should be exactly what you want to release as the new minor release.; If you notice you have made a mistake, you can make additional pull requests to the release branch to fix it.; ``master`` should look pretty similar, except the ``VERSION`` will be higher and have a ``.dev`` suffix, and the ""Development Status"" in ``setup.cfg`` will be different. * Activate the readthedocs build for the newly created version branch and set it as the latest. You are now ready to actually perform the release.; Go to deploy_. .. _bugfix:. Create a Bug Fix Release; ------------------------. In this you will modify an already-released branch by ""cherry-picking"" one or more pull requests that have been merged to ``master`` (including your new changelog), and bump the ""patch"" part of the version number. #. On your machine, make sure your copy of ``master`` is up-to-date (``git checkout master; git pull upstream master``).; In particular, make sure the changelog you wrote in the first step is visible.; #. Find",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:6968,Deployability,release,release,6968,"oduction/Stable. Commit both changes (``git add VERSION setup.cfg; git commit -m ""Set release mode for 4.7.0""``), and then push them to your fork (``git push -u origin prepare-qutip-4.7.0``); #. Using GitHub, make a pull request to the release branch (e.g. ``qutip-4.7.X``) using this branch that you just created.; You will need to change the ""base branch"" in the pull request, because GitHub will always try to make the PR against ``master`` at first.; When the tests have passed, merge this in.; #. Finally, back on ``master``, make a new pull request that changes the ``VERSION`` file to be ``<next-expected-version>.dev``, for example ``4.8.0.dev``.; The ""Development Status"" in ``setup.cfg`` on ``master`` should not have changed, and should be ::. Development Status :: 2 - Pre-Alpha. because ``master`` is never directly released. You should now have a branch that you can see on the GitHub website that is called ``qutip-4.7.X`` (or whatever minor version), and the state of the code in it should be exactly what you want to release as the new minor release.; If you notice you have made a mistake, you can make additional pull requests to the release branch to fix it.; ``master`` should look pretty similar, except the ``VERSION`` will be higher and have a ``.dev`` suffix, and the ""Development Status"" in ``setup.cfg`` will be different. * Activate the readthedocs build for the newly created version branch and set it as the latest. You are now ready to actually perform the release.; Go to deploy_. .. _bugfix:. Create a Bug Fix Release; ------------------------. In this you will modify an already-released branch by ""cherry-picking"" one or more pull requests that have been merged to ``master`` (including your new changelog), and bump the ""patch"" part of the version number. #. On your machine, make sure your copy of ``master`` is up-to-date (``git checkout master; git pull upstream master``).; In particular, make sure the changelog you wrote in the first step is visible.; #. Find",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:7062,Deployability,release,release,7062," push them to your fork (``git push -u origin prepare-qutip-4.7.0``); #. Using GitHub, make a pull request to the release branch (e.g. ``qutip-4.7.X``) using this branch that you just created.; You will need to change the ""base branch"" in the pull request, because GitHub will always try to make the PR against ``master`` at first.; When the tests have passed, merge this in.; #. Finally, back on ``master``, make a new pull request that changes the ``VERSION`` file to be ``<next-expected-version>.dev``, for example ``4.8.0.dev``.; The ""Development Status"" in ``setup.cfg`` on ``master`` should not have changed, and should be ::. Development Status :: 2 - Pre-Alpha. because ``master`` is never directly released. You should now have a branch that you can see on the GitHub website that is called ``qutip-4.7.X`` (or whatever minor version), and the state of the code in it should be exactly what you want to release as the new minor release.; If you notice you have made a mistake, you can make additional pull requests to the release branch to fix it.; ``master`` should look pretty similar, except the ``VERSION`` will be higher and have a ``.dev`` suffix, and the ""Development Status"" in ``setup.cfg`` will be different. * Activate the readthedocs build for the newly created version branch and set it as the latest. You are now ready to actually perform the release.; Go to deploy_. .. _bugfix:. Create a Bug Fix Release; ------------------------. In this you will modify an already-released branch by ""cherry-picking"" one or more pull requests that have been merged to ``master`` (including your new changelog), and bump the ""patch"" part of the version number. #. On your machine, make sure your copy of ``master`` is up-to-date (``git checkout master; git pull upstream master``).; In particular, make sure the changelog you wrote in the first step is visible.; #. Find the branch of the release that you will be modifying.; This should already exist on the ``qutip/qutip`` repository, and b",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:7397,Deployability,release,release,7397,"have passed, merge this in.; #. Finally, back on ``master``, make a new pull request that changes the ``VERSION`` file to be ``<next-expected-version>.dev``, for example ``4.8.0.dev``.; The ""Development Status"" in ``setup.cfg`` on ``master`` should not have changed, and should be ::. Development Status :: 2 - Pre-Alpha. because ``master`` is never directly released. You should now have a branch that you can see on the GitHub website that is called ``qutip-4.7.X`` (or whatever minor version), and the state of the code in it should be exactly what you want to release as the new minor release.; If you notice you have made a mistake, you can make additional pull requests to the release branch to fix it.; ``master`` should look pretty similar, except the ``VERSION`` will be higher and have a ``.dev`` suffix, and the ""Development Status"" in ``setup.cfg`` will be different. * Activate the readthedocs build for the newly created version branch and set it as the latest. You are now ready to actually perform the release.; Go to deploy_. .. _bugfix:. Create a Bug Fix Release; ------------------------. In this you will modify an already-released branch by ""cherry-picking"" one or more pull requests that have been merged to ``master`` (including your new changelog), and bump the ""patch"" part of the version number. #. On your machine, make sure your copy of ``master`` is up-to-date (``git checkout master; git pull upstream master``).; In particular, make sure the changelog you wrote in the first step is visible.; #. Find the branch of the release that you will be modifying.; This should already exist on the ``qutip/qutip`` repository, and be called ``qutip-<major>.<minor>.X`` (e.g. ``qutip-4.6.X``).; If you cannot see it, run ``git fetch upstream`` to update all the branch references from the main repository.; Checkout a new private branch, starting from the head of the release branch (``git checkout -b prepare-qutip-4.6.1 upstream/qutip-4.6.X``).; You can call this branch whatever",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:7522,Deployability,release,released,7522,"``setup.cfg`` on ``master`` should not have changed, and should be ::. Development Status :: 2 - Pre-Alpha. because ``master`` is never directly released. You should now have a branch that you can see on the GitHub website that is called ``qutip-4.7.X`` (or whatever minor version), and the state of the code in it should be exactly what you want to release as the new minor release.; If you notice you have made a mistake, you can make additional pull requests to the release branch to fix it.; ``master`` should look pretty similar, except the ``VERSION`` will be higher and have a ``.dev`` suffix, and the ""Development Status"" in ``setup.cfg`` will be different. * Activate the readthedocs build for the newly created version branch and set it as the latest. You are now ready to actually perform the release.; Go to deploy_. .. _bugfix:. Create a Bug Fix Release; ------------------------. In this you will modify an already-released branch by ""cherry-picking"" one or more pull requests that have been merged to ``master`` (including your new changelog), and bump the ""patch"" part of the version number. #. On your machine, make sure your copy of ``master`` is up-to-date (``git checkout master; git pull upstream master``).; In particular, make sure the changelog you wrote in the first step is visible.; #. Find the branch of the release that you will be modifying.; This should already exist on the ``qutip/qutip`` repository, and be called ``qutip-<major>.<minor>.X`` (e.g. ``qutip-4.6.X``).; If you cannot see it, run ``git fetch upstream`` to update all the branch references from the main repository.; Checkout a new private branch, starting from the head of the release branch (``git checkout -b prepare-qutip-4.6.1 upstream/qutip-4.6.X``).; You can call this branch whatever you like (in the example it is ``prepare-qutip-4.6.1``), because it will only be used to make a pull request.; #. Cherry-pick all the commits that will be added to this release in order, including your PR that wr",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:7666,Deployability,patch,patch,7666,"``setup.cfg`` on ``master`` should not have changed, and should be ::. Development Status :: 2 - Pre-Alpha. because ``master`` is never directly released. You should now have a branch that you can see on the GitHub website that is called ``qutip-4.7.X`` (or whatever minor version), and the state of the code in it should be exactly what you want to release as the new minor release.; If you notice you have made a mistake, you can make additional pull requests to the release branch to fix it.; ``master`` should look pretty similar, except the ``VERSION`` will be higher and have a ``.dev`` suffix, and the ""Development Status"" in ``setup.cfg`` will be different. * Activate the readthedocs build for the newly created version branch and set it as the latest. You are now ready to actually perform the release.; Go to deploy_. .. _bugfix:. Create a Bug Fix Release; ------------------------. In this you will modify an already-released branch by ""cherry-picking"" one or more pull requests that have been merged to ``master`` (including your new changelog), and bump the ""patch"" part of the version number. #. On your machine, make sure your copy of ``master`` is up-to-date (``git checkout master; git pull upstream master``).; In particular, make sure the changelog you wrote in the first step is visible.; #. Find the branch of the release that you will be modifying.; This should already exist on the ``qutip/qutip`` repository, and be called ``qutip-<major>.<minor>.X`` (e.g. ``qutip-4.6.X``).; If you cannot see it, run ``git fetch upstream`` to update all the branch references from the main repository.; Checkout a new private branch, starting from the head of the release branch (``git checkout -b prepare-qutip-4.6.1 upstream/qutip-4.6.X``).; You can call this branch whatever you like (in the example it is ``prepare-qutip-4.6.1``), because it will only be used to make a pull request.; #. Cherry-pick all the commits that will be added to this release in order, including your PR that wr",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:7929,Deployability,release,release,7929," want to release as the new minor release.; If you notice you have made a mistake, you can make additional pull requests to the release branch to fix it.; ``master`` should look pretty similar, except the ``VERSION`` will be higher and have a ``.dev`` suffix, and the ""Development Status"" in ``setup.cfg`` will be different. * Activate the readthedocs build for the newly created version branch and set it as the latest. You are now ready to actually perform the release.; Go to deploy_. .. _bugfix:. Create a Bug Fix Release; ------------------------. In this you will modify an already-released branch by ""cherry-picking"" one or more pull requests that have been merged to ``master`` (including your new changelog), and bump the ""patch"" part of the version number. #. On your machine, make sure your copy of ``master`` is up-to-date (``git checkout master; git pull upstream master``).; In particular, make sure the changelog you wrote in the first step is visible.; #. Find the branch of the release that you will be modifying.; This should already exist on the ``qutip/qutip`` repository, and be called ``qutip-<major>.<minor>.X`` (e.g. ``qutip-4.6.X``).; If you cannot see it, run ``git fetch upstream`` to update all the branch references from the main repository.; Checkout a new private branch, starting from the head of the release branch (``git checkout -b prepare-qutip-4.6.1 upstream/qutip-4.6.X``).; You can call this branch whatever you like (in the example it is ``prepare-qutip-4.6.1``), because it will only be used to make a pull request.; #. Cherry-pick all the commits that will be added to this release in order, including your PR that wrote the new changelog entries (this will be the last one you cherry-pick).; You will want to use ``git log`` to find the relevant commits, going from **oldest to newest** (their ""age"" is when they were merged into ``master``, not when the PR was first opened).; The command is slightly different depending on which merge strategy was used for",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:8146,Deployability,update,update,8146,"`` will be higher and have a ``.dev`` suffix, and the ""Development Status"" in ``setup.cfg`` will be different. * Activate the readthedocs build for the newly created version branch and set it as the latest. You are now ready to actually perform the release.; Go to deploy_. .. _bugfix:. Create a Bug Fix Release; ------------------------. In this you will modify an already-released branch by ""cherry-picking"" one or more pull requests that have been merged to ``master`` (including your new changelog), and bump the ""patch"" part of the version number. #. On your machine, make sure your copy of ``master`` is up-to-date (``git checkout master; git pull upstream master``).; In particular, make sure the changelog you wrote in the first step is visible.; #. Find the branch of the release that you will be modifying.; This should already exist on the ``qutip/qutip`` repository, and be called ``qutip-<major>.<minor>.X`` (e.g. ``qutip-4.6.X``).; If you cannot see it, run ``git fetch upstream`` to update all the branch references from the main repository.; Checkout a new private branch, starting from the head of the release branch (``git checkout -b prepare-qutip-4.6.1 upstream/qutip-4.6.X``).; You can call this branch whatever you like (in the example it is ``prepare-qutip-4.6.1``), because it will only be used to make a pull request.; #. Cherry-pick all the commits that will be added to this release in order, including your PR that wrote the new changelog entries (this will be the last one you cherry-pick).; You will want to use ``git log`` to find the relevant commits, going from **oldest to newest** (their ""age"" is when they were merged into ``master``, not when the PR was first opened).; The command is slightly different depending on which merge strategy was used for a particular PR:. - ""merge"": you only need to find one commit though the log will have included several; there will be an entry in ``git log`` with a title such as ""Merge pull request #1000 from <...>"".; Note the",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:8267,Deployability,release,release,8267," Activate the readthedocs build for the newly created version branch and set it as the latest. You are now ready to actually perform the release.; Go to deploy_. .. _bugfix:. Create a Bug Fix Release; ------------------------. In this you will modify an already-released branch by ""cherry-picking"" one or more pull requests that have been merged to ``master`` (including your new changelog), and bump the ""patch"" part of the version number. #. On your machine, make sure your copy of ``master`` is up-to-date (``git checkout master; git pull upstream master``).; In particular, make sure the changelog you wrote in the first step is visible.; #. Find the branch of the release that you will be modifying.; This should already exist on the ``qutip/qutip`` repository, and be called ``qutip-<major>.<minor>.X`` (e.g. ``qutip-4.6.X``).; If you cannot see it, run ``git fetch upstream`` to update all the branch references from the main repository.; Checkout a new private branch, starting from the head of the release branch (``git checkout -b prepare-qutip-4.6.1 upstream/qutip-4.6.X``).; You can call this branch whatever you like (in the example it is ``prepare-qutip-4.6.1``), because it will only be used to make a pull request.; #. Cherry-pick all the commits that will be added to this release in order, including your PR that wrote the new changelog entries (this will be the last one you cherry-pick).; You will want to use ``git log`` to find the relevant commits, going from **oldest to newest** (their ""age"" is when they were merged into ``master``, not when the PR was first opened).; The command is slightly different depending on which merge strategy was used for a particular PR:. - ""merge"": you only need to find one commit though the log will have included several; there will be an entry in ``git log`` with a title such as ""Merge pull request #1000 from <...>"".; Note the first 7 characters of its hash.; Cherry-pick this by ``git cherry-pick --mainline 1 <hash>``.; - ""squash and mer",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:8550,Deployability,release,release,8550,"sts that have been merged to ``master`` (including your new changelog), and bump the ""patch"" part of the version number. #. On your machine, make sure your copy of ``master`` is up-to-date (``git checkout master; git pull upstream master``).; In particular, make sure the changelog you wrote in the first step is visible.; #. Find the branch of the release that you will be modifying.; This should already exist on the ``qutip/qutip`` repository, and be called ``qutip-<major>.<minor>.X`` (e.g. ``qutip-4.6.X``).; If you cannot see it, run ``git fetch upstream`` to update all the branch references from the main repository.; Checkout a new private branch, starting from the head of the release branch (``git checkout -b prepare-qutip-4.6.1 upstream/qutip-4.6.X``).; You can call this branch whatever you like (in the example it is ``prepare-qutip-4.6.1``), because it will only be used to make a pull request.; #. Cherry-pick all the commits that will be added to this release in order, including your PR that wrote the new changelog entries (this will be the last one you cherry-pick).; You will want to use ``git log`` to find the relevant commits, going from **oldest to newest** (their ""age"" is when they were merged into ``master``, not when the PR was first opened).; The command is slightly different depending on which merge strategy was used for a particular PR:. - ""merge"": you only need to find one commit though the log will have included several; there will be an entry in ``git log`` with a title such as ""Merge pull request #1000 from <...>"".; Note the first 7 characters of its hash.; Cherry-pick this by ``git cherry-pick --mainline 1 <hash>``.; - ""squash and merge"": there will only be a single commit for the entire PR.; Its name will be ""<Name of the pull request> (#1000)"".; Note the first 7 characters of its hash.; Cherry-pick this by ``git cherry-pick <hash>``.; - ""rebase and merge"": this is the most difficult, because there will be many commits that you will have to find m",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:10542,Deployability,patch,patch,10542,"e most difficult, because there will be many commits that you will have to find manually, and cherry-pick all of them.; Go to the GitHub page for this PR, and go to the ""Commits"" tab.; Using your local ``git log`` (you may find ``git log --oneline`` useful), find the hash for every single commit that is listed on the GitHub page, in order from **oldest to newest** (top-to-bottom in the GitHub view, which is bottom-to-top in ``git log``).; You will need to use the commit message to do this; the hashes that GitHub reports will probably not be the same as how they appear locally.; Find the first 7 characters of each of the hashes.; Cherry-pick these all in one go by ``git cherry-pick <hash1> <hash2> ... <hash10>``, where ``<hash1>`` is the oldest. If any of the cherry-picks have merge conflicts, first verify that you are cherry-picking in order from oldest to newest.; If you still have merge conflicts, you will either need to manually fix them (if it is a *very* simple fix), or else you will need to find which additional PR this patch depends on, and restart the bug fix process including this additional patch.; This generally should not happen if you are sticking to very small bug fixes; if the fixes had far-reaching changes, a new minor release may be more appropriate.; #. Change the ``VERSION`` file by bumping the last number up by one (double-digit numbers are fine, so ``4.6.10`` comes after ``4.6.9``), and commit the change.; #. Push this branch to your fork, and make a pull request against the release branch.; On GitHub in the PR screen, you will need to change the ""Base"" branch to ``qutip-4.6.X`` (or whatever version), because GitHub will default to making it against ``master``.; It should be quite clear if you have forgotten to do this, because there will probably be many merge conflicts.; Once the tests have passed and you have another admin's approval, merge the PR. You should now see that the ``qutip-4.6.X`` (or whatever) branch on GitHub has been updated, an",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:10618,Deployability,patch,patch,10618,"e most difficult, because there will be many commits that you will have to find manually, and cherry-pick all of them.; Go to the GitHub page for this PR, and go to the ""Commits"" tab.; Using your local ``git log`` (you may find ``git log --oneline`` useful), find the hash for every single commit that is listed on the GitHub page, in order from **oldest to newest** (top-to-bottom in the GitHub view, which is bottom-to-top in ``git log``).; You will need to use the commit message to do this; the hashes that GitHub reports will probably not be the same as how they appear locally.; Find the first 7 characters of each of the hashes.; Cherry-pick these all in one go by ``git cherry-pick <hash1> <hash2> ... <hash10>``, where ``<hash1>`` is the oldest. If any of the cherry-picks have merge conflicts, first verify that you are cherry-picking in order from oldest to newest.; If you still have merge conflicts, you will either need to manually fix them (if it is a *very* simple fix), or else you will need to find which additional PR this patch depends on, and restart the bug fix process including this additional patch.; This generally should not happen if you are sticking to very small bug fixes; if the fixes had far-reaching changes, a new minor release may be more appropriate.; #. Change the ``VERSION`` file by bumping the last number up by one (double-digit numbers are fine, so ``4.6.10`` comes after ``4.6.9``), and commit the change.; #. Push this branch to your fork, and make a pull request against the release branch.; On GitHub in the PR screen, you will need to change the ""Base"" branch to ``qutip-4.6.X`` (or whatever version), because GitHub will default to making it against ``master``.; It should be quite clear if you have forgotten to do this, because there will probably be many merge conflicts.; Once the tests have passed and you have another admin's approval, merge the PR. You should now see that the ``qutip-4.6.X`` (or whatever) branch on GitHub has been updated, an",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:10755,Deployability,release,release,10755,"it log`` (you may find ``git log --oneline`` useful), find the hash for every single commit that is listed on the GitHub page, in order from **oldest to newest** (top-to-bottom in the GitHub view, which is bottom-to-top in ``git log``).; You will need to use the commit message to do this; the hashes that GitHub reports will probably not be the same as how they appear locally.; Find the first 7 characters of each of the hashes.; Cherry-pick these all in one go by ``git cherry-pick <hash1> <hash2> ... <hash10>``, where ``<hash1>`` is the oldest. If any of the cherry-picks have merge conflicts, first verify that you are cherry-picking in order from oldest to newest.; If you still have merge conflicts, you will either need to manually fix them (if it is a *very* simple fix), or else you will need to find which additional PR this patch depends on, and restart the bug fix process including this additional patch.; This generally should not happen if you are sticking to very small bug fixes; if the fixes had far-reaching changes, a new minor release may be more appropriate.; #. Change the ``VERSION`` file by bumping the last number up by one (double-digit numbers are fine, so ``4.6.10`` comes after ``4.6.9``), and commit the change.; #. Push this branch to your fork, and make a pull request against the release branch.; On GitHub in the PR screen, you will need to change the ""Base"" branch to ``qutip-4.6.X`` (or whatever version), because GitHub will default to making it against ``master``.; It should be quite clear if you have forgotten to do this, because there will probably be many merge conflicts.; Once the tests have passed and you have another admin's approval, merge the PR. You should now see that the ``qutip-4.6.X`` (or whatever) branch on GitHub has been updated, and now includes all the changes you have just made.; If you have made a mistake, feel free to make additonal PRs to rectify the situation. You are now ready to actually perform the release.; Go to deploy_. .",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:11021,Deployability,release,release,11021," the hashes that GitHub reports will probably not be the same as how they appear locally.; Find the first 7 characters of each of the hashes.; Cherry-pick these all in one go by ``git cherry-pick <hash1> <hash2> ... <hash10>``, where ``<hash1>`` is the oldest. If any of the cherry-picks have merge conflicts, first verify that you are cherry-picking in order from oldest to newest.; If you still have merge conflicts, you will either need to manually fix them (if it is a *very* simple fix), or else you will need to find which additional PR this patch depends on, and restart the bug fix process including this additional patch.; This generally should not happen if you are sticking to very small bug fixes; if the fixes had far-reaching changes, a new minor release may be more appropriate.; #. Change the ``VERSION`` file by bumping the last number up by one (double-digit numbers are fine, so ``4.6.10`` comes after ``4.6.9``), and commit the change.; #. Push this branch to your fork, and make a pull request against the release branch.; On GitHub in the PR screen, you will need to change the ""Base"" branch to ``qutip-4.6.X`` (or whatever version), because GitHub will default to making it against ``master``.; It should be quite clear if you have forgotten to do this, because there will probably be many merge conflicts.; Once the tests have passed and you have another admin's approval, merge the PR. You should now see that the ``qutip-4.6.X`` (or whatever) branch on GitHub has been updated, and now includes all the changes you have just made.; If you have made a mistake, feel free to make additonal PRs to rectify the situation. You are now ready to actually perform the release.; Go to deploy_. .. _deploy:. Build Release Distribution and Deploy; +++++++++++++++++++++++++++++++++++++. This step builds the source (sdist) and binary (wheel) distributions, and uploads them to PyPI (pip).; You will also be able to download the built files yourself in order to upload them to the QuTiP ",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:11489,Deployability,update,updated,11489,"u will need to find which additional PR this patch depends on, and restart the bug fix process including this additional patch.; This generally should not happen if you are sticking to very small bug fixes; if the fixes had far-reaching changes, a new minor release may be more appropriate.; #. Change the ``VERSION`` file by bumping the last number up by one (double-digit numbers are fine, so ``4.6.10`` comes after ``4.6.9``), and commit the change.; #. Push this branch to your fork, and make a pull request against the release branch.; On GitHub in the PR screen, you will need to change the ""Base"" branch to ``qutip-4.6.X`` (or whatever version), because GitHub will default to making it against ``master``.; It should be quite clear if you have forgotten to do this, because there will probably be many merge conflicts.; Once the tests have passed and you have another admin's approval, merge the PR. You should now see that the ``qutip-4.6.X`` (or whatever) branch on GitHub has been updated, and now includes all the changes you have just made.; If you have made a mistake, feel free to make additonal PRs to rectify the situation. You are now ready to actually perform the release.; Go to deploy_. .. _deploy:. Build Release Distribution and Deploy; +++++++++++++++++++++++++++++++++++++. This step builds the source (sdist) and binary (wheel) distributions, and uploads them to PyPI (pip).; You will also be able to download the built files yourself in order to upload them to the QuTiP website. Build and Deploy; ----------------. This is handled entirely by a GitHub Action.; Go to the `""Actions"" tab at the top of the QuTiP code repository <https://github.com/qutip/qutip/actions>`_.; Click on the ""Build wheels, optionally deploy to PyPI"" action in the left-hand sidebar.; Click the ""Run workflow"" dropdown in the header notification; it should look like the image below. .. image:: ../figures/release_guide_run_build_workflow.png. - Use the drop-down menu to choose the branch or tag y",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:11680,Deployability,release,release,11680,"you are sticking to very small bug fixes; if the fixes had far-reaching changes, a new minor release may be more appropriate.; #. Change the ``VERSION`` file by bumping the last number up by one (double-digit numbers are fine, so ``4.6.10`` comes after ``4.6.9``), and commit the change.; #. Push this branch to your fork, and make a pull request against the release branch.; On GitHub in the PR screen, you will need to change the ""Base"" branch to ``qutip-4.6.X`` (or whatever version), because GitHub will default to making it against ``master``.; It should be quite clear if you have forgotten to do this, because there will probably be many merge conflicts.; Once the tests have passed and you have another admin's approval, merge the PR. You should now see that the ``qutip-4.6.X`` (or whatever) branch on GitHub has been updated, and now includes all the changes you have just made.; If you have made a mistake, feel free to make additonal PRs to rectify the situation. You are now ready to actually perform the release.; Go to deploy_. .. _deploy:. Build Release Distribution and Deploy; +++++++++++++++++++++++++++++++++++++. This step builds the source (sdist) and binary (wheel) distributions, and uploads them to PyPI (pip).; You will also be able to download the built files yourself in order to upload them to the QuTiP website. Build and Deploy; ----------------. This is handled entirely by a GitHub Action.; Go to the `""Actions"" tab at the top of the QuTiP code repository <https://github.com/qutip/qutip/actions>`_.; Click on the ""Build wheels, optionally deploy to PyPI"" action in the left-hand sidebar.; Click the ""Run workflow"" dropdown in the header notification; it should look like the image below. .. image:: ../figures/release_guide_run_build_workflow.png. - Use the drop-down menu to choose the branch or tag you want to release from.; This should be called ``qutip-4.5.X`` or similar, depending on what you made earlier.; This must *never* be ``master``.; - To make the rele",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:12235,Deployability,deploy,deploy,12235,"f you have forgotten to do this, because there will probably be many merge conflicts.; Once the tests have passed and you have another admin's approval, merge the PR. You should now see that the ``qutip-4.6.X`` (or whatever) branch on GitHub has been updated, and now includes all the changes you have just made.; If you have made a mistake, feel free to make additonal PRs to rectify the situation. You are now ready to actually perform the release.; Go to deploy_. .. _deploy:. Build Release Distribution and Deploy; +++++++++++++++++++++++++++++++++++++. This step builds the source (sdist) and binary (wheel) distributions, and uploads them to PyPI (pip).; You will also be able to download the built files yourself in order to upload them to the QuTiP website. Build and Deploy; ----------------. This is handled entirely by a GitHub Action.; Go to the `""Actions"" tab at the top of the QuTiP code repository <https://github.com/qutip/qutip/actions>`_.; Click on the ""Build wheels, optionally deploy to PyPI"" action in the left-hand sidebar.; Click the ""Run workflow"" dropdown in the header notification; it should look like the image below. .. image:: ../figures/release_guide_run_build_workflow.png. - Use the drop-down menu to choose the branch or tag you want to release from.; This should be called ``qutip-4.5.X`` or similar, depending on what you made earlier.; This must *never* be ``master``.; - To make the release to PyPI, type the branch name (e.g. ``qutip-4.5.X``) into the ""Confirm chosen branch name [...]"" field.; You *may* leave this field blank to skip the deployment and only build the package.; - (Special circumstances) If for some reason you need to override the version number (for example if the previous deployment to PyPI only partially succeeded), you can type a valid Python version identifier into the ""Override version number"" field.; You probably do not need to do this.; The mechanism is designed to make alpha-testing major upgrades with nightly releases easier.; ",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:12509,Deployability,release,release,12509,"s been updated, and now includes all the changes you have just made.; If you have made a mistake, feel free to make additonal PRs to rectify the situation. You are now ready to actually perform the release.; Go to deploy_. .. _deploy:. Build Release Distribution and Deploy; +++++++++++++++++++++++++++++++++++++. This step builds the source (sdist) and binary (wheel) distributions, and uploads them to PyPI (pip).; You will also be able to download the built files yourself in order to upload them to the QuTiP website. Build and Deploy; ----------------. This is handled entirely by a GitHub Action.; Go to the `""Actions"" tab at the top of the QuTiP code repository <https://github.com/qutip/qutip/actions>`_.; Click on the ""Build wheels, optionally deploy to PyPI"" action in the left-hand sidebar.; Click the ""Run workflow"" dropdown in the header notification; it should look like the image below. .. image:: ../figures/release_guide_run_build_workflow.png. - Use the drop-down menu to choose the branch or tag you want to release from.; This should be called ``qutip-4.5.X`` or similar, depending on what you made earlier.; This must *never* be ``master``.; - To make the release to PyPI, type the branch name (e.g. ``qutip-4.5.X``) into the ""Confirm chosen branch name [...]"" field.; You *may* leave this field blank to skip the deployment and only build the package.; - (Special circumstances) If for some reason you need to override the version number (for example if the previous deployment to PyPI only partially succeeded), you can type a valid Python version identifier into the ""Override version number"" field.; You probably do not need to do this.; The mechanism is designed to make alpha-testing major upgrades with nightly releases easier.; For even a bugfix release, you should commit the change to the ``VERSION`` file.; - Click the lower ""Run workflow"" to perform the build and deployment. At this point, the deployment will take care of itself.; It should take between 30 minutes a",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:12659,Deployability,release,release,12659,"form the release.; Go to deploy_. .. _deploy:. Build Release Distribution and Deploy; +++++++++++++++++++++++++++++++++++++. This step builds the source (sdist) and binary (wheel) distributions, and uploads them to PyPI (pip).; You will also be able to download the built files yourself in order to upload them to the QuTiP website. Build and Deploy; ----------------. This is handled entirely by a GitHub Action.; Go to the `""Actions"" tab at the top of the QuTiP code repository <https://github.com/qutip/qutip/actions>`_.; Click on the ""Build wheels, optionally deploy to PyPI"" action in the left-hand sidebar.; Click the ""Run workflow"" dropdown in the header notification; it should look like the image below. .. image:: ../figures/release_guide_run_build_workflow.png. - Use the drop-down menu to choose the branch or tag you want to release from.; This should be called ``qutip-4.5.X`` or similar, depending on what you made earlier.; This must *never* be ``master``.; - To make the release to PyPI, type the branch name (e.g. ``qutip-4.5.X``) into the ""Confirm chosen branch name [...]"" field.; You *may* leave this field blank to skip the deployment and only build the package.; - (Special circumstances) If for some reason you need to override the version number (for example if the previous deployment to PyPI only partially succeeded), you can type a valid Python version identifier into the ""Override version number"" field.; You probably do not need to do this.; The mechanism is designed to make alpha-testing major upgrades with nightly releases easier.; For even a bugfix release, you should commit the change to the ``VERSION`` file.; - Click the lower ""Run workflow"" to perform the build and deployment. At this point, the deployment will take care of itself.; It should take between 30 minutes and an hour, after which the new version will be available for install by ``pip install qutip``.; You should see the new version appear on `QuTiP's PyPI page <https://pypi.org/project/qutip>",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:12817,Deployability,deploy,deployment,12817," the source (sdist) and binary (wheel) distributions, and uploads them to PyPI (pip).; You will also be able to download the built files yourself in order to upload them to the QuTiP website. Build and Deploy; ----------------. This is handled entirely by a GitHub Action.; Go to the `""Actions"" tab at the top of the QuTiP code repository <https://github.com/qutip/qutip/actions>`_.; Click on the ""Build wheels, optionally deploy to PyPI"" action in the left-hand sidebar.; Click the ""Run workflow"" dropdown in the header notification; it should look like the image below. .. image:: ../figures/release_guide_run_build_workflow.png. - Use the drop-down menu to choose the branch or tag you want to release from.; This should be called ``qutip-4.5.X`` or similar, depending on what you made earlier.; This must *never* be ``master``.; - To make the release to PyPI, type the branch name (e.g. ``qutip-4.5.X``) into the ""Confirm chosen branch name [...]"" field.; You *may* leave this field blank to skip the deployment and only build the package.; - (Special circumstances) If for some reason you need to override the version number (for example if the previous deployment to PyPI only partially succeeded), you can type a valid Python version identifier into the ""Override version number"" field.; You probably do not need to do this.; The mechanism is designed to make alpha-testing major upgrades with nightly releases easier.; For even a bugfix release, you should commit the change to the ``VERSION`` file.; - Click the lower ""Run workflow"" to perform the build and deployment. At this point, the deployment will take care of itself.; It should take between 30 minutes and an hour, after which the new version will be available for install by ``pip install qutip``.; You should see the new version appear on `QuTiP's PyPI page <https://pypi.org/project/qutip>`_. Download Built Files; --------------------. When the build is complete, click into its summary screen.; This is the main screen used to b",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:12971,Deployability,deploy,deployment,12971,"m to the QuTiP website. Build and Deploy; ----------------. This is handled entirely by a GitHub Action.; Go to the `""Actions"" tab at the top of the QuTiP code repository <https://github.com/qutip/qutip/actions>`_.; Click on the ""Build wheels, optionally deploy to PyPI"" action in the left-hand sidebar.; Click the ""Run workflow"" dropdown in the header notification; it should look like the image below. .. image:: ../figures/release_guide_run_build_workflow.png. - Use the drop-down menu to choose the branch or tag you want to release from.; This should be called ``qutip-4.5.X`` or similar, depending on what you made earlier.; This must *never* be ``master``.; - To make the release to PyPI, type the branch name (e.g. ``qutip-4.5.X``) into the ""Confirm chosen branch name [...]"" field.; You *may* leave this field blank to skip the deployment and only build the package.; - (Special circumstances) If for some reason you need to override the version number (for example if the previous deployment to PyPI only partially succeeded), you can type a valid Python version identifier into the ""Override version number"" field.; You probably do not need to do this.; The mechanism is designed to make alpha-testing major upgrades with nightly releases easier.; For even a bugfix release, you should commit the change to the ``VERSION`` file.; - Click the lower ""Run workflow"" to perform the build and deployment. At this point, the deployment will take care of itself.; It should take between 30 minutes and an hour, after which the new version will be available for install by ``pip install qutip``.; You should see the new version appear on `QuTiP's PyPI page <https://pypi.org/project/qutip>`_. Download Built Files; --------------------. When the build is complete, click into its summary screen.; This is the main screen used to both monitor the build and see its output, and should look like the below image on a success. .. image:: ../figures/release_guide_after_workflow.png. The built binary w",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:13199,Deployability,upgrade,upgrades,13199,">`_.; Click on the ""Build wheels, optionally deploy to PyPI"" action in the left-hand sidebar.; Click the ""Run workflow"" dropdown in the header notification; it should look like the image below. .. image:: ../figures/release_guide_run_build_workflow.png. - Use the drop-down menu to choose the branch or tag you want to release from.; This should be called ``qutip-4.5.X`` or similar, depending on what you made earlier.; This must *never* be ``master``.; - To make the release to PyPI, type the branch name (e.g. ``qutip-4.5.X``) into the ""Confirm chosen branch name [...]"" field.; You *may* leave this field blank to skip the deployment and only build the package.; - (Special circumstances) If for some reason you need to override the version number (for example if the previous deployment to PyPI only partially succeeded), you can type a valid Python version identifier into the ""Override version number"" field.; You probably do not need to do this.; The mechanism is designed to make alpha-testing major upgrades with nightly releases easier.; For even a bugfix release, you should commit the change to the ``VERSION`` file.; - Click the lower ""Run workflow"" to perform the build and deployment. At this point, the deployment will take care of itself.; It should take between 30 minutes and an hour, after which the new version will be available for install by ``pip install qutip``.; You should see the new version appear on `QuTiP's PyPI page <https://pypi.org/project/qutip>`_. Download Built Files; --------------------. When the build is complete, click into its summary screen.; This is the main screen used to both monitor the build and see its output, and should look like the below image on a success. .. image:: ../figures/release_guide_after_workflow.png. The built binary wheels and the source distribution are the ""build artifacts"" at the bottom.; You need to download both the wheels and the source distribution.; Save them on your computer, and unzip both files; you should have m",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:13221,Deployability,release,releases,13221,">`_.; Click on the ""Build wheels, optionally deploy to PyPI"" action in the left-hand sidebar.; Click the ""Run workflow"" dropdown in the header notification; it should look like the image below. .. image:: ../figures/release_guide_run_build_workflow.png. - Use the drop-down menu to choose the branch or tag you want to release from.; This should be called ``qutip-4.5.X`` or similar, depending on what you made earlier.; This must *never* be ``master``.; - To make the release to PyPI, type the branch name (e.g. ``qutip-4.5.X``) into the ""Confirm chosen branch name [...]"" field.; You *may* leave this field blank to skip the deployment and only build the package.; - (Special circumstances) If for some reason you need to override the version number (for example if the previous deployment to PyPI only partially succeeded), you can type a valid Python version identifier into the ""Override version number"" field.; You probably do not need to do this.; The mechanism is designed to make alpha-testing major upgrades with nightly releases easier.; For even a bugfix release, you should commit the change to the ``VERSION`` file.; - Click the lower ""Run workflow"" to perform the build and deployment. At this point, the deployment will take care of itself.; It should take between 30 minutes and an hour, after which the new version will be available for install by ``pip install qutip``.; You should see the new version appear on `QuTiP's PyPI page <https://pypi.org/project/qutip>`_. Download Built Files; --------------------. When the build is complete, click into its summary screen.; This is the main screen used to both monitor the build and see its output, and should look like the below image on a success. .. image:: ../figures/release_guide_after_workflow.png. The built binary wheels and the source distribution are the ""build artifacts"" at the bottom.; You need to download both the wheels and the source distribution.; Save them on your computer, and unzip both files; you should have m",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:13257,Deployability,release,release,13257,"ebar.; Click the ""Run workflow"" dropdown in the header notification; it should look like the image below. .. image:: ../figures/release_guide_run_build_workflow.png. - Use the drop-down menu to choose the branch or tag you want to release from.; This should be called ``qutip-4.5.X`` or similar, depending on what you made earlier.; This must *never* be ``master``.; - To make the release to PyPI, type the branch name (e.g. ``qutip-4.5.X``) into the ""Confirm chosen branch name [...]"" field.; You *may* leave this field blank to skip the deployment and only build the package.; - (Special circumstances) If for some reason you need to override the version number (for example if the previous deployment to PyPI only partially succeeded), you can type a valid Python version identifier into the ""Override version number"" field.; You probably do not need to do this.; The mechanism is designed to make alpha-testing major upgrades with nightly releases easier.; For even a bugfix release, you should commit the change to the ``VERSION`` file.; - Click the lower ""Run workflow"" to perform the build and deployment. At this point, the deployment will take care of itself.; It should take between 30 minutes and an hour, after which the new version will be available for install by ``pip install qutip``.; You should see the new version appear on `QuTiP's PyPI page <https://pypi.org/project/qutip>`_. Download Built Files; --------------------. When the build is complete, click into its summary screen.; This is the main screen used to both monitor the build and see its output, and should look like the below image on a success. .. image:: ../figures/release_guide_after_workflow.png. The built binary wheels and the source distribution are the ""build artifacts"" at the bottom.; You need to download both the wheels and the source distribution.; Save them on your computer, and unzip both files; you should have many wheel ``qutip-*.whl`` files, and two sdist files: ``qutip-*.tar.gz`` and ``qutip-*.z",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:13379,Deployability,deploy,deployment,13379,"ld look like the image below. .. image:: ../figures/release_guide_run_build_workflow.png. - Use the drop-down menu to choose the branch or tag you want to release from.; This should be called ``qutip-4.5.X`` or similar, depending on what you made earlier.; This must *never* be ``master``.; - To make the release to PyPI, type the branch name (e.g. ``qutip-4.5.X``) into the ""Confirm chosen branch name [...]"" field.; You *may* leave this field blank to skip the deployment and only build the package.; - (Special circumstances) If for some reason you need to override the version number (for example if the previous deployment to PyPI only partially succeeded), you can type a valid Python version identifier into the ""Override version number"" field.; You probably do not need to do this.; The mechanism is designed to make alpha-testing major upgrades with nightly releases easier.; For even a bugfix release, you should commit the change to the ``VERSION`` file.; - Click the lower ""Run workflow"" to perform the build and deployment. At this point, the deployment will take care of itself.; It should take between 30 minutes and an hour, after which the new version will be available for install by ``pip install qutip``.; You should see the new version appear on `QuTiP's PyPI page <https://pypi.org/project/qutip>`_. Download Built Files; --------------------. When the build is complete, click into its summary screen.; This is the main screen used to both monitor the build and see its output, and should look like the below image on a success. .. image:: ../figures/release_guide_after_workflow.png. The built binary wheels and the source distribution are the ""build artifacts"" at the bottom.; You need to download both the wheels and the source distribution.; Save them on your computer, and unzip both files; you should have many wheel ``qutip-*.whl`` files, and two sdist files: ``qutip-*.tar.gz`` and ``qutip-*.zip``.; These are the same files that have just been uploaded to PyPI. Monitor",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:13410,Deployability,deploy,deployment,13410,"e_run_build_workflow.png. - Use the drop-down menu to choose the branch or tag you want to release from.; This should be called ``qutip-4.5.X`` or similar, depending on what you made earlier.; This must *never* be ``master``.; - To make the release to PyPI, type the branch name (e.g. ``qutip-4.5.X``) into the ""Confirm chosen branch name [...]"" field.; You *may* leave this field blank to skip the deployment and only build the package.; - (Special circumstances) If for some reason you need to override the version number (for example if the previous deployment to PyPI only partially succeeded), you can type a valid Python version identifier into the ""Override version number"" field.; You probably do not need to do this.; The mechanism is designed to make alpha-testing major upgrades with nightly releases easier.; For even a bugfix release, you should commit the change to the ``VERSION`` file.; - Click the lower ""Run workflow"" to perform the build and deployment. At this point, the deployment will take care of itself.; It should take between 30 minutes and an hour, after which the new version will be available for install by ``pip install qutip``.; You should see the new version appear on `QuTiP's PyPI page <https://pypi.org/project/qutip>`_. Download Built Files; --------------------. When the build is complete, click into its summary screen.; This is the main screen used to both monitor the build and see its output, and should look like the below image on a success. .. image:: ../figures/release_guide_after_workflow.png. The built binary wheels and the source distribution are the ""build artifacts"" at the bottom.; You need to download both the wheels and the source distribution.; Save them on your computer, and unzip both files; you should have many wheel ``qutip-*.whl`` files, and two sdist files: ``qutip-*.tar.gz`` and ``qutip-*.zip``.; These are the same files that have just been uploaded to PyPI. Monitoring Progress (optional); ------------------------------. While ",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:13545,Deployability,install,install,13545,"ease from.; This should be called ``qutip-4.5.X`` or similar, depending on what you made earlier.; This must *never* be ``master``.; - To make the release to PyPI, type the branch name (e.g. ``qutip-4.5.X``) into the ""Confirm chosen branch name [...]"" field.; You *may* leave this field blank to skip the deployment and only build the package.; - (Special circumstances) If for some reason you need to override the version number (for example if the previous deployment to PyPI only partially succeeded), you can type a valid Python version identifier into the ""Override version number"" field.; You probably do not need to do this.; The mechanism is designed to make alpha-testing major upgrades with nightly releases easier.; For even a bugfix release, you should commit the change to the ``VERSION`` file.; - Click the lower ""Run workflow"" to perform the build and deployment. At this point, the deployment will take care of itself.; It should take between 30 minutes and an hour, after which the new version will be available for install by ``pip install qutip``.; You should see the new version appear on `QuTiP's PyPI page <https://pypi.org/project/qutip>`_. Download Built Files; --------------------. When the build is complete, click into its summary screen.; This is the main screen used to both monitor the build and see its output, and should look like the below image on a success. .. image:: ../figures/release_guide_after_workflow.png. The built binary wheels and the source distribution are the ""build artifacts"" at the bottom.; You need to download both the wheels and the source distribution.; Save them on your computer, and unzip both files; you should have many wheel ``qutip-*.whl`` files, and two sdist files: ``qutip-*.tar.gz`` and ``qutip-*.zip``.; These are the same files that have just been uploaded to PyPI. Monitoring Progress (optional); ------------------------------. While the build is in progress, you can monitor its progress by clicking on its entry in the list be",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:13562,Deployability,install,install,13562,"ease from.; This should be called ``qutip-4.5.X`` or similar, depending on what you made earlier.; This must *never* be ``master``.; - To make the release to PyPI, type the branch name (e.g. ``qutip-4.5.X``) into the ""Confirm chosen branch name [...]"" field.; You *may* leave this field blank to skip the deployment and only build the package.; - (Special circumstances) If for some reason you need to override the version number (for example if the previous deployment to PyPI only partially succeeded), you can type a valid Python version identifier into the ""Override version number"" field.; You probably do not need to do this.; The mechanism is designed to make alpha-testing major upgrades with nightly releases easier.; For even a bugfix release, you should commit the change to the ``VERSION`` file.; - Click the lower ""Run workflow"" to perform the build and deployment. At this point, the deployment will take care of itself.; It should take between 30 minutes and an hour, after which the new version will be available for install by ``pip install qutip``.; You should see the new version appear on `QuTiP's PyPI page <https://pypi.org/project/qutip>`_. Download Built Files; --------------------. When the build is complete, click into its summary screen.; This is the main screen used to both monitor the build and see its output, and should look like the below image on a success. .. image:: ../figures/release_guide_after_workflow.png. The built binary wheels and the source distribution are the ""build artifacts"" at the bottom.; You need to download both the wheels and the source distribution.; Save them on your computer, and unzip both files; you should have many wheel ``qutip-*.whl`` files, and two sdist files: ``qutip-*.tar.gz`` and ``qutip-*.zip``.; These are the same files that have just been uploaded to PyPI. Monitoring Progress (optional); ------------------------------. While the build is in progress, you can monitor its progress by clicking on its entry in the list be",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:14660,Deployability,deploy,deployment,14660,"load Built Files; --------------------. When the build is complete, click into its summary screen.; This is the main screen used to both monitor the build and see its output, and should look like the below image on a success. .. image:: ../figures/release_guide_after_workflow.png. The built binary wheels and the source distribution are the ""build artifacts"" at the bottom.; You need to download both the wheels and the source distribution.; Save them on your computer, and unzip both files; you should have many wheel ``qutip-*.whl`` files, and two sdist files: ``qutip-*.tar.gz`` and ``qutip-*.zip``.; These are the same files that have just been uploaded to PyPI. Monitoring Progress (optional); ------------------------------. While the build is in progress, you can monitor its progress by clicking on its entry in the list below the ""Run workflow"" button.; You should see several subjobs, like the completed screen, except they might not yet be completed. The ""Verify PyPI deployment confirmation"" should get ticked, no matter what.; If it fails, you have forgotten to choose the correct branch in the drop-down menu or you made a typo when confirming the correct branch, and you will need to restart this step.; You can check that the deployment instruction has been understood by clicking the ""Verify PyPI deployment confirmation"" job, and opening the ""Compare confirmation to current reference"" subjob.; You will see a message saying ""Built wheels will be deployed"" if you typed in the confirmation, or ""Only building wheels"" if you did not.; If you see ""Only building wheels"" but you meant to deploy the release to PyPI, you can cancel the workflow and re-run it after typing the confirmation. .. _github:. Making a Release on GitHub; ++++++++++++++++++++++++++. This is all done through `the ""Releases"" section <https://github.com/qutip/qutip/releases>`_ of the ``qutip/qutip`` repository on GitHub. - Click the ""Draft a new release"" button.; - Choose the correct branch for your release (",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:14923,Deployability,deploy,deployment,14923,"ource distribution are the ""build artifacts"" at the bottom.; You need to download both the wheels and the source distribution.; Save them on your computer, and unzip both files; you should have many wheel ``qutip-*.whl`` files, and two sdist files: ``qutip-*.tar.gz`` and ``qutip-*.zip``.; These are the same files that have just been uploaded to PyPI. Monitoring Progress (optional); ------------------------------. While the build is in progress, you can monitor its progress by clicking on its entry in the list below the ""Run workflow"" button.; You should see several subjobs, like the completed screen, except they might not yet be completed. The ""Verify PyPI deployment confirmation"" should get ticked, no matter what.; If it fails, you have forgotten to choose the correct branch in the drop-down menu or you made a typo when confirming the correct branch, and you will need to restart this step.; You can check that the deployment instruction has been understood by clicking the ""Verify PyPI deployment confirmation"" job, and opening the ""Compare confirmation to current reference"" subjob.; You will see a message saying ""Built wheels will be deployed"" if you typed in the confirmation, or ""Only building wheels"" if you did not.; If you see ""Only building wheels"" but you meant to deploy the release to PyPI, you can cancel the workflow and re-run it after typing the confirmation. .. _github:. Making a Release on GitHub; ++++++++++++++++++++++++++. This is all done through `the ""Releases"" section <https://github.com/qutip/qutip/releases>`_ of the ``qutip/qutip`` repository on GitHub. - Click the ""Draft a new release"" button.; - Choose the correct branch for your release (e.g. ``qutip-4.5.X``) in the drop-down.; - For the tag name, use ``v<your-version>``, where the version matches the contents of the ``VERSION`` file.; In other words, if you are releasing a micro version 4.5.3, use ``v4.5.3`` as the tag, or if you are releasing major version 5.0.0, use ``v5.0.0``.; - The title is",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:14995,Deployability,deploy,deployment,14995,"ource distribution are the ""build artifacts"" at the bottom.; You need to download both the wheels and the source distribution.; Save them on your computer, and unzip both files; you should have many wheel ``qutip-*.whl`` files, and two sdist files: ``qutip-*.tar.gz`` and ``qutip-*.zip``.; These are the same files that have just been uploaded to PyPI. Monitoring Progress (optional); ------------------------------. While the build is in progress, you can monitor its progress by clicking on its entry in the list below the ""Run workflow"" button.; You should see several subjobs, like the completed screen, except they might not yet be completed. The ""Verify PyPI deployment confirmation"" should get ticked, no matter what.; If it fails, you have forgotten to choose the correct branch in the drop-down menu or you made a typo when confirming the correct branch, and you will need to restart this step.; You can check that the deployment instruction has been understood by clicking the ""Verify PyPI deployment confirmation"" job, and opening the ""Compare confirmation to current reference"" subjob.; You will see a message saying ""Built wheels will be deployed"" if you typed in the confirmation, or ""Only building wheels"" if you did not.; If you see ""Only building wheels"" but you meant to deploy the release to PyPI, you can cancel the workflow and re-run it after typing the confirmation. .. _github:. Making a Release on GitHub; ++++++++++++++++++++++++++. This is all done through `the ""Releases"" section <https://github.com/qutip/qutip/releases>`_ of the ``qutip/qutip`` repository on GitHub. - Click the ""Draft a new release"" button.; - Choose the correct branch for your release (e.g. ``qutip-4.5.X``) in the drop-down.; - For the tag name, use ``v<your-version>``, where the version matches the contents of the ``VERSION`` file.; In other words, if you are releasing a micro version 4.5.3, use ``v4.5.3`` as the tag, or if you are releasing major version 5.0.0, use ``v5.0.0``.; - The title is",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:15146,Deployability,deploy,deployed,15146,"both files; you should have many wheel ``qutip-*.whl`` files, and two sdist files: ``qutip-*.tar.gz`` and ``qutip-*.zip``.; These are the same files that have just been uploaded to PyPI. Monitoring Progress (optional); ------------------------------. While the build is in progress, you can monitor its progress by clicking on its entry in the list below the ""Run workflow"" button.; You should see several subjobs, like the completed screen, except they might not yet be completed. The ""Verify PyPI deployment confirmation"" should get ticked, no matter what.; If it fails, you have forgotten to choose the correct branch in the drop-down menu or you made a typo when confirming the correct branch, and you will need to restart this step.; You can check that the deployment instruction has been understood by clicking the ""Verify PyPI deployment confirmation"" job, and opening the ""Compare confirmation to current reference"" subjob.; You will see a message saying ""Built wheels will be deployed"" if you typed in the confirmation, or ""Only building wheels"" if you did not.; If you see ""Only building wheels"" but you meant to deploy the release to PyPI, you can cancel the workflow and re-run it after typing the confirmation. .. _github:. Making a Release on GitHub; ++++++++++++++++++++++++++. This is all done through `the ""Releases"" section <https://github.com/qutip/qutip/releases>`_ of the ``qutip/qutip`` repository on GitHub. - Click the ""Draft a new release"" button.; - Choose the correct branch for your release (e.g. ``qutip-4.5.X``) in the drop-down.; - For the tag name, use ``v<your-version>``, where the version matches the contents of the ``VERSION`` file.; In other words, if you are releasing a micro version 4.5.3, use ``v4.5.3`` as the tag, or if you are releasing major version 5.0.0, use ``v5.0.0``.; - The title is ""QuTiP <your-version>"", e.g. ""QuTiP 4.6.0"".; - For the description, write a short (~two-line for a patch release) summary of the reason for this release, and note dow",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:15284,Deployability,deploy,deploy,15284,"es that have just been uploaded to PyPI. Monitoring Progress (optional); ------------------------------. While the build is in progress, you can monitor its progress by clicking on its entry in the list below the ""Run workflow"" button.; You should see several subjobs, like the completed screen, except they might not yet be completed. The ""Verify PyPI deployment confirmation"" should get ticked, no matter what.; If it fails, you have forgotten to choose the correct branch in the drop-down menu or you made a typo when confirming the correct branch, and you will need to restart this step.; You can check that the deployment instruction has been understood by clicking the ""Verify PyPI deployment confirmation"" job, and opening the ""Compare confirmation to current reference"" subjob.; You will see a message saying ""Built wheels will be deployed"" if you typed in the confirmation, or ""Only building wheels"" if you did not.; If you see ""Only building wheels"" but you meant to deploy the release to PyPI, you can cancel the workflow and re-run it after typing the confirmation. .. _github:. Making a Release on GitHub; ++++++++++++++++++++++++++. This is all done through `the ""Releases"" section <https://github.com/qutip/qutip/releases>`_ of the ``qutip/qutip`` repository on GitHub. - Click the ""Draft a new release"" button.; - Choose the correct branch for your release (e.g. ``qutip-4.5.X``) in the drop-down.; - For the tag name, use ``v<your-version>``, where the version matches the contents of the ``VERSION`` file.; In other words, if you are releasing a micro version 4.5.3, use ``v4.5.3`` as the tag, or if you are releasing major version 5.0.0, use ``v5.0.0``.; - The title is ""QuTiP <your-version>"", e.g. ""QuTiP 4.6.0"".; - For the description, write a short (~two-line for a patch release) summary of the reason for this release, and note down any particular user-facing changes that need special attention.; Underneath, put the changelog you wrote when you did the documentation release.",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:15295,Deployability,release,release,15295,"es that have just been uploaded to PyPI. Monitoring Progress (optional); ------------------------------. While the build is in progress, you can monitor its progress by clicking on its entry in the list below the ""Run workflow"" button.; You should see several subjobs, like the completed screen, except they might not yet be completed. The ""Verify PyPI deployment confirmation"" should get ticked, no matter what.; If it fails, you have forgotten to choose the correct branch in the drop-down menu or you made a typo when confirming the correct branch, and you will need to restart this step.; You can check that the deployment instruction has been understood by clicking the ""Verify PyPI deployment confirmation"" job, and opening the ""Compare confirmation to current reference"" subjob.; You will see a message saying ""Built wheels will be deployed"" if you typed in the confirmation, or ""Only building wheels"" if you did not.; If you see ""Only building wheels"" but you meant to deploy the release to PyPI, you can cancel the workflow and re-run it after typing the confirmation. .. _github:. Making a Release on GitHub; ++++++++++++++++++++++++++. This is all done through `the ""Releases"" section <https://github.com/qutip/qutip/releases>`_ of the ``qutip/qutip`` repository on GitHub. - Click the ""Draft a new release"" button.; - Choose the correct branch for your release (e.g. ``qutip-4.5.X``) in the drop-down.; - For the tag name, use ``v<your-version>``, where the version matches the contents of the ``VERSION`` file.; In other words, if you are releasing a micro version 4.5.3, use ``v4.5.3`` as the tag, or if you are releasing major version 5.0.0, use ``v5.0.0``.; - The title is ""QuTiP <your-version>"", e.g. ""QuTiP 4.6.0"".; - For the description, write a short (~two-line for a patch release) summary of the reason for this release, and note down any particular user-facing changes that need special attention.; Underneath, put the changelog you wrote when you did the documentation release.",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:15535,Deployability,release,releases,15535,"see several subjobs, like the completed screen, except they might not yet be completed. The ""Verify PyPI deployment confirmation"" should get ticked, no matter what.; If it fails, you have forgotten to choose the correct branch in the drop-down menu or you made a typo when confirming the correct branch, and you will need to restart this step.; You can check that the deployment instruction has been understood by clicking the ""Verify PyPI deployment confirmation"" job, and opening the ""Compare confirmation to current reference"" subjob.; You will see a message saying ""Built wheels will be deployed"" if you typed in the confirmation, or ""Only building wheels"" if you did not.; If you see ""Only building wheels"" but you meant to deploy the release to PyPI, you can cancel the workflow and re-run it after typing the confirmation. .. _github:. Making a Release on GitHub; ++++++++++++++++++++++++++. This is all done through `the ""Releases"" section <https://github.com/qutip/qutip/releases>`_ of the ``qutip/qutip`` repository on GitHub. - Click the ""Draft a new release"" button.; - Choose the correct branch for your release (e.g. ``qutip-4.5.X``) in the drop-down.; - For the tag name, use ``v<your-version>``, where the version matches the contents of the ``VERSION`` file.; In other words, if you are releasing a micro version 4.5.3, use ``v4.5.3`` as the tag, or if you are releasing major version 5.0.0, use ``v5.0.0``.; - The title is ""QuTiP <your-version>"", e.g. ""QuTiP 4.6.0"".; - For the description, write a short (~two-line for a patch release) summary of the reason for this release, and note down any particular user-facing changes that need special attention.; Underneath, put the changelog you wrote when you did the documentation release.; Note that there may be some syntax differences between the ``.rst`` file of the changelog and the Markdown of this description field (for example, GitHub's markdown typically maintains hard-wrap linebreaks, which is probably not what you wanted)",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:15617,Deployability,release,release,15617,"ey might not yet be completed. The ""Verify PyPI deployment confirmation"" should get ticked, no matter what.; If it fails, you have forgotten to choose the correct branch in the drop-down menu or you made a typo when confirming the correct branch, and you will need to restart this step.; You can check that the deployment instruction has been understood by clicking the ""Verify PyPI deployment confirmation"" job, and opening the ""Compare confirmation to current reference"" subjob.; You will see a message saying ""Built wheels will be deployed"" if you typed in the confirmation, or ""Only building wheels"" if you did not.; If you see ""Only building wheels"" but you meant to deploy the release to PyPI, you can cancel the workflow and re-run it after typing the confirmation. .. _github:. Making a Release on GitHub; ++++++++++++++++++++++++++. This is all done through `the ""Releases"" section <https://github.com/qutip/qutip/releases>`_ of the ``qutip/qutip`` repository on GitHub. - Click the ""Draft a new release"" button.; - Choose the correct branch for your release (e.g. ``qutip-4.5.X``) in the drop-down.; - For the tag name, use ``v<your-version>``, where the version matches the contents of the ``VERSION`` file.; In other words, if you are releasing a micro version 4.5.3, use ``v4.5.3`` as the tag, or if you are releasing major version 5.0.0, use ``v5.0.0``.; - The title is ""QuTiP <your-version>"", e.g. ""QuTiP 4.6.0"".; - For the description, write a short (~two-line for a patch release) summary of the reason for this release, and note down any particular user-facing changes that need special attention.; Underneath, put the changelog you wrote when you did the documentation release.; Note that there may be some syntax differences between the ``.rst`` file of the changelog and the Markdown of this description field (for example, GitHub's markdown typically maintains hard-wrap linebreaks, which is probably not what you wanted).; - Drag-and-drop all the ``qutip-*.whl``, ``qutip-*.tar",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:15672,Deployability,release,release,15672,"I deployment confirmation"" should get ticked, no matter what.; If it fails, you have forgotten to choose the correct branch in the drop-down menu or you made a typo when confirming the correct branch, and you will need to restart this step.; You can check that the deployment instruction has been understood by clicking the ""Verify PyPI deployment confirmation"" job, and opening the ""Compare confirmation to current reference"" subjob.; You will see a message saying ""Built wheels will be deployed"" if you typed in the confirmation, or ""Only building wheels"" if you did not.; If you see ""Only building wheels"" but you meant to deploy the release to PyPI, you can cancel the workflow and re-run it after typing the confirmation. .. _github:. Making a Release on GitHub; ++++++++++++++++++++++++++. This is all done through `the ""Releases"" section <https://github.com/qutip/qutip/releases>`_ of the ``qutip/qutip`` repository on GitHub. - Click the ""Draft a new release"" button.; - Choose the correct branch for your release (e.g. ``qutip-4.5.X``) in the drop-down.; - For the tag name, use ``v<your-version>``, where the version matches the contents of the ``VERSION`` file.; In other words, if you are releasing a micro version 4.5.3, use ``v4.5.3`` as the tag, or if you are releasing major version 5.0.0, use ``v5.0.0``.; - The title is ""QuTiP <your-version>"", e.g. ""QuTiP 4.6.0"".; - For the description, write a short (~two-line for a patch release) summary of the reason for this release, and note down any particular user-facing changes that need special attention.; Underneath, put the changelog you wrote when you did the documentation release.; Note that there may be some syntax differences between the ``.rst`` file of the changelog and the Markdown of this description field (for example, GitHub's markdown typically maintains hard-wrap linebreaks, which is probably not what you wanted).; - Drag-and-drop all the ``qutip-*.whl``, ``qutip-*.tar.gz`` and ``qutip-*.zip`` files you got after ",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:16095,Deployability,patch,patch,16095,"eels will be deployed"" if you typed in the confirmation, or ""Only building wheels"" if you did not.; If you see ""Only building wheels"" but you meant to deploy the release to PyPI, you can cancel the workflow and re-run it after typing the confirmation. .. _github:. Making a Release on GitHub; ++++++++++++++++++++++++++. This is all done through `the ""Releases"" section <https://github.com/qutip/qutip/releases>`_ of the ``qutip/qutip`` repository on GitHub. - Click the ""Draft a new release"" button.; - Choose the correct branch for your release (e.g. ``qutip-4.5.X``) in the drop-down.; - For the tag name, use ``v<your-version>``, where the version matches the contents of the ``VERSION`` file.; In other words, if you are releasing a micro version 4.5.3, use ``v4.5.3`` as the tag, or if you are releasing major version 5.0.0, use ``v5.0.0``.; - The title is ""QuTiP <your-version>"", e.g. ""QuTiP 4.6.0"".; - For the description, write a short (~two-line for a patch release) summary of the reason for this release, and note down any particular user-facing changes that need special attention.; Underneath, put the changelog you wrote when you did the documentation release.; Note that there may be some syntax differences between the ``.rst`` file of the changelog and the Markdown of this description field (for example, GitHub's markdown typically maintains hard-wrap linebreaks, which is probably not what you wanted).; - Drag-and-drop all the ``qutip-*.whl``, ``qutip-*.tar.gz`` and ``qutip-*.zip`` files you got after the build step into the assets box.; You may need to unzip the files ``wheels.zip`` and ``sdist.zip`` to find them if you haven't already; **don't** upload those two zip files. Click on the ""Publish release"" button to finalise. .. _web:. Website; +++++++. This assumes that qutip.github.io has already been forked and familiarity with the website updating workflow.; The documentation need not be updated for every patch release. HTML File Updates; -----------------. - Edit ",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:16101,Deployability,release,release,16101,"eels will be deployed"" if you typed in the confirmation, or ""Only building wheels"" if you did not.; If you see ""Only building wheels"" but you meant to deploy the release to PyPI, you can cancel the workflow and re-run it after typing the confirmation. .. _github:. Making a Release on GitHub; ++++++++++++++++++++++++++. This is all done through `the ""Releases"" section <https://github.com/qutip/qutip/releases>`_ of the ``qutip/qutip`` repository on GitHub. - Click the ""Draft a new release"" button.; - Choose the correct branch for your release (e.g. ``qutip-4.5.X``) in the drop-down.; - For the tag name, use ``v<your-version>``, where the version matches the contents of the ``VERSION`` file.; In other words, if you are releasing a micro version 4.5.3, use ``v4.5.3`` as the tag, or if you are releasing major version 5.0.0, use ``v5.0.0``.; - The title is ""QuTiP <your-version>"", e.g. ""QuTiP 4.6.0"".; - For the description, write a short (~two-line for a patch release) summary of the reason for this release, and note down any particular user-facing changes that need special attention.; Underneath, put the changelog you wrote when you did the documentation release.; Note that there may be some syntax differences between the ``.rst`` file of the changelog and the Markdown of this description field (for example, GitHub's markdown typically maintains hard-wrap linebreaks, which is probably not what you wanted).; - Drag-and-drop all the ``qutip-*.whl``, ``qutip-*.tar.gz`` and ``qutip-*.zip`` files you got after the build step into the assets box.; You may need to unzip the files ``wheels.zip`` and ``sdist.zip`` to find them if you haven't already; **don't** upload those two zip files. Click on the ""Publish release"" button to finalise. .. _web:. Website; +++++++. This assumes that qutip.github.io has already been forked and familiarity with the website updating workflow.; The documentation need not be updated for every patch release. HTML File Updates; -----------------. - Edit ",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:16141,Deployability,release,release,16141,"eels will be deployed"" if you typed in the confirmation, or ""Only building wheels"" if you did not.; If you see ""Only building wheels"" but you meant to deploy the release to PyPI, you can cancel the workflow and re-run it after typing the confirmation. .. _github:. Making a Release on GitHub; ++++++++++++++++++++++++++. This is all done through `the ""Releases"" section <https://github.com/qutip/qutip/releases>`_ of the ``qutip/qutip`` repository on GitHub. - Click the ""Draft a new release"" button.; - Choose the correct branch for your release (e.g. ``qutip-4.5.X``) in the drop-down.; - For the tag name, use ``v<your-version>``, where the version matches the contents of the ``VERSION`` file.; In other words, if you are releasing a micro version 4.5.3, use ``v4.5.3`` as the tag, or if you are releasing major version 5.0.0, use ``v5.0.0``.; - The title is ""QuTiP <your-version>"", e.g. ""QuTiP 4.6.0"".; - For the description, write a short (~two-line for a patch release) summary of the reason for this release, and note down any particular user-facing changes that need special attention.; Underneath, put the changelog you wrote when you did the documentation release.; Note that there may be some syntax differences between the ``.rst`` file of the changelog and the Markdown of this description field (for example, GitHub's markdown typically maintains hard-wrap linebreaks, which is probably not what you wanted).; - Drag-and-drop all the ``qutip-*.whl``, ``qutip-*.tar.gz`` and ``qutip-*.zip`` files you got after the build step into the assets box.; You may need to unzip the files ``wheels.zip`` and ``sdist.zip`` to find them if you haven't already; **don't** upload those two zip files. Click on the ""Publish release"" button to finalise. .. _web:. Website; +++++++. This assumes that qutip.github.io has already been forked and familiarity with the website updating workflow.; The documentation need not be updated for every patch release. HTML File Updates; -----------------. - Edit ",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:16300,Deployability,release,release,16300,"but you meant to deploy the release to PyPI, you can cancel the workflow and re-run it after typing the confirmation. .. _github:. Making a Release on GitHub; ++++++++++++++++++++++++++. This is all done through `the ""Releases"" section <https://github.com/qutip/qutip/releases>`_ of the ``qutip/qutip`` repository on GitHub. - Click the ""Draft a new release"" button.; - Choose the correct branch for your release (e.g. ``qutip-4.5.X``) in the drop-down.; - For the tag name, use ``v<your-version>``, where the version matches the contents of the ``VERSION`` file.; In other words, if you are releasing a micro version 4.5.3, use ``v4.5.3`` as the tag, or if you are releasing major version 5.0.0, use ``v5.0.0``.; - The title is ""QuTiP <your-version>"", e.g. ""QuTiP 4.6.0"".; - For the description, write a short (~two-line for a patch release) summary of the reason for this release, and note down any particular user-facing changes that need special attention.; Underneath, put the changelog you wrote when you did the documentation release.; Note that there may be some syntax differences between the ``.rst`` file of the changelog and the Markdown of this description field (for example, GitHub's markdown typically maintains hard-wrap linebreaks, which is probably not what you wanted).; - Drag-and-drop all the ``qutip-*.whl``, ``qutip-*.tar.gz`` and ``qutip-*.zip`` files you got after the build step into the assets box.; You may need to unzip the files ``wheels.zip`` and ``sdist.zip`` to find them if you haven't already; **don't** upload those two zip files. Click on the ""Publish release"" button to finalise. .. _web:. Website; +++++++. This assumes that qutip.github.io has already been forked and familiarity with the website updating workflow.; The documentation need not be updated for every patch release. HTML File Updates; -----------------. - Edit ``download.html``. * The 'Latest release' version and date should be updated.; * The tar.gz and zip links need to have their micro rele",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:16857,Deployability,release,release,16857,"releasing a micro version 4.5.3, use ``v4.5.3`` as the tag, or if you are releasing major version 5.0.0, use ``v5.0.0``.; - The title is ""QuTiP <your-version>"", e.g. ""QuTiP 4.6.0"".; - For the description, write a short (~two-line for a patch release) summary of the reason for this release, and note down any particular user-facing changes that need special attention.; Underneath, put the changelog you wrote when you did the documentation release.; Note that there may be some syntax differences between the ``.rst`` file of the changelog and the Markdown of this description field (for example, GitHub's markdown typically maintains hard-wrap linebreaks, which is probably not what you wanted).; - Drag-and-drop all the ``qutip-*.whl``, ``qutip-*.tar.gz`` and ``qutip-*.zip`` files you got after the build step into the assets box.; You may need to unzip the files ``wheels.zip`` and ``sdist.zip`` to find them if you haven't already; **don't** upload those two zip files. Click on the ""Publish release"" button to finalise. .. _web:. Website; +++++++. This assumes that qutip.github.io has already been forked and familiarity with the website updating workflow.; The documentation need not be updated for every patch release. HTML File Updates; -----------------. - Edit ``download.html``. * The 'Latest release' version and date should be updated.; * The tar.gz and zip links need to have their micro release numbers updated in their filenames, labels and trackEvent javascript.; These links should point to the ""Source code"" links that appeared when you made in the GitHub Releases section.; They should look something like ``https://github.com/qutip/qutip/archive/refs/tags/v4.6.0.tar.gz``.; * For a minor or major release links to the last micro release of the previous version will need to be moved (copied) to the 'Previous releases' section. - Edit ``_includes/sidebar.html``. * Add the new version and release date. Only actively developed version should be listed. Micro replace the previo",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:17055,Deployability,update,updated,17055,"ription, write a short (~two-line for a patch release) summary of the reason for this release, and note down any particular user-facing changes that need special attention.; Underneath, put the changelog you wrote when you did the documentation release.; Note that there may be some syntax differences between the ``.rst`` file of the changelog and the Markdown of this description field (for example, GitHub's markdown typically maintains hard-wrap linebreaks, which is probably not what you wanted).; - Drag-and-drop all the ``qutip-*.whl``, ``qutip-*.tar.gz`` and ``qutip-*.zip`` files you got after the build step into the assets box.; You may need to unzip the files ``wheels.zip`` and ``sdist.zip`` to find them if you haven't already; **don't** upload those two zip files. Click on the ""Publish release"" button to finalise. .. _web:. Website; +++++++. This assumes that qutip.github.io has already been forked and familiarity with the website updating workflow.; The documentation need not be updated for every patch release. HTML File Updates; -----------------. - Edit ``download.html``. * The 'Latest release' version and date should be updated.; * The tar.gz and zip links need to have their micro release numbers updated in their filenames, labels and trackEvent javascript.; These links should point to the ""Source code"" links that appeared when you made in the GitHub Releases section.; They should look something like ``https://github.com/qutip/qutip/archive/refs/tags/v4.6.0.tar.gz``.; * For a minor or major release links to the last micro release of the previous version will need to be moved (copied) to the 'Previous releases' section. - Edit ``_includes/sidebar.html``. * Add the new version and release date. Only actively developed version should be listed. Micro replace the previous entry but the last major can be kept.; * Link to the installation instruction, documentation, source code and changelog should be updated. - Edit ``documentation.html``. * For major and minor ",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:17073,Deployability,patch,patch,17073,"ription, write a short (~two-line for a patch release) summary of the reason for this release, and note down any particular user-facing changes that need special attention.; Underneath, put the changelog you wrote when you did the documentation release.; Note that there may be some syntax differences between the ``.rst`` file of the changelog and the Markdown of this description field (for example, GitHub's markdown typically maintains hard-wrap linebreaks, which is probably not what you wanted).; - Drag-and-drop all the ``qutip-*.whl``, ``qutip-*.tar.gz`` and ``qutip-*.zip`` files you got after the build step into the assets box.; You may need to unzip the files ``wheels.zip`` and ``sdist.zip`` to find them if you haven't already; **don't** upload those two zip files. Click on the ""Publish release"" button to finalise. .. _web:. Website; +++++++. This assumes that qutip.github.io has already been forked and familiarity with the website updating workflow.; The documentation need not be updated for every patch release. HTML File Updates; -----------------. - Edit ``download.html``. * The 'Latest release' version and date should be updated.; * The tar.gz and zip links need to have their micro release numbers updated in their filenames, labels and trackEvent javascript.; These links should point to the ""Source code"" links that appeared when you made in the GitHub Releases section.; They should look something like ``https://github.com/qutip/qutip/archive/refs/tags/v4.6.0.tar.gz``.; * For a minor or major release links to the last micro release of the previous version will need to be moved (copied) to the 'Previous releases' section. - Edit ``_includes/sidebar.html``. * Add the new version and release date. Only actively developed version should be listed. Micro replace the previous entry but the last major can be kept.; * Link to the installation instruction, documentation, source code and changelog should be updated. - Edit ``documentation.html``. * For major and minor ",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:17079,Deployability,release,release,17079,"ription, write a short (~two-line for a patch release) summary of the reason for this release, and note down any particular user-facing changes that need special attention.; Underneath, put the changelog you wrote when you did the documentation release.; Note that there may be some syntax differences between the ``.rst`` file of the changelog and the Markdown of this description field (for example, GitHub's markdown typically maintains hard-wrap linebreaks, which is probably not what you wanted).; - Drag-and-drop all the ``qutip-*.whl``, ``qutip-*.tar.gz`` and ``qutip-*.zip`` files you got after the build step into the assets box.; You may need to unzip the files ``wheels.zip`` and ``sdist.zip`` to find them if you haven't already; **don't** upload those two zip files. Click on the ""Publish release"" button to finalise. .. _web:. Website; +++++++. This assumes that qutip.github.io has already been forked and familiarity with the website updating workflow.; The documentation need not be updated for every patch release. HTML File Updates; -----------------. - Edit ``download.html``. * The 'Latest release' version and date should be updated.; * The tar.gz and zip links need to have their micro release numbers updated in their filenames, labels and trackEvent javascript.; These links should point to the ""Source code"" links that appeared when you made in the GitHub Releases section.; They should look something like ``https://github.com/qutip/qutip/archive/refs/tags/v4.6.0.tar.gz``.; * For a minor or major release links to the last micro release of the previous version will need to be moved (copied) to the 'Previous releases' section. - Edit ``_includes/sidebar.html``. * Add the new version and release date. Only actively developed version should be listed. Micro replace the previous entry but the last major can be kept.; * Link to the installation instruction, documentation, source code and changelog should be updated. - Edit ``documentation.html``. * For major and minor ",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:17166,Deployability,release,release,17166,"ser-facing changes that need special attention.; Underneath, put the changelog you wrote when you did the documentation release.; Note that there may be some syntax differences between the ``.rst`` file of the changelog and the Markdown of this description field (for example, GitHub's markdown typically maintains hard-wrap linebreaks, which is probably not what you wanted).; - Drag-and-drop all the ``qutip-*.whl``, ``qutip-*.tar.gz`` and ``qutip-*.zip`` files you got after the build step into the assets box.; You may need to unzip the files ``wheels.zip`` and ``sdist.zip`` to find them if you haven't already; **don't** upload those two zip files. Click on the ""Publish release"" button to finalise. .. _web:. Website; +++++++. This assumes that qutip.github.io has already been forked and familiarity with the website updating workflow.; The documentation need not be updated for every patch release. HTML File Updates; -----------------. - Edit ``download.html``. * The 'Latest release' version and date should be updated.; * The tar.gz and zip links need to have their micro release numbers updated in their filenames, labels and trackEvent javascript.; These links should point to the ""Source code"" links that appeared when you made in the GitHub Releases section.; They should look something like ``https://github.com/qutip/qutip/archive/refs/tags/v4.6.0.tar.gz``.; * For a minor or major release links to the last micro release of the previous version will need to be moved (copied) to the 'Previous releases' section. - Edit ``_includes/sidebar.html``. * Add the new version and release date. Only actively developed version should be listed. Micro replace the previous entry but the last major can be kept.; * Link to the installation instruction, documentation, source code and changelog should be updated. - Edit ``documentation.html``. * For major and minor release, the previous release tags should be moved (copied) to the 'Previous releases' section and the links to the readthedoc",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:17202,Deployability,update,updated,17202,"ser-facing changes that need special attention.; Underneath, put the changelog you wrote when you did the documentation release.; Note that there may be some syntax differences between the ``.rst`` file of the changelog and the Markdown of this description field (for example, GitHub's markdown typically maintains hard-wrap linebreaks, which is probably not what you wanted).; - Drag-and-drop all the ``qutip-*.whl``, ``qutip-*.tar.gz`` and ``qutip-*.zip`` files you got after the build step into the assets box.; You may need to unzip the files ``wheels.zip`` and ``sdist.zip`` to find them if you haven't already; **don't** upload those two zip files. Click on the ""Publish release"" button to finalise. .. _web:. Website; +++++++. This assumes that qutip.github.io has already been forked and familiarity with the website updating workflow.; The documentation need not be updated for every patch release. HTML File Updates; -----------------. - Edit ``download.html``. * The 'Latest release' version and date should be updated.; * The tar.gz and zip links need to have their micro release numbers updated in their filenames, labels and trackEvent javascript.; These links should point to the ""Source code"" links that appeared when you made in the GitHub Releases section.; They should look something like ``https://github.com/qutip/qutip/archive/refs/tags/v4.6.0.tar.gz``.; * For a minor or major release links to the last micro release of the previous version will need to be moved (copied) to the 'Previous releases' section. - Edit ``_includes/sidebar.html``. * Add the new version and release date. Only actively developed version should be listed. Micro replace the previous entry but the last major can be kept.; * Link to the installation instruction, documentation, source code and changelog should be updated. - Edit ``documentation.html``. * For major and minor release, the previous release tags should be moved (copied) to the 'Previous releases' section and the links to the readthedoc",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:17264,Deployability,release,release,17264," the documentation release.; Note that there may be some syntax differences between the ``.rst`` file of the changelog and the Markdown of this description field (for example, GitHub's markdown typically maintains hard-wrap linebreaks, which is probably not what you wanted).; - Drag-and-drop all the ``qutip-*.whl``, ``qutip-*.tar.gz`` and ``qutip-*.zip`` files you got after the build step into the assets box.; You may need to unzip the files ``wheels.zip`` and ``sdist.zip`` to find them if you haven't already; **don't** upload those two zip files. Click on the ""Publish release"" button to finalise. .. _web:. Website; +++++++. This assumes that qutip.github.io has already been forked and familiarity with the website updating workflow.; The documentation need not be updated for every patch release. HTML File Updates; -----------------. - Edit ``download.html``. * The 'Latest release' version and date should be updated.; * The tar.gz and zip links need to have their micro release numbers updated in their filenames, labels and trackEvent javascript.; These links should point to the ""Source code"" links that appeared when you made in the GitHub Releases section.; They should look something like ``https://github.com/qutip/qutip/archive/refs/tags/v4.6.0.tar.gz``.; * For a minor or major release links to the last micro release of the previous version will need to be moved (copied) to the 'Previous releases' section. - Edit ``_includes/sidebar.html``. * Add the new version and release date. Only actively developed version should be listed. Micro replace the previous entry but the last major can be kept.; * Link to the installation instruction, documentation, source code and changelog should be updated. - Edit ``documentation.html``. * For major and minor release, the previous release tags should be moved (copied) to the 'Previous releases' section and the links to the readthedocs of the new version added the to 'Latest releases' section. .. _cforge:. Conda Forge; +++++++++++. I",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:17280,Deployability,update,updated,17280," the documentation release.; Note that there may be some syntax differences between the ``.rst`` file of the changelog and the Markdown of this description field (for example, GitHub's markdown typically maintains hard-wrap linebreaks, which is probably not what you wanted).; - Drag-and-drop all the ``qutip-*.whl``, ``qutip-*.tar.gz`` and ``qutip-*.zip`` files you got after the build step into the assets box.; You may need to unzip the files ``wheels.zip`` and ``sdist.zip`` to find them if you haven't already; **don't** upload those two zip files. Click on the ""Publish release"" button to finalise. .. _web:. Website; +++++++. This assumes that qutip.github.io has already been forked and familiarity with the website updating workflow.; The documentation need not be updated for every patch release. HTML File Updates; -----------------. - Edit ``download.html``. * The 'Latest release' version and date should be updated.; * The tar.gz and zip links need to have their micro release numbers updated in their filenames, labels and trackEvent javascript.; These links should point to the ""Source code"" links that appeared when you made in the GitHub Releases section.; They should look something like ``https://github.com/qutip/qutip/archive/refs/tags/v4.6.0.tar.gz``.; * For a minor or major release links to the last micro release of the previous version will need to be moved (copied) to the 'Previous releases' section. - Edit ``_includes/sidebar.html``. * Add the new version and release date. Only actively developed version should be listed. Micro replace the previous entry but the last major can be kept.; * Link to the installation instruction, documentation, source code and changelog should be updated. - Edit ``documentation.html``. * For major and minor release, the previous release tags should be moved (copied) to the 'Previous releases' section and the links to the readthedocs of the new version added the to 'Latest releases' section. .. _cforge:. Conda Forge; +++++++++++. I",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:17580,Deployability,release,release,17580,"zip`` files you got after the build step into the assets box.; You may need to unzip the files ``wheels.zip`` and ``sdist.zip`` to find them if you haven't already; **don't** upload those two zip files. Click on the ""Publish release"" button to finalise. .. _web:. Website; +++++++. This assumes that qutip.github.io has already been forked and familiarity with the website updating workflow.; The documentation need not be updated for every patch release. HTML File Updates; -----------------. - Edit ``download.html``. * The 'Latest release' version and date should be updated.; * The tar.gz and zip links need to have their micro release numbers updated in their filenames, labels and trackEvent javascript.; These links should point to the ""Source code"" links that appeared when you made in the GitHub Releases section.; They should look something like ``https://github.com/qutip/qutip/archive/refs/tags/v4.6.0.tar.gz``.; * For a minor or major release links to the last micro release of the previous version will need to be moved (copied) to the 'Previous releases' section. - Edit ``_includes/sidebar.html``. * Add the new version and release date. Only actively developed version should be listed. Micro replace the previous entry but the last major can be kept.; * Link to the installation instruction, documentation, source code and changelog should be updated. - Edit ``documentation.html``. * For major and minor release, the previous release tags should be moved (copied) to the 'Previous releases' section and the links to the readthedocs of the new version added the to 'Latest releases' section. .. _cforge:. Conda Forge; +++++++++++. If not done previously then fork the `qutip-feedstock <https://github.com/conda-forge/qutip-feedstock>`_. Checkout a new branch on your fork, e.g. ::. $ git checkout -b version-4.0.2. Find the sha256 checksum for the tarball that the GitHub web interface generated when you produced the release called ""Source code"".; This is *not* the sdist that you d",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:17612,Deployability,release,release,17612,"zip`` files you got after the build step into the assets box.; You may need to unzip the files ``wheels.zip`` and ``sdist.zip`` to find them if you haven't already; **don't** upload those two zip files. Click on the ""Publish release"" button to finalise. .. _web:. Website; +++++++. This assumes that qutip.github.io has already been forked and familiarity with the website updating workflow.; The documentation need not be updated for every patch release. HTML File Updates; -----------------. - Edit ``download.html``. * The 'Latest release' version and date should be updated.; * The tar.gz and zip links need to have their micro release numbers updated in their filenames, labels and trackEvent javascript.; These links should point to the ""Source code"" links that appeared when you made in the GitHub Releases section.; They should look something like ``https://github.com/qutip/qutip/archive/refs/tags/v4.6.0.tar.gz``.; * For a minor or major release links to the last micro release of the previous version will need to be moved (copied) to the 'Previous releases' section. - Edit ``_includes/sidebar.html``. * Add the new version and release date. Only actively developed version should be listed. Micro replace the previous entry but the last major can be kept.; * Link to the installation instruction, documentation, source code and changelog should be updated. - Edit ``documentation.html``. * For major and minor release, the previous release tags should be moved (copied) to the 'Previous releases' section and the links to the readthedocs of the new version added the to 'Latest releases' section. .. _cforge:. Conda Forge; +++++++++++. If not done previously then fork the `qutip-feedstock <https://github.com/conda-forge/qutip-feedstock>`_. Checkout a new branch on your fork, e.g. ::. $ git checkout -b version-4.0.2. Find the sha256 checksum for the tarball that the GitHub web interface generated when you produced the release called ""Source code"".; This is *not* the sdist that you d",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:17692,Deployability,release,releases,17692,"zip`` files you got after the build step into the assets box.; You may need to unzip the files ``wheels.zip`` and ``sdist.zip`` to find them if you haven't already; **don't** upload those two zip files. Click on the ""Publish release"" button to finalise. .. _web:. Website; +++++++. This assumes that qutip.github.io has already been forked and familiarity with the website updating workflow.; The documentation need not be updated for every patch release. HTML File Updates; -----------------. - Edit ``download.html``. * The 'Latest release' version and date should be updated.; * The tar.gz and zip links need to have their micro release numbers updated in their filenames, labels and trackEvent javascript.; These links should point to the ""Source code"" links that appeared when you made in the GitHub Releases section.; They should look something like ``https://github.com/qutip/qutip/archive/refs/tags/v4.6.0.tar.gz``.; * For a minor or major release links to the last micro release of the previous version will need to be moved (copied) to the 'Previous releases' section. - Edit ``_includes/sidebar.html``. * Add the new version and release date. Only actively developed version should be listed. Micro replace the previous entry but the last major can be kept.; * Link to the installation instruction, documentation, source code and changelog should be updated. - Edit ``documentation.html``. * For major and minor release, the previous release tags should be moved (copied) to the 'Previous releases' section and the links to the readthedocs of the new version added the to 'Latest releases' section. .. _cforge:. Conda Forge; +++++++++++. If not done previously then fork the `qutip-feedstock <https://github.com/conda-forge/qutip-feedstock>`_. Checkout a new branch on your fork, e.g. ::. $ git checkout -b version-4.0.2. Find the sha256 checksum for the tarball that the GitHub web interface generated when you produced the release called ""Source code"".; This is *not* the sdist that you d",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:17772,Deployability,release,release,17772,"nd them if you haven't already; **don't** upload those two zip files. Click on the ""Publish release"" button to finalise. .. _web:. Website; +++++++. This assumes that qutip.github.io has already been forked and familiarity with the website updating workflow.; The documentation need not be updated for every patch release. HTML File Updates; -----------------. - Edit ``download.html``. * The 'Latest release' version and date should be updated.; * The tar.gz and zip links need to have their micro release numbers updated in their filenames, labels and trackEvent javascript.; These links should point to the ""Source code"" links that appeared when you made in the GitHub Releases section.; They should look something like ``https://github.com/qutip/qutip/archive/refs/tags/v4.6.0.tar.gz``.; * For a minor or major release links to the last micro release of the previous version will need to be moved (copied) to the 'Previous releases' section. - Edit ``_includes/sidebar.html``. * Add the new version and release date. Only actively developed version should be listed. Micro replace the previous entry but the last major can be kept.; * Link to the installation instruction, documentation, source code and changelog should be updated. - Edit ``documentation.html``. * For major and minor release, the previous release tags should be moved (copied) to the 'Previous releases' section and the links to the readthedocs of the new version added the to 'Latest releases' section. .. _cforge:. Conda Forge; +++++++++++. If not done previously then fork the `qutip-feedstock <https://github.com/conda-forge/qutip-feedstock>`_. Checkout a new branch on your fork, e.g. ::. $ git checkout -b version-4.0.2. Find the sha256 checksum for the tarball that the GitHub web interface generated when you produced the release called ""Source code"".; This is *not* the sdist that you downloaded earlier, it's a new file that GitHub labels ""Source code"".; When you download it, though, it will have a name that *looks*",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:17916,Deployability,install,installation,17916,"s already been forked and familiarity with the website updating workflow.; The documentation need not be updated for every patch release. HTML File Updates; -----------------. - Edit ``download.html``. * The 'Latest release' version and date should be updated.; * The tar.gz and zip links need to have their micro release numbers updated in their filenames, labels and trackEvent javascript.; These links should point to the ""Source code"" links that appeared when you made in the GitHub Releases section.; They should look something like ``https://github.com/qutip/qutip/archive/refs/tags/v4.6.0.tar.gz``.; * For a minor or major release links to the last micro release of the previous version will need to be moved (copied) to the 'Previous releases' section. - Edit ``_includes/sidebar.html``. * Add the new version and release date. Only actively developed version should be listed. Micro replace the previous entry but the last major can be kept.; * Link to the installation instruction, documentation, source code and changelog should be updated. - Edit ``documentation.html``. * For major and minor release, the previous release tags should be moved (copied) to the 'Previous releases' section and the links to the readthedocs of the new version added the to 'Latest releases' section. .. _cforge:. Conda Forge; +++++++++++. If not done previously then fork the `qutip-feedstock <https://github.com/conda-forge/qutip-feedstock>`_. Checkout a new branch on your fork, e.g. ::. $ git checkout -b version-4.0.2. Find the sha256 checksum for the tarball that the GitHub web interface generated when you produced the release called ""Source code"".; This is *not* the sdist that you downloaded earlier, it's a new file that GitHub labels ""Source code"".; When you download it, though, it will have a name that *looks* like it's the sdist ::. $ openssl sha256 qutip-4.0.2.tar.gz. Edit the ``recipe/meta.yaml`` file.; Change the version at the top of the file, and update the sha256 checksum.; Check that ",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:17993,Deployability,update,updated,17993,"s already been forked and familiarity with the website updating workflow.; The documentation need not be updated for every patch release. HTML File Updates; -----------------. - Edit ``download.html``. * The 'Latest release' version and date should be updated.; * The tar.gz and zip links need to have their micro release numbers updated in their filenames, labels and trackEvent javascript.; These links should point to the ""Source code"" links that appeared when you made in the GitHub Releases section.; They should look something like ``https://github.com/qutip/qutip/archive/refs/tags/v4.6.0.tar.gz``.; * For a minor or major release links to the last micro release of the previous version will need to be moved (copied) to the 'Previous releases' section. - Edit ``_includes/sidebar.html``. * Add the new version and release date. Only actively developed version should be listed. Micro replace the previous entry but the last major can be kept.; * Link to the installation instruction, documentation, source code and changelog should be updated. - Edit ``documentation.html``. * For major and minor release, the previous release tags should be moved (copied) to the 'Previous releases' section and the links to the readthedocs of the new version added the to 'Latest releases' section. .. _cforge:. Conda Forge; +++++++++++. If not done previously then fork the `qutip-feedstock <https://github.com/conda-forge/qutip-feedstock>`_. Checkout a new branch on your fork, e.g. ::. $ git checkout -b version-4.0.2. Find the sha256 checksum for the tarball that the GitHub web interface generated when you produced the release called ""Source code"".; This is *not* the sdist that you downloaded earlier, it's a new file that GitHub labels ""Source code"".; When you download it, though, it will have a name that *looks* like it's the sdist ::. $ openssl sha256 qutip-4.0.2.tar.gz. Edit the ``recipe/meta.yaml`` file.; Change the version at the top of the file, and update the sha256 checksum.; Check that ",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:18055,Deployability,release,release,18055,"ownload.html``. * The 'Latest release' version and date should be updated.; * The tar.gz and zip links need to have their micro release numbers updated in their filenames, labels and trackEvent javascript.; These links should point to the ""Source code"" links that appeared when you made in the GitHub Releases section.; They should look something like ``https://github.com/qutip/qutip/archive/refs/tags/v4.6.0.tar.gz``.; * For a minor or major release links to the last micro release of the previous version will need to be moved (copied) to the 'Previous releases' section. - Edit ``_includes/sidebar.html``. * Add the new version and release date. Only actively developed version should be listed. Micro replace the previous entry but the last major can be kept.; * Link to the installation instruction, documentation, source code and changelog should be updated. - Edit ``documentation.html``. * For major and minor release, the previous release tags should be moved (copied) to the 'Previous releases' section and the links to the readthedocs of the new version added the to 'Latest releases' section. .. _cforge:. Conda Forge; +++++++++++. If not done previously then fork the `qutip-feedstock <https://github.com/conda-forge/qutip-feedstock>`_. Checkout a new branch on your fork, e.g. ::. $ git checkout -b version-4.0.2. Find the sha256 checksum for the tarball that the GitHub web interface generated when you produced the release called ""Source code"".; This is *not* the sdist that you downloaded earlier, it's a new file that GitHub labels ""Source code"".; When you download it, though, it will have a name that *looks* like it's the sdist ::. $ openssl sha256 qutip-4.0.2.tar.gz. Edit the ``recipe/meta.yaml`` file.; Change the version at the top of the file, and update the sha256 checksum.; Check that the recipe package version requirements at least match those in ``setup.cfg``, and that any changes to the build process are reflected in ``meta.yml``.; Also ensure that the build number",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:18077,Deployability,release,release,18077,"ownload.html``. * The 'Latest release' version and date should be updated.; * The tar.gz and zip links need to have their micro release numbers updated in their filenames, labels and trackEvent javascript.; These links should point to the ""Source code"" links that appeared when you made in the GitHub Releases section.; They should look something like ``https://github.com/qutip/qutip/archive/refs/tags/v4.6.0.tar.gz``.; * For a minor or major release links to the last micro release of the previous version will need to be moved (copied) to the 'Previous releases' section. - Edit ``_includes/sidebar.html``. * Add the new version and release date. Only actively developed version should be listed. Micro replace the previous entry but the last major can be kept.; * Link to the installation instruction, documentation, source code and changelog should be updated. - Edit ``documentation.html``. * For major and minor release, the previous release tags should be moved (copied) to the 'Previous releases' section and the links to the readthedocs of the new version added the to 'Latest releases' section. .. _cforge:. Conda Forge; +++++++++++. If not done previously then fork the `qutip-feedstock <https://github.com/conda-forge/qutip-feedstock>`_. Checkout a new branch on your fork, e.g. ::. $ git checkout -b version-4.0.2. Find the sha256 checksum for the tarball that the GitHub web interface generated when you produced the release called ""Source code"".; This is *not* the sdist that you downloaded earlier, it's a new file that GitHub labels ""Source code"".; When you download it, though, it will have a name that *looks* like it's the sdist ::. $ openssl sha256 qutip-4.0.2.tar.gz. Edit the ``recipe/meta.yaml`` file.; Change the version at the top of the file, and update the sha256 checksum.; Check that the recipe package version requirements at least match those in ``setup.cfg``, and that any changes to the build process are reflected in ``meta.yml``.; Also ensure that the build number",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:18132,Deployability,release,releases,18132,"ownload.html``. * The 'Latest release' version and date should be updated.; * The tar.gz and zip links need to have their micro release numbers updated in their filenames, labels and trackEvent javascript.; These links should point to the ""Source code"" links that appeared when you made in the GitHub Releases section.; They should look something like ``https://github.com/qutip/qutip/archive/refs/tags/v4.6.0.tar.gz``.; * For a minor or major release links to the last micro release of the previous version will need to be moved (copied) to the 'Previous releases' section. - Edit ``_includes/sidebar.html``. * Add the new version and release date. Only actively developed version should be listed. Micro replace the previous entry but the last major can be kept.; * Link to the installation instruction, documentation, source code and changelog should be updated. - Edit ``documentation.html``. * For major and minor release, the previous release tags should be moved (copied) to the 'Previous releases' section and the links to the readthedocs of the new version added the to 'Latest releases' section. .. _cforge:. Conda Forge; +++++++++++. If not done previously then fork the `qutip-feedstock <https://github.com/conda-forge/qutip-feedstock>`_. Checkout a new branch on your fork, e.g. ::. $ git checkout -b version-4.0.2. Find the sha256 checksum for the tarball that the GitHub web interface generated when you produced the release called ""Source code"".; This is *not* the sdist that you downloaded earlier, it's a new file that GitHub labels ""Source code"".; When you download it, though, it will have a name that *looks* like it's the sdist ::. $ openssl sha256 qutip-4.0.2.tar.gz. Edit the ``recipe/meta.yaml`` file.; Change the version at the top of the file, and update the sha256 checksum.; Check that the recipe package version requirements at least match those in ``setup.cfg``, and that any changes to the build process are reflected in ``meta.yml``.; Also ensure that the build number",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:18223,Deployability,release,releases,18223,"ownload.html``. * The 'Latest release' version and date should be updated.; * The tar.gz and zip links need to have their micro release numbers updated in their filenames, labels and trackEvent javascript.; These links should point to the ""Source code"" links that appeared when you made in the GitHub Releases section.; They should look something like ``https://github.com/qutip/qutip/archive/refs/tags/v4.6.0.tar.gz``.; * For a minor or major release links to the last micro release of the previous version will need to be moved (copied) to the 'Previous releases' section. - Edit ``_includes/sidebar.html``. * Add the new version and release date. Only actively developed version should be listed. Micro replace the previous entry but the last major can be kept.; * Link to the installation instruction, documentation, source code and changelog should be updated. - Edit ``documentation.html``. * For major and minor release, the previous release tags should be moved (copied) to the 'Previous releases' section and the links to the readthedocs of the new version added the to 'Latest releases' section. .. _cforge:. Conda Forge; +++++++++++. If not done previously then fork the `qutip-feedstock <https://github.com/conda-forge/qutip-feedstock>`_. Checkout a new branch on your fork, e.g. ::. $ git checkout -b version-4.0.2. Find the sha256 checksum for the tarball that the GitHub web interface generated when you produced the release called ""Source code"".; This is *not* the sdist that you downloaded earlier, it's a new file that GitHub labels ""Source code"".; When you download it, though, it will have a name that *looks* like it's the sdist ::. $ openssl sha256 qutip-4.0.2.tar.gz. Edit the ``recipe/meta.yaml`` file.; Change the version at the top of the file, and update the sha256 checksum.; Check that the recipe package version requirements at least match those in ``setup.cfg``, and that any changes to the build process are reflected in ``meta.yml``.; Also ensure that the build number",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:18568,Deployability,release,release,18568,"efs/tags/v4.6.0.tar.gz``.; * For a minor or major release links to the last micro release of the previous version will need to be moved (copied) to the 'Previous releases' section. - Edit ``_includes/sidebar.html``. * Add the new version and release date. Only actively developed version should be listed. Micro replace the previous entry but the last major can be kept.; * Link to the installation instruction, documentation, source code and changelog should be updated. - Edit ``documentation.html``. * For major and minor release, the previous release tags should be moved (copied) to the 'Previous releases' section and the links to the readthedocs of the new version added the to 'Latest releases' section. .. _cforge:. Conda Forge; +++++++++++. If not done previously then fork the `qutip-feedstock <https://github.com/conda-forge/qutip-feedstock>`_. Checkout a new branch on your fork, e.g. ::. $ git checkout -b version-4.0.2. Find the sha256 checksum for the tarball that the GitHub web interface generated when you produced the release called ""Source code"".; This is *not* the sdist that you downloaded earlier, it's a new file that GitHub labels ""Source code"".; When you download it, though, it will have a name that *looks* like it's the sdist ::. $ openssl sha256 qutip-4.0.2.tar.gz. Edit the ``recipe/meta.yaml`` file.; Change the version at the top of the file, and update the sha256 checksum.; Check that the recipe package version requirements at least match those in ``setup.cfg``, and that any changes to the build process are reflected in ``meta.yml``.; Also ensure that the build number is reset ::. build:; number: 0. Push changes to your fork, e.g. ::. $ git push --set-upstream origin version-4.0.2. Make a Pull Request.; This will trigger tests of the package build process. If (when) the tests pass, the PR can be merged, which will trigger the upload of the packages to the conda-forge channel.; To test the packages, add the conda-forge channel with lowest priority ::. $ c",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:18911,Deployability,update,update,18911,"leases' section. - Edit ``_includes/sidebar.html``. * Add the new version and release date. Only actively developed version should be listed. Micro replace the previous entry but the last major can be kept.; * Link to the installation instruction, documentation, source code and changelog should be updated. - Edit ``documentation.html``. * For major and minor release, the previous release tags should be moved (copied) to the 'Previous releases' section and the links to the readthedocs of the new version added the to 'Latest releases' section. .. _cforge:. Conda Forge; +++++++++++. If not done previously then fork the `qutip-feedstock <https://github.com/conda-forge/qutip-feedstock>`_. Checkout a new branch on your fork, e.g. ::. $ git checkout -b version-4.0.2. Find the sha256 checksum for the tarball that the GitHub web interface generated when you produced the release called ""Source code"".; This is *not* the sdist that you downloaded earlier, it's a new file that GitHub labels ""Source code"".; When you download it, though, it will have a name that *looks* like it's the sdist ::. $ openssl sha256 qutip-4.0.2.tar.gz. Edit the ``recipe/meta.yaml`` file.; Change the version at the top of the file, and update the sha256 checksum.; Check that the recipe package version requirements at least match those in ``setup.cfg``, and that any changes to the build process are reflected in ``meta.yml``.; Also ensure that the build number is reset ::. build:; number: 0. Push changes to your fork, e.g. ::. $ git push --set-upstream origin version-4.0.2. Make a Pull Request.; This will trigger tests of the package build process. If (when) the tests pass, the PR can be merged, which will trigger the upload of the packages to the conda-forge channel.; To test the packages, add the conda-forge channel with lowest priority ::. $ conda config --append channels conda-forge. This should mean that the prerequistes come from the default channel, but the qutip packages are found in conda-forge.; ",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:13817,Energy Efficiency,monitor,monitor,13817,"d the package.; - (Special circumstances) If for some reason you need to override the version number (for example if the previous deployment to PyPI only partially succeeded), you can type a valid Python version identifier into the ""Override version number"" field.; You probably do not need to do this.; The mechanism is designed to make alpha-testing major upgrades with nightly releases easier.; For even a bugfix release, you should commit the change to the ``VERSION`` file.; - Click the lower ""Run workflow"" to perform the build and deployment. At this point, the deployment will take care of itself.; It should take between 30 minutes and an hour, after which the new version will be available for install by ``pip install qutip``.; You should see the new version appear on `QuTiP's PyPI page <https://pypi.org/project/qutip>`_. Download Built Files; --------------------. When the build is complete, click into its summary screen.; This is the main screen used to both monitor the build and see its output, and should look like the below image on a success. .. image:: ../figures/release_guide_after_workflow.png. The built binary wheels and the source distribution are the ""build artifacts"" at the bottom.; You need to download both the wheels and the source distribution.; Save them on your computer, and unzip both files; you should have many wheel ``qutip-*.whl`` files, and two sdist files: ``qutip-*.tar.gz`` and ``qutip-*.zip``.; These are the same files that have just been uploaded to PyPI. Monitoring Progress (optional); ------------------------------. While the build is in progress, you can monitor its progress by clicking on its entry in the list below the ""Run workflow"" button.; You should see several subjobs, like the completed screen, except they might not yet be completed. The ""Verify PyPI deployment confirmation"" should get ticked, no matter what.; If it fails, you have forgotten to choose the correct branch in the drop-down menu or you made a typo when confirming the",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:14452,Energy Efficiency,monitor,monitor,14452,"nutes and an hour, after which the new version will be available for install by ``pip install qutip``.; You should see the new version appear on `QuTiP's PyPI page <https://pypi.org/project/qutip>`_. Download Built Files; --------------------. When the build is complete, click into its summary screen.; This is the main screen used to both monitor the build and see its output, and should look like the below image on a success. .. image:: ../figures/release_guide_after_workflow.png. The built binary wheels and the source distribution are the ""build artifacts"" at the bottom.; You need to download both the wheels and the source distribution.; Save them on your computer, and unzip both files; you should have many wheel ``qutip-*.whl`` files, and two sdist files: ``qutip-*.tar.gz`` and ``qutip-*.zip``.; These are the same files that have just been uploaded to PyPI. Monitoring Progress (optional); ------------------------------. While the build is in progress, you can monitor its progress by clicking on its entry in the list below the ""Run workflow"" button.; You should see several subjobs, like the completed screen, except they might not yet be completed. The ""Verify PyPI deployment confirmation"" should get ticked, no matter what.; If it fails, you have forgotten to choose the correct branch in the drop-down menu or you made a typo when confirming the correct branch, and you will need to restart this step.; You can check that the deployment instruction has been understood by clicking the ""Verify PyPI deployment confirmation"" job, and opening the ""Compare confirmation to current reference"" subjob.; You will see a message saying ""Built wheels will be deployed"" if you typed in the confirmation, or ""Only building wheels"" if you did not.; If you see ""Only building wheels"" but you meant to deploy the release to PyPI, you can cancel the workflow and re-run it after typing the confirmation. .. _github:. Making a Release on GitHub; ++++++++++++++++++++++++++. This is all done throug",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:2942,Integrability,depend,dependency,2942,"s, or changes to existing features.; - Any new API classes or functions have entries in a suitable RST file in ``doc/apidoc``.; - Any new or changed docstrings are up-to-date and render correctly in the API documentation. Please make a normal PR to ``master`` correcting anything missing from these points and have it merged before you begin the release, if necessary. .. _update-requirement:. Updating the Requirements; -------------------------. Ensure that QuTiP's tests pass on the oldest version supported in the requirements.; On major and minor version, requirements can be adjusted upwards, but patch release must not change minimum requirements.; We follow `NEP29`_ for minimum supported versions ::. - All minor versions of Python released 42 months prior to the project, and at minimum the two latest minor versions.; - All minor versions of numpy and scipy released in the 24 months prior to the project, and at minimum the last three minor versions. If dependency versions need to be updated, update them in the master branch. The following files may need to be updated: `.github/workflows/tests.yml`, `setup.cfg` and `roadmap.rst`. Finally, ensure that PyPI wheels and conda builds cover at least these versions. .. _NEP29: https://numpy.org/neps/nep-0029-deprecation_policy.html. .. _update-changelog:. Updating the Changelog; ----------------------. This needs to be done no matter what type of release is being made. #. Create a new branch to use to make a pull request.; #. Update the changelog using ``towncrier``:. towncrier build --version=<version-number>. Where ``<version-number>`` is the expected version number of the release. #. Make a pull request on the main ``qutip/qutip`` repository with this changelog, and get other members of the admin team to approve it.; #. Merge this into ``master``. Now jump to release_ if you are making a major or minor release, or bugfix_ if you are only fixing bugs in a previous release. .. _release:. Create a New Minor or Major Release; ",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:8889,Integrability,depend,depending,8889,"#. Find the branch of the release that you will be modifying.; This should already exist on the ``qutip/qutip`` repository, and be called ``qutip-<major>.<minor>.X`` (e.g. ``qutip-4.6.X``).; If you cannot see it, run ``git fetch upstream`` to update all the branch references from the main repository.; Checkout a new private branch, starting from the head of the release branch (``git checkout -b prepare-qutip-4.6.1 upstream/qutip-4.6.X``).; You can call this branch whatever you like (in the example it is ``prepare-qutip-4.6.1``), because it will only be used to make a pull request.; #. Cherry-pick all the commits that will be added to this release in order, including your PR that wrote the new changelog entries (this will be the last one you cherry-pick).; You will want to use ``git log`` to find the relevant commits, going from **oldest to newest** (their ""age"" is when they were merged into ``master``, not when the PR was first opened).; The command is slightly different depending on which merge strategy was used for a particular PR:. - ""merge"": you only need to find one commit though the log will have included several; there will be an entry in ``git log`` with a title such as ""Merge pull request #1000 from <...>"".; Note the first 7 characters of its hash.; Cherry-pick this by ``git cherry-pick --mainline 1 <hash>``.; - ""squash and merge"": there will only be a single commit for the entire PR.; Its name will be ""<Name of the pull request> (#1000)"".; Note the first 7 characters of its hash.; Cherry-pick this by ``git cherry-pick <hash>``.; - ""rebase and merge"": this is the most difficult, because there will be many commits that you will have to find manually, and cherry-pick all of them.; Go to the GitHub page for this PR, and go to the ""Commits"" tab.; Using your local ``git log`` (you may find ``git log --oneline`` useful), find the hash for every single commit that is listed on the GitHub page, in order from **oldest to newest** (top-to-bottom in the GitHub view, w",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:9975,Integrability,message,message,9975," will have included several; there will be an entry in ``git log`` with a title such as ""Merge pull request #1000 from <...>"".; Note the first 7 characters of its hash.; Cherry-pick this by ``git cherry-pick --mainline 1 <hash>``.; - ""squash and merge"": there will only be a single commit for the entire PR.; Its name will be ""<Name of the pull request> (#1000)"".; Note the first 7 characters of its hash.; Cherry-pick this by ``git cherry-pick <hash>``.; - ""rebase and merge"": this is the most difficult, because there will be many commits that you will have to find manually, and cherry-pick all of them.; Go to the GitHub page for this PR, and go to the ""Commits"" tab.; Using your local ``git log`` (you may find ``git log --oneline`` useful), find the hash for every single commit that is listed on the GitHub page, in order from **oldest to newest** (top-to-bottom in the GitHub view, which is bottom-to-top in ``git log``).; You will need to use the commit message to do this; the hashes that GitHub reports will probably not be the same as how they appear locally.; Find the first 7 characters of each of the hashes.; Cherry-pick these all in one go by ``git cherry-pick <hash1> <hash2> ... <hash10>``, where ``<hash1>`` is the oldest. If any of the cherry-picks have merge conflicts, first verify that you are cherry-picking in order from oldest to newest.; If you still have merge conflicts, you will either need to manually fix them (if it is a *very* simple fix), or else you will need to find which additional PR this patch depends on, and restart the bug fix process including this additional patch.; This generally should not happen if you are sticking to very small bug fixes; if the fixes had far-reaching changes, a new minor release may be more appropriate.; #. Change the ``VERSION`` file by bumping the last number up by one (double-digit numbers are fine, so ``4.6.10`` comes after ``4.6.9``), and commit the change.; #. Push this branch to your fork, and make a pull request aga",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:10548,Integrability,depend,depends,10548,"e most difficult, because there will be many commits that you will have to find manually, and cherry-pick all of them.; Go to the GitHub page for this PR, and go to the ""Commits"" tab.; Using your local ``git log`` (you may find ``git log --oneline`` useful), find the hash for every single commit that is listed on the GitHub page, in order from **oldest to newest** (top-to-bottom in the GitHub view, which is bottom-to-top in ``git log``).; You will need to use the commit message to do this; the hashes that GitHub reports will probably not be the same as how they appear locally.; Find the first 7 characters of each of the hashes.; Cherry-pick these all in one go by ``git cherry-pick <hash1> <hash2> ... <hash10>``, where ``<hash1>`` is the oldest. If any of the cherry-picks have merge conflicts, first verify that you are cherry-picking in order from oldest to newest.; If you still have merge conflicts, you will either need to manually fix them (if it is a *very* simple fix), or else you will need to find which additional PR this patch depends on, and restart the bug fix process including this additional patch.; This generally should not happen if you are sticking to very small bug fixes; if the fixes had far-reaching changes, a new minor release may be more appropriate.; #. Change the ``VERSION`` file by bumping the last number up by one (double-digit numbers are fine, so ``4.6.10`` comes after ``4.6.9``), and commit the change.; #. Push this branch to your fork, and make a pull request against the release branch.; On GitHub in the PR screen, you will need to change the ""Base"" branch to ``qutip-4.6.X`` (or whatever version), because GitHub will default to making it against ``master``.; It should be quite clear if you have forgotten to do this, because there will probably be many merge conflicts.; Once the tests have passed and you have another admin's approval, merge the PR. You should now see that the ``qutip-4.6.X`` (or whatever) branch on GitHub has been updated, an",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:12574,Integrability,depend,depending,12574,"l free to make additonal PRs to rectify the situation. You are now ready to actually perform the release.; Go to deploy_. .. _deploy:. Build Release Distribution and Deploy; +++++++++++++++++++++++++++++++++++++. This step builds the source (sdist) and binary (wheel) distributions, and uploads them to PyPI (pip).; You will also be able to download the built files yourself in order to upload them to the QuTiP website. Build and Deploy; ----------------. This is handled entirely by a GitHub Action.; Go to the `""Actions"" tab at the top of the QuTiP code repository <https://github.com/qutip/qutip/actions>`_.; Click on the ""Build wheels, optionally deploy to PyPI"" action in the left-hand sidebar.; Click the ""Run workflow"" dropdown in the header notification; it should look like the image below. .. image:: ../figures/release_guide_run_build_workflow.png. - Use the drop-down menu to choose the branch or tag you want to release from.; This should be called ``qutip-4.5.X`` or similar, depending on what you made earlier.; This must *never* be ``master``.; - To make the release to PyPI, type the branch name (e.g. ``qutip-4.5.X``) into the ""Confirm chosen branch name [...]"" field.; You *may* leave this field blank to skip the deployment and only build the package.; - (Special circumstances) If for some reason you need to override the version number (for example if the previous deployment to PyPI only partially succeeded), you can type a valid Python version identifier into the ""Override version number"" field.; You probably do not need to do this.; The mechanism is designed to make alpha-testing major upgrades with nightly releases easier.; For even a bugfix release, you should commit the change to the ``VERSION`` file.; - Click the lower ""Run workflow"" to perform the build and deployment. At this point, the deployment will take care of itself.; It should take between 30 minutes and an hour, after which the new version will be available for install by ``pip install qutip``.; You ",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:15109,Integrability,message,message,15109,"both files; you should have many wheel ``qutip-*.whl`` files, and two sdist files: ``qutip-*.tar.gz`` and ``qutip-*.zip``.; These are the same files that have just been uploaded to PyPI. Monitoring Progress (optional); ------------------------------. While the build is in progress, you can monitor its progress by clicking on its entry in the list below the ""Run workflow"" button.; You should see several subjobs, like the completed screen, except they might not yet be completed. The ""Verify PyPI deployment confirmation"" should get ticked, no matter what.; If it fails, you have forgotten to choose the correct branch in the drop-down menu or you made a typo when confirming the correct branch, and you will need to restart this step.; You can check that the deployment instruction has been understood by clicking the ""Verify PyPI deployment confirmation"" job, and opening the ""Compare confirmation to current reference"" subjob.; You will see a message saying ""Built wheels will be deployed"" if you typed in the confirmation, or ""Only building wheels"" if you did not.; If you see ""Only building wheels"" but you meant to deploy the release to PyPI, you can cancel the workflow and re-run it after typing the confirmation. .. _github:. Making a Release on GitHub; ++++++++++++++++++++++++++. This is all done through `the ""Releases"" section <https://github.com/qutip/qutip/releases>`_ of the ``qutip/qutip`` repository on GitHub. - Click the ""Draft a new release"" button.; - Choose the correct branch for your release (e.g. ``qutip-4.5.X``) in the drop-down.; - For the tag name, use ``v<your-version>``, where the version matches the contents of the ``VERSION`` file.; In other words, if you are releasing a micro version 4.5.3, use ``v4.5.3`` as the tag, or if you are releasing major version 5.0.0, use ``v5.0.0``.; - The title is ""QuTiP <your-version>"", e.g. ""QuTiP 4.6.0"".; - For the description, write a short (~two-line for a patch release) summary of the reason for this release, and note dow",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:16500,Integrability,wrap,wrap,16500,"l done through `the ""Releases"" section <https://github.com/qutip/qutip/releases>`_ of the ``qutip/qutip`` repository on GitHub. - Click the ""Draft a new release"" button.; - Choose the correct branch for your release (e.g. ``qutip-4.5.X``) in the drop-down.; - For the tag name, use ``v<your-version>``, where the version matches the contents of the ``VERSION`` file.; In other words, if you are releasing a micro version 4.5.3, use ``v4.5.3`` as the tag, or if you are releasing major version 5.0.0, use ``v5.0.0``.; - The title is ""QuTiP <your-version>"", e.g. ""QuTiP 4.6.0"".; - For the description, write a short (~two-line for a patch release) summary of the reason for this release, and note down any particular user-facing changes that need special attention.; Underneath, put the changelog you wrote when you did the documentation release.; Note that there may be some syntax differences between the ``.rst`` file of the changelog and the Markdown of this description field (for example, GitHub's markdown typically maintains hard-wrap linebreaks, which is probably not what you wanted).; - Drag-and-drop all the ``qutip-*.whl``, ``qutip-*.tar.gz`` and ``qutip-*.zip`` files you got after the build step into the assets box.; You may need to unzip the files ``wheels.zip`` and ``sdist.zip`` to find them if you haven't already; **don't** upload those two zip files. Click on the ""Publish release"" button to finalise. .. _web:. Website; +++++++. This assumes that qutip.github.io has already been forked and familiarity with the website updating workflow.; The documentation need not be updated for every patch release. HTML File Updates; -----------------. - Edit ``download.html``. * The 'Latest release' version and date should be updated.; * The tar.gz and zip links need to have their micro release numbers updated in their filenames, labels and trackEvent javascript.; These links should point to the ""Source code"" links that appeared when you made in the GitHub Releases section.; They sho",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:18526,Integrability,interface,interface,18526,"efs/tags/v4.6.0.tar.gz``.; * For a minor or major release links to the last micro release of the previous version will need to be moved (copied) to the 'Previous releases' section. - Edit ``_includes/sidebar.html``. * Add the new version and release date. Only actively developed version should be listed. Micro replace the previous entry but the last major can be kept.; * Link to the installation instruction, documentation, source code and changelog should be updated. - Edit ``documentation.html``. * For major and minor release, the previous release tags should be moved (copied) to the 'Previous releases' section and the links to the readthedocs of the new version added the to 'Latest releases' section. .. _cforge:. Conda Forge; +++++++++++. If not done previously then fork the `qutip-feedstock <https://github.com/conda-forge/qutip-feedstock>`_. Checkout a new branch on your fork, e.g. ::. $ git checkout -b version-4.0.2. Find the sha256 checksum for the tarball that the GitHub web interface generated when you produced the release called ""Source code"".; This is *not* the sdist that you downloaded earlier, it's a new file that GitHub labels ""Source code"".; When you download it, though, it will have a name that *looks* like it's the sdist ::. $ openssl sha256 qutip-4.0.2.tar.gz. Edit the ``recipe/meta.yaml`` file.; Change the version at the top of the file, and update the sha256 checksum.; Check that the recipe package version requirements at least match those in ``setup.cfg``, and that any changes to the build process are reflected in ``meta.yml``.; Also ensure that the build number is reset ::. build:; number: 0. Push changes to your fork, e.g. ::. $ git push --set-upstream origin version-4.0.2. Make a Pull Request.; This will trigger tests of the package build process. If (when) the tests pass, the PR can be merged, which will trigger the upload of the packages to the conda-forge channel.; To test the packages, add the conda-forge channel with lowest priority ::. $ c",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:19536,Modifiability,config,config,19536,"leases' section. - Edit ``_includes/sidebar.html``. * Add the new version and release date. Only actively developed version should be listed. Micro replace the previous entry but the last major can be kept.; * Link to the installation instruction, documentation, source code and changelog should be updated. - Edit ``documentation.html``. * For major and minor release, the previous release tags should be moved (copied) to the 'Previous releases' section and the links to the readthedocs of the new version added the to 'Latest releases' section. .. _cforge:. Conda Forge; +++++++++++. If not done previously then fork the `qutip-feedstock <https://github.com/conda-forge/qutip-feedstock>`_. Checkout a new branch on your fork, e.g. ::. $ git checkout -b version-4.0.2. Find the sha256 checksum for the tarball that the GitHub web interface generated when you produced the release called ""Source code"".; This is *not* the sdist that you downloaded earlier, it's a new file that GitHub labels ""Source code"".; When you download it, though, it will have a name that *looks* like it's the sdist ::. $ openssl sha256 qutip-4.0.2.tar.gz. Edit the ``recipe/meta.yaml`` file.; Change the version at the top of the file, and update the sha256 checksum.; Check that the recipe package version requirements at least match those in ``setup.cfg``, and that any changes to the build process are reflected in ``meta.yml``.; Also ensure that the build number is reset ::. build:; number: 0. Push changes to your fork, e.g. ::. $ git push --set-upstream origin version-4.0.2. Make a Pull Request.; This will trigger tests of the package build process. If (when) the tests pass, the PR can be merged, which will trigger the upload of the packages to the conda-forge channel.; To test the packages, add the conda-forge channel with lowest priority ::. $ conda config --append channels conda-forge. This should mean that the prerequistes come from the default channel, but the qutip packages are found in conda-forge.; ",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:7385,Performance,perform,perform,7385,"have passed, merge this in.; #. Finally, back on ``master``, make a new pull request that changes the ``VERSION`` file to be ``<next-expected-version>.dev``, for example ``4.8.0.dev``.; The ""Development Status"" in ``setup.cfg`` on ``master`` should not have changed, and should be ::. Development Status :: 2 - Pre-Alpha. because ``master`` is never directly released. You should now have a branch that you can see on the GitHub website that is called ``qutip-4.7.X`` (or whatever minor version), and the state of the code in it should be exactly what you want to release as the new minor release.; If you notice you have made a mistake, you can make additional pull requests to the release branch to fix it.; ``master`` should look pretty similar, except the ``VERSION`` will be higher and have a ``.dev`` suffix, and the ""Development Status"" in ``setup.cfg`` will be different. * Activate the readthedocs build for the newly created version branch and set it as the latest. You are now ready to actually perform the release.; Go to deploy_. .. _bugfix:. Create a Bug Fix Release; ------------------------. In this you will modify an already-released branch by ""cherry-picking"" one or more pull requests that have been merged to ``master`` (including your new changelog), and bump the ""patch"" part of the version number. #. On your machine, make sure your copy of ``master`` is up-to-date (``git checkout master; git pull upstream master``).; In particular, make sure the changelog you wrote in the first step is visible.; #. Find the branch of the release that you will be modifying.; This should already exist on the ``qutip/qutip`` repository, and be called ``qutip-<major>.<minor>.X`` (e.g. ``qutip-4.6.X``).; If you cannot see it, run ``git fetch upstream`` to update all the branch references from the main repository.; Checkout a new private branch, starting from the head of the release branch (``git checkout -b prepare-qutip-4.6.1 upstream/qutip-4.6.X``).; You can call this branch whatever",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:11668,Performance,perform,perform,11668,"you are sticking to very small bug fixes; if the fixes had far-reaching changes, a new minor release may be more appropriate.; #. Change the ``VERSION`` file by bumping the last number up by one (double-digit numbers are fine, so ``4.6.10`` comes after ``4.6.9``), and commit the change.; #. Push this branch to your fork, and make a pull request against the release branch.; On GitHub in the PR screen, you will need to change the ""Base"" branch to ``qutip-4.6.X`` (or whatever version), because GitHub will default to making it against ``master``.; It should be quite clear if you have forgotten to do this, because there will probably be many merge conflicts.; Once the tests have passed and you have another admin's approval, merge the PR. You should now see that the ``qutip-4.6.X`` (or whatever) branch on GitHub has been updated, and now includes all the changes you have just made.; If you have made a mistake, feel free to make additonal PRs to rectify the situation. You are now ready to actually perform the release.; Go to deploy_. .. _deploy:. Build Release Distribution and Deploy; +++++++++++++++++++++++++++++++++++++. This step builds the source (sdist) and binary (wheel) distributions, and uploads them to PyPI (pip).; You will also be able to download the built files yourself in order to upload them to the QuTiP website. Build and Deploy; ----------------. This is handled entirely by a GitHub Action.; Go to the `""Actions"" tab at the top of the QuTiP code repository <https://github.com/qutip/qutip/actions>`_.; Click on the ""Build wheels, optionally deploy to PyPI"" action in the left-hand sidebar.; Click the ""Run workflow"" dropdown in the header notification; it should look like the image below. .. image:: ../figures/release_guide_run_build_workflow.png. - Use the drop-down menu to choose the branch or tag you want to release from.; This should be called ``qutip-4.5.X`` or similar, depending on what you made earlier.; This must *never* be ``master``.; - To make the rele",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:13357,Performance,perform,perform,13357,"ld look like the image below. .. image:: ../figures/release_guide_run_build_workflow.png. - Use the drop-down menu to choose the branch or tag you want to release from.; This should be called ``qutip-4.5.X`` or similar, depending on what you made earlier.; This must *never* be ``master``.; - To make the release to PyPI, type the branch name (e.g. ``qutip-4.5.X``) into the ""Confirm chosen branch name [...]"" field.; You *may* leave this field blank to skip the deployment and only build the package.; - (Special circumstances) If for some reason you need to override the version number (for example if the previous deployment to PyPI only partially succeeded), you can type a valid Python version identifier into the ""Override version number"" field.; You probably do not need to do this.; The mechanism is designed to make alpha-testing major upgrades with nightly releases easier.; For even a bugfix release, you should commit the change to the ``VERSION`` file.; - Click the lower ""Run workflow"" to perform the build and deployment. At this point, the deployment will take care of itself.; It should take between 30 minutes and an hour, after which the new version will be available for install by ``pip install qutip``.; You should see the new version appear on `QuTiP's PyPI page <https://pypi.org/project/qutip>`_. Download Built Files; --------------------. When the build is complete, click into its summary screen.; This is the main screen used to both monitor the build and see its output, and should look like the below image on a success. .. image:: ../figures/release_guide_after_workflow.png. The built binary wheels and the source distribution are the ""build artifacts"" at the bottom.; You need to download both the wheels and the source distribution.; Save them on your computer, and unzip both files; you should have many wheel ``qutip-*.whl`` files, and two sdist files: ``qutip-*.tar.gz`` and ``qutip-*.zip``.; These are the same files that have just been uploaded to PyPI. Monitor",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:9175,Security,hash,hash,9175,"e branch references from the main repository.; Checkout a new private branch, starting from the head of the release branch (``git checkout -b prepare-qutip-4.6.1 upstream/qutip-4.6.X``).; You can call this branch whatever you like (in the example it is ``prepare-qutip-4.6.1``), because it will only be used to make a pull request.; #. Cherry-pick all the commits that will be added to this release in order, including your PR that wrote the new changelog entries (this will be the last one you cherry-pick).; You will want to use ``git log`` to find the relevant commits, going from **oldest to newest** (their ""age"" is when they were merged into ``master``, not when the PR was first opened).; The command is slightly different depending on which merge strategy was used for a particular PR:. - ""merge"": you only need to find one commit though the log will have included several; there will be an entry in ``git log`` with a title such as ""Merge pull request #1000 from <...>"".; Note the first 7 characters of its hash.; Cherry-pick this by ``git cherry-pick --mainline 1 <hash>``.; - ""squash and merge"": there will only be a single commit for the entire PR.; Its name will be ""<Name of the pull request> (#1000)"".; Note the first 7 characters of its hash.; Cherry-pick this by ``git cherry-pick <hash>``.; - ""rebase and merge"": this is the most difficult, because there will be many commits that you will have to find manually, and cherry-pick all of them.; Go to the GitHub page for this PR, and go to the ""Commits"" tab.; Using your local ``git log`` (you may find ``git log --oneline`` useful), find the hash for every single commit that is listed on the GitHub page, in order from **oldest to newest** (top-to-bottom in the GitHub view, which is bottom-to-top in ``git log``).; You will need to use the commit message to do this; the hashes that GitHub reports will probably not be the same as how they appear locally.; Find the first 7 characters of each of the hashes.; Cherry-pick these all ",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:9234,Security,hash,hash,9234,"out a new private branch, starting from the head of the release branch (``git checkout -b prepare-qutip-4.6.1 upstream/qutip-4.6.X``).; You can call this branch whatever you like (in the example it is ``prepare-qutip-4.6.1``), because it will only be used to make a pull request.; #. Cherry-pick all the commits that will be added to this release in order, including your PR that wrote the new changelog entries (this will be the last one you cherry-pick).; You will want to use ``git log`` to find the relevant commits, going from **oldest to newest** (their ""age"" is when they were merged into ``master``, not when the PR was first opened).; The command is slightly different depending on which merge strategy was used for a particular PR:. - ""merge"": you only need to find one commit though the log will have included several; there will be an entry in ``git log`` with a title such as ""Merge pull request #1000 from <...>"".; Note the first 7 characters of its hash.; Cherry-pick this by ``git cherry-pick --mainline 1 <hash>``.; - ""squash and merge"": there will only be a single commit for the entire PR.; Its name will be ""<Name of the pull request> (#1000)"".; Note the first 7 characters of its hash.; Cherry-pick this by ``git cherry-pick <hash>``.; - ""rebase and merge"": this is the most difficult, because there will be many commits that you will have to find manually, and cherry-pick all of them.; Go to the GitHub page for this PR, and go to the ""Commits"" tab.; Using your local ``git log`` (you may find ``git log --oneline`` useful), find the hash for every single commit that is listed on the GitHub page, in order from **oldest to newest** (top-to-bottom in the GitHub view, which is bottom-to-top in ``git log``).; You will need to use the commit message to do this; the hashes that GitHub reports will probably not be the same as how they appear locally.; Find the first 7 characters of each of the hashes.; Cherry-pick these all in one go by ``git cherry-pick <hash1> <hash2> ... <",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:9412,Security,hash,hash,9412,"e example it is ``prepare-qutip-4.6.1``), because it will only be used to make a pull request.; #. Cherry-pick all the commits that will be added to this release in order, including your PR that wrote the new changelog entries (this will be the last one you cherry-pick).; You will want to use ``git log`` to find the relevant commits, going from **oldest to newest** (their ""age"" is when they were merged into ``master``, not when the PR was first opened).; The command is slightly different depending on which merge strategy was used for a particular PR:. - ""merge"": you only need to find one commit though the log will have included several; there will be an entry in ``git log`` with a title such as ""Merge pull request #1000 from <...>"".; Note the first 7 characters of its hash.; Cherry-pick this by ``git cherry-pick --mainline 1 <hash>``.; - ""squash and merge"": there will only be a single commit for the entire PR.; Its name will be ""<Name of the pull request> (#1000)"".; Note the first 7 characters of its hash.; Cherry-pick this by ``git cherry-pick <hash>``.; - ""rebase and merge"": this is the most difficult, because there will be many commits that you will have to find manually, and cherry-pick all of them.; Go to the GitHub page for this PR, and go to the ""Commits"" tab.; Using your local ``git log`` (you may find ``git log --oneline`` useful), find the hash for every single commit that is listed on the GitHub page, in order from **oldest to newest** (top-to-bottom in the GitHub view, which is bottom-to-top in ``git log``).; You will need to use the commit message to do this; the hashes that GitHub reports will probably not be the same as how they appear locally.; Find the first 7 characters of each of the hashes.; Cherry-pick these all in one go by ``git cherry-pick <hash1> <hash2> ... <hash10>``, where ``<hash1>`` is the oldest. If any of the cherry-picks have merge conflicts, first verify that you are cherry-picking in order from oldest to newest.; If you still have ",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:9458,Security,hash,hash,9458,"ause it will only be used to make a pull request.; #. Cherry-pick all the commits that will be added to this release in order, including your PR that wrote the new changelog entries (this will be the last one you cherry-pick).; You will want to use ``git log`` to find the relevant commits, going from **oldest to newest** (their ""age"" is when they were merged into ``master``, not when the PR was first opened).; The command is slightly different depending on which merge strategy was used for a particular PR:. - ""merge"": you only need to find one commit though the log will have included several; there will be an entry in ``git log`` with a title such as ""Merge pull request #1000 from <...>"".; Note the first 7 characters of its hash.; Cherry-pick this by ``git cherry-pick --mainline 1 <hash>``.; - ""squash and merge"": there will only be a single commit for the entire PR.; Its name will be ""<Name of the pull request> (#1000)"".; Note the first 7 characters of its hash.; Cherry-pick this by ``git cherry-pick <hash>``.; - ""rebase and merge"": this is the most difficult, because there will be many commits that you will have to find manually, and cherry-pick all of them.; Go to the GitHub page for this PR, and go to the ""Commits"" tab.; Using your local ``git log`` (you may find ``git log --oneline`` useful), find the hash for every single commit that is listed on the GitHub page, in order from **oldest to newest** (top-to-bottom in the GitHub view, which is bottom-to-top in ``git log``).; You will need to use the commit message to do this; the hashes that GitHub reports will probably not be the same as how they appear locally.; Find the first 7 characters of each of the hashes.; Cherry-pick these all in one go by ``git cherry-pick <hash1> <hash2> ... <hash10>``, where ``<hash1>`` is the oldest. If any of the cherry-picks have merge conflicts, first verify that you are cherry-picking in order from oldest to newest.; If you still have merge conflicts, you will either need to manua",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:9768,Security,hash,hash,9768,"ter``, not when the PR was first opened).; The command is slightly different depending on which merge strategy was used for a particular PR:. - ""merge"": you only need to find one commit though the log will have included several; there will be an entry in ``git log`` with a title such as ""Merge pull request #1000 from <...>"".; Note the first 7 characters of its hash.; Cherry-pick this by ``git cherry-pick --mainline 1 <hash>``.; - ""squash and merge"": there will only be a single commit for the entire PR.; Its name will be ""<Name of the pull request> (#1000)"".; Note the first 7 characters of its hash.; Cherry-pick this by ``git cherry-pick <hash>``.; - ""rebase and merge"": this is the most difficult, because there will be many commits that you will have to find manually, and cherry-pick all of them.; Go to the GitHub page for this PR, and go to the ""Commits"" tab.; Using your local ``git log`` (you may find ``git log --oneline`` useful), find the hash for every single commit that is listed on the GitHub page, in order from **oldest to newest** (top-to-bottom in the GitHub view, which is bottom-to-top in ``git log``).; You will need to use the commit message to do this; the hashes that GitHub reports will probably not be the same as how they appear locally.; Find the first 7 characters of each of the hashes.; Cherry-pick these all in one go by ``git cherry-pick <hash1> <hash2> ... <hash10>``, where ``<hash1>`` is the oldest. If any of the cherry-picks have merge conflicts, first verify that you are cherry-picking in order from oldest to newest.; If you still have merge conflicts, you will either need to manually fix them (if it is a *very* simple fix), or else you will need to find which additional PR this patch depends on, and restart the bug fix process including this additional patch.; This generally should not happen if you are sticking to very small bug fixes; if the fixes had far-reaching changes, a new minor release may be more appropriate.; #. Change the ``VERSION",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:9999,Security,hash,hashes,9999," will have included several; there will be an entry in ``git log`` with a title such as ""Merge pull request #1000 from <...>"".; Note the first 7 characters of its hash.; Cherry-pick this by ``git cherry-pick --mainline 1 <hash>``.; - ""squash and merge"": there will only be a single commit for the entire PR.; Its name will be ""<Name of the pull request> (#1000)"".; Note the first 7 characters of its hash.; Cherry-pick this by ``git cherry-pick <hash>``.; - ""rebase and merge"": this is the most difficult, because there will be many commits that you will have to find manually, and cherry-pick all of them.; Go to the GitHub page for this PR, and go to the ""Commits"" tab.; Using your local ``git log`` (you may find ``git log --oneline`` useful), find the hash for every single commit that is listed on the GitHub page, in order from **oldest to newest** (top-to-bottom in the GitHub view, which is bottom-to-top in ``git log``).; You will need to use the commit message to do this; the hashes that GitHub reports will probably not be the same as how they appear locally.; Find the first 7 characters of each of the hashes.; Cherry-pick these all in one go by ``git cherry-pick <hash1> <hash2> ... <hash10>``, where ``<hash1>`` is the oldest. If any of the cherry-picks have merge conflicts, first verify that you are cherry-picking in order from oldest to newest.; If you still have merge conflicts, you will either need to manually fix them (if it is a *very* simple fix), or else you will need to find which additional PR this patch depends on, and restart the bug fix process including this additional patch.; This generally should not happen if you are sticking to very small bug fixes; if the fixes had far-reaching changes, a new minor release may be more appropriate.; #. Change the ``VERSION`` file by bumping the last number up by one (double-digit numbers are fine, so ``4.6.10`` comes after ``4.6.9``), and commit the change.; #. Push this branch to your fork, and make a pull request aga",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:10128,Security,hash,hashes,10128,"ll request #1000 from <...>"".; Note the first 7 characters of its hash.; Cherry-pick this by ``git cherry-pick --mainline 1 <hash>``.; - ""squash and merge"": there will only be a single commit for the entire PR.; Its name will be ""<Name of the pull request> (#1000)"".; Note the first 7 characters of its hash.; Cherry-pick this by ``git cherry-pick <hash>``.; - ""rebase and merge"": this is the most difficult, because there will be many commits that you will have to find manually, and cherry-pick all of them.; Go to the GitHub page for this PR, and go to the ""Commits"" tab.; Using your local ``git log`` (you may find ``git log --oneline`` useful), find the hash for every single commit that is listed on the GitHub page, in order from **oldest to newest** (top-to-bottom in the GitHub view, which is bottom-to-top in ``git log``).; You will need to use the commit message to do this; the hashes that GitHub reports will probably not be the same as how they appear locally.; Find the first 7 characters of each of the hashes.; Cherry-pick these all in one go by ``git cherry-pick <hash1> <hash2> ... <hash10>``, where ``<hash1>`` is the oldest. If any of the cherry-picks have merge conflicts, first verify that you are cherry-picking in order from oldest to newest.; If you still have merge conflicts, you will either need to manually fix them (if it is a *very* simple fix), or else you will need to find which additional PR this patch depends on, and restart the bug fix process including this additional patch.; This generally should not happen if you are sticking to very small bug fixes; if the fixes had far-reaching changes, a new minor release may be more appropriate.; #. Change the ``VERSION`` file by bumping the last number up by one (double-digit numbers are fine, so ``4.6.10`` comes after ``4.6.9``), and commit the change.; #. Push this branch to your fork, and make a pull request against the release branch.; On GitHub in the PR screen, you will need to change the ""Base"" branch t",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:18481,Security,checksum,checksum,18481,"efs/tags/v4.6.0.tar.gz``.; * For a minor or major release links to the last micro release of the previous version will need to be moved (copied) to the 'Previous releases' section. - Edit ``_includes/sidebar.html``. * Add the new version and release date. Only actively developed version should be listed. Micro replace the previous entry but the last major can be kept.; * Link to the installation instruction, documentation, source code and changelog should be updated. - Edit ``documentation.html``. * For major and minor release, the previous release tags should be moved (copied) to the 'Previous releases' section and the links to the readthedocs of the new version added the to 'Latest releases' section. .. _cforge:. Conda Forge; +++++++++++. If not done previously then fork the `qutip-feedstock <https://github.com/conda-forge/qutip-feedstock>`_. Checkout a new branch on your fork, e.g. ::. $ git checkout -b version-4.0.2. Find the sha256 checksum for the tarball that the GitHub web interface generated when you produced the release called ""Source code"".; This is *not* the sdist that you downloaded earlier, it's a new file that GitHub labels ""Source code"".; When you download it, though, it will have a name that *looks* like it's the sdist ::. $ openssl sha256 qutip-4.0.2.tar.gz. Edit the ``recipe/meta.yaml`` file.; Change the version at the top of the file, and update the sha256 checksum.; Check that the recipe package version requirements at least match those in ``setup.cfg``, and that any changes to the build process are reflected in ``meta.yml``.; Also ensure that the build number is reset ::. build:; number: 0. Push changes to your fork, e.g. ::. $ git push --set-upstream origin version-4.0.2. Make a Pull Request.; This will trigger tests of the package build process. If (when) the tests pass, the PR can be merged, which will trigger the upload of the packages to the conda-forge channel.; To test the packages, add the conda-forge channel with lowest priority ::. $ c",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:18929,Security,checksum,checksum,18929,"leases' section. - Edit ``_includes/sidebar.html``. * Add the new version and release date. Only actively developed version should be listed. Micro replace the previous entry but the last major can be kept.; * Link to the installation instruction, documentation, source code and changelog should be updated. - Edit ``documentation.html``. * For major and minor release, the previous release tags should be moved (copied) to the 'Previous releases' section and the links to the readthedocs of the new version added the to 'Latest releases' section. .. _cforge:. Conda Forge; +++++++++++. If not done previously then fork the `qutip-feedstock <https://github.com/conda-forge/qutip-feedstock>`_. Checkout a new branch on your fork, e.g. ::. $ git checkout -b version-4.0.2. Find the sha256 checksum for the tarball that the GitHub web interface generated when you produced the release called ""Source code"".; This is *not* the sdist that you downloaded earlier, it's a new file that GitHub labels ""Source code"".; When you download it, though, it will have a name that *looks* like it's the sdist ::. $ openssl sha256 qutip-4.0.2.tar.gz. Edit the ``recipe/meta.yaml`` file.; Change the version at the top of the file, and update the sha256 checksum.; Check that the recipe package version requirements at least match those in ``setup.cfg``, and that any changes to the build process are reflected in ``meta.yml``.; Also ensure that the build number is reset ::. build:; number: 0. Push changes to your fork, e.g. ::. $ git push --set-upstream origin version-4.0.2. Make a Pull Request.; This will trigger tests of the package build process. If (when) the tests pass, the PR can be merged, which will trigger the upload of the packages to the conda-forge channel.; To test the packages, add the conda-forge channel with lowest priority ::. $ conda config --append channels conda-forge. This should mean that the prerequistes come from the default channel, but the qutip packages are found in conda-forge.; ",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:2444,Testability,test,tests,2444,"e not backwards-compatible may only be made in a major release.; New features that do not affect backwards-compatibility can be made in a minor release.; Bug fix releases should be small, only fix bugs, and not introduce any new features. There are a few steps that *should* have been kept up-to-date during day-to-day development, but might not be quite accurate.; For every change that is going to be part of your release, make sure that:. - The user guide in the documentation is updated with any new features, or changes to existing features.; - Any new API classes or functions have entries in a suitable RST file in ``doc/apidoc``.; - Any new or changed docstrings are up-to-date and render correctly in the API documentation. Please make a normal PR to ``master`` correcting anything missing from these points and have it merged before you begin the release, if necessary. .. _update-requirement:. Updating the Requirements; -------------------------. Ensure that QuTiP's tests pass on the oldest version supported in the requirements.; On major and minor version, requirements can be adjusted upwards, but patch release must not change minimum requirements.; We follow `NEP29`_ for minimum supported versions ::. - All minor versions of Python released 42 months prior to the project, and at minimum the two latest minor versions.; - All minor versions of numpy and scipy released in the 24 months prior to the project, and at minimum the last three minor versions. If dependency versions need to be updated, update them in the master branch. The following files may need to be updated: `.github/workflows/tests.yml`, `setup.cfg` and `roadmap.rst`. Finally, ensure that PyPI wheels and conda builds cover at least these versions. .. _NEP29: https://numpy.org/neps/nep-0029-deprecation_policy.html. .. _update-changelog:. Updating the Changelog; ----------------------. This needs to be done no matter what type of release is being made. #. Create a new branch to use to make a pull request.; ",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:3079,Testability,test,tests,3079,"e RST file in ``doc/apidoc``.; - Any new or changed docstrings are up-to-date and render correctly in the API documentation. Please make a normal PR to ``master`` correcting anything missing from these points and have it merged before you begin the release, if necessary. .. _update-requirement:. Updating the Requirements; -------------------------. Ensure that QuTiP's tests pass on the oldest version supported in the requirements.; On major and minor version, requirements can be adjusted upwards, but patch release must not change minimum requirements.; We follow `NEP29`_ for minimum supported versions ::. - All minor versions of Python released 42 months prior to the project, and at minimum the two latest minor versions.; - All minor versions of numpy and scipy released in the 24 months prior to the project, and at minimum the last three minor versions. If dependency versions need to be updated, update them in the master branch. The following files may need to be updated: `.github/workflows/tests.yml`, `setup.cfg` and `roadmap.rst`. Finally, ensure that PyPI wheels and conda builds cover at least these versions. .. _NEP29: https://numpy.org/neps/nep-0029-deprecation_policy.html. .. _update-changelog:. Updating the Changelog; ----------------------. This needs to be done no matter what type of release is being made. #. Create a new branch to use to make a pull request.; #. Update the changelog using ``towncrier``:. towncrier build --version=<version-number>. Where ``<version-number>`` is the expected version number of the release. #. Make a pull request on the main ``qutip/qutip`` repository with this changelog, and get other members of the admin team to approve it.; #. Merge this into ``master``. Now jump to release_ if you are making a major or minor release, or bugfix_ if you are only fixing bugs in a previous release. .. _release:. Create a New Minor or Major Release; -----------------------------------. This involves making a new branch to hold the release and ad",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:6373,Testability,test,tests,6373,"x.; For example, if you are releasing the first release of the minor 4.7 track, set ``VERSION`` to contain the string ``4.7.0``.; (*Special circumstances*: if you are making an alpha, beta or release candidate release, append a ``.a<n>``, ``.b<n>`` or ``.rc<n>`` to the version string, where ``<n>`` is an integer starting from 0 that counts how many of that pre-release track there have been.); - Edit ``setup.cfg`` by changing the ""Development Status"" line in the ``classifiers`` section to ::. Development Status :: 5 - Production/Stable. Commit both changes (``git add VERSION setup.cfg; git commit -m ""Set release mode for 4.7.0""``), and then push them to your fork (``git push -u origin prepare-qutip-4.7.0``); #. Using GitHub, make a pull request to the release branch (e.g. ``qutip-4.7.X``) using this branch that you just created.; You will need to change the ""base branch"" in the pull request, because GitHub will always try to make the PR against ``master`` at first.; When the tests have passed, merge this in.; #. Finally, back on ``master``, make a new pull request that changes the ``VERSION`` file to be ``<next-expected-version>.dev``, for example ``4.8.0.dev``.; The ""Development Status"" in ``setup.cfg`` on ``master`` should not have changed, and should be ::. Development Status :: 2 - Pre-Alpha. because ``master`` is never directly released. You should now have a branch that you can see on the GitHub website that is called ``qutip-4.7.X`` (or whatever minor version), and the state of the code in it should be exactly what you want to release as the new minor release.; If you notice you have made a mistake, you can make additional pull requests to the release branch to fix it.; ``master`` should look pretty similar, except the ``VERSION`` will be higher and have a ``.dev`` suffix, and the ""Development Status"" in ``setup.cfg`` will be different. * Activate the readthedocs build for the newly created version branch and set it as the latest. You are now ready to actually",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:8696,Testability,log,log,8696,"-to-date (``git checkout master; git pull upstream master``).; In particular, make sure the changelog you wrote in the first step is visible.; #. Find the branch of the release that you will be modifying.; This should already exist on the ``qutip/qutip`` repository, and be called ``qutip-<major>.<minor>.X`` (e.g. ``qutip-4.6.X``).; If you cannot see it, run ``git fetch upstream`` to update all the branch references from the main repository.; Checkout a new private branch, starting from the head of the release branch (``git checkout -b prepare-qutip-4.6.1 upstream/qutip-4.6.X``).; You can call this branch whatever you like (in the example it is ``prepare-qutip-4.6.1``), because it will only be used to make a pull request.; #. Cherry-pick all the commits that will be added to this release in order, including your PR that wrote the new changelog entries (this will be the last one you cherry-pick).; You will want to use ``git log`` to find the relevant commits, going from **oldest to newest** (their ""age"" is when they were merged into ``master``, not when the PR was first opened).; The command is slightly different depending on which merge strategy was used for a particular PR:. - ""merge"": you only need to find one commit though the log will have included several; there will be an entry in ``git log`` with a title such as ""Merge pull request #1000 from <...>"".; Note the first 7 characters of its hash.; Cherry-pick this by ``git cherry-pick --mainline 1 <hash>``.; - ""squash and merge"": there will only be a single commit for the entire PR.; Its name will be ""<Name of the pull request> (#1000)"".; Note the first 7 characters of its hash.; Cherry-pick this by ``git cherry-pick <hash>``.; - ""rebase and merge"": this is the most difficult, because there will be many commits that you will have to find manually, and cherry-pick all of them.; Go to the GitHub page for this PR, and go to the ""Commits"" tab.; Using your local ``git log`` (you may find ``git log --oneline`` useful), f",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:9009,Testability,log,log,9009,"qutip-<major>.<minor>.X`` (e.g. ``qutip-4.6.X``).; If you cannot see it, run ``git fetch upstream`` to update all the branch references from the main repository.; Checkout a new private branch, starting from the head of the release branch (``git checkout -b prepare-qutip-4.6.1 upstream/qutip-4.6.X``).; You can call this branch whatever you like (in the example it is ``prepare-qutip-4.6.1``), because it will only be used to make a pull request.; #. Cherry-pick all the commits that will be added to this release in order, including your PR that wrote the new changelog entries (this will be the last one you cherry-pick).; You will want to use ``git log`` to find the relevant commits, going from **oldest to newest** (their ""age"" is when they were merged into ``master``, not when the PR was first opened).; The command is slightly different depending on which merge strategy was used for a particular PR:. - ""merge"": you only need to find one commit though the log will have included several; there will be an entry in ``git log`` with a title such as ""Merge pull request #1000 from <...>"".; Note the first 7 characters of its hash.; Cherry-pick this by ``git cherry-pick --mainline 1 <hash>``.; - ""squash and merge"": there will only be a single commit for the entire PR.; Its name will be ""<Name of the pull request> (#1000)"".; Note the first 7 characters of its hash.; Cherry-pick this by ``git cherry-pick <hash>``.; - ""rebase and merge"": this is the most difficult, because there will be many commits that you will have to find manually, and cherry-pick all of them.; Go to the GitHub page for this PR, and go to the ""Commits"" tab.; Using your local ``git log`` (you may find ``git log --oneline`` useful), find the hash for every single commit that is listed on the GitHub page, in order from **oldest to newest** (top-to-bottom in the GitHub view, which is bottom-to-top in ``git log``).; You will need to use the commit message to do this; the hashes that GitHub reports will probably not",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:9073,Testability,log,log,9073,"qutip-<major>.<minor>.X`` (e.g. ``qutip-4.6.X``).; If you cannot see it, run ``git fetch upstream`` to update all the branch references from the main repository.; Checkout a new private branch, starting from the head of the release branch (``git checkout -b prepare-qutip-4.6.1 upstream/qutip-4.6.X``).; You can call this branch whatever you like (in the example it is ``prepare-qutip-4.6.1``), because it will only be used to make a pull request.; #. Cherry-pick all the commits that will be added to this release in order, including your PR that wrote the new changelog entries (this will be the last one you cherry-pick).; You will want to use ``git log`` to find the relevant commits, going from **oldest to newest** (their ""age"" is when they were merged into ``master``, not when the PR was first opened).; The command is slightly different depending on which merge strategy was used for a particular PR:. - ""merge"": you only need to find one commit though the log will have included several; there will be an entry in ``git log`` with a title such as ""Merge pull request #1000 from <...>"".; Note the first 7 characters of its hash.; Cherry-pick this by ``git cherry-pick --mainline 1 <hash>``.; - ""squash and merge"": there will only be a single commit for the entire PR.; Its name will be ""<Name of the pull request> (#1000)"".; Note the first 7 characters of its hash.; Cherry-pick this by ``git cherry-pick <hash>``.; - ""rebase and merge"": this is the most difficult, because there will be many commits that you will have to find manually, and cherry-pick all of them.; Go to the GitHub page for this PR, and go to the ""Commits"" tab.; Using your local ``git log`` (you may find ``git log --oneline`` useful), find the hash for every single commit that is listed on the GitHub page, in order from **oldest to newest** (top-to-bottom in the GitHub view, which is bottom-to-top in ``git log``).; You will need to use the commit message to do this; the hashes that GitHub reports will probably not",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:9708,Testability,log,log,9708,"ter``, not when the PR was first opened).; The command is slightly different depending on which merge strategy was used for a particular PR:. - ""merge"": you only need to find one commit though the log will have included several; there will be an entry in ``git log`` with a title such as ""Merge pull request #1000 from <...>"".; Note the first 7 characters of its hash.; Cherry-pick this by ``git cherry-pick --mainline 1 <hash>``.; - ""squash and merge"": there will only be a single commit for the entire PR.; Its name will be ""<Name of the pull request> (#1000)"".; Note the first 7 characters of its hash.; Cherry-pick this by ``git cherry-pick <hash>``.; - ""rebase and merge"": this is the most difficult, because there will be many commits that you will have to find manually, and cherry-pick all of them.; Go to the GitHub page for this PR, and go to the ""Commits"" tab.; Using your local ``git log`` (you may find ``git log --oneline`` useful), find the hash for every single commit that is listed on the GitHub page, in order from **oldest to newest** (top-to-bottom in the GitHub view, which is bottom-to-top in ``git log``).; You will need to use the commit message to do this; the hashes that GitHub reports will probably not be the same as how they appear locally.; Find the first 7 characters of each of the hashes.; Cherry-pick these all in one go by ``git cherry-pick <hash1> <hash2> ... <hash10>``, where ``<hash1>`` is the oldest. If any of the cherry-picks have merge conflicts, first verify that you are cherry-picking in order from oldest to newest.; If you still have merge conflicts, you will either need to manually fix them (if it is a *very* simple fix), or else you will need to find which additional PR this patch depends on, and restart the bug fix process including this additional patch.; This generally should not happen if you are sticking to very small bug fixes; if the fixes had far-reaching changes, a new minor release may be more appropriate.; #. Change the ``VERSION",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:9734,Testability,log,log,9734,"ter``, not when the PR was first opened).; The command is slightly different depending on which merge strategy was used for a particular PR:. - ""merge"": you only need to find one commit though the log will have included several; there will be an entry in ``git log`` with a title such as ""Merge pull request #1000 from <...>"".; Note the first 7 characters of its hash.; Cherry-pick this by ``git cherry-pick --mainline 1 <hash>``.; - ""squash and merge"": there will only be a single commit for the entire PR.; Its name will be ""<Name of the pull request> (#1000)"".; Note the first 7 characters of its hash.; Cherry-pick this by ``git cherry-pick <hash>``.; - ""rebase and merge"": this is the most difficult, because there will be many commits that you will have to find manually, and cherry-pick all of them.; Go to the GitHub page for this PR, and go to the ""Commits"" tab.; Using your local ``git log`` (you may find ``git log --oneline`` useful), find the hash for every single commit that is listed on the GitHub page, in order from **oldest to newest** (top-to-bottom in the GitHub view, which is bottom-to-top in ``git log``).; You will need to use the commit message to do this; the hashes that GitHub reports will probably not be the same as how they appear locally.; Find the first 7 characters of each of the hashes.; Cherry-pick these all in one go by ``git cherry-pick <hash1> <hash2> ... <hash10>``, where ``<hash1>`` is the oldest. If any of the cherry-picks have merge conflicts, first verify that you are cherry-picking in order from oldest to newest.; If you still have merge conflicts, you will either need to manually fix them (if it is a *very* simple fix), or else you will need to find which additional PR this patch depends on, and restart the bug fix process including this additional patch.; This generally should not happen if you are sticking to very small bug fixes; if the fixes had far-reaching changes, a new minor release may be more appropriate.; #. Change the ``VERSION",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:9934,Testability,log,log,9934,"ter``, not when the PR was first opened).; The command is slightly different depending on which merge strategy was used for a particular PR:. - ""merge"": you only need to find one commit though the log will have included several; there will be an entry in ``git log`` with a title such as ""Merge pull request #1000 from <...>"".; Note the first 7 characters of its hash.; Cherry-pick this by ``git cherry-pick --mainline 1 <hash>``.; - ""squash and merge"": there will only be a single commit for the entire PR.; Its name will be ""<Name of the pull request> (#1000)"".; Note the first 7 characters of its hash.; Cherry-pick this by ``git cherry-pick <hash>``.; - ""rebase and merge"": this is the most difficult, because there will be many commits that you will have to find manually, and cherry-pick all of them.; Go to the GitHub page for this PR, and go to the ""Commits"" tab.; Using your local ``git log`` (you may find ``git log --oneline`` useful), find the hash for every single commit that is listed on the GitHub page, in order from **oldest to newest** (top-to-bottom in the GitHub view, which is bottom-to-top in ``git log``).; You will need to use the commit message to do this; the hashes that GitHub reports will probably not be the same as how they appear locally.; Find the first 7 characters of each of the hashes.; Cherry-pick these all in one go by ``git cherry-pick <hash1> <hash2> ... <hash10>``, where ``<hash1>`` is the oldest. If any of the cherry-picks have merge conflicts, first verify that you are cherry-picking in order from oldest to newest.; If you still have merge conflicts, you will either need to manually fix them (if it is a *very* simple fix), or else you will need to find which additional PR this patch depends on, and restart the bug fix process including this additional patch.; This generally should not happen if you are sticking to very small bug fixes; if the fixes had far-reaching changes, a new minor release may be more appropriate.; #. Change the ``VERSION",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:11334,Testability,test,tests,11334,"st to newest.; If you still have merge conflicts, you will either need to manually fix them (if it is a *very* simple fix), or else you will need to find which additional PR this patch depends on, and restart the bug fix process including this additional patch.; This generally should not happen if you are sticking to very small bug fixes; if the fixes had far-reaching changes, a new minor release may be more appropriate.; #. Change the ``VERSION`` file by bumping the last number up by one (double-digit numbers are fine, so ``4.6.10`` comes after ``4.6.9``), and commit the change.; #. Push this branch to your fork, and make a pull request against the release branch.; On GitHub in the PR screen, you will need to change the ""Base"" branch to ``qutip-4.6.X`` (or whatever version), because GitHub will default to making it against ``master``.; It should be quite clear if you have forgotten to do this, because there will probably be many merge conflicts.; Once the tests have passed and you have another admin's approval, merge the PR. You should now see that the ``qutip-4.6.X`` (or whatever) branch on GitHub has been updated, and now includes all the changes you have just made.; If you have made a mistake, feel free to make additonal PRs to rectify the situation. You are now ready to actually perform the release.; Go to deploy_. .. _deploy:. Build Release Distribution and Deploy; +++++++++++++++++++++++++++++++++++++. This step builds the source (sdist) and binary (wheel) distributions, and uploads them to PyPI (pip).; You will also be able to download the built files yourself in order to upload them to the QuTiP website. Build and Deploy; ----------------. This is handled entirely by a GitHub Action.; Go to the `""Actions"" tab at the top of the QuTiP code repository <https://github.com/qutip/qutip/actions>`_.; Click on the ""Build wheels, optionally deploy to PyPI"" action in the left-hand sidebar.; Click the ""Run workflow"" dropdown in the header notification; it should look li",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:13185,Testability,test,testing,13185,">`_.; Click on the ""Build wheels, optionally deploy to PyPI"" action in the left-hand sidebar.; Click the ""Run workflow"" dropdown in the header notification; it should look like the image below. .. image:: ../figures/release_guide_run_build_workflow.png. - Use the drop-down menu to choose the branch or tag you want to release from.; This should be called ``qutip-4.5.X`` or similar, depending on what you made earlier.; This must *never* be ``master``.; - To make the release to PyPI, type the branch name (e.g. ``qutip-4.5.X``) into the ""Confirm chosen branch name [...]"" field.; You *may* leave this field blank to skip the deployment and only build the package.; - (Special circumstances) If for some reason you need to override the version number (for example if the previous deployment to PyPI only partially succeeded), you can type a valid Python version identifier into the ""Override version number"" field.; You probably do not need to do this.; The mechanism is designed to make alpha-testing major upgrades with nightly releases easier.; For even a bugfix release, you should commit the change to the ``VERSION`` file.; - Click the lower ""Run workflow"" to perform the build and deployment. At this point, the deployment will take care of itself.; It should take between 30 minutes and an hour, after which the new version will be available for install by ``pip install qutip``.; You should see the new version appear on `QuTiP's PyPI page <https://pypi.org/project/qutip>`_. Download Built Files; --------------------. When the build is complete, click into its summary screen.; This is the main screen used to both monitor the build and see its output, and should look like the below image on a success. .. image:: ../figures/release_guide_after_workflow.png. The built binary wheels and the source distribution are the ""build artifacts"" at the bottom.; You need to download both the wheels and the source distribution.; Save them on your computer, and unzip both files; you should have m",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:19294,Testability,test,tests,19294,"leases' section. - Edit ``_includes/sidebar.html``. * Add the new version and release date. Only actively developed version should be listed. Micro replace the previous entry but the last major can be kept.; * Link to the installation instruction, documentation, source code and changelog should be updated. - Edit ``documentation.html``. * For major and minor release, the previous release tags should be moved (copied) to the 'Previous releases' section and the links to the readthedocs of the new version added the to 'Latest releases' section. .. _cforge:. Conda Forge; +++++++++++. If not done previously then fork the `qutip-feedstock <https://github.com/conda-forge/qutip-feedstock>`_. Checkout a new branch on your fork, e.g. ::. $ git checkout -b version-4.0.2. Find the sha256 checksum for the tarball that the GitHub web interface generated when you produced the release called ""Source code"".; This is *not* the sdist that you downloaded earlier, it's a new file that GitHub labels ""Source code"".; When you download it, though, it will have a name that *looks* like it's the sdist ::. $ openssl sha256 qutip-4.0.2.tar.gz. Edit the ``recipe/meta.yaml`` file.; Change the version at the top of the file, and update the sha256 checksum.; Check that the recipe package version requirements at least match those in ``setup.cfg``, and that any changes to the build process are reflected in ``meta.yml``.; Also ensure that the build number is reset ::. build:; number: 0. Push changes to your fork, e.g. ::. $ git push --set-upstream origin version-4.0.2. Make a Pull Request.; This will trigger tests of the package build process. If (when) the tests pass, the PR can be merged, which will trigger the upload of the packages to the conda-forge channel.; To test the packages, add the conda-forge channel with lowest priority ::. $ conda config --append channels conda-forge. This should mean that the prerequistes come from the default channel, but the qutip packages are found in conda-forge.; ",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:19344,Testability,test,tests,19344,"leases' section. - Edit ``_includes/sidebar.html``. * Add the new version and release date. Only actively developed version should be listed. Micro replace the previous entry but the last major can be kept.; * Link to the installation instruction, documentation, source code and changelog should be updated. - Edit ``documentation.html``. * For major and minor release, the previous release tags should be moved (copied) to the 'Previous releases' section and the links to the readthedocs of the new version added the to 'Latest releases' section. .. _cforge:. Conda Forge; +++++++++++. If not done previously then fork the `qutip-feedstock <https://github.com/conda-forge/qutip-feedstock>`_. Checkout a new branch on your fork, e.g. ::. $ git checkout -b version-4.0.2. Find the sha256 checksum for the tarball that the GitHub web interface generated when you produced the release called ""Source code"".; This is *not* the sdist that you downloaded earlier, it's a new file that GitHub labels ""Source code"".; When you download it, though, it will have a name that *looks* like it's the sdist ::. $ openssl sha256 qutip-4.0.2.tar.gz. Edit the ``recipe/meta.yaml`` file.; Change the version at the top of the file, and update the sha256 checksum.; Check that the recipe package version requirements at least match those in ``setup.cfg``, and that any changes to the build process are reflected in ``meta.yml``.; Also ensure that the build number is reset ::. build:; number: 0. Push changes to your fork, e.g. ::. $ git push --set-upstream origin version-4.0.2. Make a Pull Request.; This will trigger tests of the package build process. If (when) the tests pass, the PR can be merged, which will trigger the upload of the packages to the conda-forge channel.; To test the packages, add the conda-forge channel with lowest priority ::. $ conda config --append channels conda-forge. This should mean that the prerequistes come from the default channel, but the qutip packages are found in conda-forge.; ",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:19456,Testability,test,test,19456,"leases' section. - Edit ``_includes/sidebar.html``. * Add the new version and release date. Only actively developed version should be listed. Micro replace the previous entry but the last major can be kept.; * Link to the installation instruction, documentation, source code and changelog should be updated. - Edit ``documentation.html``. * For major and minor release, the previous release tags should be moved (copied) to the 'Previous releases' section and the links to the readthedocs of the new version added the to 'Latest releases' section. .. _cforge:. Conda Forge; +++++++++++. If not done previously then fork the `qutip-feedstock <https://github.com/conda-forge/qutip-feedstock>`_. Checkout a new branch on your fork, e.g. ::. $ git checkout -b version-4.0.2. Find the sha256 checksum for the tarball that the GitHub web interface generated when you produced the release called ""Source code"".; This is *not* the sdist that you downloaded earlier, it's a new file that GitHub labels ""Source code"".; When you download it, though, it will have a name that *looks* like it's the sdist ::. $ openssl sha256 qutip-4.0.2.tar.gz. Edit the ``recipe/meta.yaml`` file.; Change the version at the top of the file, and update the sha256 checksum.; Check that the recipe package version requirements at least match those in ``setup.cfg``, and that any changes to the build process are reflected in ``meta.yml``.; Also ensure that the build number is reset ::. build:; number: 0. Push changes to your fork, e.g. ::. $ git push --set-upstream origin version-4.0.2. Make a Pull Request.; This will trigger tests of the package build process. If (when) the tests pass, the PR can be merged, which will trigger the upload of the packages to the conda-forge channel.; To test the packages, add the conda-forge channel with lowest priority ::. $ conda config --append channels conda-forge. This should mean that the prerequistes come from the default channel, but the qutip packages are found in conda-forge.; ",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:1918,Usability,guid,guide,1918,"The Release Branch; +++++++++++++++++++++++++++++. In this step you will prepare a git branch on the main QuTiP repository that has the state of the code that is going to be released.; This procedure is quite different if you are releasing a new minor or major version compared to if you are making a bugfix patch release.; For a new minor or major version, do update-changelog_ and then jump to release_.; For a bug fix to an existing release, do update-changelog_ and then jump to bugfix_. Changes that are not backwards-compatible may only be made in a major release.; New features that do not affect backwards-compatibility can be made in a minor release.; Bug fix releases should be small, only fix bugs, and not introduce any new features. There are a few steps that *should* have been kept up-to-date during day-to-day development, but might not be quite accurate.; For every change that is going to be part of your release, make sure that:. - The user guide in the documentation is updated with any new features, or changes to existing features.; - Any new API classes or functions have entries in a suitable RST file in ``doc/apidoc``.; - Any new or changed docstrings are up-to-date and render correctly in the API documentation. Please make a normal PR to ``master`` correcting anything missing from these points and have it merged before you begin the release, if necessary. .. _update-requirement:. Updating the Requirements; -------------------------. Ensure that QuTiP's tests pass on the oldest version supported in the requirements.; On major and minor version, requirements can be adjusted upwards, but patch release must not change minimum requirements.; We follow `NEP29`_ for minimum supported versions ::. - All minor versions of Python released 42 months prior to the project, and at minimum the two latest minor versions.; - All minor versions of numpy and scipy released in the 24 months prior to the project, and at minimum the last three minor versions. If dependency versio",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:10474,Usability,simpl,simple,10474,"e most difficult, because there will be many commits that you will have to find manually, and cherry-pick all of them.; Go to the GitHub page for this PR, and go to the ""Commits"" tab.; Using your local ``git log`` (you may find ``git log --oneline`` useful), find the hash for every single commit that is listed on the GitHub page, in order from **oldest to newest** (top-to-bottom in the GitHub view, which is bottom-to-top in ``git log``).; You will need to use the commit message to do this; the hashes that GitHub reports will probably not be the same as how they appear locally.; Find the first 7 characters of each of the hashes.; Cherry-pick these all in one go by ``git cherry-pick <hash1> <hash2> ... <hash10>``, where ``<hash1>`` is the oldest. If any of the cherry-picks have merge conflicts, first verify that you are cherry-picking in order from oldest to newest.; If you still have merge conflicts, you will either need to manually fix them (if it is a *very* simple fix), or else you will need to find which additional PR this patch depends on, and restart the bug fix process including this additional patch.; This generally should not happen if you are sticking to very small bug fixes; if the fixes had far-reaching changes, a new minor release may be more appropriate.; #. Change the ``VERSION`` file by bumping the last number up by one (double-digit numbers are fine, so ``4.6.10`` comes after ``4.6.9``), and commit the change.; #. Push this branch to your fork, and make a pull request against the release branch.; On GitHub in the PR screen, you will need to change the ""Base"" branch to ``qutip-4.6.X`` (or whatever version), because GitHub will default to making it against ``master``.; It should be quite clear if you have forgotten to do this, because there will probably be many merge conflicts.; Once the tests have passed and you have another admin's approval, merge the PR. You should now see that the ``qutip-4.6.X`` (or whatever) branch on GitHub has been updated, an",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst:11231,Usability,clear,clear,11231,"he cherry-picks have merge conflicts, first verify that you are cherry-picking in order from oldest to newest.; If you still have merge conflicts, you will either need to manually fix them (if it is a *very* simple fix), or else you will need to find which additional PR this patch depends on, and restart the bug fix process including this additional patch.; This generally should not happen if you are sticking to very small bug fixes; if the fixes had far-reaching changes, a new minor release may be more appropriate.; #. Change the ``VERSION`` file by bumping the last number up by one (double-digit numbers are fine, so ``4.6.10`` comes after ``4.6.9``), and commit the change.; #. Push this branch to your fork, and make a pull request against the release branch.; On GitHub in the PR screen, you will need to change the ""Base"" branch to ``qutip-4.6.X`` (or whatever version), because GitHub will default to making it against ``master``.; It should be quite clear if you have forgotten to do this, because there will probably be many merge conflicts.; Once the tests have passed and you have another admin's approval, merge the PR. You should now see that the ``qutip-4.6.X`` (or whatever) branch on GitHub has been updated, and now includes all the changes you have just made.; If you have made a mistake, feel free to make additonal PRs to rectify the situation. You are now ready to actually perform the release.; Go to deploy_. .. _deploy:. Build Release Distribution and Deploy; +++++++++++++++++++++++++++++++++++++. This step builds the source (sdist) and binary (wheel) distributions, and uploads them to PyPI (pip).; You will also be able to download the built files yourself in order to upload them to the QuTiP website. Build and Deploy; ----------------. This is handled entirely by a GitHub Action.; Go to the `""Actions"" tab at the top of the QuTiP code repository <https://github.com/qutip/qutip/actions>`_.; Click on the ""Build wheels, optionally deploy to PyPI"" action in the le",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst:2689,Availability,mainten,maintence,2689,"elated to QuTiP, and specifically those that are maintained by the; QuTiP Admim Team. Herin QuTiP will refer to the project / organisation and qutip; to the library for simulating quantum dyanmics. Should we be starting again from scratch, then we would probably chose another; name for the main qutip library, such as qutip-quantdyn. However, qutip is; famous, and the name will stay. Library package structure; =========================. With a name as general as Quantum Toolkit in Python, the scope for new code; modules to be added to qutip is very wide. The library was becoming increasingly; difficult to maintain, and in c. 2020 the QuTiP Admim Team decided to limit the; scope of the 'main' (for want of a better name) qutip package. This scope is; restricted to components for the simulation (solving) of the dynamics of quantum; systems. The scope includes utilities to support this, including analysis and; visualisation of output. At the same time, again with the intention of easing maintence, a decision to; limit dependences was agreed upon. Main qutip runtime code components should; depend only upon Numpy and Scipy. Installation (from source) requires Cython,; and some optional components also require Cython at runtime. Unit testing; requires Pytest. Visualisation (optional) components require Matplotlib. Due to the all encompassing nature of the plan to abstract the linear algebra; data layer, this enhancement (developed as part of a GSoC project) was allowed; the freedom (potential for non-backward compatibility) of requiring a major; release. The timing of such allows for a restructuring of the qutip compoments,; such that some that could be deemed out of scope could be packaged in a; different way -- that is, not installed as part of the main qutip package. Hence; the proposal for different types of package described next. With reference to; the :ref:`discussion above <what-is-qutip>` on the name QuTiP/qutip, the planned; restructuring suffers from confusing na",MatchSource.DOCS,doc/development/roadmap.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst:9560,Availability,mask,masking,9560,"objEvo`. .. _qtrl-mig:. Qtrl migration; --------------. :tag: qtrl-mig; :status: conceptualised; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. The components currently packaged as an integrated subpackage of qutip main will; be moved to separate package called Qtrl. This is the original codename of the; package before it was integrated into qutip. Also changes to exploit the new; data layer will be implemented. .. _ctrl-fw:. QuTiP control framework; -----------------------. :tag: ctrl-fw; :status: conceptualised; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. Create new package qutip-ctrlfw ""QuTiP Control Framework"". The aim is provide a; common framework that can be adopted by control optimisation packages, such that; different packages (algorithms) can be applied to the same problem. Classes for defining a controlled system:. - named control parameters. Scalar and n-dim. Continuous and discrete variables; - mapping of control parameters to dynamics generator args; - masking for control parameters to be optimised. Classes for time-dependent variable parameterisation. - piecewise constant; - piecewise linear; - Fourier basis; - more. Classes for defining an optimisation problem:. - single and multiple objectives. .. _qutip-optim:. QuTiP optimisation; ------------------. :tag: qutip-optim; :status: conceptualised; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. A wrapper for multi-variable optimisation functions. For instance those in; `scipy.optimize` (Nelder-Mead, BFGS), but also others, such as Bayesian; optimisation and other machine learning based approaches. Initially just; providing a common interface for quantum control optimisation, but applicable; more generally. .. _sympsi-mig:. Sympsi migration; ----------------. :tag: sympsi-mig; :status: conceptualised; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. Create a new family package qutip-symbolic from ajgpitch fork of Sympy. M",MatchSource.DOCS,doc/development/roadmap.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst:11478,Availability,error,errors,11478,"Create a new family package qutip-symbolic from ajgpitch fork of Sympy. Must; gain permission from Robert Johansson and Eunjong Kim. Extended Sympy simplify; to respect non-commuting operators. Produce user documentation. .. _status-mig:. Status messaging and recording; ------------------------------. :tag: status-msg; :status: conceptualised; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. QuTiP has various ways of recording and reporting status and progress. - `ProgressBar` used by some solvers; - Python logging used in qutip.control; - `Dump` used in qutip.control; - heom records `solver.Stats`. Some consolidation of these would be good. Some processes (some solvers, correlation, control optimisation) have many; stages and many layers. `Dump` was initially developed to help with debugging,; but it is also useful for recording data for analysis. qutip.logging_utils has; been criticised for the way it uses Python logging. The output goes to stderr; and hence the output looks like errors in Jupyter notebooks. Clearly, storing process stage data is costly in terms of memory and cpu time,; so any implementation must be able to be optionally switched on/off, and avoided; completely in low-level processes (cythonized components). Required features:. - optional recording (storing) of process stage data (states, operators etc); - optionally write subsets to stdout; - maybe other graphical representations; - option to save subsets to file; - should ideally replace use of `ProgressBar`, Python logging, `control.Dump`, `solver.Stats`. .. _qutip-gui:. qutip Interactive; -----------------. :status: conceptualised; :tag: qutip-gui; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. QuTiP is pretty simple to use at an entry level for anyone with basic Python; skills. However, *some* Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful ",MatchSource.DOCS,doc/development/roadmap.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst:16511,Availability,avail,available,16511,"moved to the qutip/qutip; repo. This is more typical for an OSS package. As part of the move, the plan is to reconstruct the Sphinx structure from; scratch. Historically, there have been many issues with building the docs.; Sphinx has come a long way since qutip docs first developed. The main source; (rst) files will remain [pretty much] as they are, although there is a lot of; scope to improve them. The qutip-doc repo will afterwards just be used for documents, such as this one,; pertaining to the QuTiP project. .. _qip-mig:. QIP migration; -------------. :tag: qip-mig; :status: completed; :admin lead: `Boxi <https://github.com/BoxiLi>`_; :main dev: `Sidhant Saraogi <https://github.com/sarsid>`_. A separate package for qutip-qip was created during Sidhant's GSoC project.; There is some fine tuning required, especially after qutip.control is migrated. .. _heom-revamp:. HEOM revamp; -----------. :tag: heom-revamp; :status: completed; :admin lead: `Neill <https://github.com/nwlambert>`_; :main dev: `Simon Cross <https://github.com/hodgestar>`_, `Tarun Raheja <https://github.com/tehruhn>`_. An overhaul of the HEOM solver, to incorporate the improvements pioneered in BoFiN. .. _release roadmap:. QuTiP major release roadmap; ===========================. QuTiP v.5; ---------. These Projects need to be completed for the qutip v.5 release. - :ref:`dl-abs` (completed); - :ref:`qmain-reorg` (completed); - :ref:`qmain-docs` (completed); - :ref:`solve-dl` (in-progress); - :ref:`qip-mig` (completed); - :ref:`qtrl-mig`; - :ref:`heom-revamp` (completed). The planned timeline for the release is:. - **alpha version, December 2022**. Core features packaged and available for; experienced users to test.; - **beta version, January 2023**. All required features and documentation complete,; packaged and ready for community testing.; - **full release, April 2023**. Full tested version released. Planned supported environment:. - python 3.8 .. 3.11; - numpy 1.20 .. 1.23; - scipy 1.5 .. 1.8; ",MatchSource.DOCS,doc/development/roadmap.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst:388,Deployability,release,release,388,".. _development_roadmap:. *************************; QuTiP Development Roadmap; *************************. Preamble; ========. This document outlines plan and ideas for the current and future development of; QuTiP. The document is maintained by the QuTiP Admim team. Contributuions from; the QuTiP Community are very welcome. In particular this document outlines plans for the next major release of qutip,; which will be version 5. And also plans and dreams beyond the next major; version. There is lots of development going on in QuTiP that is not recorded in here.; This a just an attempt at coordinated stragetgy and ideas for the future. .. _what-is-qutip:. What is QuTiP?; --------------. The name QuTiP refers to a few things. Most famously, qutip is a Python library; for simulating quantum dynamics. To support this, the library also contains; various software tools (functions and classes) that have more generic; applications, such as linear algebra components and visualisation utilities, and; also tools that are specifically quantum related, but have applications beyond; just solving dynamics (for instance partial trace computation). QuTiP is also an organisation, in the Github sense, and in the sense of a group; of people working collaboratively towards common objectives, and also a web; presence `qutip.org <https://qutip.org/>`_. The QuTiP Community includes all the; people who have supported the project since in conception in 2010, including; manager, funders, developers, maintainers and users. These related, and overlapping, uses of the QuTiP name are of little consequence; until one starts to consider how to organise all the software packages that are; somehow related to QuTiP, and specifically those that are maintained by the; QuTiP Admim Team. Herin QuTiP will refer to the project / organisation and qutip; to the library for simulating quantum dyanmics. Should we be starting again from scratch, then we would probably chose another; name for the main qutip library",MatchSource.DOCS,doc/development/roadmap.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst:3256,Deployability,release,release,3256,"me as general as Quantum Toolkit in Python, the scope for new code; modules to be added to qutip is very wide. The library was becoming increasingly; difficult to maintain, and in c. 2020 the QuTiP Admim Team decided to limit the; scope of the 'main' (for want of a better name) qutip package. This scope is; restricted to components for the simulation (solving) of the dynamics of quantum; systems. The scope includes utilities to support this, including analysis and; visualisation of output. At the same time, again with the intention of easing maintence, a decision to; limit dependences was agreed upon. Main qutip runtime code components should; depend only upon Numpy and Scipy. Installation (from source) requires Cython,; and some optional components also require Cython at runtime. Unit testing; requires Pytest. Visualisation (optional) components require Matplotlib. Due to the all encompassing nature of the plan to abstract the linear algebra; data layer, this enhancement (developed as part of a GSoC project) was allowed; the freedom (potential for non-backward compatibility) of requiring a major; release. The timing of such allows for a restructuring of the qutip compoments,; such that some that could be deemed out of scope could be packaged in a; different way -- that is, not installed as part of the main qutip package. Hence; the proposal for different types of package described next. With reference to; the :ref:`discussion above <what-is-qutip>` on the name QuTiP/qutip, the planned; restructuring suffers from confusing naming, which seems unavoidable without; remaining either the organisation or the main package (neither of which are; desirable). QuTiP family packages; The main qutip package already has sub-packages,; which are maintained in the main qutip repo. Any packages maitained by the; QuTiP organisation will be called QuTiP 'family' packages. Sub-packages within; qutip main will be called 'integrated' sub-packages. Some packages will be; maintained in the",MatchSource.DOCS,doc/development/roadmap.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst:3440,Deployability,install,installed,3440,"ope of the 'main' (for want of a better name) qutip package. This scope is; restricted to components for the simulation (solving) of the dynamics of quantum; systems. The scope includes utilities to support this, including analysis and; visualisation of output. At the same time, again with the intention of easing maintence, a decision to; limit dependences was agreed upon. Main qutip runtime code components should; depend only upon Numpy and Scipy. Installation (from source) requires Cython,; and some optional components also require Cython at runtime. Unit testing; requires Pytest. Visualisation (optional) components require Matplotlib. Due to the all encompassing nature of the plan to abstract the linear algebra; data layer, this enhancement (developed as part of a GSoC project) was allowed; the freedom (potential for non-backward compatibility) of requiring a major; release. The timing of such allows for a restructuring of the qutip compoments,; such that some that could be deemed out of scope could be packaged in a; different way -- that is, not installed as part of the main qutip package. Hence; the proposal for different types of package described next. With reference to; the :ref:`discussion above <what-is-qutip>` on the name QuTiP/qutip, the planned; restructuring suffers from confusing naming, which seems unavoidable without; remaining either the organisation or the main package (neither of which are; desirable). QuTiP family packages; The main qutip package already has sub-packages,; which are maintained in the main qutip repo. Any packages maitained by the; QuTiP organisation will be called QuTiP 'family' packages. Sub-packages within; qutip main will be called 'integrated' sub-packages. Some packages will be; maintained in their own repos and installed separately within the main qutip; folder structure to provide backwards compatibility, these are (will be); called qutip optional sub-packages. Others will be installed in their own; folders, but (most lik",MatchSource.DOCS,doc/development/roadmap.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst:4076,Deployability,integrat,integrated,4076,"an to abstract the linear algebra; data layer, this enhancement (developed as part of a GSoC project) was allowed; the freedom (potential for non-backward compatibility) of requiring a major; release. The timing of such allows for a restructuring of the qutip compoments,; such that some that could be deemed out of scope could be packaged in a; different way -- that is, not installed as part of the main qutip package. Hence; the proposal for different types of package described next. With reference to; the :ref:`discussion above <what-is-qutip>` on the name QuTiP/qutip, the planned; restructuring suffers from confusing naming, which seems unavoidable without; remaining either the organisation or the main package (neither of which are; desirable). QuTiP family packages; The main qutip package already has sub-packages,; which are maintained in the main qutip repo. Any packages maitained by the; QuTiP organisation will be called QuTiP 'family' packages. Sub-packages within; qutip main will be called 'integrated' sub-packages. Some packages will be; maintained in their own repos and installed separately within the main qutip; folder structure to provide backwards compatibility, these are (will be); called qutip optional sub-packages. Others will be installed in their own; folders, but (most likely) have qutip as a dependency -- these will just be; called 'family' packages. QuTiP affilliated packages; Other packages have been developed by others; outside of the QuTiP organisation that work with, and are complementary to,; qutip. The plan is to give some recognition to those that we deem worthy of; such [this needs clarification]. These packages will not be maintained by the; QuTiP Team. Family packages; ---------------. .. _qmain:. qutip main; ^^^^^^^^^^. * **current package status**: family package `qutip`; * **planned package status**: family package `qutip`. The in-scope components of the main qutip package all currently reside in the; base folder. The plan is to move ",MatchSource.DOCS,doc/development/roadmap.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst:4159,Deployability,install,installed,4159,"non-backward compatibility) of requiring a major; release. The timing of such allows for a restructuring of the qutip compoments,; such that some that could be deemed out of scope could be packaged in a; different way -- that is, not installed as part of the main qutip package. Hence; the proposal for different types of package described next. With reference to; the :ref:`discussion above <what-is-qutip>` on the name QuTiP/qutip, the planned; restructuring suffers from confusing naming, which seems unavoidable without; remaining either the organisation or the main package (neither of which are; desirable). QuTiP family packages; The main qutip package already has sub-packages,; which are maintained in the main qutip repo. Any packages maitained by the; QuTiP organisation will be called QuTiP 'family' packages. Sub-packages within; qutip main will be called 'integrated' sub-packages. Some packages will be; maintained in their own repos and installed separately within the main qutip; folder structure to provide backwards compatibility, these are (will be); called qutip optional sub-packages. Others will be installed in their own; folders, but (most likely) have qutip as a dependency -- these will just be; called 'family' packages. QuTiP affilliated packages; Other packages have been developed by others; outside of the QuTiP organisation that work with, and are complementary to,; qutip. The plan is to give some recognition to those that we deem worthy of; such [this needs clarification]. These packages will not be maintained by the; QuTiP Team. Family packages; ---------------. .. _qmain:. qutip main; ^^^^^^^^^^. * **current package status**: family package `qutip`; * **planned package status**: family package `qutip`. The in-scope components of the main qutip package all currently reside in the; base folder. The plan is to move some components into integrated subpackages as; follows:. - `core` quantum objects and operations; - `solver` quantum dynamics solvers. What wi",MatchSource.DOCS,doc/development/roadmap.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst:4328,Deployability,install,installed,4328,"pe could be packaged in a; different way -- that is, not installed as part of the main qutip package. Hence; the proposal for different types of package described next. With reference to; the :ref:`discussion above <what-is-qutip>` on the name QuTiP/qutip, the planned; restructuring suffers from confusing naming, which seems unavoidable without; remaining either the organisation or the main package (neither of which are; desirable). QuTiP family packages; The main qutip package already has sub-packages,; which are maintained in the main qutip repo. Any packages maitained by the; QuTiP organisation will be called QuTiP 'family' packages. Sub-packages within; qutip main will be called 'integrated' sub-packages. Some packages will be; maintained in their own repos and installed separately within the main qutip; folder structure to provide backwards compatibility, these are (will be); called qutip optional sub-packages. Others will be installed in their own; folders, but (most likely) have qutip as a dependency -- these will just be; called 'family' packages. QuTiP affilliated packages; Other packages have been developed by others; outside of the QuTiP organisation that work with, and are complementary to,; qutip. The plan is to give some recognition to those that we deem worthy of; such [this needs clarification]. These packages will not be maintained by the; QuTiP Team. Family packages; ---------------. .. _qmain:. qutip main; ^^^^^^^^^^. * **current package status**: family package `qutip`; * **planned package status**: family package `qutip`. The in-scope components of the main qutip package all currently reside in the; base folder. The plan is to move some components into integrated subpackages as; follows:. - `core` quantum objects and operations; - `solver` quantum dynamics solvers. What will remain in the base folder will be miscellaneous modules. There may be; some opportunity for grouping some into a `visualisation` subpackage. There is; also some potential fo",MatchSource.DOCS,doc/development/roadmap.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst:5085,Deployability,integrat,integrated,5085,"ated' sub-packages. Some packages will be; maintained in their own repos and installed separately within the main qutip; folder structure to provide backwards compatibility, these are (will be); called qutip optional sub-packages. Others will be installed in their own; folders, but (most likely) have qutip as a dependency -- these will just be; called 'family' packages. QuTiP affilliated packages; Other packages have been developed by others; outside of the QuTiP organisation that work with, and are complementary to,; qutip. The plan is to give some recognition to those that we deem worthy of; such [this needs clarification]. These packages will not be maintained by the; QuTiP Team. Family packages; ---------------. .. _qmain:. qutip main; ^^^^^^^^^^. * **current package status**: family package `qutip`; * **planned package status**: family package `qutip`. The in-scope components of the main qutip package all currently reside in the; base folder. The plan is to move some components into integrated subpackages as; follows:. - `core` quantum objects and operations; - `solver` quantum dynamics solvers. What will remain in the base folder will be miscellaneous modules. There may be; some opportunity for grouping some into a `visualisation` subpackage. There is; also some potential for renaming, as some module names have underscores, which; is unconventional. Qtrl; ^^^^. * **current package status**: integrated sub-package `qutip.control`; * **planned package status**: family package `qtrl`. There are many OSS Python packages for quantum control optimisation. There are; also many different algorithms. The current `control` integrated subpackage; provides the GRAPE and CRAB algorithms. It is too ambitious for QuTiP to attempt; (or want) to provide for all options. Control optimisation has been deemed out; of scope and hence these components will be separated out into a family package; called Qtrl. Potentially Qtrl may be replaced by separate packages for GRAPE and CRAB, ",MatchSource.DOCS,doc/development/roadmap.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst:5502,Deployability,integrat,integrated,5502,"e been developed by others; outside of the QuTiP organisation that work with, and are complementary to,; qutip. The plan is to give some recognition to those that we deem worthy of; such [this needs clarification]. These packages will not be maintained by the; QuTiP Team. Family packages; ---------------. .. _qmain:. qutip main; ^^^^^^^^^^. * **current package status**: family package `qutip`; * **planned package status**: family package `qutip`. The in-scope components of the main qutip package all currently reside in the; base folder. The plan is to move some components into integrated subpackages as; follows:. - `core` quantum objects and operations; - `solver` quantum dynamics solvers. What will remain in the base folder will be miscellaneous modules. There may be; some opportunity for grouping some into a `visualisation` subpackage. There is; also some potential for renaming, as some module names have underscores, which; is unconventional. Qtrl; ^^^^. * **current package status**: integrated sub-package `qutip.control`; * **planned package status**: family package `qtrl`. There are many OSS Python packages for quantum control optimisation. There are; also many different algorithms. The current `control` integrated subpackage; provides the GRAPE and CRAB algorithms. It is too ambitious for QuTiP to attempt; (or want) to provide for all options. Control optimisation has been deemed out; of scope and hence these components will be separated out into a family package; called Qtrl. Potentially Qtrl may be replaced by separate packages for GRAPE and CRAB, based; on the QuTiP Control Framework. QIP; ^^^. * **current package status**: integrated sub-package `qutip.qip`; * **planned package status**: family package `qutip-qip`. The QIP subpackage has been deemed out of scope (feature-wise). It also depends; on `qutip.control` and hence would be out of scope for dependency reasons. A; separate repository has already been made for qutip-qip. qutip-symbolic; ^^^^^^^^^^^^^^.",MatchSource.DOCS,doc/development/roadmap.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst:5729,Deployability,integrat,integrated,5729,"ained by the; QuTiP Team. Family packages; ---------------. .. _qmain:. qutip main; ^^^^^^^^^^. * **current package status**: family package `qutip`; * **planned package status**: family package `qutip`. The in-scope components of the main qutip package all currently reside in the; base folder. The plan is to move some components into integrated subpackages as; follows:. - `core` quantum objects and operations; - `solver` quantum dynamics solvers. What will remain in the base folder will be miscellaneous modules. There may be; some opportunity for grouping some into a `visualisation` subpackage. There is; also some potential for renaming, as some module names have underscores, which; is unconventional. Qtrl; ^^^^. * **current package status**: integrated sub-package `qutip.control`; * **planned package status**: family package `qtrl`. There are many OSS Python packages for quantum control optimisation. There are; also many different algorithms. The current `control` integrated subpackage; provides the GRAPE and CRAB algorithms. It is too ambitious for QuTiP to attempt; (or want) to provide for all options. Control optimisation has been deemed out; of scope and hence these components will be separated out into a family package; called Qtrl. Potentially Qtrl may be replaced by separate packages for GRAPE and CRAB, based; on the QuTiP Control Framework. QIP; ^^^. * **current package status**: integrated sub-package `qutip.qip`; * **planned package status**: family package `qutip-qip`. The QIP subpackage has been deemed out of scope (feature-wise). It also depends; on `qutip.control` and hence would be out of scope for dependency reasons. A; separate repository has already been made for qutip-qip. qutip-symbolic; ^^^^^^^^^^^^^^. * **current package status**: independent package `sympsi`; * **planned package status**: family package `qutip-symbolic`. Long ago Robert Johansson and Eunjong Kim developed Sympsi. It is a fairly; coomplete library for quantum computer algebra ",MatchSource.DOCS,doc/development/roadmap.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst:6161,Deployability,integrat,integrated,6161,"s; - `solver` quantum dynamics solvers. What will remain in the base folder will be miscellaneous modules. There may be; some opportunity for grouping some into a `visualisation` subpackage. There is; also some potential for renaming, as some module names have underscores, which; is unconventional. Qtrl; ^^^^. * **current package status**: integrated sub-package `qutip.control`; * **planned package status**: family package `qtrl`. There are many OSS Python packages for quantum control optimisation. There are; also many different algorithms. The current `control` integrated subpackage; provides the GRAPE and CRAB algorithms. It is too ambitious for QuTiP to attempt; (or want) to provide for all options. Control optimisation has been deemed out; of scope and hence these components will be separated out into a family package; called Qtrl. Potentially Qtrl may be replaced by separate packages for GRAPE and CRAB, based; on the QuTiP Control Framework. QIP; ^^^. * **current package status**: integrated sub-package `qutip.qip`; * **planned package status**: family package `qutip-qip`. The QIP subpackage has been deemed out of scope (feature-wise). It also depends; on `qutip.control` and hence would be out of scope for dependency reasons. A; separate repository has already been made for qutip-qip. qutip-symbolic; ^^^^^^^^^^^^^^. * **current package status**: independent package `sympsi`; * **planned package status**: family package `qutip-symbolic`. Long ago Robert Johansson and Eunjong Kim developed Sympsi. It is a fairly; coomplete library for quantum computer algebra (symbolic computation). It is; primarily a quantum wrapper for `Sympy <https://www.sympy.org>`_. It has fallen into unmaintained status. The latest version on the `sympsi repo; <https://github.com/sympsi/sympsi>`_ does not work with recent versions of; Sympy. Alex Pitchford has a `fork <https://github.com/ajgpitch/sympsi>`_ that; does 'work' with recent Sympy versions -- unit tests pass, and most examples; wo",MatchSource.DOCS,doc/development/roadmap.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst:8055,Deployability,integrat,integration,8055,"mpsi>`_ that; does 'work' with recent Sympy versions -- unit tests pass, and most examples; work. However, some (important) examples fail, due to lack of respect for; non-commuting operators in Sympy simplifcation functions (note this was true as; of Nov 2019, may be fixed now). There is a [not discussed with RJ & EK] plan to move this into the QuTiP family; to allow the Admin Team to maintain, develop and promote it. The 'Sympsi' name; is cute, but a little abstract, and qutip-symbolic is proposed as an; alternative, as it is plainer and more distinct from Sympy. Affilliated packages; --------------------. qucontrol-krotov; ^^^^^^^^^^^^^^^^. * **code repository**: https://github.com/qucontrol/krotov. A package for quantum control optimisation using Krotov, developed mainly by; Michael Goerz. Generally accepted by the Admin Team as well developed and maintained. A solid; candiate for affilliation. Development Projects; ====================. .. _solve-dl:. Solver data layer integration; -----------------------------. :tag: solve-dl; :status: development ongoing; :admin lead: `Eric <https://github.com/Ericgig>`_; :main dev: `Eric <https://github.com/Ericgig>`_. The new data layer gives opportunity for significantly improving performance of; the qutip solvers. Eric has been revamping the solvers by deploying `QobjEvo`; (the time-dependent quantum object) that he developed. `QobjEvo` will exploit; the data layer, and the solvers in turn exploit `QobjEvo`. .. _qtrl-mig:. Qtrl migration; --------------. :tag: qtrl-mig; :status: conceptualised; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. The components currently packaged as an integrated subpackage of qutip main will; be moved to separate package called Qtrl. This is the original codename of the; package before it was integrated into qutip. Also changes to exploit the new; data layer will be implemented. .. _ctrl-fw:. QuTiP control framework; -----------------------. :tag: ctrl-fw; :status: conceptu",MatchSource.DOCS,doc/development/roadmap.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst:8384,Deployability,deploy,deploying,8384,"his into the QuTiP family; to allow the Admin Team to maintain, develop and promote it. The 'Sympsi' name; is cute, but a little abstract, and qutip-symbolic is proposed as an; alternative, as it is plainer and more distinct from Sympy. Affilliated packages; --------------------. qucontrol-krotov; ^^^^^^^^^^^^^^^^. * **code repository**: https://github.com/qucontrol/krotov. A package for quantum control optimisation using Krotov, developed mainly by; Michael Goerz. Generally accepted by the Admin Team as well developed and maintained. A solid; candiate for affilliation. Development Projects; ====================. .. _solve-dl:. Solver data layer integration; -----------------------------. :tag: solve-dl; :status: development ongoing; :admin lead: `Eric <https://github.com/Ericgig>`_; :main dev: `Eric <https://github.com/Ericgig>`_. The new data layer gives opportunity for significantly improving performance of; the qutip solvers. Eric has been revamping the solvers by deploying `QobjEvo`; (the time-dependent quantum object) that he developed. `QobjEvo` will exploit; the data layer, and the solvers in turn exploit `QobjEvo`. .. _qtrl-mig:. Qtrl migration; --------------. :tag: qtrl-mig; :status: conceptualised; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. The components currently packaged as an integrated subpackage of qutip main will; be moved to separate package called Qtrl. This is the original codename of the; package before it was integrated into qutip. Also changes to exploit the new; data layer will be implemented. .. _ctrl-fw:. QuTiP control framework; -----------------------. :tag: ctrl-fw; :status: conceptualised; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. Create new package qutip-ctrlfw ""QuTiP Control Framework"". The aim is provide a; common framework that can be adopted by control optimisation packages, such that; different packages (algorithms) can be applied to the same problem. Classes for defining a contr",MatchSource.DOCS,doc/development/roadmap.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst:8739,Deployability,integrat,integrated,8739,"qucontrol/krotov. A package for quantum control optimisation using Krotov, developed mainly by; Michael Goerz. Generally accepted by the Admin Team as well developed and maintained. A solid; candiate for affilliation. Development Projects; ====================. .. _solve-dl:. Solver data layer integration; -----------------------------. :tag: solve-dl; :status: development ongoing; :admin lead: `Eric <https://github.com/Ericgig>`_; :main dev: `Eric <https://github.com/Ericgig>`_. The new data layer gives opportunity for significantly improving performance of; the qutip solvers. Eric has been revamping the solvers by deploying `QobjEvo`; (the time-dependent quantum object) that he developed. `QobjEvo` will exploit; the data layer, and the solvers in turn exploit `QobjEvo`. .. _qtrl-mig:. Qtrl migration; --------------. :tag: qtrl-mig; :status: conceptualised; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. The components currently packaged as an integrated subpackage of qutip main will; be moved to separate package called Qtrl. This is the original codename of the; package before it was integrated into qutip. Also changes to exploit the new; data layer will be implemented. .. _ctrl-fw:. QuTiP control framework; -----------------------. :tag: ctrl-fw; :status: conceptualised; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. Create new package qutip-ctrlfw ""QuTiP Control Framework"". The aim is provide a; common framework that can be adopted by control optimisation packages, such that; different packages (algorithms) can be applied to the same problem. Classes for defining a controlled system:. - named control parameters. Scalar and n-dim. Continuous and discrete variables; - mapping of control parameters to dynamics generator args; - masking for control parameters to be optimised. Classes for time-dependent variable parameterisation. - piecewise constant; - piecewise linear; - Fourier basis; - more. Classes for defining an optimis",MatchSource.DOCS,doc/development/roadmap.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst:8883,Deployability,integrat,integrated,8883," Goerz. Generally accepted by the Admin Team as well developed and maintained. A solid; candiate for affilliation. Development Projects; ====================. .. _solve-dl:. Solver data layer integration; -----------------------------. :tag: solve-dl; :status: development ongoing; :admin lead: `Eric <https://github.com/Ericgig>`_; :main dev: `Eric <https://github.com/Ericgig>`_. The new data layer gives opportunity for significantly improving performance of; the qutip solvers. Eric has been revamping the solvers by deploying `QobjEvo`; (the time-dependent quantum object) that he developed. `QobjEvo` will exploit; the data layer, and the solvers in turn exploit `QobjEvo`. .. _qtrl-mig:. Qtrl migration; --------------. :tag: qtrl-mig; :status: conceptualised; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. The components currently packaged as an integrated subpackage of qutip main will; be moved to separate package called Qtrl. This is the original codename of the; package before it was integrated into qutip. Also changes to exploit the new; data layer will be implemented. .. _ctrl-fw:. QuTiP control framework; -----------------------. :tag: ctrl-fw; :status: conceptualised; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. Create new package qutip-ctrlfw ""QuTiP Control Framework"". The aim is provide a; common framework that can be adopted by control optimisation packages, such that; different packages (algorithms) can be applied to the same problem. Classes for defining a controlled system:. - named control parameters. Scalar and n-dim. Continuous and discrete variables; - mapping of control parameters to dynamics generator args; - masking for control parameters to be optimised. Classes for time-dependent variable parameterisation. - piecewise constant; - piecewise linear; - Fourier basis; - more. Classes for defining an optimisation problem:. - single and multiple objectives. .. _qutip-optim:. QuTiP optimisation; ----------------",MatchSource.DOCS,doc/development/roadmap.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst:13034,Deployability,toggle,toggle,13034," _qutip-gui:. qutip Interactive; -----------------. :status: conceptualised; :tag: qutip-gui; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. QuTiP is pretty simple to use at an entry level for anyone with basic Python; skills. However, *some* Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners. This would make an good GSoC project. It is independent and the scope is; flexible. The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere; ^^^^^^^^^^^^^^^^^^^^^^^^. Matplotlib has some interactive features (sliders, radio buttons, cmd buttons); that can be used to control parameters. They are a bit clunky to use, but they; are there. Could maybe avoid these and develop our own GUI. An interactive Bloch; sphere could have sliders for qubit state angles. Buttons to add states, toggle; state evolution path. Interactive solvers; ^^^^^^^^^^^^^^^^^^^. Options to configure dynamics generators (Lindbladian / Hamiltonian args etc); and expectation operators. Then run solver and view state evolution. Animated circuits; ^^^^^^^^^^^^^^^^^. QIP circuits could be animated. Status lights showing evolution of states during; the processing. Animated Bloch spheres for qubits. Completed Development Projects; ==============================. .. _dl-abs:. data layer abstraction; ----------------------. :tag: dl-abs; :status: completed; :admin lead: `Eric <https://github.com/Ericgig>`_; :main dev: `Jake Lishman <https://github.com/jakelishman>`_. Development completed as a GSoC project. Fully implemented in the dev.major; branch. Currently being used by some research groups. Abstraction of the linear algebra data from code qutip components, allowing; for alternatives, such as sparse, dense etc. Difficult to summarize. Almost; every file in qutip affected in some way. A major milest",MatchSource.DOCS,doc/development/roadmap.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst:16063,Deployability,release,release,16063,"moved to the qutip/qutip; repo. This is more typical for an OSS package. As part of the move, the plan is to reconstruct the Sphinx structure from; scratch. Historically, there have been many issues with building the docs.; Sphinx has come a long way since qutip docs first developed. The main source; (rst) files will remain [pretty much] as they are, although there is a lot of; scope to improve them. The qutip-doc repo will afterwards just be used for documents, such as this one,; pertaining to the QuTiP project. .. _qip-mig:. QIP migration; -------------. :tag: qip-mig; :status: completed; :admin lead: `Boxi <https://github.com/BoxiLi>`_; :main dev: `Sidhant Saraogi <https://github.com/sarsid>`_. A separate package for qutip-qip was created during Sidhant's GSoC project.; There is some fine tuning required, especially after qutip.control is migrated. .. _heom-revamp:. HEOM revamp; -----------. :tag: heom-revamp; :status: completed; :admin lead: `Neill <https://github.com/nwlambert>`_; :main dev: `Simon Cross <https://github.com/hodgestar>`_, `Tarun Raheja <https://github.com/tehruhn>`_. An overhaul of the HEOM solver, to incorporate the improvements pioneered in BoFiN. .. _release roadmap:. QuTiP major release roadmap; ===========================. QuTiP v.5; ---------. These Projects need to be completed for the qutip v.5 release. - :ref:`dl-abs` (completed); - :ref:`qmain-reorg` (completed); - :ref:`qmain-docs` (completed); - :ref:`solve-dl` (in-progress); - :ref:`qip-mig` (completed); - :ref:`qtrl-mig`; - :ref:`heom-revamp` (completed). The planned timeline for the release is:. - **alpha version, December 2022**. Core features packaged and available for; experienced users to test.; - **beta version, January 2023**. All required features and documentation complete,; packaged and ready for community testing.; - **full release, April 2023**. Full tested version released. Planned supported environment:. - python 3.8 .. 3.11; - numpy 1.20 .. 1.23; - scipy 1.5 .. 1.8; ",MatchSource.DOCS,doc/development/roadmap.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst:16185,Deployability,release,release,16185,"moved to the qutip/qutip; repo. This is more typical for an OSS package. As part of the move, the plan is to reconstruct the Sphinx structure from; scratch. Historically, there have been many issues with building the docs.; Sphinx has come a long way since qutip docs first developed. The main source; (rst) files will remain [pretty much] as they are, although there is a lot of; scope to improve them. The qutip-doc repo will afterwards just be used for documents, such as this one,; pertaining to the QuTiP project. .. _qip-mig:. QIP migration; -------------. :tag: qip-mig; :status: completed; :admin lead: `Boxi <https://github.com/BoxiLi>`_; :main dev: `Sidhant Saraogi <https://github.com/sarsid>`_. A separate package for qutip-qip was created during Sidhant's GSoC project.; There is some fine tuning required, especially after qutip.control is migrated. .. _heom-revamp:. HEOM revamp; -----------. :tag: heom-revamp; :status: completed; :admin lead: `Neill <https://github.com/nwlambert>`_; :main dev: `Simon Cross <https://github.com/hodgestar>`_, `Tarun Raheja <https://github.com/tehruhn>`_. An overhaul of the HEOM solver, to incorporate the improvements pioneered in BoFiN. .. _release roadmap:. QuTiP major release roadmap; ===========================. QuTiP v.5; ---------. These Projects need to be completed for the qutip v.5 release. - :ref:`dl-abs` (completed); - :ref:`qmain-reorg` (completed); - :ref:`qmain-docs` (completed); - :ref:`solve-dl` (in-progress); - :ref:`qip-mig` (completed); - :ref:`qtrl-mig`; - :ref:`heom-revamp` (completed). The planned timeline for the release is:. - **alpha version, December 2022**. Core features packaged and available for; experienced users to test.; - **beta version, January 2023**. All required features and documentation complete,; packaged and ready for community testing.; - **full release, April 2023**. Full tested version released. Planned supported environment:. - python 3.8 .. 3.11; - numpy 1.20 .. 1.23; - scipy 1.5 .. 1.8; ",MatchSource.DOCS,doc/development/roadmap.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst:16435,Deployability,release,release,16435,"moved to the qutip/qutip; repo. This is more typical for an OSS package. As part of the move, the plan is to reconstruct the Sphinx structure from; scratch. Historically, there have been many issues with building the docs.; Sphinx has come a long way since qutip docs first developed. The main source; (rst) files will remain [pretty much] as they are, although there is a lot of; scope to improve them. The qutip-doc repo will afterwards just be used for documents, such as this one,; pertaining to the QuTiP project. .. _qip-mig:. QIP migration; -------------. :tag: qip-mig; :status: completed; :admin lead: `Boxi <https://github.com/BoxiLi>`_; :main dev: `Sidhant Saraogi <https://github.com/sarsid>`_. A separate package for qutip-qip was created during Sidhant's GSoC project.; There is some fine tuning required, especially after qutip.control is migrated. .. _heom-revamp:. HEOM revamp; -----------. :tag: heom-revamp; :status: completed; :admin lead: `Neill <https://github.com/nwlambert>`_; :main dev: `Simon Cross <https://github.com/hodgestar>`_, `Tarun Raheja <https://github.com/tehruhn>`_. An overhaul of the HEOM solver, to incorporate the improvements pioneered in BoFiN. .. _release roadmap:. QuTiP major release roadmap; ===========================. QuTiP v.5; ---------. These Projects need to be completed for the qutip v.5 release. - :ref:`dl-abs` (completed); - :ref:`qmain-reorg` (completed); - :ref:`qmain-docs` (completed); - :ref:`solve-dl` (in-progress); - :ref:`qip-mig` (completed); - :ref:`qtrl-mig`; - :ref:`heom-revamp` (completed). The planned timeline for the release is:. - **alpha version, December 2022**. Core features packaged and available for; experienced users to test.; - **beta version, January 2023**. All required features and documentation complete,; packaged and ready for community testing.; - **full release, April 2023**. Full tested version released. Planned supported environment:. - python 3.8 .. 3.11; - numpy 1.20 .. 1.23; - scipy 1.5 .. 1.8; ",MatchSource.DOCS,doc/development/roadmap.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst:16691,Deployability,release,release,16691,"moved to the qutip/qutip; repo. This is more typical for an OSS package. As part of the move, the plan is to reconstruct the Sphinx structure from; scratch. Historically, there have been many issues with building the docs.; Sphinx has come a long way since qutip docs first developed. The main source; (rst) files will remain [pretty much] as they are, although there is a lot of; scope to improve them. The qutip-doc repo will afterwards just be used for documents, such as this one,; pertaining to the QuTiP project. .. _qip-mig:. QIP migration; -------------. :tag: qip-mig; :status: completed; :admin lead: `Boxi <https://github.com/BoxiLi>`_; :main dev: `Sidhant Saraogi <https://github.com/sarsid>`_. A separate package for qutip-qip was created during Sidhant's GSoC project.; There is some fine tuning required, especially after qutip.control is migrated. .. _heom-revamp:. HEOM revamp; -----------. :tag: heom-revamp; :status: completed; :admin lead: `Neill <https://github.com/nwlambert>`_; :main dev: `Simon Cross <https://github.com/hodgestar>`_, `Tarun Raheja <https://github.com/tehruhn>`_. An overhaul of the HEOM solver, to incorporate the improvements pioneered in BoFiN. .. _release roadmap:. QuTiP major release roadmap; ===========================. QuTiP v.5; ---------. These Projects need to be completed for the qutip v.5 release. - :ref:`dl-abs` (completed); - :ref:`qmain-reorg` (completed); - :ref:`qmain-docs` (completed); - :ref:`solve-dl` (in-progress); - :ref:`qip-mig` (completed); - :ref:`qtrl-mig`; - :ref:`heom-revamp` (completed). The planned timeline for the release is:. - **alpha version, December 2022**. Core features packaged and available for; experienced users to test.; - **beta version, January 2023**. All required features and documentation complete,; packaged and ready for community testing.; - **full release, April 2023**. Full tested version released. Planned supported environment:. - python 3.8 .. 3.11; - numpy 1.20 .. 1.23; - scipy 1.5 .. 1.8; ",MatchSource.DOCS,doc/development/roadmap.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst:16734,Deployability,release,released,16734,"moved to the qutip/qutip; repo. This is more typical for an OSS package. As part of the move, the plan is to reconstruct the Sphinx structure from; scratch. Historically, there have been many issues with building the docs.; Sphinx has come a long way since qutip docs first developed. The main source; (rst) files will remain [pretty much] as they are, although there is a lot of; scope to improve them. The qutip-doc repo will afterwards just be used for documents, such as this one,; pertaining to the QuTiP project. .. _qip-mig:. QIP migration; -------------. :tag: qip-mig; :status: completed; :admin lead: `Boxi <https://github.com/BoxiLi>`_; :main dev: `Sidhant Saraogi <https://github.com/sarsid>`_. A separate package for qutip-qip was created during Sidhant's GSoC project.; There is some fine tuning required, especially after qutip.control is migrated. .. _heom-revamp:. HEOM revamp; -----------. :tag: heom-revamp; :status: completed; :admin lead: `Neill <https://github.com/nwlambert>`_; :main dev: `Simon Cross <https://github.com/hodgestar>`_, `Tarun Raheja <https://github.com/tehruhn>`_. An overhaul of the HEOM solver, to incorporate the improvements pioneered in BoFiN. .. _release roadmap:. QuTiP major release roadmap; ===========================. QuTiP v.5; ---------. These Projects need to be completed for the qutip v.5 release. - :ref:`dl-abs` (completed); - :ref:`qmain-reorg` (completed); - :ref:`qmain-docs` (completed); - :ref:`solve-dl` (in-progress); - :ref:`qip-mig` (completed); - :ref:`qtrl-mig`; - :ref:`heom-revamp` (completed). The planned timeline for the release is:. - **alpha version, December 2022**. Core features packaged and available for; experienced users to test.; - **beta version, January 2023**. All required features and documentation complete,; packaged and ready for community testing.; - **full release, April 2023**. Full tested version released. Planned supported environment:. - python 3.8 .. 3.11; - numpy 1.20 .. 1.23; - scipy 1.5 .. 1.8; ",MatchSource.DOCS,doc/development/roadmap.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst:2721,Integrability,depend,dependences,2721,"elated to QuTiP, and specifically those that are maintained by the; QuTiP Admim Team. Herin QuTiP will refer to the project / organisation and qutip; to the library for simulating quantum dyanmics. Should we be starting again from scratch, then we would probably chose another; name for the main qutip library, such as qutip-quantdyn. However, qutip is; famous, and the name will stay. Library package structure; =========================. With a name as general as Quantum Toolkit in Python, the scope for new code; modules to be added to qutip is very wide. The library was becoming increasingly; difficult to maintain, and in c. 2020 the QuTiP Admim Team decided to limit the; scope of the 'main' (for want of a better name) qutip package. This scope is; restricted to components for the simulation (solving) of the dynamics of quantum; systems. The scope includes utilities to support this, including analysis and; visualisation of output. At the same time, again with the intention of easing maintence, a decision to; limit dependences was agreed upon. Main qutip runtime code components should; depend only upon Numpy and Scipy. Installation (from source) requires Cython,; and some optional components also require Cython at runtime. Unit testing; requires Pytest. Visualisation (optional) components require Matplotlib. Due to the all encompassing nature of the plan to abstract the linear algebra; data layer, this enhancement (developed as part of a GSoC project) was allowed; the freedom (potential for non-backward compatibility) of requiring a major; release. The timing of such allows for a restructuring of the qutip compoments,; such that some that could be deemed out of scope could be packaged in a; different way -- that is, not installed as part of the main qutip package. Hence; the proposal for different types of package described next. With reference to; the :ref:`discussion above <what-is-qutip>` on the name QuTiP/qutip, the planned; restructuring suffers from confusing na",MatchSource.DOCS,doc/development/roadmap.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst:2793,Integrability,depend,depend,2793,"iP will refer to the project / organisation and qutip; to the library for simulating quantum dyanmics. Should we be starting again from scratch, then we would probably chose another; name for the main qutip library, such as qutip-quantdyn. However, qutip is; famous, and the name will stay. Library package structure; =========================. With a name as general as Quantum Toolkit in Python, the scope for new code; modules to be added to qutip is very wide. The library was becoming increasingly; difficult to maintain, and in c. 2020 the QuTiP Admim Team decided to limit the; scope of the 'main' (for want of a better name) qutip package. This scope is; restricted to components for the simulation (solving) of the dynamics of quantum; systems. The scope includes utilities to support this, including analysis and; visualisation of output. At the same time, again with the intention of easing maintence, a decision to; limit dependences was agreed upon. Main qutip runtime code components should; depend only upon Numpy and Scipy. Installation (from source) requires Cython,; and some optional components also require Cython at runtime. Unit testing; requires Pytest. Visualisation (optional) components require Matplotlib. Due to the all encompassing nature of the plan to abstract the linear algebra; data layer, this enhancement (developed as part of a GSoC project) was allowed; the freedom (potential for non-backward compatibility) of requiring a major; release. The timing of such allows for a restructuring of the qutip compoments,; such that some that could be deemed out of scope could be packaged in a; different way -- that is, not installed as part of the main qutip package. Hence; the proposal for different types of package described next. With reference to; the :ref:`discussion above <what-is-qutip>` on the name QuTiP/qutip, the planned; restructuring suffers from confusing naming, which seems unavoidable without; remaining either the organisation or the main package (ne",MatchSource.DOCS,doc/development/roadmap.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst:4076,Integrability,integrat,integrated,4076,"an to abstract the linear algebra; data layer, this enhancement (developed as part of a GSoC project) was allowed; the freedom (potential for non-backward compatibility) of requiring a major; release. The timing of such allows for a restructuring of the qutip compoments,; such that some that could be deemed out of scope could be packaged in a; different way -- that is, not installed as part of the main qutip package. Hence; the proposal for different types of package described next. With reference to; the :ref:`discussion above <what-is-qutip>` on the name QuTiP/qutip, the planned; restructuring suffers from confusing naming, which seems unavoidable without; remaining either the organisation or the main package (neither of which are; desirable). QuTiP family packages; The main qutip package already has sub-packages,; which are maintained in the main qutip repo. Any packages maitained by the; QuTiP organisation will be called QuTiP 'family' packages. Sub-packages within; qutip main will be called 'integrated' sub-packages. Some packages will be; maintained in their own repos and installed separately within the main qutip; folder structure to provide backwards compatibility, these are (will be); called qutip optional sub-packages. Others will be installed in their own; folders, but (most likely) have qutip as a dependency -- these will just be; called 'family' packages. QuTiP affilliated packages; Other packages have been developed by others; outside of the QuTiP organisation that work with, and are complementary to,; qutip. The plan is to give some recognition to those that we deem worthy of; such [this needs clarification]. These packages will not be maintained by the; QuTiP Team. Family packages; ---------------. .. _qmain:. qutip main; ^^^^^^^^^^. * **current package status**: family package `qutip`; * **planned package status**: family package `qutip`. The in-scope components of the main qutip package all currently reside in the; base folder. The plan is to move ",MatchSource.DOCS,doc/development/roadmap.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst:4395,Integrability,depend,dependency,4395,"pe could be packaged in a; different way -- that is, not installed as part of the main qutip package. Hence; the proposal for different types of package described next. With reference to; the :ref:`discussion above <what-is-qutip>` on the name QuTiP/qutip, the planned; restructuring suffers from confusing naming, which seems unavoidable without; remaining either the organisation or the main package (neither of which are; desirable). QuTiP family packages; The main qutip package already has sub-packages,; which are maintained in the main qutip repo. Any packages maitained by the; QuTiP organisation will be called QuTiP 'family' packages. Sub-packages within; qutip main will be called 'integrated' sub-packages. Some packages will be; maintained in their own repos and installed separately within the main qutip; folder structure to provide backwards compatibility, these are (will be); called qutip optional sub-packages. Others will be installed in their own; folders, but (most likely) have qutip as a dependency -- these will just be; called 'family' packages. QuTiP affilliated packages; Other packages have been developed by others; outside of the QuTiP organisation that work with, and are complementary to,; qutip. The plan is to give some recognition to those that we deem worthy of; such [this needs clarification]. These packages will not be maintained by the; QuTiP Team. Family packages; ---------------. .. _qmain:. qutip main; ^^^^^^^^^^. * **current package status**: family package `qutip`; * **planned package status**: family package `qutip`. The in-scope components of the main qutip package all currently reside in the; base folder. The plan is to move some components into integrated subpackages as; follows:. - `core` quantum objects and operations; - `solver` quantum dynamics solvers. What will remain in the base folder will be miscellaneous modules. There may be; some opportunity for grouping some into a `visualisation` subpackage. There is; also some potential fo",MatchSource.DOCS,doc/development/roadmap.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst:5085,Integrability,integrat,integrated,5085,"ated' sub-packages. Some packages will be; maintained in their own repos and installed separately within the main qutip; folder structure to provide backwards compatibility, these are (will be); called qutip optional sub-packages. Others will be installed in their own; folders, but (most likely) have qutip as a dependency -- these will just be; called 'family' packages. QuTiP affilliated packages; Other packages have been developed by others; outside of the QuTiP organisation that work with, and are complementary to,; qutip. The plan is to give some recognition to those that we deem worthy of; such [this needs clarification]. These packages will not be maintained by the; QuTiP Team. Family packages; ---------------. .. _qmain:. qutip main; ^^^^^^^^^^. * **current package status**: family package `qutip`; * **planned package status**: family package `qutip`. The in-scope components of the main qutip package all currently reside in the; base folder. The plan is to move some components into integrated subpackages as; follows:. - `core` quantum objects and operations; - `solver` quantum dynamics solvers. What will remain in the base folder will be miscellaneous modules. There may be; some opportunity for grouping some into a `visualisation` subpackage. There is; also some potential for renaming, as some module names have underscores, which; is unconventional. Qtrl; ^^^^. * **current package status**: integrated sub-package `qutip.control`; * **planned package status**: family package `qtrl`. There are many OSS Python packages for quantum control optimisation. There are; also many different algorithms. The current `control` integrated subpackage; provides the GRAPE and CRAB algorithms. It is too ambitious for QuTiP to attempt; (or want) to provide for all options. Control optimisation has been deemed out; of scope and hence these components will be separated out into a family package; called Qtrl. Potentially Qtrl may be replaced by separate packages for GRAPE and CRAB, ",MatchSource.DOCS,doc/development/roadmap.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst:5502,Integrability,integrat,integrated,5502,"e been developed by others; outside of the QuTiP organisation that work with, and are complementary to,; qutip. The plan is to give some recognition to those that we deem worthy of; such [this needs clarification]. These packages will not be maintained by the; QuTiP Team. Family packages; ---------------. .. _qmain:. qutip main; ^^^^^^^^^^. * **current package status**: family package `qutip`; * **planned package status**: family package `qutip`. The in-scope components of the main qutip package all currently reside in the; base folder. The plan is to move some components into integrated subpackages as; follows:. - `core` quantum objects and operations; - `solver` quantum dynamics solvers. What will remain in the base folder will be miscellaneous modules. There may be; some opportunity for grouping some into a `visualisation` subpackage. There is; also some potential for renaming, as some module names have underscores, which; is unconventional. Qtrl; ^^^^. * **current package status**: integrated sub-package `qutip.control`; * **planned package status**: family package `qtrl`. There are many OSS Python packages for quantum control optimisation. There are; also many different algorithms. The current `control` integrated subpackage; provides the GRAPE and CRAB algorithms. It is too ambitious for QuTiP to attempt; (or want) to provide for all options. Control optimisation has been deemed out; of scope and hence these components will be separated out into a family package; called Qtrl. Potentially Qtrl may be replaced by separate packages for GRAPE and CRAB, based; on the QuTiP Control Framework. QIP; ^^^. * **current package status**: integrated sub-package `qutip.qip`; * **planned package status**: family package `qutip-qip`. The QIP subpackage has been deemed out of scope (feature-wise). It also depends; on `qutip.control` and hence would be out of scope for dependency reasons. A; separate repository has already been made for qutip-qip. qutip-symbolic; ^^^^^^^^^^^^^^.",MatchSource.DOCS,doc/development/roadmap.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst:5729,Integrability,integrat,integrated,5729,"ained by the; QuTiP Team. Family packages; ---------------. .. _qmain:. qutip main; ^^^^^^^^^^. * **current package status**: family package `qutip`; * **planned package status**: family package `qutip`. The in-scope components of the main qutip package all currently reside in the; base folder. The plan is to move some components into integrated subpackages as; follows:. - `core` quantum objects and operations; - `solver` quantum dynamics solvers. What will remain in the base folder will be miscellaneous modules. There may be; some opportunity for grouping some into a `visualisation` subpackage. There is; also some potential for renaming, as some module names have underscores, which; is unconventional. Qtrl; ^^^^. * **current package status**: integrated sub-package `qutip.control`; * **planned package status**: family package `qtrl`. There are many OSS Python packages for quantum control optimisation. There are; also many different algorithms. The current `control` integrated subpackage; provides the GRAPE and CRAB algorithms. It is too ambitious for QuTiP to attempt; (or want) to provide for all options. Control optimisation has been deemed out; of scope and hence these components will be separated out into a family package; called Qtrl. Potentially Qtrl may be replaced by separate packages for GRAPE and CRAB, based; on the QuTiP Control Framework. QIP; ^^^. * **current package status**: integrated sub-package `qutip.qip`; * **planned package status**: family package `qutip-qip`. The QIP subpackage has been deemed out of scope (feature-wise). It also depends; on `qutip.control` and hence would be out of scope for dependency reasons. A; separate repository has already been made for qutip-qip. qutip-symbolic; ^^^^^^^^^^^^^^. * **current package status**: independent package `sympsi`; * **planned package status**: family package `qutip-symbolic`. Long ago Robert Johansson and Eunjong Kim developed Sympsi. It is a fairly; coomplete library for quantum computer algebra ",MatchSource.DOCS,doc/development/roadmap.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst:6161,Integrability,integrat,integrated,6161,"s; - `solver` quantum dynamics solvers. What will remain in the base folder will be miscellaneous modules. There may be; some opportunity for grouping some into a `visualisation` subpackage. There is; also some potential for renaming, as some module names have underscores, which; is unconventional. Qtrl; ^^^^. * **current package status**: integrated sub-package `qutip.control`; * **planned package status**: family package `qtrl`. There are many OSS Python packages for quantum control optimisation. There are; also many different algorithms. The current `control` integrated subpackage; provides the GRAPE and CRAB algorithms. It is too ambitious for QuTiP to attempt; (or want) to provide for all options. Control optimisation has been deemed out; of scope and hence these components will be separated out into a family package; called Qtrl. Potentially Qtrl may be replaced by separate packages for GRAPE and CRAB, based; on the QuTiP Control Framework. QIP; ^^^. * **current package status**: integrated sub-package `qutip.qip`; * **planned package status**: family package `qutip-qip`. The QIP subpackage has been deemed out of scope (feature-wise). It also depends; on `qutip.control` and hence would be out of scope for dependency reasons. A; separate repository has already been made for qutip-qip. qutip-symbolic; ^^^^^^^^^^^^^^. * **current package status**: independent package `sympsi`; * **planned package status**: family package `qutip-symbolic`. Long ago Robert Johansson and Eunjong Kim developed Sympsi. It is a fairly; coomplete library for quantum computer algebra (symbolic computation). It is; primarily a quantum wrapper for `Sympy <https://www.sympy.org>`_. It has fallen into unmaintained status. The latest version on the `sympsi repo; <https://github.com/sympsi/sympsi>`_ does not work with recent versions of; Sympy. Alex Pitchford has a `fork <https://github.com/ajgpitch/sympsi>`_ that; does 'work' with recent Sympy versions -- unit tests pass, and most examples; wo",MatchSource.DOCS,doc/development/roadmap.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst:6327,Integrability,depend,depends,6327,"ation` subpackage. There is; also some potential for renaming, as some module names have underscores, which; is unconventional. Qtrl; ^^^^. * **current package status**: integrated sub-package `qutip.control`; * **planned package status**: family package `qtrl`. There are many OSS Python packages for quantum control optimisation. There are; also many different algorithms. The current `control` integrated subpackage; provides the GRAPE and CRAB algorithms. It is too ambitious for QuTiP to attempt; (or want) to provide for all options. Control optimisation has been deemed out; of scope and hence these components will be separated out into a family package; called Qtrl. Potentially Qtrl may be replaced by separate packages for GRAPE and CRAB, based; on the QuTiP Control Framework. QIP; ^^^. * **current package status**: integrated sub-package `qutip.qip`; * **planned package status**: family package `qutip-qip`. The QIP subpackage has been deemed out of scope (feature-wise). It also depends; on `qutip.control` and hence would be out of scope for dependency reasons. A; separate repository has already been made for qutip-qip. qutip-symbolic; ^^^^^^^^^^^^^^. * **current package status**: independent package `sympsi`; * **planned package status**: family package `qutip-symbolic`. Long ago Robert Johansson and Eunjong Kim developed Sympsi. It is a fairly; coomplete library for quantum computer algebra (symbolic computation). It is; primarily a quantum wrapper for `Sympy <https://www.sympy.org>`_. It has fallen into unmaintained status. The latest version on the `sympsi repo; <https://github.com/sympsi/sympsi>`_ does not work with recent versions of; Sympy. Alex Pitchford has a `fork <https://github.com/ajgpitch/sympsi>`_ that; does 'work' with recent Sympy versions -- unit tests pass, and most examples; work. However, some (important) examples fail, due to lack of respect for; non-commuting operators in Sympy simplifcation functions (note this was true as; of Nov 2019, may ",MatchSource.DOCS,doc/development/roadmap.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst:6391,Integrability,depend,dependency,6391,"al for renaming, as some module names have underscores, which; is unconventional. Qtrl; ^^^^. * **current package status**: integrated sub-package `qutip.control`; * **planned package status**: family package `qtrl`. There are many OSS Python packages for quantum control optimisation. There are; also many different algorithms. The current `control` integrated subpackage; provides the GRAPE and CRAB algorithms. It is too ambitious for QuTiP to attempt; (or want) to provide for all options. Control optimisation has been deemed out; of scope and hence these components will be separated out into a family package; called Qtrl. Potentially Qtrl may be replaced by separate packages for GRAPE and CRAB, based; on the QuTiP Control Framework. QIP; ^^^. * **current package status**: integrated sub-package `qutip.qip`; * **planned package status**: family package `qutip-qip`. The QIP subpackage has been deemed out of scope (feature-wise). It also depends; on `qutip.control` and hence would be out of scope for dependency reasons. A; separate repository has already been made for qutip-qip. qutip-symbolic; ^^^^^^^^^^^^^^. * **current package status**: independent package `sympsi`; * **planned package status**: family package `qutip-symbolic`. Long ago Robert Johansson and Eunjong Kim developed Sympsi. It is a fairly; coomplete library for quantum computer algebra (symbolic computation). It is; primarily a quantum wrapper for `Sympy <https://www.sympy.org>`_. It has fallen into unmaintained status. The latest version on the `sympsi repo; <https://github.com/sympsi/sympsi>`_ does not work with recent versions of; Sympy. Alex Pitchford has a `fork <https://github.com/ajgpitch/sympsi>`_ that; does 'work' with recent Sympy versions -- unit tests pass, and most examples; work. However, some (important) examples fail, due to lack of respect for; non-commuting operators in Sympy simplifcation functions (note this was true as; of Nov 2019, may be fixed now). There is a [not discussed with ",MatchSource.DOCS,doc/development/roadmap.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst:6800,Integrability,wrap,wrapper,6800,"ambitious for QuTiP to attempt; (or want) to provide for all options. Control optimisation has been deemed out; of scope and hence these components will be separated out into a family package; called Qtrl. Potentially Qtrl may be replaced by separate packages for GRAPE and CRAB, based; on the QuTiP Control Framework. QIP; ^^^. * **current package status**: integrated sub-package `qutip.qip`; * **planned package status**: family package `qutip-qip`. The QIP subpackage has been deemed out of scope (feature-wise). It also depends; on `qutip.control` and hence would be out of scope for dependency reasons. A; separate repository has already been made for qutip-qip. qutip-symbolic; ^^^^^^^^^^^^^^. * **current package status**: independent package `sympsi`; * **planned package status**: family package `qutip-symbolic`. Long ago Robert Johansson and Eunjong Kim developed Sympsi. It is a fairly; coomplete library for quantum computer algebra (symbolic computation). It is; primarily a quantum wrapper for `Sympy <https://www.sympy.org>`_. It has fallen into unmaintained status. The latest version on the `sympsi repo; <https://github.com/sympsi/sympsi>`_ does not work with recent versions of; Sympy. Alex Pitchford has a `fork <https://github.com/ajgpitch/sympsi>`_ that; does 'work' with recent Sympy versions -- unit tests pass, and most examples; work. However, some (important) examples fail, due to lack of respect for; non-commuting operators in Sympy simplifcation functions (note this was true as; of Nov 2019, may be fixed now). There is a [not discussed with RJ & EK] plan to move this into the QuTiP family; to allow the Admin Team to maintain, develop and promote it. The 'Sympsi' name; is cute, but a little abstract, and qutip-symbolic is proposed as an; alternative, as it is plainer and more distinct from Sympy. Affilliated packages; --------------------. qucontrol-krotov; ^^^^^^^^^^^^^^^^. * **code repository**: https://github.com/qucontrol/krotov. A package for quantum co",MatchSource.DOCS,doc/development/roadmap.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst:8055,Integrability,integrat,integration,8055,"mpsi>`_ that; does 'work' with recent Sympy versions -- unit tests pass, and most examples; work. However, some (important) examples fail, due to lack of respect for; non-commuting operators in Sympy simplifcation functions (note this was true as; of Nov 2019, may be fixed now). There is a [not discussed with RJ & EK] plan to move this into the QuTiP family; to allow the Admin Team to maintain, develop and promote it. The 'Sympsi' name; is cute, but a little abstract, and qutip-symbolic is proposed as an; alternative, as it is plainer and more distinct from Sympy. Affilliated packages; --------------------. qucontrol-krotov; ^^^^^^^^^^^^^^^^. * **code repository**: https://github.com/qucontrol/krotov. A package for quantum control optimisation using Krotov, developed mainly by; Michael Goerz. Generally accepted by the Admin Team as well developed and maintained. A solid; candiate for affilliation. Development Projects; ====================. .. _solve-dl:. Solver data layer integration; -----------------------------. :tag: solve-dl; :status: development ongoing; :admin lead: `Eric <https://github.com/Ericgig>`_; :main dev: `Eric <https://github.com/Ericgig>`_. The new data layer gives opportunity for significantly improving performance of; the qutip solvers. Eric has been revamping the solvers by deploying `QobjEvo`; (the time-dependent quantum object) that he developed. `QobjEvo` will exploit; the data layer, and the solvers in turn exploit `QobjEvo`. .. _qtrl-mig:. Qtrl migration; --------------. :tag: qtrl-mig; :status: conceptualised; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. The components currently packaged as an integrated subpackage of qutip main will; be moved to separate package called Qtrl. This is the original codename of the; package before it was integrated into qutip. Also changes to exploit the new; data layer will be implemented. .. _ctrl-fw:. QuTiP control framework; -----------------------. :tag: ctrl-fw; :status: conceptu",MatchSource.DOCS,doc/development/roadmap.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst:8415,Integrability,depend,dependent,8415,"his into the QuTiP family; to allow the Admin Team to maintain, develop and promote it. The 'Sympsi' name; is cute, but a little abstract, and qutip-symbolic is proposed as an; alternative, as it is plainer and more distinct from Sympy. Affilliated packages; --------------------. qucontrol-krotov; ^^^^^^^^^^^^^^^^. * **code repository**: https://github.com/qucontrol/krotov. A package for quantum control optimisation using Krotov, developed mainly by; Michael Goerz. Generally accepted by the Admin Team as well developed and maintained. A solid; candiate for affilliation. Development Projects; ====================. .. _solve-dl:. Solver data layer integration; -----------------------------. :tag: solve-dl; :status: development ongoing; :admin lead: `Eric <https://github.com/Ericgig>`_; :main dev: `Eric <https://github.com/Ericgig>`_. The new data layer gives opportunity for significantly improving performance of; the qutip solvers. Eric has been revamping the solvers by deploying `QobjEvo`; (the time-dependent quantum object) that he developed. `QobjEvo` will exploit; the data layer, and the solvers in turn exploit `QobjEvo`. .. _qtrl-mig:. Qtrl migration; --------------. :tag: qtrl-mig; :status: conceptualised; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. The components currently packaged as an integrated subpackage of qutip main will; be moved to separate package called Qtrl. This is the original codename of the; package before it was integrated into qutip. Also changes to exploit the new; data layer will be implemented. .. _ctrl-fw:. QuTiP control framework; -----------------------. :tag: ctrl-fw; :status: conceptualised; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. Create new package qutip-ctrlfw ""QuTiP Control Framework"". The aim is provide a; common framework that can be adopted by control optimisation packages, such that; different packages (algorithms) can be applied to the same problem. Classes for defining a contr",MatchSource.DOCS,doc/development/roadmap.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst:8739,Integrability,integrat,integrated,8739,"qucontrol/krotov. A package for quantum control optimisation using Krotov, developed mainly by; Michael Goerz. Generally accepted by the Admin Team as well developed and maintained. A solid; candiate for affilliation. Development Projects; ====================. .. _solve-dl:. Solver data layer integration; -----------------------------. :tag: solve-dl; :status: development ongoing; :admin lead: `Eric <https://github.com/Ericgig>`_; :main dev: `Eric <https://github.com/Ericgig>`_. The new data layer gives opportunity for significantly improving performance of; the qutip solvers. Eric has been revamping the solvers by deploying `QobjEvo`; (the time-dependent quantum object) that he developed. `QobjEvo` will exploit; the data layer, and the solvers in turn exploit `QobjEvo`. .. _qtrl-mig:. Qtrl migration; --------------. :tag: qtrl-mig; :status: conceptualised; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. The components currently packaged as an integrated subpackage of qutip main will; be moved to separate package called Qtrl. This is the original codename of the; package before it was integrated into qutip. Also changes to exploit the new; data layer will be implemented. .. _ctrl-fw:. QuTiP control framework; -----------------------. :tag: ctrl-fw; :status: conceptualised; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. Create new package qutip-ctrlfw ""QuTiP Control Framework"". The aim is provide a; common framework that can be adopted by control optimisation packages, such that; different packages (algorithms) can be applied to the same problem. Classes for defining a controlled system:. - named control parameters. Scalar and n-dim. Continuous and discrete variables; - mapping of control parameters to dynamics generator args; - masking for control parameters to be optimised. Classes for time-dependent variable parameterisation. - piecewise constant; - piecewise linear; - Fourier basis; - more. Classes for defining an optimis",MatchSource.DOCS,doc/development/roadmap.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst:8883,Integrability,integrat,integrated,8883," Goerz. Generally accepted by the Admin Team as well developed and maintained. A solid; candiate for affilliation. Development Projects; ====================. .. _solve-dl:. Solver data layer integration; -----------------------------. :tag: solve-dl; :status: development ongoing; :admin lead: `Eric <https://github.com/Ericgig>`_; :main dev: `Eric <https://github.com/Ericgig>`_. The new data layer gives opportunity for significantly improving performance of; the qutip solvers. Eric has been revamping the solvers by deploying `QobjEvo`; (the time-dependent quantum object) that he developed. `QobjEvo` will exploit; the data layer, and the solvers in turn exploit `QobjEvo`. .. _qtrl-mig:. Qtrl migration; --------------. :tag: qtrl-mig; :status: conceptualised; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. The components currently packaged as an integrated subpackage of qutip main will; be moved to separate package called Qtrl. This is the original codename of the; package before it was integrated into qutip. Also changes to exploit the new; data layer will be implemented. .. _ctrl-fw:. QuTiP control framework; -----------------------. :tag: ctrl-fw; :status: conceptualised; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. Create new package qutip-ctrlfw ""QuTiP Control Framework"". The aim is provide a; common framework that can be adopted by control optimisation packages, such that; different packages (algorithms) can be applied to the same problem. Classes for defining a controlled system:. - named control parameters. Scalar and n-dim. Continuous and discrete variables; - mapping of control parameters to dynamics generator args; - masking for control parameters to be optimised. Classes for time-dependent variable parameterisation. - piecewise constant; - piecewise linear; - Fourier basis; - more. Classes for defining an optimisation problem:. - single and multiple objectives. .. _qutip-optim:. QuTiP optimisation; ----------------",MatchSource.DOCS,doc/development/roadmap.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst:9625,Integrability,depend,dependent,9625,"min lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. The components currently packaged as an integrated subpackage of qutip main will; be moved to separate package called Qtrl. This is the original codename of the; package before it was integrated into qutip. Also changes to exploit the new; data layer will be implemented. .. _ctrl-fw:. QuTiP control framework; -----------------------. :tag: ctrl-fw; :status: conceptualised; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. Create new package qutip-ctrlfw ""QuTiP Control Framework"". The aim is provide a; common framework that can be adopted by control optimisation packages, such that; different packages (algorithms) can be applied to the same problem. Classes for defining a controlled system:. - named control parameters. Scalar and n-dim. Continuous and discrete variables; - mapping of control parameters to dynamics generator args; - masking for control parameters to be optimised. Classes for time-dependent variable parameterisation. - piecewise constant; - piecewise linear; - Fourier basis; - more. Classes for defining an optimisation problem:. - single and multiple objectives. .. _qutip-optim:. QuTiP optimisation; ------------------. :tag: qutip-optim; :status: conceptualised; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. A wrapper for multi-variable optimisation functions. For instance those in; `scipy.optimize` (Nelder-Mead, BFGS), but also others, such as Bayesian; optimisation and other machine learning based approaches. Initially just; providing a common interface for quantum control optimisation, but applicable; more generally. .. _sympsi-mig:. Sympsi migration; ----------------. :tag: sympsi-mig; :status: conceptualised; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. Create a new family package qutip-symbolic from ajgpitch fork of Sympy. Must; gain permission from Robert Johansson and Eunjong Kim. Extended Sympy simplify; to respect non",MatchSource.DOCS,doc/development/roadmap.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst:9982,Integrability,wrap,wrapper,9982,"ork; -----------------------. :tag: ctrl-fw; :status: conceptualised; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. Create new package qutip-ctrlfw ""QuTiP Control Framework"". The aim is provide a; common framework that can be adopted by control optimisation packages, such that; different packages (algorithms) can be applied to the same problem. Classes for defining a controlled system:. - named control parameters. Scalar and n-dim. Continuous and discrete variables; - mapping of control parameters to dynamics generator args; - masking for control parameters to be optimised. Classes for time-dependent variable parameterisation. - piecewise constant; - piecewise linear; - Fourier basis; - more. Classes for defining an optimisation problem:. - single and multiple objectives. .. _qutip-optim:. QuTiP optimisation; ------------------. :tag: qutip-optim; :status: conceptualised; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. A wrapper for multi-variable optimisation functions. For instance those in; `scipy.optimize` (Nelder-Mead, BFGS), but also others, such as Bayesian; optimisation and other machine learning based approaches. Initially just; providing a common interface for quantum control optimisation, but applicable; more generally. .. _sympsi-mig:. Sympsi migration; ----------------. :tag: sympsi-mig; :status: conceptualised; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. Create a new family package qutip-symbolic from ajgpitch fork of Sympy. Must; gain permission from Robert Johansson and Eunjong Kim. Extended Sympy simplify; to respect non-commuting operators. Produce user documentation. .. _status-mig:. Status messaging and recording; ------------------------------. :tag: status-msg; :status: conceptualised; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. QuTiP has various ways of recording and reporting status and progress. - `ProgressBar` used by some solvers; - Python logging used",MatchSource.DOCS,doc/development/roadmap.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst:10222,Integrability,interface,interface,10222,"that can be adopted by control optimisation packages, such that; different packages (algorithms) can be applied to the same problem. Classes for defining a controlled system:. - named control parameters. Scalar and n-dim. Continuous and discrete variables; - mapping of control parameters to dynamics generator args; - masking for control parameters to be optimised. Classes for time-dependent variable parameterisation. - piecewise constant; - piecewise linear; - Fourier basis; - more. Classes for defining an optimisation problem:. - single and multiple objectives. .. _qutip-optim:. QuTiP optimisation; ------------------. :tag: qutip-optim; :status: conceptualised; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. A wrapper for multi-variable optimisation functions. For instance those in; `scipy.optimize` (Nelder-Mead, BFGS), but also others, such as Bayesian; optimisation and other machine learning based approaches. Initially just; providing a common interface for quantum control optimisation, but applicable; more generally. .. _sympsi-mig:. Sympsi migration; ----------------. :tag: sympsi-mig; :status: conceptualised; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. Create a new family package qutip-symbolic from ajgpitch fork of Sympy. Must; gain permission from Robert Johansson and Eunjong Kim. Extended Sympy simplify; to respect non-commuting operators. Produce user documentation. .. _status-mig:. Status messaging and recording; ------------------------------. :tag: status-msg; :status: conceptualised; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. QuTiP has various ways of recording and reporting status and progress. - `ProgressBar` used by some solvers; - Python logging used in qutip.control; - `Dump` used in qutip.control; - heom records `solver.Stats`. Some consolidation of these would be good. Some processes (some solvers, correlation, control optimisation) have many; stages and many layers. `Dump` was ",MatchSource.DOCS,doc/development/roadmap.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst:12346,Integrability,interface,interface,12346,"icised for the way it uses Python logging. The output goes to stderr; and hence the output looks like errors in Jupyter notebooks. Clearly, storing process stage data is costly in terms of memory and cpu time,; so any implementation must be able to be optionally switched on/off, and avoided; completely in low-level processes (cythonized components). Required features:. - optional recording (storing) of process stage data (states, operators etc); - optionally write subsets to stdout; - maybe other graphical representations; - option to save subsets to file; - should ideally replace use of `ProgressBar`, Python logging, `control.Dump`, `solver.Stats`. .. _qutip-gui:. qutip Interactive; -----------------. :status: conceptualised; :tag: qutip-gui; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. QuTiP is pretty simple to use at an entry level for anyone with basic Python; skills. However, *some* Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners. This would make an good GSoC project. It is independent and the scope is; flexible. The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere; ^^^^^^^^^^^^^^^^^^^^^^^^. Matplotlib has some interactive features (sliders, radio buttons, cmd buttons); that can be used to control parameters. They are a bit clunky to use, but they; are there. Could maybe avoid these and develop our own GUI. An interactive Bloch; sphere could have sliders for qubit state angles. Buttons to add states, toggle; state evolution path. Interactive solvers; ^^^^^^^^^^^^^^^^^^^. Options to configure dynamics generators (Lindbladian / Hamiltonian args etc); and expectation operators. Then run solver and view state evolution. Animated circuits; ^^^^^^^^^^^^^^^^^. QIP circuits could be animated. Status lights showing evolution of states during; the",MatchSource.DOCS,doc/development/roadmap.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst:3116,Modifiability,enhance,enhancement,3116,"me as general as Quantum Toolkit in Python, the scope for new code; modules to be added to qutip is very wide. The library was becoming increasingly; difficult to maintain, and in c. 2020 the QuTiP Admim Team decided to limit the; scope of the 'main' (for want of a better name) qutip package. This scope is; restricted to components for the simulation (solving) of the dynamics of quantum; systems. The scope includes utilities to support this, including analysis and; visualisation of output. At the same time, again with the intention of easing maintence, a decision to; limit dependences was agreed upon. Main qutip runtime code components should; depend only upon Numpy and Scipy. Installation (from source) requires Cython,; and some optional components also require Cython at runtime. Unit testing; requires Pytest. Visualisation (optional) components require Matplotlib. Due to the all encompassing nature of the plan to abstract the linear algebra; data layer, this enhancement (developed as part of a GSoC project) was allowed; the freedom (potential for non-backward compatibility) of requiring a major; release. The timing of such allows for a restructuring of the qutip compoments,; such that some that could be deemed out of scope could be packaged in a; different way -- that is, not installed as part of the main qutip package. Hence; the proposal for different types of package described next. With reference to; the :ref:`discussion above <what-is-qutip>` on the name QuTiP/qutip, the planned; restructuring suffers from confusing naming, which seems unavoidable without; remaining either the organisation or the main package (neither of which are; desirable). QuTiP family packages; The main qutip package already has sub-packages,; which are maintained in the main qutip repo. Any packages maitained by the; QuTiP organisation will be called QuTiP 'family' packages. Sub-packages within; qutip main will be called 'integrated' sub-packages. Some packages will be; maintained in the",MatchSource.DOCS,doc/development/roadmap.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst:9487,Modifiability,variab,variables,9487,"objEvo`. .. _qtrl-mig:. Qtrl migration; --------------. :tag: qtrl-mig; :status: conceptualised; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. The components currently packaged as an integrated subpackage of qutip main will; be moved to separate package called Qtrl. This is the original codename of the; package before it was integrated into qutip. Also changes to exploit the new; data layer will be implemented. .. _ctrl-fw:. QuTiP control framework; -----------------------. :tag: ctrl-fw; :status: conceptualised; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. Create new package qutip-ctrlfw ""QuTiP Control Framework"". The aim is provide a; common framework that can be adopted by control optimisation packages, such that; different packages (algorithms) can be applied to the same problem. Classes for defining a controlled system:. - named control parameters. Scalar and n-dim. Continuous and discrete variables; - mapping of control parameters to dynamics generator args; - masking for control parameters to be optimised. Classes for time-dependent variable parameterisation. - piecewise constant; - piecewise linear; - Fourier basis; - more. Classes for defining an optimisation problem:. - single and multiple objectives. .. _qutip-optim:. QuTiP optimisation; ------------------. :tag: qutip-optim; :status: conceptualised; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. A wrapper for multi-variable optimisation functions. For instance those in; `scipy.optimize` (Nelder-Mead, BFGS), but also others, such as Bayesian; optimisation and other machine learning based approaches. Initially just; providing a common interface for quantum control optimisation, but applicable; more generally. .. _sympsi-mig:. Sympsi migration; ----------------. :tag: sympsi-mig; :status: conceptualised; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. Create a new family package qutip-symbolic from ajgpitch fork of Sympy. M",MatchSource.DOCS,doc/development/roadmap.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst:9635,Modifiability,variab,variable,9635,"min lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. The components currently packaged as an integrated subpackage of qutip main will; be moved to separate package called Qtrl. This is the original codename of the; package before it was integrated into qutip. Also changes to exploit the new; data layer will be implemented. .. _ctrl-fw:. QuTiP control framework; -----------------------. :tag: ctrl-fw; :status: conceptualised; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. Create new package qutip-ctrlfw ""QuTiP Control Framework"". The aim is provide a; common framework that can be adopted by control optimisation packages, such that; different packages (algorithms) can be applied to the same problem. Classes for defining a controlled system:. - named control parameters. Scalar and n-dim. Continuous and discrete variables; - mapping of control parameters to dynamics generator args; - masking for control parameters to be optimised. Classes for time-dependent variable parameterisation. - piecewise constant; - piecewise linear; - Fourier basis; - more. Classes for defining an optimisation problem:. - single and multiple objectives. .. _qutip-optim:. QuTiP optimisation; ------------------. :tag: qutip-optim; :status: conceptualised; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. A wrapper for multi-variable optimisation functions. For instance those in; `scipy.optimize` (Nelder-Mead, BFGS), but also others, such as Bayesian; optimisation and other machine learning based approaches. Initially just; providing a common interface for quantum control optimisation, but applicable; more generally. .. _sympsi-mig:. Sympsi migration; ----------------. :tag: sympsi-mig; :status: conceptualised; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. Create a new family package qutip-symbolic from ajgpitch fork of Sympy. Must; gain permission from Robert Johansson and Eunjong Kim. Extended Sympy simplify; to respect non",MatchSource.DOCS,doc/development/roadmap.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst:10000,Modifiability,variab,variable,10000,"ork; -----------------------. :tag: ctrl-fw; :status: conceptualised; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. Create new package qutip-ctrlfw ""QuTiP Control Framework"". The aim is provide a; common framework that can be adopted by control optimisation packages, such that; different packages (algorithms) can be applied to the same problem. Classes for defining a controlled system:. - named control parameters. Scalar and n-dim. Continuous and discrete variables; - mapping of control parameters to dynamics generator args; - masking for control parameters to be optimised. Classes for time-dependent variable parameterisation. - piecewise constant; - piecewise linear; - Fourier basis; - more. Classes for defining an optimisation problem:. - single and multiple objectives. .. _qutip-optim:. QuTiP optimisation; ------------------. :tag: qutip-optim; :status: conceptualised; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. A wrapper for multi-variable optimisation functions. For instance those in; `scipy.optimize` (Nelder-Mead, BFGS), but also others, such as Bayesian; optimisation and other machine learning based approaches. Initially just; providing a common interface for quantum control optimisation, but applicable; more generally. .. _sympsi-mig:. Sympsi migration; ----------------. :tag: sympsi-mig; :status: conceptualised; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. Create a new family package qutip-symbolic from ajgpitch fork of Sympy. Must; gain permission from Robert Johansson and Eunjong Kim. Extended Sympy simplify; to respect non-commuting operators. Produce user documentation. .. _status-mig:. Status messaging and recording; ------------------------------. :tag: status-msg; :status: conceptualised; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. QuTiP has various ways of recording and reporting status and progress. - `ProgressBar` used by some solvers; - Python logging used",MatchSource.DOCS,doc/development/roadmap.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst:11223,Modifiability,layers,layers,11223,"aches. Initially just; providing a common interface for quantum control optimisation, but applicable; more generally. .. _sympsi-mig:. Sympsi migration; ----------------. :tag: sympsi-mig; :status: conceptualised; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. Create a new family package qutip-symbolic from ajgpitch fork of Sympy. Must; gain permission from Robert Johansson and Eunjong Kim. Extended Sympy simplify; to respect non-commuting operators. Produce user documentation. .. _status-mig:. Status messaging and recording; ------------------------------. :tag: status-msg; :status: conceptualised; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. QuTiP has various ways of recording and reporting status and progress. - `ProgressBar` used by some solvers; - Python logging used in qutip.control; - `Dump` used in qutip.control; - heom records `solver.Stats`. Some consolidation of these would be good. Some processes (some solvers, correlation, control optimisation) have many; stages and many layers. `Dump` was initially developed to help with debugging,; but it is also useful for recording data for analysis. qutip.logging_utils has; been criticised for the way it uses Python logging. The output goes to stderr; and hence the output looks like errors in Jupyter notebooks. Clearly, storing process stage data is costly in terms of memory and cpu time,; so any implementation must be able to be optionally switched on/off, and avoided; completely in low-level processes (cythonized components). Required features:. - optional recording (storing) of process stage data (states, operators etc); - optionally write subsets to stdout; - maybe other graphical representations; - option to save subsets to file; - should ideally replace use of `ProgressBar`, Python logging, `control.Dump`, `solver.Stats`. .. _qutip-gui:. qutip Interactive; -----------------. :status: conceptualised; :tag: qutip-gui; :admin lead: `Alex <https://github.com/ajgpitch>`_",MatchSource.DOCS,doc/development/roadmap.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst:12577,Modifiability,flexible,flexible,12577,"f memory and cpu time,; so any implementation must be able to be optionally switched on/off, and avoided; completely in low-level processes (cythonized components). Required features:. - optional recording (storing) of process stage data (states, operators etc); - optionally write subsets to stdout; - maybe other graphical representations; - option to save subsets to file; - should ideally replace use of `ProgressBar`, Python logging, `control.Dump`, `solver.Stats`. .. _qutip-gui:. qutip Interactive; -----------------. :status: conceptualised; :tag: qutip-gui; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. QuTiP is pretty simple to use at an entry level for anyone with basic Python; skills. However, *some* Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners. This would make an good GSoC project. It is independent and the scope is; flexible. The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere; ^^^^^^^^^^^^^^^^^^^^^^^^. Matplotlib has some interactive features (sliders, radio buttons, cmd buttons); that can be used to control parameters. They are a bit clunky to use, but they; are there. Could maybe avoid these and develop our own GUI. An interactive Bloch; sphere could have sliders for qubit state angles. Buttons to add states, toggle; state evolution path. Interactive solvers; ^^^^^^^^^^^^^^^^^^^. Options to configure dynamics generators (Lindbladian / Hamiltonian args etc); and expectation operators. Then run solver and view state evolution. Animated circuits; ^^^^^^^^^^^^^^^^^. QIP circuits could be animated. Status lights showing evolution of states during; the processing. Animated Bloch spheres for qubits. Completed Development Projects; ==============================. .. _dl-abs:. data layer abstraction; ----------------------. :tag: dl-abs;",MatchSource.DOCS,doc/development/roadmap.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst:12619,Modifiability,flexible,flexible,12619,"n must be able to be optionally switched on/off, and avoided; completely in low-level processes (cythonized components). Required features:. - optional recording (storing) of process stage data (states, operators etc); - optionally write subsets to stdout; - maybe other graphical representations; - option to save subsets to file; - should ideally replace use of `ProgressBar`, Python logging, `control.Dump`, `solver.Stats`. .. _qutip-gui:. qutip Interactive; -----------------. :status: conceptualised; :tag: qutip-gui; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. QuTiP is pretty simple to use at an entry level for anyone with basic Python; skills. However, *some* Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners. This would make an good GSoC project. It is independent and the scope is; flexible. The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere; ^^^^^^^^^^^^^^^^^^^^^^^^. Matplotlib has some interactive features (sliders, radio buttons, cmd buttons); that can be used to control parameters. They are a bit clunky to use, but they; are there. Could maybe avoid these and develop our own GUI. An interactive Bloch; sphere could have sliders for qubit state angles. Buttons to add states, toggle; state evolution path. Interactive solvers; ^^^^^^^^^^^^^^^^^^^. Options to configure dynamics generators (Lindbladian / Hamiltonian args etc); and expectation operators. Then run solver and view state evolution. Animated circuits; ^^^^^^^^^^^^^^^^^. QIP circuits could be animated. Status lights showing evolution of states during; the processing. Animated Bloch spheres for qubits. Completed Development Projects; ==============================. .. _dl-abs:. data layer abstraction; ----------------------. :tag: dl-abs; :status: completed; :admin lead: `Eric <htt",MatchSource.DOCS,doc/development/roadmap.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst:13117,Modifiability,config,configure,13117,"github.com/ajgpitch>`_; :main dev: TBA. QuTiP is pretty simple to use at an entry level for anyone with basic Python; skills. However, *some* Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners. This would make an good GSoC project. It is independent and the scope is; flexible. The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere; ^^^^^^^^^^^^^^^^^^^^^^^^. Matplotlib has some interactive features (sliders, radio buttons, cmd buttons); that can be used to control parameters. They are a bit clunky to use, but they; are there. Could maybe avoid these and develop our own GUI. An interactive Bloch; sphere could have sliders for qubit state angles. Buttons to add states, toggle; state evolution path. Interactive solvers; ^^^^^^^^^^^^^^^^^^^. Options to configure dynamics generators (Lindbladian / Hamiltonian args etc); and expectation operators. Then run solver and view state evolution. Animated circuits; ^^^^^^^^^^^^^^^^^. QIP circuits could be animated. Status lights showing evolution of states during; the processing. Animated Bloch spheres for qubits. Completed Development Projects; ==============================. .. _dl-abs:. data layer abstraction; ----------------------. :tag: dl-abs; :status: completed; :admin lead: `Eric <https://github.com/Ericgig>`_; :main dev: `Jake Lishman <https://github.com/jakelishman>`_. Development completed as a GSoC project. Fully implemented in the dev.major; branch. Currently being used by some research groups. Abstraction of the linear algebra data from code qutip components, allowing; for alternatives, such as sparse, dense etc. Difficult to summarize. Almost; every file in qutip affected in some way. A major milestone for qutip.; Significant performance improvements throughout qutip. Some developments tasks remain, including providin",MatchSource.DOCS,doc/development/roadmap.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst:8310,Performance,perform,performance,8310,"te this was true as; of Nov 2019, may be fixed now). There is a [not discussed with RJ & EK] plan to move this into the QuTiP family; to allow the Admin Team to maintain, develop and promote it. The 'Sympsi' name; is cute, but a little abstract, and qutip-symbolic is proposed as an; alternative, as it is plainer and more distinct from Sympy. Affilliated packages; --------------------. qucontrol-krotov; ^^^^^^^^^^^^^^^^. * **code repository**: https://github.com/qucontrol/krotov. A package for quantum control optimisation using Krotov, developed mainly by; Michael Goerz. Generally accepted by the Admin Team as well developed and maintained. A solid; candiate for affilliation. Development Projects; ====================. .. _solve-dl:. Solver data layer integration; -----------------------------. :tag: solve-dl; :status: development ongoing; :admin lead: `Eric <https://github.com/Ericgig>`_; :main dev: `Eric <https://github.com/Ericgig>`_. The new data layer gives opportunity for significantly improving performance of; the qutip solvers. Eric has been revamping the solvers by deploying `QobjEvo`; (the time-dependent quantum object) that he developed. `QobjEvo` will exploit; the data layer, and the solvers in turn exploit `QobjEvo`. .. _qtrl-mig:. Qtrl migration; --------------. :tag: qtrl-mig; :status: conceptualised; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. The components currently packaged as an integrated subpackage of qutip main will; be moved to separate package called Qtrl. This is the original codename of the; package before it was integrated into qutip. Also changes to exploit the new; data layer will be implemented. .. _ctrl-fw:. QuTiP control framework; -----------------------. :tag: ctrl-fw; :status: conceptualised; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. Create new package qutip-ctrlfw ""QuTiP Control Framework"". The aim is provide a; common framework that can be adopted by control optimisation packages,",MatchSource.DOCS,doc/development/roadmap.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst:10063,Performance,optimiz,optimize,10063,"_; :main dev: TBA. Create new package qutip-ctrlfw ""QuTiP Control Framework"". The aim is provide a; common framework that can be adopted by control optimisation packages, such that; different packages (algorithms) can be applied to the same problem. Classes for defining a controlled system:. - named control parameters. Scalar and n-dim. Continuous and discrete variables; - mapping of control parameters to dynamics generator args; - masking for control parameters to be optimised. Classes for time-dependent variable parameterisation. - piecewise constant; - piecewise linear; - Fourier basis; - more. Classes for defining an optimisation problem:. - single and multiple objectives. .. _qutip-optim:. QuTiP optimisation; ------------------. :tag: qutip-optim; :status: conceptualised; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. A wrapper for multi-variable optimisation functions. For instance those in; `scipy.optimize` (Nelder-Mead, BFGS), but also others, such as Bayesian; optimisation and other machine learning based approaches. Initially just; providing a common interface for quantum control optimisation, but applicable; more generally. .. _sympsi-mig:. Sympsi migration; ----------------. :tag: sympsi-mig; :status: conceptualised; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. Create a new family package qutip-symbolic from ajgpitch fork of Sympy. Must; gain permission from Robert Johansson and Eunjong Kim. Extended Sympy simplify; to respect non-commuting operators. Produce user documentation. .. _status-mig:. Status messaging and recording; ------------------------------. :tag: status-msg; :status: conceptualised; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. QuTiP has various ways of recording and reporting status and progress. - `ProgressBar` used by some solvers; - Python logging used in qutip.control; - `Dump` used in qutip.control; - heom records `solver.Stats`. Some consolidation of these would be ",MatchSource.DOCS,doc/development/roadmap.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst:14065,Performance,perform,performance,14065,"vers; ^^^^^^^^^^^^^^^^^^^. Options to configure dynamics generators (Lindbladian / Hamiltonian args etc); and expectation operators. Then run solver and view state evolution. Animated circuits; ^^^^^^^^^^^^^^^^^. QIP circuits could be animated. Status lights showing evolution of states during; the processing. Animated Bloch spheres for qubits. Completed Development Projects; ==============================. .. _dl-abs:. data layer abstraction; ----------------------. :tag: dl-abs; :status: completed; :admin lead: `Eric <https://github.com/Ericgig>`_; :main dev: `Jake Lishman <https://github.com/jakelishman>`_. Development completed as a GSoC project. Fully implemented in the dev.major; branch. Currently being used by some research groups. Abstraction of the linear algebra data from code qutip components, allowing; for alternatives, such as sparse, dense etc. Difficult to summarize. Almost; every file in qutip affected in some way. A major milestone for qutip.; Significant performance improvements throughout qutip. Some developments tasks remain, including providing full control over how the; data-layer dispatchers choose the most appropriate output type. .. _qmain-reorg:. qutip main reorganization; -------------------------. :tag: qmain-reorg; :status: completed; :admin lead: `Eric <https://github.com/Ericgig>`_; :main dev: `Jake Lishman <https://github.com/jakelishman>`_. Reorganise qutip main components to the structure :ref:`described above <qmain>`. .. _qmain-docs:. qutip user docs migration; -------------------------. :tag: qmain-docs; :status: completed; :admin lead: `Jake Lishman <https://github.com/jakelishman>`_; :main dev: `Jake Lishman <https://github.com/jakelishman>`_. The qutip user documentation build files are to be moved to the qutip/qutip; repo. This is more typical for an OSS package. As part of the move, the plan is to reconstruct the Sphinx structure from; scratch. Historically, there have been many issues with building the docs.; Sphinx has come",MatchSource.DOCS,doc/development/roadmap.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst:11660,Safety,avoid,avoided,11660,"fy; to respect non-commuting operators. Produce user documentation. .. _status-mig:. Status messaging and recording; ------------------------------. :tag: status-msg; :status: conceptualised; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. QuTiP has various ways of recording and reporting status and progress. - `ProgressBar` used by some solvers; - Python logging used in qutip.control; - `Dump` used in qutip.control; - heom records `solver.Stats`. Some consolidation of these would be good. Some processes (some solvers, correlation, control optimisation) have many; stages and many layers. `Dump` was initially developed to help with debugging,; but it is also useful for recording data for analysis. qutip.logging_utils has; been criticised for the way it uses Python logging. The output goes to stderr; and hence the output looks like errors in Jupyter notebooks. Clearly, storing process stage data is costly in terms of memory and cpu time,; so any implementation must be able to be optionally switched on/off, and avoided; completely in low-level processes (cythonized components). Required features:. - optional recording (storing) of process stage data (states, operators etc); - optionally write subsets to stdout; - maybe other graphical representations; - option to save subsets to file; - should ideally replace use of `ProgressBar`, Python logging, `control.Dump`, `solver.Stats`. .. _qutip-gui:. qutip Interactive; -----------------. :status: conceptualised; :tag: qutip-gui; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. QuTiP is pretty simple to use at an entry level for anyone with basic Python; skills. However, *some* Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners. This would make an good GSoC project. It is independent and the scope is; flexible. The scope for this is broad an",MatchSource.DOCS,doc/development/roadmap.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst:12902,Safety,avoid,avoid,12902," to save subsets to file; - should ideally replace use of `ProgressBar`, Python logging, `control.Dump`, `solver.Stats`. .. _qutip-gui:. qutip Interactive; -----------------. :status: conceptualised; :tag: qutip-gui; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. QuTiP is pretty simple to use at an entry level for anyone with basic Python; skills. However, *some* Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners. This would make an good GSoC project. It is independent and the scope is; flexible. The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere; ^^^^^^^^^^^^^^^^^^^^^^^^. Matplotlib has some interactive features (sliders, radio buttons, cmd buttons); that can be used to control parameters. They are a bit clunky to use, but they; are there. Could maybe avoid these and develop our own GUI. An interactive Bloch; sphere could have sliders for qubit state angles. Buttons to add states, toggle; state evolution path. Interactive solvers; ^^^^^^^^^^^^^^^^^^^. Options to configure dynamics generators (Lindbladian / Hamiltonian args etc); and expectation operators. Then run solver and view state evolution. Animated circuits; ^^^^^^^^^^^^^^^^^. QIP circuits could be animated. Status lights showing evolution of states during; the processing. Animated Bloch spheres for qubits. Completed Development Projects; ==============================. .. _dl-abs:. data layer abstraction; ----------------------. :tag: dl-abs; :status: completed; :admin lead: `Eric <https://github.com/Ericgig>`_; :main dev: `Jake Lishman <https://github.com/jakelishman>`_. Development completed as a GSoC project. Fully implemented in the dev.major; branch. Currently being used by some research groups. Abstraction of the linear algebra data from code qutip components, allowing; for altern",MatchSource.DOCS,doc/development/roadmap.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst:12414,Security,access,accessible,12414,"icised for the way it uses Python logging. The output goes to stderr; and hence the output looks like errors in Jupyter notebooks. Clearly, storing process stage data is costly in terms of memory and cpu time,; so any implementation must be able to be optionally switched on/off, and avoided; completely in low-level processes (cythonized components). Required features:. - optional recording (storing) of process stage data (states, operators etc); - optionally write subsets to stdout; - maybe other graphical representations; - option to save subsets to file; - should ideally replace use of `ProgressBar`, Python logging, `control.Dump`, `solver.Stats`. .. _qutip-gui:. qutip Interactive; -----------------. :status: conceptualised; :tag: qutip-gui; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. QuTiP is pretty simple to use at an entry level for anyone with basic Python; skills. However, *some* Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners. This would make an good GSoC project. It is independent and the scope is; flexible. The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere; ^^^^^^^^^^^^^^^^^^^^^^^^. Matplotlib has some interactive features (sliders, radio buttons, cmd buttons); that can be used to control parameters. They are a bit clunky to use, but they; are there. Could maybe avoid these and develop our own GUI. An interactive Bloch; sphere could have sliders for qubit state angles. Buttons to add states, toggle; state evolution path. Interactive solvers; ^^^^^^^^^^^^^^^^^^^. Options to configure dynamics generators (Lindbladian / Hamiltonian args etc); and expectation operators. Then run solver and view state evolution. Animated circuits; ^^^^^^^^^^^^^^^^^. QIP circuits could be animated. Status lights showing evolution of states during; the",MatchSource.DOCS,doc/development/roadmap.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst:2938,Testability,test,testing,2938,"robably chose another; name for the main qutip library, such as qutip-quantdyn. However, qutip is; famous, and the name will stay. Library package structure; =========================. With a name as general as Quantum Toolkit in Python, the scope for new code; modules to be added to qutip is very wide. The library was becoming increasingly; difficult to maintain, and in c. 2020 the QuTiP Admim Team decided to limit the; scope of the 'main' (for want of a better name) qutip package. This scope is; restricted to components for the simulation (solving) of the dynamics of quantum; systems. The scope includes utilities to support this, including analysis and; visualisation of output. At the same time, again with the intention of easing maintence, a decision to; limit dependences was agreed upon. Main qutip runtime code components should; depend only upon Numpy and Scipy. Installation (from source) requires Cython,; and some optional components also require Cython at runtime. Unit testing; requires Pytest. Visualisation (optional) components require Matplotlib. Due to the all encompassing nature of the plan to abstract the linear algebra; data layer, this enhancement (developed as part of a GSoC project) was allowed; the freedom (potential for non-backward compatibility) of requiring a major; release. The timing of such allows for a restructuring of the qutip compoments,; such that some that could be deemed out of scope could be packaged in a; different way -- that is, not installed as part of the main qutip package. Hence; the proposal for different types of package described next. With reference to; the :ref:`discussion above <what-is-qutip>` on the name QuTiP/qutip, the planned; restructuring suffers from confusing naming, which seems unavoidable without; remaining either the organisation or the main package (neither of which are; desirable). QuTiP family packages; The main qutip package already has sub-packages,; which are maintained in the main qutip repo. Any packag",MatchSource.DOCS,doc/development/roadmap.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst:7128,Testability,test,tests,7128,"l Framework. QIP; ^^^. * **current package status**: integrated sub-package `qutip.qip`; * **planned package status**: family package `qutip-qip`. The QIP subpackage has been deemed out of scope (feature-wise). It also depends; on `qutip.control` and hence would be out of scope for dependency reasons. A; separate repository has already been made for qutip-qip. qutip-symbolic; ^^^^^^^^^^^^^^. * **current package status**: independent package `sympsi`; * **planned package status**: family package `qutip-symbolic`. Long ago Robert Johansson and Eunjong Kim developed Sympsi. It is a fairly; coomplete library for quantum computer algebra (symbolic computation). It is; primarily a quantum wrapper for `Sympy <https://www.sympy.org>`_. It has fallen into unmaintained status. The latest version on the `sympsi repo; <https://github.com/sympsi/sympsi>`_ does not work with recent versions of; Sympy. Alex Pitchford has a `fork <https://github.com/ajgpitch/sympsi>`_ that; does 'work' with recent Sympy versions -- unit tests pass, and most examples; work. However, some (important) examples fail, due to lack of respect for; non-commuting operators in Sympy simplifcation functions (note this was true as; of Nov 2019, may be fixed now). There is a [not discussed with RJ & EK] plan to move this into the QuTiP family; to allow the Admin Team to maintain, develop and promote it. The 'Sympsi' name; is cute, but a little abstract, and qutip-symbolic is proposed as an; alternative, as it is plainer and more distinct from Sympy. Affilliated packages; --------------------. qucontrol-krotov; ^^^^^^^^^^^^^^^^. * **code repository**: https://github.com/qucontrol/krotov. A package for quantum control optimisation using Krotov, developed mainly by; Michael Goerz. Generally accepted by the Admin Team as well developed and maintained. A solid; candiate for affilliation. Development Projects; ====================. .. _solve-dl:. Solver data layer integration; -----------------------------. :tag: sol",MatchSource.DOCS,doc/development/roadmap.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst:10994,Testability,log,logging,10994," wrapper for multi-variable optimisation functions. For instance those in; `scipy.optimize` (Nelder-Mead, BFGS), but also others, such as Bayesian; optimisation and other machine learning based approaches. Initially just; providing a common interface for quantum control optimisation, but applicable; more generally. .. _sympsi-mig:. Sympsi migration; ----------------. :tag: sympsi-mig; :status: conceptualised; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. Create a new family package qutip-symbolic from ajgpitch fork of Sympy. Must; gain permission from Robert Johansson and Eunjong Kim. Extended Sympy simplify; to respect non-commuting operators. Produce user documentation. .. _status-mig:. Status messaging and recording; ------------------------------. :tag: status-msg; :status: conceptualised; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. QuTiP has various ways of recording and reporting status and progress. - `ProgressBar` used by some solvers; - Python logging used in qutip.control; - `Dump` used in qutip.control; - heom records `solver.Stats`. Some consolidation of these would be good. Some processes (some solvers, correlation, control optimisation) have many; stages and many layers. `Dump` was initially developed to help with debugging,; but it is also useful for recording data for analysis. qutip.logging_utils has; been criticised for the way it uses Python logging. The output goes to stderr; and hence the output looks like errors in Jupyter notebooks. Clearly, storing process stage data is costly in terms of memory and cpu time,; so any implementation must be able to be optionally switched on/off, and avoided; completely in low-level processes (cythonized components). Required features:. - optional recording (storing) of process stage data (states, operators etc); - optionally write subsets to stdout; - maybe other graphical representations; - option to save subsets to file; - should ideally replace use of `ProgressB",MatchSource.DOCS,doc/development/roadmap.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst:11410,Testability,log,logging,11410,"ptualised; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. Create a new family package qutip-symbolic from ajgpitch fork of Sympy. Must; gain permission from Robert Johansson and Eunjong Kim. Extended Sympy simplify; to respect non-commuting operators. Produce user documentation. .. _status-mig:. Status messaging and recording; ------------------------------. :tag: status-msg; :status: conceptualised; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. QuTiP has various ways of recording and reporting status and progress. - `ProgressBar` used by some solvers; - Python logging used in qutip.control; - `Dump` used in qutip.control; - heom records `solver.Stats`. Some consolidation of these would be good. Some processes (some solvers, correlation, control optimisation) have many; stages and many layers. `Dump` was initially developed to help with debugging,; but it is also useful for recording data for analysis. qutip.logging_utils has; been criticised for the way it uses Python logging. The output goes to stderr; and hence the output looks like errors in Jupyter notebooks. Clearly, storing process stage data is costly in terms of memory and cpu time,; so any implementation must be able to be optionally switched on/off, and avoided; completely in low-level processes (cythonized components). Required features:. - optional recording (storing) of process stage data (states, operators etc); - optionally write subsets to stdout; - maybe other graphical representations; - option to save subsets to file; - should ideally replace use of `ProgressBar`, Python logging, `control.Dump`, `solver.Stats`. .. _qutip-gui:. qutip Interactive; -----------------. :status: conceptualised; :tag: qutip-gui; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. QuTiP is pretty simple to use at an entry level for anyone with basic Python; skills. However, *some* Python skills are necessary. A graphical user interface; (GUI) for some parts of qu",MatchSource.DOCS,doc/development/roadmap.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst:11993,Testability,log,logging,11993,"iP has various ways of recording and reporting status and progress. - `ProgressBar` used by some solvers; - Python logging used in qutip.control; - `Dump` used in qutip.control; - heom records `solver.Stats`. Some consolidation of these would be good. Some processes (some solvers, correlation, control optimisation) have many; stages and many layers. `Dump` was initially developed to help with debugging,; but it is also useful for recording data for analysis. qutip.logging_utils has; been criticised for the way it uses Python logging. The output goes to stderr; and hence the output looks like errors in Jupyter notebooks. Clearly, storing process stage data is costly in terms of memory and cpu time,; so any implementation must be able to be optionally switched on/off, and avoided; completely in low-level processes (cythonized components). Required features:. - optional recording (storing) of process stage data (states, operators etc); - optionally write subsets to stdout; - maybe other graphical representations; - option to save subsets to file; - should ideally replace use of `ProgressBar`, Python logging, `control.Dump`, `solver.Stats`. .. _qutip-gui:. qutip Interactive; -----------------. :status: conceptualised; :tag: qutip-gui; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. QuTiP is pretty simple to use at an entry level for anyone with basic Python; skills. However, *some* Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners. This would make an good GSoC project. It is independent and the scope is; flexible. The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere; ^^^^^^^^^^^^^^^^^^^^^^^^. Matplotlib has some interactive features (sliders, radio buttons, cmd buttons); that can be used to control parameters. They are a bit clunky to use, but they; ",MatchSource.DOCS,doc/development/roadmap.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst:16547,Testability,test,test,16547,"moved to the qutip/qutip; repo. This is more typical for an OSS package. As part of the move, the plan is to reconstruct the Sphinx structure from; scratch. Historically, there have been many issues with building the docs.; Sphinx has come a long way since qutip docs first developed. The main source; (rst) files will remain [pretty much] as they are, although there is a lot of; scope to improve them. The qutip-doc repo will afterwards just be used for documents, such as this one,; pertaining to the QuTiP project. .. _qip-mig:. QIP migration; -------------. :tag: qip-mig; :status: completed; :admin lead: `Boxi <https://github.com/BoxiLi>`_; :main dev: `Sidhant Saraogi <https://github.com/sarsid>`_. A separate package for qutip-qip was created during Sidhant's GSoC project.; There is some fine tuning required, especially after qutip.control is migrated. .. _heom-revamp:. HEOM revamp; -----------. :tag: heom-revamp; :status: completed; :admin lead: `Neill <https://github.com/nwlambert>`_; :main dev: `Simon Cross <https://github.com/hodgestar>`_, `Tarun Raheja <https://github.com/tehruhn>`_. An overhaul of the HEOM solver, to incorporate the improvements pioneered in BoFiN. .. _release roadmap:. QuTiP major release roadmap; ===========================. QuTiP v.5; ---------. These Projects need to be completed for the qutip v.5 release. - :ref:`dl-abs` (completed); - :ref:`qmain-reorg` (completed); - :ref:`qmain-docs` (completed); - :ref:`solve-dl` (in-progress); - :ref:`qip-mig` (completed); - :ref:`qtrl-mig`; - :ref:`heom-revamp` (completed). The planned timeline for the release is:. - **alpha version, December 2022**. Core features packaged and available for; experienced users to test.; - **beta version, January 2023**. All required features and documentation complete,; packaged and ready for community testing.; - **full release, April 2023**. Full tested version released. Planned supported environment:. - python 3.8 .. 3.11; - numpy 1.20 .. 1.23; - scipy 1.5 .. 1.8; ",MatchSource.DOCS,doc/development/roadmap.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst:16672,Testability,test,testing,16672,"moved to the qutip/qutip; repo. This is more typical for an OSS package. As part of the move, the plan is to reconstruct the Sphinx structure from; scratch. Historically, there have been many issues with building the docs.; Sphinx has come a long way since qutip docs first developed. The main source; (rst) files will remain [pretty much] as they are, although there is a lot of; scope to improve them. The qutip-doc repo will afterwards just be used for documents, such as this one,; pertaining to the QuTiP project. .. _qip-mig:. QIP migration; -------------. :tag: qip-mig; :status: completed; :admin lead: `Boxi <https://github.com/BoxiLi>`_; :main dev: `Sidhant Saraogi <https://github.com/sarsid>`_. A separate package for qutip-qip was created during Sidhant's GSoC project.; There is some fine tuning required, especially after qutip.control is migrated. .. _heom-revamp:. HEOM revamp; -----------. :tag: heom-revamp; :status: completed; :admin lead: `Neill <https://github.com/nwlambert>`_; :main dev: `Simon Cross <https://github.com/hodgestar>`_, `Tarun Raheja <https://github.com/tehruhn>`_. An overhaul of the HEOM solver, to incorporate the improvements pioneered in BoFiN. .. _release roadmap:. QuTiP major release roadmap; ===========================. QuTiP v.5; ---------. These Projects need to be completed for the qutip v.5 release. - :ref:`dl-abs` (completed); - :ref:`qmain-reorg` (completed); - :ref:`qmain-docs` (completed); - :ref:`solve-dl` (in-progress); - :ref:`qip-mig` (completed); - :ref:`qtrl-mig`; - :ref:`heom-revamp` (completed). The planned timeline for the release is:. - **alpha version, December 2022**. Core features packaged and available for; experienced users to test.; - **beta version, January 2023**. All required features and documentation complete,; packaged and ready for community testing.; - **full release, April 2023**. Full tested version released. Planned supported environment:. - python 3.8 .. 3.11; - numpy 1.20 .. 1.23; - scipy 1.5 .. 1.8; ",MatchSource.DOCS,doc/development/roadmap.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst:16719,Testability,test,tested,16719,"moved to the qutip/qutip; repo. This is more typical for an OSS package. As part of the move, the plan is to reconstruct the Sphinx structure from; scratch. Historically, there have been many issues with building the docs.; Sphinx has come a long way since qutip docs first developed. The main source; (rst) files will remain [pretty much] as they are, although there is a lot of; scope to improve them. The qutip-doc repo will afterwards just be used for documents, such as this one,; pertaining to the QuTiP project. .. _qip-mig:. QIP migration; -------------. :tag: qip-mig; :status: completed; :admin lead: `Boxi <https://github.com/BoxiLi>`_; :main dev: `Sidhant Saraogi <https://github.com/sarsid>`_. A separate package for qutip-qip was created during Sidhant's GSoC project.; There is some fine tuning required, especially after qutip.control is migrated. .. _heom-revamp:. HEOM revamp; -----------. :tag: heom-revamp; :status: completed; :admin lead: `Neill <https://github.com/nwlambert>`_; :main dev: `Simon Cross <https://github.com/hodgestar>`_, `Tarun Raheja <https://github.com/tehruhn>`_. An overhaul of the HEOM solver, to incorporate the improvements pioneered in BoFiN. .. _release roadmap:. QuTiP major release roadmap; ===========================. QuTiP v.5; ---------. These Projects need to be completed for the qutip v.5 release. - :ref:`dl-abs` (completed); - :ref:`qmain-reorg` (completed); - :ref:`qmain-docs` (completed); - :ref:`solve-dl` (in-progress); - :ref:`qip-mig` (completed); - :ref:`qtrl-mig`; - :ref:`heom-revamp` (completed). The planned timeline for the release is:. - **alpha version, December 2022**. Core features packaged and available for; experienced users to test.; - **beta version, January 2023**. All required features and documentation complete,; packaged and ready for community testing.; - **full release, April 2023**. Full tested version released. Planned supported environment:. - python 3.8 .. 3.11; - numpy 1.20 .. 1.23; - scipy 1.5 .. 1.8; ",MatchSource.DOCS,doc/development/roadmap.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst:7267,Usability,simpl,simplifcation,7267,"The QIP subpackage has been deemed out of scope (feature-wise). It also depends; on `qutip.control` and hence would be out of scope for dependency reasons. A; separate repository has already been made for qutip-qip. qutip-symbolic; ^^^^^^^^^^^^^^. * **current package status**: independent package `sympsi`; * **planned package status**: family package `qutip-symbolic`. Long ago Robert Johansson and Eunjong Kim developed Sympsi. It is a fairly; coomplete library for quantum computer algebra (symbolic computation). It is; primarily a quantum wrapper for `Sympy <https://www.sympy.org>`_. It has fallen into unmaintained status. The latest version on the `sympsi repo; <https://github.com/sympsi/sympsi>`_ does not work with recent versions of; Sympy. Alex Pitchford has a `fork <https://github.com/ajgpitch/sympsi>`_ that; does 'work' with recent Sympy versions -- unit tests pass, and most examples; work. However, some (important) examples fail, due to lack of respect for; non-commuting operators in Sympy simplifcation functions (note this was true as; of Nov 2019, may be fixed now). There is a [not discussed with RJ & EK] plan to move this into the QuTiP family; to allow the Admin Team to maintain, develop and promote it. The 'Sympsi' name; is cute, but a little abstract, and qutip-symbolic is proposed as an; alternative, as it is plainer and more distinct from Sympy. Affilliated packages; --------------------. qucontrol-krotov; ^^^^^^^^^^^^^^^^. * **code repository**: https://github.com/qucontrol/krotov. A package for quantum control optimisation using Krotov, developed mainly by; Michael Goerz. Generally accepted by the Admin Team as well developed and maintained. A solid; candiate for affilliation. Development Projects; ====================. .. _solve-dl:. Solver data layer integration; -----------------------------. :tag: solve-dl; :status: development ongoing; :admin lead: `Eric <https://github.com/Ericgig>`_; :main dev: `Eric <https://github.com/Ericgig>`_. The new da",MatchSource.DOCS,doc/development/roadmap.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst:10160,Usability,learn,learning,10160,"_; :main dev: TBA. Create new package qutip-ctrlfw ""QuTiP Control Framework"". The aim is provide a; common framework that can be adopted by control optimisation packages, such that; different packages (algorithms) can be applied to the same problem. Classes for defining a controlled system:. - named control parameters. Scalar and n-dim. Continuous and discrete variables; - mapping of control parameters to dynamics generator args; - masking for control parameters to be optimised. Classes for time-dependent variable parameterisation. - piecewise constant; - piecewise linear; - Fourier basis; - more. Classes for defining an optimisation problem:. - single and multiple objectives. .. _qutip-optim:. QuTiP optimisation; ------------------. :tag: qutip-optim; :status: conceptualised; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. A wrapper for multi-variable optimisation functions. For instance those in; `scipy.optimize` (Nelder-Mead, BFGS), but also others, such as Bayesian; optimisation and other machine learning based approaches. Initially just; providing a common interface for quantum control optimisation, but applicable; more generally. .. _sympsi-mig:. Sympsi migration; ----------------. :tag: sympsi-mig; :status: conceptualised; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. Create a new family package qutip-symbolic from ajgpitch fork of Sympy. Must; gain permission from Robert Johansson and Eunjong Kim. Extended Sympy simplify; to respect non-commuting operators. Produce user documentation. .. _status-mig:. Status messaging and recording; ------------------------------. :tag: status-msg; :status: conceptualised; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. QuTiP has various ways of recording and reporting status and progress. - `ProgressBar` used by some solvers; - Python logging used in qutip.control; - `Dump` used in qutip.control; - heom records `solver.Stats`. Some consolidation of these would be ",MatchSource.DOCS,doc/development/roadmap.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst:10610,Usability,simpl,simplify,10610,"-dependent variable parameterisation. - piecewise constant; - piecewise linear; - Fourier basis; - more. Classes for defining an optimisation problem:. - single and multiple objectives. .. _qutip-optim:. QuTiP optimisation; ------------------. :tag: qutip-optim; :status: conceptualised; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. A wrapper for multi-variable optimisation functions. For instance those in; `scipy.optimize` (Nelder-Mead, BFGS), but also others, such as Bayesian; optimisation and other machine learning based approaches. Initially just; providing a common interface for quantum control optimisation, but applicable; more generally. .. _sympsi-mig:. Sympsi migration; ----------------. :tag: sympsi-mig; :status: conceptualised; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. Create a new family package qutip-symbolic from ajgpitch fork of Sympy. Must; gain permission from Robert Johansson and Eunjong Kim. Extended Sympy simplify; to respect non-commuting operators. Produce user documentation. .. _status-mig:. Status messaging and recording; ------------------------------. :tag: status-msg; :status: conceptualised; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. QuTiP has various ways of recording and reporting status and progress. - `ProgressBar` used by some solvers; - Python logging used in qutip.control; - `Dump` used in qutip.control; - heom records `solver.Stats`. Some consolidation of these would be good. Some processes (some solvers, correlation, control optimisation) have many; stages and many layers. `Dump` was initially developed to help with debugging,; but it is also useful for recording data for analysis. qutip.logging_utils has; been criticised for the way it uses Python logging. The output goes to stderr; and hence the output looks like errors in Jupyter notebooks. Clearly, storing process stage data is costly in terms of memory and cpu time,; so any implementation must be able to ",MatchSource.DOCS,doc/development/roadmap.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst:12214,Usability,simpl,simple,12214,"s initially developed to help with debugging,; but it is also useful for recording data for analysis. qutip.logging_utils has; been criticised for the way it uses Python logging. The output goes to stderr; and hence the output looks like errors in Jupyter notebooks. Clearly, storing process stage data is costly in terms of memory and cpu time,; so any implementation must be able to be optionally switched on/off, and avoided; completely in low-level processes (cythonized components). Required features:. - optional recording (storing) of process stage data (states, operators etc); - optionally write subsets to stdout; - maybe other graphical representations; - option to save subsets to file; - should ideally replace use of `ProgressBar`, Python logging, `control.Dump`, `solver.Stats`. .. _qutip-gui:. qutip Interactive; -----------------. :status: conceptualised; :tag: qutip-gui; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. QuTiP is pretty simple to use at an entry level for anyone with basic Python; skills. However, *some* Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners. This would make an good GSoC project. It is independent and the scope is; flexible. The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere; ^^^^^^^^^^^^^^^^^^^^^^^^. Matplotlib has some interactive features (sliders, radio buttons, cmd buttons); that can be used to control parameters. They are a bit clunky to use, but they; are there. Could maybe avoid these and develop our own GUI. An interactive Bloch; sphere could have sliders for qubit state angles. Buttons to add states, toggle; state evolution path. Interactive solvers; ^^^^^^^^^^^^^^^^^^^. Options to configure dynamics generators (Lindbladian / Hamiltonian args etc); and expectation operators. Then run solver and view sta",MatchSource.DOCS,doc/development/roadmap.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst:12493,Usability,learn,learners,12493,"put looks like errors in Jupyter notebooks. Clearly, storing process stage data is costly in terms of memory and cpu time,; so any implementation must be able to be optionally switched on/off, and avoided; completely in low-level processes (cythonized components). Required features:. - optional recording (storing) of process stage data (states, operators etc); - optionally write subsets to stdout; - maybe other graphical representations; - option to save subsets to file; - should ideally replace use of `ProgressBar`, Python logging, `control.Dump`, `solver.Stats`. .. _qutip-gui:. qutip Interactive; -----------------. :status: conceptualised; :tag: qutip-gui; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. QuTiP is pretty simple to use at an entry level for anyone with basic Python; skills. However, *some* Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners. This would make an good GSoC project. It is independent and the scope is; flexible. The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere; ^^^^^^^^^^^^^^^^^^^^^^^^. Matplotlib has some interactive features (sliders, radio buttons, cmd buttons); that can be used to control parameters. They are a bit clunky to use, but they; are there. Could maybe avoid these and develop our own GUI. An interactive Bloch; sphere could have sliders for qubit state angles. Buttons to add states, toggle; state evolution path. Interactive solvers; ^^^^^^^^^^^^^^^^^^^. Options to configure dynamics generators (Lindbladian / Hamiltonian args etc); and expectation operators. Then run solver and view state evolution. Animated circuits; ^^^^^^^^^^^^^^^^^. QIP circuits could be animated. Status lights showing evolution of states during; the processing. Animated Bloch spheres for qubits. Completed Development Projects; =======",MatchSource.DOCS,doc/development/roadmap.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-basics.rst:383,Availability,avail,available,383,".. _basics:. ***********************************; Basic Operations on Quantum Objects; ***********************************. .. _basics-first:. First things first; ==================. .. warning:: Do not run QuTiP from the installation directory. To load the qutip modules, first call the import statement:. .. code-block:: Python. from qutip import *. This will load all of the user available functions. Often, we also need to import the NumPy and Matplotlib libraries with:. .. code-block:: Python. import numpy as np. import matplotlib.pyplot as plt. In the rest of the documentation, functions are written using `qutip.module.function()` notation which links to the corresponding function in the QuTiP API: :ref:`functions`. However, in calling `import *`, we have already loaded all of the QuTiP modules. Therefore, we will only need the function name and not the complete path when calling the function from the interpreter prompt, Python script, or Jupyter notebook. .. _basics-qobj:. The quantum object class; ========================. .. _basics-qobj-intro:. Introduction; ---------------. The key difference between classical and quantum mechanics is the use of operators instead of numbers as variables. Moreover, we need to specify state vectors and their properties. Therefore, in computing the dynamics of quantum systems, we need a data structure that encapsulates the properties of a quantum operator and ket/bra vectors. The quantum object class, :func:`qutip.Qobj`, accomplishes this using matrix representation. To begin, let us create a blank ``Qobj``:. .. testcode:: [basics]. print(Qobj()). **Output**:. .. testoutput:: [basics]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[1], [1]], shape = (1, 1), type = bra; Qobj data =; [[0.]]. where we see the blank ``Qobj`` object with dimensions, shape, and data. Here the data corresponds to a 1x1-dimensional matrix consisting of a single zero entry. .. Hint:: By convention, the names of Python classes, such as ``Qobj()`",MatchSource.DOCS,doc/guide/guide-basics.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-basics.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-basics.rst:13254,Availability,avail,available,13254,"----+; | Shape | ``Q.shape`` | Dimensions of underlying data matrix. |; +---------------+---------------+----------------------------------------+; | is Hermitian? | ``Q.isherm`` | Is the operator Hermitian or not? |; +---------------+---------------+----------------------------------------+; | Type | ``Q.type`` | Is object of type 'ket, 'bra', |; | | | 'oper', or 'super'? |; +---------------+---------------+----------------------------------------+. .. figure:: quide-basics-qobj-box.png; :align: center; :width: 3.5in. The ``Qobj`` Class viewed as a container for the properties needed to characterize a quantum operator or state vector. For the destruction operator above:. .. doctest:: [basics]; :options: +NORMALIZE_WHITESPACE. >>> q.type; 'oper'. >>> q.isherm; False. >>> q.data; Dia(shape=(4, 4), num_diag=1). The ``data`` attribute returns a Qutip diagonal matrix.; ``Qobj`` instances store their data in Qutip matrix format.; In the core qutip module, the ``Dense``, ``CSR`` and ``Dia`` formats are available, but other packages can add other formats.; For example, the ``qutip-jax`` module adds the ``Jax`` and ``JaxDia`` formats.; One can always access the underlying matrix as a numpy array using :meth:`.Qobj.full`.; It is also possible to access the underlying data in a common format using :meth:`.Qobj.data_as`. .. doctest:: [basics]; :options: +NORMALIZE_WHITESPACE. >>> q.data_as(""dia_matrix""); <4x4 sparse matrix of type '<class 'numpy.complex128'>'; with 3 stored elements (1 diagonals) in DIAgonal format>. Conversion between storage type is done using the :meth:`.Qobj.to` method. .. doctest:: [basics]; :options: +NORMALIZE_WHITESPACE. >>> q.to(""CSR"").data; CSR(shape=(4, 4), nnz=3). >>> q.to(""CSR"").data_as(""csr_matrix""); <4x4 sparse matrix of type '<class 'numpy.complex128'>'; with 3 stored elements in Compressed Sparse Row format>. Note that :meth:`.Qobj.data_as` does not do the conversion. QuTiP will do conversion when needed to keep everything working in any format",MatchSource.DOCS,doc/guide/guide-basics.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-basics.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-basics.rst:14283,Availability,down,down,14283,".; For example, the ``qutip-jax`` module adds the ``Jax`` and ``JaxDia`` formats.; One can always access the underlying matrix as a numpy array using :meth:`.Qobj.full`.; It is also possible to access the underlying data in a common format using :meth:`.Qobj.data_as`. .. doctest:: [basics]; :options: +NORMALIZE_WHITESPACE. >>> q.data_as(""dia_matrix""); <4x4 sparse matrix of type '<class 'numpy.complex128'>'; with 3 stored elements (1 diagonals) in DIAgonal format>. Conversion between storage type is done using the :meth:`.Qobj.to` method. .. doctest:: [basics]; :options: +NORMALIZE_WHITESPACE. >>> q.to(""CSR"").data; CSR(shape=(4, 4), nnz=3). >>> q.to(""CSR"").data_as(""csr_matrix""); <4x4 sparse matrix of type '<class 'numpy.complex128'>'; with 3 stored elements in Compressed Sparse Row format>. Note that :meth:`.Qobj.data_as` does not do the conversion. QuTiP will do conversion when needed to keep everything working in any format.; However these conversions could slow down computation and it is recommended to keep to one format family where possible.; For example, core QuTiP ``Dense`` and ``CSR`` work well together and binary operations between these formats is efficient.; However binary operations between ``Dense`` and ``Jax`` should be avoided since it is not always clear whether the operation will be executed by Jax (possibly on a GPU if present) or numpy. .. _basics-qobj-math:. Qobj Math; ----------. The rules for mathematical operations on ``Qobj`` instances are similar to standard matrix arithmetic:. .. doctest:: [basics]; :options: +NORMALIZE_WHITESPACE. >>> q = destroy(4). >>> x = sigmax(). >>> q + 5; Quantum object: dims = [[4], [4]], shape = (4, 4), type = oper, isherm = False; Qobj data =; [[5. 1. 0. 0. ]; [0. 5. 1.41421356 0. ]; [0. 0. 5. 1.73205081]; [0. 0. 0. 5. ]]. >>> x * x; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[1. 0.]; [0. 1.]]. >>> q ** 3; Quantum object: dims = [[4], [4]], shape = (4, 4), type = o",MatchSource.DOCS,doc/guide/guide-basics.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-basics.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-basics.rst:15643,Availability,error,error,15643,"e operation will be executed by Jax (possibly on a GPU if present) or numpy. .. _basics-qobj-math:. Qobj Math; ----------. The rules for mathematical operations on ``Qobj`` instances are similar to standard matrix arithmetic:. .. doctest:: [basics]; :options: +NORMALIZE_WHITESPACE. >>> q = destroy(4). >>> x = sigmax(). >>> q + 5; Quantum object: dims = [[4], [4]], shape = (4, 4), type = oper, isherm = False; Qobj data =; [[5. 1. 0. 0. ]; [0. 5. 1.41421356 0. ]; [0. 0. 5. 1.73205081]; [0. 0. 0. 5. ]]. >>> x * x; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[1. 0.]; [0. 1.]]. >>> q ** 3; Quantum object: dims = [[4], [4]], shape = (4, 4), type = oper, isherm = False; Qobj data =; [[0. 0. 0. 2.44948974]; [0. 0. 0. 0. ]; [0. 0. 0. 0. ]; [0. 0. 0. 0. ]]. >>> x / np.sqrt(2); Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[0. 0.70710678]; [0.70710678 0. ]]. Of course, like matrices, multiplying two objects of incompatible shape throws an error:. .. doctest:: [basics]; :options: +SKIP. >>> print(q * x); ------------------------------------------------------------------; TypeError Traceback (most recent call last); <ipython-input-33-0b599f41213e> in <module>; ----> 1 print(q * x). ~/Documents/qutip_dev/qutip/qutip/qobj.py in __mul__(self, other); 553; 554 else:; --> 555 raise TypeError(""Incompatible Qobj shapes""); 556; 557 elif isinstance(other, np.ndarray):. TypeError: Incompatible Qobj shapes. In addition, the logic operators ""is equal"" `==` and ""is not equal"" `!=` are also supported. .. _basics-functions:. Functions operating on Qobj class; =================================. Like attributes, the quantum object class has defined functions (methods) that operate on ``Qobj`` class instances. For a general quantum object ``Q``:. .. cssclass:: table-striped. +-----------------+-------------------------------+----------------------------------------+; | Function | Command | Description ",MatchSource.DOCS,doc/guide/guide-basics.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-basics.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-basics.rst:222,Deployability,install,installation,222,".. _basics:. ***********************************; Basic Operations on Quantum Objects; ***********************************. .. _basics-first:. First things first; ==================. .. warning:: Do not run QuTiP from the installation directory. To load the qutip modules, first call the import statement:. .. code-block:: Python. from qutip import *. This will load all of the user available functions. Often, we also need to import the NumPy and Matplotlib libraries with:. .. code-block:: Python. import numpy as np. import matplotlib.pyplot as plt. In the rest of the documentation, functions are written using `qutip.module.function()` notation which links to the corresponding function in the QuTiP API: :ref:`functions`. However, in calling `import *`, we have already loaded all of the QuTiP modules. Therefore, we will only need the function name and not the complete path when calling the function from the interpreter prompt, Python script, or Jupyter notebook. .. _basics-qobj:. The quantum object class; ========================. .. _basics-qobj-intro:. Introduction; ---------------. The key difference between classical and quantum mechanics is the use of operators instead of numbers as variables. Moreover, we need to specify state vectors and their properties. Therefore, in computing the dynamics of quantum systems, we need a data structure that encapsulates the properties of a quantum operator and ket/bra vectors. The quantum object class, :func:`qutip.Qobj`, accomplishes this using matrix representation. To begin, let us create a blank ``Qobj``:. .. testcode:: [basics]. print(Qobj()). **Output**:. .. testoutput:: [basics]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[1], [1]], shape = (1, 1), type = bra; Qobj data =; [[0.]]. where we see the blank ``Qobj`` object with dimensions, shape, and data. Here the data corresponds to a 1x1-dimensional matrix consisting of a single zero entry. .. Hint:: By convention, the names of Python classes, such as ``Qobj()`",MatchSource.DOCS,doc/guide/guide-basics.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-basics.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-basics.rst:6172,Energy Efficiency,charge,charge,6172,"| | | for requested coherent state |; +--------------------------+----------------------------------+----------------------------------------+; | Coherent density matrix | ``coherent_dm(N,alpha)`` | same as coherent(N,alpha) |; | (outer product) | | |; +--------------------------+----------------------------------+----------------------------------------+; | Thermal density matrix | ``thermal_dm(N,n)`` | n = particle number expectation value |; | (for n particles) | | |; +--------------------------+----------------------------------+----------------------------------------+; | Maximally mixed density | ``maximally_mixed_dm(N)`` | N = number of levels in Hilbert space |; | matrix | | |; +--------------------------+----------------------------------+----------------------------------------+. .. cssclass:: table-striped. +--------------------------+----------------------------+----------------------------------------+; | Operators | Command (# means optional) | Inputs |; +==========================+============================+========================================+; | Charge operator | ``charge(N,M=-N)`` | Diagonal operator with entries |; | | | from M..0..N. |; +--------------------------+----------------------------+----------------------------------------+; | Commutator | ``commutator(A, B, kind)`` | Kind = 'normal' or 'anti'. |; +--------------------------+----------------------------+----------------------------------------+; | Diagonals operator | ``qdiags(N)`` | Quantum object created from arrays of |; | | | diagonals at given offsets. |; +--------------------------+----------------------------+----------------------------------------+; | Displacement operator | ``displace(N,alpha)`` | N=number of levels in Hilbert space, |; | (Single-mode) | | alpha = complex displacement amplitude.|; +--------------------------+----------------------------+----------------------------------------+; | Higher spin operators | ``jmat(j,#s)`` | j = integer or half-integer |; | ",MatchSource.DOCS,doc/guide/guide-basics.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-basics.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-basics.rst:14480,Energy Efficiency,efficient,efficient,14480,"rix as a numpy array using :meth:`.Qobj.full`.; It is also possible to access the underlying data in a common format using :meth:`.Qobj.data_as`. .. doctest:: [basics]; :options: +NORMALIZE_WHITESPACE. >>> q.data_as(""dia_matrix""); <4x4 sparse matrix of type '<class 'numpy.complex128'>'; with 3 stored elements (1 diagonals) in DIAgonal format>. Conversion between storage type is done using the :meth:`.Qobj.to` method. .. doctest:: [basics]; :options: +NORMALIZE_WHITESPACE. >>> q.to(""CSR"").data; CSR(shape=(4, 4), nnz=3). >>> q.to(""CSR"").data_as(""csr_matrix""); <4x4 sparse matrix of type '<class 'numpy.complex128'>'; with 3 stored elements in Compressed Sparse Row format>. Note that :meth:`.Qobj.data_as` does not do the conversion. QuTiP will do conversion when needed to keep everything working in any format.; However these conversions could slow down computation and it is recommended to keep to one format family where possible.; For example, core QuTiP ``Dense`` and ``CSR`` work well together and binary operations between these formats is efficient.; However binary operations between ``Dense`` and ``Jax`` should be avoided since it is not always clear whether the operation will be executed by Jax (possibly on a GPU if present) or numpy. .. _basics-qobj-math:. Qobj Math; ----------. The rules for mathematical operations on ``Qobj`` instances are similar to standard matrix arithmetic:. .. doctest:: [basics]; :options: +NORMALIZE_WHITESPACE. >>> q = destroy(4). >>> x = sigmax(). >>> q + 5; Quantum object: dims = [[4], [4]], shape = (4, 4), type = oper, isherm = False; Qobj data =; [[5. 1. 0. 0. ]; [0. 5. 1.41421356 0. ]; [0. 0. 5. 1.73205081]; [0. 0. 0. 5. ]]. >>> x * x; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[1. 0.]; [0. 1.]]. >>> q ** 3; Quantum object: dims = [[4], [4]], shape = (4, 4), type = oper, isherm = False; Qobj data =; [[0. 0. 0. 2.44948974]; [0. 0. 0. 0. ]; [0. 0. 0. 0. ]; [0. 0. 0. 0. ]]. >>> x / np.sqrt(",MatchSource.DOCS,doc/guide/guide-basics.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-basics.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-basics.rst:1203,Modifiability,variab,variables,1203," first; ==================. .. warning:: Do not run QuTiP from the installation directory. To load the qutip modules, first call the import statement:. .. code-block:: Python. from qutip import *. This will load all of the user available functions. Often, we also need to import the NumPy and Matplotlib libraries with:. .. code-block:: Python. import numpy as np. import matplotlib.pyplot as plt. In the rest of the documentation, functions are written using `qutip.module.function()` notation which links to the corresponding function in the QuTiP API: :ref:`functions`. However, in calling `import *`, we have already loaded all of the QuTiP modules. Therefore, we will only need the function name and not the complete path when calling the function from the interpreter prompt, Python script, or Jupyter notebook. .. _basics-qobj:. The quantum object class; ========================. .. _basics-qobj-intro:. Introduction; ---------------. The key difference between classical and quantum mechanics is the use of operators instead of numbers as variables. Moreover, we need to specify state vectors and their properties. Therefore, in computing the dynamics of quantum systems, we need a data structure that encapsulates the properties of a quantum operator and ket/bra vectors. The quantum object class, :func:`qutip.Qobj`, accomplishes this using matrix representation. To begin, let us create a blank ``Qobj``:. .. testcode:: [basics]. print(Qobj()). **Output**:. .. testoutput:: [basics]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[1], [1]], shape = (1, 1), type = bra; Qobj data =; [[0.]]. where we see the blank ``Qobj`` object with dimensions, shape, and data. Here the data corresponds to a 1x1-dimensional matrix consisting of a single zero entry. .. Hint:: By convention, the names of Python classes, such as ``Qobj()``, are capitalized whereas the names of functions are not. We can create a ``Qobj`` with a user defined data set by passing a list or array of data into t",MatchSource.DOCS,doc/guide/guide-basics.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-basics.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-basics.rst:249,Performance,load,load,249,".. _basics:. ***********************************; Basic Operations on Quantum Objects; ***********************************. .. _basics-first:. First things first; ==================. .. warning:: Do not run QuTiP from the installation directory. To load the qutip modules, first call the import statement:. .. code-block:: Python. from qutip import *. This will load all of the user available functions. Often, we also need to import the NumPy and Matplotlib libraries with:. .. code-block:: Python. import numpy as np. import matplotlib.pyplot as plt. In the rest of the documentation, functions are written using `qutip.module.function()` notation which links to the corresponding function in the QuTiP API: :ref:`functions`. However, in calling `import *`, we have already loaded all of the QuTiP modules. Therefore, we will only need the function name and not the complete path when calling the function from the interpreter prompt, Python script, or Jupyter notebook. .. _basics-qobj:. The quantum object class; ========================. .. _basics-qobj-intro:. Introduction; ---------------. The key difference between classical and quantum mechanics is the use of operators instead of numbers as variables. Moreover, we need to specify state vectors and their properties. Therefore, in computing the dynamics of quantum systems, we need a data structure that encapsulates the properties of a quantum operator and ket/bra vectors. The quantum object class, :func:`qutip.Qobj`, accomplishes this using matrix representation. To begin, let us create a blank ``Qobj``:. .. testcode:: [basics]. print(Qobj()). **Output**:. .. testoutput:: [basics]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[1], [1]], shape = (1, 1), type = bra; Qobj data =; [[0.]]. where we see the blank ``Qobj`` object with dimensions, shape, and data. Here the data corresponds to a 1x1-dimensional matrix consisting of a single zero entry. .. Hint:: By convention, the names of Python classes, such as ``Qobj()`",MatchSource.DOCS,doc/guide/guide-basics.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-basics.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-basics.rst:362,Performance,load,load,362,".. _basics:. ***********************************; Basic Operations on Quantum Objects; ***********************************. .. _basics-first:. First things first; ==================. .. warning:: Do not run QuTiP from the installation directory. To load the qutip modules, first call the import statement:. .. code-block:: Python. from qutip import *. This will load all of the user available functions. Often, we also need to import the NumPy and Matplotlib libraries with:. .. code-block:: Python. import numpy as np. import matplotlib.pyplot as plt. In the rest of the documentation, functions are written using `qutip.module.function()` notation which links to the corresponding function in the QuTiP API: :ref:`functions`. However, in calling `import *`, we have already loaded all of the QuTiP modules. Therefore, we will only need the function name and not the complete path when calling the function from the interpreter prompt, Python script, or Jupyter notebook. .. _basics-qobj:. The quantum object class; ========================. .. _basics-qobj-intro:. Introduction; ---------------. The key difference between classical and quantum mechanics is the use of operators instead of numbers as variables. Moreover, we need to specify state vectors and their properties. Therefore, in computing the dynamics of quantum systems, we need a data structure that encapsulates the properties of a quantum operator and ket/bra vectors. The quantum object class, :func:`qutip.Qobj`, accomplishes this using matrix representation. To begin, let us create a blank ``Qobj``:. .. testcode:: [basics]. print(Qobj()). **Output**:. .. testoutput:: [basics]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[1], [1]], shape = (1, 1), type = bra; Qobj data =; [[0.]]. where we see the blank ``Qobj`` object with dimensions, shape, and data. Here the data corresponds to a 1x1-dimensional matrix consisting of a single zero entry. .. Hint:: By convention, the names of Python classes, such as ``Qobj()`",MatchSource.DOCS,doc/guide/guide-basics.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-basics.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-basics.rst:776,Performance,load,loaded,776,".. _basics:. ***********************************; Basic Operations on Quantum Objects; ***********************************. .. _basics-first:. First things first; ==================. .. warning:: Do not run QuTiP from the installation directory. To load the qutip modules, first call the import statement:. .. code-block:: Python. from qutip import *. This will load all of the user available functions. Often, we also need to import the NumPy and Matplotlib libraries with:. .. code-block:: Python. import numpy as np. import matplotlib.pyplot as plt. In the rest of the documentation, functions are written using `qutip.module.function()` notation which links to the corresponding function in the QuTiP API: :ref:`functions`. However, in calling `import *`, we have already loaded all of the QuTiP modules. Therefore, we will only need the function name and not the complete path when calling the function from the interpreter prompt, Python script, or Jupyter notebook. .. _basics-qobj:. The quantum object class; ========================. .. _basics-qobj-intro:. Introduction; ---------------. The key difference between classical and quantum mechanics is the use of operators instead of numbers as variables. Moreover, we need to specify state vectors and their properties. Therefore, in computing the dynamics of quantum systems, we need a data structure that encapsulates the properties of a quantum operator and ket/bra vectors. The quantum object class, :func:`qutip.Qobj`, accomplishes this using matrix representation. To begin, let us create a blank ``Qobj``:. .. testcode:: [basics]. print(Qobj()). **Output**:. .. testoutput:: [basics]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[1], [1]], shape = (1, 1), type = bra; Qobj data =; [[0.]]. where we see the blank ``Qobj`` object with dimensions, shape, and data. Here the data corresponds to a 1x1-dimensional matrix consisting of a single zero entry. .. Hint:: By convention, the names of Python classes, such as ``Qobj()`",MatchSource.DOCS,doc/guide/guide-basics.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-basics.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-basics.rst:14558,Safety,avoid,avoided,14558,": [basics]; :options: +NORMALIZE_WHITESPACE. >>> q.data_as(""dia_matrix""); <4x4 sparse matrix of type '<class 'numpy.complex128'>'; with 3 stored elements (1 diagonals) in DIAgonal format>. Conversion between storage type is done using the :meth:`.Qobj.to` method. .. doctest:: [basics]; :options: +NORMALIZE_WHITESPACE. >>> q.to(""CSR"").data; CSR(shape=(4, 4), nnz=3). >>> q.to(""CSR"").data_as(""csr_matrix""); <4x4 sparse matrix of type '<class 'numpy.complex128'>'; with 3 stored elements in Compressed Sparse Row format>. Note that :meth:`.Qobj.data_as` does not do the conversion. QuTiP will do conversion when needed to keep everything working in any format.; However these conversions could slow down computation and it is recommended to keep to one format family where possible.; For example, core QuTiP ``Dense`` and ``CSR`` work well together and binary operations between these formats is efficient.; However binary operations between ``Dense`` and ``Jax`` should be avoided since it is not always clear whether the operation will be executed by Jax (possibly on a GPU if present) or numpy. .. _basics-qobj-math:. Qobj Math; ----------. The rules for mathematical operations on ``Qobj`` instances are similar to standard matrix arithmetic:. .. doctest:: [basics]; :options: +NORMALIZE_WHITESPACE. >>> q = destroy(4). >>> x = sigmax(). >>> q + 5; Quantum object: dims = [[4], [4]], shape = (4, 4), type = oper, isherm = False; Qobj data =; [[5. 1. 0. 0. ]; [0. 5. 1.41421356 0. ]; [0. 0. 5. 1.73205081]; [0. 0. 0. 5. ]]. >>> x * x; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[1. 0.]; [0. 1.]]. >>> q ** 3; Quantum object: dims = [[4], [4]], shape = (4, 4), type = oper, isherm = False; Qobj data =; [[0. 0. 0. 2.44948974]; [0. 0. 0. 0. ]; [0. 0. 0. 0. ]; [0. 0. 0. 0. ]]. >>> x / np.sqrt(2); Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[0. 0.70710678]; [0.70710678 0. ]]. Of course, like matrices,",MatchSource.DOCS,doc/guide/guide-basics.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-basics.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-basics.rst:11214,Security,access,accessed,11214,"0.]]. >>> coherent(5,0.5-0.5j); Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[ 0.7788017 +0.j ]; [ 0.38939142-0.38939142j]; [ 0. -0.27545895j]; [-0.07898617-0.07898617j]; [-0.04314271+0.j ]]. >>> destroy(4); Quantum object: dims = [[4], [4]], shape = (4, 4), type = oper, isherm = False; Qobj data =; [[0. 1. 0. 0. ]; [0. 0. 1.41421356 0. ]; [0. 0. 0. 1.73205081]; [0. 0. 0. 0. ]]. >>> sigmaz(); Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[ 1. 0.]; [ 0. -1.]]. >>> jmat(5/2.0,'+'); Quantum object: dims = [[6], [6]], shape = (6, 6), type = oper, isherm = False; Qobj data =; [[0. 2.23606798 0. 0. 0. 0. ]; [0. 0. 2.82842712 0. 0. 0. ]; [0. 0. 0. 3. 0. 0. ]; [0. 0. 0. 0. 2.82842712 0. ]; [0. 0. 0. 0. 0. 2.23606798]; [0. 0. 0. 0. 0. 0. ]]. .. _basics-qobj-props:. Qobj attributes; ---------------. We have seen that a quantum object has several internal attributes, such as data, dims, and shape. These can be accessed in the following way:. .. doctest:: [basics]; :options: +NORMALIZE_WHITESPACE. >>> q = destroy(4). >>> q.dims; [[4], [4]]. >>> q.shape; (4, 4). In general, the attributes (properties) of a ``Qobj`` object (or any Python object) can be retrieved using the `Q.attribute` notation.; In addition to the those shown with the ``print`` function, an instance of the ``Qobj`` class also has the following attributes:. .. cssclass:: table-striped. +---------------+---------------+----------------------------------------+; | Property | Attribute | Description |; +===============+===============+========================================+; | Data | ``Q.data`` | Matrix representing state or operator |; +---------------+---------------+----------------------------------------+; | Dimensions | ``Q.dims`` | List keeping track of shapes for |; | | | individual components of a |; | | | multipartite system (for tensor |; | | | products and partial traces). |; +---------------+---------------+-----------------",MatchSource.DOCS,doc/guide/guide-basics.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-basics.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-basics.rst:13403,Security,access,access,13403,"s the operator Hermitian or not? |; +---------------+---------------+----------------------------------------+; | Type | ``Q.type`` | Is object of type 'ket, 'bra', |; | | | 'oper', or 'super'? |; +---------------+---------------+----------------------------------------+. .. figure:: quide-basics-qobj-box.png; :align: center; :width: 3.5in. The ``Qobj`` Class viewed as a container for the properties needed to characterize a quantum operator or state vector. For the destruction operator above:. .. doctest:: [basics]; :options: +NORMALIZE_WHITESPACE. >>> q.type; 'oper'. >>> q.isherm; False. >>> q.data; Dia(shape=(4, 4), num_diag=1). The ``data`` attribute returns a Qutip diagonal matrix.; ``Qobj`` instances store their data in Qutip matrix format.; In the core qutip module, the ``Dense``, ``CSR`` and ``Dia`` formats are available, but other packages can add other formats.; For example, the ``qutip-jax`` module adds the ``Jax`` and ``JaxDia`` formats.; One can always access the underlying matrix as a numpy array using :meth:`.Qobj.full`.; It is also possible to access the underlying data in a common format using :meth:`.Qobj.data_as`. .. doctest:: [basics]; :options: +NORMALIZE_WHITESPACE. >>> q.data_as(""dia_matrix""); <4x4 sparse matrix of type '<class 'numpy.complex128'>'; with 3 stored elements (1 diagonals) in DIAgonal format>. Conversion between storage type is done using the :meth:`.Qobj.to` method. .. doctest:: [basics]; :options: +NORMALIZE_WHITESPACE. >>> q.to(""CSR"").data; CSR(shape=(4, 4), nnz=3). >>> q.to(""CSR"").data_as(""csr_matrix""); <4x4 sparse matrix of type '<class 'numpy.complex128'>'; with 3 stored elements in Compressed Sparse Row format>. Note that :meth:`.Qobj.data_as` does not do the conversion. QuTiP will do conversion when needed to keep everything working in any format.; However these conversions could slow down computation and it is recommended to keep to one format family where possible.; For example, core QuTiP ``Dense`` and ``CSR`` work well t",MatchSource.DOCS,doc/guide/guide-basics.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-basics.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-basics.rst:13499,Security,access,access,13499,"-----------------+; | Type | ``Q.type`` | Is object of type 'ket, 'bra', |; | | | 'oper', or 'super'? |; +---------------+---------------+----------------------------------------+. .. figure:: quide-basics-qobj-box.png; :align: center; :width: 3.5in. The ``Qobj`` Class viewed as a container for the properties needed to characterize a quantum operator or state vector. For the destruction operator above:. .. doctest:: [basics]; :options: +NORMALIZE_WHITESPACE. >>> q.type; 'oper'. >>> q.isherm; False. >>> q.data; Dia(shape=(4, 4), num_diag=1). The ``data`` attribute returns a Qutip diagonal matrix.; ``Qobj`` instances store their data in Qutip matrix format.; In the core qutip module, the ``Dense``, ``CSR`` and ``Dia`` formats are available, but other packages can add other formats.; For example, the ``qutip-jax`` module adds the ``Jax`` and ``JaxDia`` formats.; One can always access the underlying matrix as a numpy array using :meth:`.Qobj.full`.; It is also possible to access the underlying data in a common format using :meth:`.Qobj.data_as`. .. doctest:: [basics]; :options: +NORMALIZE_WHITESPACE. >>> q.data_as(""dia_matrix""); <4x4 sparse matrix of type '<class 'numpy.complex128'>'; with 3 stored elements (1 diagonals) in DIAgonal format>. Conversion between storage type is done using the :meth:`.Qobj.to` method. .. doctest:: [basics]; :options: +NORMALIZE_WHITESPACE. >>> q.to(""CSR"").data; CSR(shape=(4, 4), nnz=3). >>> q.to(""CSR"").data_as(""csr_matrix""); <4x4 sparse matrix of type '<class 'numpy.complex128'>'; with 3 stored elements in Compressed Sparse Row format>. Note that :meth:`.Qobj.data_as` does not do the conversion. QuTiP will do conversion when needed to keep everything working in any format.; However these conversions could slow down computation and it is recommended to keep to one format family where possible.; For example, core QuTiP ``Dense`` and ``CSR`` work well together and binary operations between these formats is efficient.; However binary operations",MatchSource.DOCS,doc/guide/guide-basics.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-basics.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-basics.rst:1576,Testability,test,testcode,1576,", functions are written using `qutip.module.function()` notation which links to the corresponding function in the QuTiP API: :ref:`functions`. However, in calling `import *`, we have already loaded all of the QuTiP modules. Therefore, we will only need the function name and not the complete path when calling the function from the interpreter prompt, Python script, or Jupyter notebook. .. _basics-qobj:. The quantum object class; ========================. .. _basics-qobj-intro:. Introduction; ---------------. The key difference between classical and quantum mechanics is the use of operators instead of numbers as variables. Moreover, we need to specify state vectors and their properties. Therefore, in computing the dynamics of quantum systems, we need a data structure that encapsulates the properties of a quantum operator and ket/bra vectors. The quantum object class, :func:`qutip.Qobj`, accomplishes this using matrix representation. To begin, let us create a blank ``Qobj``:. .. testcode:: [basics]. print(Qobj()). **Output**:. .. testoutput:: [basics]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[1], [1]], shape = (1, 1), type = bra; Qobj data =; [[0.]]. where we see the blank ``Qobj`` object with dimensions, shape, and data. Here the data corresponds to a 1x1-dimensional matrix consisting of a single zero entry. .. Hint:: By convention, the names of Python classes, such as ``Qobj()``, are capitalized whereas the names of functions are not. We can create a ``Qobj`` with a user defined data set by passing a list or array of data into the ``Qobj``:. .. testcode:: [basics]. print(Qobj([[1],[2],[3],[4],[5]])). **Output**:. .. testoutput:: [basics]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[1.]; [2.]; [3.]; [4.]; [5.]]. .. testcode:: [basics]. x = np.array([[1, 2, 3, 4, 5]]); print(Qobj(x)). **Output**:. .. testoutput:: [basics]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[1], [5]",MatchSource.DOCS,doc/guide/guide-basics.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-basics.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-basics.rst:1628,Testability,test,testoutput,1628," links to the corresponding function in the QuTiP API: :ref:`functions`. However, in calling `import *`, we have already loaded all of the QuTiP modules. Therefore, we will only need the function name and not the complete path when calling the function from the interpreter prompt, Python script, or Jupyter notebook. .. _basics-qobj:. The quantum object class; ========================. .. _basics-qobj-intro:. Introduction; ---------------. The key difference between classical and quantum mechanics is the use of operators instead of numbers as variables. Moreover, we need to specify state vectors and their properties. Therefore, in computing the dynamics of quantum systems, we need a data structure that encapsulates the properties of a quantum operator and ket/bra vectors. The quantum object class, :func:`qutip.Qobj`, accomplishes this using matrix representation. To begin, let us create a blank ``Qobj``:. .. testcode:: [basics]. print(Qobj()). **Output**:. .. testoutput:: [basics]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[1], [1]], shape = (1, 1), type = bra; Qobj data =; [[0.]]. where we see the blank ``Qobj`` object with dimensions, shape, and data. Here the data corresponds to a 1x1-dimensional matrix consisting of a single zero entry. .. Hint:: By convention, the names of Python classes, such as ``Qobj()``, are capitalized whereas the names of functions are not. We can create a ``Qobj`` with a user defined data set by passing a list or array of data into the ``Qobj``:. .. testcode:: [basics]. print(Qobj([[1],[2],[3],[4],[5]])). **Output**:. .. testoutput:: [basics]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[1.]; [2.]; [3.]; [4.]; [5.]]. .. testcode:: [basics]. x = np.array([[1, 2, 3, 4, 5]]); print(Qobj(x)). **Output**:. .. testoutput:: [basics]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[1], [5]], shape = (1, 5), type = bra; Qobj data =; [[1. 2. 3. 4. 5.]]. .. te",MatchSource.DOCS,doc/guide/guide-basics.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-basics.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-basics.rst:2172,Testability,test,testcode,2172,"instead of numbers as variables. Moreover, we need to specify state vectors and their properties. Therefore, in computing the dynamics of quantum systems, we need a data structure that encapsulates the properties of a quantum operator and ket/bra vectors. The quantum object class, :func:`qutip.Qobj`, accomplishes this using matrix representation. To begin, let us create a blank ``Qobj``:. .. testcode:: [basics]. print(Qobj()). **Output**:. .. testoutput:: [basics]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[1], [1]], shape = (1, 1), type = bra; Qobj data =; [[0.]]. where we see the blank ``Qobj`` object with dimensions, shape, and data. Here the data corresponds to a 1x1-dimensional matrix consisting of a single zero entry. .. Hint:: By convention, the names of Python classes, such as ``Qobj()``, are capitalized whereas the names of functions are not. We can create a ``Qobj`` with a user defined data set by passing a list or array of data into the ``Qobj``:. .. testcode:: [basics]. print(Qobj([[1],[2],[3],[4],[5]])). **Output**:. .. testoutput:: [basics]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[1.]; [2.]; [3.]; [4.]; [5.]]. .. testcode:: [basics]. x = np.array([[1, 2, 3, 4, 5]]); print(Qobj(x)). **Output**:. .. testoutput:: [basics]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[1], [5]], shape = (1, 5), type = bra; Qobj data =; [[1. 2. 3. 4. 5.]]. .. testcode:: [basics]; :hide:. np.random.seed(42). .. testcode:: [basics]. r = np.random.rand(4, 4); print(Qobj(r)). **Output**:. .. testoutput:: [basics]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[4], [4]], shape = (4, 4), type = oper, isherm = False; Qobj data =; [[0.37454012 0.95071431 0.73199394 0.59865848]; [0.15601864 0.15599452 0.05808361 0.86617615]; [0.60111501 0.70807258 0.02058449 0.96990985]; [0.83244264 0.21233911 0.18182497 0.18340451]]. Notice how both the dims and shape change according to the ",MatchSource.DOCS,doc/guide/guide-basics.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-basics.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-basics.rst:2245,Testability,test,testoutput,2245,"rties. Therefore, in computing the dynamics of quantum systems, we need a data structure that encapsulates the properties of a quantum operator and ket/bra vectors. The quantum object class, :func:`qutip.Qobj`, accomplishes this using matrix representation. To begin, let us create a blank ``Qobj``:. .. testcode:: [basics]. print(Qobj()). **Output**:. .. testoutput:: [basics]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[1], [1]], shape = (1, 1), type = bra; Qobj data =; [[0.]]. where we see the blank ``Qobj`` object with dimensions, shape, and data. Here the data corresponds to a 1x1-dimensional matrix consisting of a single zero entry. .. Hint:: By convention, the names of Python classes, such as ``Qobj()``, are capitalized whereas the names of functions are not. We can create a ``Qobj`` with a user defined data set by passing a list or array of data into the ``Qobj``:. .. testcode:: [basics]. print(Qobj([[1],[2],[3],[4],[5]])). **Output**:. .. testoutput:: [basics]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[1.]; [2.]; [3.]; [4.]; [5.]]. .. testcode:: [basics]. x = np.array([[1, 2, 3, 4, 5]]); print(Qobj(x)). **Output**:. .. testoutput:: [basics]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[1], [5]], shape = (1, 5), type = bra; Qobj data =; [[1. 2. 3. 4. 5.]]. .. testcode:: [basics]; :hide:. np.random.seed(42). .. testcode:: [basics]. r = np.random.rand(4, 4); print(Qobj(r)). **Output**:. .. testoutput:: [basics]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[4], [4]], shape = (4, 4), type = oper, isherm = False; Qobj data =; [[0.37454012 0.95071431 0.73199394 0.59865848]; [0.15601864 0.15599452 0.05808361 0.86617615]; [0.60111501 0.70807258 0.02058449 0.96990985]; [0.83244264 0.21233911 0.18182497 0.18340451]]. Notice how both the dims and shape change according to the input data. Although dims and shape appear to be the same,; dims keep track of the shapes ",MatchSource.DOCS,doc/guide/guide-basics.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-basics.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-basics.rst:2412,Testability,test,testcode,2412,"et/bra vectors. The quantum object class, :func:`qutip.Qobj`, accomplishes this using matrix representation. To begin, let us create a blank ``Qobj``:. .. testcode:: [basics]. print(Qobj()). **Output**:. .. testoutput:: [basics]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[1], [1]], shape = (1, 1), type = bra; Qobj data =; [[0.]]. where we see the blank ``Qobj`` object with dimensions, shape, and data. Here the data corresponds to a 1x1-dimensional matrix consisting of a single zero entry. .. Hint:: By convention, the names of Python classes, such as ``Qobj()``, are capitalized whereas the names of functions are not. We can create a ``Qobj`` with a user defined data set by passing a list or array of data into the ``Qobj``:. .. testcode:: [basics]. print(Qobj([[1],[2],[3],[4],[5]])). **Output**:. .. testoutput:: [basics]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[1.]; [2.]; [3.]; [4.]; [5.]]. .. testcode:: [basics]. x = np.array([[1, 2, 3, 4, 5]]); print(Qobj(x)). **Output**:. .. testoutput:: [basics]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[1], [5]], shape = (1, 5), type = bra; Qobj data =; [[1. 2. 3. 4. 5.]]. .. testcode:: [basics]; :hide:. np.random.seed(42). .. testcode:: [basics]. r = np.random.rand(4, 4); print(Qobj(r)). **Output**:. .. testoutput:: [basics]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[4], [4]], shape = (4, 4), type = oper, isherm = False; Qobj data =; [[0.37454012 0.95071431 0.73199394 0.59865848]; [0.15601864 0.15599452 0.05808361 0.86617615]; [0.60111501 0.70807258 0.02058449 0.96990985]; [0.83244264 0.21233911 0.18182497 0.18340451]]. Notice how both the dims and shape change according to the input data. Although dims and shape appear to be the same,; dims keep track of the shapes for individual components of a multipartite system, while shape does not. We refer the reader to the section; :ref:`tensor products and partial traces",MatchSource.DOCS,doc/guide/guide-basics.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-basics.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-basics.rst:2498,Testability,test,testoutput,2498,"ion. To begin, let us create a blank ``Qobj``:. .. testcode:: [basics]. print(Qobj()). **Output**:. .. testoutput:: [basics]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[1], [1]], shape = (1, 1), type = bra; Qobj data =; [[0.]]. where we see the blank ``Qobj`` object with dimensions, shape, and data. Here the data corresponds to a 1x1-dimensional matrix consisting of a single zero entry. .. Hint:: By convention, the names of Python classes, such as ``Qobj()``, are capitalized whereas the names of functions are not. We can create a ``Qobj`` with a user defined data set by passing a list or array of data into the ``Qobj``:. .. testcode:: [basics]. print(Qobj([[1],[2],[3],[4],[5]])). **Output**:. .. testoutput:: [basics]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[1.]; [2.]; [3.]; [4.]; [5.]]. .. testcode:: [basics]. x = np.array([[1, 2, 3, 4, 5]]); print(Qobj(x)). **Output**:. .. testoutput:: [basics]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[1], [5]], shape = (1, 5), type = bra; Qobj data =; [[1. 2. 3. 4. 5.]]. .. testcode:: [basics]; :hide:. np.random.seed(42). .. testcode:: [basics]. r = np.random.rand(4, 4); print(Qobj(r)). **Output**:. .. testoutput:: [basics]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[4], [4]], shape = (4, 4), type = oper, isherm = False; Qobj data =; [[0.37454012 0.95071431 0.73199394 0.59865848]; [0.15601864 0.15599452 0.05808361 0.86617615]; [0.60111501 0.70807258 0.02058449 0.96990985]; [0.83244264 0.21233911 0.18182497 0.18340451]]. Notice how both the dims and shape change according to the input data. Although dims and shape appear to be the same,; dims keep track of the shapes for individual components of a multipartite system, while shape does not. We refer the reader to the section; :ref:`tensor products and partial traces <tensor>` for more information. .. note:: If you are running QuTiP from a python script you must use t",MatchSource.DOCS,doc/guide/guide-basics.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-basics.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-basics.rst:2653,Testability,test,testcode,2653,"ALIZE_WHITESPACE. Quantum object: dims = [[1], [1]], shape = (1, 1), type = bra; Qobj data =; [[0.]]. where we see the blank ``Qobj`` object with dimensions, shape, and data. Here the data corresponds to a 1x1-dimensional matrix consisting of a single zero entry. .. Hint:: By convention, the names of Python classes, such as ``Qobj()``, are capitalized whereas the names of functions are not. We can create a ``Qobj`` with a user defined data set by passing a list or array of data into the ``Qobj``:. .. testcode:: [basics]. print(Qobj([[1],[2],[3],[4],[5]])). **Output**:. .. testoutput:: [basics]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[1.]; [2.]; [3.]; [4.]; [5.]]. .. testcode:: [basics]. x = np.array([[1, 2, 3, 4, 5]]); print(Qobj(x)). **Output**:. .. testoutput:: [basics]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[1], [5]], shape = (1, 5), type = bra; Qobj data =; [[1. 2. 3. 4. 5.]]. .. testcode:: [basics]; :hide:. np.random.seed(42). .. testcode:: [basics]. r = np.random.rand(4, 4); print(Qobj(r)). **Output**:. .. testoutput:: [basics]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[4], [4]], shape = (4, 4), type = oper, isherm = False; Qobj data =; [[0.37454012 0.95071431 0.73199394 0.59865848]; [0.15601864 0.15599452 0.05808361 0.86617615]; [0.60111501 0.70807258 0.02058449 0.96990985]; [0.83244264 0.21233911 0.18182497 0.18340451]]. Notice how both the dims and shape change according to the input data. Although dims and shape appear to be the same,; dims keep track of the shapes for individual components of a multipartite system, while shape does not. We refer the reader to the section; :ref:`tensor products and partial traces <tensor>` for more information. .. note:: If you are running QuTiP from a python script you must use the :func:`print` function to view the Qobj attributes. .. _basics-qobj-states:. States and operators; ---------------------. Manually specifyi",MatchSource.DOCS,doc/guide/guide-basics.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-basics.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-basics.rst:2705,Testability,test,testcode,2705,"1]], shape = (1, 1), type = bra; Qobj data =; [[0.]]. where we see the blank ``Qobj`` object with dimensions, shape, and data. Here the data corresponds to a 1x1-dimensional matrix consisting of a single zero entry. .. Hint:: By convention, the names of Python classes, such as ``Qobj()``, are capitalized whereas the names of functions are not. We can create a ``Qobj`` with a user defined data set by passing a list or array of data into the ``Qobj``:. .. testcode:: [basics]. print(Qobj([[1],[2],[3],[4],[5]])). **Output**:. .. testoutput:: [basics]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[1.]; [2.]; [3.]; [4.]; [5.]]. .. testcode:: [basics]. x = np.array([[1, 2, 3, 4, 5]]); print(Qobj(x)). **Output**:. .. testoutput:: [basics]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[1], [5]], shape = (1, 5), type = bra; Qobj data =; [[1. 2. 3. 4. 5.]]. .. testcode:: [basics]; :hide:. np.random.seed(42). .. testcode:: [basics]. r = np.random.rand(4, 4); print(Qobj(r)). **Output**:. .. testoutput:: [basics]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[4], [4]], shape = (4, 4), type = oper, isherm = False; Qobj data =; [[0.37454012 0.95071431 0.73199394 0.59865848]; [0.15601864 0.15599452 0.05808361 0.86617615]; [0.60111501 0.70807258 0.02058449 0.96990985]; [0.83244264 0.21233911 0.18182497 0.18340451]]. Notice how both the dims and shape change according to the input data. Although dims and shape appear to be the same,; dims keep track of the shapes for individual components of a multipartite system, while shape does not. We refer the reader to the section; :ref:`tensor products and partial traces <tensor>` for more information. .. note:: If you are running QuTiP from a python script you must use the :func:`print` function to view the Qobj attributes. .. _basics-qobj-states:. States and operators; ---------------------. Manually specifying the data for each quantum object is inefficie",MatchSource.DOCS,doc/guide/guide-basics.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-basics.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-basics.rst:2784,Testability,test,testoutput,2784," dimensions, shape, and data. Here the data corresponds to a 1x1-dimensional matrix consisting of a single zero entry. .. Hint:: By convention, the names of Python classes, such as ``Qobj()``, are capitalized whereas the names of functions are not. We can create a ``Qobj`` with a user defined data set by passing a list or array of data into the ``Qobj``:. .. testcode:: [basics]. print(Qobj([[1],[2],[3],[4],[5]])). **Output**:. .. testoutput:: [basics]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[1.]; [2.]; [3.]; [4.]; [5.]]. .. testcode:: [basics]. x = np.array([[1, 2, 3, 4, 5]]); print(Qobj(x)). **Output**:. .. testoutput:: [basics]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[1], [5]], shape = (1, 5), type = bra; Qobj data =; [[1. 2. 3. 4. 5.]]. .. testcode:: [basics]; :hide:. np.random.seed(42). .. testcode:: [basics]. r = np.random.rand(4, 4); print(Qobj(r)). **Output**:. .. testoutput:: [basics]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[4], [4]], shape = (4, 4), type = oper, isherm = False; Qobj data =; [[0.37454012 0.95071431 0.73199394 0.59865848]; [0.15601864 0.15599452 0.05808361 0.86617615]; [0.60111501 0.70807258 0.02058449 0.96990985]; [0.83244264 0.21233911 0.18182497 0.18340451]]. Notice how both the dims and shape change according to the input data. Although dims and shape appear to be the same,; dims keep track of the shapes for individual components of a multipartite system, while shape does not. We refer the reader to the section; :ref:`tensor products and partial traces <tensor>` for more information. .. note:: If you are running QuTiP from a python script you must use the :func:`print` function to view the Qobj attributes. .. _basics-qobj-states:. States and operators; ---------------------. Manually specifying the data for each quantum object is inefficient. Even more so when most objects correspond to commonly used; types such as the; ladder operat",MatchSource.DOCS,doc/guide/guide-basics.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-basics.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-basics.rst:16125,Testability,log,logic,16125,"]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[1. 0.]; [0. 1.]]. >>> q ** 3; Quantum object: dims = [[4], [4]], shape = (4, 4), type = oper, isherm = False; Qobj data =; [[0. 0. 0. 2.44948974]; [0. 0. 0. 0. ]; [0. 0. 0. 0. ]; [0. 0. 0. 0. ]]. >>> x / np.sqrt(2); Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[0. 0.70710678]; [0.70710678 0. ]]. Of course, like matrices, multiplying two objects of incompatible shape throws an error:. .. doctest:: [basics]; :options: +SKIP. >>> print(q * x); ------------------------------------------------------------------; TypeError Traceback (most recent call last); <ipython-input-33-0b599f41213e> in <module>; ----> 1 print(q * x). ~/Documents/qutip_dev/qutip/qutip/qobj.py in __mul__(self, other); 553; 554 else:; --> 555 raise TypeError(""Incompatible Qobj shapes""); 556; 557 elif isinstance(other, np.ndarray):. TypeError: Incompatible Qobj shapes. In addition, the logic operators ""is equal"" `==` and ""is not equal"" `!=` are also supported. .. _basics-functions:. Functions operating on Qobj class; =================================. Like attributes, the quantum object class has defined functions (methods) that operate on ``Qobj`` class instances. For a general quantum object ``Q``:. .. cssclass:: table-striped. +-----------------+-------------------------------+----------------------------------------+; | Function | Command | Description |; +=================+===============================+========================================+; | Check Hermicity | ``Q.check_herm()`` | Check if quantum object is Hermitian |; +-----------------+-------------------------------+----------------------------------------+; | Conjugate | ``Q.conj()`` | Conjugate of quantum object. |; +-----------------+-------------------------------+----------------------------------------+; | Cosine | ``Q.cosm()`` | Cosine of quantum object. |; +-----------------+-------------------------------+----------------",MatchSource.DOCS,doc/guide/guide-basics.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-basics.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-basics.rst:14589,Usability,clear,clear,14589,": [basics]; :options: +NORMALIZE_WHITESPACE. >>> q.data_as(""dia_matrix""); <4x4 sparse matrix of type '<class 'numpy.complex128'>'; with 3 stored elements (1 diagonals) in DIAgonal format>. Conversion between storage type is done using the :meth:`.Qobj.to` method. .. doctest:: [basics]; :options: +NORMALIZE_WHITESPACE. >>> q.to(""CSR"").data; CSR(shape=(4, 4), nnz=3). >>> q.to(""CSR"").data_as(""csr_matrix""); <4x4 sparse matrix of type '<class 'numpy.complex128'>'; with 3 stored elements in Compressed Sparse Row format>. Note that :meth:`.Qobj.data_as` does not do the conversion. QuTiP will do conversion when needed to keep everything working in any format.; However these conversions could slow down computation and it is recommended to keep to one format family where possible.; For example, core QuTiP ``Dense`` and ``CSR`` work well together and binary operations between these formats is efficient.; However binary operations between ``Dense`` and ``Jax`` should be avoided since it is not always clear whether the operation will be executed by Jax (possibly on a GPU if present) or numpy. .. _basics-qobj-math:. Qobj Math; ----------. The rules for mathematical operations on ``Qobj`` instances are similar to standard matrix arithmetic:. .. doctest:: [basics]; :options: +NORMALIZE_WHITESPACE. >>> q = destroy(4). >>> x = sigmax(). >>> q + 5; Quantum object: dims = [[4], [4]], shape = (4, 4), type = oper, isherm = False; Qobj data =; [[5. 1. 0. 0. ]; [0. 5. 1.41421356 0. ]; [0. 0. 5. 1.73205081]; [0. 0. 0. 5. ]]. >>> x * x; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[1. 0.]; [0. 1.]]. >>> q ** 3; Quantum object: dims = [[4], [4]], shape = (4, 4), type = oper, isherm = False; Qobj data =; [[0. 0. 0. 2.44948974]; [0. 0. 0. 0. ]; [0. 0. 0. 0. ]; [0. 0. 0. 0. ]]. >>> x / np.sqrt(2); Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[0. 0.70710678]; [0.70710678 0. ]]. Of course, like matrices,",MatchSource.DOCS,doc/guide/guide-basics.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-basics.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-bloch.rst:995,Availability,avail,available,995,".. _bloch:. ******************************; Plotting on the Bloch Sphere; ******************************. .. _bloch-intro:. Introduction; ============. When studying the dynamics of a two-level system, it is often convenient to visualize the state of the system by plotting the state-vector or density matrix on the Bloch sphere. In QuTiP, there is a class to allow for easy creation and manipulation of data sets, both vectors and data points, on the Bloch sphere. .. _bloch-class:. The Bloch Class; ===============. In QuTiP, creating a Bloch sphere is accomplished by calling either:. .. plot::; :context: reset. b = qutip.Bloch(). which will load an instance of the :class:`~qutip.bloch.Bloch` class.; Before getting into the details of these objects, we can simply plot the blank Bloch sphere associated with these instances via:. .. plot::; :context:. b.make_sphere(). In addition to the ``show`` command, see the API documentation for :class:`~qutip.bloch.Bloch` for a full list of other available functions.; As an example, we can add a single data point:. .. plot::; :context: close-figs. pnt = [1/np.sqrt(3), 1/np.sqrt(3), 1/np.sqrt(3)]; b.add_points(pnt); b.render(). and then a single vector:. .. plot::; :context: close-figs. b.fig.clf(); vec = [0, 1, 0]; b.add_vectors(vec); b.render(). and then add another vector corresponding to the :math:`\left|\rm up \right>` state:. .. plot::; :context: close-figs. up = qutip.basis(2, 0); b.add_states(up); b.render(). Notice that when we add more than a single vector (or data point), a different color will automatically be applied to the later data set (mod 4).; In total, the code for constructing our Bloch sphere with one vector, one state, and a single data point is:. .. plot::; :context: close-figs. b = qutip.Bloch(). pnt = [1./np.sqrt(3), 1./np.sqrt(3), 1./np.sqrt(3)]; b.add_points(pnt); vec = [0, 1, 0]; b.add_vectors(vec); up = qutip.basis(2, 0); b.add_states(up); b.render(). where we have removed the extra ``show()`` commands. We",MatchSource.DOCS,doc/guide/guide-bloch.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-bloch.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-bloch.rst:4866,Availability,down,down,4866," np.cos(th); b.add_points([xz, yz, zz]); b.render(). The color and shape of the data points is varied automatically by the Bloch class. Notice how the color and point markers change for each set of data. Again, we have had to call ``add_points`` twice because adding more than one set of multiple data points is *not* supported by the ``add_points`` function. What if we want to vary the color of our points. We can tell the :class:`qutip.bloch.Bloch` class to vary the color of each point according to the colors listed in the ``b.point_color`` list (see :ref:`bloch-config` below). Again after ``clear()``:. .. plot::; :context: close-figs. b.clear(). xp = np.cos(th); yp = np.sin(th); zp = np.zeros(20); pnts = [xp, yp, zp]; b.add_points(pnts, 'm') # <-- add a 'm' string to signify 'multi' colored points; b.render(). Now, the data points cycle through a variety of predefined colors. Now lets add another set of points, but this time we want the set to be a single color, representing say a qubit going from the :math:`\left|\rm up\right>` state to the :math:`\left|\rm down\right>` state in the y-z plane:. .. plot::; :context: close-figs. xz = np.zeros(20); yz = np.sin(th); zz = np.cos(th). b.add_points([xz, yz, zz]) # no 'm'; b.render(). A more slick way of using this 'multi' color feature is also given in the example, where we set the color of the markers as a function of time. .. _bloch-config:. Configuring the Bloch sphere; ============================. Bloch Class Options; --------------------. At the end of the last section we saw that the colors and marker shapes of the data plotted on the Bloch sphere are automatically varied according to the number of points and vectors added. But what if you want a different choice of color, or you want your sphere to be purple with different axes labels? Well then you are in luck as the Bloch class has 22 attributes which one can control. Assuming ``b=Bloch()``:. .. tabularcolumns:: | p{3cm} | p{7cm} | p{7cm} |. .. cssclass:: table-",MatchSource.DOCS,doc/guide/guide-bloch.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-bloch.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-bloch.rst:13145,Deployability,install,installing,13145,"both methods by looking at the decay of a qubit on the bloch sphere. .. _bloch-animate-decay:. Example: Qubit Decay; --------------------. The code for calculating the expectation values for the Pauli spin operators of a qubit decay is given below. This code is common to both animation examples. .. literalinclude:: scripts/ex_bloch_animation.py. .. _bloch-animate-decay-images:. Generating Images for Animation; ++++++++++++++++++++++++++++++++. An example of generating images for generating an animation outside of Python is given below::. import numpy as np; b = qutip.Bloch(); b.vector_color = ['r']; b.view = [-40, 30]; for i in range(len(sx)):; b.clear(); b.add_vectors([np.sin(theta), 0, np.cos(theta)]); b.add_points([sx[:i+1], sy[:i+1], sz[:i+1]]); b.save(dirc='temp') # saving images to temp directory in current working directory. Generating an animation using FFmpeg (for example) is fairly simple::. ffmpeg -i temp/bloch_%01d.png bloch.mp4. .. _bloch-animate-decay-direct:. Directly Generating an Animation; ++++++++++++++++++++++++++++++++. .. important::; Generating animations directly from Matplotlib requires installing either MEncoder or FFmpeg.; While either choice works on linux, it is best to choose FFmpeg when running on the Mac.; If using macports just do: ``sudo port install ffmpeg``. The code to directly generate an mp4 movie of the Qubit decay is as follows ::. from matplotlib import pyplot, animation. fig = pyplot.figure(); ax = fig.add_subplot(azim=-40, elev=30, projection=""3d""); sphere = qutip.Bloch(axes=ax). def animate(i):; sphere.clear(); sphere.add_vectors([np.sin(theta), 0, np.cos(theta)], [""r""]); sphere.add_points([sx[:i+1], sy[:i+1], sz[:i+1]]); sphere.make_sphere(); return ax. ani = animation.FuncAnimation(fig, animate, np.arange(len(sx)), blit=False, repeat=False); ani.save('bloch_sphere.mp4', fps=20). The resulting movie may be viewed here: `bloch_decay.mp4 <https://raw.githubusercontent.com/qutip/qutip/master/doc/figures/bloch_decay.mp4>`_; ",MatchSource.DOCS,doc/guide/guide-bloch.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-bloch.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-bloch.rst:13313,Deployability,install,install,13313,"both methods by looking at the decay of a qubit on the bloch sphere. .. _bloch-animate-decay:. Example: Qubit Decay; --------------------. The code for calculating the expectation values for the Pauli spin operators of a qubit decay is given below. This code is common to both animation examples. .. literalinclude:: scripts/ex_bloch_animation.py. .. _bloch-animate-decay-images:. Generating Images for Animation; ++++++++++++++++++++++++++++++++. An example of generating images for generating an animation outside of Python is given below::. import numpy as np; b = qutip.Bloch(); b.vector_color = ['r']; b.view = [-40, 30]; for i in range(len(sx)):; b.clear(); b.add_vectors([np.sin(theta), 0, np.cos(theta)]); b.add_points([sx[:i+1], sy[:i+1], sz[:i+1]]); b.save(dirc='temp') # saving images to temp directory in current working directory. Generating an animation using FFmpeg (for example) is fairly simple::. ffmpeg -i temp/bloch_%01d.png bloch.mp4. .. _bloch-animate-decay-direct:. Directly Generating an Animation; ++++++++++++++++++++++++++++++++. .. important::; Generating animations directly from Matplotlib requires installing either MEncoder or FFmpeg.; While either choice works on linux, it is best to choose FFmpeg when running on the Mac.; If using macports just do: ``sudo port install ffmpeg``. The code to directly generate an mp4 movie of the Qubit decay is as follows ::. from matplotlib import pyplot, animation. fig = pyplot.figure(); ax = fig.add_subplot(azim=-40, elev=30, projection=""3d""); sphere = qutip.Bloch(axes=ax). def animate(i):; sphere.clear(); sphere.add_vectors([np.sin(theta), 0, np.cos(theta)], [""r""]); sphere.add_points([sx[:i+1], sy[:i+1], sz[:i+1]]); sphere.make_sphere(); return ax. ani = animation.FuncAnimation(fig, animate, np.arange(len(sx)), blit=False, repeat=False); ani.save('bloch_sphere.mp4', fps=20). The resulting movie may be viewed here: `bloch_decay.mp4 <https://raw.githubusercontent.com/qutip/qutip/master/doc/figures/bloch_decay.mp4>`_; ",MatchSource.DOCS,doc/guide/guide-bloch.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-bloch.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-bloch.rst:4359,Modifiability,config,config,4359," multiple data points using the ``add_points`` function is interpreted, by default, to correspond to a single data point (single qubit state) plotted at different times. This is very useful when visualizing the dynamics of a qubit. An example of this is given in the example . If we want to plot additional qubit states we can call additional ``add_points`` functions:. .. plot::; :context: close-figs. xz = np.zeros(20); yz = np.sin(th); zz = np.cos(th); b.add_points([xz, yz, zz]); b.render(). The color and shape of the data points is varied automatically by the Bloch class. Notice how the color and point markers change for each set of data. Again, we have had to call ``add_points`` twice because adding more than one set of multiple data points is *not* supported by the ``add_points`` function. What if we want to vary the color of our points. We can tell the :class:`qutip.bloch.Bloch` class to vary the color of each point according to the colors listed in the ``b.point_color`` list (see :ref:`bloch-config` below). Again after ``clear()``:. .. plot::; :context: close-figs. b.clear(). xp = np.cos(th); yp = np.sin(th); zp = np.zeros(20); pnts = [xp, yp, zp]; b.add_points(pnts, 'm') # <-- add a 'm' string to signify 'multi' colored points; b.render(). Now, the data points cycle through a variety of predefined colors. Now lets add another set of points, but this time we want the set to be a single color, representing say a qubit going from the :math:`\left|\rm up\right>` state to the :math:`\left|\rm down\right>` state in the y-z plane:. .. plot::; :context: close-figs. xz = np.zeros(20); yz = np.sin(th); zz = np.cos(th). b.add_points([xz, yz, zz]) # no 'm'; b.render(). A more slick way of using this 'multi' color feature is also given in the example, where we set the color of the markers as a function of time. .. _bloch-config:. Configuring the Bloch sphere; ============================. Bloch Class Options; --------------------. At the end of the last section we saw that t",MatchSource.DOCS,doc/guide/guide-bloch.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-bloch.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-bloch.rst:5193,Modifiability,config,config,5193,"oints. We can tell the :class:`qutip.bloch.Bloch` class to vary the color of each point according to the colors listed in the ``b.point_color`` list (see :ref:`bloch-config` below). Again after ``clear()``:. .. plot::; :context: close-figs. b.clear(). xp = np.cos(th); yp = np.sin(th); zp = np.zeros(20); pnts = [xp, yp, zp]; b.add_points(pnts, 'm') # <-- add a 'm' string to signify 'multi' colored points; b.render(). Now, the data points cycle through a variety of predefined colors. Now lets add another set of points, but this time we want the set to be a single color, representing say a qubit going from the :math:`\left|\rm up\right>` state to the :math:`\left|\rm down\right>` state in the y-z plane:. .. plot::; :context: close-figs. xz = np.zeros(20); yz = np.sin(th); zz = np.cos(th). b.add_points([xz, yz, zz]) # no 'm'; b.render(). A more slick way of using this 'multi' color feature is also given in the example, where we set the color of the markers as a function of time. .. _bloch-config:. Configuring the Bloch sphere; ============================. Bloch Class Options; --------------------. At the end of the last section we saw that the colors and marker shapes of the data plotted on the Bloch sphere are automatically varied according to the number of points and vectors added. But what if you want a different choice of color, or you want your sphere to be purple with different axes labels? Well then you are in luck as the Bloch class has 22 attributes which one can control. Assuming ``b=Bloch()``:. .. tabularcolumns:: | p{3cm} | p{7cm} | p{7cm} |. .. cssclass:: table-striped. +---------------+---------------------------------------------------------+-------------------------------------------------+; | Attribute | Function | Default Setting |; +===============+=========================================================+=================================================+; | b.axes | Matplotlib axes instance for animations. Set by ``axes``| ``None`` |; | | keyword ar",MatchSource.DOCS,doc/guide/guide-bloch.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-bloch.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-bloch.rst:646,Performance,load,load,646,".. _bloch:. ******************************; Plotting on the Bloch Sphere; ******************************. .. _bloch-intro:. Introduction; ============. When studying the dynamics of a two-level system, it is often convenient to visualize the state of the system by plotting the state-vector or density matrix on the Bloch sphere. In QuTiP, there is a class to allow for easy creation and manipulation of data sets, both vectors and data points, on the Bloch sphere. .. _bloch-class:. The Bloch Class; ===============. In QuTiP, creating a Bloch sphere is accomplished by calling either:. .. plot::; :context: reset. b = qutip.Bloch(). which will load an instance of the :class:`~qutip.bloch.Bloch` class.; Before getting into the details of these objects, we can simply plot the blank Bloch sphere associated with these instances via:. .. plot::; :context:. b.make_sphere(). In addition to the ``show`` command, see the API documentation for :class:`~qutip.bloch.Bloch` for a full list of other available functions.; As an example, we can add a single data point:. .. plot::; :context: close-figs. pnt = [1/np.sqrt(3), 1/np.sqrt(3), 1/np.sqrt(3)]; b.add_points(pnt); b.render(). and then a single vector:. .. plot::; :context: close-figs. b.fig.clf(); vec = [0, 1, 0]; b.add_vectors(vec); b.render(). and then add another vector corresponding to the :math:`\left|\rm up \right>` state:. .. plot::; :context: close-figs. up = qutip.basis(2, 0); b.add_states(up); b.render(). Notice that when we add more than a single vector (or data point), a different color will automatically be applied to the later data set (mod 4).; In total, the code for constructing our Bloch sphere with one vector, one state, and a single data point is:. .. plot::; :context: close-figs. b = qutip.Bloch(). pnt = [1./np.sqrt(3), 1./np.sqrt(3), 1./np.sqrt(3)]; b.add_points(pnt); vec = [0, 1, 0]; b.add_vectors(vec); up = qutip.basis(2, 0); b.add_states(up); b.render(). where we have removed the extra ``show()`` commands. We",MatchSource.DOCS,doc/guide/guide-bloch.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-bloch.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-bloch.rst:10551,Security,access,accessed,10551,"[1.1, -1.1]`` |; +---------------+---------------------------------------------------------+-------------------------------------------------+; | b.ylabel | Labels for y-axis | ``['$y$', '']`` +y and -y (labels use LaTeX) |; +---------------+---------------------------------------------------------+-------------------------------------------------+; | b.ylpos | Position of y-axis labels | ``[1.2, -1.2]`` |; +---------------+---------------------------------------------------------+-------------------------------------------------+; | b.zlabel | Labels for z-axis | ``['$\left|0\right>$', '$\left|1\right>$']`` |; | | | +z and -z (labels use LaTeX) |; +---------------+---------------------------------------------------------+-------------------------------------------------+; | b.zlpos | Position of z-axis labels | ``[1.2, -1.2]`` |; +---------------+---------------------------------------------------------+-------------------------------------------------+. These properties can also be accessed via the print command:. .. doctest::. >>> b = qutip.Bloch(). >>> print(b) # doctest: +NORMALIZE_WHITESPACE; Bloch data:; -----------; Number of points: 0; Number of vectors: 0; <BLANKLINE>; Bloch sphere properties:; ------------------------; font_color: black; font_size: 20; frame_alpha: 0.2; frame_color: gray; frame_width: 1; point_color: ['b', 'r', 'g', '#CC6600']; point_marker: ['o', 's', 'd', '^']; point_size: [25, 32, 35, 45]; sphere_alpha: 0.2; sphere_color: #FFDDDD; figsize: [5, 5]; vector_color: ['g', '#CC6600', 'b', 'r']; vector_width: 3; vector_style: -|>; vector_mutation: 20; view: [-60, 30]; xlabel: ['$x$', '']; xlpos: [1.2, -1.2]; ylabel: ['$y$', '']; ylpos: [1.2, -1.2]; zlabel: ['$\\left|0\\right>$', '$\\left|1\\right>$']; zlpos: [1.2, -1.2]; <BLANKLINE>. .. _bloch-animate:. Animating with the Bloch sphere; ===============================. The Bloch class was designed from the outset to generate animations. To animate a set of vectors or data points the basic idea",MatchSource.DOCS,doc/guide/guide-bloch.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-bloch.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-bloch.rst:763,Usability,simpl,simply,763,".. _bloch:. ******************************; Plotting on the Bloch Sphere; ******************************. .. _bloch-intro:. Introduction; ============. When studying the dynamics of a two-level system, it is often convenient to visualize the state of the system by plotting the state-vector or density matrix on the Bloch sphere. In QuTiP, there is a class to allow for easy creation and manipulation of data sets, both vectors and data points, on the Bloch sphere. .. _bloch-class:. The Bloch Class; ===============. In QuTiP, creating a Bloch sphere is accomplished by calling either:. .. plot::; :context: reset. b = qutip.Bloch(). which will load an instance of the :class:`~qutip.bloch.Bloch` class.; Before getting into the details of these objects, we can simply plot the blank Bloch sphere associated with these instances via:. .. plot::; :context:. b.make_sphere(). In addition to the ``show`` command, see the API documentation for :class:`~qutip.bloch.Bloch` for a full list of other available functions.; As an example, we can add a single data point:. .. plot::; :context: close-figs. pnt = [1/np.sqrt(3), 1/np.sqrt(3), 1/np.sqrt(3)]; b.add_points(pnt); b.render(). and then a single vector:. .. plot::; :context: close-figs. b.fig.clf(); vec = [0, 1, 0]; b.add_vectors(vec); b.render(). and then add another vector corresponding to the :math:`\left|\rm up \right>` state:. .. plot::; :context: close-figs. up = qutip.basis(2, 0); b.add_states(up); b.render(). Notice that when we add more than a single vector (or data point), a different color will automatically be applied to the later data set (mod 4).; In total, the code for constructing our Bloch sphere with one vector, one state, and a single data point is:. .. plot::; :context: close-figs. b = qutip.Bloch(). pnt = [1./np.sqrt(3), 1./np.sqrt(3), 1./np.sqrt(3)]; b.add_points(pnt); vec = [0, 1, 0]; b.add_vectors(vec); up = qutip.basis(2, 0); b.add_states(up); b.render(). where we have removed the extra ``show()`` commands. We",MatchSource.DOCS,doc/guide/guide-bloch.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-bloch.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-bloch.rst:2170,Usability,clear,clear,2170,"ctor:. .. plot::; :context: close-figs. b.fig.clf(); vec = [0, 1, 0]; b.add_vectors(vec); b.render(). and then add another vector corresponding to the :math:`\left|\rm up \right>` state:. .. plot::; :context: close-figs. up = qutip.basis(2, 0); b.add_states(up); b.render(). Notice that when we add more than a single vector (or data point), a different color will automatically be applied to the later data set (mod 4).; In total, the code for constructing our Bloch sphere with one vector, one state, and a single data point is:. .. plot::; :context: close-figs. b = qutip.Bloch(). pnt = [1./np.sqrt(3), 1./np.sqrt(3), 1./np.sqrt(3)]; b.add_points(pnt); vec = [0, 1, 0]; b.add_vectors(vec); up = qutip.basis(2, 0); b.add_states(up); b.render(). where we have removed the extra ``show()`` commands. We can also plot multiple points, vectors, and states at the same time by passing list or arrays instead of individual elements. Before giving an example, we can use the `clear()` command to remove the current data from our Bloch sphere instead of creating a new instance:. .. plot::; :context: close-figs. b.clear(); b.render(). Now on the same Bloch sphere, we can plot the three states associated with the x, y, and z directions:. .. plot::; :context: close-figs. x = (qutip.basis(2, 0) + (1+0j)*qutip.basis(2, 1)).unit(); y = (qutip.basis(2, 0) + (0+1j)*qutip.basis(2, 1)).unit(); z = (qutip.basis(2, 0) + (0+0j)*qutip.basis(2, 1)).unit(). b.add_states([x, y, z]); b.render(). a similar method works for adding vectors:. .. plot::; :context: close-figs. b.clear(); vec = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]; b.add_vectors(vec); b.render(). Adding multiple points to the Bloch sphere works slightly differently than adding multiple states or vectors. For example, lets add a set of 20 points around the equator (after calling `clear()`):. .. plot::; :context: close-figs. b.clear(). th = np.linspace(0, 2*np.pi, 20); xp = np.cos(th); yp = np.sin(th); zp = np.zeros(20). pnts = [xp, yp, zp]; b.add_poi",MatchSource.DOCS,doc/guide/guide-bloch.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-bloch.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-bloch.rst:2308,Usability,clear,clear,2308," another vector corresponding to the :math:`\left|\rm up \right>` state:. .. plot::; :context: close-figs. up = qutip.basis(2, 0); b.add_states(up); b.render(). Notice that when we add more than a single vector (or data point), a different color will automatically be applied to the later data set (mod 4).; In total, the code for constructing our Bloch sphere with one vector, one state, and a single data point is:. .. plot::; :context: close-figs. b = qutip.Bloch(). pnt = [1./np.sqrt(3), 1./np.sqrt(3), 1./np.sqrt(3)]; b.add_points(pnt); vec = [0, 1, 0]; b.add_vectors(vec); up = qutip.basis(2, 0); b.add_states(up); b.render(). where we have removed the extra ``show()`` commands. We can also plot multiple points, vectors, and states at the same time by passing list or arrays instead of individual elements. Before giving an example, we can use the `clear()` command to remove the current data from our Bloch sphere instead of creating a new instance:. .. plot::; :context: close-figs. b.clear(); b.render(). Now on the same Bloch sphere, we can plot the three states associated with the x, y, and z directions:. .. plot::; :context: close-figs. x = (qutip.basis(2, 0) + (1+0j)*qutip.basis(2, 1)).unit(); y = (qutip.basis(2, 0) + (0+1j)*qutip.basis(2, 1)).unit(); z = (qutip.basis(2, 0) + (0+0j)*qutip.basis(2, 1)).unit(). b.add_states([x, y, z]); b.render(). a similar method works for adding vectors:. .. plot::; :context: close-figs. b.clear(); vec = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]; b.add_vectors(vec); b.render(). Adding multiple points to the Bloch sphere works slightly differently than adding multiple states or vectors. For example, lets add a set of 20 points around the equator (after calling `clear()`):. .. plot::; :context: close-figs. b.clear(). th = np.linspace(0, 2*np.pi, 20); xp = np.cos(th); yp = np.sin(th); zp = np.zeros(20). pnts = [xp, yp, zp]; b.add_points(pnts); b.render(). Notice that, in contrast to states or vectors, each point remains the same color as the ini",MatchSource.DOCS,doc/guide/guide-bloch.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-bloch.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-bloch.rst:2759,Usability,clear,clear,2759,"t = [1./np.sqrt(3), 1./np.sqrt(3), 1./np.sqrt(3)]; b.add_points(pnt); vec = [0, 1, 0]; b.add_vectors(vec); up = qutip.basis(2, 0); b.add_states(up); b.render(). where we have removed the extra ``show()`` commands. We can also plot multiple points, vectors, and states at the same time by passing list or arrays instead of individual elements. Before giving an example, we can use the `clear()` command to remove the current data from our Bloch sphere instead of creating a new instance:. .. plot::; :context: close-figs. b.clear(); b.render(). Now on the same Bloch sphere, we can plot the three states associated with the x, y, and z directions:. .. plot::; :context: close-figs. x = (qutip.basis(2, 0) + (1+0j)*qutip.basis(2, 1)).unit(); y = (qutip.basis(2, 0) + (0+1j)*qutip.basis(2, 1)).unit(); z = (qutip.basis(2, 0) + (0+0j)*qutip.basis(2, 1)).unit(). b.add_states([x, y, z]); b.render(). a similar method works for adding vectors:. .. plot::; :context: close-figs. b.clear(); vec = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]; b.add_vectors(vec); b.render(). Adding multiple points to the Bloch sphere works slightly differently than adding multiple states or vectors. For example, lets add a set of 20 points around the equator (after calling `clear()`):. .. plot::; :context: close-figs. b.clear(). th = np.linspace(0, 2*np.pi, 20); xp = np.cos(th); yp = np.sin(th); zp = np.zeros(20). pnts = [xp, yp, zp]; b.add_points(pnts); b.render(). Notice that, in contrast to states or vectors, each point remains the same color as the initial point. This is because adding multiple data points using the ``add_points`` function is interpreted, by default, to correspond to a single data point (single qubit state) plotted at different times. This is very useful when visualizing the dynamics of a qubit. An example of this is given in the example . If we want to plot additional qubit states we can call additional ``add_points`` functions:. .. plot::; :context: close-figs. xz = np.zeros(20); yz = np.sin(th)",MatchSource.DOCS,doc/guide/guide-bloch.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-bloch.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-bloch.rst:3027,Usability,clear,clear,3027,"nds. We can also plot multiple points, vectors, and states at the same time by passing list or arrays instead of individual elements. Before giving an example, we can use the `clear()` command to remove the current data from our Bloch sphere instead of creating a new instance:. .. plot::; :context: close-figs. b.clear(); b.render(). Now on the same Bloch sphere, we can plot the three states associated with the x, y, and z directions:. .. plot::; :context: close-figs. x = (qutip.basis(2, 0) + (1+0j)*qutip.basis(2, 1)).unit(); y = (qutip.basis(2, 0) + (0+1j)*qutip.basis(2, 1)).unit(); z = (qutip.basis(2, 0) + (0+0j)*qutip.basis(2, 1)).unit(). b.add_states([x, y, z]); b.render(). a similar method works for adding vectors:. .. plot::; :context: close-figs. b.clear(); vec = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]; b.add_vectors(vec); b.render(). Adding multiple points to the Bloch sphere works slightly differently than adding multiple states or vectors. For example, lets add a set of 20 points around the equator (after calling `clear()`):. .. plot::; :context: close-figs. b.clear(). th = np.linspace(0, 2*np.pi, 20); xp = np.cos(th); yp = np.sin(th); zp = np.zeros(20). pnts = [xp, yp, zp]; b.add_points(pnts); b.render(). Notice that, in contrast to states or vectors, each point remains the same color as the initial point. This is because adding multiple data points using the ``add_points`` function is interpreted, by default, to correspond to a single data point (single qubit state) plotted at different times. This is very useful when visualizing the dynamics of a qubit. An example of this is given in the example . If we want to plot additional qubit states we can call additional ``add_points`` functions:. .. plot::; :context: close-figs. xz = np.zeros(20); yz = np.sin(th); zz = np.cos(th); b.add_points([xz, yz, zz]); b.render(). The color and shape of the data points is varied automatically by the Bloch class. Notice how the color and point markers change for each set of data.",MatchSource.DOCS,doc/guide/guide-bloch.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-bloch.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-bloch.rst:3074,Usability,clear,clear,3074,"ng list or arrays instead of individual elements. Before giving an example, we can use the `clear()` command to remove the current data from our Bloch sphere instead of creating a new instance:. .. plot::; :context: close-figs. b.clear(); b.render(). Now on the same Bloch sphere, we can plot the three states associated with the x, y, and z directions:. .. plot::; :context: close-figs. x = (qutip.basis(2, 0) + (1+0j)*qutip.basis(2, 1)).unit(); y = (qutip.basis(2, 0) + (0+1j)*qutip.basis(2, 1)).unit(); z = (qutip.basis(2, 0) + (0+0j)*qutip.basis(2, 1)).unit(). b.add_states([x, y, z]); b.render(). a similar method works for adding vectors:. .. plot::; :context: close-figs. b.clear(); vec = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]; b.add_vectors(vec); b.render(). Adding multiple points to the Bloch sphere works slightly differently than adding multiple states or vectors. For example, lets add a set of 20 points around the equator (after calling `clear()`):. .. plot::; :context: close-figs. b.clear(). th = np.linspace(0, 2*np.pi, 20); xp = np.cos(th); yp = np.sin(th); zp = np.zeros(20). pnts = [xp, yp, zp]; b.add_points(pnts); b.render(). Notice that, in contrast to states or vectors, each point remains the same color as the initial point. This is because adding multiple data points using the ``add_points`` function is interpreted, by default, to correspond to a single data point (single qubit state) plotted at different times. This is very useful when visualizing the dynamics of a qubit. An example of this is given in the example . If we want to plot additional qubit states we can call additional ``add_points`` functions:. .. plot::; :context: close-figs. xz = np.zeros(20); yz = np.sin(th); zz = np.cos(th); b.add_points([xz, yz, zz]); b.render(). The color and shape of the data points is varied automatically by the Bloch class. Notice how the color and point markers change for each set of data. Again, we have had to call ``add_points`` twice because adding more than one set of",MatchSource.DOCS,doc/guide/guide-bloch.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-bloch.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-bloch.rst:4389,Usability,clear,clear,4389,"oints`` function is interpreted, by default, to correspond to a single data point (single qubit state) plotted at different times. This is very useful when visualizing the dynamics of a qubit. An example of this is given in the example . If we want to plot additional qubit states we can call additional ``add_points`` functions:. .. plot::; :context: close-figs. xz = np.zeros(20); yz = np.sin(th); zz = np.cos(th); b.add_points([xz, yz, zz]); b.render(). The color and shape of the data points is varied automatically by the Bloch class. Notice how the color and point markers change for each set of data. Again, we have had to call ``add_points`` twice because adding more than one set of multiple data points is *not* supported by the ``add_points`` function. What if we want to vary the color of our points. We can tell the :class:`qutip.bloch.Bloch` class to vary the color of each point according to the colors listed in the ``b.point_color`` list (see :ref:`bloch-config` below). Again after ``clear()``:. .. plot::; :context: close-figs. b.clear(). xp = np.cos(th); yp = np.sin(th); zp = np.zeros(20); pnts = [xp, yp, zp]; b.add_points(pnts, 'm') # <-- add a 'm' string to signify 'multi' colored points; b.render(). Now, the data points cycle through a variety of predefined colors. Now lets add another set of points, but this time we want the set to be a single color, representing say a qubit going from the :math:`\left|\rm up\right>` state to the :math:`\left|\rm down\right>` state in the y-z plane:. .. plot::; :context: close-figs. xz = np.zeros(20); yz = np.sin(th); zz = np.cos(th). b.add_points([xz, yz, zz]) # no 'm'; b.render(). A more slick way of using this 'multi' color feature is also given in the example, where we set the color of the markers as a function of time. .. _bloch-config:. Configuring the Bloch sphere; ============================. Bloch Class Options; --------------------. At the end of the last section we saw that the colors and marker shapes of the dat",MatchSource.DOCS,doc/guide/guide-bloch.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-bloch.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-bloch.rst:4436,Usability,clear,clear,4436,"spond to a single data point (single qubit state) plotted at different times. This is very useful when visualizing the dynamics of a qubit. An example of this is given in the example . If we want to plot additional qubit states we can call additional ``add_points`` functions:. .. plot::; :context: close-figs. xz = np.zeros(20); yz = np.sin(th); zz = np.cos(th); b.add_points([xz, yz, zz]); b.render(). The color and shape of the data points is varied automatically by the Bloch class. Notice how the color and point markers change for each set of data. Again, we have had to call ``add_points`` twice because adding more than one set of multiple data points is *not* supported by the ``add_points`` function. What if we want to vary the color of our points. We can tell the :class:`qutip.bloch.Bloch` class to vary the color of each point according to the colors listed in the ``b.point_color`` list (see :ref:`bloch-config` below). Again after ``clear()``:. .. plot::; :context: close-figs. b.clear(). xp = np.cos(th); yp = np.sin(th); zp = np.zeros(20); pnts = [xp, yp, zp]; b.add_points(pnts, 'm') # <-- add a 'm' string to signify 'multi' colored points; b.render(). Now, the data points cycle through a variety of predefined colors. Now lets add another set of points, but this time we want the set to be a single color, representing say a qubit going from the :math:`\left|\rm up\right>` state to the :math:`\left|\rm down\right>` state in the y-z plane:. .. plot::; :context: close-figs. xz = np.zeros(20); yz = np.sin(th); zz = np.cos(th). b.add_points([xz, yz, zz]) # no 'm'; b.render(). A more slick way of using this 'multi' color feature is also given in the example, where we set the color of the markers as a function of time. .. _bloch-config:. Configuring the Bloch sphere; ============================. Bloch Class Options; --------------------. At the end of the last section we saw that the colors and marker shapes of the data plotted on the Bloch sphere are automatically varie",MatchSource.DOCS,doc/guide/guide-bloch.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-bloch.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-bloch.rst:11600,Usability,clear,clear,11600,"the print command:. .. doctest::. >>> b = qutip.Bloch(). >>> print(b) # doctest: +NORMALIZE_WHITESPACE; Bloch data:; -----------; Number of points: 0; Number of vectors: 0; <BLANKLINE>; Bloch sphere properties:; ------------------------; font_color: black; font_size: 20; frame_alpha: 0.2; frame_color: gray; frame_width: 1; point_color: ['b', 'r', 'g', '#CC6600']; point_marker: ['o', 's', 'd', '^']; point_size: [25, 32, 35, 45]; sphere_alpha: 0.2; sphere_color: #FFDDDD; figsize: [5, 5]; vector_color: ['g', '#CC6600', 'b', 'r']; vector_width: 3; vector_style: -|>; vector_mutation: 20; view: [-60, 30]; xlabel: ['$x$', '']; xlpos: [1.2, -1.2]; ylabel: ['$y$', '']; ylpos: [1.2, -1.2]; zlabel: ['$\\left|0\\right>$', '$\\left|1\\right>$']; zlpos: [1.2, -1.2]; <BLANKLINE>. .. _bloch-animate:. Animating with the Bloch sphere; ===============================. The Bloch class was designed from the outset to generate animations. To animate a set of vectors or data points the basic idea is: plot the data at time t1, save the sphere, clear the sphere, plot data at t2,... The Bloch sphere will automatically number the output file based on how many times the object has been saved (this is stored in b.savenum). The easiest way to animate data on the Bloch sphere is to use the ``save()`` method and generate a series of images to convert into an animation. However, as of Matplotlib version 1.1, creating animations is built-in. We will demonstrate both methods by looking at the decay of a qubit on the bloch sphere. .. _bloch-animate-decay:. Example: Qubit Decay; --------------------. The code for calculating the expectation values for the Pauli spin operators of a qubit decay is given below. This code is common to both animation examples. .. literalinclude:: scripts/ex_bloch_animation.py. .. _bloch-animate-decay-images:. Generating Images for Animation; ++++++++++++++++++++++++++++++++. An example of generating images for generating an animation outside of Python is given below::. impor",MatchSource.DOCS,doc/guide/guide-bloch.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-bloch.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-bloch.rst:12671,Usability,clear,clear,12671,"mber the output file based on how many times the object has been saved (this is stored in b.savenum). The easiest way to animate data on the Bloch sphere is to use the ``save()`` method and generate a series of images to convert into an animation. However, as of Matplotlib version 1.1, creating animations is built-in. We will demonstrate both methods by looking at the decay of a qubit on the bloch sphere. .. _bloch-animate-decay:. Example: Qubit Decay; --------------------. The code for calculating the expectation values for the Pauli spin operators of a qubit decay is given below. This code is common to both animation examples. .. literalinclude:: scripts/ex_bloch_animation.py. .. _bloch-animate-decay-images:. Generating Images for Animation; ++++++++++++++++++++++++++++++++. An example of generating images for generating an animation outside of Python is given below::. import numpy as np; b = qutip.Bloch(); b.vector_color = ['r']; b.view = [-40, 30]; for i in range(len(sx)):; b.clear(); b.add_vectors([np.sin(theta), 0, np.cos(theta)]); b.add_points([sx[:i+1], sy[:i+1], sz[:i+1]]); b.save(dirc='temp') # saving images to temp directory in current working directory. Generating an animation using FFmpeg (for example) is fairly simple::. ffmpeg -i temp/bloch_%01d.png bloch.mp4. .. _bloch-animate-decay-direct:. Directly Generating an Animation; ++++++++++++++++++++++++++++++++. .. important::; Generating animations directly from Matplotlib requires installing either MEncoder or FFmpeg.; While either choice works on linux, it is best to choose FFmpeg when running on the Mac.; If using macports just do: ``sudo port install ffmpeg``. The code to directly generate an mp4 movie of the Qubit decay is as follows ::. from matplotlib import pyplot, animation. fig = pyplot.figure(); ax = fig.add_subplot(azim=-40, elev=30, projection=""3d""); sphere = qutip.Bloch(axes=ax). def animate(i):; sphere.clear(); sphere.add_vectors([np.sin(theta), 0, np.cos(theta)], [""r""]); sphere.add_points",MatchSource.DOCS,doc/guide/guide-bloch.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-bloch.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-bloch.rst:12921,Usability,simpl,simple,12921,"to convert into an animation. However, as of Matplotlib version 1.1, creating animations is built-in. We will demonstrate both methods by looking at the decay of a qubit on the bloch sphere. .. _bloch-animate-decay:. Example: Qubit Decay; --------------------. The code for calculating the expectation values for the Pauli spin operators of a qubit decay is given below. This code is common to both animation examples. .. literalinclude:: scripts/ex_bloch_animation.py. .. _bloch-animate-decay-images:. Generating Images for Animation; ++++++++++++++++++++++++++++++++. An example of generating images for generating an animation outside of Python is given below::. import numpy as np; b = qutip.Bloch(); b.vector_color = ['r']; b.view = [-40, 30]; for i in range(len(sx)):; b.clear(); b.add_vectors([np.sin(theta), 0, np.cos(theta)]); b.add_points([sx[:i+1], sy[:i+1], sz[:i+1]]); b.save(dirc='temp') # saving images to temp directory in current working directory. Generating an animation using FFmpeg (for example) is fairly simple::. ffmpeg -i temp/bloch_%01d.png bloch.mp4. .. _bloch-animate-decay-direct:. Directly Generating an Animation; ++++++++++++++++++++++++++++++++. .. important::; Generating animations directly from Matplotlib requires installing either MEncoder or FFmpeg.; While either choice works on linux, it is best to choose FFmpeg when running on the Mac.; If using macports just do: ``sudo port install ffmpeg``. The code to directly generate an mp4 movie of the Qubit decay is as follows ::. from matplotlib import pyplot, animation. fig = pyplot.figure(); ax = fig.add_subplot(azim=-40, elev=30, projection=""3d""); sphere = qutip.Bloch(axes=ax). def animate(i):; sphere.clear(); sphere.add_vectors([np.sin(theta), 0, np.cos(theta)], [""r""]); sphere.add_points([sx[:i+1], sy[:i+1], sz[:i+1]]); sphere.make_sphere(); return ax. ani = animation.FuncAnimation(fig, animate, np.arange(len(sx)), blit=False, repeat=False); ani.save('bloch_sphere.mp4', fps=20). The resulting movie ma",MatchSource.DOCS,doc/guide/guide-bloch.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-bloch.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-bloch.rst:13589,Usability,clear,clear,13589,"both methods by looking at the decay of a qubit on the bloch sphere. .. _bloch-animate-decay:. Example: Qubit Decay; --------------------. The code for calculating the expectation values for the Pauli spin operators of a qubit decay is given below. This code is common to both animation examples. .. literalinclude:: scripts/ex_bloch_animation.py. .. _bloch-animate-decay-images:. Generating Images for Animation; ++++++++++++++++++++++++++++++++. An example of generating images for generating an animation outside of Python is given below::. import numpy as np; b = qutip.Bloch(); b.vector_color = ['r']; b.view = [-40, 30]; for i in range(len(sx)):; b.clear(); b.add_vectors([np.sin(theta), 0, np.cos(theta)]); b.add_points([sx[:i+1], sy[:i+1], sz[:i+1]]); b.save(dirc='temp') # saving images to temp directory in current working directory. Generating an animation using FFmpeg (for example) is fairly simple::. ffmpeg -i temp/bloch_%01d.png bloch.mp4. .. _bloch-animate-decay-direct:. Directly Generating an Animation; ++++++++++++++++++++++++++++++++. .. important::; Generating animations directly from Matplotlib requires installing either MEncoder or FFmpeg.; While either choice works on linux, it is best to choose FFmpeg when running on the Mac.; If using macports just do: ``sudo port install ffmpeg``. The code to directly generate an mp4 movie of the Qubit decay is as follows ::. from matplotlib import pyplot, animation. fig = pyplot.figure(); ax = fig.add_subplot(azim=-40, elev=30, projection=""3d""); sphere = qutip.Bloch(axes=ax). def animate(i):; sphere.clear(); sphere.add_vectors([np.sin(theta), 0, np.cos(theta)], [""r""]); sphere.add_points([sx[:i+1], sy[:i+1], sz[:i+1]]); sphere.make_sphere(); return ax. ani = animation.FuncAnimation(fig, animate, np.arange(len(sx)), blit=False, repeat=False); ani.save('bloch_sphere.mp4', fps=20). The resulting movie may be viewed here: `bloch_decay.mp4 <https://raw.githubusercontent.com/qutip/qutip/master/doc/figures/bloch_decay.mp4>`_; ",MatchSource.DOCS,doc/guide/guide-bloch.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-bloch.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-control.rst:5429,Availability,error,error,5429," where :math:`\Delta t_k` is the duration of the timeslot. The evolution up to (and including) any timeslot :math:`k` (including the full evolution :math:`k=M`) can the be calculated as. .. math::. X(t_k):=X_k X_{k-1}\cdots X_1 X_0. If the objective is state-to-state transfer then :math:`X_0=\ket{\psi_0}` and the target :math:`X_{targ}=\ket{\psi_1}`, for gate synthesis :math:`X_0 = U(0) = \mathbb{1}` and the target :math:`X_{targ}=U_{targ}`. A *figure of merit* or *fidelity* is some measure of how close the evolution is to the target, based on the control amplitudes in the timeslots. The typical figure of merit for unitary systems is the normalised overlap of the evolution and the target. .. math::. f_{PSU} = \tfrac{1}{d} \big| \tr \{X_{targ}^{\dagger} X(T)\} \big|. where :math:`d` is the system dimension. In this figure of merit the absolute value is taken to ignore any differences in global phase, and :math:`0 \le f \le 1`. Typically the fidelity error (or *infidelity*) is more useful, in this case defined as :math:`\varepsilon = 1 - f_{PSU}`. There are many other possible objectives, and hence figures of merit. As there are now :math:`N \times M` variables (the :math:`u_{jk}`) and one; parameter to minimise :math:`\varepsilon`, then the problem becomes a finite; multi-variable optimisation problem, for which there are many established; methods, often referred to as 'hill-climbing' methods. The simplest of these to; understand is that of steepest ascent (or descent). The gradient of the; fidelity with respect to all the variables is calculated (or approximated) and; a step is made in the variable space in the direction of steepest ascent (or; descent). This method is a first order gradient method. In two dimensions this; describes a method of climbing a hill by heading in the direction where the; ground rises fastest. This analogy also clearly illustrates one of the main; challenges in multi-variable optimisation, which is that all methods have a; tendency to get ",MatchSource.DOCS,doc/guide/guide-control.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-control.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-control.rst:11239,Availability,down,down,11239,"[Caneva11]_ comes into play: Since the pulse complexity is usually; very low, it is sufficient to transform the optimal control problem to a few; parameter search by introducing a physically motivated function basis that; builds up the pulse. Compared to the number of time slices needed to accurately; simulate quantum dynamics (often equals basis dimension for Gradient based; algorithms), this number is lower by orders of magnitude, allowing CRAB to; efficiently optimize smooth pulses with realistic experimental constraints. It; is important to point out, that CRAB does not make any suggestion on the basis; function to be used. The basis must be chosen carefully considered, taking into; account a priori knowledge of the system (such as symmetries, magnitudes of; scales,...) and solution (e.g. sign, smoothness, bang-bang behavior,; singularities, maximum excursion or rate of change,....). By doing so, this; algorithm allows for native integration of experimental constraints such as; maximum frequencies allowed, maximum amplitude, smooth ramping up and down of; the pulse and many more. Moreover initial guesses, if they are available, can; (however not have to) be included to speed up convergence. As mentioned in the GRAPE paragraph, for CRAB local minima arising from; algorithmic design can occur, too. However, for CRAB a 'dressed' version has; recently been introduced [Rach15]_ that allows to escape local minima. For some control objectives and/or dynamical quantum descriptions, it is either; not possible to derive the gradient for the cost functional with respect to; each time slice or it is computationally expensive to do so. The same can apply; for the necessary (reverse) propagation of the co-state. All this trouble does; not occur within CRAB as those elements are not in use here. CRAB, instead,; takes the time evolution as a black-box where the pulse goes as an input and; the cost (e.g. infidelity) value will be returned as an output. This concept,; on top, all",MatchSource.DOCS,doc/guide/guide-control.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-control.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-control.rst:11311,Availability,avail,available,11311,"search by introducing a physically motivated function basis that; builds up the pulse. Compared to the number of time slices needed to accurately; simulate quantum dynamics (often equals basis dimension for Gradient based; algorithms), this number is lower by orders of magnitude, allowing CRAB to; efficiently optimize smooth pulses with realistic experimental constraints. It; is important to point out, that CRAB does not make any suggestion on the basis; function to be used. The basis must be chosen carefully considered, taking into; account a priori knowledge of the system (such as symmetries, magnitudes of; scales,...) and solution (e.g. sign, smoothness, bang-bang behavior,; singularities, maximum excursion or rate of change,....). By doing so, this; algorithm allows for native integration of experimental constraints such as; maximum frequencies allowed, maximum amplitude, smooth ramping up and down of; the pulse and many more. Moreover initial guesses, if they are available, can; (however not have to) be included to speed up convergence. As mentioned in the GRAPE paragraph, for CRAB local minima arising from; algorithmic design can occur, too. However, for CRAB a 'dressed' version has; recently been introduced [Rach15]_ that allows to escape local minima. For some control objectives and/or dynamical quantum descriptions, it is either; not possible to derive the gradient for the cost functional with respect to; each time slice or it is computationally expensive to do so. The same can apply; for the necessary (reverse) propagation of the co-state. All this trouble does; not occur within CRAB as those elements are not in use here. CRAB, instead,; takes the time evolution as a black-box where the pulse goes as an input and; the cost (e.g. infidelity) value will be returned as an output. This concept,; on top, allows for direct integration in a closed loop experimental environment; where both the preliminarily open loop optimization, as well as the final; adoption, an",MatchSource.DOCS,doc/guide/guide-control.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-control.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-control.rst:12379,Availability,error,errors,12379,".). By doing so, this; algorithm allows for native integration of experimental constraints such as; maximum frequencies allowed, maximum amplitude, smooth ramping up and down of; the pulse and many more. Moreover initial guesses, if they are available, can; (however not have to) be included to speed up convergence. As mentioned in the GRAPE paragraph, for CRAB local minima arising from; algorithmic design can occur, too. However, for CRAB a 'dressed' version has; recently been introduced [Rach15]_ that allows to escape local minima. For some control objectives and/or dynamical quantum descriptions, it is either; not possible to derive the gradient for the cost functional with respect to; each time slice or it is computationally expensive to do so. The same can apply; for the necessary (reverse) propagation of the co-state. All this trouble does; not occur within CRAB as those elements are not in use here. CRAB, instead,; takes the time evolution as a black-box where the pulse goes as an input and; the cost (e.g. infidelity) value will be returned as an output. This concept,; on top, allows for direct integration in a closed loop experimental environment; where both the preliminarily open loop optimization, as well as the final; adoption, and integration to the lab (to account for modeling errors,; experimental systematic noise, ...) can be done all in one, using this; algorithm. Optimal Quantum Control in QuTiP; ================================. The Quantum Control part of qutip has been moved to its own project. The previously available implementation is now located in the `qutip-qtrl <https://qutip-qtrl.readthedocs.io/en/stable/>`_ module. If the ``qutip-qtrl`` package is installed, it can also be imported under the name ``qutip.control`` to ease porting code developed for QuTiP 4 to QuTiP 5. A newer interface with upgraded capacities is being developped in `qutip-qoc <https://github.com/flowerthrower/qutip-qoc/tree/packaging>`_. Please give these modules a try.; ",MatchSource.DOCS,doc/guide/guide-control.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-control.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-control.rst:12623,Availability,avail,available,12623,".). By doing so, this; algorithm allows for native integration of experimental constraints such as; maximum frequencies allowed, maximum amplitude, smooth ramping up and down of; the pulse and many more. Moreover initial guesses, if they are available, can; (however not have to) be included to speed up convergence. As mentioned in the GRAPE paragraph, for CRAB local minima arising from; algorithmic design can occur, too. However, for CRAB a 'dressed' version has; recently been introduced [Rach15]_ that allows to escape local minima. For some control objectives and/or dynamical quantum descriptions, it is either; not possible to derive the gradient for the cost functional with respect to; each time slice or it is computationally expensive to do so. The same can apply; for the necessary (reverse) propagation of the co-state. All this trouble does; not occur within CRAB as those elements are not in use here. CRAB, instead,; takes the time evolution as a black-box where the pulse goes as an input and; the cost (e.g. infidelity) value will be returned as an output. This concept,; on top, allows for direct integration in a closed loop experimental environment; where both the preliminarily open loop optimization, as well as the final; adoption, and integration to the lab (to account for modeling errors,; experimental systematic noise, ...) can be done all in one, using this; algorithm. Optimal Quantum Control in QuTiP; ================================. The Quantum Control part of qutip has been moved to its own project. The previously available implementation is now located in the `qutip-qtrl <https://qutip-qtrl.readthedocs.io/en/stable/>`_ module. If the ``qutip-qtrl`` package is installed, it can also be imported under the name ``qutip.control`` to ease porting code developed for QuTiP 4 to QuTiP 5. A newer interface with upgraded capacities is being developped in `qutip-qoc <https://github.com/flowerthrower/qutip-qoc/tree/packaging>`_. Please give these modules a try.; ",MatchSource.DOCS,doc/guide/guide-control.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-control.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-control.rst:11120,Deployability,integrat,integration,11120,"[Caneva11]_ comes into play: Since the pulse complexity is usually; very low, it is sufficient to transform the optimal control problem to a few; parameter search by introducing a physically motivated function basis that; builds up the pulse. Compared to the number of time slices needed to accurately; simulate quantum dynamics (often equals basis dimension for Gradient based; algorithms), this number is lower by orders of magnitude, allowing CRAB to; efficiently optimize smooth pulses with realistic experimental constraints. It; is important to point out, that CRAB does not make any suggestion on the basis; function to be used. The basis must be chosen carefully considered, taking into; account a priori knowledge of the system (such as symmetries, magnitudes of; scales,...) and solution (e.g. sign, smoothness, bang-bang behavior,; singularities, maximum excursion or rate of change,....). By doing so, this; algorithm allows for native integration of experimental constraints such as; maximum frequencies allowed, maximum amplitude, smooth ramping up and down of; the pulse and many more. Moreover initial guesses, if they are available, can; (however not have to) be included to speed up convergence. As mentioned in the GRAPE paragraph, for CRAB local minima arising from; algorithmic design can occur, too. However, for CRAB a 'dressed' version has; recently been introduced [Rach15]_ that allows to escape local minima. For some control objectives and/or dynamical quantum descriptions, it is either; not possible to derive the gradient for the cost functional with respect to; each time slice or it is computationally expensive to do so. The same can apply; for the necessary (reverse) propagation of the co-state. All this trouble does; not occur within CRAB as those elements are not in use here. CRAB, instead,; takes the time evolution as a black-box where the pulse goes as an input and; the cost (e.g. infidelity) value will be returned as an output. This concept,; on top, all",MatchSource.DOCS,doc/guide/guide-control.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-control.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-control.rst:12187,Deployability,integrat,integration,12187,".). By doing so, this; algorithm allows for native integration of experimental constraints such as; maximum frequencies allowed, maximum amplitude, smooth ramping up and down of; the pulse and many more. Moreover initial guesses, if they are available, can; (however not have to) be included to speed up convergence. As mentioned in the GRAPE paragraph, for CRAB local minima arising from; algorithmic design can occur, too. However, for CRAB a 'dressed' version has; recently been introduced [Rach15]_ that allows to escape local minima. For some control objectives and/or dynamical quantum descriptions, it is either; not possible to derive the gradient for the cost functional with respect to; each time slice or it is computationally expensive to do so. The same can apply; for the necessary (reverse) propagation of the co-state. All this trouble does; not occur within CRAB as those elements are not in use here. CRAB, instead,; takes the time evolution as a black-box where the pulse goes as an input and; the cost (e.g. infidelity) value will be returned as an output. This concept,; on top, allows for direct integration in a closed loop experimental environment; where both the preliminarily open loop optimization, as well as the final; adoption, and integration to the lab (to account for modeling errors,; experimental systematic noise, ...) can be done all in one, using this; algorithm. Optimal Quantum Control in QuTiP; ================================. The Quantum Control part of qutip has been moved to its own project. The previously available implementation is now located in the `qutip-qtrl <https://qutip-qtrl.readthedocs.io/en/stable/>`_ module. If the ``qutip-qtrl`` package is installed, it can also be imported under the name ``qutip.control`` to ease porting code developed for QuTiP 4 to QuTiP 5. A newer interface with upgraded capacities is being developped in `qutip-qoc <https://github.com/flowerthrower/qutip-qoc/tree/packaging>`_. Please give these modules a try.; ",MatchSource.DOCS,doc/guide/guide-control.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-control.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-control.rst:12331,Deployability,integrat,integration,12331,".). By doing so, this; algorithm allows for native integration of experimental constraints such as; maximum frequencies allowed, maximum amplitude, smooth ramping up and down of; the pulse and many more. Moreover initial guesses, if they are available, can; (however not have to) be included to speed up convergence. As mentioned in the GRAPE paragraph, for CRAB local minima arising from; algorithmic design can occur, too. However, for CRAB a 'dressed' version has; recently been introduced [Rach15]_ that allows to escape local minima. For some control objectives and/or dynamical quantum descriptions, it is either; not possible to derive the gradient for the cost functional with respect to; each time slice or it is computationally expensive to do so. The same can apply; for the necessary (reverse) propagation of the co-state. All this trouble does; not occur within CRAB as those elements are not in use here. CRAB, instead,; takes the time evolution as a black-box where the pulse goes as an input and; the cost (e.g. infidelity) value will be returned as an output. This concept,; on top, allows for direct integration in a closed loop experimental environment; where both the preliminarily open loop optimization, as well as the final; adoption, and integration to the lab (to account for modeling errors,; experimental systematic noise, ...) can be done all in one, using this; algorithm. Optimal Quantum Control in QuTiP; ================================. The Quantum Control part of qutip has been moved to its own project. The previously available implementation is now located in the `qutip-qtrl <https://qutip-qtrl.readthedocs.io/en/stable/>`_ module. If the ``qutip-qtrl`` package is installed, it can also be imported under the name ``qutip.control`` to ease porting code developed for QuTiP 4 to QuTiP 5. A newer interface with upgraded capacities is being developped in `qutip-qoc <https://github.com/flowerthrower/qutip-qoc/tree/packaging>`_. Please give these modules a try.; ",MatchSource.DOCS,doc/guide/guide-control.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-control.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-control.rst:12772,Deployability,install,installed,12772,".). By doing so, this; algorithm allows for native integration of experimental constraints such as; maximum frequencies allowed, maximum amplitude, smooth ramping up and down of; the pulse and many more. Moreover initial guesses, if they are available, can; (however not have to) be included to speed up convergence. As mentioned in the GRAPE paragraph, for CRAB local minima arising from; algorithmic design can occur, too. However, for CRAB a 'dressed' version has; recently been introduced [Rach15]_ that allows to escape local minima. For some control objectives and/or dynamical quantum descriptions, it is either; not possible to derive the gradient for the cost functional with respect to; each time slice or it is computationally expensive to do so. The same can apply; for the necessary (reverse) propagation of the co-state. All this trouble does; not occur within CRAB as those elements are not in use here. CRAB, instead,; takes the time evolution as a black-box where the pulse goes as an input and; the cost (e.g. infidelity) value will be returned as an output. This concept,; on top, allows for direct integration in a closed loop experimental environment; where both the preliminarily open loop optimization, as well as the final; adoption, and integration to the lab (to account for modeling errors,; experimental systematic noise, ...) can be done all in one, using this; algorithm. Optimal Quantum Control in QuTiP; ================================. The Quantum Control part of qutip has been moved to its own project. The previously available implementation is now located in the `qutip-qtrl <https://qutip-qtrl.readthedocs.io/en/stable/>`_ module. If the ``qutip-qtrl`` package is installed, it can also be imported under the name ``qutip.control`` to ease porting code developed for QuTiP 4 to QuTiP 5. A newer interface with upgraded capacities is being developped in `qutip-qoc <https://github.com/flowerthrower/qutip-qoc/tree/packaging>`_. Please give these modules a try.; ",MatchSource.DOCS,doc/guide/guide-control.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-control.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-control.rst:12918,Deployability,upgrade,upgraded,12918,".). By doing so, this; algorithm allows for native integration of experimental constraints such as; maximum frequencies allowed, maximum amplitude, smooth ramping up and down of; the pulse and many more. Moreover initial guesses, if they are available, can; (however not have to) be included to speed up convergence. As mentioned in the GRAPE paragraph, for CRAB local minima arising from; algorithmic design can occur, too. However, for CRAB a 'dressed' version has; recently been introduced [Rach15]_ that allows to escape local minima. For some control objectives and/or dynamical quantum descriptions, it is either; not possible to derive the gradient for the cost functional with respect to; each time slice or it is computationally expensive to do so. The same can apply; for the necessary (reverse) propagation of the co-state. All this trouble does; not occur within CRAB as those elements are not in use here. CRAB, instead,; takes the time evolution as a black-box where the pulse goes as an input and; the cost (e.g. infidelity) value will be returned as an output. This concept,; on top, allows for direct integration in a closed loop experimental environment; where both the preliminarily open loop optimization, as well as the final; adoption, and integration to the lab (to account for modeling errors,; experimental systematic noise, ...) can be done all in one, using this; algorithm. Optimal Quantum Control in QuTiP; ================================. The Quantum Control part of qutip has been moved to its own project. The previously available implementation is now located in the `qutip-qtrl <https://qutip-qtrl.readthedocs.io/en/stable/>`_ module. If the ``qutip-qtrl`` package is installed, it can also be imported under the name ``qutip.control`` to ease porting code developed for QuTiP 4 to QuTiP 5. A newer interface with upgraded capacities is being developped in `qutip-qoc <https://github.com/flowerthrower/qutip-qoc/tree/packaging>`_. Please give these modules a try.; ",MatchSource.DOCS,doc/guide/guide-control.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-control.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-control.rst:7472,Energy Efficiency,efficient,efficient,7472,"stuck in local maxima. It is hard to determine whether one has; found a global maximum or not - a local peak is likely not to be the highest; mountain in the region. In quantum optimal control we can typically define an; infidelity that has a lower bound of zero. We can then look to minimise the; infidelity (from here on we will only consider optimising for infidelity; minima). This means that we can terminate any pulse optimisation when the; infidelity reaches zero (to a sufficient precision). This is however only; possible for fully controllable systems; otherwise it is hard (if not; impossible) to know that the minimum possible infidelity has been achieved. In; the hill walking analogy the step size is roughly fixed to a stride, however,; in computations the step size must be chosen. Clearly there is a trade-off here; between the number of steps (or iterations) required to reach the minima and; the possibility that we might step over a minima. In practice it is difficult; to determine an efficient and effective step size. The second order differentials of the infidelity with respect to the variables; can be used to approximate the local landscape to a parabola. This way a step; (or jump) can be made to where the minima would be if it were parabolic. This; typically vastly reduces the number of iterations, and removes the need to; guess a step size. The method where all the second differentials are calculated; explicitly is called the *Newton-Raphson* method. However, calculating the; second-order differentials (the Hessian matrix) can be computationally; expensive, and so there are a class of methods known as *quasi-Newton* that; approximate the Hessian based on successive iterations. The most popular of; these (in quantum optimal control) is the BroydenFletcherGoldfarbShanno; algorithm (BFGS). The default method in the QuTiP Qtrl GRAPE implementation is; the L-BFGS-B method in Scipy, which is a wrapper to the implementation; described in [Byrd95]_. This limit",MatchSource.DOCS,doc/guide/guide-control.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-control.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-control.rst:7762,Energy Efficiency,reduce,reduces,7762," we will only consider optimising for infidelity; minima). This means that we can terminate any pulse optimisation when the; infidelity reaches zero (to a sufficient precision). This is however only; possible for fully controllable systems; otherwise it is hard (if not; impossible) to know that the minimum possible infidelity has been achieved. In; the hill walking analogy the step size is roughly fixed to a stride, however,; in computations the step size must be chosen. Clearly there is a trade-off here; between the number of steps (or iterations) required to reach the minima and; the possibility that we might step over a minima. In practice it is difficult; to determine an efficient and effective step size. The second order differentials of the infidelity with respect to the variables; can be used to approximate the local landscape to a parabola. This way a step; (or jump) can be made to where the minima would be if it were parabolic. This; typically vastly reduces the number of iterations, and removes the need to; guess a step size. The method where all the second differentials are calculated; explicitly is called the *Newton-Raphson* method. However, calculating the; second-order differentials (the Hessian matrix) can be computationally; expensive, and so there are a class of methods known as *quasi-Newton* that; approximate the Hessian based on successive iterations. The most popular of; these (in quantum optimal control) is the BroydenFletcherGoldfarbShanno; algorithm (BFGS). The default method in the QuTiP Qtrl GRAPE implementation is; the L-BFGS-B method in Scipy, which is a wrapper to the implementation; described in [Byrd95]_. This limited memory and bounded method does not need to; store the entire Hessian, which reduces the computer memory required, and; allows bounds to be set for variable values, which considering these are field; amplitudes is often physical. The pulse optimisation is typically far more efficient if the gradients can be; calculated ",MatchSource.DOCS,doc/guide/guide-control.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-control.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-control.rst:8545,Energy Efficiency,reduce,reduces,8545,"variables; can be used to approximate the local landscape to a parabola. This way a step; (or jump) can be made to where the minima would be if it were parabolic. This; typically vastly reduces the number of iterations, and removes the need to; guess a step size. The method where all the second differentials are calculated; explicitly is called the *Newton-Raphson* method. However, calculating the; second-order differentials (the Hessian matrix) can be computationally; expensive, and so there are a class of methods known as *quasi-Newton* that; approximate the Hessian based on successive iterations. The most popular of; these (in quantum optimal control) is the BroydenFletcherGoldfarbShanno; algorithm (BFGS). The default method in the QuTiP Qtrl GRAPE implementation is; the L-BFGS-B method in Scipy, which is a wrapper to the implementation; described in [Byrd95]_. This limited memory and bounded method does not need to; store the entire Hessian, which reduces the computer memory required, and; allows bounds to be set for variable values, which considering these are field; amplitudes is often physical. The pulse optimisation is typically far more efficient if the gradients can be; calculated exactly, rather than approximated. For simple fidelity measures such; as :math:`f_{PSU}` this is possible. Firstly the propagator gradient for each; timeslot with respect to the control amplitudes is calculated. For closed; systems, with unitary dynamics, a method using the eigendecomposition is used,; which is efficient as it is also used in the propagator calculation (to; exponentiate the combined Hamiltonian). More generally (for example open; systems and symplectic dynamics) the Frechet derivative (or augmented matrix); method is used, which is described in [Flo12]_. For other optimisation goals it; may not be possible to calculate analytic gradients. In these cases it is; necessary to approximate the gradients, but this can be very expensive, and can; lead to other algori",MatchSource.DOCS,doc/guide/guide-control.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-control.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-control.rst:8743,Energy Efficiency,efficient,efficient,8743,"y reduces the number of iterations, and removes the need to; guess a step size. The method where all the second differentials are calculated; explicitly is called the *Newton-Raphson* method. However, calculating the; second-order differentials (the Hessian matrix) can be computationally; expensive, and so there are a class of methods known as *quasi-Newton* that; approximate the Hessian based on successive iterations. The most popular of; these (in quantum optimal control) is the BroydenFletcherGoldfarbShanno; algorithm (BFGS). The default method in the QuTiP Qtrl GRAPE implementation is; the L-BFGS-B method in Scipy, which is a wrapper to the implementation; described in [Byrd95]_. This limited memory and bounded method does not need to; store the entire Hessian, which reduces the computer memory required, and; allows bounds to be set for variable values, which considering these are field; amplitudes is often physical. The pulse optimisation is typically far more efficient if the gradients can be; calculated exactly, rather than approximated. For simple fidelity measures such; as :math:`f_{PSU}` this is possible. Firstly the propagator gradient for each; timeslot with respect to the control amplitudes is calculated. For closed; systems, with unitary dynamics, a method using the eigendecomposition is used,; which is efficient as it is also used in the propagator calculation (to; exponentiate the combined Hamiltonian). More generally (for example open; systems and symplectic dynamics) the Frechet derivative (or augmented matrix); method is used, which is described in [Flo12]_. For other optimisation goals it; may not be possible to calculate analytic gradients. In these cases it is; necessary to approximate the gradients, but this can be very expensive, and can; lead to other algorithms out-performing GRAPE. The CRAB Algorithm; ===================; It has been shown [Lloyd14]_, the dimension of a quantum optimal control; problem is a polynomial function of the di",MatchSource.DOCS,doc/guide/guide-control.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-control.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-control.rst:9102,Energy Efficiency,efficient,efficient,9102," as *quasi-Newton* that; approximate the Hessian based on successive iterations. The most popular of; these (in quantum optimal control) is the BroydenFletcherGoldfarbShanno; algorithm (BFGS). The default method in the QuTiP Qtrl GRAPE implementation is; the L-BFGS-B method in Scipy, which is a wrapper to the implementation; described in [Byrd95]_. This limited memory and bounded method does not need to; store the entire Hessian, which reduces the computer memory required, and; allows bounds to be set for variable values, which considering these are field; amplitudes is often physical. The pulse optimisation is typically far more efficient if the gradients can be; calculated exactly, rather than approximated. For simple fidelity measures such; as :math:`f_{PSU}` this is possible. Firstly the propagator gradient for each; timeslot with respect to the control amplitudes is calculated. For closed; systems, with unitary dynamics, a method using the eigendecomposition is used,; which is efficient as it is also used in the propagator calculation (to; exponentiate the combined Hamiltonian). More generally (for example open; systems and symplectic dynamics) the Frechet derivative (or augmented matrix); method is used, which is described in [Flo12]_. For other optimisation goals it; may not be possible to calculate analytic gradients. In these cases it is; necessary to approximate the gradients, but this can be very expensive, and can; lead to other algorithms out-performing GRAPE. The CRAB Algorithm; ===================; It has been shown [Lloyd14]_, the dimension of a quantum optimal control; problem is a polynomial function of the dimension of the manifold of the; time-polynomial reachable states, when allowing for a finite control precision; and evolution time. You can think of this as the information content of the; pulse (as being the only effective input) being very limited e.g. the pulse is; compressible to a few bytes without loosing the target. This is where the ",MatchSource.DOCS,doc/guide/guide-control.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-control.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-control.rst:10627,Energy Efficiency,efficient,efficiently,10627,"ad to other algorithms out-performing GRAPE. The CRAB Algorithm; ===================; It has been shown [Lloyd14]_, the dimension of a quantum optimal control; problem is a polynomial function of the dimension of the manifold of the; time-polynomial reachable states, when allowing for a finite control precision; and evolution time. You can think of this as the information content of the; pulse (as being the only effective input) being very limited e.g. the pulse is; compressible to a few bytes without loosing the target. This is where the **C**\ hopped **RA**\ ndom **B**\ asis (CRAB) algorithm; [Doria11]_, [Caneva11]_ comes into play: Since the pulse complexity is usually; very low, it is sufficient to transform the optimal control problem to a few; parameter search by introducing a physically motivated function basis that; builds up the pulse. Compared to the number of time slices needed to accurately; simulate quantum dynamics (often equals basis dimension for Gradient based; algorithms), this number is lower by orders of magnitude, allowing CRAB to; efficiently optimize smooth pulses with realistic experimental constraints. It; is important to point out, that CRAB does not make any suggestion on the basis; function to be used. The basis must be chosen carefully considered, taking into; account a priori knowledge of the system (such as symmetries, magnitudes of; scales,...) and solution (e.g. sign, smoothness, bang-bang behavior,; singularities, maximum excursion or rate of change,....). By doing so, this; algorithm allows for native integration of experimental constraints such as; maximum frequencies allowed, maximum amplitude, smooth ramping up and down of; the pulse and many more. Moreover initial guesses, if they are available, can; (however not have to) be included to speed up convergence. As mentioned in the GRAPE paragraph, for CRAB local minima arising from; algorithmic design can occur, too. However, for CRAB a 'dressed' version has; recently been introdu",MatchSource.DOCS,doc/guide/guide-control.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-control.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-control.rst:3602,Integrability,depend,dependent,3602," to Schrdinger's equation are of the form:. .. math::. \ket{\psi(t)} = U(t)\ket{\psi_0}. where :math:`\psi_0` is the state of the system at :math:`t=0` and :math:`U(t)` is a unitary operator on the Hilbert space containing the states. :math:`U(t)` is a solution to the *Schrdinger operator equation*. .. math::. \tfrac{d}{dt}U = -i H(t)U ,\quad U(0) = \mathbb{1}. We can use optimal control algorithms to determine a set of :math:`u_j` that will drive our system from :math:`\ket{\psi_0}` to :math:`\ket{\psi_1}`, this is state-to-state transfer, or drive the system from some arbitary state to a given state :math:`\ket{\psi_1}`, which is state preparation, or effect some unitary transformation :math:`U_{target}`, called gate synthesis. The latter of these is most important in quantum computation. The GRAPE algorithm; ===================; The **GR**\ adient **A**\ scent **P**\ ulse **E**\ ngineering was first proposed in [NKanej]_. Solutions to Schrdinger's equation for a time-dependent Hamiltonian are not generally possible to obtain analytically. Therefore, a piecewise constant approximation to the pulse amplitudes is made. Time allowed for the system to evolve :math:`T` is split into :math:`M` timeslots (typically these are of equal duration), during which the control amplitude is assumed to remain constant. The combined Hamiltonian can then be approximated as:. .. math::. H(t) \approx H(t_k) = H_0 + \sum_{j=1}^N u_{jk} H_j\quad. where :math:`k` is a timeslot index, :math:`j` is the control index, and :math:`N` is the number of controls. Hence :math:`t_k` is the evolution time at the start of the timeslot, and :math:`u_{jk}` is the amplitude of control :math:`j` throughout timeslot :math:`k`. The time evolution operator, or propagator, within the timeslot can then be calculated as:. .. math::. X_k:=e^{-iH(t_k)\Delta t_k}. where :math:`\Delta t_k` is the duration of the timeslot. The evolution up to (and including) any timeslot :math:`k` (including the full evolution ",MatchSource.DOCS,doc/guide/guide-control.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-control.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-control.rst:8401,Integrability,wrap,wrapper,8401," the possibility that we might step over a minima. In practice it is difficult; to determine an efficient and effective step size. The second order differentials of the infidelity with respect to the variables; can be used to approximate the local landscape to a parabola. This way a step; (or jump) can be made to where the minima would be if it were parabolic. This; typically vastly reduces the number of iterations, and removes the need to; guess a step size. The method where all the second differentials are calculated; explicitly is called the *Newton-Raphson* method. However, calculating the; second-order differentials (the Hessian matrix) can be computationally; expensive, and so there are a class of methods known as *quasi-Newton* that; approximate the Hessian based on successive iterations. The most popular of; these (in quantum optimal control) is the BroydenFletcherGoldfarbShanno; algorithm (BFGS). The default method in the QuTiP Qtrl GRAPE implementation is; the L-BFGS-B method in Scipy, which is a wrapper to the implementation; described in [Byrd95]_. This limited memory and bounded method does not need to; store the entire Hessian, which reduces the computer memory required, and; allows bounds to be set for variable values, which considering these are field; amplitudes is often physical. The pulse optimisation is typically far more efficient if the gradients can be; calculated exactly, rather than approximated. For simple fidelity measures such; as :math:`f_{PSU}` this is possible. Firstly the propagator gradient for each; timeslot with respect to the control amplitudes is calculated. For closed; systems, with unitary dynamics, a method using the eigendecomposition is used,; which is efficient as it is also used in the propagator calculation (to; exponentiate the combined Hamiltonian). More generally (for example open; systems and symplectic dynamics) the Frechet derivative (or augmented matrix); method is used, which is described in [Flo12]_. For other",MatchSource.DOCS,doc/guide/guide-control.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-control.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-control.rst:11120,Integrability,integrat,integration,11120,"[Caneva11]_ comes into play: Since the pulse complexity is usually; very low, it is sufficient to transform the optimal control problem to a few; parameter search by introducing a physically motivated function basis that; builds up the pulse. Compared to the number of time slices needed to accurately; simulate quantum dynamics (often equals basis dimension for Gradient based; algorithms), this number is lower by orders of magnitude, allowing CRAB to; efficiently optimize smooth pulses with realistic experimental constraints. It; is important to point out, that CRAB does not make any suggestion on the basis; function to be used. The basis must be chosen carefully considered, taking into; account a priori knowledge of the system (such as symmetries, magnitudes of; scales,...) and solution (e.g. sign, smoothness, bang-bang behavior,; singularities, maximum excursion or rate of change,....). By doing so, this; algorithm allows for native integration of experimental constraints such as; maximum frequencies allowed, maximum amplitude, smooth ramping up and down of; the pulse and many more. Moreover initial guesses, if they are available, can; (however not have to) be included to speed up convergence. As mentioned in the GRAPE paragraph, for CRAB local minima arising from; algorithmic design can occur, too. However, for CRAB a 'dressed' version has; recently been introduced [Rach15]_ that allows to escape local minima. For some control objectives and/or dynamical quantum descriptions, it is either; not possible to derive the gradient for the cost functional with respect to; each time slice or it is computationally expensive to do so. The same can apply; for the necessary (reverse) propagation of the co-state. All this trouble does; not occur within CRAB as those elements are not in use here. CRAB, instead,; takes the time evolution as a black-box where the pulse goes as an input and; the cost (e.g. infidelity) value will be returned as an output. This concept,; on top, all",MatchSource.DOCS,doc/guide/guide-control.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-control.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-control.rst:12187,Integrability,integrat,integration,12187,".). By doing so, this; algorithm allows for native integration of experimental constraints such as; maximum frequencies allowed, maximum amplitude, smooth ramping up and down of; the pulse and many more. Moreover initial guesses, if they are available, can; (however not have to) be included to speed up convergence. As mentioned in the GRAPE paragraph, for CRAB local minima arising from; algorithmic design can occur, too. However, for CRAB a 'dressed' version has; recently been introduced [Rach15]_ that allows to escape local minima. For some control objectives and/or dynamical quantum descriptions, it is either; not possible to derive the gradient for the cost functional with respect to; each time slice or it is computationally expensive to do so. The same can apply; for the necessary (reverse) propagation of the co-state. All this trouble does; not occur within CRAB as those elements are not in use here. CRAB, instead,; takes the time evolution as a black-box where the pulse goes as an input and; the cost (e.g. infidelity) value will be returned as an output. This concept,; on top, allows for direct integration in a closed loop experimental environment; where both the preliminarily open loop optimization, as well as the final; adoption, and integration to the lab (to account for modeling errors,; experimental systematic noise, ...) can be done all in one, using this; algorithm. Optimal Quantum Control in QuTiP; ================================. The Quantum Control part of qutip has been moved to its own project. The previously available implementation is now located in the `qutip-qtrl <https://qutip-qtrl.readthedocs.io/en/stable/>`_ module. If the ``qutip-qtrl`` package is installed, it can also be imported under the name ``qutip.control`` to ease porting code developed for QuTiP 4 to QuTiP 5. A newer interface with upgraded capacities is being developped in `qutip-qoc <https://github.com/flowerthrower/qutip-qoc/tree/packaging>`_. Please give these modules a try.; ",MatchSource.DOCS,doc/guide/guide-control.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-control.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-control.rst:12331,Integrability,integrat,integration,12331,".). By doing so, this; algorithm allows for native integration of experimental constraints such as; maximum frequencies allowed, maximum amplitude, smooth ramping up and down of; the pulse and many more. Moreover initial guesses, if they are available, can; (however not have to) be included to speed up convergence. As mentioned in the GRAPE paragraph, for CRAB local minima arising from; algorithmic design can occur, too. However, for CRAB a 'dressed' version has; recently been introduced [Rach15]_ that allows to escape local minima. For some control objectives and/or dynamical quantum descriptions, it is either; not possible to derive the gradient for the cost functional with respect to; each time slice or it is computationally expensive to do so. The same can apply; for the necessary (reverse) propagation of the co-state. All this trouble does; not occur within CRAB as those elements are not in use here. CRAB, instead,; takes the time evolution as a black-box where the pulse goes as an input and; the cost (e.g. infidelity) value will be returned as an output. This concept,; on top, allows for direct integration in a closed loop experimental environment; where both the preliminarily open loop optimization, as well as the final; adoption, and integration to the lab (to account for modeling errors,; experimental systematic noise, ...) can be done all in one, using this; algorithm. Optimal Quantum Control in QuTiP; ================================. The Quantum Control part of qutip has been moved to its own project. The previously available implementation is now located in the `qutip-qtrl <https://qutip-qtrl.readthedocs.io/en/stable/>`_ module. If the ``qutip-qtrl`` package is installed, it can also be imported under the name ``qutip.control`` to ease porting code developed for QuTiP 4 to QuTiP 5. A newer interface with upgraded capacities is being developped in `qutip-qoc <https://github.com/flowerthrower/qutip-qoc/tree/packaging>`_. Please give these modules a try.; ",MatchSource.DOCS,doc/guide/guide-control.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-control.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-control.rst:12903,Integrability,interface,interface,12903,".). By doing so, this; algorithm allows for native integration of experimental constraints such as; maximum frequencies allowed, maximum amplitude, smooth ramping up and down of; the pulse and many more. Moreover initial guesses, if they are available, can; (however not have to) be included to speed up convergence. As mentioned in the GRAPE paragraph, for CRAB local minima arising from; algorithmic design can occur, too. However, for CRAB a 'dressed' version has; recently been introduced [Rach15]_ that allows to escape local minima. For some control objectives and/or dynamical quantum descriptions, it is either; not possible to derive the gradient for the cost functional with respect to; each time slice or it is computationally expensive to do so. The same can apply; for the necessary (reverse) propagation of the co-state. All this trouble does; not occur within CRAB as those elements are not in use here. CRAB, instead,; takes the time evolution as a black-box where the pulse goes as an input and; the cost (e.g. infidelity) value will be returned as an output. This concept,; on top, allows for direct integration in a closed loop experimental environment; where both the preliminarily open loop optimization, as well as the final; adoption, and integration to the lab (to account for modeling errors,; experimental systematic noise, ...) can be done all in one, using this; algorithm. Optimal Quantum Control in QuTiP; ================================. The Quantum Control part of qutip has been moved to its own project. The previously available implementation is now located in the `qutip-qtrl <https://qutip-qtrl.readthedocs.io/en/stable/>`_ module. If the ``qutip-qtrl`` package is installed, it can also be imported under the name ``qutip.control`` to ease porting code developed for QuTiP 4 to QuTiP 5. A newer interface with upgraded capacities is being developped in `qutip-qoc <https://github.com/flowerthrower/qutip-qoc/tree/packaging>`_. Please give these modules a try.; ",MatchSource.DOCS,doc/guide/guide-control.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-control.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-control.rst:3785,Modifiability,evolve,evolve,3785,"s. :math:`U(t)` is a solution to the *Schrdinger operator equation*. .. math::. \tfrac{d}{dt}U = -i H(t)U ,\quad U(0) = \mathbb{1}. We can use optimal control algorithms to determine a set of :math:`u_j` that will drive our system from :math:`\ket{\psi_0}` to :math:`\ket{\psi_1}`, this is state-to-state transfer, or drive the system from some arbitary state to a given state :math:`\ket{\psi_1}`, which is state preparation, or effect some unitary transformation :math:`U_{target}`, called gate synthesis. The latter of these is most important in quantum computation. The GRAPE algorithm; ===================; The **GR**\ adient **A**\ scent **P**\ ulse **E**\ ngineering was first proposed in [NKanej]_. Solutions to Schrdinger's equation for a time-dependent Hamiltonian are not generally possible to obtain analytically. Therefore, a piecewise constant approximation to the pulse amplitudes is made. Time allowed for the system to evolve :math:`T` is split into :math:`M` timeslots (typically these are of equal duration), during which the control amplitude is assumed to remain constant. The combined Hamiltonian can then be approximated as:. .. math::. H(t) \approx H(t_k) = H_0 + \sum_{j=1}^N u_{jk} H_j\quad. where :math:`k` is a timeslot index, :math:`j` is the control index, and :math:`N` is the number of controls. Hence :math:`t_k` is the evolution time at the start of the timeslot, and :math:`u_{jk}` is the amplitude of control :math:`j` throughout timeslot :math:`k`. The time evolution operator, or propagator, within the timeslot can then be calculated as:. .. math::. X_k:=e^{-iH(t_k)\Delta t_k}. where :math:`\Delta t_k` is the duration of the timeslot. The evolution up to (and including) any timeslot :math:`k` (including the full evolution :math:`k=M`) can the be calculated as. .. math::. X(t_k):=X_k X_{k-1}\cdots X_1 X_0. If the objective is state-to-state transfer then :math:`X_0=\ket{\psi_0}` and the target :math:`X_{targ}=\ket{\psi_1}`, for gate synthesis :math:`X_0",MatchSource.DOCS,doc/guide/guide-control.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-control.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-control.rst:5634,Modifiability,variab,variables,5634,"fer then :math:`X_0=\ket{\psi_0}` and the target :math:`X_{targ}=\ket{\psi_1}`, for gate synthesis :math:`X_0 = U(0) = \mathbb{1}` and the target :math:`X_{targ}=U_{targ}`. A *figure of merit* or *fidelity* is some measure of how close the evolution is to the target, based on the control amplitudes in the timeslots. The typical figure of merit for unitary systems is the normalised overlap of the evolution and the target. .. math::. f_{PSU} = \tfrac{1}{d} \big| \tr \{X_{targ}^{\dagger} X(T)\} \big|. where :math:`d` is the system dimension. In this figure of merit the absolute value is taken to ignore any differences in global phase, and :math:`0 \le f \le 1`. Typically the fidelity error (or *infidelity*) is more useful, in this case defined as :math:`\varepsilon = 1 - f_{PSU}`. There are many other possible objectives, and hence figures of merit. As there are now :math:`N \times M` variables (the :math:`u_{jk}`) and one; parameter to minimise :math:`\varepsilon`, then the problem becomes a finite; multi-variable optimisation problem, for which there are many established; methods, often referred to as 'hill-climbing' methods. The simplest of these to; understand is that of steepest ascent (or descent). The gradient of the; fidelity with respect to all the variables is calculated (or approximated) and; a step is made in the variable space in the direction of steepest ascent (or; descent). This method is a first order gradient method. In two dimensions this; describes a method of climbing a hill by heading in the direction where the; ground rises fastest. This analogy also clearly illustrates one of the main; challenges in multi-variable optimisation, which is that all methods have a; tendency to get stuck in local maxima. It is hard to determine whether one has; found a global maximum or not - a local peak is likely not to be the highest; mountain in the region. In quantum optimal control we can typically define an; infidelity that has a lower bound of zero. We can th",MatchSource.DOCS,doc/guide/guide-control.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-control.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-control.rst:5758,Modifiability,variab,variable,5758,"fer then :math:`X_0=\ket{\psi_0}` and the target :math:`X_{targ}=\ket{\psi_1}`, for gate synthesis :math:`X_0 = U(0) = \mathbb{1}` and the target :math:`X_{targ}=U_{targ}`. A *figure of merit* or *fidelity* is some measure of how close the evolution is to the target, based on the control amplitudes in the timeslots. The typical figure of merit for unitary systems is the normalised overlap of the evolution and the target. .. math::. f_{PSU} = \tfrac{1}{d} \big| \tr \{X_{targ}^{\dagger} X(T)\} \big|. where :math:`d` is the system dimension. In this figure of merit the absolute value is taken to ignore any differences in global phase, and :math:`0 \le f \le 1`. Typically the fidelity error (or *infidelity*) is more useful, in this case defined as :math:`\varepsilon = 1 - f_{PSU}`. There are many other possible objectives, and hence figures of merit. As there are now :math:`N \times M` variables (the :math:`u_{jk}`) and one; parameter to minimise :math:`\varepsilon`, then the problem becomes a finite; multi-variable optimisation problem, for which there are many established; methods, often referred to as 'hill-climbing' methods. The simplest of these to; understand is that of steepest ascent (or descent). The gradient of the; fidelity with respect to all the variables is calculated (or approximated) and; a step is made in the variable space in the direction of steepest ascent (or; descent). This method is a first order gradient method. In two dimensions this; describes a method of climbing a hill by heading in the direction where the; ground rises fastest. This analogy also clearly illustrates one of the main; challenges in multi-variable optimisation, which is that all methods have a; tendency to get stuck in local maxima. It is hard to determine whether one has; found a global maximum or not - a local peak is likely not to be the highest; mountain in the region. In quantum optimal control we can typically define an; infidelity that has a lower bound of zero. We can th",MatchSource.DOCS,doc/guide/guide-control.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-control.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-control.rst:6014,Modifiability,variab,variables,6014,"ts. The typical figure of merit for unitary systems is the normalised overlap of the evolution and the target. .. math::. f_{PSU} = \tfrac{1}{d} \big| \tr \{X_{targ}^{\dagger} X(T)\} \big|. where :math:`d` is the system dimension. In this figure of merit the absolute value is taken to ignore any differences in global phase, and :math:`0 \le f \le 1`. Typically the fidelity error (or *infidelity*) is more useful, in this case defined as :math:`\varepsilon = 1 - f_{PSU}`. There are many other possible objectives, and hence figures of merit. As there are now :math:`N \times M` variables (the :math:`u_{jk}`) and one; parameter to minimise :math:`\varepsilon`, then the problem becomes a finite; multi-variable optimisation problem, for which there are many established; methods, often referred to as 'hill-climbing' methods. The simplest of these to; understand is that of steepest ascent (or descent). The gradient of the; fidelity with respect to all the variables is calculated (or approximated) and; a step is made in the variable space in the direction of steepest ascent (or; descent). This method is a first order gradient method. In two dimensions this; describes a method of climbing a hill by heading in the direction where the; ground rises fastest. This analogy also clearly illustrates one of the main; challenges in multi-variable optimisation, which is that all methods have a; tendency to get stuck in local maxima. It is hard to determine whether one has; found a global maximum or not - a local peak is likely not to be the highest; mountain in the region. In quantum optimal control we can typically define an; infidelity that has a lower bound of zero. We can then look to minimise the; infidelity (from here on we will only consider optimising for infidelity; minima). This means that we can terminate any pulse optimisation when the; infidelity reaches zero (to a sufficient precision). This is however only; possible for fully controllable systems; otherwise it is hard (if ",MatchSource.DOCS,doc/guide/guide-control.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-control.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-control.rst:6083,Modifiability,variab,variable,6083,"ts. The typical figure of merit for unitary systems is the normalised overlap of the evolution and the target. .. math::. f_{PSU} = \tfrac{1}{d} \big| \tr \{X_{targ}^{\dagger} X(T)\} \big|. where :math:`d` is the system dimension. In this figure of merit the absolute value is taken to ignore any differences in global phase, and :math:`0 \le f \le 1`. Typically the fidelity error (or *infidelity*) is more useful, in this case defined as :math:`\varepsilon = 1 - f_{PSU}`. There are many other possible objectives, and hence figures of merit. As there are now :math:`N \times M` variables (the :math:`u_{jk}`) and one; parameter to minimise :math:`\varepsilon`, then the problem becomes a finite; multi-variable optimisation problem, for which there are many established; methods, often referred to as 'hill-climbing' methods. The simplest of these to; understand is that of steepest ascent (or descent). The gradient of the; fidelity with respect to all the variables is calculated (or approximated) and; a step is made in the variable space in the direction of steepest ascent (or; descent). This method is a first order gradient method. In two dimensions this; describes a method of climbing a hill by heading in the direction where the; ground rises fastest. This analogy also clearly illustrates one of the main; challenges in multi-variable optimisation, which is that all methods have a; tendency to get stuck in local maxima. It is hard to determine whether one has; found a global maximum or not - a local peak is likely not to be the highest; mountain in the region. In quantum optimal control we can typically define an; infidelity that has a lower bound of zero. We can then look to minimise the; infidelity (from here on we will only consider optimising for infidelity; minima). This means that we can terminate any pulse optimisation when the; infidelity reaches zero (to a sufficient precision). This is however only; possible for fully controllable systems; otherwise it is hard (if ",MatchSource.DOCS,doc/guide/guide-control.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-control.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-control.rst:6393,Modifiability,variab,variable,6393,"1`. Typically the fidelity error (or *infidelity*) is more useful, in this case defined as :math:`\varepsilon = 1 - f_{PSU}`. There are many other possible objectives, and hence figures of merit. As there are now :math:`N \times M` variables (the :math:`u_{jk}`) and one; parameter to minimise :math:`\varepsilon`, then the problem becomes a finite; multi-variable optimisation problem, for which there are many established; methods, often referred to as 'hill-climbing' methods. The simplest of these to; understand is that of steepest ascent (or descent). The gradient of the; fidelity with respect to all the variables is calculated (or approximated) and; a step is made in the variable space in the direction of steepest ascent (or; descent). This method is a first order gradient method. In two dimensions this; describes a method of climbing a hill by heading in the direction where the; ground rises fastest. This analogy also clearly illustrates one of the main; challenges in multi-variable optimisation, which is that all methods have a; tendency to get stuck in local maxima. It is hard to determine whether one has; found a global maximum or not - a local peak is likely not to be the highest; mountain in the region. In quantum optimal control we can typically define an; infidelity that has a lower bound of zero. We can then look to minimise the; infidelity (from here on we will only consider optimising for infidelity; minima). This means that we can terminate any pulse optimisation when the; infidelity reaches zero (to a sufficient precision). This is however only; possible for fully controllable systems; otherwise it is hard (if not; impossible) to know that the minimum possible infidelity has been achieved. In; the hill walking analogy the step size is roughly fixed to a stride, however,; in computations the step size must be chosen. Clearly there is a trade-off here; between the number of steps (or iterations) required to reach the minima and; the possibility that we mi",MatchSource.DOCS,doc/guide/guide-control.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-control.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-control.rst:7576,Modifiability,variab,variables,7576," likely not to be the highest; mountain in the region. In quantum optimal control we can typically define an; infidelity that has a lower bound of zero. We can then look to minimise the; infidelity (from here on we will only consider optimising for infidelity; minima). This means that we can terminate any pulse optimisation when the; infidelity reaches zero (to a sufficient precision). This is however only; possible for fully controllable systems; otherwise it is hard (if not; impossible) to know that the minimum possible infidelity has been achieved. In; the hill walking analogy the step size is roughly fixed to a stride, however,; in computations the step size must be chosen. Clearly there is a trade-off here; between the number of steps (or iterations) required to reach the minima and; the possibility that we might step over a minima. In practice it is difficult; to determine an efficient and effective step size. The second order differentials of the infidelity with respect to the variables; can be used to approximate the local landscape to a parabola. This way a step; (or jump) can be made to where the minima would be if it were parabolic. This; typically vastly reduces the number of iterations, and removes the need to; guess a step size. The method where all the second differentials are calculated; explicitly is called the *Newton-Raphson* method. However, calculating the; second-order differentials (the Hessian matrix) can be computationally; expensive, and so there are a class of methods known as *quasi-Newton* that; approximate the Hessian based on successive iterations. The most popular of; these (in quantum optimal control) is the BroydenFletcherGoldfarbShanno; algorithm (BFGS). The default method in the QuTiP Qtrl GRAPE implementation is; the L-BFGS-B method in Scipy, which is a wrapper to the implementation; described in [Byrd95]_. This limited memory and bounded method does not need to; store the entire Hessian, which reduces the computer memory requ",MatchSource.DOCS,doc/guide/guide-control.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-control.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-control.rst:8616,Modifiability,variab,variable,8616,"variables; can be used to approximate the local landscape to a parabola. This way a step; (or jump) can be made to where the minima would be if it were parabolic. This; typically vastly reduces the number of iterations, and removes the need to; guess a step size. The method where all the second differentials are calculated; explicitly is called the *Newton-Raphson* method. However, calculating the; second-order differentials (the Hessian matrix) can be computationally; expensive, and so there are a class of methods known as *quasi-Newton* that; approximate the Hessian based on successive iterations. The most popular of; these (in quantum optimal control) is the BroydenFletcherGoldfarbShanno; algorithm (BFGS). The default method in the QuTiP Qtrl GRAPE implementation is; the L-BFGS-B method in Scipy, which is a wrapper to the implementation; described in [Byrd95]_. This limited memory and bounded method does not need to; store the entire Hessian, which reduces the computer memory required, and; allows bounds to be set for variable values, which considering these are field; amplitudes is often physical. The pulse optimisation is typically far more efficient if the gradients can be; calculated exactly, rather than approximated. For simple fidelity measures such; as :math:`f_{PSU}` this is possible. Firstly the propagator gradient for each; timeslot with respect to the control amplitudes is calculated. For closed; systems, with unitary dynamics, a method using the eigendecomposition is used,; which is efficient as it is also used in the propagator calculation (to; exponentiate the combined Hamiltonian). More generally (for example open; systems and symplectic dynamics) the Frechet derivative (or augmented matrix); method is used, which is described in [Flo12]_. For other optimisation goals it; may not be possible to calculate analytic gradients. In these cases it is; necessary to approximate the gradients, but this can be very expensive, and can; lead to other algori",MatchSource.DOCS,doc/guide/guide-control.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-control.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-control.rst:9585,Performance,perform,performing,9585,"re Hessian, which reduces the computer memory required, and; allows bounds to be set for variable values, which considering these are field; amplitudes is often physical. The pulse optimisation is typically far more efficient if the gradients can be; calculated exactly, rather than approximated. For simple fidelity measures such; as :math:`f_{PSU}` this is possible. Firstly the propagator gradient for each; timeslot with respect to the control amplitudes is calculated. For closed; systems, with unitary dynamics, a method using the eigendecomposition is used,; which is efficient as it is also used in the propagator calculation (to; exponentiate the combined Hamiltonian). More generally (for example open; systems and symplectic dynamics) the Frechet derivative (or augmented matrix); method is used, which is described in [Flo12]_. For other optimisation goals it; may not be possible to calculate analytic gradients. In these cases it is; necessary to approximate the gradients, but this can be very expensive, and can; lead to other algorithms out-performing GRAPE. The CRAB Algorithm; ===================; It has been shown [Lloyd14]_, the dimension of a quantum optimal control; problem is a polynomial function of the dimension of the manifold of the; time-polynomial reachable states, when allowing for a finite control precision; and evolution time. You can think of this as the information content of the; pulse (as being the only effective input) being very limited e.g. the pulse is; compressible to a few bytes without loosing the target. This is where the **C**\ hopped **RA**\ ndom **B**\ asis (CRAB) algorithm; [Doria11]_, [Caneva11]_ comes into play: Since the pulse complexity is usually; very low, it is sufficient to transform the optimal control problem to a few; parameter search by introducing a physically motivated function basis that; builds up the pulse. Compared to the number of time slices needed to accurately; simulate quantum dynamics (often equals basis dimens",MatchSource.DOCS,doc/guide/guide-control.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-control.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-control.rst:10639,Performance,optimiz,optimize,10639,"ad to other algorithms out-performing GRAPE. The CRAB Algorithm; ===================; It has been shown [Lloyd14]_, the dimension of a quantum optimal control; problem is a polynomial function of the dimension of the manifold of the; time-polynomial reachable states, when allowing for a finite control precision; and evolution time. You can think of this as the information content of the; pulse (as being the only effective input) being very limited e.g. the pulse is; compressible to a few bytes without loosing the target. This is where the **C**\ hopped **RA**\ ndom **B**\ asis (CRAB) algorithm; [Doria11]_, [Caneva11]_ comes into play: Since the pulse complexity is usually; very low, it is sufficient to transform the optimal control problem to a few; parameter search by introducing a physically motivated function basis that; builds up the pulse. Compared to the number of time slices needed to accurately; simulate quantum dynamics (often equals basis dimension for Gradient based; algorithms), this number is lower by orders of magnitude, allowing CRAB to; efficiently optimize smooth pulses with realistic experimental constraints. It; is important to point out, that CRAB does not make any suggestion on the basis; function to be used. The basis must be chosen carefully considered, taking into; account a priori knowledge of the system (such as symmetries, magnitudes of; scales,...) and solution (e.g. sign, smoothness, bang-bang behavior,; singularities, maximum excursion or rate of change,....). By doing so, this; algorithm allows for native integration of experimental constraints such as; maximum frequencies allowed, maximum amplitude, smooth ramping up and down of; the pulse and many more. Moreover initial guesses, if they are available, can; (however not have to) be included to speed up convergence. As mentioned in the GRAPE paragraph, for CRAB local minima arising from; algorithmic design can occur, too. However, for CRAB a 'dressed' version has; recently been introdu",MatchSource.DOCS,doc/guide/guide-control.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-control.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-control.rst:12281,Performance,optimiz,optimization,12281,".). By doing so, this; algorithm allows for native integration of experimental constraints such as; maximum frequencies allowed, maximum amplitude, smooth ramping up and down of; the pulse and many more. Moreover initial guesses, if they are available, can; (however not have to) be included to speed up convergence. As mentioned in the GRAPE paragraph, for CRAB local minima arising from; algorithmic design can occur, too. However, for CRAB a 'dressed' version has; recently been introduced [Rach15]_ that allows to escape local minima. For some control objectives and/or dynamical quantum descriptions, it is either; not possible to derive the gradient for the cost functional with respect to; each time slice or it is computationally expensive to do so. The same can apply; for the necessary (reverse) propagation of the co-state. All this trouble does; not occur within CRAB as those elements are not in use here. CRAB, instead,; takes the time evolution as a black-box where the pulse goes as an input and; the cost (e.g. infidelity) value will be returned as an output. This concept,; on top, allows for direct integration in a closed loop experimental environment; where both the preliminarily open loop optimization, as well as the final; adoption, and integration to the lab (to account for modeling errors,; experimental systematic noise, ...) can be done all in one, using this; algorithm. Optimal Quantum Control in QuTiP; ================================. The Quantum Control part of qutip has been moved to its own project. The previously available implementation is now located in the `qutip-qtrl <https://qutip-qtrl.readthedocs.io/en/stable/>`_ module. If the ``qutip-qtrl`` package is installed, it can also be imported under the name ``qutip.control`` to ease porting code developed for QuTiP 4 to QuTiP 5. A newer interface with upgraded capacities is being developped in `qutip-qoc <https://github.com/flowerthrower/qutip-qoc/tree/packaging>`_. Please give these modules a try.; ",MatchSource.DOCS,doc/guide/guide-control.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-control.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-control.rst:5886,Usability,simpl,simplest,5886,"e of merit* or *fidelity* is some measure of how close the evolution is to the target, based on the control amplitudes in the timeslots. The typical figure of merit for unitary systems is the normalised overlap of the evolution and the target. .. math::. f_{PSU} = \tfrac{1}{d} \big| \tr \{X_{targ}^{\dagger} X(T)\} \big|. where :math:`d` is the system dimension. In this figure of merit the absolute value is taken to ignore any differences in global phase, and :math:`0 \le f \le 1`. Typically the fidelity error (or *infidelity*) is more useful, in this case defined as :math:`\varepsilon = 1 - f_{PSU}`. There are many other possible objectives, and hence figures of merit. As there are now :math:`N \times M` variables (the :math:`u_{jk}`) and one; parameter to minimise :math:`\varepsilon`, then the problem becomes a finite; multi-variable optimisation problem, for which there are many established; methods, often referred to as 'hill-climbing' methods. The simplest of these to; understand is that of steepest ascent (or descent). The gradient of the; fidelity with respect to all the variables is calculated (or approximated) and; a step is made in the variable space in the direction of steepest ascent (or; descent). This method is a first order gradient method. In two dimensions this; describes a method of climbing a hill by heading in the direction where the; ground rises fastest. This analogy also clearly illustrates one of the main; challenges in multi-variable optimisation, which is that all methods have a; tendency to get stuck in local maxima. It is hard to determine whether one has; found a global maximum or not - a local peak is likely not to be the highest; mountain in the region. In quantum optimal control we can typically define an; infidelity that has a lower bound of zero. We can then look to minimise the; infidelity (from here on we will only consider optimising for infidelity; minima). This means that we can terminate any pulse optimisation when the; infidel",MatchSource.DOCS,doc/guide/guide-control.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-control.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-control.rst:6336,Usability,clear,clearly,6336,"1`. Typically the fidelity error (or *infidelity*) is more useful, in this case defined as :math:`\varepsilon = 1 - f_{PSU}`. There are many other possible objectives, and hence figures of merit. As there are now :math:`N \times M` variables (the :math:`u_{jk}`) and one; parameter to minimise :math:`\varepsilon`, then the problem becomes a finite; multi-variable optimisation problem, for which there are many established; methods, often referred to as 'hill-climbing' methods. The simplest of these to; understand is that of steepest ascent (or descent). The gradient of the; fidelity with respect to all the variables is calculated (or approximated) and; a step is made in the variable space in the direction of steepest ascent (or; descent). This method is a first order gradient method. In two dimensions this; describes a method of climbing a hill by heading in the direction where the; ground rises fastest. This analogy also clearly illustrates one of the main; challenges in multi-variable optimisation, which is that all methods have a; tendency to get stuck in local maxima. It is hard to determine whether one has; found a global maximum or not - a local peak is likely not to be the highest; mountain in the region. In quantum optimal control we can typically define an; infidelity that has a lower bound of zero. We can then look to minimise the; infidelity (from here on we will only consider optimising for infidelity; minima). This means that we can terminate any pulse optimisation when the; infidelity reaches zero (to a sufficient precision). This is however only; possible for fully controllable systems; otherwise it is hard (if not; impossible) to know that the minimum possible infidelity has been achieved. In; the hill walking analogy the step size is roughly fixed to a stride, however,; in computations the step size must be chosen. Clearly there is a trade-off here; between the number of steps (or iterations) required to reach the minima and; the possibility that we mi",MatchSource.DOCS,doc/guide/guide-control.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-control.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-control.rst:8828,Usability,simpl,simple,8828,"l the second differentials are calculated; explicitly is called the *Newton-Raphson* method. However, calculating the; second-order differentials (the Hessian matrix) can be computationally; expensive, and so there are a class of methods known as *quasi-Newton* that; approximate the Hessian based on successive iterations. The most popular of; these (in quantum optimal control) is the BroydenFletcherGoldfarbShanno; algorithm (BFGS). The default method in the QuTiP Qtrl GRAPE implementation is; the L-BFGS-B method in Scipy, which is a wrapper to the implementation; described in [Byrd95]_. This limited memory and bounded method does not need to; store the entire Hessian, which reduces the computer memory required, and; allows bounds to be set for variable values, which considering these are field; amplitudes is often physical. The pulse optimisation is typically far more efficient if the gradients can be; calculated exactly, rather than approximated. For simple fidelity measures such; as :math:`f_{PSU}` this is possible. Firstly the propagator gradient for each; timeslot with respect to the control amplitudes is calculated. For closed; systems, with unitary dynamics, a method using the eigendecomposition is used,; which is efficient as it is also used in the propagator calculation (to; exponentiate the combined Hamiltonian). More generally (for example open; systems and symplectic dynamics) the Frechet derivative (or augmented matrix); method is used, which is described in [Flo12]_. For other optimisation goals it; may not be possible to calculate analytic gradients. In these cases it is; necessary to approximate the gradients, but this can be very expensive, and can; lead to other algorithms out-performing GRAPE. The CRAB Algorithm; ===================; It has been shown [Lloyd14]_, the dimension of a quantum optimal control; problem is a polynomial function of the dimension of the manifold of the; time-polynomial reachable states, when allowing for a finite contro",MatchSource.DOCS,doc/guide/guide-control.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-control.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-correlation.rst:1759,Availability,avail,available,1759,"t> = {\rm Tr}\left[A V(t+\tau, t)\left\{B\rho(t)\right\}\right]; = {\rm Tr}\left[A V(t+\tau, t)\left\{BV(t, 0)\left\{\rho(0)\right\}\right\}\right]. We therefore first calculate :math:`\rho(t)=V(t, 0)\left\{\rho(0)\right\}` using one of the QuTiP evolution solvers with :math:`\rho(0)` as initial state, and then again use the same solver to calculate :math:`V(t+\tau, t)\left\{B\rho(t)\right\}` using :math:`B\rho(t)` as initial state. Note that if the initial state is the steady state, then :math:`\rho(t)=V(t, 0)\left\{\rho_{\rm ss}\right\}=\rho_{\rm ss}` and. .. math::. \left<A(t+\tau)B(t)\right> = {\rm Tr}\left[A V(t+\tau, t)\left\{B\rho_{\rm ss}\right\}\right]; = {\rm Tr}\left[A V(\tau, 0)\left\{B\rho_{\rm ss}\right\}\right] = \left<A(\tau)B(0)\right>,. which is independent of :math:`t`, so that we only have one time coordinate :math:`\tau`. QuTiP provides a family of functions that assists in the process of calculating two-time correlation functions. The available functions and their usage is shown in the table below. Each of these functions can use one of the following evolution solvers: Master-equation, Exponential series and the Monte-Carlo. The choice of solver is defined by the optional argument ``solver``. .. cssclass:: table-striped. +----------------------------------+--------------------------------------------------+; | QuTiP function | Correlation function |; +==================================+==================================================+; | | :math:`\left<A(t+\tau)B(t)\right>` or |; | :func:`qutip.correlation_2op_2t` | :math:`\left<A(t)B(t+\tau)\right>`. |; +----------------------------------+--------------------------------------------------+; | | :math:`\left<A(\tau)B(0)\right>` or |; | :func:`qutip.correlation_2op_1t` | :math:`\left<A(0)B(\tau)\right>`. |; +----------------------------------+--------------------------------------------------+; | :func:`qutip.correlation_3op_1t` | :math:`\left<A(0)B(\tau)C(0)\right>`. |; +----------------------",MatchSource.DOCS,doc/guide/guide-correlation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-correlation.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-correlation.rst:4615,Energy Efficiency,power,power,4615,"two times. Most importantly, this function accepts alternative solvers such as :func:`.brmesolve`. .. _correlation-steady:. Steadystate correlation function; ================================. The following code demonstrates how to calculate the :math:`\left<x(t)x(0)\right>` correlation for a leaky cavity with three different relaxation rates. .. plot::; :context: close-figs. times = np.linspace(0,10.0,200); a = destroy(10); x = a.dag() + a; H = a.dag() * a. corr1 = correlation_2op_1t(H, None, times, [np.sqrt(0.5) * a], x, x); corr2 = correlation_2op_1t(H, None, times, [np.sqrt(1.0) * a], x, x); corr3 = correlation_2op_1t(H, None, times, [np.sqrt(2.0) * a], x, x). plt.figure(); plt.plot(times, np.real(corr1)); plt.plot(times, np.real(corr2)); plt.plot(times, np.real(corr3)); plt.legend(['0.5','1.0','2.0']); plt.xlabel(r'Time $t$'); plt.ylabel(r'Correlation $\left<x(t)x(0)\right>$'); plt.show(). Emission spectrum; =================. Given a correlation function :math:`\left<A(\tau)B(0)\right>` we can define the corresponding power spectrum as. .. math::. S(\omega) = \int_{-\infty}^{\infty} \left<A(\tau)B(0)\right> e^{-i\omega\tau} d\tau. In QuTiP, we can calculate :math:`S(\omega)` using either :func:`.spectrum`, which first calculates the correlation function using one of the time-dependent solvers and then performs the Fourier transform semi-analytically, or we can use the function :func:`.spectrum_correlation_fft` to numerically calculate the Fourier transform of a given correlation data using FFT. The following example demonstrates how these two functions can be used to obtain the emission power spectrum. .. plot:: guide/scripts/spectrum_ex1.py; :width: 5.0in; :include-source:. .. _correlation-spectrum:. Non-steadystate correlation function; ====================================. More generally, we can also calculate correlation functions of the kind :math:`\left<A(t_1+t_2)B(t_1)\right>`, i.e., the correlation function of a system that is not in its steady state. In",MatchSource.DOCS,doc/guide/guide-correlation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-correlation.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-correlation.rst:5195,Energy Efficiency,power,power,5195,"sqrt(1.0) * a], x, x); corr3 = correlation_2op_1t(H, None, times, [np.sqrt(2.0) * a], x, x). plt.figure(); plt.plot(times, np.real(corr1)); plt.plot(times, np.real(corr2)); plt.plot(times, np.real(corr3)); plt.legend(['0.5','1.0','2.0']); plt.xlabel(r'Time $t$'); plt.ylabel(r'Correlation $\left<x(t)x(0)\right>$'); plt.show(). Emission spectrum; =================. Given a correlation function :math:`\left<A(\tau)B(0)\right>` we can define the corresponding power spectrum as. .. math::. S(\omega) = \int_{-\infty}^{\infty} \left<A(\tau)B(0)\right> e^{-i\omega\tau} d\tau. In QuTiP, we can calculate :math:`S(\omega)` using either :func:`.spectrum`, which first calculates the correlation function using one of the time-dependent solvers and then performs the Fourier transform semi-analytically, or we can use the function :func:`.spectrum_correlation_fft` to numerically calculate the Fourier transform of a given correlation data using FFT. The following example demonstrates how these two functions can be used to obtain the emission power spectrum. .. plot:: guide/scripts/spectrum_ex1.py; :width: 5.0in; :include-source:. .. _correlation-spectrum:. Non-steadystate correlation function; ====================================. More generally, we can also calculate correlation functions of the kind :math:`\left<A(t_1+t_2)B(t_1)\right>`, i.e., the correlation function of a system that is not in its steady state. In QuTiP, we can evaluate such correlation functions using the function :func:`.correlation_2op_2t`. The default behavior of this function is to return a matrix with the correlations as a function of the two time coordinates (:math:`t_1` and :math:`t_2`). .. plot:: guide/scripts/correlation_ex2.py; :width: 5.0in; :include-source:. However, in some cases we might be interested in the correlation functions on the form :math:`\left<A(t_1+t_2)B(t_1)\right>`, but only as a function of time coordinate :math:`t_2`. In this case we can also use the :func:`.correlation_2op_2t` funct",MatchSource.DOCS,doc/guide/guide-correlation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-correlation.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-correlation.rst:4877,Integrability,depend,dependent,4877," different relaxation rates. .. plot::; :context: close-figs. times = np.linspace(0,10.0,200); a = destroy(10); x = a.dag() + a; H = a.dag() * a. corr1 = correlation_2op_1t(H, None, times, [np.sqrt(0.5) * a], x, x); corr2 = correlation_2op_1t(H, None, times, [np.sqrt(1.0) * a], x, x); corr3 = correlation_2op_1t(H, None, times, [np.sqrt(2.0) * a], x, x). plt.figure(); plt.plot(times, np.real(corr1)); plt.plot(times, np.real(corr2)); plt.plot(times, np.real(corr3)); plt.legend(['0.5','1.0','2.0']); plt.xlabel(r'Time $t$'); plt.ylabel(r'Correlation $\left<x(t)x(0)\right>$'); plt.show(). Emission spectrum; =================. Given a correlation function :math:`\left<A(\tau)B(0)\right>` we can define the corresponding power spectrum as. .. math::. S(\omega) = \int_{-\infty}^{\infty} \left<A(\tau)B(0)\right> e^{-i\omega\tau} d\tau. In QuTiP, we can calculate :math:`S(\omega)` using either :func:`.spectrum`, which first calculates the correlation function using one of the time-dependent solvers and then performs the Fourier transform semi-analytically, or we can use the function :func:`.spectrum_correlation_fft` to numerically calculate the Fourier transform of a given correlation data using FFT. The following example demonstrates how these two functions can be used to obtain the emission power spectrum. .. plot:: guide/scripts/spectrum_ex1.py; :width: 5.0in; :include-source:. .. _correlation-spectrum:. Non-steadystate correlation function; ====================================. More generally, we can also calculate correlation functions of the kind :math:`\left<A(t_1+t_2)B(t_1)\right>`, i.e., the correlation function of a system that is not in its steady state. In QuTiP, we can evaluate such correlation functions using the function :func:`.correlation_2op_2t`. The default behavior of this function is to return a matrix with the correlations as a function of the two time coordinates (:math:`t_1` and :math:`t_2`). .. plot:: guide/scripts/correlation_ex2.py; :width: 5.0in; :in",MatchSource.DOCS,doc/guide/guide-correlation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-correlation.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-correlation.rst:247,Modifiability,evolve,evolved,247,".. _correlation:. ******************************; Two-time correlation functions; ******************************. With the QuTiP time-evolution functions (for example :func:`.mesolve` and :func:`.mcsolve`), a state vector or density matrix can be evolved from an initial state at :math:`t_0` to an arbitrary time :math:`t`, :math:`\rho(t)=V(t, t_0)\left\{\rho(t_0)\right\}`, where :math:`V(t, t_0)` is the propagator defined by the equation of motion. The resulting density matrix can then be used to evaluate the expectation values of arbitrary combinations of *same-time* operators. To calculate *two-time* correlation functions on the form :math:`\left<A(t+\tau)B(t)\right>`, we can use the quantum regression theorem (see, e.g., [Gar03]_) to write. .. math::. \left<A(t+\tau)B(t)\right> = {\rm Tr}\left[A V(t+\tau, t)\left\{B\rho(t)\right\}\right]; = {\rm Tr}\left[A V(t+\tau, t)\left\{BV(t, 0)\left\{\rho(0)\right\}\right\}\right]. We therefore first calculate :math:`\rho(t)=V(t, 0)\left\{\rho(0)\right\}` using one of the QuTiP evolution solvers with :math:`\rho(0)` as initial state, and then again use the same solver to calculate :math:`V(t+\tau, t)\left\{B\rho(t)\right\}` using :math:`B\rho(t)` as initial state. Note that if the initial state is the steady state, then :math:`\rho(t)=V(t, 0)\left\{\rho_{\rm ss}\right\}=\rho_{\rm ss}` and. .. math::. \left<A(t+\tau)B(t)\right> = {\rm Tr}\left[A V(t+\tau, t)\left\{B\rho_{\rm ss}\right\}\right]; = {\rm Tr}\left[A V(\tau, 0)\left\{B\rho_{\rm ss}\right\}\right] = \left<A(\tau)B(0)\right>,. which is independent of :math:`t`, so that we only have one time coordinate :math:`\tau`. QuTiP provides a family of functions that assists in the process of calculating two-time correlation functions. The available functions and their usage is shown in the table below. Each of these functions can use one of the following evolution solvers: Master-equation, Exponential series and the Monte-Carlo. The choice of solver is defined by the optional ",MatchSource.DOCS,doc/guide/guide-correlation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-correlation.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-correlation.rst:3327,Performance,perform,performs,3327,"h:`\left<A(t)B(t+\tau)\right>`. |; +----------------------------------+--------------------------------------------------+; | | :math:`\left<A(\tau)B(0)\right>` or |; | :func:`qutip.correlation_2op_1t` | :math:`\left<A(0)B(\tau)\right>`. |; +----------------------------------+--------------------------------------------------+; | :func:`qutip.correlation_3op_1t` | :math:`\left<A(0)B(\tau)C(0)\right>`. |; +----------------------------------+--------------------------------------------------+; | :func:`qutip.correlation_3op_2t` | :math:`\left<A(t)B(t+\tau)C(t)\right>`. |; +----------------------------------+--------------------------------------------------+; | :func:`qutip.correlation_3op` | :math:`\left<A(t)B(t+\tau)C(t)\right>`. |; +----------------------------------+--------------------------------------------------+. The most common use-case is to calculate the two time correlation function :math:`\left<A(\tau)B(0)\right>`. :func:`.correlation_2op_1t` performs this task with sensible default values, but only allows using the :func:`.mesolve` solver. From QuTiP 5.0 we added :func:`.correlation_3op`. This function can also calculate correlation functions with two or three operators and with one or two times. Most importantly, this function accepts alternative solvers such as :func:`.brmesolve`. .. _correlation-steady:. Steadystate correlation function; ================================. The following code demonstrates how to calculate the :math:`\left<x(t)x(0)\right>` correlation for a leaky cavity with three different relaxation rates. .. plot::; :context: close-figs. times = np.linspace(0,10.0,200); a = destroy(10); x = a.dag() + a; H = a.dag() * a. corr1 = correlation_2op_1t(H, None, times, [np.sqrt(0.5) * a], x, x); corr2 = correlation_2op_1t(H, None, times, [np.sqrt(1.0) * a], x, x); corr3 = correlation_2op_1t(H, None, times, [np.sqrt(2.0) * a], x, x). plt.figure(); plt.plot(times, np.real(corr1)); plt.plot(times, np.real(corr2)); plt.plot(times, np.real(corr3))",MatchSource.DOCS,doc/guide/guide-correlation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-correlation.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-correlation.rst:4904,Performance,perform,performs,4904," different relaxation rates. .. plot::; :context: close-figs. times = np.linspace(0,10.0,200); a = destroy(10); x = a.dag() + a; H = a.dag() * a. corr1 = correlation_2op_1t(H, None, times, [np.sqrt(0.5) * a], x, x); corr2 = correlation_2op_1t(H, None, times, [np.sqrt(1.0) * a], x, x); corr3 = correlation_2op_1t(H, None, times, [np.sqrt(2.0) * a], x, x). plt.figure(); plt.plot(times, np.real(corr1)); plt.plot(times, np.real(corr2)); plt.plot(times, np.real(corr3)); plt.legend(['0.5','1.0','2.0']); plt.xlabel(r'Time $t$'); plt.ylabel(r'Correlation $\left<x(t)x(0)\right>$'); plt.show(). Emission spectrum; =================. Given a correlation function :math:`\left<A(\tau)B(0)\right>` we can define the corresponding power spectrum as. .. math::. S(\omega) = \int_{-\infty}^{\infty} \left<A(\tau)B(0)\right> e^{-i\omega\tau} d\tau. In QuTiP, we can calculate :math:`S(\omega)` using either :func:`.spectrum`, which first calculates the correlation function using one of the time-dependent solvers and then performs the Fourier transform semi-analytically, or we can use the function :func:`.spectrum_correlation_fft` to numerically calculate the Fourier transform of a given correlation data using FFT. The following example demonstrates how these two functions can be used to obtain the emission power spectrum. .. plot:: guide/scripts/spectrum_ex1.py; :width: 5.0in; :include-source:. .. _correlation-spectrum:. Non-steadystate correlation function; ====================================. More generally, we can also calculate correlation functions of the kind :math:`\left<A(t_1+t_2)B(t_1)\right>`, i.e., the correlation function of a system that is not in its steady state. In QuTiP, we can evaluate such correlation functions using the function :func:`.correlation_2op_2t`. The default behavior of this function is to return a matrix with the correlations as a function of the two time coordinates (:math:`t_1` and :math:`t_2`). .. plot:: guide/scripts/correlation_ex2.py; :width: 5.0in; :in",MatchSource.DOCS,doc/guide/guide-correlation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-correlation.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-correlation.rst:5221,Usability,guid,guide,5221,"2.0) * a], x, x). plt.figure(); plt.plot(times, np.real(corr1)); plt.plot(times, np.real(corr2)); plt.plot(times, np.real(corr3)); plt.legend(['0.5','1.0','2.0']); plt.xlabel(r'Time $t$'); plt.ylabel(r'Correlation $\left<x(t)x(0)\right>$'); plt.show(). Emission spectrum; =================. Given a correlation function :math:`\left<A(\tau)B(0)\right>` we can define the corresponding power spectrum as. .. math::. S(\omega) = \int_{-\infty}^{\infty} \left<A(\tau)B(0)\right> e^{-i\omega\tau} d\tau. In QuTiP, we can calculate :math:`S(\omega)` using either :func:`.spectrum`, which first calculates the correlation function using one of the time-dependent solvers and then performs the Fourier transform semi-analytically, or we can use the function :func:`.spectrum_correlation_fft` to numerically calculate the Fourier transform of a given correlation data using FFT. The following example demonstrates how these two functions can be used to obtain the emission power spectrum. .. plot:: guide/scripts/spectrum_ex1.py; :width: 5.0in; :include-source:. .. _correlation-spectrum:. Non-steadystate correlation function; ====================================. More generally, we can also calculate correlation functions of the kind :math:`\left<A(t_1+t_2)B(t_1)\right>`, i.e., the correlation function of a system that is not in its steady state. In QuTiP, we can evaluate such correlation functions using the function :func:`.correlation_2op_2t`. The default behavior of this function is to return a matrix with the correlations as a function of the two time coordinates (:math:`t_1` and :math:`t_2`). .. plot:: guide/scripts/correlation_ex2.py; :width: 5.0in; :include-source:. However, in some cases we might be interested in the correlation functions on the form :math:`\left<A(t_1+t_2)B(t_1)\right>`, but only as a function of time coordinate :math:`t_2`. In this case we can also use the :func:`.correlation_2op_2t` function, if we pass the density matrix at time :math:`t_1` as second argument, a",MatchSource.DOCS,doc/guide/guide-correlation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-correlation.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-correlation.rst:5841,Usability,guid,guide,5841,"on using one of the time-dependent solvers and then performs the Fourier transform semi-analytically, or we can use the function :func:`.spectrum_correlation_fft` to numerically calculate the Fourier transform of a given correlation data using FFT. The following example demonstrates how these two functions can be used to obtain the emission power spectrum. .. plot:: guide/scripts/spectrum_ex1.py; :width: 5.0in; :include-source:. .. _correlation-spectrum:. Non-steadystate correlation function; ====================================. More generally, we can also calculate correlation functions of the kind :math:`\left<A(t_1+t_2)B(t_1)\right>`, i.e., the correlation function of a system that is not in its steady state. In QuTiP, we can evaluate such correlation functions using the function :func:`.correlation_2op_2t`. The default behavior of this function is to return a matrix with the correlations as a function of the two time coordinates (:math:`t_1` and :math:`t_2`). .. plot:: guide/scripts/correlation_ex2.py; :width: 5.0in; :include-source:. However, in some cases we might be interested in the correlation functions on the form :math:`\left<A(t_1+t_2)B(t_1)\right>`, but only as a function of time coordinate :math:`t_2`. In this case we can also use the :func:`.correlation_2op_2t` function, if we pass the density matrix at time :math:`t_1` as second argument, and `None` as third argument. The :func:`.correlation_2op_2t` function then returns a vector with the correlation values corresponding to the times in `taulist` (the fourth argument). Example: first-order optical coherence function; -----------------------------------------------. This example demonstrates how to calculate a correlation function on the form :math:`\left<A(\tau)B(0)\right>` for a non-steady initial state. Consider an oscillator that is interacting with a thermal environment. If the oscillator initially is in a coherent state, it will gradually decay to a thermal (incoherent) state. The amount of coh",MatchSource.DOCS,doc/guide/guide-correlation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-correlation.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-correlation.rst:7292,Usability,guid,guide,7292,"en returns a vector with the correlation values corresponding to the times in `taulist` (the fourth argument). Example: first-order optical coherence function; -----------------------------------------------. This example demonstrates how to calculate a correlation function on the form :math:`\left<A(\tau)B(0)\right>` for a non-steady initial state. Consider an oscillator that is interacting with a thermal environment. If the oscillator initially is in a coherent state, it will gradually decay to a thermal (incoherent) state. The amount of coherence can be quantified using the first-order optical coherence function :math:`g^{(1)}(\tau) = \frac{\left<a^\dagger(\tau)a(0)\right>}{\sqrt{\left<a^\dagger(\tau)a(\tau)\right>\left<a^\dagger(0)a(0)\right>}}`. For a coherent state :math:`|g^{(1)}(\tau)| = 1`, and for a completely incoherent (thermal) state :math:`g^{(1)}(\tau) = 0`. The following code calculates and plots :math:`g^{(1)}(\tau)` as a function of :math:`\tau`. .. plot:: guide/scripts/correlation_ex3.py; :width: 5.0in; :include-source:. For convenience, the steps for calculating the first-order coherence function have been collected in the function :func:`.coherence_function_g1`. Example: second-order optical coherence function; ------------------------------------------------. The second-order optical coherence function, with time-delay :math:`\tau`, is defined as. .. math::. \displaystyle g^{(2)}(\tau) = \frac{\langle a^\dagger(0)a^\dagger(\tau)a(\tau)a(0)\rangle}{\langle a^\dagger(0)a(0)\rangle^2}. For a coherent state :math:`g^{(2)}(\tau) = 1`, for a thermal state :math:`g^{(2)}(\tau=0) = 2` and it decreases as a function of time (bunched photons, they tend to appear together), and for a Fock state with :math:`n` photons :math:`g^{(2)}(\tau = 0) = n(n - 1)/n^2 < 1` and it increases with time (anti-bunched photons, more likely to arrive separated in time). To calculate this type of correlation function with QuTiP, we can use :func:`.correlation_3op_1t`, which ",MatchSource.DOCS,doc/guide/guide-correlation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-correlation.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-correlation.rst:8750,Usability,guid,guide,8750,"agger(\tau)a(0)\right>}{\sqrt{\left<a^\dagger(\tau)a(\tau)\right>\left<a^\dagger(0)a(0)\right>}}`. For a coherent state :math:`|g^{(1)}(\tau)| = 1`, and for a completely incoherent (thermal) state :math:`g^{(1)}(\tau) = 0`. The following code calculates and plots :math:`g^{(1)}(\tau)` as a function of :math:`\tau`. .. plot:: guide/scripts/correlation_ex3.py; :width: 5.0in; :include-source:. For convenience, the steps for calculating the first-order coherence function have been collected in the function :func:`.coherence_function_g1`. Example: second-order optical coherence function; ------------------------------------------------. The second-order optical coherence function, with time-delay :math:`\tau`, is defined as. .. math::. \displaystyle g^{(2)}(\tau) = \frac{\langle a^\dagger(0)a^\dagger(\tau)a(\tau)a(0)\rangle}{\langle a^\dagger(0)a(0)\rangle^2}. For a coherent state :math:`g^{(2)}(\tau) = 1`, for a thermal state :math:`g^{(2)}(\tau=0) = 2` and it decreases as a function of time (bunched photons, they tend to appear together), and for a Fock state with :math:`n` photons :math:`g^{(2)}(\tau = 0) = n(n - 1)/n^2 < 1` and it increases with time (anti-bunched photons, more likely to arrive separated in time). To calculate this type of correlation function with QuTiP, we can use :func:`.correlation_3op_1t`, which computes a correlation function on the form :math:`\left<A(0)B(\tau)C(0)\right>` (three operators, one delay-time vector).; We first have to combine the central two operators into one single one as they are evaluated at the same time, e.g. here we do :math:`a^\dagger(\tau)a(\tau) = (a^\dagger a)(\tau)`. The following code calculates and plots :math:`g^{(2)}(\tau)` as a function of :math:`\tau` for a coherent, thermal and Fock state. .. plot:: guide/scripts/correlation_ex4.py; :width: 5.0in; :include-source:. For convenience, the steps for calculating the second-order coherence function have been collected in the function :func:`.coherence_function_g2`.; ",MatchSource.DOCS,doc/guide/guide-correlation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-correlation.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst:1035,Availability,down,down,1035,"******************************; Measurement of Quantum Objects; ******************************. .. note::; New in QuTiP 4.6. .. _measurement-intro:. Introduction; ------------. Measurement is a fundamental part of the standard formulation of quantum; mechanics and is the process by which classical readings are obtained from; a quantum object. Although the interpretation of the procedure is at times; contentious, the procedure itself is mathematically straightforward and is; described in many good introductory texts. Here we will show you how to perform simple measurement operations on QuTiP; objects. The same functions :func:`~qutip.measurement.measure` and; :func:`~qutip.measurement.measurement_statistics` can be used; to handle both observable-style measurements and projective style measurements. .. _measurement-basic:. Performing a basic measurement (Observable); -------------------------------------------. First we need to select some states to measure. For now, let us create an *up*; state and a *down* state:. .. testcode::. up = basis(2, 0). down = basis(2, 1). which represent spin-1/2 particles with their spin pointing either up or down; along the z-axis. We choose what to measure (in this case) by selecting a **measurement operator**.; For example,; we could select :func:`.sigmaz` which measures the z-component of the; spin of a spin-1/2 particle, or :func:`.sigmax` which measures the; x-component:. .. testcode::. spin_z = sigmaz(). spin_x = sigmax(). How do we know what these operators measure? The answer lies in the measurement; procedure itself:. * A quantum measurement transforms the state being measured by projecting it into; one of the eigenvectors of the measurement operator. * Which eigenvector to project onto is chosen probabilistically according to the; square of the amplitude of the state in the direction of the eigenvector. * The value returned by the measurement is the eigenvalue corresponding to the; chosen eigenvector. .. note::. How to interpr",MatchSource.DOCS,doc/guide/guide-measurement.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst:1082,Availability,down,down,1082,"*********************. .. note::; New in QuTiP 4.6. .. _measurement-intro:. Introduction; ------------. Measurement is a fundamental part of the standard formulation of quantum; mechanics and is the process by which classical readings are obtained from; a quantum object. Although the interpretation of the procedure is at times; contentious, the procedure itself is mathematically straightforward and is; described in many good introductory texts. Here we will show you how to perform simple measurement operations on QuTiP; objects. The same functions :func:`~qutip.measurement.measure` and; :func:`~qutip.measurement.measurement_statistics` can be used; to handle both observable-style measurements and projective style measurements. .. _measurement-basic:. Performing a basic measurement (Observable); -------------------------------------------. First we need to select some states to measure. For now, let us create an *up*; state and a *down* state:. .. testcode::. up = basis(2, 0). down = basis(2, 1). which represent spin-1/2 particles with their spin pointing either up or down; along the z-axis. We choose what to measure (in this case) by selecting a **measurement operator**.; For example,; we could select :func:`.sigmaz` which measures the z-component of the; spin of a spin-1/2 particle, or :func:`.sigmax` which measures the; x-component:. .. testcode::. spin_z = sigmaz(). spin_x = sigmax(). How do we know what these operators measure? The answer lies in the measurement; procedure itself:. * A quantum measurement transforms the state being measured by projecting it into; one of the eigenvectors of the measurement operator. * Which eigenvector to project onto is chosen probabilistically according to the; square of the amplitude of the state in the direction of the eigenvector. * The value returned by the measurement is the eigenvalue corresponding to the; chosen eigenvector. .. note::. How to interpret this ""random choosing"" is the famous; ""quantum measurement problem"". ",MatchSource.DOCS,doc/guide/guide-measurement.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst:1175,Availability,down,down,1175,"asurement-intro:. Introduction; ------------. Measurement is a fundamental part of the standard formulation of quantum; mechanics and is the process by which classical readings are obtained from; a quantum object. Although the interpretation of the procedure is at times; contentious, the procedure itself is mathematically straightforward and is; described in many good introductory texts. Here we will show you how to perform simple measurement operations on QuTiP; objects. The same functions :func:`~qutip.measurement.measure` and; :func:`~qutip.measurement.measurement_statistics` can be used; to handle both observable-style measurements and projective style measurements. .. _measurement-basic:. Performing a basic measurement (Observable); -------------------------------------------. First we need to select some states to measure. For now, let us create an *up*; state and a *down* state:. .. testcode::. up = basis(2, 0). down = basis(2, 1). which represent spin-1/2 particles with their spin pointing either up or down; along the z-axis. We choose what to measure (in this case) by selecting a **measurement operator**.; For example,; we could select :func:`.sigmaz` which measures the z-component of the; spin of a spin-1/2 particle, or :func:`.sigmax` which measures the; x-component:. .. testcode::. spin_z = sigmaz(). spin_x = sigmax(). How do we know what these operators measure? The answer lies in the measurement; procedure itself:. * A quantum measurement transforms the state being measured by projecting it into; one of the eigenvectors of the measurement operator. * Which eigenvector to project onto is chosen probabilistically according to the; square of the amplitude of the state in the direction of the eigenvector. * The value returned by the measurement is the eigenvalue corresponding to the; chosen eigenvector. .. note::. How to interpret this ""random choosing"" is the famous; ""quantum measurement problem"". The eigenvectors of `spin_z` are the states with their spin",MatchSource.DOCS,doc/guide/guide-measurement.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst:2174,Availability,down,down,2174,"ther up or down; along the z-axis. We choose what to measure (in this case) by selecting a **measurement operator**.; For example,; we could select :func:`.sigmaz` which measures the z-component of the; spin of a spin-1/2 particle, or :func:`.sigmax` which measures the; x-component:. .. testcode::. spin_z = sigmaz(). spin_x = sigmax(). How do we know what these operators measure? The answer lies in the measurement; procedure itself:. * A quantum measurement transforms the state being measured by projecting it into; one of the eigenvectors of the measurement operator. * Which eigenvector to project onto is chosen probabilistically according to the; square of the amplitude of the state in the direction of the eigenvector. * The value returned by the measurement is the eigenvalue corresponding to the; chosen eigenvector. .. note::. How to interpret this ""random choosing"" is the famous; ""quantum measurement problem"". The eigenvectors of `spin_z` are the states with their spin pointing either up; or down, so it measures the component of the spin along the z-axis. The eigenvectors of `spin_x` are the states with their spin pointing either; left or right, so it measures the component of the spin along the x-axis. When we measure our `up` and `down` states using the operator `spin_z`, we; always obtain:. .. testcode::. from qutip.measurement import measure, measurement_statistics. measure(up, spin_z) == (1.0, up). measure(down, spin_z) == (-1.0, down). because `up` is the eigenvector of `spin_z` with eigenvalue `1.0` and `down`; is the eigenvector with eigenvalue `-1.0`. The minus signs are just an; arbitrary global phase -- `up` and `-up` represent the same quantum state. Neither eigenvector has any component in the direction of the other (they are; orthogonal), so `measure(spin_z, up)` returns the state `up` 100% percent of the; time and `measure(spin_z, down)` returns the state `down` 100% of the time. Note how :func:`~qutip.measurement.measure` returns a pair of values.",MatchSource.DOCS,doc/guide/guide-measurement.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst:2420,Availability,down,down,2420,"x-component:. .. testcode::. spin_z = sigmaz(). spin_x = sigmax(). How do we know what these operators measure? The answer lies in the measurement; procedure itself:. * A quantum measurement transforms the state being measured by projecting it into; one of the eigenvectors of the measurement operator. * Which eigenvector to project onto is chosen probabilistically according to the; square of the amplitude of the state in the direction of the eigenvector. * The value returned by the measurement is the eigenvalue corresponding to the; chosen eigenvector. .. note::. How to interpret this ""random choosing"" is the famous; ""quantum measurement problem"". The eigenvectors of `spin_z` are the states with their spin pointing either up; or down, so it measures the component of the spin along the z-axis. The eigenvectors of `spin_x` are the states with their spin pointing either; left or right, so it measures the component of the spin along the x-axis. When we measure our `up` and `down` states using the operator `spin_z`, we; always obtain:. .. testcode::. from qutip.measurement import measure, measurement_statistics. measure(up, spin_z) == (1.0, up). measure(down, spin_z) == (-1.0, down). because `up` is the eigenvector of `spin_z` with eigenvalue `1.0` and `down`; is the eigenvector with eigenvalue `-1.0`. The minus signs are just an; arbitrary global phase -- `up` and `-up` represent the same quantum state. Neither eigenvector has any component in the direction of the other (they are; orthogonal), so `measure(spin_z, up)` returns the state `up` 100% percent of the; time and `measure(spin_z, down)` returns the state `down` 100% of the time. Note how :func:`~qutip.measurement.measure` returns a pair of values. The; first is the measured value, i.e. an eigenvalue of the operator (e.g. `1.0`),; and the second is the state of the quantum system after the measurement,; i.e. an eigenvector of the operator (e.g. `up`). Now let us consider what happens if we measure the x-component ",MatchSource.DOCS,doc/guide/guide-measurement.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst:2602,Availability,down,down,2602,"antum measurement transforms the state being measured by projecting it into; one of the eigenvectors of the measurement operator. * Which eigenvector to project onto is chosen probabilistically according to the; square of the amplitude of the state in the direction of the eigenvector. * The value returned by the measurement is the eigenvalue corresponding to the; chosen eigenvector. .. note::. How to interpret this ""random choosing"" is the famous; ""quantum measurement problem"". The eigenvectors of `spin_z` are the states with their spin pointing either up; or down, so it measures the component of the spin along the z-axis. The eigenvectors of `spin_x` are the states with their spin pointing either; left or right, so it measures the component of the spin along the x-axis. When we measure our `up` and `down` states using the operator `spin_z`, we; always obtain:. .. testcode::. from qutip.measurement import measure, measurement_statistics. measure(up, spin_z) == (1.0, up). measure(down, spin_z) == (-1.0, down). because `up` is the eigenvector of `spin_z` with eigenvalue `1.0` and `down`; is the eigenvector with eigenvalue `-1.0`. The minus signs are just an; arbitrary global phase -- `up` and `-up` represent the same quantum state. Neither eigenvector has any component in the direction of the other (they are; orthogonal), so `measure(spin_z, up)` returns the state `up` 100% percent of the; time and `measure(spin_z, down)` returns the state `down` 100% of the time. Note how :func:`~qutip.measurement.measure` returns a pair of values. The; first is the measured value, i.e. an eigenvalue of the operator (e.g. `1.0`),; and the second is the state of the quantum system after the measurement,; i.e. an eigenvector of the operator (e.g. `up`). Now let us consider what happens if we measure the x-component of the spin; of `up`:. .. testcode::. measure(up, spin_x). The `up` state is not an eigenvector of `spin_x`. `spin_x` has two eigenvectors; which we will call `left` and `ri",MatchSource.DOCS,doc/guide/guide-measurement.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst:2626,Availability,down,down,2626,"ransforms the state being measured by projecting it into; one of the eigenvectors of the measurement operator. * Which eigenvector to project onto is chosen probabilistically according to the; square of the amplitude of the state in the direction of the eigenvector. * The value returned by the measurement is the eigenvalue corresponding to the; chosen eigenvector. .. note::. How to interpret this ""random choosing"" is the famous; ""quantum measurement problem"". The eigenvectors of `spin_z` are the states with their spin pointing either up; or down, so it measures the component of the spin along the z-axis. The eigenvectors of `spin_x` are the states with their spin pointing either; left or right, so it measures the component of the spin along the x-axis. When we measure our `up` and `down` states using the operator `spin_z`, we; always obtain:. .. testcode::. from qutip.measurement import measure, measurement_statistics. measure(up, spin_z) == (1.0, up). measure(down, spin_z) == (-1.0, down). because `up` is the eigenvector of `spin_z` with eigenvalue `1.0` and `down`; is the eigenvector with eigenvalue `-1.0`. The minus signs are just an; arbitrary global phase -- `up` and `-up` represent the same quantum state. Neither eigenvector has any component in the direction of the other (they are; orthogonal), so `measure(spin_z, up)` returns the state `up` 100% percent of the; time and `measure(spin_z, down)` returns the state `down` 100% of the time. Note how :func:`~qutip.measurement.measure` returns a pair of values. The; first is the measured value, i.e. an eigenvalue of the operator (e.g. `1.0`),; and the second is the state of the quantum system after the measurement,; i.e. an eigenvector of the operator (e.g. `up`). Now let us consider what happens if we measure the x-component of the spin; of `up`:. .. testcode::. measure(up, spin_x). The `up` state is not an eigenvector of `spin_x`. `spin_x` has two eigenvectors; which we will call `left` and `right`. The `up` state",MatchSource.DOCS,doc/guide/guide-measurement.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst:2704,Availability,down,down,2704,"ment operator. * Which eigenvector to project onto is chosen probabilistically according to the; square of the amplitude of the state in the direction of the eigenvector. * The value returned by the measurement is the eigenvalue corresponding to the; chosen eigenvector. .. note::. How to interpret this ""random choosing"" is the famous; ""quantum measurement problem"". The eigenvectors of `spin_z` are the states with their spin pointing either up; or down, so it measures the component of the spin along the z-axis. The eigenvectors of `spin_x` are the states with their spin pointing either; left or right, so it measures the component of the spin along the x-axis. When we measure our `up` and `down` states using the operator `spin_z`, we; always obtain:. .. testcode::. from qutip.measurement import measure, measurement_statistics. measure(up, spin_z) == (1.0, up). measure(down, spin_z) == (-1.0, down). because `up` is the eigenvector of `spin_z` with eigenvalue `1.0` and `down`; is the eigenvector with eigenvalue `-1.0`. The minus signs are just an; arbitrary global phase -- `up` and `-up` represent the same quantum state. Neither eigenvector has any component in the direction of the other (they are; orthogonal), so `measure(spin_z, up)` returns the state `up` 100% percent of the; time and `measure(spin_z, down)` returns the state `down` 100% of the time. Note how :func:`~qutip.measurement.measure` returns a pair of values. The; first is the measured value, i.e. an eigenvalue of the operator (e.g. `1.0`),; and the second is the state of the quantum system after the measurement,; i.e. an eigenvector of the operator (e.g. `up`). Now let us consider what happens if we measure the x-component of the spin; of `up`:. .. testcode::. measure(up, spin_x). The `up` state is not an eigenvector of `spin_x`. `spin_x` has two eigenvectors; which we will call `left` and `right`. The `up` state has equal components in; the direction of these two vectors, so measurement will select each o",MatchSource.DOCS,doc/guide/guide-measurement.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst:3045,Availability,down,down,3045,"hosen eigenvector. .. note::. How to interpret this ""random choosing"" is the famous; ""quantum measurement problem"". The eigenvectors of `spin_z` are the states with their spin pointing either up; or down, so it measures the component of the spin along the z-axis. The eigenvectors of `spin_x` are the states with their spin pointing either; left or right, so it measures the component of the spin along the x-axis. When we measure our `up` and `down` states using the operator `spin_z`, we; always obtain:. .. testcode::. from qutip.measurement import measure, measurement_statistics. measure(up, spin_z) == (1.0, up). measure(down, spin_z) == (-1.0, down). because `up` is the eigenvector of `spin_z` with eigenvalue `1.0` and `down`; is the eigenvector with eigenvalue `-1.0`. The minus signs are just an; arbitrary global phase -- `up` and `-up` represent the same quantum state. Neither eigenvector has any component in the direction of the other (they are; orthogonal), so `measure(spin_z, up)` returns the state `up` 100% percent of the; time and `measure(spin_z, down)` returns the state `down` 100% of the time. Note how :func:`~qutip.measurement.measure` returns a pair of values. The; first is the measured value, i.e. an eigenvalue of the operator (e.g. `1.0`),; and the second is the state of the quantum system after the measurement,; i.e. an eigenvector of the operator (e.g. `up`). Now let us consider what happens if we measure the x-component of the spin; of `up`:. .. testcode::. measure(up, spin_x). The `up` state is not an eigenvector of `spin_x`. `spin_x` has two eigenvectors; which we will call `left` and `right`. The `up` state has equal components in; the direction of these two vectors, so measurement will select each of them; 50% of the time. These `left` and `right` states are:. .. testcode::. left = (up - down).unit(). right = (up + down).unit(). When `left` is chosen, the result of the measurement will be `(-1.0, -left)`. When `right` is chosen, the result of meas",MatchSource.DOCS,doc/guide/guide-measurement.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst:3071,Availability,down,down,3071,"hosen eigenvector. .. note::. How to interpret this ""random choosing"" is the famous; ""quantum measurement problem"". The eigenvectors of `spin_z` are the states with their spin pointing either up; or down, so it measures the component of the spin along the z-axis. The eigenvectors of `spin_x` are the states with their spin pointing either; left or right, so it measures the component of the spin along the x-axis. When we measure our `up` and `down` states using the operator `spin_z`, we; always obtain:. .. testcode::. from qutip.measurement import measure, measurement_statistics. measure(up, spin_z) == (1.0, up). measure(down, spin_z) == (-1.0, down). because `up` is the eigenvector of `spin_z` with eigenvalue `1.0` and `down`; is the eigenvector with eigenvalue `-1.0`. The minus signs are just an; arbitrary global phase -- `up` and `-up` represent the same quantum state. Neither eigenvector has any component in the direction of the other (they are; orthogonal), so `measure(spin_z, up)` returns the state `up` 100% percent of the; time and `measure(spin_z, down)` returns the state `down` 100% of the time. Note how :func:`~qutip.measurement.measure` returns a pair of values. The; first is the measured value, i.e. an eigenvalue of the operator (e.g. `1.0`),; and the second is the state of the quantum system after the measurement,; i.e. an eigenvector of the operator (e.g. `up`). Now let us consider what happens if we measure the x-component of the spin; of `up`:. .. testcode::. measure(up, spin_x). The `up` state is not an eigenvector of `spin_x`. `spin_x` has two eigenvectors; which we will call `left` and `right`. The `up` state has equal components in; the direction of these two vectors, so measurement will select each of them; 50% of the time. These `left` and `right` states are:. .. testcode::. left = (up - down).unit(). right = (up + down).unit(). When `left` is chosen, the result of the measurement will be `(-1.0, -left)`. When `right` is chosen, the result of meas",MatchSource.DOCS,doc/guide/guide-measurement.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst:3814,Availability,down,down,3814,"up` and `-up` represent the same quantum state. Neither eigenvector has any component in the direction of the other (they are; orthogonal), so `measure(spin_z, up)` returns the state `up` 100% percent of the; time and `measure(spin_z, down)` returns the state `down` 100% of the time. Note how :func:`~qutip.measurement.measure` returns a pair of values. The; first is the measured value, i.e. an eigenvalue of the operator (e.g. `1.0`),; and the second is the state of the quantum system after the measurement,; i.e. an eigenvector of the operator (e.g. `up`). Now let us consider what happens if we measure the x-component of the spin; of `up`:. .. testcode::. measure(up, spin_x). The `up` state is not an eigenvector of `spin_x`. `spin_x` has two eigenvectors; which we will call `left` and `right`. The `up` state has equal components in; the direction of these two vectors, so measurement will select each of them; 50% of the time. These `left` and `right` states are:. .. testcode::. left = (up - down).unit(). right = (up + down).unit(). When `left` is chosen, the result of the measurement will be `(-1.0, -left)`. When `right` is chosen, the result of measurement with be `(1.0, right)`. .. note::. When :func:`~qutip.measurement.measure` is invoked with the second argument; being an observable, it acts as an alias to; :func:`~qutip.measurement.measure_observable`. Performing a basic measurement (Projective); -------------------------------------------. We can also choose what to measure by specifying a *list of projection operators*. For; example, we could select the projection operators :math:`\ket{0} \bra{0}` and; :math:`\ket{1} \bra{1}` which measure the state in the :math:`\ket{0}, \ket{1}`; basis. Note that these projection operators are simply the projectors determined by; the eigenstates of the :func:`~qutip.operators.sigmaz` operator. .. testcode::. Z0, Z1 = ket2dm(basis(2, 0)), ket2dm(basis(2, 1)). The probabilities and respective output state; are calculated for ea",MatchSource.DOCS,doc/guide/guide-measurement.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst:3842,Availability,down,down,3842," same quantum state. Neither eigenvector has any component in the direction of the other (they are; orthogonal), so `measure(spin_z, up)` returns the state `up` 100% percent of the; time and `measure(spin_z, down)` returns the state `down` 100% of the time. Note how :func:`~qutip.measurement.measure` returns a pair of values. The; first is the measured value, i.e. an eigenvalue of the operator (e.g. `1.0`),; and the second is the state of the quantum system after the measurement,; i.e. an eigenvector of the operator (e.g. `up`). Now let us consider what happens if we measure the x-component of the spin; of `up`:. .. testcode::. measure(up, spin_x). The `up` state is not an eigenvector of `spin_x`. `spin_x` has two eigenvectors; which we will call `left` and `right`. The `up` state has equal components in; the direction of these two vectors, so measurement will select each of them; 50% of the time. These `left` and `right` states are:. .. testcode::. left = (up - down).unit(). right = (up + down).unit(). When `left` is chosen, the result of the measurement will be `(-1.0, -left)`. When `right` is chosen, the result of measurement with be `(1.0, right)`. .. note::. When :func:`~qutip.measurement.measure` is invoked with the second argument; being an observable, it acts as an alias to; :func:`~qutip.measurement.measure_observable`. Performing a basic measurement (Projective); -------------------------------------------. We can also choose what to measure by specifying a *list of projection operators*. For; example, we could select the projection operators :math:`\ket{0} \bra{0}` and; :math:`\ket{1} \bra{1}` which measure the state in the :math:`\ket{0}, \ket{1}`; basis. Note that these projection operators are simply the projectors determined by; the eigenstates of the :func:`~qutip.operators.sigmaz` operator. .. testcode::. Z0, Z1 = ket2dm(basis(2, 0)), ket2dm(basis(2, 1)). The probabilities and respective output state; are calculated for each projection operator. .. t",MatchSource.DOCS,doc/guide/guide-measurement.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst:4891,Availability,down,down,4891,"urement will be `(-1.0, -left)`. When `right` is chosen, the result of measurement with be `(1.0, right)`. .. note::. When :func:`~qutip.measurement.measure` is invoked with the second argument; being an observable, it acts as an alias to; :func:`~qutip.measurement.measure_observable`. Performing a basic measurement (Projective); -------------------------------------------. We can also choose what to measure by specifying a *list of projection operators*. For; example, we could select the projection operators :math:`\ket{0} \bra{0}` and; :math:`\ket{1} \bra{1}` which measure the state in the :math:`\ket{0}, \ket{1}`; basis. Note that these projection operators are simply the projectors determined by; the eigenstates of the :func:`~qutip.operators.sigmaz` operator. .. testcode::. Z0, Z1 = ket2dm(basis(2, 0)), ket2dm(basis(2, 1)). The probabilities and respective output state; are calculated for each projection operator. .. testcode::. measure(up, [Z0, Z1]) == (0, up). measure(down, [Z0, Z1]) == (1, down). In this case, the projection operators are conveniently eigenstates corresponding; to subspaces of dimension :math:`1`. However, this might not be; the case, in which case it is not possible to have unique eigenvalues for each; eigenstate. Suppose we want to measure only the first; qubit in a two-qubit system. Consider the two qubit state :math:`\ket{0+}`. .. testcode::. state_0 = basis(2, 0). state_plus = (basis(2, 0) + basis(2, 1)).unit(). state_0plus = tensor(state_0, state_plus). Now, suppose we want to measure only the first qubit in the computational basis.; We can do that by measuring with the projection operators; :math:`\ket{0}\bra{0} \otimes I` and :math:`\ket{1}\bra{1} \otimes I`. .. testcode::. PZ1 = [tensor(Z0, identity(2)), tensor(Z1, identity(2))]. PZ2 = [tensor(identity(2), Z0), tensor(identity(2), Z1)]. Now, as in the previous example, we can measure by supplying a list of projection operators; and the state. .. testcode::. measure(state_0plus, PZ1)",MatchSource.DOCS,doc/guide/guide-measurement.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst:4914,Availability,down,down,4914,"urement will be `(-1.0, -left)`. When `right` is chosen, the result of measurement with be `(1.0, right)`. .. note::. When :func:`~qutip.measurement.measure` is invoked with the second argument; being an observable, it acts as an alias to; :func:`~qutip.measurement.measure_observable`. Performing a basic measurement (Projective); -------------------------------------------. We can also choose what to measure by specifying a *list of projection operators*. For; example, we could select the projection operators :math:`\ket{0} \bra{0}` and; :math:`\ket{1} \bra{1}` which measure the state in the :math:`\ket{0}, \ket{1}`; basis. Note that these projection operators are simply the projectors determined by; the eigenstates of the :func:`~qutip.operators.sigmaz` operator. .. testcode::. Z0, Z1 = ket2dm(basis(2, 0)), ket2dm(basis(2, 1)). The probabilities and respective output state; are calculated for each projection operator. .. testcode::. measure(up, [Z0, Z1]) == (0, up). measure(down, [Z0, Z1]) == (1, down). In this case, the projection operators are conveniently eigenstates corresponding; to subspaces of dimension :math:`1`. However, this might not be; the case, in which case it is not possible to have unique eigenvalues for each; eigenstate. Suppose we want to measure only the first; qubit in a two-qubit system. Consider the two qubit state :math:`\ket{0+}`. .. testcode::. state_0 = basis(2, 0). state_plus = (basis(2, 0) + basis(2, 1)).unit(). state_0plus = tensor(state_0, state_plus). Now, suppose we want to measure only the first qubit in the computational basis.; We can do that by measuring with the projection operators; :math:`\ket{0}\bra{0} \otimes I` and :math:`\ket{1}\bra{1} \otimes I`. .. testcode::. PZ1 = [tensor(Z0, identity(2)), tensor(Z1, identity(2))]. PZ2 = [tensor(identity(2), Z0), tensor(identity(2), Z1)]. Now, as in the previous example, we can measure by supplying a list of projection operators; and the state. .. testcode::. measure(state_0plus, PZ1)",MatchSource.DOCS,doc/guide/guide-measurement.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst:569,Performance,perform,perform,569,".. _measurement:. ******************************; Measurement of Quantum Objects; ******************************. .. note::; New in QuTiP 4.6. .. _measurement-intro:. Introduction; ------------. Measurement is a fundamental part of the standard formulation of quantum; mechanics and is the process by which classical readings are obtained from; a quantum object. Although the interpretation of the procedure is at times; contentious, the procedure itself is mathematically straightforward and is; described in many good introductory texts. Here we will show you how to perform simple measurement operations on QuTiP; objects. The same functions :func:`~qutip.measurement.measure` and; :func:`~qutip.measurement.measurement_statistics` can be used; to handle both observable-style measurements and projective style measurements. .. _measurement-basic:. Performing a basic measurement (Observable); -------------------------------------------. First we need to select some states to measure. For now, let us create an *up*; state and a *down* state:. .. testcode::. up = basis(2, 0). down = basis(2, 1). which represent spin-1/2 particles with their spin pointing either up or down; along the z-axis. We choose what to measure (in this case) by selecting a **measurement operator**.; For example,; we could select :func:`.sigmaz` which measures the z-component of the; spin of a spin-1/2 particle, or :func:`.sigmax` which measures the; x-component:. .. testcode::. spin_z = sigmaz(). spin_x = sigmax(). How do we know what these operators measure? The answer lies in the measurement; procedure itself:. * A quantum measurement transforms the state being measured by projecting it into; one of the eigenvectors of the measurement operator. * Which eigenvector to project onto is chosen probabilistically according to the; square of the amplitude of the state in the direction of the eigenvector. * The value returned by the measurement is the eigenvalue corresponding to the; chosen eigenvector. .. note",MatchSource.DOCS,doc/guide/guide-measurement.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst:6437,Performance,perform,perform,6437,"e first qubit in the computational basis.; We can do that by measuring with the projection operators; :math:`\ket{0}\bra{0} \otimes I` and :math:`\ket{1}\bra{1} \otimes I`. .. testcode::. PZ1 = [tensor(Z0, identity(2)), tensor(Z1, identity(2))]. PZ2 = [tensor(identity(2), Z0), tensor(identity(2), Z1)]. Now, as in the previous example, we can measure by supplying a list of projection operators; and the state. .. testcode::. measure(state_0plus, PZ1) == (0, state_0plus). The output of the measurement is the index of the measurement outcome as well; as the output state on the full Hilbert space of the input state. It is crucial to; note that we do not discard the measured qubit after measurement (as opposed to; when measuring on quantum hardware). .. note::. When :func:`~qutip.measurement.measure` is invoked with the second argument; being a list of projectors, it acts as an alias to; :func:`~qutip.measurement.measure_povm`. The :func:`~qutip.measurement.measure` function can perform measurements on; density matrices too. You can read about these and other details at; :func:`~qutip.measurement.measure_povm` and :func:`~qutip.measurement.measure_observable`. Now you know how to measure quantum states in QuTiP!. .. _measurement-statistics:. Obtaining measurement statistics(Observable); --------------------------------------------. You've just learned how to perform measurements in QuTiP, but you've also; learned that measurements are probabilistic. What if instead of just making; a single measurement, we want to determine the probability distribution of; a large number of measurements?. One way would be to repeat the measurement many times -- and this is what; happens in many quantum experiments. In QuTiP one could simulate this using:. .. testcode::; :hide:. np.random.seed(42). .. testcode::. results = {1.0: 0, -1.0: 0} # 1 and -1 are the possible outcomes; for _ in range(1000):; value, new_state = measure(up, spin_x); results[round(value)] += 1; print(results). **Outpu",MatchSource.DOCS,doc/guide/guide-measurement.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst:6824,Performance,perform,perform,6824,"ate. .. testcode::. measure(state_0plus, PZ1) == (0, state_0plus). The output of the measurement is the index of the measurement outcome as well; as the output state on the full Hilbert space of the input state. It is crucial to; note that we do not discard the measured qubit after measurement (as opposed to; when measuring on quantum hardware). .. note::. When :func:`~qutip.measurement.measure` is invoked with the second argument; being a list of projectors, it acts as an alias to; :func:`~qutip.measurement.measure_povm`. The :func:`~qutip.measurement.measure` function can perform measurements on; density matrices too. You can read about these and other details at; :func:`~qutip.measurement.measure_povm` and :func:`~qutip.measurement.measure_observable`. Now you know how to measure quantum states in QuTiP!. .. _measurement-statistics:. Obtaining measurement statistics(Observable); --------------------------------------------. You've just learned how to perform measurements in QuTiP, but you've also; learned that measurements are probabilistic. What if instead of just making; a single measurement, we want to determine the probability distribution of; a large number of measurements?. One way would be to repeat the measurement many times -- and this is what; happens in many quantum experiments. In QuTiP one could simulate this using:. .. testcode::; :hide:. np.random.seed(42). .. testcode::. results = {1.0: 0, -1.0: 0} # 1 and -1 are the possible outcomes; for _ in range(1000):; value, new_state = measure(up, spin_x); results[round(value)] += 1; print(results). **Output**:. .. testoutput::. {1.0: 497, -1.0: 503}. which measures the x-component of the spin of the `up` state `1000` times and; stores the results in a dictionary. Afterwards we expect to have seen the; result `1.0` (i.e. left) roughly 500 times and the result `-1.0` (i.e. right); roughly 500 times, but, of course, the number of each will vary slightly; each time we run it. But what if we want to know the d",MatchSource.DOCS,doc/guide/guide-measurement.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst:7930,Performance,perform,perform,7930,"urement, we want to determine the probability distribution of; a large number of measurements?. One way would be to repeat the measurement many times -- and this is what; happens in many quantum experiments. In QuTiP one could simulate this using:. .. testcode::; :hide:. np.random.seed(42). .. testcode::. results = {1.0: 0, -1.0: 0} # 1 and -1 are the possible outcomes; for _ in range(1000):; value, new_state = measure(up, spin_x); results[round(value)] += 1; print(results). **Output**:. .. testoutput::. {1.0: 497, -1.0: 503}. which measures the x-component of the spin of the `up` state `1000` times and; stores the results in a dictionary. Afterwards we expect to have seen the; result `1.0` (i.e. left) roughly 500 times and the result `-1.0` (i.e. right); roughly 500 times, but, of course, the number of each will vary slightly; each time we run it. But what if we want to know the distribution of results precisely? In a; physical system, we would have to perform the measurement many many times,; but in QuTiP we can peak at the state itself and determine the probability; distribution of the outcomes exactly in a single line:. .. doctest::; :hide:. >>> np.random.seed(42). .. doctest::. >>> eigenvalues, eigenstates, probabilities = measurement_statistics(up, spin_x). >>> eigenvalues # doctest: +NORMALIZE_WHITESPACE; array([-1., 1.]). >>> eigenstates # doctest: +NORMALIZE_WHITESPACE; array([Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[ 0.70710678]; [-0.70710678]],; Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[0.70710678]; [0.70710678]]], dtype=object). >>> probabilities # doctest: +NORMALIZE_WHITESPACE; [0.5000000000000001, 0.4999999999999999]. The :func:`~qutip.measurement.measurement_statistics` function then returns three values; when called with a single observable:. - `eigenvalues` is an array of eigenvalues of the measurement operator, i.e.; a list of the possible measurement results. In our example; ",MatchSource.DOCS,doc/guide/guide-measurement.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst:1052,Testability,test,testcode,1052,"ment of Quantum Objects; ******************************. .. note::; New in QuTiP 4.6. .. _measurement-intro:. Introduction; ------------. Measurement is a fundamental part of the standard formulation of quantum; mechanics and is the process by which classical readings are obtained from; a quantum object. Although the interpretation of the procedure is at times; contentious, the procedure itself is mathematically straightforward and is; described in many good introductory texts. Here we will show you how to perform simple measurement operations on QuTiP; objects. The same functions :func:`~qutip.measurement.measure` and; :func:`~qutip.measurement.measurement_statistics` can be used; to handle both observable-style measurements and projective style measurements. .. _measurement-basic:. Performing a basic measurement (Observable); -------------------------------------------. First we need to select some states to measure. For now, let us create an *up*; state and a *down* state:. .. testcode::. up = basis(2, 0). down = basis(2, 1). which represent spin-1/2 particles with their spin pointing either up or down; along the z-axis. We choose what to measure (in this case) by selecting a **measurement operator**.; For example,; we could select :func:`.sigmaz` which measures the z-component of the; spin of a spin-1/2 particle, or :func:`.sigmax` which measures the; x-component:. .. testcode::. spin_z = sigmaz(). spin_x = sigmax(). How do we know what these operators measure? The answer lies in the measurement; procedure itself:. * A quantum measurement transforms the state being measured by projecting it into; one of the eigenvectors of the measurement operator. * Which eigenvector to project onto is chosen probabilistically according to the; square of the amplitude of the state in the direction of the eigenvector. * The value returned by the measurement is the eigenvalue corresponding to the; chosen eigenvector. .. note::. How to interpret this ""random choosing"" is the famou",MatchSource.DOCS,doc/guide/guide-measurement.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst:1452,Testability,test,testcode,1452," mathematically straightforward and is; described in many good introductory texts. Here we will show you how to perform simple measurement operations on QuTiP; objects. The same functions :func:`~qutip.measurement.measure` and; :func:`~qutip.measurement.measurement_statistics` can be used; to handle both observable-style measurements and projective style measurements. .. _measurement-basic:. Performing a basic measurement (Observable); -------------------------------------------. First we need to select some states to measure. For now, let us create an *up*; state and a *down* state:. .. testcode::. up = basis(2, 0). down = basis(2, 1). which represent spin-1/2 particles with their spin pointing either up or down; along the z-axis. We choose what to measure (in this case) by selecting a **measurement operator**.; For example,; we could select :func:`.sigmaz` which measures the z-component of the; spin of a spin-1/2 particle, or :func:`.sigmax` which measures the; x-component:. .. testcode::. spin_z = sigmaz(). spin_x = sigmax(). How do we know what these operators measure? The answer lies in the measurement; procedure itself:. * A quantum measurement transforms the state being measured by projecting it into; one of the eigenvectors of the measurement operator. * Which eigenvector to project onto is chosen probabilistically according to the; square of the amplitude of the state in the direction of the eigenvector. * The value returned by the measurement is the eigenvalue corresponding to the; chosen eigenvector. .. note::. How to interpret this ""random choosing"" is the famous; ""quantum measurement problem"". The eigenvectors of `spin_z` are the states with their spin pointing either up; or down, so it measures the component of the spin along the z-axis. The eigenvectors of `spin_x` are the states with their spin pointing either; left or right, so it measures the component of the spin along the x-axis. When we measure our `up` and `down` states using the operator `spin",MatchSource.DOCS,doc/guide/guide-measurement.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst:2485,Testability,test,testcode,2485,"= sigmax(). How do we know what these operators measure? The answer lies in the measurement; procedure itself:. * A quantum measurement transforms the state being measured by projecting it into; one of the eigenvectors of the measurement operator. * Which eigenvector to project onto is chosen probabilistically according to the; square of the amplitude of the state in the direction of the eigenvector. * The value returned by the measurement is the eigenvalue corresponding to the; chosen eigenvector. .. note::. How to interpret this ""random choosing"" is the famous; ""quantum measurement problem"". The eigenvectors of `spin_z` are the states with their spin pointing either up; or down, so it measures the component of the spin along the z-axis. The eigenvectors of `spin_x` are the states with their spin pointing either; left or right, so it measures the component of the spin along the x-axis. When we measure our `up` and `down` states using the operator `spin_z`, we; always obtain:. .. testcode::. from qutip.measurement import measure, measurement_statistics. measure(up, spin_z) == (1.0, up). measure(down, spin_z) == (-1.0, down). because `up` is the eigenvector of `spin_z` with eigenvalue `1.0` and `down`; is the eigenvector with eigenvalue `-1.0`. The minus signs are just an; arbitrary global phase -- `up` and `-up` represent the same quantum state. Neither eigenvector has any component in the direction of the other (they are; orthogonal), so `measure(spin_z, up)` returns the state `up` 100% percent of the; time and `measure(spin_z, down)` returns the state `down` 100% of the time. Note how :func:`~qutip.measurement.measure` returns a pair of values. The; first is the measured value, i.e. an eigenvalue of the operator (e.g. `1.0`),; and the second is the state of the quantum system after the measurement,; i.e. an eigenvector of the operator (e.g. `up`). Now let us consider what happens if we measure the x-component of the spin; of `up`:. .. testcode::. measure(up, spin_",MatchSource.DOCS,doc/guide/guide-measurement.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst:3461,Testability,test,testcode,3461,"always obtain:. .. testcode::. from qutip.measurement import measure, measurement_statistics. measure(up, spin_z) == (1.0, up). measure(down, spin_z) == (-1.0, down). because `up` is the eigenvector of `spin_z` with eigenvalue `1.0` and `down`; is the eigenvector with eigenvalue `-1.0`. The minus signs are just an; arbitrary global phase -- `up` and `-up` represent the same quantum state. Neither eigenvector has any component in the direction of the other (they are; orthogonal), so `measure(spin_z, up)` returns the state `up` 100% percent of the; time and `measure(spin_z, down)` returns the state `down` 100% of the time. Note how :func:`~qutip.measurement.measure` returns a pair of values. The; first is the measured value, i.e. an eigenvalue of the operator (e.g. `1.0`),; and the second is the state of the quantum system after the measurement,; i.e. an eigenvector of the operator (e.g. `up`). Now let us consider what happens if we measure the x-component of the spin; of `up`:. .. testcode::. measure(up, spin_x). The `up` state is not an eigenvector of `spin_x`. `spin_x` has two eigenvectors; which we will call `left` and `right`. The `up` state has equal components in; the direction of these two vectors, so measurement will select each of them; 50% of the time. These `left` and `right` states are:. .. testcode::. left = (up - down).unit(). right = (up + down).unit(). When `left` is chosen, the result of the measurement will be `(-1.0, -left)`. When `right` is chosen, the result of measurement with be `(1.0, right)`. .. note::. When :func:`~qutip.measurement.measure` is invoked with the second argument; being an observable, it acts as an alias to; :func:`~qutip.measurement.measure_observable`. Performing a basic measurement (Projective); -------------------------------------------. We can also choose what to measure by specifying a *list of projection operators*. For; example, we could select the projection operators :math:`\ket{0} \bra{0}` and; :math:`\ket{1} \bra{1",MatchSource.DOCS,doc/guide/guide-measurement.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst:3789,Testability,test,testcode,3789,"lobal phase -- `up` and `-up` represent the same quantum state. Neither eigenvector has any component in the direction of the other (they are; orthogonal), so `measure(spin_z, up)` returns the state `up` 100% percent of the; time and `measure(spin_z, down)` returns the state `down` 100% of the time. Note how :func:`~qutip.measurement.measure` returns a pair of values. The; first is the measured value, i.e. an eigenvalue of the operator (e.g. `1.0`),; and the second is the state of the quantum system after the measurement,; i.e. an eigenvector of the operator (e.g. `up`). Now let us consider what happens if we measure the x-component of the spin; of `up`:. .. testcode::. measure(up, spin_x). The `up` state is not an eigenvector of `spin_x`. `spin_x` has two eigenvectors; which we will call `left` and `right`. The `up` state has equal components in; the direction of these two vectors, so measurement will select each of them; 50% of the time. These `left` and `right` states are:. .. testcode::. left = (up - down).unit(). right = (up + down).unit(). When `left` is chosen, the result of the measurement will be `(-1.0, -left)`. When `right` is chosen, the result of measurement with be `(1.0, right)`. .. note::. When :func:`~qutip.measurement.measure` is invoked with the second argument; being an observable, it acts as an alias to; :func:`~qutip.measurement.measure_observable`. Performing a basic measurement (Projective); -------------------------------------------. We can also choose what to measure by specifying a *list of projection operators*. For; example, we could select the projection operators :math:`\ket{0} \bra{0}` and; :math:`\ket{1} \bra{1}` which measure the state in the :math:`\ket{0}, \ket{1}`; basis. Note that these projection operators are simply the projectors determined by; the eigenstates of the :func:`~qutip.operators.sigmaz` operator. .. testcode::. Z0, Z1 = ket2dm(basis(2, 0)), ket2dm(basis(2, 1)). The probabilities and respective output state; are c",MatchSource.DOCS,doc/guide/guide-measurement.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst:4679,Testability,test,testcode,4679,"tors, so measurement will select each of them; 50% of the time. These `left` and `right` states are:. .. testcode::. left = (up - down).unit(). right = (up + down).unit(). When `left` is chosen, the result of the measurement will be `(-1.0, -left)`. When `right` is chosen, the result of measurement with be `(1.0, right)`. .. note::. When :func:`~qutip.measurement.measure` is invoked with the second argument; being an observable, it acts as an alias to; :func:`~qutip.measurement.measure_observable`. Performing a basic measurement (Projective); -------------------------------------------. We can also choose what to measure by specifying a *list of projection operators*. For; example, we could select the projection operators :math:`\ket{0} \bra{0}` and; :math:`\ket{1} \bra{1}` which measure the state in the :math:`\ket{0}, \ket{1}`; basis. Note that these projection operators are simply the projectors determined by; the eigenstates of the :func:`~qutip.operators.sigmaz` operator. .. testcode::. Z0, Z1 = ket2dm(basis(2, 0)), ket2dm(basis(2, 1)). The probabilities and respective output state; are calculated for each projection operator. .. testcode::. measure(up, [Z0, Z1]) == (0, up). measure(down, [Z0, Z1]) == (1, down). In this case, the projection operators are conveniently eigenstates corresponding; to subspaces of dimension :math:`1`. However, this might not be; the case, in which case it is not possible to have unique eigenvalues for each; eigenstate. Suppose we want to measure only the first; qubit in a two-qubit system. Consider the two qubit state :math:`\ket{0+}`. .. testcode::. state_0 = basis(2, 0). state_plus = (basis(2, 0) + basis(2, 1)).unit(). state_0plus = tensor(state_0, state_plus). Now, suppose we want to measure only the first qubit in the computational basis.; We can do that by measuring with the projection operators; :math:`\ket{0}\bra{0} \otimes I` and :math:`\ket{1}\bra{1} \otimes I`. .. testcode::. PZ1 = [tensor(Z0, identity(2)), tensor(Z1, iden",MatchSource.DOCS,doc/guide/guide-measurement.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst:4837,Testability,test,testcode,4837,"down).unit(). When `left` is chosen, the result of the measurement will be `(-1.0, -left)`. When `right` is chosen, the result of measurement with be `(1.0, right)`. .. note::. When :func:`~qutip.measurement.measure` is invoked with the second argument; being an observable, it acts as an alias to; :func:`~qutip.measurement.measure_observable`. Performing a basic measurement (Projective); -------------------------------------------. We can also choose what to measure by specifying a *list of projection operators*. For; example, we could select the projection operators :math:`\ket{0} \bra{0}` and; :math:`\ket{1} \bra{1}` which measure the state in the :math:`\ket{0}, \ket{1}`; basis. Note that these projection operators are simply the projectors determined by; the eigenstates of the :func:`~qutip.operators.sigmaz` operator. .. testcode::. Z0, Z1 = ket2dm(basis(2, 0)), ket2dm(basis(2, 1)). The probabilities and respective output state; are calculated for each projection operator. .. testcode::. measure(up, [Z0, Z1]) == (0, up). measure(down, [Z0, Z1]) == (1, down). In this case, the projection operators are conveniently eigenstates corresponding; to subspaces of dimension :math:`1`. However, this might not be; the case, in which case it is not possible to have unique eigenvalues for each; eigenstate. Suppose we want to measure only the first; qubit in a two-qubit system. Consider the two qubit state :math:`\ket{0+}`. .. testcode::. state_0 = basis(2, 0). state_plus = (basis(2, 0) + basis(2, 1)).unit(). state_0plus = tensor(state_0, state_plus). Now, suppose we want to measure only the first qubit in the computational basis.; We can do that by measuring with the projection operators; :math:`\ket{0}\bra{0} \otimes I` and :math:`\ket{1}\bra{1} \otimes I`. .. testcode::. PZ1 = [tensor(Z0, identity(2)), tensor(Z1, identity(2))]. PZ2 = [tensor(identity(2), Z0), tensor(identity(2), Z1)]. Now, as in the previous example, we can measure by supplying a list of projection operato",MatchSource.DOCS,doc/guide/guide-measurement.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst:5283,Testability,test,testcode,5283,"o choose what to measure by specifying a *list of projection operators*. For; example, we could select the projection operators :math:`\ket{0} \bra{0}` and; :math:`\ket{1} \bra{1}` which measure the state in the :math:`\ket{0}, \ket{1}`; basis. Note that these projection operators are simply the projectors determined by; the eigenstates of the :func:`~qutip.operators.sigmaz` operator. .. testcode::. Z0, Z1 = ket2dm(basis(2, 0)), ket2dm(basis(2, 1)). The probabilities and respective output state; are calculated for each projection operator. .. testcode::. measure(up, [Z0, Z1]) == (0, up). measure(down, [Z0, Z1]) == (1, down). In this case, the projection operators are conveniently eigenstates corresponding; to subspaces of dimension :math:`1`. However, this might not be; the case, in which case it is not possible to have unique eigenvalues for each; eigenstate. Suppose we want to measure only the first; qubit in a two-qubit system. Consider the two qubit state :math:`\ket{0+}`. .. testcode::. state_0 = basis(2, 0). state_plus = (basis(2, 0) + basis(2, 1)).unit(). state_0plus = tensor(state_0, state_plus). Now, suppose we want to measure only the first qubit in the computational basis.; We can do that by measuring with the projection operators; :math:`\ket{0}\bra{0} \otimes I` and :math:`\ket{1}\bra{1} \otimes I`. .. testcode::. PZ1 = [tensor(Z0, identity(2)), tensor(Z1, identity(2))]. PZ2 = [tensor(identity(2), Z0), tensor(identity(2), Z1)]. Now, as in the previous example, we can measure by supplying a list of projection operators; and the state. .. testcode::. measure(state_0plus, PZ1) == (0, state_0plus). The output of the measurement is the index of the measurement outcome as well; as the output state on the full Hilbert space of the input state. It is crucial to; note that we do not discard the measured qubit after measurement (as opposed to; when measuring on quantum hardware). .. note::. When :func:`~qutip.measurement.measure` is invoked with the second argume",MatchSource.DOCS,doc/guide/guide-measurement.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst:5625,Testability,test,testcode,5625,"the :func:`~qutip.operators.sigmaz` operator. .. testcode::. Z0, Z1 = ket2dm(basis(2, 0)), ket2dm(basis(2, 1)). The probabilities and respective output state; are calculated for each projection operator. .. testcode::. measure(up, [Z0, Z1]) == (0, up). measure(down, [Z0, Z1]) == (1, down). In this case, the projection operators are conveniently eigenstates corresponding; to subspaces of dimension :math:`1`. However, this might not be; the case, in which case it is not possible to have unique eigenvalues for each; eigenstate. Suppose we want to measure only the first; qubit in a two-qubit system. Consider the two qubit state :math:`\ket{0+}`. .. testcode::. state_0 = basis(2, 0). state_plus = (basis(2, 0) + basis(2, 1)).unit(). state_0plus = tensor(state_0, state_plus). Now, suppose we want to measure only the first qubit in the computational basis.; We can do that by measuring with the projection operators; :math:`\ket{0}\bra{0} \otimes I` and :math:`\ket{1}\bra{1} \otimes I`. .. testcode::. PZ1 = [tensor(Z0, identity(2)), tensor(Z1, identity(2))]. PZ2 = [tensor(identity(2), Z0), tensor(identity(2), Z1)]. Now, as in the previous example, we can measure by supplying a list of projection operators; and the state. .. testcode::. measure(state_0plus, PZ1) == (0, state_0plus). The output of the measurement is the index of the measurement outcome as well; as the output state on the full Hilbert space of the input state. It is crucial to; note that we do not discard the measured qubit after measurement (as opposed to; when measuring on quantum hardware). .. note::. When :func:`~qutip.measurement.measure` is invoked with the second argument; being a list of projectors, it acts as an alias to; :func:`~qutip.measurement.measure_povm`. The :func:`~qutip.measurement.measure` function can perform measurements on; density matrices too. You can read about these and other details at; :func:`~qutip.measurement.measure_povm` and :func:`~qutip.measurement.measure_observable`. Now you ",MatchSource.DOCS,doc/guide/guide-measurement.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst:5864,Testability,test,testcode,5864,") == (0, up). measure(down, [Z0, Z1]) == (1, down). In this case, the projection operators are conveniently eigenstates corresponding; to subspaces of dimension :math:`1`. However, this might not be; the case, in which case it is not possible to have unique eigenvalues for each; eigenstate. Suppose we want to measure only the first; qubit in a two-qubit system. Consider the two qubit state :math:`\ket{0+}`. .. testcode::. state_0 = basis(2, 0). state_plus = (basis(2, 0) + basis(2, 1)).unit(). state_0plus = tensor(state_0, state_plus). Now, suppose we want to measure only the first qubit in the computational basis.; We can do that by measuring with the projection operators; :math:`\ket{0}\bra{0} \otimes I` and :math:`\ket{1}\bra{1} \otimes I`. .. testcode::. PZ1 = [tensor(Z0, identity(2)), tensor(Z1, identity(2))]. PZ2 = [tensor(identity(2), Z0), tensor(identity(2), Z1)]. Now, as in the previous example, we can measure by supplying a list of projection operators; and the state. .. testcode::. measure(state_0plus, PZ1) == (0, state_0plus). The output of the measurement is the index of the measurement outcome as well; as the output state on the full Hilbert space of the input state. It is crucial to; note that we do not discard the measured qubit after measurement (as opposed to; when measuring on quantum hardware). .. note::. When :func:`~qutip.measurement.measure` is invoked with the second argument; being a list of projectors, it acts as an alias to; :func:`~qutip.measurement.measure_povm`. The :func:`~qutip.measurement.measure` function can perform measurements on; density matrices too. You can read about these and other details at; :func:`~qutip.measurement.measure_povm` and :func:`~qutip.measurement.measure_observable`. Now you know how to measure quantum states in QuTiP!. .. _measurement-statistics:. Obtaining measurement statistics(Observable); --------------------------------------------. You've just learned how to perform measurements in QuTiP, but you've als",MatchSource.DOCS,doc/guide/guide-measurement.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst:7214,Testability,test,testcode,7214,"nc:`~qutip.measurement.measure` is invoked with the second argument; being a list of projectors, it acts as an alias to; :func:`~qutip.measurement.measure_povm`. The :func:`~qutip.measurement.measure` function can perform measurements on; density matrices too. You can read about these and other details at; :func:`~qutip.measurement.measure_povm` and :func:`~qutip.measurement.measure_observable`. Now you know how to measure quantum states in QuTiP!. .. _measurement-statistics:. Obtaining measurement statistics(Observable); --------------------------------------------. You've just learned how to perform measurements in QuTiP, but you've also; learned that measurements are probabilistic. What if instead of just making; a single measurement, we want to determine the probability distribution of; a large number of measurements?. One way would be to repeat the measurement many times -- and this is what; happens in many quantum experiments. In QuTiP one could simulate this using:. .. testcode::; :hide:. np.random.seed(42). .. testcode::. results = {1.0: 0, -1.0: 0} # 1 and -1 are the possible outcomes; for _ in range(1000):; value, new_state = measure(up, spin_x); results[round(value)] += 1; print(results). **Output**:. .. testoutput::. {1.0: 497, -1.0: 503}. which measures the x-component of the spin of the `up` state `1000` times and; stores the results in a dictionary. Afterwards we expect to have seen the; result `1.0` (i.e. left) roughly 500 times and the result `-1.0` (i.e. right); roughly 500 times, but, of course, the number of each will vary slightly; each time we run it. But what if we want to know the distribution of results precisely? In a; physical system, we would have to perform the measurement many many times,; but in QuTiP we can peak at the state itself and determine the probability; distribution of the outcomes exactly in a single line:. .. doctest::; :hide:. >>> np.random.seed(42). .. doctest::. >>> eigenvalues, eigenstates, probabilities = measurement_s",MatchSource.DOCS,doc/guide/guide-measurement.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst:7257,Testability,test,testcode,7257,"ked with the second argument; being a list of projectors, it acts as an alias to; :func:`~qutip.measurement.measure_povm`. The :func:`~qutip.measurement.measure` function can perform measurements on; density matrices too. You can read about these and other details at; :func:`~qutip.measurement.measure_povm` and :func:`~qutip.measurement.measure_observable`. Now you know how to measure quantum states in QuTiP!. .. _measurement-statistics:. Obtaining measurement statistics(Observable); --------------------------------------------. You've just learned how to perform measurements in QuTiP, but you've also; learned that measurements are probabilistic. What if instead of just making; a single measurement, we want to determine the probability distribution of; a large number of measurements?. One way would be to repeat the measurement many times -- and this is what; happens in many quantum experiments. In QuTiP one could simulate this using:. .. testcode::; :hide:. np.random.seed(42). .. testcode::. results = {1.0: 0, -1.0: 0} # 1 and -1 are the possible outcomes; for _ in range(1000):; value, new_state = measure(up, spin_x); results[round(value)] += 1; print(results). **Output**:. .. testoutput::. {1.0: 497, -1.0: 503}. which measures the x-component of the spin of the `up` state `1000` times and; stores the results in a dictionary. Afterwards we expect to have seen the; result `1.0` (i.e. left) roughly 500 times and the result `-1.0` (i.e. right); roughly 500 times, but, of course, the number of each will vary slightly; each time we run it. But what if we want to know the distribution of results precisely? In a; physical system, we would have to perform the measurement many many times,; but in QuTiP we can peak at the state itself and determine the probability; distribution of the outcomes exactly in a single line:. .. doctest::; :hide:. >>> np.random.seed(42). .. doctest::. >>> eigenvalues, eigenstates, probabilities = measurement_statistics(up, spin_x). >>> eigenvalues ",MatchSource.DOCS,doc/guide/guide-measurement.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst:7458,Testability,test,testoutput,7458,"nsity matrices too. You can read about these and other details at; :func:`~qutip.measurement.measure_povm` and :func:`~qutip.measurement.measure_observable`. Now you know how to measure quantum states in QuTiP!. .. _measurement-statistics:. Obtaining measurement statistics(Observable); --------------------------------------------. You've just learned how to perform measurements in QuTiP, but you've also; learned that measurements are probabilistic. What if instead of just making; a single measurement, we want to determine the probability distribution of; a large number of measurements?. One way would be to repeat the measurement many times -- and this is what; happens in many quantum experiments. In QuTiP one could simulate this using:. .. testcode::; :hide:. np.random.seed(42). .. testcode::. results = {1.0: 0, -1.0: 0} # 1 and -1 are the possible outcomes; for _ in range(1000):; value, new_state = measure(up, spin_x); results[round(value)] += 1; print(results). **Output**:. .. testoutput::. {1.0: 497, -1.0: 503}. which measures the x-component of the spin of the `up` state `1000` times and; stores the results in a dictionary. Afterwards we expect to have seen the; result `1.0` (i.e. left) roughly 500 times and the result `-1.0` (i.e. right); roughly 500 times, but, of course, the number of each will vary slightly; each time we run it. But what if we want to know the distribution of results precisely? In a; physical system, we would have to perform the measurement many many times,; but in QuTiP we can peak at the state itself and determine the probability; distribution of the outcomes exactly in a single line:. .. doctest::; :hide:. >>> np.random.seed(42). .. doctest::. >>> eigenvalues, eigenstates, probabilities = measurement_statistics(up, spin_x). >>> eigenvalues # doctest: +NORMALIZE_WHITESPACE; array([-1., 1.]). >>> eigenstates # doctest: +NORMALIZE_WHITESPACE; array([Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[ 0.70710678]; [",MatchSource.DOCS,doc/guide/guide-measurement.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst:10437,Testability,test,testcode,10437,"ee lists are in the same order -- i.e. the first eigenvalue is; `eigenvalues[0]`, its corresponding eigenstate is `eigenstates[0]`, and; its probability is `probabilities[0]`, and so on. .. note::. When :func:`~qutip.measurement.measurement_statistics`; is invoked with the second argument; being an observable, it acts as an alias to; :func:`~qutip.measurement.measurement_statistics_observable`. Obtaining measurement statistics(Projective); --------------------------------------------. Similarly, when we want to obtain measurement statistics for projection operators,; we can use the `measurement_statistics` function with the second argument being a list of projectors.; Consider again, the state :math:`\ket{0+}`.; Suppose, now we want to obtain the measurement outcomes for the second qubit. We; must use the projectors specified earlier by `PZ2` which allow us to measure only; on the second qubit. Since the second qubit has the state :math:`\ket{+}`, we get; the following result. .. testcode::. collapsed_states, probabilities = measurement_statistics(state_0plus, PZ2). print(collapsed_states). **Output**:. .. testoutput::; :options: +NORMALIZE_WHITESPACE. [Quantum object: dims = [[2, 2], [1, 1]], shape = (4, 1), type = ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]], Quantum object: dims = [[2, 2], [1, 1]], shape = (4, 1), type = ket; Qobj data =; [[0.]; [1.]; [0.]; [0.]]]. .. testcode::. print(probabilities). **Output**:. .. testoutput::; :options: +NORMALIZE_WHITESPACE. [0.4999999999999999, 0.4999999999999999]. The function :func:`~qutip.measurement.measurement_statistics` then returns two values:. * `collapsed_states` is an array of the possible final states after the; measurement is complete. Each element of the array is a :obj:`.Qobj`. * `probabilities` is a list of the probabilities of each measurement outcome. Note that the collapsed_states are exactly :math:`\ket{00}` and :math:`\ket{01}`; with equal probability, as expected. The two lists are in the same order. .. ",MatchSource.DOCS,doc/guide/guide-measurement.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst:10566,Testability,test,testoutput,10566,"bility is `probabilities[0]`, and so on. .. note::. When :func:`~qutip.measurement.measurement_statistics`; is invoked with the second argument; being an observable, it acts as an alias to; :func:`~qutip.measurement.measurement_statistics_observable`. Obtaining measurement statistics(Projective); --------------------------------------------. Similarly, when we want to obtain measurement statistics for projection operators,; we can use the `measurement_statistics` function with the second argument being a list of projectors.; Consider again, the state :math:`\ket{0+}`.; Suppose, now we want to obtain the measurement outcomes for the second qubit. We; must use the projectors specified earlier by `PZ2` which allow us to measure only; on the second qubit. Since the second qubit has the state :math:`\ket{+}`, we get; the following result. .. testcode::. collapsed_states, probabilities = measurement_statistics(state_0plus, PZ2). print(collapsed_states). **Output**:. .. testoutput::; :options: +NORMALIZE_WHITESPACE. [Quantum object: dims = [[2, 2], [1, 1]], shape = (4, 1), type = ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]], Quantum object: dims = [[2, 2], [1, 1]], shape = (4, 1), type = ket; Qobj data =; [[0.]; [1.]; [0.]; [0.]]]. .. testcode::. print(probabilities). **Output**:. .. testoutput::; :options: +NORMALIZE_WHITESPACE. [0.4999999999999999, 0.4999999999999999]. The function :func:`~qutip.measurement.measurement_statistics` then returns two values:. * `collapsed_states` is an array of the possible final states after the; measurement is complete. Each element of the array is a :obj:`.Qobj`. * `probabilities` is a list of the probabilities of each measurement outcome. Note that the collapsed_states are exactly :math:`\ket{00}` and :math:`\ket{01}`; with equal probability, as expected. The two lists are in the same order. .. note::. When :func:`~qutip.measurement.measurement_statistics`; is invoked with the second argument; being a list of projectors, it acts as an alia",MatchSource.DOCS,doc/guide/guide-measurement.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst:10834,Testability,test,testcode,10834," Obtaining measurement statistics(Projective); --------------------------------------------. Similarly, when we want to obtain measurement statistics for projection operators,; we can use the `measurement_statistics` function with the second argument being a list of projectors.; Consider again, the state :math:`\ket{0+}`.; Suppose, now we want to obtain the measurement outcomes for the second qubit. We; must use the projectors specified earlier by `PZ2` which allow us to measure only; on the second qubit. Since the second qubit has the state :math:`\ket{+}`, we get; the following result. .. testcode::. collapsed_states, probabilities = measurement_statistics(state_0plus, PZ2). print(collapsed_states). **Output**:. .. testoutput::; :options: +NORMALIZE_WHITESPACE. [Quantum object: dims = [[2, 2], [1, 1]], shape = (4, 1), type = ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]], Quantum object: dims = [[2, 2], [1, 1]], shape = (4, 1), type = ket; Qobj data =; [[0.]; [1.]; [0.]; [0.]]]. .. testcode::. print(probabilities). **Output**:. .. testoutput::; :options: +NORMALIZE_WHITESPACE. [0.4999999999999999, 0.4999999999999999]. The function :func:`~qutip.measurement.measurement_statistics` then returns two values:. * `collapsed_states` is an array of the possible final states after the; measurement is complete. Each element of the array is a :obj:`.Qobj`. * `probabilities` is a list of the probabilities of each measurement outcome. Note that the collapsed_states are exactly :math:`\ket{00}` and :math:`\ket{01}`; with equal probability, as expected. The two lists are in the same order. .. note::. When :func:`~qutip.measurement.measurement_statistics`; is invoked with the second argument; being a list of projectors, it acts as an alias to; :func:`~qutip.measurement.measurement_statistics_povm`. The :func:`~qutip.measurement.measurement_statistics` function can provide statistics for measurements; of density matrices too.; You can read about these and other details at; :func:`~qut",MatchSource.DOCS,doc/guide/guide-measurement.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst:10884,Testability,test,testoutput,10884,"------------------------. Similarly, when we want to obtain measurement statistics for projection operators,; we can use the `measurement_statistics` function with the second argument being a list of projectors.; Consider again, the state :math:`\ket{0+}`.; Suppose, now we want to obtain the measurement outcomes for the second qubit. We; must use the projectors specified earlier by `PZ2` which allow us to measure only; on the second qubit. Since the second qubit has the state :math:`\ket{+}`, we get; the following result. .. testcode::. collapsed_states, probabilities = measurement_statistics(state_0plus, PZ2). print(collapsed_states). **Output**:. .. testoutput::; :options: +NORMALIZE_WHITESPACE. [Quantum object: dims = [[2, 2], [1, 1]], shape = (4, 1), type = ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]], Quantum object: dims = [[2, 2], [1, 1]], shape = (4, 1), type = ket; Qobj data =; [[0.]; [1.]; [0.]; [0.]]]. .. testcode::. print(probabilities). **Output**:. .. testoutput::; :options: +NORMALIZE_WHITESPACE. [0.4999999999999999, 0.4999999999999999]. The function :func:`~qutip.measurement.measurement_statistics` then returns two values:. * `collapsed_states` is an array of the possible final states after the; measurement is complete. Each element of the array is a :obj:`.Qobj`. * `probabilities` is a list of the probabilities of each measurement outcome. Note that the collapsed_states are exactly :math:`\ket{00}` and :math:`\ket{01}`; with equal probability, as expected. The two lists are in the same order. .. note::. When :func:`~qutip.measurement.measurement_statistics`; is invoked with the second argument; being a list of projectors, it acts as an alias to; :func:`~qutip.measurement.measurement_statistics_povm`. The :func:`~qutip.measurement.measurement_statistics` function can provide statistics for measurements; of density matrices too.; You can read about these and other details at; :func:`~qutip.measurement.measurement_statistics_observable`; and :func:`~qutip",MatchSource.DOCS,doc/guide/guide-measurement.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst:577,Usability,simpl,simple,577,".. _measurement:. ******************************; Measurement of Quantum Objects; ******************************. .. note::; New in QuTiP 4.6. .. _measurement-intro:. Introduction; ------------. Measurement is a fundamental part of the standard formulation of quantum; mechanics and is the process by which classical readings are obtained from; a quantum object. Although the interpretation of the procedure is at times; contentious, the procedure itself is mathematically straightforward and is; described in many good introductory texts. Here we will show you how to perform simple measurement operations on QuTiP; objects. The same functions :func:`~qutip.measurement.measure` and; :func:`~qutip.measurement.measurement_statistics` can be used; to handle both observable-style measurements and projective style measurements. .. _measurement-basic:. Performing a basic measurement (Observable); -------------------------------------------. First we need to select some states to measure. For now, let us create an *up*; state and a *down* state:. .. testcode::. up = basis(2, 0). down = basis(2, 1). which represent spin-1/2 particles with their spin pointing either up or down; along the z-axis. We choose what to measure (in this case) by selecting a **measurement operator**.; For example,; we could select :func:`.sigmaz` which measures the z-component of the; spin of a spin-1/2 particle, or :func:`.sigmax` which measures the; x-component:. .. testcode::. spin_z = sigmaz(). spin_x = sigmax(). How do we know what these operators measure? The answer lies in the measurement; procedure itself:. * A quantum measurement transforms the state being measured by projecting it into; one of the eigenvectors of the measurement operator. * Which eigenvector to project onto is chosen probabilistically according to the; square of the amplitude of the state in the direction of the eigenvector. * The value returned by the measurement is the eigenvalue corresponding to the; chosen eigenvector. .. note",MatchSource.DOCS,doc/guide/guide-measurement.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst:4574,Usability,simpl,simply,4574,"all `left` and `right`. The `up` state has equal components in; the direction of these two vectors, so measurement will select each of them; 50% of the time. These `left` and `right` states are:. .. testcode::. left = (up - down).unit(). right = (up + down).unit(). When `left` is chosen, the result of the measurement will be `(-1.0, -left)`. When `right` is chosen, the result of measurement with be `(1.0, right)`. .. note::. When :func:`~qutip.measurement.measure` is invoked with the second argument; being an observable, it acts as an alias to; :func:`~qutip.measurement.measure_observable`. Performing a basic measurement (Projective); -------------------------------------------. We can also choose what to measure by specifying a *list of projection operators*. For; example, we could select the projection operators :math:`\ket{0} \bra{0}` and; :math:`\ket{1} \bra{1}` which measure the state in the :math:`\ket{0}, \ket{1}`; basis. Note that these projection operators are simply the projectors determined by; the eigenstates of the :func:`~qutip.operators.sigmaz` operator. .. testcode::. Z0, Z1 = ket2dm(basis(2, 0)), ket2dm(basis(2, 1)). The probabilities and respective output state; are calculated for each projection operator. .. testcode::. measure(up, [Z0, Z1]) == (0, up). measure(down, [Z0, Z1]) == (1, down). In this case, the projection operators are conveniently eigenstates corresponding; to subspaces of dimension :math:`1`. However, this might not be; the case, in which case it is not possible to have unique eigenvalues for each; eigenstate. Suppose we want to measure only the first; qubit in a two-qubit system. Consider the two qubit state :math:`\ket{0+}`. .. testcode::. state_0 = basis(2, 0). state_plus = (basis(2, 0) + basis(2, 1)).unit(). state_0plus = tensor(state_0, state_plus). Now, suppose we want to measure only the first qubit in the computational basis.; We can do that by measuring with the projection operators; :math:`\ket{0}\bra{0} \otimes I` and :m",MatchSource.DOCS,doc/guide/guide-measurement.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst:6809,Usability,learn,learned,6809,"ate. .. testcode::. measure(state_0plus, PZ1) == (0, state_0plus). The output of the measurement is the index of the measurement outcome as well; as the output state on the full Hilbert space of the input state. It is crucial to; note that we do not discard the measured qubit after measurement (as opposed to; when measuring on quantum hardware). .. note::. When :func:`~qutip.measurement.measure` is invoked with the second argument; being a list of projectors, it acts as an alias to; :func:`~qutip.measurement.measure_povm`. The :func:`~qutip.measurement.measure` function can perform measurements on; density matrices too. You can read about these and other details at; :func:`~qutip.measurement.measure_povm` and :func:`~qutip.measurement.measure_observable`. Now you know how to measure quantum states in QuTiP!. .. _measurement-statistics:. Obtaining measurement statistics(Observable); --------------------------------------------. You've just learned how to perform measurements in QuTiP, but you've also; learned that measurements are probabilistic. What if instead of just making; a single measurement, we want to determine the probability distribution of; a large number of measurements?. One way would be to repeat the measurement many times -- and this is what; happens in many quantum experiments. In QuTiP one could simulate this using:. .. testcode::; :hide:. np.random.seed(42). .. testcode::. results = {1.0: 0, -1.0: 0} # 1 and -1 are the possible outcomes; for _ in range(1000):; value, new_state = measure(up, spin_x); results[round(value)] += 1; print(results). **Output**:. .. testoutput::. {1.0: 497, -1.0: 503}. which measures the x-component of the spin of the `up` state `1000` times and; stores the results in a dictionary. Afterwards we expect to have seen the; result `1.0` (i.e. left) roughly 500 times and the result `-1.0` (i.e. right); roughly 500 times, but, of course, the number of each will vary slightly; each time we run it. But what if we want to know the d",MatchSource.DOCS,doc/guide/guide-measurement.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst:6872,Usability,learn,learned,6872,"ate. .. testcode::. measure(state_0plus, PZ1) == (0, state_0plus). The output of the measurement is the index of the measurement outcome as well; as the output state on the full Hilbert space of the input state. It is crucial to; note that we do not discard the measured qubit after measurement (as opposed to; when measuring on quantum hardware). .. note::. When :func:`~qutip.measurement.measure` is invoked with the second argument; being a list of projectors, it acts as an alias to; :func:`~qutip.measurement.measure_povm`. The :func:`~qutip.measurement.measure` function can perform measurements on; density matrices too. You can read about these and other details at; :func:`~qutip.measurement.measure_povm` and :func:`~qutip.measurement.measure_observable`. Now you know how to measure quantum states in QuTiP!. .. _measurement-statistics:. Obtaining measurement statistics(Observable); --------------------------------------------. You've just learned how to perform measurements in QuTiP, but you've also; learned that measurements are probabilistic. What if instead of just making; a single measurement, we want to determine the probability distribution of; a large number of measurements?. One way would be to repeat the measurement many times -- and this is what; happens in many quantum experiments. In QuTiP one could simulate this using:. .. testcode::; :hide:. np.random.seed(42). .. testcode::. results = {1.0: 0, -1.0: 0} # 1 and -1 are the possible outcomes; for _ in range(1000):; value, new_state = measure(up, spin_x); results[round(value)] += 1; print(results). **Output**:. .. testoutput::. {1.0: 497, -1.0: 503}. which measures the x-component of the spin of the `up` state `1000` times and; stores the results in a dictionary. Afterwards we expect to have seen the; result `1.0` (i.e. left) roughly 500 times and the result `-1.0` (i.e. right); roughly 500 times, but, of course, the number of each will vary slightly; each time we run it. But what if we want to know the d",MatchSource.DOCS,doc/guide/guide-measurement.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-overview.rst:979,Availability,avail,available,979,".. _overview:. ******************; Guide Overview; ******************. The goal of this guide is to introduce you to the basic structures and functions that make up QuTiP. This guide is divided up into several ; sections, each highlighting a specific set of functionalities. In combination with the examples that can be found on the project ; web page `https://qutip.org/tutorials.html <https://qutip.org/tutorials.html>`_, this guide should provide a more or less complete overview ; of QuTip. We also provide the API documentation in :ref:`apidoc`. .. _overview-org:. Organization; =============. QuTiP is designed to be a general framework for solving quantum mechanics problems such as systems composed of few-level quantum systems and harmonic oscillators. To this end, QuTiP is built from a large (and ever growing) library of functions and classes; from :func:`qutip.states.basis` to :func:`qutip.wigner`. The general organization of QuTiP, highlighting the important API available to the user, is shown in the figure below. .. _figure-qutip-org:. .. figure:: figures/qutip_tree.png; :align: center; :figwidth: 100%. Tree-diagram of the 468 user accessible functions and classes in QuTiP 4.6. A vector image of the code tree is in :download:`qutip_tree.pdf <doc/qutip_tree.pdf>`. ",MatchSource.DOCS,doc/guide/guide-overview.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-overview.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-overview.rst:1239,Availability,down,download,1239,".. _overview:. ******************; Guide Overview; ******************. The goal of this guide is to introduce you to the basic structures and functions that make up QuTiP. This guide is divided up into several ; sections, each highlighting a specific set of functionalities. In combination with the examples that can be found on the project ; web page `https://qutip.org/tutorials.html <https://qutip.org/tutorials.html>`_, this guide should provide a more or less complete overview ; of QuTip. We also provide the API documentation in :ref:`apidoc`. .. _overview-org:. Organization; =============. QuTiP is designed to be a general framework for solving quantum mechanics problems such as systems composed of few-level quantum systems and harmonic oscillators. To this end, QuTiP is built from a large (and ever growing) library of functions and classes; from :func:`qutip.states.basis` to :func:`qutip.wigner`. The general organization of QuTiP, highlighting the important API available to the user, is shown in the figure below. .. _figure-qutip-org:. .. figure:: figures/qutip_tree.png; :align: center; :figwidth: 100%. Tree-diagram of the 468 user accessible functions and classes in QuTiP 4.6. A vector image of the code tree is in :download:`qutip_tree.pdf <doc/qutip_tree.pdf>`. ",MatchSource.DOCS,doc/guide/guide-overview.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-overview.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-overview.rst:1153,Security,access,accessible,1153,".. _overview:. ******************; Guide Overview; ******************. The goal of this guide is to introduce you to the basic structures and functions that make up QuTiP. This guide is divided up into several ; sections, each highlighting a specific set of functionalities. In combination with the examples that can be found on the project ; web page `https://qutip.org/tutorials.html <https://qutip.org/tutorials.html>`_, this guide should provide a more or less complete overview ; of QuTip. We also provide the API documentation in :ref:`apidoc`. .. _overview-org:. Organization; =============. QuTiP is designed to be a general framework for solving quantum mechanics problems such as systems composed of few-level quantum systems and harmonic oscillators. To this end, QuTiP is built from a large (and ever growing) library of functions and classes; from :func:`qutip.states.basis` to :func:`qutip.wigner`. The general organization of QuTiP, highlighting the important API available to the user, is shown in the figure below. .. _figure-qutip-org:. .. figure:: figures/qutip_tree.png; :align: center; :figwidth: 100%. Tree-diagram of the 468 user accessible functions and classes in QuTiP 4.6. A vector image of the code tree is in :download:`qutip_tree.pdf <doc/qutip_tree.pdf>`. ",MatchSource.DOCS,doc/guide/guide-overview.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-overview.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-overview.rst:88,Usability,guid,guide,88,".. _overview:. ******************; Guide Overview; ******************. The goal of this guide is to introduce you to the basic structures and functions that make up QuTiP. This guide is divided up into several ; sections, each highlighting a specific set of functionalities. In combination with the examples that can be found on the project ; web page `https://qutip.org/tutorials.html <https://qutip.org/tutorials.html>`_, this guide should provide a more or less complete overview ; of QuTip. We also provide the API documentation in :ref:`apidoc`. .. _overview-org:. Organization; =============. QuTiP is designed to be a general framework for solving quantum mechanics problems such as systems composed of few-level quantum systems and harmonic oscillators. To this end, QuTiP is built from a large (and ever growing) library of functions and classes; from :func:`qutip.states.basis` to :func:`qutip.wigner`. The general organization of QuTiP, highlighting the important API available to the user, is shown in the figure below. .. _figure-qutip-org:. .. figure:: figures/qutip_tree.png; :align: center; :figwidth: 100%. Tree-diagram of the 468 user accessible functions and classes in QuTiP 4.6. A vector image of the code tree is in :download:`qutip_tree.pdf <doc/qutip_tree.pdf>`. ",MatchSource.DOCS,doc/guide/guide-overview.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-overview.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-overview.rst:177,Usability,guid,guide,177,".. _overview:. ******************; Guide Overview; ******************. The goal of this guide is to introduce you to the basic structures and functions that make up QuTiP. This guide is divided up into several ; sections, each highlighting a specific set of functionalities. In combination with the examples that can be found on the project ; web page `https://qutip.org/tutorials.html <https://qutip.org/tutorials.html>`_, this guide should provide a more or less complete overview ; of QuTip. We also provide the API documentation in :ref:`apidoc`. .. _overview-org:. Organization; =============. QuTiP is designed to be a general framework for solving quantum mechanics problems such as systems composed of few-level quantum systems and harmonic oscillators. To this end, QuTiP is built from a large (and ever growing) library of functions and classes; from :func:`qutip.states.basis` to :func:`qutip.wigner`. The general organization of QuTiP, highlighting the important API available to the user, is shown in the figure below. .. _figure-qutip-org:. .. figure:: figures/qutip_tree.png; :align: center; :figwidth: 100%. Tree-diagram of the 468 user accessible functions and classes in QuTiP 4.6. A vector image of the code tree is in :download:`qutip_tree.pdf <doc/qutip_tree.pdf>`. ",MatchSource.DOCS,doc/guide/guide-overview.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-overview.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-overview.rst:429,Usability,guid,guide,429,".. _overview:. ******************; Guide Overview; ******************. The goal of this guide is to introduce you to the basic structures and functions that make up QuTiP. This guide is divided up into several ; sections, each highlighting a specific set of functionalities. In combination with the examples that can be found on the project ; web page `https://qutip.org/tutorials.html <https://qutip.org/tutorials.html>`_, this guide should provide a more or less complete overview ; of QuTip. We also provide the API documentation in :ref:`apidoc`. .. _overview-org:. Organization; =============. QuTiP is designed to be a general framework for solving quantum mechanics problems such as systems composed of few-level quantum systems and harmonic oscillators. To this end, QuTiP is built from a large (and ever growing) library of functions and classes; from :func:`qutip.states.basis` to :func:`qutip.wigner`. The general organization of QuTiP, highlighting the important API available to the user, is shown in the figure below. .. _figure-qutip-org:. .. figure:: figures/qutip_tree.png; :align: center; :figwidth: 100%. Tree-diagram of the 468 user accessible functions and classes in QuTiP 4.6. A vector image of the code tree is in :download:`qutip_tree.pdf <doc/qutip_tree.pdf>`. ",MatchSource.DOCS,doc/guide/guide-overview.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-overview.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-piqs.rst:2107,Usability,simpl,simply,2107,"um_{n=1}^{N}\left(; \frac{\gamma_\text{E}}{2}\mathcal{L}_{J_{-,n}}[\rho]; +\frac{\gamma_\text{D}}{2}\mathcal{L}_{J_{z,n}}[\rho]; +\frac{\gamma_\text{P}}{2}\mathcal{L}_{J_{+,n}}[\rho]\right). where :math:`J_{\alpha,n}=\frac{1}{2}\sigma_{\alpha,n}` are SU(2) Pauli spin operators, with :math:`{\alpha=x,y,z}` and :math:`J_{\pm,n}=\sigma_{\pm,n}`. The collective spin operators are :math:`J_{\alpha} = \sum_{n}J_{\alpha,n}` . The Lindblad super-operators are :math:`\mathcal{L}_{A} = 2A\rho A^\dagger - A^\dagger A \rho - \rho A^\dagger A`. The inclusion of local processes in the dynamics lead to using a Liouvillian space of dimension :math:`4^N`. By exploiting the permutational invariance of identical particles [2-8], the Liouvillian :math:`\mathcal{D}_\text{TLS}(\rho)` can be built as a block-diagonal matrix in the basis of Dicke states :math:`|j, m \rangle`. The system under study is defined by creating an object of the; :class:`~qutip.piqs.piqs.Dicke` class, e.g. simply named; :code:`system`, whose first attribute is. - :code:`system.N`, the number of TLSs of the system :math:`N`. The rates for collective and local processes are simply defined as. - :code:`collective_emission` defines :math:`\gamma_\text{CE}`, collective (superradiant) emission; - :code:`collective_dephasing` defines :math:`\gamma_\text{CD}`, collective dephasing; - :code:`collective_pumping` defines :math:`\gamma_\text{CP}`, collective pumping.; - :code:`emission` defines :math:`\gamma_\text{E}`, incoherent emission (losses); - :code:`dephasing` defines :math:`\gamma_\text{D}`, local dephasing; - :code:`pumping` defines :math:`\gamma_\text{P}`, incoherent pumping. Then the :code:`system.lindbladian()` creates the total TLS Lindbladian superoperator matrix. Similarly, :code:`system.hamiltonian` defines the TLS hamiltonian of the system :math:`H_\text{TLS}`. The system's Liouvillian can be built using :code:`system.liouvillian()`.; The properties of a Piqs object can be visualized by simply calling :code:",MatchSource.DOCS,doc/guide/guide-piqs.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-piqs.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-piqs.rst:2276,Usability,simpl,simply,2276,"]; +\frac{\gamma_\text{P}}{2}\mathcal{L}_{J_{+,n}}[\rho]\right). where :math:`J_{\alpha,n}=\frac{1}{2}\sigma_{\alpha,n}` are SU(2) Pauli spin operators, with :math:`{\alpha=x,y,z}` and :math:`J_{\pm,n}=\sigma_{\pm,n}`. The collective spin operators are :math:`J_{\alpha} = \sum_{n}J_{\alpha,n}` . The Lindblad super-operators are :math:`\mathcal{L}_{A} = 2A\rho A^\dagger - A^\dagger A \rho - \rho A^\dagger A`. The inclusion of local processes in the dynamics lead to using a Liouvillian space of dimension :math:`4^N`. By exploiting the permutational invariance of identical particles [2-8], the Liouvillian :math:`\mathcal{D}_\text{TLS}(\rho)` can be built as a block-diagonal matrix in the basis of Dicke states :math:`|j, m \rangle`. The system under study is defined by creating an object of the; :class:`~qutip.piqs.piqs.Dicke` class, e.g. simply named; :code:`system`, whose first attribute is. - :code:`system.N`, the number of TLSs of the system :math:`N`. The rates for collective and local processes are simply defined as. - :code:`collective_emission` defines :math:`\gamma_\text{CE}`, collective (superradiant) emission; - :code:`collective_dephasing` defines :math:`\gamma_\text{CD}`, collective dephasing; - :code:`collective_pumping` defines :math:`\gamma_\text{CP}`, collective pumping.; - :code:`emission` defines :math:`\gamma_\text{E}`, incoherent emission (losses); - :code:`dephasing` defines :math:`\gamma_\text{D}`, local dephasing; - :code:`pumping` defines :math:`\gamma_\text{P}`, incoherent pumping. Then the :code:`system.lindbladian()` creates the total TLS Lindbladian superoperator matrix. Similarly, :code:`system.hamiltonian` defines the TLS hamiltonian of the system :math:`H_\text{TLS}`. The system's Liouvillian can be built using :code:`system.liouvillian()`.; The properties of a Piqs object can be visualized by simply calling :code:`system`.; We give two basic examples on the use of *PIQS*.; In the first example the incoherent emission of N driven TLSs is ",MatchSource.DOCS,doc/guide/guide-piqs.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-piqs.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-piqs.rst:3113,Usability,simpl,simply,3113,", e.g. simply named; :code:`system`, whose first attribute is. - :code:`system.N`, the number of TLSs of the system :math:`N`. The rates for collective and local processes are simply defined as. - :code:`collective_emission` defines :math:`\gamma_\text{CE}`, collective (superradiant) emission; - :code:`collective_dephasing` defines :math:`\gamma_\text{CD}`, collective dephasing; - :code:`collective_pumping` defines :math:`\gamma_\text{CP}`, collective pumping.; - :code:`emission` defines :math:`\gamma_\text{E}`, incoherent emission (losses); - :code:`dephasing` defines :math:`\gamma_\text{D}`, local dephasing; - :code:`pumping` defines :math:`\gamma_\text{P}`, incoherent pumping. Then the :code:`system.lindbladian()` creates the total TLS Lindbladian superoperator matrix. Similarly, :code:`system.hamiltonian` defines the TLS hamiltonian of the system :math:`H_\text{TLS}`. The system's Liouvillian can be built using :code:`system.liouvillian()`.; The properties of a Piqs object can be visualized by simply calling :code:`system`.; We give two basic examples on the use of *PIQS*.; In the first example the incoherent emission of N driven TLSs is considered. .. code-block:: python. from qutip import piqs; N = 10; system = piqs.Dicke(N, emission = 1, pumping = 2); L = system.liouvillian(); steady = steadystate(L). For more example of use, see the ""Permutational Invariant Lindblad Dynamics"" section in the tutorials section of the website, `https://qutip.org/tutorials.html <https://qutip.org/tutorials.html>`_. .. list-table:: Useful PIQS functions.; :widths: 25 25 50; :header-rows: 1. * - Operators; - Command; - Description; * - Collective spin algebra :math:`J_x,\ J_y,\ J_z`; - ``jspin(N)``; - The collective spin algebra :math:`J_x,\ J_y,\ J_z` for :math:`N` TLSs; * - Collective spin :math:`J_x`; - ``jspin(N, ""x"")``; - The collective spin operator :math:`Jx`. Requires :math:`N` number of TLSs; * - Collective spin :math:`J_y`; - ``jspin(N, ""y"")``; - The collective spin opera",MatchSource.DOCS,doc/guide/guide-piqs.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-piqs.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-random.rst:4388,Integrability,depend,depending,4388,"[random]. >>> rand_super_bcsz(7).dims; [[[7], [7]], [[7], [7]]]; >>> rand_super_bcsz([[2, 3], [2, 3]]).dims; [[[2, 3], [2, 3]], [[2, 3], [2, 3]]]. Several of the random :class:`.Qobj` function in QuTiP support additional parameters as well, namely *density* and *distribution*.; :func:`.rand_dm`, :func:`.rand_herm`, :func:`.rand_unitary` and :func:`.rand_ket` can be created using multiple method controlled by *distribution*.; The :func:`.rand_ket`, :func:`.rand_herm` and :func:`.rand_unitary` functions can return quantum objects such that a fraction of the elements are identically equal to zero.; The ratio of nonzero elements is passed as the ``density`` keyword argument.; By contrast, `rand_super_bcsz` take as an argument the rank of the generated object, such that passing ``rank=1`` returns a random pure state or unitary channel, respectively.; Passing ``rank=None`` specifies that the generated object should be full-rank for the given dimension.; `rand_dm` can support *density* or *rank* depending on the chosen distribution. For example,. .. doctest:: [random]; :hide:. >>> np.random.seed(42). .. doctest:: [random]. >>> rand_dm(5, density=0.5, distribution=""herm""); Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[ 0.298+0.j , 0. +0.j , -0.095+0.1j , 0. +0.j ,-0.105+0.122j],; [ 0. +0.j , 0.088+0.j , 0. +0.j , -0.018-0.001j, 0. +0.j ],; [-0.095-0.1j , 0. +0.j , 0.328+0.j , 0. +0.j ,-0.077-0.033j],; [ 0. +0.j , -0.018+0.001j, 0. +0.j , 0.084+0.j , 0. +0.j ],; [-0.105-0.122j, 0. +0.j , -0.077+0.033j, 0. +0.j , 0.201+0.j ]]. >>> rand_dm_ginibre(5, rank=2); Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[ 0.307+0.j , -0.258+0.039j, -0.039+0.184j, 0.041-0.054j, 0.016+0.045j],; [-0.258-0.039j, 0.239+0.j , 0.075-0.15j , -0.053+0.008j,-0.057-0.078j],; [-0.039-0.184j, 0.075+0.15j , 0.136+0.j , -0.05 -0.052j,-0.028-0.058j],; [ 0.041+0.054j, -0.053-0.008j, -0.05 +0.052j, 0.083+0.j , 0.101-0",MatchSource.DOCS,doc/guide/guide-random.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-random.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-random.rst:154,Testability,test,testsetup,154,".. _random:. ********************************************; Generating Random Quantum States & Operators; ********************************************. .. testsetup:: [random]. from qutip import rand_herm, rand_dm, rand_super_bcsz, rand_dm_ginibre. QuTiP includes a collection of random state, unitary and channel generators for simulations, Monte Carlo evaluation, theorem evaluation, and code testing.; Each of these objects can be sampled from one of several different distributions. For example, a random Hermitian operator can be sampled by calling :func:`.rand_herm` function:. .. doctest:: [random]; :hide:. >>> np.random.seed(42). .. doctest:: [random]. >>> rand_herm(5) # doctest: +NORMALIZE_WHITESPACE; Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[-0.25091976+0.j 0. +0.j 0. +0.j; -0.21793701+0.47037633j -0.23212846-0.61607187j]; [ 0. +0.j -0.88383278+0.j 0.836086 -0.23956218j; -0.09464275+0.45370863j -0.15243356+0.65392096j]; [ 0. +0.j 0.836086 +0.23956218j 0.66488528+0.j; -0.26290446+0.64984451j -0.52603038-0.07991553j]; [-0.21793701-0.47037633j -0.09464275-0.45370863j -0.26290446-0.64984451j; -0.13610996+0.j -0.34240902-0.2879303j ]; [-0.23212846+0.61607187j -0.15243356-0.65392096j -0.52603038+0.07991553j; -0.34240902+0.2879303j 0. +0.j ]]. .. tabularcolumns:: | p{2cm} | p{3cm} | c |. .. cssclass:: table-striped. +-------------------------------+-----------------------------------------------+------------------------------------------+; | Random Variable Type | Sampling Functions | Dimensions |; +===============================+===============================================+==========================================+; | State vector (``ket``) | :func:`.rand_ket` | :math:`N \times 1` |; +-------------------------------+-----------------------------------------------+------------------------------------------+; | Hermitian operator (``oper``) | :func:`.rand_herm` | :math:`N \times N` |; +-------------------------------",MatchSource.DOCS,doc/guide/guide-random.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-random.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-random.rst:394,Testability,test,testing,394,".. _random:. ********************************************; Generating Random Quantum States & Operators; ********************************************. .. testsetup:: [random]. from qutip import rand_herm, rand_dm, rand_super_bcsz, rand_dm_ginibre. QuTiP includes a collection of random state, unitary and channel generators for simulations, Monte Carlo evaluation, theorem evaluation, and code testing.; Each of these objects can be sampled from one of several different distributions. For example, a random Hermitian operator can be sampled by calling :func:`.rand_herm` function:. .. doctest:: [random]; :hide:. >>> np.random.seed(42). .. doctest:: [random]. >>> rand_herm(5) # doctest: +NORMALIZE_WHITESPACE; Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[-0.25091976+0.j 0. +0.j 0. +0.j; -0.21793701+0.47037633j -0.23212846-0.61607187j]; [ 0. +0.j -0.88383278+0.j 0.836086 -0.23956218j; -0.09464275+0.45370863j -0.15243356+0.65392096j]; [ 0. +0.j 0.836086 +0.23956218j 0.66488528+0.j; -0.26290446+0.64984451j -0.52603038-0.07991553j]; [-0.21793701-0.47037633j -0.09464275-0.45370863j -0.26290446-0.64984451j; -0.13610996+0.j -0.34240902-0.2879303j ]; [-0.23212846+0.61607187j -0.15243356-0.65392096j -0.52603038+0.07991553j; -0.34240902+0.2879303j 0. +0.j ]]. .. tabularcolumns:: | p{2cm} | p{3cm} | c |. .. cssclass:: table-striped. +-------------------------------+-----------------------------------------------+------------------------------------------+; | Random Variable Type | Sampling Functions | Dimensions |; +===============================+===============================================+==========================================+; | State vector (``ket``) | :func:`.rand_ket` | :math:`N \times 1` |; +-------------------------------+-----------------------------------------------+------------------------------------------+; | Hermitian operator (``oper``) | :func:`.rand_herm` | :math:`N \times N` |; +-------------------------------",MatchSource.DOCS,doc/guide/guide-random.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-random.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-saving.rst:608,Performance,perform,performed,608,".. _saving:. **********************************; Saving QuTiP Objects and Data Sets; **********************************. With time-consuming calculations it is often necessary to store the results to files on disk, so it can be post-processed and archived. In QuTiP there are two facilities for storing data: Quantum objects can be stored to files and later read back as python pickles, and numerical data (vectors and matrices) can be exported as plain text files in for example CSV (comma-separated values), TSV (tab-separated values), etc. The former method is preferred when further calculations will be performed with the data, and the latter when the calculations are completed and data is to be imported into a post-processing tool (e.g. for generating figures). Storing and loading QuTiP objects; =================================. To store and load arbitrary QuTiP related objects (:class:`.Qobj`, :class:`.Result`, etc.) there are two functions: :func:`qutip.fileio.qsave` and :func:`qutip.fileio.qload`. The function :func:`qutip.fileio.qsave` takes an arbitrary object as first parameter and an optional filename as second parameter (default filename is `qutip_data.qu`). The filename extension is always `.qu`. The function :func:`qutip.fileio.qload` takes a mandatory filename as first argument and loads and returns the objects in the file. To illustrate how these functions can be used, consider a simple calculation of the steadystate of the harmonic oscillator ::. >>> a = destroy(10); H = a.dag() * a; >>> c_ops = [np.sqrt(0.5) * a, np.sqrt(0.25) * a.dag()]; >>> rho_ss = steadystate(H, c_ops). The steadystate density matrix `rho_ss` is an instance of :class:`.Qobj`. It can be stored to a file `steadystate.qu` using ::. >>> qsave(rho_ss, 'steadystate'); >>> !ls *.qu; density_matrix_vs_time.qu steadystate.qu. and it can later be loaded again, and used in further calculations ::. >>> rho_ss_loaded = qload('steadystate'); Loaded Qobj object:; Quantum object: dims = [[10], [10]]",MatchSource.DOCS,doc/guide/guide-saving.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-saving.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-saving.rst:782,Performance,load,loading,782,".. _saving:. **********************************; Saving QuTiP Objects and Data Sets; **********************************. With time-consuming calculations it is often necessary to store the results to files on disk, so it can be post-processed and archived. In QuTiP there are two facilities for storing data: Quantum objects can be stored to files and later read back as python pickles, and numerical data (vectors and matrices) can be exported as plain text files in for example CSV (comma-separated values), TSV (tab-separated values), etc. The former method is preferred when further calculations will be performed with the data, and the latter when the calculations are completed and data is to be imported into a post-processing tool (e.g. for generating figures). Storing and loading QuTiP objects; =================================. To store and load arbitrary QuTiP related objects (:class:`.Qobj`, :class:`.Result`, etc.) there are two functions: :func:`qutip.fileio.qsave` and :func:`qutip.fileio.qload`. The function :func:`qutip.fileio.qsave` takes an arbitrary object as first parameter and an optional filename as second parameter (default filename is `qutip_data.qu`). The filename extension is always `.qu`. The function :func:`qutip.fileio.qload` takes a mandatory filename as first argument and loads and returns the objects in the file. To illustrate how these functions can be used, consider a simple calculation of the steadystate of the harmonic oscillator ::. >>> a = destroy(10); H = a.dag() * a; >>> c_ops = [np.sqrt(0.5) * a, np.sqrt(0.25) * a.dag()]; >>> rho_ss = steadystate(H, c_ops). The steadystate density matrix `rho_ss` is an instance of :class:`.Qobj`. It can be stored to a file `steadystate.qu` using ::. >>> qsave(rho_ss, 'steadystate'); >>> !ls *.qu; density_matrix_vs_time.qu steadystate.qu. and it can later be loaded again, and used in further calculations ::. >>> rho_ss_loaded = qload('steadystate'); Loaded Qobj object:; Quantum object: dims = [[10], [10]]",MatchSource.DOCS,doc/guide/guide-saving.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-saving.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-saving.rst:853,Performance,load,load,853,".. _saving:. **********************************; Saving QuTiP Objects and Data Sets; **********************************. With time-consuming calculations it is often necessary to store the results to files on disk, so it can be post-processed and archived. In QuTiP there are two facilities for storing data: Quantum objects can be stored to files and later read back as python pickles, and numerical data (vectors and matrices) can be exported as plain text files in for example CSV (comma-separated values), TSV (tab-separated values), etc. The former method is preferred when further calculations will be performed with the data, and the latter when the calculations are completed and data is to be imported into a post-processing tool (e.g. for generating figures). Storing and loading QuTiP objects; =================================. To store and load arbitrary QuTiP related objects (:class:`.Qobj`, :class:`.Result`, etc.) there are two functions: :func:`qutip.fileio.qsave` and :func:`qutip.fileio.qload`. The function :func:`qutip.fileio.qsave` takes an arbitrary object as first parameter and an optional filename as second parameter (default filename is `qutip_data.qu`). The filename extension is always `.qu`. The function :func:`qutip.fileio.qload` takes a mandatory filename as first argument and loads and returns the objects in the file. To illustrate how these functions can be used, consider a simple calculation of the steadystate of the harmonic oscillator ::. >>> a = destroy(10); H = a.dag() * a; >>> c_ops = [np.sqrt(0.5) * a, np.sqrt(0.25) * a.dag()]; >>> rho_ss = steadystate(H, c_ops). The steadystate density matrix `rho_ss` is an instance of :class:`.Qobj`. It can be stored to a file `steadystate.qu` using ::. >>> qsave(rho_ss, 'steadystate'); >>> !ls *.qu; density_matrix_vs_time.qu steadystate.qu. and it can later be loaded again, and used in further calculations ::. >>> rho_ss_loaded = qload('steadystate'); Loaded Qobj object:; Quantum object: dims = [[10], [10]]",MatchSource.DOCS,doc/guide/guide-saving.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-saving.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-saving.rst:1313,Performance,load,loads,1313,"a: Quantum objects can be stored to files and later read back as python pickles, and numerical data (vectors and matrices) can be exported as plain text files in for example CSV (comma-separated values), TSV (tab-separated values), etc. The former method is preferred when further calculations will be performed with the data, and the latter when the calculations are completed and data is to be imported into a post-processing tool (e.g. for generating figures). Storing and loading QuTiP objects; =================================. To store and load arbitrary QuTiP related objects (:class:`.Qobj`, :class:`.Result`, etc.) there are two functions: :func:`qutip.fileio.qsave` and :func:`qutip.fileio.qload`. The function :func:`qutip.fileio.qsave` takes an arbitrary object as first parameter and an optional filename as second parameter (default filename is `qutip_data.qu`). The filename extension is always `.qu`. The function :func:`qutip.fileio.qload` takes a mandatory filename as first argument and loads and returns the objects in the file. To illustrate how these functions can be used, consider a simple calculation of the steadystate of the harmonic oscillator ::. >>> a = destroy(10); H = a.dag() * a; >>> c_ops = [np.sqrt(0.5) * a, np.sqrt(0.25) * a.dag()]; >>> rho_ss = steadystate(H, c_ops). The steadystate density matrix `rho_ss` is an instance of :class:`.Qobj`. It can be stored to a file `steadystate.qu` using ::. >>> qsave(rho_ss, 'steadystate'); >>> !ls *.qu; density_matrix_vs_time.qu steadystate.qu. and it can later be loaded again, and used in further calculations ::. >>> rho_ss_loaded = qload('steadystate'); Loaded Qobj object:; Quantum object: dims = [[10], [10]], shape = (10, 10), type = oper, isHerm = True; >>> a = destroy(10); >>> np.testing.assert_almost_equal(expect(a.dag() * a, rho_ss_loaded), 0.9902248289345061). The nice thing about the :func:`qutip.fileio.qsave` and :func:`qutip.fileio.qload` functions is that almost any object can be stored and load ag",MatchSource.DOCS,doc/guide/guide-saving.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-saving.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-saving.rst:1852,Performance,load,loaded,1852,"y QuTiP related objects (:class:`.Qobj`, :class:`.Result`, etc.) there are two functions: :func:`qutip.fileio.qsave` and :func:`qutip.fileio.qload`. The function :func:`qutip.fileio.qsave` takes an arbitrary object as first parameter and an optional filename as second parameter (default filename is `qutip_data.qu`). The filename extension is always `.qu`. The function :func:`qutip.fileio.qload` takes a mandatory filename as first argument and loads and returns the objects in the file. To illustrate how these functions can be used, consider a simple calculation of the steadystate of the harmonic oscillator ::. >>> a = destroy(10); H = a.dag() * a; >>> c_ops = [np.sqrt(0.5) * a, np.sqrt(0.25) * a.dag()]; >>> rho_ss = steadystate(H, c_ops). The steadystate density matrix `rho_ss` is an instance of :class:`.Qobj`. It can be stored to a file `steadystate.qu` using ::. >>> qsave(rho_ss, 'steadystate'); >>> !ls *.qu; density_matrix_vs_time.qu steadystate.qu. and it can later be loaded again, and used in further calculations ::. >>> rho_ss_loaded = qload('steadystate'); Loaded Qobj object:; Quantum object: dims = [[10], [10]], shape = (10, 10), type = oper, isHerm = True; >>> a = destroy(10); >>> np.testing.assert_almost_equal(expect(a.dag() * a, rho_ss_loaded), 0.9902248289345061). The nice thing about the :func:`qutip.fileio.qsave` and :func:`qutip.fileio.qload` functions is that almost any object can be stored and load again later on.; We can for example store a list of density matrices as returned by :func:`.mesolve` ::. >>> a = destroy(10); H = a.dag() * a ; c_ops = [np.sqrt(0.5) * a, np.sqrt(0.25) * a.dag()]; >>> psi0 = rand_ket(10); >>> times = np.linspace(0, 10, 10); >>> dm_list = mesolve(H, psi0, times, c_ops, []); >>> qsave(dm_list, 'density_matrix_vs_time'). And it can then be loaded and used again, for example in an other program ::. >>> dm_list_loaded = qload('density_matrix_vs_time'); Loaded Result object:; Result object with mesolve data.; --------------------",MatchSource.DOCS,doc/guide/guide-saving.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-saving.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-saving.rst:2299,Performance,load,load,2299,"ory filename as first argument and loads and returns the objects in the file. To illustrate how these functions can be used, consider a simple calculation of the steadystate of the harmonic oscillator ::. >>> a = destroy(10); H = a.dag() * a; >>> c_ops = [np.sqrt(0.5) * a, np.sqrt(0.25) * a.dag()]; >>> rho_ss = steadystate(H, c_ops). The steadystate density matrix `rho_ss` is an instance of :class:`.Qobj`. It can be stored to a file `steadystate.qu` using ::. >>> qsave(rho_ss, 'steadystate'); >>> !ls *.qu; density_matrix_vs_time.qu steadystate.qu. and it can later be loaded again, and used in further calculations ::. >>> rho_ss_loaded = qload('steadystate'); Loaded Qobj object:; Quantum object: dims = [[10], [10]], shape = (10, 10), type = oper, isHerm = True; >>> a = destroy(10); >>> np.testing.assert_almost_equal(expect(a.dag() * a, rho_ss_loaded), 0.9902248289345061). The nice thing about the :func:`qutip.fileio.qsave` and :func:`qutip.fileio.qload` functions is that almost any object can be stored and load again later on.; We can for example store a list of density matrices as returned by :func:`.mesolve` ::. >>> a = destroy(10); H = a.dag() * a ; c_ops = [np.sqrt(0.5) * a, np.sqrt(0.25) * a.dag()]; >>> psi0 = rand_ket(10); >>> times = np.linspace(0, 10, 10); >>> dm_list = mesolve(H, psi0, times, c_ops, []); >>> qsave(dm_list, 'density_matrix_vs_time'). And it can then be loaded and used again, for example in an other program ::. >>> dm_list_loaded = qload('density_matrix_vs_time'); Loaded Result object:; Result object with mesolve data.; --------------------------------; states = True; num_collapse = 0; >>> a = destroy(10); >>> expect(a.dag() * a, dm_list_loaded.states) # doctest: +SKIP; array([4.63317086, 3.59150315, 2.90590183, 2.41306641, 2.05120716,; 1.78312503, 1.58357995, 1.4346382 , 1.32327398, 1.23991233]). Storing and loading datasets; ============================. The :func:`qutip.fileio.qsave` and :func:`qutip.fileio.qload` are great, but the file for",MatchSource.DOCS,doc/guide/guide-saving.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-saving.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-saving.rst:2677,Performance,load,loaded,2677,"e stored to a file `steadystate.qu` using ::. >>> qsave(rho_ss, 'steadystate'); >>> !ls *.qu; density_matrix_vs_time.qu steadystate.qu. and it can later be loaded again, and used in further calculations ::. >>> rho_ss_loaded = qload('steadystate'); Loaded Qobj object:; Quantum object: dims = [[10], [10]], shape = (10, 10), type = oper, isHerm = True; >>> a = destroy(10); >>> np.testing.assert_almost_equal(expect(a.dag() * a, rho_ss_loaded), 0.9902248289345061). The nice thing about the :func:`qutip.fileio.qsave` and :func:`qutip.fileio.qload` functions is that almost any object can be stored and load again later on.; We can for example store a list of density matrices as returned by :func:`.mesolve` ::. >>> a = destroy(10); H = a.dag() * a ; c_ops = [np.sqrt(0.5) * a, np.sqrt(0.25) * a.dag()]; >>> psi0 = rand_ket(10); >>> times = np.linspace(0, 10, 10); >>> dm_list = mesolve(H, psi0, times, c_ops, []); >>> qsave(dm_list, 'density_matrix_vs_time'). And it can then be loaded and used again, for example in an other program ::. >>> dm_list_loaded = qload('density_matrix_vs_time'); Loaded Result object:; Result object with mesolve data.; --------------------------------; states = True; num_collapse = 0; >>> a = destroy(10); >>> expect(a.dag() * a, dm_list_loaded.states) # doctest: +SKIP; array([4.63317086, 3.59150315, 2.90590183, 2.41306641, 2.05120716,; 1.78312503, 1.58357995, 1.4346382 , 1.32327398, 1.23991233]). Storing and loading datasets; ============================. The :func:`qutip.fileio.qsave` and :func:`qutip.fileio.qload` are great, but the file format used is only understood by QuTiP (python) programs. When data must be exported to other programs the preferred method is to store the data in the commonly used plain-text file formats. With the QuTiP functions :func:`qutip.fileio.file_data_store` and :func:`qutip.fileio.file_data_read` we can store and load **numpy** arrays and matrices to files on disk using a deliminator-separated value format (for example c",MatchSource.DOCS,doc/guide/guide-saving.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-saving.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-saving.rst:3142,Performance,load,loading,3142,"). The nice thing about the :func:`qutip.fileio.qsave` and :func:`qutip.fileio.qload` functions is that almost any object can be stored and load again later on.; We can for example store a list of density matrices as returned by :func:`.mesolve` ::. >>> a = destroy(10); H = a.dag() * a ; c_ops = [np.sqrt(0.5) * a, np.sqrt(0.25) * a.dag()]; >>> psi0 = rand_ket(10); >>> times = np.linspace(0, 10, 10); >>> dm_list = mesolve(H, psi0, times, c_ops, []); >>> qsave(dm_list, 'density_matrix_vs_time'). And it can then be loaded and used again, for example in an other program ::. >>> dm_list_loaded = qload('density_matrix_vs_time'); Loaded Result object:; Result object with mesolve data.; --------------------------------; states = True; num_collapse = 0; >>> a = destroy(10); >>> expect(a.dag() * a, dm_list_loaded.states) # doctest: +SKIP; array([4.63317086, 3.59150315, 2.90590183, 2.41306641, 2.05120716,; 1.78312503, 1.58357995, 1.4346382 , 1.32327398, 1.23991233]). Storing and loading datasets; ============================. The :func:`qutip.fileio.qsave` and :func:`qutip.fileio.qload` are great, but the file format used is only understood by QuTiP (python) programs. When data must be exported to other programs the preferred method is to store the data in the commonly used plain-text file formats. With the QuTiP functions :func:`qutip.fileio.file_data_store` and :func:`qutip.fileio.file_data_read` we can store and load **numpy** arrays and matrices to files on disk using a deliminator-separated value format (for example comma-separated values CSV). Almost any program can handle this file format. The :func:`qutip.fileio.file_data_store` takes two mandatory and three optional arguments:. >>> file_data_store(filename, data, numtype=""complex"", numformat=""decimal"", sep="","") # doctest: +SKIP. where `filename` is the name of the file, `data` is the data to be written to the file (must be a *numpy* array), `numtype` (optional) is a flag indicating numerical type that can take values ",MatchSource.DOCS,doc/guide/guide-saving.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-saving.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-saving.rst:3587,Performance,load,load,3587,"y_matrix_vs_time'). And it can then be loaded and used again, for example in an other program ::. >>> dm_list_loaded = qload('density_matrix_vs_time'); Loaded Result object:; Result object with mesolve data.; --------------------------------; states = True; num_collapse = 0; >>> a = destroy(10); >>> expect(a.dag() * a, dm_list_loaded.states) # doctest: +SKIP; array([4.63317086, 3.59150315, 2.90590183, 2.41306641, 2.05120716,; 1.78312503, 1.58357995, 1.4346382 , 1.32327398, 1.23991233]). Storing and loading datasets; ============================. The :func:`qutip.fileio.qsave` and :func:`qutip.fileio.qload` are great, but the file format used is only understood by QuTiP (python) programs. When data must be exported to other programs the preferred method is to store the data in the commonly used plain-text file formats. With the QuTiP functions :func:`qutip.fileio.file_data_store` and :func:`qutip.fileio.file_data_read` we can store and load **numpy** arrays and matrices to files on disk using a deliminator-separated value format (for example comma-separated values CSV). Almost any program can handle this file format. The :func:`qutip.fileio.file_data_store` takes two mandatory and three optional arguments:. >>> file_data_store(filename, data, numtype=""complex"", numformat=""decimal"", sep="","") # doctest: +SKIP. where `filename` is the name of the file, `data` is the data to be written to the file (must be a *numpy* array), `numtype` (optional) is a flag indicating numerical type that can take values `complex` or `real`, `numformat` (optional) specifies the numerical format that can take the values `exp` for the format `1.0e1` and `decimal` for the format `10.0`, and `sep` (optional) is an arbitrary single-character field separator (usually a tab, space, comma, semicolon, etc.). A common use for the :func:`qutip.fileio.file_data_store` function is to store the expectation values of a set of operators for a sequence of times, e.g., as returned by the :func:`.mesolve` funct",MatchSource.DOCS,doc/guide/guide-saving.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-saving.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-saving.rst:7402,Performance,load,loaded,7402,"00000j,1.7435892209+0.0000000000j,-0.1126550232+0.0000000000j,0.2497182058+0.0000000000j; 5.0505050505+0.0000000000j,1.5687324121+0.0000000000j,0.1351622725+0.0000000000j,0.2018398581+0.0000000000j; 6.0606060606+0.0000000000j,1.4348632045+0.0000000000j,0.2143080535+0.0000000000j,-0.0067820038+0.0000000000j; 7.0707070707+0.0000000000j,1.3321818015+0.0000000000j,0.0950352763+0.0000000000j,-0.1630920429+0.0000000000j; 8.0808080808+0.0000000000j,1.2533244850+0.0000000000j,-0.0771210981+0.0000000000j,-0.1468923919+0.0000000000j. In this case we didn't really need to store both the real and imaginary parts, so instead we could use the ``numtype=""real""`` option. .. plot::; :context:. >>> file_data_store('expect.dat', output_data.T, numtype=""real""); >>> with open(""expect.dat"", ""r"") as f:; ... print('\n'.join(f.readlines()[:5])); # Generated by QuTiP: 100x4 real matrix in decimal format [',' separated values].; 0.0000000000,3.2109553666,0.3689771549,0.0185002867; 1.0101010101,2.6754598872,0.1298251132,-0.3303672956; 2.0202020202,2.2743186810,-0.2106241300,-0.2623894277; 3.0303030303,1.9726633457,-0.3037311621,0.0397330921. and if we prefer scientific notation we can request that using the ``numformat=""exp""`` option. .. plot::; :context:. >>> file_data_store('expect.dat', output_data.T, numtype=""real"", numformat=""exp""). Loading data previously stored using :func:`qutip.fileio.file_data_store` (or some other software) is a even easier. Regardless of which deliminator was used, if data was stored as complex or real numbers, if it is in decimal or exponential form, the data can be loaded using the :func:`qutip.fileio.file_data_read`, which only takes the filename as mandatory argument. .. plot::; :context:. input_data = file_data_read('expect.dat'); plt.plot(input_data[:,0], input_data[:,1]); # plot the data. (If a particularly obscure choice of deliminator was used it might be necessary to use the optional second argument, for example ``sep=""_""`` if ``_`` is the deliminator).; ",MatchSource.DOCS,doc/guide/guide-saving.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-saving.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-saving.rst:2077,Testability,test,testing,2077,"as first parameter and an optional filename as second parameter (default filename is `qutip_data.qu`). The filename extension is always `.qu`. The function :func:`qutip.fileio.qload` takes a mandatory filename as first argument and loads and returns the objects in the file. To illustrate how these functions can be used, consider a simple calculation of the steadystate of the harmonic oscillator ::. >>> a = destroy(10); H = a.dag() * a; >>> c_ops = [np.sqrt(0.5) * a, np.sqrt(0.25) * a.dag()]; >>> rho_ss = steadystate(H, c_ops). The steadystate density matrix `rho_ss` is an instance of :class:`.Qobj`. It can be stored to a file `steadystate.qu` using ::. >>> qsave(rho_ss, 'steadystate'); >>> !ls *.qu; density_matrix_vs_time.qu steadystate.qu. and it can later be loaded again, and used in further calculations ::. >>> rho_ss_loaded = qload('steadystate'); Loaded Qobj object:; Quantum object: dims = [[10], [10]], shape = (10, 10), type = oper, isHerm = True; >>> a = destroy(10); >>> np.testing.assert_almost_equal(expect(a.dag() * a, rho_ss_loaded), 0.9902248289345061). The nice thing about the :func:`qutip.fileio.qsave` and :func:`qutip.fileio.qload` functions is that almost any object can be stored and load again later on.; We can for example store a list of density matrices as returned by :func:`.mesolve` ::. >>> a = destroy(10); H = a.dag() * a ; c_ops = [np.sqrt(0.5) * a, np.sqrt(0.25) * a.dag()]; >>> psi0 = rand_ket(10); >>> times = np.linspace(0, 10, 10); >>> dm_list = mesolve(H, psi0, times, c_ops, []); >>> qsave(dm_list, 'density_matrix_vs_time'). And it can then be loaded and used again, for example in an other program ::. >>> dm_list_loaded = qload('density_matrix_vs_time'); Loaded Result object:; Result object with mesolve data.; --------------------------------; states = True; num_collapse = 0; >>> a = destroy(10); >>> expect(a.dag() * a, dm_list_loaded.states) # doctest: +SKIP; array([4.63317086, 3.59150315, 2.90590183, 2.41306641, 2.05120716,; 1.78312503, 1",MatchSource.DOCS,doc/guide/guide-saving.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-saving.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-saving.rst:1414,Usability,simpl,simple,1414," matrices) can be exported as plain text files in for example CSV (comma-separated values), TSV (tab-separated values), etc. The former method is preferred when further calculations will be performed with the data, and the latter when the calculations are completed and data is to be imported into a post-processing tool (e.g. for generating figures). Storing and loading QuTiP objects; =================================. To store and load arbitrary QuTiP related objects (:class:`.Qobj`, :class:`.Result`, etc.) there are two functions: :func:`qutip.fileio.qsave` and :func:`qutip.fileio.qload`. The function :func:`qutip.fileio.qsave` takes an arbitrary object as first parameter and an optional filename as second parameter (default filename is `qutip_data.qu`). The filename extension is always `.qu`. The function :func:`qutip.fileio.qload` takes a mandatory filename as first argument and loads and returns the objects in the file. To illustrate how these functions can be used, consider a simple calculation of the steadystate of the harmonic oscillator ::. >>> a = destroy(10); H = a.dag() * a; >>> c_ops = [np.sqrt(0.5) * a, np.sqrt(0.25) * a.dag()]; >>> rho_ss = steadystate(H, c_ops). The steadystate density matrix `rho_ss` is an instance of :class:`.Qobj`. It can be stored to a file `steadystate.qu` using ::. >>> qsave(rho_ss, 'steadystate'); >>> !ls *.qu; density_matrix_vs_time.qu steadystate.qu. and it can later be loaded again, and used in further calculations ::. >>> rho_ss_loaded = qload('steadystate'); Loaded Qobj object:; Quantum object: dims = [[10], [10]], shape = (10, 10), type = oper, isHerm = True; >>> a = destroy(10); >>> np.testing.assert_almost_equal(expect(a.dag() * a, rho_ss_loaded), 0.9902248289345061). The nice thing about the :func:`qutip.fileio.qsave` and :func:`qutip.fileio.qload` functions is that almost any object can be stored and load again later on.; We can for example store a list of density matrices as returned by :func:`.mesolve` ::. >>> a = de",MatchSource.DOCS,doc/guide/guide-saving.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-saving.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-settings.rst:1109,Availability,toler,tolerance,1109,"*********************; Modifying Internal QuTiP Settings; *********************************. .. _settings-params:. User Accessible Parameters; ==========================. In this section we show how to modify a few of the internal parameters used by QuTiP.; The settings that can be modified are given in the following table:. .. tabularcolumns:: | p{3cm} | p{5cm} | p{5cm} |. .. cssclass:: table-striped. +------------------------------+----------------------------------------------+------------------------------+; | Setting | Description | Options |; +==============================+==============================================+==============================+; | `auto_tidyup` | Automatically tidyup sparse quantum objects. | True / False |; +------------------------------+----------------------------------------------+------------------------------+; | `auto_tidyup_atol` | Tolerance used by tidyup. (sparse only) | float {1e-14} |; +------------------------------+----------------------------------------------+------------------------------+; | `atol` | General absolute tolerance. | float {1e-12} |; +------------------------------+----------------------------------------------+------------------------------+; | `rtol` | General relative tolerance. | float {1e-12} |; +------------------------------+----------------------------------------------+------------------------------+; | `function_coefficient_style` | Signature expected by function coefficients. | {""auto"", ""pythonic"", ""dict""} |; +------------------------------+----------------------------------------------+------------------------------+. .. _settings-usage:. Example: Changing Settings; ==========================. The two most important settings are ``auto_tidyup`` and ``auto_tidyup_atol`` as they control whether the small elements of a quantum object should be removed, and what number should be considered as the cut-off tolerance.; Modifying these, or any other parameters, is quite simple::. >>> qutip.settings.co",MatchSource.DOCS,doc/guide/guide-settings.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-settings.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-settings.rst:1279,Availability,toler,tolerance,1279,"In this section we show how to modify a few of the internal parameters used by QuTiP.; The settings that can be modified are given in the following table:. .. tabularcolumns:: | p{3cm} | p{5cm} | p{5cm} |. .. cssclass:: table-striped. +------------------------------+----------------------------------------------+------------------------------+; | Setting | Description | Options |; +==============================+==============================================+==============================+; | `auto_tidyup` | Automatically tidyup sparse quantum objects. | True / False |; +------------------------------+----------------------------------------------+------------------------------+; | `auto_tidyup_atol` | Tolerance used by tidyup. (sparse only) | float {1e-14} |; +------------------------------+----------------------------------------------+------------------------------+; | `atol` | General absolute tolerance. | float {1e-12} |; +------------------------------+----------------------------------------------+------------------------------+; | `rtol` | General relative tolerance. | float {1e-12} |; +------------------------------+----------------------------------------------+------------------------------+; | `function_coefficient_style` | Signature expected by function coefficients. | {""auto"", ""pythonic"", ""dict""} |; +------------------------------+----------------------------------------------+------------------------------+. .. _settings-usage:. Example: Changing Settings; ==========================. The two most important settings are ``auto_tidyup`` and ``auto_tidyup_atol`` as they control whether the small elements of a quantum object should be removed, and what number should be considered as the cut-off tolerance.; Modifying these, or any other parameters, is quite simple::. >>> qutip.settings.core[""auto_tidyup""] = False. The settings can also be changed for a code block::. >>> with qutip.CoreOptions(atol=1e-5):; >>> assert qutip.qeye(2) * 1e-9 == qutip.qzero(2); ",MatchSource.DOCS,doc/guide/guide-settings.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-settings.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-settings.rst:1933,Availability,toler,tolerance,1933,"In this section we show how to modify a few of the internal parameters used by QuTiP.; The settings that can be modified are given in the following table:. .. tabularcolumns:: | p{3cm} | p{5cm} | p{5cm} |. .. cssclass:: table-striped. +------------------------------+----------------------------------------------+------------------------------+; | Setting | Description | Options |; +==============================+==============================================+==============================+; | `auto_tidyup` | Automatically tidyup sparse quantum objects. | True / False |; +------------------------------+----------------------------------------------+------------------------------+; | `auto_tidyup_atol` | Tolerance used by tidyup. (sparse only) | float {1e-14} |; +------------------------------+----------------------------------------------+------------------------------+; | `atol` | General absolute tolerance. | float {1e-12} |; +------------------------------+----------------------------------------------+------------------------------+; | `rtol` | General relative tolerance. | float {1e-12} |; +------------------------------+----------------------------------------------+------------------------------+; | `function_coefficient_style` | Signature expected by function coefficients. | {""auto"", ""pythonic"", ""dict""} |; +------------------------------+----------------------------------------------+------------------------------+. .. _settings-usage:. Example: Changing Settings; ==========================. The two most important settings are ``auto_tidyup`` and ``auto_tidyup_atol`` as they control whether the small elements of a quantum object should be removed, and what number should be considered as the cut-off tolerance.; Modifying these, or any other parameters, is quite simple::. >>> qutip.settings.core[""auto_tidyup""] = False. The settings can also be changed for a code block::. >>> with qutip.CoreOptions(atol=1e-5):; >>> assert qutip.qeye(2) * 1e-9 == qutip.qzero(2); ",MatchSource.DOCS,doc/guide/guide-settings.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-settings.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-settings.rst:2151,Testability,assert,assert,2151,"In this section we show how to modify a few of the internal parameters used by QuTiP.; The settings that can be modified are given in the following table:. .. tabularcolumns:: | p{3cm} | p{5cm} | p{5cm} |. .. cssclass:: table-striped. +------------------------------+----------------------------------------------+------------------------------+; | Setting | Description | Options |; +==============================+==============================================+==============================+; | `auto_tidyup` | Automatically tidyup sparse quantum objects. | True / False |; +------------------------------+----------------------------------------------+------------------------------+; | `auto_tidyup_atol` | Tolerance used by tidyup. (sparse only) | float {1e-14} |; +------------------------------+----------------------------------------------+------------------------------+; | `atol` | General absolute tolerance. | float {1e-12} |; +------------------------------+----------------------------------------------+------------------------------+; | `rtol` | General relative tolerance. | float {1e-12} |; +------------------------------+----------------------------------------------+------------------------------+; | `function_coefficient_style` | Signature expected by function coefficients. | {""auto"", ""pythonic"", ""dict""} |; +------------------------------+----------------------------------------------+------------------------------+. .. _settings-usage:. Example: Changing Settings; ==========================. The two most important settings are ``auto_tidyup`` and ``auto_tidyup_atol`` as they control whether the small elements of a quantum object should be removed, and what number should be considered as the cut-off tolerance.; Modifying these, or any other parameters, is quite simple::. >>> qutip.settings.core[""auto_tidyup""] = False. The settings can also be changed for a code block::. >>> with qutip.CoreOptions(atol=1e-5):; >>> assert qutip.qeye(2) * 1e-9 == qutip.qzero(2); ",MatchSource.DOCS,doc/guide/guide-settings.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-settings.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-settings.rst:1996,Usability,simpl,simple,1996,"In this section we show how to modify a few of the internal parameters used by QuTiP.; The settings that can be modified are given in the following table:. .. tabularcolumns:: | p{3cm} | p{5cm} | p{5cm} |. .. cssclass:: table-striped. +------------------------------+----------------------------------------------+------------------------------+; | Setting | Description | Options |; +==============================+==============================================+==============================+; | `auto_tidyup` | Automatically tidyup sparse quantum objects. | True / False |; +------------------------------+----------------------------------------------+------------------------------+; | `auto_tidyup_atol` | Tolerance used by tidyup. (sparse only) | float {1e-14} |; +------------------------------+----------------------------------------------+------------------------------+; | `atol` | General absolute tolerance. | float {1e-12} |; +------------------------------+----------------------------------------------+------------------------------+; | `rtol` | General relative tolerance. | float {1e-12} |; +------------------------------+----------------------------------------------+------------------------------+; | `function_coefficient_style` | Signature expected by function coefficients. | {""auto"", ""pythonic"", ""dict""} |; +------------------------------+----------------------------------------------+------------------------------+. .. _settings-usage:. Example: Changing Settings; ==========================. The two most important settings are ``auto_tidyup`` and ``auto_tidyup_atol`` as they control whether the small elements of a quantum object should be removed, and what number should be considered as the cut-off tolerance.; Modifying these, or any other parameters, is quite simple::. >>> qutip.settings.core[""auto_tidyup""] = False. The settings can also be changed for a code block::. >>> with qutip.CoreOptions(atol=1e-5):; >>> assert qutip.qeye(2) * 1e-9 == qutip.qzero(2); ",MatchSource.DOCS,doc/guide/guide-settings.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-settings.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:15694,Availability,down,downarrow,15694,"*:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[ 1. 0.]; [ 0. -1.]]. .. testcode:: [states]. print(sigmaz() * spin). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[1.]; [0.]]. .. testcode:: [states]. spin2 = basis(2, 1). print(spin2). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[0.]; [1.]]. .. testcode:: [states]. print(sigmaz() * spin2). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[ 0.]; [-1.]]. The answer is now apparent. Since the QuTiP :func:`.sigmaz` function uses the standard z-basis representation of the sigma-z spin operator, the ``spin`` state corresponds to the :math:`\left|\uparrow\right>` state of a two-level spin system while ``spin2`` gives the :math:`\left|\downarrow\right>` state. Therefore, in our previous example ``sigmap() * spin``, we raised the qubit state out of the truncated two-level Hilbert space resulting in the zero state. While at first glance this convention might seem somewhat odd, it is in fact quite handy. For one, the spin operators remain in the conventional form. Second, when the spin system is in the :math:`\left|\uparrow\right>` state:. .. testcode:: [states]. print(sigmaz() * spin). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[1.]; [0.]]. the non-zero component is the zeroth-element of the underlying matrix (remember that python uses c-indexing, and matrices start with the zeroth element). The :math:`\left|\downarrow\right>` state therefore has a non-zero entry in the first index position. This corresponds nicely",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:16485,Availability,down,downarrow,16485,"ation of the sigma-z spin operator, the ``spin`` state corresponds to the :math:`\left|\uparrow\right>` state of a two-level spin system while ``spin2`` gives the :math:`\left|\downarrow\right>` state. Therefore, in our previous example ``sigmap() * spin``, we raised the qubit state out of the truncated two-level Hilbert space resulting in the zero state. While at first glance this convention might seem somewhat odd, it is in fact quite handy. For one, the spin operators remain in the conventional form. Second, when the spin system is in the :math:`\left|\uparrow\right>` state:. .. testcode:: [states]. print(sigmaz() * spin). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[1.]; [0.]]. the non-zero component is the zeroth-element of the underlying matrix (remember that python uses c-indexing, and matrices start with the zeroth element). The :math:`\left|\downarrow\right>` state therefore has a non-zero entry in the first index position. This corresponds nicely with the quantum information definitions of qubit states, where the excited :math:`\left|\uparrow\right>` state is label as :math:`\left|0\right>`, and the :math:`\left|\downarrow\right>` state by :math:`\left|1\right>`. If one wants to create spin operators for higher spin systems, then the :func:`.jmat` function comes in handy. .. _quantum_gates:. Gates; =====. The pre-defined gates are shown in the table below:. .. cssclass:: table-striped. +------------------------------------------------+-------------------------------------------------------+; | Gate function | Description |; +================================================+=======================================================+; | :func:`~qutip.core.gates.rx` | Rotation around x axis |; +------------------------------------------------+-------------------------------------------------------+; | :func:`~qutip.core.gates.ry` | Rotation around y axis |; +",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:16763,Availability,down,downarrow,16763,"ft|\downarrow\right>` state. Therefore, in our previous example ``sigmap() * spin``, we raised the qubit state out of the truncated two-level Hilbert space resulting in the zero state. While at first glance this convention might seem somewhat odd, it is in fact quite handy. For one, the spin operators remain in the conventional form. Second, when the spin system is in the :math:`\left|\uparrow\right>` state:. .. testcode:: [states]. print(sigmaz() * spin). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[1.]; [0.]]. the non-zero component is the zeroth-element of the underlying matrix (remember that python uses c-indexing, and matrices start with the zeroth element). The :math:`\left|\downarrow\right>` state therefore has a non-zero entry in the first index position. This corresponds nicely with the quantum information definitions of qubit states, where the excited :math:`\left|\uparrow\right>` state is label as :math:`\left|0\right>`, and the :math:`\left|\downarrow\right>` state by :math:`\left|1\right>`. If one wants to create spin operators for higher spin systems, then the :func:`.jmat` function comes in handy. .. _quantum_gates:. Gates; =====. The pre-defined gates are shown in the table below:. .. cssclass:: table-striped. +------------------------------------------------+-------------------------------------------------------+; | Gate function | Description |; +================================================+=======================================================+; | :func:`~qutip.core.gates.rx` | Rotation around x axis |; +------------------------------------------------+-------------------------------------------------------+; | :func:`~qutip.core.gates.ry` | Rotation around y axis |; +------------------------------------------------+-------------------------------------------------------+; | :func:`~qutip.core.gates.rz` | Rotation around z axis |; +-------",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:24665,Availability,down,down,24665,"e(5)] # must normalize. print(expect(N, states)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. [0. 1. 2. 3. 4.]. .. testcode:: [states]. cat_list = [(basis(5, 4) + x * basis(5, 3)).unit() for x in [0, 1.0j, -1.0, -1.0j]]. print(expect(c, cat_list)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. [ 0.+0.j 0.+1.j -1.+0.j 0.-1.j]. Notice how in this last example, all of the return values are complex numbers. This is because the :func:`.expect` function looks to see whether the operator is Hermitian or not. If the operator is Hermitian, then the output will always be real. In the case of non-Hermitian operators, the return values may be complex. Therefore, the :func:`.expect` function will return an array of complex values for non-Hermitian operators when the input is a list/array of states or density matrices. Of course, the :func:`.expect` function works for spin states and operators:. .. testcode:: [states]. up = basis(2, 0). down = basis(2, 1). np.testing.assert_almost_equal(expect(sigmaz(), up), 1). np.testing.assert_almost_equal(expect(sigmaz(), down), -1). as well as the composite objects discussed in the next section :ref:`tensor`:. .. testcode:: [states]. spin1 = basis(2, 0). spin2 = basis(2, 1). two_spins = tensor(spin1, spin2). sz1 = tensor(sigmaz(), qeye(2)). sz2 = tensor(qeye(2), sigmaz()). np.testing.assert_almost_equal(expect(sz1, two_spins), 1). np.testing.assert_almost_equal(expect(sz2, two_spins), -1). .. _states-super:. Superoperators and Vectorized Operators; =======================================. In addition to state vectors and density operators, QuTiP allows for; representing maps that act linearly on density operators using the Kraus,; Liouville supermatrix and Choi matrix formalisms. This support is based on the; correspondence between linear operators acting on a Hilbert space, and vectors; in two copies of that Hilbert space,; :math:`\mathrm{vec} : \mathcal{L}(\mathcal{H}) \to \mathcal{H} \",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:24790,Availability,down,down,24790,"MALIZE_WHITESPACE. [0. 1. 2. 3. 4.]. .. testcode:: [states]. cat_list = [(basis(5, 4) + x * basis(5, 3)).unit() for x in [0, 1.0j, -1.0, -1.0j]]. print(expect(c, cat_list)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. [ 0.+0.j 0.+1.j -1.+0.j 0.-1.j]. Notice how in this last example, all of the return values are complex numbers. This is because the :func:`.expect` function looks to see whether the operator is Hermitian or not. If the operator is Hermitian, then the output will always be real. In the case of non-Hermitian operators, the return values may be complex. Therefore, the :func:`.expect` function will return an array of complex values for non-Hermitian operators when the input is a list/array of states or density matrices. Of course, the :func:`.expect` function works for spin states and operators:. .. testcode:: [states]. up = basis(2, 0). down = basis(2, 1). np.testing.assert_almost_equal(expect(sigmaz(), up), 1). np.testing.assert_almost_equal(expect(sigmaz(), down), -1). as well as the composite objects discussed in the next section :ref:`tensor`:. .. testcode:: [states]. spin1 = basis(2, 0). spin2 = basis(2, 1). two_spins = tensor(spin1, spin2). sz1 = tensor(sigmaz(), qeye(2)). sz2 = tensor(qeye(2), sigmaz()). np.testing.assert_almost_equal(expect(sz1, two_spins), 1). np.testing.assert_almost_equal(expect(sz2, two_spins), -1). .. _states-super:. Superoperators and Vectorized Operators; =======================================. In addition to state vectors and density operators, QuTiP allows for; representing maps that act linearly on density operators using the Kraus,; Liouville supermatrix and Choi matrix formalisms. This support is based on the; correspondence between linear operators acting on a Hilbert space, and vectors; in two copies of that Hilbert space,; :math:`\mathrm{vec} : \mathcal{L}(\mathcal{H}) \to \mathcal{H} \otimes \mathcal{H}`; [Hav03]_, [Wat13]_. This isomorphism is implemented in QuTiP by the; :obj:`.operat",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:12831,Energy Efficiency,energy,energy,12831,":`T = \sqrt{1 - F^{2}}`, while the quantum Hellinger distance (QHE) between two pure states :math:`\left|\psi\right>` and :math:`\left|\phi\right>` is given by :math:`QHE = \sqrt{2 - 2\left|\left<\psi | \phi\right>\right|^2}`. .. testcode:: [states]. np.testing.assert_almost_equal(tracedist(y, x), np.sqrt(1 - fidelity(y, x) ** 2)). For a pure state and a mixed state, :math:`1 - F^{2} \le T` which can also be verified:. .. testcode:: [states]. assert 1 - fidelity(x, z) ** 2 < tracedist(x, z). .. _states-qubit:. Qubit (two-level) systems; =========================. Having spent a fair amount of time on basis states that represent harmonic oscillator states, we now move on to qubit, or two-level quantum systems (for example a spin-1/2). To create a state vector corresponding to a qubit system, we use the same :func:`.basis`, or :func:`.fock`, function with only two levels:. .. testcode:: [states]. spin = basis(2, 0). Now at this point one may ask how this state is different than that of a harmonic oscillator in the vacuum state truncated to two energy levels?. .. testcode:: [states]. vac = basis(2, 0). At this stage, there is no difference. This should not be surprising as we called the exact same function twice. The difference between the two comes from the action of the spin operators :func:`.sigmax`, :func:`.sigmay`, :func:`.sigmaz`, :func:`.sigmap`, and :func:`.sigmam` on these two-level states. For example, if ``vac`` corresponds to the vacuum state of a harmonic oscillator, then, as we have already seen, we can use the raising operator to get the :math:`\left|1\right>` state:. .. testcode:: [states]. print(vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[1.]; [0.]]. .. testcode:: [states]. c = create(2). print(c * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj ",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:3482,Integrability,depend,dependence,3482," function to make a raising operator:. .. testcode:: [states]. c = create(5). print(c * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [1.]; [0.]; [0.]; [0.]]. which does the same thing. We can raise the vacuum state more than once by successively apply the raising operator:. .. testcode:: [states]. print(c * c * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0. ]; [0. ]; [1.41421356]; [0. ]; [0. ]]. or just taking the square of the raising operator :math:`\left(\hat{a}^\dagger\right)^{2}`:. .. testcode:: [states]. print(c ** 2 * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0. ]; [0. ]; [1.41421356]; [0. ]; [0. ]]. Applying the raising operator twice gives the expected :math:`\sqrt{n + 1}` dependence. We can use the product of :math:`c * a` to also apply the number operator to the state vector ``vac``:. .. testcode:: [states]. print(c * a * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [0.]; [0.]; [0.]; [0.]]. or on the :math:`\left| 1\right>` state:. .. testcode:: [states]. print(c * a * (c * vac)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [1.]; [0.]; [0.]; [0.]]. or the :math:`\left| 2\right>` state:. .. testcode:: [states]. print(c * a * (c**2 * vac)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0. ]; [0. ]; [2.82842712]; [0. ]; [0. ]]. Notice how in this last example, application of the number operator doe",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:28678,Modifiability,extend,extended,28678,"st(X.dag()) # Represents conjugation by X. Note that this is done automatically by the :obj:`.to_super` function when given; ``type='oper'`` input. .. testcode:: [states]. S2 = to_super(X). np.testing.assert_almost_equal((S - S2).norm(), 0). Quantum objects representing superoperators are denoted by ``type='super'``:. .. testcode:: [states]. print(S). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True; Qobj data =; [[0. 0. 0. 1.]; [0. 0. 1. 0.]; [0. 1. 0. 0.]; [1. 0. 0. 0.]]. Information about superoperators, such as whether they represent completely; positive maps, is exposed through the :attr:`.Qobj.iscp`, :attr:`.Qobj.istp`; and :attr:`.Qobj.iscptp` attributes:. .. testcode:: [states]. print(S.iscp, S.istp, S.iscptp). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. True True True. In addition, dynamical generators on this extended space, often called; *Liouvillian superoperators*, can be created using the :func:`.liouvillian` function. Each of these takes a Hamiltonian along with; a list of collapse operators, and returns a ``type=""super""`` object that can; be exponentiated to find the superoperator for that evolution. .. testcode:: [states]. H = 10 * sigmaz(). c1 = destroy(2). L = liouvillian(H, [c1]). print(L). S = (12 * L).expm(). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = False; Qobj data =; [[ 0. +0.j 0. +0.j 0. +0.j 1. +0.j]; [ 0. +0.j -0.5+20.j 0. +0.j 0. +0.j]; [ 0. +0.j 0. +0.j -0.5-20.j 0. +0.j]; [ 0. +0.j 0. +0.j 0. +0.j -1. +0.j]]. For qubits, a particularly useful way to visualize superoperators is to plot them in the Pauli basis,; such that :math:`S_{\mu,\nu} = \langle\!\langle \sigma_{\mu} | S[\sigma_{\nu}] \rangle\!\rangle`. Because; the Pauli basis is Hermitian, :math:`S_{\mu,\nu}` is a real numb",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:350,Performance,perform,performing,350,".. _states:. *************************************; Manipulating States and Operators; *************************************. .. _states-intro:. Introduction; =================. In the previous guide section :ref:`basics`, we saw how to create states and operators, using the functions built into QuTiP. In this portion of the guide, we will look at performing basic operations with states and operators. For more detailed demonstrations on how to use and manipulate these objects, see the examples on the `tutorials <https://qutip.org/tutorials.html>`_ web page. .. _states-vectors:. State Vectors (kets or bras); ==============================. Here we begin by creating a Fock :func:`.basis` vacuum state vector :math:`\left|0\right>` with in a Hilbert space with 5 number states, from 0 to 4:. .. testcode:: [states]. vac = basis(5, 0). print(vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]; [0.]]. and then create a lowering operator :math:`\left(\hat{a}\right)` corresponding to 5 number states using the :func:`.destroy` function:. .. testcode:: [states]. a = destroy(5). print(a). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = False; Qobj data =; [[0. 1. 0. 0. 0. ]; [0. 0. 1.41421356 0. 0. ]; [0. 0. 0. 1.73205081 0. ]; [0. 0. 0. 0. 2. ]; [0. 0. 0. 0. 0. ]]. Now lets apply the destruction operator to our vacuum state ``vac``,. .. testcode:: [states]. print(a * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [0.]; [0.]; [0.]; [0.]]. We see that, as expected, the vacuum is transformed to the zero vector. A more interesting example comes from using the adjoint of the lowering operator, the raising operator :math:`\hat{a}^\dagger`:. .. testcode::",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:22278,Performance,load,load,22278,"------------------+-------------------------------------------------------+; | :func:`~qutip.core.gates.molmer_sorensen` | Molmer Sorensen gate |; +------------------------------------------------+-------------------------------------------------------+; | :func:`~qutip.core.gates.toffoli` | Toffoli gate |; +------------------------------------------------+-------------------------------------------------------+; | :func:`~qutip.core.gates.hadamard_transform` | Hadamard gate |; +------------------------------------------------+-------------------------------------------------------+; | :func:`~qutip.core.gates.qubit_clifford_group` | Generates the Clifford group on a single qubit |; +------------------------------------------------+-------------------------------------------------------+; | :func:`~qutip.core.gates.globalphase` | Global phase gate |; +------------------------------------------------+-------------------------------------------------------+. To load this qutip module, first you have to import gates:. .. code-block:: Python. from qutip import gates. For example to use the Hadamard Gate:. .. testcode:: [basics]. H = gates.hadamard_transform(); print(H). **Output**:. .. testoutput:: [basics]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims=[[2], [2]], shape=(2, 2), type='oper', dtype=Dense, isherm=True; Qobj data =; [[ 0.70710678 0.70710678]; [0.70710678 -0.70710678]]. .. _states-expect:. Expectation values; ===================. Some of the most important information about quantum systems comes from calculating the expectation value of operators, both Hermitian and non-Hermitian, as the state or density matrix of the system varies in time. Therefore, in this section we demonstrate the use of the :func:`.expect` function. To begin:. .. testcode:: [states]. vac = basis(5, 0). one = basis(5, 1). c = create(5). N = num(5). np.testing.assert_almost_equal(expect(N, vac), 0). np.testing.assert_almost_equal(expect(N, one), 1). coh = coherent_dm(5, 1.0j). n",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:41676,Performance,perform,perform,41676," from; the :math:`\chi_{00}` element:. .. testcode:: [states]. np.testing.assert_almost_equal(average_gate_fidelity(S), 0.9499999999999998). print(chi[0, 0] / 4). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. (0.925+0j). Here, the factor of 4 comes from the dimension of the underlying; Hilbert space :math:`\mathcal{H}`. As with the superoperator; and Choi representations, the :math:`\chi` representation is; denoted by the :attr:`.Qobj.superrep`, such that :func:`.to_super`,; :func:`.to_choi`, :func:`.to_kraus`,; :func:`.to_stinespring` and :func:`.to_chi`; all convert from the :math:`\chi` representation appropriately. Properties of Quantum Maps; ==========================. In addition to converting between the different representations of quantum maps,; QuTiP also provides attributes to make it easy to check if a map is completely; positive, trace preserving and/or hermicity preserving. Each of these attributes; uses :attr:`.Qobj.superrep` to automatically perform any needed conversions. In particular, a quantum map is said to be positive (but not necessarily completely; positive) if it maps all positive operators to positive operators. For instance, the; transpose map :math:`\Lambda(\rho) = \rho^{\mathrm{T}}` is a positive map. We run into; problems, however, if we tensor :math:`\Lambda` with the identity to get a partial; transpose map. .. testcode:: [states]. rho = ket2dm(bell_state()); rho_out = partial_transpose(rho, [0, 1]); print(rho_out.eigenenergies()). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. [-0.5 0.5 0.5 0.5]. Notice that even though we started with a positive map, we got an operator out; with negative eigenvalues. Complete positivity addresses this by requiring that; a map returns positive operators for all positive operators, and does so even; under tensoring with another map. The Choi matrix is very useful here, as it; can be shown that a map is completely positive if and only if its Choi matri",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:28393,Security,expose,exposed,28393,"H}` is a vector space, linear maps; on this space can be represented as matrices, often called *superoperators*.; Using the :obj:`.Qobj`, the :obj:`.spre` and :obj:`.spost` functions, supermatrices; corresponding to left- and right-multiplication respectively can be quickly; constructed. .. testcode:: [states]. X = sigmax(). S = spre(X) * spost(X.dag()) # Represents conjugation by X. Note that this is done automatically by the :obj:`.to_super` function when given; ``type='oper'`` input. .. testcode:: [states]. S2 = to_super(X). np.testing.assert_almost_equal((S - S2).norm(), 0). Quantum objects representing superoperators are denoted by ``type='super'``:. .. testcode:: [states]. print(S). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True; Qobj data =; [[0. 0. 0. 1.]; [0. 0. 1. 0.]; [0. 1. 0. 0.]; [1. 0. 0. 0.]]. Information about superoperators, such as whether they represent completely; positive maps, is exposed through the :attr:`.Qobj.iscp`, :attr:`.Qobj.istp`; and :attr:`.Qobj.iscptp` attributes:. .. testcode:: [states]. print(S.iscp, S.istp, S.iscptp). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. True True True. In addition, dynamical generators on this extended space, often called; *Liouvillian superoperators*, can be created using the :func:`.liouvillian` function. Each of these takes a Hamiltonian along with; a list of collapse operators, and returns a ``type=""super""`` object that can; be exponentiated to find the superoperator for that evolution. .. testcode:: [states]. H = 10 * sigmaz(). c1 = destroy(2). L = liouvillian(H, [c1]). print(L). S = (12 * L).expm(). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = False; Qobj data =; [[ 0. +0.j 0. +0.j 0. +0.j 1. +0.j]; [ 0. +0.j -0.5+20.j 0. +0.j 0. +0.j]; [ 0. +",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:801,Testability,test,testcode,801,".. _states:. *************************************; Manipulating States and Operators; *************************************. .. _states-intro:. Introduction; =================. In the previous guide section :ref:`basics`, we saw how to create states and operators, using the functions built into QuTiP. In this portion of the guide, we will look at performing basic operations with states and operators. For more detailed demonstrations on how to use and manipulate these objects, see the examples on the `tutorials <https://qutip.org/tutorials.html>`_ web page. .. _states-vectors:. State Vectors (kets or bras); ==============================. Here we begin by creating a Fock :func:`.basis` vacuum state vector :math:`\left|0\right>` with in a Hilbert space with 5 number states, from 0 to 4:. .. testcode:: [states]. vac = basis(5, 0). print(vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]; [0.]]. and then create a lowering operator :math:`\left(\hat{a}\right)` corresponding to 5 number states using the :func:`.destroy` function:. .. testcode:: [states]. a = destroy(5). print(a). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = False; Qobj data =; [[0. 1. 0. 0. 0. ]; [0. 0. 1.41421356 0. 0. ]; [0. 0. 0. 1.73205081 0. ]; [0. 0. 0. 0. 2. ]; [0. 0. 0. 0. 0. ]]. Now lets apply the destruction operator to our vacuum state ``vac``,. .. testcode:: [states]. print(a * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [0.]; [0.]; [0.]; [0.]]. We see that, as expected, the vacuum is transformed to the zero vector. A more interesting example comes from using the adjoint of the lowering operator, the raising operator :math:`\hat{a}^\dagger`:. .. testcode::",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:869,Testability,test,testoutput,869,".. _states:. *************************************; Manipulating States and Operators; *************************************. .. _states-intro:. Introduction; =================. In the previous guide section :ref:`basics`, we saw how to create states and operators, using the functions built into QuTiP. In this portion of the guide, we will look at performing basic operations with states and operators. For more detailed demonstrations on how to use and manipulate these objects, see the examples on the `tutorials <https://qutip.org/tutorials.html>`_ web page. .. _states-vectors:. State Vectors (kets or bras); ==============================. Here we begin by creating a Fock :func:`.basis` vacuum state vector :math:`\left|0\right>` with in a Hilbert space with 5 number states, from 0 to 4:. .. testcode:: [states]. vac = basis(5, 0). print(vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]; [0.]]. and then create a lowering operator :math:`\left(\hat{a}\right)` corresponding to 5 number states using the :func:`.destroy` function:. .. testcode:: [states]. a = destroy(5). print(a). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = False; Qobj data =; [[0. 1. 0. 0. 0. ]; [0. 0. 1.41421356 0. 0. ]; [0. 0. 0. 1.73205081 0. ]; [0. 0. 0. 0. 2. ]; [0. 0. 0. 0. 0. ]]. Now lets apply the destruction operator to our vacuum state ``vac``,. .. testcode:: [states]. print(a * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [0.]; [0.]; [0.]; [0.]]. We see that, as expected, the vacuum is transformed to the zero vector. A more interesting example comes from using the adjoint of the lowering operator, the raising operator :math:`\hat{a}^\dagger`:. .. testcode::",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:1172,Testability,test,testcode,1172,"the previous guide section :ref:`basics`, we saw how to create states and operators, using the functions built into QuTiP. In this portion of the guide, we will look at performing basic operations with states and operators. For more detailed demonstrations on how to use and manipulate these objects, see the examples on the `tutorials <https://qutip.org/tutorials.html>`_ web page. .. _states-vectors:. State Vectors (kets or bras); ==============================. Here we begin by creating a Fock :func:`.basis` vacuum state vector :math:`\left|0\right>` with in a Hilbert space with 5 number states, from 0 to 4:. .. testcode:: [states]. vac = basis(5, 0). print(vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]; [0.]]. and then create a lowering operator :math:`\left(\hat{a}\right)` corresponding to 5 number states using the :func:`.destroy` function:. .. testcode:: [states]. a = destroy(5). print(a). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = False; Qobj data =; [[0. 1. 0. 0. 0. ]; [0. 0. 1.41421356 0. 0. ]; [0. 0. 0. 1.73205081 0. ]; [0. 0. 0. 0. 2. ]; [0. 0. 0. 0. 0. ]]. Now lets apply the destruction operator to our vacuum state ``vac``,. .. testcode:: [states]. print(a * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [0.]; [0.]; [0.]; [0.]]. We see that, as expected, the vacuum is transformed to the zero vector. A more interesting example comes from using the adjoint of the lowering operator, the raising operator :math:`\hat{a}^\dagger`:. .. testcode:: [states]. print(a.dag() * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; ",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:1235,Testability,test,testoutput,1235,"rs, using the functions built into QuTiP. In this portion of the guide, we will look at performing basic operations with states and operators. For more detailed demonstrations on how to use and manipulate these objects, see the examples on the `tutorials <https://qutip.org/tutorials.html>`_ web page. .. _states-vectors:. State Vectors (kets or bras); ==============================. Here we begin by creating a Fock :func:`.basis` vacuum state vector :math:`\left|0\right>` with in a Hilbert space with 5 number states, from 0 to 4:. .. testcode:: [states]. vac = basis(5, 0). print(vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]; [0.]]. and then create a lowering operator :math:`\left(\hat{a}\right)` corresponding to 5 number states using the :func:`.destroy` function:. .. testcode:: [states]. a = destroy(5). print(a). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = False; Qobj data =; [[0. 1. 0. 0. 0. ]; [0. 0. 1.41421356 0. 0. ]; [0. 0. 0. 1.73205081 0. ]; [0. 0. 0. 0. 2. ]; [0. 0. 0. 0. 0. ]]. Now lets apply the destruction operator to our vacuum state ``vac``,. .. testcode:: [states]. print(a * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [0.]; [0.]; [0.]; [0.]]. We see that, as expected, the vacuum is transformed to the zero vector. A more interesting example comes from using the adjoint of the lowering operator, the raising operator :math:`\hat{a}^\dagger`:. .. testcode:: [states]. print(a.dag() * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [1.]; [0.]; [0.]; [0.]]. The raising operator has in indeed raised the st",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:1570,Testability,test,testcode,1570,"ors:. State Vectors (kets or bras); ==============================. Here we begin by creating a Fock :func:`.basis` vacuum state vector :math:`\left|0\right>` with in a Hilbert space with 5 number states, from 0 to 4:. .. testcode:: [states]. vac = basis(5, 0). print(vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]; [0.]]. and then create a lowering operator :math:`\left(\hat{a}\right)` corresponding to 5 number states using the :func:`.destroy` function:. .. testcode:: [states]. a = destroy(5). print(a). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = False; Qobj data =; [[0. 1. 0. 0. 0. ]; [0. 0. 1.41421356 0. 0. ]; [0. 0. 0. 1.73205081 0. ]; [0. 0. 0. 0. 2. ]; [0. 0. 0. 0. 0. ]]. Now lets apply the destruction operator to our vacuum state ``vac``,. .. testcode:: [states]. print(a * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [0.]; [0.]; [0.]; [0.]]. We see that, as expected, the vacuum is transformed to the zero vector. A more interesting example comes from using the adjoint of the lowering operator, the raising operator :math:`\hat{a}^\dagger`:. .. testcode:: [states]. print(a.dag() * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [1.]; [0.]; [0.]; [0.]]. The raising operator has in indeed raised the state `vec` from the vacuum to the :math:`\left| 1\right>` state.; Instead of using the dagger ``Qobj.dag()`` method to raise the state, we could have also used the built in :func:`.create` function to make a raising operator:. .. testcode:: [states]. c = create(5). print(c * vac). **Output**:. .. testoutput:: [states]",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:1623,Testability,test,testoutput,1623,"e we begin by creating a Fock :func:`.basis` vacuum state vector :math:`\left|0\right>` with in a Hilbert space with 5 number states, from 0 to 4:. .. testcode:: [states]. vac = basis(5, 0). print(vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]; [0.]]. and then create a lowering operator :math:`\left(\hat{a}\right)` corresponding to 5 number states using the :func:`.destroy` function:. .. testcode:: [states]. a = destroy(5). print(a). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = False; Qobj data =; [[0. 1. 0. 0. 0. ]; [0. 0. 1.41421356 0. 0. ]; [0. 0. 0. 1.73205081 0. ]; [0. 0. 0. 0. 2. ]; [0. 0. 0. 0. 0. ]]. Now lets apply the destruction operator to our vacuum state ``vac``,. .. testcode:: [states]. print(a * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [0.]; [0.]; [0.]; [0.]]. We see that, as expected, the vacuum is transformed to the zero vector. A more interesting example comes from using the adjoint of the lowering operator, the raising operator :math:`\hat{a}^\dagger`:. .. testcode:: [states]. print(a.dag() * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [1.]; [0.]; [0.]; [0.]]. The raising operator has in indeed raised the state `vec` from the vacuum to the :math:`\left| 1\right>` state.; Instead of using the dagger ``Qobj.dag()`` method to raise the state, we could have also used the built in :func:`.create` function to make a raising operator:. .. testcode:: [states]. c = create(5). print(c * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], ",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:1991,Testability,test,testcode,1991," [[1.]; [0.]; [0.]; [0.]; [0.]]. and then create a lowering operator :math:`\left(\hat{a}\right)` corresponding to 5 number states using the :func:`.destroy` function:. .. testcode:: [states]. a = destroy(5). print(a). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = False; Qobj data =; [[0. 1. 0. 0. 0. ]; [0. 0. 1.41421356 0. 0. ]; [0. 0. 0. 1.73205081 0. ]; [0. 0. 0. 0. 2. ]; [0. 0. 0. 0. 0. ]]. Now lets apply the destruction operator to our vacuum state ``vac``,. .. testcode:: [states]. print(a * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [0.]; [0.]; [0.]; [0.]]. We see that, as expected, the vacuum is transformed to the zero vector. A more interesting example comes from using the adjoint of the lowering operator, the raising operator :math:`\hat{a}^\dagger`:. .. testcode:: [states]. print(a.dag() * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [1.]; [0.]; [0.]; [0.]]. The raising operator has in indeed raised the state `vec` from the vacuum to the :math:`\left| 1\right>` state.; Instead of using the dagger ``Qobj.dag()`` method to raise the state, we could have also used the built in :func:`.create` function to make a raising operator:. .. testcode:: [states]. c = create(5). print(c * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [1.]; [0.]; [0.]; [0.]]. which does the same thing. We can raise the vacuum state more than once by successively apply the raising operator:. .. testcode:: [states]. print(c * c * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:2050,Testability,test,testoutput,2050,"left(\hat{a}\right)` corresponding to 5 number states using the :func:`.destroy` function:. .. testcode:: [states]. a = destroy(5). print(a). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = False; Qobj data =; [[0. 1. 0. 0. 0. ]; [0. 0. 1.41421356 0. 0. ]; [0. 0. 0. 1.73205081 0. ]; [0. 0. 0. 0. 2. ]; [0. 0. 0. 0. 0. ]]. Now lets apply the destruction operator to our vacuum state ``vac``,. .. testcode:: [states]. print(a * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [0.]; [0.]; [0.]; [0.]]. We see that, as expected, the vacuum is transformed to the zero vector. A more interesting example comes from using the adjoint of the lowering operator, the raising operator :math:`\hat{a}^\dagger`:. .. testcode:: [states]. print(a.dag() * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [1.]; [0.]; [0.]; [0.]]. The raising operator has in indeed raised the state `vec` from the vacuum to the :math:`\left| 1\right>` state.; Instead of using the dagger ``Qobj.dag()`` method to raise the state, we could have also used the built in :func:`.create` function to make a raising operator:. .. testcode:: [states]. c = create(5). print(c * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [1.]; [0.]; [0.]; [0.]]. which does the same thing. We can raise the vacuum state more than once by successively apply the raising operator:. .. testcode:: [states]. print(c * c * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0. ]; [0. ]; [1.41421356]; [0. ]; [0. ]]. o",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:2491,Testability,test,testcode,2491," lets apply the destruction operator to our vacuum state ``vac``,. .. testcode:: [states]. print(a * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [0.]; [0.]; [0.]; [0.]]. We see that, as expected, the vacuum is transformed to the zero vector. A more interesting example comes from using the adjoint of the lowering operator, the raising operator :math:`\hat{a}^\dagger`:. .. testcode:: [states]. print(a.dag() * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [1.]; [0.]; [0.]; [0.]]. The raising operator has in indeed raised the state `vec` from the vacuum to the :math:`\left| 1\right>` state.; Instead of using the dagger ``Qobj.dag()`` method to raise the state, we could have also used the built in :func:`.create` function to make a raising operator:. .. testcode:: [states]. c = create(5). print(c * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [1.]; [0.]; [0.]; [0.]]. which does the same thing. We can raise the vacuum state more than once by successively apply the raising operator:. .. testcode:: [states]. print(c * c * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0. ]; [0. ]; [1.41421356]; [0. ]; [0. ]]. or just taking the square of the raising operator :math:`\left(\hat{a}^\dagger\right)^{2}`:. .. testcode:: [states]. print(c ** 2 * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0. ]; [0. ]; [1.41421356]; [0. ]; [0. ]]. Applying the raising operator twice gives the expected :math:`\sqrt{n + 1}` dependence. We can ",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:2559,Testability,test,testoutput,2559,"es]. print(a * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [0.]; [0.]; [0.]; [0.]]. We see that, as expected, the vacuum is transformed to the zero vector. A more interesting example comes from using the adjoint of the lowering operator, the raising operator :math:`\hat{a}^\dagger`:. .. testcode:: [states]. print(a.dag() * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [1.]; [0.]; [0.]; [0.]]. The raising operator has in indeed raised the state `vec` from the vacuum to the :math:`\left| 1\right>` state.; Instead of using the dagger ``Qobj.dag()`` method to raise the state, we could have also used the built in :func:`.create` function to make a raising operator:. .. testcode:: [states]. c = create(5). print(c * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [1.]; [0.]; [0.]; [0.]]. which does the same thing. We can raise the vacuum state more than once by successively apply the raising operator:. .. testcode:: [states]. print(c * c * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0. ]; [0. ]; [1.41421356]; [0. ]; [0. ]]. or just taking the square of the raising operator :math:`\left(\hat{a}^\dagger\right)^{2}`:. .. testcode:: [states]. print(c ** 2 * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0. ]; [0. ]; [1.41421356]; [0. ]; [0. ]]. Applying the raising operator twice gives the expected :math:`\sqrt{n + 1}` dependence. We can use the product of :math:`c * a` to also apply the number operator to the state vecto",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:2843,Testability,test,testcode,2843,"ector. A more interesting example comes from using the adjoint of the lowering operator, the raising operator :math:`\hat{a}^\dagger`:. .. testcode:: [states]. print(a.dag() * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [1.]; [0.]; [0.]; [0.]]. The raising operator has in indeed raised the state `vec` from the vacuum to the :math:`\left| 1\right>` state.; Instead of using the dagger ``Qobj.dag()`` method to raise the state, we could have also used the built in :func:`.create` function to make a raising operator:. .. testcode:: [states]. c = create(5). print(c * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [1.]; [0.]; [0.]; [0.]]. which does the same thing. We can raise the vacuum state more than once by successively apply the raising operator:. .. testcode:: [states]. print(c * c * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0. ]; [0. ]; [1.41421356]; [0. ]; [0. ]]. or just taking the square of the raising operator :math:`\left(\hat{a}^\dagger\right)^{2}`:. .. testcode:: [states]. print(c ** 2 * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0. ]; [0. ]; [1.41421356]; [0. ]; [0. ]]. Applying the raising operator twice gives the expected :math:`\sqrt{n + 1}` dependence. We can use the product of :math:`c * a` to also apply the number operator to the state vector ``vac``:. .. testcode:: [states]. print(c * a * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [0.]; [0.]; [0.]; [0.]]. or on the :math:`\left| 1\right",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:2900,Testability,test,testoutput,2900,"ing operator, the raising operator :math:`\hat{a}^\dagger`:. .. testcode:: [states]. print(a.dag() * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [1.]; [0.]; [0.]; [0.]]. The raising operator has in indeed raised the state `vec` from the vacuum to the :math:`\left| 1\right>` state.; Instead of using the dagger ``Qobj.dag()`` method to raise the state, we could have also used the built in :func:`.create` function to make a raising operator:. .. testcode:: [states]. c = create(5). print(c * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [1.]; [0.]; [0.]; [0.]]. which does the same thing. We can raise the vacuum state more than once by successively apply the raising operator:. .. testcode:: [states]. print(c * c * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0. ]; [0. ]; [1.41421356]; [0. ]; [0. ]]. or just taking the square of the raising operator :math:`\left(\hat{a}^\dagger\right)^{2}`:. .. testcode:: [states]. print(c ** 2 * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0. ]; [0. ]; [1.41421356]; [0. ]; [0. ]]. Applying the raising operator twice gives the expected :math:`\sqrt{n + 1}` dependence. We can use the product of :math:`c * a` to also apply the number operator to the state vector ``vac``:. .. testcode:: [states]. print(c * a * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [0.]; [0.]; [0.]; [0.]]. or on the :math:`\left| 1\right>` state:. .. testcode:: [states]. print(c * a * (c * vac)). **Output**:. ",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:3172,Testability,test,testcode,3172," [[0.]; [1.]; [0.]; [0.]; [0.]]. The raising operator has in indeed raised the state `vec` from the vacuum to the :math:`\left| 1\right>` state.; Instead of using the dagger ``Qobj.dag()`` method to raise the state, we could have also used the built in :func:`.create` function to make a raising operator:. .. testcode:: [states]. c = create(5). print(c * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [1.]; [0.]; [0.]; [0.]]. which does the same thing. We can raise the vacuum state more than once by successively apply the raising operator:. .. testcode:: [states]. print(c * c * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0. ]; [0. ]; [1.41421356]; [0. ]; [0. ]]. or just taking the square of the raising operator :math:`\left(\hat{a}^\dagger\right)^{2}`:. .. testcode:: [states]. print(c ** 2 * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0. ]; [0. ]; [1.41421356]; [0. ]; [0. ]]. Applying the raising operator twice gives the expected :math:`\sqrt{n + 1}` dependence. We can use the product of :math:`c * a` to also apply the number operator to the state vector ``vac``:. .. testcode:: [states]. print(c * a * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [0.]; [0.]; [0.]; [0.]]. or on the :math:`\left| 1\right>` state:. .. testcode:: [states]. print(c * a * (c * vac)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [1.]; [0.]; [0.]; [0.]]. or the :math:`\left| 2\right>` state:. .. testcode:: [states]. print(c * a * (c**2 * vac",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:3230,Testability,test,testoutput,3230,"he state `vec` from the vacuum to the :math:`\left| 1\right>` state.; Instead of using the dagger ``Qobj.dag()`` method to raise the state, we could have also used the built in :func:`.create` function to make a raising operator:. .. testcode:: [states]. c = create(5). print(c * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [1.]; [0.]; [0.]; [0.]]. which does the same thing. We can raise the vacuum state more than once by successively apply the raising operator:. .. testcode:: [states]. print(c * c * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0. ]; [0. ]; [1.41421356]; [0. ]; [0. ]]. or just taking the square of the raising operator :math:`\left(\hat{a}^\dagger\right)^{2}`:. .. testcode:: [states]. print(c ** 2 * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0. ]; [0. ]; [1.41421356]; [0. ]; [0. ]]. Applying the raising operator twice gives the expected :math:`\sqrt{n + 1}` dependence. We can use the product of :math:`c * a` to also apply the number operator to the state vector ``vac``:. .. testcode:: [states]. print(c * a * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [0.]; [0.]; [0.]; [0.]]. or on the :math:`\left| 1\right>` state:. .. testcode:: [states]. print(c * a * (c * vac)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [1.]; [0.]; [0.]; [0.]]. or the :math:`\left| 2\right>` state:. .. testcode:: [states]. print(c * a * (c**2 * vac)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE.",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:3601,Testability,test,testcode,3601,"ACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [1.]; [0.]; [0.]; [0.]]. which does the same thing. We can raise the vacuum state more than once by successively apply the raising operator:. .. testcode:: [states]. print(c * c * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0. ]; [0. ]; [1.41421356]; [0. ]; [0. ]]. or just taking the square of the raising operator :math:`\left(\hat{a}^\dagger\right)^{2}`:. .. testcode:: [states]. print(c ** 2 * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0. ]; [0. ]; [1.41421356]; [0. ]; [0. ]]. Applying the raising operator twice gives the expected :math:`\sqrt{n + 1}` dependence. We can use the product of :math:`c * a` to also apply the number operator to the state vector ``vac``:. .. testcode:: [states]. print(c * a * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [0.]; [0.]; [0.]; [0.]]. or on the :math:`\left| 1\right>` state:. .. testcode:: [states]. print(c * a * (c * vac)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [1.]; [0.]; [0.]; [0.]]. or the :math:`\left| 2\right>` state:. .. testcode:: [states]. print(c * a * (c**2 * vac)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0. ]; [0. ]; [2.82842712]; [0. ]; [0. ]]. Notice how in this last example, application of the number operator does not give the expected value :math:`n=2`, but rather :math:`2\sqrt{2}`. This is because this last state is not normalized to unity as :math:`c\left| n\right> = \",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:3658,Testability,test,testoutput,3658,"ta =; [[0.]; [1.]; [0.]; [0.]; [0.]]. which does the same thing. We can raise the vacuum state more than once by successively apply the raising operator:. .. testcode:: [states]. print(c * c * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0. ]; [0. ]; [1.41421356]; [0. ]; [0. ]]. or just taking the square of the raising operator :math:`\left(\hat{a}^\dagger\right)^{2}`:. .. testcode:: [states]. print(c ** 2 * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0. ]; [0. ]; [1.41421356]; [0. ]; [0. ]]. Applying the raising operator twice gives the expected :math:`\sqrt{n + 1}` dependence. We can use the product of :math:`c * a` to also apply the number operator to the state vector ``vac``:. .. testcode:: [states]. print(c * a * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [0.]; [0.]; [0.]; [0.]]. or on the :math:`\left| 1\right>` state:. .. testcode:: [states]. print(c * a * (c * vac)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [1.]; [0.]; [0.]; [0.]]. or the :math:`\left| 2\right>` state:. .. testcode:: [states]. print(c * a * (c**2 * vac)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0. ]; [0. ]; [2.82842712]; [0. ]; [0. ]]. Notice how in this last example, application of the number operator does not give the expected value :math:`n=2`, but rather :math:`2\sqrt{2}`. This is because this last state is not normalized to unity as :math:`c\left| n\right> = \sqrt{n+1}\left| n+1\right>`. Therefore, we should normalize our vector fir",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:3867,Testability,test,testcode,3867,"* vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0. ]; [0. ]; [1.41421356]; [0. ]; [0. ]]. or just taking the square of the raising operator :math:`\left(\hat{a}^\dagger\right)^{2}`:. .. testcode:: [states]. print(c ** 2 * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0. ]; [0. ]; [1.41421356]; [0. ]; [0. ]]. Applying the raising operator twice gives the expected :math:`\sqrt{n + 1}` dependence. We can use the product of :math:`c * a` to also apply the number operator to the state vector ``vac``:. .. testcode:: [states]. print(c * a * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [0.]; [0.]; [0.]; [0.]]. or on the :math:`\left| 1\right>` state:. .. testcode:: [states]. print(c * a * (c * vac)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [1.]; [0.]; [0.]; [0.]]. or the :math:`\left| 2\right>` state:. .. testcode:: [states]. print(c * a * (c**2 * vac)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0. ]; [0. ]; [2.82842712]; [0. ]; [0. ]]. Notice how in this last example, application of the number operator does not give the expected value :math:`n=2`, but rather :math:`2\sqrt{2}`. This is because this last state is not normalized to unity as :math:`c\left| n\right> = \sqrt{n+1}\left| n+1\right>`. Therefore, we should normalize our vector first:. .. testcode:: [states]. print(c * a * (c**2 * vac).unit()). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:3930,Testability,test,testoutput,3930,"uantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0. ]; [0. ]; [1.41421356]; [0. ]; [0. ]]. or just taking the square of the raising operator :math:`\left(\hat{a}^\dagger\right)^{2}`:. .. testcode:: [states]. print(c ** 2 * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0. ]; [0. ]; [1.41421356]; [0. ]; [0. ]]. Applying the raising operator twice gives the expected :math:`\sqrt{n + 1}` dependence. We can use the product of :math:`c * a` to also apply the number operator to the state vector ``vac``:. .. testcode:: [states]. print(c * a * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [0.]; [0.]; [0.]; [0.]]. or on the :math:`\left| 1\right>` state:. .. testcode:: [states]. print(c * a * (c * vac)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [1.]; [0.]; [0.]; [0.]]. or the :math:`\left| 2\right>` state:. .. testcode:: [states]. print(c * a * (c**2 * vac)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0. ]; [0. ]; [2.82842712]; [0. ]; [0. ]]. Notice how in this last example, application of the number operator does not give the expected value :math:`n=2`, but rather :math:`2\sqrt{2}`. This is because this last state is not normalized to unity as :math:`c\left| n\right> = \sqrt{n+1}\left| n+1\right>`. Therefore, we should normalize our vector first:. .. testcode:: [states]. print(c * a * (c**2 * vac).unit()). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [0.]; [2.]; [0.]; [0.]]. Since we are giving a demon",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:4136,Testability,test,testcode,4136,"}^\dagger\right)^{2}`:. .. testcode:: [states]. print(c ** 2 * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0. ]; [0. ]; [1.41421356]; [0. ]; [0. ]]. Applying the raising operator twice gives the expected :math:`\sqrt{n + 1}` dependence. We can use the product of :math:`c * a` to also apply the number operator to the state vector ``vac``:. .. testcode:: [states]. print(c * a * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [0.]; [0.]; [0.]; [0.]]. or on the :math:`\left| 1\right>` state:. .. testcode:: [states]. print(c * a * (c * vac)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [1.]; [0.]; [0.]; [0.]]. or the :math:`\left| 2\right>` state:. .. testcode:: [states]. print(c * a * (c**2 * vac)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0. ]; [0. ]; [2.82842712]; [0. ]; [0. ]]. Notice how in this last example, application of the number operator does not give the expected value :math:`n=2`, but rather :math:`2\sqrt{2}`. This is because this last state is not normalized to unity as :math:`c\left| n\right> = \sqrt{n+1}\left| n+1\right>`. Therefore, we should normalize our vector first:. .. testcode:: [states]. print(c * a * (c**2 * vac).unit()). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [0.]; [2.]; [0.]; [0.]]. Since we are giving a demonstration of using states and operators, we have done a lot more work than we should have.; For example, we do not need to operate on the vacuum state to generate a higher number Fock state.",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:4202,Testability,test,testoutput,4202," testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0. ]; [0. ]; [1.41421356]; [0. ]; [0. ]]. Applying the raising operator twice gives the expected :math:`\sqrt{n + 1}` dependence. We can use the product of :math:`c * a` to also apply the number operator to the state vector ``vac``:. .. testcode:: [states]. print(c * a * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [0.]; [0.]; [0.]; [0.]]. or on the :math:`\left| 1\right>` state:. .. testcode:: [states]. print(c * a * (c * vac)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [1.]; [0.]; [0.]; [0.]]. or the :math:`\left| 2\right>` state:. .. testcode:: [states]. print(c * a * (c**2 * vac)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0. ]; [0. ]; [2.82842712]; [0. ]; [0. ]]. Notice how in this last example, application of the number operator does not give the expected value :math:`n=2`, but rather :math:`2\sqrt{2}`. This is because this last state is not normalized to unity as :math:`c\left| n\right> = \sqrt{n+1}\left| n+1\right>`. Therefore, we should normalize our vector first:. .. testcode:: [states]. print(c * a * (c**2 * vac).unit()). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [0.]; [2.]; [0.]; [0.]]. Since we are giving a demonstration of using states and operators, we have done a lot more work than we should have.; For example, we do not need to operate on the vacuum state to generate a higher number Fock state.; Instead we can use the :func:`.basis` (or :func:`.fock`) function to directly obt",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:4693,Testability,test,testcode,4693,"WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [0.]; [0.]; [0.]; [0.]]. or on the :math:`\left| 1\right>` state:. .. testcode:: [states]. print(c * a * (c * vac)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [1.]; [0.]; [0.]; [0.]]. or the :math:`\left| 2\right>` state:. .. testcode:: [states]. print(c * a * (c**2 * vac)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0. ]; [0. ]; [2.82842712]; [0. ]; [0. ]]. Notice how in this last example, application of the number operator does not give the expected value :math:`n=2`, but rather :math:`2\sqrt{2}`. This is because this last state is not normalized to unity as :math:`c\left| n\right> = \sqrt{n+1}\left| n+1\right>`. Therefore, we should normalize our vector first:. .. testcode:: [states]. print(c * a * (c**2 * vac).unit()). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [0.]; [2.]; [0.]; [0.]]. Since we are giving a demonstration of using states and operators, we have done a lot more work than we should have.; For example, we do not need to operate on the vacuum state to generate a higher number Fock state.; Instead we can use the :func:`.basis` (or :func:`.fock`) function to directly obtain the required state:. .. testcode:: [states]. ket = basis(5, 2). print(ket). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [0.]; [1.]; [0.]; [0.]]. Notice how it is automatically normalized. We can also use the built in :func:`.num` operator:. .. testcode:: [states]. n = num(5). print(n). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. ",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:4766,Testability,test,testoutput,4766,".]; [0.]; [0.]; [0.]; [0.]]. or on the :math:`\left| 1\right>` state:. .. testcode:: [states]. print(c * a * (c * vac)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [1.]; [0.]; [0.]; [0.]]. or the :math:`\left| 2\right>` state:. .. testcode:: [states]. print(c * a * (c**2 * vac)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0. ]; [0. ]; [2.82842712]; [0. ]; [0. ]]. Notice how in this last example, application of the number operator does not give the expected value :math:`n=2`, but rather :math:`2\sqrt{2}`. This is because this last state is not normalized to unity as :math:`c\left| n\right> = \sqrt{n+1}\left| n+1\right>`. Therefore, we should normalize our vector first:. .. testcode:: [states]. print(c * a * (c**2 * vac).unit()). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [0.]; [2.]; [0.]; [0.]]. Since we are giving a demonstration of using states and operators, we have done a lot more work than we should have.; For example, we do not need to operate on the vacuum state to generate a higher number Fock state.; Instead we can use the :func:`.basis` (or :func:`.fock`) function to directly obtain the required state:. .. testcode:: [states]. ket = basis(5, 2). print(ket). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [0.]; [1.]; [0.]; [0.]]. Notice how it is automatically normalized. We can also use the built in :func:`.num` operator:. .. testcode:: [states]. n = num(5). print(n). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:5257,Testability,test,testcode,5257,"object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0. ]; [0. ]; [2.82842712]; [0. ]; [0. ]]. Notice how in this last example, application of the number operator does not give the expected value :math:`n=2`, but rather :math:`2\sqrt{2}`. This is because this last state is not normalized to unity as :math:`c\left| n\right> = \sqrt{n+1}\left| n+1\right>`. Therefore, we should normalize our vector first:. .. testcode:: [states]. print(c * a * (c**2 * vac).unit()). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [0.]; [2.]; [0.]; [0.]]. Since we are giving a demonstration of using states and operators, we have done a lot more work than we should have.; For example, we do not need to operate on the vacuum state to generate a higher number Fock state.; Instead we can use the :func:`.basis` (or :func:`.fock`) function to directly obtain the required state:. .. testcode:: [states]. ket = basis(5, 2). print(ket). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [0.]; [1.]; [0.]; [0.]]. Notice how it is automatically normalized. We can also use the built in :func:`.num` operator:. .. testcode:: [states]. n = num(5). print(n). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[0. 0. 0. 0. 0.]; [0. 1. 0. 0. 0.]; [0. 0. 2. 0. 0.]; [0. 0. 0. 3. 0.]; [0. 0. 0. 0. 4.]]. Therefore, instead of ``c * a * (c ** 2 * vac).unit()`` we have:. .. testcode:: [states]. print(n * ket). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [0.]; [2.]; [0.]; [0.]]. We can also create superpositions of states:. .. testcode:: [states]. ket = (basis(5, 0) + bas",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:5325,Testability,test,testoutput,5325,"82842712]; [0. ]; [0. ]]. Notice how in this last example, application of the number operator does not give the expected value :math:`n=2`, but rather :math:`2\sqrt{2}`. This is because this last state is not normalized to unity as :math:`c\left| n\right> = \sqrt{n+1}\left| n+1\right>`. Therefore, we should normalize our vector first:. .. testcode:: [states]. print(c * a * (c**2 * vac).unit()). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [0.]; [2.]; [0.]; [0.]]. Since we are giving a demonstration of using states and operators, we have done a lot more work than we should have.; For example, we do not need to operate on the vacuum state to generate a higher number Fock state.; Instead we can use the :func:`.basis` (or :func:`.fock`) function to directly obtain the required state:. .. testcode:: [states]. ket = basis(5, 2). print(ket). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [0.]; [1.]; [0.]; [0.]]. Notice how it is automatically normalized. We can also use the built in :func:`.num` operator:. .. testcode:: [states]. n = num(5). print(n). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[0. 0. 0. 0. 0.]; [0. 1. 0. 0. 0.]; [0. 0. 2. 0. 0.]; [0. 0. 0. 3. 0.]; [0. 0. 0. 0. 4.]]. Therefore, instead of ``c * a * (c ** 2 * vac).unit()`` we have:. .. testcode:: [states]. print(n * ket). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [0.]; [2.]; [0.]; [0.]]. We can also create superpositions of states:. .. testcode:: [states]. ket = (basis(5, 0) + basis(5, 1)).unit(). print(ket). **Output**:. .. testoutput:: [states]; :options: +NORMA",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:5588,Testability,test,testcode,5588,"| n\right> = \sqrt{n+1}\left| n+1\right>`. Therefore, we should normalize our vector first:. .. testcode:: [states]. print(c * a * (c**2 * vac).unit()). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [0.]; [2.]; [0.]; [0.]]. Since we are giving a demonstration of using states and operators, we have done a lot more work than we should have.; For example, we do not need to operate on the vacuum state to generate a higher number Fock state.; Instead we can use the :func:`.basis` (or :func:`.fock`) function to directly obtain the required state:. .. testcode:: [states]. ket = basis(5, 2). print(ket). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [0.]; [1.]; [0.]; [0.]]. Notice how it is automatically normalized. We can also use the built in :func:`.num` operator:. .. testcode:: [states]. n = num(5). print(n). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[0. 0. 0. 0. 0.]; [0. 1. 0. 0. 0.]; [0. 0. 2. 0. 0.]; [0. 0. 0. 3. 0.]; [0. 0. 0. 0. 4.]]. Therefore, instead of ``c * a * (c ** 2 * vac).unit()`` we have:. .. testcode:: [states]. print(n * ket). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [0.]; [2.]; [0.]; [0.]]. We can also create superpositions of states:. .. testcode:: [states]. ket = (basis(5, 0) + basis(5, 1)).unit(). print(ket). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.70710678]; [0.70710678]; [0. ]; [0. ]; [0. ]]. where we have used the :meth:`.Qobj.unit` method to again normalize the state. Operating with the numb",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:5647,Testability,test,testoutput,5647," vector first:. .. testcode:: [states]. print(c * a * (c**2 * vac).unit()). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [0.]; [2.]; [0.]; [0.]]. Since we are giving a demonstration of using states and operators, we have done a lot more work than we should have.; For example, we do not need to operate on the vacuum state to generate a higher number Fock state.; Instead we can use the :func:`.basis` (or :func:`.fock`) function to directly obtain the required state:. .. testcode:: [states]. ket = basis(5, 2). print(ket). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [0.]; [1.]; [0.]; [0.]]. Notice how it is automatically normalized. We can also use the built in :func:`.num` operator:. .. testcode:: [states]. n = num(5). print(n). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[0. 0. 0. 0. 0.]; [0. 1. 0. 0. 0.]; [0. 0. 2. 0. 0.]; [0. 0. 0. 3. 0.]; [0. 0. 0. 0. 4.]]. Therefore, instead of ``c * a * (c ** 2 * vac).unit()`` we have:. .. testcode:: [states]. print(n * ket). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [0.]; [2.]; [0.]; [0.]]. We can also create superpositions of states:. .. testcode:: [states]. ket = (basis(5, 0) + basis(5, 1)).unit(). print(ket). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.70710678]; [0.70710678]; [0. ]; [0. ]; [0. ]]. where we have used the :meth:`.Qobj.unit` method to again normalize the state. Operating with the number function again:. .. testcode:: [states]. print(n * ket). **Output**:. .. ",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:5956,Testability,test,testcode,5956," of using states and operators, we have done a lot more work than we should have.; For example, we do not need to operate on the vacuum state to generate a higher number Fock state.; Instead we can use the :func:`.basis` (or :func:`.fock`) function to directly obtain the required state:. .. testcode:: [states]. ket = basis(5, 2). print(ket). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [0.]; [1.]; [0.]; [0.]]. Notice how it is automatically normalized. We can also use the built in :func:`.num` operator:. .. testcode:: [states]. n = num(5). print(n). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[0. 0. 0. 0. 0.]; [0. 1. 0. 0. 0.]; [0. 0. 2. 0. 0.]; [0. 0. 0. 3. 0.]; [0. 0. 0. 0. 4.]]. Therefore, instead of ``c * a * (c ** 2 * vac).unit()`` we have:. .. testcode:: [states]. print(n * ket). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [0.]; [2.]; [0.]; [0.]]. We can also create superpositions of states:. .. testcode:: [states]. ket = (basis(5, 0) + basis(5, 1)).unit(). print(ket). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.70710678]; [0.70710678]; [0. ]; [0. ]; [0. ]]. where we have used the :meth:`.Qobj.unit` method to again normalize the state. Operating with the number function again:. .. testcode:: [states]. print(n * ket). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0. ]; [0.70710678]; [0. ]; [0. ]; [0. ]]. We can also create coherent states and squeezed states by applying the :func:`.displace` and :func:`.squeeze` functi",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:6009,Testability,test,testoutput,6009,"ould have.; For example, we do not need to operate on the vacuum state to generate a higher number Fock state.; Instead we can use the :func:`.basis` (or :func:`.fock`) function to directly obtain the required state:. .. testcode:: [states]. ket = basis(5, 2). print(ket). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [0.]; [1.]; [0.]; [0.]]. Notice how it is automatically normalized. We can also use the built in :func:`.num` operator:. .. testcode:: [states]. n = num(5). print(n). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[0. 0. 0. 0. 0.]; [0. 1. 0. 0. 0.]; [0. 0. 2. 0. 0.]; [0. 0. 0. 3. 0.]; [0. 0. 0. 0. 4.]]. Therefore, instead of ``c * a * (c ** 2 * vac).unit()`` we have:. .. testcode:: [states]. print(n * ket). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [0.]; [2.]; [0.]; [0.]]. We can also create superpositions of states:. .. testcode:: [states]. ket = (basis(5, 0) + basis(5, 1)).unit(). print(ket). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.70710678]; [0.70710678]; [0. ]; [0. ]; [0. ]]. where we have used the :meth:`.Qobj.unit` method to again normalize the state. Operating with the number function again:. .. testcode:: [states]. print(n * ket). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0. ]; [0.70710678]; [0. ]; [0. ]; [0. ]]. We can also create coherent states and squeezed states by applying the :func:`.displace` and :func:`.squeeze` functions to the vacuum state:. .. testcode:: [states]. vac = basis(5, 0). d",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:6222,Testability,test,testcode,6222,"n the required state:. .. testcode:: [states]. ket = basis(5, 2). print(ket). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [0.]; [1.]; [0.]; [0.]]. Notice how it is automatically normalized. We can also use the built in :func:`.num` operator:. .. testcode:: [states]. n = num(5). print(n). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[0. 0. 0. 0. 0.]; [0. 1. 0. 0. 0.]; [0. 0. 2. 0. 0.]; [0. 0. 0. 3. 0.]; [0. 0. 0. 0. 4.]]. Therefore, instead of ``c * a * (c ** 2 * vac).unit()`` we have:. .. testcode:: [states]. print(n * ket). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [0.]; [2.]; [0.]; [0.]]. We can also create superpositions of states:. .. testcode:: [states]. ket = (basis(5, 0) + basis(5, 1)).unit(). print(ket). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.70710678]; [0.70710678]; [0. ]; [0. ]; [0. ]]. where we have used the :meth:`.Qobj.unit` method to again normalize the state. Operating with the number function again:. .. testcode:: [states]. print(n * ket). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0. ]; [0.70710678]; [0. ]; [0. ]; [0. ]]. We can also create coherent states and squeezed states by applying the :func:`.displace` and :func:`.squeeze` functions to the vacuum state:. .. testcode:: [states]. vac = basis(5, 0). d = displace(5, 1j). s = squeeze(5, np.complex(0.25, 0.25)). print(d * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:6313,Testability,test,testoutput,6313,"tates]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [0.]; [1.]; [0.]; [0.]]. Notice how it is automatically normalized. We can also use the built in :func:`.num` operator:. .. testcode:: [states]. n = num(5). print(n). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[0. 0. 0. 0. 0.]; [0. 1. 0. 0. 0.]; [0. 0. 2. 0. 0.]; [0. 0. 0. 3. 0.]; [0. 0. 0. 0. 4.]]. Therefore, instead of ``c * a * (c ** 2 * vac).unit()`` we have:. .. testcode:: [states]. print(n * ket). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [0.]; [2.]; [0.]; [0.]]. We can also create superpositions of states:. .. testcode:: [states]. ket = (basis(5, 0) + basis(5, 1)).unit(). print(ket). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.70710678]; [0.70710678]; [0. ]; [0. ]; [0. ]]. where we have used the :meth:`.Qobj.unit` method to again normalize the state. Operating with the number function again:. .. testcode:: [states]. print(n * ket). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0. ]; [0.70710678]; [0. ]; [0. ]; [0. ]]. We can also create coherent states and squeezed states by applying the :func:`.displace` and :func:`.squeeze` functions to the vacuum state:. .. testcode:: [states]. vac = basis(5, 0). d = displace(5, 1j). s = squeeze(5, np.complex(0.25, 0.25)). print(d * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[ 0.60655682+0.j ]; [ 0. +0.60628133j]; [-0.4303874 +0.j ]; [ 0. -0.24104351j];",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:6621,Testability,test,testcode,6621," **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[0. 0. 0. 0. 0.]; [0. 1. 0. 0. 0.]; [0. 0. 2. 0. 0.]; [0. 0. 0. 3. 0.]; [0. 0. 0. 0. 4.]]. Therefore, instead of ``c * a * (c ** 2 * vac).unit()`` we have:. .. testcode:: [states]. print(n * ket). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [0.]; [2.]; [0.]; [0.]]. We can also create superpositions of states:. .. testcode:: [states]. ket = (basis(5, 0) + basis(5, 1)).unit(). print(ket). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.70710678]; [0.70710678]; [0. ]; [0. ]; [0. ]]. where we have used the :meth:`.Qobj.unit` method to again normalize the state. Operating with the number function again:. .. testcode:: [states]. print(n * ket). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0. ]; [0.70710678]; [0. ]; [0. ]; [0. ]]. We can also create coherent states and squeezed states by applying the :func:`.displace` and :func:`.squeeze` functions to the vacuum state:. .. testcode:: [states]. vac = basis(5, 0). d = displace(5, 1j). s = squeeze(5, np.complex(0.25, 0.25)). print(d * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[ 0.60655682+0.j ]; [ 0. +0.60628133j]; [-0.4303874 +0.j ]; [ 0. -0.24104351j]; [ 0.14552147+0.j ]]. .. testcode:: [states]. print(d * s * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[ 0.65893786+0.08139381j]; [ 0.10779462+0.51579735j]; [-0.37567217-0.0132685",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:6674,Testability,test,testoutput,6674,". Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[0. 0. 0. 0. 0.]; [0. 1. 0. 0. 0.]; [0. 0. 2. 0. 0.]; [0. 0. 0. 3. 0.]; [0. 0. 0. 0. 4.]]. Therefore, instead of ``c * a * (c ** 2 * vac).unit()`` we have:. .. testcode:: [states]. print(n * ket). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [0.]; [2.]; [0.]; [0.]]. We can also create superpositions of states:. .. testcode:: [states]. ket = (basis(5, 0) + basis(5, 1)).unit(). print(ket). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.70710678]; [0.70710678]; [0. ]; [0. ]; [0. ]]. where we have used the :meth:`.Qobj.unit` method to again normalize the state. Operating with the number function again:. .. testcode:: [states]. print(n * ket). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0. ]; [0.70710678]; [0. ]; [0. ]; [0. ]]. We can also create coherent states and squeezed states by applying the :func:`.displace` and :func:`.squeeze` functions to the vacuum state:. .. testcode:: [states]. vac = basis(5, 0). d = displace(5, 1j). s = squeeze(5, np.complex(0.25, 0.25)). print(d * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[ 0.60655682+0.j ]; [ 0. +0.60628133j]; [-0.4303874 +0.j ]; [ 0. -0.24104351j]; [ 0.14552147+0.j ]]. .. testcode:: [states]. print(d * s * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[ 0.65893786+0.08139381j]; [ 0.10779462+0.51579735j]; [-0.37567217-0.01326853j]; [-0.02688063-0.23828775j]; [ 0.26352814+0.11512178j]]. Of course,",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:6995,Testability,test,testcode,6995,". .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [0.]; [2.]; [0.]; [0.]]. We can also create superpositions of states:. .. testcode:: [states]. ket = (basis(5, 0) + basis(5, 1)).unit(). print(ket). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.70710678]; [0.70710678]; [0. ]; [0. ]; [0. ]]. where we have used the :meth:`.Qobj.unit` method to again normalize the state. Operating with the number function again:. .. testcode:: [states]. print(n * ket). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0. ]; [0.70710678]; [0. ]; [0. ]; [0. ]]. We can also create coherent states and squeezed states by applying the :func:`.displace` and :func:`.squeeze` functions to the vacuum state:. .. testcode:: [states]. vac = basis(5, 0). d = displace(5, 1j). s = squeeze(5, np.complex(0.25, 0.25)). print(d * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[ 0.60655682+0.j ]; [ 0. +0.60628133j]; [-0.4303874 +0.j ]; [ 0. -0.24104351j]; [ 0.14552147+0.j ]]. .. testcode:: [states]. print(d * s * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[ 0.65893786+0.08139381j]; [ 0.10779462+0.51579735j]; [-0.37567217-0.01326853j]; [-0.02688063-0.23828775j]; [ 0.26352814+0.11512178j]]. Of course, displacing the vacuum gives a coherent state, which can also be generated using the built in :func:`.coherent` function. .. _states-dm:. Density matrices; =================. One of the main purpose of QuTiP is to explore the dynamics of **open** quantum systems, where the most general state of a system",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:7128,Testability,test,testoutput,7128,"2.]; [0.]; [0.]]. We can also create superpositions of states:. .. testcode:: [states]. ket = (basis(5, 0) + basis(5, 1)).unit(). print(ket). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.70710678]; [0.70710678]; [0. ]; [0. ]; [0. ]]. where we have used the :meth:`.Qobj.unit` method to again normalize the state. Operating with the number function again:. .. testcode:: [states]. print(n * ket). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0. ]; [0.70710678]; [0. ]; [0. ]; [0. ]]. We can also create coherent states and squeezed states by applying the :func:`.displace` and :func:`.squeeze` functions to the vacuum state:. .. testcode:: [states]. vac = basis(5, 0). d = displace(5, 1j). s = squeeze(5, np.complex(0.25, 0.25)). print(d * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[ 0.60655682+0.j ]; [ 0. +0.60628133j]; [-0.4303874 +0.j ]; [ 0. -0.24104351j]; [ 0.14552147+0.j ]]. .. testcode:: [states]. print(d * s * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[ 0.65893786+0.08139381j]; [ 0.10779462+0.51579735j]; [-0.37567217-0.01326853j]; [-0.02688063-0.23828775j]; [ 0.26352814+0.11512178j]]. Of course, displacing the vacuum gives a coherent state, which can also be generated using the built in :func:`.coherent` function. .. _states-dm:. Density matrices; =================. One of the main purpose of QuTiP is to explore the dynamics of **open** quantum systems, where the most general state of a system is no longer a state vector, but rather a density matrix. Since operations on density matrices operate identically to those of vectors, we will just ",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:7365,Testability,test,testcode,7365,"um object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.70710678]; [0.70710678]; [0. ]; [0. ]; [0. ]]. where we have used the :meth:`.Qobj.unit` method to again normalize the state. Operating with the number function again:. .. testcode:: [states]. print(n * ket). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0. ]; [0.70710678]; [0. ]; [0. ]; [0. ]]. We can also create coherent states and squeezed states by applying the :func:`.displace` and :func:`.squeeze` functions to the vacuum state:. .. testcode:: [states]. vac = basis(5, 0). d = displace(5, 1j). s = squeeze(5, np.complex(0.25, 0.25)). print(d * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[ 0.60655682+0.j ]; [ 0. +0.60628133j]; [-0.4303874 +0.j ]; [ 0. -0.24104351j]; [ 0.14552147+0.j ]]. .. testcode:: [states]. print(d * s * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[ 0.65893786+0.08139381j]; [ 0.10779462+0.51579735j]; [-0.37567217-0.01326853j]; [-0.02688063-0.23828775j]; [ 0.26352814+0.11512178j]]. Of course, displacing the vacuum gives a coherent state, which can also be generated using the built in :func:`.coherent` function. .. _states-dm:. Density matrices; =================. One of the main purpose of QuTiP is to explore the dynamics of **open** quantum systems, where the most general state of a system is no longer a state vector, but rather a density matrix. Since operations on density matrices operate identically to those of vectors, we will just briefly highlight creating and using these structures. The simplest density matrix is created by forming the outer-product :math:`\left|\psi\right>\left<\psi\right|` of a ket vector:. .. testcode:: [states]. ket = basis(",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:7422,Testability,test,testoutput,7422,"70710678]; [0.70710678]; [0. ]; [0. ]; [0. ]]. where we have used the :meth:`.Qobj.unit` method to again normalize the state. Operating with the number function again:. .. testcode:: [states]. print(n * ket). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0. ]; [0.70710678]; [0. ]; [0. ]; [0. ]]. We can also create coherent states and squeezed states by applying the :func:`.displace` and :func:`.squeeze` functions to the vacuum state:. .. testcode:: [states]. vac = basis(5, 0). d = displace(5, 1j). s = squeeze(5, np.complex(0.25, 0.25)). print(d * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[ 0.60655682+0.j ]; [ 0. +0.60628133j]; [-0.4303874 +0.j ]; [ 0. -0.24104351j]; [ 0.14552147+0.j ]]. .. testcode:: [states]. print(d * s * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[ 0.65893786+0.08139381j]; [ 0.10779462+0.51579735j]; [-0.37567217-0.01326853j]; [-0.02688063-0.23828775j]; [ 0.26352814+0.11512178j]]. Of course, displacing the vacuum gives a coherent state, which can also be generated using the built in :func:`.coherent` function. .. _states-dm:. Density matrices; =================. One of the main purpose of QuTiP is to explore the dynamics of **open** quantum systems, where the most general state of a system is no longer a state vector, but rather a density matrix. Since operations on density matrices operate identically to those of vectors, we will just briefly highlight creating and using these structures. The simplest density matrix is created by forming the outer-product :math:`\left|\psi\right>\left<\psi\right|` of a ket vector:. .. testcode:: [states]. ket = basis(5, 2). print(ket * ket.dag()). **Output**:. .. testoutput:: [states]; :opt",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:8342,Testability,test,testcode,8342,"47+0.j ]]. .. testcode:: [states]. print(d * s * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[ 0.65893786+0.08139381j]; [ 0.10779462+0.51579735j]; [-0.37567217-0.01326853j]; [-0.02688063-0.23828775j]; [ 0.26352814+0.11512178j]]. Of course, displacing the vacuum gives a coherent state, which can also be generated using the built in :func:`.coherent` function. .. _states-dm:. Density matrices; =================. One of the main purpose of QuTiP is to explore the dynamics of **open** quantum systems, where the most general state of a system is no longer a state vector, but rather a density matrix. Since operations on density matrices operate identically to those of vectors, we will just briefly highlight creating and using these structures. The simplest density matrix is created by forming the outer-product :math:`\left|\psi\right>\left<\psi\right|` of a ket vector:. .. testcode:: [states]. ket = basis(5, 2). print(ket * ket.dag()). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[0. 0. 0. 0. 0.]; [0. 0. 0. 0. 0.]; [0. 0. 1. 0. 0.]; [0. 0. 0. 0. 0.]; [0. 0. 0. 0. 0.]]. A similar task can also be accomplished via the :func:`.fock_dm` or :func:`.ket2dm` functions:. .. testcode:: [states]. print(fock_dm(5, 2)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[0. 0. 0. 0. 0.]; [0. 0. 0. 0. 0.]; [0. 0. 1. 0. 0.]; [0. 0. 0. 0. 0.]; [0. 0. 0. 0. 0.]]. .. testcode:: [states]. print(ket2dm(ket)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[0. 0. 0. 0. 0.]; [0. 0. 0. 0. 0.]; [0. 0. 1. 0. 0.]; [0. 0. 0. 0. 0.]; [0. 0. 0. 0",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:8422,Testability,test,testoutput,8422,"ions: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[ 0.65893786+0.08139381j]; [ 0.10779462+0.51579735j]; [-0.37567217-0.01326853j]; [-0.02688063-0.23828775j]; [ 0.26352814+0.11512178j]]. Of course, displacing the vacuum gives a coherent state, which can also be generated using the built in :func:`.coherent` function. .. _states-dm:. Density matrices; =================. One of the main purpose of QuTiP is to explore the dynamics of **open** quantum systems, where the most general state of a system is no longer a state vector, but rather a density matrix. Since operations on density matrices operate identically to those of vectors, we will just briefly highlight creating and using these structures. The simplest density matrix is created by forming the outer-product :math:`\left|\psi\right>\left<\psi\right|` of a ket vector:. .. testcode:: [states]. ket = basis(5, 2). print(ket * ket.dag()). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[0. 0. 0. 0. 0.]; [0. 0. 0. 0. 0.]; [0. 0. 1. 0. 0.]; [0. 0. 0. 0. 0.]; [0. 0. 0. 0. 0.]]. A similar task can also be accomplished via the :func:`.fock_dm` or :func:`.ket2dm` functions:. .. testcode:: [states]. print(fock_dm(5, 2)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[0. 0. 0. 0. 0.]; [0. 0. 0. 0. 0.]; [0. 0. 1. 0. 0.]; [0. 0. 0. 0. 0.]; [0. 0. 0. 0. 0.]]. .. testcode:: [states]. print(ket2dm(ket)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[0. 0. 0. 0. 0.]; [0. 0. 0. 0. 0.]; [0. 0. 1. 0. 0.]; [0. 0. 0. 0. 0.]; [0. 0. 0. 0. 0.]]. If we want to create a density matrix with equal classical probability of being found in ",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:8761,Testability,test,testcode,8761,"rated using the built in :func:`.coherent` function. .. _states-dm:. Density matrices; =================. One of the main purpose of QuTiP is to explore the dynamics of **open** quantum systems, where the most general state of a system is no longer a state vector, but rather a density matrix. Since operations on density matrices operate identically to those of vectors, we will just briefly highlight creating and using these structures. The simplest density matrix is created by forming the outer-product :math:`\left|\psi\right>\left<\psi\right|` of a ket vector:. .. testcode:: [states]. ket = basis(5, 2). print(ket * ket.dag()). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[0. 0. 0. 0. 0.]; [0. 0. 0. 0. 0.]; [0. 0. 1. 0. 0.]; [0. 0. 0. 0. 0.]; [0. 0. 0. 0. 0.]]. A similar task can also be accomplished via the :func:`.fock_dm` or :func:`.ket2dm` functions:. .. testcode:: [states]. print(fock_dm(5, 2)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[0. 0. 0. 0. 0.]; [0. 0. 0. 0. 0.]; [0. 0. 1. 0. 0.]; [0. 0. 0. 0. 0.]; [0. 0. 0. 0. 0.]]. .. testcode:: [states]. print(ket2dm(ket)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[0. 0. 0. 0. 0.]; [0. 0. 0. 0. 0.]; [0. 0. 1. 0. 0.]; [0. 0. 0. 0. 0.]; [0. 0. 0. 0. 0.]]. If we want to create a density matrix with equal classical probability of being found in the :math:`\left|2\right>` or :math:`\left|4\right>` number states we can do the following:. .. testcode:: [states]. print(0.5 * ket2dm(basis(5, 4)) + 0.5 * ket2dm(basis(5, 2))). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm ",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:8820,Testability,test,testoutput,8820,"matrices; =================. One of the main purpose of QuTiP is to explore the dynamics of **open** quantum systems, where the most general state of a system is no longer a state vector, but rather a density matrix. Since operations on density matrices operate identically to those of vectors, we will just briefly highlight creating and using these structures. The simplest density matrix is created by forming the outer-product :math:`\left|\psi\right>\left<\psi\right|` of a ket vector:. .. testcode:: [states]. ket = basis(5, 2). print(ket * ket.dag()). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[0. 0. 0. 0. 0.]; [0. 0. 0. 0. 0.]; [0. 0. 1. 0. 0.]; [0. 0. 0. 0. 0.]; [0. 0. 0. 0. 0.]]. A similar task can also be accomplished via the :func:`.fock_dm` or :func:`.ket2dm` functions:. .. testcode:: [states]. print(fock_dm(5, 2)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[0. 0. 0. 0. 0.]; [0. 0. 0. 0. 0.]; [0. 0. 1. 0. 0.]; [0. 0. 0. 0. 0.]; [0. 0. 0. 0. 0.]]. .. testcode:: [states]. print(ket2dm(ket)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[0. 0. 0. 0. 0.]; [0. 0. 0. 0. 0.]; [0. 0. 1. 0. 0.]; [0. 0. 0. 0. 0.]; [0. 0. 0. 0. 0.]]. If we want to create a density matrix with equal classical probability of being found in the :math:`\left|2\right>` or :math:`\left|4\right>` number states we can do the following:. .. testcode:: [states]. print(0.5 * ket2dm(basis(5, 4)) + 0.5 * ket2dm(basis(5, 2))). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[0. 0. 0. 0. 0. ]; [0. 0. 0. 0. 0. ]; [0. 0. 0.5 0. 0.",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:9063,Testability,test,testcode,9063,"erations on density matrices operate identically to those of vectors, we will just briefly highlight creating and using these structures. The simplest density matrix is created by forming the outer-product :math:`\left|\psi\right>\left<\psi\right|` of a ket vector:. .. testcode:: [states]. ket = basis(5, 2). print(ket * ket.dag()). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[0. 0. 0. 0. 0.]; [0. 0. 0. 0. 0.]; [0. 0. 1. 0. 0.]; [0. 0. 0. 0. 0.]; [0. 0. 0. 0. 0.]]. A similar task can also be accomplished via the :func:`.fock_dm` or :func:`.ket2dm` functions:. .. testcode:: [states]. print(fock_dm(5, 2)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[0. 0. 0. 0. 0.]; [0. 0. 0. 0. 0.]; [0. 0. 1. 0. 0.]; [0. 0. 0. 0. 0.]; [0. 0. 0. 0. 0.]]. .. testcode:: [states]. print(ket2dm(ket)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[0. 0. 0. 0. 0.]; [0. 0. 0. 0. 0.]; [0. 0. 1. 0. 0.]; [0. 0. 0. 0. 0.]; [0. 0. 0. 0. 0.]]. If we want to create a density matrix with equal classical probability of being found in the :math:`\left|2\right>` or :math:`\left|4\right>` number states we can do the following:. .. testcode:: [states]. print(0.5 * ket2dm(basis(5, 4)) + 0.5 * ket2dm(basis(5, 2))). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[0. 0. 0. 0. 0. ]; [0. 0. 0. 0. 0. ]; [0. 0. 0.5 0. 0. ]; [0. 0. 0. 0. 0. ]; [0. 0. 0. 0. 0.5]]. or use ``0.5 * fock_dm(5, 2) + 0.5 * fock_dm(5, 4)``.; There are also several other built-in functions for creating predefined density matrices, for example :func:`.coherent_dm` and :",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:9120,Testability,test,testoutput,9120,"ll just briefly highlight creating and using these structures. The simplest density matrix is created by forming the outer-product :math:`\left|\psi\right>\left<\psi\right|` of a ket vector:. .. testcode:: [states]. ket = basis(5, 2). print(ket * ket.dag()). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[0. 0. 0. 0. 0.]; [0. 0. 0. 0. 0.]; [0. 0. 1. 0. 0.]; [0. 0. 0. 0. 0.]; [0. 0. 0. 0. 0.]]. A similar task can also be accomplished via the :func:`.fock_dm` or :func:`.ket2dm` functions:. .. testcode:: [states]. print(fock_dm(5, 2)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[0. 0. 0. 0. 0.]; [0. 0. 0. 0. 0.]; [0. 0. 1. 0. 0.]; [0. 0. 0. 0. 0.]; [0. 0. 0. 0. 0.]]. .. testcode:: [states]. print(ket2dm(ket)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[0. 0. 0. 0. 0.]; [0. 0. 0. 0. 0.]; [0. 0. 1. 0. 0.]; [0. 0. 0. 0. 0.]; [0. 0. 0. 0. 0.]]. If we want to create a density matrix with equal classical probability of being found in the :math:`\left|2\right>` or :math:`\left|4\right>` number states we can do the following:. .. testcode:: [states]. print(0.5 * ket2dm(basis(5, 4)) + 0.5 * ket2dm(basis(5, 2))). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[0. 0. 0. 0. 0. ]; [0. 0. 0. 0. 0. ]; [0. 0. 0.5 0. 0. ]; [0. 0. 0. 0. 0. ]; [0. 0. 0. 0. 0.5]]. or use ``0.5 * fock_dm(5, 2) + 0.5 * fock_dm(5, 4)``.; There are also several other built-in functions for creating predefined density matrices, for example :func:`.coherent_dm` and :func:`.thermal_dm` which create coherent state and thermal state density m",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:9545,Testability,test,testcode,9545,"e; Qobj data =; [[0. 0. 0. 0. 0.]; [0. 0. 0. 0. 0.]; [0. 0. 1. 0. 0.]; [0. 0. 0. 0. 0.]; [0. 0. 0. 0. 0.]]. A similar task can also be accomplished via the :func:`.fock_dm` or :func:`.ket2dm` functions:. .. testcode:: [states]. print(fock_dm(5, 2)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[0. 0. 0. 0. 0.]; [0. 0. 0. 0. 0.]; [0. 0. 1. 0. 0.]; [0. 0. 0. 0. 0.]; [0. 0. 0. 0. 0.]]. .. testcode:: [states]. print(ket2dm(ket)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[0. 0. 0. 0. 0.]; [0. 0. 0. 0. 0.]; [0. 0. 1. 0. 0.]; [0. 0. 0. 0. 0.]; [0. 0. 0. 0. 0.]]. If we want to create a density matrix with equal classical probability of being found in the :math:`\left|2\right>` or :math:`\left|4\right>` number states we can do the following:. .. testcode:: [states]. print(0.5 * ket2dm(basis(5, 4)) + 0.5 * ket2dm(basis(5, 2))). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[0. 0. 0. 0. 0. ]; [0. 0. 0. 0. 0. ]; [0. 0. 0.5 0. 0. ]; [0. 0. 0. 0. 0. ]; [0. 0. 0. 0. 0.5]]. or use ``0.5 * fock_dm(5, 2) + 0.5 * fock_dm(5, 4)``.; There are also several other built-in functions for creating predefined density matrices, for example :func:`.coherent_dm` and :func:`.thermal_dm` which create coherent state and thermal state density matrices, respectively. .. testcode:: [states]. print(coherent_dm(5, 1.25)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[0.20980701 0.26141096 0.23509686 0.15572585 0.13390765]; [0.26141096 0.32570738 0.29292109 0.19402805 0.16684347]; [0.23509686 0.29292109 0.26343512 0.17449684 0.1500",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:9644,Testability,test,testoutput,9644," task can also be accomplished via the :func:`.fock_dm` or :func:`.ket2dm` functions:. .. testcode:: [states]. print(fock_dm(5, 2)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[0. 0. 0. 0. 0.]; [0. 0. 0. 0. 0.]; [0. 0. 1. 0. 0.]; [0. 0. 0. 0. 0.]; [0. 0. 0. 0. 0.]]. .. testcode:: [states]. print(ket2dm(ket)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[0. 0. 0. 0. 0.]; [0. 0. 0. 0. 0.]; [0. 0. 1. 0. 0.]; [0. 0. 0. 0. 0.]; [0. 0. 0. 0. 0.]]. If we want to create a density matrix with equal classical probability of being found in the :math:`\left|2\right>` or :math:`\left|4\right>` number states we can do the following:. .. testcode:: [states]. print(0.5 * ket2dm(basis(5, 4)) + 0.5 * ket2dm(basis(5, 2))). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[0. 0. 0. 0. 0. ]; [0. 0. 0. 0. 0. ]; [0. 0. 0.5 0. 0. ]; [0. 0. 0. 0. 0. ]; [0. 0. 0. 0. 0.5]]. or use ``0.5 * fock_dm(5, 2) + 0.5 * fock_dm(5, 4)``.; There are also several other built-in functions for creating predefined density matrices, for example :func:`.coherent_dm` and :func:`.thermal_dm` which create coherent state and thermal state density matrices, respectively. .. testcode:: [states]. print(coherent_dm(5, 1.25)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[0.20980701 0.26141096 0.23509686 0.15572585 0.13390765]; [0.26141096 0.32570738 0.29292109 0.19402805 0.16684347]; [0.23509686 0.29292109 0.26343512 0.17449684 0.1500487 ]; [0.15572585 0.19402805 0.17449684 0.11558499 0.09939079]; [0.13390765 0.16684347 0.1500487 0.09939079 0.08546",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:10173,Testability,test,testcode,10173,"m object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[0. 0. 0. 0. 0.]; [0. 0. 0. 0. 0.]; [0. 0. 1. 0. 0.]; [0. 0. 0. 0. 0.]; [0. 0. 0. 0. 0.]]. If we want to create a density matrix with equal classical probability of being found in the :math:`\left|2\right>` or :math:`\left|4\right>` number states we can do the following:. .. testcode:: [states]. print(0.5 * ket2dm(basis(5, 4)) + 0.5 * ket2dm(basis(5, 2))). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[0. 0. 0. 0. 0. ]; [0. 0. 0. 0. 0. ]; [0. 0. 0.5 0. 0. ]; [0. 0. 0. 0. 0. ]; [0. 0. 0. 0. 0.5]]. or use ``0.5 * fock_dm(5, 2) + 0.5 * fock_dm(5, 4)``.; There are also several other built-in functions for creating predefined density matrices, for example :func:`.coherent_dm` and :func:`.thermal_dm` which create coherent state and thermal state density matrices, respectively. .. testcode:: [states]. print(coherent_dm(5, 1.25)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[0.20980701 0.26141096 0.23509686 0.15572585 0.13390765]; [0.26141096 0.32570738 0.29292109 0.19402805 0.16684347]; [0.23509686 0.29292109 0.26343512 0.17449684 0.1500487 ]; [0.15572585 0.19402805 0.17449684 0.11558499 0.09939079]; [0.13390765 0.16684347 0.1500487 0.09939079 0.0854655 ]]. .. testcode:: [states]. print(thermal_dm(5, 1.25)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[0.46927974 0. 0. 0. 0. ]; [0. 0.26071096 0. 0. 0. ]; [0. 0. 0.14483942 0. 0. ]; [0. 0. 0. 0.08046635 0. ]; [0. 0. 0. 0. 0.04470353]]. QuTiP also provides a set of distance metrics for determining how close two density matrix distributions are to each other.; Included are the trace dista",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:10239,Testability,test,testoutput,10239,"; [[0. 0. 0. 0. 0.]; [0. 0. 0. 0. 0.]; [0. 0. 1. 0. 0.]; [0. 0. 0. 0. 0.]; [0. 0. 0. 0. 0.]]. If we want to create a density matrix with equal classical probability of being found in the :math:`\left|2\right>` or :math:`\left|4\right>` number states we can do the following:. .. testcode:: [states]. print(0.5 * ket2dm(basis(5, 4)) + 0.5 * ket2dm(basis(5, 2))). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[0. 0. 0. 0. 0. ]; [0. 0. 0. 0. 0. ]; [0. 0. 0.5 0. 0. ]; [0. 0. 0. 0. 0. ]; [0. 0. 0. 0. 0.5]]. or use ``0.5 * fock_dm(5, 2) + 0.5 * fock_dm(5, 4)``.; There are also several other built-in functions for creating predefined density matrices, for example :func:`.coherent_dm` and :func:`.thermal_dm` which create coherent state and thermal state density matrices, respectively. .. testcode:: [states]. print(coherent_dm(5, 1.25)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[0.20980701 0.26141096 0.23509686 0.15572585 0.13390765]; [0.26141096 0.32570738 0.29292109 0.19402805 0.16684347]; [0.23509686 0.29292109 0.26343512 0.17449684 0.1500487 ]; [0.15572585 0.19402805 0.17449684 0.11558499 0.09939079]; [0.13390765 0.16684347 0.1500487 0.09939079 0.0854655 ]]. .. testcode:: [states]. print(thermal_dm(5, 1.25)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[0.46927974 0. 0. 0. 0. ]; [0. 0.26071096 0. 0. 0. ]; [0. 0. 0.14483942 0. 0. ]; [0. 0. 0. 0.08046635 0. ]; [0. 0. 0. 0. 0.04470353]]. QuTiP also provides a set of distance metrics for determining how close two density matrix distributions are to each other.; Included are the trace distance :func:`.tracedist`, fidelity :func:`.fidelity`, Hilbert-Schmidt distance :func:",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:10681,Testability,test,testcode,10681,"ITESPACE. Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[0. 0. 0. 0. 0. ]; [0. 0. 0. 0. 0. ]; [0. 0. 0.5 0. 0. ]; [0. 0. 0. 0. 0. ]; [0. 0. 0. 0. 0.5]]. or use ``0.5 * fock_dm(5, 2) + 0.5 * fock_dm(5, 4)``.; There are also several other built-in functions for creating predefined density matrices, for example :func:`.coherent_dm` and :func:`.thermal_dm` which create coherent state and thermal state density matrices, respectively. .. testcode:: [states]. print(coherent_dm(5, 1.25)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[0.20980701 0.26141096 0.23509686 0.15572585 0.13390765]; [0.26141096 0.32570738 0.29292109 0.19402805 0.16684347]; [0.23509686 0.29292109 0.26343512 0.17449684 0.1500487 ]; [0.15572585 0.19402805 0.17449684 0.11558499 0.09939079]; [0.13390765 0.16684347 0.1500487 0.09939079 0.0854655 ]]. .. testcode:: [states]. print(thermal_dm(5, 1.25)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[0.46927974 0. 0. 0. 0. ]; [0. 0.26071096 0. 0. 0. ]; [0. 0. 0.14483942 0. 0. ]; [0. 0. 0. 0.08046635 0. ]; [0. 0. 0. 0. 0.04470353]]. QuTiP also provides a set of distance metrics for determining how close two density matrix distributions are to each other.; Included are the trace distance :func:`.tracedist`, fidelity :func:`.fidelity`, Hilbert-Schmidt distance :func:`.hilbert_dist`, Bures distance :func:`.bures_dist`, Bures angle :func:`.bures_angle`, and quantum Hellinger distance :func:`.hellinger_dist`. .. testcode:: [states]. x = coherent_dm(5, 1.25). y = coherent_dm(5, np.complex(0, 1.25)) # <-- note the 'j'. z = thermal_dm(5, 0.125). np.testing.assert_almost_equal(fidelity(x, x), 1). np.testing.assert_almost_equal(hellinger_dist(x, y), 1.3819080728932833). We also know that for",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:10746,Testability,test,testoutput,10746,"True; Qobj data =; [[0. 0. 0. 0. 0. ]; [0. 0. 0. 0. 0. ]; [0. 0. 0.5 0. 0. ]; [0. 0. 0. 0. 0. ]; [0. 0. 0. 0. 0.5]]. or use ``0.5 * fock_dm(5, 2) + 0.5 * fock_dm(5, 4)``.; There are also several other built-in functions for creating predefined density matrices, for example :func:`.coherent_dm` and :func:`.thermal_dm` which create coherent state and thermal state density matrices, respectively. .. testcode:: [states]. print(coherent_dm(5, 1.25)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[0.20980701 0.26141096 0.23509686 0.15572585 0.13390765]; [0.26141096 0.32570738 0.29292109 0.19402805 0.16684347]; [0.23509686 0.29292109 0.26343512 0.17449684 0.1500487 ]; [0.15572585 0.19402805 0.17449684 0.11558499 0.09939079]; [0.13390765 0.16684347 0.1500487 0.09939079 0.0854655 ]]. .. testcode:: [states]. print(thermal_dm(5, 1.25)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[0.46927974 0. 0. 0. 0. ]; [0. 0.26071096 0. 0. 0. ]; [0. 0. 0.14483942 0. 0. ]; [0. 0. 0. 0.08046635 0. ]; [0. 0. 0. 0. 0.04470353]]. QuTiP also provides a set of distance metrics for determining how close two density matrix distributions are to each other.; Included are the trace distance :func:`.tracedist`, fidelity :func:`.fidelity`, Hilbert-Schmidt distance :func:`.hilbert_dist`, Bures distance :func:`.bures_dist`, Bures angle :func:`.bures_angle`, and quantum Hellinger distance :func:`.hellinger_dist`. .. testcode:: [states]. x = coherent_dm(5, 1.25). y = coherent_dm(5, np.complex(0, 1.25)) # <-- note the 'j'. z = thermal_dm(5, 0.125). np.testing.assert_almost_equal(fidelity(x, x), 1). np.testing.assert_almost_equal(hellinger_dist(x, y), 1.3819080728932833). We also know that for two pure states, the trace distance (T) and the fidelity (F) are related by :math",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:11412,Testability,test,testcode,11412," 0.15572585 0.13390765]; [0.26141096 0.32570738 0.29292109 0.19402805 0.16684347]; [0.23509686 0.29292109 0.26343512 0.17449684 0.1500487 ]; [0.15572585 0.19402805 0.17449684 0.11558499 0.09939079]; [0.13390765 0.16684347 0.1500487 0.09939079 0.0854655 ]]. .. testcode:: [states]. print(thermal_dm(5, 1.25)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[0.46927974 0. 0. 0. 0. ]; [0. 0.26071096 0. 0. 0. ]; [0. 0. 0.14483942 0. 0. ]; [0. 0. 0. 0.08046635 0. ]; [0. 0. 0. 0. 0.04470353]]. QuTiP also provides a set of distance metrics for determining how close two density matrix distributions are to each other.; Included are the trace distance :func:`.tracedist`, fidelity :func:`.fidelity`, Hilbert-Schmidt distance :func:`.hilbert_dist`, Bures distance :func:`.bures_dist`, Bures angle :func:`.bures_angle`, and quantum Hellinger distance :func:`.hellinger_dist`. .. testcode:: [states]. x = coherent_dm(5, 1.25). y = coherent_dm(5, np.complex(0, 1.25)) # <-- note the 'j'. z = thermal_dm(5, 0.125). np.testing.assert_almost_equal(fidelity(x, x), 1). np.testing.assert_almost_equal(hellinger_dist(x, y), 1.3819080728932833). We also know that for two pure states, the trace distance (T) and the fidelity (F) are related by :math:`T = \sqrt{1 - F^{2}}`, while the quantum Hellinger distance (QHE) between two pure states :math:`\left|\psi\right>` and :math:`\left|\phi\right>` is given by :math:`QHE = \sqrt{2 - 2\left|\left<\psi | \phi\right>\right|^2}`. .. testcode:: [states]. np.testing.assert_almost_equal(tracedist(y, x), np.sqrt(1 - fidelity(y, x) ** 2)). For a pure state and a mixed state, :math:`1 - F^{2} \le T` which can also be verified:. .. testcode:: [states]. assert 1 - fidelity(x, z) ** 2 < tracedist(x, z). .. _states-qubit:. Qubit (two-level) systems; =========================. Having spent a fair amount of time on basis states that represent harmonic osci",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:11548,Testability,test,testing,11548,"500487 ]; [0.15572585 0.19402805 0.17449684 0.11558499 0.09939079]; [0.13390765 0.16684347 0.1500487 0.09939079 0.0854655 ]]. .. testcode:: [states]. print(thermal_dm(5, 1.25)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[0.46927974 0. 0. 0. 0. ]; [0. 0.26071096 0. 0. 0. ]; [0. 0. 0.14483942 0. 0. ]; [0. 0. 0. 0.08046635 0. ]; [0. 0. 0. 0. 0.04470353]]. QuTiP also provides a set of distance metrics for determining how close two density matrix distributions are to each other.; Included are the trace distance :func:`.tracedist`, fidelity :func:`.fidelity`, Hilbert-Schmidt distance :func:`.hilbert_dist`, Bures distance :func:`.bures_dist`, Bures angle :func:`.bures_angle`, and quantum Hellinger distance :func:`.hellinger_dist`. .. testcode:: [states]. x = coherent_dm(5, 1.25). y = coherent_dm(5, np.complex(0, 1.25)) # <-- note the 'j'. z = thermal_dm(5, 0.125). np.testing.assert_almost_equal(fidelity(x, x), 1). np.testing.assert_almost_equal(hellinger_dist(x, y), 1.3819080728932833). We also know that for two pure states, the trace distance (T) and the fidelity (F) are related by :math:`T = \sqrt{1 - F^{2}}`, while the quantum Hellinger distance (QHE) between two pure states :math:`\left|\psi\right>` and :math:`\left|\phi\right>` is given by :math:`QHE = \sqrt{2 - 2\left|\left<\psi | \phi\right>\right|^2}`. .. testcode:: [states]. np.testing.assert_almost_equal(tracedist(y, x), np.sqrt(1 - fidelity(y, x) ** 2)). For a pure state and a mixed state, :math:`1 - F^{2} \le T` which can also be verified:. .. testcode:: [states]. assert 1 - fidelity(x, z) ** 2 < tracedist(x, z). .. _states-qubit:. Qubit (two-level) systems; =========================. Having spent a fair amount of time on basis states that represent harmonic oscillator states, we now move on to qubit, or two-level quantum systems (for example a spin-1/2). To create a state vector correspond",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:11599,Testability,test,testing,11599,"499 0.09939079]; [0.13390765 0.16684347 0.1500487 0.09939079 0.0854655 ]]. .. testcode:: [states]. print(thermal_dm(5, 1.25)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[0.46927974 0. 0. 0. 0. ]; [0. 0.26071096 0. 0. 0. ]; [0. 0. 0.14483942 0. 0. ]; [0. 0. 0. 0.08046635 0. ]; [0. 0. 0. 0. 0.04470353]]. QuTiP also provides a set of distance metrics for determining how close two density matrix distributions are to each other.; Included are the trace distance :func:`.tracedist`, fidelity :func:`.fidelity`, Hilbert-Schmidt distance :func:`.hilbert_dist`, Bures distance :func:`.bures_dist`, Bures angle :func:`.bures_angle`, and quantum Hellinger distance :func:`.hellinger_dist`. .. testcode:: [states]. x = coherent_dm(5, 1.25). y = coherent_dm(5, np.complex(0, 1.25)) # <-- note the 'j'. z = thermal_dm(5, 0.125). np.testing.assert_almost_equal(fidelity(x, x), 1). np.testing.assert_almost_equal(hellinger_dist(x, y), 1.3819080728932833). We also know that for two pure states, the trace distance (T) and the fidelity (F) are related by :math:`T = \sqrt{1 - F^{2}}`, while the quantum Hellinger distance (QHE) between two pure states :math:`\left|\psi\right>` and :math:`\left|\phi\right>` is given by :math:`QHE = \sqrt{2 - 2\left|\left<\psi | \phi\right>\right|^2}`. .. testcode:: [states]. np.testing.assert_almost_equal(tracedist(y, x), np.sqrt(1 - fidelity(y, x) ** 2)). For a pure state and a mixed state, :math:`1 - F^{2} \le T` which can also be verified:. .. testcode:: [states]. assert 1 - fidelity(x, z) ** 2 < tracedist(x, z). .. _states-qubit:. Qubit (two-level) systems; =========================. Having spent a fair amount of time on basis states that represent harmonic oscillator states, we now move on to qubit, or two-level quantum systems (for example a spin-1/2). To create a state vector corresponding to a qubit system, we use the same :func:`.basi",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:12003,Testability,test,testcode,12003," 0. 0.04470353]]. QuTiP also provides a set of distance metrics for determining how close two density matrix distributions are to each other.; Included are the trace distance :func:`.tracedist`, fidelity :func:`.fidelity`, Hilbert-Schmidt distance :func:`.hilbert_dist`, Bures distance :func:`.bures_dist`, Bures angle :func:`.bures_angle`, and quantum Hellinger distance :func:`.hellinger_dist`. .. testcode:: [states]. x = coherent_dm(5, 1.25). y = coherent_dm(5, np.complex(0, 1.25)) # <-- note the 'j'. z = thermal_dm(5, 0.125). np.testing.assert_almost_equal(fidelity(x, x), 1). np.testing.assert_almost_equal(hellinger_dist(x, y), 1.3819080728932833). We also know that for two pure states, the trace distance (T) and the fidelity (F) are related by :math:`T = \sqrt{1 - F^{2}}`, while the quantum Hellinger distance (QHE) between two pure states :math:`\left|\psi\right>` and :math:`\left|\phi\right>` is given by :math:`QHE = \sqrt{2 - 2\left|\left<\psi | \phi\right>\right|^2}`. .. testcode:: [states]. np.testing.assert_almost_equal(tracedist(y, x), np.sqrt(1 - fidelity(y, x) ** 2)). For a pure state and a mixed state, :math:`1 - F^{2} \le T` which can also be verified:. .. testcode:: [states]. assert 1 - fidelity(x, z) ** 2 < tracedist(x, z). .. _states-qubit:. Qubit (two-level) systems; =========================. Having spent a fair amount of time on basis states that represent harmonic oscillator states, we now move on to qubit, or two-level quantum systems (for example a spin-1/2). To create a state vector corresponding to a qubit system, we use the same :func:`.basis`, or :func:`.fock`, function with only two levels:. .. testcode:: [states]. spin = basis(2, 0). Now at this point one may ask how this state is different than that of a harmonic oscillator in the vacuum state truncated to two energy levels?. .. testcode:: [states]. vac = basis(2, 0). At this stage, there is no difference. This should not be surprising as we called the exact same function twice. The differ",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:12027,Testability,test,testing,12027,"uTiP also provides a set of distance metrics for determining how close two density matrix distributions are to each other.; Included are the trace distance :func:`.tracedist`, fidelity :func:`.fidelity`, Hilbert-Schmidt distance :func:`.hilbert_dist`, Bures distance :func:`.bures_dist`, Bures angle :func:`.bures_angle`, and quantum Hellinger distance :func:`.hellinger_dist`. .. testcode:: [states]. x = coherent_dm(5, 1.25). y = coherent_dm(5, np.complex(0, 1.25)) # <-- note the 'j'. z = thermal_dm(5, 0.125). np.testing.assert_almost_equal(fidelity(x, x), 1). np.testing.assert_almost_equal(hellinger_dist(x, y), 1.3819080728932833). We also know that for two pure states, the trace distance (T) and the fidelity (F) are related by :math:`T = \sqrt{1 - F^{2}}`, while the quantum Hellinger distance (QHE) between two pure states :math:`\left|\psi\right>` and :math:`\left|\phi\right>` is given by :math:`QHE = \sqrt{2 - 2\left|\left<\psi | \phi\right>\right|^2}`. .. testcode:: [states]. np.testing.assert_almost_equal(tracedist(y, x), np.sqrt(1 - fidelity(y, x) ** 2)). For a pure state and a mixed state, :math:`1 - F^{2} \le T` which can also be verified:. .. testcode:: [states]. assert 1 - fidelity(x, z) ** 2 < tracedist(x, z). .. _states-qubit:. Qubit (two-level) systems; =========================. Having spent a fair amount of time on basis states that represent harmonic oscillator states, we now move on to qubit, or two-level quantum systems (for example a spin-1/2). To create a state vector corresponding to a qubit system, we use the same :func:`.basis`, or :func:`.fock`, function with only two levels:. .. testcode:: [states]. spin = basis(2, 0). Now at this point one may ask how this state is different than that of a harmonic oscillator in the vacuum state truncated to two energy levels?. .. testcode:: [states]. vac = basis(2, 0). At this stage, there is no difference. This should not be surprising as we called the exact same function twice. The difference between the t",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:12199,Testability,test,testcode,12199,"idelity :func:`.fidelity`, Hilbert-Schmidt distance :func:`.hilbert_dist`, Bures distance :func:`.bures_dist`, Bures angle :func:`.bures_angle`, and quantum Hellinger distance :func:`.hellinger_dist`. .. testcode:: [states]. x = coherent_dm(5, 1.25). y = coherent_dm(5, np.complex(0, 1.25)) # <-- note the 'j'. z = thermal_dm(5, 0.125). np.testing.assert_almost_equal(fidelity(x, x), 1). np.testing.assert_almost_equal(hellinger_dist(x, y), 1.3819080728932833). We also know that for two pure states, the trace distance (T) and the fidelity (F) are related by :math:`T = \sqrt{1 - F^{2}}`, while the quantum Hellinger distance (QHE) between two pure states :math:`\left|\psi\right>` and :math:`\left|\phi\right>` is given by :math:`QHE = \sqrt{2 - 2\left|\left<\psi | \phi\right>\right|^2}`. .. testcode:: [states]. np.testing.assert_almost_equal(tracedist(y, x), np.sqrt(1 - fidelity(y, x) ** 2)). For a pure state and a mixed state, :math:`1 - F^{2} \le T` which can also be verified:. .. testcode:: [states]. assert 1 - fidelity(x, z) ** 2 < tracedist(x, z). .. _states-qubit:. Qubit (two-level) systems; =========================. Having spent a fair amount of time on basis states that represent harmonic oscillator states, we now move on to qubit, or two-level quantum systems (for example a spin-1/2). To create a state vector corresponding to a qubit system, we use the same :func:`.basis`, or :func:`.fock`, function with only two levels:. .. testcode:: [states]. spin = basis(2, 0). Now at this point one may ask how this state is different than that of a harmonic oscillator in the vacuum state truncated to two energy levels?. .. testcode:: [states]. vac = basis(2, 0). At this stage, there is no difference. This should not be surprising as we called the exact same function twice. The difference between the two comes from the action of the spin operators :func:`.sigmax`, :func:`.sigmay`, :func:`.sigmaz`, :func:`.sigmap`, and :func:`.sigmam` on these two-level states. For example, if ",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:12220,Testability,assert,assert,12220,"chmidt distance :func:`.hilbert_dist`, Bures distance :func:`.bures_dist`, Bures angle :func:`.bures_angle`, and quantum Hellinger distance :func:`.hellinger_dist`. .. testcode:: [states]. x = coherent_dm(5, 1.25). y = coherent_dm(5, np.complex(0, 1.25)) # <-- note the 'j'. z = thermal_dm(5, 0.125). np.testing.assert_almost_equal(fidelity(x, x), 1). np.testing.assert_almost_equal(hellinger_dist(x, y), 1.3819080728932833). We also know that for two pure states, the trace distance (T) and the fidelity (F) are related by :math:`T = \sqrt{1 - F^{2}}`, while the quantum Hellinger distance (QHE) between two pure states :math:`\left|\psi\right>` and :math:`\left|\phi\right>` is given by :math:`QHE = \sqrt{2 - 2\left|\left<\psi | \phi\right>\right|^2}`. .. testcode:: [states]. np.testing.assert_almost_equal(tracedist(y, x), np.sqrt(1 - fidelity(y, x) ** 2)). For a pure state and a mixed state, :math:`1 - F^{2} \le T` which can also be verified:. .. testcode:: [states]. assert 1 - fidelity(x, z) ** 2 < tracedist(x, z). .. _states-qubit:. Qubit (two-level) systems; =========================. Having spent a fair amount of time on basis states that represent harmonic oscillator states, we now move on to qubit, or two-level quantum systems (for example a spin-1/2). To create a state vector corresponding to a qubit system, we use the same :func:`.basis`, or :func:`.fock`, function with only two levels:. .. testcode:: [states]. spin = basis(2, 0). Now at this point one may ask how this state is different than that of a harmonic oscillator in the vacuum state truncated to two energy levels?. .. testcode:: [states]. vac = basis(2, 0). At this stage, there is no difference. This should not be surprising as we called the exact same function twice. The difference between the two comes from the action of the spin operators :func:`.sigmax`, :func:`.sigmay`, :func:`.sigmaz`, :func:`.sigmap`, and :func:`.sigmam` on these two-level states. For example, if ``vac`` corresponds to the vacuum s",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:12660,Testability,test,testcode,12660," We also know that for two pure states, the trace distance (T) and the fidelity (F) are related by :math:`T = \sqrt{1 - F^{2}}`, while the quantum Hellinger distance (QHE) between two pure states :math:`\left|\psi\right>` and :math:`\left|\phi\right>` is given by :math:`QHE = \sqrt{2 - 2\left|\left<\psi | \phi\right>\right|^2}`. .. testcode:: [states]. np.testing.assert_almost_equal(tracedist(y, x), np.sqrt(1 - fidelity(y, x) ** 2)). For a pure state and a mixed state, :math:`1 - F^{2} \le T` which can also be verified:. .. testcode:: [states]. assert 1 - fidelity(x, z) ** 2 < tracedist(x, z). .. _states-qubit:. Qubit (two-level) systems; =========================. Having spent a fair amount of time on basis states that represent harmonic oscillator states, we now move on to qubit, or two-level quantum systems (for example a spin-1/2). To create a state vector corresponding to a qubit system, we use the same :func:`.basis`, or :func:`.fock`, function with only two levels:. .. testcode:: [states]. spin = basis(2, 0). Now at this point one may ask how this state is different than that of a harmonic oscillator in the vacuum state truncated to two energy levels?. .. testcode:: [states]. vac = basis(2, 0). At this stage, there is no difference. This should not be surprising as we called the exact same function twice. The difference between the two comes from the action of the spin operators :func:`.sigmax`, :func:`.sigmay`, :func:`.sigmaz`, :func:`.sigmap`, and :func:`.sigmam` on these two-level states. For example, if ``vac`` corresponds to the vacuum state of a harmonic oscillator, then, as we have already seen, we can use the raising operator to get the :math:`\left|1\right>` state:. .. testcode:: [states]. print(vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[1.]; [0.]]. .. testcode:: [states]. c = create(2). print(c * vac). **Output**:. .. testoutput:: [states]",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:12850,Testability,test,testcode,12850,"tates :math:`\left|\psi\right>` and :math:`\left|\phi\right>` is given by :math:`QHE = \sqrt{2 - 2\left|\left<\psi | \phi\right>\right|^2}`. .. testcode:: [states]. np.testing.assert_almost_equal(tracedist(y, x), np.sqrt(1 - fidelity(y, x) ** 2)). For a pure state and a mixed state, :math:`1 - F^{2} \le T` which can also be verified:. .. testcode:: [states]. assert 1 - fidelity(x, z) ** 2 < tracedist(x, z). .. _states-qubit:. Qubit (two-level) systems; =========================. Having spent a fair amount of time on basis states that represent harmonic oscillator states, we now move on to qubit, or two-level quantum systems (for example a spin-1/2). To create a state vector corresponding to a qubit system, we use the same :func:`.basis`, or :func:`.fock`, function with only two levels:. .. testcode:: [states]. spin = basis(2, 0). Now at this point one may ask how this state is different than that of a harmonic oscillator in the vacuum state truncated to two energy levels?. .. testcode:: [states]. vac = basis(2, 0). At this stage, there is no difference. This should not be surprising as we called the exact same function twice. The difference between the two comes from the action of the spin operators :func:`.sigmax`, :func:`.sigmay`, :func:`.sigmaz`, :func:`.sigmap`, and :func:`.sigmam` on these two-level states. For example, if ``vac`` corresponds to the vacuum state of a harmonic oscillator, then, as we have already seen, we can use the raising operator to get the :math:`\left|1\right>` state:. .. testcode:: [states]. print(vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[1.]; [0.]]. .. testcode:: [states]. c = create(2). print(c * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[0.]; [1.]]. For a spin system, the operator analogous to the raising operator",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:13383,Testability,test,testcode,13383,"s that represent harmonic oscillator states, we now move on to qubit, or two-level quantum systems (for example a spin-1/2). To create a state vector corresponding to a qubit system, we use the same :func:`.basis`, or :func:`.fock`, function with only two levels:. .. testcode:: [states]. spin = basis(2, 0). Now at this point one may ask how this state is different than that of a harmonic oscillator in the vacuum state truncated to two energy levels?. .. testcode:: [states]. vac = basis(2, 0). At this stage, there is no difference. This should not be surprising as we called the exact same function twice. The difference between the two comes from the action of the spin operators :func:`.sigmax`, :func:`.sigmay`, :func:`.sigmaz`, :func:`.sigmap`, and :func:`.sigmam` on these two-level states. For example, if ``vac`` corresponds to the vacuum state of a harmonic oscillator, then, as we have already seen, we can use the raising operator to get the :math:`\left|1\right>` state:. .. testcode:: [states]. print(vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[1.]; [0.]]. .. testcode:: [states]. c = create(2). print(c * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[0.]; [1.]]. For a spin system, the operator analogous to the raising operator is the sigma-plus operator :func:`.sigmap`. Operating on the ``spin`` state gives:. .. testcode:: [states]. print(spin). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[1.]; [0.]]. .. testcode:: [states]. print(sigmap() * spin). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[0.]; [0.]]. Now we see the difference! The :func:`.",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:13432,Testability,test,testoutput,13432,"t, or two-level quantum systems (for example a spin-1/2). To create a state vector corresponding to a qubit system, we use the same :func:`.basis`, or :func:`.fock`, function with only two levels:. .. testcode:: [states]. spin = basis(2, 0). Now at this point one may ask how this state is different than that of a harmonic oscillator in the vacuum state truncated to two energy levels?. .. testcode:: [states]. vac = basis(2, 0). At this stage, there is no difference. This should not be surprising as we called the exact same function twice. The difference between the two comes from the action of the spin operators :func:`.sigmax`, :func:`.sigmay`, :func:`.sigmaz`, :func:`.sigmap`, and :func:`.sigmam` on these two-level states. For example, if ``vac`` corresponds to the vacuum state of a harmonic oscillator, then, as we have already seen, we can use the raising operator to get the :math:`\left|1\right>` state:. .. testcode:: [states]. print(vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[1.]; [0.]]. .. testcode:: [states]. c = create(2). print(c * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[0.]; [1.]]. For a spin system, the operator analogous to the raising operator is the sigma-plus operator :func:`.sigmap`. Operating on the ``spin`` state gives:. .. testcode:: [states]. print(spin). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[1.]; [0.]]. .. testcode:: [states]. print(sigmap() * spin). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[0.]; [0.]]. Now we see the difference! The :func:`.sigmap` operator acting on the ``spin`` state returns the zero vec",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:13581,Testability,test,testcode,13581," :func:`.basis`, or :func:`.fock`, function with only two levels:. .. testcode:: [states]. spin = basis(2, 0). Now at this point one may ask how this state is different than that of a harmonic oscillator in the vacuum state truncated to two energy levels?. .. testcode:: [states]. vac = basis(2, 0). At this stage, there is no difference. This should not be surprising as we called the exact same function twice. The difference between the two comes from the action of the spin operators :func:`.sigmax`, :func:`.sigmay`, :func:`.sigmaz`, :func:`.sigmap`, and :func:`.sigmam` on these two-level states. For example, if ``vac`` corresponds to the vacuum state of a harmonic oscillator, then, as we have already seen, we can use the raising operator to get the :math:`\left|1\right>` state:. .. testcode:: [states]. print(vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[1.]; [0.]]. .. testcode:: [states]. c = create(2). print(c * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[0.]; [1.]]. For a spin system, the operator analogous to the raising operator is the sigma-plus operator :func:`.sigmap`. Operating on the ``spin`` state gives:. .. testcode:: [states]. print(spin). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[1.]; [0.]]. .. testcode:: [states]. print(sigmap() * spin). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[0.]; [0.]]. Now we see the difference! The :func:`.sigmap` operator acting on the ``spin`` state returns the zero vector. Why is this? To see what happened, let us use the :func:`.sigmaz` operator:. .. testcode:: [states]. print(sigmaz()). **Output*",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:13649,Testability,test,testoutput,13649,"es]. spin = basis(2, 0). Now at this point one may ask how this state is different than that of a harmonic oscillator in the vacuum state truncated to two energy levels?. .. testcode:: [states]. vac = basis(2, 0). At this stage, there is no difference. This should not be surprising as we called the exact same function twice. The difference between the two comes from the action of the spin operators :func:`.sigmax`, :func:`.sigmay`, :func:`.sigmaz`, :func:`.sigmap`, and :func:`.sigmam` on these two-level states. For example, if ``vac`` corresponds to the vacuum state of a harmonic oscillator, then, as we have already seen, we can use the raising operator to get the :math:`\left|1\right>` state:. .. testcode:: [states]. print(vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[1.]; [0.]]. .. testcode:: [states]. c = create(2). print(c * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[0.]; [1.]]. For a spin system, the operator analogous to the raising operator is the sigma-plus operator :func:`.sigmap`. Operating on the ``spin`` state gives:. .. testcode:: [states]. print(spin). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[1.]; [0.]]. .. testcode:: [states]. print(sigmap() * spin). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[0.]; [0.]]. Now we see the difference! The :func:`.sigmap` operator acting on the ``spin`` state returns the zero vector. Why is this? To see what happened, let us use the :func:`.sigmaz` operator:. .. testcode:: [states]. print(sigmaz()). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims =",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:13948,Testability,test,testcode,13948,"g as we called the exact same function twice. The difference between the two comes from the action of the spin operators :func:`.sigmax`, :func:`.sigmay`, :func:`.sigmaz`, :func:`.sigmap`, and :func:`.sigmam` on these two-level states. For example, if ``vac`` corresponds to the vacuum state of a harmonic oscillator, then, as we have already seen, we can use the raising operator to get the :math:`\left|1\right>` state:. .. testcode:: [states]. print(vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[1.]; [0.]]. .. testcode:: [states]. c = create(2). print(c * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[0.]; [1.]]. For a spin system, the operator analogous to the raising operator is the sigma-plus operator :func:`.sigmap`. Operating on the ``spin`` state gives:. .. testcode:: [states]. print(spin). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[1.]; [0.]]. .. testcode:: [states]. print(sigmap() * spin). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[0.]; [0.]]. Now we see the difference! The :func:`.sigmap` operator acting on the ``spin`` state returns the zero vector. Why is this? To see what happened, let us use the :func:`.sigmaz` operator:. .. testcode:: [states]. print(sigmaz()). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[ 1. 0.]; [ 0. -1.]]. .. testcode:: [states]. print(sigmaz() * spin). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj d",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:13998,Testability,test,testoutput,13998," the two comes from the action of the spin operators :func:`.sigmax`, :func:`.sigmay`, :func:`.sigmaz`, :func:`.sigmap`, and :func:`.sigmam` on these two-level states. For example, if ``vac`` corresponds to the vacuum state of a harmonic oscillator, then, as we have already seen, we can use the raising operator to get the :math:`\left|1\right>` state:. .. testcode:: [states]. print(vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[1.]; [0.]]. .. testcode:: [states]. c = create(2). print(c * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[0.]; [1.]]. For a spin system, the operator analogous to the raising operator is the sigma-plus operator :func:`.sigmap`. Operating on the ``spin`` state gives:. .. testcode:: [states]. print(spin). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[1.]; [0.]]. .. testcode:: [states]. print(sigmap() * spin). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[0.]; [0.]]. Now we see the difference! The :func:`.sigmap` operator acting on the ``spin`` state returns the zero vector. Why is this? To see what happened, let us use the :func:`.sigmaz` operator:. .. testcode:: [states]. print(sigmaz()). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[ 1. 0.]; [ 0. -1.]]. .. testcode:: [states]. print(sigmaz() * spin). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[1.]; [0.]]. .. testcode:: [states]. spin2 = basis(2, 1). p",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:14147,Testability,test,testcode,14147,"`.sigmam` on these two-level states. For example, if ``vac`` corresponds to the vacuum state of a harmonic oscillator, then, as we have already seen, we can use the raising operator to get the :math:`\left|1\right>` state:. .. testcode:: [states]. print(vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[1.]; [0.]]. .. testcode:: [states]. c = create(2). print(c * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[0.]; [1.]]. For a spin system, the operator analogous to the raising operator is the sigma-plus operator :func:`.sigmap`. Operating on the ``spin`` state gives:. .. testcode:: [states]. print(spin). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[1.]; [0.]]. .. testcode:: [states]. print(sigmap() * spin). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[0.]; [0.]]. Now we see the difference! The :func:`.sigmap` operator acting on the ``spin`` state returns the zero vector. Why is this? To see what happened, let us use the :func:`.sigmaz` operator:. .. testcode:: [states]. print(sigmaz()). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[ 1. 0.]; [ 0. -1.]]. .. testcode:: [states]. print(sigmaz() * spin). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[1.]; [0.]]. .. testcode:: [states]. spin2 = basis(2, 1). print(spin2). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, ",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:14208,Testability,test,testoutput,14208," vacuum state of a harmonic oscillator, then, as we have already seen, we can use the raising operator to get the :math:`\left|1\right>` state:. .. testcode:: [states]. print(vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[1.]; [0.]]. .. testcode:: [states]. c = create(2). print(c * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[0.]; [1.]]. For a spin system, the operator analogous to the raising operator is the sigma-plus operator :func:`.sigmap`. Operating on the ``spin`` state gives:. .. testcode:: [states]. print(spin). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[1.]; [0.]]. .. testcode:: [states]. print(sigmap() * spin). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[0.]; [0.]]. Now we see the difference! The :func:`.sigmap` operator acting on the ``spin`` state returns the zero vector. Why is this? To see what happened, let us use the :func:`.sigmaz` operator:. .. testcode:: [states]. print(sigmaz()). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[ 1. 0.]; [ 0. -1.]]. .. testcode:: [states]. print(sigmaz() * spin). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[1.]; [0.]]. .. testcode:: [states]. spin2 = basis(2, 1). print(spin2). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[0.]; [1.]]. .. testcode:: [states]. print(sigma",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:14544,Testability,test,testcode,14544,"bj data =; [[1.]; [0.]]. .. testcode:: [states]. c = create(2). print(c * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[0.]; [1.]]. For a spin system, the operator analogous to the raising operator is the sigma-plus operator :func:`.sigmap`. Operating on the ``spin`` state gives:. .. testcode:: [states]. print(spin). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[1.]; [0.]]. .. testcode:: [states]. print(sigmap() * spin). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[0.]; [0.]]. Now we see the difference! The :func:`.sigmap` operator acting on the ``spin`` state returns the zero vector. Why is this? To see what happened, let us use the :func:`.sigmaz` operator:. .. testcode:: [states]. print(sigmaz()). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[ 1. 0.]; [ 0. -1.]]. .. testcode:: [states]. print(sigmaz() * spin). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[1.]; [0.]]. .. testcode:: [states]. spin2 = basis(2, 1). print(spin2). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[0.]; [1.]]. .. testcode:: [states]. print(sigmaz() * spin2). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[ 0.]; [-1.]]. The answer is now apparent. Since the QuTiP :func:`.sigmaz` function uses the standard z-basis representation of the sigma-z spin operator, t",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:14598,Testability,test,testoutput,14598,"* vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[0.]; [1.]]. For a spin system, the operator analogous to the raising operator is the sigma-plus operator :func:`.sigmap`. Operating on the ``spin`` state gives:. .. testcode:: [states]. print(spin). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[1.]; [0.]]. .. testcode:: [states]. print(sigmap() * spin). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[0.]; [0.]]. Now we see the difference! The :func:`.sigmap` operator acting on the ``spin`` state returns the zero vector. Why is this? To see what happened, let us use the :func:`.sigmaz` operator:. .. testcode:: [states]. print(sigmaz()). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[ 1. 0.]; [ 0. -1.]]. .. testcode:: [states]. print(sigmaz() * spin). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[1.]; [0.]]. .. testcode:: [states]. spin2 = basis(2, 1). print(spin2). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[0.]; [1.]]. .. testcode:: [states]. print(sigmaz() * spin2). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[ 0.]; [-1.]]. The answer is now apparent. Since the QuTiP :func:`.sigmaz` function uses the standard z-basis representation of the sigma-z spin operator, the ``spin`` state corresponds to the :math:`\left|\uparrow\right>` stat",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:14772,Testability,test,testcode,14772,"[[0.]; [1.]]. For a spin system, the operator analogous to the raising operator is the sigma-plus operator :func:`.sigmap`. Operating on the ``spin`` state gives:. .. testcode:: [states]. print(spin). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[1.]; [0.]]. .. testcode:: [states]. print(sigmap() * spin). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[0.]; [0.]]. Now we see the difference! The :func:`.sigmap` operator acting on the ``spin`` state returns the zero vector. Why is this? To see what happened, let us use the :func:`.sigmaz` operator:. .. testcode:: [states]. print(sigmaz()). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[ 1. 0.]; [ 0. -1.]]. .. testcode:: [states]. print(sigmaz() * spin). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[1.]; [0.]]. .. testcode:: [states]. spin2 = basis(2, 1). print(spin2). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[0.]; [1.]]. .. testcode:: [states]. print(sigmaz() * spin2). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[ 0.]; [-1.]]. The answer is now apparent. Since the QuTiP :func:`.sigmaz` function uses the standard z-basis representation of the sigma-z spin operator, the ``spin`` state corresponds to the :math:`\left|\uparrow\right>` state of a two-level spin system while ``spin2`` gives the :math:`\left|\downarrow\right>` state. Therefore, in our previous example ``sigmap() * spin``, we rais",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:14833,Testability,test,testoutput,14833," is the sigma-plus operator :func:`.sigmap`. Operating on the ``spin`` state gives:. .. testcode:: [states]. print(spin). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[1.]; [0.]]. .. testcode:: [states]. print(sigmap() * spin). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[0.]; [0.]]. Now we see the difference! The :func:`.sigmap` operator acting on the ``spin`` state returns the zero vector. Why is this? To see what happened, let us use the :func:`.sigmaz` operator:. .. testcode:: [states]. print(sigmaz()). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[ 1. 0.]; [ 0. -1.]]. .. testcode:: [states]. print(sigmaz() * spin). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[1.]; [0.]]. .. testcode:: [states]. spin2 = basis(2, 1). print(spin2). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[0.]; [1.]]. .. testcode:: [states]. print(sigmaz() * spin2). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[ 0.]; [-1.]]. The answer is now apparent. Since the QuTiP :func:`.sigmaz` function uses the standard z-basis representation of the sigma-z spin operator, the ``spin`` state corresponds to the :math:`\left|\uparrow\right>` state of a two-level spin system while ``spin2`` gives the :math:`\left|\downarrow\right>` state. Therefore, in our previous example ``sigmap() * spin``, we raised the qubit state out of the truncated two-level Hilbert space resulting in t",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:14982,Testability,test,testcode,14982,"*:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[1.]; [0.]]. .. testcode:: [states]. print(sigmap() * spin). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[0.]; [0.]]. Now we see the difference! The :func:`.sigmap` operator acting on the ``spin`` state returns the zero vector. Why is this? To see what happened, let us use the :func:`.sigmaz` operator:. .. testcode:: [states]. print(sigmaz()). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[ 1. 0.]; [ 0. -1.]]. .. testcode:: [states]. print(sigmaz() * spin). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[1.]; [0.]]. .. testcode:: [states]. spin2 = basis(2, 1). print(spin2). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[0.]; [1.]]. .. testcode:: [states]. print(sigmaz() * spin2). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[ 0.]; [-1.]]. The answer is now apparent. Since the QuTiP :func:`.sigmaz` function uses the standard z-basis representation of the sigma-z spin operator, the ``spin`` state corresponds to the :math:`\left|\uparrow\right>` state of a two-level spin system while ``spin2`` gives the :math:`\left|\downarrow\right>` state. Therefore, in our previous example ``sigmap() * spin``, we raised the qubit state out of the truncated two-level Hilbert space resulting in the zero state. While at first glance this convention might seem somewhat odd, it is in fact quite handy. For one, the spin operators",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:15054,Testability,test,testoutput,15054,", [1]], shape = (2, 1), type = ket; Qobj data =; [[1.]; [0.]]. .. testcode:: [states]. print(sigmap() * spin). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[0.]; [0.]]. Now we see the difference! The :func:`.sigmap` operator acting on the ``spin`` state returns the zero vector. Why is this? To see what happened, let us use the :func:`.sigmaz` operator:. .. testcode:: [states]. print(sigmaz()). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[ 1. 0.]; [ 0. -1.]]. .. testcode:: [states]. print(sigmaz() * spin). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[1.]; [0.]]. .. testcode:: [states]. spin2 = basis(2, 1). print(spin2). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[0.]; [1.]]. .. testcode:: [states]. print(sigmaz() * spin2). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[ 0.]; [-1.]]. The answer is now apparent. Since the QuTiP :func:`.sigmaz` function uses the standard z-basis representation of the sigma-z spin operator, the ``spin`` state corresponds to the :math:`\left|\uparrow\right>` state of a two-level spin system while ``spin2`` gives the :math:`\left|\downarrow\right>` state. Therefore, in our previous example ``sigmap() * spin``, we raised the qubit state out of the truncated two-level Hilbert space resulting in the zero state. While at first glance this convention might seem somewhat odd, it is in fact quite handy. For one, the spin operators remain in the conventional form. Second, when the spin system is in the :math:`\left|\up",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:15203,Testability,test,testcode,15203,"output:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[0.]; [0.]]. Now we see the difference! The :func:`.sigmap` operator acting on the ``spin`` state returns the zero vector. Why is this? To see what happened, let us use the :func:`.sigmaz` operator:. .. testcode:: [states]. print(sigmaz()). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[ 1. 0.]; [ 0. -1.]]. .. testcode:: [states]. print(sigmaz() * spin). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[1.]; [0.]]. .. testcode:: [states]. spin2 = basis(2, 1). print(spin2). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[0.]; [1.]]. .. testcode:: [states]. print(sigmaz() * spin2). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[ 0.]; [-1.]]. The answer is now apparent. Since the QuTiP :func:`.sigmaz` function uses the standard z-basis representation of the sigma-z spin operator, the ``spin`` state corresponds to the :math:`\left|\uparrow\right>` state of a two-level spin system while ``spin2`` gives the :math:`\left|\downarrow\right>` state. Therefore, in our previous example ``sigmap() * spin``, we raised the qubit state out of the truncated two-level Hilbert space resulting in the zero state. While at first glance this convention might seem somewhat odd, it is in fact quite handy. For one, the spin operators remain in the conventional form. Second, when the spin system is in the :math:`\left|\uparrow\right>` state:. .. testcode:: [states]. print(sigmaz() * spin). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WH",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:15265,Testability,test,testoutput,15265," [1]], shape = (2, 1), type = ket; Qobj data =; [[0.]; [0.]]. Now we see the difference! The :func:`.sigmap` operator acting on the ``spin`` state returns the zero vector. Why is this? To see what happened, let us use the :func:`.sigmaz` operator:. .. testcode:: [states]. print(sigmaz()). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[ 1. 0.]; [ 0. -1.]]. .. testcode:: [states]. print(sigmaz() * spin). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[1.]; [0.]]. .. testcode:: [states]. spin2 = basis(2, 1). print(spin2). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[0.]; [1.]]. .. testcode:: [states]. print(sigmaz() * spin2). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[ 0.]; [-1.]]. The answer is now apparent. Since the QuTiP :func:`.sigmaz` function uses the standard z-basis representation of the sigma-z spin operator, the ``spin`` state corresponds to the :math:`\left|\uparrow\right>` state of a two-level spin system while ``spin2`` gives the :math:`\left|\downarrow\right>` state. Therefore, in our previous example ``sigmap() * spin``, we raised the qubit state out of the truncated two-level Hilbert space resulting in the zero state. While at first glance this convention might seem somewhat odd, it is in fact quite handy. For one, the spin operators remain in the conventional form. Second, when the spin system is in the :math:`\left|\uparrow\right>` state:. .. testcode:: [states]. print(sigmaz() * spin). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj d",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:16106,Testability,test,testcode,16106,"um object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[0.]; [1.]]. .. testcode:: [states]. print(sigmaz() * spin2). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[ 0.]; [-1.]]. The answer is now apparent. Since the QuTiP :func:`.sigmaz` function uses the standard z-basis representation of the sigma-z spin operator, the ``spin`` state corresponds to the :math:`\left|\uparrow\right>` state of a two-level spin system while ``spin2`` gives the :math:`\left|\downarrow\right>` state. Therefore, in our previous example ``sigmap() * spin``, we raised the qubit state out of the truncated two-level Hilbert space resulting in the zero state. While at first glance this convention might seem somewhat odd, it is in fact quite handy. For one, the spin operators remain in the conventional form. Second, when the spin system is in the :math:`\left|\uparrow\right>` state:. .. testcode:: [states]. print(sigmaz() * spin). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[1.]; [0.]]. the non-zero component is the zeroth-element of the underlying matrix (remember that python uses c-indexing, and matrices start with the zeroth element). The :math:`\left|\downarrow\right>` state therefore has a non-zero entry in the first index position. This corresponds nicely with the quantum information definitions of qubit states, where the excited :math:`\left|\uparrow\right>` state is label as :math:`\left|0\right>`, and the :math:`\left|\downarrow\right>` state by :math:`\left|1\right>`. If one wants to create spin operators for higher spin systems, then the :func:`.jmat` function comes in handy. .. _quantum_gates:. Gates; =====. The pre-defined gates are shown in the table below:. .. cssclass:: table-striped. +------------------------------------------------+-------------------------",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:16167,Testability,test,testoutput,16167,"1.]]. .. testcode:: [states]. print(sigmaz() * spin2). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[ 0.]; [-1.]]. The answer is now apparent. Since the QuTiP :func:`.sigmaz` function uses the standard z-basis representation of the sigma-z spin operator, the ``spin`` state corresponds to the :math:`\left|\uparrow\right>` state of a two-level spin system while ``spin2`` gives the :math:`\left|\downarrow\right>` state. Therefore, in our previous example ``sigmap() * spin``, we raised the qubit state out of the truncated two-level Hilbert space resulting in the zero state. While at first glance this convention might seem somewhat odd, it is in fact quite handy. For one, the spin operators remain in the conventional form. Second, when the spin system is in the :math:`\left|\uparrow\right>` state:. .. testcode:: [states]. print(sigmaz() * spin). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[1.]; [0.]]. the non-zero component is the zeroth-element of the underlying matrix (remember that python uses c-indexing, and matrices start with the zeroth element). The :math:`\left|\downarrow\right>` state therefore has a non-zero entry in the first index position. This corresponds nicely with the quantum information definitions of qubit states, where the excited :math:`\left|\uparrow\right>` state is label as :math:`\left|0\right>`, and the :math:`\left|\downarrow\right>` state by :math:`\left|1\right>`. If one wants to create spin operators for higher spin systems, then the :func:`.jmat` function comes in handy. .. _quantum_gates:. Gates; =====. The pre-defined gates are shown in the table below:. .. cssclass:: table-striped. +------------------------------------------------+-------------------------------------------------------+; | Gate function | Description |; +===========",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:22426,Testability,test,testcode,22426,"orensen gate |; +------------------------------------------------+-------------------------------------------------------+; | :func:`~qutip.core.gates.toffoli` | Toffoli gate |; +------------------------------------------------+-------------------------------------------------------+; | :func:`~qutip.core.gates.hadamard_transform` | Hadamard gate |; +------------------------------------------------+-------------------------------------------------------+; | :func:`~qutip.core.gates.qubit_clifford_group` | Generates the Clifford group on a single qubit |; +------------------------------------------------+-------------------------------------------------------+; | :func:`~qutip.core.gates.globalphase` | Global phase gate |; +------------------------------------------------+-------------------------------------------------------+. To load this qutip module, first you have to import gates:. .. code-block:: Python. from qutip import gates. For example to use the Hadamard Gate:. .. testcode:: [basics]. H = gates.hadamard_transform(); print(H). **Output**:. .. testoutput:: [basics]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims=[[2], [2]], shape=(2, 2), type='oper', dtype=Dense, isherm=True; Qobj data =; [[ 0.70710678 0.70710678]; [0.70710678 -0.70710678]]. .. _states-expect:. Expectation values; ===================. Some of the most important information about quantum systems comes from calculating the expectation value of operators, both Hermitian and non-Hermitian, as the state or density matrix of the system varies in time. Therefore, in this section we demonstrate the use of the :func:`.expect` function. To begin:. .. testcode:: [states]. vac = basis(5, 0). one = basis(5, 1). c = create(5). N = num(5). np.testing.assert_almost_equal(expect(N, vac), 0). np.testing.assert_almost_equal(expect(N, one), 1). coh = coherent_dm(5, 1.0j). np.testing.assert_almost_equal(expect(N, coh), 0.9970555745806597). cat = (basis(5, 4) + 1.0j * basis(5, 3)).unit(). np.testing.asser",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:22505,Testability,test,testoutput,22505,"------------------------+; | :func:`~qutip.core.gates.toffoli` | Toffoli gate |; +------------------------------------------------+-------------------------------------------------------+; | :func:`~qutip.core.gates.hadamard_transform` | Hadamard gate |; +------------------------------------------------+-------------------------------------------------------+; | :func:`~qutip.core.gates.qubit_clifford_group` | Generates the Clifford group on a single qubit |; +------------------------------------------------+-------------------------------------------------------+; | :func:`~qutip.core.gates.globalphase` | Global phase gate |; +------------------------------------------------+-------------------------------------------------------+. To load this qutip module, first you have to import gates:. .. code-block:: Python. from qutip import gates. For example to use the Hadamard Gate:. .. testcode:: [basics]. H = gates.hadamard_transform(); print(H). **Output**:. .. testoutput:: [basics]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims=[[2], [2]], shape=(2, 2), type='oper', dtype=Dense, isherm=True; Qobj data =; [[ 0.70710678 0.70710678]; [0.70710678 -0.70710678]]. .. _states-expect:. Expectation values; ===================. Some of the most important information about quantum systems comes from calculating the expectation value of operators, both Hermitian and non-Hermitian, as the state or density matrix of the system varies in time. Therefore, in this section we demonstrate the use of the :func:`.expect` function. To begin:. .. testcode:: [states]. vac = basis(5, 0). one = basis(5, 1). c = create(5). N = num(5). np.testing.assert_almost_equal(expect(N, vac), 0). np.testing.assert_almost_equal(expect(N, one), 1). coh = coherent_dm(5, 1.0j). np.testing.assert_almost_equal(expect(N, coh), 0.9970555745806597). cat = (basis(5, 4) + 1.0j * basis(5, 3)).unit(). np.testing.assert_almost_equal(expect(c, cat), 0.9999999999999998j). The :func:`.expect` function also accepts l",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:23087,Testability,test,testcode,23087,"-----+; | :func:`~qutip.core.gates.globalphase` | Global phase gate |; +------------------------------------------------+-------------------------------------------------------+. To load this qutip module, first you have to import gates:. .. code-block:: Python. from qutip import gates. For example to use the Hadamard Gate:. .. testcode:: [basics]. H = gates.hadamard_transform(); print(H). **Output**:. .. testoutput:: [basics]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims=[[2], [2]], shape=(2, 2), type='oper', dtype=Dense, isherm=True; Qobj data =; [[ 0.70710678 0.70710678]; [0.70710678 -0.70710678]]. .. _states-expect:. Expectation values; ===================. Some of the most important information about quantum systems comes from calculating the expectation value of operators, both Hermitian and non-Hermitian, as the state or density matrix of the system varies in time. Therefore, in this section we demonstrate the use of the :func:`.expect` function. To begin:. .. testcode:: [states]. vac = basis(5, 0). one = basis(5, 1). c = create(5). N = num(5). np.testing.assert_almost_equal(expect(N, vac), 0). np.testing.assert_almost_equal(expect(N, one), 1). coh = coherent_dm(5, 1.0j). np.testing.assert_almost_equal(expect(N, coh), 0.9970555745806597). cat = (basis(5, 4) + 1.0j * basis(5, 3)).unit(). np.testing.assert_almost_equal(expect(c, cat), 0.9999999999999998j). The :func:`.expect` function also accepts lists or arrays of state vectors or density matrices for the second input:. .. testcode:: [states]. states = [(c**k * vac).unit() for k in range(5)] # must normalize. print(expect(N, states)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. [0. 1. 2. 3. 4.]. .. testcode:: [states]. cat_list = [(basis(5, 4) + x * basis(5, 3)).unit() for x in [0, 1.0j, -1.0, -1.0j]]. print(expect(c, cat_list)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. [ 0.+0.j 0.+1.j -1.+0.j 0.-1.j]. Notice how in this last example, all of t",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:23176,Testability,test,testing,23176,"------------------------------------+-------------------------------------------------------+. To load this qutip module, first you have to import gates:. .. code-block:: Python. from qutip import gates. For example to use the Hadamard Gate:. .. testcode:: [basics]. H = gates.hadamard_transform(); print(H). **Output**:. .. testoutput:: [basics]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims=[[2], [2]], shape=(2, 2), type='oper', dtype=Dense, isherm=True; Qobj data =; [[ 0.70710678 0.70710678]; [0.70710678 -0.70710678]]. .. _states-expect:. Expectation values; ===================. Some of the most important information about quantum systems comes from calculating the expectation value of operators, both Hermitian and non-Hermitian, as the state or density matrix of the system varies in time. Therefore, in this section we demonstrate the use of the :func:`.expect` function. To begin:. .. testcode:: [states]. vac = basis(5, 0). one = basis(5, 1). c = create(5). N = num(5). np.testing.assert_almost_equal(expect(N, vac), 0). np.testing.assert_almost_equal(expect(N, one), 1). coh = coherent_dm(5, 1.0j). np.testing.assert_almost_equal(expect(N, coh), 0.9970555745806597). cat = (basis(5, 4) + 1.0j * basis(5, 3)).unit(). np.testing.assert_almost_equal(expect(c, cat), 0.9999999999999998j). The :func:`.expect` function also accepts lists or arrays of state vectors or density matrices for the second input:. .. testcode:: [states]. states = [(c**k * vac).unit() for k in range(5)] # must normalize. print(expect(N, states)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. [0. 1. 2. 3. 4.]. .. testcode:: [states]. cat_list = [(basis(5, 4) + x * basis(5, 3)).unit() for x in [0, 1.0j, -1.0, -1.0j]]. print(expect(c, cat_list)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. [ 0.+0.j 0.+1.j -1.+0.j 0.-1.j]. Notice how in this last example, all of the return values are complex numbers. This is because the :func:`.expect` function ",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:23227,Testability,test,testing,23227,"-----------------------------------------+. To load this qutip module, first you have to import gates:. .. code-block:: Python. from qutip import gates. For example to use the Hadamard Gate:. .. testcode:: [basics]. H = gates.hadamard_transform(); print(H). **Output**:. .. testoutput:: [basics]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims=[[2], [2]], shape=(2, 2), type='oper', dtype=Dense, isherm=True; Qobj data =; [[ 0.70710678 0.70710678]; [0.70710678 -0.70710678]]. .. _states-expect:. Expectation values; ===================. Some of the most important information about quantum systems comes from calculating the expectation value of operators, both Hermitian and non-Hermitian, as the state or density matrix of the system varies in time. Therefore, in this section we demonstrate the use of the :func:`.expect` function. To begin:. .. testcode:: [states]. vac = basis(5, 0). one = basis(5, 1). c = create(5). N = num(5). np.testing.assert_almost_equal(expect(N, vac), 0). np.testing.assert_almost_equal(expect(N, one), 1). coh = coherent_dm(5, 1.0j). np.testing.assert_almost_equal(expect(N, coh), 0.9970555745806597). cat = (basis(5, 4) + 1.0j * basis(5, 3)).unit(). np.testing.assert_almost_equal(expect(c, cat), 0.9999999999999998j). The :func:`.expect` function also accepts lists or arrays of state vectors or density matrices for the second input:. .. testcode:: [states]. states = [(c**k * vac).unit() for k in range(5)] # must normalize. print(expect(N, states)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. [0. 1. 2. 3. 4.]. .. testcode:: [states]. cat_list = [(basis(5, 4) + x * basis(5, 3)).unit() for x in [0, 1.0j, -1.0, -1.0j]]. print(expect(c, cat_list)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. [ 0.+0.j 0.+1.j -1.+0.j 0.-1.j]. Notice how in this last example, all of the return values are complex numbers. This is because the :func:`.expect` function looks to see whether the operator is Hermitian or n",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:23306,Testability,test,testing,23306,"u have to import gates:. .. code-block:: Python. from qutip import gates. For example to use the Hadamard Gate:. .. testcode:: [basics]. H = gates.hadamard_transform(); print(H). **Output**:. .. testoutput:: [basics]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims=[[2], [2]], shape=(2, 2), type='oper', dtype=Dense, isherm=True; Qobj data =; [[ 0.70710678 0.70710678]; [0.70710678 -0.70710678]]. .. _states-expect:. Expectation values; ===================. Some of the most important information about quantum systems comes from calculating the expectation value of operators, both Hermitian and non-Hermitian, as the state or density matrix of the system varies in time. Therefore, in this section we demonstrate the use of the :func:`.expect` function. To begin:. .. testcode:: [states]. vac = basis(5, 0). one = basis(5, 1). c = create(5). N = num(5). np.testing.assert_almost_equal(expect(N, vac), 0). np.testing.assert_almost_equal(expect(N, one), 1). coh = coherent_dm(5, 1.0j). np.testing.assert_almost_equal(expect(N, coh), 0.9970555745806597). cat = (basis(5, 4) + 1.0j * basis(5, 3)).unit(). np.testing.assert_almost_equal(expect(c, cat), 0.9999999999999998j). The :func:`.expect` function also accepts lists or arrays of state vectors or density matrices for the second input:. .. testcode:: [states]. states = [(c**k * vac).unit() for k in range(5)] # must normalize. print(expect(N, states)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. [0. 1. 2. 3. 4.]. .. testcode:: [states]. cat_list = [(basis(5, 4) + x * basis(5, 3)).unit() for x in [0, 1.0j, -1.0, -1.0j]]. print(expect(c, cat_list)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. [ 0.+0.j 0.+1.j -1.+0.j 0.-1.j]. Notice how in this last example, all of the return values are complex numbers. This is because the :func:`.expect` function looks to see whether the operator is Hermitian or not. If the operator is Hermitian, then the output will always be real. In the c",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:23423,Testability,test,testing,23423,"estcode:: [basics]. H = gates.hadamard_transform(); print(H). **Output**:. .. testoutput:: [basics]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims=[[2], [2]], shape=(2, 2), type='oper', dtype=Dense, isherm=True; Qobj data =; [[ 0.70710678 0.70710678]; [0.70710678 -0.70710678]]. .. _states-expect:. Expectation values; ===================. Some of the most important information about quantum systems comes from calculating the expectation value of operators, both Hermitian and non-Hermitian, as the state or density matrix of the system varies in time. Therefore, in this section we demonstrate the use of the :func:`.expect` function. To begin:. .. testcode:: [states]. vac = basis(5, 0). one = basis(5, 1). c = create(5). N = num(5). np.testing.assert_almost_equal(expect(N, vac), 0). np.testing.assert_almost_equal(expect(N, one), 1). coh = coherent_dm(5, 1.0j). np.testing.assert_almost_equal(expect(N, coh), 0.9970555745806597). cat = (basis(5, 4) + 1.0j * basis(5, 3)).unit(). np.testing.assert_almost_equal(expect(c, cat), 0.9999999999999998j). The :func:`.expect` function also accepts lists or arrays of state vectors or density matrices for the second input:. .. testcode:: [states]. states = [(c**k * vac).unit() for k in range(5)] # must normalize. print(expect(N, states)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. [0. 1. 2. 3. 4.]. .. testcode:: [states]. cat_list = [(basis(5, 4) + x * basis(5, 3)).unit() for x in [0, 1.0j, -1.0, -1.0j]]. print(expect(c, cat_list)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. [ 0.+0.j 0.+1.j -1.+0.j 0.-1.j]. Notice how in this last example, all of the return values are complex numbers. This is because the :func:`.expect` function looks to see whether the operator is Hermitian or not. If the operator is Hermitian, then the output will always be real. In the case of non-Hermitian operators, the return values may be complex. Therefore, the :func:`.expect` function will return",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:23610,Testability,test,testcode,23610,", dtype=Dense, isherm=True; Qobj data =; [[ 0.70710678 0.70710678]; [0.70710678 -0.70710678]]. .. _states-expect:. Expectation values; ===================. Some of the most important information about quantum systems comes from calculating the expectation value of operators, both Hermitian and non-Hermitian, as the state or density matrix of the system varies in time. Therefore, in this section we demonstrate the use of the :func:`.expect` function. To begin:. .. testcode:: [states]. vac = basis(5, 0). one = basis(5, 1). c = create(5). N = num(5). np.testing.assert_almost_equal(expect(N, vac), 0). np.testing.assert_almost_equal(expect(N, one), 1). coh = coherent_dm(5, 1.0j). np.testing.assert_almost_equal(expect(N, coh), 0.9970555745806597). cat = (basis(5, 4) + 1.0j * basis(5, 3)).unit(). np.testing.assert_almost_equal(expect(c, cat), 0.9999999999999998j). The :func:`.expect` function also accepts lists or arrays of state vectors or density matrices for the second input:. .. testcode:: [states]. states = [(c**k * vac).unit() for k in range(5)] # must normalize. print(expect(N, states)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. [0. 1. 2. 3. 4.]. .. testcode:: [states]. cat_list = [(basis(5, 4) + x * basis(5, 3)).unit() for x in [0, 1.0j, -1.0, -1.0j]]. print(expect(c, cat_list)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. [ 0.+0.j 0.+1.j -1.+0.j 0.-1.j]. Notice how in this last example, all of the return values are complex numbers. This is because the :func:`.expect` function looks to see whether the operator is Hermitian or not. If the operator is Hermitian, then the output will always be real. In the case of non-Hermitian operators, the return values may be complex. Therefore, the :func:`.expect` function will return an array of complex values for non-Hermitian operators when the input is a list/array of states or density matrices. Of course, the :func:`.expect` function works for spin states and operators",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:23740,Testability,test,testoutput,23740,"======. Some of the most important information about quantum systems comes from calculating the expectation value of operators, both Hermitian and non-Hermitian, as the state or density matrix of the system varies in time. Therefore, in this section we demonstrate the use of the :func:`.expect` function. To begin:. .. testcode:: [states]. vac = basis(5, 0). one = basis(5, 1). c = create(5). N = num(5). np.testing.assert_almost_equal(expect(N, vac), 0). np.testing.assert_almost_equal(expect(N, one), 1). coh = coherent_dm(5, 1.0j). np.testing.assert_almost_equal(expect(N, coh), 0.9970555745806597). cat = (basis(5, 4) + 1.0j * basis(5, 3)).unit(). np.testing.assert_almost_equal(expect(c, cat), 0.9999999999999998j). The :func:`.expect` function also accepts lists or arrays of state vectors or density matrices for the second input:. .. testcode:: [states]. states = [(c**k * vac).unit() for k in range(5)] # must normalize. print(expect(N, states)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. [0. 1. 2. 3. 4.]. .. testcode:: [states]. cat_list = [(basis(5, 4) + x * basis(5, 3)).unit() for x in [0, 1.0j, -1.0, -1.0j]]. print(expect(c, cat_list)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. [ 0.+0.j 0.+1.j -1.+0.j 0.-1.j]. Notice how in this last example, all of the return values are complex numbers. This is because the :func:`.expect` function looks to see whether the operator is Hermitian or not. If the operator is Hermitian, then the output will always be real. In the case of non-Hermitian operators, the return values may be complex. Therefore, the :func:`.expect` function will return an array of complex values for non-Hermitian operators when the input is a list/array of states or density matrices. Of course, the :func:`.expect` function works for spin states and operators:. .. testcode:: [states]. up = basis(2, 0). down = basis(2, 1). np.testing.assert_almost_equal(expect(sigmaz(), up), 1). np.testing.assert_almost_",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:23817,Testability,test,testcode,23817,"m systems comes from calculating the expectation value of operators, both Hermitian and non-Hermitian, as the state or density matrix of the system varies in time. Therefore, in this section we demonstrate the use of the :func:`.expect` function. To begin:. .. testcode:: [states]. vac = basis(5, 0). one = basis(5, 1). c = create(5). N = num(5). np.testing.assert_almost_equal(expect(N, vac), 0). np.testing.assert_almost_equal(expect(N, one), 1). coh = coherent_dm(5, 1.0j). np.testing.assert_almost_equal(expect(N, coh), 0.9970555745806597). cat = (basis(5, 4) + 1.0j * basis(5, 3)).unit(). np.testing.assert_almost_equal(expect(c, cat), 0.9999999999999998j). The :func:`.expect` function also accepts lists or arrays of state vectors or density matrices for the second input:. .. testcode:: [states]. states = [(c**k * vac).unit() for k in range(5)] # must normalize. print(expect(N, states)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. [0. 1. 2. 3. 4.]. .. testcode:: [states]. cat_list = [(basis(5, 4) + x * basis(5, 3)).unit() for x in [0, 1.0j, -1.0, -1.0j]]. print(expect(c, cat_list)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. [ 0.+0.j 0.+1.j -1.+0.j 0.-1.j]. Notice how in this last example, all of the return values are complex numbers. This is because the :func:`.expect` function looks to see whether the operator is Hermitian or not. If the operator is Hermitian, then the output will always be real. In the case of non-Hermitian operators, the return values may be complex. Therefore, the :func:`.expect` function will return an array of complex values for non-Hermitian operators when the input is a list/array of states or density matrices. Of course, the :func:`.expect` function works for spin states and operators:. .. testcode:: [states]. up = basis(2, 0). down = basis(2, 1). np.testing.assert_almost_equal(expect(sigmaz(), up), 1). np.testing.assert_almost_equal(expect(sigmaz(), down), -1). as well as the composite ",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:23967,Testability,test,testoutput,23967,"efore, in this section we demonstrate the use of the :func:`.expect` function. To begin:. .. testcode:: [states]. vac = basis(5, 0). one = basis(5, 1). c = create(5). N = num(5). np.testing.assert_almost_equal(expect(N, vac), 0). np.testing.assert_almost_equal(expect(N, one), 1). coh = coherent_dm(5, 1.0j). np.testing.assert_almost_equal(expect(N, coh), 0.9970555745806597). cat = (basis(5, 4) + 1.0j * basis(5, 3)).unit(). np.testing.assert_almost_equal(expect(c, cat), 0.9999999999999998j). The :func:`.expect` function also accepts lists or arrays of state vectors or density matrices for the second input:. .. testcode:: [states]. states = [(c**k * vac).unit() for k in range(5)] # must normalize. print(expect(N, states)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. [0. 1. 2. 3. 4.]. .. testcode:: [states]. cat_list = [(basis(5, 4) + x * basis(5, 3)).unit() for x in [0, 1.0j, -1.0, -1.0j]]. print(expect(c, cat_list)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. [ 0.+0.j 0.+1.j -1.+0.j 0.-1.j]. Notice how in this last example, all of the return values are complex numbers. This is because the :func:`.expect` function looks to see whether the operator is Hermitian or not. If the operator is Hermitian, then the output will always be real. In the case of non-Hermitian operators, the return values may be complex. Therefore, the :func:`.expect` function will return an array of complex values for non-Hermitian operators when the input is a list/array of states or density matrices. Of course, the :func:`.expect` function works for spin states and operators:. .. testcode:: [states]. up = basis(2, 0). down = basis(2, 1). np.testing.assert_almost_equal(expect(sigmaz(), up), 1). np.testing.assert_almost_equal(expect(sigmaz(), down), -1). as well as the composite objects discussed in the next section :ref:`tensor`:. .. testcode:: [states]. spin1 = basis(2, 0). spin2 = basis(2, 1). two_spins = tensor(spin1, spin2). sz1 = tensor(",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:24626,Testability,test,testcode,24626,"es = [(c**k * vac).unit() for k in range(5)] # must normalize. print(expect(N, states)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. [0. 1. 2. 3. 4.]. .. testcode:: [states]. cat_list = [(basis(5, 4) + x * basis(5, 3)).unit() for x in [0, 1.0j, -1.0, -1.0j]]. print(expect(c, cat_list)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. [ 0.+0.j 0.+1.j -1.+0.j 0.-1.j]. Notice how in this last example, all of the return values are complex numbers. This is because the :func:`.expect` function looks to see whether the operator is Hermitian or not. If the operator is Hermitian, then the output will always be real. In the case of non-Hermitian operators, the return values may be complex. Therefore, the :func:`.expect` function will return an array of complex values for non-Hermitian operators when the input is a list/array of states or density matrices. Of course, the :func:`.expect` function works for spin states and operators:. .. testcode:: [states]. up = basis(2, 0). down = basis(2, 1). np.testing.assert_almost_equal(expect(sigmaz(), up), 1). np.testing.assert_almost_equal(expect(sigmaz(), down), -1). as well as the composite objects discussed in the next section :ref:`tensor`:. .. testcode:: [states]. spin1 = basis(2, 0). spin2 = basis(2, 1). two_spins = tensor(spin1, spin2). sz1 = tensor(sigmaz(), qeye(2)). sz2 = tensor(qeye(2), sigmaz()). np.testing.assert_almost_equal(expect(sz1, two_spins), 1). np.testing.assert_almost_equal(expect(sz2, two_spins), -1). .. _states-super:. Superoperators and Vectorized Operators; =======================================. In addition to state vectors and density operators, QuTiP allows for; representing maps that act linearly on density operators using the Kraus,; Liouville supermatrix and Choi matrix formalisms. This support is based on the; correspondence between linear operators acting on a Hilbert space, and vectors; in two copies of that Hilbert space,; :math:`\mathrm{vec} : \mat",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:24688,Testability,test,testing,24688,"lize. print(expect(N, states)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. [0. 1. 2. 3. 4.]. .. testcode:: [states]. cat_list = [(basis(5, 4) + x * basis(5, 3)).unit() for x in [0, 1.0j, -1.0, -1.0j]]. print(expect(c, cat_list)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. [ 0.+0.j 0.+1.j -1.+0.j 0.-1.j]. Notice how in this last example, all of the return values are complex numbers. This is because the :func:`.expect` function looks to see whether the operator is Hermitian or not. If the operator is Hermitian, then the output will always be real. In the case of non-Hermitian operators, the return values may be complex. Therefore, the :func:`.expect` function will return an array of complex values for non-Hermitian operators when the input is a list/array of states or density matrices. Of course, the :func:`.expect` function works for spin states and operators:. .. testcode:: [states]. up = basis(2, 0). down = basis(2, 1). np.testing.assert_almost_equal(expect(sigmaz(), up), 1). np.testing.assert_almost_equal(expect(sigmaz(), down), -1). as well as the composite objects discussed in the next section :ref:`tensor`:. .. testcode:: [states]. spin1 = basis(2, 0). spin2 = basis(2, 1). two_spins = tensor(spin1, spin2). sz1 = tensor(sigmaz(), qeye(2)). sz2 = tensor(qeye(2), sigmaz()). np.testing.assert_almost_equal(expect(sz1, two_spins), 1). np.testing.assert_almost_equal(expect(sz2, two_spins), -1). .. _states-super:. Superoperators and Vectorized Operators; =======================================. In addition to state vectors and density operators, QuTiP allows for; representing maps that act linearly on density operators using the Kraus,; Liouville supermatrix and Choi matrix formalisms. This support is based on the; correspondence between linear operators acting on a Hilbert space, and vectors; in two copies of that Hilbert space,; :math:`\mathrm{vec} : \mathcal{L}(\mathcal{H}) \to \mathcal{H} \otimes \mathcal{H}",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:24745,Testability,test,testing,24745,"t:: [states]; :options: +NORMALIZE_WHITESPACE. [0. 1. 2. 3. 4.]. .. testcode:: [states]. cat_list = [(basis(5, 4) + x * basis(5, 3)).unit() for x in [0, 1.0j, -1.0, -1.0j]]. print(expect(c, cat_list)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. [ 0.+0.j 0.+1.j -1.+0.j 0.-1.j]. Notice how in this last example, all of the return values are complex numbers. This is because the :func:`.expect` function looks to see whether the operator is Hermitian or not. If the operator is Hermitian, then the output will always be real. In the case of non-Hermitian operators, the return values may be complex. Therefore, the :func:`.expect` function will return an array of complex values for non-Hermitian operators when the input is a list/array of states or density matrices. Of course, the :func:`.expect` function works for spin states and operators:. .. testcode:: [states]. up = basis(2, 0). down = basis(2, 1). np.testing.assert_almost_equal(expect(sigmaz(), up), 1). np.testing.assert_almost_equal(expect(sigmaz(), down), -1). as well as the composite objects discussed in the next section :ref:`tensor`:. .. testcode:: [states]. spin1 = basis(2, 0). spin2 = basis(2, 1). two_spins = tensor(spin1, spin2). sz1 = tensor(sigmaz(), qeye(2)). sz2 = tensor(qeye(2), sigmaz()). np.testing.assert_almost_equal(expect(sz1, two_spins), 1). np.testing.assert_almost_equal(expect(sz2, two_spins), -1). .. _states-super:. Superoperators and Vectorized Operators; =======================================. In addition to state vectors and density operators, QuTiP allows for; representing maps that act linearly on density operators using the Kraus,; Liouville supermatrix and Choi matrix formalisms. This support is based on the; correspondence between linear operators acting on a Hilbert space, and vectors; in two copies of that Hilbert space,; :math:`\mathrm{vec} : \mathcal{L}(\mathcal{H}) \to \mathcal{H} \otimes \mathcal{H}`; [Hav03]_, [Wat13]_. This isomorphism is implemented in",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:24884,Testability,test,testcode,24884,"x in [0, 1.0j, -1.0, -1.0j]]. print(expect(c, cat_list)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. [ 0.+0.j 0.+1.j -1.+0.j 0.-1.j]. Notice how in this last example, all of the return values are complex numbers. This is because the :func:`.expect` function looks to see whether the operator is Hermitian or not. If the operator is Hermitian, then the output will always be real. In the case of non-Hermitian operators, the return values may be complex. Therefore, the :func:`.expect` function will return an array of complex values for non-Hermitian operators when the input is a list/array of states or density matrices. Of course, the :func:`.expect` function works for spin states and operators:. .. testcode:: [states]. up = basis(2, 0). down = basis(2, 1). np.testing.assert_almost_equal(expect(sigmaz(), up), 1). np.testing.assert_almost_equal(expect(sigmaz(), down), -1). as well as the composite objects discussed in the next section :ref:`tensor`:. .. testcode:: [states]. spin1 = basis(2, 0). spin2 = basis(2, 1). two_spins = tensor(spin1, spin2). sz1 = tensor(sigmaz(), qeye(2)). sz2 = tensor(qeye(2), sigmaz()). np.testing.assert_almost_equal(expect(sz1, two_spins), 1). np.testing.assert_almost_equal(expect(sz2, two_spins), -1). .. _states-super:. Superoperators and Vectorized Operators; =======================================. In addition to state vectors and density operators, QuTiP allows for; representing maps that act linearly on density operators using the Kraus,; Liouville supermatrix and Choi matrix formalisms. This support is based on the; correspondence between linear operators acting on a Hilbert space, and vectors; in two copies of that Hilbert space,; :math:`\mathrm{vec} : \mathcal{L}(\mathcal{H}) \to \mathcal{H} \otimes \mathcal{H}`; [Hav03]_, [Wat13]_. This isomorphism is implemented in QuTiP by the; :obj:`.operator_to_vector` and; :obj:`.vector_to_operator` functions:. .. testcode:: [states]. psi = basis(2, 0). rho = ket2dm(psi",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:25050,Testability,test,testing,25050,". Notice how in this last example, all of the return values are complex numbers. This is because the :func:`.expect` function looks to see whether the operator is Hermitian or not. If the operator is Hermitian, then the output will always be real. In the case of non-Hermitian operators, the return values may be complex. Therefore, the :func:`.expect` function will return an array of complex values for non-Hermitian operators when the input is a list/array of states or density matrices. Of course, the :func:`.expect` function works for spin states and operators:. .. testcode:: [states]. up = basis(2, 0). down = basis(2, 1). np.testing.assert_almost_equal(expect(sigmaz(), up), 1). np.testing.assert_almost_equal(expect(sigmaz(), down), -1). as well as the composite objects discussed in the next section :ref:`tensor`:. .. testcode:: [states]. spin1 = basis(2, 0). spin2 = basis(2, 1). two_spins = tensor(spin1, spin2). sz1 = tensor(sigmaz(), qeye(2)). sz2 = tensor(qeye(2), sigmaz()). np.testing.assert_almost_equal(expect(sz1, two_spins), 1). np.testing.assert_almost_equal(expect(sz2, two_spins), -1). .. _states-super:. Superoperators and Vectorized Operators; =======================================. In addition to state vectors and density operators, QuTiP allows for; representing maps that act linearly on density operators using the Kraus,; Liouville supermatrix and Choi matrix formalisms. This support is based on the; correspondence between linear operators acting on a Hilbert space, and vectors; in two copies of that Hilbert space,; :math:`\mathrm{vec} : \mathcal{L}(\mathcal{H}) \to \mathcal{H} \otimes \mathcal{H}`; [Hav03]_, [Wat13]_. This isomorphism is implemented in QuTiP by the; :obj:`.operator_to_vector` and; :obj:`.vector_to_operator` functions:. .. testcode:: [states]. psi = basis(2, 0). rho = ket2dm(psi). print(rho). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = ",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:25109,Testability,test,testing,25109," are complex numbers. This is because the :func:`.expect` function looks to see whether the operator is Hermitian or not. If the operator is Hermitian, then the output will always be real. In the case of non-Hermitian operators, the return values may be complex. Therefore, the :func:`.expect` function will return an array of complex values for non-Hermitian operators when the input is a list/array of states or density matrices. Of course, the :func:`.expect` function works for spin states and operators:. .. testcode:: [states]. up = basis(2, 0). down = basis(2, 1). np.testing.assert_almost_equal(expect(sigmaz(), up), 1). np.testing.assert_almost_equal(expect(sigmaz(), down), -1). as well as the composite objects discussed in the next section :ref:`tensor`:. .. testcode:: [states]. spin1 = basis(2, 0). spin2 = basis(2, 1). two_spins = tensor(spin1, spin2). sz1 = tensor(sigmaz(), qeye(2)). sz2 = tensor(qeye(2), sigmaz()). np.testing.assert_almost_equal(expect(sz1, two_spins), 1). np.testing.assert_almost_equal(expect(sz2, two_spins), -1). .. _states-super:. Superoperators and Vectorized Operators; =======================================. In addition to state vectors and density operators, QuTiP allows for; representing maps that act linearly on density operators using the Kraus,; Liouville supermatrix and Choi matrix formalisms. This support is based on the; correspondence between linear operators acting on a Hilbert space, and vectors; in two copies of that Hilbert space,; :math:`\mathrm{vec} : \mathcal{L}(\mathcal{H}) \to \mathcal{H} \otimes \mathcal{H}`; [Hav03]_, [Wat13]_. This isomorphism is implemented in QuTiP by the; :obj:`.operator_to_vector` and; :obj:`.vector_to_operator` functions:. .. testcode:: [states]. psi = basis(2, 0). rho = ket2dm(psi). print(rho). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[1. 0.]; [0. 0.]]. .. testcode:: [state",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:25838,Testability,test,testcode,25838," the next section :ref:`tensor`:. .. testcode:: [states]. spin1 = basis(2, 0). spin2 = basis(2, 1). two_spins = tensor(spin1, spin2). sz1 = tensor(sigmaz(), qeye(2)). sz2 = tensor(qeye(2), sigmaz()). np.testing.assert_almost_equal(expect(sz1, two_spins), 1). np.testing.assert_almost_equal(expect(sz2, two_spins), -1). .. _states-super:. Superoperators and Vectorized Operators; =======================================. In addition to state vectors and density operators, QuTiP allows for; representing maps that act linearly on density operators using the Kraus,; Liouville supermatrix and Choi matrix formalisms. This support is based on the; correspondence between linear operators acting on a Hilbert space, and vectors; in two copies of that Hilbert space,; :math:`\mathrm{vec} : \mathcal{L}(\mathcal{H}) \to \mathcal{H} \otimes \mathcal{H}`; [Hav03]_, [Wat13]_. This isomorphism is implemented in QuTiP by the; :obj:`.operator_to_vector` and; :obj:`.vector_to_operator` functions:. .. testcode:: [states]. psi = basis(2, 0). rho = ket2dm(psi). print(rho). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[1. 0.]; [0. 0.]]. .. testcode:: [states]. vec_rho = operator_to_vector(rho). print(vec_rho). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [1]], shape = (4, 1), type = operator-ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]]. .. testcode:: [states]. rho2 = vector_to_operator(vec_rho). np.testing.assert_almost_equal((rho - rho2).norm(), 0). The :attr:`.Qobj.type` attribute indicates whether a quantum object is; a vector corresponding to an operator (``operator-ket``), or its Hermitian; conjugate (``operator-bra``). Note that QuTiP uses the *column-stacking* convention for the isomorphism; between :math:`\mathcal{L}(\mathcal{H})` and :math:`\mathcal{H} \otimes \mathcal{H}`:. .. testcode:: [states]. A = Qobj(n",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:25925,Testability,test,testoutput,25925,"pins = tensor(spin1, spin2). sz1 = tensor(sigmaz(), qeye(2)). sz2 = tensor(qeye(2), sigmaz()). np.testing.assert_almost_equal(expect(sz1, two_spins), 1). np.testing.assert_almost_equal(expect(sz2, two_spins), -1). .. _states-super:. Superoperators and Vectorized Operators; =======================================. In addition to state vectors and density operators, QuTiP allows for; representing maps that act linearly on density operators using the Kraus,; Liouville supermatrix and Choi matrix formalisms. This support is based on the; correspondence between linear operators acting on a Hilbert space, and vectors; in two copies of that Hilbert space,; :math:`\mathrm{vec} : \mathcal{L}(\mathcal{H}) \to \mathcal{H} \otimes \mathcal{H}`; [Hav03]_, [Wat13]_. This isomorphism is implemented in QuTiP by the; :obj:`.operator_to_vector` and; :obj:`.vector_to_operator` functions:. .. testcode:: [states]. psi = basis(2, 0). rho = ket2dm(psi). print(rho). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[1. 0.]; [0. 0.]]. .. testcode:: [states]. vec_rho = operator_to_vector(rho). print(vec_rho). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [1]], shape = (4, 1), type = operator-ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]]. .. testcode:: [states]. rho2 = vector_to_operator(vec_rho). np.testing.assert_almost_equal((rho - rho2).norm(), 0). The :attr:`.Qobj.type` attribute indicates whether a quantum object is; a vector corresponding to an operator (``operator-ket``), or its Hermitian; conjugate (``operator-bra``). Note that QuTiP uses the *column-stacking* convention for the isomorphism; between :math:`\mathcal{L}(\mathcal{H})` and :math:`\mathcal{H} \otimes \mathcal{H}`:. .. testcode:: [states]. A = Qobj(np.arange(4).reshape((2, 2))). print(A). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHIT",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:26096,Testability,test,testcode,26096," np.testing.assert_almost_equal(expect(sz2, two_spins), -1). .. _states-super:. Superoperators and Vectorized Operators; =======================================. In addition to state vectors and density operators, QuTiP allows for; representing maps that act linearly on density operators using the Kraus,; Liouville supermatrix and Choi matrix formalisms. This support is based on the; correspondence between linear operators acting on a Hilbert space, and vectors; in two copies of that Hilbert space,; :math:`\mathrm{vec} : \mathcal{L}(\mathcal{H}) \to \mathcal{H} \otimes \mathcal{H}`; [Hav03]_, [Wat13]_. This isomorphism is implemented in QuTiP by the; :obj:`.operator_to_vector` and; :obj:`.vector_to_operator` functions:. .. testcode:: [states]. psi = basis(2, 0). rho = ket2dm(psi). print(rho). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[1. 0.]; [0. 0.]]. .. testcode:: [states]. vec_rho = operator_to_vector(rho). print(vec_rho). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [1]], shape = (4, 1), type = operator-ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]]. .. testcode:: [states]. rho2 = vector_to_operator(vec_rho). np.testing.assert_almost_equal((rho - rho2).norm(), 0). The :attr:`.Qobj.type` attribute indicates whether a quantum object is; a vector corresponding to an operator (``operator-ket``), or its Hermitian; conjugate (``operator-bra``). Note that QuTiP uses the *column-stacking* convention for the isomorphism; between :math:`\mathcal{L}(\mathcal{H})` and :math:`\mathcal{H} \otimes \mathcal{H}`:. .. testcode:: [states]. A = Qobj(np.arange(4).reshape((2, 2))). print(A). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = False; Qobj data =; [[0. 1.]; [2. 3.]]. .. testcode:: [states]. print(ope",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:26184,Testability,test,testoutput,26184,"zed Operators; =======================================. In addition to state vectors and density operators, QuTiP allows for; representing maps that act linearly on density operators using the Kraus,; Liouville supermatrix and Choi matrix formalisms. This support is based on the; correspondence between linear operators acting on a Hilbert space, and vectors; in two copies of that Hilbert space,; :math:`\mathrm{vec} : \mathcal{L}(\mathcal{H}) \to \mathcal{H} \otimes \mathcal{H}`; [Hav03]_, [Wat13]_. This isomorphism is implemented in QuTiP by the; :obj:`.operator_to_vector` and; :obj:`.vector_to_operator` functions:. .. testcode:: [states]. psi = basis(2, 0). rho = ket2dm(psi). print(rho). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[1. 0.]; [0. 0.]]. .. testcode:: [states]. vec_rho = operator_to_vector(rho). print(vec_rho). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [1]], shape = (4, 1), type = operator-ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]]. .. testcode:: [states]. rho2 = vector_to_operator(vec_rho). np.testing.assert_almost_equal((rho - rho2).norm(), 0). The :attr:`.Qobj.type` attribute indicates whether a quantum object is; a vector corresponding to an operator (``operator-ket``), or its Hermitian; conjugate (``operator-bra``). Note that QuTiP uses the *column-stacking* convention for the isomorphism; between :math:`\mathcal{L}(\mathcal{H})` and :math:`\mathcal{H} \otimes \mathcal{H}`:. .. testcode:: [states]. A = Qobj(np.arange(4).reshape((2, 2))). print(A). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = False; Qobj data =; [[0. 1.]; [2. 3.]]. .. testcode:: [states]. print(operator_to_vector(A)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum obje",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:26361,Testability,test,testcode,26361,"ly on density operators using the Kraus,; Liouville supermatrix and Choi matrix formalisms. This support is based on the; correspondence between linear operators acting on a Hilbert space, and vectors; in two copies of that Hilbert space,; :math:`\mathrm{vec} : \mathcal{L}(\mathcal{H}) \to \mathcal{H} \otimes \mathcal{H}`; [Hav03]_, [Wat13]_. This isomorphism is implemented in QuTiP by the; :obj:`.operator_to_vector` and; :obj:`.vector_to_operator` functions:. .. testcode:: [states]. psi = basis(2, 0). rho = ket2dm(psi). print(rho). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[1. 0.]; [0. 0.]]. .. testcode:: [states]. vec_rho = operator_to_vector(rho). print(vec_rho). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [1]], shape = (4, 1), type = operator-ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]]. .. testcode:: [states]. rho2 = vector_to_operator(vec_rho). np.testing.assert_almost_equal((rho - rho2).norm(), 0). The :attr:`.Qobj.type` attribute indicates whether a quantum object is; a vector corresponding to an operator (``operator-ket``), or its Hermitian; conjugate (``operator-bra``). Note that QuTiP uses the *column-stacking* convention for the isomorphism; between :math:`\mathcal{L}(\mathcal{H})` and :math:`\mathcal{H} \otimes \mathcal{H}`:. .. testcode:: [states]. A = Qobj(np.arange(4).reshape((2, 2))). print(A). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = False; Qobj data =; [[0. 1.]; [2. 3.]]. .. testcode:: [states]. print(operator_to_vector(A)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [1]], shape = (4, 1), type = operator-ket; Qobj data =; [[0.]; [2.]; [1.]; [3.]]. Since :math:`\mathcal{H} \otimes \mathcal{H}` is a vec",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:26421,Testability,test,testing,26421,"ermatrix and Choi matrix formalisms. This support is based on the; correspondence between linear operators acting on a Hilbert space, and vectors; in two copies of that Hilbert space,; :math:`\mathrm{vec} : \mathcal{L}(\mathcal{H}) \to \mathcal{H} \otimes \mathcal{H}`; [Hav03]_, [Wat13]_. This isomorphism is implemented in QuTiP by the; :obj:`.operator_to_vector` and; :obj:`.vector_to_operator` functions:. .. testcode:: [states]. psi = basis(2, 0). rho = ket2dm(psi). print(rho). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[1. 0.]; [0. 0.]]. .. testcode:: [states]. vec_rho = operator_to_vector(rho). print(vec_rho). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [1]], shape = (4, 1), type = operator-ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]]. .. testcode:: [states]. rho2 = vector_to_operator(vec_rho). np.testing.assert_almost_equal((rho - rho2).norm(), 0). The :attr:`.Qobj.type` attribute indicates whether a quantum object is; a vector corresponding to an operator (``operator-ket``), or its Hermitian; conjugate (``operator-bra``). Note that QuTiP uses the *column-stacking* convention for the isomorphism; between :math:`\mathcal{L}(\mathcal{H})` and :math:`\mathcal{H} \otimes \mathcal{H}`:. .. testcode:: [states]. A = Qobj(np.arange(4).reshape((2, 2))). print(A). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = False; Qobj data =; [[0. 1.]; [2. 3.]]. .. testcode:: [states]. print(operator_to_vector(A)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [1]], shape = (4, 1), type = operator-ket; Qobj data =; [[0.]; [2.]; [1.]; [3.]]. Since :math:`\mathcal{H} \otimes \mathcal{H}` is a vector space, linear maps; on this space can be represent",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:26817,Testability,test,testcode,26817,"ctions:. .. testcode:: [states]. psi = basis(2, 0). rho = ket2dm(psi). print(rho). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[1. 0.]; [0. 0.]]. .. testcode:: [states]. vec_rho = operator_to_vector(rho). print(vec_rho). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [1]], shape = (4, 1), type = operator-ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]]. .. testcode:: [states]. rho2 = vector_to_operator(vec_rho). np.testing.assert_almost_equal((rho - rho2).norm(), 0). The :attr:`.Qobj.type` attribute indicates whether a quantum object is; a vector corresponding to an operator (``operator-ket``), or its Hermitian; conjugate (``operator-bra``). Note that QuTiP uses the *column-stacking* convention for the isomorphism; between :math:`\mathcal{L}(\mathcal{H})` and :math:`\mathcal{H} \otimes \mathcal{H}`:. .. testcode:: [states]. A = Qobj(np.arange(4).reshape((2, 2))). print(A). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = False; Qobj data =; [[0. 1.]; [2. 3.]]. .. testcode:: [states]. print(operator_to_vector(A)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [1]], shape = (4, 1), type = operator-ket; Qobj data =; [[0.]; [2.]; [1.]; [3.]]. Since :math:`\mathcal{H} \otimes \mathcal{H}` is a vector space, linear maps; on this space can be represented as matrices, often called *superoperators*.; Using the :obj:`.Qobj`, the :obj:`.spre` and :obj:`.spost` functions, supermatrices; corresponding to left- and right-multiplication respectively can be quickly; constructed. .. testcode:: [states]. X = sigmax(). S = spre(X) * spost(X.dag()) # Represents conjugation by X. Note that this is done automatically by the :obj:`.to_super` function when given;",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:26904,Testability,test,testoutput,26904,"tput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[1. 0.]; [0. 0.]]. .. testcode:: [states]. vec_rho = operator_to_vector(rho). print(vec_rho). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [1]], shape = (4, 1), type = operator-ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]]. .. testcode:: [states]. rho2 = vector_to_operator(vec_rho). np.testing.assert_almost_equal((rho - rho2).norm(), 0). The :attr:`.Qobj.type` attribute indicates whether a quantum object is; a vector corresponding to an operator (``operator-ket``), or its Hermitian; conjugate (``operator-bra``). Note that QuTiP uses the *column-stacking* convention for the isomorphism; between :math:`\mathcal{L}(\mathcal{H})` and :math:`\mathcal{H} \otimes \mathcal{H}`:. .. testcode:: [states]. A = Qobj(np.arange(4).reshape((2, 2))). print(A). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = False; Qobj data =; [[0. 1.]; [2. 3.]]. .. testcode:: [states]. print(operator_to_vector(A)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [1]], shape = (4, 1), type = operator-ket; Qobj data =; [[0.]; [2.]; [1.]; [3.]]. Since :math:`\mathcal{H} \otimes \mathcal{H}` is a vector space, linear maps; on this space can be represented as matrices, often called *superoperators*.; Using the :obj:`.Qobj`, the :obj:`.spre` and :obj:`.spost` functions, supermatrices; corresponding to left- and right-multiplication respectively can be quickly; constructed. .. testcode:: [states]. X = sigmax(). S = spre(X) * spost(X.dag()) # Represents conjugation by X. Note that this is done automatically by the :obj:`.to_super` function when given; ``type='oper'`` input. .. testcode:: [states]. S2 = to_super(X). np.testing.assert_almost_equal((S - S2",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:27076,Testability,test,testcode,27076,". 0.]]. .. testcode:: [states]. vec_rho = operator_to_vector(rho). print(vec_rho). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [1]], shape = (4, 1), type = operator-ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]]. .. testcode:: [states]. rho2 = vector_to_operator(vec_rho). np.testing.assert_almost_equal((rho - rho2).norm(), 0). The :attr:`.Qobj.type` attribute indicates whether a quantum object is; a vector corresponding to an operator (``operator-ket``), or its Hermitian; conjugate (``operator-bra``). Note that QuTiP uses the *column-stacking* convention for the isomorphism; between :math:`\mathcal{L}(\mathcal{H})` and :math:`\mathcal{H} \otimes \mathcal{H}`:. .. testcode:: [states]. A = Qobj(np.arange(4).reshape((2, 2))). print(A). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = False; Qobj data =; [[0. 1.]; [2. 3.]]. .. testcode:: [states]. print(operator_to_vector(A)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [1]], shape = (4, 1), type = operator-ket; Qobj data =; [[0.]; [2.]; [1.]; [3.]]. Since :math:`\mathcal{H} \otimes \mathcal{H}` is a vector space, linear maps; on this space can be represented as matrices, often called *superoperators*.; Using the :obj:`.Qobj`, the :obj:`.spre` and :obj:`.spost` functions, supermatrices; corresponding to left- and right-multiplication respectively can be quickly; constructed. .. testcode:: [states]. X = sigmax(). S = spre(X) * spost(X.dag()) # Represents conjugation by X. Note that this is done automatically by the :obj:`.to_super` function when given; ``type='oper'`` input. .. testcode:: [states]. S2 = to_super(X). np.testing.assert_almost_equal((S - S2).norm(), 0). Quantum objects representing superoperators are denoted by ``type='super'``:. .. testcode:: [states]. print(S). **Output**:. .. testoutput:: ",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:27143,Testability,test,testoutput,27143,"Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [1]], shape = (4, 1), type = operator-ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]]. .. testcode:: [states]. rho2 = vector_to_operator(vec_rho). np.testing.assert_almost_equal((rho - rho2).norm(), 0). The :attr:`.Qobj.type` attribute indicates whether a quantum object is; a vector corresponding to an operator (``operator-ket``), or its Hermitian; conjugate (``operator-bra``). Note that QuTiP uses the *column-stacking* convention for the isomorphism; between :math:`\mathcal{L}(\mathcal{H})` and :math:`\mathcal{H} \otimes \mathcal{H}`:. .. testcode:: [states]. A = Qobj(np.arange(4).reshape((2, 2))). print(A). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = False; Qobj data =; [[0. 1.]; [2. 3.]]. .. testcode:: [states]. print(operator_to_vector(A)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [1]], shape = (4, 1), type = operator-ket; Qobj data =; [[0.]; [2.]; [1.]; [3.]]. Since :math:`\mathcal{H} \otimes \mathcal{H}` is a vector space, linear maps; on this space can be represented as matrices, often called *superoperators*.; Using the :obj:`.Qobj`, the :obj:`.spre` and :obj:`.spost` functions, supermatrices; corresponding to left- and right-multiplication respectively can be quickly; constructed. .. testcode:: [states]. X = sigmax(). S = spre(X) * spost(X.dag()) # Represents conjugation by X. Note that this is done automatically by the :obj:`.to_super` function when given; ``type='oper'`` input. .. testcode:: [states]. S2 = to_super(X). np.testing.assert_almost_equal((S - S2).norm(), 0). Quantum objects representing superoperators are denoted by ``type='super'``:. .. testcode:: [states]. print(S). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2],",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:27651,Testability,test,testcode,27651,"t QuTiP uses the *column-stacking* convention for the isomorphism; between :math:`\mathcal{L}(\mathcal{H})` and :math:`\mathcal{H} \otimes \mathcal{H}`:. .. testcode:: [states]. A = Qobj(np.arange(4).reshape((2, 2))). print(A). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = False; Qobj data =; [[0. 1.]; [2. 3.]]. .. testcode:: [states]. print(operator_to_vector(A)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [1]], shape = (4, 1), type = operator-ket; Qobj data =; [[0.]; [2.]; [1.]; [3.]]. Since :math:`\mathcal{H} \otimes \mathcal{H}` is a vector space, linear maps; on this space can be represented as matrices, often called *superoperators*.; Using the :obj:`.Qobj`, the :obj:`.spre` and :obj:`.spost` functions, supermatrices; corresponding to left- and right-multiplication respectively can be quickly; constructed. .. testcode:: [states]. X = sigmax(). S = spre(X) * spost(X.dag()) # Represents conjugation by X. Note that this is done automatically by the :obj:`.to_super` function when given; ``type='oper'`` input. .. testcode:: [states]. S2 = to_super(X). np.testing.assert_almost_equal((S - S2).norm(), 0). Quantum objects representing superoperators are denoted by ``type='super'``:. .. testcode:: [states]. print(S). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True; Qobj data =; [[0. 0. 0. 1.]; [0. 0. 1. 0.]; [0. 1. 0. 0.]; [1. 0. 0. 0.]]. Information about superoperators, such as whether they represent completely; positive maps, is exposed through the :attr:`.Qobj.iscp`, :attr:`.Qobj.istp`; and :attr:`.Qobj.iscptp` attributes:. .. testcode:: [states]. print(S.iscp, S.istp, S.iscptp). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. True True True. In addition, dynamical ge",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:27854,Testability,test,testcode,27854,"hape((2, 2))). print(A). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = False; Qobj data =; [[0. 1.]; [2. 3.]]. .. testcode:: [states]. print(operator_to_vector(A)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [1]], shape = (4, 1), type = operator-ket; Qobj data =; [[0.]; [2.]; [1.]; [3.]]. Since :math:`\mathcal{H} \otimes \mathcal{H}` is a vector space, linear maps; on this space can be represented as matrices, often called *superoperators*.; Using the :obj:`.Qobj`, the :obj:`.spre` and :obj:`.spost` functions, supermatrices; corresponding to left- and right-multiplication respectively can be quickly; constructed. .. testcode:: [states]. X = sigmax(). S = spre(X) * spost(X.dag()) # Represents conjugation by X. Note that this is done automatically by the :obj:`.to_super` function when given; ``type='oper'`` input. .. testcode:: [states]. S2 = to_super(X). np.testing.assert_almost_equal((S - S2).norm(), 0). Quantum objects representing superoperators are denoted by ``type='super'``:. .. testcode:: [states]. print(S). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True; Qobj data =; [[0. 0. 0. 1.]; [0. 0. 1. 0.]; [0. 1. 0. 0.]; [1. 0. 0. 0.]]. Information about superoperators, such as whether they represent completely; positive maps, is exposed through the :attr:`.Qobj.iscp`, :attr:`.Qobj.istp`; and :attr:`.Qobj.iscptp` attributes:. .. testcode:: [states]. print(S.iscp, S.istp, S.iscptp). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. True True True. In addition, dynamical generators on this extended space, often called; *Liouvillian superoperators*, can be created using the :func:`.liouvillian` function. Each of these takes a Hamiltonian along with; a list of collapse opera",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:27896,Testability,test,testing,27896," .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = False; Qobj data =; [[0. 1.]; [2. 3.]]. .. testcode:: [states]. print(operator_to_vector(A)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [1]], shape = (4, 1), type = operator-ket; Qobj data =; [[0.]; [2.]; [1.]; [3.]]. Since :math:`\mathcal{H} \otimes \mathcal{H}` is a vector space, linear maps; on this space can be represented as matrices, often called *superoperators*.; Using the :obj:`.Qobj`, the :obj:`.spre` and :obj:`.spost` functions, supermatrices; corresponding to left- and right-multiplication respectively can be quickly; constructed. .. testcode:: [states]. X = sigmax(). S = spre(X) * spost(X.dag()) # Represents conjugation by X. Note that this is done automatically by the :obj:`.to_super` function when given; ``type='oper'`` input. .. testcode:: [states]. S2 = to_super(X). np.testing.assert_almost_equal((S - S2).norm(), 0). Quantum objects representing superoperators are denoted by ``type='super'``:. .. testcode:: [states]. print(S). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True; Qobj data =; [[0. 0. 0. 1.]; [0. 0. 1. 0.]; [0. 1. 0. 0.]; [1. 0. 0. 0.]]. Information about superoperators, such as whether they represent completely; positive maps, is exposed through the :attr:`.Qobj.iscp`, :attr:`.Qobj.istp`; and :attr:`.Qobj.iscptp` attributes:. .. testcode:: [states]. print(S.iscp, S.istp, S.iscptp). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. True True True. In addition, dynamical generators on this extended space, often called; *Liouvillian superoperators*, can be created using the :func:`.liouvillian` function. Each of these takes a Hamiltonian along with; a list of collapse operators, and returns a ``type=""super""``",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:28026,Testability,test,testcode,28026,"lse; Qobj data =; [[0. 1.]; [2. 3.]]. .. testcode:: [states]. print(operator_to_vector(A)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [1]], shape = (4, 1), type = operator-ket; Qobj data =; [[0.]; [2.]; [1.]; [3.]]. Since :math:`\mathcal{H} \otimes \mathcal{H}` is a vector space, linear maps; on this space can be represented as matrices, often called *superoperators*.; Using the :obj:`.Qobj`, the :obj:`.spre` and :obj:`.spost` functions, supermatrices; corresponding to left- and right-multiplication respectively can be quickly; constructed. .. testcode:: [states]. X = sigmax(). S = spre(X) * spost(X.dag()) # Represents conjugation by X. Note that this is done automatically by the :obj:`.to_super` function when given; ``type='oper'`` input. .. testcode:: [states]. S2 = to_super(X). np.testing.assert_almost_equal((S - S2).norm(), 0). Quantum objects representing superoperators are denoted by ``type='super'``:. .. testcode:: [states]. print(S). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True; Qobj data =; [[0. 0. 0. 1.]; [0. 0. 1. 0.]; [0. 1. 0. 0.]; [1. 0. 0. 0.]]. Information about superoperators, such as whether they represent completely; positive maps, is exposed through the :attr:`.Qobj.iscp`, :attr:`.Qobj.istp`; and :attr:`.Qobj.iscptp` attributes:. .. testcode:: [states]. print(S.iscp, S.istp, S.iscptp). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. True True True. In addition, dynamical generators on this extended space, often called; *Liouvillian superoperators*, can be created using the :func:`.liouvillian` function. Each of these takes a Hamiltonian along with; a list of collapse operators, and returns a ``type=""super""`` object that can; be exponentiated to find the superoperator for that evolution. .. testcode:: [states]. H = 10 * sigmaz(). c1 = destroy",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:28073,Testability,test,testoutput,28073,"nt(operator_to_vector(A)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [1]], shape = (4, 1), type = operator-ket; Qobj data =; [[0.]; [2.]; [1.]; [3.]]. Since :math:`\mathcal{H} \otimes \mathcal{H}` is a vector space, linear maps; on this space can be represented as matrices, often called *superoperators*.; Using the :obj:`.Qobj`, the :obj:`.spre` and :obj:`.spost` functions, supermatrices; corresponding to left- and right-multiplication respectively can be quickly; constructed. .. testcode:: [states]. X = sigmax(). S = spre(X) * spost(X.dag()) # Represents conjugation by X. Note that this is done automatically by the :obj:`.to_super` function when given; ``type='oper'`` input. .. testcode:: [states]. S2 = to_super(X). np.testing.assert_almost_equal((S - S2).norm(), 0). Quantum objects representing superoperators are denoted by ``type='super'``:. .. testcode:: [states]. print(S). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True; Qobj data =; [[0. 0. 0. 1.]; [0. 0. 1. 0.]; [0. 1. 0. 0.]; [1. 0. 0. 0.]]. Information about superoperators, such as whether they represent completely; positive maps, is exposed through the :attr:`.Qobj.iscp`, :attr:`.Qobj.istp`; and :attr:`.Qobj.iscptp` attributes:. .. testcode:: [states]. print(S.iscp, S.istp, S.iscptp). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. True True True. In addition, dynamical generators on this extended space, often called; *Liouvillian superoperators*, can be created using the :func:`.liouvillian` function. Each of these takes a Hamiltonian along with; a list of collapse operators, and returns a ``type=""super""`` object that can; be exponentiated to find the superoperator for that evolution. .. testcode:: [states]. H = 10 * sigmaz(). c1 = destroy(2). L = liouvillian(H, [c1]). print(L). S = (12 * L).expm(). **",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:28494,Testability,test,testcode,28494,"bj:`.spre` and :obj:`.spost` functions, supermatrices; corresponding to left- and right-multiplication respectively can be quickly; constructed. .. testcode:: [states]. X = sigmax(). S = spre(X) * spost(X.dag()) # Represents conjugation by X. Note that this is done automatically by the :obj:`.to_super` function when given; ``type='oper'`` input. .. testcode:: [states]. S2 = to_super(X). np.testing.assert_almost_equal((S - S2).norm(), 0). Quantum objects representing superoperators are denoted by ``type='super'``:. .. testcode:: [states]. print(S). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True; Qobj data =; [[0. 0. 0. 1.]; [0. 0. 1. 0.]; [0. 1. 0. 0.]; [1. 0. 0. 0.]]. Information about superoperators, such as whether they represent completely; positive maps, is exposed through the :attr:`.Qobj.iscp`, :attr:`.Qobj.istp`; and :attr:`.Qobj.iscptp` attributes:. .. testcode:: [states]. print(S.iscp, S.istp, S.iscptp). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. True True True. In addition, dynamical generators on this extended space, often called; *Liouvillian superoperators*, can be created using the :func:`.liouvillian` function. Each of these takes a Hamiltonian along with; a list of collapse operators, and returns a ``type=""super""`` object that can; be exponentiated to find the superoperator for that evolution. .. testcode:: [states]. H = 10 * sigmaz(). c1 = destroy(2). L = liouvillian(H, [c1]). print(L). S = (12 * L).expm(). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = False; Qobj data =; [[ 0. +0.j 0. +0.j 0. +0.j 1. +0.j]; [ 0. +0.j -0.5+20.j 0. +0.j 0. +0.j]; [ 0. +0.j 0. +0.j -0.5-20.j 0. +0.j]; [ 0. +0.j 0. +0.j 0. +0.j -1. +0.j]]. For qubits, a particularly useful way to visualize superoperators is to plo",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:28564,Testability,test,testoutput,28564,"multiplication respectively can be quickly; constructed. .. testcode:: [states]. X = sigmax(). S = spre(X) * spost(X.dag()) # Represents conjugation by X. Note that this is done automatically by the :obj:`.to_super` function when given; ``type='oper'`` input. .. testcode:: [states]. S2 = to_super(X). np.testing.assert_almost_equal((S - S2).norm(), 0). Quantum objects representing superoperators are denoted by ``type='super'``:. .. testcode:: [states]. print(S). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True; Qobj data =; [[0. 0. 0. 1.]; [0. 0. 1. 0.]; [0. 1. 0. 0.]; [1. 0. 0. 0.]]. Information about superoperators, such as whether they represent completely; positive maps, is exposed through the :attr:`.Qobj.iscp`, :attr:`.Qobj.istp`; and :attr:`.Qobj.iscptp` attributes:. .. testcode:: [states]. print(S.iscp, S.istp, S.iscptp). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. True True True. In addition, dynamical generators on this extended space, often called; *Liouvillian superoperators*, can be created using the :func:`.liouvillian` function. Each of these takes a Hamiltonian along with; a list of collapse operators, and returns a ``type=""super""`` object that can; be exponentiated to find the superoperator for that evolution. .. testcode:: [states]. H = 10 * sigmaz(). c1 = destroy(2). L = liouvillian(H, [c1]). print(L). S = (12 * L).expm(). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = False; Qobj data =; [[ 0. +0.j 0. +0.j 0. +0.j 1. +0.j]; [ 0. +0.j -0.5+20.j 0. +0.j 0. +0.j]; [ 0. +0.j 0. +0.j -0.5-20.j 0. +0.j]; [ 0. +0.j 0. +0.j 0. +0.j -1. +0.j]]. For qubits, a particularly useful way to visualize superoperators is to plot them in the Pauli basis,; such that :math:`S_{\mu,\nu} = \langle\!\langle \sigma_{\mu",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:28984,Testability,test,testcode,28984,"denoted by ``type='super'``:. .. testcode:: [states]. print(S). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True; Qobj data =; [[0. 0. 0. 1.]; [0. 0. 1. 0.]; [0. 1. 0. 0.]; [1. 0. 0. 0.]]. Information about superoperators, such as whether they represent completely; positive maps, is exposed through the :attr:`.Qobj.iscp`, :attr:`.Qobj.istp`; and :attr:`.Qobj.iscptp` attributes:. .. testcode:: [states]. print(S.iscp, S.istp, S.iscptp). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. True True True. In addition, dynamical generators on this extended space, often called; *Liouvillian superoperators*, can be created using the :func:`.liouvillian` function. Each of these takes a Hamiltonian along with; a list of collapse operators, and returns a ``type=""super""`` object that can; be exponentiated to find the superoperator for that evolution. .. testcode:: [states]. H = 10 * sigmaz(). c1 = destroy(2). L = liouvillian(H, [c1]). print(L). S = (12 * L).expm(). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = False; Qobj data =; [[ 0. +0.j 0. +0.j 0. +0.j 1. +0.j]; [ 0. +0.j -0.5+20.j 0. +0.j 0. +0.j]; [ 0. +0.j 0. +0.j -0.5-20.j 0. +0.j]; [ 0. +0.j 0. +0.j 0. +0.j -1. +0.j]]. For qubits, a particularly useful way to visualize superoperators is to plot them in the Pauli basis,; such that :math:`S_{\mu,\nu} = \langle\!\langle \sigma_{\mu} | S[\sigma_{\nu}] \rangle\!\rangle`. Because; the Pauli basis is Hermitian, :math:`S_{\mu,\nu}` is a real number for all Hermitian-preserving superoperators; :math:`S`,; allowing us to plot the elements of :math:`S` as a `Hinton diagram <https://matplotlib.org/examples/specialty_plots/hinton_demo.html>`_. In such diagrams, positive elements are indicated by white squares, and negative elements; by ",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:29114,Testability,test,testoutput,29114,"ct: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True; Qobj data =; [[0. 0. 0. 1.]; [0. 0. 1. 0.]; [0. 1. 0. 0.]; [1. 0. 0. 0.]]. Information about superoperators, such as whether they represent completely; positive maps, is exposed through the :attr:`.Qobj.iscp`, :attr:`.Qobj.istp`; and :attr:`.Qobj.iscptp` attributes:. .. testcode:: [states]. print(S.iscp, S.istp, S.iscptp). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. True True True. In addition, dynamical generators on this extended space, often called; *Liouvillian superoperators*, can be created using the :func:`.liouvillian` function. Each of these takes a Hamiltonian along with; a list of collapse operators, and returns a ``type=""super""`` object that can; be exponentiated to find the superoperator for that evolution. .. testcode:: [states]. H = 10 * sigmaz(). c1 = destroy(2). L = liouvillian(H, [c1]). print(L). S = (12 * L).expm(). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = False; Qobj data =; [[ 0. +0.j 0. +0.j 0. +0.j 1. +0.j]; [ 0. +0.j -0.5+20.j 0. +0.j 0. +0.j]; [ 0. +0.j 0. +0.j -0.5-20.j 0. +0.j]; [ 0. +0.j 0. +0.j 0. +0.j -1. +0.j]]. For qubits, a particularly useful way to visualize superoperators is to plot them in the Pauli basis,; such that :math:`S_{\mu,\nu} = \langle\!\langle \sigma_{\mu} | S[\sigma_{\nu}] \rangle\!\rangle`. Because; the Pauli basis is Hermitian, :math:`S_{\mu,\nu}` is a real number for all Hermitian-preserving superoperators; :math:`S`,; allowing us to plot the elements of :math:`S` as a `Hinton diagram <https://matplotlib.org/examples/specialty_plots/hinton_demo.html>`_. In such diagrams, positive elements are indicated by white squares, and negative elements; by black squares. The size of each element is indicated by the size of the corresponding square. For instance,; let :math:`S[\rho] = \sigma_x \rho \si",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:31416,Testability,test,testcode,31416,"rt *; settings.colorblind_safe = True. import matplotlib.pyplot as plt; plt.rcParams['savefig.transparent'] = True. X = sigmax(); S = spre(X) * spost(X.dag()). hinton(S). Choi, Kraus, Stinespring and :math:`\chi` Representations; =========================================================. In addition to the superoperator representation of quantum maps, QuTiP; supports several other useful representations. First, the Choi matrix; :math:`J(\Lambda)` of a quantum map :math:`\Lambda` is useful for working with; ancilla-assisted process tomography (AAPT), and for reasoning about properties; of a map or channel. Up to normalization, the Choi matrix is defined by acting; :math:`\Lambda` on half of an entangled pair. In the column-stacking; convention,. .. math::. J(\Lambda) = (\mathbb{1} \otimes \Lambda) [|\mathbb{1}\rangle\!\rangle \langle\!\langle \mathbb{1}|]. In QuTiP, :math:`J(\Lambda)` can be found by calling the :func:`.to_choi`; function on a ``type=""super""`` :obj:`.Qobj`. .. testcode:: [states]. X = sigmax(). S = sprepost(X, X). J = to_choi(S). print(J). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True, superrep = choi; Qobj data =; [[0. 0. 0. 0.]; [0. 1. 1. 0.]; [0. 1. 1. 0.]; [0. 0. 0. 0.]]. .. testcode:: [states]. print(to_choi(spre(qeye(2)))). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True, superrep = choi; Qobj data =; [[1. 0. 0. 1.]; [0. 0. 0. 0.]; [0. 0. 0. 0.]; [1. 0. 0. 1.]]. If a :obj:`.Qobj` instance is already in the Choi :attr:`.Qobj.superrep`, then calling :func:`.to_choi`; does nothing:. .. testcode:: [states]. print(to_choi(J)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True, superrep = choi; Qobj data =;",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:31513,Testability,test,testoutput,31513," X = sigmax(); S = spre(X) * spost(X.dag()). hinton(S). Choi, Kraus, Stinespring and :math:`\chi` Representations; =========================================================. In addition to the superoperator representation of quantum maps, QuTiP; supports several other useful representations. First, the Choi matrix; :math:`J(\Lambda)` of a quantum map :math:`\Lambda` is useful for working with; ancilla-assisted process tomography (AAPT), and for reasoning about properties; of a map or channel. Up to normalization, the Choi matrix is defined by acting; :math:`\Lambda` on half of an entangled pair. In the column-stacking; convention,. .. math::. J(\Lambda) = (\mathbb{1} \otimes \Lambda) [|\mathbb{1}\rangle\!\rangle \langle\!\langle \mathbb{1}|]. In QuTiP, :math:`J(\Lambda)` can be found by calling the :func:`.to_choi`; function on a ``type=""super""`` :obj:`.Qobj`. .. testcode:: [states]. X = sigmax(). S = sprepost(X, X). J = to_choi(S). print(J). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True, superrep = choi; Qobj data =; [[0. 0. 0. 0.]; [0. 1. 1. 0.]; [0. 1. 1. 0.]; [0. 0. 0. 0.]]. .. testcode:: [states]. print(to_choi(spre(qeye(2)))). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True, superrep = choi; Qobj data =; [[1. 0. 0. 1.]; [0. 0. 0. 0.]; [0. 0. 0. 0.]; [1. 0. 0. 1.]]. If a :obj:`.Qobj` instance is already in the Choi :attr:`.Qobj.superrep`, then calling :func:`.to_choi`; does nothing:. .. testcode:: [states]. print(to_choi(J)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True, superrep = choi; Qobj data =; [[0. 0. 0. 0.]; [0. 1. 1. 0.]; [0. 1. 1. 0.]; [0. 0. 0. 0.]]. To get back to the superoperator representation, si",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:31758,Testability,test,testcode,31758,"antum maps, QuTiP; supports several other useful representations. First, the Choi matrix; :math:`J(\Lambda)` of a quantum map :math:`\Lambda` is useful for working with; ancilla-assisted process tomography (AAPT), and for reasoning about properties; of a map or channel. Up to normalization, the Choi matrix is defined by acting; :math:`\Lambda` on half of an entangled pair. In the column-stacking; convention,. .. math::. J(\Lambda) = (\mathbb{1} \otimes \Lambda) [|\mathbb{1}\rangle\!\rangle \langle\!\langle \mathbb{1}|]. In QuTiP, :math:`J(\Lambda)` can be found by calling the :func:`.to_choi`; function on a ``type=""super""`` :obj:`.Qobj`. .. testcode:: [states]. X = sigmax(). S = sprepost(X, X). J = to_choi(S). print(J). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True, superrep = choi; Qobj data =; [[0. 0. 0. 0.]; [0. 1. 1. 0.]; [0. 1. 1. 0.]; [0. 0. 0. 0.]]. .. testcode:: [states]. print(to_choi(spre(qeye(2)))). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True, superrep = choi; Qobj data =; [[1. 0. 0. 1.]; [0. 0. 0. 0.]; [0. 0. 0. 0.]; [1. 0. 0. 1.]]. If a :obj:`.Qobj` instance is already in the Choi :attr:`.Qobj.superrep`, then calling :func:`.to_choi`; does nothing:. .. testcode:: [states]. print(to_choi(J)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True, superrep = choi; Qobj data =; [[0. 0. 0. 0.]; [0. 1. 1. 0.]; [0. 1. 1. 0.]; [0. 0. 0. 0.]]. To get back to the superoperator representation, simply use the :func:`.to_super` function.; As with :func:`.to_choi`, :func:`.to_super` is idempotent:. .. testcode:: [states]. print(to_super(J) - S). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantu",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:31826,Testability,test,testoutput,31826,"ix; :math:`J(\Lambda)` of a quantum map :math:`\Lambda` is useful for working with; ancilla-assisted process tomography (AAPT), and for reasoning about properties; of a map or channel. Up to normalization, the Choi matrix is defined by acting; :math:`\Lambda` on half of an entangled pair. In the column-stacking; convention,. .. math::. J(\Lambda) = (\mathbb{1} \otimes \Lambda) [|\mathbb{1}\rangle\!\rangle \langle\!\langle \mathbb{1}|]. In QuTiP, :math:`J(\Lambda)` can be found by calling the :func:`.to_choi`; function on a ``type=""super""`` :obj:`.Qobj`. .. testcode:: [states]. X = sigmax(). S = sprepost(X, X). J = to_choi(S). print(J). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True, superrep = choi; Qobj data =; [[0. 0. 0. 0.]; [0. 1. 1. 0.]; [0. 1. 1. 0.]; [0. 0. 0. 0.]]. .. testcode:: [states]. print(to_choi(spre(qeye(2)))). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True, superrep = choi; Qobj data =; [[1. 0. 0. 1.]; [0. 0. 0. 0.]; [0. 0. 0. 0.]; [1. 0. 0. 1.]]. If a :obj:`.Qobj` instance is already in the Choi :attr:`.Qobj.superrep`, then calling :func:`.to_choi`; does nothing:. .. testcode:: [states]. print(to_choi(J)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True, superrep = choi; Qobj data =; [[0. 0. 0. 0.]; [0. 1. 1. 0.]; [0. 1. 1. 0.]; [0. 0. 0. 0.]]. To get back to the superoperator representation, simply use the :func:`.to_super` function.; As with :func:`.to_choi`, :func:`.to_super` is idempotent:. .. testcode:: [states]. print(to_super(J) - S). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = Tru",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:32191,Testability,test,testcode,32191,") = (\mathbb{1} \otimes \Lambda) [|\mathbb{1}\rangle\!\rangle \langle\!\langle \mathbb{1}|]. In QuTiP, :math:`J(\Lambda)` can be found by calling the :func:`.to_choi`; function on a ``type=""super""`` :obj:`.Qobj`. .. testcode:: [states]. X = sigmax(). S = sprepost(X, X). J = to_choi(S). print(J). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True, superrep = choi; Qobj data =; [[0. 0. 0. 0.]; [0. 1. 1. 0.]; [0. 1. 1. 0.]; [0. 0. 0. 0.]]. .. testcode:: [states]. print(to_choi(spre(qeye(2)))). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True, superrep = choi; Qobj data =; [[1. 0. 0. 1.]; [0. 0. 0. 0.]; [0. 0. 0. 0.]; [1. 0. 0. 1.]]. If a :obj:`.Qobj` instance is already in the Choi :attr:`.Qobj.superrep`, then calling :func:`.to_choi`; does nothing:. .. testcode:: [states]. print(to_choi(J)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True, superrep = choi; Qobj data =; [[0. 0. 0. 0.]; [0. 1. 1. 0.]; [0. 1. 1. 0.]; [0. 0. 0. 0.]]. To get back to the superoperator representation, simply use the :func:`.to_super` function.; As with :func:`.to_choi`, :func:`.to_super` is idempotent:. .. testcode:: [states]. print(to_super(J) - S). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True; Qobj data =; [[0. 0. 0. 0.]; [0. 0. 0. 0.]; [0. 0. 0. 0.]; [0. 0. 0. 0.]]. .. testcode:: [states]. print(to_super(S)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True; Qobj data =; [[0. 0. 0. 1.]; [0. 0. 1. 0.]; [0. 1. 0. 0.]; [",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:32247,Testability,test,testoutput,32247,"ngle \mathbb{1}|]. In QuTiP, :math:`J(\Lambda)` can be found by calling the :func:`.to_choi`; function on a ``type=""super""`` :obj:`.Qobj`. .. testcode:: [states]. X = sigmax(). S = sprepost(X, X). J = to_choi(S). print(J). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True, superrep = choi; Qobj data =; [[0. 0. 0. 0.]; [0. 1. 1. 0.]; [0. 1. 1. 0.]; [0. 0. 0. 0.]]. .. testcode:: [states]. print(to_choi(spre(qeye(2)))). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True, superrep = choi; Qobj data =; [[1. 0. 0. 1.]; [0. 0. 0. 0.]; [0. 0. 0. 0.]; [1. 0. 0. 1.]]. If a :obj:`.Qobj` instance is already in the Choi :attr:`.Qobj.superrep`, then calling :func:`.to_choi`; does nothing:. .. testcode:: [states]. print(to_choi(J)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True, superrep = choi; Qobj data =; [[0. 0. 0. 0.]; [0. 1. 1. 0.]; [0. 1. 1. 0.]; [0. 0. 0. 0.]]. To get back to the superoperator representation, simply use the :func:`.to_super` function.; As with :func:`.to_choi`, :func:`.to_super` is idempotent:. .. testcode:: [states]. print(to_super(J) - S). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True; Qobj data =; [[0. 0. 0. 0.]; [0. 0. 0. 0.]; [0. 0. 0. 0.]; [0. 0. 0. 0.]]. .. testcode:: [states]. print(to_super(S)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True; Qobj data =; [[0. 0. 0. 1.]; [0. 0. 1. 0.]; [0. 1. 0. 0.]; [1. 0. 0. 0.]]. We can quickly obtain another useful representation from t",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:32645,Testability,test,testcode,32645," = True, superrep = choi; Qobj data =; [[0. 0. 0. 0.]; [0. 1. 1. 0.]; [0. 1. 1. 0.]; [0. 0. 0. 0.]]. .. testcode:: [states]. print(to_choi(spre(qeye(2)))). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True, superrep = choi; Qobj data =; [[1. 0. 0. 1.]; [0. 0. 0. 0.]; [0. 0. 0. 0.]; [1. 0. 0. 1.]]. If a :obj:`.Qobj` instance is already in the Choi :attr:`.Qobj.superrep`, then calling :func:`.to_choi`; does nothing:. .. testcode:: [states]. print(to_choi(J)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True, superrep = choi; Qobj data =; [[0. 0. 0. 0.]; [0. 1. 1. 0.]; [0. 1. 1. 0.]; [0. 0. 0. 0.]]. To get back to the superoperator representation, simply use the :func:`.to_super` function.; As with :func:`.to_choi`, :func:`.to_super` is idempotent:. .. testcode:: [states]. print(to_super(J) - S). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True; Qobj data =; [[0. 0. 0. 0.]; [0. 0. 0. 0.]; [0. 0. 0. 0.]; [0. 0. 0. 0.]]. .. testcode:: [states]. print(to_super(S)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True; Qobj data =; [[0. 0. 0. 1.]; [0. 0. 1. 0.]; [0. 1. 0. 0.]; [1. 0. 0. 0.]]. We can quickly obtain another useful representation from the Choi matrix by taking its eigendecomposition.; In particular, let :math:`\{A_i\}` be a set of operators such that; :math:`J(\Lambda) = \sum_i |A_i\rangle\!\rangle \langle\!\langle A_i|`.; We can write :math:`J(\Lambda)` in this way; for any hermicity-preserving map; that is, for any map :math:`\Lambda` such that :math:`J(\Lambda) = J^\dagger(\Lambda)`.; These operators then f",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:32706,Testability,test,testoutput,32706," 0.]; [0. 0. 0. 0.]]. .. testcode:: [states]. print(to_choi(spre(qeye(2)))). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True, superrep = choi; Qobj data =; [[1. 0. 0. 1.]; [0. 0. 0. 0.]; [0. 0. 0. 0.]; [1. 0. 0. 1.]]. If a :obj:`.Qobj` instance is already in the Choi :attr:`.Qobj.superrep`, then calling :func:`.to_choi`; does nothing:. .. testcode:: [states]. print(to_choi(J)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True, superrep = choi; Qobj data =; [[0. 0. 0. 0.]; [0. 1. 1. 0.]; [0. 1. 1. 0.]; [0. 0. 0. 0.]]. To get back to the superoperator representation, simply use the :func:`.to_super` function.; As with :func:`.to_choi`, :func:`.to_super` is idempotent:. .. testcode:: [states]. print(to_super(J) - S). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True; Qobj data =; [[0. 0. 0. 0.]; [0. 0. 0. 0.]; [0. 0. 0. 0.]; [0. 0. 0. 0.]]. .. testcode:: [states]. print(to_super(S)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True; Qobj data =; [[0. 0. 0. 1.]; [0. 0. 1. 0.]; [0. 1. 0. 0.]; [1. 0. 0. 0.]]. We can quickly obtain another useful representation from the Choi matrix by taking its eigendecomposition.; In particular, let :math:`\{A_i\}` be a set of operators such that; :math:`J(\Lambda) = \sum_i |A_i\rangle\!\rangle \langle\!\langle A_i|`.; We can write :math:`J(\Lambda)` in this way; for any hermicity-preserving map; that is, for any map :math:`\Lambda` such that :math:`J(\Lambda) = J^\dagger(\Lambda)`.; These operators then form the Kraus representation of :math:`\Lambda`. In particular, for any input ",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:32934,Testability,test,testcode,32934,"4), type = super, isherm = True, superrep = choi; Qobj data =; [[1. 0. 0. 1.]; [0. 0. 0. 0.]; [0. 0. 0. 0.]; [1. 0. 0. 1.]]. If a :obj:`.Qobj` instance is already in the Choi :attr:`.Qobj.superrep`, then calling :func:`.to_choi`; does nothing:. .. testcode:: [states]. print(to_choi(J)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True, superrep = choi; Qobj data =; [[0. 0. 0. 0.]; [0. 1. 1. 0.]; [0. 1. 1. 0.]; [0. 0. 0. 0.]]. To get back to the superoperator representation, simply use the :func:`.to_super` function.; As with :func:`.to_choi`, :func:`.to_super` is idempotent:. .. testcode:: [states]. print(to_super(J) - S). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True; Qobj data =; [[0. 0. 0. 0.]; [0. 0. 0. 0.]; [0. 0. 0. 0.]; [0. 0. 0. 0.]]. .. testcode:: [states]. print(to_super(S)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True; Qobj data =; [[0. 0. 0. 1.]; [0. 0. 1. 0.]; [0. 1. 0. 0.]; [1. 0. 0. 0.]]. We can quickly obtain another useful representation from the Choi matrix by taking its eigendecomposition.; In particular, let :math:`\{A_i\}` be a set of operators such that; :math:`J(\Lambda) = \sum_i |A_i\rangle\!\rangle \langle\!\langle A_i|`.; We can write :math:`J(\Lambda)` in this way; for any hermicity-preserving map; that is, for any map :math:`\Lambda` such that :math:`J(\Lambda) = J^\dagger(\Lambda)`.; These operators then form the Kraus representation of :math:`\Lambda`. In particular, for any input :math:`\rho`,. .. math::. \Lambda(\rho) = \sum_i A_i \rho A_i^\dagger. Notice using the column-stacking identity that :math:`(C^\mathrm{T} \otimes A) |B\rangle\!\rangle = |ABC\rangle\!\rangle`,; we have that. ..",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:32991,Testability,test,testoutput,32991,".]; [0. 0. 0. 0.]; [0. 0. 0. 0.]; [1. 0. 0. 1.]]. If a :obj:`.Qobj` instance is already in the Choi :attr:`.Qobj.superrep`, then calling :func:`.to_choi`; does nothing:. .. testcode:: [states]. print(to_choi(J)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True, superrep = choi; Qobj data =; [[0. 0. 0. 0.]; [0. 1. 1. 0.]; [0. 1. 1. 0.]; [0. 0. 0. 0.]]. To get back to the superoperator representation, simply use the :func:`.to_super` function.; As with :func:`.to_choi`, :func:`.to_super` is idempotent:. .. testcode:: [states]. print(to_super(J) - S). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True; Qobj data =; [[0. 0. 0. 0.]; [0. 0. 0. 0.]; [0. 0. 0. 0.]; [0. 0. 0. 0.]]. .. testcode:: [states]. print(to_super(S)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True; Qobj data =; [[0. 0. 0. 1.]; [0. 0. 1. 0.]; [0. 1. 0. 0.]; [1. 0. 0. 0.]]. We can quickly obtain another useful representation from the Choi matrix by taking its eigendecomposition.; In particular, let :math:`\{A_i\}` be a set of operators such that; :math:`J(\Lambda) = \sum_i |A_i\rangle\!\rangle \langle\!\langle A_i|`.; We can write :math:`J(\Lambda)` in this way; for any hermicity-preserving map; that is, for any map :math:`\Lambda` such that :math:`J(\Lambda) = J^\dagger(\Lambda)`.; These operators then form the Kraus representation of :math:`\Lambda`. In particular, for any input :math:`\rho`,. .. math::. \Lambda(\rho) = \sum_i A_i \rho A_i^\dagger. Notice using the column-stacking identity that :math:`(C^\mathrm{T} \otimes A) |B\rangle\!\rangle = |ABC\rangle\!\rangle`,; we have that. .. math::. \sum_i (\mathbb{1} \otimes A_i) (\mathbb{1} \otimes A_i)^\dagger ",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:34260,Testability,test,testcode,34260,"rom the Choi matrix by taking its eigendecomposition.; In particular, let :math:`\{A_i\}` be a set of operators such that; :math:`J(\Lambda) = \sum_i |A_i\rangle\!\rangle \langle\!\langle A_i|`.; We can write :math:`J(\Lambda)` in this way; for any hermicity-preserving map; that is, for any map :math:`\Lambda` such that :math:`J(\Lambda) = J^\dagger(\Lambda)`.; These operators then form the Kraus representation of :math:`\Lambda`. In particular, for any input :math:`\rho`,. .. math::. \Lambda(\rho) = \sum_i A_i \rho A_i^\dagger. Notice using the column-stacking identity that :math:`(C^\mathrm{T} \otimes A) |B\rangle\!\rangle = |ABC\rangle\!\rangle`,; we have that. .. math::. \sum_i (\mathbb{1} \otimes A_i) (\mathbb{1} \otimes A_i)^\dagger |\mathbb{1}\rangle\!\rangle \langle\!\langle\mathbb{1}|; = \sum_i |A_i\rangle\!\rangle \langle\!\langle A_i| = J(\Lambda). The Kraus representation of a hermicity-preserving map can be found in QuTiP; using the :func:`.to_kraus` function. .. testcode:: [states]. del sum # np.sum overwrote sum and caused a bug. .. testcode:: [states]. I, X, Y, Z = qeye(2), sigmax(), sigmay(), sigmaz(). .. testcode:: [states]. S = sum([sprepost(P, P) for P in (I, X, Y, Z)]) / 4; print(S). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True; Qobj data =; [[0.5 0. 0. 0.5]; [0. 0. 0. 0. ]; [0. 0. 0. 0. ]; [0.5 0. 0. 0.5]]. .. testcode:: [states]. J = to_choi(S); print(J). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True, superrep = choi; Qobj data =; [[0.5 0. 0. 0. ]; [0. 0.5 0. 0. ]; [0. 0. 0.5 0. ]; [0. 0. 0. 0.5]]. .. testcode:: [states]. print(J.eigenstates()[1]). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. [Quantum object: dims = [[[2], [2]], [1, 1]], shape = (4, 1), type = operator-ket; Qobj data",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:34333,Testability,test,testcode,34333," :math:`\{A_i\}` be a set of operators such that; :math:`J(\Lambda) = \sum_i |A_i\rangle\!\rangle \langle\!\langle A_i|`.; We can write :math:`J(\Lambda)` in this way; for any hermicity-preserving map; that is, for any map :math:`\Lambda` such that :math:`J(\Lambda) = J^\dagger(\Lambda)`.; These operators then form the Kraus representation of :math:`\Lambda`. In particular, for any input :math:`\rho`,. .. math::. \Lambda(\rho) = \sum_i A_i \rho A_i^\dagger. Notice using the column-stacking identity that :math:`(C^\mathrm{T} \otimes A) |B\rangle\!\rangle = |ABC\rangle\!\rangle`,; we have that. .. math::. \sum_i (\mathbb{1} \otimes A_i) (\mathbb{1} \otimes A_i)^\dagger |\mathbb{1}\rangle\!\rangle \langle\!\langle\mathbb{1}|; = \sum_i |A_i\rangle\!\rangle \langle\!\langle A_i| = J(\Lambda). The Kraus representation of a hermicity-preserving map can be found in QuTiP; using the :func:`.to_kraus` function. .. testcode:: [states]. del sum # np.sum overwrote sum and caused a bug. .. testcode:: [states]. I, X, Y, Z = qeye(2), sigmax(), sigmay(), sigmaz(). .. testcode:: [states]. S = sum([sprepost(P, P) for P in (I, X, Y, Z)]) / 4; print(S). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True; Qobj data =; [[0.5 0. 0. 0.5]; [0. 0. 0. 0. ]; [0. 0. 0. 0. ]; [0.5 0. 0. 0.5]]. .. testcode:: [states]. J = to_choi(S); print(J). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True, superrep = choi; Qobj data =; [[0.5 0. 0. 0. ]; [0. 0.5 0. 0. ]; [0. 0. 0.5 0. ]; [0. 0. 0. 0.5]]. .. testcode:: [states]. print(J.eigenstates()[1]). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. [Quantum object: dims = [[[2], [2]], [1, 1]], shape = (4, 1), type = operator-ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]]; Quantum object: dims = [[[2], [2]], [1, 1]]",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:34409,Testability,test,testcode,34409," |A_i\rangle\!\rangle \langle\!\langle A_i|`.; We can write :math:`J(\Lambda)` in this way; for any hermicity-preserving map; that is, for any map :math:`\Lambda` such that :math:`J(\Lambda) = J^\dagger(\Lambda)`.; These operators then form the Kraus representation of :math:`\Lambda`. In particular, for any input :math:`\rho`,. .. math::. \Lambda(\rho) = \sum_i A_i \rho A_i^\dagger. Notice using the column-stacking identity that :math:`(C^\mathrm{T} \otimes A) |B\rangle\!\rangle = |ABC\rangle\!\rangle`,; we have that. .. math::. \sum_i (\mathbb{1} \otimes A_i) (\mathbb{1} \otimes A_i)^\dagger |\mathbb{1}\rangle\!\rangle \langle\!\langle\mathbb{1}|; = \sum_i |A_i\rangle\!\rangle \langle\!\langle A_i| = J(\Lambda). The Kraus representation of a hermicity-preserving map can be found in QuTiP; using the :func:`.to_kraus` function. .. testcode:: [states]. del sum # np.sum overwrote sum and caused a bug. .. testcode:: [states]. I, X, Y, Z = qeye(2), sigmax(), sigmay(), sigmaz(). .. testcode:: [states]. S = sum([sprepost(P, P) for P in (I, X, Y, Z)]) / 4; print(S). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True; Qobj data =; [[0.5 0. 0. 0.5]; [0. 0. 0. 0. ]; [0. 0. 0. 0. ]; [0.5 0. 0. 0.5]]. .. testcode:: [states]. J = to_choi(S); print(J). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True, superrep = choi; Qobj data =; [[0.5 0. 0. 0. ]; [0. 0.5 0. 0. ]; [0. 0. 0.5 0. ]; [0. 0. 0. 0.5]]. .. testcode:: [states]. print(J.eigenstates()[1]). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. [Quantum object: dims = [[[2], [2]], [1, 1]], shape = (4, 1), type = operator-ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]]; Quantum object: dims = [[[2], [2]], [1, 1]], shape = (4, 1), type = operator-ket; Qobj data =; [[0.]; [1.]; [0.]; [0.]]",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:34509,Testability,test,testoutput,34509,"ng map; that is, for any map :math:`\Lambda` such that :math:`J(\Lambda) = J^\dagger(\Lambda)`.; These operators then form the Kraus representation of :math:`\Lambda`. In particular, for any input :math:`\rho`,. .. math::. \Lambda(\rho) = \sum_i A_i \rho A_i^\dagger. Notice using the column-stacking identity that :math:`(C^\mathrm{T} \otimes A) |B\rangle\!\rangle = |ABC\rangle\!\rangle`,; we have that. .. math::. \sum_i (\mathbb{1} \otimes A_i) (\mathbb{1} \otimes A_i)^\dagger |\mathbb{1}\rangle\!\rangle \langle\!\langle\mathbb{1}|; = \sum_i |A_i\rangle\!\rangle \langle\!\langle A_i| = J(\Lambda). The Kraus representation of a hermicity-preserving map can be found in QuTiP; using the :func:`.to_kraus` function. .. testcode:: [states]. del sum # np.sum overwrote sum and caused a bug. .. testcode:: [states]. I, X, Y, Z = qeye(2), sigmax(), sigmay(), sigmaz(). .. testcode:: [states]. S = sum([sprepost(P, P) for P in (I, X, Y, Z)]) / 4; print(S). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True; Qobj data =; [[0.5 0. 0. 0.5]; [0. 0. 0. 0. ]; [0. 0. 0. 0. ]; [0.5 0. 0. 0.5]]. .. testcode:: [states]. J = to_choi(S); print(J). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True, superrep = choi; Qobj data =; [[0.5 0. 0. 0. ]; [0. 0.5 0. 0. ]; [0. 0. 0.5 0. ]; [0. 0. 0. 0.5]]. .. testcode:: [states]. print(J.eigenstates()[1]). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. [Quantum object: dims = [[[2], [2]], [1, 1]], shape = (4, 1), type = operator-ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]]; Quantum object: dims = [[[2], [2]], [1, 1]], shape = (4, 1), type = operator-ket; Qobj data =; [[0.]; [1.]; [0.]; [0.]]; Quantum object: dims = [[[2], [2]], [1, 1]], shape = (4, 1), type = operator-ket; Qobj data =; [[0.]; [0.]; [1.]; [",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:34743,Testability,test,testcode,34743,"ath::. \Lambda(\rho) = \sum_i A_i \rho A_i^\dagger. Notice using the column-stacking identity that :math:`(C^\mathrm{T} \otimes A) |B\rangle\!\rangle = |ABC\rangle\!\rangle`,; we have that. .. math::. \sum_i (\mathbb{1} \otimes A_i) (\mathbb{1} \otimes A_i)^\dagger |\mathbb{1}\rangle\!\rangle \langle\!\langle\mathbb{1}|; = \sum_i |A_i\rangle\!\rangle \langle\!\langle A_i| = J(\Lambda). The Kraus representation of a hermicity-preserving map can be found in QuTiP; using the :func:`.to_kraus` function. .. testcode:: [states]. del sum # np.sum overwrote sum and caused a bug. .. testcode:: [states]. I, X, Y, Z = qeye(2), sigmax(), sigmay(), sigmaz(). .. testcode:: [states]. S = sum([sprepost(P, P) for P in (I, X, Y, Z)]) / 4; print(S). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True; Qobj data =; [[0.5 0. 0. 0.5]; [0. 0. 0. 0. ]; [0. 0. 0. 0. ]; [0.5 0. 0. 0.5]]. .. testcode:: [states]. J = to_choi(S); print(J). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True, superrep = choi; Qobj data =; [[0.5 0. 0. 0. ]; [0. 0.5 0. 0. ]; [0. 0. 0.5 0. ]; [0. 0. 0. 0.5]]. .. testcode:: [states]. print(J.eigenstates()[1]). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. [Quantum object: dims = [[[2], [2]], [1, 1]], shape = (4, 1), type = operator-ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]]; Quantum object: dims = [[[2], [2]], [1, 1]], shape = (4, 1), type = operator-ket; Qobj data =; [[0.]; [1.]; [0.]; [0.]]; Quantum object: dims = [[[2], [2]], [1, 1]], shape = (4, 1), type = operator-ket; Qobj data =; [[0.]; [0.]; [1.]; [0.]]; Quantum object: dims = [[[2], [2]], [1, 1]], shape = (4, 1), type = operator-ket; Qobj data =; [[0.]; [0.]; [0.]; [1.]]]. .. testcode:: [states]. K = to_kraus(S); print(K). **Output**:. .. testoutput:: [states];",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:34806,Testability,test,testoutput,34806,"ing identity that :math:`(C^\mathrm{T} \otimes A) |B\rangle\!\rangle = |ABC\rangle\!\rangle`,; we have that. .. math::. \sum_i (\mathbb{1} \otimes A_i) (\mathbb{1} \otimes A_i)^\dagger |\mathbb{1}\rangle\!\rangle \langle\!\langle\mathbb{1}|; = \sum_i |A_i\rangle\!\rangle \langle\!\langle A_i| = J(\Lambda). The Kraus representation of a hermicity-preserving map can be found in QuTiP; using the :func:`.to_kraus` function. .. testcode:: [states]. del sum # np.sum overwrote sum and caused a bug. .. testcode:: [states]. I, X, Y, Z = qeye(2), sigmax(), sigmay(), sigmaz(). .. testcode:: [states]. S = sum([sprepost(P, P) for P in (I, X, Y, Z)]) / 4; print(S). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True; Qobj data =; [[0.5 0. 0. 0.5]; [0. 0. 0. 0. ]; [0. 0. 0. 0. ]; [0.5 0. 0. 0.5]]. .. testcode:: [states]. J = to_choi(S); print(J). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True, superrep = choi; Qobj data =; [[0.5 0. 0. 0. ]; [0. 0.5 0. 0. ]; [0. 0. 0.5 0. ]; [0. 0. 0. 0.5]]. .. testcode:: [states]. print(J.eigenstates()[1]). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. [Quantum object: dims = [[[2], [2]], [1, 1]], shape = (4, 1), type = operator-ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]]; Quantum object: dims = [[[2], [2]], [1, 1]], shape = (4, 1), type = operator-ket; Qobj data =; [[0.]; [1.]; [0.]; [0.]]; Quantum object: dims = [[[2], [2]], [1, 1]], shape = (4, 1), type = operator-ket; Qobj data =; [[0.]; [0.]; [1.]; [0.]]; Quantum object: dims = [[[2], [2]], [1, 1]], shape = (4, 1), type = operator-ket; Qobj data =; [[0.]; [0.]; [0.]; [1.]]]. .. testcode:: [states]. K = to_kraus(S); print(K). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. [Quantum object: dims = [[2], [2]], shape = (2",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:35058,Testability,test,testcode,35058,"bb{1}|; = \sum_i |A_i\rangle\!\rangle \langle\!\langle A_i| = J(\Lambda). The Kraus representation of a hermicity-preserving map can be found in QuTiP; using the :func:`.to_kraus` function. .. testcode:: [states]. del sum # np.sum overwrote sum and caused a bug. .. testcode:: [states]. I, X, Y, Z = qeye(2), sigmax(), sigmay(), sigmaz(). .. testcode:: [states]. S = sum([sprepost(P, P) for P in (I, X, Y, Z)]) / 4; print(S). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True; Qobj data =; [[0.5 0. 0. 0.5]; [0. 0. 0. 0. ]; [0. 0. 0. 0. ]; [0.5 0. 0. 0.5]]. .. testcode:: [states]. J = to_choi(S); print(J). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True, superrep = choi; Qobj data =; [[0.5 0. 0. 0. ]; [0. 0.5 0. 0. ]; [0. 0. 0.5 0. ]; [0. 0. 0. 0.5]]. .. testcode:: [states]. print(J.eigenstates()[1]). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. [Quantum object: dims = [[[2], [2]], [1, 1]], shape = (4, 1), type = operator-ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]]; Quantum object: dims = [[[2], [2]], [1, 1]], shape = (4, 1), type = operator-ket; Qobj data =; [[0.]; [1.]; [0.]; [0.]]; Quantum object: dims = [[[2], [2]], [1, 1]], shape = (4, 1), type = operator-ket; Qobj data =; [[0.]; [0.]; [1.]; [0.]]; Quantum object: dims = [[[2], [2]], [1, 1]], shape = (4, 1), type = operator-ket; Qobj data =; [[0.]; [0.]; [0.]; [1.]]]. .. testcode:: [states]. K = to_kraus(S); print(K). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. [Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[0.70710678 0. ]; [0. 0. ]], Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = False; Qobj data =; [[0. 0. ]; [0.70710678 0. ]], Quantum object: dims = [[2], [2]], ",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:35122,Testability,test,testoutput,35122,"s representation of a hermicity-preserving map can be found in QuTiP; using the :func:`.to_kraus` function. .. testcode:: [states]. del sum # np.sum overwrote sum and caused a bug. .. testcode:: [states]. I, X, Y, Z = qeye(2), sigmax(), sigmay(), sigmaz(). .. testcode:: [states]. S = sum([sprepost(P, P) for P in (I, X, Y, Z)]) / 4; print(S). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True; Qobj data =; [[0.5 0. 0. 0.5]; [0. 0. 0. 0. ]; [0. 0. 0. 0. ]; [0.5 0. 0. 0.5]]. .. testcode:: [states]. J = to_choi(S); print(J). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True, superrep = choi; Qobj data =; [[0.5 0. 0. 0. ]; [0. 0.5 0. 0. ]; [0. 0. 0.5 0. ]; [0. 0. 0. 0.5]]. .. testcode:: [states]. print(J.eigenstates()[1]). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. [Quantum object: dims = [[[2], [2]], [1, 1]], shape = (4, 1), type = operator-ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]]; Quantum object: dims = [[[2], [2]], [1, 1]], shape = (4, 1), type = operator-ket; Qobj data =; [[0.]; [1.]; [0.]; [0.]]; Quantum object: dims = [[[2], [2]], [1, 1]], shape = (4, 1), type = operator-ket; Qobj data =; [[0.]; [0.]; [1.]; [0.]]; Quantum object: dims = [[[2], [2]], [1, 1]], shape = (4, 1), type = operator-ket; Qobj data =; [[0.]; [0.]; [0.]; [1.]]]. .. testcode:: [states]. K = to_kraus(S); print(K). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. [Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[0.70710678 0. ]; [0. 0. ]], Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = False; Qobj data =; [[0. 0. ]; [0.70710678 0. ]], Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = False; Qobj data =; [[0. 0.70710678]; [0. 0",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:35667,Testability,test,testcode,35667,"5 0. 0. 0.5]; [0. 0. 0. 0. ]; [0. 0. 0. 0. ]; [0.5 0. 0. 0.5]]. .. testcode:: [states]. J = to_choi(S); print(J). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True, superrep = choi; Qobj data =; [[0.5 0. 0. 0. ]; [0. 0.5 0. 0. ]; [0. 0. 0.5 0. ]; [0. 0. 0. 0.5]]. .. testcode:: [states]. print(J.eigenstates()[1]). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. [Quantum object: dims = [[[2], [2]], [1, 1]], shape = (4, 1), type = operator-ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]]; Quantum object: dims = [[[2], [2]], [1, 1]], shape = (4, 1), type = operator-ket; Qobj data =; [[0.]; [1.]; [0.]; [0.]]; Quantum object: dims = [[[2], [2]], [1, 1]], shape = (4, 1), type = operator-ket; Qobj data =; [[0.]; [0.]; [1.]; [0.]]; Quantum object: dims = [[[2], [2]], [1, 1]], shape = (4, 1), type = operator-ket; Qobj data =; [[0.]; [0.]; [0.]; [1.]]]. .. testcode:: [states]. K = to_kraus(S); print(K). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. [Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[0.70710678 0. ]; [0. 0. ]], Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = False; Qobj data =; [[0. 0. ]; [0.70710678 0. ]], Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = False; Qobj data =; [[0. 0.70710678]; [0. 0. ]], Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[0. 0. ]; [0. 0.70710678]]]. As with the other representation conversion functions, :func:`.to_kraus`; checks the :attr:`.Qobj.superrep` attribute of its input, and chooses an appropriate; conversion method. Thus, in the above example, we can also call :func:`.to_kraus`; on ``J``. .. testcode:: [states]. KJ = to_kraus(J); print(KJ). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. [Quantum object: dims ",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:35731,Testability,test,testoutput,35731,"tes]. J = to_choi(S); print(J). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True, superrep = choi; Qobj data =; [[0.5 0. 0. 0. ]; [0. 0.5 0. 0. ]; [0. 0. 0.5 0. ]; [0. 0. 0. 0.5]]. .. testcode:: [states]. print(J.eigenstates()[1]). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. [Quantum object: dims = [[[2], [2]], [1, 1]], shape = (4, 1), type = operator-ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]]; Quantum object: dims = [[[2], [2]], [1, 1]], shape = (4, 1), type = operator-ket; Qobj data =; [[0.]; [1.]; [0.]; [0.]]; Quantum object: dims = [[[2], [2]], [1, 1]], shape = (4, 1), type = operator-ket; Qobj data =; [[0.]; [0.]; [1.]; [0.]]; Quantum object: dims = [[[2], [2]], [1, 1]], shape = (4, 1), type = operator-ket; Qobj data =; [[0.]; [0.]; [0.]; [1.]]]. .. testcode:: [states]. K = to_kraus(S); print(K). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. [Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[0.70710678 0. ]; [0. 0. ]], Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = False; Qobj data =; [[0. 0. ]; [0.70710678 0. ]], Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = False; Qobj data =; [[0. 0.70710678]; [0. 0. ]], Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[0. 0. ]; [0. 0.70710678]]]. As with the other representation conversion functions, :func:`.to_kraus`; checks the :attr:`.Qobj.superrep` attribute of its input, and chooses an appropriate; conversion method. Thus, in the above example, we can also call :func:`.to_kraus`; on ``J``. .. testcode:: [states]. KJ = to_kraus(J); print(KJ). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. [Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[0.707106",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:36533,Testability,test,testcode,36533,"Quantum object: dims = [[[2], [2]], [1, 1]], shape = (4, 1), type = operator-ket; Qobj data =; [[0.]; [0.]; [0.]; [1.]]]. .. testcode:: [states]. K = to_kraus(S); print(K). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. [Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[0.70710678 0. ]; [0. 0. ]], Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = False; Qobj data =; [[0. 0. ]; [0.70710678 0. ]], Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = False; Qobj data =; [[0. 0.70710678]; [0. 0. ]], Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[0. 0. ]; [0. 0.70710678]]]. As with the other representation conversion functions, :func:`.to_kraus`; checks the :attr:`.Qobj.superrep` attribute of its input, and chooses an appropriate; conversion method. Thus, in the above example, we can also call :func:`.to_kraus`; on ``J``. .. testcode:: [states]. KJ = to_kraus(J); print(KJ). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. [Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[0.70710678 0. ]; [0. 0. ]], Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = False; Qobj data =; [[0. 0. ]; [0.70710678 0. ]], Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = False; Qobj data =; [[0. 0.70710678]; [0. 0. ]], Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[0. 0. ]; [0. 0.70710678]]]. .. testcode:: [states]. for A, AJ in zip(K, KJ):; print(A - AJ). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[0. 0.]; [0. 0.]]; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[0. 0.]; [0. 0.]]; Quantum object: dims = [[2], [2]], sh",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:36599,Testability,test,testoutput,36599,"bj data =; [[0.]; [0.]; [0.]; [1.]]]. .. testcode:: [states]. K = to_kraus(S); print(K). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. [Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[0.70710678 0. ]; [0. 0. ]], Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = False; Qobj data =; [[0. 0. ]; [0.70710678 0. ]], Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = False; Qobj data =; [[0. 0.70710678]; [0. 0. ]], Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[0. 0. ]; [0. 0.70710678]]]. As with the other representation conversion functions, :func:`.to_kraus`; checks the :attr:`.Qobj.superrep` attribute of its input, and chooses an appropriate; conversion method. Thus, in the above example, we can also call :func:`.to_kraus`; on ``J``. .. testcode:: [states]. KJ = to_kraus(J); print(KJ). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. [Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[0.70710678 0. ]; [0. 0. ]], Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = False; Qobj data =; [[0. 0. ]; [0.70710678 0. ]], Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = False; Qobj data =; [[0. 0.70710678]; [0. 0. ]], Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[0. 0. ]; [0. 0.70710678]]]. .. testcode:: [states]. for A, AJ in zip(K, KJ):; print(A - AJ). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[0. 0.]; [0. 0.]]; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[0. 0.]; [0. 0.]]; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[0. 0.]; [0. 0.]]; Quantum ",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:37148,Testability,test,testcode,37148,"antum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[0. 0. ]; [0. 0.70710678]]]. As with the other representation conversion functions, :func:`.to_kraus`; checks the :attr:`.Qobj.superrep` attribute of its input, and chooses an appropriate; conversion method. Thus, in the above example, we can also call :func:`.to_kraus`; on ``J``. .. testcode:: [states]. KJ = to_kraus(J); print(KJ). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. [Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[0.70710678 0. ]; [0. 0. ]], Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = False; Qobj data =; [[0. 0. ]; [0.70710678 0. ]], Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = False; Qobj data =; [[0. 0.70710678]; [0. 0. ]], Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[0. 0. ]; [0. 0.70710678]]]. .. testcode:: [states]. for A, AJ in zip(K, KJ):; print(A - AJ). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[0. 0.]; [0. 0.]]; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[0. 0.]; [0. 0.]]; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[0. 0.]; [0. 0.]]; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[0. 0.]; [0. 0.]]. The Stinespring representation is closely related to the Kraus representation,; and consists of a pair of operators :math:`A` and :math:`B` such that for; all operators :math:`X` acting on :math:`\mathcal{H}`,. .. math::. \Lambda(X) = \operatorname{Tr}_2(A X B^\dagger),. where the partial trace is over a new index that corresponds to the; index in the Kraus summation. Conversion to Stinespring; is handled by the :func:`.to_s",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:37226,Testability,test,testoutput,37226,". ]; [0. 0.70710678]]]. As with the other representation conversion functions, :func:`.to_kraus`; checks the :attr:`.Qobj.superrep` attribute of its input, and chooses an appropriate; conversion method. Thus, in the above example, we can also call :func:`.to_kraus`; on ``J``. .. testcode:: [states]. KJ = to_kraus(J); print(KJ). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. [Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[0.70710678 0. ]; [0. 0. ]], Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = False; Qobj data =; [[0. 0. ]; [0.70710678 0. ]], Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = False; Qobj data =; [[0. 0.70710678]; [0. 0. ]], Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[0. 0. ]; [0. 0.70710678]]]. .. testcode:: [states]. for A, AJ in zip(K, KJ):; print(A - AJ). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[0. 0.]; [0. 0.]]; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[0. 0.]; [0. 0.]]; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[0. 0.]; [0. 0.]]; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[0. 0.]; [0. 0.]]. The Stinespring representation is closely related to the Kraus representation,; and consists of a pair of operators :math:`A` and :math:`B` such that for; all operators :math:`X` acting on :math:`\mathcal{H}`,. .. math::. \Lambda(X) = \operatorname{Tr}_2(A X B^\dagger),. where the partial trace is over a new index that corresponds to the; index in the Kraus summation. Conversion to Stinespring; is handled by the :func:`.to_stinespring`; function. .. testcode:: [states]. a = create(2).dag(). S_ad = sprepost(a * a.dag()",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:38184,Testability,test,testcode,38184,"; print(A - AJ). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[0. 0.]; [0. 0.]]; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[0. 0.]; [0. 0.]]; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[0. 0.]; [0. 0.]]; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[0. 0.]; [0. 0.]]. The Stinespring representation is closely related to the Kraus representation,; and consists of a pair of operators :math:`A` and :math:`B` such that for; all operators :math:`X` acting on :math:`\mathcal{H}`,. .. math::. \Lambda(X) = \operatorname{Tr}_2(A X B^\dagger),. where the partial trace is over a new index that corresponds to the; index in the Kraus summation. Conversion to Stinespring; is handled by the :func:`.to_stinespring`; function. .. testcode:: [states]. a = create(2).dag(). S_ad = sprepost(a * a.dag(), a * a.dag()) + sprepost(a, a.dag()); S = 0.9 * sprepost(I, I) + 0.1 * S_ad. print(S). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = False; Qobj data =; [[1. 0. 0. 0.1]; [0. 0.9 0. 0. ]; [0. 0. 0.9 0. ]; [0. 0. 0. 0.9]]. .. testcode:: [states]. A, B = to_stinespring(S); print(A). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 3], [2]], shape = (6, 2), type = oper, isherm = False; Qobj data =; [[-0.98845443 0. ]; [ 0. 0.31622777]; [ 0.15151842 0. ]; [ 0. -0.93506452]; [ 0. 0. ]; [ 0. -0.16016975]]. .. testcode:: [states]. print(B). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 3], [2]], shape = (6, 2), type = oper, isherm = False; Qobj data =; [[-0.98845443 0. ]; [ 0. 0.31622777]; [ 0.15151842 0. ]; [ 0. -0.935",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:38357,Testability,test,testoutput,38357,"[0. 0.]]; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[0. 0.]; [0. 0.]]; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[0. 0.]; [0. 0.]]; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[0. 0.]; [0. 0.]]. The Stinespring representation is closely related to the Kraus representation,; and consists of a pair of operators :math:`A` and :math:`B` such that for; all operators :math:`X` acting on :math:`\mathcal{H}`,. .. math::. \Lambda(X) = \operatorname{Tr}_2(A X B^\dagger),. where the partial trace is over a new index that corresponds to the; index in the Kraus summation. Conversion to Stinespring; is handled by the :func:`.to_stinespring`; function. .. testcode:: [states]. a = create(2).dag(). S_ad = sprepost(a * a.dag(), a * a.dag()) + sprepost(a, a.dag()); S = 0.9 * sprepost(I, I) + 0.1 * S_ad. print(S). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = False; Qobj data =; [[1. 0. 0. 0.1]; [0. 0.9 0. 0. ]; [0. 0. 0.9 0. ]; [0. 0. 0. 0.9]]. .. testcode:: [states]. A, B = to_stinespring(S); print(A). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 3], [2]], shape = (6, 2), type = oper, isherm = False; Qobj data =; [[-0.98845443 0. ]; [ 0. 0.31622777]; [ 0.15151842 0. ]; [ 0. -0.93506452]; [ 0. 0. ]; [ 0. -0.16016975]]. .. testcode:: [states]. print(B). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 3], [2]], shape = (6, 2), type = oper, isherm = False; Qobj data =; [[-0.98845443 0. ]; [ 0. 0.31622777]; [ 0.15151842 0. ]; [ 0. -0.93506452]; [ 0. 0. ]; [ 0. -0.16016975]]. Notice that a new index has been added, such that :math:`A` and :math:`B`; have dimensions ``[[2, 3], [2]]``, with the length-3 index representing the;",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:38592,Testability,test,testcode,38592,". 0.]; [0. 0.]]; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[0. 0.]; [0. 0.]]. The Stinespring representation is closely related to the Kraus representation,; and consists of a pair of operators :math:`A` and :math:`B` such that for; all operators :math:`X` acting on :math:`\mathcal{H}`,. .. math::. \Lambda(X) = \operatorname{Tr}_2(A X B^\dagger),. where the partial trace is over a new index that corresponds to the; index in the Kraus summation. Conversion to Stinespring; is handled by the :func:`.to_stinespring`; function. .. testcode:: [states]. a = create(2).dag(). S_ad = sprepost(a * a.dag(), a * a.dag()) + sprepost(a, a.dag()); S = 0.9 * sprepost(I, I) + 0.1 * S_ad. print(S). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = False; Qobj data =; [[1. 0. 0. 0.1]; [0. 0.9 0. 0. ]; [0. 0. 0.9 0. ]; [0. 0. 0. 0.9]]. .. testcode:: [states]. A, B = to_stinespring(S); print(A). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 3], [2]], shape = (6, 2), type = oper, isherm = False; Qobj data =; [[-0.98845443 0. ]; [ 0. 0.31622777]; [ 0.15151842 0. ]; [ 0. -0.93506452]; [ 0. 0. ]; [ 0. -0.16016975]]. .. testcode:: [states]. print(B). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 3], [2]], shape = (6, 2), type = oper, isherm = False; Qobj data =; [[-0.98845443 0. ]; [ 0. 0.31622777]; [ 0.15151842 0. ]; [ 0. -0.93506452]; [ 0. 0. ]; [ 0. -0.16016975]]. Notice that a new index has been added, such that :math:`A` and :math:`B`; have dimensions ``[[2, 3], [2]]``, with the length-3 index representing the; fact that the Choi matrix is rank-3 (alternatively, that the map has three; Kraus operators). .. testcode:: [states]. to_kraus(S); print(to_choi(S).eigenenergies()). **Output**:. .. testoutput:: [states]; :options: +N",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:38665,Testability,test,testoutput,38665,"rue; Qobj data =; [[0. 0.]; [0. 0.]]. The Stinespring representation is closely related to the Kraus representation,; and consists of a pair of operators :math:`A` and :math:`B` such that for; all operators :math:`X` acting on :math:`\mathcal{H}`,. .. math::. \Lambda(X) = \operatorname{Tr}_2(A X B^\dagger),. where the partial trace is over a new index that corresponds to the; index in the Kraus summation. Conversion to Stinespring; is handled by the :func:`.to_stinespring`; function. .. testcode:: [states]. a = create(2).dag(). S_ad = sprepost(a * a.dag(), a * a.dag()) + sprepost(a, a.dag()); S = 0.9 * sprepost(I, I) + 0.1 * S_ad. print(S). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = False; Qobj data =; [[1. 0. 0. 0.1]; [0. 0.9 0. 0. ]; [0. 0. 0.9 0. ]; [0. 0. 0. 0.9]]. .. testcode:: [states]. A, B = to_stinespring(S); print(A). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 3], [2]], shape = (6, 2), type = oper, isherm = False; Qobj data =; [[-0.98845443 0. ]; [ 0. 0.31622777]; [ 0.15151842 0. ]; [ 0. -0.93506452]; [ 0. 0. ]; [ 0. -0.16016975]]. .. testcode:: [states]. print(B). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 3], [2]], shape = (6, 2), type = oper, isherm = False; Qobj data =; [[-0.98845443 0. ]; [ 0. 0.31622777]; [ 0.15151842 0. ]; [ 0. -0.93506452]; [ 0. 0. ]; [ 0. -0.16016975]]. Notice that a new index has been added, such that :math:`A` and :math:`B`; have dimensions ``[[2, 3], [2]]``, with the length-3 index representing the; fact that the Choi matrix is rank-3 (alternatively, that the map has three; Kraus operators). .. testcode:: [states]. to_kraus(S); print(to_choi(S).eigenenergies()). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. [0. 0.04861218 0.1 1.85138782]. Finally, the last superoperator repre",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:38927,Testability,test,testcode,38927,"}`,. .. math::. \Lambda(X) = \operatorname{Tr}_2(A X B^\dagger),. where the partial trace is over a new index that corresponds to the; index in the Kraus summation. Conversion to Stinespring; is handled by the :func:`.to_stinespring`; function. .. testcode:: [states]. a = create(2).dag(). S_ad = sprepost(a * a.dag(), a * a.dag()) + sprepost(a, a.dag()); S = 0.9 * sprepost(I, I) + 0.1 * S_ad. print(S). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = False; Qobj data =; [[1. 0. 0. 0.1]; [0. 0.9 0. 0. ]; [0. 0. 0.9 0. ]; [0. 0. 0. 0.9]]. .. testcode:: [states]. A, B = to_stinespring(S); print(A). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 3], [2]], shape = (6, 2), type = oper, isherm = False; Qobj data =; [[-0.98845443 0. ]; [ 0. 0.31622777]; [ 0.15151842 0. ]; [ 0. -0.93506452]; [ 0. 0. ]; [ 0. -0.16016975]]. .. testcode:: [states]. print(B). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 3], [2]], shape = (6, 2), type = oper, isherm = False; Qobj data =; [[-0.98845443 0. ]; [ 0. 0.31622777]; [ 0.15151842 0. ]; [ 0. -0.93506452]; [ 0. 0. ]; [ 0. -0.16016975]]. Notice that a new index has been added, such that :math:`A` and :math:`B`; have dimensions ``[[2, 3], [2]]``, with the length-3 index representing the; fact that the Choi matrix is rank-3 (alternatively, that the map has three; Kraus operators). .. testcode:: [states]. to_kraus(S); print(to_choi(S).eigenenergies()). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. [0. 0.04861218 0.1 1.85138782]. Finally, the last superoperator representation supported by QuTiP is; the :math:`\chi`-matrix representation,. .. math::. \Lambda(\rho) = \sum_{\alpha,\beta} \chi_{\alpha,\beta} B_{\alpha} \rho B_{\beta}^\dagger,. where :math:`\{B_\alpha\}` is a basis for the space of matrices acti",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:38974,Testability,test,testoutput,38974," where the partial trace is over a new index that corresponds to the; index in the Kraus summation. Conversion to Stinespring; is handled by the :func:`.to_stinespring`; function. .. testcode:: [states]. a = create(2).dag(). S_ad = sprepost(a * a.dag(), a * a.dag()) + sprepost(a, a.dag()); S = 0.9 * sprepost(I, I) + 0.1 * S_ad. print(S). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = False; Qobj data =; [[1. 0. 0. 0.1]; [0. 0.9 0. 0. ]; [0. 0. 0.9 0. ]; [0. 0. 0. 0.9]]. .. testcode:: [states]. A, B = to_stinespring(S); print(A). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 3], [2]], shape = (6, 2), type = oper, isherm = False; Qobj data =; [[-0.98845443 0. ]; [ 0. 0.31622777]; [ 0.15151842 0. ]; [ 0. -0.93506452]; [ 0. 0. ]; [ 0. -0.16016975]]. .. testcode:: [states]. print(B). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 3], [2]], shape = (6, 2), type = oper, isherm = False; Qobj data =; [[-0.98845443 0. ]; [ 0. 0.31622777]; [ 0.15151842 0. ]; [ 0. -0.93506452]; [ 0. 0. ]; [ 0. -0.16016975]]. Notice that a new index has been added, such that :math:`A` and :math:`B`; have dimensions ``[[2, 3], [2]]``, with the length-3 index representing the; fact that the Choi matrix is rank-3 (alternatively, that the map has three; Kraus operators). .. testcode:: [states]. to_kraus(S); print(to_choi(S).eigenenergies()). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. [0. 0.04861218 0.1 1.85138782]. Finally, the last superoperator representation supported by QuTiP is; the :math:`\chi`-matrix representation,. .. math::. \Lambda(\rho) = \sum_{\alpha,\beta} \chi_{\alpha,\beta} B_{\alpha} \rho B_{\beta}^\dagger,. where :math:`\{B_\alpha\}` is a basis for the space of matrices acting; on :math:`\mathcal{H}`. In QuTiP, this basis is taken to be ",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:39482,Testability,test,testcode,39482," isherm = False; Qobj data =; [[1. 0. 0. 0.1]; [0. 0.9 0. 0. ]; [0. 0. 0.9 0. ]; [0. 0. 0. 0.9]]. .. testcode:: [states]. A, B = to_stinespring(S); print(A). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 3], [2]], shape = (6, 2), type = oper, isherm = False; Qobj data =; [[-0.98845443 0. ]; [ 0. 0.31622777]; [ 0.15151842 0. ]; [ 0. -0.93506452]; [ 0. 0. ]; [ 0. -0.16016975]]. .. testcode:: [states]. print(B). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 3], [2]], shape = (6, 2), type = oper, isherm = False; Qobj data =; [[-0.98845443 0. ]; [ 0. 0.31622777]; [ 0.15151842 0. ]; [ 0. -0.93506452]; [ 0. 0. ]; [ 0. -0.16016975]]. Notice that a new index has been added, such that :math:`A` and :math:`B`; have dimensions ``[[2, 3], [2]]``, with the length-3 index representing the; fact that the Choi matrix is rank-3 (alternatively, that the map has three; Kraus operators). .. testcode:: [states]. to_kraus(S); print(to_choi(S).eigenenergies()). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. [0. 0.04861218 0.1 1.85138782]. Finally, the last superoperator representation supported by QuTiP is; the :math:`\chi`-matrix representation,. .. math::. \Lambda(\rho) = \sum_{\alpha,\beta} \chi_{\alpha,\beta} B_{\alpha} \rho B_{\beta}^\dagger,. where :math:`\{B_\alpha\}` is a basis for the space of matrices acting; on :math:`\mathcal{H}`. In QuTiP, this basis is taken to be the Pauli; basis :math:`B_\alpha = \sigma_\alpha / \sqrt{2}`. Conversion to the; :math:`\chi` formalism is handled by the :func:`.to_chi`; function. .. testcode:: [states]. chi = to_chi(S); print(chi). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True, superrep = chi; Qobj data =; [[3.7+0.j 0. +0.j 0. +0.j 0.1+0.j ]; [0. +0.j 0.1+0.j 0. +0.1j 0. +0.j ]; [0. +0.j 0. -0.1j 0.",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:39567,Testability,test,testoutput,39567,"stcode:: [states]. A, B = to_stinespring(S); print(A). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 3], [2]], shape = (6, 2), type = oper, isherm = False; Qobj data =; [[-0.98845443 0. ]; [ 0. 0.31622777]; [ 0.15151842 0. ]; [ 0. -0.93506452]; [ 0. 0. ]; [ 0. -0.16016975]]. .. testcode:: [states]. print(B). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 3], [2]], shape = (6, 2), type = oper, isherm = False; Qobj data =; [[-0.98845443 0. ]; [ 0. 0.31622777]; [ 0.15151842 0. ]; [ 0. -0.93506452]; [ 0. 0. ]; [ 0. -0.16016975]]. Notice that a new index has been added, such that :math:`A` and :math:`B`; have dimensions ``[[2, 3], [2]]``, with the length-3 index representing the; fact that the Choi matrix is rank-3 (alternatively, that the map has three; Kraus operators). .. testcode:: [states]. to_kraus(S); print(to_choi(S).eigenenergies()). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. [0. 0.04861218 0.1 1.85138782]. Finally, the last superoperator representation supported by QuTiP is; the :math:`\chi`-matrix representation,. .. math::. \Lambda(\rho) = \sum_{\alpha,\beta} \chi_{\alpha,\beta} B_{\alpha} \rho B_{\beta}^\dagger,. where :math:`\{B_\alpha\}` is a basis for the space of matrices acting; on :math:`\mathcal{H}`. In QuTiP, this basis is taken to be the Pauli; basis :math:`B_\alpha = \sigma_\alpha / \sqrt{2}`. Conversion to the; :math:`\chi` formalism is handled by the :func:`.to_chi`; function. .. testcode:: [states]. chi = to_chi(S); print(chi). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True, superrep = chi; Qobj data =; [[3.7+0.j 0. +0.j 0. +0.j 0.1+0.j ]; [0. +0.j 0.1+0.j 0. +0.1j 0. +0.j ]; [0. +0.j 0. -0.1j 0.1+0.j 0. +0.j ]; [0.1+0.j 0. +0.j 0. +0.j 0.1+0.j ]]. One convenient property of the :math:`\chi` matr",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:40153,Testability,test,testcode,40153,"; [ 0.15151842 0. ]; [ 0. -0.93506452]; [ 0. 0. ]; [ 0. -0.16016975]]. Notice that a new index has been added, such that :math:`A` and :math:`B`; have dimensions ``[[2, 3], [2]]``, with the length-3 index representing the; fact that the Choi matrix is rank-3 (alternatively, that the map has three; Kraus operators). .. testcode:: [states]. to_kraus(S); print(to_choi(S).eigenenergies()). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. [0. 0.04861218 0.1 1.85138782]. Finally, the last superoperator representation supported by QuTiP is; the :math:`\chi`-matrix representation,. .. math::. \Lambda(\rho) = \sum_{\alpha,\beta} \chi_{\alpha,\beta} B_{\alpha} \rho B_{\beta}^\dagger,. where :math:`\{B_\alpha\}` is a basis for the space of matrices acting; on :math:`\mathcal{H}`. In QuTiP, this basis is taken to be the Pauli; basis :math:`B_\alpha = \sigma_\alpha / \sqrt{2}`. Conversion to the; :math:`\chi` formalism is handled by the :func:`.to_chi`; function. .. testcode:: [states]. chi = to_chi(S); print(chi). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True, superrep = chi; Qobj data =; [[3.7+0.j 0. +0.j 0. +0.j 0.1+0.j ]; [0. +0.j 0.1+0.j 0. +0.1j 0. +0.j ]; [0. +0.j 0. -0.1j 0.1+0.j 0. +0.j ]; [0.1+0.j 0. +0.j 0. +0.j 0.1+0.j ]]. One convenient property of the :math:`\chi` matrix is that the average; gate fidelity with the identity map can be read off directly from; the :math:`\chi_{00}` element:. .. testcode:: [states]. np.testing.assert_almost_equal(average_gate_fidelity(S), 0.9499999999999998). print(chi[0, 0] / 4). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. (0.925+0j). Here, the factor of 4 comes from the dimension of the underlying; Hilbert space :math:`\mathcal{H}`. As with the superoperator; and Choi representations, the :math:`\chi` representation is; denoted by the :attr:`.Qobj.superrep`, such that",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:40219,Testability,test,testoutput,40219," new index has been added, such that :math:`A` and :math:`B`; have dimensions ``[[2, 3], [2]]``, with the length-3 index representing the; fact that the Choi matrix is rank-3 (alternatively, that the map has three; Kraus operators). .. testcode:: [states]. to_kraus(S); print(to_choi(S).eigenenergies()). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. [0. 0.04861218 0.1 1.85138782]. Finally, the last superoperator representation supported by QuTiP is; the :math:`\chi`-matrix representation,. .. math::. \Lambda(\rho) = \sum_{\alpha,\beta} \chi_{\alpha,\beta} B_{\alpha} \rho B_{\beta}^\dagger,. where :math:`\{B_\alpha\}` is a basis for the space of matrices acting; on :math:`\mathcal{H}`. In QuTiP, this basis is taken to be the Pauli; basis :math:`B_\alpha = \sigma_\alpha / \sqrt{2}`. Conversion to the; :math:`\chi` formalism is handled by the :func:`.to_chi`; function. .. testcode:: [states]. chi = to_chi(S); print(chi). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True, superrep = chi; Qobj data =; [[3.7+0.j 0. +0.j 0. +0.j 0.1+0.j ]; [0. +0.j 0.1+0.j 0. +0.1j 0. +0.j ]; [0. +0.j 0. -0.1j 0.1+0.j 0. +0.j ]; [0.1+0.j 0. +0.j 0. +0.j 0.1+0.j ]]. One convenient property of the :math:`\chi` matrix is that the average; gate fidelity with the identity map can be read off directly from; the :math:`\chi_{00}` element:. .. testcode:: [states]. np.testing.assert_almost_equal(average_gate_fidelity(S), 0.9499999999999998). print(chi[0, 0] / 4). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. (0.925+0j). Here, the factor of 4 comes from the dimension of the underlying; Hilbert space :math:`\mathcal{H}`. As with the superoperator; and Choi representations, the :math:`\chi` representation is; denoted by the :attr:`.Qobj.superrep`, such that :func:`.to_super`,; :func:`.to_choi`, :func:`.to_kraus`,; :func:`.to_stinespring` ",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:40720,Testability,test,testcode,40720,":math:`\chi`-matrix representation,. .. math::. \Lambda(\rho) = \sum_{\alpha,\beta} \chi_{\alpha,\beta} B_{\alpha} \rho B_{\beta}^\dagger,. where :math:`\{B_\alpha\}` is a basis for the space of matrices acting; on :math:`\mathcal{H}`. In QuTiP, this basis is taken to be the Pauli; basis :math:`B_\alpha = \sigma_\alpha / \sqrt{2}`. Conversion to the; :math:`\chi` formalism is handled by the :func:`.to_chi`; function. .. testcode:: [states]. chi = to_chi(S); print(chi). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True, superrep = chi; Qobj data =; [[3.7+0.j 0. +0.j 0. +0.j 0.1+0.j ]; [0. +0.j 0.1+0.j 0. +0.1j 0. +0.j ]; [0. +0.j 0. -0.1j 0.1+0.j 0. +0.j ]; [0.1+0.j 0. +0.j 0. +0.j 0.1+0.j ]]. One convenient property of the :math:`\chi` matrix is that the average; gate fidelity with the identity map can be read off directly from; the :math:`\chi_{00}` element:. .. testcode:: [states]. np.testing.assert_almost_equal(average_gate_fidelity(S), 0.9499999999999998). print(chi[0, 0] / 4). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. (0.925+0j). Here, the factor of 4 comes from the dimension of the underlying; Hilbert space :math:`\mathcal{H}`. As with the superoperator; and Choi representations, the :math:`\chi` representation is; denoted by the :attr:`.Qobj.superrep`, such that :func:`.to_super`,; :func:`.to_choi`, :func:`.to_kraus`,; :func:`.to_stinespring` and :func:`.to_chi`; all convert from the :math:`\chi` representation appropriately. Properties of Quantum Maps; ==========================. In addition to converting between the different representations of quantum maps,; QuTiP also provides attributes to make it easy to check if a map is completely; positive, trace preserving and/or hermicity preserving. Each of these attributes; uses :attr:`.Qobj.superrep` to automatically perform any needed conversions. In particular, a quant",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:40744,Testability,test,testing,40744," representation,. .. math::. \Lambda(\rho) = \sum_{\alpha,\beta} \chi_{\alpha,\beta} B_{\alpha} \rho B_{\beta}^\dagger,. where :math:`\{B_\alpha\}` is a basis for the space of matrices acting; on :math:`\mathcal{H}`. In QuTiP, this basis is taken to be the Pauli; basis :math:`B_\alpha = \sigma_\alpha / \sqrt{2}`. Conversion to the; :math:`\chi` formalism is handled by the :func:`.to_chi`; function. .. testcode:: [states]. chi = to_chi(S); print(chi). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True, superrep = chi; Qobj data =; [[3.7+0.j 0. +0.j 0. +0.j 0.1+0.j ]; [0. +0.j 0.1+0.j 0. +0.1j 0. +0.j ]; [0. +0.j 0. -0.1j 0.1+0.j 0. +0.j ]; [0.1+0.j 0. +0.j 0. +0.j 0.1+0.j ]]. One convenient property of the :math:`\chi` matrix is that the average; gate fidelity with the identity map can be read off directly from; the :math:`\chi_{00}` element:. .. testcode:: [states]. np.testing.assert_almost_equal(average_gate_fidelity(S), 0.9499999999999998). print(chi[0, 0] / 4). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. (0.925+0j). Here, the factor of 4 comes from the dimension of the underlying; Hilbert space :math:`\mathcal{H}`. As with the superoperator; and Choi representations, the :math:`\chi` representation is; denoted by the :attr:`.Qobj.superrep`, such that :func:`.to_super`,; :func:`.to_choi`, :func:`.to_kraus`,; :func:`.to_stinespring` and :func:`.to_chi`; all convert from the :math:`\chi` representation appropriately. Properties of Quantum Maps; ==========================. In addition to converting between the different representations of quantum maps,; QuTiP also provides attributes to make it easy to check if a map is completely; positive, trace preserving and/or hermicity preserving. Each of these attributes; uses :attr:`.Qobj.superrep` to automatically perform any needed conversions. In particular, a quantum map is said to ",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:40857,Testability,test,testoutput,40857,"B_\alpha\}` is a basis for the space of matrices acting; on :math:`\mathcal{H}`. In QuTiP, this basis is taken to be the Pauli; basis :math:`B_\alpha = \sigma_\alpha / \sqrt{2}`. Conversion to the; :math:`\chi` formalism is handled by the :func:`.to_chi`; function. .. testcode:: [states]. chi = to_chi(S); print(chi). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True, superrep = chi; Qobj data =; [[3.7+0.j 0. +0.j 0. +0.j 0.1+0.j ]; [0. +0.j 0.1+0.j 0. +0.1j 0. +0.j ]; [0. +0.j 0. -0.1j 0.1+0.j 0. +0.j ]; [0.1+0.j 0. +0.j 0. +0.j 0.1+0.j ]]. One convenient property of the :math:`\chi` matrix is that the average; gate fidelity with the identity map can be read off directly from; the :math:`\chi_{00}` element:. .. testcode:: [states]. np.testing.assert_almost_equal(average_gate_fidelity(S), 0.9499999999999998). print(chi[0, 0] / 4). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. (0.925+0j). Here, the factor of 4 comes from the dimension of the underlying; Hilbert space :math:`\mathcal{H}`. As with the superoperator; and Choi representations, the :math:`\chi` representation is; denoted by the :attr:`.Qobj.superrep`, such that :func:`.to_super`,; :func:`.to_choi`, :func:`.to_kraus`,; :func:`.to_stinespring` and :func:`.to_chi`; all convert from the :math:`\chi` representation appropriately. Properties of Quantum Maps; ==========================. In addition to converting between the different representations of quantum maps,; QuTiP also provides attributes to make it easy to check if a map is completely; positive, trace preserving and/or hermicity preserving. Each of these attributes; uses :attr:`.Qobj.superrep` to automatically perform any needed conversions. In particular, a quantum map is said to be positive (but not necessarily completely; positive) if it maps all positive operators to positive operators. For instance, the; trans",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:42069,Testability,test,testcode,42069," the :math:`\chi` representation is; denoted by the :attr:`.Qobj.superrep`, such that :func:`.to_super`,; :func:`.to_choi`, :func:`.to_kraus`,; :func:`.to_stinespring` and :func:`.to_chi`; all convert from the :math:`\chi` representation appropriately. Properties of Quantum Maps; ==========================. In addition to converting between the different representations of quantum maps,; QuTiP also provides attributes to make it easy to check if a map is completely; positive, trace preserving and/or hermicity preserving. Each of these attributes; uses :attr:`.Qobj.superrep` to automatically perform any needed conversions. In particular, a quantum map is said to be positive (but not necessarily completely; positive) if it maps all positive operators to positive operators. For instance, the; transpose map :math:`\Lambda(\rho) = \rho^{\mathrm{T}}` is a positive map. We run into; problems, however, if we tensor :math:`\Lambda` with the identity to get a partial; transpose map. .. testcode:: [states]. rho = ket2dm(bell_state()); rho_out = partial_transpose(rho, [0, 1]); print(rho_out.eigenenergies()). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. [-0.5 0.5 0.5 0.5]. Notice that even though we started with a positive map, we got an operator out; with negative eigenvalues. Complete positivity addresses this by requiring that; a map returns positive operators for all positive operators, and does so even; under tensoring with another map. The Choi matrix is very useful here, as it; can be shown that a map is completely positive if and only if its Choi matrix; is positive [Wat13]_. QuTiP implements this check with the :attr:`.Qobj.iscp`; attribute. As an example, notice that the snippet above already calculates; the Choi matrix of the transpose map by acting it on half of an entangled; pair. We simply need to manually set the ``dims`` and ``superrep`` attributes to reflect the; structure of the underlying Hilbert space and the chosen representation. .",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:42208,Testability,test,testoutput,42208,"inespring` and :func:`.to_chi`; all convert from the :math:`\chi` representation appropriately. Properties of Quantum Maps; ==========================. In addition to converting between the different representations of quantum maps,; QuTiP also provides attributes to make it easy to check if a map is completely; positive, trace preserving and/or hermicity preserving. Each of these attributes; uses :attr:`.Qobj.superrep` to automatically perform any needed conversions. In particular, a quantum map is said to be positive (but not necessarily completely; positive) if it maps all positive operators to positive operators. For instance, the; transpose map :math:`\Lambda(\rho) = \rho^{\mathrm{T}}` is a positive map. We run into; problems, however, if we tensor :math:`\Lambda` with the identity to get a partial; transpose map. .. testcode:: [states]. rho = ket2dm(bell_state()); rho_out = partial_transpose(rho, [0, 1]); print(rho_out.eigenenergies()). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. [-0.5 0.5 0.5 0.5]. Notice that even though we started with a positive map, we got an operator out; with negative eigenvalues. Complete positivity addresses this by requiring that; a map returns positive operators for all positive operators, and does so even; under tensoring with another map. The Choi matrix is very useful here, as it; can be shown that a map is completely positive if and only if its Choi matrix; is positive [Wat13]_. QuTiP implements this check with the :attr:`.Qobj.iscp`; attribute. As an example, notice that the snippet above already calculates; the Choi matrix of the transpose map by acting it on half of an entangled; pair. We simply need to manually set the ``dims`` and ``superrep`` attributes to reflect the; structure of the underlying Hilbert space and the chosen representation. .. testcode:: [states]. J = rho_out; J.dims = [[[2], [2]], [[2], [2]]]; J.superrep = 'choi'; print(J.iscp). **Output**:. .. testoutput:: [states]; :options: ",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:43081,Testability,test,testcode,43081,"rho = ket2dm(bell_state()); rho_out = partial_transpose(rho, [0, 1]); print(rho_out.eigenenergies()). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. [-0.5 0.5 0.5 0.5]. Notice that even though we started with a positive map, we got an operator out; with negative eigenvalues. Complete positivity addresses this by requiring that; a map returns positive operators for all positive operators, and does so even; under tensoring with another map. The Choi matrix is very useful here, as it; can be shown that a map is completely positive if and only if its Choi matrix; is positive [Wat13]_. QuTiP implements this check with the :attr:`.Qobj.iscp`; attribute. As an example, notice that the snippet above already calculates; the Choi matrix of the transpose map by acting it on half of an entangled; pair. We simply need to manually set the ``dims`` and ``superrep`` attributes to reflect the; structure of the underlying Hilbert space and the chosen representation. .. testcode:: [states]. J = rho_out; J.dims = [[[2], [2]], [[2], [2]]]; J.superrep = 'choi'; print(J.iscp). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. False. This confirms that the transpose map is not completely positive. On the other hand,; the transpose map does satisfy a weaker condition, namely that it is hermicity preserving.; That is, :math:`\Lambda(\rho) = (\Lambda(\rho))^\dagger` for all :math:`\rho` such that; :math:`\rho = \rho^\dagger`. To see this, we note that :math:`(\rho^{\mathrm{T}})^\dagger; = \rho^*`, the complex conjugate of :math:`\rho`. By assumption, :math:`\rho = \rho^\dagger; = (\rho^*)^{\mathrm{T}}`, though, such that :math:`\Lambda(\rho) = \Lambda(\rho^\dagger) = \rho^*`.; We can confirm this by checking the :attr:`.Qobj.ishp` attribute:. .. testcode:: [states]. print(J.ishp). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. True. Next, we note that the transpose map does preserve the trace of its inputs, such that; :mat",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:43202,Testability,test,testoutput,43202,"; :options: +NORMALIZE_WHITESPACE. [-0.5 0.5 0.5 0.5]. Notice that even though we started with a positive map, we got an operator out; with negative eigenvalues. Complete positivity addresses this by requiring that; a map returns positive operators for all positive operators, and does so even; under tensoring with another map. The Choi matrix is very useful here, as it; can be shown that a map is completely positive if and only if its Choi matrix; is positive [Wat13]_. QuTiP implements this check with the :attr:`.Qobj.iscp`; attribute. As an example, notice that the snippet above already calculates; the Choi matrix of the transpose map by acting it on half of an entangled; pair. We simply need to manually set the ``dims`` and ``superrep`` attributes to reflect the; structure of the underlying Hilbert space and the chosen representation. .. testcode:: [states]. J = rho_out; J.dims = [[[2], [2]], [[2], [2]]]; J.superrep = 'choi'; print(J.iscp). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. False. This confirms that the transpose map is not completely positive. On the other hand,; the transpose map does satisfy a weaker condition, namely that it is hermicity preserving.; That is, :math:`\Lambda(\rho) = (\Lambda(\rho))^\dagger` for all :math:`\rho` such that; :math:`\rho = \rho^\dagger`. To see this, we note that :math:`(\rho^{\mathrm{T}})^\dagger; = \rho^*`, the complex conjugate of :math:`\rho`. By assumption, :math:`\rho = \rho^\dagger; = (\rho^*)^{\mathrm{T}}`, though, such that :math:`\Lambda(\rho) = \Lambda(\rho^\dagger) = \rho^*`.; We can confirm this by checking the :attr:`.Qobj.ishp` attribute:. .. testcode:: [states]. print(J.ishp). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. True. Next, we note that the transpose map does preserve the trace of its inputs, such that; :math:`\operatorname{Tr}(\Lambda[\rho]) = \operatorname{Tr}(\rho)` for all :math:`\rho`.; This can be confirmed by the :attr:`.Qobj.istp` attr",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:43886,Testability,test,testcode,43886,"QuTiP implements this check with the :attr:`.Qobj.iscp`; attribute. As an example, notice that the snippet above already calculates; the Choi matrix of the transpose map by acting it on half of an entangled; pair. We simply need to manually set the ``dims`` and ``superrep`` attributes to reflect the; structure of the underlying Hilbert space and the chosen representation. .. testcode:: [states]. J = rho_out; J.dims = [[[2], [2]], [[2], [2]]]; J.superrep = 'choi'; print(J.iscp). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. False. This confirms that the transpose map is not completely positive. On the other hand,; the transpose map does satisfy a weaker condition, namely that it is hermicity preserving.; That is, :math:`\Lambda(\rho) = (\Lambda(\rho))^\dagger` for all :math:`\rho` such that; :math:`\rho = \rho^\dagger`. To see this, we note that :math:`(\rho^{\mathrm{T}})^\dagger; = \rho^*`, the complex conjugate of :math:`\rho`. By assumption, :math:`\rho = \rho^\dagger; = (\rho^*)^{\mathrm{T}}`, though, such that :math:`\Lambda(\rho) = \Lambda(\rho^\dagger) = \rho^*`.; We can confirm this by checking the :attr:`.Qobj.ishp` attribute:. .. testcode:: [states]. print(J.ishp). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. True. Next, we note that the transpose map does preserve the trace of its inputs, such that; :math:`\operatorname{Tr}(\Lambda[\rho]) = \operatorname{Tr}(\rho)` for all :math:`\rho`.; This can be confirmed by the :attr:`.Qobj.istp` attribute:. .. testcode:: [states]. print(J.istp). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. False. Finally, a map is called a quantum channel if it always maps valid states to valid; states. Formally, a map is a channel if it is both completely positive and trace preserving.; Thus, QuTiP provides a single attribute to quickly check that this is true. .. doctest:: [states]. >>> print(J.iscptp); False. >>> print(to_super(qeye(2)).iscptp); True; ",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:43938,Testability,test,testoutput,43938,"QuTiP implements this check with the :attr:`.Qobj.iscp`; attribute. As an example, notice that the snippet above already calculates; the Choi matrix of the transpose map by acting it on half of an entangled; pair. We simply need to manually set the ``dims`` and ``superrep`` attributes to reflect the; structure of the underlying Hilbert space and the chosen representation. .. testcode:: [states]. J = rho_out; J.dims = [[[2], [2]], [[2], [2]]]; J.superrep = 'choi'; print(J.iscp). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. False. This confirms that the transpose map is not completely positive. On the other hand,; the transpose map does satisfy a weaker condition, namely that it is hermicity preserving.; That is, :math:`\Lambda(\rho) = (\Lambda(\rho))^\dagger` for all :math:`\rho` such that; :math:`\rho = \rho^\dagger`. To see this, we note that :math:`(\rho^{\mathrm{T}})^\dagger; = \rho^*`, the complex conjugate of :math:`\rho`. By assumption, :math:`\rho = \rho^\dagger; = (\rho^*)^{\mathrm{T}}`, though, such that :math:`\Lambda(\rho) = \Lambda(\rho^\dagger) = \rho^*`.; We can confirm this by checking the :attr:`.Qobj.ishp` attribute:. .. testcode:: [states]. print(J.ishp). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. True. Next, we note that the transpose map does preserve the trace of its inputs, such that; :math:`\operatorname{Tr}(\Lambda[\rho]) = \operatorname{Tr}(\rho)` for all :math:`\rho`.; This can be confirmed by the :attr:`.Qobj.istp` attribute:. .. testcode:: [states]. print(J.istp). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. False. Finally, a map is called a quantum channel if it always maps valid states to valid; states. Formally, a map is a channel if it is both completely positive and trace preserving.; Thus, QuTiP provides a single attribute to quickly check that this is true. .. doctest:: [states]. >>> print(J.iscptp); False. >>> print(to_super(qeye(2)).iscptp); True; ",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:44240,Testability,test,testcode,44240,"QuTiP implements this check with the :attr:`.Qobj.iscp`; attribute. As an example, notice that the snippet above already calculates; the Choi matrix of the transpose map by acting it on half of an entangled; pair. We simply need to manually set the ``dims`` and ``superrep`` attributes to reflect the; structure of the underlying Hilbert space and the chosen representation. .. testcode:: [states]. J = rho_out; J.dims = [[[2], [2]], [[2], [2]]]; J.superrep = 'choi'; print(J.iscp). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. False. This confirms that the transpose map is not completely positive. On the other hand,; the transpose map does satisfy a weaker condition, namely that it is hermicity preserving.; That is, :math:`\Lambda(\rho) = (\Lambda(\rho))^\dagger` for all :math:`\rho` such that; :math:`\rho = \rho^\dagger`. To see this, we note that :math:`(\rho^{\mathrm{T}})^\dagger; = \rho^*`, the complex conjugate of :math:`\rho`. By assumption, :math:`\rho = \rho^\dagger; = (\rho^*)^{\mathrm{T}}`, though, such that :math:`\Lambda(\rho) = \Lambda(\rho^\dagger) = \rho^*`.; We can confirm this by checking the :attr:`.Qobj.ishp` attribute:. .. testcode:: [states]. print(J.ishp). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. True. Next, we note that the transpose map does preserve the trace of its inputs, such that; :math:`\operatorname{Tr}(\Lambda[\rho]) = \operatorname{Tr}(\rho)` for all :math:`\rho`.; This can be confirmed by the :attr:`.Qobj.istp` attribute:. .. testcode:: [states]. print(J.istp). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. False. Finally, a map is called a quantum channel if it always maps valid states to valid; states. Formally, a map is a channel if it is both completely positive and trace preserving.; Thus, QuTiP provides a single attribute to quickly check that this is true. .. doctest:: [states]. >>> print(J.iscptp); False. >>> print(to_super(qeye(2)).iscptp); True; ",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:44292,Testability,test,testoutput,44292,"QuTiP implements this check with the :attr:`.Qobj.iscp`; attribute. As an example, notice that the snippet above already calculates; the Choi matrix of the transpose map by acting it on half of an entangled; pair. We simply need to manually set the ``dims`` and ``superrep`` attributes to reflect the; structure of the underlying Hilbert space and the chosen representation. .. testcode:: [states]. J = rho_out; J.dims = [[[2], [2]], [[2], [2]]]; J.superrep = 'choi'; print(J.iscp). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. False. This confirms that the transpose map is not completely positive. On the other hand,; the transpose map does satisfy a weaker condition, namely that it is hermicity preserving.; That is, :math:`\Lambda(\rho) = (\Lambda(\rho))^\dagger` for all :math:`\rho` such that; :math:`\rho = \rho^\dagger`. To see this, we note that :math:`(\rho^{\mathrm{T}})^\dagger; = \rho^*`, the complex conjugate of :math:`\rho`. By assumption, :math:`\rho = \rho^\dagger; = (\rho^*)^{\mathrm{T}}`, though, such that :math:`\Lambda(\rho) = \Lambda(\rho^\dagger) = \rho^*`.; We can confirm this by checking the :attr:`.Qobj.ishp` attribute:. .. testcode:: [states]. print(J.ishp). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. True. Next, we note that the transpose map does preserve the trace of its inputs, such that; :math:`\operatorname{Tr}(\Lambda[\rho]) = \operatorname{Tr}(\rho)` for all :math:`\rho`.; This can be confirmed by the :attr:`.Qobj.istp` attribute:. .. testcode:: [states]. print(J.istp). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. False. Finally, a map is called a quantum channel if it always maps valid states to valid; states. Formally, a map is a channel if it is both completely positive and trace preserving.; Thus, QuTiP provides a single attribute to quickly check that this is true. .. doctest:: [states]. >>> print(J.iscptp); False. >>> print(to_super(qeye(2)).iscptp); True; ",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:194,Usability,guid,guide,194,".. _states:. *************************************; Manipulating States and Operators; *************************************. .. _states-intro:. Introduction; =================. In the previous guide section :ref:`basics`, we saw how to create states and operators, using the functions built into QuTiP. In this portion of the guide, we will look at performing basic operations with states and operators. For more detailed demonstrations on how to use and manipulate these objects, see the examples on the `tutorials <https://qutip.org/tutorials.html>`_ web page. .. _states-vectors:. State Vectors (kets or bras); ==============================. Here we begin by creating a Fock :func:`.basis` vacuum state vector :math:`\left|0\right>` with in a Hilbert space with 5 number states, from 0 to 4:. .. testcode:: [states]. vac = basis(5, 0). print(vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]; [0.]]. and then create a lowering operator :math:`\left(\hat{a}\right)` corresponding to 5 number states using the :func:`.destroy` function:. .. testcode:: [states]. a = destroy(5). print(a). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = False; Qobj data =; [[0. 1. 0. 0. 0. ]; [0. 0. 1.41421356 0. 0. ]; [0. 0. 0. 1.73205081 0. ]; [0. 0. 0. 0. 2. ]; [0. 0. 0. 0. 0. ]]. Now lets apply the destruction operator to our vacuum state ``vac``,. .. testcode:: [states]. print(a * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [0.]; [0.]; [0.]; [0.]]. We see that, as expected, the vacuum is transformed to the zero vector. A more interesting example comes from using the adjoint of the lowering operator, the raising operator :math:`\hat{a}^\dagger`:. .. testcode::",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:327,Usability,guid,guide,327,".. _states:. *************************************; Manipulating States and Operators; *************************************. .. _states-intro:. Introduction; =================. In the previous guide section :ref:`basics`, we saw how to create states and operators, using the functions built into QuTiP. In this portion of the guide, we will look at performing basic operations with states and operators. For more detailed demonstrations on how to use and manipulate these objects, see the examples on the `tutorials <https://qutip.org/tutorials.html>`_ web page. .. _states-vectors:. State Vectors (kets or bras); ==============================. Here we begin by creating a Fock :func:`.basis` vacuum state vector :math:`\left|0\right>` with in a Hilbert space with 5 number states, from 0 to 4:. .. testcode:: [states]. vac = basis(5, 0). print(vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]; [0.]]. and then create a lowering operator :math:`\left(\hat{a}\right)` corresponding to 5 number states using the :func:`.destroy` function:. .. testcode:: [states]. a = destroy(5). print(a). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = False; Qobj data =; [[0. 1. 0. 0. 0. ]; [0. 0. 1.41421356 0. 0. ]; [0. 0. 0. 1.73205081 0. ]; [0. 0. 0. 0. 2. ]; [0. 0. 0. 0. 0. ]]. Now lets apply the destruction operator to our vacuum state ``vac``,. .. testcode:: [states]. print(a * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [0.]; [0.]; [0.]; [0.]]. We see that, as expected, the vacuum is transformed to the zero vector. A more interesting example comes from using the adjoint of the lowering operator, the raising operator :math:`\hat{a}^\dagger`:. .. testcode::",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:8214,Usability,simpl,simplest,8214,"+0.j ]; [ 0. +0.60628133j]; [-0.4303874 +0.j ]; [ 0. -0.24104351j]; [ 0.14552147+0.j ]]. .. testcode:: [states]. print(d * s * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[ 0.65893786+0.08139381j]; [ 0.10779462+0.51579735j]; [-0.37567217-0.01326853j]; [-0.02688063-0.23828775j]; [ 0.26352814+0.11512178j]]. Of course, displacing the vacuum gives a coherent state, which can also be generated using the built in :func:`.coherent` function. .. _states-dm:. Density matrices; =================. One of the main purpose of QuTiP is to explore the dynamics of **open** quantum systems, where the most general state of a system is no longer a state vector, but rather a density matrix. Since operations on density matrices operate identically to those of vectors, we will just briefly highlight creating and using these structures. The simplest density matrix is created by forming the outer-product :math:`\left|\psi\right>\left<\psi\right|` of a ket vector:. .. testcode:: [states]. ket = basis(5, 2). print(ket * ket.dag()). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[0. 0. 0. 0. 0.]; [0. 0. 0. 0. 0.]; [0. 0. 1. 0. 0.]; [0. 0. 0. 0. 0.]; [0. 0. 0. 0. 0.]]. A similar task can also be accomplished via the :func:`.fock_dm` or :func:`.ket2dm` functions:. .. testcode:: [states]. print(fock_dm(5, 2)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[0. 0. 0. 0. 0.]; [0. 0. 0. 0. 0.]; [0. 0. 1. 0. 0.]; [0. 0. 0. 0. 0.]; [0. 0. 0. 0. 0.]]. .. testcode:: [states]. print(ket2dm(ket)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[0. 0",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:32538,Usability,simpl,simply,32538,": [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True, superrep = choi; Qobj data =; [[0. 0. 0. 0.]; [0. 1. 1. 0.]; [0. 1. 1. 0.]; [0. 0. 0. 0.]]. .. testcode:: [states]. print(to_choi(spre(qeye(2)))). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True, superrep = choi; Qobj data =; [[1. 0. 0. 1.]; [0. 0. 0. 0.]; [0. 0. 0. 0.]; [1. 0. 0. 1.]]. If a :obj:`.Qobj` instance is already in the Choi :attr:`.Qobj.superrep`, then calling :func:`.to_choi`; does nothing:. .. testcode:: [states]. print(to_choi(J)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True, superrep = choi; Qobj data =; [[0. 0. 0. 0.]; [0. 1. 1. 0.]; [0. 1. 1. 0.]; [0. 0. 0. 0.]]. To get back to the superoperator representation, simply use the :func:`.to_super` function.; As with :func:`.to_choi`, :func:`.to_super` is idempotent:. .. testcode:: [states]. print(to_super(J) - S). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True; Qobj data =; [[0. 0. 0. 0.]; [0. 0. 0. 0.]; [0. 0. 0. 0.]; [0. 0. 0. 0.]]. .. testcode:: [states]. print(to_super(S)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True; Qobj data =; [[0. 0. 0. 1.]; [0. 0. 1. 0.]; [0. 1. 0. 0.]; [1. 0. 0. 0.]]. We can quickly obtain another useful representation from the Choi matrix by taking its eigendecomposition.; In particular, let :math:`\{A_i\}` be a set of operators such that; :math:`J(\Lambda) = \sum_i |A_i\rangle\!\rangle \langle\!\langle A_i|`.; We can write :math:`J(\Lambda)` in this way; for any hermici",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst:42920,Usability,simpl,simply,42920,"or :math:`\Lambda` with the identity to get a partial; transpose map. .. testcode:: [states]. rho = ket2dm(bell_state()); rho_out = partial_transpose(rho, [0, 1]); print(rho_out.eigenenergies()). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. [-0.5 0.5 0.5 0.5]. Notice that even though we started with a positive map, we got an operator out; with negative eigenvalues. Complete positivity addresses this by requiring that; a map returns positive operators for all positive operators, and does so even; under tensoring with another map. The Choi matrix is very useful here, as it; can be shown that a map is completely positive if and only if its Choi matrix; is positive [Wat13]_. QuTiP implements this check with the :attr:`.Qobj.iscp`; attribute. As an example, notice that the snippet above already calculates; the Choi matrix of the transpose map by acting it on half of an entangled; pair. We simply need to manually set the ``dims`` and ``superrep`` attributes to reflect the; structure of the underlying Hilbert space and the chosen representation. .. testcode:: [states]. J = rho_out; J.dims = [[[2], [2]], [[2], [2]]]; J.superrep = 'choi'; print(J.iscp). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. False. This confirms that the transpose map is not completely positive. On the other hand,; the transpose map does satisfy a weaker condition, namely that it is hermicity preserving.; That is, :math:`\Lambda(\rho) = (\Lambda(\rho))^\dagger` for all :math:`\rho` such that; :math:`\rho = \rho^\dagger`. To see this, we note that :math:`(\rho^{\mathrm{T}})^\dagger; = \rho^*`, the complex conjugate of :math:`\rho`. By assumption, :math:`\rho = \rho^\dagger; = (\rho^*)^{\mathrm{T}}`, though, such that :math:`\Lambda(\rho) = \Lambda(\rho^\dagger) = \rho^*`.; We can confirm this by checking the :attr:`.Qobj.ishp` attribute:. .. testcode:: [states]. print(J.ishp). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Tru",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-steady.rst:2220,Availability,avail,available,2220,"ate`. This function implements a number of different methods for finding the steady state, each with their own pros and cons, where the method used can be chosen using the ``method`` keyword argument. .. cssclass:: table-striped. .. list-table::; :widths: 10 15 30; :header-rows: 1. * - Method; - Keyword; - Description; * - Direct (default); - 'direct'; - Direct solution solving :math:`Ax=b`.; * - Eigenvalue; - 'eigen'; - Iteratively find the zero eigenvalue of :math:`\mathcal{L}`.; * - Inverse-Power; - 'power'; - Solve using the inverse-power method.; * - SVD; - 'svd'; - Steady-state solution via the **dense** SVD of the Liouvillian. The function :func:`.steadystate` can take either a Hamiltonian and a list; of collapse operators as input, generating internally the corresponding; Liouvillian super operator in Lindblad form, or alternatively, a Liouvillian; passed by the user. Both the ``""direct""`` and ``""power""`` method need to solve a linear equation; system. To do so, there are multiple solvers available: ``. .. cssclass:: table-striped. .. list-table::; :widths: 10 15 20; :header-rows: 1. * - Solver; - Original function; - Description; * - ""solve""; - ``numpy.linalg.solve``; - Dense solver from numpy.; * - ""lstsq""; - ``numpy.linalg.lstsq``; - Dense least-squares solver.; * - ""spsolve""; - ``scipy.sparse.linalg.spsolve``; - Sparse solver from scipy.; * - ""gmres""; - ``scipy.sparse.linalg.gmres``; - Generalized Minimal RESidual iterative solver.; * - ""lgmres""; - ``scipy.sparse.linalg.lgmres``; - LGMRES iterative solver.; * - ""bicgstab""; - ``scipy.sparse.linalg.bicgstab``; - BIConjugate Gradient STABilized iterative solver.; * - ""mkl_spsolve""; - ``pardiso``; - Intel Pardiso LU solver from MKL. QuTiP can take advantage of the Intel Pardiso LU solver in the Intel Math; Kernel library that comes with the Anacoda (2.5+) and Intel Python; distributions. This gives a substantial increase in performance compared with; the standard SuperLU method used by SciPy. To verify that ",MatchSource.DOCS,doc/guide/guide-steady.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-steady.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-steady.rst:5207,Availability,down,downside,5207,"`solver=""spsolve""`` indicate to use the sparse solver. Sparse solvers may still use quite a large amount of memory when they factorize the; matrix since the Liouvillian usually has a large bandwidth.; To address this, :func:`.steadystate` allows one to use the bandwidth minimization algorithms; listed in :ref:`steady-args`. For example:. .. code-block:: python. rho_ss = steadystate(H, c_ops, solver=""spsolve"", use_rcm=True). where ``use_rcm=True`` turns on a bandwidth minimization routine. Although it is not obvious, the ``'direct'``, ``'eigen'``, and ``'power'``; methods all use an LU decomposition internally and thus can have a large; memory overhead. In contrast, iterative solvers such as the ``'gmres'``,; ``'lgmres'``, and ``'bicgstab'`` do not factor the matrix and thus take less; memory than the LU methods and allow, in principle, for extremely; large system sizes. The downside is that these methods can take much longer; than the direct method as the condition number of the Liouvillian matrix is; large, indicating that these iterative methods require a large number of; iterations for convergence. To overcome this, one can use a preconditioner; :math:`M` that solves for an approximate inverse for the (modified); Liouvillian, thus better conditioning the problem, leading to faster; convergence. The use of a preconditioner can actually make these iterative; methods faster than the other solution methods. The problem with precondioning; is that it is only well defined for Hermitian matrices. Since the Liouvillian; is non-Hermitian, the ability to find a good preconditioner is not guaranteed.; And moreover, if a preconditioner is found, it is not guaranteed to have a good; condition number. QuTiP can make use of an incomplete LU preconditioner when; using the iterative ``'gmres'``, ``'lgmres'``, and ``'bicgstab'`` solvers by; setting ``use_precond=True``. The preconditioner optionally makes use of a; combination of symmetric and anti-symmetric matrix permutations th",MatchSource.DOCS,doc/guide/guide-steady.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-steady.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-steady.rst:6583,Availability,error,error,6583,"(modified); Liouvillian, thus better conditioning the problem, leading to faster; convergence. The use of a preconditioner can actually make these iterative; methods faster than the other solution methods. The problem with precondioning; is that it is only well defined for Hermitian matrices. Since the Liouvillian; is non-Hermitian, the ability to find a good preconditioner is not guaranteed.; And moreover, if a preconditioner is found, it is not guaranteed to have a good; condition number. QuTiP can make use of an incomplete LU preconditioner when; using the iterative ``'gmres'``, ``'lgmres'``, and ``'bicgstab'`` solvers by; setting ``use_precond=True``. The preconditioner optionally makes use of a; combination of symmetric and anti-symmetric matrix permutations that attempt to; improve the preconditioning process. These features are discussed in the; :ref:`steady-args` section. Even with these state-of-the-art permutations,; the generation of a successful preconditoner for non-symmetric matrices is; currently a trial-and-error process due to the lack of mathematical work done; in this area. It is always recommended to begin with the direct solver with no; additional arguments before selecting a different method. Finding the steady-state solution is not limited to the Lindblad form of the; master equation. Any time-independent Liouvillian constructed from a; Hamiltonian and collapse operators can be used as an input::. >>> rho_ss = steadystate(L). where ``L`` is the Louvillian. All of the additional arguments can also be; used in this case. .. _steady-args:. Additional Solver Arguments; =============================. The following additional solver arguments are available for the steady-state solver:. .. cssclass:: table-striped. .. list-table::; :widths: 10 30 60; :header-rows: 1. * - Keyword; - Default; - Description; * - weight; - None; - Set the weighting factor used in the ``'direct'`` method.; * - use_precond; - False; - Generate a preconditioner when using th",MatchSource.DOCS,doc/guide/guide-steady.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-steady.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-steady.rst:7236,Availability,avail,available,7236,"nally makes use of a; combination of symmetric and anti-symmetric matrix permutations that attempt to; improve the preconditioning process. These features are discussed in the; :ref:`steady-args` section. Even with these state-of-the-art permutations,; the generation of a successful preconditoner for non-symmetric matrices is; currently a trial-and-error process due to the lack of mathematical work done; in this area. It is always recommended to begin with the direct solver with no; additional arguments before selecting a different method. Finding the steady-state solution is not limited to the Lindblad form of the; master equation. Any time-independent Liouvillian constructed from a; Hamiltonian and collapse operators can be used as an input::. >>> rho_ss = steadystate(L). where ``L`` is the Louvillian. All of the additional arguments can also be; used in this case. .. _steady-args:. Additional Solver Arguments; =============================. The following additional solver arguments are available for the steady-state solver:. .. cssclass:: table-striped. .. list-table::; :widths: 10 30 60; :header-rows: 1. * - Keyword; - Default; - Description; * - weight; - None; - Set the weighting factor used in the ``'direct'`` method.; * - use_precond; - False; - Generate a preconditioner when using the ``'gmres'`` and ``'lgmres'`` methods.; * - use_rcm; - False; - Use a Reverse Cuthill-Mckee reordering to minimize the bandwidth of the modified Liouvillian used in the LU decomposition.; * - use_wbm; - False; - Use a Weighted Bipartite Matching algorithm to attempt to make the modified Liouvillian more diagonally dominant, and thus for favorable for preconditioning.; * - power_tol; - 1e-12; - Tolerance for the solution when using the 'power' method.; * - power_maxiter; - 10; - Maximum number of iterations of the power method.; * - power_eps; - 1e-15; - Small weight used in the ""power"" method.; * - \*\*kwargs; - {}; - Options to pass through the linalg solvers.; See the corresp",MatchSource.DOCS,doc/guide/guide-steady.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-steady.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-steady.rst:1717,Energy Efficiency,power,power,1717,"be achieved using direct or iterative solution methods faster than using master equation or Monte Carlo simulations. Although the steady state equation has a simple mathematical form, the properties of the Liouvillian operator are such that the solutions to this equation are anything but straightforward to find. Steady State solvers in QuTiP; =============================. In QuTiP, the steady-state solution for a system Hamiltonian or Liouvillian is given by :func:`.steadystate`. This function implements a number of different methods for finding the steady state, each with their own pros and cons, where the method used can be chosen using the ``method`` keyword argument. .. cssclass:: table-striped. .. list-table::; :widths: 10 15 30; :header-rows: 1. * - Method; - Keyword; - Description; * - Direct (default); - 'direct'; - Direct solution solving :math:`Ax=b`.; * - Eigenvalue; - 'eigen'; - Iteratively find the zero eigenvalue of :math:`\mathcal{L}`.; * - Inverse-Power; - 'power'; - Solve using the inverse-power method.; * - SVD; - 'svd'; - Steady-state solution via the **dense** SVD of the Liouvillian. The function :func:`.steadystate` can take either a Hamiltonian and a list; of collapse operators as input, generating internally the corresponding; Liouvillian super operator in Lindblad form, or alternatively, a Liouvillian; passed by the user. Both the ``""direct""`` and ``""power""`` method need to solve a linear equation; system. To do so, there are multiple solvers available: ``. .. cssclass:: table-striped. .. list-table::; :widths: 10 15 20; :header-rows: 1. * - Solver; - Original function; - Description; * - ""solve""; - ``numpy.linalg.solve``; - Dense solver from numpy.; * - ""lstsq""; - ``numpy.linalg.lstsq``; - Dense least-squares solver.; * - ""spsolve""; - ``scipy.sparse.linalg.spsolve``; - Sparse solver from scipy.; * - ""gmres""; - ``scipy.sparse.linalg.gmres``; - Generalized Minimal RESidual iterative solver.; * - ""lgmres""; - ``scipy.sparse.linalg.lgmres``; - LG",MatchSource.DOCS,doc/guide/guide-steady.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-steady.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-steady.rst:1751,Energy Efficiency,power,power,1751,"be achieved using direct or iterative solution methods faster than using master equation or Monte Carlo simulations. Although the steady state equation has a simple mathematical form, the properties of the Liouvillian operator are such that the solutions to this equation are anything but straightforward to find. Steady State solvers in QuTiP; =============================. In QuTiP, the steady-state solution for a system Hamiltonian or Liouvillian is given by :func:`.steadystate`. This function implements a number of different methods for finding the steady state, each with their own pros and cons, where the method used can be chosen using the ``method`` keyword argument. .. cssclass:: table-striped. .. list-table::; :widths: 10 15 30; :header-rows: 1. * - Method; - Keyword; - Description; * - Direct (default); - 'direct'; - Direct solution solving :math:`Ax=b`.; * - Eigenvalue; - 'eigen'; - Iteratively find the zero eigenvalue of :math:`\mathcal{L}`.; * - Inverse-Power; - 'power'; - Solve using the inverse-power method.; * - SVD; - 'svd'; - Steady-state solution via the **dense** SVD of the Liouvillian. The function :func:`.steadystate` can take either a Hamiltonian and a list; of collapse operators as input, generating internally the corresponding; Liouvillian super operator in Lindblad form, or alternatively, a Liouvillian; passed by the user. Both the ``""direct""`` and ``""power""`` method need to solve a linear equation; system. To do so, there are multiple solvers available: ``. .. cssclass:: table-striped. .. list-table::; :widths: 10 15 20; :header-rows: 1. * - Solver; - Original function; - Description; * - ""solve""; - ``numpy.linalg.solve``; - Dense solver from numpy.; * - ""lstsq""; - ``numpy.linalg.lstsq``; - Dense least-squares solver.; * - ""spsolve""; - ``scipy.sparse.linalg.spsolve``; - Sparse solver from scipy.; * - ""gmres""; - ``scipy.sparse.linalg.gmres``; - Generalized Minimal RESidual iterative solver.; * - ""lgmres""; - ``scipy.sparse.linalg.lgmres``; - LG",MatchSource.DOCS,doc/guide/guide-steady.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-steady.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-steady.rst:2126,Energy Efficiency,power,power,2126," for a system Hamiltonian or Liouvillian is given by :func:`.steadystate`. This function implements a number of different methods for finding the steady state, each with their own pros and cons, where the method used can be chosen using the ``method`` keyword argument. .. cssclass:: table-striped. .. list-table::; :widths: 10 15 30; :header-rows: 1. * - Method; - Keyword; - Description; * - Direct (default); - 'direct'; - Direct solution solving :math:`Ax=b`.; * - Eigenvalue; - 'eigen'; - Iteratively find the zero eigenvalue of :math:`\mathcal{L}`.; * - Inverse-Power; - 'power'; - Solve using the inverse-power method.; * - SVD; - 'svd'; - Steady-state solution via the **dense** SVD of the Liouvillian. The function :func:`.steadystate` can take either a Hamiltonian and a list; of collapse operators as input, generating internally the corresponding; Liouvillian super operator in Lindblad form, or alternatively, a Liouvillian; passed by the user. Both the ``""direct""`` and ``""power""`` method need to solve a linear equation; system. To do so, there are multiple solvers available: ``. .. cssclass:: table-striped. .. list-table::; :widths: 10 15 20; :header-rows: 1. * - Solver; - Original function; - Description; * - ""solve""; - ``numpy.linalg.solve``; - Dense solver from numpy.; * - ""lstsq""; - ``numpy.linalg.lstsq``; - Dense least-squares solver.; * - ""spsolve""; - ``scipy.sparse.linalg.spsolve``; - Sparse solver from scipy.; * - ""gmres""; - ``scipy.sparse.linalg.gmres``; - Generalized Minimal RESidual iterative solver.; * - ""lgmres""; - ``scipy.sparse.linalg.lgmres``; - LGMRES iterative solver.; * - ""bicgstab""; - ``scipy.sparse.linalg.bicgstab``; - BIConjugate Gradient STABilized iterative solver.; * - ""mkl_spsolve""; - ``pardiso``; - Intel Pardiso LU solver from MKL. QuTiP can take advantage of the Intel Pardiso LU solver in the Intel Math; Kernel library that comes with the Anacoda (2.5+) and Intel Python; distributions. This gives a substantial increase in performance comp",MatchSource.DOCS,doc/guide/guide-steady.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-steady.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-steady.rst:4199,Energy Efficiency,power,power,4199," To verify that QuTiP can find the; necessary libraries, one can check for ``INTEL MKL Ext: True`` in the QuTiP; about box (:func:`.about`). .. _steady-usage:. Using the Steadystate Solver; =============================. Solving for the steady state solution to the Lindblad master equation for a; general system with :func:`.steadystate` can be accomplished; using::. >>> rho_ss = steadystate(H, c_ops). where ``H`` is a quantum object representing the system Hamiltonian, and; ``c_ops`` is a list of quantum objects for the system collapse operators. The; output, labelled as ``rho_ss``, is the steady-state solution for the systems.; If no other keywords are passed to the solver, the default 'direct' method is; used with ``numpy.linalg.solve``, generating a solution that is exact to; machine precision at the expense of a large memory requirement. However; Liouvillians are often quite sparse and using a sparse solver may be preferred:. .. code-block:: python. rho_ss = steadystate(H, c_ops, method=""power"", solver=""spsolve""). where ``method='power'`` indicates that we are using the inverse-power solution; method, and ``solver=""spsolve""`` indicate to use the sparse solver. Sparse solvers may still use quite a large amount of memory when they factorize the; matrix since the Liouvillian usually has a large bandwidth.; To address this, :func:`.steadystate` allows one to use the bandwidth minimization algorithms; listed in :ref:`steady-args`. For example:. .. code-block:: python. rho_ss = steadystate(H, c_ops, solver=""spsolve"", use_rcm=True). where ``use_rcm=True`` turns on a bandwidth minimization routine. Although it is not obvious, the ``'direct'``, ``'eigen'``, and ``'power'``; methods all use an LU decomposition internally and thus can have a large; memory overhead. In contrast, iterative solvers such as the ``'gmres'``,; ``'lgmres'``, and ``'bicgstab'`` do not factor the matrix and thus take less; memory than the LU methods and allow, in principle, for extremely; large sys",MatchSource.DOCS,doc/guide/guide-steady.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-steady.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-steady.rst:4242,Energy Efficiency,power,power,4242,"uTiP; about box (:func:`.about`). .. _steady-usage:. Using the Steadystate Solver; =============================. Solving for the steady state solution to the Lindblad master equation for a; general system with :func:`.steadystate` can be accomplished; using::. >>> rho_ss = steadystate(H, c_ops). where ``H`` is a quantum object representing the system Hamiltonian, and; ``c_ops`` is a list of quantum objects for the system collapse operators. The; output, labelled as ``rho_ss``, is the steady-state solution for the systems.; If no other keywords are passed to the solver, the default 'direct' method is; used with ``numpy.linalg.solve``, generating a solution that is exact to; machine precision at the expense of a large memory requirement. However; Liouvillians are often quite sparse and using a sparse solver may be preferred:. .. code-block:: python. rho_ss = steadystate(H, c_ops, method=""power"", solver=""spsolve""). where ``method='power'`` indicates that we are using the inverse-power solution; method, and ``solver=""spsolve""`` indicate to use the sparse solver. Sparse solvers may still use quite a large amount of memory when they factorize the; matrix since the Liouvillian usually has a large bandwidth.; To address this, :func:`.steadystate` allows one to use the bandwidth minimization algorithms; listed in :ref:`steady-args`. For example:. .. code-block:: python. rho_ss = steadystate(H, c_ops, solver=""spsolve"", use_rcm=True). where ``use_rcm=True`` turns on a bandwidth minimization routine. Although it is not obvious, the ``'direct'``, ``'eigen'``, and ``'power'``; methods all use an LU decomposition internally and thus can have a large; memory overhead. In contrast, iterative solvers such as the ``'gmres'``,; ``'lgmres'``, and ``'bicgstab'`` do not factor the matrix and thus take less; memory than the LU methods and allow, in principle, for extremely; large system sizes. The downside is that these methods can take much longer; than the direct method as the condition ",MatchSource.DOCS,doc/guide/guide-steady.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-steady.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-steady.rst:4291,Energy Efficiency,power,power,4291,"uTiP; about box (:func:`.about`). .. _steady-usage:. Using the Steadystate Solver; =============================. Solving for the steady state solution to the Lindblad master equation for a; general system with :func:`.steadystate` can be accomplished; using::. >>> rho_ss = steadystate(H, c_ops). where ``H`` is a quantum object representing the system Hamiltonian, and; ``c_ops`` is a list of quantum objects for the system collapse operators. The; output, labelled as ``rho_ss``, is the steady-state solution for the systems.; If no other keywords are passed to the solver, the default 'direct' method is; used with ``numpy.linalg.solve``, generating a solution that is exact to; machine precision at the expense of a large memory requirement. However; Liouvillians are often quite sparse and using a sparse solver may be preferred:. .. code-block:: python. rho_ss = steadystate(H, c_ops, method=""power"", solver=""spsolve""). where ``method='power'`` indicates that we are using the inverse-power solution; method, and ``solver=""spsolve""`` indicate to use the sparse solver. Sparse solvers may still use quite a large amount of memory when they factorize the; matrix since the Liouvillian usually has a large bandwidth.; To address this, :func:`.steadystate` allows one to use the bandwidth minimization algorithms; listed in :ref:`steady-args`. For example:. .. code-block:: python. rho_ss = steadystate(H, c_ops, solver=""spsolve"", use_rcm=True). where ``use_rcm=True`` turns on a bandwidth minimization routine. Although it is not obvious, the ``'direct'``, ``'eigen'``, and ``'power'``; methods all use an LU decomposition internally and thus can have a large; memory overhead. In contrast, iterative solvers such as the ``'gmres'``,; ``'lgmres'``, and ``'bicgstab'`` do not factor the matrix and thus take less; memory than the LU methods and allow, in principle, for extremely; large system sizes. The downside is that these methods can take much longer; than the direct method as the condition ",MatchSource.DOCS,doc/guide/guide-steady.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-steady.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-steady.rst:4880,Energy Efficiency,power,power,4880," method is; used with ``numpy.linalg.solve``, generating a solution that is exact to; machine precision at the expense of a large memory requirement. However; Liouvillians are often quite sparse and using a sparse solver may be preferred:. .. code-block:: python. rho_ss = steadystate(H, c_ops, method=""power"", solver=""spsolve""). where ``method='power'`` indicates that we are using the inverse-power solution; method, and ``solver=""spsolve""`` indicate to use the sparse solver. Sparse solvers may still use quite a large amount of memory when they factorize the; matrix since the Liouvillian usually has a large bandwidth.; To address this, :func:`.steadystate` allows one to use the bandwidth minimization algorithms; listed in :ref:`steady-args`. For example:. .. code-block:: python. rho_ss = steadystate(H, c_ops, solver=""spsolve"", use_rcm=True). where ``use_rcm=True`` turns on a bandwidth minimization routine. Although it is not obvious, the ``'direct'``, ``'eigen'``, and ``'power'``; methods all use an LU decomposition internally and thus can have a large; memory overhead. In contrast, iterative solvers such as the ``'gmres'``,; ``'lgmres'``, and ``'bicgstab'`` do not factor the matrix and thus take less; memory than the LU methods and allow, in principle, for extremely; large system sizes. The downside is that these methods can take much longer; than the direct method as the condition number of the Liouvillian matrix is; large, indicating that these iterative methods require a large number of; iterations for convergence. To overcome this, one can use a preconditioner; :math:`M` that solves for an approximate inverse for the (modified); Liouvillian, thus better conditioning the problem, leading to faster; convergence. The use of a preconditioner can actually make these iterative; methods faster than the other solution methods. The problem with precondioning; is that it is only well defined for Hermitian matrices. Since the Liouvillian; is non-Hermitian, the ability to fin",MatchSource.DOCS,doc/guide/guide-steady.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-steady.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-steady.rst:7986,Energy Efficiency,power,power,7986,"ors can be used as an input::. >>> rho_ss = steadystate(L). where ``L`` is the Louvillian. All of the additional arguments can also be; used in this case. .. _steady-args:. Additional Solver Arguments; =============================. The following additional solver arguments are available for the steady-state solver:. .. cssclass:: table-striped. .. list-table::; :widths: 10 30 60; :header-rows: 1. * - Keyword; - Default; - Description; * - weight; - None; - Set the weighting factor used in the ``'direct'`` method.; * - use_precond; - False; - Generate a preconditioner when using the ``'gmres'`` and ``'lgmres'`` methods.; * - use_rcm; - False; - Use a Reverse Cuthill-Mckee reordering to minimize the bandwidth of the modified Liouvillian used in the LU decomposition.; * - use_wbm; - False; - Use a Weighted Bipartite Matching algorithm to attempt to make the modified Liouvillian more diagonally dominant, and thus for favorable for preconditioning.; * - power_tol; - 1e-12; - Tolerance for the solution when using the 'power' method.; * - power_maxiter; - 10; - Maximum number of iterations of the power method.; * - power_eps; - 1e-15; - Small weight used in the ""power"" method.; * - \*\*kwargs; - {}; - Options to pass through the linalg solvers.; See the corresponding documentation from scipy for a full list. Further information can be found in the :func:`.steadystate` docstrings. .. _steady-example:. Example: Harmonic Oscillator in Thermal Bath; ============================================. A simple example of a system that reaches a steady state is a harmonic oscillator coupled to a thermal environment. Below we consider a harmonic oscillator, initially in the :math:`\left|10\right>` number state, and weakly coupled to a thermal environment characterized by an average particle expectation value of :math:`\left<n\right>=2`. We calculate the evolution via master equation and Monte Carlo methods, and see that they converge to the steady-state solution. Here we choose to perf",MatchSource.DOCS,doc/guide/guide-steady.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-steady.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-steady.rst:8065,Energy Efficiency,power,power,8065,"villian. All of the additional arguments can also be; used in this case. .. _steady-args:. Additional Solver Arguments; =============================. The following additional solver arguments are available for the steady-state solver:. .. cssclass:: table-striped. .. list-table::; :widths: 10 30 60; :header-rows: 1. * - Keyword; - Default; - Description; * - weight; - None; - Set the weighting factor used in the ``'direct'`` method.; * - use_precond; - False; - Generate a preconditioner when using the ``'gmres'`` and ``'lgmres'`` methods.; * - use_rcm; - False; - Use a Reverse Cuthill-Mckee reordering to minimize the bandwidth of the modified Liouvillian used in the LU decomposition.; * - use_wbm; - False; - Use a Weighted Bipartite Matching algorithm to attempt to make the modified Liouvillian more diagonally dominant, and thus for favorable for preconditioning.; * - power_tol; - 1e-12; - Tolerance for the solution when using the 'power' method.; * - power_maxiter; - 10; - Maximum number of iterations of the power method.; * - power_eps; - 1e-15; - Small weight used in the ""power"" method.; * - \*\*kwargs; - {}; - Options to pass through the linalg solvers.; See the corresponding documentation from scipy for a full list. Further information can be found in the :func:`.steadystate` docstrings. .. _steady-example:. Example: Harmonic Oscillator in Thermal Bath; ============================================. A simple example of a system that reaches a steady state is a harmonic oscillator coupled to a thermal environment. Below we consider a harmonic oscillator, initially in the :math:`\left|10\right>` number state, and weakly coupled to a thermal environment characterized by an average particle expectation value of :math:`\left<n\right>=2`. We calculate the evolution via master equation and Monte Carlo methods, and see that they converge to the steady-state solution. Here we choose to perform only a few Monte Carlo trajectories so we can distinguish this evolution from",MatchSource.DOCS,doc/guide/guide-steady.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-steady.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-steady.rst:8132,Energy Efficiency,power,power,8132,".. _steady-args:. Additional Solver Arguments; =============================. The following additional solver arguments are available for the steady-state solver:. .. cssclass:: table-striped. .. list-table::; :widths: 10 30 60; :header-rows: 1. * - Keyword; - Default; - Description; * - weight; - None; - Set the weighting factor used in the ``'direct'`` method.; * - use_precond; - False; - Generate a preconditioner when using the ``'gmres'`` and ``'lgmres'`` methods.; * - use_rcm; - False; - Use a Reverse Cuthill-Mckee reordering to minimize the bandwidth of the modified Liouvillian used in the LU decomposition.; * - use_wbm; - False; - Use a Weighted Bipartite Matching algorithm to attempt to make the modified Liouvillian more diagonally dominant, and thus for favorable for preconditioning.; * - power_tol; - 1e-12; - Tolerance for the solution when using the 'power' method.; * - power_maxiter; - 10; - Maximum number of iterations of the power method.; * - power_eps; - 1e-15; - Small weight used in the ""power"" method.; * - \*\*kwargs; - {}; - Options to pass through the linalg solvers.; See the corresponding documentation from scipy for a full list. Further information can be found in the :func:`.steadystate` docstrings. .. _steady-example:. Example: Harmonic Oscillator in Thermal Bath; ============================================. A simple example of a system that reaches a steady state is a harmonic oscillator coupled to a thermal environment. Below we consider a harmonic oscillator, initially in the :math:`\left|10\right>` number state, and weakly coupled to a thermal environment characterized by an average particle expectation value of :math:`\left<n\right>=2`. We calculate the evolution via master equation and Monte Carlo methods, and see that they converge to the steady-state solution. Here we choose to perform only a few Monte Carlo trajectories so we can distinguish this evolution from the master-equation solution. .. plot:: guide/scripts/ex_steady.py; :inc",MatchSource.DOCS,doc/guide/guide-steady.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-steady.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-steady.rst:4805,Integrability,rout,routine,4805,", is the steady-state solution for the systems.; If no other keywords are passed to the solver, the default 'direct' method is; used with ``numpy.linalg.solve``, generating a solution that is exact to; machine precision at the expense of a large memory requirement. However; Liouvillians are often quite sparse and using a sparse solver may be preferred:. .. code-block:: python. rho_ss = steadystate(H, c_ops, method=""power"", solver=""spsolve""). where ``method='power'`` indicates that we are using the inverse-power solution; method, and ``solver=""spsolve""`` indicate to use the sparse solver. Sparse solvers may still use quite a large amount of memory when they factorize the; matrix since the Liouvillian usually has a large bandwidth.; To address this, :func:`.steadystate` allows one to use the bandwidth minimization algorithms; listed in :ref:`steady-args`. For example:. .. code-block:: python. rho_ss = steadystate(H, c_ops, solver=""spsolve"", use_rcm=True). where ``use_rcm=True`` turns on a bandwidth minimization routine. Although it is not obvious, the ``'direct'``, ``'eigen'``, and ``'power'``; methods all use an LU decomposition internally and thus can have a large; memory overhead. In contrast, iterative solvers such as the ``'gmres'``,; ``'lgmres'``, and ``'bicgstab'`` do not factor the matrix and thus take less; memory than the LU methods and allow, in principle, for extremely; large system sizes. The downside is that these methods can take much longer; than the direct method as the condition number of the Liouvillian matrix is; large, indicating that these iterative methods require a large number of; iterations for convergence. To overcome this, one can use a preconditioner; :math:`M` that solves for an approximate inverse for the (modified); Liouvillian, thus better conditioning the problem, leading to faster; convergence. The use of a preconditioner can actually make these iterative; methods faster than the other solution methods. The problem with precondioning",MatchSource.DOCS,doc/guide/guide-steady.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-steady.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-steady.rst:3123,Performance,perform,performance,3123,"hod need to solve a linear equation; system. To do so, there are multiple solvers available: ``. .. cssclass:: table-striped. .. list-table::; :widths: 10 15 20; :header-rows: 1. * - Solver; - Original function; - Description; * - ""solve""; - ``numpy.linalg.solve``; - Dense solver from numpy.; * - ""lstsq""; - ``numpy.linalg.lstsq``; - Dense least-squares solver.; * - ""spsolve""; - ``scipy.sparse.linalg.spsolve``; - Sparse solver from scipy.; * - ""gmres""; - ``scipy.sparse.linalg.gmres``; - Generalized Minimal RESidual iterative solver.; * - ""lgmres""; - ``scipy.sparse.linalg.lgmres``; - LGMRES iterative solver.; * - ""bicgstab""; - ``scipy.sparse.linalg.bicgstab``; - BIConjugate Gradient STABilized iterative solver.; * - ""mkl_spsolve""; - ``pardiso``; - Intel Pardiso LU solver from MKL. QuTiP can take advantage of the Intel Pardiso LU solver in the Intel Math; Kernel library that comes with the Anacoda (2.5+) and Intel Python; distributions. This gives a substantial increase in performance compared with; the standard SuperLU method used by SciPy. To verify that QuTiP can find the; necessary libraries, one can check for ``INTEL MKL Ext: True`` in the QuTiP; about box (:func:`.about`). .. _steady-usage:. Using the Steadystate Solver; =============================. Solving for the steady state solution to the Lindblad master equation for a; general system with :func:`.steadystate` can be accomplished; using::. >>> rho_ss = steadystate(H, c_ops). where ``H`` is a quantum object representing the system Hamiltonian, and; ``c_ops`` is a list of quantum objects for the system collapse operators. The; output, labelled as ``rho_ss``, is the steady-state solution for the systems.; If no other keywords are passed to the solver, the default 'direct' method is; used with ``numpy.linalg.solve``, generating a solution that is exact to; machine precision at the expense of a large memory requirement. However; Liouvillians are often quite sparse and using a sparse solver may be preferred:. .. ",MatchSource.DOCS,doc/guide/guide-steady.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-steady.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-steady.rst:8954,Performance,perform,perform,8954,"s:. Additional Solver Arguments; =============================. The following additional solver arguments are available for the steady-state solver:. .. cssclass:: table-striped. .. list-table::; :widths: 10 30 60; :header-rows: 1. * - Keyword; - Default; - Description; * - weight; - None; - Set the weighting factor used in the ``'direct'`` method.; * - use_precond; - False; - Generate a preconditioner when using the ``'gmres'`` and ``'lgmres'`` methods.; * - use_rcm; - False; - Use a Reverse Cuthill-Mckee reordering to minimize the bandwidth of the modified Liouvillian used in the LU decomposition.; * - use_wbm; - False; - Use a Weighted Bipartite Matching algorithm to attempt to make the modified Liouvillian more diagonally dominant, and thus for favorable for preconditioning.; * - power_tol; - 1e-12; - Tolerance for the solution when using the 'power' method.; * - power_maxiter; - 10; - Maximum number of iterations of the power method.; * - power_eps; - 1e-15; - Small weight used in the ""power"" method.; * - \*\*kwargs; - {}; - Options to pass through the linalg solvers.; See the corresponding documentation from scipy for a full list. Further information can be found in the :func:`.steadystate` docstrings. .. _steady-example:. Example: Harmonic Oscillator in Thermal Bath; ============================================. A simple example of a system that reaches a steady state is a harmonic oscillator coupled to a thermal environment. Below we consider a harmonic oscillator, initially in the :math:`\left|10\right>` number state, and weakly coupled to a thermal environment characterized by an average particle expectation value of :math:`\left<n\right>=2`. We calculate the evolution via master equation and Monte Carlo methods, and see that they converge to the steady-state solution. Here we choose to perform only a few Monte Carlo trajectories so we can distinguish this evolution from the master-equation solution. .. plot:: guide/scripts/ex_steady.py; :include-source:; ",MatchSource.DOCS,doc/guide/guide-steady.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-steady.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-steady.rst:886,Usability,simpl,simple,886,".. _steady:. *************************************; Solving for Steady-State Solutions; *************************************. .. _steady-intro:. Introduction; ============. For time-independent open quantum systems with decay rates larger than the corresponding excitation rates, the system will tend toward a steady state as :math:`t\rightarrow\infty` that satisfies the equation. .. math::; \frac{d\hat{\rho}_{ss}}{dt}=\mathcal{L}\hat{\rho}_{ss}=0. Although the requirement for time-independence seems quite resitrictive, one can often employ a transformation to the interaction picture that yields a time-independent Hamiltonian. For many these systems, solving for the asymptotic density matrix :math:`\hat{\rho}_{ss}` can be achieved using direct or iterative solution methods faster than using master equation or Monte Carlo simulations. Although the steady state equation has a simple mathematical form, the properties of the Liouvillian operator are such that the solutions to this equation are anything but straightforward to find. Steady State solvers in QuTiP; =============================. In QuTiP, the steady-state solution for a system Hamiltonian or Liouvillian is given by :func:`.steadystate`. This function implements a number of different methods for finding the steady state, each with their own pros and cons, where the method used can be chosen using the ``method`` keyword argument. .. cssclass:: table-striped. .. list-table::; :widths: 10 15 30; :header-rows: 1. * - Method; - Keyword; - Description; * - Direct (default); - 'direct'; - Direct solution solving :math:`Ax=b`.; * - Eigenvalue; - 'eigen'; - Iteratively find the zero eigenvalue of :math:`\mathcal{L}`.; * - Inverse-Power; - 'power'; - Solve using the inverse-power method.; * - SVD; - 'svd'; - Steady-state solution via the **dense** SVD of the Liouvillian. The function :func:`.steadystate` can take either a Hamiltonian and a list; of collapse operators as input, generating internally the corresponding; Li",MatchSource.DOCS,doc/guide/guide-steady.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-steady.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-steady.rst:8469,Usability,simpl,simple,8469,"s:. Additional Solver Arguments; =============================. The following additional solver arguments are available for the steady-state solver:. .. cssclass:: table-striped. .. list-table::; :widths: 10 30 60; :header-rows: 1. * - Keyword; - Default; - Description; * - weight; - None; - Set the weighting factor used in the ``'direct'`` method.; * - use_precond; - False; - Generate a preconditioner when using the ``'gmres'`` and ``'lgmres'`` methods.; * - use_rcm; - False; - Use a Reverse Cuthill-Mckee reordering to minimize the bandwidth of the modified Liouvillian used in the LU decomposition.; * - use_wbm; - False; - Use a Weighted Bipartite Matching algorithm to attempt to make the modified Liouvillian more diagonally dominant, and thus for favorable for preconditioning.; * - power_tol; - 1e-12; - Tolerance for the solution when using the 'power' method.; * - power_maxiter; - 10; - Maximum number of iterations of the power method.; * - power_eps; - 1e-15; - Small weight used in the ""power"" method.; * - \*\*kwargs; - {}; - Options to pass through the linalg solvers.; See the corresponding documentation from scipy for a full list. Further information can be found in the :func:`.steadystate` docstrings. .. _steady-example:. Example: Harmonic Oscillator in Thermal Bath; ============================================. A simple example of a system that reaches a steady state is a harmonic oscillator coupled to a thermal environment. Below we consider a harmonic oscillator, initially in the :math:`\left|10\right>` number state, and weakly coupled to a thermal environment characterized by an average particle expectation value of :math:`\left<n\right>=2`. We calculate the evolution via master equation and Monte Carlo methods, and see that they converge to the steady-state solution. Here we choose to perform only a few Monte Carlo trajectories so we can distinguish this evolution from the master-equation solution. .. plot:: guide/scripts/ex_steady.py; :include-source:; ",MatchSource.DOCS,doc/guide/guide-steady.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-steady.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-steady.rst:9080,Usability,guid,guide,9080,"s:. Additional Solver Arguments; =============================. The following additional solver arguments are available for the steady-state solver:. .. cssclass:: table-striped. .. list-table::; :widths: 10 30 60; :header-rows: 1. * - Keyword; - Default; - Description; * - weight; - None; - Set the weighting factor used in the ``'direct'`` method.; * - use_precond; - False; - Generate a preconditioner when using the ``'gmres'`` and ``'lgmres'`` methods.; * - use_rcm; - False; - Use a Reverse Cuthill-Mckee reordering to minimize the bandwidth of the modified Liouvillian used in the LU decomposition.; * - use_wbm; - False; - Use a Weighted Bipartite Matching algorithm to attempt to make the modified Liouvillian more diagonally dominant, and thus for favorable for preconditioning.; * - power_tol; - 1e-12; - Tolerance for the solution when using the 'power' method.; * - power_maxiter; - 10; - Maximum number of iterations of the power method.; * - power_eps; - 1e-15; - Small weight used in the ""power"" method.; * - \*\*kwargs; - {}; - Options to pass through the linalg solvers.; See the corresponding documentation from scipy for a full list. Further information can be found in the :func:`.steadystate` docstrings. .. _steady-example:. Example: Harmonic Oscillator in Thermal Bath; ============================================. A simple example of a system that reaches a steady state is a harmonic oscillator coupled to a thermal environment. Below we consider a harmonic oscillator, initially in the :math:`\left|10\right>` number state, and weakly coupled to a thermal environment characterized by an average particle expectation value of :math:`\left<n\right>=2`. We calculate the evolution via master equation and Monte Carlo methods, and see that they converge to the steady-state solution. Here we choose to perform only a few Monte Carlo trajectories so we can distinguish this evolution from the master-equation solution. .. plot:: guide/scripts/ex_steady.py; :include-source:; ",MatchSource.DOCS,doc/guide/guide-steady.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-steady.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-super.rst:2367,Energy Efficiency,reduce,reduced-channels,2367,".gates import cnot, hadamard_transform. hinton(identity([2, 3]).unit()); hinton(Qobj([[1, 0.5], [0.5, 1]]).unit()). We show superoperators as matrices in the *Pauli basis*, such that any Hermicity-preserving map is represented by a real-valued matrix. This is especially convienent for use with Hinton diagrams, as the plot thus carries complete information about the channel. As an example, conjugation by :math:`\sigma_z` leaves :math:`\mathbb{1}` and :math:`\sigma_z` invariant, but flips the sign of :math:`\sigma_x` and :math:`\sigma_y`. This is indicated in Hinton diagrams by a negative-valued square for the sign change and a positive-valued square for a +1 sign. .. plot::; :context: close-figs. hinton(to_super(sigmaz())). As a couple more examples, we also consider the supermatrix for a Hadamard transform and for :math:`\sigma_z \otimes H`. .. plot::; :context: close-figs. hinton(to_super(hadamard_transform())); hinton(to_super(tensor(sigmaz(), hadamard_transform()))). .. _super-reduced-channels:. Reduced Channels; ================. As an example of tensor contraction, we now consider the map. .. math::. S(\rho)=\Tr_2 (\scriptstyle \rm CNOT (\rho \otimes \ket{0}\bra{0}) \scriptstyle \rm CNOT^\dagger). We can think of the :math:`\scriptstyle \rm CNOT` here as a system-environment representation of an open quantum process, in which an environment register is prepared in a state :math:`\rho_{\text{anc}}`, then a unitary acts jointly on the system of interest and environment. Finally, the environment is traced out, leaving a *channel* on the system alone. In terms of `Wood diagrams <http://arxiv.org/abs/1111.6950>`, this can be represented as the composition of a preparation map, evolution under the system-environment unitary, and then a measurement map. .. figure:: figures/sprep-wood-diagram.png; :align: center; :width: 2.5in. The two tensor wires on the left indicate where we must take a tensor contraction to obtain the measurement map.; Numbering the tensor wires fr",MatchSource.DOCS,doc/guide/guide-super.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-super.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-super.rst:348,Integrability,contract,contracts,348,".. _super:. *****************************************************; Superoperators, Pauli Basis and Channel Contraction; *****************************************************; written by `Christopher Granade <http://www.cgranade.com>`, Institute for Quantum Computing. In this guide, we will demonstrate the :func:`.tensor_contract` function, which contracts one or more pairs of indices of a Qobj. This functionality can be used to find rectangular superoperators that implement the partial trace channel :math:S(\rho) = \Tr_2(\rho)`, for instance. Using this functionality, we can quickly turn a system-environment representation of an open quantum process into a superoperator representation. .. _super-representation-plotting:. Superoperator Representations and Plotting; ==========================================. We start off by first demonstrating plotting of superoperators, as this will be useful to us in visualizing the results of a contracted channel. In particular, we will use Hinton diagrams as implemented by :func:`~qutip.visualization.hinton`, which; show the real parts of matrix elements as squares whose size and color both correspond to the magnitude of each element. To illustrate, we first plot a few density operators. .. plot::; :context: reset. from qutip import hinton, identity, Qobj, to_super, sigmaz, tensor, tensor_contract; from qutip.core.gates import cnot, hadamard_transform. hinton(identity([2, 3]).unit()); hinton(Qobj([[1, 0.5], [0.5, 1]]).unit()). We show superoperators as matrices in the *Pauli basis*, such that any Hermicity-preserving map is represented by a real-valued matrix. This is especially convienent for use with Hinton diagrams, as the plot thus carries complete information about the channel. As an example, conjugation by :math:`\sigma_z` leaves :math:`\mathbb{1}` and :math:`\sigma_z` invariant, but flips the sign of :math:`\sigma_x` and :math:`\sigma_y`. This is indicated in Hinton diagrams by a negative-valued square for the sign change a",MatchSource.DOCS,doc/guide/guide-super.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-super.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-super.rst:944,Integrability,contract,contracted,944,".. _super:. *****************************************************; Superoperators, Pauli Basis and Channel Contraction; *****************************************************; written by `Christopher Granade <http://www.cgranade.com>`, Institute for Quantum Computing. In this guide, we will demonstrate the :func:`.tensor_contract` function, which contracts one or more pairs of indices of a Qobj. This functionality can be used to find rectangular superoperators that implement the partial trace channel :math:S(\rho) = \Tr_2(\rho)`, for instance. Using this functionality, we can quickly turn a system-environment representation of an open quantum process into a superoperator representation. .. _super-representation-plotting:. Superoperator Representations and Plotting; ==========================================. We start off by first demonstrating plotting of superoperators, as this will be useful to us in visualizing the results of a contracted channel. In particular, we will use Hinton diagrams as implemented by :func:`~qutip.visualization.hinton`, which; show the real parts of matrix elements as squares whose size and color both correspond to the magnitude of each element. To illustrate, we first plot a few density operators. .. plot::; :context: reset. from qutip import hinton, identity, Qobj, to_super, sigmaz, tensor, tensor_contract; from qutip.core.gates import cnot, hadamard_transform. hinton(identity([2, 3]).unit()); hinton(Qobj([[1, 0.5], [0.5, 1]]).unit()). We show superoperators as matrices in the *Pauli basis*, such that any Hermicity-preserving map is represented by a real-valued matrix. This is especially convienent for use with Hinton diagrams, as the plot thus carries complete information about the channel. As an example, conjugation by :math:`\sigma_z` leaves :math:`\mathbb{1}` and :math:`\sigma_z` invariant, but flips the sign of :math:`\sigma_x` and :math:`\sigma_y`. This is indicated in Hinton diagrams by a negative-valued square for the sign change a",MatchSource.DOCS,doc/guide/guide-super.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-super.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-super.rst:2446,Integrability,contract,contraction,2446,"Qobj([[1, 0.5], [0.5, 1]]).unit()). We show superoperators as matrices in the *Pauli basis*, such that any Hermicity-preserving map is represented by a real-valued matrix. This is especially convienent for use with Hinton diagrams, as the plot thus carries complete information about the channel. As an example, conjugation by :math:`\sigma_z` leaves :math:`\mathbb{1}` and :math:`\sigma_z` invariant, but flips the sign of :math:`\sigma_x` and :math:`\sigma_y`. This is indicated in Hinton diagrams by a negative-valued square for the sign change and a positive-valued square for a +1 sign. .. plot::; :context: close-figs. hinton(to_super(sigmaz())). As a couple more examples, we also consider the supermatrix for a Hadamard transform and for :math:`\sigma_z \otimes H`. .. plot::; :context: close-figs. hinton(to_super(hadamard_transform())); hinton(to_super(tensor(sigmaz(), hadamard_transform()))). .. _super-reduced-channels:. Reduced Channels; ================. As an example of tensor contraction, we now consider the map. .. math::. S(\rho)=\Tr_2 (\scriptstyle \rm CNOT (\rho \otimes \ket{0}\bra{0}) \scriptstyle \rm CNOT^\dagger). We can think of the :math:`\scriptstyle \rm CNOT` here as a system-environment representation of an open quantum process, in which an environment register is prepared in a state :math:`\rho_{\text{anc}}`, then a unitary acts jointly on the system of interest and environment. Finally, the environment is traced out, leaving a *channel* on the system alone. In terms of `Wood diagrams <http://arxiv.org/abs/1111.6950>`, this can be represented as the composition of a preparation map, evolution under the system-environment unitary, and then a measurement map. .. figure:: figures/sprep-wood-diagram.png; :align: center; :width: 2.5in. The two tensor wires on the left indicate where we must take a tensor contraction to obtain the measurement map.; Numbering the tensor wires from 0 to 3, this corresponds to a :func:`.tensor_contract` argument of ``(1, 3)``",MatchSource.DOCS,doc/guide/guide-super.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-super.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-super.rst:3299,Integrability,contract,contraction,3299,"transform())); hinton(to_super(tensor(sigmaz(), hadamard_transform()))). .. _super-reduced-channels:. Reduced Channels; ================. As an example of tensor contraction, we now consider the map. .. math::. S(\rho)=\Tr_2 (\scriptstyle \rm CNOT (\rho \otimes \ket{0}\bra{0}) \scriptstyle \rm CNOT^\dagger). We can think of the :math:`\scriptstyle \rm CNOT` here as a system-environment representation of an open quantum process, in which an environment register is prepared in a state :math:`\rho_{\text{anc}}`, then a unitary acts jointly on the system of interest and environment. Finally, the environment is traced out, leaving a *channel* on the system alone. In terms of `Wood diagrams <http://arxiv.org/abs/1111.6950>`, this can be represented as the composition of a preparation map, evolution under the system-environment unitary, and then a measurement map. .. figure:: figures/sprep-wood-diagram.png; :align: center; :width: 2.5in. The two tensor wires on the left indicate where we must take a tensor contraction to obtain the measurement map.; Numbering the tensor wires from 0 to 3, this corresponds to a :func:`.tensor_contract` argument of ``(1, 3)``. .. plot::; :context:; :nofigs:. tensor_contract(to_super(identity([2, 2])), (1, 3)). Meanwhile, the :func:`.super_tensor` function implements the swap on the right, such that we can quickly find the preparation map. .. plot::; :context:; :nofigs:. q = tensor(identity(2), basis(2)); s_prep = sprepost(q, q.dag()). For a :math:`\scriptstyle \rm CNOT` system-environment model, the composition of these maps should give us a completely dephasing channel. The channel on both qubits is just the superunitary :math:`\scriptstyle \rm CNOT` channel:. .. plot::; :context: close-figs. hinton(to_super(cnot())). We now complete by multiplying the superunitary :math:`\scriptstyle \rm CNOT` by the preparation channel above, then applying the partial trace channel by contracting the second and fourth index indices. As expected, this gives",MatchSource.DOCS,doc/guide/guide-super.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-super.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-super.rst:4213,Integrability,contract,contracting,4213,". S(\rho)=\Tr_2 (\scriptstyle \rm CNOT (\rho \otimes \ket{0}\bra{0}) \scriptstyle \rm CNOT^\dagger). We can think of the :math:`\scriptstyle \rm CNOT` here as a system-environment representation of an open quantum process, in which an environment register is prepared in a state :math:`\rho_{\text{anc}}`, then a unitary acts jointly on the system of interest and environment. Finally, the environment is traced out, leaving a *channel* on the system alone. In terms of `Wood diagrams <http://arxiv.org/abs/1111.6950>`, this can be represented as the composition of a preparation map, evolution under the system-environment unitary, and then a measurement map. .. figure:: figures/sprep-wood-diagram.png; :align: center; :width: 2.5in. The two tensor wires on the left indicate where we must take a tensor contraction to obtain the measurement map.; Numbering the tensor wires from 0 to 3, this corresponds to a :func:`.tensor_contract` argument of ``(1, 3)``. .. plot::; :context:; :nofigs:. tensor_contract(to_super(identity([2, 2])), (1, 3)). Meanwhile, the :func:`.super_tensor` function implements the swap on the right, such that we can quickly find the preparation map. .. plot::; :context:; :nofigs:. q = tensor(identity(2), basis(2)); s_prep = sprepost(q, q.dag()). For a :math:`\scriptstyle \rm CNOT` system-environment model, the composition of these maps should give us a completely dephasing channel. The channel on both qubits is just the superunitary :math:`\scriptstyle \rm CNOT` channel:. .. plot::; :context: close-figs. hinton(to_super(cnot())). We now complete by multiplying the superunitary :math:`\scriptstyle \rm CNOT` by the preparation channel above, then applying the partial trace channel by contracting the second and fourth index indices. As expected, this gives us a dephasing map. .. plot::; :context: close-figs. hinton(tensor_contract(to_super(cnot()), (1, 3)) * s_prep). .. plot::; :context: reset; :include-source: false; :nofigs:. # reset the context at the end; ",MatchSource.DOCS,doc/guide/guide-super.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-super.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-super.rst:276,Usability,guid,guide,276,".. _super:. *****************************************************; Superoperators, Pauli Basis and Channel Contraction; *****************************************************; written by `Christopher Granade <http://www.cgranade.com>`, Institute for Quantum Computing. In this guide, we will demonstrate the :func:`.tensor_contract` function, which contracts one or more pairs of indices of a Qobj. This functionality can be used to find rectangular superoperators that implement the partial trace channel :math:S(\rho) = \Tr_2(\rho)`, for instance. Using this functionality, we can quickly turn a system-environment representation of an open quantum process into a superoperator representation. .. _super-representation-plotting:. Superoperator Representations and Plotting; ==========================================. We start off by first demonstrating plotting of superoperators, as this will be useful to us in visualizing the results of a contracted channel. In particular, we will use Hinton diagrams as implemented by :func:`~qutip.visualization.hinton`, which; show the real parts of matrix elements as squares whose size and color both correspond to the magnitude of each element. To illustrate, we first plot a few density operators. .. plot::; :context: reset. from qutip import hinton, identity, Qobj, to_super, sigmaz, tensor, tensor_contract; from qutip.core.gates import cnot, hadamard_transform. hinton(identity([2, 3]).unit()); hinton(Qobj([[1, 0.5], [0.5, 1]]).unit()). We show superoperators as matrices in the *Pauli basis*, such that any Hermicity-preserving map is represented by a real-valued matrix. This is especially convienent for use with Hinton diagrams, as the plot thus carries complete information about the channel. As an example, conjugation by :math:`\sigma_z` leaves :math:`\mathbb{1}` and :math:`\sigma_z` invariant, but flips the sign of :math:`\sigma_x` and :math:`\sigma_y`. This is indicated in Hinton diagrams by a negative-valued square for the sign change a",MatchSource.DOCS,doc/guide/guide-super.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-super.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-tensor.rst:2470,Availability,down,down,2470,", 2], [1, 1]], shape = (4, 1), type = ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]]. or equivalently using the ``list`` format:. .. testcode:: [tensor]. print(tensor([basis(2, 0), basis(2, 0)])). **Output**:. .. testoutput:: [tensor]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 2], [1, 1]], shape = (4, 1), type = ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]]. This is straightforward to generalize to more qubits by adding more component state vectors in the argument list to the :func:`~qutip.core.tensor.tensor` function, as illustrated in the following example:. .. testcode:: [tensor]. print(tensor((basis(2, 0) + basis(2, 1)).unit(), (basis(2, 0) + basis(2, 1)).unit(), basis(2, 0))). **Output**:. .. testoutput:: [tensor]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 2, 2], [1, 1, 1]], shape = (8, 1), type = ket; Qobj data =; [[0.5]; [0. ]; [0.5]; [0. ]; [0.5]; [0. ]; [0.5]; [0. ]]. This state is slightly more complicated, describing two qubits in a superposition between the up and down states, while the third qubit is in its ground state. To construct operators that act on an extended Hilbert space of a combined system, we similarly pass a list of operators for each component system to the :func:`~qutip.core.tensor.tensor` function. For example, to form the operator that represents the simultaneous action of the :math:`\sigma_x` operator on two qubits:. .. testcode:: [tensor]. print(tensor(sigmax(), sigmax())). **Output**:. .. testoutput:: [tensor]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True; Qobj data =; [[0. 0. 0. 1.]; [0. 0. 1. 0.]; [0. 1. 0. 0.]; [1. 0. 0. 0.]]. To create operators in a combined Hilbert space that only act on a single component, we take the tensor product of the operator acting on the subspace of interest, with the identity operators corresponding to the components that are to be unchanged. For example, the operator that represents :math:`\sigma_z",MatchSource.DOCS,doc/guide/guide-tensor.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-tensor.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-tensor.rst:4289,Energy Efficiency,energy,energy,4289,"s corresponding to the components that are to be unchanged. For example, the operator that represents :math:`\sigma_z` on the first qubit in a two-qubit system, while leaving the second qubit unaffected:. .. testcode:: [tensor]. print(tensor(sigmaz(), identity(2))). **Output**:. .. testoutput:: [tensor]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True; Qobj data =; [[ 1. 0. 0. 0.]; [ 0. 1. 0. 0.]; [ 0. 0. -1. 0.]; [ 0. 0. 0. -1.]]. .. _tensor-product-example:. Example: Constructing composite Hamiltonians; ============================================. The :func:`~qutip.core.tensor.tensor` function is extensively used when constructing Hamiltonians for composite systems. Here we'll look at some simple examples. .. _tensor-product-example-2qubits:. Two coupled qubits; ------------------. First, let's consider a system of two coupled qubits. Assume that both the qubits have equal energy splitting, and that the qubits are coupled through a :math:`\sigma_x\otimes\sigma_x` interaction with strength g = 0.05 (in units where the bare qubit energy splitting is unity). The Hamiltonian describing this system is:. .. testcode:: [tensor]. H = tensor(sigmaz(), identity(2)) + tensor(identity(2), sigmaz()) + 0.05 * tensor(sigmax(), sigmax()). print(H). **Output**:. .. testoutput:: [tensor]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True; Qobj data =; [[ 2. 0. 0. 0.05]; [ 0. 0. 0.05 0. ]; [ 0. 0.05 0. 0. ]; [ 0.05 0. 0. -2. ]]. .. _tensor-product-example-3qubits:. Three coupled qubits; --------------------. The two-qubit example is easily generalized to three coupled qubits:. .. testcode:: [tensor]. H = (tensor(sigmaz(), identity(2), identity(2)) + tensor(identity(2), sigmaz(), identity(2)) + tensor(identity(2), identity(2), sigmaz()) + 0.5 * tensor(sigmax(), sigmax(), identity(2)) + 0.25 * tensor(identity(2), sigmax(), sigmax())). print(H). **Out",MatchSource.DOCS,doc/guide/guide-tensor.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-tensor.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-tensor.rst:4447,Energy Efficiency,energy,energy,4447,"gma_z` on the first qubit in a two-qubit system, while leaving the second qubit unaffected:. .. testcode:: [tensor]. print(tensor(sigmaz(), identity(2))). **Output**:. .. testoutput:: [tensor]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True; Qobj data =; [[ 1. 0. 0. 0.]; [ 0. 1. 0. 0.]; [ 0. 0. -1. 0.]; [ 0. 0. 0. -1.]]. .. _tensor-product-example:. Example: Constructing composite Hamiltonians; ============================================. The :func:`~qutip.core.tensor.tensor` function is extensively used when constructing Hamiltonians for composite systems. Here we'll look at some simple examples. .. _tensor-product-example-2qubits:. Two coupled qubits; ------------------. First, let's consider a system of two coupled qubits. Assume that both the qubits have equal energy splitting, and that the qubits are coupled through a :math:`\sigma_x\otimes\sigma_x` interaction with strength g = 0.05 (in units where the bare qubit energy splitting is unity). The Hamiltonian describing this system is:. .. testcode:: [tensor]. H = tensor(sigmaz(), identity(2)) + tensor(identity(2), sigmaz()) + 0.05 * tensor(sigmax(), sigmax()). print(H). **Output**:. .. testoutput:: [tensor]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True; Qobj data =; [[ 2. 0. 0. 0.05]; [ 0. 0. 0.05 0. ]; [ 0. 0.05 0. 0. ]; [ 0.05 0. 0. -2. ]]. .. _tensor-product-example-3qubits:. Three coupled qubits; --------------------. The two-qubit example is easily generalized to three coupled qubits:. .. testcode:: [tensor]. H = (tensor(sigmaz(), identity(2), identity(2)) + tensor(identity(2), sigmaz(), identity(2)) + tensor(identity(2), identity(2), sigmaz()) + 0.5 * tensor(sigmax(), sigmax(), identity(2)) + 0.25 * tensor(identity(2), sigmax(), sigmax())). print(H). **Output**:. .. testoutput:: [tensor]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 2, 2], [2, 2, 2]],",MatchSource.DOCS,doc/guide/guide-tensor.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-tensor.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-tensor.rst:6188,Energy Efficiency,energy,energy,6188,"tensor(identity(2), sigmax(), sigmax())). print(H). **Output**:. .. testoutput:: [tensor]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 2, 2], [2, 2, 2]], shape = (8, 8), type = oper, isherm = True; Qobj data =; [[ 3. 0. 0. 0.25 0. 0. 0.5 0. ]; [ 0. 1. 0.25 0. 0. 0. 0. 0.5 ]; [ 0. 0.25 1. 0. 0.5 0. 0. 0. ]; [ 0.25 0. 0. -1. 0. 0.5 0. 0. ]; [ 0. 0. 0.5 0. 1. 0. 0. 0.25]; [ 0. 0. 0. 0.5 0. -1. 0.25 0. ]; [ 0.5 0. 0. 0. 0. 0.25 -1. 0. ]; [ 0. 0.5 0. 0. 0.25 0. 0. -3. ]]. .. _tensor-product-example-jcmodel:. A two-level system coupled to a cavity: The Jaynes-Cummings model; -------------------------------------------------------------------. The simplest possible quantum mechanical description for light-matter interaction is encapsulated in the Jaynes-Cummings model, which describes the coupling between a two-level atom and a single-mode electromagnetic field (a cavity mode). Denoting the energy splitting of the atom and cavity ``omega_a`` and ``omega_c``, respectively, and the atom-cavity interaction strength ``g``, the Jaynes-Cummings Hamiltonian can be constructed as:. .. plot::; :context: reset. N = 6. omega_a = 1.0. omega_c = 1.25. g = 0.75. a = tensor(identity(2), destroy(N)). sm = tensor(destroy(2), identity(N)). sz = tensor(sigmaz(), identity(N)). H = 0.5 * omega_a * sz + omega_c * a.dag() * a + g * (a.dag() * sm + a * sm.dag()). hinton(H, fig=plt.figure(figsize=(12, 12))). Here ``N`` is the number of Fock states included in the cavity mode. .. _tensor-ptrace:. Partial trace; =============. The partial trace is an operation that reduces the dimension of a Hilbert space by eliminating some degrees of freedom by averaging (tracing).; In this sense it is therefore the converse of the tensor product.; It is useful when one is interested in only a part of a coupled quantum system.; For open quantum systems, this typically involves tracing over the environment leaving only the system of interest.; In QuTiP the class method :meth:`~qutip.core.qobj.Qobj.",MatchSource.DOCS,doc/guide/guide-tensor.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-tensor.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-tensor.rst:6849,Energy Efficiency,reduce,reduces,6849,"------------------------------------------------------. The simplest possible quantum mechanical description for light-matter interaction is encapsulated in the Jaynes-Cummings model, which describes the coupling between a two-level atom and a single-mode electromagnetic field (a cavity mode). Denoting the energy splitting of the atom and cavity ``omega_a`` and ``omega_c``, respectively, and the atom-cavity interaction strength ``g``, the Jaynes-Cummings Hamiltonian can be constructed as:. .. plot::; :context: reset. N = 6. omega_a = 1.0. omega_c = 1.25. g = 0.75. a = tensor(identity(2), destroy(N)). sm = tensor(destroy(2), identity(N)). sz = tensor(sigmaz(), identity(N)). H = 0.5 * omega_a * sz + omega_c * a.dag() * a + g * (a.dag() * sm + a * sm.dag()). hinton(H, fig=plt.figure(figsize=(12, 12))). Here ``N`` is the number of Fock states included in the cavity mode. .. _tensor-ptrace:. Partial trace; =============. The partial trace is an operation that reduces the dimension of a Hilbert space by eliminating some degrees of freedom by averaging (tracing).; In this sense it is therefore the converse of the tensor product.; It is useful when one is interested in only a part of a coupled quantum system.; For open quantum systems, this typically involves tracing over the environment leaving only the system of interest.; In QuTiP the class method :meth:`~qutip.core.qobj.Qobj.ptrace` is used to take partial traces. :meth:`~qutip.core.qobj.Qobj.ptrace` acts on the :class:`~qutip.core.qobj.Qobj` instance for which it is called, and it takes one argument ``sel``, which is a ``list`` of integers that mark the component systems that should be **kept**.; All other components are traced out. For example, the density matrix describing a single qubit obtained from a coupled two-qubit system is obtained via:. .. doctest:: [tensor]; :options: +NORMALIZE_WHITESPACE. >>> psi = tensor(basis(2, 0), basis(2, 1)). >>> psi.ptrace(0); Quantum object: dims = [[2], [2]], shape = (2, 2), type ",MatchSource.DOCS,doc/guide/guide-tensor.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-tensor.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-tensor.rst:11416,Integrability,contract,contracting,11416,"er(A), to_super(B)).dims; [[[2], [2], [3], [3]], [[2], [2], [3], [3]]]. In the former case, the result correctly has four copies; of the compound index with dims ``[2, 3]``. In the latter; case, however, each of the Hilbert space indices is listed; independently and in the wrong order. The :func:`.super_tensor` function performs the needed; rearrangement, providing the most direct analog to :func:`.tensor` on; the underlying Hilbert space. In particular, for any two ``type=""oper""``; Qobjs ``A`` and ``B``, ``to_super(tensor(A, B)) == super_tensor(to_super(A), to_super(B))`` and; ``operator_to_vector(tensor(A, B)) == super_tensor(operator_to_vector(A), operator_to_vector(B))``. Returning to the previous example:. .. doctest:: [tensor]. >>> super_tensor(to_super(A), to_super(B)).dims; [[[2, 3], [2, 3]], [[2, 3], [2, 3]]]. The :func:`.composite` function automatically switches between; :func:`.tensor` and :func:`.super_tensor` based on the ``type``; of its arguments, such that ``composite(A, B)`` returns an appropriate Qobj to; represent the composition of two systems. .. doctest:: [tensor]. >>> composite(A, B).dims; [[2, 3], [2, 3]]. >>> composite(to_super(A), to_super(B)).dims; [[[2, 3], [2, 3]], [[2, 3], [2, 3]]]. QuTiP also allows more general tensor manipulations that are; useful for converting between superoperator representations [WBC11]_.; In particular, the :func:`~qutip.core.tensor.tensor_contract` function allows for; contracting one or more pairs of indices.; This can be used to find superoperators that represent partial trace maps.; Using this functionality, we can construct some quite exotic maps,; such as a map from :math:`3 \times 3` operators to :math:`2 \times 2`; operators:. .. doctest:: [tensor]. >>> tensor_contract(composite(to_super(A), to_super(B)), (1, 3), (4, 6)).dims; [[[2], [2]], [[3], [3]]]. ..; TODO: remake from notebook to tutorials; .. _channel contraction tutorial: github/qutip/qutip-notebooks/blob/master/examples/superop-contract.ipynb; ",MatchSource.DOCS,doc/guide/guide-tensor.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-tensor.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-tensor.rst:11871,Integrability,contract,contraction,11871,"er(A), to_super(B)).dims; [[[2], [2], [3], [3]], [[2], [2], [3], [3]]]. In the former case, the result correctly has four copies; of the compound index with dims ``[2, 3]``. In the latter; case, however, each of the Hilbert space indices is listed; independently and in the wrong order. The :func:`.super_tensor` function performs the needed; rearrangement, providing the most direct analog to :func:`.tensor` on; the underlying Hilbert space. In particular, for any two ``type=""oper""``; Qobjs ``A`` and ``B``, ``to_super(tensor(A, B)) == super_tensor(to_super(A), to_super(B))`` and; ``operator_to_vector(tensor(A, B)) == super_tensor(operator_to_vector(A), operator_to_vector(B))``. Returning to the previous example:. .. doctest:: [tensor]. >>> super_tensor(to_super(A), to_super(B)).dims; [[[2, 3], [2, 3]], [[2, 3], [2, 3]]]. The :func:`.composite` function automatically switches between; :func:`.tensor` and :func:`.super_tensor` based on the ``type``; of its arguments, such that ``composite(A, B)`` returns an appropriate Qobj to; represent the composition of two systems. .. doctest:: [tensor]. >>> composite(A, B).dims; [[2, 3], [2, 3]]. >>> composite(to_super(A), to_super(B)).dims; [[[2, 3], [2, 3]], [[2, 3], [2, 3]]]. QuTiP also allows more general tensor manipulations that are; useful for converting between superoperator representations [WBC11]_.; In particular, the :func:`~qutip.core.tensor.tensor_contract` function allows for; contracting one or more pairs of indices.; This can be used to find superoperators that represent partial trace maps.; Using this functionality, we can construct some quite exotic maps,; such as a map from :math:`3 \times 3` operators to :math:`2 \times 2`; operators:. .. doctest:: [tensor]. >>> tensor_contract(composite(to_super(A), to_super(B)), (1, 3), (4, 6)).dims; [[[2], [2]], [[3], [3]]]. ..; TODO: remake from notebook to tutorials; .. _channel contraction tutorial: github/qutip/qutip-notebooks/blob/master/examples/superop-contract.ipynb; ",MatchSource.DOCS,doc/guide/guide-tensor.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-tensor.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-tensor.rst:11951,Integrability,contract,contract,11951,"er(A), to_super(B)).dims; [[[2], [2], [3], [3]], [[2], [2], [3], [3]]]. In the former case, the result correctly has four copies; of the compound index with dims ``[2, 3]``. In the latter; case, however, each of the Hilbert space indices is listed; independently and in the wrong order. The :func:`.super_tensor` function performs the needed; rearrangement, providing the most direct analog to :func:`.tensor` on; the underlying Hilbert space. In particular, for any two ``type=""oper""``; Qobjs ``A`` and ``B``, ``to_super(tensor(A, B)) == super_tensor(to_super(A), to_super(B))`` and; ``operator_to_vector(tensor(A, B)) == super_tensor(operator_to_vector(A), operator_to_vector(B))``. Returning to the previous example:. .. doctest:: [tensor]. >>> super_tensor(to_super(A), to_super(B)).dims; [[[2, 3], [2, 3]], [[2, 3], [2, 3]]]. The :func:`.composite` function automatically switches between; :func:`.tensor` and :func:`.super_tensor` based on the ``type``; of its arguments, such that ``composite(A, B)`` returns an appropriate Qobj to; represent the composition of two systems. .. doctest:: [tensor]. >>> composite(A, B).dims; [[2, 3], [2, 3]]. >>> composite(to_super(A), to_super(B)).dims; [[[2, 3], [2, 3]], [[2, 3], [2, 3]]]. QuTiP also allows more general tensor manipulations that are; useful for converting between superoperator representations [WBC11]_.; In particular, the :func:`~qutip.core.tensor.tensor_contract` function allows for; contracting one or more pairs of indices.; This can be used to find superoperators that represent partial trace maps.; Using this functionality, we can construct some quite exotic maps,; such as a map from :math:`3 \times 3` operators to :math:`2 \times 2`; operators:. .. doctest:: [tensor]. >>> tensor_contract(composite(to_super(A), to_super(B)), (1, 3), (4, 6)).dims; [[[2], [2]], [[3], [3]]]. ..; TODO: remake from notebook to tutorials; .. _channel contraction tutorial: github/qutip/qutip-notebooks/blob/master/examples/superop-contract.ipynb; ",MatchSource.DOCS,doc/guide/guide-tensor.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-tensor.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-tensor.rst:2567,Modifiability,extend,extended,2567,"basis(2, 0), basis(2, 0)])). **Output**:. .. testoutput:: [tensor]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 2], [1, 1]], shape = (4, 1), type = ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]]. This is straightforward to generalize to more qubits by adding more component state vectors in the argument list to the :func:`~qutip.core.tensor.tensor` function, as illustrated in the following example:. .. testcode:: [tensor]. print(tensor((basis(2, 0) + basis(2, 1)).unit(), (basis(2, 0) + basis(2, 1)).unit(), basis(2, 0))). **Output**:. .. testoutput:: [tensor]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 2, 2], [1, 1, 1]], shape = (8, 1), type = ket; Qobj data =; [[0.5]; [0. ]; [0.5]; [0. ]; [0.5]; [0. ]; [0.5]; [0. ]]. This state is slightly more complicated, describing two qubits in a superposition between the up and down states, while the third qubit is in its ground state. To construct operators that act on an extended Hilbert space of a combined system, we similarly pass a list of operators for each component system to the :func:`~qutip.core.tensor.tensor` function. For example, to form the operator that represents the simultaneous action of the :math:`\sigma_x` operator on two qubits:. .. testcode:: [tensor]. print(tensor(sigmax(), sigmax())). **Output**:. .. testoutput:: [tensor]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True; Qobj data =; [[0. 0. 0. 1.]; [0. 0. 1. 0.]; [0. 1. 0. 0.]; [1. 0. 0. 0.]]. To create operators in a combined Hilbert space that only act on a single component, we take the tensor product of the operator acting on the subspace of interest, with the identity operators corresponding to the components that are to be unchanged. For example, the operator that represents :math:`\sigma_z` on the first qubit in a two-qubit system, while leaving the second qubit unaffected:. .. testcode:: [tensor]. print(tensor(sigmaz(), identity(2))). **Output**:. ..",MatchSource.DOCS,doc/guide/guide-tensor.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-tensor.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-tensor.rst:6084,Modifiability,coupling,coupling,6084," .. testcode:: [tensor]. H = (tensor(sigmaz(), identity(2), identity(2)) + tensor(identity(2), sigmaz(), identity(2)) + tensor(identity(2), identity(2), sigmaz()) + 0.5 * tensor(sigmax(), sigmax(), identity(2)) + 0.25 * tensor(identity(2), sigmax(), sigmax())). print(H). **Output**:. .. testoutput:: [tensor]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 2, 2], [2, 2, 2]], shape = (8, 8), type = oper, isherm = True; Qobj data =; [[ 3. 0. 0. 0.25 0. 0. 0.5 0. ]; [ 0. 1. 0.25 0. 0. 0. 0. 0.5 ]; [ 0. 0.25 1. 0. 0.5 0. 0. 0. ]; [ 0.25 0. 0. -1. 0. 0.5 0. 0. ]; [ 0. 0. 0.5 0. 1. 0. 0. 0.25]; [ 0. 0. 0. 0.5 0. -1. 0.25 0. ]; [ 0.5 0. 0. 0. 0. 0.25 -1. 0. ]; [ 0. 0.5 0. 0. 0.25 0. 0. -3. ]]. .. _tensor-product-example-jcmodel:. A two-level system coupled to a cavity: The Jaynes-Cummings model; -------------------------------------------------------------------. The simplest possible quantum mechanical description for light-matter interaction is encapsulated in the Jaynes-Cummings model, which describes the coupling between a two-level atom and a single-mode electromagnetic field (a cavity mode). Denoting the energy splitting of the atom and cavity ``omega_a`` and ``omega_c``, respectively, and the atom-cavity interaction strength ``g``, the Jaynes-Cummings Hamiltonian can be constructed as:. .. plot::; :context: reset. N = 6. omega_a = 1.0. omega_c = 1.25. g = 0.75. a = tensor(identity(2), destroy(N)). sm = tensor(destroy(2), identity(N)). sz = tensor(sigmaz(), identity(N)). H = 0.5 * omega_a * sz + omega_c * a.dag() * a + g * (a.dag() * sm + a * sm.dag()). hinton(H, fig=plt.figure(figsize=(12, 12))). Here ``N`` is the number of Fock states included in the cavity mode. .. _tensor-ptrace:. Partial trace; =============. The partial trace is an operation that reduces the dimension of a Hilbert space by eliminating some degrees of freedom by averaging (tracing).; In this sense it is therefore the converse of the tensor product.; It is useful when one is intereste",MatchSource.DOCS,doc/guide/guide-tensor.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-tensor.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-tensor.rst:10289,Performance,perform,performs,10289,"ed; using the isomorphism; :math:`\mathrm{vec} : \mathcal{L}(\mathcal{H}) \to \mathcal{H} \otimes \mathcal{H}` [Hav03]_, [Wat13]_.; To represent superoperators acting on :math:`\mathcal{L}(\mathcal{H}_1 \otimes \mathcal{H}_2)` thus takes some tensor rearrangement to get the desired ordering; :math:`\mathcal{H}_1 \otimes \mathcal{H}_2 \otimes \mathcal{H}_1 \otimes \mathcal{H}_2`. In particular, this means that :func:`.tensor` does not act as; one might expect on the results of :func:`.to_super`:. .. doctest:: [tensor]. >>> A = qeye([2]). >>> B = qeye([3]). >>> to_super(tensor(A, B)).dims; [[[2, 3], [2, 3]], [[2, 3], [2, 3]]]. >>> tensor(to_super(A), to_super(B)).dims; [[[2], [2], [3], [3]], [[2], [2], [3], [3]]]. In the former case, the result correctly has four copies; of the compound index with dims ``[2, 3]``. In the latter; case, however, each of the Hilbert space indices is listed; independently and in the wrong order. The :func:`.super_tensor` function performs the needed; rearrangement, providing the most direct analog to :func:`.tensor` on; the underlying Hilbert space. In particular, for any two ``type=""oper""``; Qobjs ``A`` and ``B``, ``to_super(tensor(A, B)) == super_tensor(to_super(A), to_super(B))`` and; ``operator_to_vector(tensor(A, B)) == super_tensor(operator_to_vector(A), operator_to_vector(B))``. Returning to the previous example:. .. doctest:: [tensor]. >>> super_tensor(to_super(A), to_super(B)).dims; [[[2, 3], [2, 3]], [[2, 3], [2, 3]]]. The :func:`.composite` function automatically switches between; :func:`.tensor` and :func:`.super_tensor` based on the ``type``; of its arguments, such that ``composite(A, B)`` returns an appropriate Qobj to; represent the composition of two systems. .. doctest:: [tensor]. >>> composite(A, B).dims; [[2, 3], [2, 3]]. >>> composite(to_super(A), to_super(B)).dims; [[[2, 3], [2, 3]], [[2, 3], [2, 3]]]. QuTiP also allows more general tensor manipulations that are; useful for converting between superoperator representati",MatchSource.DOCS,doc/guide/guide-tensor.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-tensor.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-tensor.rst:1288,Testability,test,testcode,1288,"ed to an oscillator, etc. - we need to expand the Hilbert space by taking the tensor product of the state vectors for each of the system components. Similarly, the operators acting on the state vectors in the combined Hilbert space (describing the coupled system) are formed by taking the tensor product of the individual operators. In QuTiP the function :func:`~qutip.core.tensor.tensor` is used to accomplish this task. This function takes as argument a collection::. >>> tensor(op1, op2, op3) # doctest: +SKIP. or a ``list``::. >>> tensor([op1, op2, op3]) # doctest: +SKIP. of state vectors *or* operators and returns a composite quantum object for the combined Hilbert space. The function accepts an arbitrary number of states or operators as argument. The type returned quantum object is the same as that of the input(s). For example, the state vector describing two qubits in their ground states is formed by taking the tensor product of the two single-qubit ground state vectors:. .. testcode:: [tensor]. print(tensor(basis(2, 0), basis(2, 0))). **Output**:. .. testoutput:: [tensor]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 2], [1, 1]], shape = (4, 1), type = ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]]. or equivalently using the ``list`` format:. .. testcode:: [tensor]. print(tensor([basis(2, 0), basis(2, 0)])). **Output**:. .. testoutput:: [tensor]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 2], [1, 1]], shape = (4, 1), type = ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]]. This is straightforward to generalize to more qubits by adding more component state vectors in the argument list to the :func:`~qutip.core.tensor.tensor` function, as illustrated in the following example:. .. testcode:: [tensor]. print(tensor((basis(2, 0) + basis(2, 1)).unit(), (basis(2, 0) + basis(2, 1)).unit(), basis(2, 0))). **Output**:. .. testoutput:: [tensor]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 2, 2], [1, 1, 1]], shape = (8, 1), type = ket; ",MatchSource.DOCS,doc/guide/guide-tensor.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-tensor.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-tensor.rst:1366,Testability,test,testoutput,1366,"the state vectors for each of the system components. Similarly, the operators acting on the state vectors in the combined Hilbert space (describing the coupled system) are formed by taking the tensor product of the individual operators. In QuTiP the function :func:`~qutip.core.tensor.tensor` is used to accomplish this task. This function takes as argument a collection::. >>> tensor(op1, op2, op3) # doctest: +SKIP. or a ``list``::. >>> tensor([op1, op2, op3]) # doctest: +SKIP. of state vectors *or* operators and returns a composite quantum object for the combined Hilbert space. The function accepts an arbitrary number of states or operators as argument. The type returned quantum object is the same as that of the input(s). For example, the state vector describing two qubits in their ground states is formed by taking the tensor product of the two single-qubit ground state vectors:. .. testcode:: [tensor]. print(tensor(basis(2, 0), basis(2, 0))). **Output**:. .. testoutput:: [tensor]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 2], [1, 1]], shape = (4, 1), type = ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]]. or equivalently using the ``list`` format:. .. testcode:: [tensor]. print(tensor([basis(2, 0), basis(2, 0)])). **Output**:. .. testoutput:: [tensor]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 2], [1, 1]], shape = (4, 1), type = ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]]. This is straightforward to generalize to more qubits by adding more component state vectors in the argument list to the :func:`~qutip.core.tensor.tensor` function, as illustrated in the following example:. .. testcode:: [tensor]. print(tensor((basis(2, 0) + basis(2, 1)).unit(), (basis(2, 0) + basis(2, 1)).unit(), basis(2, 0))). **Output**:. .. testoutput:: [tensor]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 2, 2], [1, 1, 1]], shape = (8, 1), type = ket; Qobj data =; [[0.5]; [0. ]; [0.5]; [0. ]; [0.5]; [0. ]; [0.5]; [0. ]]. This state is slightly m",MatchSource.DOCS,doc/guide/guide-tensor.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-tensor.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-tensor.rst:1577,Testability,test,testcode,1577,"tensor product of the individual operators. In QuTiP the function :func:`~qutip.core.tensor.tensor` is used to accomplish this task. This function takes as argument a collection::. >>> tensor(op1, op2, op3) # doctest: +SKIP. or a ``list``::. >>> tensor([op1, op2, op3]) # doctest: +SKIP. of state vectors *or* operators and returns a composite quantum object for the combined Hilbert space. The function accepts an arbitrary number of states or operators as argument. The type returned quantum object is the same as that of the input(s). For example, the state vector describing two qubits in their ground states is formed by taking the tensor product of the two single-qubit ground state vectors:. .. testcode:: [tensor]. print(tensor(basis(2, 0), basis(2, 0))). **Output**:. .. testoutput:: [tensor]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 2], [1, 1]], shape = (4, 1), type = ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]]. or equivalently using the ``list`` format:. .. testcode:: [tensor]. print(tensor([basis(2, 0), basis(2, 0)])). **Output**:. .. testoutput:: [tensor]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 2], [1, 1]], shape = (4, 1), type = ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]]. This is straightforward to generalize to more qubits by adding more component state vectors in the argument list to the :func:`~qutip.core.tensor.tensor` function, as illustrated in the following example:. .. testcode:: [tensor]. print(tensor((basis(2, 0) + basis(2, 1)).unit(), (basis(2, 0) + basis(2, 1)).unit(), basis(2, 0))). **Output**:. .. testoutput:: [tensor]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 2, 2], [1, 1, 1]], shape = (8, 1), type = ket; Qobj data =; [[0.5]; [0. ]; [0.5]; [0. ]; [0.5]; [0. ]; [0.5]; [0. ]]. This state is slightly more complicated, describing two qubits in a superposition between the up and down states, while the third qubit is in its ground state. To construct operators that act on an extended Hilbert spa",MatchSource.DOCS,doc/guide/guide-tensor.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-tensor.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-tensor.rst:1657,Testability,test,testoutput,1657,"` is used to accomplish this task. This function takes as argument a collection::. >>> tensor(op1, op2, op3) # doctest: +SKIP. or a ``list``::. >>> tensor([op1, op2, op3]) # doctest: +SKIP. of state vectors *or* operators and returns a composite quantum object for the combined Hilbert space. The function accepts an arbitrary number of states or operators as argument. The type returned quantum object is the same as that of the input(s). For example, the state vector describing two qubits in their ground states is formed by taking the tensor product of the two single-qubit ground state vectors:. .. testcode:: [tensor]. print(tensor(basis(2, 0), basis(2, 0))). **Output**:. .. testoutput:: [tensor]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 2], [1, 1]], shape = (4, 1), type = ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]]. or equivalently using the ``list`` format:. .. testcode:: [tensor]. print(tensor([basis(2, 0), basis(2, 0)])). **Output**:. .. testoutput:: [tensor]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 2], [1, 1]], shape = (4, 1), type = ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]]. This is straightforward to generalize to more qubits by adding more component state vectors in the argument list to the :func:`~qutip.core.tensor.tensor` function, as illustrated in the following example:. .. testcode:: [tensor]. print(tensor((basis(2, 0) + basis(2, 1)).unit(), (basis(2, 0) + basis(2, 1)).unit(), basis(2, 0))). **Output**:. .. testoutput:: [tensor]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 2, 2], [1, 1, 1]], shape = (8, 1), type = ket; Qobj data =; [[0.5]; [0. ]; [0.5]; [0. ]; [0.5]; [0. ]; [0.5]; [0. ]]. This state is slightly more complicated, describing two qubits in a superposition between the up and down states, while the third qubit is in its ground state. To construct operators that act on an extended Hilbert space of a combined system, we similarly pass a list of operators for each component system to the :",MatchSource.DOCS,doc/guide/guide-tensor.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-tensor.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-tensor.rst:2030,Testability,test,testcode,2030,"s as argument. The type returned quantum object is the same as that of the input(s). For example, the state vector describing two qubits in their ground states is formed by taking the tensor product of the two single-qubit ground state vectors:. .. testcode:: [tensor]. print(tensor(basis(2, 0), basis(2, 0))). **Output**:. .. testoutput:: [tensor]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 2], [1, 1]], shape = (4, 1), type = ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]]. or equivalently using the ``list`` format:. .. testcode:: [tensor]. print(tensor([basis(2, 0), basis(2, 0)])). **Output**:. .. testoutput:: [tensor]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 2], [1, 1]], shape = (4, 1), type = ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]]. This is straightforward to generalize to more qubits by adding more component state vectors in the argument list to the :func:`~qutip.core.tensor.tensor` function, as illustrated in the following example:. .. testcode:: [tensor]. print(tensor((basis(2, 0) + basis(2, 1)).unit(), (basis(2, 0) + basis(2, 1)).unit(), basis(2, 0))). **Output**:. .. testoutput:: [tensor]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 2, 2], [1, 1, 1]], shape = (8, 1), type = ket; Qobj data =; [[0.5]; [0. ]; [0.5]; [0. ]; [0.5]; [0. ]; [0.5]; [0. ]]. This state is slightly more complicated, describing two qubits in a superposition between the up and down states, while the third qubit is in its ground state. To construct operators that act on an extended Hilbert space of a combined system, we similarly pass a list of operators for each component system to the :func:`~qutip.core.tensor.tensor` function. For example, to form the operator that represents the simultaneous action of the :math:`\sigma_x` operator on two qubits:. .. testcode:: [tensor]. print(tensor(sigmax(), sigmax())). **Output**:. .. testoutput:: [tensor]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), ty",MatchSource.DOCS,doc/guide/guide-tensor.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-tensor.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-tensor.rst:2167,Testability,test,testoutput,2167,"ates is formed by taking the tensor product of the two single-qubit ground state vectors:. .. testcode:: [tensor]. print(tensor(basis(2, 0), basis(2, 0))). **Output**:. .. testoutput:: [tensor]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 2], [1, 1]], shape = (4, 1), type = ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]]. or equivalently using the ``list`` format:. .. testcode:: [tensor]. print(tensor([basis(2, 0), basis(2, 0)])). **Output**:. .. testoutput:: [tensor]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 2], [1, 1]], shape = (4, 1), type = ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]]. This is straightforward to generalize to more qubits by adding more component state vectors in the argument list to the :func:`~qutip.core.tensor.tensor` function, as illustrated in the following example:. .. testcode:: [tensor]. print(tensor((basis(2, 0) + basis(2, 1)).unit(), (basis(2, 0) + basis(2, 1)).unit(), basis(2, 0))). **Output**:. .. testoutput:: [tensor]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 2, 2], [1, 1, 1]], shape = (8, 1), type = ket; Qobj data =; [[0.5]; [0. ]; [0.5]; [0. ]; [0.5]; [0. ]; [0.5]; [0. ]]. This state is slightly more complicated, describing two qubits in a superposition between the up and down states, while the third qubit is in its ground state. To construct operators that act on an extended Hilbert space of a combined system, we similarly pass a list of operators for each component system to the :func:`~qutip.core.tensor.tensor` function. For example, to form the operator that represents the simultaneous action of the :math:`\sigma_x` operator on two qubits:. .. testcode:: [tensor]. print(tensor(sigmax(), sigmax())). **Output**:. .. testoutput:: [tensor]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True; Qobj data =; [[0. 0. 0. 1.]; [0. 0. 1. 0.]; [0. 1. 0. 0.]; [1. 0. 0. 0.]]. To create operators in a combined Hilbert space that ",MatchSource.DOCS,doc/guide/guide-tensor.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-tensor.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-tensor.rst:2853,Testability,test,testcode,2853,"more qubits by adding more component state vectors in the argument list to the :func:`~qutip.core.tensor.tensor` function, as illustrated in the following example:. .. testcode:: [tensor]. print(tensor((basis(2, 0) + basis(2, 1)).unit(), (basis(2, 0) + basis(2, 1)).unit(), basis(2, 0))). **Output**:. .. testoutput:: [tensor]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 2, 2], [1, 1, 1]], shape = (8, 1), type = ket; Qobj data =; [[0.5]; [0. ]; [0.5]; [0. ]; [0.5]; [0. ]; [0.5]; [0. ]]. This state is slightly more complicated, describing two qubits in a superposition between the up and down states, while the third qubit is in its ground state. To construct operators that act on an extended Hilbert space of a combined system, we similarly pass a list of operators for each component system to the :func:`~qutip.core.tensor.tensor` function. For example, to form the operator that represents the simultaneous action of the :math:`\sigma_x` operator on two qubits:. .. testcode:: [tensor]. print(tensor(sigmax(), sigmax())). **Output**:. .. testoutput:: [tensor]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True; Qobj data =; [[0. 0. 0. 1.]; [0. 0. 1. 0.]; [0. 1. 0. 0.]; [1. 0. 0. 0.]]. To create operators in a combined Hilbert space that only act on a single component, we take the tensor product of the operator acting on the subspace of interest, with the identity operators corresponding to the components that are to be unchanged. For example, the operator that represents :math:`\sigma_z` on the first qubit in a two-qubit system, while leaving the second qubit unaffected:. .. testcode:: [tensor]. print(tensor(sigmaz(), identity(2))). **Output**:. .. testoutput:: [tensor]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True; Qobj data =; [[ 1. 0. 0. 0.]; [ 0. 1. 0. 0.]; [ 0. 0. -1. 0.]; [ 0. 0. 0. -1.]]. .. _tensor-product-example:",MatchSource.DOCS,doc/guide/guide-tensor.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-tensor.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-tensor.rst:2925,Testability,test,testoutput,2925,"ip.core.tensor.tensor` function, as illustrated in the following example:. .. testcode:: [tensor]. print(tensor((basis(2, 0) + basis(2, 1)).unit(), (basis(2, 0) + basis(2, 1)).unit(), basis(2, 0))). **Output**:. .. testoutput:: [tensor]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 2, 2], [1, 1, 1]], shape = (8, 1), type = ket; Qobj data =; [[0.5]; [0. ]; [0.5]; [0. ]; [0.5]; [0. ]; [0.5]; [0. ]]. This state is slightly more complicated, describing two qubits in a superposition between the up and down states, while the third qubit is in its ground state. To construct operators that act on an extended Hilbert space of a combined system, we similarly pass a list of operators for each component system to the :func:`~qutip.core.tensor.tensor` function. For example, to form the operator that represents the simultaneous action of the :math:`\sigma_x` operator on two qubits:. .. testcode:: [tensor]. print(tensor(sigmax(), sigmax())). **Output**:. .. testoutput:: [tensor]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True; Qobj data =; [[0. 0. 0. 1.]; [0. 0. 1. 0.]; [0. 1. 0. 0.]; [1. 0. 0. 0.]]. To create operators in a combined Hilbert space that only act on a single component, we take the tensor product of the operator acting on the subspace of interest, with the identity operators corresponding to the components that are to be unchanged. For example, the operator that represents :math:`\sigma_z` on the first qubit in a two-qubit system, while leaving the second qubit unaffected:. .. testcode:: [tensor]. print(tensor(sigmaz(), identity(2))). **Output**:. .. testoutput:: [tensor]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True; Qobj data =; [[ 1. 0. 0. 0.]; [ 0. 1. 0. 0.]; [ 0. 0. -1. 0.]; [ 0. 0. 0. -1.]]. .. _tensor-product-example:. Example: Constructing composite Hamiltonians; =========================================",MatchSource.DOCS,doc/guide/guide-tensor.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-tensor.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-tensor.rst:3539,Testability,test,testcode,3539,"ors that act on an extended Hilbert space of a combined system, we similarly pass a list of operators for each component system to the :func:`~qutip.core.tensor.tensor` function. For example, to form the operator that represents the simultaneous action of the :math:`\sigma_x` operator on two qubits:. .. testcode:: [tensor]. print(tensor(sigmax(), sigmax())). **Output**:. .. testoutput:: [tensor]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True; Qobj data =; [[0. 0. 0. 1.]; [0. 0. 1. 0.]; [0. 1. 0. 0.]; [1. 0. 0. 0.]]. To create operators in a combined Hilbert space that only act on a single component, we take the tensor product of the operator acting on the subspace of interest, with the identity operators corresponding to the components that are to be unchanged. For example, the operator that represents :math:`\sigma_z` on the first qubit in a two-qubit system, while leaving the second qubit unaffected:. .. testcode:: [tensor]. print(tensor(sigmaz(), identity(2))). **Output**:. .. testoutput:: [tensor]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True; Qobj data =; [[ 1. 0. 0. 0.]; [ 0. 1. 0. 0.]; [ 0. 0. -1. 0.]; [ 0. 0. 0. -1.]]. .. _tensor-product-example:. Example: Constructing composite Hamiltonians; ============================================. The :func:`~qutip.core.tensor.tensor` function is extensively used when constructing Hamiltonians for composite systems. Here we'll look at some simple examples. .. _tensor-product-example-2qubits:. Two coupled qubits; ------------------. First, let's consider a system of two coupled qubits. Assume that both the qubits have equal energy splitting, and that the qubits are coupled through a :math:`\sigma_x\otimes\sigma_x` interaction with strength g = 0.05 (in units where the bare qubit energy splitting is unity). The Hamiltonian describing this system is:. .. testcode:: [tensor]. H = te",MatchSource.DOCS,doc/guide/guide-tensor.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-tensor.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-tensor.rst:3614,Testability,test,testoutput,3614,"perators for each component system to the :func:`~qutip.core.tensor.tensor` function. For example, to form the operator that represents the simultaneous action of the :math:`\sigma_x` operator on two qubits:. .. testcode:: [tensor]. print(tensor(sigmax(), sigmax())). **Output**:. .. testoutput:: [tensor]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True; Qobj data =; [[0. 0. 0. 1.]; [0. 0. 1. 0.]; [0. 1. 0. 0.]; [1. 0. 0. 0.]]. To create operators in a combined Hilbert space that only act on a single component, we take the tensor product of the operator acting on the subspace of interest, with the identity operators corresponding to the components that are to be unchanged. For example, the operator that represents :math:`\sigma_z` on the first qubit in a two-qubit system, while leaving the second qubit unaffected:. .. testcode:: [tensor]. print(tensor(sigmaz(), identity(2))). **Output**:. .. testoutput:: [tensor]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True; Qobj data =; [[ 1. 0. 0. 0.]; [ 0. 1. 0. 0.]; [ 0. 0. -1. 0.]; [ 0. 0. 0. -1.]]. .. _tensor-product-example:. Example: Constructing composite Hamiltonians; ============================================. The :func:`~qutip.core.tensor.tensor` function is extensively used when constructing Hamiltonians for composite systems. Here we'll look at some simple examples. .. _tensor-product-example-2qubits:. Two coupled qubits; ------------------. First, let's consider a system of two coupled qubits. Assume that both the qubits have equal energy splitting, and that the qubits are coupled through a :math:`\sigma_x\otimes\sigma_x` interaction with strength g = 0.05 (in units where the bare qubit energy splitting is unity). The Hamiltonian describing this system is:. .. testcode:: [tensor]. H = tensor(sigmaz(), identity(2)) + tensor(identity(2), sigmaz()) + 0.05 * tensor(sigmax(), sigmax",MatchSource.DOCS,doc/guide/guide-tensor.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-tensor.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-tensor.rst:4522,Testability,test,testcode,4522,"ed:. .. testcode:: [tensor]. print(tensor(sigmaz(), identity(2))). **Output**:. .. testoutput:: [tensor]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True; Qobj data =; [[ 1. 0. 0. 0.]; [ 0. 1. 0. 0.]; [ 0. 0. -1. 0.]; [ 0. 0. 0. -1.]]. .. _tensor-product-example:. Example: Constructing composite Hamiltonians; ============================================. The :func:`~qutip.core.tensor.tensor` function is extensively used when constructing Hamiltonians for composite systems. Here we'll look at some simple examples. .. _tensor-product-example-2qubits:. Two coupled qubits; ------------------. First, let's consider a system of two coupled qubits. Assume that both the qubits have equal energy splitting, and that the qubits are coupled through a :math:`\sigma_x\otimes\sigma_x` interaction with strength g = 0.05 (in units where the bare qubit energy splitting is unity). The Hamiltonian describing this system is:. .. testcode:: [tensor]. H = tensor(sigmaz(), identity(2)) + tensor(identity(2), sigmaz()) + 0.05 * tensor(sigmax(), sigmax()). print(H). **Output**:. .. testoutput:: [tensor]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True; Qobj data =; [[ 2. 0. 0. 0.05]; [ 0. 0. 0.05 0. ]; [ 0. 0.05 0. 0. ]; [ 0.05 0. 0. -2. ]]. .. _tensor-product-example-3qubits:. Three coupled qubits; --------------------. The two-qubit example is easily generalized to three coupled qubits:. .. testcode:: [tensor]. H = (tensor(sigmaz(), identity(2), identity(2)) + tensor(identity(2), sigmaz(), identity(2)) + tensor(identity(2), identity(2), sigmaz()) + 0.5 * tensor(sigmax(), sigmax(), identity(2)) + 0.25 * tensor(identity(2), sigmax(), sigmax())). print(H). **Output**:. .. testoutput:: [tensor]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 2, 2], [2, 2, 2]], shape = (8, 8), type = oper, isherm = True; Qobj data =; [[ 3. 0. 0. 0.25 0. 0. 0.5 0. ",MatchSource.DOCS,doc/guide/guide-tensor.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-tensor.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-tensor.rst:4672,Testability,test,testoutput,4672,"], [2, 2]], shape = (4, 4), type = oper, isherm = True; Qobj data =; [[ 1. 0. 0. 0.]; [ 0. 1. 0. 0.]; [ 0. 0. -1. 0.]; [ 0. 0. 0. -1.]]. .. _tensor-product-example:. Example: Constructing composite Hamiltonians; ============================================. The :func:`~qutip.core.tensor.tensor` function is extensively used when constructing Hamiltonians for composite systems. Here we'll look at some simple examples. .. _tensor-product-example-2qubits:. Two coupled qubits; ------------------. First, let's consider a system of two coupled qubits. Assume that both the qubits have equal energy splitting, and that the qubits are coupled through a :math:`\sigma_x\otimes\sigma_x` interaction with strength g = 0.05 (in units where the bare qubit energy splitting is unity). The Hamiltonian describing this system is:. .. testcode:: [tensor]. H = tensor(sigmaz(), identity(2)) + tensor(identity(2), sigmaz()) + 0.05 * tensor(sigmax(), sigmax()). print(H). **Output**:. .. testoutput:: [tensor]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True; Qobj data =; [[ 2. 0. 0. 0.05]; [ 0. 0. 0.05 0. ]; [ 0. 0.05 0. 0. ]; [ 0.05 0. 0. -2. ]]. .. _tensor-product-example-3qubits:. Three coupled qubits; --------------------. The two-qubit example is easily generalized to three coupled qubits:. .. testcode:: [tensor]. H = (tensor(sigmaz(), identity(2), identity(2)) + tensor(identity(2), sigmaz(), identity(2)) + tensor(identity(2), identity(2), sigmaz()) + 0.5 * tensor(sigmax(), sigmax(), identity(2)) + 0.25 * tensor(identity(2), sigmax(), sigmax())). print(H). **Output**:. .. testoutput:: [tensor]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 2, 2], [2, 2, 2]], shape = (8, 8), type = oper, isherm = True; Qobj data =; [[ 3. 0. 0. 0.25 0. 0. 0.5 0. ]; [ 0. 1. 0.25 0. 0. 0. 0. 0.5 ]; [ 0. 0.25 1. 0. 0.5 0. 0. 0. ]; [ 0.25 0. 0. -1. 0. 0.5 0. 0. ]; [ 0. 0. 0.5 0. 1. 0. 0. 0.25]; [ 0. 0. 0. 0.5 0. -1. 0.25 0. ]; [ 0",MatchSource.DOCS,doc/guide/guide-tensor.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-tensor.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-tensor.rst:5058,Testability,test,testcode,5058,"e systems. Here we'll look at some simple examples. .. _tensor-product-example-2qubits:. Two coupled qubits; ------------------. First, let's consider a system of two coupled qubits. Assume that both the qubits have equal energy splitting, and that the qubits are coupled through a :math:`\sigma_x\otimes\sigma_x` interaction with strength g = 0.05 (in units where the bare qubit energy splitting is unity). The Hamiltonian describing this system is:. .. testcode:: [tensor]. H = tensor(sigmaz(), identity(2)) + tensor(identity(2), sigmaz()) + 0.05 * tensor(sigmax(), sigmax()). print(H). **Output**:. .. testoutput:: [tensor]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True; Qobj data =; [[ 2. 0. 0. 0.05]; [ 0. 0. 0.05 0. ]; [ 0. 0.05 0. 0. ]; [ 0.05 0. 0. -2. ]]. .. _tensor-product-example-3qubits:. Three coupled qubits; --------------------. The two-qubit example is easily generalized to three coupled qubits:. .. testcode:: [tensor]. H = (tensor(sigmaz(), identity(2), identity(2)) + tensor(identity(2), sigmaz(), identity(2)) + tensor(identity(2), identity(2), sigmaz()) + 0.5 * tensor(sigmax(), sigmax(), identity(2)) + 0.25 * tensor(identity(2), sigmax(), sigmax())). print(H). **Output**:. .. testoutput:: [tensor]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 2, 2], [2, 2, 2]], shape = (8, 8), type = oper, isherm = True; Qobj data =; [[ 3. 0. 0. 0.25 0. 0. 0.5 0. ]; [ 0. 1. 0.25 0. 0. 0. 0. 0.5 ]; [ 0. 0.25 1. 0. 0.5 0. 0. 0. ]; [ 0.25 0. 0. -1. 0. 0.5 0. 0. ]; [ 0. 0. 0.5 0. 1. 0. 0. 0.25]; [ 0. 0. 0. 0.5 0. -1. 0.25 0. ]; [ 0.5 0. 0. 0. 0. 0.25 -1. 0. ]; [ 0. 0.5 0. 0. 0.25 0. 0. -3. ]]. .. _tensor-product-example-jcmodel:. A two-level system coupled to a cavity: The Jaynes-Cummings model; -------------------------------------------------------------------. The simplest possible quantum mechanical description for light-matter interaction is encapsulated in the Jaynes-Cummings model, whic",MatchSource.DOCS,doc/guide/guide-tensor.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-tensor.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-tensor.rst:5342,Testability,test,testoutput,5342,"es\sigma_x` interaction with strength g = 0.05 (in units where the bare qubit energy splitting is unity). The Hamiltonian describing this system is:. .. testcode:: [tensor]. H = tensor(sigmaz(), identity(2)) + tensor(identity(2), sigmaz()) + 0.05 * tensor(sigmax(), sigmax()). print(H). **Output**:. .. testoutput:: [tensor]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True; Qobj data =; [[ 2. 0. 0. 0.05]; [ 0. 0. 0.05 0. ]; [ 0. 0.05 0. 0. ]; [ 0.05 0. 0. -2. ]]. .. _tensor-product-example-3qubits:. Three coupled qubits; --------------------. The two-qubit example is easily generalized to three coupled qubits:. .. testcode:: [tensor]. H = (tensor(sigmaz(), identity(2), identity(2)) + tensor(identity(2), sigmaz(), identity(2)) + tensor(identity(2), identity(2), sigmaz()) + 0.5 * tensor(sigmax(), sigmax(), identity(2)) + 0.25 * tensor(identity(2), sigmax(), sigmax())). print(H). **Output**:. .. testoutput:: [tensor]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 2, 2], [2, 2, 2]], shape = (8, 8), type = oper, isherm = True; Qobj data =; [[ 3. 0. 0. 0.25 0. 0. 0.5 0. ]; [ 0. 1. 0.25 0. 0. 0. 0. 0.5 ]; [ 0. 0.25 1. 0. 0.5 0. 0. 0. ]; [ 0.25 0. 0. -1. 0. 0.5 0. 0. ]; [ 0. 0. 0.5 0. 1. 0. 0. 0.25]; [ 0. 0. 0. 0.5 0. -1. 0.25 0. ]; [ 0.5 0. 0. 0. 0. 0.25 -1. 0. ]; [ 0. 0.5 0. 0. 0.25 0. 0. -3. ]]. .. _tensor-product-example-jcmodel:. A two-level system coupled to a cavity: The Jaynes-Cummings model; -------------------------------------------------------------------. The simplest possible quantum mechanical description for light-matter interaction is encapsulated in the Jaynes-Cummings model, which describes the coupling between a two-level atom and a single-mode electromagnetic field (a cavity mode). Denoting the energy splitting of the atom and cavity ``omega_a`` and ``omega_c``, respectively, and the atom-cavity interaction strength ``g``, the Jaynes-Cummings Hamiltonian can be constructed",MatchSource.DOCS,doc/guide/guide-tensor.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-tensor.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-tensor.rst:4102,Usability,simpl,simple,4102,". 0. 1. 0.]; [0. 1. 0. 0.]; [1. 0. 0. 0.]]. To create operators in a combined Hilbert space that only act on a single component, we take the tensor product of the operator acting on the subspace of interest, with the identity operators corresponding to the components that are to be unchanged. For example, the operator that represents :math:`\sigma_z` on the first qubit in a two-qubit system, while leaving the second qubit unaffected:. .. testcode:: [tensor]. print(tensor(sigmaz(), identity(2))). **Output**:. .. testoutput:: [tensor]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True; Qobj data =; [[ 1. 0. 0. 0.]; [ 0. 1. 0. 0.]; [ 0. 0. -1. 0.]; [ 0. 0. 0. -1.]]. .. _tensor-product-example:. Example: Constructing composite Hamiltonians; ============================================. The :func:`~qutip.core.tensor.tensor` function is extensively used when constructing Hamiltonians for composite systems. Here we'll look at some simple examples. .. _tensor-product-example-2qubits:. Two coupled qubits; ------------------. First, let's consider a system of two coupled qubits. Assume that both the qubits have equal energy splitting, and that the qubits are coupled through a :math:`\sigma_x\otimes\sigma_x` interaction with strength g = 0.05 (in units where the bare qubit energy splitting is unity). The Hamiltonian describing this system is:. .. testcode:: [tensor]. H = tensor(sigmaz(), identity(2)) + tensor(identity(2), sigmaz()) + 0.05 * tensor(sigmax(), sigmax()). print(H). **Output**:. .. testoutput:: [tensor]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True; Qobj data =; [[ 2. 0. 0. 0.05]; [ 0. 0. 0.05 0. ]; [ 0. 0.05 0. 0. ]; [ 0.05 0. 0. -2. ]]. .. _tensor-product-example-3qubits:. Three coupled qubits; --------------------. The two-qubit example is easily generalized to three coupled qubits:. .. testcode:: [tensor]. H = (tensor(sigmaz(",MatchSource.DOCS,doc/guide/guide-tensor.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-tensor.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-tensor.rst:5940,Usability,simpl,simplest,5940," .. testcode:: [tensor]. H = (tensor(sigmaz(), identity(2), identity(2)) + tensor(identity(2), sigmaz(), identity(2)) + tensor(identity(2), identity(2), sigmaz()) + 0.5 * tensor(sigmax(), sigmax(), identity(2)) + 0.25 * tensor(identity(2), sigmax(), sigmax())). print(H). **Output**:. .. testoutput:: [tensor]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 2, 2], [2, 2, 2]], shape = (8, 8), type = oper, isherm = True; Qobj data =; [[ 3. 0. 0. 0.25 0. 0. 0.5 0. ]; [ 0. 1. 0.25 0. 0. 0. 0. 0.5 ]; [ 0. 0.25 1. 0. 0.5 0. 0. 0. ]; [ 0.25 0. 0. -1. 0. 0.5 0. 0. ]; [ 0. 0. 0.5 0. 1. 0. 0. 0.25]; [ 0. 0. 0. 0.5 0. -1. 0.25 0. ]; [ 0.5 0. 0. 0. 0. 0.25 -1. 0. ]; [ 0. 0.5 0. 0. 0.25 0. 0. -3. ]]. .. _tensor-product-example-jcmodel:. A two-level system coupled to a cavity: The Jaynes-Cummings model; -------------------------------------------------------------------. The simplest possible quantum mechanical description for light-matter interaction is encapsulated in the Jaynes-Cummings model, which describes the coupling between a two-level atom and a single-mode electromagnetic field (a cavity mode). Denoting the energy splitting of the atom and cavity ``omega_a`` and ``omega_c``, respectively, and the atom-cavity interaction strength ``g``, the Jaynes-Cummings Hamiltonian can be constructed as:. .. plot::; :context: reset. N = 6. omega_a = 1.0. omega_c = 1.25. g = 0.75. a = tensor(identity(2), destroy(N)). sm = tensor(destroy(2), identity(N)). sz = tensor(sigmaz(), identity(N)). H = 0.5 * omega_a * sz + omega_c * a.dag() * a + g * (a.dag() * sm + a * sm.dag()). hinton(H, fig=plt.figure(figsize=(12, 12))). Here ``N`` is the number of Fock states included in the cavity mode. .. _tensor-ptrace:. Partial trace; =============. The partial trace is an operation that reduces the dimension of a Hilbert space by eliminating some degrees of freedom by averaging (tracing).; In this sense it is therefore the converse of the tensor product.; It is useful when one is intereste",MatchSource.DOCS,doc/guide/guide-tensor.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-tensor.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-visualization.rst:10941,Availability,error,errors,10941,"("""".join([lbls_list[k][inds[k]] for k in range(len(lbls_list))])). fig, ax = matrix_histogram(H, xlabels, xlabels, limits=[-4,4]). ax.view_init(azim=-55, elev=45). plt.show(). Similarly, we can use the function :func:`qutip.visualization.hinton`, which is; used below to visualize the corresponding steadystate density matrix:. .. plot::; :context: close-figs. rho_ss = steadystate(H, [np.sqrt(0.1) * a, np.sqrt(0.4) * b.dag()]). hinton(rho_ss). plt.show(). .. _visual-qpt:. Quantum process tomography; ==========================. Quantum process tomography (QPT) is a useful technique for characterizing experimental implementations of quantum gates involving a small number of qubits. It can also be a useful theoretical tool that can give insight in how a process transforms states, and it can be used for example to study how noise or other imperfections deteriorate a gate. Whereas a fidelity or distance measure can give a single number that indicates how far from ideal a gate is, a quantum process tomography analysis can give detailed information about exactly what kind of errors various imperfections introduce. The idea is to construct a transformation matrix for a quantum process (for example a quantum gate) that describes how the density matrix of a system is transformed by the process. We can then decompose the transformation in some operator basis that represent well-defined and easily interpreted transformations of the input states. To see how this works (see e.g. [Moh08]_ for more details), consider a process that is described by quantum map :math:`\epsilon(\rho_{\rm in}) = \rho_{\rm out}`, which can be written. .. math::; :label: qpt-quantum-map. \epsilon(\rho_{\rm in}) = \rho_{\rm out} = \sum_{i}^{N^2} A_i \rho_{\rm in} A_i^\dagger,. where :math:`N` is the number of states of the system (that is, :math:`\rho` is represented by an :math:`[N\times N]` matrix). Given an orthogonal operator basis of our choice :math:`\{B_i\}_i^{N^2}`, which satisfies :math:`{\rm Tr}[B",MatchSource.DOCS,doc/guide/guide-visualization.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-visualization.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-visualization.rst:8142,Energy Efficiency,efficient,efficient,8142,"---. The Husimi Q function is, like the Wigner function, a quasiprobability; distribution for harmonic modes. It is defined as. .. math::. Q(\alpha) = \frac{1}{\pi}\left<\alpha|\rho|\alpha\right>. where :math:`\left|\alpha\right>` is a coherent state and; :math:`\alpha = x + iy`. In QuTiP, the Husimi Q function can be computed given; a state ket or density matrix using the function :func:`.qfunc`, as; demonstrated below. .. plot::; :context: close-figs. Q_coherent = qfunc(rho_coherent, xvec, xvec); Q_thermal = qfunc(rho_thermal, xvec, xvec); Q_fock = qfunc(rho_fock, xvec, xvec); fig, axes = plt.subplots(1, 3, figsize=(12,3)); cont0 = axes[0].contourf(xvec, xvec, Q_coherent, 100); lbl0 = axes[0].set_title(""Coherent state""); cont1 = axes[1].contourf(xvec, xvec, Q_thermal, 100); lbl1 = axes[1].set_title(""Thermal state""); cont0 = axes[2].contourf(xvec, xvec, Q_fock, 100); lbl2 = axes[2].set_title(""Fock state""); plt.show(). If you need to calculate the Q function for many states with the same; phase-space coordinates, it is more efficient to use the :obj:`.QFunc` class.; This stores various intermediary results to achieve an order-of-magnitude; improvement compared to calling :obj:`.qfunc` in a loop. .. code-block:: python. xs = np.linspace(-1, 1, 101); qfunc_calculator = qutip.QFunc(xs, xs); q_state1 = qfunc_calculator(qutip.rand_dm(5)); q_state2 = qfunc_calculator(qutip.rand_ket(100)). .. _visual-oper:. Visualizing operators; =====================. Sometimes, it may also be useful to directly visualizing the underlying matrix; representation of an operator. The density matrix, for example, is an operator; whose elements can give insights about the state it represents, but one might; also be interesting in plotting the matrix of an Hamiltonian to inspect the; structure and relative importance of various elements. QuTiP offers a few functions for quickly visualizing matrix data in the; form of histograms, :func:`qutip.visualization.matrix_histogram` and; as Hinton diagra",MatchSource.DOCS,doc/guide/guide-visualization.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-visualization.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-visualization.rst:15568,Integrability,depend,dependent,15568,"rix :math:`M` with a size that is the square of the size of the superoperator for the system. Obviously, this scales very badly with increasing system size, but this method can still be a very useful for small systems (such as system comprised of a small number of coupled qubits). Implementation in QuTiP; -----------------------. In QuTiP, the procedure described above is implemented in the function :func:`qutip.tomography.qpt`, which returns the :math:`\chi` matrix given a density matrix propagator.; To illustrate how to use this function, let's consider the SWAP gate for two qubits. In QuTiP the function :func:`.swap` generates the unitary transformation for the state kets:. .. plot::; :context: close-figs. from qutip.core.gates import swap. U_psi = swap(). To be able to use this unitary transformation matrix as input to the function :func:`qutip.tomography.qpt`, we first need to convert it to a transformation matrix for the corresponding density matrix:. .. plot::; :context:. U_rho = spre(U_psi) * spost(U_psi.dag()). Next, we construct a list of operators that define the basis :math:`\{B_i\}` in the form of a list of operators for each composite system. At the same time, we also construct a list of corresponding labels that will be used when plotting the :math:`\chi` matrix. .. plot::; :context:. op_basis = [[qeye(2), sigmax(), sigmay(), sigmaz()]] * 2; op_label = [[""i"", ""x"", ""y"", ""z""]] * 2. We are now ready to compute :math:`\chi` using :func:`qutip.tomography.qpt`, and to plot it using :func:`qutip.tomography.qpt_plot_combined`. .. plot::; :context:. chi = qpt(U_rho, op_basis). fig = qpt_plot_combined(chi, op_label, r'SWAP'). plt.show(). For a slightly more advanced example, where the density matrix propagator is calculated from the dynamics of a system defined by its Hamiltonian and collapse operators using the function :func:`.propagator`, see notebook ""Time-dependent master equation: Landau-Zener transitions"" on the tutorials section on the QuTiP web site.; ",MatchSource.DOCS,doc/guide/guide-visualization.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-visualization.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-visualization.rst:824,Performance,perform,perform,824,".. _visual:. .. plot::; :include-source: False. import numpy as np. from qutip import *. import pylab as plt. from warnings import warn. plt.close(""all""). *********************************************; Visualization of quantum states and processes; *********************************************. Visualization is often an important complement to a simulation of a quantum; mechanical system. The first method of visualization that come to mind might be; to plot the expectation values of a few selected operators. But on top of that,; it can often be instructive to visualize for example the state vectors or; density matices that describe the state of the system, or how the state is; transformed as a function of time (see process tomography below). In this; section we demonstrate how QuTiP and matplotlib can be used to perform a few; types of visualizations that often can provide additional understanding of; quantum system. .. _visual-fock:. Fock-basis probability distribution; ===================================. In quantum mechanics probability distributions plays an important role, and as; in statistics, the expectation values computed from a probability distribution; does not reveal the full story. For example, consider an quantum harmonic; oscillator mode with Hamiltonian :math:`H = \hbar\omega a^\dagger a`, which is; in a state described by its density matrix :math:`\rho`, and which on average; is occupied by two photons, :math:`\mathrm{Tr}[\rho a^\dagger a] = 2`. Given; this information we cannot say whether the oscillator is in a Fock state,; a thermal state, a coherent state, etc. By visualizing the photon distribution; in the Fock state basis important clues about the underlying state can be; obtained. One convenient way to visualize a probability distribution is to use histograms.; Consider the following histogram visualization of the number-basis probability; distribution, which can be obtained from the diagonal of the density matrix,; for a few possible oscilla",MatchSource.DOCS,doc/guide/guide-visualization.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-visualization.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-visualization.rst:12393,Security,access,access,12393,"ider a process that is described by quantum map :math:`\epsilon(\rho_{\rm in}) = \rho_{\rm out}`, which can be written. .. math::; :label: qpt-quantum-map. \epsilon(\rho_{\rm in}) = \rho_{\rm out} = \sum_{i}^{N^2} A_i \rho_{\rm in} A_i^\dagger,. where :math:`N` is the number of states of the system (that is, :math:`\rho` is represented by an :math:`[N\times N]` matrix). Given an orthogonal operator basis of our choice :math:`\{B_i\}_i^{N^2}`, which satisfies :math:`{\rm Tr}[B_i^\dagger B_j] = N\delta_{ij}`, we can write the map as. .. math::; :label: qpt-quantum-map-transformed. \epsilon(\rho_{\rm in}) = \rho_{\rm out} = \sum_{mn} \chi_{mn} B_m \rho_{\rm in} B_n^\dagger. where :math:`\chi_{mn} = \sum_{ij} b_{im}b_{jn}^*` and :math:`A_i = \sum_{m} b_{im}B_{m}`. Here, matrix :math:`\chi` is the transformation matrix we are after, since it describes how much :math:`B_m \rho_{\rm in} B_n^\dagger` contributes to :math:`\rho_{\rm out}`. In a numerical simulation of a quantum process we usually do not have access to the quantum map in the form Eq. :eq:`qpt-quantum-map`. Instead, what we usually can do is to calculate the propagator :math:`U` for the density matrix in superoperator form, using for example the QuTiP function :func:`qutip.propagator.propagator`. We can then write. .. math::. \epsilon(\tilde{\rho}_{\rm in}) = U \tilde{\rho}_{\rm in} = \tilde{\rho}_{\rm out}. where :math:`\tilde{\rho}` is the vector representation of the density matrix :math:`\rho`. If we write Eq. :eq:`qpt-quantum-map-transformed` in superoperator form as well we obtain. .. math::. \tilde{\rho}_{\rm out} = \sum_{mn} \chi_{mn} \tilde{B}_m \tilde{B}_n^\dagger \tilde{\rho}_{\rm in} = U \tilde{\rho}_{\rm in}. so we can identify. .. math::. U = \sum_{mn} \chi_{mn} \tilde{B}_m \tilde{B}_n^\dagger. Now this is a linear equation systems for the :math:`N^2 \times N^2` elements in :math:`\chi`. We can solve it by writing :math:`\chi` and the superoperator propagator as :math:`[N^4]` vectors, and likewis",MatchSource.DOCS,doc/guide/guide-visualization.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-visualization.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide.rst:95,Usability,guid,guide-overview,95,.. _guide:. *******************; Users Guide; *******************. .. toctree::; :maxdepth: 2. guide-overview.rst; guide-basics.rst; guide-states.rst; guide-tensor.rst; guide-super.rst; guide-dynamics.rst; guide-heom.rst; guide-steady.rst; guide-piqs.rst; guide-correlation.rst; guide-bloch.rst; guide-visualization.rst; guide-saving.rst; guide-random.rst; guide-settings.rst; guide-measurement.rst; guide-control.rst; ,MatchSource.DOCS,doc/guide/guide.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide.rst:115,Usability,guid,guide-basics,115,.. _guide:. *******************; Users Guide; *******************. .. toctree::; :maxdepth: 2. guide-overview.rst; guide-basics.rst; guide-states.rst; guide-tensor.rst; guide-super.rst; guide-dynamics.rst; guide-heom.rst; guide-steady.rst; guide-piqs.rst; guide-correlation.rst; guide-bloch.rst; guide-visualization.rst; guide-saving.rst; guide-random.rst; guide-settings.rst; guide-measurement.rst; guide-control.rst; ,MatchSource.DOCS,doc/guide/guide.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide.rst:133,Usability,guid,guide-states,133,.. _guide:. *******************; Users Guide; *******************. .. toctree::; :maxdepth: 2. guide-overview.rst; guide-basics.rst; guide-states.rst; guide-tensor.rst; guide-super.rst; guide-dynamics.rst; guide-heom.rst; guide-steady.rst; guide-piqs.rst; guide-correlation.rst; guide-bloch.rst; guide-visualization.rst; guide-saving.rst; guide-random.rst; guide-settings.rst; guide-measurement.rst; guide-control.rst; ,MatchSource.DOCS,doc/guide/guide.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide.rst:151,Usability,guid,guide-tensor,151,.. _guide:. *******************; Users Guide; *******************. .. toctree::; :maxdepth: 2. guide-overview.rst; guide-basics.rst; guide-states.rst; guide-tensor.rst; guide-super.rst; guide-dynamics.rst; guide-heom.rst; guide-steady.rst; guide-piqs.rst; guide-correlation.rst; guide-bloch.rst; guide-visualization.rst; guide-saving.rst; guide-random.rst; guide-settings.rst; guide-measurement.rst; guide-control.rst; ,MatchSource.DOCS,doc/guide/guide.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide.rst:169,Usability,guid,guide-super,169,.. _guide:. *******************; Users Guide; *******************. .. toctree::; :maxdepth: 2. guide-overview.rst; guide-basics.rst; guide-states.rst; guide-tensor.rst; guide-super.rst; guide-dynamics.rst; guide-heom.rst; guide-steady.rst; guide-piqs.rst; guide-correlation.rst; guide-bloch.rst; guide-visualization.rst; guide-saving.rst; guide-random.rst; guide-settings.rst; guide-measurement.rst; guide-control.rst; ,MatchSource.DOCS,doc/guide/guide.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide.rst:186,Usability,guid,guide-dynamics,186,.. _guide:. *******************; Users Guide; *******************. .. toctree::; :maxdepth: 2. guide-overview.rst; guide-basics.rst; guide-states.rst; guide-tensor.rst; guide-super.rst; guide-dynamics.rst; guide-heom.rst; guide-steady.rst; guide-piqs.rst; guide-correlation.rst; guide-bloch.rst; guide-visualization.rst; guide-saving.rst; guide-random.rst; guide-settings.rst; guide-measurement.rst; guide-control.rst; ,MatchSource.DOCS,doc/guide/guide.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide.rst:206,Usability,guid,guide-heom,206,.. _guide:. *******************; Users Guide; *******************. .. toctree::; :maxdepth: 2. guide-overview.rst; guide-basics.rst; guide-states.rst; guide-tensor.rst; guide-super.rst; guide-dynamics.rst; guide-heom.rst; guide-steady.rst; guide-piqs.rst; guide-correlation.rst; guide-bloch.rst; guide-visualization.rst; guide-saving.rst; guide-random.rst; guide-settings.rst; guide-measurement.rst; guide-control.rst; ,MatchSource.DOCS,doc/guide/guide.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide.rst:222,Usability,guid,guide-steady,222,.. _guide:. *******************; Users Guide; *******************. .. toctree::; :maxdepth: 2. guide-overview.rst; guide-basics.rst; guide-states.rst; guide-tensor.rst; guide-super.rst; guide-dynamics.rst; guide-heom.rst; guide-steady.rst; guide-piqs.rst; guide-correlation.rst; guide-bloch.rst; guide-visualization.rst; guide-saving.rst; guide-random.rst; guide-settings.rst; guide-measurement.rst; guide-control.rst; ,MatchSource.DOCS,doc/guide/guide.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide.rst:240,Usability,guid,guide-piqs,240,.. _guide:. *******************; Users Guide; *******************. .. toctree::; :maxdepth: 2. guide-overview.rst; guide-basics.rst; guide-states.rst; guide-tensor.rst; guide-super.rst; guide-dynamics.rst; guide-heom.rst; guide-steady.rst; guide-piqs.rst; guide-correlation.rst; guide-bloch.rst; guide-visualization.rst; guide-saving.rst; guide-random.rst; guide-settings.rst; guide-measurement.rst; guide-control.rst; ,MatchSource.DOCS,doc/guide/guide.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide.rst:256,Usability,guid,guide-correlation,256,.. _guide:. *******************; Users Guide; *******************. .. toctree::; :maxdepth: 2. guide-overview.rst; guide-basics.rst; guide-states.rst; guide-tensor.rst; guide-super.rst; guide-dynamics.rst; guide-heom.rst; guide-steady.rst; guide-piqs.rst; guide-correlation.rst; guide-bloch.rst; guide-visualization.rst; guide-saving.rst; guide-random.rst; guide-settings.rst; guide-measurement.rst; guide-control.rst; ,MatchSource.DOCS,doc/guide/guide.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide.rst:279,Usability,guid,guide-bloch,279,.. _guide:. *******************; Users Guide; *******************. .. toctree::; :maxdepth: 2. guide-overview.rst; guide-basics.rst; guide-states.rst; guide-tensor.rst; guide-super.rst; guide-dynamics.rst; guide-heom.rst; guide-steady.rst; guide-piqs.rst; guide-correlation.rst; guide-bloch.rst; guide-visualization.rst; guide-saving.rst; guide-random.rst; guide-settings.rst; guide-measurement.rst; guide-control.rst; ,MatchSource.DOCS,doc/guide/guide.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide.rst:296,Usability,guid,guide-visualization,296,.. _guide:. *******************; Users Guide; *******************. .. toctree::; :maxdepth: 2. guide-overview.rst; guide-basics.rst; guide-states.rst; guide-tensor.rst; guide-super.rst; guide-dynamics.rst; guide-heom.rst; guide-steady.rst; guide-piqs.rst; guide-correlation.rst; guide-bloch.rst; guide-visualization.rst; guide-saving.rst; guide-random.rst; guide-settings.rst; guide-measurement.rst; guide-control.rst; ,MatchSource.DOCS,doc/guide/guide.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide.rst:321,Usability,guid,guide-saving,321,.. _guide:. *******************; Users Guide; *******************. .. toctree::; :maxdepth: 2. guide-overview.rst; guide-basics.rst; guide-states.rst; guide-tensor.rst; guide-super.rst; guide-dynamics.rst; guide-heom.rst; guide-steady.rst; guide-piqs.rst; guide-correlation.rst; guide-bloch.rst; guide-visualization.rst; guide-saving.rst; guide-random.rst; guide-settings.rst; guide-measurement.rst; guide-control.rst; ,MatchSource.DOCS,doc/guide/guide.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide.rst:339,Usability,guid,guide-random,339,.. _guide:. *******************; Users Guide; *******************. .. toctree::; :maxdepth: 2. guide-overview.rst; guide-basics.rst; guide-states.rst; guide-tensor.rst; guide-super.rst; guide-dynamics.rst; guide-heom.rst; guide-steady.rst; guide-piqs.rst; guide-correlation.rst; guide-bloch.rst; guide-visualization.rst; guide-saving.rst; guide-random.rst; guide-settings.rst; guide-measurement.rst; guide-control.rst; ,MatchSource.DOCS,doc/guide/guide.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide.rst:357,Usability,guid,guide-settings,357,.. _guide:. *******************; Users Guide; *******************. .. toctree::; :maxdepth: 2. guide-overview.rst; guide-basics.rst; guide-states.rst; guide-tensor.rst; guide-super.rst; guide-dynamics.rst; guide-heom.rst; guide-steady.rst; guide-piqs.rst; guide-correlation.rst; guide-bloch.rst; guide-visualization.rst; guide-saving.rst; guide-random.rst; guide-settings.rst; guide-measurement.rst; guide-control.rst; ,MatchSource.DOCS,doc/guide/guide.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide.rst:377,Usability,guid,guide-measurement,377,.. _guide:. *******************; Users Guide; *******************. .. toctree::; :maxdepth: 2. guide-overview.rst; guide-basics.rst; guide-states.rst; guide-tensor.rst; guide-super.rst; guide-dynamics.rst; guide-heom.rst; guide-steady.rst; guide-piqs.rst; guide-correlation.rst; guide-bloch.rst; guide-visualization.rst; guide-saving.rst; guide-random.rst; guide-settings.rst; guide-measurement.rst; guide-control.rst; ,MatchSource.DOCS,doc/guide/guide.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide.rst:400,Usability,guid,guide-control,400,.. _guide:. *******************; Users Guide; *******************. .. toctree::; :maxdepth: 2. guide-overview.rst; guide-basics.rst; guide-states.rst; guide-tensor.rst; guide-super.rst; guide-dynamics.rst; guide-heom.rst; guide-steady.rst; guide-piqs.rst; guide-correlation.rst; guide-bloch.rst; guide-visualization.rst; guide-saving.rst; guide-random.rst; guide-settings.rst; guide-measurement.rst; guide-control.rst; ,MatchSource.DOCS,doc/guide/guide.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/heom-gpu.rst:574,Modifiability,extend,extend,574,"**********************************************************; GPU implementation of the Hierarchical Equations of Motion; **********************************************************. .. contents:: Contents; :local:; :depth: 3. The Hierarchical Equations of Motion (HEOM) method is a non-perturbative; approach to simulate the evolution of the density matrix of dissipative quantum; systems. The underlying equations are a system of coupled ODEs which can be run; on a GPU. This will allow the study of larger systems as discussed in [1]_. The; goal of this project would be to extend QuTiP's HEOM method [2]_ and implement; it on a GPU. Since the method is related to simulating large, coupled ODEs, it can also be; quite general and extended to other solvers. Expected outcomes; =================. * A version of HEOM which runs on a GPU.; * Performance comparison with the CPU version.; * Implement dynamic scaling. Skills; ======. * Git, python and familiarity with the Python scientific computing stack; * CUDA and OpenCL knowledge. Difficulty; ==========. * Hard. Mentors; =======. * Neill Lambert (nwlambert@gmail.com); * Alex Pitchford (alex.pitchford@gmail.com); * Shahnawaz Ahmed (shahnawaz.ahmed95@gmail.com); * Simon Cross (hodgestar@gmail.com). References; ==========. .. [1] https://pubs.acs.org/doi/abs/10.1021/ct200126d?src=recsys&journalCode=jctcce; .. [2] https://arxiv.org/abs/2010.10806; ",MatchSource.DOCS,doc/development/ideas/heom-gpu.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/heom-gpu.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/heom-gpu.rst:731,Modifiability,extend,extended,731,"**********************************************************; GPU implementation of the Hierarchical Equations of Motion; **********************************************************. .. contents:: Contents; :local:; :depth: 3. The Hierarchical Equations of Motion (HEOM) method is a non-perturbative; approach to simulate the evolution of the density matrix of dissipative quantum; systems. The underlying equations are a system of coupled ODEs which can be run; on a GPU. This will allow the study of larger systems as discussed in [1]_. The; goal of this project would be to extend QuTiP's HEOM method [2]_ and implement; it on a GPU. Since the method is related to simulating large, coupled ODEs, it can also be; quite general and extended to other solvers. Expected outcomes; =================. * A version of HEOM which runs on a GPU.; * Performance comparison with the CPU version.; * Implement dynamic scaling. Skills; ======. * Git, python and familiarity with the Python scientific computing stack; * CUDA and OpenCL knowledge. Difficulty; ==========. * Hard. Mentors; =======. * Neill Lambert (nwlambert@gmail.com); * Alex Pitchford (alex.pitchford@gmail.com); * Shahnawaz Ahmed (shahnawaz.ahmed95@gmail.com); * Simon Cross (hodgestar@gmail.com). References; ==========. .. [1] https://pubs.acs.org/doi/abs/10.1021/ct200126d?src=recsys&journalCode=jctcce; .. [2] https://arxiv.org/abs/2010.10806; ",MatchSource.DOCS,doc/development/ideas/heom-gpu.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/heom-gpu.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/pulse-level-quantum-circuits.rst:1521,Integrability,depend,depend,1521,"es and features, allowing the simulation both at the; level of gates and at the level of time evolution. To connect them, a compiler; is implemented to compile quantum gates into the Hamiltonian model. We would; like to further enhance this feature in QuTiP and the connection with other; libraries. Expected outcomes; =================. * APIs to import and export pulses to other libraries. Quantum compiler is a; current research topic in quantum engineering. Although QuTiP has a simple; compiler, many may want to try their own compiler which is more compatible; with their quantum device. Allowing importation and exportation of control; pulses will make this much easier. This will include a study of existing; libraries, such as `qiskit.pulse` and `OpenPulse` [1]_, comparing them with; `qutip.qip.pulse` module and building a more general and comprehensive; description of the pulse. * More examples of quantum system in the `qutip.qip.device` module. The circuit; simulation and compilation depend strongly on the physical system. At the; moment, we have two models: spin chain and cavity QED. We would like to; include some other commonly used planform such as Superconducting system [2]_,; Ion trap system [3]_ or silicon system. Each model will need a new set of; control Hamiltonian and a compiler that finds the control pulse of a quantum; gate. More involved noise models can also be added based on the physical; system. This part is going to involve some physics and study of commonly used; hardware platforms. The related code can be found in `qutip.qip.device` and; `qutip.qip.compiler`. Skills; ======. * Git, Python and familiarity with the Python scientific computing stack; * quantum information processing and quantum computing (quantum circuit formalism). Difficulty; ==========. * Medium. Mentors; =======. * Boxi Li (etamin1201@gmail.com) [QuTiP GSoC 2019 graduate]; * Nathan Shammah (nathan.shammah@gmail.com); * Alex Pitchford (alex.pitchford@gmail.com). References; ====",MatchSource.DOCS,doc/development/ideas/pulse-level-quantum-circuits.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/pulse-level-quantum-circuits.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/pulse-level-quantum-circuits.rst:210,Modifiability,enhance,enhance,210,"*******************************************; Pulse level description of quantum circuits; *******************************************. .. contents:: Contents; :local:; :depth: 3. The aim of this proposal is to enhance QuTiP quantum-circuit compilation; features with regard to quantum information processing. While QuTiP core modules; deal with dynamics simulation, there is also a module for quantum circuits; simulation. The two subsequent Google Summer of Code projects, in 2019 and 2020,; enhanced them in capabilities and features, allowing the simulation both at the; level of gates and at the level of time evolution. To connect them, a compiler; is implemented to compile quantum gates into the Hamiltonian model. We would; like to further enhance this feature in QuTiP and the connection with other; libraries. Expected outcomes; =================. * APIs to import and export pulses to other libraries. Quantum compiler is a; current research topic in quantum engineering. Although QuTiP has a simple; compiler, many may want to try their own compiler which is more compatible; with their quantum device. Allowing importation and exportation of control; pulses will make this much easier. This will include a study of existing; libraries, such as `qiskit.pulse` and `OpenPulse` [1]_, comparing them with; `qutip.qip.pulse` module and building a more general and comprehensive; description of the pulse. * More examples of quantum system in the `qutip.qip.device` module. The circuit; simulation and compilation depend strongly on the physical system. At the; moment, we have two models: spin chain and cavity QED. We would like to; include some other commonly used planform such as Superconducting system [2]_,; Ion trap system [3]_ or silicon system. Each model will need a new set of; control Hamiltonian and a compiler that finds the control pulse of a quantum; gate. More involved noise models can also be added based on the physical; system. This part is going to involve some physics a",MatchSource.DOCS,doc/development/ideas/pulse-level-quantum-circuits.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/pulse-level-quantum-circuits.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/pulse-level-quantum-circuits.rst:493,Modifiability,enhance,enhanced,493,"*******************************************; Pulse level description of quantum circuits; *******************************************. .. contents:: Contents; :local:; :depth: 3. The aim of this proposal is to enhance QuTiP quantum-circuit compilation; features with regard to quantum information processing. While QuTiP core modules; deal with dynamics simulation, there is also a module for quantum circuits; simulation. The two subsequent Google Summer of Code projects, in 2019 and 2020,; enhanced them in capabilities and features, allowing the simulation both at the; level of gates and at the level of time evolution. To connect them, a compiler; is implemented to compile quantum gates into the Hamiltonian model. We would; like to further enhance this feature in QuTiP and the connection with other; libraries. Expected outcomes; =================. * APIs to import and export pulses to other libraries. Quantum compiler is a; current research topic in quantum engineering. Although QuTiP has a simple; compiler, many may want to try their own compiler which is more compatible; with their quantum device. Allowing importation and exportation of control; pulses will make this much easier. This will include a study of existing; libraries, such as `qiskit.pulse` and `OpenPulse` [1]_, comparing them with; `qutip.qip.pulse` module and building a more general and comprehensive; description of the pulse. * More examples of quantum system in the `qutip.qip.device` module. The circuit; simulation and compilation depend strongly on the physical system. At the; moment, we have two models: spin chain and cavity QED. We would like to; include some other commonly used planform such as Superconducting system [2]_,; Ion trap system [3]_ or silicon system. Each model will need a new set of; control Hamiltonian and a compiler that finds the control pulse of a quantum; gate. More involved noise models can also be added based on the physical; system. This part is going to involve some physics a",MatchSource.DOCS,doc/development/ideas/pulse-level-quantum-circuits.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/pulse-level-quantum-circuits.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/pulse-level-quantum-circuits.rst:748,Modifiability,enhance,enhance,748,"*******************************************; Pulse level description of quantum circuits; *******************************************. .. contents:: Contents; :local:; :depth: 3. The aim of this proposal is to enhance QuTiP quantum-circuit compilation; features with regard to quantum information processing. While QuTiP core modules; deal with dynamics simulation, there is also a module for quantum circuits; simulation. The two subsequent Google Summer of Code projects, in 2019 and 2020,; enhanced them in capabilities and features, allowing the simulation both at the; level of gates and at the level of time evolution. To connect them, a compiler; is implemented to compile quantum gates into the Hamiltonian model. We would; like to further enhance this feature in QuTiP and the connection with other; libraries. Expected outcomes; =================. * APIs to import and export pulses to other libraries. Quantum compiler is a; current research topic in quantum engineering. Although QuTiP has a simple; compiler, many may want to try their own compiler which is more compatible; with their quantum device. Allowing importation and exportation of control; pulses will make this much easier. This will include a study of existing; libraries, such as `qiskit.pulse` and `OpenPulse` [1]_, comparing them with; `qutip.qip.pulse` module and building a more general and comprehensive; description of the pulse. * More examples of quantum system in the `qutip.qip.device` module. The circuit; simulation and compilation depend strongly on the physical system. At the; moment, we have two models: spin chain and cavity QED. We would like to; include some other commonly used planform such as Superconducting system [2]_,; Ion trap system [3]_ or silicon system. Each model will need a new set of; control Hamiltonian and a compiler that finds the control pulse of a quantum; gate. More involved noise models can also be added based on the physical; system. This part is going to involve some physics a",MatchSource.DOCS,doc/development/ideas/pulse-level-quantum-circuits.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/pulse-level-quantum-circuits.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/pulse-level-quantum-circuits.rst:1004,Usability,simpl,simple,1004,"se level description of quantum circuits; *******************************************. .. contents:: Contents; :local:; :depth: 3. The aim of this proposal is to enhance QuTiP quantum-circuit compilation; features with regard to quantum information processing. While QuTiP core modules; deal with dynamics simulation, there is also a module for quantum circuits; simulation. The two subsequent Google Summer of Code projects, in 2019 and 2020,; enhanced them in capabilities and features, allowing the simulation both at the; level of gates and at the level of time evolution. To connect them, a compiler; is implemented to compile quantum gates into the Hamiltonian model. We would; like to further enhance this feature in QuTiP and the connection with other; libraries. Expected outcomes; =================. * APIs to import and export pulses to other libraries. Quantum compiler is a; current research topic in quantum engineering. Although QuTiP has a simple; compiler, many may want to try their own compiler which is more compatible; with their quantum device. Allowing importation and exportation of control; pulses will make this much easier. This will include a study of existing; libraries, such as `qiskit.pulse` and `OpenPulse` [1]_, comparing them with; `qutip.qip.pulse` module and building a more general and comprehensive; description of the pulse. * More examples of quantum system in the `qutip.qip.device` module. The circuit; simulation and compilation depend strongly on the physical system. At the; moment, we have two models: spin chain and cavity QED. We would like to; include some other commonly used planform such as Superconducting system [2]_,; Ion trap system [3]_ or silicon system. Each model will need a new set of; control Hamiltonian and a compiler that finds the control pulse of a quantum; gate. More involved noise models can also be added based on the physical; system. This part is going to involve some physics and study of commonly used; hardware platforms. ",MatchSource.DOCS,doc/development/ideas/pulse-level-quantum-circuits.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/pulse-level-quantum-circuits.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/pulse-level-quantum-circuits.rst:2873,Usability,guid,guide,2873,"opic in quantum engineering. Although QuTiP has a simple; compiler, many may want to try their own compiler which is more compatible; with their quantum device. Allowing importation and exportation of control; pulses will make this much easier. This will include a study of existing; libraries, such as `qiskit.pulse` and `OpenPulse` [1]_, comparing them with; `qutip.qip.pulse` module and building a more general and comprehensive; description of the pulse. * More examples of quantum system in the `qutip.qip.device` module. The circuit; simulation and compilation depend strongly on the physical system. At the; moment, we have two models: spin chain and cavity QED. We would like to; include some other commonly used planform such as Superconducting system [2]_,; Ion trap system [3]_ or silicon system. Each model will need a new set of; control Hamiltonian and a compiler that finds the control pulse of a quantum; gate. More involved noise models can also be added based on the physical; system. This part is going to involve some physics and study of commonly used; hardware platforms. The related code can be found in `qutip.qip.device` and; `qutip.qip.compiler`. Skills; ======. * Git, Python and familiarity with the Python scientific computing stack; * quantum information processing and quantum computing (quantum circuit formalism). Difficulty; ==========. * Medium. Mentors; =======. * Boxi Li (etamin1201@gmail.com) [QuTiP GSoC 2019 graduate]; * Nathan Shammah (nathan.shammah@gmail.com); * Alex Pitchford (alex.pitchford@gmail.com). References; ==========. .. [1] McKay D C, Alexander T, Bello L, et al. Qiskit backend specifications for openqasm and openpulse experiments[J]. arXiv preprint arXiv:1809.03452, 2018. .. [2] Hffner H, Roos C F, Blatt R, **Quantum computing with trapped ions**, Physics reports, 2008, 469(4): 155-203. .. [3] Krantz P, Kjaergaard M, Yan F, et al. **A quantum engineer's guide to superconducting qubits**, Applied Physics Reviews, 2019, 6(2): 021318.; ",MatchSource.DOCS,doc/development/ideas/pulse-level-quantum-circuits.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/pulse-level-quantum-circuits.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/quantum-error-mitigation.rst:933,Availability,error,error,933,"************************; Quantum Error Mitigation; ************************. .. contents:: Contents; :local:; :depth: 3. From the QuTiP 4.5 release, the qutip.qip module now contains the noisy quantum; circuit simulator (which was a GSoC project) providing enhanced features for a; pulse-level description of quantum circuits and noise models. A new class; `Processor` and several subclasses are added to represent different platforms; for quantum computing. They can transfer a quantum circuit into the; corresponding control sequence and simulate the dynamics with QuTiP solvers.; Different noise models can be added to `qutip.qip.noise` to simulate noise in a; quantum device. This module is still young and many features can be improved, including new; device models, new noise models and integration with the existing general; framework for quantum circuits (`qutip.qip.circuit`). There are also possible; applications such as error mitigation techniques ([1]_, [2]_, [3]_). The tutorial notebooks can be found in the Quantum information processing; section of https://qutip.org/qutip-tutorials/index-v5.html. A; recent presentation on the FOSDEM conference may help you get an overview; (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github; Project page for a collection of related issues and ongoing Pull Requests. Expected outcomes; =================. - Make an overview of existing libraries and features in error mitigation,; similarly to a literature survey for a research article, but for a code; project (starting from Refs. [4]_, [5]_). This is done in order to best; integrate the features in QuTiP with existing libraries and avoid; reinventing the wheel.; - Features to perform error mitigation techniques in QuTiP, such as zero-noise; extrapolation by pulse stretching.; - Tutorials implementing basic quantum error mitigation protocols; - Possible integration with Mitiq [6]_. Skills; ======. * Background in quantum physics and quantum circuits.; * Git, py",MatchSource.DOCS,doc/development/ideas/quantum-error-mitigation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/quantum-error-mitigation.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/quantum-error-mitigation.rst:1442,Availability,error,error,1442,"sfer a quantum circuit into the; corresponding control sequence and simulate the dynamics with QuTiP solvers.; Different noise models can be added to `qutip.qip.noise` to simulate noise in a; quantum device. This module is still young and many features can be improved, including new; device models, new noise models and integration with the existing general; framework for quantum circuits (`qutip.qip.circuit`). There are also possible; applications such as error mitigation techniques ([1]_, [2]_, [3]_). The tutorial notebooks can be found in the Quantum information processing; section of https://qutip.org/qutip-tutorials/index-v5.html. A; recent presentation on the FOSDEM conference may help you get an overview; (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github; Project page for a collection of related issues and ongoing Pull Requests. Expected outcomes; =================. - Make an overview of existing libraries and features in error mitigation,; similarly to a literature survey for a research article, but for a code; project (starting from Refs. [4]_, [5]_). This is done in order to best; integrate the features in QuTiP with existing libraries and avoid; reinventing the wheel.; - Features to perform error mitigation techniques in QuTiP, such as zero-noise; extrapolation by pulse stretching.; - Tutorials implementing basic quantum error mitigation protocols; - Possible integration with Mitiq [6]_. Skills; ======. * Background in quantum physics and quantum circuits.; * Git, python and familiarity with the Python scientific computing stack. Difficulty; ==========. * Medium. Mentors; =======. * Nathan Shammah (nathan.shammah@gmail.com); * Alex Pitchford (alex.pitchford@gmail.com); * Eric Gigure (eric.giguere@usherbrooke.ca); * Neill Lambert (nwlambert@gmail.com); * Boxi Li (etamin1201@gmail.com) [QuTiP GSoC 2019 graduate]. References; ==========. .. [1] Kristan Temme, Sergey Bravyi, Jay M. Gambetta, **Error mitigation for short-depth quantu",MatchSource.DOCS,doc/development/ideas/quantum-error-mitigation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/quantum-error-mitigation.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/quantum-error-mitigation.rst:1720,Availability,error,error,1720,"ew; device models, new noise models and integration with the existing general; framework for quantum circuits (`qutip.qip.circuit`). There are also possible; applications such as error mitigation techniques ([1]_, [2]_, [3]_). The tutorial notebooks can be found in the Quantum information processing; section of https://qutip.org/qutip-tutorials/index-v5.html. A; recent presentation on the FOSDEM conference may help you get an overview; (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github; Project page for a collection of related issues and ongoing Pull Requests. Expected outcomes; =================. - Make an overview of existing libraries and features in error mitigation,; similarly to a literature survey for a research article, but for a code; project (starting from Refs. [4]_, [5]_). This is done in order to best; integrate the features in QuTiP with existing libraries and avoid; reinventing the wheel.; - Features to perform error mitigation techniques in QuTiP, such as zero-noise; extrapolation by pulse stretching.; - Tutorials implementing basic quantum error mitigation protocols; - Possible integration with Mitiq [6]_. Skills; ======. * Background in quantum physics and quantum circuits.; * Git, python and familiarity with the Python scientific computing stack. Difficulty; ==========. * Medium. Mentors; =======. * Nathan Shammah (nathan.shammah@gmail.com); * Alex Pitchford (alex.pitchford@gmail.com); * Eric Gigure (eric.giguere@usherbrooke.ca); * Neill Lambert (nwlambert@gmail.com); * Boxi Li (etamin1201@gmail.com) [QuTiP GSoC 2019 graduate]. References; ==========. .. [1] Kristan Temme, Sergey Bravyi, Jay M. Gambetta, **Error mitigation for short-depth quantum circuits**, Phys. Rev. Lett. 119, 180509 (2017). .. [2] Abhinav Kandala, Kristan Temme, Antonio D. Corcoles, Antonio Mezzacapo, Jerry M. Chow, Jay M. Gambetta,; **Extending the computational reach of a noisy superconducting quantum processor**, Nature *567*, 491 (2019). .. [3] S",MatchSource.DOCS,doc/development/ideas/quantum-error-mitigation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/quantum-error-mitigation.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/quantum-error-mitigation.rst:1853,Availability,error,error,1853,"qutip.qip.circuit`). There are also possible; applications such as error mitigation techniques ([1]_, [2]_, [3]_). The tutorial notebooks can be found in the Quantum information processing; section of https://qutip.org/qutip-tutorials/index-v5.html. A; recent presentation on the FOSDEM conference may help you get an overview; (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github; Project page for a collection of related issues and ongoing Pull Requests. Expected outcomes; =================. - Make an overview of existing libraries and features in error mitigation,; similarly to a literature survey for a research article, but for a code; project (starting from Refs. [4]_, [5]_). This is done in order to best; integrate the features in QuTiP with existing libraries and avoid; reinventing the wheel.; - Features to perform error mitigation techniques in QuTiP, such as zero-noise; extrapolation by pulse stretching.; - Tutorials implementing basic quantum error mitigation protocols; - Possible integration with Mitiq [6]_. Skills; ======. * Background in quantum physics and quantum circuits.; * Git, python and familiarity with the Python scientific computing stack. Difficulty; ==========. * Medium. Mentors; =======. * Nathan Shammah (nathan.shammah@gmail.com); * Alex Pitchford (alex.pitchford@gmail.com); * Eric Gigure (eric.giguere@usherbrooke.ca); * Neill Lambert (nwlambert@gmail.com); * Boxi Li (etamin1201@gmail.com) [QuTiP GSoC 2019 graduate]. References; ==========. .. [1] Kristan Temme, Sergey Bravyi, Jay M. Gambetta, **Error mitigation for short-depth quantum circuits**, Phys. Rev. Lett. 119, 180509 (2017). .. [2] Abhinav Kandala, Kristan Temme, Antonio D. Corcoles, Antonio Mezzacapo, Jerry M. Chow, Jay M. Gambetta,; **Extending the computational reach of a noisy superconducting quantum processor**, Nature *567*, 491 (2019). .. [3] S. Endo, S.C. Benjamin, Y. Li, **Practical quantum error mitigation for near-future applications**, Physical Revi",MatchSource.DOCS,doc/development/ideas/quantum-error-mitigation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/quantum-error-mitigation.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/quantum-error-mitigation.rst:2804,Availability,error,error,2804,"ce may help you get an overview; (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github; Project page for a collection of related issues and ongoing Pull Requests. Expected outcomes; =================. - Make an overview of existing libraries and features in error mitigation,; similarly to a literature survey for a research article, but for a code; project (starting from Refs. [4]_, [5]_). This is done in order to best; integrate the features in QuTiP with existing libraries and avoid; reinventing the wheel.; - Features to perform error mitigation techniques in QuTiP, such as zero-noise; extrapolation by pulse stretching.; - Tutorials implementing basic quantum error mitigation protocols; - Possible integration with Mitiq [6]_. Skills; ======. * Background in quantum physics and quantum circuits.; * Git, python and familiarity with the Python scientific computing stack. Difficulty; ==========. * Medium. Mentors; =======. * Nathan Shammah (nathan.shammah@gmail.com); * Alex Pitchford (alex.pitchford@gmail.com); * Eric Gigure (eric.giguere@usherbrooke.ca); * Neill Lambert (nwlambert@gmail.com); * Boxi Li (etamin1201@gmail.com) [QuTiP GSoC 2019 graduate]. References; ==========. .. [1] Kristan Temme, Sergey Bravyi, Jay M. Gambetta, **Error mitigation for short-depth quantum circuits**, Phys. Rev. Lett. 119, 180509 (2017). .. [2] Abhinav Kandala, Kristan Temme, Antonio D. Corcoles, Antonio Mezzacapo, Jerry M. Chow, Jay M. Gambetta,; **Extending the computational reach of a noisy superconducting quantum processor**, Nature *567*, 491 (2019). .. [3] S. Endo, S.C. Benjamin, Y. Li, **Practical quantum error mitigation for near-future applications**, Physical Review X *8*, 031027 (2018). .. [4] Boxi Li's blog on the GSoC 2019 project on pulse-level control, https://gsoc2019-boxili.blogspot.com/. .. [5] Video of a recent talk on the GSoC 2019 project, https://fosdem.org/2020/schedule/event/quantum_qutip/. .. [6] `Mitiq <https://mitiq.readthedocs.io/>`_; ",MatchSource.DOCS,doc/development/ideas/quantum-error-mitigation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/quantum-error-mitigation.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/quantum-error-mitigation.rst:141,Deployability,release,release,141,"************************; Quantum Error Mitigation; ************************. .. contents:: Contents; :local:; :depth: 3. From the QuTiP 4.5 release, the qutip.qip module now contains the noisy quantum; circuit simulator (which was a GSoC project) providing enhanced features for a; pulse-level description of quantum circuits and noise models. A new class; `Processor` and several subclasses are added to represent different platforms; for quantum computing. They can transfer a quantum circuit into the; corresponding control sequence and simulate the dynamics with QuTiP solvers.; Different noise models can be added to `qutip.qip.noise` to simulate noise in a; quantum device. This module is still young and many features can be improved, including new; device models, new noise models and integration with the existing general; framework for quantum circuits (`qutip.qip.circuit`). There are also possible; applications such as error mitigation techniques ([1]_, [2]_, [3]_). The tutorial notebooks can be found in the Quantum information processing; section of https://qutip.org/qutip-tutorials/index-v5.html. A; recent presentation on the FOSDEM conference may help you get an overview; (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github; Project page for a collection of related issues and ongoing Pull Requests. Expected outcomes; =================. - Make an overview of existing libraries and features in error mitigation,; similarly to a literature survey for a research article, but for a code; project (starting from Refs. [4]_, [5]_). This is done in order to best; integrate the features in QuTiP with existing libraries and avoid; reinventing the wheel.; - Features to perform error mitigation techniques in QuTiP, such as zero-noise; extrapolation by pulse stretching.; - Tutorials implementing basic quantum error mitigation protocols; - Possible integration with Mitiq [6]_. Skills; ======. * Background in quantum physics and quantum circuits.; * Git, py",MatchSource.DOCS,doc/development/ideas/quantum-error-mitigation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/quantum-error-mitigation.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/quantum-error-mitigation.rst:794,Deployability,integrat,integration,794,"************************; Quantum Error Mitigation; ************************. .. contents:: Contents; :local:; :depth: 3. From the QuTiP 4.5 release, the qutip.qip module now contains the noisy quantum; circuit simulator (which was a GSoC project) providing enhanced features for a; pulse-level description of quantum circuits and noise models. A new class; `Processor` and several subclasses are added to represent different platforms; for quantum computing. They can transfer a quantum circuit into the; corresponding control sequence and simulate the dynamics with QuTiP solvers.; Different noise models can be added to `qutip.qip.noise` to simulate noise in a; quantum device. This module is still young and many features can be improved, including new; device models, new noise models and integration with the existing general; framework for quantum circuits (`qutip.qip.circuit`). There are also possible; applications such as error mitigation techniques ([1]_, [2]_, [3]_). The tutorial notebooks can be found in the Quantum information processing; section of https://qutip.org/qutip-tutorials/index-v5.html. A; recent presentation on the FOSDEM conference may help you get an overview; (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github; Project page for a collection of related issues and ongoing Pull Requests. Expected outcomes; =================. - Make an overview of existing libraries and features in error mitigation,; similarly to a literature survey for a research article, but for a code; project (starting from Refs. [4]_, [5]_). This is done in order to best; integrate the features in QuTiP with existing libraries and avoid; reinventing the wheel.; - Features to perform error mitigation techniques in QuTiP, such as zero-noise; extrapolation by pulse stretching.; - Tutorials implementing basic quantum error mitigation protocols; - Possible integration with Mitiq [6]_. Skills; ======. * Background in quantum physics and quantum circuits.; * Git, py",MatchSource.DOCS,doc/development/ideas/quantum-error-mitigation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/quantum-error-mitigation.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/quantum-error-mitigation.rst:1607,Deployability,integrat,integrate,1607,"oise` to simulate noise in a; quantum device. This module is still young and many features can be improved, including new; device models, new noise models and integration with the existing general; framework for quantum circuits (`qutip.qip.circuit`). There are also possible; applications such as error mitigation techniques ([1]_, [2]_, [3]_). The tutorial notebooks can be found in the Quantum information processing; section of https://qutip.org/qutip-tutorials/index-v5.html. A; recent presentation on the FOSDEM conference may help you get an overview; (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github; Project page for a collection of related issues and ongoing Pull Requests. Expected outcomes; =================. - Make an overview of existing libraries and features in error mitigation,; similarly to a literature survey for a research article, but for a code; project (starting from Refs. [4]_, [5]_). This is done in order to best; integrate the features in QuTiP with existing libraries and avoid; reinventing the wheel.; - Features to perform error mitigation techniques in QuTiP, such as zero-noise; extrapolation by pulse stretching.; - Tutorials implementing basic quantum error mitigation protocols; - Possible integration with Mitiq [6]_. Skills; ======. * Background in quantum physics and quantum circuits.; * Git, python and familiarity with the Python scientific computing stack. Difficulty; ==========. * Medium. Mentors; =======. * Nathan Shammah (nathan.shammah@gmail.com); * Alex Pitchford (alex.pitchford@gmail.com); * Eric Gigure (eric.giguere@usherbrooke.ca); * Neill Lambert (nwlambert@gmail.com); * Boxi Li (etamin1201@gmail.com) [QuTiP GSoC 2019 graduate]. References; ==========. .. [1] Kristan Temme, Sergey Bravyi, Jay M. Gambetta, **Error mitigation for short-depth quantum circuits**, Phys. Rev. Lett. 119, 180509 (2017). .. [2] Abhinav Kandala, Kristan Temme, Antonio D. Corcoles, Antonio Mezzacapo, Jerry M. Chow, Jay M. Gambetta,; ",MatchSource.DOCS,doc/development/ideas/quantum-error-mitigation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/quantum-error-mitigation.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/quantum-error-mitigation.rst:1892,Deployability,integrat,integration,1892,"qutip.qip.circuit`). There are also possible; applications such as error mitigation techniques ([1]_, [2]_, [3]_). The tutorial notebooks can be found in the Quantum information processing; section of https://qutip.org/qutip-tutorials/index-v5.html. A; recent presentation on the FOSDEM conference may help you get an overview; (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github; Project page for a collection of related issues and ongoing Pull Requests. Expected outcomes; =================. - Make an overview of existing libraries and features in error mitigation,; similarly to a literature survey for a research article, but for a code; project (starting from Refs. [4]_, [5]_). This is done in order to best; integrate the features in QuTiP with existing libraries and avoid; reinventing the wheel.; - Features to perform error mitigation techniques in QuTiP, such as zero-noise; extrapolation by pulse stretching.; - Tutorials implementing basic quantum error mitigation protocols; - Possible integration with Mitiq [6]_. Skills; ======. * Background in quantum physics and quantum circuits.; * Git, python and familiarity with the Python scientific computing stack. Difficulty; ==========. * Medium. Mentors; =======. * Nathan Shammah (nathan.shammah@gmail.com); * Alex Pitchford (alex.pitchford@gmail.com); * Eric Gigure (eric.giguere@usherbrooke.ca); * Neill Lambert (nwlambert@gmail.com); * Boxi Li (etamin1201@gmail.com) [QuTiP GSoC 2019 graduate]. References; ==========. .. [1] Kristan Temme, Sergey Bravyi, Jay M. Gambetta, **Error mitigation for short-depth quantum circuits**, Phys. Rev. Lett. 119, 180509 (2017). .. [2] Abhinav Kandala, Kristan Temme, Antonio D. Corcoles, Antonio Mezzacapo, Jerry M. Chow, Jay M. Gambetta,; **Extending the computational reach of a noisy superconducting quantum processor**, Nature *567*, 491 (2019). .. [3] S. Endo, S.C. Benjamin, Y. Li, **Practical quantum error mitigation for near-future applications**, Physical Revi",MatchSource.DOCS,doc/development/ideas/quantum-error-mitigation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/quantum-error-mitigation.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/quantum-error-mitigation.rst:1219,Energy Efficiency,schedul,schedule,1219,"s a GSoC project) providing enhanced features for a; pulse-level description of quantum circuits and noise models. A new class; `Processor` and several subclasses are added to represent different platforms; for quantum computing. They can transfer a quantum circuit into the; corresponding control sequence and simulate the dynamics with QuTiP solvers.; Different noise models can be added to `qutip.qip.noise` to simulate noise in a; quantum device. This module is still young and many features can be improved, including new; device models, new noise models and integration with the existing general; framework for quantum circuits (`qutip.qip.circuit`). There are also possible; applications such as error mitigation techniques ([1]_, [2]_, [3]_). The tutorial notebooks can be found in the Quantum information processing; section of https://qutip.org/qutip-tutorials/index-v5.html. A; recent presentation on the FOSDEM conference may help you get an overview; (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github; Project page for a collection of related issues and ongoing Pull Requests. Expected outcomes; =================. - Make an overview of existing libraries and features in error mitigation,; similarly to a literature survey for a research article, but for a code; project (starting from Refs. [4]_, [5]_). This is done in order to best; integrate the features in QuTiP with existing libraries and avoid; reinventing the wheel.; - Features to perform error mitigation techniques in QuTiP, such as zero-noise; extrapolation by pulse stretching.; - Tutorials implementing basic quantum error mitigation protocols; - Possible integration with Mitiq [6]_. Skills; ======. * Background in quantum physics and quantum circuits.; * Git, python and familiarity with the Python scientific computing stack. Difficulty; ==========. * Medium. Mentors; =======. * Nathan Shammah (nathan.shammah@gmail.com); * Alex Pitchford (alex.pitchford@gmail.com); * Eric Gigure (eric.g",MatchSource.DOCS,doc/development/ideas/quantum-error-mitigation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/quantum-error-mitigation.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/quantum-error-mitigation.rst:3081,Energy Efficiency,schedul,schedule,3081,"ce may help you get an overview; (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github; Project page for a collection of related issues and ongoing Pull Requests. Expected outcomes; =================. - Make an overview of existing libraries and features in error mitigation,; similarly to a literature survey for a research article, but for a code; project (starting from Refs. [4]_, [5]_). This is done in order to best; integrate the features in QuTiP with existing libraries and avoid; reinventing the wheel.; - Features to perform error mitigation techniques in QuTiP, such as zero-noise; extrapolation by pulse stretching.; - Tutorials implementing basic quantum error mitigation protocols; - Possible integration with Mitiq [6]_. Skills; ======. * Background in quantum physics and quantum circuits.; * Git, python and familiarity with the Python scientific computing stack. Difficulty; ==========. * Medium. Mentors; =======. * Nathan Shammah (nathan.shammah@gmail.com); * Alex Pitchford (alex.pitchford@gmail.com); * Eric Gigure (eric.giguere@usherbrooke.ca); * Neill Lambert (nwlambert@gmail.com); * Boxi Li (etamin1201@gmail.com) [QuTiP GSoC 2019 graduate]. References; ==========. .. [1] Kristan Temme, Sergey Bravyi, Jay M. Gambetta, **Error mitigation for short-depth quantum circuits**, Phys. Rev. Lett. 119, 180509 (2017). .. [2] Abhinav Kandala, Kristan Temme, Antonio D. Corcoles, Antonio Mezzacapo, Jerry M. Chow, Jay M. Gambetta,; **Extending the computational reach of a noisy superconducting quantum processor**, Nature *567*, 491 (2019). .. [3] S. Endo, S.C. Benjamin, Y. Li, **Practical quantum error mitigation for near-future applications**, Physical Review X *8*, 031027 (2018). .. [4] Boxi Li's blog on the GSoC 2019 project on pulse-level control, https://gsoc2019-boxili.blogspot.com/. .. [5] Video of a recent talk on the GSoC 2019 project, https://fosdem.org/2020/schedule/event/quantum_qutip/. .. [6] `Mitiq <https://mitiq.readthedocs.io/>`_; ",MatchSource.DOCS,doc/development/ideas/quantum-error-mitigation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/quantum-error-mitigation.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/quantum-error-mitigation.rst:794,Integrability,integrat,integration,794,"************************; Quantum Error Mitigation; ************************. .. contents:: Contents; :local:; :depth: 3. From the QuTiP 4.5 release, the qutip.qip module now contains the noisy quantum; circuit simulator (which was a GSoC project) providing enhanced features for a; pulse-level description of quantum circuits and noise models. A new class; `Processor` and several subclasses are added to represent different platforms; for quantum computing. They can transfer a quantum circuit into the; corresponding control sequence and simulate the dynamics with QuTiP solvers.; Different noise models can be added to `qutip.qip.noise` to simulate noise in a; quantum device. This module is still young and many features can be improved, including new; device models, new noise models and integration with the existing general; framework for quantum circuits (`qutip.qip.circuit`). There are also possible; applications such as error mitigation techniques ([1]_, [2]_, [3]_). The tutorial notebooks can be found in the Quantum information processing; section of https://qutip.org/qutip-tutorials/index-v5.html. A; recent presentation on the FOSDEM conference may help you get an overview; (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github; Project page for a collection of related issues and ongoing Pull Requests. Expected outcomes; =================. - Make an overview of existing libraries and features in error mitigation,; similarly to a literature survey for a research article, but for a code; project (starting from Refs. [4]_, [5]_). This is done in order to best; integrate the features in QuTiP with existing libraries and avoid; reinventing the wheel.; - Features to perform error mitigation techniques in QuTiP, such as zero-noise; extrapolation by pulse stretching.; - Tutorials implementing basic quantum error mitigation protocols; - Possible integration with Mitiq [6]_. Skills; ======. * Background in quantum physics and quantum circuits.; * Git, py",MatchSource.DOCS,doc/development/ideas/quantum-error-mitigation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/quantum-error-mitigation.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/quantum-error-mitigation.rst:1607,Integrability,integrat,integrate,1607,"oise` to simulate noise in a; quantum device. This module is still young and many features can be improved, including new; device models, new noise models and integration with the existing general; framework for quantum circuits (`qutip.qip.circuit`). There are also possible; applications such as error mitigation techniques ([1]_, [2]_, [3]_). The tutorial notebooks can be found in the Quantum information processing; section of https://qutip.org/qutip-tutorials/index-v5.html. A; recent presentation on the FOSDEM conference may help you get an overview; (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github; Project page for a collection of related issues and ongoing Pull Requests. Expected outcomes; =================. - Make an overview of existing libraries and features in error mitigation,; similarly to a literature survey for a research article, but for a code; project (starting from Refs. [4]_, [5]_). This is done in order to best; integrate the features in QuTiP with existing libraries and avoid; reinventing the wheel.; - Features to perform error mitigation techniques in QuTiP, such as zero-noise; extrapolation by pulse stretching.; - Tutorials implementing basic quantum error mitigation protocols; - Possible integration with Mitiq [6]_. Skills; ======. * Background in quantum physics and quantum circuits.; * Git, python and familiarity with the Python scientific computing stack. Difficulty; ==========. * Medium. Mentors; =======. * Nathan Shammah (nathan.shammah@gmail.com); * Alex Pitchford (alex.pitchford@gmail.com); * Eric Gigure (eric.giguere@usherbrooke.ca); * Neill Lambert (nwlambert@gmail.com); * Boxi Li (etamin1201@gmail.com) [QuTiP GSoC 2019 graduate]. References; ==========. .. [1] Kristan Temme, Sergey Bravyi, Jay M. Gambetta, **Error mitigation for short-depth quantum circuits**, Phys. Rev. Lett. 119, 180509 (2017). .. [2] Abhinav Kandala, Kristan Temme, Antonio D. Corcoles, Antonio Mezzacapo, Jerry M. Chow, Jay M. Gambetta,; ",MatchSource.DOCS,doc/development/ideas/quantum-error-mitigation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/quantum-error-mitigation.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/quantum-error-mitigation.rst:1870,Integrability,protocol,protocols,1870,"qutip.qip.circuit`). There are also possible; applications such as error mitigation techniques ([1]_, [2]_, [3]_). The tutorial notebooks can be found in the Quantum information processing; section of https://qutip.org/qutip-tutorials/index-v5.html. A; recent presentation on the FOSDEM conference may help you get an overview; (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github; Project page for a collection of related issues and ongoing Pull Requests. Expected outcomes; =================. - Make an overview of existing libraries and features in error mitigation,; similarly to a literature survey for a research article, but for a code; project (starting from Refs. [4]_, [5]_). This is done in order to best; integrate the features in QuTiP with existing libraries and avoid; reinventing the wheel.; - Features to perform error mitigation techniques in QuTiP, such as zero-noise; extrapolation by pulse stretching.; - Tutorials implementing basic quantum error mitigation protocols; - Possible integration with Mitiq [6]_. Skills; ======. * Background in quantum physics and quantum circuits.; * Git, python and familiarity with the Python scientific computing stack. Difficulty; ==========. * Medium. Mentors; =======. * Nathan Shammah (nathan.shammah@gmail.com); * Alex Pitchford (alex.pitchford@gmail.com); * Eric Gigure (eric.giguere@usherbrooke.ca); * Neill Lambert (nwlambert@gmail.com); * Boxi Li (etamin1201@gmail.com) [QuTiP GSoC 2019 graduate]. References; ==========. .. [1] Kristan Temme, Sergey Bravyi, Jay M. Gambetta, **Error mitigation for short-depth quantum circuits**, Phys. Rev. Lett. 119, 180509 (2017). .. [2] Abhinav Kandala, Kristan Temme, Antonio D. Corcoles, Antonio Mezzacapo, Jerry M. Chow, Jay M. Gambetta,; **Extending the computational reach of a noisy superconducting quantum processor**, Nature *567*, 491 (2019). .. [3] S. Endo, S.C. Benjamin, Y. Li, **Practical quantum error mitigation for near-future applications**, Physical Revi",MatchSource.DOCS,doc/development/ideas/quantum-error-mitigation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/quantum-error-mitigation.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/quantum-error-mitigation.rst:1892,Integrability,integrat,integration,1892,"qutip.qip.circuit`). There are also possible; applications such as error mitigation techniques ([1]_, [2]_, [3]_). The tutorial notebooks can be found in the Quantum information processing; section of https://qutip.org/qutip-tutorials/index-v5.html. A; recent presentation on the FOSDEM conference may help you get an overview; (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github; Project page for a collection of related issues and ongoing Pull Requests. Expected outcomes; =================. - Make an overview of existing libraries and features in error mitigation,; similarly to a literature survey for a research article, but for a code; project (starting from Refs. [4]_, [5]_). This is done in order to best; integrate the features in QuTiP with existing libraries and avoid; reinventing the wheel.; - Features to perform error mitigation techniques in QuTiP, such as zero-noise; extrapolation by pulse stretching.; - Tutorials implementing basic quantum error mitigation protocols; - Possible integration with Mitiq [6]_. Skills; ======. * Background in quantum physics and quantum circuits.; * Git, python and familiarity with the Python scientific computing stack. Difficulty; ==========. * Medium. Mentors; =======. * Nathan Shammah (nathan.shammah@gmail.com); * Alex Pitchford (alex.pitchford@gmail.com); * Eric Gigure (eric.giguere@usherbrooke.ca); * Neill Lambert (nwlambert@gmail.com); * Boxi Li (etamin1201@gmail.com) [QuTiP GSoC 2019 graduate]. References; ==========. .. [1] Kristan Temme, Sergey Bravyi, Jay M. Gambetta, **Error mitigation for short-depth quantum circuits**, Phys. Rev. Lett. 119, 180509 (2017). .. [2] Abhinav Kandala, Kristan Temme, Antonio D. Corcoles, Antonio Mezzacapo, Jerry M. Chow, Jay M. Gambetta,; **Extending the computational reach of a noisy superconducting quantum processor**, Nature *567*, 491 (2019). .. [3] S. Endo, S.C. Benjamin, Y. Li, **Practical quantum error mitigation for near-future applications**, Physical Revi",MatchSource.DOCS,doc/development/ideas/quantum-error-mitigation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/quantum-error-mitigation.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/quantum-error-mitigation.rst:258,Modifiability,enhance,enhanced,258,"************************; Quantum Error Mitigation; ************************. .. contents:: Contents; :local:; :depth: 3. From the QuTiP 4.5 release, the qutip.qip module now contains the noisy quantum; circuit simulator (which was a GSoC project) providing enhanced features for a; pulse-level description of quantum circuits and noise models. A new class; `Processor` and several subclasses are added to represent different platforms; for quantum computing. They can transfer a quantum circuit into the; corresponding control sequence and simulate the dynamics with QuTiP solvers.; Different noise models can be added to `qutip.qip.noise` to simulate noise in a; quantum device. This module is still young and many features can be improved, including new; device models, new noise models and integration with the existing general; framework for quantum circuits (`qutip.qip.circuit`). There are also possible; applications such as error mitigation techniques ([1]_, [2]_, [3]_). The tutorial notebooks can be found in the Quantum information processing; section of https://qutip.org/qutip-tutorials/index-v5.html. A; recent presentation on the FOSDEM conference may help you get an overview; (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github; Project page for a collection of related issues and ongoing Pull Requests. Expected outcomes; =================. - Make an overview of existing libraries and features in error mitigation,; similarly to a literature survey for a research article, but for a code; project (starting from Refs. [4]_, [5]_). This is done in order to best; integrate the features in QuTiP with existing libraries and avoid; reinventing the wheel.; - Features to perform error mitigation techniques in QuTiP, such as zero-noise; extrapolation by pulse stretching.; - Tutorials implementing basic quantum error mitigation protocols; - Possible integration with Mitiq [6]_. Skills; ======. * Background in quantum physics and quantum circuits.; * Git, py",MatchSource.DOCS,doc/development/ideas/quantum-error-mitigation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/quantum-error-mitigation.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/quantum-error-mitigation.rst:1712,Performance,perform,perform,1712,"ew; device models, new noise models and integration with the existing general; framework for quantum circuits (`qutip.qip.circuit`). There are also possible; applications such as error mitigation techniques ([1]_, [2]_, [3]_). The tutorial notebooks can be found in the Quantum information processing; section of https://qutip.org/qutip-tutorials/index-v5.html. A; recent presentation on the FOSDEM conference may help you get an overview; (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github; Project page for a collection of related issues and ongoing Pull Requests. Expected outcomes; =================. - Make an overview of existing libraries and features in error mitigation,; similarly to a literature survey for a research article, but for a code; project (starting from Refs. [4]_, [5]_). This is done in order to best; integrate the features in QuTiP with existing libraries and avoid; reinventing the wheel.; - Features to perform error mitigation techniques in QuTiP, such as zero-noise; extrapolation by pulse stretching.; - Tutorials implementing basic quantum error mitigation protocols; - Possible integration with Mitiq [6]_. Skills; ======. * Background in quantum physics and quantum circuits.; * Git, python and familiarity with the Python scientific computing stack. Difficulty; ==========. * Medium. Mentors; =======. * Nathan Shammah (nathan.shammah@gmail.com); * Alex Pitchford (alex.pitchford@gmail.com); * Eric Gigure (eric.giguere@usherbrooke.ca); * Neill Lambert (nwlambert@gmail.com); * Boxi Li (etamin1201@gmail.com) [QuTiP GSoC 2019 graduate]. References; ==========. .. [1] Kristan Temme, Sergey Bravyi, Jay M. Gambetta, **Error mitigation for short-depth quantum circuits**, Phys. Rev. Lett. 119, 180509 (2017). .. [2] Abhinav Kandala, Kristan Temme, Antonio D. Corcoles, Antonio Mezzacapo, Jerry M. Chow, Jay M. Gambetta,; **Extending the computational reach of a noisy superconducting quantum processor**, Nature *567*, 491 (2019). .. [3] S",MatchSource.DOCS,doc/development/ideas/quantum-error-mitigation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/quantum-error-mitigation.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/quantum-error-mitigation.rst:1667,Safety,avoid,avoid,1667,"oise` to simulate noise in a; quantum device. This module is still young and many features can be improved, including new; device models, new noise models and integration with the existing general; framework for quantum circuits (`qutip.qip.circuit`). There are also possible; applications such as error mitigation techniques ([1]_, [2]_, [3]_). The tutorial notebooks can be found in the Quantum information processing; section of https://qutip.org/qutip-tutorials/index-v5.html. A; recent presentation on the FOSDEM conference may help you get an overview; (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github; Project page for a collection of related issues and ongoing Pull Requests. Expected outcomes; =================. - Make an overview of existing libraries and features in error mitigation,; similarly to a literature survey for a research article, but for a code; project (starting from Refs. [4]_, [5]_). This is done in order to best; integrate the features in QuTiP with existing libraries and avoid; reinventing the wheel.; - Features to perform error mitigation techniques in QuTiP, such as zero-noise; extrapolation by pulse stretching.; - Tutorials implementing basic quantum error mitigation protocols; - Possible integration with Mitiq [6]_. Skills; ======. * Background in quantum physics and quantum circuits.; * Git, python and familiarity with the Python scientific computing stack. Difficulty; ==========. * Medium. Mentors; =======. * Nathan Shammah (nathan.shammah@gmail.com); * Alex Pitchford (alex.pitchford@gmail.com); * Eric Gigure (eric.giguere@usherbrooke.ca); * Neill Lambert (nwlambert@gmail.com); * Boxi Li (etamin1201@gmail.com) [QuTiP GSoC 2019 graduate]. References; ==========. .. [1] Kristan Temme, Sergey Bravyi, Jay M. Gambetta, **Error mitigation for short-depth quantum circuits**, Phys. Rev. Lett. 119, 180509 (2017). .. [2] Abhinav Kandala, Kristan Temme, Antonio D. Corcoles, Antonio Mezzacapo, Jerry M. Chow, Jay M. Gambetta,; ",MatchSource.DOCS,doc/development/ideas/quantum-error-mitigation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/quantum-error-mitigation.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/qutip-interactive.rst:888,Deployability,toggle,toggle,888,"*****************; QuTiP Interactive; *****************. .. contents:: Contents; :local:; :depth: 3. QuTiP is pretty simple to use at an entry level for anyone with basic Python; skills. However, *some* Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners. Ideally, interactive components could be embedded in web pages. Including, but; not limited to, Jupyter notebooks. The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere; ------------------------. QuTiP has a Bloch sphere virtualisation for qubit states. This could be made; interactive through sliders, radio buttons, cmd buttons etc. An interactive; Bloch sphere could have sliders for qubit state angles. Buttons to add states,; toggle state evolution path. Potential for recording animations. Matplotlib has; some interactive features (sliders, radio buttons, cmd buttons) that can be used; to control parameters. that could potentially be used. Interactive solvers; -------------------. Options to configure dynamics generators (Lindbladian / Hamiltonian args etc); and expectation operators. Then run solver and view state evolution. Animated circuits; -----------------. QIP circuits could be animated. Status lights showing evolution of states during; the processing. Animated Bloch spheres for qubits. Expected outcomes; =================. * Interactive graphical components for demonstrating quantum dynamics; * Web pages for qutip.org or Jupyter notebooks introducing quantum dynamics; using the new components. Skills; ======. * Git, Python and familiarity with the Python scientific computing stack; * elementary understanding of quantum dynamics. Difficulty; ==========. * Variable. Mentors; =======. * Nathan Shammah (nathan.shammah@gmail.com); * Alex Pitchford (alex.pitchford@gmail.com); * Simon Cross (hodgestar@gmail.com); * B",MatchSource.DOCS,doc/development/ideas/qutip-interactive.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/qutip-interactive.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/qutip-interactive.rst:249,Integrability,interface,interface,249,"*****************; QuTiP Interactive; *****************. .. contents:: Contents; :local:; :depth: 3. QuTiP is pretty simple to use at an entry level for anyone with basic Python; skills. However, *some* Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners. Ideally, interactive components could be embedded in web pages. Including, but; not limited to, Jupyter notebooks. The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere; ------------------------. QuTiP has a Bloch sphere virtualisation for qubit states. This could be made; interactive through sliders, radio buttons, cmd buttons etc. An interactive; Bloch sphere could have sliders for qubit state angles. Buttons to add states,; toggle state evolution path. Potential for recording animations. Matplotlib has; some interactive features (sliders, radio buttons, cmd buttons) that can be used; to control parameters. that could potentially be used. Interactive solvers; -------------------. Options to configure dynamics generators (Lindbladian / Hamiltonian args etc); and expectation operators. Then run solver and view state evolution. Animated circuits; -----------------. QIP circuits could be animated. Status lights showing evolution of states during; the processing. Animated Bloch spheres for qubits. Expected outcomes; =================. * Interactive graphical components for demonstrating quantum dynamics; * Web pages for qutip.org or Jupyter notebooks introducing quantum dynamics; using the new components. Skills; ======. * Git, Python and familiarity with the Python scientific computing stack; * elementary understanding of quantum dynamics. Difficulty; ==========. * Variable. Mentors; =======. * Nathan Shammah (nathan.shammah@gmail.com); * Alex Pitchford (alex.pitchford@gmail.com); * Simon Cross (hodgestar@gmail.com); * B",MatchSource.DOCS,doc/development/ideas/qutip-interactive.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/qutip-interactive.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/qutip-interactive.rst:553,Modifiability,flexible,flexible,553,"*****************; QuTiP Interactive; *****************. .. contents:: Contents; :local:; :depth: 3. QuTiP is pretty simple to use at an entry level for anyone with basic Python; skills. However, *some* Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners. Ideally, interactive components could be embedded in web pages. Including, but; not limited to, Jupyter notebooks. The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere; ------------------------. QuTiP has a Bloch sphere virtualisation for qubit states. This could be made; interactive through sliders, radio buttons, cmd buttons etc. An interactive; Bloch sphere could have sliders for qubit state angles. Buttons to add states,; toggle state evolution path. Potential for recording animations. Matplotlib has; some interactive features (sliders, radio buttons, cmd buttons) that can be used; to control parameters. that could potentially be used. Interactive solvers; -------------------. Options to configure dynamics generators (Lindbladian / Hamiltonian args etc); and expectation operators. Then run solver and view state evolution. Animated circuits; -----------------. QIP circuits could be animated. Status lights showing evolution of states during; the processing. Animated Bloch spheres for qubits. Expected outcomes; =================. * Interactive graphical components for demonstrating quantum dynamics; * Web pages for qutip.org or Jupyter notebooks introducing quantum dynamics; using the new components. Skills; ======. * Git, Python and familiarity with the Python scientific computing stack; * elementary understanding of quantum dynamics. Difficulty; ==========. * Variable. Mentors; =======. * Nathan Shammah (nathan.shammah@gmail.com); * Alex Pitchford (alex.pitchford@gmail.com); * Simon Cross (hodgestar@gmail.com); * B",MatchSource.DOCS,doc/development/ideas/qutip-interactive.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/qutip-interactive.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/qutip-interactive.rst:1159,Modifiability,config,configure,1159," contents:: Contents; :local:; :depth: 3. QuTiP is pretty simple to use at an entry level for anyone with basic Python; skills. However, *some* Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners. Ideally, interactive components could be embedded in web pages. Including, but; not limited to, Jupyter notebooks. The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere; ------------------------. QuTiP has a Bloch sphere virtualisation for qubit states. This could be made; interactive through sliders, radio buttons, cmd buttons etc. An interactive; Bloch sphere could have sliders for qubit state angles. Buttons to add states,; toggle state evolution path. Potential for recording animations. Matplotlib has; some interactive features (sliders, radio buttons, cmd buttons) that can be used; to control parameters. that could potentially be used. Interactive solvers; -------------------. Options to configure dynamics generators (Lindbladian / Hamiltonian args etc); and expectation operators. Then run solver and view state evolution. Animated circuits; -----------------. QIP circuits could be animated. Status lights showing evolution of states during; the processing. Animated Bloch spheres for qubits. Expected outcomes; =================. * Interactive graphical components for demonstrating quantum dynamics; * Web pages for qutip.org or Jupyter notebooks introducing quantum dynamics; using the new components. Skills; ======. * Git, Python and familiarity with the Python scientific computing stack; * elementary understanding of quantum dynamics. Difficulty; ==========. * Variable. Mentors; =======. * Nathan Shammah (nathan.shammah@gmail.com); * Alex Pitchford (alex.pitchford@gmail.com); * Simon Cross (hodgestar@gmail.com); * Boxi Li (etamin1201@gmail.com) [QuTiP GSoC 2019 graduate]; ",MatchSource.DOCS,doc/development/ideas/qutip-interactive.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/qutip-interactive.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/qutip-interactive.rst:317,Security,access,accessible,317,"*****************; QuTiP Interactive; *****************. .. contents:: Contents; :local:; :depth: 3. QuTiP is pretty simple to use at an entry level for anyone with basic Python; skills. However, *some* Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners. Ideally, interactive components could be embedded in web pages. Including, but; not limited to, Jupyter notebooks. The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere; ------------------------. QuTiP has a Bloch sphere virtualisation for qubit states. This could be made; interactive through sliders, radio buttons, cmd buttons etc. An interactive; Bloch sphere could have sliders for qubit state angles. Buttons to add states,; toggle state evolution path. Potential for recording animations. Matplotlib has; some interactive features (sliders, radio buttons, cmd buttons) that can be used; to control parameters. that could potentially be used. Interactive solvers; -------------------. Options to configure dynamics generators (Lindbladian / Hamiltonian args etc); and expectation operators. Then run solver and view state evolution. Animated circuits; -----------------. QIP circuits could be animated. Status lights showing evolution of states during; the processing. Animated Bloch spheres for qubits. Expected outcomes; =================. * Interactive graphical components for demonstrating quantum dynamics; * Web pages for qutip.org or Jupyter notebooks introducing quantum dynamics; using the new components. Skills; ======. * Git, Python and familiarity with the Python scientific computing stack; * elementary understanding of quantum dynamics. Difficulty; ==========. * Variable. Mentors; =======. * Nathan Shammah (nathan.shammah@gmail.com); * Alex Pitchford (alex.pitchford@gmail.com); * Simon Cross (hodgestar@gmail.com); * B",MatchSource.DOCS,doc/development/ideas/qutip-interactive.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/qutip-interactive.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/qutip-interactive.rst:117,Usability,simpl,simple,117,"*****************; QuTiP Interactive; *****************. .. contents:: Contents; :local:; :depth: 3. QuTiP is pretty simple to use at an entry level for anyone with basic Python; skills. However, *some* Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners. Ideally, interactive components could be embedded in web pages. Including, but; not limited to, Jupyter notebooks. The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere; ------------------------. QuTiP has a Bloch sphere virtualisation for qubit states. This could be made; interactive through sliders, radio buttons, cmd buttons etc. An interactive; Bloch sphere could have sliders for qubit state angles. Buttons to add states,; toggle state evolution path. Potential for recording animations. Matplotlib has; some interactive features (sliders, radio buttons, cmd buttons) that can be used; to control parameters. that could potentially be used. Interactive solvers; -------------------. Options to configure dynamics generators (Lindbladian / Hamiltonian args etc); and expectation operators. Then run solver and view state evolution. Animated circuits; -----------------. QIP circuits could be animated. Status lights showing evolution of states during; the processing. Animated Bloch spheres for qubits. Expected outcomes; =================. * Interactive graphical components for demonstrating quantum dynamics; * Web pages for qutip.org or Jupyter notebooks introducing quantum dynamics; using the new components. Skills; ======. * Git, Python and familiarity with the Python scientific computing stack; * elementary understanding of quantum dynamics. Difficulty; ==========. * Variable. Mentors; =======. * Nathan Shammah (nathan.shammah@gmail.com); * Alex Pitchford (alex.pitchford@gmail.com); * Simon Cross (hodgestar@gmail.com); * B",MatchSource.DOCS,doc/development/ideas/qutip-interactive.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/qutip-interactive.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/qutip-interactive.rst:396,Usability,learn,learners,396,"*****************; QuTiP Interactive; *****************. .. contents:: Contents; :local:; :depth: 3. QuTiP is pretty simple to use at an entry level for anyone with basic Python; skills. However, *some* Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners. Ideally, interactive components could be embedded in web pages. Including, but; not limited to, Jupyter notebooks. The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere; ------------------------. QuTiP has a Bloch sphere virtualisation for qubit states. This could be made; interactive through sliders, radio buttons, cmd buttons etc. An interactive; Bloch sphere could have sliders for qubit state angles. Buttons to add states,; toggle state evolution path. Potential for recording animations. Matplotlib has; some interactive features (sliders, radio buttons, cmd buttons) that can be used; to control parameters. that could potentially be used. Interactive solvers; -------------------. Options to configure dynamics generators (Lindbladian / Hamiltonian args etc); and expectation operators. Then run solver and view state evolution. Animated circuits; -----------------. QIP circuits could be animated. Status lights showing evolution of states during; the processing. Animated Bloch spheres for qubits. Expected outcomes; =================. * Interactive graphical components for demonstrating quantum dynamics; * Web pages for qutip.org or Jupyter notebooks introducing quantum dynamics; using the new components. Skills; ======. * Git, Python and familiarity with the Python scientific computing stack; * elementary understanding of quantum dynamics. Difficulty; ==========. * Variable. Mentors; =======. * Nathan Shammah (nathan.shammah@gmail.com); * Alex Pitchford (alex.pitchford@gmail.com); * Simon Cross (hodgestar@gmail.com); * B",MatchSource.DOCS,doc/development/ideas/qutip-interactive.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/qutip-interactive.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/tensorflow-data-backend.rst:871,Energy Efficiency,efficient,efficiently,871,"***********************; TensorFlow Data Backend; ***********************. .. contents:: Contents; :local:; :depth: 3. .. note::; This project was completed as part of GSoC 2021 [3]_. QuTiP's data layer provides the mathematical operations needed to work with; quantum states and operators, i.e. ``Qobj``, inside QuTiP. As part of Google; Summer of Code 2020, the data layer was rewritten to allow new backends to; be added more easily and for different backends to interoperate with each; other. Backends using in-memory spares and dense matrices already exist,; and we would like to add a backend that implements the necessary operations; using TensorFlow [1]_. Why a TensorFlow backend?; -------------------------. TensorFlow supports distributing matrix operations across multiple GPUs and; multiple machines, and abstracts away some of the complexities of doing so; efficiently. We hope that by using TensorFlow we might enable QuTiP to scale; to bigger quantum systems (e.g. more qubits) and decrease the time taken to; simulate them. There is particular interest in trying the new backend with the; BoFiN HEOM (Hierarchical Equations of Motion) solver [2]_. Challenges; ----------. TensorFlow is a very different kind of computational framework to the existing; dense and sparse matrix backends. It uses flow graphs to describe operations,; and to work efficiently. Ideally large graphs of operations need to be; executed together in order to efficiently compute results. The QuTiP data layer might need to be adjusted to accommodate these; differences, and it is possible that this will prove challenging or even; that we will not find a reasonable way to achieve the desired performance. Expected outcomes; =================. * Add a ``qutip.core.data.tensorflow`` data type.; * Implement specialisations for some important operations (e.g. ``add``,; ``mul``, ``matmul``, ``eigen``, etc).; * Write a small benchmark to show how ``Qobj`` operations scale on the new; backend in comparison to t",MatchSource.DOCS,doc/development/ideas/tensorflow-data-backend.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/tensorflow-data-backend.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/tensorflow-data-backend.rst:1360,Energy Efficiency,efficient,efficiently,1360,"; Summer of Code 2020, the data layer was rewritten to allow new backends to; be added more easily and for different backends to interoperate with each; other. Backends using in-memory spares and dense matrices already exist,; and we would like to add a backend that implements the necessary operations; using TensorFlow [1]_. Why a TensorFlow backend?; -------------------------. TensorFlow supports distributing matrix operations across multiple GPUs and; multiple machines, and abstracts away some of the complexities of doing so; efficiently. We hope that by using TensorFlow we might enable QuTiP to scale; to bigger quantum systems (e.g. more qubits) and decrease the time taken to; simulate them. There is particular interest in trying the new backend with the; BoFiN HEOM (Hierarchical Equations of Motion) solver [2]_. Challenges; ----------. TensorFlow is a very different kind of computational framework to the existing; dense and sparse matrix backends. It uses flow graphs to describe operations,; and to work efficiently. Ideally large graphs of operations need to be; executed together in order to efficiently compute results. The QuTiP data layer might need to be adjusted to accommodate these; differences, and it is possible that this will prove challenging or even; that we will not find a reasonable way to achieve the desired performance. Expected outcomes; =================. * Add a ``qutip.core.data.tensorflow`` data type.; * Implement specialisations for some important operations (e.g. ``add``,; ``mul``, ``matmul``, ``eigen``, etc).; * Write a small benchmark to show how ``Qobj`` operations scale on the new; backend in comparison to the existing backends. Run the benchmark both; with and without using a GPU.; * Implement enough for a solver to run on top of the new TensorFlow data; backend and benchmark that (stretch goal). Skills; ======. * Git, Python and familiarity with the Python scientific computing stack; * Familiarity with TensorFlow (beneficial, but not r",MatchSource.DOCS,doc/development/ideas/tensorflow-data-backend.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/tensorflow-data-backend.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/tensorflow-data-backend.rst:1450,Energy Efficiency,efficient,efficiently,1450,"ore easily and for different backends to interoperate with each; other. Backends using in-memory spares and dense matrices already exist,; and we would like to add a backend that implements the necessary operations; using TensorFlow [1]_. Why a TensorFlow backend?; -------------------------. TensorFlow supports distributing matrix operations across multiple GPUs and; multiple machines, and abstracts away some of the complexities of doing so; efficiently. We hope that by using TensorFlow we might enable QuTiP to scale; to bigger quantum systems (e.g. more qubits) and decrease the time taken to; simulate them. There is particular interest in trying the new backend with the; BoFiN HEOM (Hierarchical Equations of Motion) solver [2]_. Challenges; ----------. TensorFlow is a very different kind of computational framework to the existing; dense and sparse matrix backends. It uses flow graphs to describe operations,; and to work efficiently. Ideally large graphs of operations need to be; executed together in order to efficiently compute results. The QuTiP data layer might need to be adjusted to accommodate these; differences, and it is possible that this will prove challenging or even; that we will not find a reasonable way to achieve the desired performance. Expected outcomes; =================. * Add a ``qutip.core.data.tensorflow`` data type.; * Implement specialisations for some important operations (e.g. ``add``,; ``mul``, ``matmul``, ``eigen``, etc).; * Write a small benchmark to show how ``Qobj`` operations scale on the new; backend in comparison to the existing backends. Run the benchmark both; with and without using a GPU.; * Implement enough for a solver to run on top of the new TensorFlow data; backend and benchmark that (stretch goal). Skills; ======. * Git, Python and familiarity with the Python scientific computing stack; * Familiarity with TensorFlow (beneficial, but not required); * Familiarity with Cython (beneficial, but not required). Difficulty; ========",MatchSource.DOCS,doc/development/ideas/tensorflow-data-backend.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/tensorflow-data-backend.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/tensorflow-data-backend.rst:1684,Performance,perform,performance,1684,"d a backend that implements the necessary operations; using TensorFlow [1]_. Why a TensorFlow backend?; -------------------------. TensorFlow supports distributing matrix operations across multiple GPUs and; multiple machines, and abstracts away some of the complexities of doing so; efficiently. We hope that by using TensorFlow we might enable QuTiP to scale; to bigger quantum systems (e.g. more qubits) and decrease the time taken to; simulate them. There is particular interest in trying the new backend with the; BoFiN HEOM (Hierarchical Equations of Motion) solver [2]_. Challenges; ----------. TensorFlow is a very different kind of computational framework to the existing; dense and sparse matrix backends. It uses flow graphs to describe operations,; and to work efficiently. Ideally large graphs of operations need to be; executed together in order to efficiently compute results. The QuTiP data layer might need to be adjusted to accommodate these; differences, and it is possible that this will prove challenging or even; that we will not find a reasonable way to achieve the desired performance. Expected outcomes; =================. * Add a ``qutip.core.data.tensorflow`` data type.; * Implement specialisations for some important operations (e.g. ``add``,; ``mul``, ``matmul``, ``eigen``, etc).; * Write a small benchmark to show how ``Qobj`` operations scale on the new; backend in comparison to the existing backends. Run the benchmark both; with and without using a GPU.; * Implement enough for a solver to run on top of the new TensorFlow data; backend and benchmark that (stretch goal). Skills; ======. * Git, Python and familiarity with the Python scientific computing stack; * Familiarity with TensorFlow (beneficial, but not required); * Familiarity with Cython (beneficial, but not required). Difficulty; ==========. * Medium. Mentors; =======. * Simon Cross (hodgestar@gmail.com); * Jake Lishman (jake@binhbar.com); * Alex Pitchford (alex.pitchford@gmail.com). References; =",MatchSource.DOCS,doc/development/ideas/tensorflow-data-backend.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/tensorflow-data-backend.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/tensorflow-data-backend.rst:1915,Testability,benchmark,benchmark,1915,"ow supports distributing matrix operations across multiple GPUs and; multiple machines, and abstracts away some of the complexities of doing so; efficiently. We hope that by using TensorFlow we might enable QuTiP to scale; to bigger quantum systems (e.g. more qubits) and decrease the time taken to; simulate them. There is particular interest in trying the new backend with the; BoFiN HEOM (Hierarchical Equations of Motion) solver [2]_. Challenges; ----------. TensorFlow is a very different kind of computational framework to the existing; dense and sparse matrix backends. It uses flow graphs to describe operations,; and to work efficiently. Ideally large graphs of operations need to be; executed together in order to efficiently compute results. The QuTiP data layer might need to be adjusted to accommodate these; differences, and it is possible that this will prove challenging or even; that we will not find a reasonable way to achieve the desired performance. Expected outcomes; =================. * Add a ``qutip.core.data.tensorflow`` data type.; * Implement specialisations for some important operations (e.g. ``add``,; ``mul``, ``matmul``, ``eigen``, etc).; * Write a small benchmark to show how ``Qobj`` operations scale on the new; backend in comparison to the existing backends. Run the benchmark both; with and without using a GPU.; * Implement enough for a solver to run on top of the new TensorFlow data; backend and benchmark that (stretch goal). Skills; ======. * Git, Python and familiarity with the Python scientific computing stack; * Familiarity with TensorFlow (beneficial, but not required); * Familiarity with Cython (beneficial, but not required). Difficulty; ==========. * Medium. Mentors; =======. * Simon Cross (hodgestar@gmail.com); * Jake Lishman (jake@binhbar.com); * Alex Pitchford (alex.pitchford@gmail.com). References; ==========. .. [1] https://www.tensorflow.org/; .. [2] https://github.com/tehruhn/bofin; .. [3] https://github.com/qutip/qutip-tensorflow/; ",MatchSource.DOCS,doc/development/ideas/tensorflow-data-backend.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/tensorflow-data-backend.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/tensorflow-data-backend.rst:2031,Testability,benchmark,benchmark,2031,"ow supports distributing matrix operations across multiple GPUs and; multiple machines, and abstracts away some of the complexities of doing so; efficiently. We hope that by using TensorFlow we might enable QuTiP to scale; to bigger quantum systems (e.g. more qubits) and decrease the time taken to; simulate them. There is particular interest in trying the new backend with the; BoFiN HEOM (Hierarchical Equations of Motion) solver [2]_. Challenges; ----------. TensorFlow is a very different kind of computational framework to the existing; dense and sparse matrix backends. It uses flow graphs to describe operations,; and to work efficiently. Ideally large graphs of operations need to be; executed together in order to efficiently compute results. The QuTiP data layer might need to be adjusted to accommodate these; differences, and it is possible that this will prove challenging or even; that we will not find a reasonable way to achieve the desired performance. Expected outcomes; =================. * Add a ``qutip.core.data.tensorflow`` data type.; * Implement specialisations for some important operations (e.g. ``add``,; ``mul``, ``matmul``, ``eigen``, etc).; * Write a small benchmark to show how ``Qobj`` operations scale on the new; backend in comparison to the existing backends. Run the benchmark both; with and without using a GPU.; * Implement enough for a solver to run on top of the new TensorFlow data; backend and benchmark that (stretch goal). Skills; ======. * Git, Python and familiarity with the Python scientific computing stack; * Familiarity with TensorFlow (beneficial, but not required); * Familiarity with Cython (beneficial, but not required). Difficulty; ==========. * Medium. Mentors; =======. * Simon Cross (hodgestar@gmail.com); * Jake Lishman (jake@binhbar.com); * Alex Pitchford (alex.pitchford@gmail.com). References; ==========. .. [1] https://www.tensorflow.org/; .. [2] https://github.com/tehruhn/bofin; .. [3] https://github.com/qutip/qutip-tensorflow/; ",MatchSource.DOCS,doc/development/ideas/tensorflow-data-backend.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/tensorflow-data-backend.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/tensorflow-data-backend.rst:2164,Testability,benchmark,benchmark,2164,"ow supports distributing matrix operations across multiple GPUs and; multiple machines, and abstracts away some of the complexities of doing so; efficiently. We hope that by using TensorFlow we might enable QuTiP to scale; to bigger quantum systems (e.g. more qubits) and decrease the time taken to; simulate them. There is particular interest in trying the new backend with the; BoFiN HEOM (Hierarchical Equations of Motion) solver [2]_. Challenges; ----------. TensorFlow is a very different kind of computational framework to the existing; dense and sparse matrix backends. It uses flow graphs to describe operations,; and to work efficiently. Ideally large graphs of operations need to be; executed together in order to efficiently compute results. The QuTiP data layer might need to be adjusted to accommodate these; differences, and it is possible that this will prove challenging or even; that we will not find a reasonable way to achieve the desired performance. Expected outcomes; =================. * Add a ``qutip.core.data.tensorflow`` data type.; * Implement specialisations for some important operations (e.g. ``add``,; ``mul``, ``matmul``, ``eigen``, etc).; * Write a small benchmark to show how ``Qobj`` operations scale on the new; backend in comparison to the existing backends. Run the benchmark both; with and without using a GPU.; * Implement enough for a solver to run on top of the new TensorFlow data; backend and benchmark that (stretch goal). Skills; ======. * Git, Python and familiarity with the Python scientific computing stack; * Familiarity with TensorFlow (beneficial, but not required); * Familiarity with Cython (beneficial, but not required). Difficulty; ==========. * Medium. Mentors; =======. * Simon Cross (hodgestar@gmail.com); * Jake Lishman (jake@binhbar.com); * Alex Pitchford (alex.pitchford@gmail.com). References; ==========. .. [1] https://www.tensorflow.org/; .. [2] https://github.com/tehruhn/bofin; .. [3] https://github.com/qutip/qutip-tensorflow/; ",MatchSource.DOCS,doc/development/ideas/tensorflow-data-backend.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/tensorflow-data-backend.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst:1813,Availability,down,downside,1813,"s, and in those cases the Lindblad master equation is usually the method of choice. However, in some cases, for example systems with varying energy biases and eigenstates and that couple to an environment in some well-defined manner (through a physically motivated system-environment interaction operator), it is often desirable to derive the master equation from more fundamental physical principles, and relate it to for example the noise-power spectrum of the environment. The Bloch-Redfield formalism is one such approach to derive a master equation from a microscopic system.; It starts from a combined system-environment perspective, and derives a perturbative master equation for the system alone, under the assumption of weak system-environment coupling.; One advantage of this approach is that the dissipation processes and rates are obtained directly from the properties of the environment.; On the downside, it does not intrinsically guarantee that the resulting master equation unconditionally preserves the physical properties of the density matrix (because it is a perturbative method).; The Bloch-Redfield master equation must therefore be used with care, and the assumptions made in the derivation must be honored.; (The Lindblad master equation is in a sense more robust -- it always results in a physical density matrix -- although some collapse operators might not be physically justified).; For a full derivation of the Bloch Redfield master equation, see e.g. [Coh92]_ or [Bre02]_.; Here we present only a brief version of the derivation, with the intention of introducing the notation and how it relates to the implementation in QuTiP. .. _bloch-redfield-derivation:. Brief Derivation and Definitions; ================================. The starting point of the Bloch-Redfield formalism is the total Hamiltonian for the system and the environment (bath): :math:`H = H_{\rm S} + H_{\rm B} + H_{\rm I}`, where :math:`H` is the total system+bath Hamiltonian, :math:`H_{\rm S}` and ",MatchSource.DOCS,doc/guide/dynamics/dynamics-bloch-redfield.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst:2185,Availability,robust,robust,2185,"desirable to derive the master equation from more fundamental physical principles, and relate it to for example the noise-power spectrum of the environment. The Bloch-Redfield formalism is one such approach to derive a master equation from a microscopic system.; It starts from a combined system-environment perspective, and derives a perturbative master equation for the system alone, under the assumption of weak system-environment coupling.; One advantage of this approach is that the dissipation processes and rates are obtained directly from the properties of the environment.; On the downside, it does not intrinsically guarantee that the resulting master equation unconditionally preserves the physical properties of the density matrix (because it is a perturbative method).; The Bloch-Redfield master equation must therefore be used with care, and the assumptions made in the derivation must be honored.; (The Lindblad master equation is in a sense more robust -- it always results in a physical density matrix -- although some collapse operators might not be physically justified).; For a full derivation of the Bloch Redfield master equation, see e.g. [Coh92]_ or [Bre02]_.; Here we present only a brief version of the derivation, with the intention of introducing the notation and how it relates to the implementation in QuTiP. .. _bloch-redfield-derivation:. Brief Derivation and Definitions; ================================. The starting point of the Bloch-Redfield formalism is the total Hamiltonian for the system and the environment (bath): :math:`H = H_{\rm S} + H_{\rm B} + H_{\rm I}`, where :math:`H` is the total system+bath Hamiltonian, :math:`H_{\rm S}` and :math:`H_{\rm B}` are the system and bath Hamiltonians, respectively, and :math:`H_{\rm I}` is the interaction Hamiltonian. The most general form of a master equation for the system dynamics is obtained by tracing out the bath from the von-Neumann equation of motion for the combined system (:math:`\dot\rho = -i\hbar^{-",MatchSource.DOCS,doc/guide/dynamics/dynamics-bloch-redfield.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst:4648,Deployability,integrat,integration,4648,"the system and the bath, neither in the initial state nor at any time during the evolution.; *It is justified for weak system-bath interaction.*. The master equation :eq:`br-nonmarkovian-form-one` is non-Markovian, i.e., the change in the density matrix at a time :math:`t` depends on states at all times :math:`\tau < t`, making it intractable to solve both theoretically and numerically.; To make progress towards a manageable master equation, we now introduce the Markovian approximation, in which :math:`\rho_S(\tau)` is replaced by :math:`\rho_S(t)` in Eq. :eq:`br-nonmarkovian-form-one`.; The result is the Redfield equation. .. math::; :label: br-nonmarkovian-form-two. \frac{d}{dt}\rho_S(t) = - \hbar^{-2}\int_0^t d\tau\; {\rm Tr}_B [H_I(t), [H_I(\tau), \rho_S(t)\otimes\rho_B]],. which is local in time with respect the density matrix, but still not Markovian since it contains an implicit dependence on the initial state. By extending the integration to infinity and substituting :math:`\tau \rightarrow t-\tau`, a fully Markovian master equation is obtained:. .. math::; :label: br-markovian-form. \frac{d}{dt}\rho_S(t) = - \hbar^{-2}\int_0^\infty d\tau\; {\rm Tr}_B [H_I(t), [H_I(t-\tau), \rho_S(t)\otimes\rho_B]]. The two Markovian approximations introduced above are valid if the time-scale with which the system dynamics changes is large compared to the time-scale with which correlations in the bath decays (corresponding to a ""short-memory"" bath, which results in Markovian system dynamics). The master equation :eq:`br-markovian-form` is still on a too general form to be suitable for numerical implementation. We therefore assume that the system-bath interaction takes the form :math:`H_I = \sum_\alpha A_\alpha \otimes B_\alpha` and where :math:`A_\alpha` are system operators and :math:`B_\alpha` are bath operators.; This allows us to write master equation in terms of system operators and bath correlation functions:. .. math::. \frac{d}{dt}\rho_S(t) =; -\hbar^{-2}; \sum_{\alph",MatchSource.DOCS,doc/guide/dynamics/dynamics-bloch-redfield.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst:1045,Energy Efficiency,energy,energy,1045,"s plt; from scipy import *; from qutip import *; import numpy as np. .. _bloch-redfield-intro:. Introduction; ============. The Lindblad master equation introduced earlier is constructed so that it describes a physical evolution of the density matrix (i.e., trace and positivity preserving), but it does not provide a connection to any underlying microscopic physical model.; The Lindblad operators (collapse operators) describe phenomenological processes, such as for example dephasing and spin flips, and the rates of these processes are arbitrary parameters in the model.; In many situations the collapse operators and their corresponding rates have clear physical interpretation, such as dephasing and relaxation rates, and in those cases the Lindblad master equation is usually the method of choice. However, in some cases, for example systems with varying energy biases and eigenstates and that couple to an environment in some well-defined manner (through a physically motivated system-environment interaction operator), it is often desirable to derive the master equation from more fundamental physical principles, and relate it to for example the noise-power spectrum of the environment. The Bloch-Redfield formalism is one such approach to derive a master equation from a microscopic system.; It starts from a combined system-environment perspective, and derives a perturbative master equation for the system alone, under the assumption of weak system-environment coupling.; One advantage of this approach is that the dissipation processes and rates are obtained directly from the properties of the environment.; On the downside, it does not intrinsically guarantee that the resulting master equation unconditionally preserves the physical properties of the density matrix (because it is a perturbative method).; The Bloch-Redfield master equation must therefore be used with care, and the assumptions made in the derivation must be honored.; (The Lindblad master equation is in a sense mor",MatchSource.DOCS,doc/guide/dynamics/dynamics-bloch-redfield.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst:1345,Energy Efficiency,power,power,1345,"s plt; from scipy import *; from qutip import *; import numpy as np. .. _bloch-redfield-intro:. Introduction; ============. The Lindblad master equation introduced earlier is constructed so that it describes a physical evolution of the density matrix (i.e., trace and positivity preserving), but it does not provide a connection to any underlying microscopic physical model.; The Lindblad operators (collapse operators) describe phenomenological processes, such as for example dephasing and spin flips, and the rates of these processes are arbitrary parameters in the model.; In many situations the collapse operators and their corresponding rates have clear physical interpretation, such as dephasing and relaxation rates, and in those cases the Lindblad master equation is usually the method of choice. However, in some cases, for example systems with varying energy biases and eigenstates and that couple to an environment in some well-defined manner (through a physically motivated system-environment interaction operator), it is often desirable to derive the master equation from more fundamental physical principles, and relate it to for example the noise-power spectrum of the environment. The Bloch-Redfield formalism is one such approach to derive a master equation from a microscopic system.; It starts from a combined system-environment perspective, and derives a perturbative master equation for the system alone, under the assumption of weak system-environment coupling.; One advantage of this approach is that the dissipation processes and rates are obtained directly from the properties of the environment.; On the downside, it does not intrinsically guarantee that the resulting master equation unconditionally preserves the physical properties of the density matrix (because it is a perturbative method).; The Bloch-Redfield master equation must therefore be used with care, and the assumptions made in the derivation must be honored.; (The Lindblad master equation is in a sense mor",MatchSource.DOCS,doc/guide/dynamics/dynamics-bloch-redfield.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst:7441,Energy Efficiency,power,power,7441,"he eigenstate :math:`\left|m\right>`, we obtain in matrix form in the Schrdinger picture. .. math::. \frac{d}{dt}\rho_{ab}(t); =&; -i\omega_{ab}\rho_{ab}(t) \nonumber\\; &-\hbar^{-2}; \sum_{\alpha,\beta}; \sum_{c,d}^{\rm sec}; \int_0^\infty d\tau\;; \left\{; g_{\alpha\beta}(\tau); \left[\delta_{bd}\sum_nA^\alpha_{an}A^\beta_{nc}e^{i\omega_{cn}\tau}; -; A^\alpha_{ac} A^\beta_{db} e^{i\omega_{ca}\tau}; \right]; \right. \nonumber\\; &+; \left.; g_{\alpha\beta}(-\tau); \left[\delta_{ac}\sum_n A^\alpha_{dn}A^\beta_{nb} e^{i\omega_{nd}\tau}; -; A^\alpha_{ac}A^\beta_{db}e^{i\omega_{bd}\tau}; \right]; \right\} \rho_{cd}(t),; \nonumber\\. where the ""sec"" above the summation symbol indicate summation of the secular terms which satisfy :math:`|\omega_{ab}-\omega_{cd}| \ll \tau_ {\rm decay}`.; This is an almost-useful form of the master equation. The final step before arriving at the form of the Bloch-Redfield master equation that is implemented in QuTiP, involves rewriting the bath correlation function :math:`g(\tau)` in terms of the noise-power spectrum of the environment :math:`S(\omega) = \int_{-\infty}^\infty d\tau e^{i\omega\tau} g(\tau)`:. .. math::; :label: br-nonmarkovian-form-four. \int_0^\infty d\tau\; g_{\alpha\beta}(\tau) e^{i\omega\tau} = \frac{1}{2}S_{\alpha\beta}(\omega) + i\lambda_{\alpha\beta}(\omega),. where :math:`\lambda_{ab}(\omega)` is an energy shift that is neglected here. The final form of the Bloch-Redfield master equation is. .. math::; :label: br-final. \frac{d}{dt}\rho_{ab}(t); =; -i\omega_{ab}\rho_{ab}(t); +; \sum_{c,d}^{\rm sec}R_{abcd}\rho_{cd}(t),. where. .. math::; :label: br-nonmarkovian-form-five. R_{abcd} = -\frac{\hbar^{-2}}{2} \sum_{\alpha,\beta}; \left\{; \delta_{bd}\sum_nA^\alpha_{an}A^\beta_{nc}S_{\alpha\beta}(\omega_{cn}); -; A^\alpha_{ac} A^\beta_{db} S_{\alpha\beta}(\omega_{ca}); \right. \nonumber\\; +; \left.; \delta_{ac}\sum_n A^\alpha_{dn}A^\beta_{nb} S_{\alpha\beta}(\omega_{dn}); -; A^\alpha_{ac}A^\beta_{db} S_{\alpha\beta}(\om",MatchSource.DOCS,doc/guide/dynamics/dynamics-bloch-redfield.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst:7768,Energy Efficiency,energy,energy,7768,"A^\beta_{db} e^{i\omega_{ca}\tau}; \right]; \right. \nonumber\\; &+; \left.; g_{\alpha\beta}(-\tau); \left[\delta_{ac}\sum_n A^\alpha_{dn}A^\beta_{nb} e^{i\omega_{nd}\tau}; -; A^\alpha_{ac}A^\beta_{db}e^{i\omega_{bd}\tau}; \right]; \right\} \rho_{cd}(t),; \nonumber\\. where the ""sec"" above the summation symbol indicate summation of the secular terms which satisfy :math:`|\omega_{ab}-\omega_{cd}| \ll \tau_ {\rm decay}`.; This is an almost-useful form of the master equation. The final step before arriving at the form of the Bloch-Redfield master equation that is implemented in QuTiP, involves rewriting the bath correlation function :math:`g(\tau)` in terms of the noise-power spectrum of the environment :math:`S(\omega) = \int_{-\infty}^\infty d\tau e^{i\omega\tau} g(\tau)`:. .. math::; :label: br-nonmarkovian-form-four. \int_0^\infty d\tau\; g_{\alpha\beta}(\tau) e^{i\omega\tau} = \frac{1}{2}S_{\alpha\beta}(\omega) + i\lambda_{\alpha\beta}(\omega),. where :math:`\lambda_{ab}(\omega)` is an energy shift that is neglected here. The final form of the Bloch-Redfield master equation is. .. math::; :label: br-final. \frac{d}{dt}\rho_{ab}(t); =; -i\omega_{ab}\rho_{ab}(t); +; \sum_{c,d}^{\rm sec}R_{abcd}\rho_{cd}(t),. where. .. math::; :label: br-nonmarkovian-form-five. R_{abcd} = -\frac{\hbar^{-2}}{2} \sum_{\alpha,\beta}; \left\{; \delta_{bd}\sum_nA^\alpha_{an}A^\beta_{nc}S_{\alpha\beta}(\omega_{cn}); -; A^\alpha_{ac} A^\beta_{db} S_{\alpha\beta}(\omega_{ca}); \right. \nonumber\\; +; \left.; \delta_{ac}\sum_n A^\alpha_{dn}A^\beta_{nb} S_{\alpha\beta}(\omega_{dn}); -; A^\alpha_{ac}A^\beta_{db} S_{\alpha\beta}(\omega_{db}); \right\},. is the Bloch-Redfield tensor. The Bloch-Redfield master equation in the form Eq. :eq:`br-final` is suitable for numerical implementation. The input parameters are the system Hamiltonian :math:`H`, the system operators through which the environment couples to the system :math:`A_\alpha`, and the noise-power spectrum :math:`S_{\alpha\beta}(\omega)`",MatchSource.DOCS,doc/guide/dynamics/dynamics-bloch-redfield.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst:8719,Energy Efficiency,power,power,8719,"ga) + i\lambda_{\alpha\beta}(\omega),. where :math:`\lambda_{ab}(\omega)` is an energy shift that is neglected here. The final form of the Bloch-Redfield master equation is. .. math::; :label: br-final. \frac{d}{dt}\rho_{ab}(t); =; -i\omega_{ab}\rho_{ab}(t); +; \sum_{c,d}^{\rm sec}R_{abcd}\rho_{cd}(t),. where. .. math::; :label: br-nonmarkovian-form-five. R_{abcd} = -\frac{\hbar^{-2}}{2} \sum_{\alpha,\beta}; \left\{; \delta_{bd}\sum_nA^\alpha_{an}A^\beta_{nc}S_{\alpha\beta}(\omega_{cn}); -; A^\alpha_{ac} A^\beta_{db} S_{\alpha\beta}(\omega_{ca}); \right. \nonumber\\; +; \left.; \delta_{ac}\sum_n A^\alpha_{dn}A^\beta_{nb} S_{\alpha\beta}(\omega_{dn}); -; A^\alpha_{ac}A^\beta_{db} S_{\alpha\beta}(\omega_{db}); \right\},. is the Bloch-Redfield tensor. The Bloch-Redfield master equation in the form Eq. :eq:`br-final` is suitable for numerical implementation. The input parameters are the system Hamiltonian :math:`H`, the system operators through which the environment couples to the system :math:`A_\alpha`, and the noise-power spectrum :math:`S_{\alpha\beta}(\omega)` associated with each system-environment interaction term. To simplify the numerical implementation we assume that :math:`A_\alpha` are Hermitian and that cross-correlations between different environment operators vanish, so that the final expression for the Bloch-Redfield tensor that is implemented in QuTiP is. .. math::; :label: br-tensor. R_{abcd} = -\frac{\hbar^{-2}}{2} \sum_{\alpha}; \left\{; \delta_{bd}\sum_nA^\alpha_{an}A^\alpha_{nc}S_{\alpha}(\omega_{cn}); -; A^\alpha_{ac} A^\alpha_{db} S_{\alpha}(\omega_{ca}); \right. \nonumber\\; +; \left.; \delta_{ac}\sum_n A^\alpha_{dn}A^\alpha_{nb} S_{\alpha}(\omega_{dn}); -; A^\alpha_{ac}A^\alpha_{db} S_{\alpha}(\omega_{db}); \right\}. .. _bloch-redfield-qutip:. Bloch-Redfield master equation in QuTiP; =======================================. In QuTiP, the Bloch-Redfield tensor Eq. :eq:`br-tensor` can be calculated using the function :func:`.bloch_redfield_tensor`",MatchSource.DOCS,doc/guide/dynamics/dynamics-bloch-redfield.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst:15050,Energy Efficiency,efficient,efficient,15050,"=[[sigmax(), ohmic_spectrum]],; e_ops=e_ops, sec_cutoff=-1). will simulate the same example as above without the secular approximation.; Note that using the non-secular version may lead to negativity issues. .. _td-bloch-redfield:. Time-dependent Bloch-Redfield Dynamics; =======================================. If you have not done so already, please read the section: :ref:`time`. As we have already discussed, the Bloch-Redfield master equation requires transforming; into the eigenbasis of the system Hamiltonian.; For time-independent systems, this transformation need only be done once.; However, for time-dependent systems, one must move to the instantaneous eigenbasis; at each time-step in the evolution, thus greatly increasing the computational complexity of the dynamics.; In addition, the requirement for computing all the eigenvalues severely limits the scalability of the method.; Fortunately, this eigen decomposition occurs at the Hamiltonian level, as opposed to the; super-operator level, and thus, with efficient programming, one can tackle many systems that are commonly encountered. For time-dependent Hamiltonians, the Hamiltonian itself can be passed into the solver; like any other time dependent Hamiltonian, as thus we will not discuss this topic further.; Instead, here the focus is on time-dependent bath coupling terms.; To this end, suppose that we have a dissipative harmonic oscillator, where the white-noise; dissipation rate decreases exponentially with time :math:`\kappa(t) = \kappa(0)\exp(-t)`.; In the Lindblad or Monte Carlo solvers, this could be implemented as a time-dependent; collapse operator list ``c_ops = [[a, 'sqrt(kappa*exp(-t))']]``.; In the Bloch-Redfield solver, the bath coupling terms must be Hermitian.; As such, in this example, our coupling operator is the position operator ``a+a.dag()``.; The complete example, and comparison to the analytic expression is:. .. plot::; :context: close-figs. N = 10 # number of basis states to consider; a ",MatchSource.DOCS,doc/guide/dynamics/dynamics-bloch-redfield.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst:17156,Energy Efficiency,power,power,17156," is:. .. plot::; :context: close-figs. N = 10 # number of basis states to consider; a = destroy(N); H = a.dag() * a; psi0 = basis(N, 9) # initial state; kappa = 0.2 # coupling to oscillator; a_ops = [; ([a+a.dag(), f'sqrt({kappa}*exp(-t))'], '(w>=0)'); ]; tlist = np.linspace(0, 10, 100). out = brmesolve(H, psi0, tlist, a_ops, e_ops=[a.dag() * a]); actual_answer = 9.0 * np.exp(-kappa * (1.0 - np.exp(-tlist))). plt.figure(); plt.plot(tlist, out.expect[0]); plt.plot(tlist, actual_answer); plt.show(). In many cases, the bath-coupling operators can take the form :math:`A = f(t)a + f(t)^* a^{+}`.; The operator parts of the `a_ops` can be made of as many time-dependent terms as needed to construct such operator.; For example consider a white-noise bath that is coupled to an operator of the form ``exp(1j*t)*a + exp(-1j*t)* a.dag()``.; In this example, the ``a_ops`` list would be:. .. plot::; :context: close-figs. a_ops = [; ([[a, 'exp(1j*t)'], [a.dag(), 'exp(-1j*t)']], f'{kappa} * (w >= 0)'); ]. where the first tuple element ``[[a, 'exp(1j*t)'], [a.dag(), 'exp(-1j*t)']]`` tells; the solver what is the time-dependent Hermitian coupling operator.; The second tuple ``f'{kappa} * (w >= 0)'``, gives the noise power spectrum.; A full example is:. .. plot::; :context: close-figs. N = 10; w0 = 1.0 * 2 * np.pi; g = 0.05 * w0; kappa = 0.15; times = np.linspace(0, 25, 1000). a = destroy(N); H = w0 * a.dag() * a + g * (a + a.dag()); psi0 = ket2dm((basis(N, 4) + basis(N, 2) + basis(N, 0)).unit()); a_ops = [[; QobjEvo([[a, 'exp(1j*t)'], [a.dag(), 'exp(-1j*t)']]), (f'{kappa} * (w >= 0)'); ]]; e_ops = [a.dag() * a, a + a.dag()]. res_brme = brmesolve(H, psi0, times, a_ops, e_ops). plt.figure(); plt.plot(times, res_brme.expect[0], label=r'$a^{+}a$'); plt.plot(times, res_brme.expect[1], label=r'$a+a^{+}$'); plt.legend(); plt.show(). Further examples on time-dependent Bloch-Redfield simulations can be found in the online tutorials. .. plot::; :context: reset; :include-source: false; :nofigs:; ",MatchSource.DOCS,doc/guide/dynamics/dynamics-bloch-redfield.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst:3973,Integrability,depend,depends,3973,"interaction Hamiltonian. The most general form of a master equation for the system dynamics is obtained by tracing out the bath from the von-Neumann equation of motion for the combined system (:math:`\dot\rho = -i\hbar^{-1}[H, \rho]`). In the interaction picture the result is. .. math::; :label: br-nonmarkovian-form-one. \frac{d}{dt}\rho_S(t) = - \hbar^{-2}\int_0^t d\tau\; {\rm Tr}_B [H_I(t), [H_I(\tau), \rho_S(\tau)\otimes\rho_B]],. where the additional assumption that the total system-bath density matrix can be factorized as :math:`\rho(t) \approx \rho_S(t) \otimes \rho_B`.; This assumption is known as the Born approximation, and it implies that there never is any entanglement between the system and the bath, neither in the initial state nor at any time during the evolution.; *It is justified for weak system-bath interaction.*. The master equation :eq:`br-nonmarkovian-form-one` is non-Markovian, i.e., the change in the density matrix at a time :math:`t` depends on states at all times :math:`\tau < t`, making it intractable to solve both theoretically and numerically.; To make progress towards a manageable master equation, we now introduce the Markovian approximation, in which :math:`\rho_S(\tau)` is replaced by :math:`\rho_S(t)` in Eq. :eq:`br-nonmarkovian-form-one`.; The result is the Redfield equation. .. math::; :label: br-nonmarkovian-form-two. \frac{d}{dt}\rho_S(t) = - \hbar^{-2}\int_0^t d\tau\; {\rm Tr}_B [H_I(t), [H_I(\tau), \rho_S(t)\otimes\rho_B]],. which is local in time with respect the density matrix, but still not Markovian since it contains an implicit dependence on the initial state. By extending the integration to infinity and substituting :math:`\tau \rightarrow t-\tau`, a fully Markovian master equation is obtained:. .. math::; :label: br-markovian-form. \frac{d}{dt}\rho_S(t) = - \hbar^{-2}\int_0^\infty d\tau\; {\rm Tr}_B [H_I(t), [H_I(t-\tau), \rho_S(t)\otimes\rho_B]]. The two Markovian approximations introduced above are valid if the time-scale",MatchSource.DOCS,doc/guide/dynamics/dynamics-bloch-redfield.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst:4598,Integrability,depend,dependence,4598," \rho_S(t) \otimes \rho_B`.; This assumption is known as the Born approximation, and it implies that there never is any entanglement between the system and the bath, neither in the initial state nor at any time during the evolution.; *It is justified for weak system-bath interaction.*. The master equation :eq:`br-nonmarkovian-form-one` is non-Markovian, i.e., the change in the density matrix at a time :math:`t` depends on states at all times :math:`\tau < t`, making it intractable to solve both theoretically and numerically.; To make progress towards a manageable master equation, we now introduce the Markovian approximation, in which :math:`\rho_S(\tau)` is replaced by :math:`\rho_S(t)` in Eq. :eq:`br-nonmarkovian-form-one`.; The result is the Redfield equation. .. math::; :label: br-nonmarkovian-form-two. \frac{d}{dt}\rho_S(t) = - \hbar^{-2}\int_0^t d\tau\; {\rm Tr}_B [H_I(t), [H_I(\tau), \rho_S(t)\otimes\rho_B]],. which is local in time with respect the density matrix, but still not Markovian since it contains an implicit dependence on the initial state. By extending the integration to infinity and substituting :math:`\tau \rightarrow t-\tau`, a fully Markovian master equation is obtained:. .. math::; :label: br-markovian-form. \frac{d}{dt}\rho_S(t) = - \hbar^{-2}\int_0^\infty d\tau\; {\rm Tr}_B [H_I(t), [H_I(t-\tau), \rho_S(t)\otimes\rho_B]]. The two Markovian approximations introduced above are valid if the time-scale with which the system dynamics changes is large compared to the time-scale with which correlations in the bath decays (corresponding to a ""short-memory"" bath, which results in Markovian system dynamics). The master equation :eq:`br-markovian-form` is still on a too general form to be suitable for numerical implementation. We therefore assume that the system-bath interaction takes the form :math:`H_I = \sum_\alpha A_\alpha \otimes B_\alpha` and where :math:`A_\alpha` are system operators and :math:`B_\alpha` are bath operators.; This allows us to wri",MatchSource.DOCS,doc/guide/dynamics/dynamics-bloch-redfield.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst:4648,Integrability,integrat,integration,4648,"the system and the bath, neither in the initial state nor at any time during the evolution.; *It is justified for weak system-bath interaction.*. The master equation :eq:`br-nonmarkovian-form-one` is non-Markovian, i.e., the change in the density matrix at a time :math:`t` depends on states at all times :math:`\tau < t`, making it intractable to solve both theoretically and numerically.; To make progress towards a manageable master equation, we now introduce the Markovian approximation, in which :math:`\rho_S(\tau)` is replaced by :math:`\rho_S(t)` in Eq. :eq:`br-nonmarkovian-form-one`.; The result is the Redfield equation. .. math::; :label: br-nonmarkovian-form-two. \frac{d}{dt}\rho_S(t) = - \hbar^{-2}\int_0^t d\tau\; {\rm Tr}_B [H_I(t), [H_I(\tau), \rho_S(t)\otimes\rho_B]],. which is local in time with respect the density matrix, but still not Markovian since it contains an implicit dependence on the initial state. By extending the integration to infinity and substituting :math:`\tau \rightarrow t-\tau`, a fully Markovian master equation is obtained:. .. math::; :label: br-markovian-form. \frac{d}{dt}\rho_S(t) = - \hbar^{-2}\int_0^\infty d\tau\; {\rm Tr}_B [H_I(t), [H_I(t-\tau), \rho_S(t)\otimes\rho_B]]. The two Markovian approximations introduced above are valid if the time-scale with which the system dynamics changes is large compared to the time-scale with which correlations in the bath decays (corresponding to a ""short-memory"" bath, which results in Markovian system dynamics). The master equation :eq:`br-markovian-form` is still on a too general form to be suitable for numerical implementation. We therefore assume that the system-bath interaction takes the form :math:`H_I = \sum_\alpha A_\alpha \otimes B_\alpha` and where :math:`A_\alpha` are system operators and :math:`B_\alpha` are bath operators.; This allows us to write master equation in terms of system operators and bath correlation functions:. .. math::. \frac{d}{dt}\rho_S(t) =; -\hbar^{-2}; \sum_{\alph",MatchSource.DOCS,doc/guide/dynamics/dynamics-bloch-redfield.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst:14263,Integrability,depend,dependent,14263,"mic_spectrum]], e_ops=e_ops). where the resulting `output` is an instance of the class :class:`.Result`. .. note::; While the code example simulates the Bloch-Redfield equation in the secular; approximation, QuTiP's implementation allows the user to simulate the non-secular; version of the Bloch-Redfield equation by setting ``sec_cutoff=-1``, as well as; do a partial secular approximation by setting it to a ``float`` , this float; will become the cutoff for the sum in :eq:`br-final` meaning terms with; :math:`|\omega_{ab}-\omega_{cd}|` greater than the cutoff will be neglected.; Its default value is 0.1 which corresponds to the secular approximation.; For example the command; ::. output = brmesolve(H, psi0, tlist, a_ops=[[sigmax(), ohmic_spectrum]],; e_ops=e_ops, sec_cutoff=-1). will simulate the same example as above without the secular approximation.; Note that using the non-secular version may lead to negativity issues. .. _td-bloch-redfield:. Time-dependent Bloch-Redfield Dynamics; =======================================. If you have not done so already, please read the section: :ref:`time`. As we have already discussed, the Bloch-Redfield master equation requires transforming; into the eigenbasis of the system Hamiltonian.; For time-independent systems, this transformation need only be done once.; However, for time-dependent systems, one must move to the instantaneous eigenbasis; at each time-step in the evolution, thus greatly increasing the computational complexity of the dynamics.; In addition, the requirement for computing all the eigenvalues severely limits the scalability of the method.; Fortunately, this eigen decomposition occurs at the Hamiltonian level, as opposed to the; super-operator level, and thus, with efficient programming, one can tackle many systems that are commonly encountered. For time-dependent Hamiltonians, the Hamiltonian itself can be passed into the solver; like any other time dependent Hamiltonian, as thus we will not discuss this top",MatchSource.DOCS,doc/guide/dynamics/dynamics-bloch-redfield.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst:14639,Integrability,depend,dependent,14639,"t`` , this float; will become the cutoff for the sum in :eq:`br-final` meaning terms with; :math:`|\omega_{ab}-\omega_{cd}|` greater than the cutoff will be neglected.; Its default value is 0.1 which corresponds to the secular approximation.; For example the command; ::. output = brmesolve(H, psi0, tlist, a_ops=[[sigmax(), ohmic_spectrum]],; e_ops=e_ops, sec_cutoff=-1). will simulate the same example as above without the secular approximation.; Note that using the non-secular version may lead to negativity issues. .. _td-bloch-redfield:. Time-dependent Bloch-Redfield Dynamics; =======================================. If you have not done so already, please read the section: :ref:`time`. As we have already discussed, the Bloch-Redfield master equation requires transforming; into the eigenbasis of the system Hamiltonian.; For time-independent systems, this transformation need only be done once.; However, for time-dependent systems, one must move to the instantaneous eigenbasis; at each time-step in the evolution, thus greatly increasing the computational complexity of the dynamics.; In addition, the requirement for computing all the eigenvalues severely limits the scalability of the method.; Fortunately, this eigen decomposition occurs at the Hamiltonian level, as opposed to the; super-operator level, and thus, with efficient programming, one can tackle many systems that are commonly encountered. For time-dependent Hamiltonians, the Hamiltonian itself can be passed into the solver; like any other time dependent Hamiltonian, as thus we will not discuss this topic further.; Instead, here the focus is on time-dependent bath coupling terms.; To this end, suppose that we have a dissipative harmonic oscillator, where the white-noise; dissipation rate decreases exponentially with time :math:`\kappa(t) = \kappa(0)\exp(-t)`.; In the Lindblad or Monte Carlo solvers, this could be implemented as a time-dependent; collapse operator list ``c_ops = [[a, 'sqrt(kappa*exp(-t))']]``.; I",MatchSource.DOCS,doc/guide/dynamics/dynamics-bloch-redfield.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst:15141,Integrability,depend,dependent,15141,"ivity issues. .. _td-bloch-redfield:. Time-dependent Bloch-Redfield Dynamics; =======================================. If you have not done so already, please read the section: :ref:`time`. As we have already discussed, the Bloch-Redfield master equation requires transforming; into the eigenbasis of the system Hamiltonian.; For time-independent systems, this transformation need only be done once.; However, for time-dependent systems, one must move to the instantaneous eigenbasis; at each time-step in the evolution, thus greatly increasing the computational complexity of the dynamics.; In addition, the requirement for computing all the eigenvalues severely limits the scalability of the method.; Fortunately, this eigen decomposition occurs at the Hamiltonian level, as opposed to the; super-operator level, and thus, with efficient programming, one can tackle many systems that are commonly encountered. For time-dependent Hamiltonians, the Hamiltonian itself can be passed into the solver; like any other time dependent Hamiltonian, as thus we will not discuss this topic further.; Instead, here the focus is on time-dependent bath coupling terms.; To this end, suppose that we have a dissipative harmonic oscillator, where the white-noise; dissipation rate decreases exponentially with time :math:`\kappa(t) = \kappa(0)\exp(-t)`.; In the Lindblad or Monte Carlo solvers, this could be implemented as a time-dependent; collapse operator list ``c_ops = [[a, 'sqrt(kappa*exp(-t))']]``.; In the Bloch-Redfield solver, the bath coupling terms must be Hermitian.; As such, in this example, our coupling operator is the position operator ``a+a.dag()``.; The complete example, and comparison to the analytic expression is:. .. plot::; :context: close-figs. N = 10 # number of basis states to consider; a = destroy(N); H = a.dag() * a; psi0 = basis(N, 9) # initial state; kappa = 0.2 # coupling to oscillator; a_ops = [; ([a+a.dag(), f'sqrt({kappa}*exp(-t))'], '(w>=0)'); ]; tlist = np.linspace(0, 1",MatchSource.DOCS,doc/guide/dynamics/dynamics-bloch-redfield.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst:15239,Integrability,depend,dependent,15239,"ivity issues. .. _td-bloch-redfield:. Time-dependent Bloch-Redfield Dynamics; =======================================. If you have not done so already, please read the section: :ref:`time`. As we have already discussed, the Bloch-Redfield master equation requires transforming; into the eigenbasis of the system Hamiltonian.; For time-independent systems, this transformation need only be done once.; However, for time-dependent systems, one must move to the instantaneous eigenbasis; at each time-step in the evolution, thus greatly increasing the computational complexity of the dynamics.; In addition, the requirement for computing all the eigenvalues severely limits the scalability of the method.; Fortunately, this eigen decomposition occurs at the Hamiltonian level, as opposed to the; super-operator level, and thus, with efficient programming, one can tackle many systems that are commonly encountered. For time-dependent Hamiltonians, the Hamiltonian itself can be passed into the solver; like any other time dependent Hamiltonian, as thus we will not discuss this topic further.; Instead, here the focus is on time-dependent bath coupling terms.; To this end, suppose that we have a dissipative harmonic oscillator, where the white-noise; dissipation rate decreases exponentially with time :math:`\kappa(t) = \kappa(0)\exp(-t)`.; In the Lindblad or Monte Carlo solvers, this could be implemented as a time-dependent; collapse operator list ``c_ops = [[a, 'sqrt(kappa*exp(-t))']]``.; In the Bloch-Redfield solver, the bath coupling terms must be Hermitian.; As such, in this example, our coupling operator is the position operator ``a+a.dag()``.; The complete example, and comparison to the analytic expression is:. .. plot::; :context: close-figs. N = 10 # number of basis states to consider; a = destroy(N); H = a.dag() * a; psi0 = basis(N, 9) # initial state; kappa = 0.2 # coupling to oscillator; a_ops = [; ([a+a.dag(), f'sqrt({kappa}*exp(-t))'], '(w>=0)'); ]; tlist = np.linspace(0, 1",MatchSource.DOCS,doc/guide/dynamics/dynamics-bloch-redfield.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst:15346,Integrability,depend,dependent,15346,"you have not done so already, please read the section: :ref:`time`. As we have already discussed, the Bloch-Redfield master equation requires transforming; into the eigenbasis of the system Hamiltonian.; For time-independent systems, this transformation need only be done once.; However, for time-dependent systems, one must move to the instantaneous eigenbasis; at each time-step in the evolution, thus greatly increasing the computational complexity of the dynamics.; In addition, the requirement for computing all the eigenvalues severely limits the scalability of the method.; Fortunately, this eigen decomposition occurs at the Hamiltonian level, as opposed to the; super-operator level, and thus, with efficient programming, one can tackle many systems that are commonly encountered. For time-dependent Hamiltonians, the Hamiltonian itself can be passed into the solver; like any other time dependent Hamiltonian, as thus we will not discuss this topic further.; Instead, here the focus is on time-dependent bath coupling terms.; To this end, suppose that we have a dissipative harmonic oscillator, where the white-noise; dissipation rate decreases exponentially with time :math:`\kappa(t) = \kappa(0)\exp(-t)`.; In the Lindblad or Monte Carlo solvers, this could be implemented as a time-dependent; collapse operator list ``c_ops = [[a, 'sqrt(kappa*exp(-t))']]``.; In the Bloch-Redfield solver, the bath coupling terms must be Hermitian.; As such, in this example, our coupling operator is the position operator ``a+a.dag()``.; The complete example, and comparison to the analytic expression is:. .. plot::; :context: close-figs. N = 10 # number of basis states to consider; a = destroy(N); H = a.dag() * a; psi0 = basis(N, 9) # initial state; kappa = 0.2 # coupling to oscillator; a_ops = [; ([a+a.dag(), f'sqrt({kappa}*exp(-t))'], '(w>=0)'); ]; tlist = np.linspace(0, 10, 100). out = brmesolve(H, psi0, tlist, a_ops, e_ops=[a.dag() * a]); actual_answer = 9.0 * np.exp(-kappa * (1.0 - np.exp(-",MatchSource.DOCS,doc/guide/dynamics/dynamics-bloch-redfield.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst:15637,Integrability,depend,dependent,15637,"ime-dependent systems, one must move to the instantaneous eigenbasis; at each time-step in the evolution, thus greatly increasing the computational complexity of the dynamics.; In addition, the requirement for computing all the eigenvalues severely limits the scalability of the method.; Fortunately, this eigen decomposition occurs at the Hamiltonian level, as opposed to the; super-operator level, and thus, with efficient programming, one can tackle many systems that are commonly encountered. For time-dependent Hamiltonians, the Hamiltonian itself can be passed into the solver; like any other time dependent Hamiltonian, as thus we will not discuss this topic further.; Instead, here the focus is on time-dependent bath coupling terms.; To this end, suppose that we have a dissipative harmonic oscillator, where the white-noise; dissipation rate decreases exponentially with time :math:`\kappa(t) = \kappa(0)\exp(-t)`.; In the Lindblad or Monte Carlo solvers, this could be implemented as a time-dependent; collapse operator list ``c_ops = [[a, 'sqrt(kappa*exp(-t))']]``.; In the Bloch-Redfield solver, the bath coupling terms must be Hermitian.; As such, in this example, our coupling operator is the position operator ``a+a.dag()``.; The complete example, and comparison to the analytic expression is:. .. plot::; :context: close-figs. N = 10 # number of basis states to consider; a = destroy(N); H = a.dag() * a; psi0 = basis(N, 9) # initial state; kappa = 0.2 # coupling to oscillator; a_ops = [; ([a+a.dag(), f'sqrt({kappa}*exp(-t))'], '(w>=0)'); ]; tlist = np.linspace(0, 10, 100). out = brmesolve(H, psi0, tlist, a_ops, e_ops=[a.dag() * a]); actual_answer = 9.0 * np.exp(-kappa * (1.0 - np.exp(-tlist))). plt.figure(); plt.plot(tlist, out.expect[0]); plt.plot(tlist, actual_answer); plt.show(). In many cases, the bath-coupling operators can take the form :math:`A = f(t)a + f(t)^* a^{+}`.; The operator parts of the `a_ops` can be made of as many time-dependent terms as needed to constr",MatchSource.DOCS,doc/guide/dynamics/dynamics-bloch-redfield.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst:16601,Integrability,depend,dependent,16601,"vers, this could be implemented as a time-dependent; collapse operator list ``c_ops = [[a, 'sqrt(kappa*exp(-t))']]``.; In the Bloch-Redfield solver, the bath coupling terms must be Hermitian.; As such, in this example, our coupling operator is the position operator ``a+a.dag()``.; The complete example, and comparison to the analytic expression is:. .. plot::; :context: close-figs. N = 10 # number of basis states to consider; a = destroy(N); H = a.dag() * a; psi0 = basis(N, 9) # initial state; kappa = 0.2 # coupling to oscillator; a_ops = [; ([a+a.dag(), f'sqrt({kappa}*exp(-t))'], '(w>=0)'); ]; tlist = np.linspace(0, 10, 100). out = brmesolve(H, psi0, tlist, a_ops, e_ops=[a.dag() * a]); actual_answer = 9.0 * np.exp(-kappa * (1.0 - np.exp(-tlist))). plt.figure(); plt.plot(tlist, out.expect[0]); plt.plot(tlist, actual_answer); plt.show(). In many cases, the bath-coupling operators can take the form :math:`A = f(t)a + f(t)^* a^{+}`.; The operator parts of the `a_ops` can be made of as many time-dependent terms as needed to construct such operator.; For example consider a white-noise bath that is coupled to an operator of the form ``exp(1j*t)*a + exp(-1j*t)* a.dag()``.; In this example, the ``a_ops`` list would be:. .. plot::; :context: close-figs. a_ops = [; ([[a, 'exp(1j*t)'], [a.dag(), 'exp(-1j*t)']], f'{kappa} * (w >= 0)'); ]. where the first tuple element ``[[a, 'exp(1j*t)'], [a.dag(), 'exp(-1j*t)']]`` tells; the solver what is the time-dependent Hermitian coupling operator.; The second tuple ``f'{kappa} * (w >= 0)'``, gives the noise power spectrum.; A full example is:. .. plot::; :context: close-figs. N = 10; w0 = 1.0 * 2 * np.pi; g = 0.05 * w0; kappa = 0.15; times = np.linspace(0, 25, 1000). a = destroy(N); H = w0 * a.dag() * a + g * (a + a.dag()); psi0 = ket2dm((basis(N, 4) + basis(N, 2) + basis(N, 0)).unit()); a_ops = [[; QobjEvo([[a, 'exp(1j*t)'], [a.dag(), 'exp(-1j*t)']]), (f'{kappa} * (w >= 0)'); ]]; e_ops = [a.dag() * a, a + a.dag()]. res_brme = brmesolve(H,",MatchSource.DOCS,doc/guide/dynamics/dynamics-bloch-redfield.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst:17056,Integrability,depend,dependent,17056," is:. .. plot::; :context: close-figs. N = 10 # number of basis states to consider; a = destroy(N); H = a.dag() * a; psi0 = basis(N, 9) # initial state; kappa = 0.2 # coupling to oscillator; a_ops = [; ([a+a.dag(), f'sqrt({kappa}*exp(-t))'], '(w>=0)'); ]; tlist = np.linspace(0, 10, 100). out = brmesolve(H, psi0, tlist, a_ops, e_ops=[a.dag() * a]); actual_answer = 9.0 * np.exp(-kappa * (1.0 - np.exp(-tlist))). plt.figure(); plt.plot(tlist, out.expect[0]); plt.plot(tlist, actual_answer); plt.show(). In many cases, the bath-coupling operators can take the form :math:`A = f(t)a + f(t)^* a^{+}`.; The operator parts of the `a_ops` can be made of as many time-dependent terms as needed to construct such operator.; For example consider a white-noise bath that is coupled to an operator of the form ``exp(1j*t)*a + exp(-1j*t)* a.dag()``.; In this example, the ``a_ops`` list would be:. .. plot::; :context: close-figs. a_ops = [; ([[a, 'exp(1j*t)'], [a.dag(), 'exp(-1j*t)']], f'{kappa} * (w >= 0)'); ]. where the first tuple element ``[[a, 'exp(1j*t)'], [a.dag(), 'exp(-1j*t)']]`` tells; the solver what is the time-dependent Hermitian coupling operator.; The second tuple ``f'{kappa} * (w >= 0)'``, gives the noise power spectrum.; A full example is:. .. plot::; :context: close-figs. N = 10; w0 = 1.0 * 2 * np.pi; g = 0.05 * w0; kappa = 0.15; times = np.linspace(0, 25, 1000). a = destroy(N); H = w0 * a.dag() * a + g * (a + a.dag()); psi0 = ket2dm((basis(N, 4) + basis(N, 2) + basis(N, 0)).unit()); a_ops = [[; QobjEvo([[a, 'exp(1j*t)'], [a.dag(), 'exp(-1j*t)']]), (f'{kappa} * (w >= 0)'); ]]; e_ops = [a.dag() * a, a + a.dag()]. res_brme = brmesolve(H, psi0, times, a_ops, e_ops). plt.figure(); plt.plot(times, res_brme.expect[0], label=r'$a^{+}a$'); plt.plot(times, res_brme.expect[1], label=r'$a+a^{+}$'); plt.legend(); plt.show(). Further examples on time-dependent Bloch-Redfield simulations can be found in the online tutorials. .. plot::; :context: reset; :include-source: false; :nofigs:; ",MatchSource.DOCS,doc/guide/dynamics/dynamics-bloch-redfield.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst:17803,Integrability,depend,dependent,17803," is:. .. plot::; :context: close-figs. N = 10 # number of basis states to consider; a = destroy(N); H = a.dag() * a; psi0 = basis(N, 9) # initial state; kappa = 0.2 # coupling to oscillator; a_ops = [; ([a+a.dag(), f'sqrt({kappa}*exp(-t))'], '(w>=0)'); ]; tlist = np.linspace(0, 10, 100). out = brmesolve(H, psi0, tlist, a_ops, e_ops=[a.dag() * a]); actual_answer = 9.0 * np.exp(-kappa * (1.0 - np.exp(-tlist))). plt.figure(); plt.plot(tlist, out.expect[0]); plt.plot(tlist, actual_answer); plt.show(). In many cases, the bath-coupling operators can take the form :math:`A = f(t)a + f(t)^* a^{+}`.; The operator parts of the `a_ops` can be made of as many time-dependent terms as needed to construct such operator.; For example consider a white-noise bath that is coupled to an operator of the form ``exp(1j*t)*a + exp(-1j*t)* a.dag()``.; In this example, the ``a_ops`` list would be:. .. plot::; :context: close-figs. a_ops = [; ([[a, 'exp(1j*t)'], [a.dag(), 'exp(-1j*t)']], f'{kappa} * (w >= 0)'); ]. where the first tuple element ``[[a, 'exp(1j*t)'], [a.dag(), 'exp(-1j*t)']]`` tells; the solver what is the time-dependent Hermitian coupling operator.; The second tuple ``f'{kappa} * (w >= 0)'``, gives the noise power spectrum.; A full example is:. .. plot::; :context: close-figs. N = 10; w0 = 1.0 * 2 * np.pi; g = 0.05 * w0; kappa = 0.15; times = np.linspace(0, 25, 1000). a = destroy(N); H = w0 * a.dag() * a + g * (a + a.dag()); psi0 = ket2dm((basis(N, 4) + basis(N, 2) + basis(N, 0)).unit()); a_ops = [[; QobjEvo([[a, 'exp(1j*t)'], [a.dag(), 'exp(-1j*t)']]), (f'{kappa} * (w >= 0)'); ]]; e_ops = [a.dag() * a, a + a.dag()]. res_brme = brmesolve(H, psi0, times, a_ops, e_ops). plt.figure(); plt.plot(times, res_brme.expect[0], label=r'$a^{+}a$'); plt.plot(times, res_brme.expect[1], label=r'$a+a^{+}$'); plt.legend(); plt.show(). Further examples on time-dependent Bloch-Redfield simulations can be found in the online tutorials. .. plot::; :context: reset; :include-source: false; :nofigs:; ",MatchSource.DOCS,doc/guide/dynamics/dynamics-bloch-redfield.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst:1657,Modifiability,coupling,coupling,1657,"rators (collapse operators) describe phenomenological processes, such as for example dephasing and spin flips, and the rates of these processes are arbitrary parameters in the model.; In many situations the collapse operators and their corresponding rates have clear physical interpretation, such as dephasing and relaxation rates, and in those cases the Lindblad master equation is usually the method of choice. However, in some cases, for example systems with varying energy biases and eigenstates and that couple to an environment in some well-defined manner (through a physically motivated system-environment interaction operator), it is often desirable to derive the master equation from more fundamental physical principles, and relate it to for example the noise-power spectrum of the environment. The Bloch-Redfield formalism is one such approach to derive a master equation from a microscopic system.; It starts from a combined system-environment perspective, and derives a perturbative master equation for the system alone, under the assumption of weak system-environment coupling.; One advantage of this approach is that the dissipation processes and rates are obtained directly from the properties of the environment.; On the downside, it does not intrinsically guarantee that the resulting master equation unconditionally preserves the physical properties of the density matrix (because it is a perturbative method).; The Bloch-Redfield master equation must therefore be used with care, and the assumptions made in the derivation must be honored.; (The Lindblad master equation is in a sense more robust -- it always results in a physical density matrix -- although some collapse operators might not be physically justified).; For a full derivation of the Bloch Redfield master equation, see e.g. [Coh92]_ or [Bre02]_.; Here we present only a brief version of the derivation, with the intention of introducing the notation and how it relates to the implementation in QuTiP. .. _bloch-red",MatchSource.DOCS,doc/guide/dynamics/dynamics-bloch-redfield.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst:4634,Modifiability,extend,extending,4634,"the system and the bath, neither in the initial state nor at any time during the evolution.; *It is justified for weak system-bath interaction.*. The master equation :eq:`br-nonmarkovian-form-one` is non-Markovian, i.e., the change in the density matrix at a time :math:`t` depends on states at all times :math:`\tau < t`, making it intractable to solve both theoretically and numerically.; To make progress towards a manageable master equation, we now introduce the Markovian approximation, in which :math:`\rho_S(\tau)` is replaced by :math:`\rho_S(t)` in Eq. :eq:`br-nonmarkovian-form-one`.; The result is the Redfield equation. .. math::; :label: br-nonmarkovian-form-two. \frac{d}{dt}\rho_S(t) = - \hbar^{-2}\int_0^t d\tau\; {\rm Tr}_B [H_I(t), [H_I(\tau), \rho_S(t)\otimes\rho_B]],. which is local in time with respect the density matrix, but still not Markovian since it contains an implicit dependence on the initial state. By extending the integration to infinity and substituting :math:`\tau \rightarrow t-\tau`, a fully Markovian master equation is obtained:. .. math::; :label: br-markovian-form. \frac{d}{dt}\rho_S(t) = - \hbar^{-2}\int_0^\infty d\tau\; {\rm Tr}_B [H_I(t), [H_I(t-\tau), \rho_S(t)\otimes\rho_B]]. The two Markovian approximations introduced above are valid if the time-scale with which the system dynamics changes is large compared to the time-scale with which correlations in the bath decays (corresponding to a ""short-memory"" bath, which results in Markovian system dynamics). The master equation :eq:`br-markovian-form` is still on a too general form to be suitable for numerical implementation. We therefore assume that the system-bath interaction takes the form :math:`H_I = \sum_\alpha A_\alpha \otimes B_\alpha` and where :math:`A_\alpha` are system operators and :math:`B_\alpha` are bath operators.; This allows us to write master equation in terms of system operators and bath correlation functions:. .. math::. \frac{d}{dt}\rho_S(t) =; -\hbar^{-2}; \sum_{\alph",MatchSource.DOCS,doc/guide/dynamics/dynamics-bloch-redfield.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst:9885,Modifiability,coupling,coupling,9885,"t interaction term. To simplify the numerical implementation we assume that :math:`A_\alpha` are Hermitian and that cross-correlations between different environment operators vanish, so that the final expression for the Bloch-Redfield tensor that is implemented in QuTiP is. .. math::; :label: br-tensor. R_{abcd} = -\frac{\hbar^{-2}}{2} \sum_{\alpha}; \left\{; \delta_{bd}\sum_nA^\alpha_{an}A^\alpha_{nc}S_{\alpha}(\omega_{cn}); -; A^\alpha_{ac} A^\alpha_{db} S_{\alpha}(\omega_{ca}); \right. \nonumber\\; +; \left.; \delta_{ac}\sum_n A^\alpha_{dn}A^\alpha_{nb} S_{\alpha}(\omega_{dn}); -; A^\alpha_{ac}A^\alpha_{db} S_{\alpha}(\omega_{db}); \right\}. .. _bloch-redfield-qutip:. Bloch-Redfield master equation in QuTiP; =======================================. In QuTiP, the Bloch-Redfield tensor Eq. :eq:`br-tensor` can be calculated using the function :func:`.bloch_redfield_tensor`.; It takes two mandatory arguments: The system Hamiltonian :math:`H`, a nested list of operator; :math:`A_\alpha`, spectral density functions :math:`S_\alpha(\omega)` pairs that characterize the coupling between system and bath.; The spectral density functions are Python callback functions that takes the (angular) frequency as a single argument. To illustrate how to calculate the Bloch-Redfield tensor, let's consider a two-level atom. .. math::; :label: qubit. H = -\frac{1}{2}\Delta\sigma_x - \frac{1}{2}\epsilon_0\sigma_z. .. testcode:: [dynamics-br]. delta = 0.2 * 2*np.pi; eps0 = 1.0 * 2*np.pi; gamma1 = 0.5. H = - delta/2.0 * sigmax() - eps0/2.0 * sigmaz(). def ohmic_spectrum(w):; if w == 0.0: # dephasing inducing noise; return gamma1; else: # relaxation inducing noise; return gamma1 / 2 * (w / (2 * np.pi)) * (w > 0.0). R, ekets = bloch_redfield_tensor(H, a_ops=[[sigmax(), ohmic_spectrum]]). print(R). **Output**:. .. testoutput:: [dynamics-br]. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = False; Qobj data =; [[ 0. +0.j 0. +0.j 0. +0.j; 0.24514517+0.j ]; ",MatchSource.DOCS,doc/guide/dynamics/dynamics-bloch-redfield.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst:15361,Modifiability,coupling,coupling,15361,"you have not done so already, please read the section: :ref:`time`. As we have already discussed, the Bloch-Redfield master equation requires transforming; into the eigenbasis of the system Hamiltonian.; For time-independent systems, this transformation need only be done once.; However, for time-dependent systems, one must move to the instantaneous eigenbasis; at each time-step in the evolution, thus greatly increasing the computational complexity of the dynamics.; In addition, the requirement for computing all the eigenvalues severely limits the scalability of the method.; Fortunately, this eigen decomposition occurs at the Hamiltonian level, as opposed to the; super-operator level, and thus, with efficient programming, one can tackle many systems that are commonly encountered. For time-dependent Hamiltonians, the Hamiltonian itself can be passed into the solver; like any other time dependent Hamiltonian, as thus we will not discuss this topic further.; Instead, here the focus is on time-dependent bath coupling terms.; To this end, suppose that we have a dissipative harmonic oscillator, where the white-noise; dissipation rate decreases exponentially with time :math:`\kappa(t) = \kappa(0)\exp(-t)`.; In the Lindblad or Monte Carlo solvers, this could be implemented as a time-dependent; collapse operator list ``c_ops = [[a, 'sqrt(kappa*exp(-t))']]``.; In the Bloch-Redfield solver, the bath coupling terms must be Hermitian.; As such, in this example, our coupling operator is the position operator ``a+a.dag()``.; The complete example, and comparison to the analytic expression is:. .. plot::; :context: close-figs. N = 10 # number of basis states to consider; a = destroy(N); H = a.dag() * a; psi0 = basis(N, 9) # initial state; kappa = 0.2 # coupling to oscillator; a_ops = [; ([a+a.dag(), f'sqrt({kappa}*exp(-t))'], '(w>=0)'); ]; tlist = np.linspace(0, 10, 100). out = brmesolve(H, psi0, tlist, a_ops, e_ops=[a.dag() * a]); actual_answer = 9.0 * np.exp(-kappa * (1.0 - np.exp(-",MatchSource.DOCS,doc/guide/dynamics/dynamics-bloch-redfield.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst:15753,Modifiability,coupling,coupling,15753,"atly increasing the computational complexity of the dynamics.; In addition, the requirement for computing all the eigenvalues severely limits the scalability of the method.; Fortunately, this eigen decomposition occurs at the Hamiltonian level, as opposed to the; super-operator level, and thus, with efficient programming, one can tackle many systems that are commonly encountered. For time-dependent Hamiltonians, the Hamiltonian itself can be passed into the solver; like any other time dependent Hamiltonian, as thus we will not discuss this topic further.; Instead, here the focus is on time-dependent bath coupling terms.; To this end, suppose that we have a dissipative harmonic oscillator, where the white-noise; dissipation rate decreases exponentially with time :math:`\kappa(t) = \kappa(0)\exp(-t)`.; In the Lindblad or Monte Carlo solvers, this could be implemented as a time-dependent; collapse operator list ``c_ops = [[a, 'sqrt(kappa*exp(-t))']]``.; In the Bloch-Redfield solver, the bath coupling terms must be Hermitian.; As such, in this example, our coupling operator is the position operator ``a+a.dag()``.; The complete example, and comparison to the analytic expression is:. .. plot::; :context: close-figs. N = 10 # number of basis states to consider; a = destroy(N); H = a.dag() * a; psi0 = basis(N, 9) # initial state; kappa = 0.2 # coupling to oscillator; a_ops = [; ([a+a.dag(), f'sqrt({kappa}*exp(-t))'], '(w>=0)'); ]; tlist = np.linspace(0, 10, 100). out = brmesolve(H, psi0, tlist, a_ops, e_ops=[a.dag() * a]); actual_answer = 9.0 * np.exp(-kappa * (1.0 - np.exp(-tlist))). plt.figure(); plt.plot(tlist, out.expect[0]); plt.plot(tlist, actual_answer); plt.show(). In many cases, the bath-coupling operators can take the form :math:`A = f(t)a + f(t)^* a^{+}`.; The operator parts of the `a_ops` can be made of as many time-dependent terms as needed to construct such operator.; For example consider a white-noise bath that is coupled to an operator of the form ``exp(1j*t",MatchSource.DOCS,doc/guide/dynamics/dynamics-bloch-redfield.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst:15818,Modifiability,coupling,coupling,15818,"he requirement for computing all the eigenvalues severely limits the scalability of the method.; Fortunately, this eigen decomposition occurs at the Hamiltonian level, as opposed to the; super-operator level, and thus, with efficient programming, one can tackle many systems that are commonly encountered. For time-dependent Hamiltonians, the Hamiltonian itself can be passed into the solver; like any other time dependent Hamiltonian, as thus we will not discuss this topic further.; Instead, here the focus is on time-dependent bath coupling terms.; To this end, suppose that we have a dissipative harmonic oscillator, where the white-noise; dissipation rate decreases exponentially with time :math:`\kappa(t) = \kappa(0)\exp(-t)`.; In the Lindblad or Monte Carlo solvers, this could be implemented as a time-dependent; collapse operator list ``c_ops = [[a, 'sqrt(kappa*exp(-t))']]``.; In the Bloch-Redfield solver, the bath coupling terms must be Hermitian.; As such, in this example, our coupling operator is the position operator ``a+a.dag()``.; The complete example, and comparison to the analytic expression is:. .. plot::; :context: close-figs. N = 10 # number of basis states to consider; a = destroy(N); H = a.dag() * a; psi0 = basis(N, 9) # initial state; kappa = 0.2 # coupling to oscillator; a_ops = [; ([a+a.dag(), f'sqrt({kappa}*exp(-t))'], '(w>=0)'); ]; tlist = np.linspace(0, 10, 100). out = brmesolve(H, psi0, tlist, a_ops, e_ops=[a.dag() * a]); actual_answer = 9.0 * np.exp(-kappa * (1.0 - np.exp(-tlist))). plt.figure(); plt.plot(tlist, out.expect[0]); plt.plot(tlist, actual_answer); plt.show(). In many cases, the bath-coupling operators can take the form :math:`A = f(t)a + f(t)^* a^{+}`.; The operator parts of the `a_ops` can be made of as many time-dependent terms as needed to construct such operator.; For example consider a white-noise bath that is coupled to an operator of the form ``exp(1j*t)*a + exp(-1j*t)* a.dag()``.; In this example, the ``a_ops`` list would be:. .",MatchSource.DOCS,doc/guide/dynamics/dynamics-bloch-redfield.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst:16107,Modifiability,coupling,coupling,16107,"tered. For time-dependent Hamiltonians, the Hamiltonian itself can be passed into the solver; like any other time dependent Hamiltonian, as thus we will not discuss this topic further.; Instead, here the focus is on time-dependent bath coupling terms.; To this end, suppose that we have a dissipative harmonic oscillator, where the white-noise; dissipation rate decreases exponentially with time :math:`\kappa(t) = \kappa(0)\exp(-t)`.; In the Lindblad or Monte Carlo solvers, this could be implemented as a time-dependent; collapse operator list ``c_ops = [[a, 'sqrt(kappa*exp(-t))']]``.; In the Bloch-Redfield solver, the bath coupling terms must be Hermitian.; As such, in this example, our coupling operator is the position operator ``a+a.dag()``.; The complete example, and comparison to the analytic expression is:. .. plot::; :context: close-figs. N = 10 # number of basis states to consider; a = destroy(N); H = a.dag() * a; psi0 = basis(N, 9) # initial state; kappa = 0.2 # coupling to oscillator; a_ops = [; ([a+a.dag(), f'sqrt({kappa}*exp(-t))'], '(w>=0)'); ]; tlist = np.linspace(0, 10, 100). out = brmesolve(H, psi0, tlist, a_ops, e_ops=[a.dag() * a]); actual_answer = 9.0 * np.exp(-kappa * (1.0 - np.exp(-tlist))). plt.figure(); plt.plot(tlist, out.expect[0]); plt.plot(tlist, actual_answer); plt.show(). In many cases, the bath-coupling operators can take the form :math:`A = f(t)a + f(t)^* a^{+}`.; The operator parts of the `a_ops` can be made of as many time-dependent terms as needed to construct such operator.; For example consider a white-noise bath that is coupled to an operator of the form ``exp(1j*t)*a + exp(-1j*t)* a.dag()``.; In this example, the ``a_ops`` list would be:. .. plot::; :context: close-figs. a_ops = [; ([[a, 'exp(1j*t)'], [a.dag(), 'exp(-1j*t)']], f'{kappa} * (w >= 0)'); ]. where the first tuple element ``[[a, 'exp(1j*t)'], [a.dag(), 'exp(-1j*t)']]`` tells; the solver what is the time-dependent Hermitian coupling operator.; The second tuple ``f'{kappa} *",MatchSource.DOCS,doc/guide/dynamics/dynamics-bloch-redfield.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst:16467,Modifiability,coupling,coupling,16467,"creases exponentially with time :math:`\kappa(t) = \kappa(0)\exp(-t)`.; In the Lindblad or Monte Carlo solvers, this could be implemented as a time-dependent; collapse operator list ``c_ops = [[a, 'sqrt(kappa*exp(-t))']]``.; In the Bloch-Redfield solver, the bath coupling terms must be Hermitian.; As such, in this example, our coupling operator is the position operator ``a+a.dag()``.; The complete example, and comparison to the analytic expression is:. .. plot::; :context: close-figs. N = 10 # number of basis states to consider; a = destroy(N); H = a.dag() * a; psi0 = basis(N, 9) # initial state; kappa = 0.2 # coupling to oscillator; a_ops = [; ([a+a.dag(), f'sqrt({kappa}*exp(-t))'], '(w>=0)'); ]; tlist = np.linspace(0, 10, 100). out = brmesolve(H, psi0, tlist, a_ops, e_ops=[a.dag() * a]); actual_answer = 9.0 * np.exp(-kappa * (1.0 - np.exp(-tlist))). plt.figure(); plt.plot(tlist, out.expect[0]); plt.plot(tlist, actual_answer); plt.show(). In many cases, the bath-coupling operators can take the form :math:`A = f(t)a + f(t)^* a^{+}`.; The operator parts of the `a_ops` can be made of as many time-dependent terms as needed to construct such operator.; For example consider a white-noise bath that is coupled to an operator of the form ``exp(1j*t)*a + exp(-1j*t)* a.dag()``.; In this example, the ``a_ops`` list would be:. .. plot::; :context: close-figs. a_ops = [; ([[a, 'exp(1j*t)'], [a.dag(), 'exp(-1j*t)']], f'{kappa} * (w >= 0)'); ]. where the first tuple element ``[[a, 'exp(1j*t)'], [a.dag(), 'exp(-1j*t)']]`` tells; the solver what is the time-dependent Hermitian coupling operator.; The second tuple ``f'{kappa} * (w >= 0)'``, gives the noise power spectrum.; A full example is:. .. plot::; :context: close-figs. N = 10; w0 = 1.0 * 2 * np.pi; g = 0.05 * w0; kappa = 0.15; times = np.linspace(0, 25, 1000). a = destroy(N); H = w0 * a.dag() * a + g * (a + a.dag()); psi0 = ket2dm((basis(N, 4) + basis(N, 2) + basis(N, 0)).unit()); a_ops = [[; QobjEvo([[a, 'exp(1j*t)'], [a.dag(),",MatchSource.DOCS,doc/guide/dynamics/dynamics-bloch-redfield.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst:17076,Modifiability,coupling,coupling,17076," is:. .. plot::; :context: close-figs. N = 10 # number of basis states to consider; a = destroy(N); H = a.dag() * a; psi0 = basis(N, 9) # initial state; kappa = 0.2 # coupling to oscillator; a_ops = [; ([a+a.dag(), f'sqrt({kappa}*exp(-t))'], '(w>=0)'); ]; tlist = np.linspace(0, 10, 100). out = brmesolve(H, psi0, tlist, a_ops, e_ops=[a.dag() * a]); actual_answer = 9.0 * np.exp(-kappa * (1.0 - np.exp(-tlist))). plt.figure(); plt.plot(tlist, out.expect[0]); plt.plot(tlist, actual_answer); plt.show(). In many cases, the bath-coupling operators can take the form :math:`A = f(t)a + f(t)^* a^{+}`.; The operator parts of the `a_ops` can be made of as many time-dependent terms as needed to construct such operator.; For example consider a white-noise bath that is coupled to an operator of the form ``exp(1j*t)*a + exp(-1j*t)* a.dag()``.; In this example, the ``a_ops`` list would be:. .. plot::; :context: close-figs. a_ops = [; ([[a, 'exp(1j*t)'], [a.dag(), 'exp(-1j*t)']], f'{kappa} * (w >= 0)'); ]. where the first tuple element ``[[a, 'exp(1j*t)'], [a.dag(), 'exp(-1j*t)']]`` tells; the solver what is the time-dependent Hermitian coupling operator.; The second tuple ``f'{kappa} * (w >= 0)'``, gives the noise power spectrum.; A full example is:. .. plot::; :context: close-figs. N = 10; w0 = 1.0 * 2 * np.pi; g = 0.05 * w0; kappa = 0.15; times = np.linspace(0, 25, 1000). a = destroy(N); H = w0 * a.dag() * a + g * (a + a.dag()); psi0 = ket2dm((basis(N, 4) + basis(N, 2) + basis(N, 0)).unit()); a_ops = [[; QobjEvo([[a, 'exp(1j*t)'], [a.dag(), 'exp(-1j*t)']]), (f'{kappa} * (w >= 0)'); ]]; e_ops = [a.dag() * a, a + a.dag()]. res_brme = brmesolve(H, psi0, times, a_ops, e_ops). plt.figure(); plt.plot(times, res_brme.expect[0], label=r'$a^{+}a$'); plt.plot(times, res_brme.expect[1], label=r'$a+a^{+}$'); plt.legend(); plt.show(). Further examples on time-dependent Bloch-Redfield simulations can be found in the online tutorials. .. plot::; :context: reset; :include-source: false; :nofigs:; ",MatchSource.DOCS,doc/guide/dynamics/dynamics-bloch-redfield.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst:14895,Performance,scalab,scalability,14895,"ll be neglected.; Its default value is 0.1 which corresponds to the secular approximation.; For example the command; ::. output = brmesolve(H, psi0, tlist, a_ops=[[sigmax(), ohmic_spectrum]],; e_ops=e_ops, sec_cutoff=-1). will simulate the same example as above without the secular approximation.; Note that using the non-secular version may lead to negativity issues. .. _td-bloch-redfield:. Time-dependent Bloch-Redfield Dynamics; =======================================. If you have not done so already, please read the section: :ref:`time`. As we have already discussed, the Bloch-Redfield master equation requires transforming; into the eigenbasis of the system Hamiltonian.; For time-independent systems, this transformation need only be done once.; However, for time-dependent systems, one must move to the instantaneous eigenbasis; at each time-step in the evolution, thus greatly increasing the computational complexity of the dynamics.; In addition, the requirement for computing all the eigenvalues severely limits the scalability of the method.; Fortunately, this eigen decomposition occurs at the Hamiltonian level, as opposed to the; super-operator level, and thus, with efficient programming, one can tackle many systems that are commonly encountered. For time-dependent Hamiltonians, the Hamiltonian itself can be passed into the solver; like any other time dependent Hamiltonian, as thus we will not discuss this topic further.; Instead, here the focus is on time-dependent bath coupling terms.; To this end, suppose that we have a dissipative harmonic oscillator, where the white-noise; dissipation rate decreases exponentially with time :math:`\kappa(t) = \kappa(0)\exp(-t)`.; In the Lindblad or Monte Carlo solvers, this could be implemented as a time-dependent; collapse operator list ``c_ops = [[a, 'sqrt(kappa*exp(-t))']]``.; In the Bloch-Redfield solver, the bath coupling terms must be Hermitian.; As such, in this example, our coupling operator is the position operator ``a+a",MatchSource.DOCS,doc/guide/dynamics/dynamics-bloch-redfield.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst:10222,Testability,test,testcode,10222,"-; A^\alpha_{ac} A^\alpha_{db} S_{\alpha}(\omega_{ca}); \right. \nonumber\\; +; \left.; \delta_{ac}\sum_n A^\alpha_{dn}A^\alpha_{nb} S_{\alpha}(\omega_{dn}); -; A^\alpha_{ac}A^\alpha_{db} S_{\alpha}(\omega_{db}); \right\}. .. _bloch-redfield-qutip:. Bloch-Redfield master equation in QuTiP; =======================================. In QuTiP, the Bloch-Redfield tensor Eq. :eq:`br-tensor` can be calculated using the function :func:`.bloch_redfield_tensor`.; It takes two mandatory arguments: The system Hamiltonian :math:`H`, a nested list of operator; :math:`A_\alpha`, spectral density functions :math:`S_\alpha(\omega)` pairs that characterize the coupling between system and bath.; The spectral density functions are Python callback functions that takes the (angular) frequency as a single argument. To illustrate how to calculate the Bloch-Redfield tensor, let's consider a two-level atom. .. math::; :label: qubit. H = -\frac{1}{2}\Delta\sigma_x - \frac{1}{2}\epsilon_0\sigma_z. .. testcode:: [dynamics-br]. delta = 0.2 * 2*np.pi; eps0 = 1.0 * 2*np.pi; gamma1 = 0.5. H = - delta/2.0 * sigmax() - eps0/2.0 * sigmaz(). def ohmic_spectrum(w):; if w == 0.0: # dephasing inducing noise; return gamma1; else: # relaxation inducing noise; return gamma1 / 2 * (w / (2 * np.pi)) * (w > 0.0). R, ekets = bloch_redfield_tensor(H, a_ops=[[sigmax(), ohmic_spectrum]]). print(R). **Output**:. .. testoutput:: [dynamics-br]. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = False; Qobj data =; [[ 0. +0.j 0. +0.j 0. +0.j; 0.24514517+0.j ]; [ 0. +0.j -0.16103412-6.4076169j 0. +0.j; 0. +0.j ]; [ 0. +0.j 0. +0.j -0.16103412+6.4076169j; 0. +0.j ]; [ 0. +0.j 0. +0.j 0. +0.j; -0.24514517+0.j ]]. Note that it is also possible to add Lindblad dissipation superoperators in the; Bloch-Refield tensor by passing the operators via the ``c_ops`` keyword argument; like you would in the :func:`.mesolve` or :func:`.mcsolve` functions.; For convenience, the function :func:`.bloch",MatchSource.DOCS,doc/guide/dynamics/dynamics-bloch-redfield.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst:10622,Testability,test,testoutput,10622,"ated using the function :func:`.bloch_redfield_tensor`.; It takes two mandatory arguments: The system Hamiltonian :math:`H`, a nested list of operator; :math:`A_\alpha`, spectral density functions :math:`S_\alpha(\omega)` pairs that characterize the coupling between system and bath.; The spectral density functions are Python callback functions that takes the (angular) frequency as a single argument. To illustrate how to calculate the Bloch-Redfield tensor, let's consider a two-level atom. .. math::; :label: qubit. H = -\frac{1}{2}\Delta\sigma_x - \frac{1}{2}\epsilon_0\sigma_z. .. testcode:: [dynamics-br]. delta = 0.2 * 2*np.pi; eps0 = 1.0 * 2*np.pi; gamma1 = 0.5. H = - delta/2.0 * sigmax() - eps0/2.0 * sigmaz(). def ohmic_spectrum(w):; if w == 0.0: # dephasing inducing noise; return gamma1; else: # relaxation inducing noise; return gamma1 / 2 * (w / (2 * np.pi)) * (w > 0.0). R, ekets = bloch_redfield_tensor(H, a_ops=[[sigmax(), ohmic_spectrum]]). print(R). **Output**:. .. testoutput:: [dynamics-br]. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = False; Qobj data =; [[ 0. +0.j 0. +0.j 0. +0.j; 0.24514517+0.j ]; [ 0. +0.j -0.16103412-6.4076169j 0. +0.j; 0. +0.j ]; [ 0. +0.j 0. +0.j -0.16103412+6.4076169j; 0. +0.j ]; [ 0. +0.j 0. +0.j 0. +0.j; -0.24514517+0.j ]]. Note that it is also possible to add Lindblad dissipation superoperators in the; Bloch-Refield tensor by passing the operators via the ``c_ops`` keyword argument; like you would in the :func:`.mesolve` or :func:`.mcsolve` functions.; For convenience, the function :func:`.bloch_redfield_tensor` also returns the basis; transformation operator, the eigen vector matrix, since they are calculated in the; process of calculating the Bloch-Redfield tensor `R`, and the `ekets` are usually; needed again later when transforming operators between the laboratory basis and the eigen basis.; The tensor can be obtained in the laboratory basis by setting ``fock_basis=True``,; in that ca",MatchSource.DOCS,doc/guide/dynamics/dynamics-bloch-redfield.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst:836,Usability,clear,clear,836,".. _bloch_redfield:. ******************************; Bloch-Redfield master equation; ******************************. .. plot::; :context: reset; :include-source: False. import pylab as plt; from scipy import *; from qutip import *; import numpy as np. .. _bloch-redfield-intro:. Introduction; ============. The Lindblad master equation introduced earlier is constructed so that it describes a physical evolution of the density matrix (i.e., trace and positivity preserving), but it does not provide a connection to any underlying microscopic physical model.; The Lindblad operators (collapse operators) describe phenomenological processes, such as for example dephasing and spin flips, and the rates of these processes are arbitrary parameters in the model.; In many situations the collapse operators and their corresponding rates have clear physical interpretation, such as dephasing and relaxation rates, and in those cases the Lindblad master equation is usually the method of choice. However, in some cases, for example systems with varying energy biases and eigenstates and that couple to an environment in some well-defined manner (through a physically motivated system-environment interaction operator), it is often desirable to derive the master equation from more fundamental physical principles, and relate it to for example the noise-power spectrum of the environment. The Bloch-Redfield formalism is one such approach to derive a master equation from a microscopic system.; It starts from a combined system-environment perspective, and derives a perturbative master equation for the system alone, under the assumption of weak system-environment coupling.; One advantage of this approach is that the dissipation processes and rates are obtained directly from the properties of the environment.; On the downside, it does not intrinsically guarantee that the resulting master equation unconditionally preserves the physical properties of the density matrix (because it is a perturbative metho",MatchSource.DOCS,doc/guide/dynamics/dynamics-bloch-redfield.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst:8827,Usability,simpl,simplify,8827,"\sum_{c,d}^{\rm sec}R_{abcd}\rho_{cd}(t),. where. .. math::; :label: br-nonmarkovian-form-five. R_{abcd} = -\frac{\hbar^{-2}}{2} \sum_{\alpha,\beta}; \left\{; \delta_{bd}\sum_nA^\alpha_{an}A^\beta_{nc}S_{\alpha\beta}(\omega_{cn}); -; A^\alpha_{ac} A^\beta_{db} S_{\alpha\beta}(\omega_{ca}); \right. \nonumber\\; +; \left.; \delta_{ac}\sum_n A^\alpha_{dn}A^\beta_{nb} S_{\alpha\beta}(\omega_{dn}); -; A^\alpha_{ac}A^\beta_{db} S_{\alpha\beta}(\omega_{db}); \right\},. is the Bloch-Redfield tensor. The Bloch-Redfield master equation in the form Eq. :eq:`br-final` is suitable for numerical implementation. The input parameters are the system Hamiltonian :math:`H`, the system operators through which the environment couples to the system :math:`A_\alpha`, and the noise-power spectrum :math:`S_{\alpha\beta}(\omega)` associated with each system-environment interaction term. To simplify the numerical implementation we assume that :math:`A_\alpha` are Hermitian and that cross-correlations between different environment operators vanish, so that the final expression for the Bloch-Redfield tensor that is implemented in QuTiP is. .. math::; :label: br-tensor. R_{abcd} = -\frac{\hbar^{-2}}{2} \sum_{\alpha}; \left\{; \delta_{bd}\sum_nA^\alpha_{an}A^\alpha_{nc}S_{\alpha}(\omega_{cn}); -; A^\alpha_{ac} A^\alpha_{db} S_{\alpha}(\omega_{ca}); \right. \nonumber\\; +; \left.; \delta_{ac}\sum_n A^\alpha_{dn}A^\alpha_{nb} S_{\alpha}(\omega_{dn}); -; A^\alpha_{ac}A^\alpha_{db} S_{\alpha}(\omega_{db}); \right\}. .. _bloch-redfield-qutip:. Bloch-Redfield master equation in QuTiP; =======================================. In QuTiP, the Bloch-Redfield tensor Eq. :eq:`br-tensor` can be calculated using the function :func:`.bloch_redfield_tensor`.; It takes two mandatory arguments: The system Hamiltonian :math:`H`, a nested list of operator; :math:`A_\alpha`, spectral density functions :math:`S_\alpha(\omega)` pairs that characterize the coupling between system and bath.; The spectral density functions ",MatchSource.DOCS,doc/guide/dynamics/dynamics-bloch-redfield.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-class.rst:2650,Deployability,update,updated,2650," = [a.dag() * a, sm.dag() * sm]; H = QobjEvo(; [a.dag()*a + sm.dag()*sm, [(sm*a.dag() + sm.dag()*a), lambda t, A: A]],; args={""A"": 0.5*np.pi}; ). solver = MESolver(H, c_ops=[np.sqrt(0.1) * a], options={""atol"": 1e-8}); solver.options[""normalize_output""] = True; psi0 = tensor(fock(2, 0), fock(10, 5)); data1 = solver.run(psi0, times, e_ops=e_ops); psi1 = tensor(fock(2, 0), coherent(10, 2 - 1j)); data2 = solver.run(psi1, times, e_ops=e_ops). plt.figure(); plt.plot(times, data1.expect[0], ""b"", times, data1.expect[1], ""r"", lw=2); plt.plot(times, data2.expect[0], 'b--', times, data2.expect[1], 'r--', lw=2); plt.title('Master Equation time evolution'); plt.xlabel('Time', fontsize=14); plt.ylabel('Expectation values', fontsize=14); plt.legend((""cavity photon number"", ""atom excitation probability"")); plt.show(). Note that as shown, options can be set at initialization or with the; ``options`` property. The simulation parameters, the ``args`` of the :class:`.QobjEvo` passed as system; operators, can be updated at the start of a run:. .. plot::; :context: close-figs. data1 = solver.run(psi0, times, e_ops=e_ops); data2 = solver.run(psi0, times, e_ops=e_ops, args={""A"": 0.25*np.pi}); data3 = solver.run(psi0, times, e_ops=e_ops, args={""A"": 0.125*np.pi}). plt.figure(); plt.plot(times, data1.expect[0], label=""A=pi/2""); plt.plot(times, data2.expect[0], label=""A=pi/4""); plt.plot(times, data3.expect[0], label=""A=pi/8""); plt.title('Master Equation time evolution'); plt.xlabel('Time', fontsize=14); plt.ylabel('Expectation values', fontsize=14); plt.legend(); plt.show(). Stepping through the run; ------------------------. The solver class also allows to run through a simulation one step at a time, updating; args at each step:. .. plot::; :context: close-figs. data = [5.]; solver.start(state0=psi0, t0=times[0]); for t in times[1:]:; psi_t = solver.step(t, args={""A"": np.pi*np.exp(-(t-3)**2)}); data.append(expect(e_ops[0], psi_t)). plt.figure(); plt.plot(times, data); plt.title('Master Equati",MatchSource.DOCS,doc/guide/dynamics/dynamics-class.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-class.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-class.rst:4311,Deployability,integrat,integration,4311,"through a simulation one step at a time, updating; args at each step:. .. plot::; :context: close-figs. data = [5.]; solver.start(state0=psi0, t0=times[0]); for t in times[1:]:; psi_t = solver.step(t, args={""A"": np.pi*np.exp(-(t-3)**2)}); data.append(expect(e_ops[0], psi_t)). plt.figure(); plt.plot(times, data); plt.title('Master Equation time evolution'); plt.xlabel('Time', fontsize=14); plt.ylabel('Expectation values', fontsize=14); plt.legend((""cavity photon number"")); plt.show(). .. note::. This is an example only, updating a constant ``args`` parameter between step; should not replace using a function as QobjEvo's coefficient. .. note::. It is possible to create multiple solvers and to advance them using ``step`` in; parallel. However, many ODE solver, including the default ``adams`` method, only; allow one instance at a time per process. QuTiP supports using multiple solver instances; of these ODE solvers but with a performance cost. In these situations, using; ``dop853`` or ``vern9`` integration method is recommended instead. Feedback: Accessing the solver state from evolution operators; =============================================================. The state of the system during the evolution is accessible via properties of the solver classes. Each solver has a ``StateFeedback`` and ``ExpectFeedback`` class method that can; be passed as arguments to time dependent systems. For example, ``ExpectFeedback``; can be used to create a system which uncouples when there are 5 or fewer photons in the; cavity. .. plot::; :context: close-figs. def f(t, e1):; ex = (e1.real - 5); return (ex > 0) * ex * 10. times = np.linspace(0.0, 1.0, 301); a = tensor(qeye(2), destroy(10)); sm = tensor(destroy(2), qeye(10)); e_ops = [a.dag() * a, sm.dag() * sm]; psi0 = tensor(fock(2, 0), fock(10, 8)); e_ops = [a.dag() * a, sm.dag() * sm]. H = [a*a.dag(), [sm*a.dag() + sm.dag()*a, f]]; data = mesolve(H, psi0, times, c_ops=[a], e_ops=e_ops,; args={""e1"": MESolver.ExpectFeedback(a.dag() * a)",MatchSource.DOCS,doc/guide/dynamics/dynamics-class.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-class.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-class.rst:233,Integrability,interface,interface,233,".. _solver_class:. *******************************************; Solver Class Interface; *******************************************. In QuTiP version 5 and later, solvers such as :func:`.mesolve`, :func:`.mcsolve` also have; a class interface. The class interface allows reusing the Hamiltonian and fine tuning; many details of how the solver is run. Examples of some of the solver class features are given below. Reusing Hamiltonian Data; ------------------------. There are many cases where one would like to study multiple evolutions of; the same quantum system, whether by changing the initial state or other parameters.; In order to evolve a given system as fast as possible, the solvers in QuTiP; take the given input operators (Hamiltonian, collapse operators, etc) and prepare; them for use with the selected ODE solver. These operations are usually reasonably fast, but for some solvers, such as; :func:`.brmesolve` or :func:`.fmmesolve`, the overhead can be significant.; Even for simpler solvers, the time spent organizing data can become appreciable; when repeatedly solving a system. The class interface allows us to setup the system once and reuse it with various; parameters. Most ``...solve`` function have a paired ``...Solver`` class, with a; ``..Solver.run`` method to run the evolution. At class; instance creation, the physics (``H``, ``c_ops``, ``a_ops``, etc.) and options; are passed. The initial state, times and expectation operators are only passed; when calling ``run``:. .. plot::; :context: close-figs. times = np.linspace(0.0, 6.0, 601); a = tensor(qeye(2), destroy(10)); sm = tensor(destroy(2), qeye(10)); e_ops = [a.dag() * a, sm.dag() * sm]; H = QobjEvo(; [a.dag()*a + sm.dag()*sm, [(sm*a.dag() + sm.dag()*a), lambda t, A: A]],; args={""A"": 0.5*np.pi}; ). solver = MESolver(H, c_ops=[np.sqrt(0.1) * a], options={""atol"": 1e-8}); solver.options[""normalize_output""] = True; psi0 = tensor(fock(2, 0), fock(10, 5)); data1 = solver.run(psi0, times, e_ops=e_ops); psi1 = tens",MatchSource.DOCS,doc/guide/dynamics/dynamics-class.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-class.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-class.rst:254,Integrability,interface,interface,254,".. _solver_class:. *******************************************; Solver Class Interface; *******************************************. In QuTiP version 5 and later, solvers such as :func:`.mesolve`, :func:`.mcsolve` also have; a class interface. The class interface allows reusing the Hamiltonian and fine tuning; many details of how the solver is run. Examples of some of the solver class features are given below. Reusing Hamiltonian Data; ------------------------. There are many cases where one would like to study multiple evolutions of; the same quantum system, whether by changing the initial state or other parameters.; In order to evolve a given system as fast as possible, the solvers in QuTiP; take the given input operators (Hamiltonian, collapse operators, etc) and prepare; them for use with the selected ODE solver. These operations are usually reasonably fast, but for some solvers, such as; :func:`.brmesolve` or :func:`.fmmesolve`, the overhead can be significant.; Even for simpler solvers, the time spent organizing data can become appreciable; when repeatedly solving a system. The class interface allows us to setup the system once and reuse it with various; parameters. Most ``...solve`` function have a paired ``...Solver`` class, with a; ``..Solver.run`` method to run the evolution. At class; instance creation, the physics (``H``, ``c_ops``, ``a_ops``, etc.) and options; are passed. The initial state, times and expectation operators are only passed; when calling ``run``:. .. plot::; :context: close-figs. times = np.linspace(0.0, 6.0, 601); a = tensor(qeye(2), destroy(10)); sm = tensor(destroy(2), qeye(10)); e_ops = [a.dag() * a, sm.dag() * sm]; H = QobjEvo(; [a.dag()*a + sm.dag()*sm, [(sm*a.dag() + sm.dag()*a), lambda t, A: A]],; args={""A"": 0.5*np.pi}; ). solver = MESolver(H, c_ops=[np.sqrt(0.1) * a], options={""atol"": 1e-8}); solver.options[""normalize_output""] = True; psi0 = tensor(fock(2, 0), fock(10, 5)); data1 = solver.run(psi0, times, e_ops=e_ops); psi1 = tens",MatchSource.DOCS,doc/guide/dynamics/dynamics-class.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-class.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-class.rst:1107,Integrability,interface,interface,1107,"ersion 5 and later, solvers such as :func:`.mesolve`, :func:`.mcsolve` also have; a class interface. The class interface allows reusing the Hamiltonian and fine tuning; many details of how the solver is run. Examples of some of the solver class features are given below. Reusing Hamiltonian Data; ------------------------. There are many cases where one would like to study multiple evolutions of; the same quantum system, whether by changing the initial state or other parameters.; In order to evolve a given system as fast as possible, the solvers in QuTiP; take the given input operators (Hamiltonian, collapse operators, etc) and prepare; them for use with the selected ODE solver. These operations are usually reasonably fast, but for some solvers, such as; :func:`.brmesolve` or :func:`.fmmesolve`, the overhead can be significant.; Even for simpler solvers, the time spent organizing data can become appreciable; when repeatedly solving a system. The class interface allows us to setup the system once and reuse it with various; parameters. Most ``...solve`` function have a paired ``...Solver`` class, with a; ``..Solver.run`` method to run the evolution. At class; instance creation, the physics (``H``, ``c_ops``, ``a_ops``, etc.) and options; are passed. The initial state, times and expectation operators are only passed; when calling ``run``:. .. plot::; :context: close-figs. times = np.linspace(0.0, 6.0, 601); a = tensor(qeye(2), destroy(10)); sm = tensor(destroy(2), qeye(10)); e_ops = [a.dag() * a, sm.dag() * sm]; H = QobjEvo(; [a.dag()*a + sm.dag()*sm, [(sm*a.dag() + sm.dag()*a), lambda t, A: A]],; args={""A"": 0.5*np.pi}; ). solver = MESolver(H, c_ops=[np.sqrt(0.1) * a], options={""atol"": 1e-8}); solver.options[""normalize_output""] = True; psi0 = tensor(fock(2, 0), fock(10, 5)); data1 = solver.run(psi0, times, e_ops=e_ops); psi1 = tensor(fock(2, 0), coherent(10, 2 - 1j)); data2 = solver.run(psi1, times, e_ops=e_ops). plt.figure(); plt.plot(times, data1.expect[0], ""b"", times,",MatchSource.DOCS,doc/guide/dynamics/dynamics-class.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-class.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-class.rst:4311,Integrability,integrat,integration,4311,"through a simulation one step at a time, updating; args at each step:. .. plot::; :context: close-figs. data = [5.]; solver.start(state0=psi0, t0=times[0]); for t in times[1:]:; psi_t = solver.step(t, args={""A"": np.pi*np.exp(-(t-3)**2)}); data.append(expect(e_ops[0], psi_t)). plt.figure(); plt.plot(times, data); plt.title('Master Equation time evolution'); plt.xlabel('Time', fontsize=14); plt.ylabel('Expectation values', fontsize=14); plt.legend((""cavity photon number"")); plt.show(). .. note::. This is an example only, updating a constant ``args`` parameter between step; should not replace using a function as QobjEvo's coefficient. .. note::. It is possible to create multiple solvers and to advance them using ``step`` in; parallel. However, many ODE solver, including the default ``adams`` method, only; allow one instance at a time per process. QuTiP supports using multiple solver instances; of these ODE solvers but with a performance cost. In these situations, using; ``dop853`` or ``vern9`` integration method is recommended instead. Feedback: Accessing the solver state from evolution operators; =============================================================. The state of the system during the evolution is accessible via properties of the solver classes. Each solver has a ``StateFeedback`` and ``ExpectFeedback`` class method that can; be passed as arguments to time dependent systems. For example, ``ExpectFeedback``; can be used to create a system which uncouples when there are 5 or fewer photons in the; cavity. .. plot::; :context: close-figs. def f(t, e1):; ex = (e1.real - 5); return (ex > 0) * ex * 10. times = np.linspace(0.0, 1.0, 301); a = tensor(qeye(2), destroy(10)); sm = tensor(destroy(2), qeye(10)); e_ops = [a.dag() * a, sm.dag() * sm]; psi0 = tensor(fock(2, 0), fock(10, 8)); e_ops = [a.dag() * a, sm.dag() * sm]. H = [a*a.dag(), [sm*a.dag() + sm.dag()*a, f]]; data = mesolve(H, psi0, times, c_ops=[a], e_ops=e_ops,; args={""e1"": MESolver.ExpectFeedback(a.dag() * a)",MatchSource.DOCS,doc/guide/dynamics/dynamics-class.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-class.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-class.rst:4690,Integrability,depend,dependent,4690,"e(); plt.plot(times, data); plt.title('Master Equation time evolution'); plt.xlabel('Time', fontsize=14); plt.ylabel('Expectation values', fontsize=14); plt.legend((""cavity photon number"")); plt.show(). .. note::. This is an example only, updating a constant ``args`` parameter between step; should not replace using a function as QobjEvo's coefficient. .. note::. It is possible to create multiple solvers and to advance them using ``step`` in; parallel. However, many ODE solver, including the default ``adams`` method, only; allow one instance at a time per process. QuTiP supports using multiple solver instances; of these ODE solvers but with a performance cost. In these situations, using; ``dop853`` or ``vern9`` integration method is recommended instead. Feedback: Accessing the solver state from evolution operators; =============================================================. The state of the system during the evolution is accessible via properties of the solver classes. Each solver has a ``StateFeedback`` and ``ExpectFeedback`` class method that can; be passed as arguments to time dependent systems. For example, ``ExpectFeedback``; can be used to create a system which uncouples when there are 5 or fewer photons in the; cavity. .. plot::; :context: close-figs. def f(t, e1):; ex = (e1.real - 5); return (ex > 0) * ex * 10. times = np.linspace(0.0, 1.0, 301); a = tensor(qeye(2), destroy(10)); sm = tensor(destroy(2), qeye(10)); e_ops = [a.dag() * a, sm.dag() * sm]; psi0 = tensor(fock(2, 0), fock(10, 8)); e_ops = [a.dag() * a, sm.dag() * sm]. H = [a*a.dag(), [sm*a.dag() + sm.dag()*a, f]]; data = mesolve(H, psi0, times, c_ops=[a], e_ops=e_ops,; args={""e1"": MESolver.ExpectFeedback(a.dag() * a)}; ).expect. plt.figure(); plt.plot(times, data[0]); plt.plot(times, data[1]); plt.title('Master Equation time evolution'); plt.xlabel('Time', fontsize=14); plt.ylabel('Expectation values', fontsize=14); plt.legend((""cavity photon number"", ""atom excitation probability"")); plt.show(); ",MatchSource.DOCS,doc/guide/dynamics/dynamics-class.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-class.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-class.rst:638,Modifiability,evolve,evolve,638,".. _solver_class:. *******************************************; Solver Class Interface; *******************************************. In QuTiP version 5 and later, solvers such as :func:`.mesolve`, :func:`.mcsolve` also have; a class interface. The class interface allows reusing the Hamiltonian and fine tuning; many details of how the solver is run. Examples of some of the solver class features are given below. Reusing Hamiltonian Data; ------------------------. There are many cases where one would like to study multiple evolutions of; the same quantum system, whether by changing the initial state or other parameters.; In order to evolve a given system as fast as possible, the solvers in QuTiP; take the given input operators (Hamiltonian, collapse operators, etc) and prepare; them for use with the selected ODE solver. These operations are usually reasonably fast, but for some solvers, such as; :func:`.brmesolve` or :func:`.fmmesolve`, the overhead can be significant.; Even for simpler solvers, the time spent organizing data can become appreciable; when repeatedly solving a system. The class interface allows us to setup the system once and reuse it with various; parameters. Most ``...solve`` function have a paired ``...Solver`` class, with a; ``..Solver.run`` method to run the evolution. At class; instance creation, the physics (``H``, ``c_ops``, ``a_ops``, etc.) and options; are passed. The initial state, times and expectation operators are only passed; when calling ``run``:. .. plot::; :context: close-figs. times = np.linspace(0.0, 6.0, 601); a = tensor(qeye(2), destroy(10)); sm = tensor(destroy(2), qeye(10)); e_ops = [a.dag() * a, sm.dag() * sm]; H = QobjEvo(; [a.dag()*a + sm.dag()*sm, [(sm*a.dag() + sm.dag()*a), lambda t, A: A]],; args={""A"": 0.5*np.pi}; ). solver = MESolver(H, c_ops=[np.sqrt(0.1) * a], options={""atol"": 1e-8}); solver.options[""normalize_output""] = True; psi0 = tensor(fock(2, 0), fock(10, 5)); data1 = solver.run(psi0, times, e_ops=e_ops); psi1 = tens",MatchSource.DOCS,doc/guide/dynamics/dynamics-class.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-class.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-class.rst:4241,Performance,perform,performance,4241,"show(). Stepping through the run; ------------------------. The solver class also allows to run through a simulation one step at a time, updating; args at each step:. .. plot::; :context: close-figs. data = [5.]; solver.start(state0=psi0, t0=times[0]); for t in times[1:]:; psi_t = solver.step(t, args={""A"": np.pi*np.exp(-(t-3)**2)}); data.append(expect(e_ops[0], psi_t)). plt.figure(); plt.plot(times, data); plt.title('Master Equation time evolution'); plt.xlabel('Time', fontsize=14); plt.ylabel('Expectation values', fontsize=14); plt.legend((""cavity photon number"")); plt.show(). .. note::. This is an example only, updating a constant ``args`` parameter between step; should not replace using a function as QobjEvo's coefficient. .. note::. It is possible to create multiple solvers and to advance them using ``step`` in; parallel. However, many ODE solver, including the default ``adams`` method, only; allow one instance at a time per process. QuTiP supports using multiple solver instances; of these ODE solvers but with a performance cost. In these situations, using; ``dop853`` or ``vern9`` integration method is recommended instead. Feedback: Accessing the solver state from evolution operators; =============================================================. The state of the system during the evolution is accessible via properties of the solver classes. Each solver has a ``StateFeedback`` and ``ExpectFeedback`` class method that can; be passed as arguments to time dependent systems. For example, ``ExpectFeedback``; can be used to create a system which uncouples when there are 5 or fewer photons in the; cavity. .. plot::; :context: close-figs. def f(t, e1):; ex = (e1.real - 5); return (ex > 0) * ex * 10. times = np.linspace(0.0, 1.0, 301); a = tensor(qeye(2), destroy(10)); sm = tensor(destroy(2), qeye(10)); e_ops = [a.dag() * a, sm.dag() * sm]; psi0 = tensor(fock(2, 0), fock(10, 8)); e_ops = [a.dag() * a, sm.dag() * sm]. H = [a*a.dag(), [sm*a.dag() + sm.dag()*a, f]]; data = ",MatchSource.DOCS,doc/guide/dynamics/dynamics-class.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-class.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-class.rst:4528,Security,access,accessible,4528,"xp(-(t-3)**2)}); data.append(expect(e_ops[0], psi_t)). plt.figure(); plt.plot(times, data); plt.title('Master Equation time evolution'); plt.xlabel('Time', fontsize=14); plt.ylabel('Expectation values', fontsize=14); plt.legend((""cavity photon number"")); plt.show(). .. note::. This is an example only, updating a constant ``args`` parameter between step; should not replace using a function as QobjEvo's coefficient. .. note::. It is possible to create multiple solvers and to advance them using ``step`` in; parallel. However, many ODE solver, including the default ``adams`` method, only; allow one instance at a time per process. QuTiP supports using multiple solver instances; of these ODE solvers but with a performance cost. In these situations, using; ``dop853`` or ``vern9`` integration method is recommended instead. Feedback: Accessing the solver state from evolution operators; =============================================================. The state of the system during the evolution is accessible via properties of the solver classes. Each solver has a ``StateFeedback`` and ``ExpectFeedback`` class method that can; be passed as arguments to time dependent systems. For example, ``ExpectFeedback``; can be used to create a system which uncouples when there are 5 or fewer photons in the; cavity. .. plot::; :context: close-figs. def f(t, e1):; ex = (e1.real - 5); return (ex > 0) * ex * 10. times = np.linspace(0.0, 1.0, 301); a = tensor(qeye(2), destroy(10)); sm = tensor(destroy(2), qeye(10)); e_ops = [a.dag() * a, sm.dag() * sm]; psi0 = tensor(fock(2, 0), fock(10, 8)); e_ops = [a.dag() * a, sm.dag() * sm]. H = [a*a.dag(), [sm*a.dag() + sm.dag()*a, f]]; data = mesolve(H, psi0, times, c_ops=[a], e_ops=e_ops,; args={""e1"": MESolver.ExpectFeedback(a.dag() * a)}; ).expect. plt.figure(); plt.plot(times, data[0]); plt.plot(times, data[1]); plt.title('Master Equation time evolution'); plt.xlabel('Time', fontsize=14); plt.ylabel('Expectation values', fontsize=14); plt.legend((""cavit",MatchSource.DOCS,doc/guide/dynamics/dynamics-class.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-class.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-class.rst:991,Usability,simpl,simpler,991,"************************; Solver Class Interface; *******************************************. In QuTiP version 5 and later, solvers such as :func:`.mesolve`, :func:`.mcsolve` also have; a class interface. The class interface allows reusing the Hamiltonian and fine tuning; many details of how the solver is run. Examples of some of the solver class features are given below. Reusing Hamiltonian Data; ------------------------. There are many cases where one would like to study multiple evolutions of; the same quantum system, whether by changing the initial state or other parameters.; In order to evolve a given system as fast as possible, the solvers in QuTiP; take the given input operators (Hamiltonian, collapse operators, etc) and prepare; them for use with the selected ODE solver. These operations are usually reasonably fast, but for some solvers, such as; :func:`.brmesolve` or :func:`.fmmesolve`, the overhead can be significant.; Even for simpler solvers, the time spent organizing data can become appreciable; when repeatedly solving a system. The class interface allows us to setup the system once and reuse it with various; parameters. Most ``...solve`` function have a paired ``...Solver`` class, with a; ``..Solver.run`` method to run the evolution. At class; instance creation, the physics (``H``, ``c_ops``, ``a_ops``, etc.) and options; are passed. The initial state, times and expectation operators are only passed; when calling ``run``:. .. plot::; :context: close-figs. times = np.linspace(0.0, 6.0, 601); a = tensor(qeye(2), destroy(10)); sm = tensor(destroy(2), qeye(10)); e_ops = [a.dag() * a, sm.dag() * sm]; H = QobjEvo(; [a.dag()*a + sm.dag()*sm, [(sm*a.dag() + sm.dag()*a), lambda t, A: A]],; args={""A"": 0.5*np.pi}; ). solver = MESolver(H, c_ops=[np.sqrt(0.1) * a], options={""atol"": 1e-8}); solver.options[""normalize_output""] = True; psi0 = tensor(fock(2, 0), fock(10, 5)); data1 = solver.run(psi0, times, e_ops=e_ops); psi1 = tensor(fock(2, 0), coherent(10, 2 - 1j));",MatchSource.DOCS,doc/guide/dynamics/dynamics-class.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-class.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-data.rst:5625,Availability,avail,available,5625,"es Solver Results; ====================================. Solver which compute multiple trajectories such as the Monte Carlo Equations; Solvers or the Stochastics Solvers result will differ depending on whether the; trajectories are flags to be saved.; For example:. .. doctest::; :options: +SKIP. >>> mcsolve(H, psi, np.linspace(0, 1, 11), c_ops, e_ops=[num(N)], ntraj=25, options={""keep_runs_results"": False}); >>> np.shape(result.expect); (1, 11). >>> mcsolve(H, psi, np.linspace(0, 1, 11), c_ops, e_ops=[num(N)], ntraj=25, options={""keep_runs_results"": True}); >>> np.shape(result.expect); (1, 25, 11). When the runs are not saved, the expectation values and states are averaged; over all trajectories, while a list over the runs are given when they are stored.; For a fix output format, ``average_expect`` return the average, while; ``runs_states`` return the list over trajectories. The ``runs_`` output will; return ``None`` when the trajectories are not saved. Standard derivation of the; expectation values is also available:. +-------------------------+----------------------+------------------------------------------------------------------------+; | Reduced result | Trajectories results | Description |; +=========================+======================+========================================================================+; | ``average_states`` | ``runs_states`` | State vectors or density matrices calculated at each times of tlist |; +-------------------------+----------------------+------------------------------------------------------------------------+; | ``average_final_state`` | ``runs_final_state`` | State vectors or density matrices calculated at the last time of tlist |; +-------------------------+----------------------+------------------------------------------------------------------------+; | ``average_expect`` | ``runs_expect`` | List/array of expectation values, if requested. |; +-------------------------+----------------------+------------------------------",MatchSource.DOCS,doc/guide/dynamics/dynamics-data.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-data.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-data.rst:3201,Deployability,integrat,integration,3201,"ata; ======================. To understand how to access the data in a Result object we will use an example; as a guide, although we do not worry about the simulation details at this stage.; Like all solvers, the Master Equation solver used in this example returns an; Result object, here called simply ``result``. To see what is contained inside; ``result`` we can use the print function:. .. doctest::; :options: +SKIP. >>> print(result); <Result; Solver: mesolve; Solver stats:; method: 'scipy zvode adams'; init time: 0.0001876354217529297; preparation time: 0.007544517517089844; run time: 0.001268625259399414; solver: 'Master Equation Evolution'; num_collapse: 1; Time interval: [0, 1.0] (2 steps); Number of e_ops: 1; State not saved.; >. The first line tells us that this data object was generated from the Master; Equation solver :func:`.mesolve`. Next we have the statistics including the ODE; solver used, setup time, number of collpases. Then the integration interval is; described, followed with the number of expectation value computed. Finally, it; says whether the states are stored. Now we have all the information needed to analyze the simulation results.; To access the data for the two expectation values one can do:. .. testcode::; :skipif: True. expt0 = result.expect[0]; expt1 = result.expect[1]. Recall that Python uses C-style indexing that begins with zero (i.e.,; [0] => 1st collapse operator data).; Alternatively, expectation values can be obtained as a dictionary:. .. testcode::; :skipif: True. e_ops = {""sx"": sigmax(), ""sy"": sigmay(), ""sz"": sigmaz()}; ...; expt_sx = result.e_data[""sx""]. When ``e_ops`` is a list, ``e_data`` ca be used with the list index. Together; with the array of times at which these expectation values are calculated:. .. testcode::; :skipif: True. times = result.times. we can plot the resulting expectation values:. .. testcode::; :skipif: True. plot(times, expt0); plot(times, expt1); show(). State vectors, or density matrices, are accessed ",MatchSource.DOCS,doc/guide/dynamics/dynamics-data.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-data.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-data.rst:3201,Integrability,integrat,integration,3201,"ata; ======================. To understand how to access the data in a Result object we will use an example; as a guide, although we do not worry about the simulation details at this stage.; Like all solvers, the Master Equation solver used in this example returns an; Result object, here called simply ``result``. To see what is contained inside; ``result`` we can use the print function:. .. doctest::; :options: +SKIP. >>> print(result); <Result; Solver: mesolve; Solver stats:; method: 'scipy zvode adams'; init time: 0.0001876354217529297; preparation time: 0.007544517517089844; run time: 0.001268625259399414; solver: 'Master Equation Evolution'; num_collapse: 1; Time interval: [0, 1.0] (2 steps); Number of e_ops: 1; State not saved.; >. The first line tells us that this data object was generated from the Master; Equation solver :func:`.mesolve`. Next we have the statistics including the ODE; solver used, setup time, number of collpases. Then the integration interval is; described, followed with the number of expectation value computed. Finally, it; says whether the states are stored. Now we have all the information needed to analyze the simulation results.; To access the data for the two expectation values one can do:. .. testcode::; :skipif: True. expt0 = result.expect[0]; expt1 = result.expect[1]. Recall that Python uses C-style indexing that begins with zero (i.e.,; [0] => 1st collapse operator data).; Alternatively, expectation values can be obtained as a dictionary:. .. testcode::; :skipif: True. e_ops = {""sx"": sigmax(), ""sy"": sigmay(), ""sz"": sigmaz()}; ...; expt_sx = result.e_data[""sx""]. When ``e_ops`` is a list, ``e_data`` ca be used with the list index. Together; with the array of times at which these expectation values are calculated:. .. testcode::; :skipif: True. times = result.times. we can plot the resulting expectation values:. .. testcode::; :skipif: True. plot(times, expt0); plot(times, expt1); show(). State vectors, or density matrices, are accessed ",MatchSource.DOCS,doc/guide/dynamics/dynamics-data.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-data.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-data.rst:4791,Integrability,depend,depending,4791,"kipif: True. e_ops = {""sx"": sigmax(), ""sy"": sigmay(), ""sz"": sigmaz()}; ...; expt_sx = result.e_data[""sx""]. When ``e_ops`` is a list, ``e_data`` ca be used with the list index. Together; with the array of times at which these expectation values are calculated:. .. testcode::; :skipif: True. times = result.times. we can plot the resulting expectation values:. .. testcode::; :skipif: True. plot(times, expt0); plot(times, expt1); show(). State vectors, or density matrices, are accessed in a similar manner, although; typically one does not need an index (i.e [0]) since there is only one list for; each of these components. Some other solver can have other output,; :func:`.heomsolve`'s results can have ``ado_states`` output if the options; ``store_ados`` is set, similarly, :func:`.fmmesolve` can return; ``floquet_states``. Multiple Trajectories Solver Results; ====================================. Solver which compute multiple trajectories such as the Monte Carlo Equations; Solvers or the Stochastics Solvers result will differ depending on whether the; trajectories are flags to be saved.; For example:. .. doctest::; :options: +SKIP. >>> mcsolve(H, psi, np.linspace(0, 1, 11), c_ops, e_ops=[num(N)], ntraj=25, options={""keep_runs_results"": False}); >>> np.shape(result.expect); (1, 11). >>> mcsolve(H, psi, np.linspace(0, 1, 11), c_ops, e_ops=[num(N)], ntraj=25, options={""keep_runs_results"": True}); >>> np.shape(result.expect); (1, 25, 11). When the runs are not saved, the expectation values and states are averaged; over all trajectories, while a list over the runs are given when they are stored.; For a fix output format, ``average_expect`` return the average, while; ``runs_states`` return the list over trajectories. The ``runs_`` output will; return ``None`` when the trajectories are not saved. Standard derivation of the; expectation values is also available:. +-------------------------+----------------------+--------------------------------------------------------------------",MatchSource.DOCS,doc/guide/dynamics/dynamics-data.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-data.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-data.rst:2214,Security,access,access,2214,"----------------------------------------------------------------+; | ``result.expect`` | List/array of expectation values, if requested. |; +------------------------+-----------------------------------------------------------------------+; | ``result.e_data`` | Dictionary of expectation values, if requested. |; +------------------------+-----------------------------------------------------------------------+; | ``result.states`` | List/array of state vectors/density matrices calculated at ``times``, |; | | if requested. |; +------------------------+-----------------------------------------------------------------------+; | ``result.final_state`` | State vector or density matrix at the last time of the evolution. |; +------------------------+-----------------------------------------------------------------------+; | ``result.stats`` | Various statistics about the evolution. |; +------------------------+-----------------------------------------------------------------------+. .. _odedata-access:. Accessing Result Data; ======================. To understand how to access the data in a Result object we will use an example; as a guide, although we do not worry about the simulation details at this stage.; Like all solvers, the Master Equation solver used in this example returns an; Result object, here called simply ``result``. To see what is contained inside; ``result`` we can use the print function:. .. doctest::; :options: +SKIP. >>> print(result); <Result; Solver: mesolve; Solver stats:; method: 'scipy zvode adams'; init time: 0.0001876354217529297; preparation time: 0.007544517517089844; run time: 0.001268625259399414; solver: 'Master Equation Evolution'; num_collapse: 1; Time interval: [0, 1.0] (2 steps); Number of e_ops: 1; State not saved.; >. The first line tells us that this data object was generated from the Master; Equation solver :func:`.mesolve`. Next we have the statistics including the ODE; solver used, setup time, number of collpases. Then the integration ",MatchSource.DOCS,doc/guide/dynamics/dynamics-data.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-data.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-data.rst:2291,Security,access,access,2291," |; +------------------------+-----------------------------------------------------------------------+; | ``result.e_data`` | Dictionary of expectation values, if requested. |; +------------------------+-----------------------------------------------------------------------+; | ``result.states`` | List/array of state vectors/density matrices calculated at ``times``, |; | | if requested. |; +------------------------+-----------------------------------------------------------------------+; | ``result.final_state`` | State vector or density matrix at the last time of the evolution. |; +------------------------+-----------------------------------------------------------------------+; | ``result.stats`` | Various statistics about the evolution. |; +------------------------+-----------------------------------------------------------------------+. .. _odedata-access:. Accessing Result Data; ======================. To understand how to access the data in a Result object we will use an example; as a guide, although we do not worry about the simulation details at this stage.; Like all solvers, the Master Equation solver used in this example returns an; Result object, here called simply ``result``. To see what is contained inside; ``result`` we can use the print function:. .. doctest::; :options: +SKIP. >>> print(result); <Result; Solver: mesolve; Solver stats:; method: 'scipy zvode adams'; init time: 0.0001876354217529297; preparation time: 0.007544517517089844; run time: 0.001268625259399414; solver: 'Master Equation Evolution'; num_collapse: 1; Time interval: [0, 1.0] (2 steps); Number of e_ops: 1; State not saved.; >. The first line tells us that this data object was generated from the Master; Equation solver :func:`.mesolve`. Next we have the statistics including the ODE; solver used, setup time, number of collpases. Then the integration interval is; described, followed with the number of expectation value computed. Finally, it; says whether the states are stored. Now we h",MatchSource.DOCS,doc/guide/dynamics/dynamics-data.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-data.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-data.rst:3420,Security,access,access,3420,"s, the Master Equation solver used in this example returns an; Result object, here called simply ``result``. To see what is contained inside; ``result`` we can use the print function:. .. doctest::; :options: +SKIP. >>> print(result); <Result; Solver: mesolve; Solver stats:; method: 'scipy zvode adams'; init time: 0.0001876354217529297; preparation time: 0.007544517517089844; run time: 0.001268625259399414; solver: 'Master Equation Evolution'; num_collapse: 1; Time interval: [0, 1.0] (2 steps); Number of e_ops: 1; State not saved.; >. The first line tells us that this data object was generated from the Master; Equation solver :func:`.mesolve`. Next we have the statistics including the ODE; solver used, setup time, number of collpases. Then the integration interval is; described, followed with the number of expectation value computed. Finally, it; says whether the states are stored. Now we have all the information needed to analyze the simulation results.; To access the data for the two expectation values one can do:. .. testcode::; :skipif: True. expt0 = result.expect[0]; expt1 = result.expect[1]. Recall that Python uses C-style indexing that begins with zero (i.e.,; [0] => 1st collapse operator data).; Alternatively, expectation values can be obtained as a dictionary:. .. testcode::; :skipif: True. e_ops = {""sx"": sigmax(), ""sy"": sigmay(), ""sz"": sigmaz()}; ...; expt_sx = result.e_data[""sx""]. When ``e_ops`` is a list, ``e_data`` ca be used with the list index. Together; with the array of times at which these expectation values are calculated:. .. testcode::; :skipif: True. times = result.times. we can plot the resulting expectation values:. .. testcode::; :skipif: True. plot(times, expt0); plot(times, expt1); show(). State vectors, or density matrices, are accessed in a similar manner, although; typically one does not need an index (i.e [0]) since there is only one list for; each of these components. Some other solver can have other output,; :func:`.heomsolve`'s resu",MatchSource.DOCS,doc/guide/dynamics/dynamics-data.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-data.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-data.rst:4233,Security,access,accessed,4233,"he number of expectation value computed. Finally, it; says whether the states are stored. Now we have all the information needed to analyze the simulation results.; To access the data for the two expectation values one can do:. .. testcode::; :skipif: True. expt0 = result.expect[0]; expt1 = result.expect[1]. Recall that Python uses C-style indexing that begins with zero (i.e.,; [0] => 1st collapse operator data).; Alternatively, expectation values can be obtained as a dictionary:. .. testcode::; :skipif: True. e_ops = {""sx"": sigmax(), ""sy"": sigmay(), ""sz"": sigmaz()}; ...; expt_sx = result.e_data[""sx""]. When ``e_ops`` is a list, ``e_data`` ca be used with the list index. Together; with the array of times at which these expectation values are calculated:. .. testcode::; :skipif: True. times = result.times. we can plot the resulting expectation values:. .. testcode::; :skipif: True. plot(times, expt0); plot(times, expt1); show(). State vectors, or density matrices, are accessed in a similar manner, although; typically one does not need an index (i.e [0]) since there is only one list for; each of these components. Some other solver can have other output,; :func:`.heomsolve`'s results can have ``ado_states`` output if the options; ``store_ados`` is set, similarly, :func:`.fmmesolve` can return; ``floquet_states``. Multiple Trajectories Solver Results; ====================================. Solver which compute multiple trajectories such as the Monte Carlo Equations; Solvers or the Stochastics Solvers result will differ depending on whether the; trajectories are flags to be saved.; For example:. .. doctest::; :options: +SKIP. >>> mcsolve(H, psi, np.linspace(0, 1, 11), c_ops, e_ops=[num(N)], ntraj=25, options={""keep_runs_results"": False}); >>> np.shape(result.expect); (1, 11). >>> mcsolve(H, psi, np.linspace(0, 1, 11), c_ops, e_ops=[num(N)], ntraj=25, options={""keep_runs_results"": True}); >>> np.shape(result.expect); (1, 25, 11). When the runs are not saved, the expectation ",MatchSource.DOCS,doc/guide/dynamics/dynamics-data.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-data.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-data.rst:3483,Testability,test,testcode,3483,"le returns an; Result object, here called simply ``result``. To see what is contained inside; ``result`` we can use the print function:. .. doctest::; :options: +SKIP. >>> print(result); <Result; Solver: mesolve; Solver stats:; method: 'scipy zvode adams'; init time: 0.0001876354217529297; preparation time: 0.007544517517089844; run time: 0.001268625259399414; solver: 'Master Equation Evolution'; num_collapse: 1; Time interval: [0, 1.0] (2 steps); Number of e_ops: 1; State not saved.; >. The first line tells us that this data object was generated from the Master; Equation solver :func:`.mesolve`. Next we have the statistics including the ODE; solver used, setup time, number of collpases. Then the integration interval is; described, followed with the number of expectation value computed. Finally, it; says whether the states are stored. Now we have all the information needed to analyze the simulation results.; To access the data for the two expectation values one can do:. .. testcode::; :skipif: True. expt0 = result.expect[0]; expt1 = result.expect[1]. Recall that Python uses C-style indexing that begins with zero (i.e.,; [0] => 1st collapse operator data).; Alternatively, expectation values can be obtained as a dictionary:. .. testcode::; :skipif: True. e_ops = {""sx"": sigmax(), ""sy"": sigmay(), ""sz"": sigmaz()}; ...; expt_sx = result.e_data[""sx""]. When ``e_ops`` is a list, ``e_data`` ca be used with the list index. Together; with the array of times at which these expectation values are calculated:. .. testcode::; :skipif: True. times = result.times. we can plot the resulting expectation values:. .. testcode::; :skipif: True. plot(times, expt0); plot(times, expt1); show(). State vectors, or density matrices, are accessed in a similar manner, although; typically one does not need an index (i.e [0]) since there is only one list for; each of these components. Some other solver can have other output,; :func:`.heomsolve`'s results can have ``ado_states`` output if the options",MatchSource.DOCS,doc/guide/dynamics/dynamics-data.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-data.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-data.rst:3741,Testability,test,testcode,3741,"nit time: 0.0001876354217529297; preparation time: 0.007544517517089844; run time: 0.001268625259399414; solver: 'Master Equation Evolution'; num_collapse: 1; Time interval: [0, 1.0] (2 steps); Number of e_ops: 1; State not saved.; >. The first line tells us that this data object was generated from the Master; Equation solver :func:`.mesolve`. Next we have the statistics including the ODE; solver used, setup time, number of collpases. Then the integration interval is; described, followed with the number of expectation value computed. Finally, it; says whether the states are stored. Now we have all the information needed to analyze the simulation results.; To access the data for the two expectation values one can do:. .. testcode::; :skipif: True. expt0 = result.expect[0]; expt1 = result.expect[1]. Recall that Python uses C-style indexing that begins with zero (i.e.,; [0] => 1st collapse operator data).; Alternatively, expectation values can be obtained as a dictionary:. .. testcode::; :skipif: True. e_ops = {""sx"": sigmax(), ""sy"": sigmay(), ""sz"": sigmaz()}; ...; expt_sx = result.e_data[""sx""]. When ``e_ops`` is a list, ``e_data`` ca be used with the list index. Together; with the array of times at which these expectation values are calculated:. .. testcode::; :skipif: True. times = result.times. we can plot the resulting expectation values:. .. testcode::; :skipif: True. plot(times, expt0); plot(times, expt1); show(). State vectors, or density matrices, are accessed in a similar manner, although; typically one does not need an index (i.e [0]) since there is only one list for; each of these components. Some other solver can have other output,; :func:`.heomsolve`'s results can have ``ado_states`` output if the options; ``store_ados`` is set, similarly, :func:`.fmmesolve` can return; ``floquet_states``. Multiple Trajectories Solver Results; ====================================. Solver which compute multiple trajectories such as the Monte Carlo Equations; Solvers or the St",MatchSource.DOCS,doc/guide/dynamics/dynamics-data.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-data.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-data.rst:4019,Testability,test,testcode,4019,"ct was generated from the Master; Equation solver :func:`.mesolve`. Next we have the statistics including the ODE; solver used, setup time, number of collpases. Then the integration interval is; described, followed with the number of expectation value computed. Finally, it; says whether the states are stored. Now we have all the information needed to analyze the simulation results.; To access the data for the two expectation values one can do:. .. testcode::; :skipif: True. expt0 = result.expect[0]; expt1 = result.expect[1]. Recall that Python uses C-style indexing that begins with zero (i.e.,; [0] => 1st collapse operator data).; Alternatively, expectation values can be obtained as a dictionary:. .. testcode::; :skipif: True. e_ops = {""sx"": sigmax(), ""sy"": sigmay(), ""sz"": sigmaz()}; ...; expt_sx = result.e_data[""sx""]. When ``e_ops`` is a list, ``e_data`` ca be used with the list index. Together; with the array of times at which these expectation values are calculated:. .. testcode::; :skipif: True. times = result.times. we can plot the resulting expectation values:. .. testcode::; :skipif: True. plot(times, expt0); plot(times, expt1); show(). State vectors, or density matrices, are accessed in a similar manner, although; typically one does not need an index (i.e [0]) since there is only one list for; each of these components. Some other solver can have other output,; :func:`.heomsolve`'s results can have ``ado_states`` output if the options; ``store_ados`` is set, similarly, :func:`.fmmesolve` can return; ``floquet_states``. Multiple Trajectories Solver Results; ====================================. Solver which compute multiple trajectories such as the Monte Carlo Equations; Solvers or the Stochastics Solvers result will differ depending on whether the; trajectories are flags to be saved.; For example:. .. doctest::; :options: +SKIP. >>> mcsolve(H, psi, np.linspace(0, 1, 11), c_ops, e_ops=[num(N)], ntraj=25, options={""keep_runs_results"": False}); >>> np.shape(resul",MatchSource.DOCS,doc/guide/dynamics/dynamics-data.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-data.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-data.rst:4118,Testability,test,testcode,4118,"luding the ODE; solver used, setup time, number of collpases. Then the integration interval is; described, followed with the number of expectation value computed. Finally, it; says whether the states are stored. Now we have all the information needed to analyze the simulation results.; To access the data for the two expectation values one can do:. .. testcode::; :skipif: True. expt0 = result.expect[0]; expt1 = result.expect[1]. Recall that Python uses C-style indexing that begins with zero (i.e.,; [0] => 1st collapse operator data).; Alternatively, expectation values can be obtained as a dictionary:. .. testcode::; :skipif: True. e_ops = {""sx"": sigmax(), ""sy"": sigmay(), ""sz"": sigmaz()}; ...; expt_sx = result.e_data[""sx""]. When ``e_ops`` is a list, ``e_data`` ca be used with the list index. Together; with the array of times at which these expectation values are calculated:. .. testcode::; :skipif: True. times = result.times. we can plot the resulting expectation values:. .. testcode::; :skipif: True. plot(times, expt0); plot(times, expt1); show(). State vectors, or density matrices, are accessed in a similar manner, although; typically one does not need an index (i.e [0]) since there is only one list for; each of these components. Some other solver can have other output,; :func:`.heomsolve`'s results can have ``ado_states`` output if the options; ``store_ados`` is set, similarly, :func:`.fmmesolve` can return; ``floquet_states``. Multiple Trajectories Solver Results; ====================================. Solver which compute multiple trajectories such as the Monte Carlo Equations; Solvers or the Stochastics Solvers result will differ depending on whether the; trajectories are flags to be saved.; For example:. .. doctest::; :options: +SKIP. >>> mcsolve(H, psi, np.linspace(0, 1, 11), c_ops, e_ops=[num(N)], ntraj=25, options={""keep_runs_results"": False}); >>> np.shape(result.expect); (1, 11). >>> mcsolve(H, psi, np.linspace(0, 1, 11), c_ops, e_ops=[num(N)], ntraj=25, opt",MatchSource.DOCS,doc/guide/dynamics/dynamics-data.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-data.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-data.rst:7391,Testability,test,testcode,7391,"ates`` | State vectors or density matrices calculated at each times of tlist |; +-------------------------+----------------------+------------------------------------------------------------------------+; | ``average_final_state`` | ``runs_final_state`` | State vectors or density matrices calculated at the last time of tlist |; +-------------------------+----------------------+------------------------------------------------------------------------+; | ``average_expect`` | ``runs_expect`` | List/array of expectation values, if requested. |; +-------------------------+----------------------+------------------------------------------------------------------------+; | ``std_expect`` | | List/array of standard derivation of the expectation values. |; +-------------------------+----------------------+------------------------------------------------------------------------+; | ``average_e_data`` | ``runs_e_data`` | Dictionary of expectation values, if requested. |; +-------------------------+----------------------+------------------------------------------------------------------------+; | ``std_e_data`` | | Dictionary of standard derivation of the expectation values. |; +-------------------------+----------------------+------------------------------------------------------------------------+. Multiple trajectories results also keep the trajectories ``seeds`` to allows; recomputing the results. .. testcode::; :skipif: True. seeds = result.seeds. One last feature specific to multi-trajectories results is the addition operation; that can be used to merge sets of trajectories. .. code-block::. >>> run1 = smesolve(H, psi, np.linspace(0, 1, 11), c_ops, e_ops=[num(N)], ntraj=25); >>> print(run1.num_trajectories); 25; >>> run2 = smesolve(H, psi, np.linspace(0, 1, 11), c_ops, e_ops=[num(N)], ntraj=25); >>> print(run2.num_trajectories); 25; >>> merged = run1 + run2; >>> print(merged.num_trajectories); 50. This allows one to improve statistics while keeping previous computations.; ",MatchSource.DOCS,doc/guide/dynamics/dynamics-data.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-data.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-data.rst:2355,Usability,guid,guide,2355," |; +------------------------+-----------------------------------------------------------------------+; | ``result.e_data`` | Dictionary of expectation values, if requested. |; +------------------------+-----------------------------------------------------------------------+; | ``result.states`` | List/array of state vectors/density matrices calculated at ``times``, |; | | if requested. |; +------------------------+-----------------------------------------------------------------------+; | ``result.final_state`` | State vector or density matrix at the last time of the evolution. |; +------------------------+-----------------------------------------------------------------------+; | ``result.stats`` | Various statistics about the evolution. |; +------------------------+-----------------------------------------------------------------------+. .. _odedata-access:. Accessing Result Data; ======================. To understand how to access the data in a Result object we will use an example; as a guide, although we do not worry about the simulation details at this stage.; Like all solvers, the Master Equation solver used in this example returns an; Result object, here called simply ``result``. To see what is contained inside; ``result`` we can use the print function:. .. doctest::; :options: +SKIP. >>> print(result); <Result; Solver: mesolve; Solver stats:; method: 'scipy zvode adams'; init time: 0.0001876354217529297; preparation time: 0.007544517517089844; run time: 0.001268625259399414; solver: 'Master Equation Evolution'; num_collapse: 1; Time interval: [0, 1.0] (2 steps); Number of e_ops: 1; State not saved.; >. The first line tells us that this data object was generated from the Master; Equation solver :func:`.mesolve`. Next we have the statistics including the ODE; solver used, setup time, number of collpases. Then the integration interval is; described, followed with the number of expectation value computed. Finally, it; says whether the states are stored. Now we h",MatchSource.DOCS,doc/guide/dynamics/dynamics-data.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-data.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-data.rst:2537,Usability,simpl,simply,2537,"ectation values, if requested. |; +------------------------+-----------------------------------------------------------------------+; | ``result.states`` | List/array of state vectors/density matrices calculated at ``times``, |; | | if requested. |; +------------------------+-----------------------------------------------------------------------+; | ``result.final_state`` | State vector or density matrix at the last time of the evolution. |; +------------------------+-----------------------------------------------------------------------+; | ``result.stats`` | Various statistics about the evolution. |; +------------------------+-----------------------------------------------------------------------+. .. _odedata-access:. Accessing Result Data; ======================. To understand how to access the data in a Result object we will use an example; as a guide, although we do not worry about the simulation details at this stage.; Like all solvers, the Master Equation solver used in this example returns an; Result object, here called simply ``result``. To see what is contained inside; ``result`` we can use the print function:. .. doctest::; :options: +SKIP. >>> print(result); <Result; Solver: mesolve; Solver stats:; method: 'scipy zvode adams'; init time: 0.0001876354217529297; preparation time: 0.007544517517089844; run time: 0.001268625259399414; solver: 'Master Equation Evolution'; num_collapse: 1; Time interval: [0, 1.0] (2 steps); Number of e_ops: 1; State not saved.; >. The first line tells us that this data object was generated from the Master; Equation solver :func:`.mesolve`. Next we have the statistics including the ODE; solver used, setup time, number of collpases. Then the integration interval is; described, followed with the number of expectation value computed. Finally, it; says whether the states are stored. Now we have all the information needed to analyze the simulation results.; To access the data for the two expectation values one can do:. .. testcode::",MatchSource.DOCS,doc/guide/dynamics/dynamics-data.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-data.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-floquet.rst:243,Deployability,integrat,integration,243,".. _floquet:. *****************; Floquet Formalism; *****************. .. _floquet-intro:. Introduction; ============. Many time-dependent problems of interest are periodic. The dynamics of such systems can be solved for directly by numerical integration of the Schrdinger or Master equation, using the time-dependent Hamiltonian. But they can also be transformed into time-independent problems using the Floquet formalism. Time-independent problems can be solve much more efficiently, so such a transformation is often very desirable. In the standard derivations of the Lindblad and Bloch-Redfield master equations the Hamiltonian describing the system under consideration is assumed to be time independent. Thus, strictly speaking, the standard forms of these master equation formalisms should not blindly be applied to system with time-dependent Hamiltonians. However, in many relevant cases, in particular for weak driving, the standard master equations still turns out to be useful for many time-dependent problems. But a more rigorous approach would be to rederive the master equation taking the time-dependent nature of the Hamiltonian into account from the start. The Floquet-Markov Master equation is one such a formalism, with important applications for strongly driven systems (see e.g., [Gri98]_). Here we give an overview of how the Floquet and Floquet-Markov formalisms can be used for solving time-dependent problems in QuTiP. To introduce the terminology and naming conventions used in QuTiP we first give a brief summary of quantum Floquet theory. .. _floquet-unitary:. Floquet theory for unitary evolution; ====================================. The Schrdinger equation with a time-dependent Hamiltonian :math:`H(t)` is. .. math::; :label: eq_td_schrodinger. 	H(t)\Psi(t) = i\hbar\frac{\partial}{\partial t}\Psi(t),. where :math:`\Psi(t)` is the wave function solution. Here we are interested in problems with periodic time-dependence, i.e., the Hamiltonian satisfies :math:`H(t) = ",MatchSource.DOCS,doc/guide/dynamics/dynamics-floquet.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-floquet.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-floquet.rst:474,Energy Efficiency,efficient,efficiently,474,".. _floquet:. *****************; Floquet Formalism; *****************. .. _floquet-intro:. Introduction; ============. Many time-dependent problems of interest are periodic. The dynamics of such systems can be solved for directly by numerical integration of the Schrdinger or Master equation, using the time-dependent Hamiltonian. But they can also be transformed into time-independent problems using the Floquet formalism. Time-independent problems can be solve much more efficiently, so such a transformation is often very desirable. In the standard derivations of the Lindblad and Bloch-Redfield master equations the Hamiltonian describing the system under consideration is assumed to be time independent. Thus, strictly speaking, the standard forms of these master equation formalisms should not blindly be applied to system with time-dependent Hamiltonians. However, in many relevant cases, in particular for weak driving, the standard master equations still turns out to be useful for many time-dependent problems. But a more rigorous approach would be to rederive the master equation taking the time-dependent nature of the Hamiltonian into account from the start. The Floquet-Markov Master equation is one such a formalism, with important applications for strongly driven systems (see e.g., [Gri98]_). Here we give an overview of how the Floquet and Floquet-Markov formalisms can be used for solving time-dependent problems in QuTiP. To introduce the terminology and naming conventions used in QuTiP we first give a brief summary of quantum Floquet theory. .. _floquet-unitary:. Floquet theory for unitary evolution; ====================================. The Schrdinger equation with a time-dependent Hamiltonian :math:`H(t)` is. .. math::; :label: eq_td_schrodinger. 	H(t)\Psi(t) = i\hbar\frac{\partial}{\partial t}\Psi(t),. where :math:`\Psi(t)` is the wave function solution. Here we are interested in problems with periodic time-dependence, i.e., the Hamiltonian satisfies :math:`H(t) = ",MatchSource.DOCS,doc/guide/dynamics/dynamics-floquet.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-floquet.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-floquet.rst:10895,Energy Efficiency,efficient,efficiently,10895," that is the solution to :eq:`eq_driven_qubit` at an arbitrary; time :math:`t` using the function :meth:`.FloquetBasis.from_floquet_basis`:. .. plot::; :context: close-figs. >>> t = 10 * np.random.rand(); >>> psi_t = floquet_basis.from_floquet_basis(f_coeff, t). The following example illustrates how to use the functions introduced above to calculate; and plot the time-evolution of :eq:`eq_driven_qubit`. .. plot:: guide/scripts/floquet_ex1.py; :width: 4.0in; :include-source:. Pre-computing the Floquet modes for one period; ----------------------------------------------. When evaluating the Floquet states or the wavefunction at many points in time it; is useful to pre-compute the Floquet modes for the first period of the driving with; the required times. The list of times to pre-compute modes for may be passed to; :class:`.FloquetBasis` using ``precompute=tlist``, and then; :meth:`.FloquetBasis.from_floquet_basis` and :meth:`.FloquetBasis.to_floquet_basis`; can be used to efficiently retrieve the wave function at the pre-computed times.; The following example illustrates how the example from the previous section can be; solved more efficiently using these functions for pre-computing the Floquet modes:. .. plot:: guide/scripts/floquet_ex2.py; :width: 4.0in; :include-source:. Note that the parameters and the Hamiltonian used in this example is not the same as; in the previous section, and hence the different appearance of the resulting figure. For convenience, all the steps described above for calculating the evolution of a; quantum system using the Floquet formalisms are encapsulated in the function :func:`.fsesolve`.; Using this function, we could have achieved the same results as in the examples above using. .. code-block:: python. output = fsesolve(H, psi0=psi0, tlist=tlist, e_ops=[qutip.num(2)], args=args); p_ex = output.expect[0]. .. _floquet-dissipative:. Floquet theory for dissipative evolution; ========================================. A driven system that is in",MatchSource.DOCS,doc/guide/dynamics/dynamics-floquet.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-floquet.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-floquet.rst:11058,Energy Efficiency,efficient,efficiently,11058,"sis`:. .. plot::; :context: close-figs. >>> t = 10 * np.random.rand(); >>> psi_t = floquet_basis.from_floquet_basis(f_coeff, t). The following example illustrates how to use the functions introduced above to calculate; and plot the time-evolution of :eq:`eq_driven_qubit`. .. plot:: guide/scripts/floquet_ex1.py; :width: 4.0in; :include-source:. Pre-computing the Floquet modes for one period; ----------------------------------------------. When evaluating the Floquet states or the wavefunction at many points in time it; is useful to pre-compute the Floquet modes for the first period of the driving with; the required times. The list of times to pre-compute modes for may be passed to; :class:`.FloquetBasis` using ``precompute=tlist``, and then; :meth:`.FloquetBasis.from_floquet_basis` and :meth:`.FloquetBasis.to_floquet_basis`; can be used to efficiently retrieve the wave function at the pre-computed times.; The following example illustrates how the example from the previous section can be; solved more efficiently using these functions for pre-computing the Floquet modes:. .. plot:: guide/scripts/floquet_ex2.py; :width: 4.0in; :include-source:. Note that the parameters and the Hamiltonian used in this example is not the same as; in the previous section, and hence the different appearance of the resulting figure. For convenience, all the steps described above for calculating the evolution of a; quantum system using the Floquet formalisms are encapsulated in the function :func:`.fsesolve`.; Using this function, we could have achieved the same results as in the examples above using. .. code-block:: python. output = fsesolve(H, psi0=psi0, tlist=tlist, e_ops=[qutip.num(2)], args=args); p_ex = output.expect[0]. .. _floquet-dissipative:. Floquet theory for dissipative evolution; ========================================. A driven system that is interacting with its environment is not necessarily well; described by the standard Lindblad master equation, since its dissipation proc",MatchSource.DOCS,doc/guide/dynamics/dynamics-floquet.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-floquet.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-floquet.rst:129,Integrability,depend,dependent,129,".. _floquet:. *****************; Floquet Formalism; *****************. .. _floquet-intro:. Introduction; ============. Many time-dependent problems of interest are periodic. The dynamics of such systems can be solved for directly by numerical integration of the Schrdinger or Master equation, using the time-dependent Hamiltonian. But they can also be transformed into time-independent problems using the Floquet formalism. Time-independent problems can be solve much more efficiently, so such a transformation is often very desirable. In the standard derivations of the Lindblad and Bloch-Redfield master equations the Hamiltonian describing the system under consideration is assumed to be time independent. Thus, strictly speaking, the standard forms of these master equation formalisms should not blindly be applied to system with time-dependent Hamiltonians. However, in many relevant cases, in particular for weak driving, the standard master equations still turns out to be useful for many time-dependent problems. But a more rigorous approach would be to rederive the master equation taking the time-dependent nature of the Hamiltonian into account from the start. The Floquet-Markov Master equation is one such a formalism, with important applications for strongly driven systems (see e.g., [Gri98]_). Here we give an overview of how the Floquet and Floquet-Markov formalisms can be used for solving time-dependent problems in QuTiP. To introduce the terminology and naming conventions used in QuTiP we first give a brief summary of quantum Floquet theory. .. _floquet-unitary:. Floquet theory for unitary evolution; ====================================. The Schrdinger equation with a time-dependent Hamiltonian :math:`H(t)` is. .. math::; :label: eq_td_schrodinger. 	H(t)\Psi(t) = i\hbar\frac{\partial}{\partial t}\Psi(t),. where :math:`\Psi(t)` is the wave function solution. Here we are interested in problems with periodic time-dependence, i.e., the Hamiltonian satisfies :math:`H(t) = ",MatchSource.DOCS,doc/guide/dynamics/dynamics-floquet.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-floquet.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-floquet.rst:243,Integrability,integrat,integration,243,".. _floquet:. *****************; Floquet Formalism; *****************. .. _floquet-intro:. Introduction; ============. Many time-dependent problems of interest are periodic. The dynamics of such systems can be solved for directly by numerical integration of the Schrdinger or Master equation, using the time-dependent Hamiltonian. But they can also be transformed into time-independent problems using the Floquet formalism. Time-independent problems can be solve much more efficiently, so such a transformation is often very desirable. In the standard derivations of the Lindblad and Bloch-Redfield master equations the Hamiltonian describing the system under consideration is assumed to be time independent. Thus, strictly speaking, the standard forms of these master equation formalisms should not blindly be applied to system with time-dependent Hamiltonians. However, in many relevant cases, in particular for weak driving, the standard master equations still turns out to be useful for many time-dependent problems. But a more rigorous approach would be to rederive the master equation taking the time-dependent nature of the Hamiltonian into account from the start. The Floquet-Markov Master equation is one such a formalism, with important applications for strongly driven systems (see e.g., [Gri98]_). Here we give an overview of how the Floquet and Floquet-Markov formalisms can be used for solving time-dependent problems in QuTiP. To introduce the terminology and naming conventions used in QuTiP we first give a brief summary of quantum Floquet theory. .. _floquet-unitary:. Floquet theory for unitary evolution; ====================================. The Schrdinger equation with a time-dependent Hamiltonian :math:`H(t)` is. .. math::; :label: eq_td_schrodinger. 	H(t)\Psi(t) = i\hbar\frac{\partial}{\partial t}\Psi(t),. where :math:`\Psi(t)` is the wave function solution. Here we are interested in problems with periodic time-dependence, i.e., the Hamiltonian satisfies :math:`H(t) = ",MatchSource.DOCS,doc/guide/dynamics/dynamics-floquet.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-floquet.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-floquet.rst:309,Integrability,depend,dependent,309,".. _floquet:. *****************; Floquet Formalism; *****************. .. _floquet-intro:. Introduction; ============. Many time-dependent problems of interest are periodic. The dynamics of such systems can be solved for directly by numerical integration of the Schrdinger or Master equation, using the time-dependent Hamiltonian. But they can also be transformed into time-independent problems using the Floquet formalism. Time-independent problems can be solve much more efficiently, so such a transformation is often very desirable. In the standard derivations of the Lindblad and Bloch-Redfield master equations the Hamiltonian describing the system under consideration is assumed to be time independent. Thus, strictly speaking, the standard forms of these master equation formalisms should not blindly be applied to system with time-dependent Hamiltonians. However, in many relevant cases, in particular for weak driving, the standard master equations still turns out to be useful for many time-dependent problems. But a more rigorous approach would be to rederive the master equation taking the time-dependent nature of the Hamiltonian into account from the start. The Floquet-Markov Master equation is one such a formalism, with important applications for strongly driven systems (see e.g., [Gri98]_). Here we give an overview of how the Floquet and Floquet-Markov formalisms can be used for solving time-dependent problems in QuTiP. To introduce the terminology and naming conventions used in QuTiP we first give a brief summary of quantum Floquet theory. .. _floquet-unitary:. Floquet theory for unitary evolution; ====================================. The Schrdinger equation with a time-dependent Hamiltonian :math:`H(t)` is. .. math::; :label: eq_td_schrodinger. 	H(t)\Psi(t) = i\hbar\frac{\partial}{\partial t}\Psi(t),. where :math:`\Psi(t)` is the wave function solution. Here we are interested in problems with periodic time-dependence, i.e., the Hamiltonian satisfies :math:`H(t) = ",MatchSource.DOCS,doc/guide/dynamics/dynamics-floquet.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-floquet.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-floquet.rst:840,Integrability,depend,dependent,840,".. _floquet:. *****************; Floquet Formalism; *****************. .. _floquet-intro:. Introduction; ============. Many time-dependent problems of interest are periodic. The dynamics of such systems can be solved for directly by numerical integration of the Schrdinger or Master equation, using the time-dependent Hamiltonian. But they can also be transformed into time-independent problems using the Floquet formalism. Time-independent problems can be solve much more efficiently, so such a transformation is often very desirable. In the standard derivations of the Lindblad and Bloch-Redfield master equations the Hamiltonian describing the system under consideration is assumed to be time independent. Thus, strictly speaking, the standard forms of these master equation formalisms should not blindly be applied to system with time-dependent Hamiltonians. However, in many relevant cases, in particular for weak driving, the standard master equations still turns out to be useful for many time-dependent problems. But a more rigorous approach would be to rederive the master equation taking the time-dependent nature of the Hamiltonian into account from the start. The Floquet-Markov Master equation is one such a formalism, with important applications for strongly driven systems (see e.g., [Gri98]_). Here we give an overview of how the Floquet and Floquet-Markov formalisms can be used for solving time-dependent problems in QuTiP. To introduce the terminology and naming conventions used in QuTiP we first give a brief summary of quantum Floquet theory. .. _floquet-unitary:. Floquet theory for unitary evolution; ====================================. The Schrdinger equation with a time-dependent Hamiltonian :math:`H(t)` is. .. math::; :label: eq_td_schrodinger. 	H(t)\Psi(t) = i\hbar\frac{\partial}{\partial t}\Psi(t),. where :math:`\Psi(t)` is the wave function solution. Here we are interested in problems with periodic time-dependence, i.e., the Hamiltonian satisfies :math:`H(t) = ",MatchSource.DOCS,doc/guide/dynamics/dynamics-floquet.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-floquet.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-floquet.rst:1002,Integrability,depend,dependent,1002,".. _floquet:. *****************; Floquet Formalism; *****************. .. _floquet-intro:. Introduction; ============. Many time-dependent problems of interest are periodic. The dynamics of such systems can be solved for directly by numerical integration of the Schrdinger or Master equation, using the time-dependent Hamiltonian. But they can also be transformed into time-independent problems using the Floquet formalism. Time-independent problems can be solve much more efficiently, so such a transformation is often very desirable. In the standard derivations of the Lindblad and Bloch-Redfield master equations the Hamiltonian describing the system under consideration is assumed to be time independent. Thus, strictly speaking, the standard forms of these master equation formalisms should not blindly be applied to system with time-dependent Hamiltonians. However, in many relevant cases, in particular for weak driving, the standard master equations still turns out to be useful for many time-dependent problems. But a more rigorous approach would be to rederive the master equation taking the time-dependent nature of the Hamiltonian into account from the start. The Floquet-Markov Master equation is one such a formalism, with important applications for strongly driven systems (see e.g., [Gri98]_). Here we give an overview of how the Floquet and Floquet-Markov formalisms can be used for solving time-dependent problems in QuTiP. To introduce the terminology and naming conventions used in QuTiP we first give a brief summary of quantum Floquet theory. .. _floquet-unitary:. Floquet theory for unitary evolution; ====================================. The Schrdinger equation with a time-dependent Hamiltonian :math:`H(t)` is. .. math::; :label: eq_td_schrodinger. 	H(t)\Psi(t) = i\hbar\frac{\partial}{\partial t}\Psi(t),. where :math:`\Psi(t)` is the wave function solution. Here we are interested in problems with periodic time-dependence, i.e., the Hamiltonian satisfies :math:`H(t) = ",MatchSource.DOCS,doc/guide/dynamics/dynamics-floquet.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-floquet.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-floquet.rst:1108,Integrability,depend,dependent,1108,"duction; ============. Many time-dependent problems of interest are periodic. The dynamics of such systems can be solved for directly by numerical integration of the Schrdinger or Master equation, using the time-dependent Hamiltonian. But they can also be transformed into time-independent problems using the Floquet formalism. Time-independent problems can be solve much more efficiently, so such a transformation is often very desirable. In the standard derivations of the Lindblad and Bloch-Redfield master equations the Hamiltonian describing the system under consideration is assumed to be time independent. Thus, strictly speaking, the standard forms of these master equation formalisms should not blindly be applied to system with time-dependent Hamiltonians. However, in many relevant cases, in particular for weak driving, the standard master equations still turns out to be useful for many time-dependent problems. But a more rigorous approach would be to rederive the master equation taking the time-dependent nature of the Hamiltonian into account from the start. The Floquet-Markov Master equation is one such a formalism, with important applications for strongly driven systems (see e.g., [Gri98]_). Here we give an overview of how the Floquet and Floquet-Markov formalisms can be used for solving time-dependent problems in QuTiP. To introduce the terminology and naming conventions used in QuTiP we first give a brief summary of quantum Floquet theory. .. _floquet-unitary:. Floquet theory for unitary evolution; ====================================. The Schrdinger equation with a time-dependent Hamiltonian :math:`H(t)` is. .. math::; :label: eq_td_schrodinger. 	H(t)\Psi(t) = i\hbar\frac{\partial}{\partial t}\Psi(t),. where :math:`\Psi(t)` is the wave function solution. Here we are interested in problems with periodic time-dependence, i.e., the Hamiltonian satisfies :math:`H(t) = H(t+T)` where :math:`T` is the period. According to the Floquet theorem, there exist solutions t",MatchSource.DOCS,doc/guide/dynamics/dynamics-floquet.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-floquet.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-floquet.rst:1414,Integrability,depend,dependent,1414,"ndependent problems using the Floquet formalism. Time-independent problems can be solve much more efficiently, so such a transformation is often very desirable. In the standard derivations of the Lindblad and Bloch-Redfield master equations the Hamiltonian describing the system under consideration is assumed to be time independent. Thus, strictly speaking, the standard forms of these master equation formalisms should not blindly be applied to system with time-dependent Hamiltonians. However, in many relevant cases, in particular for weak driving, the standard master equations still turns out to be useful for many time-dependent problems. But a more rigorous approach would be to rederive the master equation taking the time-dependent nature of the Hamiltonian into account from the start. The Floquet-Markov Master equation is one such a formalism, with important applications for strongly driven systems (see e.g., [Gri98]_). Here we give an overview of how the Floquet and Floquet-Markov formalisms can be used for solving time-dependent problems in QuTiP. To introduce the terminology and naming conventions used in QuTiP we first give a brief summary of quantum Floquet theory. .. _floquet-unitary:. Floquet theory for unitary evolution; ====================================. The Schrdinger equation with a time-dependent Hamiltonian :math:`H(t)` is. .. math::; :label: eq_td_schrodinger. 	H(t)\Psi(t) = i\hbar\frac{\partial}{\partial t}\Psi(t),. where :math:`\Psi(t)` is the wave function solution. Here we are interested in problems with periodic time-dependence, i.e., the Hamiltonian satisfies :math:`H(t) = H(t+T)` where :math:`T` is the period. According to the Floquet theorem, there exist solutions to :eq:`eq_td_schrodinger` of the form. .. math::; :label: eq_floquet_states. \Psi_\alpha(t) = \exp(-i\epsilon_\alpha t/\hbar)\Phi_\alpha(t),. where :math:`\Psi_\alpha(t)` are the *Floquet states* (i.e., the set of wave function solutions to the Schrdinger equation), :math:`\Phi",MatchSource.DOCS,doc/guide/dynamics/dynamics-floquet.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-floquet.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-floquet.rst:1701,Integrability,depend,dependent,1701,"pendent. Thus, strictly speaking, the standard forms of these master equation formalisms should not blindly be applied to system with time-dependent Hamiltonians. However, in many relevant cases, in particular for weak driving, the standard master equations still turns out to be useful for many time-dependent problems. But a more rigorous approach would be to rederive the master equation taking the time-dependent nature of the Hamiltonian into account from the start. The Floquet-Markov Master equation is one such a formalism, with important applications for strongly driven systems (see e.g., [Gri98]_). Here we give an overview of how the Floquet and Floquet-Markov formalisms can be used for solving time-dependent problems in QuTiP. To introduce the terminology and naming conventions used in QuTiP we first give a brief summary of quantum Floquet theory. .. _floquet-unitary:. Floquet theory for unitary evolution; ====================================. The Schrdinger equation with a time-dependent Hamiltonian :math:`H(t)` is. .. math::; :label: eq_td_schrodinger. 	H(t)\Psi(t) = i\hbar\frac{\partial}{\partial t}\Psi(t),. where :math:`\Psi(t)` is the wave function solution. Here we are interested in problems with periodic time-dependence, i.e., the Hamiltonian satisfies :math:`H(t) = H(t+T)` where :math:`T` is the period. According to the Floquet theorem, there exist solutions to :eq:`eq_td_schrodinger` of the form. .. math::; :label: eq_floquet_states. \Psi_\alpha(t) = \exp(-i\epsilon_\alpha t/\hbar)\Phi_\alpha(t),. where :math:`\Psi_\alpha(t)` are the *Floquet states* (i.e., the set of wave function solutions to the Schrdinger equation), :math:`\Phi_\alpha(t)=\Phi_\alpha(t+T)` are the periodic *Floquet modes*, and :math:`\epsilon_\alpha` are the *quasienergy levels*. The quasienergy levels are constants in time, but only uniquely defined up to multiples of :math:`2\pi/T` (i.e., unique value in the interval :math:`[0, 2\pi/T]`). If we know the Floquet modes (for :math:",MatchSource.DOCS,doc/guide/dynamics/dynamics-floquet.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-floquet.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-floquet.rst:1943,Integrability,depend,dependence,1943,"iving, the standard master equations still turns out to be useful for many time-dependent problems. But a more rigorous approach would be to rederive the master equation taking the time-dependent nature of the Hamiltonian into account from the start. The Floquet-Markov Master equation is one such a formalism, with important applications for strongly driven systems (see e.g., [Gri98]_). Here we give an overview of how the Floquet and Floquet-Markov formalisms can be used for solving time-dependent problems in QuTiP. To introduce the terminology and naming conventions used in QuTiP we first give a brief summary of quantum Floquet theory. .. _floquet-unitary:. Floquet theory for unitary evolution; ====================================. The Schrdinger equation with a time-dependent Hamiltonian :math:`H(t)` is. .. math::; :label: eq_td_schrodinger. 	H(t)\Psi(t) = i\hbar\frac{\partial}{\partial t}\Psi(t),. where :math:`\Psi(t)` is the wave function solution. Here we are interested in problems with periodic time-dependence, i.e., the Hamiltonian satisfies :math:`H(t) = H(t+T)` where :math:`T` is the period. According to the Floquet theorem, there exist solutions to :eq:`eq_td_schrodinger` of the form. .. math::; :label: eq_floquet_states. \Psi_\alpha(t) = \exp(-i\epsilon_\alpha t/\hbar)\Phi_\alpha(t),. where :math:`\Psi_\alpha(t)` are the *Floquet states* (i.e., the set of wave function solutions to the Schrdinger equation), :math:`\Phi_\alpha(t)=\Phi_\alpha(t+T)` are the periodic *Floquet modes*, and :math:`\epsilon_\alpha` are the *quasienergy levels*. The quasienergy levels are constants in time, but only uniquely defined up to multiples of :math:`2\pi/T` (i.e., unique value in the interval :math:`[0, 2\pi/T]`). If we know the Floquet modes (for :math:`t \in [0,T]`) and the quasienergies for a particular :math:`H(t)`, we can easily decompose any initial wavefunction :math:`\Psi(t=0)` in the Floquet states and immediately obtain the solution for arbitrary :math:`t`. .. m",MatchSource.DOCS,doc/guide/dynamics/dynamics-floquet.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-floquet.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-floquet.rst:4069,Integrability,depend,dependent,4069,"re the coefficients :math:`c_\alpha` are determined by the initial wavefunction :math:`\Psi(0) = \sum_\alpha c_\alpha \Psi_\alpha(0)`. This formalism is useful for finding :math:`\Psi(t)` for a given :math:`H(t)` only if we can obtain the Floquet modes :math:`\Phi_a(t)` and quasienergies :math:`\epsilon_\alpha` more easily than directly solving :eq:`eq_td_schrodinger`. By substituting :eq:`eq_floquet_states` into the Schrdinger equation :eq:`eq_td_schrodinger` we obtain an eigenvalue equation for the Floquet modes and quasienergies. .. math::; :label: eq_floquet_eigen_problem. \mathcal{H}(t)\Phi_\alpha(t) = \epsilon_\alpha\Phi_\alpha(t),. where :math:`\mathcal{H}(t) = H(t) - i\hbar\partial_t`. This eigenvalue problem could be solved analytically or numerically, but in QuTiP we use an alternative approach for numerically finding the Floquet states and quasienergies [see e.g. Creffield et al., Phys. Rev. B 67, 165301 (2003)]. Consider the propagator for the time-dependent Schrdinger equation :eq:`eq_td_schrodinger`, which by definition satisfies. .. math::. U(T+t,t)\Psi(t) = \Psi(T+t). Inserting the Floquet states from :eq:`eq_floquet_states` into this expression results in. .. math::; U(T+t,t)\exp(-i\epsilon_\alpha t/\hbar)\Phi_\alpha(t) = \exp(-i\epsilon_\alpha(T+t)/\hbar)\Phi_\alpha(T+t),. or, since :math:`\Phi_\alpha(T+t)=\Phi_\alpha(t)`,. .. math::; U(T+t,t)\Phi_\alpha(t) = \exp(-i\epsilon_\alpha T/\hbar)\Phi_\alpha(t) = \eta_\alpha \Phi_\alpha(t),. which shows that the Floquet modes are eigenstates of the one-period propagator. We can therefore find the Floquet modes and quasienergies :math:`\epsilon_\alpha = -\hbar\arg(\eta_\alpha)/T` by numerically calculating :math:`U(T+t,t)` and diagonalizing it. In particular this method is useful to find :math:`\Phi_\alpha(0)` by calculating and diagonalize :math:`U(T,0)`. The Floquet modes at arbitrary time :math:`t` can then be found by propagating :math:`\Phi_\alpha(0)` to :math:`\Phi_\alpha(t)` using the wave functio",MatchSource.DOCS,doc/guide/dynamics/dynamics-floquet.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-floquet.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-floquet.rst:5810,Integrability,depend,dependent,5810,"agonalizing it. In particular this method is useful to find :math:`\Phi_\alpha(0)` by calculating and diagonalize :math:`U(T,0)`. The Floquet modes at arbitrary time :math:`t` can then be found by propagating :math:`\Phi_\alpha(0)` to :math:`\Phi_\alpha(t)` using the wave function propagator :math:`U(t,0)\Psi_\alpha(0) = \Psi_\alpha(t)`, which for the Floquet modes yields. .. math::. U(t,0)\Phi_\alpha(0) = \exp(-i\epsilon_\alpha t/\hbar)\Phi_\alpha(t),. so that :math:`\Phi_\alpha(t) = \exp(i\epsilon_\alpha t/\hbar) U(t,0)\Phi_\alpha(0)`. Since :math:`\Phi_\alpha(t)` is periodic we only need to evaluate it for :math:`t \in [0, T]`, and from :math:`\Phi_\alpha(t \in [0,T])` we can directly evaluate :math:`\Phi_\alpha(t)`, :math:`\Psi_\alpha(t)` and :math:`\Psi(t)` for arbitrary large :math:`t`. Floquet formalism in QuTiP; --------------------------. QuTiP provides a family of functions to calculate the Floquet modes and quasi energies,; Floquet state decomposition, etc., given a time-dependent Hamiltonian. Consider for example the case of a strongly driven two-level atom, described by the Hamiltonian. .. math::; :label: eq_driven_qubit. H(t) = -\frac{1}{2}\Delta\sigma_x - \frac{1}{2}\epsilon_0\sigma_z + \frac{1}{2}A\sin(\omega t)\sigma_z. In QuTiP we can define this Hamiltonian as follows:. .. code-block:: python. >>> delta = 0.2 * 2*np.pi; >>> eps0 = 1.0 * 2*np.pi; >>> A = 2.5 * 2*np.pi; >>> omega = 1.0 * 2*np.pi; >>> H0 = - delta/2.0 * sigmax() - eps0/2.0 * sigmaz(); >>> H1 = A/2.0 * sigmaz(); >>> args = {'w': omega}; >>> H = [H0, [H1, 'sin(w * t)']]. The :math:`t=0` Floquet modes corresponding to the Hamiltonian :eq:`eq_driven_qubit`; can then be calculated using the :class:`.FloquetBasis` class, which encapsulates; the Floquet modes and the quasienergies:. .. code-block:: python. >>> T = 2*np.pi / omega; >>> floquet_basis = FloquetBasis(H, T, args); >>> f_energies = floquet_basis.e_quasi; >>> f_energies # doctest: +NORMALIZE_WHITESPACE; array([-2.83131212, 2.831312",MatchSource.DOCS,doc/guide/dynamics/dynamics-floquet.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-floquet.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-floquet.rst:12064,Integrability,depend,dependent,12064,"strates how the example from the previous section can be; solved more efficiently using these functions for pre-computing the Floquet modes:. .. plot:: guide/scripts/floquet_ex2.py; :width: 4.0in; :include-source:. Note that the parameters and the Hamiltonian used in this example is not the same as; in the previous section, and hence the different appearance of the resulting figure. For convenience, all the steps described above for calculating the evolution of a; quantum system using the Floquet formalisms are encapsulated in the function :func:`.fsesolve`.; Using this function, we could have achieved the same results as in the examples above using. .. code-block:: python. output = fsesolve(H, psi0=psi0, tlist=tlist, e_ops=[qutip.num(2)], args=args); p_ex = output.expect[0]. .. _floquet-dissipative:. Floquet theory for dissipative evolution; ========================================. A driven system that is interacting with its environment is not necessarily well; described by the standard Lindblad master equation, since its dissipation process; could be time-dependent due to the driving. In such cases a rigorious approach would; be to take the driving into account when deriving the master equation. This can be; done in many different ways, but one way common approach is to derive the master; equation in the Floquet basis. That approach results in the so-called Floquet-Markov; master equation, see Grifoni et al., Physics Reports 304, 299 (1998) for details. For a brief summary of the derivation, the important contents for the implementation; in QuTiP are listed below. The floquet mode :math:`\ket{\phi_\alpha(t)}` refers to a full class of quasienergies; defined by :math:`\epsilon_\alpha + k \Omega` for arbitrary :math:`k`. Hence, the; quasienenergy difference between two floquet modes is given by. .. math::; \Delta_{\alpha \beta k} = \frac{\epsilon_\alpha - \epsilon_\beta}{\hbar} + k \Omega. For any coupling operator :math:`q` (given by the user) the matrix elements ",MatchSource.DOCS,doc/guide/dynamics/dynamics-floquet.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-floquet.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-floquet.rst:14224,Integrability,depend,dependent,14224,".. math::; \gamma_{\alpha \beta k} = 2 \pi J(\Delta_{\alpha \beta k}) | X_{\alpha \beta k}|^2. The master equation is further simplified by the RWA, which makes the following matrix useful:. .. math::; A_{\alpha \beta} = \sum_{k = -\infty}^\infty [\gamma_{\alpha \beta k} + n_{th}(|\Delta_{\alpha \beta k}|)(\gamma_{\alpha \beta k} + \gamma_{\alpha \beta -k}). The density matrix of the system then evolves according to:. .. math::; \dot{\rho}_{\alpha \alpha}(t) = \sum_\nu (A_{\alpha \nu} \rho_{\nu \nu}(t) - A_{\nu \alpha} \rho_{\alpha \alpha} (t)). .. math::; \dot{\rho}_{\alpha \beta}(t) = -\frac{1}{2} \sum_\nu (A_{\nu \alpha} + A_{\nu \beta}) \rho_{\alpha \beta}(t) \qquad \alpha \neq \beta. The Floquet-Markov master equation in QuTiP; -------------------------------------------. The QuTiP function :func:`.fmmesolve` implements the Floquet-Markov master equation.; It calculates the dynamics of a system given its initial state, a time-dependent; Hamiltonian, a list of operators through which the system couples to its environment; and a list of corresponding spectral-density functions that describes the environment.; In contrast to the :func:`.mesolve` and :func:`.mcsolve`, and the :func:`.fmmesolve`; does characterize the environment with dissipation rates, but extract the strength; of the coupling to the environment from the noise spectral-density functions and; the instantaneous Hamiltonian parameters (similar to the Bloch-Redfield master; equation solver :func:`.brmesolve`). .. note::. Currently the :func:`.fmmesolve` can only accept a single environment coupling; operator and spectral-density function. The noise spectral-density function of the environment is implemented as a Python; callback function that is passed to the solver. For example:. .. code-block:: python. gamma1 = 0.1; def noise_spectrum(omega):; return (omega>0) * 0.5 * gamma1 * omega/(2*pi). The other parameters are similar to the :func:`.mesolve` and :func:`.mcsolve`,; and the same format for the ret",MatchSource.DOCS,doc/guide/dynamics/dynamics-floquet.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-floquet.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-floquet.rst:12921,Modifiability,coupling,coupling,12921,"ribed by the standard Lindblad master equation, since its dissipation process; could be time-dependent due to the driving. In such cases a rigorious approach would; be to take the driving into account when deriving the master equation. This can be; done in many different ways, but one way common approach is to derive the master; equation in the Floquet basis. That approach results in the so-called Floquet-Markov; master equation, see Grifoni et al., Physics Reports 304, 299 (1998) for details. For a brief summary of the derivation, the important contents for the implementation; in QuTiP are listed below. The floquet mode :math:`\ket{\phi_\alpha(t)}` refers to a full class of quasienergies; defined by :math:`\epsilon_\alpha + k \Omega` for arbitrary :math:`k`. Hence, the; quasienenergy difference between two floquet modes is given by. .. math::; \Delta_{\alpha \beta k} = \frac{\epsilon_\alpha - \epsilon_\beta}{\hbar} + k \Omega. For any coupling operator :math:`q` (given by the user) the matrix elements in; the floquet basis are calculated as:. .. math::; X_{\alpha \beta k} = \frac{1}{T} \int_0^T dt \; e^{-ik \Omega t} \bra{\phi_\alpha(t)}q\ket{\phi_\beta(t)}. From the matrix elements and the spectral density :math:`J(\omega)`, the decay; rate :math:`\gamma_{\alpha \beta k}` is defined:. .. math::; \gamma_{\alpha \beta k} = 2 \pi J(\Delta_{\alpha \beta k}) | X_{\alpha \beta k}|^2. The master equation is further simplified by the RWA, which makes the following matrix useful:. .. math::; A_{\alpha \beta} = \sum_{k = -\infty}^\infty [\gamma_{\alpha \beta k} + n_{th}(|\Delta_{\alpha \beta k}|)(\gamma_{\alpha \beta k} + \gamma_{\alpha \beta -k}). The density matrix of the system then evolves according to:. .. math::; \dot{\rho}_{\alpha \alpha}(t) = \sum_\nu (A_{\alpha \nu} \rho_{\nu \nu}(t) - A_{\nu \alpha} \rho_{\alpha \alpha} (t)). .. math::; \dot{\rho}_{\alpha \beta}(t) = -\frac{1}{2} \sum_\nu (A_{\nu \alpha} + A_{\nu \beta}) \rho_{\alpha \beta}(t) \qquad \alpha \neq \",MatchSource.DOCS,doc/guide/dynamics/dynamics-floquet.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-floquet.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-floquet.rst:13678,Modifiability,evolve,evolves,13678," defined by :math:`\epsilon_\alpha + k \Omega` for arbitrary :math:`k`. Hence, the; quasienenergy difference between two floquet modes is given by. .. math::; \Delta_{\alpha \beta k} = \frac{\epsilon_\alpha - \epsilon_\beta}{\hbar} + k \Omega. For any coupling operator :math:`q` (given by the user) the matrix elements in; the floquet basis are calculated as:. .. math::; X_{\alpha \beta k} = \frac{1}{T} \int_0^T dt \; e^{-ik \Omega t} \bra{\phi_\alpha(t)}q\ket{\phi_\beta(t)}. From the matrix elements and the spectral density :math:`J(\omega)`, the decay; rate :math:`\gamma_{\alpha \beta k}` is defined:. .. math::; \gamma_{\alpha \beta k} = 2 \pi J(\Delta_{\alpha \beta k}) | X_{\alpha \beta k}|^2. The master equation is further simplified by the RWA, which makes the following matrix useful:. .. math::; A_{\alpha \beta} = \sum_{k = -\infty}^\infty [\gamma_{\alpha \beta k} + n_{th}(|\Delta_{\alpha \beta k}|)(\gamma_{\alpha \beta k} + \gamma_{\alpha \beta -k}). The density matrix of the system then evolves according to:. .. math::; \dot{\rho}_{\alpha \alpha}(t) = \sum_\nu (A_{\alpha \nu} \rho_{\nu \nu}(t) - A_{\nu \alpha} \rho_{\alpha \alpha} (t)). .. math::; \dot{\rho}_{\alpha \beta}(t) = -\frac{1}{2} \sum_\nu (A_{\nu \alpha} + A_{\nu \beta}) \rho_{\alpha \beta}(t) \qquad \alpha \neq \beta. The Floquet-Markov master equation in QuTiP; -------------------------------------------. The QuTiP function :func:`.fmmesolve` implements the Floquet-Markov master equation.; It calculates the dynamics of a system given its initial state, a time-dependent; Hamiltonian, a list of operators through which the system couples to its environment; and a list of corresponding spectral-density functions that describes the environment.; In contrast to the :func:`.mesolve` and :func:`.mcsolve`, and the :func:`.fmmesolve`; does characterize the environment with dissipation rates, but extract the strength; of the coupling to the environment from the noise spectral-density functions and; the insta",MatchSource.DOCS,doc/guide/dynamics/dynamics-floquet.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-floquet.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-floquet.rst:14586,Modifiability,coupling,coupling,14586,"pha \beta -k}). The density matrix of the system then evolves according to:. .. math::; \dot{\rho}_{\alpha \alpha}(t) = \sum_\nu (A_{\alpha \nu} \rho_{\nu \nu}(t) - A_{\nu \alpha} \rho_{\alpha \alpha} (t)). .. math::; \dot{\rho}_{\alpha \beta}(t) = -\frac{1}{2} \sum_\nu (A_{\nu \alpha} + A_{\nu \beta}) \rho_{\alpha \beta}(t) \qquad \alpha \neq \beta. The Floquet-Markov master equation in QuTiP; -------------------------------------------. The QuTiP function :func:`.fmmesolve` implements the Floquet-Markov master equation.; It calculates the dynamics of a system given its initial state, a time-dependent; Hamiltonian, a list of operators through which the system couples to its environment; and a list of corresponding spectral-density functions that describes the environment.; In contrast to the :func:`.mesolve` and :func:`.mcsolve`, and the :func:`.fmmesolve`; does characterize the environment with dissipation rates, but extract the strength; of the coupling to the environment from the noise spectral-density functions and; the instantaneous Hamiltonian parameters (similar to the Bloch-Redfield master; equation solver :func:`.brmesolve`). .. note::. Currently the :func:`.fmmesolve` can only accept a single environment coupling; operator and spectral-density function. The noise spectral-density function of the environment is implemented as a Python; callback function that is passed to the solver. For example:. .. code-block:: python. gamma1 = 0.1; def noise_spectrum(omega):; return (omega>0) * 0.5 * gamma1 * omega/(2*pi). The other parameters are similar to the :func:`.mesolve` and :func:`.mcsolve`,; and the same format for the return value is used :class:`.Result`.; The following example extends the example studied above, and uses :func:`.fmmesolve`; to introduce dissipation into the calculation. .. plot:: guide/scripts/floquet_ex3.py; :width: 4.0in; :include-source:. Finally, :func:`.fmmesolve` always expects the ``e_ops`` to; be specified in the laboratory basis (as ",MatchSource.DOCS,doc/guide/dynamics/dynamics-floquet.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-floquet.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-floquet.rst:14859,Modifiability,coupling,coupling,14859,"a \beta}(t) = -\frac{1}{2} \sum_\nu (A_{\nu \alpha} + A_{\nu \beta}) \rho_{\alpha \beta}(t) \qquad \alpha \neq \beta. The Floquet-Markov master equation in QuTiP; -------------------------------------------. The QuTiP function :func:`.fmmesolve` implements the Floquet-Markov master equation.; It calculates the dynamics of a system given its initial state, a time-dependent; Hamiltonian, a list of operators through which the system couples to its environment; and a list of corresponding spectral-density functions that describes the environment.; In contrast to the :func:`.mesolve` and :func:`.mcsolve`, and the :func:`.fmmesolve`; does characterize the environment with dissipation rates, but extract the strength; of the coupling to the environment from the noise spectral-density functions and; the instantaneous Hamiltonian parameters (similar to the Bloch-Redfield master; equation solver :func:`.brmesolve`). .. note::. Currently the :func:`.fmmesolve` can only accept a single environment coupling; operator and spectral-density function. The noise spectral-density function of the environment is implemented as a Python; callback function that is passed to the solver. For example:. .. code-block:: python. gamma1 = 0.1; def noise_spectrum(omega):; return (omega>0) * 0.5 * gamma1 * omega/(2*pi). The other parameters are similar to the :func:`.mesolve` and :func:`.mcsolve`,; and the same format for the return value is used :class:`.Result`.; The following example extends the example studied above, and uses :func:`.fmmesolve`; to introduce dissipation into the calculation. .. plot:: guide/scripts/floquet_ex3.py; :width: 4.0in; :include-source:. Finally, :func:`.fmmesolve` always expects the ``e_ops`` to; be specified in the laboratory basis (as for other solvers) and we can calculate; expectation values using:. .. code-block:: python. output = fmmesolve(H, psi0, tlist, [sigmax()], e_ops=[num(2)],; spectra_cb=[noise_spectrum], T=T, args=args); p_ex = output.expect[0]. .. plot::",MatchSource.DOCS,doc/guide/dynamics/dynamics-floquet.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-floquet.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-floquet.rst:15338,Modifiability,extend,extends,15338,"A_{\nu \beta}) \rho_{\alpha \beta}(t) \qquad \alpha \neq \beta. The Floquet-Markov master equation in QuTiP; -------------------------------------------. The QuTiP function :func:`.fmmesolve` implements the Floquet-Markov master equation.; It calculates the dynamics of a system given its initial state, a time-dependent; Hamiltonian, a list of operators through which the system couples to its environment; and a list of corresponding spectral-density functions that describes the environment.; In contrast to the :func:`.mesolve` and :func:`.mcsolve`, and the :func:`.fmmesolve`; does characterize the environment with dissipation rates, but extract the strength; of the coupling to the environment from the noise spectral-density functions and; the instantaneous Hamiltonian parameters (similar to the Bloch-Redfield master; equation solver :func:`.brmesolve`). .. note::. Currently the :func:`.fmmesolve` can only accept a single environment coupling; operator and spectral-density function. The noise spectral-density function of the environment is implemented as a Python; callback function that is passed to the solver. For example:. .. code-block:: python. gamma1 = 0.1; def noise_spectrum(omega):; return (omega>0) * 0.5 * gamma1 * omega/(2*pi). The other parameters are similar to the :func:`.mesolve` and :func:`.mcsolve`,; and the same format for the return value is used :class:`.Result`.; The following example extends the example studied above, and uses :func:`.fmmesolve`; to introduce dissipation into the calculation. .. plot:: guide/scripts/floquet_ex3.py; :width: 4.0in; :include-source:. Finally, :func:`.fmmesolve` always expects the ``e_ops`` to; be specified in the laboratory basis (as for other solvers) and we can calculate; expectation values using:. .. code-block:: python. output = fmmesolve(H, psi0, tlist, [sigmax()], e_ops=[num(2)],; spectra_cb=[noise_spectrum], T=T, args=args); p_ex = output.expect[0]. .. plot::; :context: reset; :include-source: false; :nofigs:; ",MatchSource.DOCS,doc/guide/dynamics/dynamics-floquet.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-floquet.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-floquet.rst:10327,Usability,guid,guide,10327," original problem :eq:`eq_driven_qubit` given some initial state :math:`\left|\psi_0\right>`.; To do that, we first need to decompose the initial state in the Floquet states,; using the function :meth:`.FloquetBasis.to_floquet_basis`. .. plot::; :context: close-figs. >>> psi0 = rand_ket(2); >>> f_coeff = floquet_basis.to_floquet_basis(psi0); >>> f_coeff # doctest: +SKIP; [(-0.645265993068382+0.7304552549315746j),; (0.15517002114250228-0.1612116102238258j)]. and given this decomposition of the initial state in the Floquet states we can easily; evaluate the wavefunction that is the solution to :eq:`eq_driven_qubit` at an arbitrary; time :math:`t` using the function :meth:`.FloquetBasis.from_floquet_basis`:. .. plot::; :context: close-figs. >>> t = 10 * np.random.rand(); >>> psi_t = floquet_basis.from_floquet_basis(f_coeff, t). The following example illustrates how to use the functions introduced above to calculate; and plot the time-evolution of :eq:`eq_driven_qubit`. .. plot:: guide/scripts/floquet_ex1.py; :width: 4.0in; :include-source:. Pre-computing the Floquet modes for one period; ----------------------------------------------. When evaluating the Floquet states or the wavefunction at many points in time it; is useful to pre-compute the Floquet modes for the first period of the driving with; the required times. The list of times to pre-compute modes for may be passed to; :class:`.FloquetBasis` using ``precompute=tlist``, and then; :meth:`.FloquetBasis.from_floquet_basis` and :meth:`.FloquetBasis.to_floquet_basis`; can be used to efficiently retrieve the wave function at the pre-computed times.; The following example illustrates how the example from the previous section can be; solved more efficiently using these functions for pre-computing the Floquet modes:. .. plot:: guide/scripts/floquet_ex2.py; :width: 4.0in; :include-source:. Note that the parameters and the Hamiltonian used in this example is not the same as; in the previous section, and hence the differen",MatchSource.DOCS,doc/guide/dynamics/dynamics-floquet.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-floquet.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-floquet.rst:11140,Usability,guid,guide,11140,"quet_basis(f_coeff, t). The following example illustrates how to use the functions introduced above to calculate; and plot the time-evolution of :eq:`eq_driven_qubit`. .. plot:: guide/scripts/floquet_ex1.py; :width: 4.0in; :include-source:. Pre-computing the Floquet modes for one period; ----------------------------------------------. When evaluating the Floquet states or the wavefunction at many points in time it; is useful to pre-compute the Floquet modes for the first period of the driving with; the required times. The list of times to pre-compute modes for may be passed to; :class:`.FloquetBasis` using ``precompute=tlist``, and then; :meth:`.FloquetBasis.from_floquet_basis` and :meth:`.FloquetBasis.to_floquet_basis`; can be used to efficiently retrieve the wave function at the pre-computed times.; The following example illustrates how the example from the previous section can be; solved more efficiently using these functions for pre-computing the Floquet modes:. .. plot:: guide/scripts/floquet_ex2.py; :width: 4.0in; :include-source:. Note that the parameters and the Hamiltonian used in this example is not the same as; in the previous section, and hence the different appearance of the resulting figure. For convenience, all the steps described above for calculating the evolution of a; quantum system using the Floquet formalisms are encapsulated in the function :func:`.fsesolve`.; Using this function, we could have achieved the same results as in the examples above using. .. code-block:: python. output = fsesolve(H, psi0=psi0, tlist=tlist, e_ops=[qutip.num(2)], args=args); p_ex = output.expect[0]. .. _floquet-dissipative:. Floquet theory for dissipative evolution; ========================================. A driven system that is interacting with its environment is not necessarily well; described by the standard Lindblad master equation, since its dissipation process; could be time-dependent due to the driving. In such cases a rigorious approach would; be to take th",MatchSource.DOCS,doc/guide/dynamics/dynamics-floquet.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-floquet.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-floquet.rst:13405,Usability,simpl,simplified,13405,"l., Physics Reports 304, 299 (1998) for details. For a brief summary of the derivation, the important contents for the implementation; in QuTiP are listed below. The floquet mode :math:`\ket{\phi_\alpha(t)}` refers to a full class of quasienergies; defined by :math:`\epsilon_\alpha + k \Omega` for arbitrary :math:`k`. Hence, the; quasienenergy difference between two floquet modes is given by. .. math::; \Delta_{\alpha \beta k} = \frac{\epsilon_\alpha - \epsilon_\beta}{\hbar} + k \Omega. For any coupling operator :math:`q` (given by the user) the matrix elements in; the floquet basis are calculated as:. .. math::; X_{\alpha \beta k} = \frac{1}{T} \int_0^T dt \; e^{-ik \Omega t} \bra{\phi_\alpha(t)}q\ket{\phi_\beta(t)}. From the matrix elements and the spectral density :math:`J(\omega)`, the decay; rate :math:`\gamma_{\alpha \beta k}` is defined:. .. math::; \gamma_{\alpha \beta k} = 2 \pi J(\Delta_{\alpha \beta k}) | X_{\alpha \beta k}|^2. The master equation is further simplified by the RWA, which makes the following matrix useful:. .. math::; A_{\alpha \beta} = \sum_{k = -\infty}^\infty [\gamma_{\alpha \beta k} + n_{th}(|\Delta_{\alpha \beta k}|)(\gamma_{\alpha \beta k} + \gamma_{\alpha \beta -k}). The density matrix of the system then evolves according to:. .. math::; \dot{\rho}_{\alpha \alpha}(t) = \sum_\nu (A_{\alpha \nu} \rho_{\nu \nu}(t) - A_{\nu \alpha} \rho_{\alpha \alpha} (t)). .. math::; \dot{\rho}_{\alpha \beta}(t) = -\frac{1}{2} \sum_\nu (A_{\nu \alpha} + A_{\nu \beta}) \rho_{\alpha \beta}(t) \qquad \alpha \neq \beta. The Floquet-Markov master equation in QuTiP; -------------------------------------------. The QuTiP function :func:`.fmmesolve` implements the Floquet-Markov master equation.; It calculates the dynamics of a system given its initial state, a time-dependent; Hamiltonian, a list of operators through which the system couples to its environment; and a list of corresponding spectral-density functions that describes the environment.; In contrast ",MatchSource.DOCS,doc/guide/dynamics/dynamics-floquet.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-floquet.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-floquet.rst:15459,Usability,guid,guide,15459,"A_{\nu \beta}) \rho_{\alpha \beta}(t) \qquad \alpha \neq \beta. The Floquet-Markov master equation in QuTiP; -------------------------------------------. The QuTiP function :func:`.fmmesolve` implements the Floquet-Markov master equation.; It calculates the dynamics of a system given its initial state, a time-dependent; Hamiltonian, a list of operators through which the system couples to its environment; and a list of corresponding spectral-density functions that describes the environment.; In contrast to the :func:`.mesolve` and :func:`.mcsolve`, and the :func:`.fmmesolve`; does characterize the environment with dissipation rates, but extract the strength; of the coupling to the environment from the noise spectral-density functions and; the instantaneous Hamiltonian parameters (similar to the Bloch-Redfield master; equation solver :func:`.brmesolve`). .. note::. Currently the :func:`.fmmesolve` can only accept a single environment coupling; operator and spectral-density function. The noise spectral-density function of the environment is implemented as a Python; callback function that is passed to the solver. For example:. .. code-block:: python. gamma1 = 0.1; def noise_spectrum(omega):; return (omega>0) * 0.5 * gamma1 * omega/(2*pi). The other parameters are similar to the :func:`.mesolve` and :func:`.mcsolve`,; and the same format for the return value is used :class:`.Result`.; The following example extends the example studied above, and uses :func:`.fmmesolve`; to introduce dissipation into the calculation. .. plot:: guide/scripts/floquet_ex3.py; :width: 4.0in; :include-source:. Finally, :func:`.fmmesolve` always expects the ``e_ops`` to; be specified in the laboratory basis (as for other solvers) and we can calculate; expectation values using:. .. code-block:: python. output = fmmesolve(H, psi0, tlist, [sigmax()], e_ops=[num(2)],; spectra_cb=[noise_spectrum], T=T, args=args); p_ex = output.expect[0]. .. plot::; :context: reset; :include-source: false; :nofigs:; ",MatchSource.DOCS,doc/guide/dynamics/dynamics-floquet.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-floquet.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-intro.rst:232,Modifiability,evolve,evolves,232,".. _intro:. ************; Introduction; ************. Although in some cases, we want to find the stationary states of; a quantum system, often we are interested in the dynamics:; how the state of a system or an ensemble of systems evolves with time.; QuTiP provides many ways to model dynamics. There are two kinds of quantum systems: open systems that interact; with a larger environment and closed systems that do not.; In a closed system, the state can be described by a state vector.; When we are modeling an open system, or an ensemble of systems,; the use of the density matrix is mandatory. The following table lists of the solvers QuTiP provides for dynamic; quantum systems and indicates the type of object returned by the solver:. .. list-table:: QuTiP Solvers; :widths: 50 25 25 25; :header-rows: 1. * - Equation; - Function; - Class; - Returns; * - Unitary evolution, Schrdinger equation.; - :func:`~qutip.solver.sesolve.sesolve`; - :obj:`~qutip.solver.sesolve.SESolver`; - :obj:`~qutip.solver.result.Result`; * - Periodic Schrdinger equation.; - :func:`~qutip.solver.floquet.fsesolve`; - None; - :obj:`~qutip.solver.result.Result`; * - Schrdinger equation using Krylov method; - :func:`~qutip.solver.krylovsolve.krylovsolve`; - None; - :obj:`~qutip.solver.result.Result`; * - Lindblad master eqn. or Von Neuman eqn.; - :func:`~qutip.solver.mesolve.mesolve`; - :obj:`~qutip.solver.mesolve.MESolver`; - :obj:`~qutip.solver.result.Result`; * - Monte Carlo evolution; - :func:`~qutip.solver.mcsolve.mcsolve`; - :obj:`~qutip.solver.mcsolve.MCSolver`; - :obj:`~qutip.solver.result.McResult`; * - Non-Markovian Monte Carlo; - :func:`~qutip.solver.nm_mcsolve.nm_mcsolve`; - :obj:`~qutip.solver.nm_mcsolve.NonMarkovianMCSolver`; - :obj:`~qutip.solver.result.NmmcResult`; * - Bloch-Redfield master equation; - :func:`~qutip.solver.mesolve.brmesolve`; - :obj:`~qutip.solver.mesolve.BRSolver`; - :obj:`~qutip.solver.result.Result`; * - Floquet-Markov master equation; - :func:`~qutip.solver.floqu",MatchSource.DOCS,doc/guide/dynamics/dynamics-intro.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-intro.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-krylov.rst:2007,Availability,error,error,2007,"ly for the last; two vectors in the basis. Written in this basis the time-evolved state can be approximated as. .. math::; 	:label: lanczoskrylov. 	|\psi(t)\rangle=e^{-iHt}|\psi\rangle\approx\mathbb{P}_{N}e^{-iHt}\mathbb{P}_{N}|\psi\rangle=\mathbb{V}_{N}^{\dagger}e^{-iT_{N}t}\mathbb{V}_{N}|\psi\rangle\equiv\left|\psi_{N}(t)\right\rangle,. where :math:`T_{N}=\mathbb{V}_{N} H \mathbb{V}_{N}^{\dagger}` is the Hamiltonian; reduced to the Krylov subspace (which takes a tridiagonal matrix form), and; :math:`\mathbb{V}_{N}^{\dagger}` is the matrix containing the vectors of the; Krylov basis as columns. With the above approximation, the time-evolution is calculated only with a; smaller square matrix of the desired size. Therefore, the Krylov method provides; huge speed-ups in computation of short-time evolutions when the dimension of the; Hamiltonian is very large, a point at which exact calculations on the complete; subspace are practically impossible. One of the biggest problems with this type of method is the control of the error.; After a short time, the error starts to grow exponentially. However, this can be; easily corrected by restarting the subspace when the error reaches a certain; threshold. Therefore, a series of :math:`M` Krylov-subspace time evolutions; provides accurate solutions for the complete time evolution. Within this scheme,; the magic of Krylov resides not only in its ability to capture complex time evolutions; from very large Hilbert spaces with very small dimenions :math:`M`, but also in; the computing speed-up it presents. For exceptional cases, the Lanczos algorithm might arrive at the exact evolution; of the initial state at a dimension :math:`M_{hb}<M`. This is called a happy; breakdown. For example, if a Hamiltonian has a symmetry subspace :math:`D_{\text{sim}}<M`,; then the algorithm will optimize using the value math:`M_{hb}<M`:, at which the; evolution is not only exact but also cheap. .. _krylov-qutip:. Krylov Solver in QuTiP; =============",MatchSource.DOCS,doc/guide/dynamics/dynamics-krylov.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-krylov.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-krylov.rst:2039,Availability,error,error,2039,"me-evolved state can be approximated as. .. math::; 	:label: lanczoskrylov. 	|\psi(t)\rangle=e^{-iHt}|\psi\rangle\approx\mathbb{P}_{N}e^{-iHt}\mathbb{P}_{N}|\psi\rangle=\mathbb{V}_{N}^{\dagger}e^{-iT_{N}t}\mathbb{V}_{N}|\psi\rangle\equiv\left|\psi_{N}(t)\right\rangle,. where :math:`T_{N}=\mathbb{V}_{N} H \mathbb{V}_{N}^{\dagger}` is the Hamiltonian; reduced to the Krylov subspace (which takes a tridiagonal matrix form), and; :math:`\mathbb{V}_{N}^{\dagger}` is the matrix containing the vectors of the; Krylov basis as columns. With the above approximation, the time-evolution is calculated only with a; smaller square matrix of the desired size. Therefore, the Krylov method provides; huge speed-ups in computation of short-time evolutions when the dimension of the; Hamiltonian is very large, a point at which exact calculations on the complete; subspace are practically impossible. One of the biggest problems with this type of method is the control of the error.; After a short time, the error starts to grow exponentially. However, this can be; easily corrected by restarting the subspace when the error reaches a certain; threshold. Therefore, a series of :math:`M` Krylov-subspace time evolutions; provides accurate solutions for the complete time evolution. Within this scheme,; the magic of Krylov resides not only in its ability to capture complex time evolutions; from very large Hilbert spaces with very small dimenions :math:`M`, but also in; the computing speed-up it presents. For exceptional cases, the Lanczos algorithm might arrive at the exact evolution; of the initial state at a dimension :math:`M_{hb}<M`. This is called a happy; breakdown. For example, if a Hamiltonian has a symmetry subspace :math:`D_{\text{sim}}<M`,; then the algorithm will optimize using the value math:`M_{hb}<M`:, at which the; evolution is not only exact but also cheap. .. _krylov-qutip:. Krylov Solver in QuTiP; ======================. In QuTiP, Krylov-subspace evolution is implemented as the fun",MatchSource.DOCS,doc/guide/dynamics/dynamics-krylov.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-krylov.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-krylov.rst:2150,Availability,error,error,2150,"rangle=e^{-iHt}|\psi\rangle\approx\mathbb{P}_{N}e^{-iHt}\mathbb{P}_{N}|\psi\rangle=\mathbb{V}_{N}^{\dagger}e^{-iT_{N}t}\mathbb{V}_{N}|\psi\rangle\equiv\left|\psi_{N}(t)\right\rangle,. where :math:`T_{N}=\mathbb{V}_{N} H \mathbb{V}_{N}^{\dagger}` is the Hamiltonian; reduced to the Krylov subspace (which takes a tridiagonal matrix form), and; :math:`\mathbb{V}_{N}^{\dagger}` is the matrix containing the vectors of the; Krylov basis as columns. With the above approximation, the time-evolution is calculated only with a; smaller square matrix of the desired size. Therefore, the Krylov method provides; huge speed-ups in computation of short-time evolutions when the dimension of the; Hamiltonian is very large, a point at which exact calculations on the complete; subspace are practically impossible. One of the biggest problems with this type of method is the control of the error.; After a short time, the error starts to grow exponentially. However, this can be; easily corrected by restarting the subspace when the error reaches a certain; threshold. Therefore, a series of :math:`M` Krylov-subspace time evolutions; provides accurate solutions for the complete time evolution. Within this scheme,; the magic of Krylov resides not only in its ability to capture complex time evolutions; from very large Hilbert spaces with very small dimenions :math:`M`, but also in; the computing speed-up it presents. For exceptional cases, the Lanczos algorithm might arrive at the exact evolution; of the initial state at a dimension :math:`M_{hb}<M`. This is called a happy; breakdown. For example, if a Hamiltonian has a symmetry subspace :math:`D_{\text{sim}}<M`,; then the algorithm will optimize using the value math:`M_{hb}<M`:, at which the; evolution is not only exact but also cheap. .. _krylov-qutip:. Krylov Solver in QuTiP; ======================. In QuTiP, Krylov-subspace evolution is implemented as the function :func:`.krylovsolve`.; Arguments are nearly the same as :func:`.sesolve` functio",MatchSource.DOCS,doc/guide/dynamics/dynamics-krylov.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-krylov.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-krylov.rst:1395,Energy Efficiency,reduce,reduced,1395,"ov subspace associated with that state and; Hamiltonian is given by. .. math::; 	:label: krylovsubspace. 	\mathcal{K}_{N}=\operatorname{span}\left\{|\psi\rangle, H|\psi\rangle, \ldots, H^{N-1}|\psi\rangle\right\},. where the dimension :math:`N<D` is a parameter of choice. To construct an; orthonormal basis :math:`B_N` for :math:`\mathcal{K}_{N}`, the simplest algorithm; is the well-known Lanczos algorithm, which provides a sort of Gram-Schmidt procedure; that harnesses the fact that orthonormalization needs to be imposed only for the last; two vectors in the basis. Written in this basis the time-evolved state can be approximated as. .. math::; 	:label: lanczoskrylov. 	|\psi(t)\rangle=e^{-iHt}|\psi\rangle\approx\mathbb{P}_{N}e^{-iHt}\mathbb{P}_{N}|\psi\rangle=\mathbb{V}_{N}^{\dagger}e^{-iT_{N}t}\mathbb{V}_{N}|\psi\rangle\equiv\left|\psi_{N}(t)\right\rangle,. where :math:`T_{N}=\mathbb{V}_{N} H \mathbb{V}_{N}^{\dagger}` is the Hamiltonian; reduced to the Krylov subspace (which takes a tridiagonal matrix form), and; :math:`\mathbb{V}_{N}^{\dagger}` is the matrix containing the vectors of the; Krylov basis as columns. With the above approximation, the time-evolution is calculated only with a; smaller square matrix of the desired size. Therefore, the Krylov method provides; huge speed-ups in computation of short-time evolutions when the dimension of the; Hamiltonian is very large, a point at which exact calculations on the complete; subspace are practically impossible. One of the biggest problems with this type of method is the control of the error.; After a short time, the error starts to grow exponentially. However, this can be; easily corrected by restarting the subspace when the error reaches a certain; threshold. Therefore, a series of :math:`M` Krylov-subspace time evolutions; provides accurate solutions for the complete time evolution. Within this scheme,; the magic of Krylov resides not only in its ability to capture complex time evolutions; from very large Hilbe",MatchSource.DOCS,doc/guide/dynamics/dynamics-krylov.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-krylov.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-krylov.rst:3199,Integrability,depend,depend,3199,"hen the error reaches a certain; threshold. Therefore, a series of :math:`M` Krylov-subspace time evolutions; provides accurate solutions for the complete time evolution. Within this scheme,; the magic of Krylov resides not only in its ability to capture complex time evolutions; from very large Hilbert spaces with very small dimenions :math:`M`, but also in; the computing speed-up it presents. For exceptional cases, the Lanczos algorithm might arrive at the exact evolution; of the initial state at a dimension :math:`M_{hb}<M`. This is called a happy; breakdown. For example, if a Hamiltonian has a symmetry subspace :math:`D_{\text{sim}}<M`,; then the algorithm will optimize using the value math:`M_{hb}<M`:, at which the; evolution is not only exact but also cheap. .. _krylov-qutip:. Krylov Solver in QuTiP; ======================. In QuTiP, Krylov-subspace evolution is implemented as the function :func:`.krylovsolve`.; Arguments are nearly the same as :func:`.sesolve` function for master-equation; evolution, except that the Hamiltonian cannot depend on time, the initial state; must always be a ket vector, (it cannot be used to compute propagators) and an; additional parameter ``krylov_dim`` is needed. ``krylov_dim`` defines the; maximum allowed Krylov-subspace dimension. Let's solve a simple example using the algorithm in QuTiP to get familiar with the method. .. plot::; :context: reset. >>> dim = 100; >>> jx = jmat((dim - 1) / 2.0, ""x""); >>> jy = jmat((dim - 1) / 2.0, ""y""); >>> jz = jmat((dim - 1) / 2.0, ""z""); >>> e_ops = [jx, jy, jz]; >>> H = (jz + jx) / 2; >>> psi0 = rand_ket(dim, seed=1); >>> tlist = np.linspace(0.0, 10.0, 200); >>> results = krylovsolve(H, psi0, tlist, krylov_dim=20, e_ops=e_ops); >>> plt.figure(); >>> for expect in results.expect:; >>> plt.plot(tlist, expect); >>> plt.legend(('jmat x', 'jmat y', 'jmat z')); >>> plt.xlabel('Time'); >>> plt.ylabel('Expectation values'); >>> plt.show(). .. plot::; :context: reset; :include-source: false; :nofigs:; ",MatchSource.DOCS,doc/guide/dynamics/dynamics-krylov.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-krylov.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-krylov.rst:350,Modifiability,evolve,evolves,350,".. _krylov:. *******************************************; Krylov Solver; *******************************************. .. _krylov-intro:. Introduction; =============. The Krylov-subspace method is a standard method to approximate quantum dynamics.; Let :math:`\left|\psi\right\rangle` be a state in a :math:`D`-dimensional; complex Hilbert space that evolves under a time-independent Hamiltonian :math:`H`.; Then, the :math:`N`-dimensional Krylov subspace associated with that state and; Hamiltonian is given by. .. math::; 	:label: krylovsubspace. 	\mathcal{K}_{N}=\operatorname{span}\left\{|\psi\rangle, H|\psi\rangle, \ldots, H^{N-1}|\psi\rangle\right\},. where the dimension :math:`N<D` is a parameter of choice. To construct an; orthonormal basis :math:`B_N` for :math:`\mathcal{K}_{N}`, the simplest algorithm; is the well-known Lanczos algorithm, which provides a sort of Gram-Schmidt procedure; that harnesses the fact that orthonormalization needs to be imposed only for the last; two vectors in the basis. Written in this basis the time-evolved state can be approximated as. .. math::; 	:label: lanczoskrylov. 	|\psi(t)\rangle=e^{-iHt}|\psi\rangle\approx\mathbb{P}_{N}e^{-iHt}\mathbb{P}_{N}|\psi\rangle=\mathbb{V}_{N}^{\dagger}e^{-iT_{N}t}\mathbb{V}_{N}|\psi\rangle\equiv\left|\psi_{N}(t)\right\rangle,. where :math:`T_{N}=\mathbb{V}_{N} H \mathbb{V}_{N}^{\dagger}` is the Hamiltonian; reduced to the Krylov subspace (which takes a tridiagonal matrix form), and; :math:`\mathbb{V}_{N}^{\dagger}` is the matrix containing the vectors of the; Krylov basis as columns. With the above approximation, the time-evolution is calculated only with a; smaller square matrix of the desired size. Therefore, the Krylov method provides; huge speed-ups in computation of short-time evolutions when the dimension of the; Hamiltonian is very large, a point at which exact calculations on the complete; subspace are practically impossible. One of the biggest problems with this type of method is the control o",MatchSource.DOCS,doc/guide/dynamics/dynamics-krylov.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-krylov.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-krylov.rst:1046,Modifiability,evolve,evolved,1046,"********; Krylov Solver; *******************************************. .. _krylov-intro:. Introduction; =============. The Krylov-subspace method is a standard method to approximate quantum dynamics.; Let :math:`\left|\psi\right\rangle` be a state in a :math:`D`-dimensional; complex Hilbert space that evolves under a time-independent Hamiltonian :math:`H`.; Then, the :math:`N`-dimensional Krylov subspace associated with that state and; Hamiltonian is given by. .. math::; 	:label: krylovsubspace. 	\mathcal{K}_{N}=\operatorname{span}\left\{|\psi\rangle, H|\psi\rangle, \ldots, H^{N-1}|\psi\rangle\right\},. where the dimension :math:`N<D` is a parameter of choice. To construct an; orthonormal basis :math:`B_N` for :math:`\mathcal{K}_{N}`, the simplest algorithm; is the well-known Lanczos algorithm, which provides a sort of Gram-Schmidt procedure; that harnesses the fact that orthonormalization needs to be imposed only for the last; two vectors in the basis. Written in this basis the time-evolved state can be approximated as. .. math::; 	:label: lanczoskrylov. 	|\psi(t)\rangle=e^{-iHt}|\psi\rangle\approx\mathbb{P}_{N}e^{-iHt}\mathbb{P}_{N}|\psi\rangle=\mathbb{V}_{N}^{\dagger}e^{-iT_{N}t}\mathbb{V}_{N}|\psi\rangle\equiv\left|\psi_{N}(t)\right\rangle,. where :math:`T_{N}=\mathbb{V}_{N} H \mathbb{V}_{N}^{\dagger}` is the Hamiltonian; reduced to the Krylov subspace (which takes a tridiagonal matrix form), and; :math:`\mathbb{V}_{N}^{\dagger}` is the matrix containing the vectors of the; Krylov basis as columns. With the above approximation, the time-evolution is calculated only with a; smaller square matrix of the desired size. Therefore, the Krylov method provides; huge speed-ups in computation of short-time evolutions when the dimension of the; Hamiltonian is very large, a point at which exact calculations on the complete; subspace are practically impossible. One of the biggest problems with this type of method is the control of the error.; After a short time, the error star",MatchSource.DOCS,doc/guide/dynamics/dynamics-krylov.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-krylov.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-krylov.rst:2815,Performance,optimiz,optimize,2815,"e; Hamiltonian is very large, a point at which exact calculations on the complete; subspace are practically impossible. One of the biggest problems with this type of method is the control of the error.; After a short time, the error starts to grow exponentially. However, this can be; easily corrected by restarting the subspace when the error reaches a certain; threshold. Therefore, a series of :math:`M` Krylov-subspace time evolutions; provides accurate solutions for the complete time evolution. Within this scheme,; the magic of Krylov resides not only in its ability to capture complex time evolutions; from very large Hilbert spaces with very small dimenions :math:`M`, but also in; the computing speed-up it presents. For exceptional cases, the Lanczos algorithm might arrive at the exact evolution; of the initial state at a dimension :math:`M_{hb}<M`. This is called a happy; breakdown. For example, if a Hamiltonian has a symmetry subspace :math:`D_{\text{sim}}<M`,; then the algorithm will optimize using the value math:`M_{hb}<M`:, at which the; evolution is not only exact but also cheap. .. _krylov-qutip:. Krylov Solver in QuTiP; ======================. In QuTiP, Krylov-subspace evolution is implemented as the function :func:`.krylovsolve`.; Arguments are nearly the same as :func:`.sesolve` function for master-equation; evolution, except that the Hamiltonian cannot depend on time, the initial state; must always be a ket vector, (it cannot be used to compute propagators) and an; additional parameter ``krylov_dim`` is needed. ``krylov_dim`` defines the; maximum allowed Krylov-subspace dimension. Let's solve a simple example using the algorithm in QuTiP to get familiar with the method. .. plot::; :context: reset. >>> dim = 100; >>> jx = jmat((dim - 1) / 2.0, ""x""); >>> jy = jmat((dim - 1) / 2.0, ""y""); >>> jz = jmat((dim - 1) / 2.0, ""z""); >>> e_ops = [jx, jy, jz]; >>> H = (jz + jx) / 2; >>> psi0 = rand_ket(dim, seed=1); >>> tlist = np.linspace(0.0, 10.0, 200); >>> results",MatchSource.DOCS,doc/guide/dynamics/dynamics-krylov.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-krylov.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-krylov.rst:796,Usability,simpl,simplest,796,".. _krylov:. *******************************************; Krylov Solver; *******************************************. .. _krylov-intro:. Introduction; =============. The Krylov-subspace method is a standard method to approximate quantum dynamics.; Let :math:`\left|\psi\right\rangle` be a state in a :math:`D`-dimensional; complex Hilbert space that evolves under a time-independent Hamiltonian :math:`H`.; Then, the :math:`N`-dimensional Krylov subspace associated with that state and; Hamiltonian is given by. .. math::; 	:label: krylovsubspace. 	\mathcal{K}_{N}=\operatorname{span}\left\{|\psi\rangle, H|\psi\rangle, \ldots, H^{N-1}|\psi\rangle\right\},. where the dimension :math:`N<D` is a parameter of choice. To construct an; orthonormal basis :math:`B_N` for :math:`\mathcal{K}_{N}`, the simplest algorithm; is the well-known Lanczos algorithm, which provides a sort of Gram-Schmidt procedure; that harnesses the fact that orthonormalization needs to be imposed only for the last; two vectors in the basis. Written in this basis the time-evolved state can be approximated as. .. math::; 	:label: lanczoskrylov. 	|\psi(t)\rangle=e^{-iHt}|\psi\rangle\approx\mathbb{P}_{N}e^{-iHt}\mathbb{P}_{N}|\psi\rangle=\mathbb{V}_{N}^{\dagger}e^{-iT_{N}t}\mathbb{V}_{N}|\psi\rangle\equiv\left|\psi_{N}(t)\right\rangle,. where :math:`T_{N}=\mathbb{V}_{N} H \mathbb{V}_{N}^{\dagger}` is the Hamiltonian; reduced to the Krylov subspace (which takes a tridiagonal matrix form), and; :math:`\mathbb{V}_{N}^{\dagger}` is the matrix containing the vectors of the; Krylov basis as columns. With the above approximation, the time-evolution is calculated only with a; smaller square matrix of the desired size. Therefore, the Krylov method provides; huge speed-ups in computation of short-time evolutions when the dimension of the; Hamiltonian is very large, a point at which exact calculations on the complete; subspace are practically impossible. One of the biggest problems with this type of method is the control o",MatchSource.DOCS,doc/guide/dynamics/dynamics-krylov.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-krylov.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-krylov.rst:3446,Usability,simpl,simple,3446,"hen the error reaches a certain; threshold. Therefore, a series of :math:`M` Krylov-subspace time evolutions; provides accurate solutions for the complete time evolution. Within this scheme,; the magic of Krylov resides not only in its ability to capture complex time evolutions; from very large Hilbert spaces with very small dimenions :math:`M`, but also in; the computing speed-up it presents. For exceptional cases, the Lanczos algorithm might arrive at the exact evolution; of the initial state at a dimension :math:`M_{hb}<M`. This is called a happy; breakdown. For example, if a Hamiltonian has a symmetry subspace :math:`D_{\text{sim}}<M`,; then the algorithm will optimize using the value math:`M_{hb}<M`:, at which the; evolution is not only exact but also cheap. .. _krylov-qutip:. Krylov Solver in QuTiP; ======================. In QuTiP, Krylov-subspace evolution is implemented as the function :func:`.krylovsolve`.; Arguments are nearly the same as :func:`.sesolve` function for master-equation; evolution, except that the Hamiltonian cannot depend on time, the initial state; must always be a ket vector, (it cannot be used to compute propagators) and an; additional parameter ``krylov_dim`` is needed. ``krylov_dim`` defines the; maximum allowed Krylov-subspace dimension. Let's solve a simple example using the algorithm in QuTiP to get familiar with the method. .. plot::; :context: reset. >>> dim = 100; >>> jx = jmat((dim - 1) / 2.0, ""x""); >>> jy = jmat((dim - 1) / 2.0, ""y""); >>> jz = jmat((dim - 1) / 2.0, ""z""); >>> e_ops = [jx, jy, jz]; >>> H = (jz + jx) / 2; >>> psi0 = rand_ket(dim, seed=1); >>> tlist = np.linspace(0.0, 10.0, 200); >>> results = krylovsolve(H, psi0, tlist, krylov_dim=20, e_ops=e_ops); >>> plt.figure(); >>> for expect in results.expect:; >>> plt.plot(tlist, expect); >>> plt.legend(('jmat x', 'jmat y', 'jmat z')); >>> plt.xlabel('Time'); >>> plt.ylabel('Expectation values'); >>> plt.show(). .. plot::; :context: reset; :include-source: false; :nofigs:; ",MatchSource.DOCS,doc/guide/dynamics/dynamics-krylov.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-krylov.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-master.rst:1723,Energy Efficiency,efficient,efficient,1723," in a set of basis functions that span the Hilbert space of the; Hamiltonian, and to write the equation in matrix and vector form. .. math::. i\hbar\frac{d}{dt}\left|\psi\right> = H \left|\psi\right>. where :math:`\left|\psi\right>` is the state vector and :math:`H` is the matrix; representation of the Hamiltonian. This matrix equation can, in principle, be; solved by diagonalizing the Hamiltonian matrix :math:`H`. In practice, however,; it is difficult to perform this diagonalization unless the size of the Hilbert; space (dimension of the matrix :math:`H`) is small. Analytically, it is a; formidable task to calculate the dynamics for systems with more than two states.; If, in addition, we consider dissipation due to the inevitable interaction with; a surrounding environment, the computational complexity grows even larger, and; we have to resort to numerical calculations in all realistic situations. This; illustrates the importance of numerical calculations in describing the dynamics; of open quantum systems, and the need for efficient and accessible tools for; this task. The Schrdinger equation, which governs the time-evolution of closed quantum; systems, is defined by its Hamiltonian and state vector. In the previous; section, :ref:`tensor`, we showed how Hamiltonians and state vectors are; constructed in QuTiP. Given a Hamiltonian, we can calculate the unitary; (non-dissipative) time-evolution of an arbitrary state vector; :math:`\left|\psi_0\right>` (``psi0``) using the QuTiP solver :obj:`.SESolver`; or the function :func:`.sesolve`. It evolves the state vector and evaluates the; expectation values for a set of operators ``e_ops`` at the points in time in; the list ``times``, using an ordinary differential equation solver. For example, the time evolution of a quantum spin-1/2 system with tunneling rate; 0.1 that initially is in the up state is calculated, and the expectation values; of the :math:`\sigma_z` operator evaluated, with the following code. .. plot::;",MatchSource.DOCS,doc/guide/dynamics/dynamics-master.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-master.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-master.rst:5562,Energy Efficiency,energy,energy,5562,".expect[1]); >>> ax.set_xlabel('Time'); >>> ax.set_ylabel('Expectation values'); >>> ax.legend((""Sigma-Z"", ""Sigma-Y"")); >>> plt.show(). If an empty list of operators is passed to the ``e_ops`` parameter, the; :func:`.sesolve` and :func:`.mesolve` functions return a :class:`.Result`; instance that contains a list of state vectors for the times specified in; ``times``. .. plot::; :context: close-figs. >>> times = [0.0, 1.0]; >>> result = sesolve(H, psi0, times, []); >>> result.states; [Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[1.]; [0.]], Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[0.80901699+0.j ]; [0. -0.58778526j]]]. .. _master-nonunitary:. Non-unitary evolution; =======================. While the evolution of the state vector in a closed quantum system is; deterministic, open quantum systems are stochastic in nature. The effect of an; environment on the system of interest is to induce stochastic transitions; between energy levels, and to introduce uncertainty in the phase difference; between states of the system. The state of an open quantum system is therefore; described in terms of ensemble averaged states using the density matrix; formalism. A density matrix :math:`\rho` describes a probability distribution; of quantum states :math:`\left|\psi_n\right>`, in a matrix representation; :math:`\rho = \sum_n p_n \left|\psi_n\right>\left<\psi_n\right|`, where; :math:`p_n` is the classical probability that the system is in the quantum state; :math:`\left|\psi_n\right>`. The time evolution of a density matrix :math:`\rho`; is the topic of the remaining portions of this section. .. _master-master:. The Lindblad Master equation; =============================. The standard approach for deriving the equations of motion for a system; interacting with its environment is to expand the scope of the system to; include the environment. The combined quantum system is then closed, and its; evolution is governed b",MatchSource.DOCS,doc/guide/dynamics/dynamics-master.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-master.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-master.rst:7503,Energy Efficiency,reduce,reduced,7503,"ment. The combined quantum system is then closed, and its; evolution is governed by the von Neumann equation. .. math::; :label: neumann_total. \dot \rho_{\rm tot}(t) = -\frac{i}{\hbar}[H_{\rm tot}, \rho_{\rm tot}(t)],. the equivalent of the Schrdinger equation :eq:`schrodinger` in the density; matrix formalism. Here, the total Hamiltonian. .. math::. 	H_{\rm tot} = H_{\rm sys} + H_{\rm env} + H_{\rm int},. includes the original system Hamiltonian :math:`H_{\rm sys}`, the Hamiltonian; for the environment :math:`H_{\rm env}`, and a term representing the interaction; between the system and its environment :math:`H_{\rm int}`. Since we are only; interested in the dynamics of the system, we can at this point perform a partial; trace over the environmental degrees of freedom in Eq. :eq:`neumann_total`, and; thereby obtain a master equation for the motion of the original system density; matrix. The most general trace-preserving and completely positive form of this; evolution is the Lindblad master equation for the reduced density matrix; :math:`\rho = {\rm Tr}_{\rm env}[\rho_{\rm tot}]`. .. math::; 	:label: lindblad_master_equation. 	\dot\rho(t)=-\frac{i}{\hbar}[H(t),\rho(t)]+\sum_n \frac{1}{2} \left[2 C_n \rho(t) C_n^\dagger - \rho(t) C_n^\dagger C_n - C_n^\dagger C_n \rho(t)\right]. where the :math:`C_n = \sqrt{\gamma_n} A_n` are collapse operators, and; :math:`A_n` are the operators through which the environment couples to the; system in :math:`H_{\rm int}`, and :math:`\gamma_n` are the corresponding rates.; The derivation of Eq. :eq:`lindblad_master_equation` may be found in several; sources, and will not be reproduced here. Instead, we emphasize the; approximations that are required to arrive at the master equation in the form; of Eq. :eq:`lindblad_master_equation` from physical arguments, and hence; perform a calculation in QuTiP:. - **Separability:** At :math:`t=0` there are no correlations between the system; and its environment such that the total density matrix ",MatchSource.DOCS,doc/guide/dynamics/dynamics-master.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-master.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-master.rst:9730,Energy Efficiency,energy,energy,9730,"t of the interaction with the system;; (2) The system and the environment remain separable throughout the evolution.; These assumptions are justified if the interaction is weak, and if the; environment is much larger than the system. In summary,; :math:`\rho_{\rm tot}(t) \approx \rho(t)\otimes\rho_{\rm env}`. - **Markov approximation** The time-scale of decay for the environment; :math:`\tau_{\rm env}` is much shorter than the smallest time-scale of the; system dynamics :math:`\tau_{\rm sys} \gg \tau_{\rm env}`. This approximation; is often deemed a ""short-memory environment"" as it requires that environmental; correlation functions decay on a time-scale fast compared to those of the system. - **Secular approximation** Stipulates that elements in the master equation corresponding; to transition frequencies satisfy :math:`|\omega_{ab}-\omega_{cd}| \ll 1/\tau_{\rm sys}`,; i.e., all fast rotating terms in the interaction picture can be neglected.; It also ignores terms that lead to a small renormalization of the system energy levels.; This approximation is not strictly necessary for all master-equation formalisms; (e.g., the Block-Redfield master equation), but it is required for arriving; at the Lindblad form :eq:`lindblad_master_equation` which is used in :func:`.mesolve`. For systems with environments satisfying the conditions outlined above, the; Lindblad master equation :eq:`lindblad_master_equation` governs the; time-evolution of the system density matrix, giving an ensemble average of the; system dynamics. In order to ensure that these approximations are not violated,; it is important that the decay rates :math:`\gamma_n` be smaller than the; minimum energy splitting in the system Hamiltonian. Situations that demand; special attention therefore include, for example, systems strongly coupled to; their environment, and systems with degenerate or nearly degenerate energy levels. For non-unitary evolution of a quantum systems, i.e., evolution that includes; incoherent",MatchSource.DOCS,doc/guide/dynamics/dynamics-master.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-master.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-master.rst:10381,Energy Efficiency,energy,energy,10381," functions decay on a time-scale fast compared to those of the system. - **Secular approximation** Stipulates that elements in the master equation corresponding; to transition frequencies satisfy :math:`|\omega_{ab}-\omega_{cd}| \ll 1/\tau_{\rm sys}`,; i.e., all fast rotating terms in the interaction picture can be neglected.; It also ignores terms that lead to a small renormalization of the system energy levels.; This approximation is not strictly necessary for all master-equation formalisms; (e.g., the Block-Redfield master equation), but it is required for arriving; at the Lindblad form :eq:`lindblad_master_equation` which is used in :func:`.mesolve`. For systems with environments satisfying the conditions outlined above, the; Lindblad master equation :eq:`lindblad_master_equation` governs the; time-evolution of the system density matrix, giving an ensemble average of the; system dynamics. In order to ensure that these approximations are not violated,; it is important that the decay rates :math:`\gamma_n` be smaller than the; minimum energy splitting in the system Hamiltonian. Situations that demand; special attention therefore include, for example, systems strongly coupled to; their environment, and systems with degenerate or nearly degenerate energy levels. For non-unitary evolution of a quantum systems, i.e., evolution that includes; incoherent processes such as relaxation and dephasing, it is common to use; master equations. In QuTiP, the function :func:`.mesolve` is used for both:; the evolution according to the Schrdinger equation and to the master equation,; even though these two equations of motion are very different. The :func:`.mesolve`; function automatically determines if it is sufficient to use the Schrdinger; equation (if no collapse operators were given) or if it has to use the; master equation (if collapse operators were given). Note that to calculate; the time evolution according to the Schrdinger equation is easier and much; faster (for large ",MatchSource.DOCS,doc/guide/dynamics/dynamics-master.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-master.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-master.rst:10596,Energy Efficiency,energy,energy,10596,"atisfy :math:`|\omega_{ab}-\omega_{cd}| \ll 1/\tau_{\rm sys}`,; i.e., all fast rotating terms in the interaction picture can be neglected.; It also ignores terms that lead to a small renormalization of the system energy levels.; This approximation is not strictly necessary for all master-equation formalisms; (e.g., the Block-Redfield master equation), but it is required for arriving; at the Lindblad form :eq:`lindblad_master_equation` which is used in :func:`.mesolve`. For systems with environments satisfying the conditions outlined above, the; Lindblad master equation :eq:`lindblad_master_equation` governs the; time-evolution of the system density matrix, giving an ensemble average of the; system dynamics. In order to ensure that these approximations are not violated,; it is important that the decay rates :math:`\gamma_n` be smaller than the; minimum energy splitting in the system Hamiltonian. Situations that demand; special attention therefore include, for example, systems strongly coupled to; their environment, and systems with degenerate or nearly degenerate energy levels. For non-unitary evolution of a quantum systems, i.e., evolution that includes; incoherent processes such as relaxation and dephasing, it is common to use; master equations. In QuTiP, the function :func:`.mesolve` is used for both:; the evolution according to the Schrdinger equation and to the master equation,; even though these two equations of motion are very different. The :func:`.mesolve`; function automatically determines if it is sufficient to use the Schrdinger; equation (if no collapse operators were given) or if it has to use the; master equation (if collapse operators were given). Note that to calculate; the time evolution according to the Schrdinger equation is easier and much; faster (for large systems) than using the master equation, so if possible the; solver will fall back on using the Schrdinger equation. What is new in the master equation compared to the Schrdinger equatio",MatchSource.DOCS,doc/guide/dynamics/dynamics-master.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-master.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-master.rst:12394,Energy Efficiency,energy,energy,12394,"master equation, so if possible the; solver will fall back on using the Schrdinger equation. What is new in the master equation compared to the Schrdinger equation are; processes that describe dissipation in the quantum system due to its interaction; with an environment. These environmental interactions are defined by the; operators through which the system couples to the environment, and rates that; describe the strength of the processes. In QuTiP, the product of the square root of the rate and the operator that; describe the dissipation process is called a collapse operator. A list of; collapse operators (``c_ops``) is passed as the fourth argument to the; :func:`.mesolve` function in order to define the dissipation processes in the master; equation. When the ``c_ops`` isn't empty, the :func:`.mesolve` function will use; the master equation instead of the unitary Schrdinger equation. Using the example with the spin dynamics from the previous section, we can; easily add a relaxation process (describing the dissipation of energy from the; spin to its environment), by adding ``np.sqrt(0.05) * sigmax()`` in the fourth; parameter to the :func:`.mesolve` function. .. plot::; :context: close-figs. >>> times = np.linspace(0.0, 10.0, 100); >>> result = mesolve(H, psi0, times, [np.sqrt(0.05) * sigmax()], e_ops=[sigmaz(), sigmay()]); >>> fig, ax = plt.subplots(); >>> ax.plot(times, result.expect[0]); >>> ax.plot(times, result.expect[1]); >>> ax.set_xlabel('Time'); >>> ax.set_ylabel('Expectation values'); >>> ax.legend((""Sigma-Z"", ""Sigma-Y"")); >>> plt.show(). Here, 0.05 is the rate and the operator :math:`\sigma_x` (:func:`.sigmax`); describes the dissipation process. Now a slightly more complex example: Consider a two-level atom coupled to a; leaky single-mode cavity through a dipole-type interaction, which supports a; coherent exchange of quanta between the two systems. If the atom initially is; in its groundstate and the cavity in a 5-photon Fock state, the dynamics is;",MatchSource.DOCS,doc/guide/dynamics/dynamics-master.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-master.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-master.rst:2249,Modifiability,evolve,evolves,2249," than two states.; If, in addition, we consider dissipation due to the inevitable interaction with; a surrounding environment, the computational complexity grows even larger, and; we have to resort to numerical calculations in all realistic situations. This; illustrates the importance of numerical calculations in describing the dynamics; of open quantum systems, and the need for efficient and accessible tools for; this task. The Schrdinger equation, which governs the time-evolution of closed quantum; systems, is defined by its Hamiltonian and state vector. In the previous; section, :ref:`tensor`, we showed how Hamiltonians and state vectors are; constructed in QuTiP. Given a Hamiltonian, we can calculate the unitary; (non-dissipative) time-evolution of an arbitrary state vector; :math:`\left|\psi_0\right>` (``psi0``) using the QuTiP solver :obj:`.SESolver`; or the function :func:`.sesolve`. It evolves the state vector and evaluates the; expectation values for a set of operators ``e_ops`` at the points in time in; the list ``times``, using an ordinary differential equation solver. For example, the time evolution of a quantum spin-1/2 system with tunneling rate; 0.1 that initially is in the up state is calculated, and the expectation values; of the :math:`\sigma_z` operator evaluated, with the following code. .. plot::; :context: reset. >>> H = 2*np.pi * 0.1 * sigmax(); >>> psi0 = basis(2, 0); >>> times = np.linspace(0.0, 10.0, 20); >>> solver = SESolver(H); >>> result = solver.run(psi0, times, e_ops=[sigmaz()]); >>> result.expect; [array([ 1. , 0.78914057, 0.24548543, -0.40169579, -0.87947417,; -0.98636112, -0.67728018, -0.08257665, 0.54695111, 0.94581862,; 0.94581574, 0.54694361, -0.08258559, -0.67728679, -0.9863626 ,; -0.87946979, -0.40168705, 0.24549517, 0.78914703, 1. ])]. See the next section for examples on evolution with dissipation using; :func:`.mesolve`. The function returns an instance of :class:`.Result`, as described in the; previous section :ref:`solver",MatchSource.DOCS,doc/guide/dynamics/dynamics-master.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-master.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-master.rst:1142,Performance,perform,perform,1142,"; The dynamics of a closed (pure) quantum system is governed by the Schrdinger equation. .. math::; :label: schrodinger. 	i\hbar\frac{\partial}{\partial t}\Psi = \hat H \Psi,. where :math:`\Psi` is the wave function, :math:`\hat H` the Hamiltonian, and; :math:`\hbar` is Planck's constant. In general, the Schrdinger equation is a; partial differential equation (PDE) where both :math:`\Psi` and :math:`\hat H`; are functions of space and time. For computational purposes it is useful to; expand the PDE in a set of basis functions that span the Hilbert space of the; Hamiltonian, and to write the equation in matrix and vector form. .. math::. i\hbar\frac{d}{dt}\left|\psi\right> = H \left|\psi\right>. where :math:`\left|\psi\right>` is the state vector and :math:`H` is the matrix; representation of the Hamiltonian. This matrix equation can, in principle, be; solved by diagonalizing the Hamiltonian matrix :math:`H`. In practice, however,; it is difficult to perform this diagonalization unless the size of the Hilbert; space (dimension of the matrix :math:`H`) is small. Analytically, it is a; formidable task to calculate the dynamics for systems with more than two states.; If, in addition, we consider dissipation due to the inevitable interaction with; a surrounding environment, the computational complexity grows even larger, and; we have to resort to numerical calculations in all realistic situations. This; illustrates the importance of numerical calculations in describing the dynamics; of open quantum systems, and the need for efficient and accessible tools for; this task. The Schrdinger equation, which governs the time-evolution of closed quantum; systems, is defined by its Hamiltonian and state vector. In the previous; section, :ref:`tensor`, we showed how Hamiltonians and state vectors are; constructed in QuTiP. Given a Hamiltonian, we can calculate the unitary; (non-dissipative) time-evolution of an arbitrary state vector; :math:`\left|\psi_0\right>` (``psi0``) using ",MatchSource.DOCS,doc/guide/dynamics/dynamics-master.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-master.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-master.rst:7193,Performance,perform,perform,7193,"of the remaining portions of this section. .. _master-master:. The Lindblad Master equation; =============================. The standard approach for deriving the equations of motion for a system; interacting with its environment is to expand the scope of the system to; include the environment. The combined quantum system is then closed, and its; evolution is governed by the von Neumann equation. .. math::; :label: neumann_total. \dot \rho_{\rm tot}(t) = -\frac{i}{\hbar}[H_{\rm tot}, \rho_{\rm tot}(t)],. the equivalent of the Schrdinger equation :eq:`schrodinger` in the density; matrix formalism. Here, the total Hamiltonian. .. math::. 	H_{\rm tot} = H_{\rm sys} + H_{\rm env} + H_{\rm int},. includes the original system Hamiltonian :math:`H_{\rm sys}`, the Hamiltonian; for the environment :math:`H_{\rm env}`, and a term representing the interaction; between the system and its environment :math:`H_{\rm int}`. Since we are only; interested in the dynamics of the system, we can at this point perform a partial; trace over the environmental degrees of freedom in Eq. :eq:`neumann_total`, and; thereby obtain a master equation for the motion of the original system density; matrix. The most general trace-preserving and completely positive form of this; evolution is the Lindblad master equation for the reduced density matrix; :math:`\rho = {\rm Tr}_{\rm env}[\rho_{\rm tot}]`. .. math::; 	:label: lindblad_master_equation. 	\dot\rho(t)=-\frac{i}{\hbar}[H(t),\rho(t)]+\sum_n \frac{1}{2} \left[2 C_n \rho(t) C_n^\dagger - \rho(t) C_n^\dagger C_n - C_n^\dagger C_n \rho(t)\right]. where the :math:`C_n = \sqrt{\gamma_n} A_n` are collapse operators, and; :math:`A_n` are the operators through which the environment couples to the; system in :math:`H_{\rm int}`, and :math:`\gamma_n` are the corresponding rates.; The derivation of Eq. :eq:`lindblad_master_equation` may be found in several; sources, and will not be reproduced here. Instead, we emphasize the; approximations that are require",MatchSource.DOCS,doc/guide/dynamics/dynamics-master.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-master.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-master.rst:8310,Performance,perform,perform,8310," thereby obtain a master equation for the motion of the original system density; matrix. The most general trace-preserving and completely positive form of this; evolution is the Lindblad master equation for the reduced density matrix; :math:`\rho = {\rm Tr}_{\rm env}[\rho_{\rm tot}]`. .. math::; 	:label: lindblad_master_equation. 	\dot\rho(t)=-\frac{i}{\hbar}[H(t),\rho(t)]+\sum_n \frac{1}{2} \left[2 C_n \rho(t) C_n^\dagger - \rho(t) C_n^\dagger C_n - C_n^\dagger C_n \rho(t)\right]. where the :math:`C_n = \sqrt{\gamma_n} A_n` are collapse operators, and; :math:`A_n` are the operators through which the environment couples to the; system in :math:`H_{\rm int}`, and :math:`\gamma_n` are the corresponding rates.; The derivation of Eq. :eq:`lindblad_master_equation` may be found in several; sources, and will not be reproduced here. Instead, we emphasize the; approximations that are required to arrive at the master equation in the form; of Eq. :eq:`lindblad_master_equation` from physical arguments, and hence; perform a calculation in QuTiP:. - **Separability:** At :math:`t=0` there are no correlations between the system; and its environment such that the total density matrix can be written as a; tensor product :math:`\rho^I_{\rm tot}(0) = \rho^I(0) \otimes \rho^I_{\rm env}(0)`. - **Born approximation:** Requires: (1) that the state of the environment does; not significantly change as a result of the interaction with the system;; (2) The system and the environment remain separable throughout the evolution.; These assumptions are justified if the interaction is weak, and if the; environment is much larger than the system. In summary,; :math:`\rho_{\rm tot}(t) \approx \rho(t)\otimes\rho_{\rm env}`. - **Markov approximation** The time-scale of decay for the environment; :math:`\tau_{\rm env}` is much shorter than the smallest time-scale of the; system dynamics :math:`\tau_{\rm sys} \gg \tau_{\rm env}`. This approximation; is often deemed a ""short-memory environment"" as it requ",MatchSource.DOCS,doc/guide/dynamics/dynamics-master.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-master.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-master.rst:1737,Security,access,accessible,1737," in a set of basis functions that span the Hilbert space of the; Hamiltonian, and to write the equation in matrix and vector form. .. math::. i\hbar\frac{d}{dt}\left|\psi\right> = H \left|\psi\right>. where :math:`\left|\psi\right>` is the state vector and :math:`H` is the matrix; representation of the Hamiltonian. This matrix equation can, in principle, be; solved by diagonalizing the Hamiltonian matrix :math:`H`. In practice, however,; it is difficult to perform this diagonalization unless the size of the Hilbert; space (dimension of the matrix :math:`H`) is small. Analytically, it is a; formidable task to calculate the dynamics for systems with more than two states.; If, in addition, we consider dissipation due to the inevitable interaction with; a surrounding environment, the computational complexity grows even larger, and; we have to resort to numerical calculations in all realistic situations. This; illustrates the importance of numerical calculations in describing the dynamics; of open quantum systems, and the need for efficient and accessible tools for; this task. The Schrdinger equation, which governs the time-evolution of closed quantum; systems, is defined by its Hamiltonian and state vector. In the previous; section, :ref:`tensor`, we showed how Hamiltonians and state vectors are; constructed in QuTiP. Given a Hamiltonian, we can calculate the unitary; (non-dissipative) time-evolution of an arbitrary state vector; :math:`\left|\psi_0\right>` (``psi0``) using the QuTiP solver :obj:`.SESolver`; or the function :func:`.sesolve`. It evolves the state vector and evaluates the; expectation values for a set of operators ``e_ops`` at the points in time in; the list ``times``, using an ordinary differential equation solver. For example, the time evolution of a quantum spin-1/2 system with tunneling rate; 0.1 that initially is in the up state is calculated, and the expectation values; of the :math:`\sigma_z` operator evaluated, with the following code. .. plot::;",MatchSource.DOCS,doc/guide/dynamics/dynamics-master.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-master.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-monte.rst:7659,Availability,error,errors,7659," a list over the expectation operators, trajectories and times in that order.; The averages are stored in ``result.average_expect`` and the standard derivation; of the expectation values in ``result.std_expect``. When the states are returned,; ``result.runs_states`` will be an array of length ``ntraj``. Each element; contains an array of ""Qobj"" type ket with the same number of elements as ``times``.; ``result.average_states`` is a list of density matrices computed as the average; of the states at each time step. Furthermore, the output will also contain a; list of times at which the collapse occurred, and which collapse operators did; the collapse. These can be obtained in ``result.col_times`` and; ``result.col_which`` respectively. .. _monte-ntraj:. Changing the Number of Trajectories; -----------------------------------. By default, the ``mcsolve`` function runs 500 trajectories.; This value was chosen because it gives good accuracy, Monte Carlo errors scale; as :math:`1/n` where :math:`n` is the number of trajectories, and simultaneously; does not take an excessive amount of time to run. However, you can change the; number of trajectories to fit your needs. In order to run 1000 trajectories in; the above example, we can simply modify the call to ``mcsolve`` like:. .. code-block::. data = mcsolve(H, psi0, times, c_ops e_ops=e_ops, ntraj=1000). where we have added the keyword argument ``ntraj=1000`` at the end of the inputs.; Now, the Monte Carlo solver will calculate expectation values for both operators,; ``a.dag() * a, sm.dag() * sm`` averaging over 1000 trajectories. Other than a target number of trajectories, it is possible to use a computation; time or errors bars as condition to stop computing trajectories. ``timeout`` is quite simple as ``mcsolve`` will stop starting the computation of; new trajectories when it is reached. Thus:. .. code-block::. data = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], e_ops=e_ops, ntraj=1000, timeout=60). Will compute 60 seconds ",MatchSource.DOCS,doc/guide/dynamics/dynamics-monte.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-monte.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-monte.rst:8385,Availability,error,errors,8385,"btained in ``result.col_times`` and; ``result.col_which`` respectively. .. _monte-ntraj:. Changing the Number of Trajectories; -----------------------------------. By default, the ``mcsolve`` function runs 500 trajectories.; This value was chosen because it gives good accuracy, Monte Carlo errors scale; as :math:`1/n` where :math:`n` is the number of trajectories, and simultaneously; does not take an excessive amount of time to run. However, you can change the; number of trajectories to fit your needs. In order to run 1000 trajectories in; the above example, we can simply modify the call to ``mcsolve`` like:. .. code-block::. data = mcsolve(H, psi0, times, c_ops e_ops=e_ops, ntraj=1000). where we have added the keyword argument ``ntraj=1000`` at the end of the inputs.; Now, the Monte Carlo solver will calculate expectation values for both operators,; ``a.dag() * a, sm.dag() * sm`` averaging over 1000 trajectories. Other than a target number of trajectories, it is possible to use a computation; time or errors bars as condition to stop computing trajectories. ``timeout`` is quite simple as ``mcsolve`` will stop starting the computation of; new trajectories when it is reached. Thus:. .. code-block::. data = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], e_ops=e_ops, ntraj=1000, timeout=60). Will compute 60 seconds of trajectories or 1000, which ever is reached first.; The solver will finish any trajectory started when the timeout is reached. Therefore; if the computation time of a single trajectory is quite long, the overall computation; time can be much longer that the provided timeout. Lastly, ``mcsolve`` can be instructed to stop when the statistical error of the; expectation values get under a certain value. When computing the average over; trajectories, the error on these are computed using; `jackknife resampling <https://en.wikipedia.org/wiki/Jackknife_resampling>`_; for each expect and each time and the computation will be stopped when all these values; are under t",MatchSource.DOCS,doc/guide/dynamics/dynamics-monte.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-monte.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-monte.rst:9044,Availability,error,error,9044,"e_ops=e_ops, ntraj=1000). where we have added the keyword argument ``ntraj=1000`` at the end of the inputs.; Now, the Monte Carlo solver will calculate expectation values for both operators,; ``a.dag() * a, sm.dag() * sm`` averaging over 1000 trajectories. Other than a target number of trajectories, it is possible to use a computation; time or errors bars as condition to stop computing trajectories. ``timeout`` is quite simple as ``mcsolve`` will stop starting the computation of; new trajectories when it is reached. Thus:. .. code-block::. data = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], e_ops=e_ops, ntraj=1000, timeout=60). Will compute 60 seconds of trajectories or 1000, which ever is reached first.; The solver will finish any trajectory started when the timeout is reached. Therefore; if the computation time of a single trajectory is quite long, the overall computation; time can be much longer that the provided timeout. Lastly, ``mcsolve`` can be instructed to stop when the statistical error of the; expectation values get under a certain value. When computing the average over; trajectories, the error on these are computed using; `jackknife resampling <https://en.wikipedia.org/wiki/Jackknife_resampling>`_; for each expect and each time and the computation will be stopped when all these values; are under the tolerance passed to ``target_tol``. Therefore:. .. code-block::. data = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], e_ops=e_ops,; ntraj=1000, target_tol=0.01, timeout=600). will stop either after all errors bars on expectation values are under ``0.01``, 1000; trajectories are computed or 10 minutes have passed, whichever comes first. When a; single values is passed, it is used as the absolute value of the tolerance.; When a pair of values is passed, it is understood as an absolute and relative; tolerance pair. For even finer control, one such pair can be passed for each ``e_ops``.; For example:. .. code-block::. data = mcsolve(H, psi0, times, c_ops, e_ops=e_ops",MatchSource.DOCS,doc/guide/dynamics/dynamics-monte.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-monte.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-monte.rst:9155,Availability,error,error,9155,"Carlo solver will calculate expectation values for both operators,; ``a.dag() * a, sm.dag() * sm`` averaging over 1000 trajectories. Other than a target number of trajectories, it is possible to use a computation; time or errors bars as condition to stop computing trajectories. ``timeout`` is quite simple as ``mcsolve`` will stop starting the computation of; new trajectories when it is reached. Thus:. .. code-block::. data = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], e_ops=e_ops, ntraj=1000, timeout=60). Will compute 60 seconds of trajectories or 1000, which ever is reached first.; The solver will finish any trajectory started when the timeout is reached. Therefore; if the computation time of a single trajectory is quite long, the overall computation; time can be much longer that the provided timeout. Lastly, ``mcsolve`` can be instructed to stop when the statistical error of the; expectation values get under a certain value. When computing the average over; trajectories, the error on these are computed using; `jackknife resampling <https://en.wikipedia.org/wiki/Jackknife_resampling>`_; for each expect and each time and the computation will be stopped when all these values; are under the tolerance passed to ``target_tol``. Therefore:. .. code-block::. data = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], e_ops=e_ops,; ntraj=1000, target_tol=0.01, timeout=600). will stop either after all errors bars on expectation values are under ``0.01``, 1000; trajectories are computed or 10 minutes have passed, whichever comes first. When a; single values is passed, it is used as the absolute value of the tolerance.; When a pair of values is passed, it is understood as an absolute and relative; tolerance pair. For even finer control, one such pair can be passed for each ``e_ops``.; For example:. .. code-block::. data = mcsolve(H, psi0, times, c_ops, e_ops=e_ops, target_tol=[; (1e-5, 0.1),; (0, 0),; ]). will stop when the error bars on the expectation values of the first ``e_ops`` ar",MatchSource.DOCS,doc/guide/dynamics/dynamics-monte.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-monte.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-monte.rst:9371,Availability,toler,tolerance,9371,"er of trajectories, it is possible to use a computation; time or errors bars as condition to stop computing trajectories. ``timeout`` is quite simple as ``mcsolve`` will stop starting the computation of; new trajectories when it is reached. Thus:. .. code-block::. data = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], e_ops=e_ops, ntraj=1000, timeout=60). Will compute 60 seconds of trajectories or 1000, which ever is reached first.; The solver will finish any trajectory started when the timeout is reached. Therefore; if the computation time of a single trajectory is quite long, the overall computation; time can be much longer that the provided timeout. Lastly, ``mcsolve`` can be instructed to stop when the statistical error of the; expectation values get under a certain value. When computing the average over; trajectories, the error on these are computed using; `jackknife resampling <https://en.wikipedia.org/wiki/Jackknife_resampling>`_; for each expect and each time and the computation will be stopped when all these values; are under the tolerance passed to ``target_tol``. Therefore:. .. code-block::. data = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], e_ops=e_ops,; ntraj=1000, target_tol=0.01, timeout=600). will stop either after all errors bars on expectation values are under ``0.01``, 1000; trajectories are computed or 10 minutes have passed, whichever comes first. When a; single values is passed, it is used as the absolute value of the tolerance.; When a pair of values is passed, it is understood as an absolute and relative; tolerance pair. For even finer control, one such pair can be passed for each ``e_ops``.; For example:. .. code-block::. data = mcsolve(H, psi0, times, c_ops, e_ops=e_ops, target_tol=[; (1e-5, 0.1),; (0, 0),; ]). will stop when the error bars on the expectation values of the first ``e_ops`` are; under 10% of their average values. If after computation of some trajectories, it is determined that more are needed, it; is possible to add trajectories ",MatchSource.DOCS,doc/guide/dynamics/dynamics-monte.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-monte.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-monte.rst:9571,Availability,error,errors,9571,"::. data = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], e_ops=e_ops, ntraj=1000, timeout=60). Will compute 60 seconds of trajectories or 1000, which ever is reached first.; The solver will finish any trajectory started when the timeout is reached. Therefore; if the computation time of a single trajectory is quite long, the overall computation; time can be much longer that the provided timeout. Lastly, ``mcsolve`` can be instructed to stop when the statistical error of the; expectation values get under a certain value. When computing the average over; trajectories, the error on these are computed using; `jackknife resampling <https://en.wikipedia.org/wiki/Jackknife_resampling>`_; for each expect and each time and the computation will be stopped when all these values; are under the tolerance passed to ``target_tol``. Therefore:. .. code-block::. data = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], e_ops=e_ops,; ntraj=1000, target_tol=0.01, timeout=600). will stop either after all errors bars on expectation values are under ``0.01``, 1000; trajectories are computed or 10 minutes have passed, whichever comes first. When a; single values is passed, it is used as the absolute value of the tolerance.; When a pair of values is passed, it is understood as an absolute and relative; tolerance pair. For even finer control, one such pair can be passed for each ``e_ops``.; For example:. .. code-block::. data = mcsolve(H, psi0, times, c_ops, e_ops=e_ops, target_tol=[; (1e-5, 0.1),; (0, 0),; ]). will stop when the error bars on the expectation values of the first ``e_ops`` are; under 10% of their average values. If after computation of some trajectories, it is determined that more are needed, it; is possible to add trajectories to existing result by adding result together:. .. code-block::. >>> run1 = mcsolve(H, psi, times, c_ops, e_ops=e_ops, ntraj=25); >>> print(run1.num_trajectories); 25; >>> run2 = mcsolve(H, psi, times, c_ops, e_ops=e_ops, ntraj=25); >>> print(run2.num_trajectori",MatchSource.DOCS,doc/guide/dynamics/dynamics-monte.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-monte.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-monte.rst:9780,Availability,toler,tolerance,9780,"st.; The solver will finish any trajectory started when the timeout is reached. Therefore; if the computation time of a single trajectory is quite long, the overall computation; time can be much longer that the provided timeout. Lastly, ``mcsolve`` can be instructed to stop when the statistical error of the; expectation values get under a certain value. When computing the average over; trajectories, the error on these are computed using; `jackknife resampling <https://en.wikipedia.org/wiki/Jackknife_resampling>`_; for each expect and each time and the computation will be stopped when all these values; are under the tolerance passed to ``target_tol``. Therefore:. .. code-block::. data = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], e_ops=e_ops,; ntraj=1000, target_tol=0.01, timeout=600). will stop either after all errors bars on expectation values are under ``0.01``, 1000; trajectories are computed or 10 minutes have passed, whichever comes first. When a; single values is passed, it is used as the absolute value of the tolerance.; When a pair of values is passed, it is understood as an absolute and relative; tolerance pair. For even finer control, one such pair can be passed for each ``e_ops``.; For example:. .. code-block::. data = mcsolve(H, psi0, times, c_ops, e_ops=e_ops, target_tol=[; (1e-5, 0.1),; (0, 0),; ]). will stop when the error bars on the expectation values of the first ``e_ops`` are; under 10% of their average values. If after computation of some trajectories, it is determined that more are needed, it; is possible to add trajectories to existing result by adding result together:. .. code-block::. >>> run1 = mcsolve(H, psi, times, c_ops, e_ops=e_ops, ntraj=25); >>> print(run1.num_trajectories); 25; >>> run2 = mcsolve(H, psi, times, c_ops, e_ops=e_ops, ntraj=25); >>> print(run2.num_trajectories); 25; >>> merged = run1 + run2; >>> print(merged.num_trajectories); 50. Note that this merging operation only checks that the result are compatible --; i.e. that th",MatchSource.DOCS,doc/guide/dynamics/dynamics-monte.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-monte.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-monte.rst:9871,Availability,toler,tolerance,9871," if the computation time of a single trajectory is quite long, the overall computation; time can be much longer that the provided timeout. Lastly, ``mcsolve`` can be instructed to stop when the statistical error of the; expectation values get under a certain value. When computing the average over; trajectories, the error on these are computed using; `jackknife resampling <https://en.wikipedia.org/wiki/Jackknife_resampling>`_; for each expect and each time and the computation will be stopped when all these values; are under the tolerance passed to ``target_tol``. Therefore:. .. code-block::. data = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], e_ops=e_ops,; ntraj=1000, target_tol=0.01, timeout=600). will stop either after all errors bars on expectation values are under ``0.01``, 1000; trajectories are computed or 10 minutes have passed, whichever comes first. When a; single values is passed, it is used as the absolute value of the tolerance.; When a pair of values is passed, it is understood as an absolute and relative; tolerance pair. For even finer control, one such pair can be passed for each ``e_ops``.; For example:. .. code-block::. data = mcsolve(H, psi0, times, c_ops, e_ops=e_ops, target_tol=[; (1e-5, 0.1),; (0, 0),; ]). will stop when the error bars on the expectation values of the first ``e_ops`` are; under 10% of their average values. If after computation of some trajectories, it is determined that more are needed, it; is possible to add trajectories to existing result by adding result together:. .. code-block::. >>> run1 = mcsolve(H, psi, times, c_ops, e_ops=e_ops, ntraj=25); >>> print(run1.num_trajectories); 25; >>> run2 = mcsolve(H, psi, times, c_ops, e_ops=e_ops, ntraj=25); >>> print(run2.num_trajectories); 25; >>> merged = run1 + run2; >>> print(merged.num_trajectories); 50. Note that this merging operation only checks that the result are compatible --; i.e. that the ``e_ops`` and ``tlist`` are the same. It does not check that the same initial state or; ",MatchSource.DOCS,doc/guide/dynamics/dynamics-monte.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-monte.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-monte.rst:10102,Availability,error,error,10102,"ectories, the error on these are computed using; `jackknife resampling <https://en.wikipedia.org/wiki/Jackknife_resampling>`_; for each expect and each time and the computation will be stopped when all these values; are under the tolerance passed to ``target_tol``. Therefore:. .. code-block::. data = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], e_ops=e_ops,; ntraj=1000, target_tol=0.01, timeout=600). will stop either after all errors bars on expectation values are under ``0.01``, 1000; trajectories are computed or 10 minutes have passed, whichever comes first. When a; single values is passed, it is used as the absolute value of the tolerance.; When a pair of values is passed, it is understood as an absolute and relative; tolerance pair. For even finer control, one such pair can be passed for each ``e_ops``.; For example:. .. code-block::. data = mcsolve(H, psi0, times, c_ops, e_ops=e_ops, target_tol=[; (1e-5, 0.1),; (0, 0),; ]). will stop when the error bars on the expectation values of the first ``e_ops`` are; under 10% of their average values. If after computation of some trajectories, it is determined that more are needed, it; is possible to add trajectories to existing result by adding result together:. .. code-block::. >>> run1 = mcsolve(H, psi, times, c_ops, e_ops=e_ops, ntraj=25); >>> print(run1.num_trajectories); 25; >>> run2 = mcsolve(H, psi, times, c_ops, e_ops=e_ops, ntraj=25); >>> print(run2.num_trajectories); 25; >>> merged = run1 + run2; >>> print(merged.num_trajectories); 50. Note that this merging operation only checks that the result are compatible --; i.e. that the ``e_ops`` and ``tlist`` are the same. It does not check that the same initial state or; Hamiltonian where used. This can be used to explore the convergence of the Monte Carlo solver.; For example, the following code block plots expectation values for 1, 10 and 100; trajectories:. .. plot::; :context: close-figs. solver = MCSolver(H, c_ops=[np.sqrt(0.1) * a]); c_ops=[np.sqrt(0.1) * a]; e_op",MatchSource.DOCS,doc/guide/dynamics/dynamics-monte.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-monte.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-monte.rst:14841,Availability,avail,available,14841,"ing algorithm'); plt.xlabel(""time [ns]""); plt.ylabel(r""$p_{1}$""); plt.legend(); plt.show(). The original sampling algorithm samples the no-jump trajectory on average 96.7%; of the time, while the improved sampling algorithm only does so once. .. _monte-seeds:. Reproducibility; ---------------. For reproducibility of Monte-Carlo computations it is possible to set the seed of the random; number generator:. .. code-block::. >>> res1 = mcsolve(H, psi0, tlist, c_ops, e_ops=e_ops, seeds=1, ntraj=1); >>> res2 = mcsolve(H, psi0, tlist, c_ops, e_ops=e_ops, seeds=1, ntraj=1); >>> res3 = mcsolve(H, psi0, tlist, c_ops, e_ops=e_ops, seeds=2, ntraj=1); >>> np.allclose(res1, res2); True; >>> np.allclose(res1, res3); False. The ``seeds`` parameter can either be an integer or a numpy ``SeedSequence``, which; will then be used to create seeds for each trajectory. Alternatively it may be a list of; intergers or ``SeedSequence`` s with one seed for each trajectories. Seeds available in; the result object can be used to redo the same evolution:. .. code-block::. >>> res1 = mcsolve(H, psi0, tlist, c_ops, e_ops=e_ops, ntraj=10); >>> res2 = mcsolve(H, psi0, tlist, c_ops, e_ops=e_ops, seeds=res1.seeds, ntraj=10); >>> np.allclose(res1, res2); True. .. _monte-parallel:. Running trajectories in parallel; --------------------------------. Monte-Carlo evolutions often need hundreds of trajectories to obtain sufficient; statistics. Since all trajectories are independent of each other, they can be computed; in parallel. The option ``map`` can take ``""serial""``, ``""parallel""`` or ``""loky""``.; Both ``""parallel""`` and ``""loky""`` compute trajectories on multiple CPUs using; respectively the `multiprocessing <https://docs.python.org/3/library/multiprocessing.html>`_; and `loky <https://loky.readthedocs.io/en/stable/index.html>`_ python modules. .. code-block::. >>> res_par = mcsolve(H, psi0, tlist, c_ops, e_ops=e_ops, options={""map"": ""parallel""}, seeds=1); >>> res_ser = mcsolve(H, psi0, tlist, c_ops, e_",MatchSource.DOCS,doc/guide/dynamics/dynamics-monte.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-monte.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-monte.rst:468,Deployability,continuous,continuously,468,".. _monte:. *******************************************; Monte Carlo Solver; *******************************************. .. _monte-intro:. Introduction; =============. Where as the density matrix formalism describes the ensemble average over many; identical realizations of a quantum system, the Monte Carlo (MC), or; quantum-jump approach to wave function evolution, allows for simulating an; individual realization of the system dynamics. Here, the environment is; continuously monitored, resulting in a series of quantum jumps in the system; wave function, conditioned on the increase in information gained about the; state of the system via the environmental measurements. In general, this; evolution is governed by the Schrdinger equation with a **non-Hermitian**; effective Hamiltonian. .. math::; :label: heff. H_{\rm eff}=H_{\rm sys}-\frac{i\hbar}{2}\sum_{i}C^{+}_{n}C_{n},. where again, the :math:`C_{n}` are collapse operators, each corresponding to a; separate irreversible process with rate :math:`\gamma_{n}`. Here, the strictly; negative non-Hermitian portion of Eq. :eq:`heff` gives rise to a reduction in; the norm of the wave function, that to first-order in a small time; :math:`\delta t`, is given by; :math:`\left<\psi(t+\delta t)|\psi(t+\delta t)\right>=1-\delta p` where. .. math::; :label: jump. \delta p =\delta t \sum_{n}\left<\psi(t)|C^{+}_{n}C_{n}|\psi(t)\right>,. and :math:`\delta t` is such that :math:`\delta p \ll 1`. With a probability; of remaining in the state :math:`\left|\psi(t+\delta t)\right>` given by; :math:`1-\delta p`, the corresponding quantum jump probability is thus Eq.; :eq:`jump`. If the environmental measurements register a quantum jump, say via; the emission of a photon into the environment, or a change in the spin of a; quantum dot, the wave function undergoes a jump into a state defined by; projecting :math:`\left|\psi(t)\right>` using the collapse operator; :math:`C_{n}` corresponding to the measurement. .. math::; :label: project. \lef",MatchSource.DOCS,doc/guide/dynamics/dynamics-monte.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-monte.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-monte.rst:481,Energy Efficiency,monitor,monitored,481,".. _monte:. *******************************************; Monte Carlo Solver; *******************************************. .. _monte-intro:. Introduction; =============. Where as the density matrix formalism describes the ensemble average over many; identical realizations of a quantum system, the Monte Carlo (MC), or; quantum-jump approach to wave function evolution, allows for simulating an; individual realization of the system dynamics. Here, the environment is; continuously monitored, resulting in a series of quantum jumps in the system; wave function, conditioned on the increase in information gained about the; state of the system via the environmental measurements. In general, this; evolution is governed by the Schrdinger equation with a **non-Hermitian**; effective Hamiltonian. .. math::; :label: heff. H_{\rm eff}=H_{\rm sys}-\frac{i\hbar}{2}\sum_{i}C^{+}_{n}C_{n},. where again, the :math:`C_{n}` are collapse operators, each corresponding to a; separate irreversible process with rate :math:`\gamma_{n}`. Here, the strictly; negative non-Hermitian portion of Eq. :eq:`heff` gives rise to a reduction in; the norm of the wave function, that to first-order in a small time; :math:`\delta t`, is given by; :math:`\left<\psi(t+\delta t)|\psi(t+\delta t)\right>=1-\delta p` where. .. math::; :label: jump. \delta p =\delta t \sum_{n}\left<\psi(t)|C^{+}_{n}C_{n}|\psi(t)\right>,. and :math:`\delta t` is such that :math:`\delta p \ll 1`. With a probability; of remaining in the state :math:`\left|\psi(t+\delta t)\right>` given by; :math:`1-\delta p`, the corresponding quantum jump probability is thus Eq.; :eq:`jump`. If the environmental measurements register a quantum jump, say via; the emission of a photon into the environment, or a change in the spin of a; quantum dot, the wave function undergoes a jump into a state defined by; projecting :math:`\left|\psi(t)\right>` using the collapse operator; :math:`C_{n}` corresponding to the measurement. .. math::; :label: project. \lef",MatchSource.DOCS,doc/guide/dynamics/dynamics-monte.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-monte.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-monte.rst:6232,Energy Efficiency,efficient,efficient,6232,"dvantage of the Monte Carlo method over the master equation approach is that; only the state vector is required to be kept in the computers memory, as opposed; to the entire density matrix. For large quantum system this becomes a significant; advantage, and the Monte Carlo solver is therefore generally recommended for such; systems. For example, simulating a Heisenberg spin-chain consisting of 10 spins; with random parameters and initial states takes almost 7 times longer using the; master equation rather than Monte Carlo approach with the default number of; trajectories running on a quad-CPU machine. Furthermore, it takes about 7 times; the memory as well. However, for small systems, the added overhead of averaging; a large number of stochastic trajectories to obtain the open system dynamics, as; well as starting the multiprocessing functionality, outweighs the benefit of the; minor (in this case) memory saving. Master equation methods are therefore; generally more efficient when Hilbert space sizes are on the order of a couple; of hundred states or smaller. Monte Carlo Solver Result; -------------------------. The Monte Carlo solver returns a :class:`.McResult` object consisting of; expectation values and/or states. The main difference with :func:`.mesolve`'s; :class:`.Result` is that it optionally stores the result of each trajectory; together with their averages. When trajectories are stored, ``result.runs_expect``; is a list over the expectation operators, trajectories and times in that order.; The averages are stored in ``result.average_expect`` and the standard derivation; of the expectation values in ``result.std_expect``. When the states are returned,; ``result.runs_states`` will be an array of length ``ntraj``. Each element; contains an array of ""Qobj"" type ket with the same number of elements as ``times``.; ``result.average_states`` is a list of density matrices computed as the average; of the states at each time step. Furthermore, the output will also con",MatchSource.DOCS,doc/guide/dynamics/dynamics-monte.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-monte.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-monte.rst:12165,Energy Efficiency,reduce,reduce,12165,", times, c_ops, e_ops=e_ops, ntraj=1); data10 = data1 + mcsolve(H, psi0, times, c_ops, e_ops=e_ops, ntraj=9); data100 = data10 + mcsolve(H, psi0, times, c_ops, e_ops=e_ops, ntraj=90). expt1 = data1.expect; expt10 = data10.expect; expt100 = data100.expect. plt.figure(); plt.plot(times, expt1[0], label=""ntraj=1""); plt.plot(times, expt10[0], label=""ntraj=10""); plt.plot(times, expt100[0], label=""ntraj=100""); plt.title('Monte Carlo time evolution'); plt.xlabel('Time'); plt.ylabel('Expectation values'); plt.legend(); plt.show(). Using the Improved Sampling Algorithm; -------------------------------------. Oftentimes, quantum jumps are rare. This is especially true in the context of; simulating gates for quantum information purposes, where typical gate times are; orders of magnitude smaller than typical timescales for decoherence. In this case,; using the standard monte-carlo sampling algorithm, we often repeatedly sample the; no-jump trajectory. We can thus reduce the number of required runs by only; sampling the no-jump trajectory once. We then extract the no-jump probability; :math:`p`, and for all future runs we only sample random numbers :math:`r_1`; where :math:`r_1>p`, thus ensuring that a jump will occur. When it comes time to; compute expectation values, we weight the no-jump trajectory by :math:`p` and; the jump trajectories by :math:`1-p`. This algorithm is described in [Abd19]_; and can be utilized by setting the option ``""improved_sampling""`` in the call; to ``mcsolve``:. .. plot::; :context: close-figs. data = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], options={""improved_sampling"": True}). where in this case the first run samples the no-jump trajectory, and the; remaining 499 trajectories are all guaranteed to include (at least) one jump. The power of this algorithm is most obvious when considering systems that rarely; undergo jumps. For instance, consider the following T1 simulation of a qubit with; a lifetime of 10 microseconds (assuming time is in units o",MatchSource.DOCS,doc/guide/dynamics/dynamics-monte.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-monte.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-monte.rst:12980,Energy Efficiency,power,power,12980,"ecoherence. In this case,; using the standard monte-carlo sampling algorithm, we often repeatedly sample the; no-jump trajectory. We can thus reduce the number of required runs by only; sampling the no-jump trajectory once. We then extract the no-jump probability; :math:`p`, and for all future runs we only sample random numbers :math:`r_1`; where :math:`r_1>p`, thus ensuring that a jump will occur. When it comes time to; compute expectation values, we weight the no-jump trajectory by :math:`p` and; the jump trajectories by :math:`1-p`. This algorithm is described in [Abd19]_; and can be utilized by setting the option ``""improved_sampling""`` in the call; to ``mcsolve``:. .. plot::; :context: close-figs. data = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], options={""improved_sampling"": True}). where in this case the first run samples the no-jump trajectory, and the; remaining 499 trajectories are all guaranteed to include (at least) one jump. The power of this algorithm is most obvious when considering systems that rarely; undergo jumps. For instance, consider the following T1 simulation of a qubit with; a lifetime of 10 microseconds (assuming time is in units of nanoseconds). .. plot::; :context: close-figs. times = np.linspace(0.0, 300.0, 100); psi0 = fock(2, 1); sm = fock(2, 0) * fock(2, 1).dag(); omega = 2.0 * np.pi * 1.0; H0 = -0.5 * omega * sigmaz(); gamma = 1/10000; data = mcsolve(; [H0], psi0, times, [np.sqrt(gamma) * sm], [sm.dag() * sm], ntraj=100; ); data_imp = mcsolve(; [H0], psi0, times, [np.sqrt(gamma) * sm], [sm.dag() * sm], ntraj=100,; options={""improved_sampling"": True}; ). plt.figure(); plt.plot(times, data.expect[0], label=""original""); plt.plot(times, data_imp.expect[0], label=""improved sampling""); plt.plot(times, np.exp(-gamma * times), label=r""$\exp(-\gamma t)$""); plt.title('Monte Carlo: improved sampling algorithm'); plt.xlabel(""time [ns]""); plt.ylabel(r""$p_{1}$""); plt.legend(); plt.show(). The original sampling algorithm samples the no-jump traject",MatchSource.DOCS,doc/guide/dynamics/dynamics-monte.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-monte.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-monte.rst:4313,Performance,perform,performed,4313,"tor :math:`C_{n}` is chosen such that :math:`n` is the smallest; integer satisfying:. .. math::; :label: mc3. \sum_{i=1}^{n} P_{n}(\tau) \ge r_2. where the individual :math:`P_{n}` are given by Eq. :eq:`pcn`. Note that the; left hand side of Eq. :eq:`mc3` is, by definition, normalized to unity. - **IV:** Using the renormalized state from step III as the new initial; condition at time :math:`\tau`, draw a new random number, and repeat the; above procedure until the final simulation time is reached. .. _monte-qutip:. Monte Carlo in QuTiP; ====================. In QuTiP, Monte Carlo evolution is implemented with the :func:`.mcsolve`; function. It takes nearly the same arguments as the :func:`.mesolve`; function for master-equation evolution, except that the initial state must be a; ket vector, as oppose to a density matrix, and there is an optional keyword; parameter ``ntraj`` that defines the number of stochastic trajectories to be; simulated. By default, ``ntraj=500`` indicating that 500 Monte Carlo; trajectories will be performed. To illustrate the use of the Monte Carlo evolution of quantum systems in QuTiP,; let's again consider the case of a two-level atom coupled to a leaky cavity.; The only differences to the master-equation treatment is that in this case we; invoke the :func:`.mcsolve` function instead of :func:`.mesolve`. .. plot::; :context: reset. times = np.linspace(0.0, 10.0, 200); psi0 = tensor(fock(2, 0), fock(10, 8)); a = tensor(qeye(2), destroy(10)); sm = tensor(destroy(2), qeye(10)); H = 2*np.pi*a.dag()*a + 2*np.pi*sm.dag()*sm + 2*np.pi*0.25*(sm*a.dag() + sm.dag()*a); data = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], e_ops=[a.dag() * a, sm.dag() * sm]). plt.figure(); plt.plot(times, data.expect[0], times, data.expect[1]); plt.title('Monte Carlo time evolution'); plt.xlabel('Time'); plt.ylabel('Expectation values'); plt.legend((""cavity photon number"", ""atom excitation probability"")); plt.show(). .. guide-dynamics-mc1:. The advantage of the Monte Carlo",MatchSource.DOCS,doc/guide/dynamics/dynamics-monte.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-monte.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-monte.rst:8444,Safety,timeout,timeout,8444,"------------------------------. By default, the ``mcsolve`` function runs 500 trajectories.; This value was chosen because it gives good accuracy, Monte Carlo errors scale; as :math:`1/n` where :math:`n` is the number of trajectories, and simultaneously; does not take an excessive amount of time to run. However, you can change the; number of trajectories to fit your needs. In order to run 1000 trajectories in; the above example, we can simply modify the call to ``mcsolve`` like:. .. code-block::. data = mcsolve(H, psi0, times, c_ops e_ops=e_ops, ntraj=1000). where we have added the keyword argument ``ntraj=1000`` at the end of the inputs.; Now, the Monte Carlo solver will calculate expectation values for both operators,; ``a.dag() * a, sm.dag() * sm`` averaging over 1000 trajectories. Other than a target number of trajectories, it is possible to use a computation; time or errors bars as condition to stop computing trajectories. ``timeout`` is quite simple as ``mcsolve`` will stop starting the computation of; new trajectories when it is reached. Thus:. .. code-block::. data = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], e_ops=e_ops, ntraj=1000, timeout=60). Will compute 60 seconds of trajectories or 1000, which ever is reached first.; The solver will finish any trajectory started when the timeout is reached. Therefore; if the computation time of a single trajectory is quite long, the overall computation; time can be much longer that the provided timeout. Lastly, ``mcsolve`` can be instructed to stop when the statistical error of the; expectation values get under a certain value. When computing the average over; trajectories, the error on these are computed using; `jackknife resampling <https://en.wikipedia.org/wiki/Jackknife_resampling>`_; for each expect and each time and the computation will be stopped when all these values; are under the tolerance passed to ``target_tol``. Therefore:. .. code-block::. data = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], e_ops=e_ops,; ",MatchSource.DOCS,doc/guide/dynamics/dynamics-monte.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-monte.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-monte.rst:8661,Safety,timeout,timeout,8661,"te Carlo errors scale; as :math:`1/n` where :math:`n` is the number of trajectories, and simultaneously; does not take an excessive amount of time to run. However, you can change the; number of trajectories to fit your needs. In order to run 1000 trajectories in; the above example, we can simply modify the call to ``mcsolve`` like:. .. code-block::. data = mcsolve(H, psi0, times, c_ops e_ops=e_ops, ntraj=1000). where we have added the keyword argument ``ntraj=1000`` at the end of the inputs.; Now, the Monte Carlo solver will calculate expectation values for both operators,; ``a.dag() * a, sm.dag() * sm`` averaging over 1000 trajectories. Other than a target number of trajectories, it is possible to use a computation; time or errors bars as condition to stop computing trajectories. ``timeout`` is quite simple as ``mcsolve`` will stop starting the computation of; new trajectories when it is reached. Thus:. .. code-block::. data = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], e_ops=e_ops, ntraj=1000, timeout=60). Will compute 60 seconds of trajectories or 1000, which ever is reached first.; The solver will finish any trajectory started when the timeout is reached. Therefore; if the computation time of a single trajectory is quite long, the overall computation; time can be much longer that the provided timeout. Lastly, ``mcsolve`` can be instructed to stop when the statistical error of the; expectation values get under a certain value. When computing the average over; trajectories, the error on these are computed using; `jackknife resampling <https://en.wikipedia.org/wiki/Jackknife_resampling>`_; for each expect and each time and the computation will be stopped when all these values; are under the tolerance passed to ``target_tol``. Therefore:. .. code-block::. data = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], e_ops=e_ops,; ntraj=1000, target_tol=0.01, timeout=600). will stop either after all errors bars on expectation values are under ``0.01``, 1000; trajectories are co",MatchSource.DOCS,doc/guide/dynamics/dynamics-monte.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-monte.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-monte.rst:8808,Safety,timeout,timeout,8808,"of time to run. However, you can change the; number of trajectories to fit your needs. In order to run 1000 trajectories in; the above example, we can simply modify the call to ``mcsolve`` like:. .. code-block::. data = mcsolve(H, psi0, times, c_ops e_ops=e_ops, ntraj=1000). where we have added the keyword argument ``ntraj=1000`` at the end of the inputs.; Now, the Monte Carlo solver will calculate expectation values for both operators,; ``a.dag() * a, sm.dag() * sm`` averaging over 1000 trajectories. Other than a target number of trajectories, it is possible to use a computation; time or errors bars as condition to stop computing trajectories. ``timeout`` is quite simple as ``mcsolve`` will stop starting the computation of; new trajectories when it is reached. Thus:. .. code-block::. data = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], e_ops=e_ops, ntraj=1000, timeout=60). Will compute 60 seconds of trajectories or 1000, which ever is reached first.; The solver will finish any trajectory started when the timeout is reached. Therefore; if the computation time of a single trajectory is quite long, the overall computation; time can be much longer that the provided timeout. Lastly, ``mcsolve`` can be instructed to stop when the statistical error of the; expectation values get under a certain value. When computing the average over; trajectories, the error on these are computed using; `jackknife resampling <https://en.wikipedia.org/wiki/Jackknife_resampling>`_; for each expect and each time and the computation will be stopped when all these values; are under the tolerance passed to ``target_tol``. Therefore:. .. code-block::. data = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], e_ops=e_ops,; ntraj=1000, target_tol=0.01, timeout=600). will stop either after all errors bars on expectation values are under ``0.01``, 1000; trajectories are computed or 10 minutes have passed, whichever comes first. When a; single values is passed, it is used as the absolute value of the tolerance",MatchSource.DOCS,doc/guide/dynamics/dynamics-monte.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-monte.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-monte.rst:8968,Safety,timeout,timeout,8968,"ectories in; the above example, we can simply modify the call to ``mcsolve`` like:. .. code-block::. data = mcsolve(H, psi0, times, c_ops e_ops=e_ops, ntraj=1000). where we have added the keyword argument ``ntraj=1000`` at the end of the inputs.; Now, the Monte Carlo solver will calculate expectation values for both operators,; ``a.dag() * a, sm.dag() * sm`` averaging over 1000 trajectories. Other than a target number of trajectories, it is possible to use a computation; time or errors bars as condition to stop computing trajectories. ``timeout`` is quite simple as ``mcsolve`` will stop starting the computation of; new trajectories when it is reached. Thus:. .. code-block::. data = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], e_ops=e_ops, ntraj=1000, timeout=60). Will compute 60 seconds of trajectories or 1000, which ever is reached first.; The solver will finish any trajectory started when the timeout is reached. Therefore; if the computation time of a single trajectory is quite long, the overall computation; time can be much longer that the provided timeout. Lastly, ``mcsolve`` can be instructed to stop when the statistical error of the; expectation values get under a certain value. When computing the average over; trajectories, the error on these are computed using; `jackknife resampling <https://en.wikipedia.org/wiki/Jackknife_resampling>`_; for each expect and each time and the computation will be stopped when all these values; are under the tolerance passed to ``target_tol``. Therefore:. .. code-block::. data = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], e_ops=e_ops,; ntraj=1000, target_tol=0.01, timeout=600). will stop either after all errors bars on expectation values are under ``0.01``, 1000; trajectories are computed or 10 minutes have passed, whichever comes first. When a; single values is passed, it is used as the absolute value of the tolerance.; When a pair of values is passed, it is understood as an absolute and relative; tolerance pair. For even finer ",MatchSource.DOCS,doc/guide/dynamics/dynamics-monte.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-monte.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-monte.rst:9530,Safety,timeout,timeout,9530,"tories when it is reached. Thus:. .. code-block::. data = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], e_ops=e_ops, ntraj=1000, timeout=60). Will compute 60 seconds of trajectories or 1000, which ever is reached first.; The solver will finish any trajectory started when the timeout is reached. Therefore; if the computation time of a single trajectory is quite long, the overall computation; time can be much longer that the provided timeout. Lastly, ``mcsolve`` can be instructed to stop when the statistical error of the; expectation values get under a certain value. When computing the average over; trajectories, the error on these are computed using; `jackknife resampling <https://en.wikipedia.org/wiki/Jackknife_resampling>`_; for each expect and each time and the computation will be stopped when all these values; are under the tolerance passed to ``target_tol``. Therefore:. .. code-block::. data = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], e_ops=e_ops,; ntraj=1000, target_tol=0.01, timeout=600). will stop either after all errors bars on expectation values are under ``0.01``, 1000; trajectories are computed or 10 minutes have passed, whichever comes first. When a; single values is passed, it is used as the absolute value of the tolerance.; When a pair of values is passed, it is understood as an absolute and relative; tolerance pair. For even finer control, one such pair can be passed for each ``e_ops``.; For example:. .. code-block::. data = mcsolve(H, psi0, times, c_ops, e_ops=e_ops, target_tol=[; (1e-5, 0.1),; (0, 0),; ]). will stop when the error bars on the expectation values of the first ``e_ops`` are; under 10% of their average values. If after computation of some trajectories, it is determined that more are needed, it; is possible to add trajectories to existing result by adding result together:. .. code-block::. >>> run1 = mcsolve(H, psi, times, c_ops, e_ops=e_ops, ntraj=25); >>> print(run1.num_trajectories); 25; >>> run2 = mcsolve(H, psi, times, c_ops, e_ops=e",MatchSource.DOCS,doc/guide/dynamics/dynamics-monte.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-monte.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-monte.rst:17186,Safety,detect,detections,17186,"wn_key=(1,),),; SeedSequence(entropy=1,spawn_key=(0,),),; SeedSequence(entropy=1,spawn_key=(2,),)]. >>> print(res_ser.seeds[:3]); [SeedSequence(entropy=1,spawn_key=(0,),),; SeedSequence(entropy=1,spawn_key=(1,),),; SeedSequence(entropy=1,spawn_key=(2,),)]. Photocurrent; ------------. The photocurrent, previously computed using the ``photocurrent_sesolve`` and; ``photocurrent_sesolve`` functions, are now included in the output of; :func:`.mcsolve` as ``result.photocurrent``. .. plot::; :context: close-figs. times = np.linspace(0.0, 10.0, 200); psi0 = tensor(fock(2, 0), fock(10, 8)); a = tensor(qeye(2), destroy(10)); sm = tensor(destroy(2), qeye(10)); e_ops = [a.dag() * a, sm.dag() * sm]; H = 2*np.pi*a.dag()*a + 2*np.pi*sm.dag()*sm + 2*np.pi*0.25*(sm*a.dag() + sm.dag()*a); data = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], e_ops=e_ops). plt.figure(); plt.plot((times[:-1] + times[1:])/2, data.photocurrent[0]); plt.title('Monte Carlo Photocurrent'); plt.xlabel('Time'); plt.ylabel('Photon detections'); plt.show(). .. openmcsolve:. Open Systems; ------------. ``mcsolve`` can be used to study systems which have measurement and dissipative; interactions with their environment. This is done by passing a Liouvillian including the; dissipative interaction to the solver instead of a Hamiltonian.; In this case the effective Liouvillian becomes:. .. math::; :label: Leff. L_{\rm eff}\rho = L_{\rm sys}\rho -\frac{1}{2}\sum_{i}\left( C^{+}_{n}C_{n}\rho + \rho C^{+}_{n}C_{n}\right),. With the collapse probability becoming:. .. math::; :label: L_jump. \delta p =\delta t \sum_{n}\mathrm{tr}\left(\rho(t)C^{+}_{n}C_{n}\right),. And a jump with the collapse operator ``n`` changing the state as:. .. math::; :label: L_project. \rho(t+\delta t) = C_{n} \rho(t) C^{+}_{n} / \mathrm{tr}\left( C_{n} \rho(t) C^{+}_{n} \right),. We can redo the previous example for a situation where only half the emitted photons are detected. .. plot::; :context: close-figs. times = np.linspace(0.0, 10.0, 200); psi",MatchSource.DOCS,doc/guide/dynamics/dynamics-monte.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-monte.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-monte.rst:18105,Safety,detect,detected,18105,"fock(2, 0), fock(10, 8)); a = tensor(qeye(2), destroy(10)); sm = tensor(destroy(2), qeye(10)); e_ops = [a.dag() * a, sm.dag() * sm]; H = 2*np.pi*a.dag()*a + 2*np.pi*sm.dag()*sm + 2*np.pi*0.25*(sm*a.dag() + sm.dag()*a); data = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], e_ops=e_ops). plt.figure(); plt.plot((times[:-1] + times[1:])/2, data.photocurrent[0]); plt.title('Monte Carlo Photocurrent'); plt.xlabel('Time'); plt.ylabel('Photon detections'); plt.show(). .. openmcsolve:. Open Systems; ------------. ``mcsolve`` can be used to study systems which have measurement and dissipative; interactions with their environment. This is done by passing a Liouvillian including the; dissipative interaction to the solver instead of a Hamiltonian.; In this case the effective Liouvillian becomes:. .. math::; :label: Leff. L_{\rm eff}\rho = L_{\rm sys}\rho -\frac{1}{2}\sum_{i}\left( C^{+}_{n}C_{n}\rho + \rho C^{+}_{n}C_{n}\right),. With the collapse probability becoming:. .. math::; :label: L_jump. \delta p =\delta t \sum_{n}\mathrm{tr}\left(\rho(t)C^{+}_{n}C_{n}\right),. And a jump with the collapse operator ``n`` changing the state as:. .. math::; :label: L_project. \rho(t+\delta t) = C_{n} \rho(t) C^{+}_{n} / \mathrm{tr}\left( C_{n} \rho(t) C^{+}_{n} \right),. We can redo the previous example for a situation where only half the emitted photons are detected. .. plot::; :context: close-figs. times = np.linspace(0.0, 10.0, 200); psi0 = tensor(fock(2, 0), fock(10, 8)); a = tensor(qeye(2), destroy(10)); sm = tensor(destroy(2), qeye(10)); H = 2*np.pi*a.dag()*a + 2*np.pi*sm.dag()*sm + 2*np.pi*0.25*(sm*a.dag() + sm.dag()*a); L = liouvillian(H, [np.sqrt(0.05) * a]); data = mcsolve(L, psi0, times, [np.sqrt(0.05) * a], e_ops=[a.dag() * a, sm.dag() * sm]). plt.figure(); plt.plot((times[:-1] + times[1:])/2, data.photocurrent[0]); plt.title('Monte Carlo Photocurrent'); plt.xlabel('Time'); plt.ylabel('Photon detections'); plt.show(). .. plot::; :context: reset; :include-source: false; :nofigs:; ",MatchSource.DOCS,doc/guide/dynamics/dynamics-monte.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-monte.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-monte.rst:18662,Safety,detect,detections,18662,"fock(2, 0), fock(10, 8)); a = tensor(qeye(2), destroy(10)); sm = tensor(destroy(2), qeye(10)); e_ops = [a.dag() * a, sm.dag() * sm]; H = 2*np.pi*a.dag()*a + 2*np.pi*sm.dag()*sm + 2*np.pi*0.25*(sm*a.dag() + sm.dag()*a); data = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], e_ops=e_ops). plt.figure(); plt.plot((times[:-1] + times[1:])/2, data.photocurrent[0]); plt.title('Monte Carlo Photocurrent'); plt.xlabel('Time'); plt.ylabel('Photon detections'); plt.show(). .. openmcsolve:. Open Systems; ------------. ``mcsolve`` can be used to study systems which have measurement and dissipative; interactions with their environment. This is done by passing a Liouvillian including the; dissipative interaction to the solver instead of a Hamiltonian.; In this case the effective Liouvillian becomes:. .. math::; :label: Leff. L_{\rm eff}\rho = L_{\rm sys}\rho -\frac{1}{2}\sum_{i}\left( C^{+}_{n}C_{n}\rho + \rho C^{+}_{n}C_{n}\right),. With the collapse probability becoming:. .. math::; :label: L_jump. \delta p =\delta t \sum_{n}\mathrm{tr}\left(\rho(t)C^{+}_{n}C_{n}\right),. And a jump with the collapse operator ``n`` changing the state as:. .. math::; :label: L_project. \rho(t+\delta t) = C_{n} \rho(t) C^{+}_{n} / \mathrm{tr}\left( C_{n} \rho(t) C^{+}_{n} \right),. We can redo the previous example for a situation where only half the emitted photons are detected. .. plot::; :context: close-figs. times = np.linspace(0.0, 10.0, 200); psi0 = tensor(fock(2, 0), fock(10, 8)); a = tensor(qeye(2), destroy(10)); sm = tensor(destroy(2), qeye(10)); H = 2*np.pi*a.dag()*a + 2*np.pi*sm.dag()*sm + 2*np.pi*0.25*(sm*a.dag() + sm.dag()*a); L = liouvillian(H, [np.sqrt(0.05) * a]); data = mcsolve(L, psi0, times, [np.sqrt(0.05) * a], e_ops=[a.dag() * a, sm.dag() * sm]). plt.figure(); plt.plot((times[:-1] + times[1:])/2, data.photocurrent[0]); plt.title('Monte Carlo Photocurrent'); plt.xlabel('Time'); plt.ylabel('Photon detections'); plt.show(). .. plot::; :context: reset; :include-source: false; :nofigs:; ",MatchSource.DOCS,doc/guide/dynamics/dynamics-monte.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-monte.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-monte.rst:5225,Usability,guid,guide-dynamics-,5225,"y default, ``ntraj=500`` indicating that 500 Monte Carlo; trajectories will be performed. To illustrate the use of the Monte Carlo evolution of quantum systems in QuTiP,; let's again consider the case of a two-level atom coupled to a leaky cavity.; The only differences to the master-equation treatment is that in this case we; invoke the :func:`.mcsolve` function instead of :func:`.mesolve`. .. plot::; :context: reset. times = np.linspace(0.0, 10.0, 200); psi0 = tensor(fock(2, 0), fock(10, 8)); a = tensor(qeye(2), destroy(10)); sm = tensor(destroy(2), qeye(10)); H = 2*np.pi*a.dag()*a + 2*np.pi*sm.dag()*sm + 2*np.pi*0.25*(sm*a.dag() + sm.dag()*a); data = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], e_ops=[a.dag() * a, sm.dag() * sm]). plt.figure(); plt.plot(times, data.expect[0], times, data.expect[1]); plt.title('Monte Carlo time evolution'); plt.xlabel('Time'); plt.ylabel('Expectation values'); plt.legend((""cavity photon number"", ""atom excitation probability"")); plt.show(). .. guide-dynamics-mc1:. The advantage of the Monte Carlo method over the master equation approach is that; only the state vector is required to be kept in the computers memory, as opposed; to the entire density matrix. For large quantum system this becomes a significant; advantage, and the Monte Carlo solver is therefore generally recommended for such; systems. For example, simulating a Heisenberg spin-chain consisting of 10 spins; with random parameters and initial states takes almost 7 times longer using the; master equation rather than Monte Carlo approach with the default number of; trajectories running on a quad-CPU machine. Furthermore, it takes about 7 times; the memory as well. However, for small systems, the added overhead of averaging; a large number of stochastic trajectories to obtain the open system dynamics, as; well as starting the multiprocessing functionality, outweighs the benefit of the; minor (in this case) memory saving. Master equation methods are therefore; generally more eff",MatchSource.DOCS,doc/guide/dynamics/dynamics-monte.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-monte.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-monte.rst:7940,Usability,simpl,simply,7940," returned,; ``result.runs_states`` will be an array of length ``ntraj``. Each element; contains an array of ""Qobj"" type ket with the same number of elements as ``times``.; ``result.average_states`` is a list of density matrices computed as the average; of the states at each time step. Furthermore, the output will also contain a; list of times at which the collapse occurred, and which collapse operators did; the collapse. These can be obtained in ``result.col_times`` and; ``result.col_which`` respectively. .. _monte-ntraj:. Changing the Number of Trajectories; -----------------------------------. By default, the ``mcsolve`` function runs 500 trajectories.; This value was chosen because it gives good accuracy, Monte Carlo errors scale; as :math:`1/n` where :math:`n` is the number of trajectories, and simultaneously; does not take an excessive amount of time to run. However, you can change the; number of trajectories to fit your needs. In order to run 1000 trajectories in; the above example, we can simply modify the call to ``mcsolve`` like:. .. code-block::. data = mcsolve(H, psi0, times, c_ops e_ops=e_ops, ntraj=1000). where we have added the keyword argument ``ntraj=1000`` at the end of the inputs.; Now, the Monte Carlo solver will calculate expectation values for both operators,; ``a.dag() * a, sm.dag() * sm`` averaging over 1000 trajectories. Other than a target number of trajectories, it is possible to use a computation; time or errors bars as condition to stop computing trajectories. ``timeout`` is quite simple as ``mcsolve`` will stop starting the computation of; new trajectories when it is reached. Thus:. .. code-block::. data = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], e_ops=e_ops, ntraj=1000, timeout=60). Will compute 60 seconds of trajectories or 1000, which ever is reached first.; The solver will finish any trajectory started when the timeout is reached. Therefore; if the computation time of a single trajectory is quite long, the overall computation; time",MatchSource.DOCS,doc/guide/dynamics/dynamics-monte.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-monte.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-monte.rst:8463,Usability,simpl,simple,8463,"------------------------------. By default, the ``mcsolve`` function runs 500 trajectories.; This value was chosen because it gives good accuracy, Monte Carlo errors scale; as :math:`1/n` where :math:`n` is the number of trajectories, and simultaneously; does not take an excessive amount of time to run. However, you can change the; number of trajectories to fit your needs. In order to run 1000 trajectories in; the above example, we can simply modify the call to ``mcsolve`` like:. .. code-block::. data = mcsolve(H, psi0, times, c_ops e_ops=e_ops, ntraj=1000). where we have added the keyword argument ``ntraj=1000`` at the end of the inputs.; Now, the Monte Carlo solver will calculate expectation values for both operators,; ``a.dag() * a, sm.dag() * sm`` averaging over 1000 trajectories. Other than a target number of trajectories, it is possible to use a computation; time or errors bars as condition to stop computing trajectories. ``timeout`` is quite simple as ``mcsolve`` will stop starting the computation of; new trajectories when it is reached. Thus:. .. code-block::. data = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], e_ops=e_ops, ntraj=1000, timeout=60). Will compute 60 seconds of trajectories or 1000, which ever is reached first.; The solver will finish any trajectory started when the timeout is reached. Therefore; if the computation time of a single trajectory is quite long, the overall computation; time can be much longer that the provided timeout. Lastly, ``mcsolve`` can be instructed to stop when the statistical error of the; expectation values get under a certain value. When computing the average over; trajectories, the error on these are computed using; `jackknife resampling <https://en.wikipedia.org/wiki/Jackknife_resampling>`_; for each expect and each time and the computation will be stopped when all these values; are under the tolerance passed to ``target_tol``. Therefore:. .. code-block::. data = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], e_ops=e_ops,; ",MatchSource.DOCS,doc/guide/dynamics/dynamics-monte.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-monte.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-nmmonte.rst:3731,Deployability,integrat,integration,3731,"csolve`` requires collapse operators :math:`A_n` and target ""rates""; :math:`\gamma_n` (which are allowed to take negative values) to be given in list; form ``[[C_1, gamma_1], [C_2, gamma_2], ...]``. Note that we give the actual; rate and not its square root, and that ``nm_mcsolve`` automatically computes; associated jump rates :math:`\Gamma_n(t)\geq0` appropriate for simulation. We conclude with a simple example demonstrating the usage of the ``nm_mcsolve``; function. For more elaborate, physically motivated examples, we refer to the; `accompanying tutorial notebook <https://github.com/qutip/qutip-tutorials/blob/main/tutorials-v5/time-evolution/013_nonmarkovian_monte_carlo.md>`_. .. plot::; :context: reset. times = np.linspace(0, 1, 201); psi0 = basis(2, 1); a0 = destroy(2); H = a0.dag() * a0. # Rate functions; gamma1 = ""kappa * nth""; gamma2 = ""kappa * (nth+1) + 12 * np.exp(-2*t**3) * (-np.sin(15*t)**2)""; # gamma2 becomes negative during some time intervals. # nm_mcsolve integration; ops_and_rates = []; ops_and_rates.append([a0.dag(), gamma1]); ops_and_rates.append([a0, gamma2]); MCSol = nm_mcsolve(H, psi0, times, ops_and_rates,; args={'kappa': 1.0 / 0.129, 'nth': 0.063},; e_ops=[a0.dag() * a0, a0 * a0.dag()],; options={'map': 'parallel'}, ntraj=2500). # mesolve integration for comparison; d_ops = [[lindblad_dissipator(a0.dag(), a0.dag()), gamma1],; [lindblad_dissipator(a0, a0), gamma2]]; MESol = mesolve(H, psi0, times, d_ops, e_ops=[a0.dag() * a0, a0 * a0.dag()],; args={'kappa': 1.0 / 0.129, 'nth': 0.063}). plt.figure(); plt.plot(times, MCSol.expect[0], 'g',; times, MCSol.expect[1], 'b',; times, MCSol.trace, 'r'); plt.plot(times, MESol.expect[0], 'g--',; times, MESol.expect[1], 'b--'); plt.title('Monte Carlo time evolution'); plt.xlabel('Time'); plt.ylabel('Expectation values'); plt.legend((r'$\langle 1 | \rho | 1 \rangle$',; r'$\langle 0 | \rho | 0 \rangle$',; r'$\operatorname{tr} \rho$')); plt.show(). .. plot::; :context: reset; :include-source: false; :nofigs:; ",MatchSource.DOCS,doc/guide/dynamics/dynamics-nmmonte.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-nmmonte.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-nmmonte.rst:4028,Deployability,integrat,integration,4028,"csolve`` requires collapse operators :math:`A_n` and target ""rates""; :math:`\gamma_n` (which are allowed to take negative values) to be given in list; form ``[[C_1, gamma_1], [C_2, gamma_2], ...]``. Note that we give the actual; rate and not its square root, and that ``nm_mcsolve`` automatically computes; associated jump rates :math:`\Gamma_n(t)\geq0` appropriate for simulation. We conclude with a simple example demonstrating the usage of the ``nm_mcsolve``; function. For more elaborate, physically motivated examples, we refer to the; `accompanying tutorial notebook <https://github.com/qutip/qutip-tutorials/blob/main/tutorials-v5/time-evolution/013_nonmarkovian_monte_carlo.md>`_. .. plot::; :context: reset. times = np.linspace(0, 1, 201); psi0 = basis(2, 1); a0 = destroy(2); H = a0.dag() * a0. # Rate functions; gamma1 = ""kappa * nth""; gamma2 = ""kappa * (nth+1) + 12 * np.exp(-2*t**3) * (-np.sin(15*t)**2)""; # gamma2 becomes negative during some time intervals. # nm_mcsolve integration; ops_and_rates = []; ops_and_rates.append([a0.dag(), gamma1]); ops_and_rates.append([a0, gamma2]); MCSol = nm_mcsolve(H, psi0, times, ops_and_rates,; args={'kappa': 1.0 / 0.129, 'nth': 0.063},; e_ops=[a0.dag() * a0, a0 * a0.dag()],; options={'map': 'parallel'}, ntraj=2500). # mesolve integration for comparison; d_ops = [[lindblad_dissipator(a0.dag(), a0.dag()), gamma1],; [lindblad_dissipator(a0, a0), gamma2]]; MESol = mesolve(H, psi0, times, d_ops, e_ops=[a0.dag() * a0, a0 * a0.dag()],; args={'kappa': 1.0 / 0.129, 'nth': 0.063}). plt.figure(); plt.plot(times, MCSol.expect[0], 'g',; times, MCSol.expect[1], 'b',; times, MCSol.trace, 'r'); plt.plot(times, MESol.expect[0], 'g--',; times, MESol.expect[1], 'b--'); plt.title('Monte Carlo time evolution'); plt.xlabel('Time'); plt.ylabel('Expectation values'); plt.legend((r'$\langle 1 | \rho | 1 \rangle$',; r'$\langle 0 | \rho | 0 \rangle$',; r'$\operatorname{tr} \rho$')); plt.show(). .. plot::; :context: reset; :include-source: false; :nofigs:; ",MatchSource.DOCS,doc/guide/dynamics/dynamics-nmmonte.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-nmmonte.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-nmmonte.rst:3731,Integrability,integrat,integration,3731,"csolve`` requires collapse operators :math:`A_n` and target ""rates""; :math:`\gamma_n` (which are allowed to take negative values) to be given in list; form ``[[C_1, gamma_1], [C_2, gamma_2], ...]``. Note that we give the actual; rate and not its square root, and that ``nm_mcsolve`` automatically computes; associated jump rates :math:`\Gamma_n(t)\geq0` appropriate for simulation. We conclude with a simple example demonstrating the usage of the ``nm_mcsolve``; function. For more elaborate, physically motivated examples, we refer to the; `accompanying tutorial notebook <https://github.com/qutip/qutip-tutorials/blob/main/tutorials-v5/time-evolution/013_nonmarkovian_monte_carlo.md>`_. .. plot::; :context: reset. times = np.linspace(0, 1, 201); psi0 = basis(2, 1); a0 = destroy(2); H = a0.dag() * a0. # Rate functions; gamma1 = ""kappa * nth""; gamma2 = ""kappa * (nth+1) + 12 * np.exp(-2*t**3) * (-np.sin(15*t)**2)""; # gamma2 becomes negative during some time intervals. # nm_mcsolve integration; ops_and_rates = []; ops_and_rates.append([a0.dag(), gamma1]); ops_and_rates.append([a0, gamma2]); MCSol = nm_mcsolve(H, psi0, times, ops_and_rates,; args={'kappa': 1.0 / 0.129, 'nth': 0.063},; e_ops=[a0.dag() * a0, a0 * a0.dag()],; options={'map': 'parallel'}, ntraj=2500). # mesolve integration for comparison; d_ops = [[lindblad_dissipator(a0.dag(), a0.dag()), gamma1],; [lindblad_dissipator(a0, a0), gamma2]]; MESol = mesolve(H, psi0, times, d_ops, e_ops=[a0.dag() * a0, a0 * a0.dag()],; args={'kappa': 1.0 / 0.129, 'nth': 0.063}). plt.figure(); plt.plot(times, MCSol.expect[0], 'g',; times, MCSol.expect[1], 'b',; times, MCSol.trace, 'r'); plt.plot(times, MESol.expect[0], 'g--',; times, MESol.expect[1], 'b--'); plt.title('Monte Carlo time evolution'); plt.xlabel('Time'); plt.ylabel('Expectation values'); plt.legend((r'$\langle 1 | \rho | 1 \rangle$',; r'$\langle 0 | \rho | 0 \rangle$',; r'$\operatorname{tr} \rho$')); plt.show(). .. plot::; :context: reset; :include-source: false; :nofigs:; ",MatchSource.DOCS,doc/guide/dynamics/dynamics-nmmonte.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-nmmonte.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-nmmonte.rst:4028,Integrability,integrat,integration,4028,"csolve`` requires collapse operators :math:`A_n` and target ""rates""; :math:`\gamma_n` (which are allowed to take negative values) to be given in list; form ``[[C_1, gamma_1], [C_2, gamma_2], ...]``. Note that we give the actual; rate and not its square root, and that ``nm_mcsolve`` automatically computes; associated jump rates :math:`\Gamma_n(t)\geq0` appropriate for simulation. We conclude with a simple example demonstrating the usage of the ``nm_mcsolve``; function. For more elaborate, physically motivated examples, we refer to the; `accompanying tutorial notebook <https://github.com/qutip/qutip-tutorials/blob/main/tutorials-v5/time-evolution/013_nonmarkovian_monte_carlo.md>`_. .. plot::; :context: reset. times = np.linspace(0, 1, 201); psi0 = basis(2, 1); a0 = destroy(2); H = a0.dag() * a0. # Rate functions; gamma1 = ""kappa * nth""; gamma2 = ""kappa * (nth+1) + 12 * np.exp(-2*t**3) * (-np.sin(15*t)**2)""; # gamma2 becomes negative during some time intervals. # nm_mcsolve integration; ops_and_rates = []; ops_and_rates.append([a0.dag(), gamma1]); ops_and_rates.append([a0, gamma2]); MCSol = nm_mcsolve(H, psi0, times, ops_and_rates,; args={'kappa': 1.0 / 0.129, 'nth': 0.063},; e_ops=[a0.dag() * a0, a0 * a0.dag()],; options={'map': 'parallel'}, ntraj=2500). # mesolve integration for comparison; d_ops = [[lindblad_dissipator(a0.dag(), a0.dag()), gamma1],; [lindblad_dissipator(a0, a0), gamma2]]; MESol = mesolve(H, psi0, times, d_ops, e_ops=[a0.dag() * a0, a0 * a0.dag()],; args={'kappa': 1.0 / 0.129, 'nth': 0.063}). plt.figure(); plt.plot(times, MCSol.expect[0], 'g',; times, MCSol.expect[1], 'b',; times, MCSol.trace, 'r'); plt.plot(times, MESol.expect[0], 'g--',; times, MESol.expect[1], 'b--'); plt.title('Monte Carlo time evolution'); plt.xlabel('Time'); plt.ylabel('Expectation values'); plt.legend((r'$\langle 1 | \rho | 1 \rangle$',; r'$\langle 0 | \rho | 0 \rangle$',; r'$\operatorname{tr} \rho$')); plt.show(). .. plot::; :context: reset; :include-source: false; :nofigs:; ",MatchSource.DOCS,doc/guide/dynamics/dynamics-nmmonte.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-nmmonte.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-nmmonte.rst:1496,Modifiability,evolve,evolves,1496," A_n^\dagger A_n - A_n^\dagger A_n \rho(t)\right]. with ""rates"" :math:`\gamma_n(t)` that can take negative values.; This can be done with the :func:`.nm_mcsolve` function.; The function is based on the influence martingale formalism [Donvil22]_ and; formally requires that the collapse operators :math:`A_n` satisfy a completeness; relation of the form. .. math::; :label: nmmcsolve_completeness. \sum_n A_n^\dagger A_n = \alpha \mathbb{I} ,. where :math:`\mathbb{I}` is the identity operator on the system Hilbert space; and :math:`\alpha>0`.; Note that when the collapse operators of a model don't satisfy such a relation,; ``nm_mcsolve`` automatically adds an extra collapse operator such that; :eq:`nmmcsolve_completeness` is satisfied.; The rate corresponding to this extra collapse operator is set to zero. Technically, the influence martingale formalism works as follows.; We introduce an influence martingale :math:`\mu(t)`, which follows the evolution; of the system state. When no jump happens, it evolves as. .. math::; :label: influence_cont. \mu(t) = \exp\left( \alpha\int_0^t K(\tau) d\tau \right). where :math:`K(t)` is for now an arbitrary function.; When a jump corresponding to the collapse operator :math:`A_n` happens, the; influence martingale becomes. .. math::; :label: influence_disc. \mu(t+\delta t) = \mu(t)\left(\frac{K(t)-\gamma_n(t)}{\gamma_n(t)}\right). Assuming that the state :math:`\bar\rho(t)` computed by the Monte Carlo average. .. math::; :label: mc_paired_state. \bar\rho(t) = \frac{1}{N}\sum_{l=1}^N |\psi_l(t)\rangle\langle \psi_l(t)|. solves a Lindblad master equation with collapse operators :math:`A_n` and rates; :math:`\Gamma_n(t)`, the state :math:`\rho(t)` defined by. .. math::; :label: mc_martingale_state. \rho(t) = \frac{1}{N}\sum_{l=1}^N \mu_l(t) |\psi_l(t)\rangle\langle \psi_l(t)|. solves a Lindblad master equation with collapse operators :math:`A_n` and shifted; rates :math:`\gamma_n(t)-K(t)`. Thus, while :math:`\Gamma_n(t) \geq 0`, the new; """,MatchSource.DOCS,doc/guide/dynamics/dynamics-nmmonte.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-nmmonte.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-nmmonte.rst:3146,Usability,simpl,simple,3146,"tate :math:`\rho(t)` defined by. .. math::; :label: mc_martingale_state. \rho(t) = \frac{1}{N}\sum_{l=1}^N \mu_l(t) |\psi_l(t)\rangle\langle \psi_l(t)|. solves a Lindblad master equation with collapse operators :math:`A_n` and shifted; rates :math:`\gamma_n(t)-K(t)`. Thus, while :math:`\Gamma_n(t) \geq 0`, the new; ""rates"" :math:`\gamma_n(t) = \Gamma_n(t) - K(t)` satisfy no positivity requirement. The input of :func:`.nm_mcsolve` is almost the same as for :func:`.mcsolve`.; The only difference is how the collapse operators and rate functions should be; defined. ``nm_mcsolve`` requires collapse operators :math:`A_n` and target ""rates""; :math:`\gamma_n` (which are allowed to take negative values) to be given in list; form ``[[C_1, gamma_1], [C_2, gamma_2], ...]``. Note that we give the actual; rate and not its square root, and that ``nm_mcsolve`` automatically computes; associated jump rates :math:`\Gamma_n(t)\geq0` appropriate for simulation. We conclude with a simple example demonstrating the usage of the ``nm_mcsolve``; function. For more elaborate, physically motivated examples, we refer to the; `accompanying tutorial notebook <https://github.com/qutip/qutip-tutorials/blob/main/tutorials-v5/time-evolution/013_nonmarkovian_monte_carlo.md>`_. .. plot::; :context: reset. times = np.linspace(0, 1, 201); psi0 = basis(2, 1); a0 = destroy(2); H = a0.dag() * a0. # Rate functions; gamma1 = ""kappa * nth""; gamma2 = ""kappa * (nth+1) + 12 * np.exp(-2*t**3) * (-np.sin(15*t)**2)""; # gamma2 becomes negative during some time intervals. # nm_mcsolve integration; ops_and_rates = []; ops_and_rates.append([a0.dag(), gamma1]); ops_and_rates.append([a0, gamma2]); MCSol = nm_mcsolve(H, psi0, times, ops_and_rates,; args={'kappa': 1.0 / 0.129, 'nth': 0.063},; e_ops=[a0.dag() * a0, a0 * a0.dag()],; options={'map': 'parallel'}, ntraj=2500). # mesolve integration for comparison; d_ops = [[lindblad_dissipator(a0.dag(), a0.dag()), gamma1],; [lindblad_dissipator(a0, a0), gamma2]]; MESol = mesolve",MatchSource.DOCS,doc/guide/dynamics/dynamics-nmmonte.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-nmmonte.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-options.rst:1194,Availability,toler,tolerance,1194,".. _options:. *********************************************; Setting Options for the Dynamics Solvers; *********************************************. .. testsetup:: [dynamics_options]. from qutip.solver.mesolve import MESolver, mesolve; import numpy as np. Occasionally it is necessary to change the built in parameters of the dynamics; solvers used by for example the :func:`.mesolve` and :func:`.mcsolve` functions.; The options for all dynamics solvers may be changed by using the dictionaries. .. testcode:: [dynamics_options]. options = {""store_states"": True, ""atol"": 1e-12}. Supported items come from 2 sources, the solver and the ODE integration method.; Supported solver options and their default can be seen using the class interface:. .. testcode:: [dynamics_options]. help(MESolver.options). Options supported by the ODE integration depend on the ""method"" options of the solver,; they can be listed through the integrator method of the solvers:. .. testcode:: [dynamics_options]. help(MESolver.integrator(""adams"").options). See :ref:`classes-ode` for a list of supported methods. As an example, let us consider changing the integrator, turn the GUI off, and; strengthen the absolute tolerance. .. testcode:: [dynamics_options]. options = {method=""bdf"", ""atol"": 1e-10, ""progress_bar"": False}. To use these new settings we can use the keyword argument ``options`` in either ; the :func:`.mesolve` and :func:`.mcsolve` function::. >>> mesolve(H0, psi0, tlist, c_op_list, [sigmaz()], options=options). or::. >>> MCSolver(H0, c_op_list, options=options); ",MatchSource.DOCS,doc/guide/dynamics/dynamics-options.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-options.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-options.rst:641,Deployability,integrat,integration,641,".. _options:. *********************************************; Setting Options for the Dynamics Solvers; *********************************************. .. testsetup:: [dynamics_options]. from qutip.solver.mesolve import MESolver, mesolve; import numpy as np. Occasionally it is necessary to change the built in parameters of the dynamics; solvers used by for example the :func:`.mesolve` and :func:`.mcsolve` functions.; The options for all dynamics solvers may be changed by using the dictionaries. .. testcode:: [dynamics_options]. options = {""store_states"": True, ""atol"": 1e-12}. Supported items come from 2 sources, the solver and the ODE integration method.; Supported solver options and their default can be seen using the class interface:. .. testcode:: [dynamics_options]. help(MESolver.options). Options supported by the ODE integration depend on the ""method"" options of the solver,; they can be listed through the integrator method of the solvers:. .. testcode:: [dynamics_options]. help(MESolver.integrator(""adams"").options). See :ref:`classes-ode` for a list of supported methods. As an example, let us consider changing the integrator, turn the GUI off, and; strengthen the absolute tolerance. .. testcode:: [dynamics_options]. options = {method=""bdf"", ""atol"": 1e-10, ""progress_bar"": False}. To use these new settings we can use the keyword argument ``options`` in either ; the :func:`.mesolve` and :func:`.mcsolve` function::. >>> mesolve(H0, psi0, tlist, c_op_list, [sigmaz()], options=options). or::. >>> MCSolver(H0, c_op_list, options=options); ",MatchSource.DOCS,doc/guide/dynamics/dynamics-options.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-options.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-options.rst:832,Deployability,integrat,integration,832,".. _options:. *********************************************; Setting Options for the Dynamics Solvers; *********************************************. .. testsetup:: [dynamics_options]. from qutip.solver.mesolve import MESolver, mesolve; import numpy as np. Occasionally it is necessary to change the built in parameters of the dynamics; solvers used by for example the :func:`.mesolve` and :func:`.mcsolve` functions.; The options for all dynamics solvers may be changed by using the dictionaries. .. testcode:: [dynamics_options]. options = {""store_states"": True, ""atol"": 1e-12}. Supported items come from 2 sources, the solver and the ODE integration method.; Supported solver options and their default can be seen using the class interface:. .. testcode:: [dynamics_options]. help(MESolver.options). Options supported by the ODE integration depend on the ""method"" options of the solver,; they can be listed through the integrator method of the solvers:. .. testcode:: [dynamics_options]. help(MESolver.integrator(""adams"").options). See :ref:`classes-ode` for a list of supported methods. As an example, let us consider changing the integrator, turn the GUI off, and; strengthen the absolute tolerance. .. testcode:: [dynamics_options]. options = {method=""bdf"", ""atol"": 1e-10, ""progress_bar"": False}. To use these new settings we can use the keyword argument ``options`` in either ; the :func:`.mesolve` and :func:`.mcsolve` function::. >>> mesolve(H0, psi0, tlist, c_op_list, [sigmaz()], options=options). or::. >>> MCSolver(H0, c_op_list, options=options); ",MatchSource.DOCS,doc/guide/dynamics/dynamics-options.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-options.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-options.rst:922,Deployability,integrat,integrator,922,".. _options:. *********************************************; Setting Options for the Dynamics Solvers; *********************************************. .. testsetup:: [dynamics_options]. from qutip.solver.mesolve import MESolver, mesolve; import numpy as np. Occasionally it is necessary to change the built in parameters of the dynamics; solvers used by for example the :func:`.mesolve` and :func:`.mcsolve` functions.; The options for all dynamics solvers may be changed by using the dictionaries. .. testcode:: [dynamics_options]. options = {""store_states"": True, ""atol"": 1e-12}. Supported items come from 2 sources, the solver and the ODE integration method.; Supported solver options and their default can be seen using the class interface:. .. testcode:: [dynamics_options]. help(MESolver.options). Options supported by the ODE integration depend on the ""method"" options of the solver,; they can be listed through the integrator method of the solvers:. .. testcode:: [dynamics_options]. help(MESolver.integrator(""adams"").options). See :ref:`classes-ode` for a list of supported methods. As an example, let us consider changing the integrator, turn the GUI off, and; strengthen the absolute tolerance. .. testcode:: [dynamics_options]. options = {method=""bdf"", ""atol"": 1e-10, ""progress_bar"": False}. To use these new settings we can use the keyword argument ``options`` in either ; the :func:`.mesolve` and :func:`.mcsolve` function::. >>> mesolve(H0, psi0, tlist, c_op_list, [sigmaz()], options=options). or::. >>> MCSolver(H0, c_op_list, options=options); ",MatchSource.DOCS,doc/guide/dynamics/dynamics-options.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-options.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-options.rst:1005,Deployability,integrat,integrator,1005,".. _options:. *********************************************; Setting Options for the Dynamics Solvers; *********************************************. .. testsetup:: [dynamics_options]. from qutip.solver.mesolve import MESolver, mesolve; import numpy as np. Occasionally it is necessary to change the built in parameters of the dynamics; solvers used by for example the :func:`.mesolve` and :func:`.mcsolve` functions.; The options for all dynamics solvers may be changed by using the dictionaries. .. testcode:: [dynamics_options]. options = {""store_states"": True, ""atol"": 1e-12}. Supported items come from 2 sources, the solver and the ODE integration method.; Supported solver options and their default can be seen using the class interface:. .. testcode:: [dynamics_options]. help(MESolver.options). Options supported by the ODE integration depend on the ""method"" options of the solver,; they can be listed through the integrator method of the solvers:. .. testcode:: [dynamics_options]. help(MESolver.integrator(""adams"").options). See :ref:`classes-ode` for a list of supported methods. As an example, let us consider changing the integrator, turn the GUI off, and; strengthen the absolute tolerance. .. testcode:: [dynamics_options]. options = {method=""bdf"", ""atol"": 1e-10, ""progress_bar"": False}. To use these new settings we can use the keyword argument ``options`` in either ; the :func:`.mesolve` and :func:`.mcsolve` function::. >>> mesolve(H0, psi0, tlist, c_op_list, [sigmaz()], options=options). or::. >>> MCSolver(H0, c_op_list, options=options); ",MatchSource.DOCS,doc/guide/dynamics/dynamics-options.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-options.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-options.rst:1135,Deployability,integrat,integrator,1135,".. _options:. *********************************************; Setting Options for the Dynamics Solvers; *********************************************. .. testsetup:: [dynamics_options]. from qutip.solver.mesolve import MESolver, mesolve; import numpy as np. Occasionally it is necessary to change the built in parameters of the dynamics; solvers used by for example the :func:`.mesolve` and :func:`.mcsolve` functions.; The options for all dynamics solvers may be changed by using the dictionaries. .. testcode:: [dynamics_options]. options = {""store_states"": True, ""atol"": 1e-12}. Supported items come from 2 sources, the solver and the ODE integration method.; Supported solver options and their default can be seen using the class interface:. .. testcode:: [dynamics_options]. help(MESolver.options). Options supported by the ODE integration depend on the ""method"" options of the solver,; they can be listed through the integrator method of the solvers:. .. testcode:: [dynamics_options]. help(MESolver.integrator(""adams"").options). See :ref:`classes-ode` for a list of supported methods. As an example, let us consider changing the integrator, turn the GUI off, and; strengthen the absolute tolerance. .. testcode:: [dynamics_options]. options = {method=""bdf"", ""atol"": 1e-10, ""progress_bar"": False}. To use these new settings we can use the keyword argument ``options`` in either ; the :func:`.mesolve` and :func:`.mcsolve` function::. >>> mesolve(H0, psi0, tlist, c_op_list, [sigmaz()], options=options). or::. >>> MCSolver(H0, c_op_list, options=options); ",MatchSource.DOCS,doc/guide/dynamics/dynamics-options.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-options.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-options.rst:641,Integrability,integrat,integration,641,".. _options:. *********************************************; Setting Options for the Dynamics Solvers; *********************************************. .. testsetup:: [dynamics_options]. from qutip.solver.mesolve import MESolver, mesolve; import numpy as np. Occasionally it is necessary to change the built in parameters of the dynamics; solvers used by for example the :func:`.mesolve` and :func:`.mcsolve` functions.; The options for all dynamics solvers may be changed by using the dictionaries. .. testcode:: [dynamics_options]. options = {""store_states"": True, ""atol"": 1e-12}. Supported items come from 2 sources, the solver and the ODE integration method.; Supported solver options and their default can be seen using the class interface:. .. testcode:: [dynamics_options]. help(MESolver.options). Options supported by the ODE integration depend on the ""method"" options of the solver,; they can be listed through the integrator method of the solvers:. .. testcode:: [dynamics_options]. help(MESolver.integrator(""adams"").options). See :ref:`classes-ode` for a list of supported methods. As an example, let us consider changing the integrator, turn the GUI off, and; strengthen the absolute tolerance. .. testcode:: [dynamics_options]. options = {method=""bdf"", ""atol"": 1e-10, ""progress_bar"": False}. To use these new settings we can use the keyword argument ``options`` in either ; the :func:`.mesolve` and :func:`.mcsolve` function::. >>> mesolve(H0, psi0, tlist, c_op_list, [sigmaz()], options=options). or::. >>> MCSolver(H0, c_op_list, options=options); ",MatchSource.DOCS,doc/guide/dynamics/dynamics-options.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-options.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-options.rst:733,Integrability,interface,interface,733,".. _options:. *********************************************; Setting Options for the Dynamics Solvers; *********************************************. .. testsetup:: [dynamics_options]. from qutip.solver.mesolve import MESolver, mesolve; import numpy as np. Occasionally it is necessary to change the built in parameters of the dynamics; solvers used by for example the :func:`.mesolve` and :func:`.mcsolve` functions.; The options for all dynamics solvers may be changed by using the dictionaries. .. testcode:: [dynamics_options]. options = {""store_states"": True, ""atol"": 1e-12}. Supported items come from 2 sources, the solver and the ODE integration method.; Supported solver options and their default can be seen using the class interface:. .. testcode:: [dynamics_options]. help(MESolver.options). Options supported by the ODE integration depend on the ""method"" options of the solver,; they can be listed through the integrator method of the solvers:. .. testcode:: [dynamics_options]. help(MESolver.integrator(""adams"").options). See :ref:`classes-ode` for a list of supported methods. As an example, let us consider changing the integrator, turn the GUI off, and; strengthen the absolute tolerance. .. testcode:: [dynamics_options]. options = {method=""bdf"", ""atol"": 1e-10, ""progress_bar"": False}. To use these new settings we can use the keyword argument ``options`` in either ; the :func:`.mesolve` and :func:`.mcsolve` function::. >>> mesolve(H0, psi0, tlist, c_op_list, [sigmaz()], options=options). or::. >>> MCSolver(H0, c_op_list, options=options); ",MatchSource.DOCS,doc/guide/dynamics/dynamics-options.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-options.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-options.rst:832,Integrability,integrat,integration,832,".. _options:. *********************************************; Setting Options for the Dynamics Solvers; *********************************************. .. testsetup:: [dynamics_options]. from qutip.solver.mesolve import MESolver, mesolve; import numpy as np. Occasionally it is necessary to change the built in parameters of the dynamics; solvers used by for example the :func:`.mesolve` and :func:`.mcsolve` functions.; The options for all dynamics solvers may be changed by using the dictionaries. .. testcode:: [dynamics_options]. options = {""store_states"": True, ""atol"": 1e-12}. Supported items come from 2 sources, the solver and the ODE integration method.; Supported solver options and their default can be seen using the class interface:. .. testcode:: [dynamics_options]. help(MESolver.options). Options supported by the ODE integration depend on the ""method"" options of the solver,; they can be listed through the integrator method of the solvers:. .. testcode:: [dynamics_options]. help(MESolver.integrator(""adams"").options). See :ref:`classes-ode` for a list of supported methods. As an example, let us consider changing the integrator, turn the GUI off, and; strengthen the absolute tolerance. .. testcode:: [dynamics_options]. options = {method=""bdf"", ""atol"": 1e-10, ""progress_bar"": False}. To use these new settings we can use the keyword argument ``options`` in either ; the :func:`.mesolve` and :func:`.mcsolve` function::. >>> mesolve(H0, psi0, tlist, c_op_list, [sigmaz()], options=options). or::. >>> MCSolver(H0, c_op_list, options=options); ",MatchSource.DOCS,doc/guide/dynamics/dynamics-options.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-options.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-options.rst:844,Integrability,depend,depend,844,".. _options:. *********************************************; Setting Options for the Dynamics Solvers; *********************************************. .. testsetup:: [dynamics_options]. from qutip.solver.mesolve import MESolver, mesolve; import numpy as np. Occasionally it is necessary to change the built in parameters of the dynamics; solvers used by for example the :func:`.mesolve` and :func:`.mcsolve` functions.; The options for all dynamics solvers may be changed by using the dictionaries. .. testcode:: [dynamics_options]. options = {""store_states"": True, ""atol"": 1e-12}. Supported items come from 2 sources, the solver and the ODE integration method.; Supported solver options and their default can be seen using the class interface:. .. testcode:: [dynamics_options]. help(MESolver.options). Options supported by the ODE integration depend on the ""method"" options of the solver,; they can be listed through the integrator method of the solvers:. .. testcode:: [dynamics_options]. help(MESolver.integrator(""adams"").options). See :ref:`classes-ode` for a list of supported methods. As an example, let us consider changing the integrator, turn the GUI off, and; strengthen the absolute tolerance. .. testcode:: [dynamics_options]. options = {method=""bdf"", ""atol"": 1e-10, ""progress_bar"": False}. To use these new settings we can use the keyword argument ``options`` in either ; the :func:`.mesolve` and :func:`.mcsolve` function::. >>> mesolve(H0, psi0, tlist, c_op_list, [sigmaz()], options=options). or::. >>> MCSolver(H0, c_op_list, options=options); ",MatchSource.DOCS,doc/guide/dynamics/dynamics-options.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-options.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-options.rst:922,Integrability,integrat,integrator,922,".. _options:. *********************************************; Setting Options for the Dynamics Solvers; *********************************************. .. testsetup:: [dynamics_options]. from qutip.solver.mesolve import MESolver, mesolve; import numpy as np. Occasionally it is necessary to change the built in parameters of the dynamics; solvers used by for example the :func:`.mesolve` and :func:`.mcsolve` functions.; The options for all dynamics solvers may be changed by using the dictionaries. .. testcode:: [dynamics_options]. options = {""store_states"": True, ""atol"": 1e-12}. Supported items come from 2 sources, the solver and the ODE integration method.; Supported solver options and their default can be seen using the class interface:. .. testcode:: [dynamics_options]. help(MESolver.options). Options supported by the ODE integration depend on the ""method"" options of the solver,; they can be listed through the integrator method of the solvers:. .. testcode:: [dynamics_options]. help(MESolver.integrator(""adams"").options). See :ref:`classes-ode` for a list of supported methods. As an example, let us consider changing the integrator, turn the GUI off, and; strengthen the absolute tolerance. .. testcode:: [dynamics_options]. options = {method=""bdf"", ""atol"": 1e-10, ""progress_bar"": False}. To use these new settings we can use the keyword argument ``options`` in either ; the :func:`.mesolve` and :func:`.mcsolve` function::. >>> mesolve(H0, psi0, tlist, c_op_list, [sigmaz()], options=options). or::. >>> MCSolver(H0, c_op_list, options=options); ",MatchSource.DOCS,doc/guide/dynamics/dynamics-options.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-options.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-options.rst:1005,Integrability,integrat,integrator,1005,".. _options:. *********************************************; Setting Options for the Dynamics Solvers; *********************************************. .. testsetup:: [dynamics_options]. from qutip.solver.mesolve import MESolver, mesolve; import numpy as np. Occasionally it is necessary to change the built in parameters of the dynamics; solvers used by for example the :func:`.mesolve` and :func:`.mcsolve` functions.; The options for all dynamics solvers may be changed by using the dictionaries. .. testcode:: [dynamics_options]. options = {""store_states"": True, ""atol"": 1e-12}. Supported items come from 2 sources, the solver and the ODE integration method.; Supported solver options and their default can be seen using the class interface:. .. testcode:: [dynamics_options]. help(MESolver.options). Options supported by the ODE integration depend on the ""method"" options of the solver,; they can be listed through the integrator method of the solvers:. .. testcode:: [dynamics_options]. help(MESolver.integrator(""adams"").options). See :ref:`classes-ode` for a list of supported methods. As an example, let us consider changing the integrator, turn the GUI off, and; strengthen the absolute tolerance. .. testcode:: [dynamics_options]. options = {method=""bdf"", ""atol"": 1e-10, ""progress_bar"": False}. To use these new settings we can use the keyword argument ``options`` in either ; the :func:`.mesolve` and :func:`.mcsolve` function::. >>> mesolve(H0, psi0, tlist, c_op_list, [sigmaz()], options=options). or::. >>> MCSolver(H0, c_op_list, options=options); ",MatchSource.DOCS,doc/guide/dynamics/dynamics-options.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-options.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-options.rst:1135,Integrability,integrat,integrator,1135,".. _options:. *********************************************; Setting Options for the Dynamics Solvers; *********************************************. .. testsetup:: [dynamics_options]. from qutip.solver.mesolve import MESolver, mesolve; import numpy as np. Occasionally it is necessary to change the built in parameters of the dynamics; solvers used by for example the :func:`.mesolve` and :func:`.mcsolve` functions.; The options for all dynamics solvers may be changed by using the dictionaries. .. testcode:: [dynamics_options]. options = {""store_states"": True, ""atol"": 1e-12}. Supported items come from 2 sources, the solver and the ODE integration method.; Supported solver options and their default can be seen using the class interface:. .. testcode:: [dynamics_options]. help(MESolver.options). Options supported by the ODE integration depend on the ""method"" options of the solver,; they can be listed through the integrator method of the solvers:. .. testcode:: [dynamics_options]. help(MESolver.integrator(""adams"").options). See :ref:`classes-ode` for a list of supported methods. As an example, let us consider changing the integrator, turn the GUI off, and; strengthen the absolute tolerance. .. testcode:: [dynamics_options]. options = {method=""bdf"", ""atol"": 1e-10, ""progress_bar"": False}. To use these new settings we can use the keyword argument ``options`` in either ; the :func:`.mesolve` and :func:`.mcsolve` function::. >>> mesolve(H0, psi0, tlist, c_op_list, [sigmaz()], options=options). or::. >>> MCSolver(H0, c_op_list, options=options); ",MatchSource.DOCS,doc/guide/dynamics/dynamics-options.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-options.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-options.rst:153,Testability,test,testsetup,153,".. _options:. *********************************************; Setting Options for the Dynamics Solvers; *********************************************. .. testsetup:: [dynamics_options]. from qutip.solver.mesolve import MESolver, mesolve; import numpy as np. Occasionally it is necessary to change the built in parameters of the dynamics; solvers used by for example the :func:`.mesolve` and :func:`.mcsolve` functions.; The options for all dynamics solvers may be changed by using the dictionaries. .. testcode:: [dynamics_options]. options = {""store_states"": True, ""atol"": 1e-12}. Supported items come from 2 sources, the solver and the ODE integration method.; Supported solver options and their default can be seen using the class interface:. .. testcode:: [dynamics_options]. help(MESolver.options). Options supported by the ODE integration depend on the ""method"" options of the solver,; they can be listed through the integrator method of the solvers:. .. testcode:: [dynamics_options]. help(MESolver.integrator(""adams"").options). See :ref:`classes-ode` for a list of supported methods. As an example, let us consider changing the integrator, turn the GUI off, and; strengthen the absolute tolerance. .. testcode:: [dynamics_options]. options = {method=""bdf"", ""atol"": 1e-10, ""progress_bar"": False}. To use these new settings we can use the keyword argument ``options`` in either ; the :func:`.mesolve` and :func:`.mcsolve` function::. >>> mesolve(H0, psi0, tlist, c_op_list, [sigmaz()], options=options). or::. >>> MCSolver(H0, c_op_list, options=options); ",MatchSource.DOCS,doc/guide/dynamics/dynamics-options.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-options.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-options.rst:501,Testability,test,testcode,501,".. _options:. *********************************************; Setting Options for the Dynamics Solvers; *********************************************. .. testsetup:: [dynamics_options]. from qutip.solver.mesolve import MESolver, mesolve; import numpy as np. Occasionally it is necessary to change the built in parameters of the dynamics; solvers used by for example the :func:`.mesolve` and :func:`.mcsolve` functions.; The options for all dynamics solvers may be changed by using the dictionaries. .. testcode:: [dynamics_options]. options = {""store_states"": True, ""atol"": 1e-12}. Supported items come from 2 sources, the solver and the ODE integration method.; Supported solver options and their default can be seen using the class interface:. .. testcode:: [dynamics_options]. help(MESolver.options). Options supported by the ODE integration depend on the ""method"" options of the solver,; they can be listed through the integrator method of the solvers:. .. testcode:: [dynamics_options]. help(MESolver.integrator(""adams"").options). See :ref:`classes-ode` for a list of supported methods. As an example, let us consider changing the integrator, turn the GUI off, and; strengthen the absolute tolerance. .. testcode:: [dynamics_options]. options = {method=""bdf"", ""atol"": 1e-10, ""progress_bar"": False}. To use these new settings we can use the keyword argument ``options`` in either ; the :func:`.mesolve` and :func:`.mcsolve` function::. >>> mesolve(H0, psi0, tlist, c_op_list, [sigmaz()], options=options). or::. >>> MCSolver(H0, c_op_list, options=options); ",MatchSource.DOCS,doc/guide/dynamics/dynamics-options.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-options.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-options.rst:748,Testability,test,testcode,748,".. _options:. *********************************************; Setting Options for the Dynamics Solvers; *********************************************. .. testsetup:: [dynamics_options]. from qutip.solver.mesolve import MESolver, mesolve; import numpy as np. Occasionally it is necessary to change the built in parameters of the dynamics; solvers used by for example the :func:`.mesolve` and :func:`.mcsolve` functions.; The options for all dynamics solvers may be changed by using the dictionaries. .. testcode:: [dynamics_options]. options = {""store_states"": True, ""atol"": 1e-12}. Supported items come from 2 sources, the solver and the ODE integration method.; Supported solver options and their default can be seen using the class interface:. .. testcode:: [dynamics_options]. help(MESolver.options). Options supported by the ODE integration depend on the ""method"" options of the solver,; they can be listed through the integrator method of the solvers:. .. testcode:: [dynamics_options]. help(MESolver.integrator(""adams"").options). See :ref:`classes-ode` for a list of supported methods. As an example, let us consider changing the integrator, turn the GUI off, and; strengthen the absolute tolerance. .. testcode:: [dynamics_options]. options = {method=""bdf"", ""atol"": 1e-10, ""progress_bar"": False}. To use these new settings we can use the keyword argument ``options`` in either ; the :func:`.mesolve` and :func:`.mcsolve` function::. >>> mesolve(H0, psi0, tlist, c_op_list, [sigmaz()], options=options). or::. >>> MCSolver(H0, c_op_list, options=options); ",MatchSource.DOCS,doc/guide/dynamics/dynamics-options.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-options.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-options.rst:960,Testability,test,testcode,960,".. _options:. *********************************************; Setting Options for the Dynamics Solvers; *********************************************. .. testsetup:: [dynamics_options]. from qutip.solver.mesolve import MESolver, mesolve; import numpy as np. Occasionally it is necessary to change the built in parameters of the dynamics; solvers used by for example the :func:`.mesolve` and :func:`.mcsolve` functions.; The options for all dynamics solvers may be changed by using the dictionaries. .. testcode:: [dynamics_options]. options = {""store_states"": True, ""atol"": 1e-12}. Supported items come from 2 sources, the solver and the ODE integration method.; Supported solver options and their default can be seen using the class interface:. .. testcode:: [dynamics_options]. help(MESolver.options). Options supported by the ODE integration depend on the ""method"" options of the solver,; they can be listed through the integrator method of the solvers:. .. testcode:: [dynamics_options]. help(MESolver.integrator(""adams"").options). See :ref:`classes-ode` for a list of supported methods. As an example, let us consider changing the integrator, turn the GUI off, and; strengthen the absolute tolerance. .. testcode:: [dynamics_options]. options = {method=""bdf"", ""atol"": 1e-10, ""progress_bar"": False}. To use these new settings we can use the keyword argument ``options`` in either ; the :func:`.mesolve` and :func:`.mcsolve` function::. >>> mesolve(H0, psi0, tlist, c_op_list, [sigmaz()], options=options). or::. >>> MCSolver(H0, c_op_list, options=options); ",MatchSource.DOCS,doc/guide/dynamics/dynamics-options.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-options.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-options.rst:1208,Testability,test,testcode,1208,".. _options:. *********************************************; Setting Options for the Dynamics Solvers; *********************************************. .. testsetup:: [dynamics_options]. from qutip.solver.mesolve import MESolver, mesolve; import numpy as np. Occasionally it is necessary to change the built in parameters of the dynamics; solvers used by for example the :func:`.mesolve` and :func:`.mcsolve` functions.; The options for all dynamics solvers may be changed by using the dictionaries. .. testcode:: [dynamics_options]. options = {""store_states"": True, ""atol"": 1e-12}. Supported items come from 2 sources, the solver and the ODE integration method.; Supported solver options and their default can be seen using the class interface:. .. testcode:: [dynamics_options]. help(MESolver.options). Options supported by the ODE integration depend on the ""method"" options of the solver,; they can be listed through the integrator method of the solvers:. .. testcode:: [dynamics_options]. help(MESolver.integrator(""adams"").options). See :ref:`classes-ode` for a list of supported methods. As an example, let us consider changing the integrator, turn the GUI off, and; strengthen the absolute tolerance. .. testcode:: [dynamics_options]. options = {method=""bdf"", ""atol"": 1e-10, ""progress_bar"": False}. To use these new settings we can use the keyword argument ``options`` in either ; the :func:`.mesolve` and :func:`.mcsolve` function::. >>> mesolve(H0, psi0, tlist, c_op_list, [sigmaz()], options=options). or::. >>> MCSolver(H0, c_op_list, options=options); ",MatchSource.DOCS,doc/guide/dynamics/dynamics-options.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-options.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-propagator.rst:1145,Availability,avail,available,1145,"cient and the full propagator; is desired. QuTiP has the :func:`.propagator` function to compute them:. .. code-block::. >>> H = sigmaz() + np.pi *sigmax(); >>> psi_t = sesolve(H, basis(2, 1), [0, 0.5, 1]).states; >>> prop = propagator(H, [0, 0.5, 1]). >>> print((psi_t[1] - prop[1] @ basis(2, 1)).norm()); 2.455965272327082e-06. >>> print((psi_t[2] - prop[2] @ basis(2, 1)).norm()); 2.0071900004562142e-06. The first argument is the Hamiltonian, any time dependent system format is; accepted. The function also accepts an optional `c_ops` argument for collapse operators.; When used, a propagator for density matrices is computed:; :math:`\rho(t) = U(t)(\rho(0))`:. .. code-block::. >>> rho_t = mesolve(H, fock_dm(2, 1), [0, 0.5, 1], c_ops=[sigmam()]).states; >>> prop = propagator(H, [0, 0.5, 1], c_ops=[sigmam()]). >>> print((rho_t[1] - prop[1](fock_dm(2, 1))).norm()); 7.23009476734681e-07. >>> print((rho_t[2] - prop[2](fock_dm(2, 1))).norm()); 1.2666967766644768e-06. The propagator function is also available as a class:. .. code-block::. >>> U = Propagator(H, c_ops=[sigmam()]). >>> state_0_5 = U(0.5)(fock_dm(2, 1)); >>> state_1 = U(1., t_start=0.5)(state_0_5). >>> print((rho_t[1] - state_0_5).norm()); 7.23009476734681e-07. >>> print((rho_t[2] - state_1).norm()); 8.355518501351504e-07. The :obj:`.Propagator` can take ``options`` and ``args`` as a solver instance. .. _propagator_solver:. Using a solver to compute a propagator; ======================================. Many solvers accept an operator as the initial state. When an identity matrix is; passed as the initial state, the propagator is computed. This can be used to compute; a propagator for Bloch-Redfield or Floquet equations:. .. code-block::. >>> delta = 0.2 * 2*np.pi; >>> eps0 = 1.0 * 2*np.pi; >>> gamma1 = 0.5. >>> H = - delta/2.0 * sigmax() - eps0/2.0 * sigmaz(). >>> def ohmic_spectrum(w):; >>> if w == 0.0: # dephasing inducing noise; >>> return gamma1; >>> else: # relaxation inducing noise; >>> return gamma1 / 2 * ",MatchSource.DOCS,doc/guide/dynamics/dynamics-propagator.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-propagator.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-propagator.rst:595,Integrability,depend,dependent,595,".. _propagator:. *********************; Computing propagators; *********************. Sometime the evolution of a single state is not sufficient and the full propagator; is desired. QuTiP has the :func:`.propagator` function to compute them:. .. code-block::. >>> H = sigmaz() + np.pi *sigmax(); >>> psi_t = sesolve(H, basis(2, 1), [0, 0.5, 1]).states; >>> prop = propagator(H, [0, 0.5, 1]). >>> print((psi_t[1] - prop[1] @ basis(2, 1)).norm()); 2.455965272327082e-06. >>> print((psi_t[2] - prop[2] @ basis(2, 1)).norm()); 2.0071900004562142e-06. The first argument is the Hamiltonian, any time dependent system format is; accepted. The function also accepts an optional `c_ops` argument for collapse operators.; When used, a propagator for density matrices is computed:; :math:`\rho(t) = U(t)(\rho(0))`:. .. code-block::. >>> rho_t = mesolve(H, fock_dm(2, 1), [0, 0.5, 1], c_ops=[sigmam()]).states; >>> prop = propagator(H, [0, 0.5, 1], c_ops=[sigmam()]). >>> print((rho_t[1] - prop[1](fock_dm(2, 1))).norm()); 7.23009476734681e-07. >>> print((rho_t[2] - prop[2](fock_dm(2, 1))).norm()); 1.2666967766644768e-06. The propagator function is also available as a class:. .. code-block::. >>> U = Propagator(H, c_ops=[sigmam()]). >>> state_0_5 = U(0.5)(fock_dm(2, 1)); >>> state_1 = U(1., t_start=0.5)(state_0_5). >>> print((rho_t[1] - state_0_5).norm()); 7.23009476734681e-07. >>> print((rho_t[2] - state_1).norm()); 8.355518501351504e-07. The :obj:`.Propagator` can take ``options`` and ``args`` as a solver instance. .. _propagator_solver:. Using a solver to compute a propagator; ======================================. Many solvers accept an operator as the initial state. When an identity matrix is; passed as the initial state, the propagator is computed. This can be used to compute; a propagator for Bloch-Redfield or Floquet equations:. .. code-block::. >>> delta = 0.2 * 2*np.pi; >>> eps0 = 1.0 * 2*np.pi; >>> gamma1 = 0.5. >>> H = - delta/2.0 * sigmax() - eps0/2.0 * sigmaz(). >>> def ohmic_sp",MatchSource.DOCS,doc/guide/dynamics/dynamics-propagator.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-propagator.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-stochastic.rst:4821,Availability,avail,available,4821,"d :math:`S_n`:. .. math::; :label: liouvillian. d_1 = - i[H(t),\rho(t)]; + \sum_i D[C_i]\rho; + \sum_n D[S_n]\rho,. The stochastic part, :math:`d_{2,n}`, is given solely by the operators :math:`S_n`. .. math::; :label: stochastic_smesolve. d_{2,n} = S_n \rho(t) + \rho(t) S_n^\dagger - \mathrm{tr}\left(S_n \rho (t); + \rho(t) S_n^\dagger \right)\,\rho(t). As in the stochastic Schrodinger equation, heterodyne detection can be chosen by passing ``heterodyne=True``. Example; -------. Below, we solve the dynamics for an optical cavity at 0K whose output is monitored; using homodyne detection. The cavity decay rate is given by :math:`\kappa` and the; :math:`\Delta` is the cavity detuning with respect to the driving field.; The measurement operators can be passed using the option ``m_ops``. The homodyne; current :math:`J_x` is calculated using. .. math::; :label: measurement_result. J_x = \langle x \rangle + dW / dt,. where :math:`x` is the operator passed using ``m_ops``. The results are available; in ``result.measurements``. .. plot::; :context: reset. # parameters; DIM = 20 # Hilbert space dimension; DELTA = 5 * 2 * np.pi # cavity detuning; KAPPA = 2 # cavity decay rate; INTENSITY = 4 # intensity of initial state; NUMBER_OF_TRAJECTORIES = 500. # operators; a = destroy(DIM); x = a + a.dag(); H = DELTA * a.dag() * a. rho_0 = coherent(DIM, np.sqrt(INTENSITY)); times = np.arange(0, 1, 0.0025). stoc_solution = smesolve(; H, rho_0, times,; c_ops=[],; sc_ops=[np.sqrt(KAPPA) * a],; e_ops=[x],; ntraj=NUMBER_OF_TRAJECTORIES,; options={""dt"": 0.00125, ""store_measurement"": True,}; ). fig, ax = plt.subplots(); ax.set_title('Stochastic Master Equation - Homodyne Detection'); ax.plot(times[1:], np.array(stoc_solution.measurement).mean(axis=0)[0, :].real,; 'r', lw=2, label=r'$J_x$'); ax.plot(times, stoc_solution.expect[0], 'k', lw=2,; label=r'$\langle x \rangle$'); ax.set_xlabel('Time'); ax.legend(). ..; TODO merge qutip-tutorials#61; For other examples on :func:`qutip.solver.stochastic",MatchSource.DOCS,doc/guide/dynamics/dynamics-stochastic.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-stochastic.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-stochastic.rst:5901,Availability,avail,available,5901,"ppa` and the; :math:`\Delta` is the cavity detuning with respect to the driving field.; The measurement operators can be passed using the option ``m_ops``. The homodyne; current :math:`J_x` is calculated using. .. math::; :label: measurement_result. J_x = \langle x \rangle + dW / dt,. where :math:`x` is the operator passed using ``m_ops``. The results are available; in ``result.measurements``. .. plot::; :context: reset. # parameters; DIM = 20 # Hilbert space dimension; DELTA = 5 * 2 * np.pi # cavity detuning; KAPPA = 2 # cavity decay rate; INTENSITY = 4 # intensity of initial state; NUMBER_OF_TRAJECTORIES = 500. # operators; a = destroy(DIM); x = a + a.dag(); H = DELTA * a.dag() * a. rho_0 = coherent(DIM, np.sqrt(INTENSITY)); times = np.arange(0, 1, 0.0025). stoc_solution = smesolve(; H, rho_0, times,; c_ops=[],; sc_ops=[np.sqrt(KAPPA) * a],; e_ops=[x],; ntraj=NUMBER_OF_TRAJECTORIES,; options={""dt"": 0.00125, ""store_measurement"": True,}; ). fig, ax = plt.subplots(); ax.set_title('Stochastic Master Equation - Homodyne Detection'); ax.plot(times[1:], np.array(stoc_solution.measurement).mean(axis=0)[0, :].real,; 'r', lw=2, label=r'$J_x$'); ax.plot(times, stoc_solution.expect[0], 'k', lw=2,; label=r'$\langle x \rangle$'); ax.set_xlabel('Time'); ax.legend(). ..; TODO merge qutip-tutorials#61; For other examples on :func:`qutip.solver.stochastic.smesolve`, see the; `following notebook <...>`_, as well as these notebooks available at; `QuTiP Tutorials page <https://qutip.org/tutorials.html>`_:; `heterodyne detection <...>`_,; `inefficient detection <...>`_, and; `feedback control <https://github.com/jrjohansson/reproduced-papers/blob/master/Reproduce-SIAM-JCO-46-445-2007-Mirrahimi.ipynb>`_. The stochastic solvers share many features with :func:`.mcsolve`, such as; end conditions, seed control and running in parallel. See the sections; :ref:`monte-ntraj`, :ref:`monte-seeds` and :ref:`monte-parallel` for details. .. plot::; :context: reset; :include-source: false; :nofigs:; ",MatchSource.DOCS,doc/guide/dynamics/dynamics-stochastic.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-stochastic.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-stochastic.rst:187,Deployability,continuous,continuous,187,".. _stochastic:. *******************************************; Stochastic Solver; *******************************************. .. _stochastic-intro:. When a quantum system is subjected to continuous measurement, through homodyne detection for example, it is possible to simulate the conditional quantum state using stochastic Schrodinger and master equations.; The solution of these stochastic equations are quantum trajectories, which represent the conditioned evolution of the system given a specific measurement record. In general, the stochastic evolution of a quantum state is calculated in; QuTiP by solving the general equation. .. math::; :label: general_form. d \rho (t) = d_1 \rho \, dt + \sum_n d_{2,n} \rho \, dW_n,. where :math:`dW_n` is a Wiener increment, which has the expectation values :math:`E[dW] = 0` and :math:`E[dW^2] = dt`. Stochastic Schrodinger Equation; ===============================. .. _sse-solver:. The stochastic Schrodinger equation is given by (see section 4.4, [Wis09]_). .. math::; :label: jump_ssesolve. d \psi(t) = - i H \psi(t) dt; - \sum_n \left( \frac{S_n^\dagger S_n}{2} -\frac{e_n}{2} S_n; + \frac{e_n^2}{8} \right) \psi(t) dt; + \sum_n \left( S_n - \frac{e_n}{2} \right) \psi(t) dW_n,. where :math:`H` is the Hamiltonian, :math:`S_n` are the stochastic collapse operators, and :math:`e_n` is. .. math::; :label: jump_matrix_element. e_n = \left<\psi(t)|S_n + S_n^\dagger|\psi(t)\right>. In QuTiP, this equation can be solved using the function :func:`~qutip.solver.stochastic.ssesolve`,; which is implemented by defining :math:`d_1` and :math:`d_{2,n}` from Equation :eq:`general_form` as. .. math::; :label: d1_def. d_1 = -iH - \frac{1}{2} \sum_n \left(S_n^\dagger S_n - e_n S_n + \frac{e_i^2}{4} \right),. and. .. math::; :label: d2_def. d_{2, n} = S_n - \frac{e_n}{2}. The solver :func:`~qutip.solver.stochastic.ssesolve` will construct the operators; :math:`d_1` and :math:`d_{2,n}` once the user passes the Hamiltonian (``H``) and; the stochastic opera",MatchSource.DOCS,doc/guide/dynamics/dynamics-stochastic.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-stochastic.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-stochastic.rst:3652,Energy Efficiency,monitor,monitored,3652,"development notebook <...TODO-Merge 61...>`_. Stochastic Master Equation; ==========================. .. Stochastic Master equation. When the initial state of the system is a density matrix :math:`\rho`, the stochastic master equation solver :func:`qutip.stochastic.smesolve` must be used.; The stochastic master equation is given by (see section 4.4, [Wis09]_). .. math::; :label: stochastic_master. d \rho (t) = -i[H, \rho(t)] dt + D[A]\rho(t) dt + \mathcal{H}[A]\rho dW(t). where. .. math::; :label: dissipator. D[A] \rho = \frac{1}{2} \left[2 A \rho A^\dagger; - \rho A^\dagger A - A^\dagger A \rho \right],. and. .. math::; :label: h_cal. \mathcal{H}[A]\rho = A\rho(t) + \rho(t) A^\dagger - \mathrm{tr}[A\rho(t) + \rho(t) A^\dagger]. In QuTiP, solutions for the stochastic master equation are obtained using the solver; :func:`~qutip.solver.stochastic.smesolve`. The implementation takes into account 2; types of collapse operators. :math:`C_i` (``c_ops``) represent the dissipation in; the environment, while :math:`S_n` (``sc_ops``) are monitored operators.; The deterministic part of the evolution, described by the :math:`d_1` in Equation; :eq:`general_form`, takes into account all operators :math:`C_i` and :math:`S_n`:. .. math::; :label: liouvillian. d_1 = - i[H(t),\rho(t)]; + \sum_i D[C_i]\rho; + \sum_n D[S_n]\rho,. The stochastic part, :math:`d_{2,n}`, is given solely by the operators :math:`S_n`. .. math::; :label: stochastic_smesolve. d_{2,n} = S_n \rho(t) + \rho(t) S_n^\dagger - \mathrm{tr}\left(S_n \rho (t); + \rho(t) S_n^\dagger \right)\,\rho(t). As in the stochastic Schrodinger equation, heterodyne detection can be chosen by passing ``heterodyne=True``. Example; -------. Below, we solve the dynamics for an optical cavity at 0K whose output is monitored; using homodyne detection. The cavity decay rate is given by :math:`\kappa` and the; :math:`\Delta` is the cavity detuning with respect to the driving field.; The measurement operators can be passed using the option `",MatchSource.DOCS,doc/guide/dynamics/dynamics-stochastic.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-stochastic.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-stochastic.rst:4382,Energy Efficiency,monitor,monitored,4382,"ons for the stochastic master equation are obtained using the solver; :func:`~qutip.solver.stochastic.smesolve`. The implementation takes into account 2; types of collapse operators. :math:`C_i` (``c_ops``) represent the dissipation in; the environment, while :math:`S_n` (``sc_ops``) are monitored operators.; The deterministic part of the evolution, described by the :math:`d_1` in Equation; :eq:`general_form`, takes into account all operators :math:`C_i` and :math:`S_n`:. .. math::; :label: liouvillian. d_1 = - i[H(t),\rho(t)]; + \sum_i D[C_i]\rho; + \sum_n D[S_n]\rho,. The stochastic part, :math:`d_{2,n}`, is given solely by the operators :math:`S_n`. .. math::; :label: stochastic_smesolve. d_{2,n} = S_n \rho(t) + \rho(t) S_n^\dagger - \mathrm{tr}\left(S_n \rho (t); + \rho(t) S_n^\dagger \right)\,\rho(t). As in the stochastic Schrodinger equation, heterodyne detection can be chosen by passing ``heterodyne=True``. Example; -------. Below, we solve the dynamics for an optical cavity at 0K whose output is monitored; using homodyne detection. The cavity decay rate is given by :math:`\kappa` and the; :math:`\Delta` is the cavity detuning with respect to the driving field.; The measurement operators can be passed using the option ``m_ops``. The homodyne; current :math:`J_x` is calculated using. .. math::; :label: measurement_result. J_x = \langle x \rangle + dW / dt,. where :math:`x` is the operator passed using ``m_ops``. The results are available; in ``result.measurements``. .. plot::; :context: reset. # parameters; DIM = 20 # Hilbert space dimension; DELTA = 5 * 2 * np.pi # cavity detuning; KAPPA = 2 # cavity decay rate; INTENSITY = 4 # intensity of initial state; NUMBER_OF_TRAJECTORIES = 500. # operators; a = destroy(DIM); x = a + a.dag(); H = DELTA * a.dag() * a. rho_0 = coherent(DIM, np.sqrt(INTENSITY)); times = np.arange(0, 1, 0.0025). stoc_solution = smesolve(; H, rho_0, times,; c_ops=[],; sc_ops=[np.sqrt(KAPPA) * a],; e_ops=[x],; ntraj=NUMBER_OF_TRAJECTORIES,; o",MatchSource.DOCS,doc/guide/dynamics/dynamics-stochastic.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-stochastic.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-stochastic.rst:228,Safety,detect,detection,228,".. _stochastic:. *******************************************; Stochastic Solver; *******************************************. .. _stochastic-intro:. When a quantum system is subjected to continuous measurement, through homodyne detection for example, it is possible to simulate the conditional quantum state using stochastic Schrodinger and master equations.; The solution of these stochastic equations are quantum trajectories, which represent the conditioned evolution of the system given a specific measurement record. In general, the stochastic evolution of a quantum state is calculated in; QuTiP by solving the general equation. .. math::; :label: general_form. d \rho (t) = d_1 \rho \, dt + \sum_n d_{2,n} \rho \, dW_n,. where :math:`dW_n` is a Wiener increment, which has the expectation values :math:`E[dW] = 0` and :math:`E[dW^2] = dt`. Stochastic Schrodinger Equation; ===============================. .. _sse-solver:. The stochastic Schrodinger equation is given by (see section 4.4, [Wis09]_). .. math::; :label: jump_ssesolve. d \psi(t) = - i H \psi(t) dt; - \sum_n \left( \frac{S_n^\dagger S_n}{2} -\frac{e_n}{2} S_n; + \frac{e_n^2}{8} \right) \psi(t) dt; + \sum_n \left( S_n - \frac{e_n}{2} \right) \psi(t) dW_n,. where :math:`H` is the Hamiltonian, :math:`S_n` are the stochastic collapse operators, and :math:`e_n` is. .. math::; :label: jump_matrix_element. e_n = \left<\psi(t)|S_n + S_n^\dagger|\psi(t)\right>. In QuTiP, this equation can be solved using the function :func:`~qutip.solver.stochastic.ssesolve`,; which is implemented by defining :math:`d_1` and :math:`d_{2,n}` from Equation :eq:`general_form` as. .. math::; :label: d1_def. d_1 = -iH - \frac{1}{2} \sum_n \left(S_n^\dagger S_n - e_n S_n + \frac{e_i^2}{4} \right),. and. .. math::; :label: d2_def. d_{2, n} = S_n - \frac{e_n}{2}. The solver :func:`~qutip.solver.stochastic.ssesolve` will construct the operators; :math:`d_1` and :math:`d_{2,n}` once the user passes the Hamiltonian (``H``) and; the stochastic opera",MatchSource.DOCS,doc/guide/dynamics/dynamics-stochastic.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-stochastic.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-stochastic.rst:2379,Safety,detect,detections,2379,"right>. In QuTiP, this equation can be solved using the function :func:`~qutip.solver.stochastic.ssesolve`,; which is implemented by defining :math:`d_1` and :math:`d_{2,n}` from Equation :eq:`general_form` as. .. math::; :label: d1_def. d_1 = -iH - \frac{1}{2} \sum_n \left(S_n^\dagger S_n - e_n S_n + \frac{e_i^2}{4} \right),. and. .. math::; :label: d2_def. d_{2, n} = S_n - \frac{e_n}{2}. The solver :func:`~qutip.solver.stochastic.ssesolve` will construct the operators; :math:`d_1` and :math:`d_{2,n}` once the user passes the Hamiltonian (``H``) and; the stochastic operator list (``sc_ops``). As with the :func:`~qutip.solver.mcsolve.mcsolve`,; the number of trajectories and the seed for the noise realisation can be fixed using; the arguments: ``ntraj`` and ``seeds``, respectively. If the user also requires the; measurement output, the options entry ``{""store_measurement"": True}`` should be included. Per default, homodyne is used. Heterodyne detections can be easily simulated by passing; the arguments ``'heterodyne=True'`` to :func:`~qutip.solver.stochastic.ssesolve`. ..; Examples of how to solve the stochastic Schrodinger equation using QuTiP; can be found in this `development notebook <...TODO-Merge 61...>`_. Stochastic Master Equation; ==========================. .. Stochastic Master equation. When the initial state of the system is a density matrix :math:`\rho`, the stochastic master equation solver :func:`qutip.stochastic.smesolve` must be used.; The stochastic master equation is given by (see section 4.4, [Wis09]_). .. math::; :label: stochastic_master. d \rho (t) = -i[H, \rho(t)] dt + D[A]\rho(t) dt + \mathcal{H}[A]\rho dW(t). where. .. math::; :label: dissipator. D[A] \rho = \frac{1}{2} \left[2 A \rho A^\dagger; - \rho A^\dagger A - A^\dagger A \rho \right],. and. .. math::; :label: h_cal. \mathcal{H}[A]\rho = A\rho(t) + \rho(t) A^\dagger - \mathrm{tr}[A\rho(t) + \rho(t) A^\dagger]. In QuTiP, solutions for the stochastic master equation are obtained using th",MatchSource.DOCS,doc/guide/dynamics/dynamics-stochastic.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-stochastic.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-stochastic.rst:4235,Safety,detect,detection,4235,"; :label: h_cal. \mathcal{H}[A]\rho = A\rho(t) + \rho(t) A^\dagger - \mathrm{tr}[A\rho(t) + \rho(t) A^\dagger]. In QuTiP, solutions for the stochastic master equation are obtained using the solver; :func:`~qutip.solver.stochastic.smesolve`. The implementation takes into account 2; types of collapse operators. :math:`C_i` (``c_ops``) represent the dissipation in; the environment, while :math:`S_n` (``sc_ops``) are monitored operators.; The deterministic part of the evolution, described by the :math:`d_1` in Equation; :eq:`general_form`, takes into account all operators :math:`C_i` and :math:`S_n`:. .. math::; :label: liouvillian. d_1 = - i[H(t),\rho(t)]; + \sum_i D[C_i]\rho; + \sum_n D[S_n]\rho,. The stochastic part, :math:`d_{2,n}`, is given solely by the operators :math:`S_n`. .. math::; :label: stochastic_smesolve. d_{2,n} = S_n \rho(t) + \rho(t) S_n^\dagger - \mathrm{tr}\left(S_n \rho (t); + \rho(t) S_n^\dagger \right)\,\rho(t). As in the stochastic Schrodinger equation, heterodyne detection can be chosen by passing ``heterodyne=True``. Example; -------. Below, we solve the dynamics for an optical cavity at 0K whose output is monitored; using homodyne detection. The cavity decay rate is given by :math:`\kappa` and the; :math:`\Delta` is the cavity detuning with respect to the driving field.; The measurement operators can be passed using the option ``m_ops``. The homodyne; current :math:`J_x` is calculated using. .. math::; :label: measurement_result. J_x = \langle x \rangle + dW / dt,. where :math:`x` is the operator passed using ``m_ops``. The results are available; in ``result.measurements``. .. plot::; :context: reset. # parameters; DIM = 20 # Hilbert space dimension; DELTA = 5 * 2 * np.pi # cavity detuning; KAPPA = 2 # cavity decay rate; INTENSITY = 4 # intensity of initial state; NUMBER_OF_TRAJECTORIES = 500. # operators; a = destroy(DIM); x = a + a.dag(); H = DELTA * a.dag() * a. rho_0 = coherent(DIM, np.sqrt(INTENSITY)); times = np.arange(0, 1, 0.0025). st",MatchSource.DOCS,doc/guide/dynamics/dynamics-stochastic.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-stochastic.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-stochastic.rst:4408,Safety,detect,detection,4408,"ons for the stochastic master equation are obtained using the solver; :func:`~qutip.solver.stochastic.smesolve`. The implementation takes into account 2; types of collapse operators. :math:`C_i` (``c_ops``) represent the dissipation in; the environment, while :math:`S_n` (``sc_ops``) are monitored operators.; The deterministic part of the evolution, described by the :math:`d_1` in Equation; :eq:`general_form`, takes into account all operators :math:`C_i` and :math:`S_n`:. .. math::; :label: liouvillian. d_1 = - i[H(t),\rho(t)]; + \sum_i D[C_i]\rho; + \sum_n D[S_n]\rho,. The stochastic part, :math:`d_{2,n}`, is given solely by the operators :math:`S_n`. .. math::; :label: stochastic_smesolve. d_{2,n} = S_n \rho(t) + \rho(t) S_n^\dagger - \mathrm{tr}\left(S_n \rho (t); + \rho(t) S_n^\dagger \right)\,\rho(t). As in the stochastic Schrodinger equation, heterodyne detection can be chosen by passing ``heterodyne=True``. Example; -------. Below, we solve the dynamics for an optical cavity at 0K whose output is monitored; using homodyne detection. The cavity decay rate is given by :math:`\kappa` and the; :math:`\Delta` is the cavity detuning with respect to the driving field.; The measurement operators can be passed using the option ``m_ops``. The homodyne; current :math:`J_x` is calculated using. .. math::; :label: measurement_result. J_x = \langle x \rangle + dW / dt,. where :math:`x` is the operator passed using ``m_ops``. The results are available; in ``result.measurements``. .. plot::; :context: reset. # parameters; DIM = 20 # Hilbert space dimension; DELTA = 5 * 2 * np.pi # cavity detuning; KAPPA = 2 # cavity decay rate; INTENSITY = 4 # intensity of initial state; NUMBER_OF_TRAJECTORIES = 500. # operators; a = destroy(DIM); x = a + a.dag(); H = DELTA * a.dag() * a. rho_0 = coherent(DIM, np.sqrt(INTENSITY)); times = np.arange(0, 1, 0.0025). stoc_solution = smesolve(; H, rho_0, times,; c_ops=[],; sc_ops=[np.sqrt(KAPPA) * a],; e_ops=[x],; ntraj=NUMBER_OF_TRAJECTORIES,; o",MatchSource.DOCS,doc/guide/dynamics/dynamics-stochastic.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-stochastic.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-stochastic.rst:5988,Safety,detect,detection,5988,"ppa` and the; :math:`\Delta` is the cavity detuning with respect to the driving field.; The measurement operators can be passed using the option ``m_ops``. The homodyne; current :math:`J_x` is calculated using. .. math::; :label: measurement_result. J_x = \langle x \rangle + dW / dt,. where :math:`x` is the operator passed using ``m_ops``. The results are available; in ``result.measurements``. .. plot::; :context: reset. # parameters; DIM = 20 # Hilbert space dimension; DELTA = 5 * 2 * np.pi # cavity detuning; KAPPA = 2 # cavity decay rate; INTENSITY = 4 # intensity of initial state; NUMBER_OF_TRAJECTORIES = 500. # operators; a = destroy(DIM); x = a + a.dag(); H = DELTA * a.dag() * a. rho_0 = coherent(DIM, np.sqrt(INTENSITY)); times = np.arange(0, 1, 0.0025). stoc_solution = smesolve(; H, rho_0, times,; c_ops=[],; sc_ops=[np.sqrt(KAPPA) * a],; e_ops=[x],; ntraj=NUMBER_OF_TRAJECTORIES,; options={""dt"": 0.00125, ""store_measurement"": True,}; ). fig, ax = plt.subplots(); ax.set_title('Stochastic Master Equation - Homodyne Detection'); ax.plot(times[1:], np.array(stoc_solution.measurement).mean(axis=0)[0, :].real,; 'r', lw=2, label=r'$J_x$'); ax.plot(times, stoc_solution.expect[0], 'k', lw=2,; label=r'$\langle x \rangle$'); ax.set_xlabel('Time'); ax.legend(). ..; TODO merge qutip-tutorials#61; For other examples on :func:`qutip.solver.stochastic.smesolve`, see the; `following notebook <...>`_, as well as these notebooks available at; `QuTiP Tutorials page <https://qutip.org/tutorials.html>`_:; `heterodyne detection <...>`_,; `inefficient detection <...>`_, and; `feedback control <https://github.com/jrjohansson/reproduced-papers/blob/master/Reproduce-SIAM-JCO-46-445-2007-Mirrahimi.ipynb>`_. The stochastic solvers share many features with :func:`.mcsolve`, such as; end conditions, seed control and running in parallel. See the sections; :ref:`monte-ntraj`, :ref:`monte-seeds` and :ref:`monte-parallel` for details. .. plot::; :context: reset; :include-source: false; :nofigs:; ",MatchSource.DOCS,doc/guide/dynamics/dynamics-stochastic.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-stochastic.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-stochastic.rst:6021,Safety,detect,detection,6021,"ppa` and the; :math:`\Delta` is the cavity detuning with respect to the driving field.; The measurement operators can be passed using the option ``m_ops``. The homodyne; current :math:`J_x` is calculated using. .. math::; :label: measurement_result. J_x = \langle x \rangle + dW / dt,. where :math:`x` is the operator passed using ``m_ops``. The results are available; in ``result.measurements``. .. plot::; :context: reset. # parameters; DIM = 20 # Hilbert space dimension; DELTA = 5 * 2 * np.pi # cavity detuning; KAPPA = 2 # cavity decay rate; INTENSITY = 4 # intensity of initial state; NUMBER_OF_TRAJECTORIES = 500. # operators; a = destroy(DIM); x = a + a.dag(); H = DELTA * a.dag() * a. rho_0 = coherent(DIM, np.sqrt(INTENSITY)); times = np.arange(0, 1, 0.0025). stoc_solution = smesolve(; H, rho_0, times,; c_ops=[],; sc_ops=[np.sqrt(KAPPA) * a],; e_ops=[x],; ntraj=NUMBER_OF_TRAJECTORIES,; options={""dt"": 0.00125, ""store_measurement"": True,}; ). fig, ax = plt.subplots(); ax.set_title('Stochastic Master Equation - Homodyne Detection'); ax.plot(times[1:], np.array(stoc_solution.measurement).mean(axis=0)[0, :].real,; 'r', lw=2, label=r'$J_x$'); ax.plot(times, stoc_solution.expect[0], 'k', lw=2,; label=r'$\langle x \rangle$'); ax.set_xlabel('Time'); ax.legend(). ..; TODO merge qutip-tutorials#61; For other examples on :func:`qutip.solver.stochastic.smesolve`, see the; `following notebook <...>`_, as well as these notebooks available at; `QuTiP Tutorials page <https://qutip.org/tutorials.html>`_:; `heterodyne detection <...>`_,; `inefficient detection <...>`_, and; `feedback control <https://github.com/jrjohansson/reproduced-papers/blob/master/Reproduce-SIAM-JCO-46-445-2007-Mirrahimi.ipynb>`_. The stochastic solvers share many features with :func:`.mcsolve`, such as; end conditions, seed control and running in parallel. See the sections; :ref:`monte-ntraj`, :ref:`monte-seeds` and :ref:`monte-parallel` for details. .. plot::; :context: reset; :include-source: false; :nofigs:; ",MatchSource.DOCS,doc/guide/dynamics/dynamics-stochastic.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-stochastic.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-stochastic.rst:6046,Usability,feedback,feedback,6046,"ppa` and the; :math:`\Delta` is the cavity detuning with respect to the driving field.; The measurement operators can be passed using the option ``m_ops``. The homodyne; current :math:`J_x` is calculated using. .. math::; :label: measurement_result. J_x = \langle x \rangle + dW / dt,. where :math:`x` is the operator passed using ``m_ops``. The results are available; in ``result.measurements``. .. plot::; :context: reset. # parameters; DIM = 20 # Hilbert space dimension; DELTA = 5 * 2 * np.pi # cavity detuning; KAPPA = 2 # cavity decay rate; INTENSITY = 4 # intensity of initial state; NUMBER_OF_TRAJECTORIES = 500. # operators; a = destroy(DIM); x = a + a.dag(); H = DELTA * a.dag() * a. rho_0 = coherent(DIM, np.sqrt(INTENSITY)); times = np.arange(0, 1, 0.0025). stoc_solution = smesolve(; H, rho_0, times,; c_ops=[],; sc_ops=[np.sqrt(KAPPA) * a],; e_ops=[x],; ntraj=NUMBER_OF_TRAJECTORIES,; options={""dt"": 0.00125, ""store_measurement"": True,}; ). fig, ax = plt.subplots(); ax.set_title('Stochastic Master Equation - Homodyne Detection'); ax.plot(times[1:], np.array(stoc_solution.measurement).mean(axis=0)[0, :].real,; 'r', lw=2, label=r'$J_x$'); ax.plot(times, stoc_solution.expect[0], 'k', lw=2,; label=r'$\langle x \rangle$'); ax.set_xlabel('Time'); ax.legend(). ..; TODO merge qutip-tutorials#61; For other examples on :func:`qutip.solver.stochastic.smesolve`, see the; `following notebook <...>`_, as well as these notebooks available at; `QuTiP Tutorials page <https://qutip.org/tutorials.html>`_:; `heterodyne detection <...>`_,; `inefficient detection <...>`_, and; `feedback control <https://github.com/jrjohansson/reproduced-papers/blob/master/Reproduce-SIAM-JCO-46-445-2007-Mirrahimi.ipynb>`_. The stochastic solvers share many features with :func:`.mcsolve`, such as; end conditions, seed control and running in parallel. See the sections; :ref:`monte-ntraj`, :ref:`monte-seeds` and :ref:`monte-parallel` for details. .. plot::; :context: reset; :include-source: false; :nofigs:; ",MatchSource.DOCS,doc/guide/dynamics/dynamics-stochastic.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-stochastic.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst:12863,Availability,avail,available,12863,"; Qobj data =; [[0. 1.]; [2. 0.]]; >>> print(summed_evo(0, a=3, b=1)); Quantum object: dims=[[2], [2]], shape=(2, 2), type='oper', isherm=True; Qobj data =; [[0. 3.]; [3. 0.]]. Coefficients; ============. To build time dependent quantum system we often use a list of :obj:`.Qobj` and; :obj:`.Coefficient`. These :obj:`.Coefficient` represent the strength of the corresponding; quantum object a function that of time. Up to now, we used functions for these,; but QuTiP support multiple formats: ``callable``, ``strings``, ``array``. **Function coefficients** :; Use a callable with the signature ``f(t: double, ...) -> double`` as coefficient.; Any function or method that can be called by ``f(t, args)``, ``f(t, **args)`` is accepted. .. code-block:: python. def coeff(t, A, sigma):; return A * np.exp(-(t / sigma)**2). H = QobjEvo([H0, [H1, coeff]], args=args). **String coefficients** :; Use a string containing a simple Python expression.; The variable ``t``, common mathematical functions such as ``sin`` or ``exp`` an; variable in args will be available. If available, the string will be compiled using; cython, fixing variable type when possible, allowing slightly faster execution than function.; While the speed up is usually very small, in long evolution, numerous calls to the; functions are made and it's can accumulate. From version 5, compilation of the; coefficient is done only once and saved between sessions. When either the cython or; filelock modules are not available, the code will be executed in python using; ``exec`` with the same environment . This, however, as no advantage over using; python function. .. code-block:: python. coeff = ""A * exp(-(t / sigma)**2)"". H = QobjEvo([H0, [H1, coeff]], args=args). Here is a list of defined variables:; ``sin``, ``cos``, ``tan``, ``asin``, ``acos``, ``atan``, ``pi``,; ``sinh``, ``cosh``, ``tanh``, ``asinh``, ``acosh``, ``atanh``,; ``exp``, ``log``, ``log10``, ``erf``, ``zerf``, ``sqrt``,; ``real``, ``imag``, ``conj``, ``abs``, ``",MatchSource.DOCS,doc/guide/dynamics/dynamics-time.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst:12877,Availability,avail,available,12877," isherm=True; Qobj data =; [[0. 3.]; [3. 0.]]. Coefficients; ============. To build time dependent quantum system we often use a list of :obj:`.Qobj` and; :obj:`.Coefficient`. These :obj:`.Coefficient` represent the strength of the corresponding; quantum object a function that of time. Up to now, we used functions for these,; but QuTiP support multiple formats: ``callable``, ``strings``, ``array``. **Function coefficients** :; Use a callable with the signature ``f(t: double, ...) -> double`` as coefficient.; Any function or method that can be called by ``f(t, args)``, ``f(t, **args)`` is accepted. .. code-block:: python. def coeff(t, A, sigma):; return A * np.exp(-(t / sigma)**2). H = QobjEvo([H0, [H1, coeff]], args=args). **String coefficients** :; Use a string containing a simple Python expression.; The variable ``t``, common mathematical functions such as ``sin`` or ``exp`` an; variable in args will be available. If available, the string will be compiled using; cython, fixing variable type when possible, allowing slightly faster execution than function.; While the speed up is usually very small, in long evolution, numerous calls to the; functions are made and it's can accumulate. From version 5, compilation of the; coefficient is done only once and saved between sessions. When either the cython or; filelock modules are not available, the code will be executed in python using; ``exec`` with the same environment . This, however, as no advantage over using; python function. .. code-block:: python. coeff = ""A * exp(-(t / sigma)**2)"". H = QobjEvo([H0, [H1, coeff]], args=args). Here is a list of defined variables:; ``sin``, ``cos``, ``tan``, ``asin``, ``acos``, ``atan``, ``pi``,; ``sinh``, ``cosh``, ``tanh``, ``asinh``, ``acosh``, ``atanh``,; ``exp``, ``log``, ``log10``, ``erf``, ``zerf``, ``sqrt``,; ``real``, ``imag``, ``conj``, ``abs``, ``norm``, ``arg``, ``proj``,; ``np`` (numpy), ``spe`` (scipy.special) and ``cython_special``; (scipy cython interface). **Array coeff",MatchSource.DOCS,doc/guide/dynamics/dynamics-time.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst:13292,Availability,avail,available,13292,"callable``, ``strings``, ``array``. **Function coefficients** :; Use a callable with the signature ``f(t: double, ...) -> double`` as coefficient.; Any function or method that can be called by ``f(t, args)``, ``f(t, **args)`` is accepted. .. code-block:: python. def coeff(t, A, sigma):; return A * np.exp(-(t / sigma)**2). H = QobjEvo([H0, [H1, coeff]], args=args). **String coefficients** :; Use a string containing a simple Python expression.; The variable ``t``, common mathematical functions such as ``sin`` or ``exp`` an; variable in args will be available. If available, the string will be compiled using; cython, fixing variable type when possible, allowing slightly faster execution than function.; While the speed up is usually very small, in long evolution, numerous calls to the; functions are made and it's can accumulate. From version 5, compilation of the; coefficient is done only once and saved between sessions. When either the cython or; filelock modules are not available, the code will be executed in python using; ``exec`` with the same environment . This, however, as no advantage over using; python function. .. code-block:: python. coeff = ""A * exp(-(t / sigma)**2)"". H = QobjEvo([H0, [H1, coeff]], args=args). Here is a list of defined variables:; ``sin``, ``cos``, ``tan``, ``asin``, ``acos``, ``atan``, ``pi``,; ``sinh``, ``cosh``, ``tanh``, ``asinh``, ``acosh``, ``atanh``,; ``exp``, ``log``, ``log10``, ``erf``, ``zerf``, ``sqrt``,; ``real``, ``imag``, ``conj``, ``abs``, ``norm``, ``arg``, ``proj``,; ``np`` (numpy), ``spe`` (scipy.special) and ``cython_special``; (scipy cython interface). **Array coefficients** :; Use the spline interpolation of an array.; Useful when the coefficient is hard to define as a function or obtained from experimental data.; The times at which the array are defined must be passed as ``tlist``:. .. code-block:: python. times = np.linspace(-sigma*5, sigma*5, 500); coeff = A * exp(-(times / sigma)**2). H = QobjEvo([H0, [H1, coeff]], tlis",MatchSource.DOCS,doc/guide/dynamics/dynamics-time.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst:10895,Deployability,update,update,10895,"o(1)); Quantum object: dims=[[2], [2]], shape=(2, 2), type='oper', isherm=True; Qobj data =; [[ 1. 8.64710495]; [ 8.64710495 -1. ]]; >>> print(qevo(1, {""A"": 5, ""sigma"": 0.2})); Quantum object: dims=[[2], [2]], shape=(2, 2), type='oper', isherm=True; Qobj data =; [[ 1.00000000e+00 6.94397193e-11]; [ 6.94397193e-11 -1.00000000e+00]]; >>> print(qevo(1, A=5)); Quantum object: dims=[[2], [2]], shape=(2, 2), type='oper', isherm=True; Qobj data =; [[ 1. 4.8039472]; [ 4.8039472 -1. ]]. Whether the original coefficient used the ``args`` or specific input does not matter.; It is fine to mix the different signatures. Solver calls take an ``args`` input that is used to build the time dependent system.; If the Hamiltonian or collapse operators are already :obj:`.QobjEvo`, their arguments will be overwritten. .. code-block:: python. def system(t, A, sigma):; return H0 + H1 * (A * np.exp(-(t / sigma)**2)). mesolve(system, ..., args=args). To update arguments of an existing time dependent quantum system, you can pass the; previous object as the input of a :obj:`.QobjEvo` with new ``args``:. .. code-block:: python. >>> new_qevo = QobjEvo(qevo, args={""A"": 5, ""sigma"": 0.2}); >>> new_qevo(1) == qevo(1, {""A"": 5, ""sigma"": 0.2}); True. :obj:`.QobjEvo` created from a monolithic function can also use arguments:. .. code-block:: python. def oper(t, w):; return num(N) + (destroy(N) + create(N)) * np.sin(t*w). H_t = QobjEvo(oper, args={""w"": np.pi}). When merging two or more :obj:`.QobjEvo`, each will keep it arguments, but; calling it with updated are will affect all parts:. .. code-block:: python. >>> qevo1 = QobjEvo([[sigmap(), lambda t, a: a]], args={""a"": 1}); >>> qevo2 = QobjEvo([[sigmam(), lambda t, a: a]], args={""a"": 2}); >>> summed_evo = qevo1 + qevo2; >>> print(summed_evo(0)); Quantum object: dims=[[2], [2]], shape=(2, 2), type='oper', isherm=False; Qobj data =; [[0. 1.]; [2. 0.]]; >>> print(summed_evo(0, a=3, b=1)); Quantum object: dims=[[2], [2]], shape=(2, 2), type='oper', isherm=Tr",MatchSource.DOCS,doc/guide/dynamics/dynamics-time.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst:11492,Deployability,update,updated,11492,"``args`` or specific input does not matter.; It is fine to mix the different signatures. Solver calls take an ``args`` input that is used to build the time dependent system.; If the Hamiltonian or collapse operators are already :obj:`.QobjEvo`, their arguments will be overwritten. .. code-block:: python. def system(t, A, sigma):; return H0 + H1 * (A * np.exp(-(t / sigma)**2)). mesolve(system, ..., args=args). To update arguments of an existing time dependent quantum system, you can pass the; previous object as the input of a :obj:`.QobjEvo` with new ``args``:. .. code-block:: python. >>> new_qevo = QobjEvo(qevo, args={""A"": 5, ""sigma"": 0.2}); >>> new_qevo(1) == qevo(1, {""A"": 5, ""sigma"": 0.2}); True. :obj:`.QobjEvo` created from a monolithic function can also use arguments:. .. code-block:: python. def oper(t, w):; return num(N) + (destroy(N) + create(N)) * np.sin(t*w). H_t = QobjEvo(oper, args={""w"": np.pi}). When merging two or more :obj:`.QobjEvo`, each will keep it arguments, but; calling it with updated are will affect all parts:. .. code-block:: python. >>> qevo1 = QobjEvo([[sigmap(), lambda t, a: a]], args={""a"": 1}); >>> qevo2 = QobjEvo([[sigmam(), lambda t, a: a]], args={""a"": 2}); >>> summed_evo = qevo1 + qevo2; >>> print(summed_evo(0)); Quantum object: dims=[[2], [2]], shape=(2, 2), type='oper', isherm=False; Qobj data =; [[0. 1.]; [2. 0.]]; >>> print(summed_evo(0, a=3, b=1)); Quantum object: dims=[[2], [2]], shape=(2, 2), type='oper', isherm=True; Qobj data =; [[0. 3.]; [3. 0.]]. Coefficients; ============. To build time dependent quantum system we often use a list of :obj:`.Qobj` and; :obj:`.Coefficient`. These :obj:`.Coefficient` represent the strength of the corresponding; quantum object a function that of time. Up to now, we used functions for these,; but QuTiP support multiple formats: ``callable``, ``strings``, ``array``. **Function coefficients** :; Use a callable with the signature ``f(t: double, ...) -> double`` as coefficient.; Any function or method",MatchSource.DOCS,doc/guide/dynamics/dynamics-time.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst:16648,Deployability,integrat,integration,16648,"mes). c_ops = [QobjEvo([destroy(N), coeff], tlist=times)]; tlist = np.linspace(0, 1, 11); data = mesolve(qeye(N), basis(N, N-1), tlist, c_ops=c_ops, e_ops=[num(N)]).expect[0]; plt.plot(tlist, data). Different coefficient types can be mixed in a :obj:`.QobjEvo`. Given the multiple choices of input style, the first question that arises is which option to choose?; In short, the function based method (first option) is the most general,; allowing for essentially arbitrary coefficients expressed via user defined functions.; However, by automatically compiling your system into C++ code,; the second option (string based) tends to be more efficient and run faster.; Of course, for small system sizes and evolution times, the difference will be minor.; Lastly the spline method is usually as fast the string method, but it cannot be modified once created. .. _time_max_step:. Working with pulses; ===================. Special care is needed when working with pulses. ODE solvers select the step; length automatically and can miss thin pulses when not properly warned.; Integrations methods with variable step sizes have the ``max_step`` option that; control the maximum length of a single internal integration step. This value; should be set to under half the pulse width to be certain they are not missed. For example, the following pulse is missed without fixing the maximum step length. .. plot::; :context: close-figs. def pulse(t):; return 10 * np.pi * (0.7 < t < 0.75). tlist = np.linspace(0, 1, 201); H = [sigmaz(), [sigmax(), pulse]]; psi0 = basis(2,1). data1 = sesolve(H, psi0, tlist, e_ops=num(2)).expect[0]; data2 = sesolve(H, psi0, tlist, e_ops=num(2), options={""max_step"": 0.01}).expect[0]. plt.plot(tlist, data1, label=""no max_step""); plt.plot(tlist, data2, label=""fixed max_step""); plt.fill_between(tlist, [pulse(t) for t in tlist], color=""g"", alpha=0.2, label=""pulse""); plt.ylim([-0.1, 1.1]); plt.legend(loc=""center left""). .. plot::; :context: reset; :include-source: false; :nofigs:; ",MatchSource.DOCS,doc/guide/dynamics/dynamics-time.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst:16090,Energy Efficiency,efficient,efficient,16090,"in solver, if the time dependent quantum system is; in list format, the solver tlist is used as times of the array.; This is often not ideal as the interpolation is usually less precise close the extremities of the range.; It is therefore better to create the QobjEvo using an extended range prior to the solver:. .. plot::; :context: close-figs. N = 5; times = np.linspace(-0.1, 1.1, 13); coeff = np.exp(-times). c_ops = [QobjEvo([destroy(N), coeff], tlist=times)]; tlist = np.linspace(0, 1, 11); data = mesolve(qeye(N), basis(N, N-1), tlist, c_ops=c_ops, e_ops=[num(N)]).expect[0]; plt.plot(tlist, data). Different coefficient types can be mixed in a :obj:`.QobjEvo`. Given the multiple choices of input style, the first question that arises is which option to choose?; In short, the function based method (first option) is the most general,; allowing for essentially arbitrary coefficients expressed via user defined functions.; However, by automatically compiling your system into C++ code,; the second option (string based) tends to be more efficient and run faster.; Of course, for small system sizes and evolution times, the difference will be minor.; Lastly the spline method is usually as fast the string method, but it cannot be modified once created. .. _time_max_step:. Working with pulses; ===================. Special care is needed when working with pulses. ODE solvers select the step; length automatically and can miss thin pulses when not properly warned.; Integrations methods with variable step sizes have the ``max_step`` option that; control the maximum length of a single internal integration step. This value; should be set to under half the pulse width to be certain they are not missed. For example, the following pulse is missed without fixing the maximum step length. .. plot::; :context: close-figs. def pulse(t):; return 10 * np.pi * (0.7 < t < 0.75). tlist = np.linspace(0, 1, 201); H = [sigmaz(), [sigmax(), pulse]]; psi0 = basis(2,1). data1 = sesolve(H, psi0, tlist, e",MatchSource.DOCS,doc/guide/dynamics/dynamics-time.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst:89,Integrability,depend,dependent,89,".. _time:. *************************************************; Solving Problems with Time-dependent Hamiltonians; *************************************************. Time-Dependent Operators; ========================. In the previous examples of quantum evolution,; we assumed that the systems under consideration were described by time-independent Hamiltonians.; However, many systems have explicit time dependence in either the Hamiltonian,; or the collapse operators describing coupling to the environment, and sometimes; both components might depend on time. The time-evolutions solvers such as :func:`.sesolve`,; :func:`.brmesolve`, etc. are all capable of handling time-dependent Hamiltonians and collapse terms.; QuTiP use :obj:`.QobjEvo` to represent time-dependent quantum operators.; There are three different ways to build a :obj:`.QobjEvo`:. 1. **Function based**: Build the time dependent operator from a function returning a :obj:`.Qobj`:. .. code-block:: python. def oper(t):; return num(N) + (destroy(N) + create(N)) * np.sin(t). H_t = QobjEvo(oper). 1. **List based**: The time dependent quantum operator is represented as a list of ``qobj`` and ``[qobj, coefficient]`` pairs:. .. code-block:: python. H_t = QobjEvo([num(N), [create(N), lambda t: np.sin(t)], [destroy(N), lambda t: np.sin(t)]]). 3. **coefficent based**: The product of a :obj:`.Qobj` with a :obj:`.Coefficient`,; created by the :func:`.coefficient` function, result in a :obj:`.QobjEvo`:. .. code-block:: python. coeff = coefficent(lambda t: np.sin(t)); H_t = num(N) + (destroy(N) + create(N)) * coeff. These 3 examples will create the same time dependent operator, however the function; based method will usually be slower when used in solver. Most solvers accept a :obj:`.QobjEvo` when an operator is expected: this include; the Hamiltonian ``H``, collapse operators, expectation values operators, the operator; of :func:`.brmesolve`'s ``a_ops``, etc. Exception are :func:`.krylovsolve`'s; Hamiltonian and HEOM's Bath",MatchSource.DOCS,doc/guide/dynamics/dynamics-time.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst:403,Integrability,depend,dependence,403,".. _time:. *************************************************; Solving Problems with Time-dependent Hamiltonians; *************************************************. Time-Dependent Operators; ========================. In the previous examples of quantum evolution,; we assumed that the systems under consideration were described by time-independent Hamiltonians.; However, many systems have explicit time dependence in either the Hamiltonian,; or the collapse operators describing coupling to the environment, and sometimes; both components might depend on time. The time-evolutions solvers such as :func:`.sesolve`,; :func:`.brmesolve`, etc. are all capable of handling time-dependent Hamiltonians and collapse terms.; QuTiP use :obj:`.QobjEvo` to represent time-dependent quantum operators.; There are three different ways to build a :obj:`.QobjEvo`:. 1. **Function based**: Build the time dependent operator from a function returning a :obj:`.Qobj`:. .. code-block:: python. def oper(t):; return num(N) + (destroy(N) + create(N)) * np.sin(t). H_t = QobjEvo(oper). 1. **List based**: The time dependent quantum operator is represented as a list of ``qobj`` and ``[qobj, coefficient]`` pairs:. .. code-block:: python. H_t = QobjEvo([num(N), [create(N), lambda t: np.sin(t)], [destroy(N), lambda t: np.sin(t)]]). 3. **coefficent based**: The product of a :obj:`.Qobj` with a :obj:`.Coefficient`,; created by the :func:`.coefficient` function, result in a :obj:`.QobjEvo`:. .. code-block:: python. coeff = coefficent(lambda t: np.sin(t)); H_t = num(N) + (destroy(N) + create(N)) * coeff. These 3 examples will create the same time dependent operator, however the function; based method will usually be slower when used in solver. Most solvers accept a :obj:`.QobjEvo` when an operator is expected: this include; the Hamiltonian ``H``, collapse operators, expectation values operators, the operator; of :func:`.brmesolve`'s ``a_ops``, etc. Exception are :func:`.krylovsolve`'s; Hamiltonian and HEOM's Bath",MatchSource.DOCS,doc/guide/dynamics/dynamics-time.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst:545,Integrability,depend,depend,545,".. _time:. *************************************************; Solving Problems with Time-dependent Hamiltonians; *************************************************. Time-Dependent Operators; ========================. In the previous examples of quantum evolution,; we assumed that the systems under consideration were described by time-independent Hamiltonians.; However, many systems have explicit time dependence in either the Hamiltonian,; or the collapse operators describing coupling to the environment, and sometimes; both components might depend on time. The time-evolutions solvers such as :func:`.sesolve`,; :func:`.brmesolve`, etc. are all capable of handling time-dependent Hamiltonians and collapse terms.; QuTiP use :obj:`.QobjEvo` to represent time-dependent quantum operators.; There are three different ways to build a :obj:`.QobjEvo`:. 1. **Function based**: Build the time dependent operator from a function returning a :obj:`.Qobj`:. .. code-block:: python. def oper(t):; return num(N) + (destroy(N) + create(N)) * np.sin(t). H_t = QobjEvo(oper). 1. **List based**: The time dependent quantum operator is represented as a list of ``qobj`` and ``[qobj, coefficient]`` pairs:. .. code-block:: python. H_t = QobjEvo([num(N), [create(N), lambda t: np.sin(t)], [destroy(N), lambda t: np.sin(t)]]). 3. **coefficent based**: The product of a :obj:`.Qobj` with a :obj:`.Coefficient`,; created by the :func:`.coefficient` function, result in a :obj:`.QobjEvo`:. .. code-block:: python. coeff = coefficent(lambda t: np.sin(t)); H_t = num(N) + (destroy(N) + create(N)) * coeff. These 3 examples will create the same time dependent operator, however the function; based method will usually be slower when used in solver. Most solvers accept a :obj:`.QobjEvo` when an operator is expected: this include; the Hamiltonian ``H``, collapse operators, expectation values operators, the operator; of :func:`.brmesolve`'s ``a_ops``, etc. Exception are :func:`.krylovsolve`'s; Hamiltonian and HEOM's Bath",MatchSource.DOCS,doc/guide/dynamics/dynamics-time.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst:674,Integrability,depend,dependent,674,".. _time:. *************************************************; Solving Problems with Time-dependent Hamiltonians; *************************************************. Time-Dependent Operators; ========================. In the previous examples of quantum evolution,; we assumed that the systems under consideration were described by time-independent Hamiltonians.; However, many systems have explicit time dependence in either the Hamiltonian,; or the collapse operators describing coupling to the environment, and sometimes; both components might depend on time. The time-evolutions solvers such as :func:`.sesolve`,; :func:`.brmesolve`, etc. are all capable of handling time-dependent Hamiltonians and collapse terms.; QuTiP use :obj:`.QobjEvo` to represent time-dependent quantum operators.; There are three different ways to build a :obj:`.QobjEvo`:. 1. **Function based**: Build the time dependent operator from a function returning a :obj:`.Qobj`:. .. code-block:: python. def oper(t):; return num(N) + (destroy(N) + create(N)) * np.sin(t). H_t = QobjEvo(oper). 1. **List based**: The time dependent quantum operator is represented as a list of ``qobj`` and ``[qobj, coefficient]`` pairs:. .. code-block:: python. H_t = QobjEvo([num(N), [create(N), lambda t: np.sin(t)], [destroy(N), lambda t: np.sin(t)]]). 3. **coefficent based**: The product of a :obj:`.Qobj` with a :obj:`.Coefficient`,; created by the :func:`.coefficient` function, result in a :obj:`.QobjEvo`:. .. code-block:: python. coeff = coefficent(lambda t: np.sin(t)); H_t = num(N) + (destroy(N) + create(N)) * coeff. These 3 examples will create the same time dependent operator, however the function; based method will usually be slower when used in solver. Most solvers accept a :obj:`.QobjEvo` when an operator is expected: this include; the Hamiltonian ``H``, collapse operators, expectation values operators, the operator; of :func:`.brmesolve`'s ``a_ops``, etc. Exception are :func:`.krylovsolve`'s; Hamiltonian and HEOM's Bath",MatchSource.DOCS,doc/guide/dynamics/dynamics-time.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst:762,Integrability,depend,dependent,762,".. _time:. *************************************************; Solving Problems with Time-dependent Hamiltonians; *************************************************. Time-Dependent Operators; ========================. In the previous examples of quantum evolution,; we assumed that the systems under consideration were described by time-independent Hamiltonians.; However, many systems have explicit time dependence in either the Hamiltonian,; or the collapse operators describing coupling to the environment, and sometimes; both components might depend on time. The time-evolutions solvers such as :func:`.sesolve`,; :func:`.brmesolve`, etc. are all capable of handling time-dependent Hamiltonians and collapse terms.; QuTiP use :obj:`.QobjEvo` to represent time-dependent quantum operators.; There are three different ways to build a :obj:`.QobjEvo`:. 1. **Function based**: Build the time dependent operator from a function returning a :obj:`.Qobj`:. .. code-block:: python. def oper(t):; return num(N) + (destroy(N) + create(N)) * np.sin(t). H_t = QobjEvo(oper). 1. **List based**: The time dependent quantum operator is represented as a list of ``qobj`` and ``[qobj, coefficient]`` pairs:. .. code-block:: python. H_t = QobjEvo([num(N), [create(N), lambda t: np.sin(t)], [destroy(N), lambda t: np.sin(t)]]). 3. **coefficent based**: The product of a :obj:`.Qobj` with a :obj:`.Coefficient`,; created by the :func:`.coefficient` function, result in a :obj:`.QobjEvo`:. .. code-block:: python. coeff = coefficent(lambda t: np.sin(t)); H_t = num(N) + (destroy(N) + create(N)) * coeff. These 3 examples will create the same time dependent operator, however the function; based method will usually be slower when used in solver. Most solvers accept a :obj:`.QobjEvo` when an operator is expected: this include; the Hamiltonian ``H``, collapse operators, expectation values operators, the operator; of :func:`.brmesolve`'s ``a_ops``, etc. Exception are :func:`.krylovsolve`'s; Hamiltonian and HEOM's Bath",MatchSource.DOCS,doc/guide/dynamics/dynamics-time.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst:890,Integrability,depend,dependent,890,".. _time:. *************************************************; Solving Problems with Time-dependent Hamiltonians; *************************************************. Time-Dependent Operators; ========================. In the previous examples of quantum evolution,; we assumed that the systems under consideration were described by time-independent Hamiltonians.; However, many systems have explicit time dependence in either the Hamiltonian,; or the collapse operators describing coupling to the environment, and sometimes; both components might depend on time. The time-evolutions solvers such as :func:`.sesolve`,; :func:`.brmesolve`, etc. are all capable of handling time-dependent Hamiltonians and collapse terms.; QuTiP use :obj:`.QobjEvo` to represent time-dependent quantum operators.; There are three different ways to build a :obj:`.QobjEvo`:. 1. **Function based**: Build the time dependent operator from a function returning a :obj:`.Qobj`:. .. code-block:: python. def oper(t):; return num(N) + (destroy(N) + create(N)) * np.sin(t). H_t = QobjEvo(oper). 1. **List based**: The time dependent quantum operator is represented as a list of ``qobj`` and ``[qobj, coefficient]`` pairs:. .. code-block:: python. H_t = QobjEvo([num(N), [create(N), lambda t: np.sin(t)], [destroy(N), lambda t: np.sin(t)]]). 3. **coefficent based**: The product of a :obj:`.Qobj` with a :obj:`.Coefficient`,; created by the :func:`.coefficient` function, result in a :obj:`.QobjEvo`:. .. code-block:: python. coeff = coefficent(lambda t: np.sin(t)); H_t = num(N) + (destroy(N) + create(N)) * coeff. These 3 examples will create the same time dependent operator, however the function; based method will usually be slower when used in solver. Most solvers accept a :obj:`.QobjEvo` when an operator is expected: this include; the Hamiltonian ``H``, collapse operators, expectation values operators, the operator; of :func:`.brmesolve`'s ``a_ops``, etc. Exception are :func:`.krylovsolve`'s; Hamiltonian and HEOM's Bath",MatchSource.DOCS,doc/guide/dynamics/dynamics-time.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst:1093,Integrability,depend,dependent,1093,"*********************************. Time-Dependent Operators; ========================. In the previous examples of quantum evolution,; we assumed that the systems under consideration were described by time-independent Hamiltonians.; However, many systems have explicit time dependence in either the Hamiltonian,; or the collapse operators describing coupling to the environment, and sometimes; both components might depend on time. The time-evolutions solvers such as :func:`.sesolve`,; :func:`.brmesolve`, etc. are all capable of handling time-dependent Hamiltonians and collapse terms.; QuTiP use :obj:`.QobjEvo` to represent time-dependent quantum operators.; There are three different ways to build a :obj:`.QobjEvo`:. 1. **Function based**: Build the time dependent operator from a function returning a :obj:`.Qobj`:. .. code-block:: python. def oper(t):; return num(N) + (destroy(N) + create(N)) * np.sin(t). H_t = QobjEvo(oper). 1. **List based**: The time dependent quantum operator is represented as a list of ``qobj`` and ``[qobj, coefficient]`` pairs:. .. code-block:: python. H_t = QobjEvo([num(N), [create(N), lambda t: np.sin(t)], [destroy(N), lambda t: np.sin(t)]]). 3. **coefficent based**: The product of a :obj:`.Qobj` with a :obj:`.Coefficient`,; created by the :func:`.coefficient` function, result in a :obj:`.QobjEvo`:. .. code-block:: python. coeff = coefficent(lambda t: np.sin(t)); H_t = num(N) + (destroy(N) + create(N)) * coeff. These 3 examples will create the same time dependent operator, however the function; based method will usually be slower when used in solver. Most solvers accept a :obj:`.QobjEvo` when an operator is expected: this include; the Hamiltonian ``H``, collapse operators, expectation values operators, the operator; of :func:`.brmesolve`'s ``a_ops``, etc. Exception are :func:`.krylovsolve`'s; Hamiltonian and HEOM's Bath operators. Most solvers will accept any format that could be made into a :obj:`.QobjEvo` for the Hamiltonian.; All of the follow",MatchSource.DOCS,doc/guide/dynamics/dynamics-time.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst:1628,Integrability,depend,dependent,1628,"e of handling time-dependent Hamiltonians and collapse terms.; QuTiP use :obj:`.QobjEvo` to represent time-dependent quantum operators.; There are three different ways to build a :obj:`.QobjEvo`:. 1. **Function based**: Build the time dependent operator from a function returning a :obj:`.Qobj`:. .. code-block:: python. def oper(t):; return num(N) + (destroy(N) + create(N)) * np.sin(t). H_t = QobjEvo(oper). 1. **List based**: The time dependent quantum operator is represented as a list of ``qobj`` and ``[qobj, coefficient]`` pairs:. .. code-block:: python. H_t = QobjEvo([num(N), [create(N), lambda t: np.sin(t)], [destroy(N), lambda t: np.sin(t)]]). 3. **coefficent based**: The product of a :obj:`.Qobj` with a :obj:`.Coefficient`,; created by the :func:`.coefficient` function, result in a :obj:`.QobjEvo`:. .. code-block:: python. coeff = coefficent(lambda t: np.sin(t)); H_t = num(N) + (destroy(N) + create(N)) * coeff. These 3 examples will create the same time dependent operator, however the function; based method will usually be slower when used in solver. Most solvers accept a :obj:`.QobjEvo` when an operator is expected: this include; the Hamiltonian ``H``, collapse operators, expectation values operators, the operator; of :func:`.brmesolve`'s ``a_ops``, etc. Exception are :func:`.krylovsolve`'s; Hamiltonian and HEOM's Bath operators. Most solvers will accept any format that could be made into a :obj:`.QobjEvo` for the Hamiltonian.; All of the following are equivalent:. .. code-block:: python. result = mesolve(H_t, ...); result = mesolve([num(N), [destroy(N) + create(N), lambda t: np.sin(t)]], ...); result = mesolve(oper, ...). Collapse operator also accept a list of object that could be made into :obj:`.QobjEvo`.; However one needs to be careful about not confusing the list nature of the `c_ops`; parameter with list format quantum system. In the following call:. .. code-block:: python. result = mesolve(H_t, ..., c_ops=[num(N), [destroy(N) + create(N), lambda t: np",MatchSource.DOCS,doc/guide/dynamics/dynamics-time.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst:2939,Integrability,depend,dependent,2939,"ors. Most solvers will accept any format that could be made into a :obj:`.QobjEvo` for the Hamiltonian.; All of the following are equivalent:. .. code-block:: python. result = mesolve(H_t, ...); result = mesolve([num(N), [destroy(N) + create(N), lambda t: np.sin(t)]], ...); result = mesolve(oper, ...). Collapse operator also accept a list of object that could be made into :obj:`.QobjEvo`.; However one needs to be careful about not confusing the list nature of the `c_ops`; parameter with list format quantum system. In the following call:. .. code-block:: python. result = mesolve(H_t, ..., c_ops=[num(N), [destroy(N) + create(N), lambda t: np.sin(t)]]). :func:`.mesolve` will see 2 collapses operators:; ``num(N)`` and ``[destroy(N) + create(N), lambda t: np.sin(t)]``.; It is therefore preferred to pass each collapse operator as either a :obj:`.Qobj`; or a :obj:`.QobjEvo`. As an example, we will look at a case with a time-dependent Hamiltonian of the form; :math:`H=H_{0}+f(t)H_{1}` where :math:`f(t)` is the time-dependent driving strength; given as :math:`f(t)=A\exp\left[-\left( t/\sigma \right)^{2}\right]`.; The following code sets up the problem. .. plot::; :context: reset. ustate = basis(3, 0); excited = basis(3, 1); ground = basis(3, 2). N = 2 # Set where to truncate Fock state for cavity; sigma_ge = tensor(qeye(N), ground * excited.dag()) # |g><e|; sigma_ue = tensor(qeye(N), ustate * excited.dag()) # |u><e|; a = tensor(destroy(N), qeye(3)); ada = tensor(num(N), qeye(3)). c_ops = [] # Build collapse operators; kappa = 1.5 # Cavity decay rate; c_ops.append(np.sqrt(kappa) * a); gamma = 6 # Atomic decay rate; c_ops.append(np.sqrt(5*gamma/9) * sigma_ue) # Use Rb branching ratio of 5/9 e->u; c_ops.append(np.sqrt(4*gamma/9) * sigma_ge) # 4/9 e->g. t = np.linspace(-15, 15, 100) # Define time vector; psi0 = tensor(basis(N, 0), ustate) # Define initial state. state_GG = tensor(basis(N, 1), ground) # Define states onto which to project; sigma_GG = state_GG * state_GG.dag(); st",MatchSource.DOCS,doc/guide/dynamics/dynamics-time.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst:3031,Integrability,depend,dependent,3031,"ors. Most solvers will accept any format that could be made into a :obj:`.QobjEvo` for the Hamiltonian.; All of the following are equivalent:. .. code-block:: python. result = mesolve(H_t, ...); result = mesolve([num(N), [destroy(N) + create(N), lambda t: np.sin(t)]], ...); result = mesolve(oper, ...). Collapse operator also accept a list of object that could be made into :obj:`.QobjEvo`.; However one needs to be careful about not confusing the list nature of the `c_ops`; parameter with list format quantum system. In the following call:. .. code-block:: python. result = mesolve(H_t, ..., c_ops=[num(N), [destroy(N) + create(N), lambda t: np.sin(t)]]). :func:`.mesolve` will see 2 collapses operators:; ``num(N)`` and ``[destroy(N) + create(N), lambda t: np.sin(t)]``.; It is therefore preferred to pass each collapse operator as either a :obj:`.Qobj`; or a :obj:`.QobjEvo`. As an example, we will look at a case with a time-dependent Hamiltonian of the form; :math:`H=H_{0}+f(t)H_{1}` where :math:`f(t)` is the time-dependent driving strength; given as :math:`f(t)=A\exp\left[-\left( t/\sigma \right)^{2}\right]`.; The following code sets up the problem. .. plot::; :context: reset. ustate = basis(3, 0); excited = basis(3, 1); ground = basis(3, 2). N = 2 # Set where to truncate Fock state for cavity; sigma_ge = tensor(qeye(N), ground * excited.dag()) # |g><e|; sigma_ue = tensor(qeye(N), ustate * excited.dag()) # |u><e|; a = tensor(destroy(N), qeye(3)); ada = tensor(num(N), qeye(3)). c_ops = [] # Build collapse operators; kappa = 1.5 # Cavity decay rate; c_ops.append(np.sqrt(kappa) * a); gamma = 6 # Atomic decay rate; c_ops.append(np.sqrt(5*gamma/9) * sigma_ue) # Use Rb branching ratio of 5/9 e->u; c_ops.append(np.sqrt(4*gamma/9) * sigma_ge) # 4/9 e->g. t = np.linspace(-15, 15, 100) # Define time vector; psi0 = tensor(basis(N, 0), ustate) # Define initial state. state_GG = tensor(basis(N, 1), ground) # Define states onto which to project; sigma_GG = state_GG * state_GG.dag(); st",MatchSource.DOCS,doc/guide/dynamics/dynamics-time.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst:4228,Integrability,depend,dependent,4228,"ited = basis(3, 1); ground = basis(3, 2). N = 2 # Set where to truncate Fock state for cavity; sigma_ge = tensor(qeye(N), ground * excited.dag()) # |g><e|; sigma_ue = tensor(qeye(N), ustate * excited.dag()) # |u><e|; a = tensor(destroy(N), qeye(3)); ada = tensor(num(N), qeye(3)). c_ops = [] # Build collapse operators; kappa = 1.5 # Cavity decay rate; c_ops.append(np.sqrt(kappa) * a); gamma = 6 # Atomic decay rate; c_ops.append(np.sqrt(5*gamma/9) * sigma_ue) # Use Rb branching ratio of 5/9 e->u; c_ops.append(np.sqrt(4*gamma/9) * sigma_ge) # 4/9 e->g. t = np.linspace(-15, 15, 100) # Define time vector; psi0 = tensor(basis(N, 0), ustate) # Define initial state. state_GG = tensor(basis(N, 1), ground) # Define states onto which to project; sigma_GG = state_GG * state_GG.dag(); state_UU = tensor(basis(N, 0), ustate); sigma_UU = state_UU * state_UU.dag(). g = 5 # coupling strength; H0 = -g * (sigma_ge.dag() * a + a.dag() * sigma_ge) # time-independent term; H1 = (sigma_ue.dag() + sigma_ue) # time-dependent term. Given that we have a single time-dependent Hamiltonian term, and constant collapse terms,; we need to specify a single Python function for the coefficient :math:`f(t)`.; In this case, one can simply do. .. plot::; :context: close-figs; :nofigs:. def H1_coeff(t):; return 9 * np.exp(-(t / 5.) ** 2). In this case, the return value depends only on time. However it is possible to; add optional arguments to the call, see `Using arguments`_.; Having specified our coefficient function, we can now specify the Hamiltonian in; list format and call the solver (in this case :func:`.mesolve`). .. plot::; :context: close-figs. H = [H0, [H1, H1_coeff]]; output = mesolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). We can call the Monte Carlo solver in the exact same way (if using the default ``ntraj=500``):. ..; Hacky fix because plot has complicated conditional code execution. .. doctest::; :skipif: True. output = mcsolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). The outpu",MatchSource.DOCS,doc/guide/dynamics/dynamics-time.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst:4277,Integrability,depend,dependent,4277,"= tensor(qeye(N), ground * excited.dag()) # |g><e|; sigma_ue = tensor(qeye(N), ustate * excited.dag()) # |u><e|; a = tensor(destroy(N), qeye(3)); ada = tensor(num(N), qeye(3)). c_ops = [] # Build collapse operators; kappa = 1.5 # Cavity decay rate; c_ops.append(np.sqrt(kappa) * a); gamma = 6 # Atomic decay rate; c_ops.append(np.sqrt(5*gamma/9) * sigma_ue) # Use Rb branching ratio of 5/9 e->u; c_ops.append(np.sqrt(4*gamma/9) * sigma_ge) # 4/9 e->g. t = np.linspace(-15, 15, 100) # Define time vector; psi0 = tensor(basis(N, 0), ustate) # Define initial state. state_GG = tensor(basis(N, 1), ground) # Define states onto which to project; sigma_GG = state_GG * state_GG.dag(); state_UU = tensor(basis(N, 0), ustate); sigma_UU = state_UU * state_UU.dag(). g = 5 # coupling strength; H0 = -g * (sigma_ge.dag() * a + a.dag() * sigma_ge) # time-independent term; H1 = (sigma_ue.dag() + sigma_ue) # time-dependent term. Given that we have a single time-dependent Hamiltonian term, and constant collapse terms,; we need to specify a single Python function for the coefficient :math:`f(t)`.; In this case, one can simply do. .. plot::; :context: close-figs; :nofigs:. def H1_coeff(t):; return 9 * np.exp(-(t / 5.) ** 2). In this case, the return value depends only on time. However it is possible to; add optional arguments to the call, see `Using arguments`_.; Having specified our coefficient function, we can now specify the Hamiltonian in; list format and call the solver (in this case :func:`.mesolve`). .. plot::; :context: close-figs. H = [H0, [H1, H1_coeff]]; output = mesolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). We can call the Monte Carlo solver in the exact same way (if using the default ``ntraj=500``):. ..; Hacky fix because plot has complicated conditional code execution. .. doctest::; :skipif: True. output = mcsolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). The output from the master equation solver is identical to that shown in the examples,; the Monte Carlo however wi",MatchSource.DOCS,doc/guide/dynamics/dynamics-time.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst:4574,Integrability,depend,depends,4574,"y rate; c_ops.append(np.sqrt(kappa) * a); gamma = 6 # Atomic decay rate; c_ops.append(np.sqrt(5*gamma/9) * sigma_ue) # Use Rb branching ratio of 5/9 e->u; c_ops.append(np.sqrt(4*gamma/9) * sigma_ge) # 4/9 e->g. t = np.linspace(-15, 15, 100) # Define time vector; psi0 = tensor(basis(N, 0), ustate) # Define initial state. state_GG = tensor(basis(N, 1), ground) # Define states onto which to project; sigma_GG = state_GG * state_GG.dag(); state_UU = tensor(basis(N, 0), ustate); sigma_UU = state_UU * state_UU.dag(). g = 5 # coupling strength; H0 = -g * (sigma_ge.dag() * a + a.dag() * sigma_ge) # time-independent term; H1 = (sigma_ue.dag() + sigma_ue) # time-dependent term. Given that we have a single time-dependent Hamiltonian term, and constant collapse terms,; we need to specify a single Python function for the coefficient :math:`f(t)`.; In this case, one can simply do. .. plot::; :context: close-figs; :nofigs:. def H1_coeff(t):; return 9 * np.exp(-(t / 5.) ** 2). In this case, the return value depends only on time. However it is possible to; add optional arguments to the call, see `Using arguments`_.; Having specified our coefficient function, we can now specify the Hamiltonian in; list format and call the solver (in this case :func:`.mesolve`). .. plot::; :context: close-figs. H = [H0, [H1, H1_coeff]]; output = mesolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). We can call the Monte Carlo solver in the exact same way (if using the default ``ntraj=500``):. ..; Hacky fix because plot has complicated conditional code execution. .. doctest::; :skipif: True. output = mcsolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). The output from the master equation solver is identical to that shown in the examples,; the Monte Carlo however will be noticeably off, suggesting we should increase the number; of trajectories for this example. In addition, we can also consider the decay of a; simple Harmonic oscillator with time-varying decay rate. .. plot::; :context: close-figs. kap",MatchSource.DOCS,doc/guide/dynamics/dynamics-time.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst:5818,Integrability,depend,dependent,5818," the solver (in this case :func:`.mesolve`). .. plot::; :context: close-figs. H = [H0, [H1, H1_coeff]]; output = mesolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). We can call the Monte Carlo solver in the exact same way (if using the default ``ntraj=500``):. ..; Hacky fix because plot has complicated conditional code execution. .. doctest::; :skipif: True. output = mcsolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). The output from the master equation solver is identical to that shown in the examples,; the Monte Carlo however will be noticeably off, suggesting we should increase the number; of trajectories for this example. In addition, we can also consider the decay of a; simple Harmonic oscillator with time-varying decay rate. .. plot::; :context: close-figs. kappa = 0.5. def col_coeff(t, args): # coefficient function; return np.sqrt(kappa * np.exp(-t)). N = 10 # number of basis states; a = destroy(N); H = a.dag() * a # simple HO; psi0 = basis(N, 9) # initial state; c_ops = [QobjEvo([a, col_coeff])] # time-dependent collapse term; times = np.linspace(0, 10, 100); output = mesolve(H, psi0, times, c_ops, [a.dag() * a]). Qobjevo; =======. :obj:`.QobjEvo` as a time dependent quantum system, as it's main functionality; create a :obj:`.Qobj` at a time:. .. doctest:: [basics]; :options: +NORMALIZE_WHITESPACE. >>> print(H_t(np.pi / 2)); Quantum object: dims=[[2], [2]], shape=(2, 2), type='oper', isherm=True; Qobj data =; [[0. 1.]; [1. 1.]]. :obj:`.QobjEvo` shares a lot of properties with the :obj:`.Qobj`. +----------------+------------------+----------------------------------------+; | Property | Attribute | Description |; +================+==================+========================================+; | Dimensions | ``Q.dims`` | Shapes the tensor structure. |; +----------------+------------------+----------------------------------------+; | Shape | ``Q.shape`` | Dimensions of underlying data matrix. |; +----------------+------------------+-------------------------",MatchSource.DOCS,doc/guide/dynamics/dynamics-time.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst:5976,Integrability,depend,dependent,5976," same way (if using the default ``ntraj=500``):. ..; Hacky fix because plot has complicated conditional code execution. .. doctest::; :skipif: True. output = mcsolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). The output from the master equation solver is identical to that shown in the examples,; the Monte Carlo however will be noticeably off, suggesting we should increase the number; of trajectories for this example. In addition, we can also consider the decay of a; simple Harmonic oscillator with time-varying decay rate. .. plot::; :context: close-figs. kappa = 0.5. def col_coeff(t, args): # coefficient function; return np.sqrt(kappa * np.exp(-t)). N = 10 # number of basis states; a = destroy(N); H = a.dag() * a # simple HO; psi0 = basis(N, 9) # initial state; c_ops = [QobjEvo([a, col_coeff])] # time-dependent collapse term; times = np.linspace(0, 10, 100); output = mesolve(H, psi0, times, c_ops, [a.dag() * a]). Qobjevo; =======. :obj:`.QobjEvo` as a time dependent quantum system, as it's main functionality; create a :obj:`.Qobj` at a time:. .. doctest:: [basics]; :options: +NORMALIZE_WHITESPACE. >>> print(H_t(np.pi / 2)); Quantum object: dims=[[2], [2]], shape=(2, 2), type='oper', isherm=True; Qobj data =; [[0. 1.]; [1. 1.]]. :obj:`.QobjEvo` shares a lot of properties with the :obj:`.Qobj`. +----------------+------------------+----------------------------------------+; | Property | Attribute | Description |; +================+==================+========================================+; | Dimensions | ``Q.dims`` | Shapes the tensor structure. |; +----------------+------------------+----------------------------------------+; | Shape | ``Q.shape`` | Dimensions of underlying data matrix. |; +----------------+------------------+----------------------------------------+; | Type | ``Q.type`` | Is object of type 'ket, 'bra', |; | | | 'oper', or 'super'? |; +----------------+------------------+----------------------------------------+; | Representation | ``Q.superrep``",MatchSource.DOCS,doc/guide/dynamics/dynamics-time.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst:7191,Integrability,depend,depend,7191,"ape=(2, 2), type='oper', isherm=True; Qobj data =; [[0. 1.]; [1. 1.]]. :obj:`.QobjEvo` shares a lot of properties with the :obj:`.Qobj`. +----------------+------------------+----------------------------------------+; | Property | Attribute | Description |; +================+==================+========================================+; | Dimensions | ``Q.dims`` | Shapes the tensor structure. |; +----------------+------------------+----------------------------------------+; | Shape | ``Q.shape`` | Dimensions of underlying data matrix. |; +----------------+------------------+----------------------------------------+; | Type | ``Q.type`` | Is object of type 'ket, 'bra', |; | | | 'oper', or 'super'? |; +----------------+------------------+----------------------------------------+; | Representation | ``Q.superrep`` | Representation used if `type` is |; | | | 'super'? |; +----------------+------------------+----------------------------------------+; | Is constant | ``Q.isconstant`` | Does the QobjEvo depend on time. |; +----------------+------------------+----------------------------------------+. :obj:`.QobjEvo`'s follow the same mathematical operations rules than :obj:`.Qobj`.; They can be added, subtracted and multiplied with scalar, ``Qobj`` and ``QobjEvo``.; They also support the ``dag`` and ``trans`` and ``conj`` method and can be used; for tensor operations and super operator transformation:. .. code-block:: python. H = tensor(H_t, qeye(2)); c_op = tensor(QobjEvo([destroy(N), lambda t: np.exp(-t)]), sigmax()). L = -1j * (spre(H) - spost(H.dag())); L += spre(c_op) * spost(c_op.dag()) - 0.5 * spre(c_op.dag() * c_op) - 0.5 * spost(c_op.dag() * c_op). Or equivalently:. .. code-block:: python. L = liouvillian(H, [c_op]). Using arguments; ---------------. Until now, the coefficients were only functions of time. In the definition of ``H1_coeff``,; the driving amplitude ``A`` and width ``sigma`` were hardcoded with their numerical values.; This is fine for problems that are ",MatchSource.DOCS,doc/guide/dynamics/dynamics-time.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst:10635,Integrability,depend,dependent,10635,"ill fail:. .. code-block:: python. >>> QobjEvo(system); TypeError: H1_coeff() missing 2 required positional arguments: 'A' and 'sigma'. When evaluation the :obj:`.QobjEvo` at a time, new arguments can be passed either; with the ``args`` dictionary positional arguments, or with specific keywords arguments:. .. code-block:: python. >>> print(qevo(1)); Quantum object: dims=[[2], [2]], shape=(2, 2), type='oper', isherm=True; Qobj data =; [[ 1. 8.64710495]; [ 8.64710495 -1. ]]; >>> print(qevo(1, {""A"": 5, ""sigma"": 0.2})); Quantum object: dims=[[2], [2]], shape=(2, 2), type='oper', isherm=True; Qobj data =; [[ 1.00000000e+00 6.94397193e-11]; [ 6.94397193e-11 -1.00000000e+00]]; >>> print(qevo(1, A=5)); Quantum object: dims=[[2], [2]], shape=(2, 2), type='oper', isherm=True; Qobj data =; [[ 1. 4.8039472]; [ 4.8039472 -1. ]]. Whether the original coefficient used the ``args`` or specific input does not matter.; It is fine to mix the different signatures. Solver calls take an ``args`` input that is used to build the time dependent system.; If the Hamiltonian or collapse operators are already :obj:`.QobjEvo`, their arguments will be overwritten. .. code-block:: python. def system(t, A, sigma):; return H0 + H1 * (A * np.exp(-(t / sigma)**2)). mesolve(system, ..., args=args). To update arguments of an existing time dependent quantum system, you can pass the; previous object as the input of a :obj:`.QobjEvo` with new ``args``:. .. code-block:: python. >>> new_qevo = QobjEvo(qevo, args={""A"": 5, ""sigma"": 0.2}); >>> new_qevo(1) == qevo(1, {""A"": 5, ""sigma"": 0.2}); True. :obj:`.QobjEvo` created from a monolithic function can also use arguments:. .. code-block:: python. def oper(t, w):; return num(N) + (destroy(N) + create(N)) * np.sin(t*w). H_t = QobjEvo(oper, args={""w"": np.pi}). When merging two or more :obj:`.QobjEvo`, each will keep it arguments, but; calling it with updated are will affect all parts:. .. code-block:: python. >>> qevo1 = QobjEvo([[sigmap(), lambda t, a: a]], args={""a",MatchSource.DOCS,doc/guide/dynamics/dynamics-time.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst:10932,Integrability,depend,dependent,10932,"o(1)); Quantum object: dims=[[2], [2]], shape=(2, 2), type='oper', isherm=True; Qobj data =; [[ 1. 8.64710495]; [ 8.64710495 -1. ]]; >>> print(qevo(1, {""A"": 5, ""sigma"": 0.2})); Quantum object: dims=[[2], [2]], shape=(2, 2), type='oper', isherm=True; Qobj data =; [[ 1.00000000e+00 6.94397193e-11]; [ 6.94397193e-11 -1.00000000e+00]]; >>> print(qevo(1, A=5)); Quantum object: dims=[[2], [2]], shape=(2, 2), type='oper', isherm=True; Qobj data =; [[ 1. 4.8039472]; [ 4.8039472 -1. ]]. Whether the original coefficient used the ``args`` or specific input does not matter.; It is fine to mix the different signatures. Solver calls take an ``args`` input that is used to build the time dependent system.; If the Hamiltonian or collapse operators are already :obj:`.QobjEvo`, their arguments will be overwritten. .. code-block:: python. def system(t, A, sigma):; return H0 + H1 * (A * np.exp(-(t / sigma)**2)). mesolve(system, ..., args=args). To update arguments of an existing time dependent quantum system, you can pass the; previous object as the input of a :obj:`.QobjEvo` with new ``args``:. .. code-block:: python. >>> new_qevo = QobjEvo(qevo, args={""A"": 5, ""sigma"": 0.2}); >>> new_qevo(1) == qevo(1, {""A"": 5, ""sigma"": 0.2}); True. :obj:`.QobjEvo` created from a monolithic function can also use arguments:. .. code-block:: python. def oper(t, w):; return num(N) + (destroy(N) + create(N)) * np.sin(t*w). H_t = QobjEvo(oper, args={""w"": np.pi}). When merging two or more :obj:`.QobjEvo`, each will keep it arguments, but; calling it with updated are will affect all parts:. .. code-block:: python. >>> qevo1 = QobjEvo([[sigmap(), lambda t, a: a]], args={""a"": 1}); >>> qevo2 = QobjEvo([[sigmam(), lambda t, a: a]], args={""a"": 2}); >>> summed_evo = qevo1 + qevo2; >>> print(summed_evo(0)); Quantum object: dims=[[2], [2]], shape=(2, 2), type='oper', isherm=False; Qobj data =; [[0. 1.]; [2. 0.]]; >>> print(summed_evo(0, a=3, b=1)); Quantum object: dims=[[2], [2]], shape=(2, 2), type='oper', isherm=Tr",MatchSource.DOCS,doc/guide/dynamics/dynamics-time.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst:12033,Integrability,depend,dependent,12033,"-block:: python. >>> new_qevo = QobjEvo(qevo, args={""A"": 5, ""sigma"": 0.2}); >>> new_qevo(1) == qevo(1, {""A"": 5, ""sigma"": 0.2}); True. :obj:`.QobjEvo` created from a monolithic function can also use arguments:. .. code-block:: python. def oper(t, w):; return num(N) + (destroy(N) + create(N)) * np.sin(t*w). H_t = QobjEvo(oper, args={""w"": np.pi}). When merging two or more :obj:`.QobjEvo`, each will keep it arguments, but; calling it with updated are will affect all parts:. .. code-block:: python. >>> qevo1 = QobjEvo([[sigmap(), lambda t, a: a]], args={""a"": 1}); >>> qevo2 = QobjEvo([[sigmam(), lambda t, a: a]], args={""a"": 2}); >>> summed_evo = qevo1 + qevo2; >>> print(summed_evo(0)); Quantum object: dims=[[2], [2]], shape=(2, 2), type='oper', isherm=False; Qobj data =; [[0. 1.]; [2. 0.]]; >>> print(summed_evo(0, a=3, b=1)); Quantum object: dims=[[2], [2]], shape=(2, 2), type='oper', isherm=True; Qobj data =; [[0. 3.]; [3. 0.]]. Coefficients; ============. To build time dependent quantum system we often use a list of :obj:`.Qobj` and; :obj:`.Coefficient`. These :obj:`.Coefficient` represent the strength of the corresponding; quantum object a function that of time. Up to now, we used functions for these,; but QuTiP support multiple formats: ``callable``, ``strings``, ``array``. **Function coefficients** :; Use a callable with the signature ``f(t: double, ...) -> double`` as coefficient.; Any function or method that can be called by ``f(t, args)``, ``f(t, **args)`` is accepted. .. code-block:: python. def coeff(t, A, sigma):; return A * np.exp(-(t / sigma)**2). H = QobjEvo([H0, [H1, coeff]], args=args). **String coefficients** :; Use a string containing a simple Python expression.; The variable ``t``, common mathematical functions such as ``sin`` or ``exp`` an; variable in args will be available. If available, the string will be compiled using; cython, fixing variable type when possible, allowing slightly faster execution than function.; While the speed up is usually very ",MatchSource.DOCS,doc/guide/dynamics/dynamics-time.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst:13920,Integrability,interface,interface,13920,"l be compiled using; cython, fixing variable type when possible, allowing slightly faster execution than function.; While the speed up is usually very small, in long evolution, numerous calls to the; functions are made and it's can accumulate. From version 5, compilation of the; coefficient is done only once and saved between sessions. When either the cython or; filelock modules are not available, the code will be executed in python using; ``exec`` with the same environment . This, however, as no advantage over using; python function. .. code-block:: python. coeff = ""A * exp(-(t / sigma)**2)"". H = QobjEvo([H0, [H1, coeff]], args=args). Here is a list of defined variables:; ``sin``, ``cos``, ``tan``, ``asin``, ``acos``, ``atan``, ``pi``,; ``sinh``, ``cosh``, ``tanh``, ``asinh``, ``acosh``, ``atanh``,; ``exp``, ``log``, ``log10``, ``erf``, ``zerf``, ``sqrt``,; ``real``, ``imag``, ``conj``, ``abs``, ``norm``, ``arg``, ``proj``,; ``np`` (numpy), ``spe`` (scipy.special) and ``cython_special``; (scipy cython interface). **Array coefficients** :; Use the spline interpolation of an array.; Useful when the coefficient is hard to define as a function or obtained from experimental data.; The times at which the array are defined must be passed as ``tlist``:. .. code-block:: python. times = np.linspace(-sigma*5, sigma*5, 500); coeff = A * exp(-(times / sigma)**2). H = QobjEvo([H0, [H1, coeff]], tlist=times). Per default, a cubic spline interpolation is used, but the order of the interpolation can be controlled with the order input:; Outside the interpolation range, the first or last value are used. .. plot::; :context: close-figs. times = np.array([0, 0.1, 0.3, 0.6, 1.0]); coeff = times * (1.1 - times); tlist = np.linspace(-0.1, 1.1, 25). H = QobjEvo([qeye(1), coeff], tlist=times); plt.plot(tlist, [H(t).norm() for t in tlist], label=""CubicSpline""). H = QobjEvo([qeye(1), coeff], tlist=times, order=0); plt.plot(tlist, [H(t).norm() for t in tlist], label=""step""). H = QobjEvo([qeye(",MatchSource.DOCS,doc/guide/dynamics/dynamics-time.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst:15067,Integrability,depend,dependent,15067,"ntal data.; The times at which the array are defined must be passed as ``tlist``:. .. code-block:: python. times = np.linspace(-sigma*5, sigma*5, 500); coeff = A * exp(-(times / sigma)**2). H = QobjEvo([H0, [H1, coeff]], tlist=times). Per default, a cubic spline interpolation is used, but the order of the interpolation can be controlled with the order input:; Outside the interpolation range, the first or last value are used. .. plot::; :context: close-figs. times = np.array([0, 0.1, 0.3, 0.6, 1.0]); coeff = times * (1.1 - times); tlist = np.linspace(-0.1, 1.1, 25). H = QobjEvo([qeye(1), coeff], tlist=times); plt.plot(tlist, [H(t).norm() for t in tlist], label=""CubicSpline""). H = QobjEvo([qeye(1), coeff], tlist=times, order=0); plt.plot(tlist, [H(t).norm() for t in tlist], label=""step""). H = QobjEvo([qeye(1), coeff], tlist=times, order=1); plt.plot(tlist, [H(t).norm() for t in tlist], label=""linear""). plt.legend(). When using array coefficients in solver, if the time dependent quantum system is; in list format, the solver tlist is used as times of the array.; This is often not ideal as the interpolation is usually less precise close the extremities of the range.; It is therefore better to create the QobjEvo using an extended range prior to the solver:. .. plot::; :context: close-figs. N = 5; times = np.linspace(-0.1, 1.1, 13); coeff = np.exp(-times). c_ops = [QobjEvo([destroy(N), coeff], tlist=times)]; tlist = np.linspace(0, 1, 11); data = mesolve(qeye(N), basis(N, N-1), tlist, c_ops=c_ops, e_ops=[num(N)]).expect[0]; plt.plot(tlist, data). Different coefficient types can be mixed in a :obj:`.QobjEvo`. Given the multiple choices of input style, the first question that arises is which option to choose?; In short, the function based method (first option) is the most general,; allowing for essentially arbitrary coefficients expressed via user defined functions.; However, by automatically compiling your system into C++ code,; the second option (string based) tends to be m",MatchSource.DOCS,doc/guide/dynamics/dynamics-time.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst:16648,Integrability,integrat,integration,16648,"mes). c_ops = [QobjEvo([destroy(N), coeff], tlist=times)]; tlist = np.linspace(0, 1, 11); data = mesolve(qeye(N), basis(N, N-1), tlist, c_ops=c_ops, e_ops=[num(N)]).expect[0]; plt.plot(tlist, data). Different coefficient types can be mixed in a :obj:`.QobjEvo`. Given the multiple choices of input style, the first question that arises is which option to choose?; In short, the function based method (first option) is the most general,; allowing for essentially arbitrary coefficients expressed via user defined functions.; However, by automatically compiling your system into C++ code,; the second option (string based) tends to be more efficient and run faster.; Of course, for small system sizes and evolution times, the difference will be minor.; Lastly the spline method is usually as fast the string method, but it cannot be modified once created. .. _time_max_step:. Working with pulses; ===================. Special care is needed when working with pulses. ODE solvers select the step; length automatically and can miss thin pulses when not properly warned.; Integrations methods with variable step sizes have the ``max_step`` option that; control the maximum length of a single internal integration step. This value; should be set to under half the pulse width to be certain they are not missed. For example, the following pulse is missed without fixing the maximum step length. .. plot::; :context: close-figs. def pulse(t):; return 10 * np.pi * (0.7 < t < 0.75). tlist = np.linspace(0, 1, 201); H = [sigmaz(), [sigmax(), pulse]]; psi0 = basis(2,1). data1 = sesolve(H, psi0, tlist, e_ops=num(2)).expect[0]; data2 = sesolve(H, psi0, tlist, e_ops=num(2), options={""max_step"": 0.01}).expect[0]. plt.plot(tlist, data1, label=""no max_step""); plt.plot(tlist, data2, label=""fixed max_step""); plt.fill_between(tlist, [pulse(t) for t in tlist], color=""g"", alpha=0.2, label=""pulse""); plt.ylim([-0.1, 1.1]); plt.legend(loc=""center left""). .. plot::; :context: reset; :include-source: false; :nofigs:; ",MatchSource.DOCS,doc/guide/dynamics/dynamics-time.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst:479,Modifiability,coupling,coupling,479,".. _time:. *************************************************; Solving Problems with Time-dependent Hamiltonians; *************************************************. Time-Dependent Operators; ========================. In the previous examples of quantum evolution,; we assumed that the systems under consideration were described by time-independent Hamiltonians.; However, many systems have explicit time dependence in either the Hamiltonian,; or the collapse operators describing coupling to the environment, and sometimes; both components might depend on time. The time-evolutions solvers such as :func:`.sesolve`,; :func:`.brmesolve`, etc. are all capable of handling time-dependent Hamiltonians and collapse terms.; QuTiP use :obj:`.QobjEvo` to represent time-dependent quantum operators.; There are three different ways to build a :obj:`.QobjEvo`:. 1. **Function based**: Build the time dependent operator from a function returning a :obj:`.Qobj`:. .. code-block:: python. def oper(t):; return num(N) + (destroy(N) + create(N)) * np.sin(t). H_t = QobjEvo(oper). 1. **List based**: The time dependent quantum operator is represented as a list of ``qobj`` and ``[qobj, coefficient]`` pairs:. .. code-block:: python. H_t = QobjEvo([num(N), [create(N), lambda t: np.sin(t)], [destroy(N), lambda t: np.sin(t)]]). 3. **coefficent based**: The product of a :obj:`.Qobj` with a :obj:`.Coefficient`,; created by the :func:`.coefficient` function, result in a :obj:`.QobjEvo`:. .. code-block:: python. coeff = coefficent(lambda t: np.sin(t)); H_t = num(N) + (destroy(N) + create(N)) * coeff. These 3 examples will create the same time dependent operator, however the function; based method will usually be slower when used in solver. Most solvers accept a :obj:`.QobjEvo` when an operator is expected: this include; the Hamiltonian ``H``, collapse operators, expectation values operators, the operator; of :func:`.brmesolve`'s ``a_ops``, etc. Exception are :func:`.krylovsolve`'s; Hamiltonian and HEOM's Bath",MatchSource.DOCS,doc/guide/dynamics/dynamics-time.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst:4092,Modifiability,coupling,coupling,4092," \right)^{2}\right]`.; The following code sets up the problem. .. plot::; :context: reset. ustate = basis(3, 0); excited = basis(3, 1); ground = basis(3, 2). N = 2 # Set where to truncate Fock state for cavity; sigma_ge = tensor(qeye(N), ground * excited.dag()) # |g><e|; sigma_ue = tensor(qeye(N), ustate * excited.dag()) # |u><e|; a = tensor(destroy(N), qeye(3)); ada = tensor(num(N), qeye(3)). c_ops = [] # Build collapse operators; kappa = 1.5 # Cavity decay rate; c_ops.append(np.sqrt(kappa) * a); gamma = 6 # Atomic decay rate; c_ops.append(np.sqrt(5*gamma/9) * sigma_ue) # Use Rb branching ratio of 5/9 e->u; c_ops.append(np.sqrt(4*gamma/9) * sigma_ge) # 4/9 e->g. t = np.linspace(-15, 15, 100) # Define time vector; psi0 = tensor(basis(N, 0), ustate) # Define initial state. state_GG = tensor(basis(N, 1), ground) # Define states onto which to project; sigma_GG = state_GG * state_GG.dag(); state_UU = tensor(basis(N, 0), ustate); sigma_UU = state_UU * state_UU.dag(). g = 5 # coupling strength; H0 = -g * (sigma_ge.dag() * a + a.dag() * sigma_ge) # time-independent term; H1 = (sigma_ue.dag() + sigma_ue) # time-dependent term. Given that we have a single time-dependent Hamiltonian term, and constant collapse terms,; we need to specify a single Python function for the coefficient :math:`f(t)`.; In this case, one can simply do. .. plot::; :context: close-figs; :nofigs:. def H1_coeff(t):; return 9 * np.exp(-(t / 5.) ** 2). In this case, the return value depends only on time. However it is possible to; add optional arguments to the call, see `Using arguments`_.; Having specified our coefficient function, we can now specify the Hamiltonian in; list format and call the solver (in this case :func:`.mesolve`). .. plot::; :context: close-figs. H = [H0, [H1, H1_coeff]]; output = mesolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). We can call the Monte Carlo solver in the exact same way (if using the default ``ntraj=500``):. ..; Hacky fix because plot has complicated conditional co",MatchSource.DOCS,doc/guide/dynamics/dynamics-time.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst:8664,Modifiability,variab,variable,8664,"n:. .. code-block:: python. H = tensor(H_t, qeye(2)); c_op = tensor(QobjEvo([destroy(N), lambda t: np.exp(-t)]), sigmax()). L = -1j * (spre(H) - spost(H.dag())); L += spre(c_op) * spost(c_op.dag()) - 0.5 * spre(c_op.dag() * c_op) - 0.5 * spost(c_op.dag() * c_op). Or equivalently:. .. code-block:: python. L = liouvillian(H, [c_op]). Using arguments; ---------------. Until now, the coefficients were only functions of time. In the definition of ``H1_coeff``,; the driving amplitude ``A`` and width ``sigma`` were hardcoded with their numerical values.; This is fine for problems that are specialized, or that we only want to run once.; However, in many cases, we would like study the same problem with a range of parameters and; not have to worry about manually changing the values on each run.; QuTiP allows you to accomplish this using by adding extra arguments to coefficients; function that make the :obj:`.QobjEvo`. For instance, instead of explicitly writing; 9 for the amplitude and 5 for the width of the gaussian driving term, we can add an; `args` positional variable:. .. code-block:: python. >>> def H1_coeff(t, args):; >>> return args['A'] * np.exp(-(t/args['sigma'])**2). or, new from v5, add the extra parameter directly:. .. code-block:: python. >>> def H1_coeff(t, A, sigma):; >>> return A * np.exp(-(t / sigma)**2). When the second positional input of the coefficient function is named ``args``,; the arguments are passed as a Python dictionary of ``key: value`` pairs.; Otherwise the coefficient function is called as ``coeff(t, **args)``.; In the last example, ``args = {'A': a, 'sigma': b}`` where ``a`` and ``b`` are the; two parameters for the amplitude and width, respectively.; This ``args`` dictionary need to be given at creation of the :obj:`.QobjEvo` when; function using then are included:. .. code-block:: python. >>> system = [sigmaz(), [sigmax(), H1_coeff]]; >>> args={'A': 9, 'sigma': 5}; >>> qevo = QobjEvo(system, args=args). But without ``args``, the :obj:`.QobjE",MatchSource.DOCS,doc/guide/dynamics/dynamics-time.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst:12761,Modifiability,variab,variable,12761,"; Qobj data =; [[0. 1.]; [2. 0.]]; >>> print(summed_evo(0, a=3, b=1)); Quantum object: dims=[[2], [2]], shape=(2, 2), type='oper', isherm=True; Qobj data =; [[0. 3.]; [3. 0.]]. Coefficients; ============. To build time dependent quantum system we often use a list of :obj:`.Qobj` and; :obj:`.Coefficient`. These :obj:`.Coefficient` represent the strength of the corresponding; quantum object a function that of time. Up to now, we used functions for these,; but QuTiP support multiple formats: ``callable``, ``strings``, ``array``. **Function coefficients** :; Use a callable with the signature ``f(t: double, ...) -> double`` as coefficient.; Any function or method that can be called by ``f(t, args)``, ``f(t, **args)`` is accepted. .. code-block:: python. def coeff(t, A, sigma):; return A * np.exp(-(t / sigma)**2). H = QobjEvo([H0, [H1, coeff]], args=args). **String coefficients** :; Use a string containing a simple Python expression.; The variable ``t``, common mathematical functions such as ``sin`` or ``exp`` an; variable in args will be available. If available, the string will be compiled using; cython, fixing variable type when possible, allowing slightly faster execution than function.; While the speed up is usually very small, in long evolution, numerous calls to the; functions are made and it's can accumulate. From version 5, compilation of the; coefficient is done only once and saved between sessions. When either the cython or; filelock modules are not available, the code will be executed in python using; ``exec`` with the same environment . This, however, as no advantage over using; python function. .. code-block:: python. coeff = ""A * exp(-(t / sigma)**2)"". H = QobjEvo([H0, [H1, coeff]], args=args). Here is a list of defined variables:; ``sin``, ``cos``, ``tan``, ``asin``, ``acos``, ``atan``, ``pi``,; ``sinh``, ``cosh``, ``tanh``, ``asinh``, ``acosh``, ``atanh``,; ``exp``, ``log``, ``log10``, ``erf``, ``zerf``, ``sqrt``,; ``real``, ``imag``, ``conj``, ``abs``, ``",MatchSource.DOCS,doc/guide/dynamics/dynamics-time.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst:12838,Modifiability,variab,variable,12838,"; Qobj data =; [[0. 1.]; [2. 0.]]; >>> print(summed_evo(0, a=3, b=1)); Quantum object: dims=[[2], [2]], shape=(2, 2), type='oper', isherm=True; Qobj data =; [[0. 3.]; [3. 0.]]. Coefficients; ============. To build time dependent quantum system we often use a list of :obj:`.Qobj` and; :obj:`.Coefficient`. These :obj:`.Coefficient` represent the strength of the corresponding; quantum object a function that of time. Up to now, we used functions for these,; but QuTiP support multiple formats: ``callable``, ``strings``, ``array``. **Function coefficients** :; Use a callable with the signature ``f(t: double, ...) -> double`` as coefficient.; Any function or method that can be called by ``f(t, args)``, ``f(t, **args)`` is accepted. .. code-block:: python. def coeff(t, A, sigma):; return A * np.exp(-(t / sigma)**2). H = QobjEvo([H0, [H1, coeff]], args=args). **String coefficients** :; Use a string containing a simple Python expression.; The variable ``t``, common mathematical functions such as ``sin`` or ``exp`` an; variable in args will be available. If available, the string will be compiled using; cython, fixing variable type when possible, allowing slightly faster execution than function.; While the speed up is usually very small, in long evolution, numerous calls to the; functions are made and it's can accumulate. From version 5, compilation of the; coefficient is done only once and saved between sessions. When either the cython or; filelock modules are not available, the code will be executed in python using; ``exec`` with the same environment . This, however, as no advantage over using; python function. .. code-block:: python. coeff = ""A * exp(-(t / sigma)**2)"". H = QobjEvo([H0, [H1, coeff]], args=args). Here is a list of defined variables:; ``sin``, ``cos``, ``tan``, ``asin``, ``acos``, ``atan``, ``pi``,; ``sinh``, ``cosh``, ``tanh``, ``asinh``, ``acosh``, ``atanh``,; ``exp``, ``log``, ``log10``, ``erf``, ``zerf``, ``sqrt``,; ``real``, ``imag``, ``conj``, ``abs``, ``",MatchSource.DOCS,doc/guide/dynamics/dynamics-time.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst:12938,Modifiability,variab,variable,12938," isherm=True; Qobj data =; [[0. 3.]; [3. 0.]]. Coefficients; ============. To build time dependent quantum system we often use a list of :obj:`.Qobj` and; :obj:`.Coefficient`. These :obj:`.Coefficient` represent the strength of the corresponding; quantum object a function that of time. Up to now, we used functions for these,; but QuTiP support multiple formats: ``callable``, ``strings``, ``array``. **Function coefficients** :; Use a callable with the signature ``f(t: double, ...) -> double`` as coefficient.; Any function or method that can be called by ``f(t, args)``, ``f(t, **args)`` is accepted. .. code-block:: python. def coeff(t, A, sigma):; return A * np.exp(-(t / sigma)**2). H = QobjEvo([H0, [H1, coeff]], args=args). **String coefficients** :; Use a string containing a simple Python expression.; The variable ``t``, common mathematical functions such as ``sin`` or ``exp`` an; variable in args will be available. If available, the string will be compiled using; cython, fixing variable type when possible, allowing slightly faster execution than function.; While the speed up is usually very small, in long evolution, numerous calls to the; functions are made and it's can accumulate. From version 5, compilation of the; coefficient is done only once and saved between sessions. When either the cython or; filelock modules are not available, the code will be executed in python using; ``exec`` with the same environment . This, however, as no advantage over using; python function. .. code-block:: python. coeff = ""A * exp(-(t / sigma)**2)"". H = QobjEvo([H0, [H1, coeff]], args=args). Here is a list of defined variables:; ``sin``, ``cos``, ``tan``, ``asin``, ``acos``, ``atan``, ``pi``,; ``sinh``, ``cosh``, ``tanh``, ``asinh``, ``acosh``, ``atanh``,; ``exp``, ``log``, ``log10``, ``erf``, ``zerf``, ``sqrt``,; ``real``, ``imag``, ``conj``, ``abs``, ``norm``, ``arg``, ``proj``,; ``np`` (numpy), ``spe`` (scipy.special) and ``cython_special``; (scipy cython interface). **Array coeff",MatchSource.DOCS,doc/guide/dynamics/dynamics-time.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst:13572,Modifiability,variab,variables,13572," string containing a simple Python expression.; The variable ``t``, common mathematical functions such as ``sin`` or ``exp`` an; variable in args will be available. If available, the string will be compiled using; cython, fixing variable type when possible, allowing slightly faster execution than function.; While the speed up is usually very small, in long evolution, numerous calls to the; functions are made and it's can accumulate. From version 5, compilation of the; coefficient is done only once and saved between sessions. When either the cython or; filelock modules are not available, the code will be executed in python using; ``exec`` with the same environment . This, however, as no advantage over using; python function. .. code-block:: python. coeff = ""A * exp(-(t / sigma)**2)"". H = QobjEvo([H0, [H1, coeff]], args=args). Here is a list of defined variables:; ``sin``, ``cos``, ``tan``, ``asin``, ``acos``, ``atan``, ``pi``,; ``sinh``, ``cosh``, ``tanh``, ``asinh``, ``acosh``, ``atanh``,; ``exp``, ``log``, ``log10``, ``erf``, ``zerf``, ``sqrt``,; ``real``, ``imag``, ``conj``, ``abs``, ``norm``, ``arg``, ``proj``,; ``np`` (numpy), ``spe`` (scipy.special) and ``cython_special``; (scipy cython interface). **Array coefficients** :; Use the spline interpolation of an array.; Useful when the coefficient is hard to define as a function or obtained from experimental data.; The times at which the array are defined must be passed as ``tlist``:. .. code-block:: python. times = np.linspace(-sigma*5, sigma*5, 500); coeff = A * exp(-(times / sigma)**2). H = QobjEvo([H0, [H1, coeff]], tlist=times). Per default, a cubic spline interpolation is used, but the order of the interpolation can be controlled with the order input:; Outside the interpolation range, the first or last value are used. .. plot::; :context: close-figs. times = np.array([0, 0.1, 0.3, 0.6, 1.0]); coeff = times * (1.1 - times); tlist = np.linspace(-0.1, 1.1, 25). H = QobjEvo([qeye(1), coeff], tlist=times); plt.plo",MatchSource.DOCS,doc/guide/dynamics/dynamics-time.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst:15321,Modifiability,extend,extended,15321,"t=times). Per default, a cubic spline interpolation is used, but the order of the interpolation can be controlled with the order input:; Outside the interpolation range, the first or last value are used. .. plot::; :context: close-figs. times = np.array([0, 0.1, 0.3, 0.6, 1.0]); coeff = times * (1.1 - times); tlist = np.linspace(-0.1, 1.1, 25). H = QobjEvo([qeye(1), coeff], tlist=times); plt.plot(tlist, [H(t).norm() for t in tlist], label=""CubicSpline""). H = QobjEvo([qeye(1), coeff], tlist=times, order=0); plt.plot(tlist, [H(t).norm() for t in tlist], label=""step""). H = QobjEvo([qeye(1), coeff], tlist=times, order=1); plt.plot(tlist, [H(t).norm() for t in tlist], label=""linear""). plt.legend(). When using array coefficients in solver, if the time dependent quantum system is; in list format, the solver tlist is used as times of the array.; This is often not ideal as the interpolation is usually less precise close the extremities of the range.; It is therefore better to create the QobjEvo using an extended range prior to the solver:. .. plot::; :context: close-figs. N = 5; times = np.linspace(-0.1, 1.1, 13); coeff = np.exp(-times). c_ops = [QobjEvo([destroy(N), coeff], tlist=times)]; tlist = np.linspace(0, 1, 11); data = mesolve(qeye(N), basis(N, N-1), tlist, c_ops=c_ops, e_ops=[num(N)]).expect[0]; plt.plot(tlist, data). Different coefficient types can be mixed in a :obj:`.QobjEvo`. Given the multiple choices of input style, the first question that arises is which option to choose?; In short, the function based method (first option) is the most general,; allowing for essentially arbitrary coefficients expressed via user defined functions.; However, by automatically compiling your system into C++ code,; the second option (string based) tends to be more efficient and run faster.; Of course, for small system sizes and evolution times, the difference will be minor.; Lastly the spline method is usually as fast the string method, but it cannot be modified once created. .. _t",MatchSource.DOCS,doc/guide/dynamics/dynamics-time.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst:16545,Modifiability,variab,variable,16545,"mes). c_ops = [QobjEvo([destroy(N), coeff], tlist=times)]; tlist = np.linspace(0, 1, 11); data = mesolve(qeye(N), basis(N, N-1), tlist, c_ops=c_ops, e_ops=[num(N)]).expect[0]; plt.plot(tlist, data). Different coefficient types can be mixed in a :obj:`.QobjEvo`. Given the multiple choices of input style, the first question that arises is which option to choose?; In short, the function based method (first option) is the most general,; allowing for essentially arbitrary coefficients expressed via user defined functions.; However, by automatically compiling your system into C++ code,; the second option (string based) tends to be more efficient and run faster.; Of course, for small system sizes and evolution times, the difference will be minor.; Lastly the spline method is usually as fast the string method, but it cannot be modified once created. .. _time_max_step:. Working with pulses; ===================. Special care is needed when working with pulses. ODE solvers select the step; length automatically and can miss thin pulses when not properly warned.; Integrations methods with variable step sizes have the ``max_step`` option that; control the maximum length of a single internal integration step. This value; should be set to under half the pulse width to be certain they are not missed. For example, the following pulse is missed without fixing the maximum step length. .. plot::; :context: close-figs. def pulse(t):; return 10 * np.pi * (0.7 < t < 0.75). tlist = np.linspace(0, 1, 201); H = [sigmaz(), [sigmax(), pulse]]; psi0 = basis(2,1). data1 = sesolve(H, psi0, tlist, e_ops=num(2)).expect[0]; data2 = sesolve(H, psi0, tlist, e_ops=num(2), options={""max_step"": 0.01}).expect[0]. plt.plot(tlist, data1, label=""no max_step""); plt.plot(tlist, data2, label=""fixed max_step""); plt.fill_between(tlist, [pulse(t) for t in tlist], color=""g"", alpha=0.2, label=""pulse""); plt.ylim([-0.1, 1.1]); plt.legend(loc=""center left""). .. plot::; :context: reset; :include-source: false; :nofigs:; ",MatchSource.DOCS,doc/guide/dynamics/dynamics-time.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst:13725,Testability,log,log,13725," string containing a simple Python expression.; The variable ``t``, common mathematical functions such as ``sin`` or ``exp`` an; variable in args will be available. If available, the string will be compiled using; cython, fixing variable type when possible, allowing slightly faster execution than function.; While the speed up is usually very small, in long evolution, numerous calls to the; functions are made and it's can accumulate. From version 5, compilation of the; coefficient is done only once and saved between sessions. When either the cython or; filelock modules are not available, the code will be executed in python using; ``exec`` with the same environment . This, however, as no advantage over using; python function. .. code-block:: python. coeff = ""A * exp(-(t / sigma)**2)"". H = QobjEvo([H0, [H1, coeff]], args=args). Here is a list of defined variables:; ``sin``, ``cos``, ``tan``, ``asin``, ``acos``, ``atan``, ``pi``,; ``sinh``, ``cosh``, ``tanh``, ``asinh``, ``acosh``, ``atanh``,; ``exp``, ``log``, ``log10``, ``erf``, ``zerf``, ``sqrt``,; ``real``, ``imag``, ``conj``, ``abs``, ``norm``, ``arg``, ``proj``,; ``np`` (numpy), ``spe`` (scipy.special) and ``cython_special``; (scipy cython interface). **Array coefficients** :; Use the spline interpolation of an array.; Useful when the coefficient is hard to define as a function or obtained from experimental data.; The times at which the array are defined must be passed as ``tlist``:. .. code-block:: python. times = np.linspace(-sigma*5, sigma*5, 500); coeff = A * exp(-(times / sigma)**2). H = QobjEvo([H0, [H1, coeff]], tlist=times). Per default, a cubic spline interpolation is used, but the order of the interpolation can be controlled with the order input:; Outside the interpolation range, the first or last value are used. .. plot::; :context: close-figs. times = np.array([0, 0.1, 0.3, 0.6, 1.0]); coeff = times * (1.1 - times); tlist = np.linspace(-0.1, 1.1, 25). H = QobjEvo([qeye(1), coeff], tlist=times); plt.plo",MatchSource.DOCS,doc/guide/dynamics/dynamics-time.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst:4436,Usability,simpl,simply,4436," # |u><e|; a = tensor(destroy(N), qeye(3)); ada = tensor(num(N), qeye(3)). c_ops = [] # Build collapse operators; kappa = 1.5 # Cavity decay rate; c_ops.append(np.sqrt(kappa) * a); gamma = 6 # Atomic decay rate; c_ops.append(np.sqrt(5*gamma/9) * sigma_ue) # Use Rb branching ratio of 5/9 e->u; c_ops.append(np.sqrt(4*gamma/9) * sigma_ge) # 4/9 e->g. t = np.linspace(-15, 15, 100) # Define time vector; psi0 = tensor(basis(N, 0), ustate) # Define initial state. state_GG = tensor(basis(N, 1), ground) # Define states onto which to project; sigma_GG = state_GG * state_GG.dag(); state_UU = tensor(basis(N, 0), ustate); sigma_UU = state_UU * state_UU.dag(). g = 5 # coupling strength; H0 = -g * (sigma_ge.dag() * a + a.dag() * sigma_ge) # time-independent term; H1 = (sigma_ue.dag() + sigma_ue) # time-dependent term. Given that we have a single time-dependent Hamiltonian term, and constant collapse terms,; we need to specify a single Python function for the coefficient :math:`f(t)`.; In this case, one can simply do. .. plot::; :context: close-figs; :nofigs:. def H1_coeff(t):; return 9 * np.exp(-(t / 5.) ** 2). In this case, the return value depends only on time. However it is possible to; add optional arguments to the call, see `Using arguments`_.; Having specified our coefficient function, we can now specify the Hamiltonian in; list format and call the solver (in this case :func:`.mesolve`). .. plot::; :context: close-figs. H = [H0, [H1, H1_coeff]]; output = mesolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). We can call the Monte Carlo solver in the exact same way (if using the default ``ntraj=500``):. ..; Hacky fix because plot has complicated conditional code execution. .. doctest::; :skipif: True. output = mcsolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). The output from the master equation solver is identical to that shown in the examples,; the Monte Carlo however will be noticeably off, suggesting we should increase the number; of trajectories for this example. In ",MatchSource.DOCS,doc/guide/dynamics/dynamics-time.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst:5476,Usability,simpl,simple,5476,"; :nofigs:. def H1_coeff(t):; return 9 * np.exp(-(t / 5.) ** 2). In this case, the return value depends only on time. However it is possible to; add optional arguments to the call, see `Using arguments`_.; Having specified our coefficient function, we can now specify the Hamiltonian in; list format and call the solver (in this case :func:`.mesolve`). .. plot::; :context: close-figs. H = [H0, [H1, H1_coeff]]; output = mesolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). We can call the Monte Carlo solver in the exact same way (if using the default ``ntraj=500``):. ..; Hacky fix because plot has complicated conditional code execution. .. doctest::; :skipif: True. output = mcsolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). The output from the master equation solver is identical to that shown in the examples,; the Monte Carlo however will be noticeably off, suggesting we should increase the number; of trajectories for this example. In addition, we can also consider the decay of a; simple Harmonic oscillator with time-varying decay rate. .. plot::; :context: close-figs. kappa = 0.5. def col_coeff(t, args): # coefficient function; return np.sqrt(kappa * np.exp(-t)). N = 10 # number of basis states; a = destroy(N); H = a.dag() * a # simple HO; psi0 = basis(N, 9) # initial state; c_ops = [QobjEvo([a, col_coeff])] # time-dependent collapse term; times = np.linspace(0, 10, 100); output = mesolve(H, psi0, times, c_ops, [a.dag() * a]). Qobjevo; =======. :obj:`.QobjEvo` as a time dependent quantum system, as it's main functionality; create a :obj:`.Qobj` at a time:. .. doctest:: [basics]; :options: +NORMALIZE_WHITESPACE. >>> print(H_t(np.pi / 2)); Quantum object: dims=[[2], [2]], shape=(2, 2), type='oper', isherm=True; Qobj data =; [[0. 1.]; [1. 1.]]. :obj:`.QobjEvo` shares a lot of properties with the :obj:`.Qobj`. +----------------+------------------+----------------------------------------+; | Property | Attribute | Description |; +================+==================+===",MatchSource.DOCS,doc/guide/dynamics/dynamics-time.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst:5730,Usability,simpl,simple,5730," the solver (in this case :func:`.mesolve`). .. plot::; :context: close-figs. H = [H0, [H1, H1_coeff]]; output = mesolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). We can call the Monte Carlo solver in the exact same way (if using the default ``ntraj=500``):. ..; Hacky fix because plot has complicated conditional code execution. .. doctest::; :skipif: True. output = mcsolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). The output from the master equation solver is identical to that shown in the examples,; the Monte Carlo however will be noticeably off, suggesting we should increase the number; of trajectories for this example. In addition, we can also consider the decay of a; simple Harmonic oscillator with time-varying decay rate. .. plot::; :context: close-figs. kappa = 0.5. def col_coeff(t, args): # coefficient function; return np.sqrt(kappa * np.exp(-t)). N = 10 # number of basis states; a = destroy(N); H = a.dag() * a # simple HO; psi0 = basis(N, 9) # initial state; c_ops = [QobjEvo([a, col_coeff])] # time-dependent collapse term; times = np.linspace(0, 10, 100); output = mesolve(H, psi0, times, c_ops, [a.dag() * a]). Qobjevo; =======. :obj:`.QobjEvo` as a time dependent quantum system, as it's main functionality; create a :obj:`.Qobj` at a time:. .. doctest:: [basics]; :options: +NORMALIZE_WHITESPACE. >>> print(H_t(np.pi / 2)); Quantum object: dims=[[2], [2]], shape=(2, 2), type='oper', isherm=True; Qobj data =; [[0. 1.]; [1. 1.]]. :obj:`.QobjEvo` shares a lot of properties with the :obj:`.Qobj`. +----------------+------------------+----------------------------------------+; | Property | Attribute | Description |; +================+==================+========================================+; | Dimensions | ``Q.dims`` | Shapes the tensor structure. |; +----------------+------------------+----------------------------------------+; | Shape | ``Q.shape`` | Dimensions of underlying data matrix. |; +----------------+------------------+-------------------------",MatchSource.DOCS,doc/guide/dynamics/dynamics-time.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst:12730,Usability,simpl,simple,12730," >>> print(summed_evo(0)); Quantum object: dims=[[2], [2]], shape=(2, 2), type='oper', isherm=False; Qobj data =; [[0. 1.]; [2. 0.]]; >>> print(summed_evo(0, a=3, b=1)); Quantum object: dims=[[2], [2]], shape=(2, 2), type='oper', isherm=True; Qobj data =; [[0. 3.]; [3. 0.]]. Coefficients; ============. To build time dependent quantum system we often use a list of :obj:`.Qobj` and; :obj:`.Coefficient`. These :obj:`.Coefficient` represent the strength of the corresponding; quantum object a function that of time. Up to now, we used functions for these,; but QuTiP support multiple formats: ``callable``, ``strings``, ``array``. **Function coefficients** :; Use a callable with the signature ``f(t: double, ...) -> double`` as coefficient.; Any function or method that can be called by ``f(t, args)``, ``f(t, **args)`` is accepted. .. code-block:: python. def coeff(t, A, sigma):; return A * np.exp(-(t / sigma)**2). H = QobjEvo([H0, [H1, coeff]], args=args). **String coefficients** :; Use a string containing a simple Python expression.; The variable ``t``, common mathematical functions such as ``sin`` or ``exp`` an; variable in args will be available. If available, the string will be compiled using; cython, fixing variable type when possible, allowing slightly faster execution than function.; While the speed up is usually very small, in long evolution, numerous calls to the; functions are made and it's can accumulate. From version 5, compilation of the; coefficient is done only once and saved between sessions. When either the cython or; filelock modules are not available, the code will be executed in python using; ``exec`` with the same environment . This, however, as no advantage over using; python function. .. code-block:: python. coeff = ""A * exp(-(t / sigma)**2)"". H = QobjEvo([H0, [H1, coeff]], args=args). Here is a list of defined variables:; ``sin``, ``cos``, ``tan``, ``asin``, ``acos``, ``atan``, ``pi``,; ``sinh``, ``cosh``, ``tanh``, ``asinh``, ``acosh``, ``atanh``,; ``",MatchSource.DOCS,doc/guide/dynamics/dynamics-time.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/heom/bosonic.rst:4942,Availability,avail,available,4942,"ch the state was evaluated (i.e. ``tlist``); - ``states``: the system states at each time; - ``expect``: a list with the values of each ``e_ops`` at each time; - ``e_data``: a dictionary with the values of each ``e_op`` at each time; - ``ado_states``: see below (an instance of; :class:`~qutip.solver.heom.HierarchyADOsState`). If ``ado_return=True`` is passed to ``.run(...)`` the full set of auxilliary; density operators (ADOs) that make up the hierarchy at each time will be; returned as ``.ado_states``. We will describe how to use these to determine; other properties, such as system-bath currents, later in the fermionic guide; (see :ref:`heom-determining-currents`). If one has a full set of ADOs from a previous call of ``.run(...)`` you may; supply it as the initial state of the solver by calling; ``.run(result.ado_states[-1], tlist, ado_init=True)``. As with other QuTiP solvers, if expectation operators or functions are supplied; using ``.run(..., e_ops=[...])`` the expectation values are available in; ``result.expect`` and ``result.e_data``. Below we run the solver again, but use ``e_ops`` to store the expectation; values of the population of the system states and the coherence:. .. plot::; :context:. # Define the operators that measure the populations of the two; # system states:; P11p = basis(2,0) * basis(2,0).dag(); P22p = basis(2,1) * basis(2,1).dag(). # Define the operator that measures the 0, 1 element of density matrix; # (corresonding to coherence):; P12p = basis(2,0) * basis(2,1).dag(). # Run the solver:; tlist = np.linspace(0, 20, 101); result = solver.run(rho0, tlist, e_ops={""11"": P11p, ""22"": P22p, ""12"": P12p}). # Plot the results:; fig, axes = plt.subplots(1, 1, sharex=True, figsize=(8,8)); axes.plot(result.times, result.e_data[""11""], 'b', linewidth=2, label=""P11""); axes.plot(result.times, result.e_data[""12""], 'r', linewidth=2, label=""P12""); axes.set_xlabel(r't', fontsize=28); axes.legend(loc=0, fontsize=12). Steady-state; ------------. Using the same s",MatchSource.DOCS,doc/guide/heom/bosonic.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/heom/bosonic.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/heom/bosonic.rst:1845,Energy Efficiency,energy,energy,1845,"th with a; truncated expansion and show how to include an approximation to all of the; remaining terms in the bath expansion. Afterwards, we will show how to calculate the bath expansion coefficients and to; use those coefficients to construct your own bath description so that you can; implement your own bosonic baths. Finally, we will demonstrate how to simulate a system coupled to multiple; independent baths, as occurs, for example, in certain photosynthesis processes. A notebook containing a complete example similar to this one implemented in; BoFiN can be found in; `example notebook 1a <https://github.com/tehruhn/bofin/blob/main/examples/example-1a-Spin-bath-model-basic.ipynb>`__. Describing the system and bath; ------------------------------. First, let us construct the system Hamiltonian, :math:`H_{sys}`, and the initial; system state, ``rho0``:. .. plot::; :context: reset; :nofigs:. from qutip import basis, sigmax, sigmaz. # The system Hamiltonian:; eps = 0.5 # energy of the 2-level system; Del = 1.0 # tunnelling term; H_sys = 0.5 * eps * sigmaz() + 0.5 * Del * sigmax(). # Initial state of the system:; rho0 = basis(2,0) * basis(2,0).dag(). Now let us describe the bath properties:. .. plot::; :context:; :nofigs:. # Bath properties:; gamma = 0.5 # cut off frequency; lam = 0.1 # coupling strength; T = 0.5 # temperature. # System-bath coupling operator:; Q = sigmaz(). where :math:`\gamma` (``gamma``), :math:`\lambda` (``lam``) and :math:`T` are; the parameters of a Drude-Lorentz bath, and ``Q`` is the coupling operator; between the system and the bath. We may the pass these parameters to either; :class:`~qutip.solver.heom.DrudeLorentzBath` or; :class:`~qutip.solver.heom.DrudeLorentzPadeBath` to construct an expansion of; the bath correlations:. .. plot::; :context:; :nofigs:. from qutip.solver.heom import DrudeLorentzBath; from qutip.solver.heom import DrudeLorentzPadeBath. # Number of expansion terms to retain:; Nk = 2. # Matsubara expansion:; bath = DrudeLorent",MatchSource.DOCS,doc/guide/heom/bosonic.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/heom/bosonic.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/heom/bosonic.rst:570,Modifiability,evolve,evolve,570,"####################; Bosonic Environments; ####################. In this section we consider a simple two-level system coupled to a; Drude-Lorentz bosonic bath. The system Hamiltonian, :math:`H_{sys}`, and the bath; spectral density, :math:`J_D`, are. .. math::. H_{sys} &= \frac{\epsilon \sigma_z}{2} + \frac{\Delta \sigma_x}{2}. J_D &= \frac{2\lambda \gamma \omega}{(\gamma^2 + \omega^2)},. We will demonstrate how to describe the bath using two different expansions; of the spectral density correlation function (Matsubara's expansion and; a Pad expansion), how to evolve the system in time, and how to calculate; the steady state. First we will do this in the simplest way, using the built-in implementations of; the two bath expansions, :class:`~qutip.solver.heom.DrudeLorentzBath` and; :class:`~qutip.solver.heom.DrudeLorentzPadeBath`. We will do this both with a; truncated expansion and show how to include an approximation to all of the; remaining terms in the bath expansion. Afterwards, we will show how to calculate the bath expansion coefficients and to; use those coefficients to construct your own bath description so that you can; implement your own bosonic baths. Finally, we will demonstrate how to simulate a system coupled to multiple; independent baths, as occurs, for example, in certain photosynthesis processes. A notebook containing a complete example similar to this one implemented in; BoFiN can be found in; `example notebook 1a <https://github.com/tehruhn/bofin/blob/main/examples/example-1a-Spin-bath-model-basic.ipynb>`__. Describing the system and bath; ------------------------------. First, let us construct the system Hamiltonian, :math:`H_{sys}`, and the initial; system state, ``rho0``:. .. plot::; :context: reset; :nofigs:. from qutip import basis, sigmax, sigmaz. # The system Hamiltonian:; eps = 0.5 # energy of the 2-level system; Del = 1.0 # tunnelling term; H_sys = 0.5 * eps * sigmaz() + 0.5 * Del * sigmax(). # Initial state of the system:; rho0 = basis",MatchSource.DOCS,doc/guide/heom/bosonic.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/heom/bosonic.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/heom/bosonic.rst:2166,Modifiability,coupling,coupling,2166,"baths. Finally, we will demonstrate how to simulate a system coupled to multiple; independent baths, as occurs, for example, in certain photosynthesis processes. A notebook containing a complete example similar to this one implemented in; BoFiN can be found in; `example notebook 1a <https://github.com/tehruhn/bofin/blob/main/examples/example-1a-Spin-bath-model-basic.ipynb>`__. Describing the system and bath; ------------------------------. First, let us construct the system Hamiltonian, :math:`H_{sys}`, and the initial; system state, ``rho0``:. .. plot::; :context: reset; :nofigs:. from qutip import basis, sigmax, sigmaz. # The system Hamiltonian:; eps = 0.5 # energy of the 2-level system; Del = 1.0 # tunnelling term; H_sys = 0.5 * eps * sigmaz() + 0.5 * Del * sigmax(). # Initial state of the system:; rho0 = basis(2,0) * basis(2,0).dag(). Now let us describe the bath properties:. .. plot::; :context:; :nofigs:. # Bath properties:; gamma = 0.5 # cut off frequency; lam = 0.1 # coupling strength; T = 0.5 # temperature. # System-bath coupling operator:; Q = sigmaz(). where :math:`\gamma` (``gamma``), :math:`\lambda` (``lam``) and :math:`T` are; the parameters of a Drude-Lorentz bath, and ``Q`` is the coupling operator; between the system and the bath. We may the pass these parameters to either; :class:`~qutip.solver.heom.DrudeLorentzBath` or; :class:`~qutip.solver.heom.DrudeLorentzPadeBath` to construct an expansion of; the bath correlations:. .. plot::; :context:; :nofigs:. from qutip.solver.heom import DrudeLorentzBath; from qutip.solver.heom import DrudeLorentzPadeBath. # Number of expansion terms to retain:; Nk = 2. # Matsubara expansion:; bath = DrudeLorentzBath(Q, lam, gamma, T, Nk). # Pad expansion:; bath = DrudeLorentzPadeBath(Q, lam, gamma, T, Nk). Where ``Nk`` is the number of terms to retain within the expansion of the; bath. .. _heom-bosonic-system-and-bath-dynamics:. System and bath dynamics; ------------------------. Now we are ready to construct a solver:",MatchSource.DOCS,doc/guide/heom/bosonic.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/heom/bosonic.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/heom/bosonic.rst:2222,Modifiability,coupling,coupling,2222,"ystem coupled to multiple; independent baths, as occurs, for example, in certain photosynthesis processes. A notebook containing a complete example similar to this one implemented in; BoFiN can be found in; `example notebook 1a <https://github.com/tehruhn/bofin/blob/main/examples/example-1a-Spin-bath-model-basic.ipynb>`__. Describing the system and bath; ------------------------------. First, let us construct the system Hamiltonian, :math:`H_{sys}`, and the initial; system state, ``rho0``:. .. plot::; :context: reset; :nofigs:. from qutip import basis, sigmax, sigmaz. # The system Hamiltonian:; eps = 0.5 # energy of the 2-level system; Del = 1.0 # tunnelling term; H_sys = 0.5 * eps * sigmaz() + 0.5 * Del * sigmax(). # Initial state of the system:; rho0 = basis(2,0) * basis(2,0).dag(). Now let us describe the bath properties:. .. plot::; :context:; :nofigs:. # Bath properties:; gamma = 0.5 # cut off frequency; lam = 0.1 # coupling strength; T = 0.5 # temperature. # System-bath coupling operator:; Q = sigmaz(). where :math:`\gamma` (``gamma``), :math:`\lambda` (``lam``) and :math:`T` are; the parameters of a Drude-Lorentz bath, and ``Q`` is the coupling operator; between the system and the bath. We may the pass these parameters to either; :class:`~qutip.solver.heom.DrudeLorentzBath` or; :class:`~qutip.solver.heom.DrudeLorentzPadeBath` to construct an expansion of; the bath correlations:. .. plot::; :context:; :nofigs:. from qutip.solver.heom import DrudeLorentzBath; from qutip.solver.heom import DrudeLorentzPadeBath. # Number of expansion terms to retain:; Nk = 2. # Matsubara expansion:; bath = DrudeLorentzBath(Q, lam, gamma, T, Nk). # Pad expansion:; bath = DrudeLorentzPadeBath(Q, lam, gamma, T, Nk). Where ``Nk`` is the number of terms to retain within the expansion of the; bath. .. _heom-bosonic-system-and-bath-dynamics:. System and bath dynamics; ------------------------. Now we are ready to construct a solver:. .. plot::; :context:; :nofigs:. from qutip.solver.he",MatchSource.DOCS,doc/guide/heom/bosonic.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/heom/bosonic.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/heom/bosonic.rst:2392,Modifiability,coupling,coupling,2392,"containing a complete example similar to this one implemented in; BoFiN can be found in; `example notebook 1a <https://github.com/tehruhn/bofin/blob/main/examples/example-1a-Spin-bath-model-basic.ipynb>`__. Describing the system and bath; ------------------------------. First, let us construct the system Hamiltonian, :math:`H_{sys}`, and the initial; system state, ``rho0``:. .. plot::; :context: reset; :nofigs:. from qutip import basis, sigmax, sigmaz. # The system Hamiltonian:; eps = 0.5 # energy of the 2-level system; Del = 1.0 # tunnelling term; H_sys = 0.5 * eps * sigmaz() + 0.5 * Del * sigmax(). # Initial state of the system:; rho0 = basis(2,0) * basis(2,0).dag(). Now let us describe the bath properties:. .. plot::; :context:; :nofigs:. # Bath properties:; gamma = 0.5 # cut off frequency; lam = 0.1 # coupling strength; T = 0.5 # temperature. # System-bath coupling operator:; Q = sigmaz(). where :math:`\gamma` (``gamma``), :math:`\lambda` (``lam``) and :math:`T` are; the parameters of a Drude-Lorentz bath, and ``Q`` is the coupling operator; between the system and the bath. We may the pass these parameters to either; :class:`~qutip.solver.heom.DrudeLorentzBath` or; :class:`~qutip.solver.heom.DrudeLorentzPadeBath` to construct an expansion of; the bath correlations:. .. plot::; :context:; :nofigs:. from qutip.solver.heom import DrudeLorentzBath; from qutip.solver.heom import DrudeLorentzPadeBath. # Number of expansion terms to retain:; Nk = 2. # Matsubara expansion:; bath = DrudeLorentzBath(Q, lam, gamma, T, Nk). # Pad expansion:; bath = DrudeLorentzPadeBath(Q, lam, gamma, T, Nk). Where ``Nk`` is the number of terms to retain within the expansion of the; bath. .. _heom-bosonic-system-and-bath-dynamics:. System and bath dynamics; ------------------------. Now we are ready to construct a solver:. .. plot::; :context:; :nofigs:. from qutip.solver.heom import HEOMSolver. max_depth = 5 # maximum hierarchy depth to retain; options = {""nsteps"": 15_000}. solver = HEOMSo",MatchSource.DOCS,doc/guide/heom/bosonic.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/heom/bosonic.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/heom/bosonic.rst:6548,Modifiability,coupling,coupling,6548,")); axes.plot(result.times, result.e_data[""11""], 'b', linewidth=2, label=""P11""); axes.plot(result.times, result.e_data[""12""], 'r', linewidth=2, label=""P12""); axes.set_xlabel(r't', fontsize=28); axes.legend(loc=0, fontsize=12). Steady-state; ------------. Using the same solver, we can also determine the steady state of the; combined system and bath using:. .. plot::; :context:; :nofigs:. steady_state, steady_ados = solver.steady_state(). where ``steady_state`` is the steady state of the system and ``steady_ados``; if the steady state of the full hierarchy. The ADO states are; described more fully in :ref:`heom-determining-currents` and; :class:`~qutip.solver.heom.HierarchyADOsState`. Matsubara Terminator; --------------------. When constructing the Drude-Lorentz bath we have truncated the expansion at; ``Nk = 2`` terms and ignore the remaining terms. However, since the coupling to these higher order terms is comparatively weak,; we may consider the interaction with them to be Markovian, and construct an; additional Lindbladian term that captures their interaction with the system and; the lower order terms in the expansion. This additional term is called the ``terminator`` because it terminates the; expansion. The :class:`~qutip.solver.heom.DrudeLorentzBath` and; :class:`~qutip.solver.heom.DrudeLorentzPadeBath` both provide a means of; calculating the terminator for a given expansion:. .. plot::; :context:; :nofigs:. # Matsubara expansion:; bath = DrudeLorentzBath(Q, lam, gamma, T, Nk). # Pad expansion:; bath = DrudeLorentzPadeBath(Q, lam, gamma, T, Nk). # Add terminator to the system Liouvillian:; delta, terminator = bath.terminator(); HL = liouvillian(H_sys) + terminator. # Construct solver:; solver = HEOMSolver(HL, bath, max_depth=max_depth, options=options). This captures the Markovian effect of the remaining terms in the expansion; without having to fully model many more terms. The value ``delta`` is an approximation to the strength of the effect of; the remaini",MatchSource.DOCS,doc/guide/heom/bosonic.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/heom/bosonic.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/heom/bosonic.rst:9527,Modifiability,extend,extend,9527,"{- \nu_{k,imag} t}. In the specific case of Matsubara expansion for the Drude-Lorentz bath, the; coefficients of this expansion are, for the real part, :math:`C_{real}(t)`:. .. math::. \nu_{k,real} &= \begin{cases}; \gamma & k = 0\\; {2 \pi k} / {\beta } & k \geq 1\\; \end{cases}. c_{k,real} &= \begin{cases}; \lambda \gamma [\cot(\beta \gamma / 2) - i] & k = 0\\; \frac{4 \lambda \gamma \nu_k }{ (\nu_k^2 - \gamma^2)\beta} & k \geq 1\\; \end{cases}. and the imaginary part, :math:`C_{imag}(t)`:. .. math::. \nu_{k,imag} &= \begin{cases}; \gamma & k = 0\\; 0 & k \geq 1\\; \end{cases}. c_{k,imag} &= \begin{cases}; - \lambda \gamma & k = 0\\; 0 & k \geq 1\\; \end{cases}. And now the same numbers calculated in Python:. .. plot::; :context:; :nofigs:. # Convenience functions and parameters:. def cot(x):; return 1. / np.tan(x). beta = 1. / T. # Number of expansion terms to calculate:; Nk = 2. # C_real expansion terms:; ck_real = [lam * gamma / np.tan(gamma / (2 * T))]; ck_real.extend([; (8 * lam * gamma * T * np.pi * k * T /; ((2 * np.pi * k * T)**2 - gamma**2)); for k in range(1, Nk + 1); ]); vk_real = [gamma]; vk_real.extend([2 * np.pi * k * T for k in range(1, Nk + 1)]). # C_imag expansion terms (this is the full expansion):; ck_imag = [lam * gamma * (-1.0)]; vk_imag = [gamma]. After all that, constructing the bath is very straight forward:. .. plot::; :context:; :nofigs:. from qutip.solver.heom import BosonicBath. bath = BosonicBath(Q, ck_real, vk_real, ck_imag, vk_imag). And we're done!. The :class:`~qutip.solver.heom.BosonicBath` can be used with the; :class:`~qutip.solver.heom.HEOMSolver` in exactly the same way as the baths; we constructed previously using the built-in Drude-Lorentz bath expansions. Multiple baths; --------------. The :class:`~qutip.solver.heom.HEOMSolver` supports having a system interact; with multiple environments. All that is needed is to supply a list of baths; instead of a single bath. In the example below we calculate the evolution of a small s",MatchSource.DOCS,doc/guide/heom/bosonic.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/heom/bosonic.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/heom/bosonic.rst:9673,Modifiability,extend,extend,9673,"r the real part, :math:`C_{real}(t)`:. .. math::. \nu_{k,real} &= \begin{cases}; \gamma & k = 0\\; {2 \pi k} / {\beta } & k \geq 1\\; \end{cases}. c_{k,real} &= \begin{cases}; \lambda \gamma [\cot(\beta \gamma / 2) - i] & k = 0\\; \frac{4 \lambda \gamma \nu_k }{ (\nu_k^2 - \gamma^2)\beta} & k \geq 1\\; \end{cases}. and the imaginary part, :math:`C_{imag}(t)`:. .. math::. \nu_{k,imag} &= \begin{cases}; \gamma & k = 0\\; 0 & k \geq 1\\; \end{cases}. c_{k,imag} &= \begin{cases}; - \lambda \gamma & k = 0\\; 0 & k \geq 1\\; \end{cases}. And now the same numbers calculated in Python:. .. plot::; :context:; :nofigs:. # Convenience functions and parameters:. def cot(x):; return 1. / np.tan(x). beta = 1. / T. # Number of expansion terms to calculate:; Nk = 2. # C_real expansion terms:; ck_real = [lam * gamma / np.tan(gamma / (2 * T))]; ck_real.extend([; (8 * lam * gamma * T * np.pi * k * T /; ((2 * np.pi * k * T)**2 - gamma**2)); for k in range(1, Nk + 1); ]); vk_real = [gamma]; vk_real.extend([2 * np.pi * k * T for k in range(1, Nk + 1)]). # C_imag expansion terms (this is the full expansion):; ck_imag = [lam * gamma * (-1.0)]; vk_imag = [gamma]. After all that, constructing the bath is very straight forward:. .. plot::; :context:; :nofigs:. from qutip.solver.heom import BosonicBath. bath = BosonicBath(Q, ck_real, vk_real, ck_imag, vk_imag). And we're done!. The :class:`~qutip.solver.heom.BosonicBath` can be used with the; :class:`~qutip.solver.heom.HEOMSolver` in exactly the same way as the baths; we constructed previously using the built-in Drude-Lorentz bath expansions. Multiple baths; --------------. The :class:`~qutip.solver.heom.HEOMSolver` supports having a system interact; with multiple environments. All that is needed is to supply a list of baths; instead of a single bath. In the example below we calculate the evolution of a small system where; each basis state of the system interacts with a separate bath. Such; an arrangement can model, for example, the FennaMatth",MatchSource.DOCS,doc/guide/heom/bosonic.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/heom/bosonic.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/heom/bosonic.rst:96,Usability,simpl,simple,96,"####################; Bosonic Environments; ####################. In this section we consider a simple two-level system coupled to a; Drude-Lorentz bosonic bath. The system Hamiltonian, :math:`H_{sys}`, and the bath; spectral density, :math:`J_D`, are. .. math::. H_{sys} &= \frac{\epsilon \sigma_z}{2} + \frac{\Delta \sigma_x}{2}. J_D &= \frac{2\lambda \gamma \omega}{(\gamma^2 + \omega^2)},. We will demonstrate how to describe the bath using two different expansions; of the spectral density correlation function (Matsubara's expansion and; a Pad expansion), how to evolve the system in time, and how to calculate; the steady state. First we will do this in the simplest way, using the built-in implementations of; the two bath expansions, :class:`~qutip.solver.heom.DrudeLorentzBath` and; :class:`~qutip.solver.heom.DrudeLorentzPadeBath`. We will do this both with a; truncated expansion and show how to include an approximation to all of the; remaining terms in the bath expansion. Afterwards, we will show how to calculate the bath expansion coefficients and to; use those coefficients to construct your own bath description so that you can; implement your own bosonic baths. Finally, we will demonstrate how to simulate a system coupled to multiple; independent baths, as occurs, for example, in certain photosynthesis processes. A notebook containing a complete example similar to this one implemented in; BoFiN can be found in; `example notebook 1a <https://github.com/tehruhn/bofin/blob/main/examples/example-1a-Spin-bath-model-basic.ipynb>`__. Describing the system and bath; ------------------------------. First, let us construct the system Hamiltonian, :math:`H_{sys}`, and the initial; system state, ``rho0``:. .. plot::; :context: reset; :nofigs:. from qutip import basis, sigmax, sigmaz. # The system Hamiltonian:; eps = 0.5 # energy of the 2-level system; Del = 1.0 # tunnelling term; H_sys = 0.5 * eps * sigmaz() + 0.5 * Del * sigmax(). # Initial state of the system:; rho0 = basis",MatchSource.DOCS,doc/guide/heom/bosonic.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/heom/bosonic.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/heom/bosonic.rst:666,Usability,simpl,simplest,666,"####################; Bosonic Environments; ####################. In this section we consider a simple two-level system coupled to a; Drude-Lorentz bosonic bath. The system Hamiltonian, :math:`H_{sys}`, and the bath; spectral density, :math:`J_D`, are. .. math::. H_{sys} &= \frac{\epsilon \sigma_z}{2} + \frac{\Delta \sigma_x}{2}. J_D &= \frac{2\lambda \gamma \omega}{(\gamma^2 + \omega^2)},. We will demonstrate how to describe the bath using two different expansions; of the spectral density correlation function (Matsubara's expansion and; a Pad expansion), how to evolve the system in time, and how to calculate; the steady state. First we will do this in the simplest way, using the built-in implementations of; the two bath expansions, :class:`~qutip.solver.heom.DrudeLorentzBath` and; :class:`~qutip.solver.heom.DrudeLorentzPadeBath`. We will do this both with a; truncated expansion and show how to include an approximation to all of the; remaining terms in the bath expansion. Afterwards, we will show how to calculate the bath expansion coefficients and to; use those coefficients to construct your own bath description so that you can; implement your own bosonic baths. Finally, we will demonstrate how to simulate a system coupled to multiple; independent baths, as occurs, for example, in certain photosynthesis processes. A notebook containing a complete example similar to this one implemented in; BoFiN can be found in; `example notebook 1a <https://github.com/tehruhn/bofin/blob/main/examples/example-1a-Spin-bath-model-basic.ipynb>`__. Describing the system and bath; ------------------------------. First, let us construct the system Hamiltonian, :math:`H_{sys}`, and the initial; system state, ``rho0``:. .. plot::; :context: reset; :nofigs:. from qutip import basis, sigmax, sigmaz. # The system Hamiltonian:; eps = 0.5 # energy of the 2-level system; Del = 1.0 # tunnelling term; H_sys = 0.5 * eps * sigmaz() + 0.5 * Del * sigmax(). # Initial state of the system:; rho0 = basis",MatchSource.DOCS,doc/guide/heom/bosonic.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/heom/bosonic.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/heom/bosonic.rst:4565,Usability,guid,guide,4565,"ate the system state at; result = solver.run(rho0, tlist). The ``max_depth`` parameter determines how many levels of the hierarchy to; retain. As a first approximation hierarchy depth may be thought of as similar; to the order of Feynman Diagrams (both classify terms by increasing number; of interactions). The ``result`` is a standard QuTiP results object with the attributes:. - ``times``: the times at which the state was evaluated (i.e. ``tlist``); - ``states``: the system states at each time; - ``expect``: a list with the values of each ``e_ops`` at each time; - ``e_data``: a dictionary with the values of each ``e_op`` at each time; - ``ado_states``: see below (an instance of; :class:`~qutip.solver.heom.HierarchyADOsState`). If ``ado_return=True`` is passed to ``.run(...)`` the full set of auxilliary; density operators (ADOs) that make up the hierarchy at each time will be; returned as ``.ado_states``. We will describe how to use these to determine; other properties, such as system-bath currents, later in the fermionic guide; (see :ref:`heom-determining-currents`). If one has a full set of ADOs from a previous call of ``.run(...)`` you may; supply it as the initial state of the solver by calling; ``.run(result.ado_states[-1], tlist, ado_init=True)``. As with other QuTiP solvers, if expectation operators or functions are supplied; using ``.run(..., e_ops=[...])`` the expectation values are available in; ``result.expect`` and ``result.e_data``. Below we run the solver again, but use ``e_ops`` to store the expectation; values of the population of the system states and the coherence:. .. plot::; :context:. # Define the operators that measure the populations of the two; # system states:; P11p = basis(2,0) * basis(2,0).dag(); P22p = basis(2,1) * basis(2,1).dag(). # Define the operator that measures the 0, 1 element of density matrix; # (corresonding to coherence):; P12p = basis(2,0) * basis(2,1).dag(). # Run the solver:; tlist = np.linspace(0, 20, 101); result = solver.",MatchSource.DOCS,doc/guide/heom/bosonic.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/heom/bosonic.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/heom/fermionic.rst:12641,Availability,down,down,12641,">`_,; and :math:`Nk` specifies the cut-off in the expansion. Evaluating the integral for the correlation functions gives:. .. math::. C^{\sigma}(t) \approx \sum_{l=0}^{Nk} \eta^{\sigma,l} e^{-\gamma_{\sigma,l}t}. where:. .. math::. \eta_{\sigma, l} &= \begin{cases}; \frac{\Gamma W}{2} f_F^{approx}(i\beta W) & l = 0\\; -i\cdot \frac{k_l}{\beta} \cdot \frac{\Gamma W^2}{-\frac{\epsilon^2_l}{\beta^2} + W^2} & l \neq 0\\; \end{cases}. \gamma_{\sigma,l} &= \begin{cases}; W - \sigma i\mu & l = 0\\; \frac{\epsilon_l}{\beta} - \sigma i \mu & l \neq 0\\; \end{cases}. and :math:`\beta = \frac{1}{T}`. And now we calculate the same numbers in Python:. .. plot::; :context:; :nofigs:. # Imports; from numpy.linalg import eigvalsh. # Convenience functions and parameters:; def deltafun(j, k):; """""" Kronecker delta function. """"""; return 1.0 if j == k else 0. def f_approx(x, Nk):; """""" Pad approxmation to Fermi distribution. """"""; f = 0.5; for ll in range(1, Nk + 1):; # kappa and epsilon are calculated further down; f = f - 2 * kappa[ll] * x / (x**2 + epsilon[ll]**2); return f. def kappa_epsilon(Nk):; """""" Calculate kappa and epsilon coefficients. """""". alpha = np.zeros((2 * Nk, 2 * Nk)); for j in range(2 * Nk):; for k in range(2 * Nk):; alpha[j][k] = (; (deltafun(j, k + 1) + deltafun(j, k - 1)); / np.sqrt((2 * (j + 1) - 1) * (2 * (k + 1) - 1)); ). eps = [-2. / val for val in eigvalsh(alpha)[:Nk]]. alpha_p = np.zeros((2 * Nk - 1, 2 * Nk - 1)); for j in range(2 * Nk - 1):; for k in range(2 * Nk - 1):; alpha_p[j][k] = (; (deltafun(j, k + 1) + deltafun(j, k - 1)); / np.sqrt((2 * (j + 1) + 1) * (2 * (k + 1) + 1)); ). chi = [-2. / val for val in eigvalsh(alpha_p)[:Nk - 1]]. eta_list = [; 0.5 * Nk * (2 * (Nk + 1) - 1) * (; np.prod([chi[k]**2 - eps[j]**2 for k in range(Nk - 1)]) /; np.prod([; eps[k]**2 - eps[j]**2 + deltafun(j, k) for k in range(Nk); ]); ); for j in range(Nk); ]. kappa = [0] + eta_list; epsilon = [0] + eps. return kappa, epsilon. kappa, epsilon = kappa_epsilon(Nk). # Phew, we made",MatchSource.DOCS,doc/guide/heom/fermionic.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/heom/fermionic.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/heom/fermionic.rst:2074,Energy Efficiency,energy,energy,2074,"ass:`~qutip.solver.heom.LorentzianPadeBath`. Afterwards, we will show how to calculate the bath expansion coefficients and to; use those coefficients to construct your own bath description so that you can; implement your own fermionic baths. Our implementation of fermionic baths primarily follows the definitions used by; Christian Schinabeck in his dissertation (; https://opus4.kobv.de/opus4-fau/files/10984/DissertationChristianSchinabeck.pdf; ) and related publications. A notebook containing a complete example similar to this one implemented in; BoFiN can be found in `example notebook 4b; <https://github.com/tehruhn/bofin/blob/main/examples/example-4b-fermions-single-impurity-model.ipynb>`__. Describing the system and bath; ------------------------------. First, let us construct the system Hamiltonian, :math:`H_{sys}`, and the initial; system state, ``rho0``:. .. plot::; :context: reset; :nofigs:. from qutip import basis, destroy. # The system Hamiltonian:; e1 = 1. # site energy; H_sys = e1 * destroy(2).dag() * destroy(2). # Initial state of the system:; rho0 = basis(2,0) * basis(2,0).dag(). Now let us describe the bath properties:. .. plot::; :context:; :nofigs:. # Shared bath properties:; gamma = 0.01 # coupling strength; W = 1.0 # cut-off; T = 0.025851991 # temperature; beta = 1. / T. # Chemical potentials for the two baths:; mu_L = 1.; mu_R = -1. # System-bath coupling operator:; Q = destroy(2). where :math:`\Gamma` (``gamma``), :math:`W` and :math:`T` are the parameters of; an Lorentzian bath, :math:`\mu_L` (``mu_L``) and :math:`\mu_R` (``mu_R``) are; the chemical potentials of the left and right baths, and ``Q`` is the coupling; operator between the system and the baths. We may the pass these parameters to either ``LorentzianBath`` or; ``LorentzianPadeBath`` to construct an expansion of the bath correlations:. .. plot::; :context:; :nofigs:. from qutip.solver.heom import LorentzianBath; from qutip.solver.heom import LorentzianPadeBath. # Number of expansion t",MatchSource.DOCS,doc/guide/heom/fermionic.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/heom/fermionic.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/heom/fermionic.rst:574,Modifiability,evolve,evolve,574,"######################; Fermionic Environments; ######################. Here we model a single fermion coupled to two electronic leads or reservoirs; (e.g., this can describe a single quantum dot, a molecular transistor, etc).; The system hamiltonian, :math:`H_{sys}`, and bath spectral density, :math:`J_D`,; are. .. math::. H_{sys} &= c^{\dagger} c. J_D &= \frac{\Gamma W^2}{(w - \mu)^2 + W^2},. We will demonstrate how to describe the bath using two different expansions; of the spectral density correlation function (Matsubara's expansion and; a Pad expansion), how to evolve the system in time, and how to calculate; the steady state. Since our fermion is coupled to two reservoirs, we will construct two baths --; one for each reservoir or lead -- and call them the left (:math:`L`) and right; (:math:`R`) baths for convenience. Each bath will have a different chemical; potential :math:`\mu` which we will label :math:`\mu_L` and :math:`\mu_R`. First we will do this using the built-in implementations of the bath expansions,; :class:`~qutip.solver.heom.LorentzianBath` and; :class:`~qutip.solver.heom.LorentzianPadeBath`. Afterwards, we will show how to calculate the bath expansion coefficients and to; use those coefficients to construct your own bath description so that you can; implement your own fermionic baths. Our implementation of fermionic baths primarily follows the definitions used by; Christian Schinabeck in his dissertation (; https://opus4.kobv.de/opus4-fau/files/10984/DissertationChristianSchinabeck.pdf; ) and related publications. A notebook containing a complete example similar to this one implemented in; BoFiN can be found in `example notebook 4b; <https://github.com/tehruhn/bofin/blob/main/examples/example-4b-fermions-single-impurity-model.ipynb>`__. Describing the system and bath; ------------------------------. First, let us construct the system Hamiltonian, :math:`H_{sys}`, and the initial; system state, ``rho0``:. .. plot::; :context: reset; :nofigs:. fro",MatchSource.DOCS,doc/guide/heom/fermionic.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/heom/fermionic.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/heom/fermionic.rst:2312,Modifiability,coupling,coupling,2312,"aths. Our implementation of fermionic baths primarily follows the definitions used by; Christian Schinabeck in his dissertation (; https://opus4.kobv.de/opus4-fau/files/10984/DissertationChristianSchinabeck.pdf; ) and related publications. A notebook containing a complete example similar to this one implemented in; BoFiN can be found in `example notebook 4b; <https://github.com/tehruhn/bofin/blob/main/examples/example-4b-fermions-single-impurity-model.ipynb>`__. Describing the system and bath; ------------------------------. First, let us construct the system Hamiltonian, :math:`H_{sys}`, and the initial; system state, ``rho0``:. .. plot::; :context: reset; :nofigs:. from qutip import basis, destroy. # The system Hamiltonian:; e1 = 1. # site energy; H_sys = e1 * destroy(2).dag() * destroy(2). # Initial state of the system:; rho0 = basis(2,0) * basis(2,0).dag(). Now let us describe the bath properties:. .. plot::; :context:; :nofigs:. # Shared bath properties:; gamma = 0.01 # coupling strength; W = 1.0 # cut-off; T = 0.025851991 # temperature; beta = 1. / T. # Chemical potentials for the two baths:; mu_L = 1.; mu_R = -1. # System-bath coupling operator:; Q = destroy(2). where :math:`\Gamma` (``gamma``), :math:`W` and :math:`T` are the parameters of; an Lorentzian bath, :math:`\mu_L` (``mu_L``) and :math:`\mu_R` (``mu_R``) are; the chemical potentials of the left and right baths, and ``Q`` is the coupling; operator between the system and the baths. We may the pass these parameters to either ``LorentzianBath`` or; ``LorentzianPadeBath`` to construct an expansion of the bath correlations:. .. plot::; :context:; :nofigs:. from qutip.solver.heom import LorentzianBath; from qutip.solver.heom import LorentzianPadeBath. # Number of expansion terms to retain:; Nk = 2. # Matsubara expansion:; bath_L = LorentzianBath(Q, gamma, W, mu_L, T, Nk, tag=""L""); bath_R = LorentzianBath(Q, gamma, W, mu_R, T, Nk, tag=""R""). # Pad expansion:; bath_L = LorentzianPadeBath(Q, gamma, W, mu_L, T",MatchSource.DOCS,doc/guide/heom/fermionic.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/heom/fermionic.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/heom/fermionic.rst:2474,Modifiability,coupling,coupling,2474,"/files/10984/DissertationChristianSchinabeck.pdf; ) and related publications. A notebook containing a complete example similar to this one implemented in; BoFiN can be found in `example notebook 4b; <https://github.com/tehruhn/bofin/blob/main/examples/example-4b-fermions-single-impurity-model.ipynb>`__. Describing the system and bath; ------------------------------. First, let us construct the system Hamiltonian, :math:`H_{sys}`, and the initial; system state, ``rho0``:. .. plot::; :context: reset; :nofigs:. from qutip import basis, destroy. # The system Hamiltonian:; e1 = 1. # site energy; H_sys = e1 * destroy(2).dag() * destroy(2). # Initial state of the system:; rho0 = basis(2,0) * basis(2,0).dag(). Now let us describe the bath properties:. .. plot::; :context:; :nofigs:. # Shared bath properties:; gamma = 0.01 # coupling strength; W = 1.0 # cut-off; T = 0.025851991 # temperature; beta = 1. / T. # Chemical potentials for the two baths:; mu_L = 1.; mu_R = -1. # System-bath coupling operator:; Q = destroy(2). where :math:`\Gamma` (``gamma``), :math:`W` and :math:`T` are the parameters of; an Lorentzian bath, :math:`\mu_L` (``mu_L``) and :math:`\mu_R` (``mu_R``) are; the chemical potentials of the left and right baths, and ``Q`` is the coupling; operator between the system and the baths. We may the pass these parameters to either ``LorentzianBath`` or; ``LorentzianPadeBath`` to construct an expansion of the bath correlations:. .. plot::; :context:; :nofigs:. from qutip.solver.heom import LorentzianBath; from qutip.solver.heom import LorentzianPadeBath. # Number of expansion terms to retain:; Nk = 2. # Matsubara expansion:; bath_L = LorentzianBath(Q, gamma, W, mu_L, T, Nk, tag=""L""); bath_R = LorentzianBath(Q, gamma, W, mu_R, T, Nk, tag=""R""). # Pad expansion:; bath_L = LorentzianPadeBath(Q, gamma, W, mu_L, T, Nk, tag=""L""); bath_R = LorentzianPadeBath(Q, gamma, W, mu_R, T, Nk, tag=""R""). Where ``Nk`` is the number of terms to retain within the expansion of the; bath. N",MatchSource.DOCS,doc/guide/heom/fermionic.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/heom/fermionic.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/heom/fermionic.rst:2740,Modifiability,coupling,coupling,2740,"e found in `example notebook 4b; <https://github.com/tehruhn/bofin/blob/main/examples/example-4b-fermions-single-impurity-model.ipynb>`__. Describing the system and bath; ------------------------------. First, let us construct the system Hamiltonian, :math:`H_{sys}`, and the initial; system state, ``rho0``:. .. plot::; :context: reset; :nofigs:. from qutip import basis, destroy. # The system Hamiltonian:; e1 = 1. # site energy; H_sys = e1 * destroy(2).dag() * destroy(2). # Initial state of the system:; rho0 = basis(2,0) * basis(2,0).dag(). Now let us describe the bath properties:. .. plot::; :context:; :nofigs:. # Shared bath properties:; gamma = 0.01 # coupling strength; W = 1.0 # cut-off; T = 0.025851991 # temperature; beta = 1. / T. # Chemical potentials for the two baths:; mu_L = 1.; mu_R = -1. # System-bath coupling operator:; Q = destroy(2). where :math:`\Gamma` (``gamma``), :math:`W` and :math:`T` are the parameters of; an Lorentzian bath, :math:`\mu_L` (``mu_L``) and :math:`\mu_R` (``mu_R``) are; the chemical potentials of the left and right baths, and ``Q`` is the coupling; operator between the system and the baths. We may the pass these parameters to either ``LorentzianBath`` or; ``LorentzianPadeBath`` to construct an expansion of the bath correlations:. .. plot::; :context:; :nofigs:. from qutip.solver.heom import LorentzianBath; from qutip.solver.heom import LorentzianPadeBath. # Number of expansion terms to retain:; Nk = 2. # Matsubara expansion:; bath_L = LorentzianBath(Q, gamma, W, mu_L, T, Nk, tag=""L""); bath_R = LorentzianBath(Q, gamma, W, mu_R, T, Nk, tag=""R""). # Pad expansion:; bath_L = LorentzianPadeBath(Q, gamma, W, mu_L, T, Nk, tag=""L""); bath_R = LorentzianPadeBath(Q, gamma, W, mu_R, T, Nk, tag=""R""). Where ``Nk`` is the number of terms to retain within the expansion of the; bath. Note that we haved labelled each bath with a tag (either ""L"" or ""R"") so that; we can identify the exponents from individual baths later when calculating; the currents b",MatchSource.DOCS,doc/guide/heom/fermionic.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/heom/fermionic.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/heom/fermionic.rst:6388,Security,access,access,6388,"en the system and the two baths. We will plot; these in the next section using the auxiliary density operators (ADOs); returned by the solver. .. _heom-determining-currents:. Determining currents; --------------------. The currents between the system and a fermionic bath may be calculated from the; first level auxiliary density operators (ADOs) associated with the exponents; of that bath. The contribution to the current into a given bath from each exponent in that; bath is:. .. math::. \mathrm{Contribution from Exponent} = \pm i \mathrm{Tr}(Q^\pm \cdot A). where the :math:`\pm` sign is the sign of the exponent (see the; description later in :ref:`heom-fermionic-pade-expansion-coefficients`) and; :math:`Q^\pm` is :math:`Q` for ``+`` exponents and :math:`Q^{\dagger}` for; ``-`` exponents. The first-level exponents for the left bath are retrieved by calling; ``.filter(tags=[""L""])`` on ``ado_state`` which is an instance of; :class:`~qutip.solver.heom.HierarchyADOsState` and also provides access to; the methods of :class:`~qutip.solver.heom.HierarchyADOs` which describes the; structure of the hierarchy for a given problem. Here the tag ""L"" matches the tag passed when constructing ``bath_L`` earlier; in this example. Similarly, we may calculate the current to the right bath from the exponents; tagged with ""R"". .. plot::; :context:; :nofigs:. def exp_current(aux, exp):; """""" Calculate the current for a single exponent. """"""; sign = 1 if exp.type == exp.types[""+""] else -1; op = exp.Q if exp.type == exp.types[""+""] else exp.Q.dag(); return 1j * sign * (op * aux).tr(). def heom_current(tag, ado_state):; """""" Calculate the current between the system and the given bath. """"""; level_1_ados = [; (ado_state.extract(label), ado_state.exps(label)[0]); for label in ado_state.filter(tags=[tag]); ]; return np.real(sum(exp_current(aux, exp) for aux, exp in level_1_ados)). heom_left_current = lambda t, ado_state: heom_current(""L"", ado_state); heom_right_current = lambda t, ado_state: heom_curr",MatchSource.DOCS,doc/guide/heom/fermionic.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/heom/fermionic.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/heom/history.rst:350,Availability,avail,available,350,"########################; Previous implementations; ########################. The current HEOM implementation in QuTiP is the latest in a succession of HEOM; implementations by various contributors:. HSolverDL; ---------. The original HEOM solver was implemented by Neill Lambert, Anubhav Vardhan,; and Alexander Pitchford. In QuTiP 4.7 it was still available as; ``qutip.solve.nonmarkov.dlheom_solver.HSolverDL`` but the legacy implementation; was removed in QuTiP 5. It only directly provided support for the Drude-Lorentz bath although there was; the possibility of sub-classing the solver to implement other baths. A compatible interface using the current implementation is still available; under the same name in :class:`qutip.solver.heom.HSolverDL`. BoFiN-HEOM; ----------. BoFiN-HEOM (the bosonic and fermionic HEOM solver) was a much more; flexible re-write of the original QuTiP ``HSolverDL`` that added support for; both bosonic and fermionic baths and for baths to be specified directly via; their correlation function expansion coefficients. Its authors were; Neill Lambert, Tarun Raheja, Shahnawaz Ahmed, and Alexander Pitchford. BoFiN was written outside of QuTiP and is can still be found in its original; repository at https://github.com/tehruhn/bofin. The construction of the right-hand side matrix for BoFiN was slow, so; BoFiN-fast, a hybrid C++ and Python implementation, was written that performed; the right-hand side construction in C++. It was otherwise identical to the; pure Python version. BoFiN-fast can be found at; https://github.com/tehruhn/bofin_fast. BoFiN also came with an extensive set of example notebooks that are available; at https://github.com/tehruhn/bofin/tree/main/examples. Current implementation; ----------------------. The current implementation is a rewrite of BoFiN in pure Python. It's right-hand; side construction has similar speed to BoFiN-fast, but is written in pure; Python. Built-in implementations of a variety of different baths are provided",MatchSource.DOCS,doc/guide/heom/history.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/heom/history.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/heom/history.rst:684,Availability,avail,available,684,"########################; Previous implementations; ########################. The current HEOM implementation in QuTiP is the latest in a succession of HEOM; implementations by various contributors:. HSolverDL; ---------. The original HEOM solver was implemented by Neill Lambert, Anubhav Vardhan,; and Alexander Pitchford. In QuTiP 4.7 it was still available as; ``qutip.solve.nonmarkov.dlheom_solver.HSolverDL`` but the legacy implementation; was removed in QuTiP 5. It only directly provided support for the Drude-Lorentz bath although there was; the possibility of sub-classing the solver to implement other baths. A compatible interface using the current implementation is still available; under the same name in :class:`qutip.solver.heom.HSolverDL`. BoFiN-HEOM; ----------. BoFiN-HEOM (the bosonic and fermionic HEOM solver) was a much more; flexible re-write of the original QuTiP ``HSolverDL`` that added support for; both bosonic and fermionic baths and for baths to be specified directly via; their correlation function expansion coefficients. Its authors were; Neill Lambert, Tarun Raheja, Shahnawaz Ahmed, and Alexander Pitchford. BoFiN was written outside of QuTiP and is can still be found in its original; repository at https://github.com/tehruhn/bofin. The construction of the right-hand side matrix for BoFiN was slow, so; BoFiN-fast, a hybrid C++ and Python implementation, was written that performed; the right-hand side construction in C++. It was otherwise identical to the; pure Python version. BoFiN-fast can be found at; https://github.com/tehruhn/bofin_fast. BoFiN also came with an extensive set of example notebooks that are available; at https://github.com/tehruhn/bofin/tree/main/examples. Current implementation; ----------------------. The current implementation is a rewrite of BoFiN in pure Python. It's right-hand; side construction has similar speed to BoFiN-fast, but is written in pure; Python. Built-in implementations of a variety of different baths are provided",MatchSource.DOCS,doc/guide/heom/history.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/heom/history.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/heom/history.rst:1652,Availability,avail,available,1652,"lve.nonmarkov.dlheom_solver.HSolverDL`` but the legacy implementation; was removed in QuTiP 5. It only directly provided support for the Drude-Lorentz bath although there was; the possibility of sub-classing the solver to implement other baths. A compatible interface using the current implementation is still available; under the same name in :class:`qutip.solver.heom.HSolverDL`. BoFiN-HEOM; ----------. BoFiN-HEOM (the bosonic and fermionic HEOM solver) was a much more; flexible re-write of the original QuTiP ``HSolverDL`` that added support for; both bosonic and fermionic baths and for baths to be specified directly via; their correlation function expansion coefficients. Its authors were; Neill Lambert, Tarun Raheja, Shahnawaz Ahmed, and Alexander Pitchford. BoFiN was written outside of QuTiP and is can still be found in its original; repository at https://github.com/tehruhn/bofin. The construction of the right-hand side matrix for BoFiN was slow, so; BoFiN-fast, a hybrid C++ and Python implementation, was written that performed; the right-hand side construction in C++. It was otherwise identical to the; pure Python version. BoFiN-fast can be found at; https://github.com/tehruhn/bofin_fast. BoFiN also came with an extensive set of example notebooks that are available; at https://github.com/tehruhn/bofin/tree/main/examples. Current implementation; ----------------------. The current implementation is a rewrite of BoFiN in pure Python. It's right-hand; side construction has similar speed to BoFiN-fast, but is written in pure; Python. Built-in implementations of a variety of different baths are provided,; and a single solver is used for both fermionic and bosonic baths. Multiple baths; of either the same kind, or a mixture of fermionic and bosonic baths, may be; specified in a single problem, and there is good support for working with the; auxiliary density operator (ADO) state and extracting information from it. The code was written by Neill Lambert and Simon Cross.; ",MatchSource.DOCS,doc/guide/heom/history.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/heom/history.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/heom/history.rst:632,Integrability,interface,interface,632,"########################; Previous implementations; ########################. The current HEOM implementation in QuTiP is the latest in a succession of HEOM; implementations by various contributors:. HSolverDL; ---------. The original HEOM solver was implemented by Neill Lambert, Anubhav Vardhan,; and Alexander Pitchford. In QuTiP 4.7 it was still available as; ``qutip.solve.nonmarkov.dlheom_solver.HSolverDL`` but the legacy implementation; was removed in QuTiP 5. It only directly provided support for the Drude-Lorentz bath although there was; the possibility of sub-classing the solver to implement other baths. A compatible interface using the current implementation is still available; under the same name in :class:`qutip.solver.heom.HSolverDL`. BoFiN-HEOM; ----------. BoFiN-HEOM (the bosonic and fermionic HEOM solver) was a much more; flexible re-write of the original QuTiP ``HSolverDL`` that added support for; both bosonic and fermionic baths and for baths to be specified directly via; their correlation function expansion coefficients. Its authors were; Neill Lambert, Tarun Raheja, Shahnawaz Ahmed, and Alexander Pitchford. BoFiN was written outside of QuTiP and is can still be found in its original; repository at https://github.com/tehruhn/bofin. The construction of the right-hand side matrix for BoFiN was slow, so; BoFiN-fast, a hybrid C++ and Python implementation, was written that performed; the right-hand side construction in C++. It was otherwise identical to the; pure Python version. BoFiN-fast can be found at; https://github.com/tehruhn/bofin_fast. BoFiN also came with an extensive set of example notebooks that are available; at https://github.com/tehruhn/bofin/tree/main/examples. Current implementation; ----------------------. The current implementation is a rewrite of BoFiN in pure Python. It's right-hand; side construction has similar speed to BoFiN-fast, but is written in pure; Python. Built-in implementations of a variety of different baths are provided",MatchSource.DOCS,doc/guide/heom/history.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/heom/history.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/heom/history.rst:848,Modifiability,flexible,flexible,848,"########################; Previous implementations; ########################. The current HEOM implementation in QuTiP is the latest in a succession of HEOM; implementations by various contributors:. HSolverDL; ---------. The original HEOM solver was implemented by Neill Lambert, Anubhav Vardhan,; and Alexander Pitchford. In QuTiP 4.7 it was still available as; ``qutip.solve.nonmarkov.dlheom_solver.HSolverDL`` but the legacy implementation; was removed in QuTiP 5. It only directly provided support for the Drude-Lorentz bath although there was; the possibility of sub-classing the solver to implement other baths. A compatible interface using the current implementation is still available; under the same name in :class:`qutip.solver.heom.HSolverDL`. BoFiN-HEOM; ----------. BoFiN-HEOM (the bosonic and fermionic HEOM solver) was a much more; flexible re-write of the original QuTiP ``HSolverDL`` that added support for; both bosonic and fermionic baths and for baths to be specified directly via; their correlation function expansion coefficients. Its authors were; Neill Lambert, Tarun Raheja, Shahnawaz Ahmed, and Alexander Pitchford. BoFiN was written outside of QuTiP and is can still be found in its original; repository at https://github.com/tehruhn/bofin. The construction of the right-hand side matrix for BoFiN was slow, so; BoFiN-fast, a hybrid C++ and Python implementation, was written that performed; the right-hand side construction in C++. It was otherwise identical to the; pure Python version. BoFiN-fast can be found at; https://github.com/tehruhn/bofin_fast. BoFiN also came with an extensive set of example notebooks that are available; at https://github.com/tehruhn/bofin/tree/main/examples. Current implementation; ----------------------. The current implementation is a rewrite of BoFiN in pure Python. It's right-hand; side construction has similar speed to BoFiN-fast, but is written in pure; Python. Built-in implementations of a variety of different baths are provided",MatchSource.DOCS,doc/guide/heom/history.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/heom/history.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/heom/history.rst:1799,Modifiability,rewrite,rewrite,1799,"lve.nonmarkov.dlheom_solver.HSolverDL`` but the legacy implementation; was removed in QuTiP 5. It only directly provided support for the Drude-Lorentz bath although there was; the possibility of sub-classing the solver to implement other baths. A compatible interface using the current implementation is still available; under the same name in :class:`qutip.solver.heom.HSolverDL`. BoFiN-HEOM; ----------. BoFiN-HEOM (the bosonic and fermionic HEOM solver) was a much more; flexible re-write of the original QuTiP ``HSolverDL`` that added support for; both bosonic and fermionic baths and for baths to be specified directly via; their correlation function expansion coefficients. Its authors were; Neill Lambert, Tarun Raheja, Shahnawaz Ahmed, and Alexander Pitchford. BoFiN was written outside of QuTiP and is can still be found in its original; repository at https://github.com/tehruhn/bofin. The construction of the right-hand side matrix for BoFiN was slow, so; BoFiN-fast, a hybrid C++ and Python implementation, was written that performed; the right-hand side construction in C++. It was otherwise identical to the; pure Python version. BoFiN-fast can be found at; https://github.com/tehruhn/bofin_fast. BoFiN also came with an extensive set of example notebooks that are available; at https://github.com/tehruhn/bofin/tree/main/examples. Current implementation; ----------------------. The current implementation is a rewrite of BoFiN in pure Python. It's right-hand; side construction has similar speed to BoFiN-fast, but is written in pure; Python. Built-in implementations of a variety of different baths are provided,; and a single solver is used for both fermionic and bosonic baths. Multiple baths; of either the same kind, or a mixture of fermionic and bosonic baths, may be; specified in a single problem, and there is good support for working with the; auxiliary density operator (ADO) state and extracting information from it. The code was written by Neill Lambert and Simon Cross.; ",MatchSource.DOCS,doc/guide/heom/history.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/heom/history.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/heom/history.rst:1409,Performance,perform,performed,1409,"``qutip.solve.nonmarkov.dlheom_solver.HSolverDL`` but the legacy implementation; was removed in QuTiP 5. It only directly provided support for the Drude-Lorentz bath although there was; the possibility of sub-classing the solver to implement other baths. A compatible interface using the current implementation is still available; under the same name in :class:`qutip.solver.heom.HSolverDL`. BoFiN-HEOM; ----------. BoFiN-HEOM (the bosonic and fermionic HEOM solver) was a much more; flexible re-write of the original QuTiP ``HSolverDL`` that added support for; both bosonic and fermionic baths and for baths to be specified directly via; their correlation function expansion coefficients. Its authors were; Neill Lambert, Tarun Raheja, Shahnawaz Ahmed, and Alexander Pitchford. BoFiN was written outside of QuTiP and is can still be found in its original; repository at https://github.com/tehruhn/bofin. The construction of the right-hand side matrix for BoFiN was slow, so; BoFiN-fast, a hybrid C++ and Python implementation, was written that performed; the right-hand side construction in C++. It was otherwise identical to the; pure Python version. BoFiN-fast can be found at; https://github.com/tehruhn/bofin_fast. BoFiN also came with an extensive set of example notebooks that are available; at https://github.com/tehruhn/bofin/tree/main/examples. Current implementation; ----------------------. The current implementation is a rewrite of BoFiN in pure Python. It's right-hand; side construction has similar speed to BoFiN-fast, but is written in pure; Python. Built-in implementations of a variety of different baths are provided,; and a single solver is used for both fermionic and bosonic baths. Multiple baths; of either the same kind, or a mixture of fermionic and bosonic baths, may be; specified in a single problem, and there is good support for working with the; auxiliary density operator (ADO) state and extracting information from it. The code was written by Neill Lambert and Simo",MatchSource.DOCS,doc/guide/heom/history.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/heom/history.rst
https://github.com/qutip/qutip/tree/v5.0.4/doc/LICENSE_cc-by-3.0.txt:2115,Availability,avail,available,2115,"f doubt, where the; Work is a musical work, performance or phonogram, the synchronization of; the Work in timed-relation with a moving image (""synching"") will be; considered an Adaptation for the purpose of this License. b. ""Collection"" means a collection of literary or artistic works, such as; encyclopedias and anthologies, or performances, phonograms or broadcasts,; or other works or subject matter other than works listed in Section 1(f); below, which, by reason of the selection and arrangement of their; contents, constitute intellectual creations, in which the Work is; included in its entirety in unmodified form along with one or more other; contributions, each constituting separate and independent works in; themselves, which together are assembled into a collective whole. A work; that constitutes a Collection will not be considered an Adaptation (as; defined above) for the purposes of this License. c. ""Distribute"" means to make available to the public the original and; copies of the Work or Adaptation, as appropriate, through sale or other; transfer of ownership. d. ""Licensor"" means the individual, individuals, entity or entities that; offer(s) the Work under the terms of this License. e. ""Original Author"" means, in the case of a literary or artistic work, the; individual, individuals, entity or entities who created the Work or if no; individual or entity can be identified, the publisher; and in addition; (i) in the case of a performance the actors, singers, musicians, dancers,; and other persons who act, sing, deliver, declaim, play in, interpret or; otherwise perform literary or artistic works or expressions of folklore;; (ii) in the case of a phonogram the producer being the person or legal; entity who first fixes the sounds of a performance or other sounds; and,; (iii) in the case of broadcasts, the organization that transmits the; broadcast. f. ""Work"" means the literary and/or artistic work offered under the terms of; this License including without limitatio",MatchSource.DOCS,doc/LICENSE_cc-by-3.0.txt,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/LICENSE_cc-by-3.0.txt
https://github.com/qutip/qutip/tree/v5.0.4/doc/LICENSE_cc-by-3.0.txt:4762,Availability,avail,available,4762,"rk of applied art; an illustration, map, plan, sketch or; three-dimensional work relative to geography, topography, architecture or; science; a performance; a broadcast; a phonogram; a compilation of data; to the extent it is protected as a copyrightable work; or a work; performed by a variety or circus performer to the extent it is not; otherwise considered a literary or artistic work. g. ""You"" means an individual or entity exercising rights under this License; who has not previously violated the terms of this License with respect to; the Work, or who has received express permission from the Licensor to; exercise rights under this License despite a previous violation. h. ""Publicly Perform"" means to perform public recitations of the Work and to; communicate to the public those public recitations, by any means or; process, including by wire or wireless means or public digital; performances; to make available to the public Works in such a way that; members of the public may access these Works from a place and at a place; individually chosen by them; to perform the Work to the public by any; means or process and the communication to the public of the performances; of the Work, including by public digital performance; to broadcast and; rebroadcast the Work by any means including signs, sounds or images. i. ""Reproduce"" means to make copies of the Work by any means including; without limitation by sound or visual recordings and the right of; fixation and reproducing fixations of the Work, including storage of a; protected performance or phonogram in digital form or other electronic; medium. 2. Fair Dealing Rights. Nothing in this License is intended to reduce, limit, or; restrict any uses free from copyright or rights arising from limitations or; exceptions that are provided for in connection with the copyright protection; under copyright law or other applicable laws. 3. License Grant. Subject to the terms and conditions of this License, Licensor; hereby grants You a worl",MatchSource.DOCS,doc/LICENSE_cc-by-3.0.txt,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/LICENSE_cc-by-3.0.txt
https://github.com/qutip/qutip/tree/v5.0.4/doc/LICENSE_cc-by-3.0.txt:14302,Deployability,release,release,14302,"NCIDENTAL, CONSEQUENTIAL, PUNITIVE OR EXEMPLARY DAMAGES ARISING OUT OF THIS; LICENSE OR THE USE OF THE WORK, EVEN IF LICENSOR HAS BEEN ADVISED OF THE; POSSIBILITY OF SUCH DAMAGES. 7. Termination. a. This License and the rights granted hereunder will terminate automatically; upon any breach by You of the terms of this License. Individuals or; entities who have received Adaptations or Collections from You under this; License, however, will not have their licenses terminated provided such; individuals or entities remain in full compliance with those licenses.; Sections 1, 2, 5, 6, 7, and 8 will survive any termination of this; License. b. Subject to the above terms and conditions, the license granted here is; perpetual (for the duration of the applicable copyright in the Work).; Notwithstanding the above, Licensor reserves the right to release the Work; under different license terms or to stop distributing the Work at any; time; provided, however that any such election will not serve to withdraw; this License (or any other license that has been, or is required to be,; granted under the terms of this License), and this License will continue; in full force and effect unless terminated as stated above. 8. Miscellaneous. a. Each time You Distribute or Publicly Perform the Work or a Collection,; the Licensor offers to the recipient a license to the Work on the same; terms and conditions as the license granted to You under this License. b. Each time You Distribute or Publicly Perform an Adaptation, Licensor; offers to the recipient a license to the original Work on the same terms; and conditions as the license granted to You under this License. c. If any provision of this License is invalid or unenforceable under; applicable law, it shall not affect the validity or enforceability of the; remainder of the terms of this License, and without further action by the; parties to this agreement, such provision shall be reformed to the; minimum extent necessary to make such provision",MatchSource.DOCS,doc/LICENSE_cc-by-3.0.txt,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/LICENSE_cc-by-3.0.txt
https://github.com/qutip/qutip/tree/v5.0.4/doc/LICENSE_cc-by-3.0.txt:716,Energy Efficiency,adapt,adaptation,716,"THE WORK (AS DEFINED BELOW) IS PROVIDED UNDER THE TERMS OF THIS CREATIVE COMMONS; PUBLIC LICENSE (""CCPL"" OR ""LICENSE""). THE WORK IS PROTECTED BY COPYRIGHT AND/OR; OTHER APPLICABLE LAW. ANY USE OF THE WORK OTHER THAN AS AUTHORIZED UNDER THIS; LICENSE OR COPYRIGHT LAW IS PROHIBITED. BY EXERCISING ANY RIGHTS TO THE WORK PROVIDED HERE, YOU ACCEPT AND AGREE TO BE; BOUND BY THE TERMS OF THIS LICENSE. TO THE EXTENT THIS LICENSE MAY BE CONSIDERED; TO BE A CONTRACT, THE LICENSOR GRANTS YOU THE RIGHTS CONTAINED HERE IN; CONSIDERATION OF YOUR ACCEPTANCE OF SUCH TERMS AND CONDITIONS. 1. Definitions. a. ""Adaptation"" means a work based upon the Work, or upon the Work and other; pre-existing works, such as a translation, adaptation, derivative work,; arrangement of music or other alterations of a literary or artistic work,; or phonogram or performance and includes cinematographic adaptations or; any other form in which the Work may be recast, transformed, or adapted; including in any form recognizably derived from the original, except that; a work that constitutes a Collection will not be considered an Adaptation; for the purpose of this License. For the avoidance of doubt, where the; Work is a musical work, performance or phonogram, the synchronization of; the Work in timed-relation with a moving image (""synching"") will be; considered an Adaptation for the purpose of this License. b. ""Collection"" means a collection of literary or artistic works, such as; encyclopedias and anthologies, or performances, phonograms or broadcasts,; or other works or subject matter other than works listed in Section 1(f); below, which, by reason of the selection and arrangement of their; contents, constitute intellectual creations, in which the Work is; included in its entirety in unmodified form along with one or more other; contributions, each constituting separate and independent works in; themselves, which together are assembled into a collective whole. A work; that constitutes a Collection will no",MatchSource.DOCS,doc/LICENSE_cc-by-3.0.txt,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/LICENSE_cc-by-3.0.txt
https://github.com/qutip/qutip/tree/v5.0.4/doc/LICENSE_cc-by-3.0.txt:878,Energy Efficiency,adapt,adaptations,878,"THE WORK (AS DEFINED BELOW) IS PROVIDED UNDER THE TERMS OF THIS CREATIVE COMMONS; PUBLIC LICENSE (""CCPL"" OR ""LICENSE""). THE WORK IS PROTECTED BY COPYRIGHT AND/OR; OTHER APPLICABLE LAW. ANY USE OF THE WORK OTHER THAN AS AUTHORIZED UNDER THIS; LICENSE OR COPYRIGHT LAW IS PROHIBITED. BY EXERCISING ANY RIGHTS TO THE WORK PROVIDED HERE, YOU ACCEPT AND AGREE TO BE; BOUND BY THE TERMS OF THIS LICENSE. TO THE EXTENT THIS LICENSE MAY BE CONSIDERED; TO BE A CONTRACT, THE LICENSOR GRANTS YOU THE RIGHTS CONTAINED HERE IN; CONSIDERATION OF YOUR ACCEPTANCE OF SUCH TERMS AND CONDITIONS. 1. Definitions. a. ""Adaptation"" means a work based upon the Work, or upon the Work and other; pre-existing works, such as a translation, adaptation, derivative work,; arrangement of music or other alterations of a literary or artistic work,; or phonogram or performance and includes cinematographic adaptations or; any other form in which the Work may be recast, transformed, or adapted; including in any form recognizably derived from the original, except that; a work that constitutes a Collection will not be considered an Adaptation; for the purpose of this License. For the avoidance of doubt, where the; Work is a musical work, performance or phonogram, the synchronization of; the Work in timed-relation with a moving image (""synching"") will be; considered an Adaptation for the purpose of this License. b. ""Collection"" means a collection of literary or artistic works, such as; encyclopedias and anthologies, or performances, phonograms or broadcasts,; or other works or subject matter other than works listed in Section 1(f); below, which, by reason of the selection and arrangement of their; contents, constitute intellectual creations, in which the Work is; included in its entirety in unmodified form along with one or more other; contributions, each constituting separate and independent works in; themselves, which together are assembled into a collective whole. A work; that constitutes a Collection will no",MatchSource.DOCS,doc/LICENSE_cc-by-3.0.txt,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/LICENSE_cc-by-3.0.txt
https://github.com/qutip/qutip/tree/v5.0.4/doc/LICENSE_cc-by-3.0.txt:958,Energy Efficiency,adapt,adapted,958,"THE WORK (AS DEFINED BELOW) IS PROVIDED UNDER THE TERMS OF THIS CREATIVE COMMONS; PUBLIC LICENSE (""CCPL"" OR ""LICENSE""). THE WORK IS PROTECTED BY COPYRIGHT AND/OR; OTHER APPLICABLE LAW. ANY USE OF THE WORK OTHER THAN AS AUTHORIZED UNDER THIS; LICENSE OR COPYRIGHT LAW IS PROHIBITED. BY EXERCISING ANY RIGHTS TO THE WORK PROVIDED HERE, YOU ACCEPT AND AGREE TO BE; BOUND BY THE TERMS OF THIS LICENSE. TO THE EXTENT THIS LICENSE MAY BE CONSIDERED; TO BE A CONTRACT, THE LICENSOR GRANTS YOU THE RIGHTS CONTAINED HERE IN; CONSIDERATION OF YOUR ACCEPTANCE OF SUCH TERMS AND CONDITIONS. 1. Definitions. a. ""Adaptation"" means a work based upon the Work, or upon the Work and other; pre-existing works, such as a translation, adaptation, derivative work,; arrangement of music or other alterations of a literary or artistic work,; or phonogram or performance and includes cinematographic adaptations or; any other form in which the Work may be recast, transformed, or adapted; including in any form recognizably derived from the original, except that; a work that constitutes a Collection will not be considered an Adaptation; for the purpose of this License. For the avoidance of doubt, where the; Work is a musical work, performance or phonogram, the synchronization of; the Work in timed-relation with a moving image (""synching"") will be; considered an Adaptation for the purpose of this License. b. ""Collection"" means a collection of literary or artistic works, such as; encyclopedias and anthologies, or performances, phonograms or broadcasts,; or other works or subject matter other than works listed in Section 1(f); below, which, by reason of the selection and arrangement of their; contents, constitute intellectual creations, in which the Work is; included in its entirety in unmodified form along with one or more other; contributions, each constituting separate and independent works in; themselves, which together are assembled into a collective whole. A work; that constitutes a Collection will no",MatchSource.DOCS,doc/LICENSE_cc-by-3.0.txt,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/LICENSE_cc-by-3.0.txt
https://github.com/qutip/qutip/tree/v5.0.4/doc/LICENSE_cc-by-3.0.txt:5526,Energy Efficiency,reduce,reduce,5526,"ate to the public those public recitations, by any means or; process, including by wire or wireless means or public digital; performances; to make available to the public Works in such a way that; members of the public may access these Works from a place and at a place; individually chosen by them; to perform the Work to the public by any; means or process and the communication to the public of the performances; of the Work, including by public digital performance; to broadcast and; rebroadcast the Work by any means including signs, sounds or images. i. ""Reproduce"" means to make copies of the Work by any means including; without limitation by sound or visual recordings and the right of; fixation and reproducing fixations of the Work, including storage of a; protected performance or phonogram in digital form or other electronic; medium. 2. Fair Dealing Rights. Nothing in this License is intended to reduce, limit, or; restrict any uses free from copyright or rights arising from limitations or; exceptions that are provided for in connection with the copyright protection; under copyright law or other applicable laws. 3. License Grant. Subject to the terms and conditions of this License, Licensor; hereby grants You a worldwide, royalty-free, non-exclusive, perpetual (for; the duration of the applicable copyright) license to exercise the rights in; the Work as stated below:. a. to Reproduce the Work, to incorporate the Work into one or more; Collections, and to Reproduce the Work as incorporated in the; Collections;. b. to create and Reproduce Adaptations provided that any such Adaptation,; including any translation in any medium, takes reasonable steps to; clearly label, demarcate or otherwise identify that changes were made to; the original Work. For example, a translation could be marked ""The; original work was translated from English to Spanish,"" or a modification; could indicate ""The original work has been modified."";. c. to Distribute and Publicly Perform the Work in",MatchSource.DOCS,doc/LICENSE_cc-by-3.0.txt,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/LICENSE_cc-by-3.0.txt
https://github.com/qutip/qutip/tree/v5.0.4/doc/LICENSE_cc-by-3.0.txt:15653,Energy Efficiency,charge,charged,15653,"his License will continue; in full force and effect unless terminated as stated above. 8. Miscellaneous. a. Each time You Distribute or Publicly Perform the Work or a Collection,; the Licensor offers to the recipient a license to the Work on the same; terms and conditions as the license granted to You under this License. b. Each time You Distribute or Publicly Perform an Adaptation, Licensor; offers to the recipient a license to the original Work on the same terms; and conditions as the license granted to You under this License. c. If any provision of this License is invalid or unenforceable under; applicable law, it shall not affect the validity or enforceability of the; remainder of the terms of this License, and without further action by the; parties to this agreement, such provision shall be reformed to the; minimum extent necessary to make such provision valid and enforceable. d. No term or provision of this License shall be deemed waived and no breach; consented to unless such waiver or consent shall be in writing and signed; by the party to be charged with such waiver or consent. e. This License constitutes the entire agreement between the parties with; respect to the Work licensed here. There are no understandings,; agreements or representations with respect to the Work not specified; here. Licensor shall not be bound by any additional provisions that may; appear in any communication from You. This License may not be modified; without the mutual written agreement of the Licensor and You. f. The rights granted under, and the subject matter referenced, in this; License were drafted utilizing the terminology of the Berne Convention; for the Protection of Literary and Artistic Works (as amended on; September 28, 1979), the Rome Convention of 1961, the WIPO Copyright; Treaty of 1996, the WIPO Performances and Phonograms Treaty of 1996 and; the Universal Copyright Convention (as revised on July 24, 1971). These; rights and subject matter take effect in the relevan",MatchSource.DOCS,doc/LICENSE_cc-by-3.0.txt,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/LICENSE_cc-by-3.0.txt
https://github.com/qutip/qutip/tree/v5.0.4/doc/LICENSE_cc-by-3.0.txt:1243,Integrability,synchroniz,synchronization,1243," PROHIBITED. BY EXERCISING ANY RIGHTS TO THE WORK PROVIDED HERE, YOU ACCEPT AND AGREE TO BE; BOUND BY THE TERMS OF THIS LICENSE. TO THE EXTENT THIS LICENSE MAY BE CONSIDERED; TO BE A CONTRACT, THE LICENSOR GRANTS YOU THE RIGHTS CONTAINED HERE IN; CONSIDERATION OF YOUR ACCEPTANCE OF SUCH TERMS AND CONDITIONS. 1. Definitions. a. ""Adaptation"" means a work based upon the Work, or upon the Work and other; pre-existing works, such as a translation, adaptation, derivative work,; arrangement of music or other alterations of a literary or artistic work,; or phonogram or performance and includes cinematographic adaptations or; any other form in which the Work may be recast, transformed, or adapted; including in any form recognizably derived from the original, except that; a work that constitutes a Collection will not be considered an Adaptation; for the purpose of this License. For the avoidance of doubt, where the; Work is a musical work, performance or phonogram, the synchronization of; the Work in timed-relation with a moving image (""synching"") will be; considered an Adaptation for the purpose of this License. b. ""Collection"" means a collection of literary or artistic works, such as; encyclopedias and anthologies, or performances, phonograms or broadcasts,; or other works or subject matter other than works listed in Section 1(f); below, which, by reason of the selection and arrangement of their; contents, constitute intellectual creations, in which the Work is; included in its entirety in unmodified form along with one or more other; contributions, each constituting separate and independent works in; themselves, which together are assembled into a collective whole. A work; that constitutes a Collection will not be considered an Adaptation (as; defined above) for the purposes of this License. c. ""Distribute"" means to make available to the public the original and; copies of the Work or Adaptation, as appropriate, through sale or other; transfer of ownership. d. ""Licensor"" me",MatchSource.DOCS,doc/LICENSE_cc-by-3.0.txt,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/LICENSE_cc-by-3.0.txt
https://github.com/qutip/qutip/tree/v5.0.4/doc/LICENSE_cc-by-3.0.txt:716,Modifiability,adapt,adaptation,716,"THE WORK (AS DEFINED BELOW) IS PROVIDED UNDER THE TERMS OF THIS CREATIVE COMMONS; PUBLIC LICENSE (""CCPL"" OR ""LICENSE""). THE WORK IS PROTECTED BY COPYRIGHT AND/OR; OTHER APPLICABLE LAW. ANY USE OF THE WORK OTHER THAN AS AUTHORIZED UNDER THIS; LICENSE OR COPYRIGHT LAW IS PROHIBITED. BY EXERCISING ANY RIGHTS TO THE WORK PROVIDED HERE, YOU ACCEPT AND AGREE TO BE; BOUND BY THE TERMS OF THIS LICENSE. TO THE EXTENT THIS LICENSE MAY BE CONSIDERED; TO BE A CONTRACT, THE LICENSOR GRANTS YOU THE RIGHTS CONTAINED HERE IN; CONSIDERATION OF YOUR ACCEPTANCE OF SUCH TERMS AND CONDITIONS. 1. Definitions. a. ""Adaptation"" means a work based upon the Work, or upon the Work and other; pre-existing works, such as a translation, adaptation, derivative work,; arrangement of music or other alterations of a literary or artistic work,; or phonogram or performance and includes cinematographic adaptations or; any other form in which the Work may be recast, transformed, or adapted; including in any form recognizably derived from the original, except that; a work that constitutes a Collection will not be considered an Adaptation; for the purpose of this License. For the avoidance of doubt, where the; Work is a musical work, performance or phonogram, the synchronization of; the Work in timed-relation with a moving image (""synching"") will be; considered an Adaptation for the purpose of this License. b. ""Collection"" means a collection of literary or artistic works, such as; encyclopedias and anthologies, or performances, phonograms or broadcasts,; or other works or subject matter other than works listed in Section 1(f); below, which, by reason of the selection and arrangement of their; contents, constitute intellectual creations, in which the Work is; included in its entirety in unmodified form along with one or more other; contributions, each constituting separate and independent works in; themselves, which together are assembled into a collective whole. A work; that constitutes a Collection will no",MatchSource.DOCS,doc/LICENSE_cc-by-3.0.txt,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/LICENSE_cc-by-3.0.txt
https://github.com/qutip/qutip/tree/v5.0.4/doc/LICENSE_cc-by-3.0.txt:878,Modifiability,adapt,adaptations,878,"THE WORK (AS DEFINED BELOW) IS PROVIDED UNDER THE TERMS OF THIS CREATIVE COMMONS; PUBLIC LICENSE (""CCPL"" OR ""LICENSE""). THE WORK IS PROTECTED BY COPYRIGHT AND/OR; OTHER APPLICABLE LAW. ANY USE OF THE WORK OTHER THAN AS AUTHORIZED UNDER THIS; LICENSE OR COPYRIGHT LAW IS PROHIBITED. BY EXERCISING ANY RIGHTS TO THE WORK PROVIDED HERE, YOU ACCEPT AND AGREE TO BE; BOUND BY THE TERMS OF THIS LICENSE. TO THE EXTENT THIS LICENSE MAY BE CONSIDERED; TO BE A CONTRACT, THE LICENSOR GRANTS YOU THE RIGHTS CONTAINED HERE IN; CONSIDERATION OF YOUR ACCEPTANCE OF SUCH TERMS AND CONDITIONS. 1. Definitions. a. ""Adaptation"" means a work based upon the Work, or upon the Work and other; pre-existing works, such as a translation, adaptation, derivative work,; arrangement of music or other alterations of a literary or artistic work,; or phonogram or performance and includes cinematographic adaptations or; any other form in which the Work may be recast, transformed, or adapted; including in any form recognizably derived from the original, except that; a work that constitutes a Collection will not be considered an Adaptation; for the purpose of this License. For the avoidance of doubt, where the; Work is a musical work, performance or phonogram, the synchronization of; the Work in timed-relation with a moving image (""synching"") will be; considered an Adaptation for the purpose of this License. b. ""Collection"" means a collection of literary or artistic works, such as; encyclopedias and anthologies, or performances, phonograms or broadcasts,; or other works or subject matter other than works listed in Section 1(f); below, which, by reason of the selection and arrangement of their; contents, constitute intellectual creations, in which the Work is; included in its entirety in unmodified form along with one or more other; contributions, each constituting separate and independent works in; themselves, which together are assembled into a collective whole. A work; that constitutes a Collection will no",MatchSource.DOCS,doc/LICENSE_cc-by-3.0.txt,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/LICENSE_cc-by-3.0.txt
https://github.com/qutip/qutip/tree/v5.0.4/doc/LICENSE_cc-by-3.0.txt:958,Modifiability,adapt,adapted,958,"THE WORK (AS DEFINED BELOW) IS PROVIDED UNDER THE TERMS OF THIS CREATIVE COMMONS; PUBLIC LICENSE (""CCPL"" OR ""LICENSE""). THE WORK IS PROTECTED BY COPYRIGHT AND/OR; OTHER APPLICABLE LAW. ANY USE OF THE WORK OTHER THAN AS AUTHORIZED UNDER THIS; LICENSE OR COPYRIGHT LAW IS PROHIBITED. BY EXERCISING ANY RIGHTS TO THE WORK PROVIDED HERE, YOU ACCEPT AND AGREE TO BE; BOUND BY THE TERMS OF THIS LICENSE. TO THE EXTENT THIS LICENSE MAY BE CONSIDERED; TO BE A CONTRACT, THE LICENSOR GRANTS YOU THE RIGHTS CONTAINED HERE IN; CONSIDERATION OF YOUR ACCEPTANCE OF SUCH TERMS AND CONDITIONS. 1. Definitions. a. ""Adaptation"" means a work based upon the Work, or upon the Work and other; pre-existing works, such as a translation, adaptation, derivative work,; arrangement of music or other alterations of a literary or artistic work,; or phonogram or performance and includes cinematographic adaptations or; any other form in which the Work may be recast, transformed, or adapted; including in any form recognizably derived from the original, except that; a work that constitutes a Collection will not be considered an Adaptation; for the purpose of this License. For the avoidance of doubt, where the; Work is a musical work, performance or phonogram, the synchronization of; the Work in timed-relation with a moving image (""synching"") will be; considered an Adaptation for the purpose of this License. b. ""Collection"" means a collection of literary or artistic works, such as; encyclopedias and anthologies, or performances, phonograms or broadcasts,; or other works or subject matter other than works listed in Section 1(f); below, which, by reason of the selection and arrangement of their; contents, constitute intellectual creations, in which the Work is; included in its entirety in unmodified form along with one or more other; contributions, each constituting separate and independent works in; themselves, which together are assembled into a collective whole. A work; that constitutes a Collection will no",MatchSource.DOCS,doc/LICENSE_cc-by-3.0.txt,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/LICENSE_cc-by-3.0.txt
https://github.com/qutip/qutip/tree/v5.0.4/doc/LICENSE_cc-by-3.0.txt:837,Performance,perform,performance,837,"THE WORK (AS DEFINED BELOW) IS PROVIDED UNDER THE TERMS OF THIS CREATIVE COMMONS; PUBLIC LICENSE (""CCPL"" OR ""LICENSE""). THE WORK IS PROTECTED BY COPYRIGHT AND/OR; OTHER APPLICABLE LAW. ANY USE OF THE WORK OTHER THAN AS AUTHORIZED UNDER THIS; LICENSE OR COPYRIGHT LAW IS PROHIBITED. BY EXERCISING ANY RIGHTS TO THE WORK PROVIDED HERE, YOU ACCEPT AND AGREE TO BE; BOUND BY THE TERMS OF THIS LICENSE. TO THE EXTENT THIS LICENSE MAY BE CONSIDERED; TO BE A CONTRACT, THE LICENSOR GRANTS YOU THE RIGHTS CONTAINED HERE IN; CONSIDERATION OF YOUR ACCEPTANCE OF SUCH TERMS AND CONDITIONS. 1. Definitions. a. ""Adaptation"" means a work based upon the Work, or upon the Work and other; pre-existing works, such as a translation, adaptation, derivative work,; arrangement of music or other alterations of a literary or artistic work,; or phonogram or performance and includes cinematographic adaptations or; any other form in which the Work may be recast, transformed, or adapted; including in any form recognizably derived from the original, except that; a work that constitutes a Collection will not be considered an Adaptation; for the purpose of this License. For the avoidance of doubt, where the; Work is a musical work, performance or phonogram, the synchronization of; the Work in timed-relation with a moving image (""synching"") will be; considered an Adaptation for the purpose of this License. b. ""Collection"" means a collection of literary or artistic works, such as; encyclopedias and anthologies, or performances, phonograms or broadcasts,; or other works or subject matter other than works listed in Section 1(f); below, which, by reason of the selection and arrangement of their; contents, constitute intellectual creations, in which the Work is; included in its entirety in unmodified form along with one or more other; contributions, each constituting separate and independent works in; themselves, which together are assembled into a collective whole. A work; that constitutes a Collection will no",MatchSource.DOCS,doc/LICENSE_cc-by-3.0.txt,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/LICENSE_cc-by-3.0.txt
https://github.com/qutip/qutip/tree/v5.0.4/doc/LICENSE_cc-by-3.0.txt:1213,Performance,perform,performance,1213," PROHIBITED. BY EXERCISING ANY RIGHTS TO THE WORK PROVIDED HERE, YOU ACCEPT AND AGREE TO BE; BOUND BY THE TERMS OF THIS LICENSE. TO THE EXTENT THIS LICENSE MAY BE CONSIDERED; TO BE A CONTRACT, THE LICENSOR GRANTS YOU THE RIGHTS CONTAINED HERE IN; CONSIDERATION OF YOUR ACCEPTANCE OF SUCH TERMS AND CONDITIONS. 1. Definitions. a. ""Adaptation"" means a work based upon the Work, or upon the Work and other; pre-existing works, such as a translation, adaptation, derivative work,; arrangement of music or other alterations of a literary or artistic work,; or phonogram or performance and includes cinematographic adaptations or; any other form in which the Work may be recast, transformed, or adapted; including in any form recognizably derived from the original, except that; a work that constitutes a Collection will not be considered an Adaptation; for the purpose of this License. For the avoidance of doubt, where the; Work is a musical work, performance or phonogram, the synchronization of; the Work in timed-relation with a moving image (""synching"") will be; considered an Adaptation for the purpose of this License. b. ""Collection"" means a collection of literary or artistic works, such as; encyclopedias and anthologies, or performances, phonograms or broadcasts,; or other works or subject matter other than works listed in Section 1(f); below, which, by reason of the selection and arrangement of their; contents, constitute intellectual creations, in which the Work is; included in its entirety in unmodified form along with one or more other; contributions, each constituting separate and independent works in; themselves, which together are assembled into a collective whole. A work; that constitutes a Collection will not be considered an Adaptation (as; defined above) for the purposes of this License. c. ""Distribute"" means to make available to the public the original and; copies of the Work or Adaptation, as appropriate, through sale or other; transfer of ownership. d. ""Licensor"" me",MatchSource.DOCS,doc/LICENSE_cc-by-3.0.txt,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/LICENSE_cc-by-3.0.txt
https://github.com/qutip/qutip/tree/v5.0.4/doc/LICENSE_cc-by-3.0.txt:1499,Performance,perform,performances,1499,"pre-existing works, such as a translation, adaptation, derivative work,; arrangement of music or other alterations of a literary or artistic work,; or phonogram or performance and includes cinematographic adaptations or; any other form in which the Work may be recast, transformed, or adapted; including in any form recognizably derived from the original, except that; a work that constitutes a Collection will not be considered an Adaptation; for the purpose of this License. For the avoidance of doubt, where the; Work is a musical work, performance or phonogram, the synchronization of; the Work in timed-relation with a moving image (""synching"") will be; considered an Adaptation for the purpose of this License. b. ""Collection"" means a collection of literary or artistic works, such as; encyclopedias and anthologies, or performances, phonograms or broadcasts,; or other works or subject matter other than works listed in Section 1(f); below, which, by reason of the selection and arrangement of their; contents, constitute intellectual creations, in which the Work is; included in its entirety in unmodified form along with one or more other; contributions, each constituting separate and independent works in; themselves, which together are assembled into a collective whole. A work; that constitutes a Collection will not be considered an Adaptation (as; defined above) for the purposes of this License. c. ""Distribute"" means to make available to the public the original and; copies of the Work or Adaptation, as appropriate, through sale or other; transfer of ownership. d. ""Licensor"" means the individual, individuals, entity or entities that; offer(s) the Work under the terms of this License. e. ""Original Author"" means, in the case of a literary or artistic work, the; individual, individuals, entity or entities who created the Work or if no; individual or entity can be identified, the publisher; and in addition; (i) in the case of a performance the actors, singers, musicians, dancers",MatchSource.DOCS,doc/LICENSE_cc-by-3.0.txt,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/LICENSE_cc-by-3.0.txt
https://github.com/qutip/qutip/tree/v5.0.4/doc/LICENSE_cc-by-3.0.txt:2623,Performance,perform,performance,2623,"creations, in which the Work is; included in its entirety in unmodified form along with one or more other; contributions, each constituting separate and independent works in; themselves, which together are assembled into a collective whole. A work; that constitutes a Collection will not be considered an Adaptation (as; defined above) for the purposes of this License. c. ""Distribute"" means to make available to the public the original and; copies of the Work or Adaptation, as appropriate, through sale or other; transfer of ownership. d. ""Licensor"" means the individual, individuals, entity or entities that; offer(s) the Work under the terms of this License. e. ""Original Author"" means, in the case of a literary or artistic work, the; individual, individuals, entity or entities who created the Work or if no; individual or entity can be identified, the publisher; and in addition; (i) in the case of a performance the actors, singers, musicians, dancers,; and other persons who act, sing, deliver, declaim, play in, interpret or; otherwise perform literary or artistic works or expressions of folklore;; (ii) in the case of a phonogram the producer being the person or legal; entity who first fixes the sounds of a performance or other sounds; and,; (iii) in the case of broadcasts, the organization that transmits the; broadcast. f. ""Work"" means the literary and/or artistic work offered under the terms of; this License including without limitation any production in the literary,; scientific and artistic domain, whatever may be the mode or form of its; expression including digital form, such as a book, pamphlet and other; writing; a lecture, address, sermon or other work of the same nature; a; dramatic or dramatico-musical work; a choreographic work or entertainment; in dumb show; a musical composition with or without words; a; cinematographic work to which are assimilated works expressed by a; process analogous to cinematography; a work of drawing, painting,; architecture, sculptur",MatchSource.DOCS,doc/LICENSE_cc-by-3.0.txt,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/LICENSE_cc-by-3.0.txt
https://github.com/qutip/qutip/tree/v5.0.4/doc/LICENSE_cc-by-3.0.txt:2761,Performance,perform,perform,2761,"creations, in which the Work is; included in its entirety in unmodified form along with one or more other; contributions, each constituting separate and independent works in; themselves, which together are assembled into a collective whole. A work; that constitutes a Collection will not be considered an Adaptation (as; defined above) for the purposes of this License. c. ""Distribute"" means to make available to the public the original and; copies of the Work or Adaptation, as appropriate, through sale or other; transfer of ownership. d. ""Licensor"" means the individual, individuals, entity or entities that; offer(s) the Work under the terms of this License. e. ""Original Author"" means, in the case of a literary or artistic work, the; individual, individuals, entity or entities who created the Work or if no; individual or entity can be identified, the publisher; and in addition; (i) in the case of a performance the actors, singers, musicians, dancers,; and other persons who act, sing, deliver, declaim, play in, interpret or; otherwise perform literary or artistic works or expressions of folklore;; (ii) in the case of a phonogram the producer being the person or legal; entity who first fixes the sounds of a performance or other sounds; and,; (iii) in the case of broadcasts, the organization that transmits the; broadcast. f. ""Work"" means the literary and/or artistic work offered under the terms of; this License including without limitation any production in the literary,; scientific and artistic domain, whatever may be the mode or form of its; expression including digital form, such as a book, pamphlet and other; writing; a lecture, address, sermon or other work of the same nature; a; dramatic or dramatico-musical work; a choreographic work or entertainment; in dumb show; a musical composition with or without words; a; cinematographic work to which are assimilated works expressed by a; process analogous to cinematography; a work of drawing, painting,; architecture, sculptur",MatchSource.DOCS,doc/LICENSE_cc-by-3.0.txt,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/LICENSE_cc-by-3.0.txt
https://github.com/qutip/qutip/tree/v5.0.4/doc/LICENSE_cc-by-3.0.txt:2936,Performance,perform,performance,2936,"creations, in which the Work is; included in its entirety in unmodified form along with one or more other; contributions, each constituting separate and independent works in; themselves, which together are assembled into a collective whole. A work; that constitutes a Collection will not be considered an Adaptation (as; defined above) for the purposes of this License. c. ""Distribute"" means to make available to the public the original and; copies of the Work or Adaptation, as appropriate, through sale or other; transfer of ownership. d. ""Licensor"" means the individual, individuals, entity or entities that; offer(s) the Work under the terms of this License. e. ""Original Author"" means, in the case of a literary or artistic work, the; individual, individuals, entity or entities who created the Work or if no; individual or entity can be identified, the publisher; and in addition; (i) in the case of a performance the actors, singers, musicians, dancers,; and other persons who act, sing, deliver, declaim, play in, interpret or; otherwise perform literary or artistic works or expressions of folklore;; (ii) in the case of a phonogram the producer being the person or legal; entity who first fixes the sounds of a performance or other sounds; and,; (iii) in the case of broadcasts, the organization that transmits the; broadcast. f. ""Work"" means the literary and/or artistic work offered under the terms of; this License including without limitation any production in the literary,; scientific and artistic domain, whatever may be the mode or form of its; expression including digital form, such as a book, pamphlet and other; writing; a lecture, address, sermon or other work of the same nature; a; dramatic or dramatico-musical work; a choreographic work or entertainment; in dumb show; a musical composition with or without words; a; cinematographic work to which are assimilated works expressed by a; process analogous to cinematography; a work of drawing, painting,; architecture, sculptur",MatchSource.DOCS,doc/LICENSE_cc-by-3.0.txt,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/LICENSE_cc-by-3.0.txt
https://github.com/qutip/qutip/tree/v5.0.4/doc/LICENSE_cc-by-3.0.txt:3995,Performance,perform,performance,3995,"singers, musicians, dancers,; and other persons who act, sing, deliver, declaim, play in, interpret or; otherwise perform literary or artistic works or expressions of folklore;; (ii) in the case of a phonogram the producer being the person or legal; entity who first fixes the sounds of a performance or other sounds; and,; (iii) in the case of broadcasts, the organization that transmits the; broadcast. f. ""Work"" means the literary and/or artistic work offered under the terms of; this License including without limitation any production in the literary,; scientific and artistic domain, whatever may be the mode or form of its; expression including digital form, such as a book, pamphlet and other; writing; a lecture, address, sermon or other work of the same nature; a; dramatic or dramatico-musical work; a choreographic work or entertainment; in dumb show; a musical composition with or without words; a; cinematographic work to which are assimilated works expressed by a; process analogous to cinematography; a work of drawing, painting,; architecture, sculpture, engraving or lithography; a photographic work to; which are assimilated works expressed by a process analogous to; photography; a work of applied art; an illustration, map, plan, sketch or; three-dimensional work relative to geography, topography, architecture or; science; a performance; a broadcast; a phonogram; a compilation of data; to the extent it is protected as a copyrightable work; or a work; performed by a variety or circus performer to the extent it is not; otherwise considered a literary or artistic work. g. ""You"" means an individual or entity exercising rights under this License; who has not previously violated the terms of this License with respect to; the Work, or who has received express permission from the Licensor to; exercise rights under this License despite a previous violation. h. ""Publicly Perform"" means to perform public recitations of the Work and to; communicate to the public those public r",MatchSource.DOCS,doc/LICENSE_cc-by-3.0.txt,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/LICENSE_cc-by-3.0.txt
https://github.com/qutip/qutip/tree/v5.0.4/doc/LICENSE_cc-by-3.0.txt:4123,Performance,perform,performed,4123,"singers, musicians, dancers,; and other persons who act, sing, deliver, declaim, play in, interpret or; otherwise perform literary or artistic works or expressions of folklore;; (ii) in the case of a phonogram the producer being the person or legal; entity who first fixes the sounds of a performance or other sounds; and,; (iii) in the case of broadcasts, the organization that transmits the; broadcast. f. ""Work"" means the literary and/or artistic work offered under the terms of; this License including without limitation any production in the literary,; scientific and artistic domain, whatever may be the mode or form of its; expression including digital form, such as a book, pamphlet and other; writing; a lecture, address, sermon or other work of the same nature; a; dramatic or dramatico-musical work; a choreographic work or entertainment; in dumb show; a musical composition with or without words; a; cinematographic work to which are assimilated works expressed by a; process analogous to cinematography; a work of drawing, painting,; architecture, sculpture, engraving or lithography; a photographic work to; which are assimilated works expressed by a process analogous to; photography; a work of applied art; an illustration, map, plan, sketch or; three-dimensional work relative to geography, topography, architecture or; science; a performance; a broadcast; a phonogram; a compilation of data; to the extent it is protected as a copyrightable work; or a work; performed by a variety or circus performer to the extent it is not; otherwise considered a literary or artistic work. g. ""You"" means an individual or entity exercising rights under this License; who has not previously violated the terms of this License with respect to; the Work, or who has received express permission from the Licensor to; exercise rights under this License despite a previous violation. h. ""Publicly Perform"" means to perform public recitations of the Work and to; communicate to the public those public r",MatchSource.DOCS,doc/LICENSE_cc-by-3.0.txt,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/LICENSE_cc-by-3.0.txt
https://github.com/qutip/qutip/tree/v5.0.4/doc/LICENSE_cc-by-3.0.txt:4156,Performance,perform,performer,4156,"singers, musicians, dancers,; and other persons who act, sing, deliver, declaim, play in, interpret or; otherwise perform literary or artistic works or expressions of folklore;; (ii) in the case of a phonogram the producer being the person or legal; entity who first fixes the sounds of a performance or other sounds; and,; (iii) in the case of broadcasts, the organization that transmits the; broadcast. f. ""Work"" means the literary and/or artistic work offered under the terms of; this License including without limitation any production in the literary,; scientific and artistic domain, whatever may be the mode or form of its; expression including digital form, such as a book, pamphlet and other; writing; a lecture, address, sermon or other work of the same nature; a; dramatic or dramatico-musical work; a choreographic work or entertainment; in dumb show; a musical composition with or without words; a; cinematographic work to which are assimilated works expressed by a; process analogous to cinematography; a work of drawing, painting,; architecture, sculpture, engraving or lithography; a photographic work to; which are assimilated works expressed by a process analogous to; photography; a work of applied art; an illustration, map, plan, sketch or; three-dimensional work relative to geography, topography, architecture or; science; a performance; a broadcast; a phonogram; a compilation of data; to the extent it is protected as a copyrightable work; or a work; performed by a variety or circus performer to the extent it is not; otherwise considered a literary or artistic work. g. ""You"" means an individual or entity exercising rights under this License; who has not previously violated the terms of this License with respect to; the Work, or who has received express permission from the Licensor to; exercise rights under this License despite a previous violation. h. ""Publicly Perform"" means to perform public recitations of the Work and to; communicate to the public those public r",MatchSource.DOCS,doc/LICENSE_cc-by-3.0.txt,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/LICENSE_cc-by-3.0.txt
https://github.com/qutip/qutip/tree/v5.0.4/doc/LICENSE_cc-by-3.0.txt:4560,Performance,perform,perform,4560,"rk of applied art; an illustration, map, plan, sketch or; three-dimensional work relative to geography, topography, architecture or; science; a performance; a broadcast; a phonogram; a compilation of data; to the extent it is protected as a copyrightable work; or a work; performed by a variety or circus performer to the extent it is not; otherwise considered a literary or artistic work. g. ""You"" means an individual or entity exercising rights under this License; who has not previously violated the terms of this License with respect to; the Work, or who has received express permission from the Licensor to; exercise rights under this License despite a previous violation. h. ""Publicly Perform"" means to perform public recitations of the Work and to; communicate to the public those public recitations, by any means or; process, including by wire or wireless means or public digital; performances; to make available to the public Works in such a way that; members of the public may access these Works from a place and at a place; individually chosen by them; to perform the Work to the public by any; means or process and the communication to the public of the performances; of the Work, including by public digital performance; to broadcast and; rebroadcast the Work by any means including signs, sounds or images. i. ""Reproduce"" means to make copies of the Work by any means including; without limitation by sound or visual recordings and the right of; fixation and reproducing fixations of the Work, including storage of a; protected performance or phonogram in digital form or other electronic; medium. 2. Fair Dealing Rights. Nothing in this License is intended to reduce, limit, or; restrict any uses free from copyright or rights arising from limitations or; exceptions that are provided for in connection with the copyright protection; under copyright law or other applicable laws. 3. License Grant. Subject to the terms and conditions of this License, Licensor; hereby grants You a worl",MatchSource.DOCS,doc/LICENSE_cc-by-3.0.txt,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/LICENSE_cc-by-3.0.txt
https://github.com/qutip/qutip/tree/v5.0.4/doc/LICENSE_cc-by-3.0.txt:4740,Performance,perform,performances,4740,"rk of applied art; an illustration, map, plan, sketch or; three-dimensional work relative to geography, topography, architecture or; science; a performance; a broadcast; a phonogram; a compilation of data; to the extent it is protected as a copyrightable work; or a work; performed by a variety or circus performer to the extent it is not; otherwise considered a literary or artistic work. g. ""You"" means an individual or entity exercising rights under this License; who has not previously violated the terms of this License with respect to; the Work, or who has received express permission from the Licensor to; exercise rights under this License despite a previous violation. h. ""Publicly Perform"" means to perform public recitations of the Work and to; communicate to the public those public recitations, by any means or; process, including by wire or wireless means or public digital; performances; to make available to the public Works in such a way that; members of the public may access these Works from a place and at a place; individually chosen by them; to perform the Work to the public by any; means or process and the communication to the public of the performances; of the Work, including by public digital performance; to broadcast and; rebroadcast the Work by any means including signs, sounds or images. i. ""Reproduce"" means to make copies of the Work by any means including; without limitation by sound or visual recordings and the right of; fixation and reproducing fixations of the Work, including storage of a; protected performance or phonogram in digital form or other electronic; medium. 2. Fair Dealing Rights. Nothing in this License is intended to reduce, limit, or; restrict any uses free from copyright or rights arising from limitations or; exceptions that are provided for in connection with the copyright protection; under copyright law or other applicable laws. 3. License Grant. Subject to the terms and conditions of this License, Licensor; hereby grants You a worl",MatchSource.DOCS,doc/LICENSE_cc-by-3.0.txt,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/LICENSE_cc-by-3.0.txt
https://github.com/qutip/qutip/tree/v5.0.4/doc/LICENSE_cc-by-3.0.txt:4918,Performance,perform,perform,4918,"rk of applied art; an illustration, map, plan, sketch or; three-dimensional work relative to geography, topography, architecture or; science; a performance; a broadcast; a phonogram; a compilation of data; to the extent it is protected as a copyrightable work; or a work; performed by a variety or circus performer to the extent it is not; otherwise considered a literary or artistic work. g. ""You"" means an individual or entity exercising rights under this License; who has not previously violated the terms of this License with respect to; the Work, or who has received express permission from the Licensor to; exercise rights under this License despite a previous violation. h. ""Publicly Perform"" means to perform public recitations of the Work and to; communicate to the public those public recitations, by any means or; process, including by wire or wireless means or public digital; performances; to make available to the public Works in such a way that; members of the public may access these Works from a place and at a place; individually chosen by them; to perform the Work to the public by any; means or process and the communication to the public of the performances; of the Work, including by public digital performance; to broadcast and; rebroadcast the Work by any means including signs, sounds or images. i. ""Reproduce"" means to make copies of the Work by any means including; without limitation by sound or visual recordings and the right of; fixation and reproducing fixations of the Work, including storage of a; protected performance or phonogram in digital form or other electronic; medium. 2. Fair Dealing Rights. Nothing in this License is intended to reduce, limit, or; restrict any uses free from copyright or rights arising from limitations or; exceptions that are provided for in connection with the copyright protection; under copyright law or other applicable laws. 3. License Grant. Subject to the terms and conditions of this License, Licensor; hereby grants You a worl",MatchSource.DOCS,doc/LICENSE_cc-by-3.0.txt,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/LICENSE_cc-by-3.0.txt
https://github.com/qutip/qutip/tree/v5.0.4/doc/LICENSE_cc-by-3.0.txt:5017,Performance,perform,performances,5017,"rk of applied art; an illustration, map, plan, sketch or; three-dimensional work relative to geography, topography, architecture or; science; a performance; a broadcast; a phonogram; a compilation of data; to the extent it is protected as a copyrightable work; or a work; performed by a variety or circus performer to the extent it is not; otherwise considered a literary or artistic work. g. ""You"" means an individual or entity exercising rights under this License; who has not previously violated the terms of this License with respect to; the Work, or who has received express permission from the Licensor to; exercise rights under this License despite a previous violation. h. ""Publicly Perform"" means to perform public recitations of the Work and to; communicate to the public those public recitations, by any means or; process, including by wire or wireless means or public digital; performances; to make available to the public Works in such a way that; members of the public may access these Works from a place and at a place; individually chosen by them; to perform the Work to the public by any; means or process and the communication to the public of the performances; of the Work, including by public digital performance; to broadcast and; rebroadcast the Work by any means including signs, sounds or images. i. ""Reproduce"" means to make copies of the Work by any means including; without limitation by sound or visual recordings and the right of; fixation and reproducing fixations of the Work, including storage of a; protected performance or phonogram in digital form or other electronic; medium. 2. Fair Dealing Rights. Nothing in this License is intended to reduce, limit, or; restrict any uses free from copyright or rights arising from limitations or; exceptions that are provided for in connection with the copyright protection; under copyright law or other applicable laws. 3. License Grant. Subject to the terms and conditions of this License, Licensor; hereby grants You a worl",MatchSource.DOCS,doc/LICENSE_cc-by-3.0.txt,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/LICENSE_cc-by-3.0.txt
https://github.com/qutip/qutip/tree/v5.0.4/doc/LICENSE_cc-by-3.0.txt:5072,Performance,perform,performance,5072,"rk of applied art; an illustration, map, plan, sketch or; three-dimensional work relative to geography, topography, architecture or; science; a performance; a broadcast; a phonogram; a compilation of data; to the extent it is protected as a copyrightable work; or a work; performed by a variety or circus performer to the extent it is not; otherwise considered a literary or artistic work. g. ""You"" means an individual or entity exercising rights under this License; who has not previously violated the terms of this License with respect to; the Work, or who has received express permission from the Licensor to; exercise rights under this License despite a previous violation. h. ""Publicly Perform"" means to perform public recitations of the Work and to; communicate to the public those public recitations, by any means or; process, including by wire or wireless means or public digital; performances; to make available to the public Works in such a way that; members of the public may access these Works from a place and at a place; individually chosen by them; to perform the Work to the public by any; means or process and the communication to the public of the performances; of the Work, including by public digital performance; to broadcast and; rebroadcast the Work by any means including signs, sounds or images. i. ""Reproduce"" means to make copies of the Work by any means including; without limitation by sound or visual recordings and the right of; fixation and reproducing fixations of the Work, including storage of a; protected performance or phonogram in digital form or other electronic; medium. 2. Fair Dealing Rights. Nothing in this License is intended to reduce, limit, or; restrict any uses free from copyright or rights arising from limitations or; exceptions that are provided for in connection with the copyright protection; under copyright law or other applicable laws. 3. License Grant. Subject to the terms and conditions of this License, Licensor; hereby grants You a worl",MatchSource.DOCS,doc/LICENSE_cc-by-3.0.txt,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/LICENSE_cc-by-3.0.txt
https://github.com/qutip/qutip/tree/v5.0.4/doc/LICENSE_cc-by-3.0.txt:5393,Performance,perform,performance,5393,"who has not previously violated the terms of this License with respect to; the Work, or who has received express permission from the Licensor to; exercise rights under this License despite a previous violation. h. ""Publicly Perform"" means to perform public recitations of the Work and to; communicate to the public those public recitations, by any means or; process, including by wire or wireless means or public digital; performances; to make available to the public Works in such a way that; members of the public may access these Works from a place and at a place; individually chosen by them; to perform the Work to the public by any; means or process and the communication to the public of the performances; of the Work, including by public digital performance; to broadcast and; rebroadcast the Work by any means including signs, sounds or images. i. ""Reproduce"" means to make copies of the Work by any means including; without limitation by sound or visual recordings and the right of; fixation and reproducing fixations of the Work, including storage of a; protected performance or phonogram in digital form or other electronic; medium. 2. Fair Dealing Rights. Nothing in this License is intended to reduce, limit, or; restrict any uses free from copyright or rights arising from limitations or; exceptions that are provided for in connection with the copyright protection; under copyright law or other applicable laws. 3. License Grant. Subject to the terms and conditions of this License, Licensor; hereby grants You a worldwide, royalty-free, non-exclusive, perpetual (for; the duration of the applicable copyright) license to exercise the rights in; the Work as stated below:. a. to Reproduce the Work, to incorporate the Work into one or more; Collections, and to Reproduce the Work as incorporated in the; Collections;. b. to create and Reproduce Adaptations provided that any such Adaptation,; including any translation in any medium, takes reasonable steps to; clearly label, demarcat",MatchSource.DOCS,doc/LICENSE_cc-by-3.0.txt,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/LICENSE_cc-by-3.0.txt
https://github.com/qutip/qutip/tree/v5.0.4/doc/LICENSE_cc-by-3.0.txt:1158,Safety,avoid,avoidance,1158," PROHIBITED. BY EXERCISING ANY RIGHTS TO THE WORK PROVIDED HERE, YOU ACCEPT AND AGREE TO BE; BOUND BY THE TERMS OF THIS LICENSE. TO THE EXTENT THIS LICENSE MAY BE CONSIDERED; TO BE A CONTRACT, THE LICENSOR GRANTS YOU THE RIGHTS CONTAINED HERE IN; CONSIDERATION OF YOUR ACCEPTANCE OF SUCH TERMS AND CONDITIONS. 1. Definitions. a. ""Adaptation"" means a work based upon the Work, or upon the Work and other; pre-existing works, such as a translation, adaptation, derivative work,; arrangement of music or other alterations of a literary or artistic work,; or phonogram or performance and includes cinematographic adaptations or; any other form in which the Work may be recast, transformed, or adapted; including in any form recognizably derived from the original, except that; a work that constitutes a Collection will not be considered an Adaptation; for the purpose of this License. For the avoidance of doubt, where the; Work is a musical work, performance or phonogram, the synchronization of; the Work in timed-relation with a moving image (""synching"") will be; considered an Adaptation for the purpose of this License. b. ""Collection"" means a collection of literary or artistic works, such as; encyclopedias and anthologies, or performances, phonograms or broadcasts,; or other works or subject matter other than works listed in Section 1(f); below, which, by reason of the selection and arrangement of their; contents, constitute intellectual creations, in which the Work is; included in its entirety in unmodified form along with one or more other; contributions, each constituting separate and independent works in; themselves, which together are assembled into a collective whole. A work; that constitutes a Collection will not be considered an Adaptation (as; defined above) for the purposes of this License. c. ""Distribute"" means to make available to the public the original and; copies of the Work or Adaptation, as appropriate, through sale or other; transfer of ownership. d. ""Licensor"" me",MatchSource.DOCS,doc/LICENSE_cc-by-3.0.txt,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/LICENSE_cc-by-3.0.txt
https://github.com/qutip/qutip/tree/v5.0.4/doc/LICENSE_cc-by-3.0.txt:6722,Safety,avoid,avoidance,6722,"r applicable laws. 3. License Grant. Subject to the terms and conditions of this License, Licensor; hereby grants You a worldwide, royalty-free, non-exclusive, perpetual (for; the duration of the applicable copyright) license to exercise the rights in; the Work as stated below:. a. to Reproduce the Work, to incorporate the Work into one or more; Collections, and to Reproduce the Work as incorporated in the; Collections;. b. to create and Reproduce Adaptations provided that any such Adaptation,; including any translation in any medium, takes reasonable steps to; clearly label, demarcate or otherwise identify that changes were made to; the original Work. For example, a translation could be marked ""The; original work was translated from English to Spanish,"" or a modification; could indicate ""The original work has been modified."";. c. to Distribute and Publicly Perform the Work including as incorporated in; Collections; and,. d. to Distribute and Publicly Perform Adaptations. For the avoidance of doubt:. i. Non-waivable Compulsory License Schemes. In those jurisdictions in; which the right to collect royalties through any statutory or; compulsory licensing scheme cannot be waived, the Licensor reserves; the exclusive right to collect such royalties for any exercise by You; of the rights granted under this License;. ii. Waivable Compulsory License Schemes. In those jurisdictions in which; the right to collect royalties through any statutory or compulsory; licensing scheme can be waived, the Licensor waives the exclusive; right to collect such royalties for any exercise by You of the; rights granted under this License; and,. iii. Voluntary License Schemes. The Licensor waives the right to collect; royalties, whether individually or, in the event that the Licensor; is a member of a collecting society that administers voluntary; licensing schemes, via that society, from any exercise by You of; the rights granted under this License. The above rights may be exercised in all me",MatchSource.DOCS,doc/LICENSE_cc-by-3.0.txt,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/LICENSE_cc-by-3.0.txt
https://github.com/qutip/qutip/tree/v5.0.4/doc/LICENSE_cc-by-3.0.txt:11180,Safety,avoid,avoidance,11180,"uch URI does not refer to the copyright notice or; licensing information for the Work; and (iv) , consistent with Section; 3(b), in the case of an Adaptation, a credit identifying the use of the; Work in the Adaptation (e.g., ""French translation of the Work by Original; Author,"" or ""Screenplay based on original Work by Original Author""). The; credit required by this Section 4 (b) may be implemented in any; reasonable manner; provided, however, that in the case of a Adaptation or; Collection, at a minimum such credit will appear, if a credit for all; contributing authors of the Adaptation or Collection appears, then as; part of these credits and in a manner at least as prominent as the; credits for the other contributing authors. For the avoidance of doubt,; You may only use the credit required by this Section for the purpose of; attribution in the manner set out above and, by exercising Your rights; under this License, You may not implicitly or explicitly assert or imply; any connection with, sponsorship or endorsement by the Original Author,; Licensor and/or Attribution Parties, as appropriate, of You or Your use; of the Work, without the separate, express prior written permission of; the Original Author, Licensor and/or Attribution Parties. c. Except as otherwise agreed in writing by the Licensor or as may be; otherwise permitted by applicable law, if You Reproduce, Distribute or; Publicly Perform the Work either by itself or as part of any Adaptations; or Collections, You must not distort, mutilate, modify or take other; derogatory action in relation to the Work which would be prejudicial to; the Original Author's honor or reputation. Licensor agrees that in those; jurisdictions (e.g. Japan), in which any exercise of the right granted in; Section 3(b) of this License (the right to make Adaptations) would be; deemed to be a distortion, mutilation, modification or other derogatory; action prejudicial to the Original Author's honor and reputation, the; Licensor will",MatchSource.DOCS,doc/LICENSE_cc-by-3.0.txt,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/LICENSE_cc-by-3.0.txt
https://github.com/qutip/qutip/tree/v5.0.4/doc/LICENSE_cc-by-3.0.txt:4838,Security,access,access,4838,"rk of applied art; an illustration, map, plan, sketch or; three-dimensional work relative to geography, topography, architecture or; science; a performance; a broadcast; a phonogram; a compilation of data; to the extent it is protected as a copyrightable work; or a work; performed by a variety or circus performer to the extent it is not; otherwise considered a literary or artistic work. g. ""You"" means an individual or entity exercising rights under this License; who has not previously violated the terms of this License with respect to; the Work, or who has received express permission from the Licensor to; exercise rights under this License despite a previous violation. h. ""Publicly Perform"" means to perform public recitations of the Work and to; communicate to the public those public recitations, by any means or; process, including by wire or wireless means or public digital; performances; to make available to the public Works in such a way that; members of the public may access these Works from a place and at a place; individually chosen by them; to perform the Work to the public by any; means or process and the communication to the public of the performances; of the Work, including by public digital performance; to broadcast and; rebroadcast the Work by any means including signs, sounds or images. i. ""Reproduce"" means to make copies of the Work by any means including; without limitation by sound or visual recordings and the right of; fixation and reproducing fixations of the Work, including storage of a; protected performance or phonogram in digital form or other electronic; medium. 2. Fair Dealing Rights. Nothing in this License is intended to reduce, limit, or; restrict any uses free from copyright or rights arising from limitations or; exceptions that are provided for in connection with the copyright protection; under copyright law or other applicable laws. 3. License Grant. Subject to the terms and conditions of this License, Licensor; hereby grants You a worl",MatchSource.DOCS,doc/LICENSE_cc-by-3.0.txt,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/LICENSE_cc-by-3.0.txt
https://github.com/qutip/qutip/tree/v5.0.4/doc/LICENSE_cc-by-3.0.txt:11403,Testability,assert,assert,11403,"uch URI does not refer to the copyright notice or; licensing information for the Work; and (iv) , consistent with Section; 3(b), in the case of an Adaptation, a credit identifying the use of the; Work in the Adaptation (e.g., ""French translation of the Work by Original; Author,"" or ""Screenplay based on original Work by Original Author""). The; credit required by this Section 4 (b) may be implemented in any; reasonable manner; provided, however, that in the case of a Adaptation or; Collection, at a minimum such credit will appear, if a credit for all; contributing authors of the Adaptation or Collection appears, then as; part of these credits and in a manner at least as prominent as the; credits for the other contributing authors. For the avoidance of doubt,; You may only use the credit required by this Section for the purpose of; attribution in the manner set out above and, by exercising Your rights; under this License, You may not implicitly or explicitly assert or imply; any connection with, sponsorship or endorsement by the Original Author,; Licensor and/or Attribution Parties, as appropriate, of You or Your use; of the Work, without the separate, express prior written permission of; the Original Author, Licensor and/or Attribution Parties. c. Except as otherwise agreed in writing by the Licensor or as may be; otherwise permitted by applicable law, if You Reproduce, Distribute or; Publicly Perform the Work either by itself or as part of any Adaptations; or Collections, You must not distort, mutilate, modify or take other; derogatory action in relation to the Work which would be prejudicial to; the Original Author's honor or reputation. Licensor agrees that in those; jurisdictions (e.g. Japan), in which any exercise of the right granted in; Section 3(b) of this License (the right to make Adaptations) would be; deemed to be a distortion, mutilation, modification or other derogatory; action prejudicial to the Original Author's honor and reputation, the; Licensor will",MatchSource.DOCS,doc/LICENSE_cc-by-3.0.txt,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/LICENSE_cc-by-3.0.txt
https://github.com/qutip/qutip/tree/v5.0.4/doc/LICENSE_cc-by-3.0.txt:12447,Testability,assert,assert,12447,"ply; any connection with, sponsorship or endorsement by the Original Author,; Licensor and/or Attribution Parties, as appropriate, of You or Your use; of the Work, without the separate, express prior written permission of; the Original Author, Licensor and/or Attribution Parties. c. Except as otherwise agreed in writing by the Licensor or as may be; otherwise permitted by applicable law, if You Reproduce, Distribute or; Publicly Perform the Work either by itself or as part of any Adaptations; or Collections, You must not distort, mutilate, modify or take other; derogatory action in relation to the Work which would be prejudicial to; the Original Author's honor or reputation. Licensor agrees that in those; jurisdictions (e.g. Japan), in which any exercise of the right granted in; Section 3(b) of this License (the right to make Adaptations) would be; deemed to be a distortion, mutilation, modification or other derogatory; action prejudicial to the Original Author's honor and reputation, the; Licensor will waive or not assert, as appropriate, this Section, to the; fullest extent permitted by the applicable national law, to enable You to; reasonably exercise Your right under Section 3(b) of this License (right; to make Adaptations) but not otherwise. 5. Representations, Warranties and Disclaimer. UNLESS OTHERWISE MUTUALLY AGREED TO BY THE PARTIES IN WRITING, LICENSOR; OFFERS THE WORK AS-IS AND MAKES NO REPRESENTATIONS OR WARRANTIES OF ANY KIND; CONCERNING THE WORK, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, INCLUDING,; WITHOUT LIMITATION, WARRANTIES OF TITLE, MERCHANTIBILITY, FITNESS FOR A; PARTICULAR PURPOSE, NONINFRINGEMENT, OR THE ABSENCE OF LATENT OR OTHER; DEFECTS, ACCURACY, OR THE PRESENCE OF ABSENCE OF ERRORS, WHETHER OR NOT; DISCOVERABLE. SOME JURISDICTIONS DO NOT ALLOW THE EXCLUSION OF IMPLIED; WARRANTIES, SO SUCH EXCLUSION MAY NOT APPLY TO YOU. 6. Limitation on Liability. EXCEPT TO THE EXTENT REQUIRED BY APPLICABLE LAW, IN; NO EVENT WILL LICENSOR BE LIABLE TO Y",MatchSource.DOCS,doc/LICENSE_cc-by-3.0.txt,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/LICENSE_cc-by-3.0.txt
https://github.com/qutip/qutip/tree/v5.0.4/doc/LICENSE_cc-by-3.0.txt:6295,Usability,clear,clearly,6295,"d or visual recordings and the right of; fixation and reproducing fixations of the Work, including storage of a; protected performance or phonogram in digital form or other electronic; medium. 2. Fair Dealing Rights. Nothing in this License is intended to reduce, limit, or; restrict any uses free from copyright or rights arising from limitations or; exceptions that are provided for in connection with the copyright protection; under copyright law or other applicable laws. 3. License Grant. Subject to the terms and conditions of this License, Licensor; hereby grants You a worldwide, royalty-free, non-exclusive, perpetual (for; the duration of the applicable copyright) license to exercise the rights in; the Work as stated below:. a. to Reproduce the Work, to incorporate the Work into one or more; Collections, and to Reproduce the Work as incorporated in the; Collections;. b. to create and Reproduce Adaptations provided that any such Adaptation,; including any translation in any medium, takes reasonable steps to; clearly label, demarcate or otherwise identify that changes were made to; the original Work. For example, a translation could be marked ""The; original work was translated from English to Spanish,"" or a modification; could indicate ""The original work has been modified."";. c. to Distribute and Publicly Perform the Work including as incorporated in; Collections; and,. d. to Distribute and Publicly Perform Adaptations. For the avoidance of doubt:. i. Non-waivable Compulsory License Schemes. In those jurisdictions in; which the right to collect royalties through any statutory or; compulsory licensing scheme cannot be waived, the Licensor reserves; the exclusive right to collect such royalties for any exercise by You; of the rights granted under this License;. ii. Waivable Compulsory License Schemes. In those jurisdictions in which; the right to collect royalties through any statutory or compulsory; licensing scheme can be waived, the Licensor waives the exclusive; ri",MatchSource.DOCS,doc/LICENSE_cc-by-3.0.txt,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/LICENSE_cc-by-3.0.txt
https://github.com/qutip/qutip/tree/v5.0.4/doc/templates/layout.html:37,Modifiability,extend,extends,37,"{# Import the theme's layout. #}; {% extends ""!layout.html"" %}. {# Custom CSS overrides #}; {% set bootswatch_css_custom = ['_static/site.css'] %}",MatchSource.DOCS,doc/templates/layout.html,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/templates/layout.html
https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.html:70,Availability,error,error,70,". '''; Code for simulating secure key rate, twofolds, and quantum bit error rate; Written in Python and QuTIP by Catherine Holloway (c2hollow@iqc.ca). Detector model and squashing functions by Catherine Holloway,; based on code by Dr. Thomas Jennewein (tjennewe@iqc.ca). Contributed to the QuTiP project on June 06, 2012 by Catherine Holloway.; '''. #imports; from qutip import *; from numpy import *; from pylab import *; import matplotlib; import matplotlib.pyplot as plt. def choose(n, k):; 	""""""; 	Binomial coefficient function for the detector model.; 	; 	Parameters; 	----------; 	n : int; 	 Number of elements.; 	k : int; 	 Number of subelements.; 	; 	Returns; 	-------; 	coeff : int; 	 Binomial coefficient.; 	; 	""""""; 	if 0 <= k <= n:; 		ntok = 1; 		ktok = 1; 		for t in xrange(1, min(k, n - k) + 1):; 			ntok *= n; 			ktok *= t; 			n -= 1; 		return ntok // ktok; 	else:; 		return 0. def BucketDetector_realistic_detector(N,efficiency,n_factor):; 	""""""; 	Bucket detector model based on H. Lee, U. Yurtsever, P. Kok, G. Hockney, C. Adami, S. Braunstein,; 	and J. Dowling, ""Towards photostatistics from photon-number discriminating detectors,""; 	Journal of Modern Optics, vol. 51, p. 15171528, 2004.; 	; 	Parameters; 	----------; 	N : int ; 	 The Fock Space dimension.; 	efficiency : float; 	 The channel efficiency.; 	n_factor : float; 	 The average number of dark counts per detection window APD (Bucket Detector).; 	; 	Returns; 	-------; 	[proj, un_proj] : list; 	 The projection and unprojection operators.; 	; 	""""""; 	proj=zeros((N,N)); 	#APD (Bucket Detector) un_detector (=gives probability for 0-detection); 	un_proj=identity(N); 	#n_factor = 0;; 	for i in range(N):; 	 probs = 0;; 	 for k in range (1,100):; 	 for d in range(k+1):; 	 if k-d<=i:; 	 probs= probs+ (exp(-n_factor)*(n_factor)**(d))/factorial(d)*choose(i,k-d)*efficiency**(k-d)*(1-efficiency)**(i-k+d); 	 ; 	 proj[i,i]=probs; 	 ; 	; 	un_proj = un_proj-proj; 	un_proj = Qobj(un_proj); 	proj = Qobj(proj); 	return [proj,un_proj].",MatchSource.DOCS,doc/contrib/sim_ent_qkd/sim_ent_qkd.html,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.html
https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.html:4764,Availability,error,error,4764,"0][0][0][1]+det_exp[1][0][0][0])+0.25*det_exp[0][0][0][0]. 	return [HH,HV,VH,VV]. def sim_qkd_entanglement(eps,loss_a,loss_b,n_factor_a,n_factor_b,N):; 	""""""; 	Simulate skr with an SPDC state.; 	; 	Parameters; 	----------; 	eps : float; 	 The squeezing factor, sort of analogous to the amount of ; 	 pumping power to the spdc source, but not really.; 	loss_a : float; 	 Efficiency of the quantum channel going to Alice.; 	loss_b : float; 	 Efficiency of the quantum channel going to Bob. ; 	n_factor_a : float; 	 Background noise in Alice's detection.; 	n_factor_b : float; 	 Background noise in Bob's detection.; 	N : int; 	 Size of the fock space that we allow for the states; 	; 	Returns; 	-------; 	qber : float; 	 The Quantum Bit Error Rate; 	twofolds : float; 	 Probability of Alice and Bob getting a simultaneous detection ; 	 of a photon pair (also referred to as coincidences) within a ; 	 timing window.; 	skr : float; 	 Probability of getting a secure key bit within a timing window, ; 	 assuming error correction and privacy amplification, in the ; 	 limit of many coincidences.; ; """"""; 	#make vaccuum state; 	vacc = basis(N,0). 	#make squeezing operator for SPDC; 	H_sq = 1j*eps*(tensor(create(N),create(N))+tensor(destroy(N),destroy(N))); 	; 	#exponentiate hamiltonian and apply it to vaccuum state to make an SPDC state; 	U_sq = H_sq.expm(); 	spdc = U_sq*tensor(vacc,vacc); 	psi = tensor(spdc,spdc); 	#since qutip doesn't have a permute function, ; 	#we have to do a couple of steps in between; 	#1. turn psi from a sparse matrix to a full matrix; 	out = psi.full(); 	#2. reshape psi into a 4-D matrix; 	out = reshape(out, (N,N,N,-1)); 	#3. permute the dimensions of our 4-D matrix; 	out = transpose(out,(0,3,2,1)); 	#4. turn the matrix back into a 1-D array ; 	out = reshape(out,(N*N*N*N,-1)); 	#5. convert the matrix back into a quantum object; 	psi = Qobj(out,dims = [[N, N, N, N], [1, 1, 1, 1]]). 	# model detectors; 	a_det = BucketDetector_realistic_detector(N,loss_a,n_factor_a); 	",MatchSource.DOCS,doc/contrib/sim_ent_qkd/sim_ent_qkd.html,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.html
https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.html:6264,Availability,error,error,6264," do a couple of steps in between; 	#1. turn psi from a sparse matrix to a full matrix; 	out = psi.full(); 	#2. reshape psi into a 4-D matrix; 	out = reshape(out, (N,N,N,-1)); 	#3. permute the dimensions of our 4-D matrix; 	out = transpose(out,(0,3,2,1)); 	#4. turn the matrix back into a 1-D array ; 	out = reshape(out,(N*N*N*N,-1)); 	#5. convert the matrix back into a quantum object; 	psi = Qobj(out,dims = [[N, N, N, N], [1, 1, 1, 1]]). 	# model detectors; 	a_det = BucketDetector_realistic_detector(N,loss_a,n_factor_a); 	b_det = BucketDetector_realistic_detector(N,loss_b,n_factor_b); 	; 	#measure detection probabilities; 	probs2f=measure_2folds_4modes_squashing(N,psi,a_det,b_det). 	#Rates returned are 'per pulse', so multiply by source rate; 	twofolds=probs2f[0]+probs2f[1]+probs2f[2]+probs2f[3]; 	#Determine QBER from returned detection probabilities; 	qber = (probs2f[0]+probs2f[3])/twofolds. 	#calculate the entropy of the qber ; 	if qber>0:; 		H2=-qber*log2(qber) - (1-qber)*log2(1-qber); 	else:; 		H2 = 0; 	# estimate error correction efficiency from the CASCADE algorithm ; 	f_e = 1.16904371810274 + qber; 	#security analysis - calculate skr in infinite key limit; 	#See Chris Erven's PhD thesis or Xiongfeng Ma's paper ; 	#to understand where this equation comes from; 	skr=real(twofolds*0.5*(1-(1+f_e)*H2)); 	return [qber, skr, twofolds]. if __name__=='__main__':; 	#Lets look at what happens to the secure key rate and ; 	#the quantum bit error rate as the loss gets worse.; 	#Analogous to distance with fiber optic links.; 	; 	#define the fock space; 	N = 7; 	#define the squeezing paramter; 	eps = 0.2; 	#define the noise factor; 	n_factor = 4.0e-5; 	#define the length of the coincidence window (in s); 	coinc_window = 2.0e-9; 	loss_db = arange(0,30); 	skr = zeros(30); 	qber = zeros(30); 	twofolds = zeros(30); ; #run calculation; 	for i in range(30):; 		exp_loss = 10.0**(-loss_db[i]/10.0);; 		[qber[i], skr[i], twofolds[i]] = sim_qkd_entanglement(eps,exp_loss,exp_loss,n_factor",MatchSource.DOCS,doc/contrib/sim_ent_qkd/sim_ent_qkd.html,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.html
https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.html:6689,Availability,error,error,6689,"N, N], [1, 1, 1, 1]]). 	# model detectors; 	a_det = BucketDetector_realistic_detector(N,loss_a,n_factor_a); 	b_det = BucketDetector_realistic_detector(N,loss_b,n_factor_b); 	; 	#measure detection probabilities; 	probs2f=measure_2folds_4modes_squashing(N,psi,a_det,b_det). 	#Rates returned are 'per pulse', so multiply by source rate; 	twofolds=probs2f[0]+probs2f[1]+probs2f[2]+probs2f[3]; 	#Determine QBER from returned detection probabilities; 	qber = (probs2f[0]+probs2f[3])/twofolds. 	#calculate the entropy of the qber ; 	if qber>0:; 		H2=-qber*log2(qber) - (1-qber)*log2(1-qber); 	else:; 		H2 = 0; 	# estimate error correction efficiency from the CASCADE algorithm ; 	f_e = 1.16904371810274 + qber; 	#security analysis - calculate skr in infinite key limit; 	#See Chris Erven's PhD thesis or Xiongfeng Ma's paper ; 	#to understand where this equation comes from; 	skr=real(twofolds*0.5*(1-(1+f_e)*H2)); 	return [qber, skr, twofolds]. if __name__=='__main__':; 	#Lets look at what happens to the secure key rate and ; 	#the quantum bit error rate as the loss gets worse.; 	#Analogous to distance with fiber optic links.; 	; 	#define the fock space; 	N = 7; 	#define the squeezing paramter; 	eps = 0.2; 	#define the noise factor; 	n_factor = 4.0e-5; 	#define the length of the coincidence window (in s); 	coinc_window = 2.0e-9; 	loss_db = arange(0,30); 	skr = zeros(30); 	qber = zeros(30); 	twofolds = zeros(30); ; #run calculation; 	for i in range(30):; 		exp_loss = 10.0**(-loss_db[i]/10.0);; 		[qber[i], skr[i], twofolds[i]] = sim_qkd_entanglement(eps,exp_loss,exp_loss,n_factor,n_factor,N); 	skr = skr/coinc_window; 	qber = qber*100; ; #plot results; 	fig = plt.figure(); 	ax = fig.add_subplot(211); 	ax.plot(loss_db, skr,lw=2); 	ax.set_yscale('log'); 	ax.set_ylabel('Secure Key Rate (bits/s)'); 	ax.set_xlabel('Loss (dB)'); 	ax = fig.add_subplot(212); 	ax.plot(loss_db, qber,lw=2); 	ax.set_ylabel('Quantum Bit Error Rate (%)'); 	ax.set_ylim([0,15]); 	ax.set_xlabel('Loss (dB)'); 	plt.show(). ",MatchSource.DOCS,doc/contrib/sim_ent_qkd/sim_ent_qkd.html,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.html
https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.html:3288,Deployability,configurat,configurations,3288,"he entangled state to analyze; 	proj1 : qobj; 	 1st projection operator for the Channel between Alice and; 	the Channel between Bob.; 	proj2 : qobj; 	 2nd projection operator for the Channel between Alice and ; 	 the Channel between Bob.; 	; 	Returns; 	-------; 	[HH,HV,VH,VV] : list; 	 Two-fold probabilities.; 	; 	Notes; 	-----; 	The squashing (assigning double pairs to random bases) comes from two papers:; 	; 	 T. Moroder, O. Guhne, N. Beaudry, M. Piani, and N. Lutkenhaus,; 	 ""Entanglement verication with realistic measurement devices via squashing operations,""; 	 Phys. Rev. A, vol. 81, p. 052342, May 2010.; 	; 	 N. Lutkenhaus, ""Estimates for practical quantum cryptography,"" Phys. Rev.A,; 	 vol. 59, pp. 3301-3319, May 1999.; 	; 	""""""; 	ida=qeye(N); 	final_state=psi; 	det_exp = zeros((2,2,2,2)). 	#i,j,k,l means Ha,Va,Hb,Vb, 0 means detector clicked, 1 means detector did not click; 	for i in range(2):; 		for j in range(2):; 			for k in range(2):; 				for l in range(2):; 					#expectation values for different detector configurations; 					det_exp[i][j][k][l] = abs(expect(tensor(proj[i],proj[j],proj2[k],proj[l]),final_state)); 	#two fold probabilities; 	HH = det_exp[0][1][0][1]+0.5*(det_exp[0][0][0][1]+det_exp[0][1][0][0])+0.25*det_exp[0][0][0][0]; 	VV = det_exp[1][0][1][0]+0.5*(det_exp[0][0][1][0]+det_exp[1][0][0][0])+0.25*det_exp[0][0][0][0]; 	HV = det_exp[0][1][1][0]+0.5*(det_exp[0][0][1][0]+det_exp[0][1][0][0])+0.25*det_exp[0][0][0][0]; 	VH = det_exp[1][0][0][1]+0.5*(det_exp[0][0][0][1]+det_exp[1][0][0][0])+0.25*det_exp[0][0][0][0]. 	return [HH,HV,VH,VV]. def sim_qkd_entanglement(eps,loss_a,loss_b,n_factor_a,n_factor_b,N):; 	""""""; 	Simulate skr with an SPDC state.; 	; 	Parameters; 	----------; 	eps : float; 	 The squeezing factor, sort of analogous to the amount of ; 	 pumping power to the spdc source, but not really.; 	loss_a : float; 	 Efficiency of the quantum channel going to Alice.; 	loss_b : float; 	 Efficiency of the quantum channel going to Bob. ; 	n_factor_a",MatchSource.DOCS,doc/contrib/sim_ent_qkd/sim_ent_qkd.html,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.html
https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.html:4064,Energy Efficiency,power,power,4064,"te=psi; 	det_exp = zeros((2,2,2,2)). 	#i,j,k,l means Ha,Va,Hb,Vb, 0 means detector clicked, 1 means detector did not click; 	for i in range(2):; 		for j in range(2):; 			for k in range(2):; 				for l in range(2):; 					#expectation values for different detector configurations; 					det_exp[i][j][k][l] = abs(expect(tensor(proj[i],proj[j],proj2[k],proj[l]),final_state)); 	#two fold probabilities; 	HH = det_exp[0][1][0][1]+0.5*(det_exp[0][0][0][1]+det_exp[0][1][0][0])+0.25*det_exp[0][0][0][0]; 	VV = det_exp[1][0][1][0]+0.5*(det_exp[0][0][1][0]+det_exp[1][0][0][0])+0.25*det_exp[0][0][0][0]; 	HV = det_exp[0][1][1][0]+0.5*(det_exp[0][0][1][0]+det_exp[0][1][0][0])+0.25*det_exp[0][0][0][0]; 	VH = det_exp[1][0][0][1]+0.5*(det_exp[0][0][0][1]+det_exp[1][0][0][0])+0.25*det_exp[0][0][0][0]. 	return [HH,HV,VH,VV]. def sim_qkd_entanglement(eps,loss_a,loss_b,n_factor_a,n_factor_b,N):; 	""""""; 	Simulate skr with an SPDC state.; 	; 	Parameters; 	----------; 	eps : float; 	 The squeezing factor, sort of analogous to the amount of ; 	 pumping power to the spdc source, but not really.; 	loss_a : float; 	 Efficiency of the quantum channel going to Alice.; 	loss_b : float; 	 Efficiency of the quantum channel going to Bob. ; 	n_factor_a : float; 	 Background noise in Alice's detection.; 	n_factor_b : float; 	 Background noise in Bob's detection.; 	N : int; 	 Size of the fock space that we allow for the states; 	; 	Returns; 	-------; 	qber : float; 	 The Quantum Bit Error Rate; 	twofolds : float; 	 Probability of Alice and Bob getting a simultaneous detection ; 	 of a photon pair (also referred to as coincidences) within a ; 	 timing window.; 	skr : float; 	 Probability of getting a secure key bit within a timing window, ; 	 assuming error correction and privacy amplification, in the ; 	 limit of many coincidences.; ; """"""; 	#make vaccuum state; 	vacc = basis(N,0). 	#make squeezing operator for SPDC; 	H_sq = 1j*eps*(tensor(create(N),create(N))+tensor(destroy(N),destroy(N))); 	; 	#exponentiate ",MatchSource.DOCS,doc/contrib/sim_ent_qkd/sim_ent_qkd.html,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.html
https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.html:3288,Modifiability,config,configurations,3288,"he entangled state to analyze; 	proj1 : qobj; 	 1st projection operator for the Channel between Alice and; 	the Channel between Bob.; 	proj2 : qobj; 	 2nd projection operator for the Channel between Alice and ; 	 the Channel between Bob.; 	; 	Returns; 	-------; 	[HH,HV,VH,VV] : list; 	 Two-fold probabilities.; 	; 	Notes; 	-----; 	The squashing (assigning double pairs to random bases) comes from two papers:; 	; 	 T. Moroder, O. Guhne, N. Beaudry, M. Piani, and N. Lutkenhaus,; 	 ""Entanglement verication with realistic measurement devices via squashing operations,""; 	 Phys. Rev. A, vol. 81, p. 052342, May 2010.; 	; 	 N. Lutkenhaus, ""Estimates for practical quantum cryptography,"" Phys. Rev.A,; 	 vol. 59, pp. 3301-3319, May 1999.; 	; 	""""""; 	ida=qeye(N); 	final_state=psi; 	det_exp = zeros((2,2,2,2)). 	#i,j,k,l means Ha,Va,Hb,Vb, 0 means detector clicked, 1 means detector did not click; 	for i in range(2):; 		for j in range(2):; 			for k in range(2):; 				for l in range(2):; 					#expectation values for different detector configurations; 					det_exp[i][j][k][l] = abs(expect(tensor(proj[i],proj[j],proj2[k],proj[l]),final_state)); 	#two fold probabilities; 	HH = det_exp[0][1][0][1]+0.5*(det_exp[0][0][0][1]+det_exp[0][1][0][0])+0.25*det_exp[0][0][0][0]; 	VV = det_exp[1][0][1][0]+0.5*(det_exp[0][0][1][0]+det_exp[1][0][0][0])+0.25*det_exp[0][0][0][0]; 	HV = det_exp[0][1][1][0]+0.5*(det_exp[0][0][1][0]+det_exp[0][1][0][0])+0.25*det_exp[0][0][0][0]; 	VH = det_exp[1][0][0][1]+0.5*(det_exp[0][0][0][1]+det_exp[1][0][0][0])+0.25*det_exp[0][0][0][0]. 	return [HH,HV,VH,VV]. def sim_qkd_entanglement(eps,loss_a,loss_b,n_factor_a,n_factor_b,N):; 	""""""; 	Simulate skr with an SPDC state.; 	; 	Parameters; 	----------; 	eps : float; 	 The squeezing factor, sort of analogous to the amount of ; 	 pumping power to the spdc source, but not really.; 	loss_a : float; 	 Efficiency of the quantum channel going to Alice.; 	loss_b : float; 	 Efficiency of the quantum channel going to Bob. ; 	n_factor_a",MatchSource.DOCS,doc/contrib/sim_ent_qkd/sim_ent_qkd.html,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.html
https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.html:539,Safety,detect,detector,539,". '''; Code for simulating secure key rate, twofolds, and quantum bit error rate; Written in Python and QuTIP by Catherine Holloway (c2hollow@iqc.ca). Detector model and squashing functions by Catherine Holloway,; based on code by Dr. Thomas Jennewein (tjennewe@iqc.ca). Contributed to the QuTiP project on June 06, 2012 by Catherine Holloway.; '''. #imports; from qutip import *; from numpy import *; from pylab import *; import matplotlib; import matplotlib.pyplot as plt. def choose(n, k):; 	""""""; 	Binomial coefficient function for the detector model.; 	; 	Parameters; 	----------; 	n : int; 	 Number of elements.; 	k : int; 	 Number of subelements.; 	; 	Returns; 	-------; 	coeff : int; 	 Binomial coefficient.; 	; 	""""""; 	if 0 <= k <= n:; 		ntok = 1; 		ktok = 1; 		for t in xrange(1, min(k, n - k) + 1):; 			ntok *= n; 			ktok *= t; 			n -= 1; 		return ntok // ktok; 	else:; 		return 0. def BucketDetector_realistic_detector(N,efficiency,n_factor):; 	""""""; 	Bucket detector model based on H. Lee, U. Yurtsever, P. Kok, G. Hockney, C. Adami, S. Braunstein,; 	and J. Dowling, ""Towards photostatistics from photon-number discriminating detectors,""; 	Journal of Modern Optics, vol. 51, p. 15171528, 2004.; 	; 	Parameters; 	----------; 	N : int ; 	 The Fock Space dimension.; 	efficiency : float; 	 The channel efficiency.; 	n_factor : float; 	 The average number of dark counts per detection window APD (Bucket Detector).; 	; 	Returns; 	-------; 	[proj, un_proj] : list; 	 The projection and unprojection operators.; 	; 	""""""; 	proj=zeros((N,N)); 	#APD (Bucket Detector) un_detector (=gives probability for 0-detection); 	un_proj=identity(N); 	#n_factor = 0;; 	for i in range(N):; 	 probs = 0;; 	 for k in range (1,100):; 	 for d in range(k+1):; 	 if k-d<=i:; 	 probs= probs+ (exp(-n_factor)*(n_factor)**(d))/factorial(d)*choose(i,k-d)*efficiency**(k-d)*(1-efficiency)**(i-k+d); 	 ; 	 proj[i,i]=probs; 	 ; 	; 	un_proj = un_proj-proj; 	un_proj = Qobj(un_proj); 	proj = Qobj(proj); 	return [proj,un_proj].",MatchSource.DOCS,doc/contrib/sim_ent_qkd/sim_ent_qkd.html,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.html
https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.html:968,Safety,detect,detector,968,". '''; Code for simulating secure key rate, twofolds, and quantum bit error rate; Written in Python and QuTIP by Catherine Holloway (c2hollow@iqc.ca). Detector model and squashing functions by Catherine Holloway,; based on code by Dr. Thomas Jennewein (tjennewe@iqc.ca). Contributed to the QuTiP project on June 06, 2012 by Catherine Holloway.; '''. #imports; from qutip import *; from numpy import *; from pylab import *; import matplotlib; import matplotlib.pyplot as plt. def choose(n, k):; 	""""""; 	Binomial coefficient function for the detector model.; 	; 	Parameters; 	----------; 	n : int; 	 Number of elements.; 	k : int; 	 Number of subelements.; 	; 	Returns; 	-------; 	coeff : int; 	 Binomial coefficient.; 	; 	""""""; 	if 0 <= k <= n:; 		ntok = 1; 		ktok = 1; 		for t in xrange(1, min(k, n - k) + 1):; 			ntok *= n; 			ktok *= t; 			n -= 1; 		return ntok // ktok; 	else:; 		return 0. def BucketDetector_realistic_detector(N,efficiency,n_factor):; 	""""""; 	Bucket detector model based on H. Lee, U. Yurtsever, P. Kok, G. Hockney, C. Adami, S. Braunstein,; 	and J. Dowling, ""Towards photostatistics from photon-number discriminating detectors,""; 	Journal of Modern Optics, vol. 51, p. 15171528, 2004.; 	; 	Parameters; 	----------; 	N : int ; 	 The Fock Space dimension.; 	efficiency : float; 	 The channel efficiency.; 	n_factor : float; 	 The average number of dark counts per detection window APD (Bucket Detector).; 	; 	Returns; 	-------; 	[proj, un_proj] : list; 	 The projection and unprojection operators.; 	; 	""""""; 	proj=zeros((N,N)); 	#APD (Bucket Detector) un_detector (=gives probability for 0-detection); 	un_proj=identity(N); 	#n_factor = 0;; 	for i in range(N):; 	 probs = 0;; 	 for k in range (1,100):; 	 for d in range(k+1):; 	 if k-d<=i:; 	 probs= probs+ (exp(-n_factor)*(n_factor)**(d))/factorial(d)*choose(i,k-d)*efficiency**(k-d)*(1-efficiency)**(i-k+d); 	 ; 	 proj[i,i]=probs; 	 ; 	; 	un_proj = un_proj-proj; 	un_proj = Qobj(un_proj); 	proj = Qobj(proj); 	return [proj,un_proj].",MatchSource.DOCS,doc/contrib/sim_ent_qkd/sim_ent_qkd.html,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.html
https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.html:1136,Safety,detect,detectors,1136,"Holloway (c2hollow@iqc.ca). Detector model and squashing functions by Catherine Holloway,; based on code by Dr. Thomas Jennewein (tjennewe@iqc.ca). Contributed to the QuTiP project on June 06, 2012 by Catherine Holloway.; '''. #imports; from qutip import *; from numpy import *; from pylab import *; import matplotlib; import matplotlib.pyplot as plt. def choose(n, k):; 	""""""; 	Binomial coefficient function for the detector model.; 	; 	Parameters; 	----------; 	n : int; 	 Number of elements.; 	k : int; 	 Number of subelements.; 	; 	Returns; 	-------; 	coeff : int; 	 Binomial coefficient.; 	; 	""""""; 	if 0 <= k <= n:; 		ntok = 1; 		ktok = 1; 		for t in xrange(1, min(k, n - k) + 1):; 			ntok *= n; 			ktok *= t; 			n -= 1; 		return ntok // ktok; 	else:; 		return 0. def BucketDetector_realistic_detector(N,efficiency,n_factor):; 	""""""; 	Bucket detector model based on H. Lee, U. Yurtsever, P. Kok, G. Hockney, C. Adami, S. Braunstein,; 	and J. Dowling, ""Towards photostatistics from photon-number discriminating detectors,""; 	Journal of Modern Optics, vol. 51, p. 15171528, 2004.; 	; 	Parameters; 	----------; 	N : int ; 	 The Fock Space dimension.; 	efficiency : float; 	 The channel efficiency.; 	n_factor : float; 	 The average number of dark counts per detection window APD (Bucket Detector).; 	; 	Returns; 	-------; 	[proj, un_proj] : list; 	 The projection and unprojection operators.; 	; 	""""""; 	proj=zeros((N,N)); 	#APD (Bucket Detector) un_detector (=gives probability for 0-detection); 	un_proj=identity(N); 	#n_factor = 0;; 	for i in range(N):; 	 probs = 0;; 	 for k in range (1,100):; 	 for d in range(k+1):; 	 if k-d<=i:; 	 probs= probs+ (exp(-n_factor)*(n_factor)**(d))/factorial(d)*choose(i,k-d)*efficiency**(k-d)*(1-efficiency)**(i-k+d); 	 ; 	 proj[i,i]=probs; 	 ; 	; 	un_proj = un_proj-proj; 	un_proj = Qobj(un_proj); 	proj = Qobj(proj); 	return [proj,un_proj]. def measure_2folds_4modes_squashing(N,psi,proj,proj2):; 	""""""; 	Determines the 2-fold count rate on the joint state ; 	outp",MatchSource.DOCS,doc/contrib/sim_ent_qkd/sim_ent_qkd.html,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.html
https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.html:1381,Safety,detect,detection,1381," import *; from numpy import *; from pylab import *; import matplotlib; import matplotlib.pyplot as plt. def choose(n, k):; 	""""""; 	Binomial coefficient function for the detector model.; 	; 	Parameters; 	----------; 	n : int; 	 Number of elements.; 	k : int; 	 Number of subelements.; 	; 	Returns; 	-------; 	coeff : int; 	 Binomial coefficient.; 	; 	""""""; 	if 0 <= k <= n:; 		ntok = 1; 		ktok = 1; 		for t in xrange(1, min(k, n - k) + 1):; 			ntok *= n; 			ktok *= t; 			n -= 1; 		return ntok // ktok; 	else:; 		return 0. def BucketDetector_realistic_detector(N,efficiency,n_factor):; 	""""""; 	Bucket detector model based on H. Lee, U. Yurtsever, P. Kok, G. Hockney, C. Adami, S. Braunstein,; 	and J. Dowling, ""Towards photostatistics from photon-number discriminating detectors,""; 	Journal of Modern Optics, vol. 51, p. 15171528, 2004.; 	; 	Parameters; 	----------; 	N : int ; 	 The Fock Space dimension.; 	efficiency : float; 	 The channel efficiency.; 	n_factor : float; 	 The average number of dark counts per detection window APD (Bucket Detector).; 	; 	Returns; 	-------; 	[proj, un_proj] : list; 	 The projection and unprojection operators.; 	; 	""""""; 	proj=zeros((N,N)); 	#APD (Bucket Detector) un_detector (=gives probability for 0-detection); 	un_proj=identity(N); 	#n_factor = 0;; 	for i in range(N):; 	 probs = 0;; 	 for k in range (1,100):; 	 for d in range(k+1):; 	 if k-d<=i:; 	 probs= probs+ (exp(-n_factor)*(n_factor)**(d))/factorial(d)*choose(i,k-d)*efficiency**(k-d)*(1-efficiency)**(i-k+d); 	 ; 	 proj[i,i]=probs; 	 ; 	; 	un_proj = un_proj-proj; 	un_proj = Qobj(un_proj); 	proj = Qobj(proj); 	return [proj,un_proj]. def measure_2folds_4modes_squashing(N,psi,proj,proj2):; 	""""""; 	Determines the 2-fold count rate on the joint state ; 	outputs for an array of double count probabilities.; 	; 	Parameters; 	----------; 	N : int; 	 The Fock Space dimension.; 	psi : qobj; 	 The entangled state to analyze; 	proj1 : qobj; 	 1st projection operator for the Channel between Alice and; 	the C",MatchSource.DOCS,doc/contrib/sim_ent_qkd/sim_ent_qkd.html,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.html
https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.html:1607,Safety,detect,detection,1607,"ktok = 1; 		for t in xrange(1, min(k, n - k) + 1):; 			ntok *= n; 			ktok *= t; 			n -= 1; 		return ntok // ktok; 	else:; 		return 0. def BucketDetector_realistic_detector(N,efficiency,n_factor):; 	""""""; 	Bucket detector model based on H. Lee, U. Yurtsever, P. Kok, G. Hockney, C. Adami, S. Braunstein,; 	and J. Dowling, ""Towards photostatistics from photon-number discriminating detectors,""; 	Journal of Modern Optics, vol. 51, p. 15171528, 2004.; 	; 	Parameters; 	----------; 	N : int ; 	 The Fock Space dimension.; 	efficiency : float; 	 The channel efficiency.; 	n_factor : float; 	 The average number of dark counts per detection window APD (Bucket Detector).; 	; 	Returns; 	-------; 	[proj, un_proj] : list; 	 The projection and unprojection operators.; 	; 	""""""; 	proj=zeros((N,N)); 	#APD (Bucket Detector) un_detector (=gives probability for 0-detection); 	un_proj=identity(N); 	#n_factor = 0;; 	for i in range(N):; 	 probs = 0;; 	 for k in range (1,100):; 	 for d in range(k+1):; 	 if k-d<=i:; 	 probs= probs+ (exp(-n_factor)*(n_factor)**(d))/factorial(d)*choose(i,k-d)*efficiency**(k-d)*(1-efficiency)**(i-k+d); 	 ; 	 proj[i,i]=probs; 	 ; 	; 	un_proj = un_proj-proj; 	un_proj = Qobj(un_proj); 	proj = Qobj(proj); 	return [proj,un_proj]. def measure_2folds_4modes_squashing(N,psi,proj,proj2):; 	""""""; 	Determines the 2-fold count rate on the joint state ; 	outputs for an array of double count probabilities.; 	; 	Parameters; 	----------; 	N : int; 	 The Fock Space dimension.; 	psi : qobj; 	 The entangled state to analyze; 	proj1 : qobj; 	 1st projection operator for the Channel between Alice and; 	the Channel between Bob.; 	proj2 : qobj; 	 2nd projection operator for the Channel between Alice and ; 	 the Channel between Bob.; 	; 	Returns; 	-------; 	[HH,HV,VH,VV] : list; 	 Two-fold probabilities.; 	; 	Notes; 	-----; 	The squashing (assigning double pairs to random bases) comes from two papers:; 	; 	 T. Moroder, O. Guhne, N. Beaudry, M. Piani, and N. Lutkenhaus,; 	 ""Entanglement veric",MatchSource.DOCS,doc/contrib/sim_ent_qkd/sim_ent_qkd.html,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.html
https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.html:3100,Safety,detect,detector,3100,"he entangled state to analyze; 	proj1 : qobj; 	 1st projection operator for the Channel between Alice and; 	the Channel between Bob.; 	proj2 : qobj; 	 2nd projection operator for the Channel between Alice and ; 	 the Channel between Bob.; 	; 	Returns; 	-------; 	[HH,HV,VH,VV] : list; 	 Two-fold probabilities.; 	; 	Notes; 	-----; 	The squashing (assigning double pairs to random bases) comes from two papers:; 	; 	 T. Moroder, O. Guhne, N. Beaudry, M. Piani, and N. Lutkenhaus,; 	 ""Entanglement verication with realistic measurement devices via squashing operations,""; 	 Phys. Rev. A, vol. 81, p. 052342, May 2010.; 	; 	 N. Lutkenhaus, ""Estimates for practical quantum cryptography,"" Phys. Rev.A,; 	 vol. 59, pp. 3301-3319, May 1999.; 	; 	""""""; 	ida=qeye(N); 	final_state=psi; 	det_exp = zeros((2,2,2,2)). 	#i,j,k,l means Ha,Va,Hb,Vb, 0 means detector clicked, 1 means detector did not click; 	for i in range(2):; 		for j in range(2):; 			for k in range(2):; 				for l in range(2):; 					#expectation values for different detector configurations; 					det_exp[i][j][k][l] = abs(expect(tensor(proj[i],proj[j],proj2[k],proj[l]),final_state)); 	#two fold probabilities; 	HH = det_exp[0][1][0][1]+0.5*(det_exp[0][0][0][1]+det_exp[0][1][0][0])+0.25*det_exp[0][0][0][0]; 	VV = det_exp[1][0][1][0]+0.5*(det_exp[0][0][1][0]+det_exp[1][0][0][0])+0.25*det_exp[0][0][0][0]; 	HV = det_exp[0][1][1][0]+0.5*(det_exp[0][0][1][0]+det_exp[0][1][0][0])+0.25*det_exp[0][0][0][0]; 	VH = det_exp[1][0][0][1]+0.5*(det_exp[0][0][0][1]+det_exp[1][0][0][0])+0.25*det_exp[0][0][0][0]. 	return [HH,HV,VH,VV]. def sim_qkd_entanglement(eps,loss_a,loss_b,n_factor_a,n_factor_b,N):; 	""""""; 	Simulate skr with an SPDC state.; 	; 	Parameters; 	----------; 	eps : float; 	 The squeezing factor, sort of analogous to the amount of ; 	 pumping power to the spdc source, but not really.; 	loss_a : float; 	 Efficiency of the quantum channel going to Alice.; 	loss_b : float; 	 Efficiency of the quantum channel going to Bob. ; 	n_factor_a",MatchSource.DOCS,doc/contrib/sim_ent_qkd/sim_ent_qkd.html,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.html
https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.html:3126,Safety,detect,detector,3126,"he entangled state to analyze; 	proj1 : qobj; 	 1st projection operator for the Channel between Alice and; 	the Channel between Bob.; 	proj2 : qobj; 	 2nd projection operator for the Channel between Alice and ; 	 the Channel between Bob.; 	; 	Returns; 	-------; 	[HH,HV,VH,VV] : list; 	 Two-fold probabilities.; 	; 	Notes; 	-----; 	The squashing (assigning double pairs to random bases) comes from two papers:; 	; 	 T. Moroder, O. Guhne, N. Beaudry, M. Piani, and N. Lutkenhaus,; 	 ""Entanglement verication with realistic measurement devices via squashing operations,""; 	 Phys. Rev. A, vol. 81, p. 052342, May 2010.; 	; 	 N. Lutkenhaus, ""Estimates for practical quantum cryptography,"" Phys. Rev.A,; 	 vol. 59, pp. 3301-3319, May 1999.; 	; 	""""""; 	ida=qeye(N); 	final_state=psi; 	det_exp = zeros((2,2,2,2)). 	#i,j,k,l means Ha,Va,Hb,Vb, 0 means detector clicked, 1 means detector did not click; 	for i in range(2):; 		for j in range(2):; 			for k in range(2):; 				for l in range(2):; 					#expectation values for different detector configurations; 					det_exp[i][j][k][l] = abs(expect(tensor(proj[i],proj[j],proj2[k],proj[l]),final_state)); 	#two fold probabilities; 	HH = det_exp[0][1][0][1]+0.5*(det_exp[0][0][0][1]+det_exp[0][1][0][0])+0.25*det_exp[0][0][0][0]; 	VV = det_exp[1][0][1][0]+0.5*(det_exp[0][0][1][0]+det_exp[1][0][0][0])+0.25*det_exp[0][0][0][0]; 	HV = det_exp[0][1][1][0]+0.5*(det_exp[0][0][1][0]+det_exp[0][1][0][0])+0.25*det_exp[0][0][0][0]; 	VH = det_exp[1][0][0][1]+0.5*(det_exp[0][0][0][1]+det_exp[1][0][0][0])+0.25*det_exp[0][0][0][0]. 	return [HH,HV,VH,VV]. def sim_qkd_entanglement(eps,loss_a,loss_b,n_factor_a,n_factor_b,N):; 	""""""; 	Simulate skr with an SPDC state.; 	; 	Parameters; 	----------; 	eps : float; 	 The squeezing factor, sort of analogous to the amount of ; 	 pumping power to the spdc source, but not really.; 	loss_a : float; 	 Efficiency of the quantum channel going to Alice.; 	loss_b : float; 	 Efficiency of the quantum channel going to Bob. ; 	n_factor_a",MatchSource.DOCS,doc/contrib/sim_ent_qkd/sim_ent_qkd.html,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.html
https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.html:3279,Safety,detect,detector,3279,"he entangled state to analyze; 	proj1 : qobj; 	 1st projection operator for the Channel between Alice and; 	the Channel between Bob.; 	proj2 : qobj; 	 2nd projection operator for the Channel between Alice and ; 	 the Channel between Bob.; 	; 	Returns; 	-------; 	[HH,HV,VH,VV] : list; 	 Two-fold probabilities.; 	; 	Notes; 	-----; 	The squashing (assigning double pairs to random bases) comes from two papers:; 	; 	 T. Moroder, O. Guhne, N. Beaudry, M. Piani, and N. Lutkenhaus,; 	 ""Entanglement verication with realistic measurement devices via squashing operations,""; 	 Phys. Rev. A, vol. 81, p. 052342, May 2010.; 	; 	 N. Lutkenhaus, ""Estimates for practical quantum cryptography,"" Phys. Rev.A,; 	 vol. 59, pp. 3301-3319, May 1999.; 	; 	""""""; 	ida=qeye(N); 	final_state=psi; 	det_exp = zeros((2,2,2,2)). 	#i,j,k,l means Ha,Va,Hb,Vb, 0 means detector clicked, 1 means detector did not click; 	for i in range(2):; 		for j in range(2):; 			for k in range(2):; 				for l in range(2):; 					#expectation values for different detector configurations; 					det_exp[i][j][k][l] = abs(expect(tensor(proj[i],proj[j],proj2[k],proj[l]),final_state)); 	#two fold probabilities; 	HH = det_exp[0][1][0][1]+0.5*(det_exp[0][0][0][1]+det_exp[0][1][0][0])+0.25*det_exp[0][0][0][0]; 	VV = det_exp[1][0][1][0]+0.5*(det_exp[0][0][1][0]+det_exp[1][0][0][0])+0.25*det_exp[0][0][0][0]; 	HV = det_exp[0][1][1][0]+0.5*(det_exp[0][0][1][0]+det_exp[0][1][0][0])+0.25*det_exp[0][0][0][0]; 	VH = det_exp[1][0][0][1]+0.5*(det_exp[0][0][0][1]+det_exp[1][0][0][0])+0.25*det_exp[0][0][0][0]. 	return [HH,HV,VH,VV]. def sim_qkd_entanglement(eps,loss_a,loss_b,n_factor_a,n_factor_b,N):; 	""""""; 	Simulate skr with an SPDC state.; 	; 	Parameters; 	----------; 	eps : float; 	 The squeezing factor, sort of analogous to the amount of ; 	 pumping power to the spdc source, but not really.; 	loss_a : float; 	 Efficiency of the quantum channel going to Alice.; 	loss_b : float; 	 Efficiency of the quantum channel going to Bob. ; 	n_factor_a",MatchSource.DOCS,doc/contrib/sim_ent_qkd/sim_ent_qkd.html,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.html
https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.html:4297,Safety,detect,detection,4297,"ent detector configurations; 					det_exp[i][j][k][l] = abs(expect(tensor(proj[i],proj[j],proj2[k],proj[l]),final_state)); 	#two fold probabilities; 	HH = det_exp[0][1][0][1]+0.5*(det_exp[0][0][0][1]+det_exp[0][1][0][0])+0.25*det_exp[0][0][0][0]; 	VV = det_exp[1][0][1][0]+0.5*(det_exp[0][0][1][0]+det_exp[1][0][0][0])+0.25*det_exp[0][0][0][0]; 	HV = det_exp[0][1][1][0]+0.5*(det_exp[0][0][1][0]+det_exp[0][1][0][0])+0.25*det_exp[0][0][0][0]; 	VH = det_exp[1][0][0][1]+0.5*(det_exp[0][0][0][1]+det_exp[1][0][0][0])+0.25*det_exp[0][0][0][0]. 	return [HH,HV,VH,VV]. def sim_qkd_entanglement(eps,loss_a,loss_b,n_factor_a,n_factor_b,N):; 	""""""; 	Simulate skr with an SPDC state.; 	; 	Parameters; 	----------; 	eps : float; 	 The squeezing factor, sort of analogous to the amount of ; 	 pumping power to the spdc source, but not really.; 	loss_a : float; 	 Efficiency of the quantum channel going to Alice.; 	loss_b : float; 	 Efficiency of the quantum channel going to Bob. ; 	n_factor_a : float; 	 Background noise in Alice's detection.; 	n_factor_b : float; 	 Background noise in Bob's detection.; 	N : int; 	 Size of the fock space that we allow for the states; 	; 	Returns; 	-------; 	qber : float; 	 The Quantum Bit Error Rate; 	twofolds : float; 	 Probability of Alice and Bob getting a simultaneous detection ; 	 of a photon pair (also referred to as coincidences) within a ; 	 timing window.; 	skr : float; 	 Probability of getting a secure key bit within a timing window, ; 	 assuming error correction and privacy amplification, in the ; 	 limit of many coincidences.; ; """"""; 	#make vaccuum state; 	vacc = basis(N,0). 	#make squeezing operator for SPDC; 	H_sq = 1j*eps*(tensor(create(N),create(N))+tensor(destroy(N),destroy(N))); 	; 	#exponentiate hamiltonian and apply it to vaccuum state to make an SPDC state; 	U_sq = H_sq.expm(); 	spdc = U_sq*tensor(vacc,vacc); 	psi = tensor(spdc,spdc); 	#since qutip doesn't have a permute function, ; 	#we have to do a couple of steps in between; 	#1. turn",MatchSource.DOCS,doc/contrib/sim_ent_qkd/sim_ent_qkd.html,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.html
https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.html:4358,Safety,detect,detection,4358,"pect(tensor(proj[i],proj[j],proj2[k],proj[l]),final_state)); 	#two fold probabilities; 	HH = det_exp[0][1][0][1]+0.5*(det_exp[0][0][0][1]+det_exp[0][1][0][0])+0.25*det_exp[0][0][0][0]; 	VV = det_exp[1][0][1][0]+0.5*(det_exp[0][0][1][0]+det_exp[1][0][0][0])+0.25*det_exp[0][0][0][0]; 	HV = det_exp[0][1][1][0]+0.5*(det_exp[0][0][1][0]+det_exp[0][1][0][0])+0.25*det_exp[0][0][0][0]; 	VH = det_exp[1][0][0][1]+0.5*(det_exp[0][0][0][1]+det_exp[1][0][0][0])+0.25*det_exp[0][0][0][0]. 	return [HH,HV,VH,VV]. def sim_qkd_entanglement(eps,loss_a,loss_b,n_factor_a,n_factor_b,N):; 	""""""; 	Simulate skr with an SPDC state.; 	; 	Parameters; 	----------; 	eps : float; 	 The squeezing factor, sort of analogous to the amount of ; 	 pumping power to the spdc source, but not really.; 	loss_a : float; 	 Efficiency of the quantum channel going to Alice.; 	loss_b : float; 	 Efficiency of the quantum channel going to Bob. ; 	n_factor_a : float; 	 Background noise in Alice's detection.; 	n_factor_b : float; 	 Background noise in Bob's detection.; 	N : int; 	 Size of the fock space that we allow for the states; 	; 	Returns; 	-------; 	qber : float; 	 The Quantum Bit Error Rate; 	twofolds : float; 	 Probability of Alice and Bob getting a simultaneous detection ; 	 of a photon pair (also referred to as coincidences) within a ; 	 timing window.; 	skr : float; 	 Probability of getting a secure key bit within a timing window, ; 	 assuming error correction and privacy amplification, in the ; 	 limit of many coincidences.; ; """"""; 	#make vaccuum state; 	vacc = basis(N,0). 	#make squeezing operator for SPDC; 	H_sq = 1j*eps*(tensor(create(N),create(N))+tensor(destroy(N),destroy(N))); 	; 	#exponentiate hamiltonian and apply it to vaccuum state to make an SPDC state; 	U_sq = H_sq.expm(); 	spdc = U_sq*tensor(vacc,vacc); 	psi = tensor(spdc,spdc); 	#since qutip doesn't have a permute function, ; 	#we have to do a couple of steps in between; 	#1. turn psi from a sparse matrix to a full matrix; 	out = psi.full(); ",MatchSource.DOCS,doc/contrib/sim_ent_qkd/sim_ent_qkd.html,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.html
https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.html:4576,Safety,detect,detection,4576,"0]; 	VV = det_exp[1][0][1][0]+0.5*(det_exp[0][0][1][0]+det_exp[1][0][0][0])+0.25*det_exp[0][0][0][0]; 	HV = det_exp[0][1][1][0]+0.5*(det_exp[0][0][1][0]+det_exp[0][1][0][0])+0.25*det_exp[0][0][0][0]; 	VH = det_exp[1][0][0][1]+0.5*(det_exp[0][0][0][1]+det_exp[1][0][0][0])+0.25*det_exp[0][0][0][0]. 	return [HH,HV,VH,VV]. def sim_qkd_entanglement(eps,loss_a,loss_b,n_factor_a,n_factor_b,N):; 	""""""; 	Simulate skr with an SPDC state.; 	; 	Parameters; 	----------; 	eps : float; 	 The squeezing factor, sort of analogous to the amount of ; 	 pumping power to the spdc source, but not really.; 	loss_a : float; 	 Efficiency of the quantum channel going to Alice.; 	loss_b : float; 	 Efficiency of the quantum channel going to Bob. ; 	n_factor_a : float; 	 Background noise in Alice's detection.; 	n_factor_b : float; 	 Background noise in Bob's detection.; 	N : int; 	 Size of the fock space that we allow for the states; 	; 	Returns; 	-------; 	qber : float; 	 The Quantum Bit Error Rate; 	twofolds : float; 	 Probability of Alice and Bob getting a simultaneous detection ; 	 of a photon pair (also referred to as coincidences) within a ; 	 timing window.; 	skr : float; 	 Probability of getting a secure key bit within a timing window, ; 	 assuming error correction and privacy amplification, in the ; 	 limit of many coincidences.; ; """"""; 	#make vaccuum state; 	vacc = basis(N,0). 	#make squeezing operator for SPDC; 	H_sq = 1j*eps*(tensor(create(N),create(N))+tensor(destroy(N),destroy(N))); 	; 	#exponentiate hamiltonian and apply it to vaccuum state to make an SPDC state; 	U_sq = H_sq.expm(); 	spdc = U_sq*tensor(vacc,vacc); 	psi = tensor(spdc,spdc); 	#since qutip doesn't have a permute function, ; 	#we have to do a couple of steps in between; 	#1. turn psi from a sparse matrix to a full matrix; 	out = psi.full(); 	#2. reshape psi into a 4-D matrix; 	out = reshape(out, (N,N,N,-1)); 	#3. permute the dimensions of our 4-D matrix; 	out = transpose(out,(0,3,2,1)); 	#4. turn the matrix back into a",MatchSource.DOCS,doc/contrib/sim_ent_qkd/sim_ent_qkd.html,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.html
https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.html:5681,Safety,detect,detectors,5681,"plification, in the ; 	 limit of many coincidences.; ; """"""; 	#make vaccuum state; 	vacc = basis(N,0). 	#make squeezing operator for SPDC; 	H_sq = 1j*eps*(tensor(create(N),create(N))+tensor(destroy(N),destroy(N))); 	; 	#exponentiate hamiltonian and apply it to vaccuum state to make an SPDC state; 	U_sq = H_sq.expm(); 	spdc = U_sq*tensor(vacc,vacc); 	psi = tensor(spdc,spdc); 	#since qutip doesn't have a permute function, ; 	#we have to do a couple of steps in between; 	#1. turn psi from a sparse matrix to a full matrix; 	out = psi.full(); 	#2. reshape psi into a 4-D matrix; 	out = reshape(out, (N,N,N,-1)); 	#3. permute the dimensions of our 4-D matrix; 	out = transpose(out,(0,3,2,1)); 	#4. turn the matrix back into a 1-D array ; 	out = reshape(out,(N*N*N*N,-1)); 	#5. convert the matrix back into a quantum object; 	psi = Qobj(out,dims = [[N, N, N, N], [1, 1, 1, 1]]). 	# model detectors; 	a_det = BucketDetector_realistic_detector(N,loss_a,n_factor_a); 	b_det = BucketDetector_realistic_detector(N,loss_b,n_factor_b); 	; 	#measure detection probabilities; 	probs2f=measure_2folds_4modes_squashing(N,psi,a_det,b_det). 	#Rates returned are 'per pulse', so multiply by source rate; 	twofolds=probs2f[0]+probs2f[1]+probs2f[2]+probs2f[3]; 	#Determine QBER from returned detection probabilities; 	qber = (probs2f[0]+probs2f[3])/twofolds. 	#calculate the entropy of the qber ; 	if qber>0:; 		H2=-qber*log2(qber) - (1-qber)*log2(1-qber); 	else:; 		H2 = 0; 	# estimate error correction efficiency from the CASCADE algorithm ; 	f_e = 1.16904371810274 + qber; 	#security analysis - calculate skr in infinite key limit; 	#See Chris Erven's PhD thesis or Xiongfeng Ma's paper ; 	#to understand where this equation comes from; 	skr=real(twofolds*0.5*(1-(1+f_e)*H2)); 	return [qber, skr, twofolds]. if __name__=='__main__':; 	#Lets look at what happens to the secure key rate and ; 	#the quantum bit error rate as the loss gets worse.; 	#Analogous to distance with fiber optic links.; 	; 	#define the fock s",MatchSource.DOCS,doc/contrib/sim_ent_qkd/sim_ent_qkd.html,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.html
https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.html:5835,Safety,detect,detection,5835,"plification, in the ; 	 limit of many coincidences.; ; """"""; 	#make vaccuum state; 	vacc = basis(N,0). 	#make squeezing operator for SPDC; 	H_sq = 1j*eps*(tensor(create(N),create(N))+tensor(destroy(N),destroy(N))); 	; 	#exponentiate hamiltonian and apply it to vaccuum state to make an SPDC state; 	U_sq = H_sq.expm(); 	spdc = U_sq*tensor(vacc,vacc); 	psi = tensor(spdc,spdc); 	#since qutip doesn't have a permute function, ; 	#we have to do a couple of steps in between; 	#1. turn psi from a sparse matrix to a full matrix; 	out = psi.full(); 	#2. reshape psi into a 4-D matrix; 	out = reshape(out, (N,N,N,-1)); 	#3. permute the dimensions of our 4-D matrix; 	out = transpose(out,(0,3,2,1)); 	#4. turn the matrix back into a 1-D array ; 	out = reshape(out,(N*N*N*N,-1)); 	#5. convert the matrix back into a quantum object; 	psi = Qobj(out,dims = [[N, N, N, N], [1, 1, 1, 1]]). 	# model detectors; 	a_det = BucketDetector_realistic_detector(N,loss_a,n_factor_a); 	b_det = BucketDetector_realistic_detector(N,loss_b,n_factor_b); 	; 	#measure detection probabilities; 	probs2f=measure_2folds_4modes_squashing(N,psi,a_det,b_det). 	#Rates returned are 'per pulse', so multiply by source rate; 	twofolds=probs2f[0]+probs2f[1]+probs2f[2]+probs2f[3]; 	#Determine QBER from returned detection probabilities; 	qber = (probs2f[0]+probs2f[3])/twofolds. 	#calculate the entropy of the qber ; 	if qber>0:; 		H2=-qber*log2(qber) - (1-qber)*log2(1-qber); 	else:; 		H2 = 0; 	# estimate error correction efficiency from the CASCADE algorithm ; 	f_e = 1.16904371810274 + qber; 	#security analysis - calculate skr in infinite key limit; 	#See Chris Erven's PhD thesis or Xiongfeng Ma's paper ; 	#to understand where this equation comes from; 	skr=real(twofolds*0.5*(1-(1+f_e)*H2)); 	return [qber, skr, twofolds]. if __name__=='__main__':; 	#Lets look at what happens to the secure key rate and ; 	#the quantum bit error rate as the loss gets worse.; 	#Analogous to distance with fiber optic links.; 	; 	#define the fock s",MatchSource.DOCS,doc/contrib/sim_ent_qkd/sim_ent_qkd.html,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.html
https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.html:6069,Safety,detect,detection,6069,"hamiltonian and apply it to vaccuum state to make an SPDC state; 	U_sq = H_sq.expm(); 	spdc = U_sq*tensor(vacc,vacc); 	psi = tensor(spdc,spdc); 	#since qutip doesn't have a permute function, ; 	#we have to do a couple of steps in between; 	#1. turn psi from a sparse matrix to a full matrix; 	out = psi.full(); 	#2. reshape psi into a 4-D matrix; 	out = reshape(out, (N,N,N,-1)); 	#3. permute the dimensions of our 4-D matrix; 	out = transpose(out,(0,3,2,1)); 	#4. turn the matrix back into a 1-D array ; 	out = reshape(out,(N*N*N*N,-1)); 	#5. convert the matrix back into a quantum object; 	psi = Qobj(out,dims = [[N, N, N, N], [1, 1, 1, 1]]). 	# model detectors; 	a_det = BucketDetector_realistic_detector(N,loss_a,n_factor_a); 	b_det = BucketDetector_realistic_detector(N,loss_b,n_factor_b); 	; 	#measure detection probabilities; 	probs2f=measure_2folds_4modes_squashing(N,psi,a_det,b_det). 	#Rates returned are 'per pulse', so multiply by source rate; 	twofolds=probs2f[0]+probs2f[1]+probs2f[2]+probs2f[3]; 	#Determine QBER from returned detection probabilities; 	qber = (probs2f[0]+probs2f[3])/twofolds. 	#calculate the entropy of the qber ; 	if qber>0:; 		H2=-qber*log2(qber) - (1-qber)*log2(1-qber); 	else:; 		H2 = 0; 	# estimate error correction efficiency from the CASCADE algorithm ; 	f_e = 1.16904371810274 + qber; 	#security analysis - calculate skr in infinite key limit; 	#See Chris Erven's PhD thesis or Xiongfeng Ma's paper ; 	#to understand where this equation comes from; 	skr=real(twofolds*0.5*(1-(1+f_e)*H2)); 	return [qber, skr, twofolds]. if __name__=='__main__':; 	#Lets look at what happens to the secure key rate and ; 	#the quantum bit error rate as the loss gets worse.; 	#Analogous to distance with fiber optic links.; 	; 	#define the fock space; 	N = 7; 	#define the squeezing paramter; 	eps = 0.2; 	#define the noise factor; 	n_factor = 4.0e-5; 	#define the length of the coincidence window (in s); 	coinc_window = 2.0e-9; 	loss_db = arange(0,30); 	skr = zeros(30); 	qber",MatchSource.DOCS,doc/contrib/sim_ent_qkd/sim_ent_qkd.html,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.html
https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.html:27,Security,secur,secure,27,". '''; Code for simulating secure key rate, twofolds, and quantum bit error rate; Written in Python and QuTIP by Catherine Holloway (c2hollow@iqc.ca). Detector model and squashing functions by Catherine Holloway,; based on code by Dr. Thomas Jennewein (tjennewe@iqc.ca). Contributed to the QuTiP project on June 06, 2012 by Catherine Holloway.; '''. #imports; from qutip import *; from numpy import *; from pylab import *; import matplotlib; import matplotlib.pyplot as plt. def choose(n, k):; 	""""""; 	Binomial coefficient function for the detector model.; 	; 	Parameters; 	----------; 	n : int; 	 Number of elements.; 	k : int; 	 Number of subelements.; 	; 	Returns; 	-------; 	coeff : int; 	 Binomial coefficient.; 	; 	""""""; 	if 0 <= k <= n:; 		ntok = 1; 		ktok = 1; 		for t in xrange(1, min(k, n - k) + 1):; 			ntok *= n; 			ktok *= t; 			n -= 1; 		return ntok // ktok; 	else:; 		return 0. def BucketDetector_realistic_detector(N,efficiency,n_factor):; 	""""""; 	Bucket detector model based on H. Lee, U. Yurtsever, P. Kok, G. Hockney, C. Adami, S. Braunstein,; 	and J. Dowling, ""Towards photostatistics from photon-number discriminating detectors,""; 	Journal of Modern Optics, vol. 51, p. 15171528, 2004.; 	; 	Parameters; 	----------; 	N : int ; 	 The Fock Space dimension.; 	efficiency : float; 	 The channel efficiency.; 	n_factor : float; 	 The average number of dark counts per detection window APD (Bucket Detector).; 	; 	Returns; 	-------; 	[proj, un_proj] : list; 	 The projection and unprojection operators.; 	; 	""""""; 	proj=zeros((N,N)); 	#APD (Bucket Detector) un_detector (=gives probability for 0-detection); 	un_proj=identity(N); 	#n_factor = 0;; 	for i in range(N):; 	 probs = 0;; 	 for k in range (1,100):; 	 for d in range(k+1):; 	 if k-d<=i:; 	 probs= probs+ (exp(-n_factor)*(n_factor)**(d))/factorial(d)*choose(i,k-d)*efficiency**(k-d)*(1-efficiency)**(i-k+d); 	 ; 	 proj[i,i]=probs; 	 ; 	; 	un_proj = un_proj-proj; 	un_proj = Qobj(un_proj); 	proj = Qobj(proj); 	return [proj,un_proj].",MatchSource.DOCS,doc/contrib/sim_ent_qkd/sim_ent_qkd.html,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.html
https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.html:4712,Security,secur,secure,4712,"0][0][0][1]+det_exp[1][0][0][0])+0.25*det_exp[0][0][0][0]. 	return [HH,HV,VH,VV]. def sim_qkd_entanglement(eps,loss_a,loss_b,n_factor_a,n_factor_b,N):; 	""""""; 	Simulate skr with an SPDC state.; 	; 	Parameters; 	----------; 	eps : float; 	 The squeezing factor, sort of analogous to the amount of ; 	 pumping power to the spdc source, but not really.; 	loss_a : float; 	 Efficiency of the quantum channel going to Alice.; 	loss_b : float; 	 Efficiency of the quantum channel going to Bob. ; 	n_factor_a : float; 	 Background noise in Alice's detection.; 	n_factor_b : float; 	 Background noise in Bob's detection.; 	N : int; 	 Size of the fock space that we allow for the states; 	; 	Returns; 	-------; 	qber : float; 	 The Quantum Bit Error Rate; 	twofolds : float; 	 Probability of Alice and Bob getting a simultaneous detection ; 	 of a photon pair (also referred to as coincidences) within a ; 	 timing window.; 	skr : float; 	 Probability of getting a secure key bit within a timing window, ; 	 assuming error correction and privacy amplification, in the ; 	 limit of many coincidences.; ; """"""; 	#make vaccuum state; 	vacc = basis(N,0). 	#make squeezing operator for SPDC; 	H_sq = 1j*eps*(tensor(create(N),create(N))+tensor(destroy(N),destroy(N))); 	; 	#exponentiate hamiltonian and apply it to vaccuum state to make an SPDC state; 	U_sq = H_sq.expm(); 	spdc = U_sq*tensor(vacc,vacc); 	psi = tensor(spdc,spdc); 	#since qutip doesn't have a permute function, ; 	#we have to do a couple of steps in between; 	#1. turn psi from a sparse matrix to a full matrix; 	out = psi.full(); 	#2. reshape psi into a 4-D matrix; 	out = reshape(out, (N,N,N,-1)); 	#3. permute the dimensions of our 4-D matrix; 	out = transpose(out,(0,3,2,1)); 	#4. turn the matrix back into a 1-D array ; 	out = reshape(out,(N*N*N*N,-1)); 	#5. convert the matrix back into a quantum object; 	psi = Qobj(out,dims = [[N, N, N, N], [1, 1, 1, 1]]). 	# model detectors; 	a_det = BucketDetector_realistic_detector(N,loss_a,n_factor_a); 	",MatchSource.DOCS,doc/contrib/sim_ent_qkd/sim_ent_qkd.html,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.html
https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.html:6355,Security,secur,security,6355," of our 4-D matrix; 	out = transpose(out,(0,3,2,1)); 	#4. turn the matrix back into a 1-D array ; 	out = reshape(out,(N*N*N*N,-1)); 	#5. convert the matrix back into a quantum object; 	psi = Qobj(out,dims = [[N, N, N, N], [1, 1, 1, 1]]). 	# model detectors; 	a_det = BucketDetector_realistic_detector(N,loss_a,n_factor_a); 	b_det = BucketDetector_realistic_detector(N,loss_b,n_factor_b); 	; 	#measure detection probabilities; 	probs2f=measure_2folds_4modes_squashing(N,psi,a_det,b_det). 	#Rates returned are 'per pulse', so multiply by source rate; 	twofolds=probs2f[0]+probs2f[1]+probs2f[2]+probs2f[3]; 	#Determine QBER from returned detection probabilities; 	qber = (probs2f[0]+probs2f[3])/twofolds. 	#calculate the entropy of the qber ; 	if qber>0:; 		H2=-qber*log2(qber) - (1-qber)*log2(1-qber); 	else:; 		H2 = 0; 	# estimate error correction efficiency from the CASCADE algorithm ; 	f_e = 1.16904371810274 + qber; 	#security analysis - calculate skr in infinite key limit; 	#See Chris Erven's PhD thesis or Xiongfeng Ma's paper ; 	#to understand where this equation comes from; 	skr=real(twofolds*0.5*(1-(1+f_e)*H2)); 	return [qber, skr, twofolds]. if __name__=='__main__':; 	#Lets look at what happens to the secure key rate and ; 	#the quantum bit error rate as the loss gets worse.; 	#Analogous to distance with fiber optic links.; 	; 	#define the fock space; 	N = 7; 	#define the squeezing paramter; 	eps = 0.2; 	#define the noise factor; 	n_factor = 4.0e-5; 	#define the length of the coincidence window (in s); 	coinc_window = 2.0e-9; 	loss_db = arange(0,30); 	skr = zeros(30); 	qber = zeros(30); 	twofolds = zeros(30); ; #run calculation; 	for i in range(30):; 		exp_loss = 10.0**(-loss_db[i]/10.0);; 		[qber[i], skr[i], twofolds[i]] = sim_qkd_entanglement(eps,exp_loss,exp_loss,n_factor,n_factor,N); 	skr = skr/coinc_window; 	qber = qber*100; ; #plot results; 	fig = plt.figure(); 	ax = fig.add_subplot(211); 	ax.plot(loss_db, skr,lw=2); 	ax.set_yscale('log'); 	ax.set_ylabel('Secure Key",MatchSource.DOCS,doc/contrib/sim_ent_qkd/sim_ent_qkd.html,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.html
https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.html:6649,Security,secur,secure,6649,"N, N], [1, 1, 1, 1]]). 	# model detectors; 	a_det = BucketDetector_realistic_detector(N,loss_a,n_factor_a); 	b_det = BucketDetector_realistic_detector(N,loss_b,n_factor_b); 	; 	#measure detection probabilities; 	probs2f=measure_2folds_4modes_squashing(N,psi,a_det,b_det). 	#Rates returned are 'per pulse', so multiply by source rate; 	twofolds=probs2f[0]+probs2f[1]+probs2f[2]+probs2f[3]; 	#Determine QBER from returned detection probabilities; 	qber = (probs2f[0]+probs2f[3])/twofolds. 	#calculate the entropy of the qber ; 	if qber>0:; 		H2=-qber*log2(qber) - (1-qber)*log2(1-qber); 	else:; 		H2 = 0; 	# estimate error correction efficiency from the CASCADE algorithm ; 	f_e = 1.16904371810274 + qber; 	#security analysis - calculate skr in infinite key limit; 	#See Chris Erven's PhD thesis or Xiongfeng Ma's paper ; 	#to understand where this equation comes from; 	skr=real(twofolds*0.5*(1-(1+f_e)*H2)); 	return [qber, skr, twofolds]. if __name__=='__main__':; 	#Lets look at what happens to the secure key rate and ; 	#the quantum bit error rate as the loss gets worse.; 	#Analogous to distance with fiber optic links.; 	; 	#define the fock space; 	N = 7; 	#define the squeezing paramter; 	eps = 0.2; 	#define the noise factor; 	n_factor = 4.0e-5; 	#define the length of the coincidence window (in s); 	coinc_window = 2.0e-9; 	loss_db = arange(0,30); 	skr = zeros(30); 	qber = zeros(30); 	twofolds = zeros(30); ; #run calculation; 	for i in range(30):; 		exp_loss = 10.0**(-loss_db[i]/10.0);; 		[qber[i], skr[i], twofolds[i]] = sim_qkd_entanglement(eps,exp_loss,exp_loss,n_factor,n_factor,N); 	skr = skr/coinc_window; 	qber = qber*100; ; #plot results; 	fig = plt.figure(); 	ax = fig.add_subplot(211); 	ax.plot(loss_db, skr,lw=2); 	ax.set_yscale('log'); 	ax.set_ylabel('Secure Key Rate (bits/s)'); 	ax.set_xlabel('Loss (dB)'); 	ax = fig.add_subplot(212); 	ax.plot(loss_db, qber,lw=2); 	ax.set_ylabel('Quantum Bit Error Rate (%)'); 	ax.set_ylim([0,15]); 	ax.set_xlabel('Loss (dB)'); 	plt.show(). ",MatchSource.DOCS,doc/contrib/sim_ent_qkd/sim_ent_qkd.html,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.html
https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.html:7401,Testability,log,log,7401,"N, N], [1, 1, 1, 1]]). 	# model detectors; 	a_det = BucketDetector_realistic_detector(N,loss_a,n_factor_a); 	b_det = BucketDetector_realistic_detector(N,loss_b,n_factor_b); 	; 	#measure detection probabilities; 	probs2f=measure_2folds_4modes_squashing(N,psi,a_det,b_det). 	#Rates returned are 'per pulse', so multiply by source rate; 	twofolds=probs2f[0]+probs2f[1]+probs2f[2]+probs2f[3]; 	#Determine QBER from returned detection probabilities; 	qber = (probs2f[0]+probs2f[3])/twofolds. 	#calculate the entropy of the qber ; 	if qber>0:; 		H2=-qber*log2(qber) - (1-qber)*log2(1-qber); 	else:; 		H2 = 0; 	# estimate error correction efficiency from the CASCADE algorithm ; 	f_e = 1.16904371810274 + qber; 	#security analysis - calculate skr in infinite key limit; 	#See Chris Erven's PhD thesis or Xiongfeng Ma's paper ; 	#to understand where this equation comes from; 	skr=real(twofolds*0.5*(1-(1+f_e)*H2)); 	return [qber, skr, twofolds]. if __name__=='__main__':; 	#Lets look at what happens to the secure key rate and ; 	#the quantum bit error rate as the loss gets worse.; 	#Analogous to distance with fiber optic links.; 	; 	#define the fock space; 	N = 7; 	#define the squeezing paramter; 	eps = 0.2; 	#define the noise factor; 	n_factor = 4.0e-5; 	#define the length of the coincidence window (in s); 	coinc_window = 2.0e-9; 	loss_db = arange(0,30); 	skr = zeros(30); 	qber = zeros(30); 	twofolds = zeros(30); ; #run calculation; 	for i in range(30):; 		exp_loss = 10.0**(-loss_db[i]/10.0);; 		[qber[i], skr[i], twofolds[i]] = sim_qkd_entanglement(eps,exp_loss,exp_loss,n_factor,n_factor,N); 	skr = skr/coinc_window; 	qber = qber*100; ; #plot results; 	fig = plt.figure(); 	ax = fig.add_subplot(211); 	ax.plot(loss_db, skr,lw=2); 	ax.set_yscale('log'); 	ax.set_ylabel('Secure Key Rate (bits/s)'); 	ax.set_xlabel('Loss (dB)'); 	ax = fig.add_subplot(212); 	ax.plot(loss_db, qber,lw=2); 	ax.set_ylabel('Quantum Bit Error Rate (%)'); 	ax.set_ylim([0,15]); 	ax.set_xlabel('Loss (dB)'); 	plt.show(). ",MatchSource.DOCS,doc/contrib/sim_ent_qkd/sim_ent_qkd.html,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.html
