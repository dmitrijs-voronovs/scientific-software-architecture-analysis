quality_attribute,keyword,matched_word,sentence,source,filename,author,repo,version,wiki,url
Availability,avail,available,"As contributors and maintainers of this project, and in the interest of fostering an open and welcoming community, we pledge to respect all people who contribute through reporting issues, posting feature requests, updating documentation, submitting pull requests or patches, and other activities. We are committed to making participation in this project a harassment-free experience for everyone, regardless of level of experience, gender, gender identity and expression, sexual orientation, disability, personal appearance, body size, race, ethnicity, age, religion, or nationality. Examples of unacceptable behavior by participants include:. * The use of sexualized language or imagery; * Personal attacks; * Trolling or insulting/derogatory comments; * Public or private harassment; * Publishing other's private information, such as physical or electronic addresses, without explicit permission; * Other unethical or unprofessional conduct. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct. By adopting this Code of Conduct, project maintainers commit themselves to fairly and consistently applying these principles to every aspect of managing this project. Project maintainers who do not follow or enforce the Code of Conduct may be permanently removed from the project team. This code of conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. . Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by opening an issue or contacting one or more of the project maintainers. . This Code of Conduct is adapted from the Contributor Covenant , version 1.2.0, available at https://www.contributor-covenant.org/version/1/2/0/code-of-conduct.html . [homepage]: https://contributor-covenant.org; [version]: https://contributor-covenant.org/version/1/2/; ",MatchSource.DOCS,CODE_OF_CONDUCT.md,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/CODE_OF_CONDUCT.md
Deployability,patch,patches,"# Contributor Covenant Code of Conduct. As contributors and maintainers of this project, and in the interest of fostering an open and welcoming community, we pledge to respect all people who contribute through reporting issues, posting feature requests, updating documentation, submitting pull requests or patches, and other activities. We are committed to making participation in this project a harassment-free experience for everyone, regardless of level of experience, gender, gender identity and expression, sexual orientation, disability, personal appearance, body size, race, ethnicity, age, religion, or nationality. Examples of unacceptable behavior by participants include:. * The use of sexualized language or imagery; * Personal attacks; * Trolling or insulting/derogatory comments; * Public or private harassment; * Publishing other's private information, such as physical or electronic addresses, without explicit permission; * Other unethical or unprofessional conduct. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct. By adopting this Code of Conduct, project maintainers commit themselves to fairly and consistently applying these principles to every aspect of managing this project. Project maintainers who do not follow or enforce the Code of Conduct may be permanently removed from the project team. This code of conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. . Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by opening an issue or contacting one or more of the project maintainers. . This Code of Conduct is adapted from the Contributor Covenant , version 1.2.0, available at https://www.contributor-covenant.org/version/1/2/0/code-of-conduct.html . [homepage]: https://contributor-covenant.org; [version]: https://",MatchSource.DOCS,CODE_OF_CONDUCT.md,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/CODE_OF_CONDUCT.md
Energy Efficiency,adapt,adapted,"As contributors and maintainers of this project, and in the interest of fostering an open and welcoming community, we pledge to respect all people who contribute through reporting issues, posting feature requests, updating documentation, submitting pull requests or patches, and other activities. We are committed to making participation in this project a harassment-free experience for everyone, regardless of level of experience, gender, gender identity and expression, sexual orientation, disability, personal appearance, body size, race, ethnicity, age, religion, or nationality. Examples of unacceptable behavior by participants include:. * The use of sexualized language or imagery; * Personal attacks; * Trolling or insulting/derogatory comments; * Public or private harassment; * Publishing other's private information, such as physical or electronic addresses, without explicit permission; * Other unethical or unprofessional conduct. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct. By adopting this Code of Conduct, project maintainers commit themselves to fairly and consistently applying these principles to every aspect of managing this project. Project maintainers who do not follow or enforce the Code of Conduct may be permanently removed from the project team. This code of conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. . Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by opening an issue or contacting one or more of the project maintainers. . This Code of Conduct is adapted from the Contributor Covenant , version 1.2.0, available at https://www.contributor-covenant.org/version/1/2/0/code-of-conduct.html . [homepage]: https://contributor-covenant.org; [version]: https://contributor-covenant.org/version/1/2/; ",MatchSource.DOCS,CODE_OF_CONDUCT.md,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/CODE_OF_CONDUCT.md
Modifiability,adapt,adapted,"As contributors and maintainers of this project, and in the interest of fostering an open and welcoming community, we pledge to respect all people who contribute through reporting issues, posting feature requests, updating documentation, submitting pull requests or patches, and other activities. We are committed to making participation in this project a harassment-free experience for everyone, regardless of level of experience, gender, gender identity and expression, sexual orientation, disability, personal appearance, body size, race, ethnicity, age, religion, or nationality. Examples of unacceptable behavior by participants include:. * The use of sexualized language or imagery; * Personal attacks; * Trolling or insulting/derogatory comments; * Public or private harassment; * Publishing other's private information, such as physical or electronic addresses, without explicit permission; * Other unethical or unprofessional conduct. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct. By adopting this Code of Conduct, project maintainers commit themselves to fairly and consistently applying these principles to every aspect of managing this project. Project maintainers who do not follow or enforce the Code of Conduct may be permanently removed from the project team. This code of conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. . Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by opening an issue or contacting one or more of the project maintainers. . This Code of Conduct is adapted from the Contributor Covenant , version 1.2.0, available at https://www.contributor-covenant.org/version/1/2/0/code-of-conduct.html . [homepage]: https://contributor-covenant.org; [version]: https://contributor-covenant.org/version/1/2/; ",MatchSource.DOCS,CODE_OF_CONDUCT.md,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/CODE_OF_CONDUCT.md
Security,attack,attacks,"# Contributor Covenant Code of Conduct. As contributors and maintainers of this project, and in the interest of fostering an open and welcoming community, we pledge to respect all people who contribute through reporting issues, posting feature requests, updating documentation, submitting pull requests or patches, and other activities. We are committed to making participation in this project a harassment-free experience for everyone, regardless of level of experience, gender, gender identity and expression, sexual orientation, disability, personal appearance, body size, race, ethnicity, age, religion, or nationality. Examples of unacceptable behavior by participants include:. * The use of sexualized language or imagery; * Personal attacks; * Trolling or insulting/derogatory comments; * Public or private harassment; * Publishing other's private information, such as physical or electronic addresses, without explicit permission; * Other unethical or unprofessional conduct. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct. By adopting this Code of Conduct, project maintainers commit themselves to fairly and consistently applying these principles to every aspect of managing this project. Project maintainers who do not follow or enforce the Code of Conduct may be permanently removed from the project team. This code of conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. . Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by opening an issue or contacting one or more of the project maintainers. . This Code of Conduct is adapted from the Contributor Covenant , version 1.2.0, available at https://www.contributor-covenant.org/version/1/2/0/code-of-conduct.html . [homepage]: https://contributor-covenant.org; [version]: https://",MatchSource.DOCS,CODE_OF_CONDUCT.md,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/CODE_OF_CONDUCT.md
Availability,down,downloads,"tps://github.com/boxili),; [J. Lishman](https://github.com/jakelishman),; [S. Cross](https://github.com/hodgestar),; [A. Galicia](https://github.com/AGaliciaMartinez),; [P. Menczel](https://github.com/pmenczel),; [P. Hopf](https://github.com/flowerthrower/),; [P. D. Nation](https://github.com/nonhermitian),; and [J. R. Johansson](https://github.com/jrjohansson). [![Build Status](https://github.com/qutip/qutip/actions/workflows/tests.yml/badge.svg?branch=master)](https://github.com/qutip/qutip/actions/workflows/tests.yml); [![Coverage Status](https://img.shields.io/coveralls/qutip/qutip.svg?logo=Coveralls)](https://coveralls.io/r/qutip/qutip); [![Maintainability](https://api.codeclimate.com/v1/badges/df502674f1dfa1f1b67a/maintainability)](https://codeclimate.com/github/qutip/qutip/maintainability); [![license](https://img.shields.io/badge/license-New%20BSD-blue.svg)](https://opensource.org/licenses/BSD-3-Clause); [![PyPi Downloads](https://img.shields.io/pypi/dm/qutip?label=downloads%20%7C%20pip&logo=PyPI)](https://pypi.org/project/qutip); [![Conda-Forge Downloads](https://img.shields.io/conda/dn/conda-forge/qutip?label=downloads%20%7C%20conda&logo=Conda-Forge)](https://anaconda.org/conda-forge/qutip). QuTiP is open-source software for simulating the dynamics of closed and open quantum systems.; It uses the excellent Numpy, Scipy, and Cython packages as numerical backends, and graphical output is provided by Matplotlib.; QuTiP aims to provide user-friendly and efficient numerical simulations of a wide variety of quantum mechanical problems, including those with Hamiltonians and/or collapse operators with arbitrary time-dependence, commonly found in a wide range of physics applications.; QuTiP is freely available for use and/or modification, and it can be used on all Unix-based platforms and on Windows.; Being free of any licensing fees, QuTiP is ideal for exploring quantum mechanics in research as well as in the classroom. Support; -------. [![Unitary Fund](https://i",MatchSource.DOCS,README.md,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/README.md
Deployability,install,install,"red%20by-NumFOCUS-orange.svg?style=flat&colorA=E1523D&colorB=007D8A)](https://numfocus.org). We are proud to be affiliated with [Unitary Fund](https://unitary.fund) and [numFOCUS](https://numfocus.org). We are grateful for [Nori's lab](https://dml.riken.jp/) at RIKEN and [Blais' lab](https://www.physique.usherbrooke.ca/blais/) at the Institut Quantique; for providing developer positions to work on QuTiP. We also thank Google for supporting us by financing GSoC students to work on the QuTiP as well as [other supporting organizations](https://qutip.org/#supporting-organizations) that have been supporting QuTiP over the years. Installation; ------------. [![Pip Package](https://img.shields.io/pypi/v/qutip?logo=PyPI)](https://pypi.org/project/qutip); [![Conda-Forge Package](https://img.shields.io/conda/vn/conda-forge/qutip?logo=Conda-Forge)](https://anaconda.org/conda-forge/qutip). QuTiP is available on both `pip` and `conda` (the latter in the `conda-forge` channel).; You can install QuTiP from `pip` by doing. ```bash; pip install qutip; ```. to get the minimal installation.; You can instead use the target `qutip[full]` to install QuTiP with all its optional dependencies.; For more details, including instructions on how to build from source, see [the detailed installation guide in the documentation](https://qutip.readthedocs.io/en/stable/installation.html). All back releases are also available for download in the [releases section of this repository](https://github.com/qutip/qutip/releases), where you can also find per-version changelogs.; For the most complete set of release notes and changelogs for historic versions, see the [changelog](https://qutip.readthedocs.io/en/stable/changelog.html) section in the documentation. The pre-release of QuTiP 5.0 is available on PyPI and can be installed using pip:. ```bash; pip install --pre qutip; ```. This version breaks compatibility with QuTiP 4.7 in many small ways.; Please see the [changelog](https://github.com/qutip/qutip/b",MatchSource.DOCS,README.md,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/README.md
Energy Efficiency,efficient,efficient,"lls/qutip/qutip.svg?logo=Coveralls)](https://coveralls.io/r/qutip/qutip); [![Maintainability](https://api.codeclimate.com/v1/badges/df502674f1dfa1f1b67a/maintainability)](https://codeclimate.com/github/qutip/qutip/maintainability); [![license](https://img.shields.io/badge/license-New%20BSD-blue.svg)](https://opensource.org/licenses/BSD-3-Clause); [![PyPi Downloads](https://img.shields.io/pypi/dm/qutip?label=downloads%20%7C%20pip&logo=PyPI)](https://pypi.org/project/qutip); [![Conda-Forge Downloads](https://img.shields.io/conda/dn/conda-forge/qutip?label=downloads%20%7C%20conda&logo=Conda-Forge)](https://anaconda.org/conda-forge/qutip). QuTiP is open-source software for simulating the dynamics of closed and open quantum systems.; It uses the excellent Numpy, Scipy, and Cython packages as numerical backends, and graphical output is provided by Matplotlib.; QuTiP aims to provide user-friendly and efficient numerical simulations of a wide variety of quantum mechanical problems, including those with Hamiltonians and/or collapse operators with arbitrary time-dependence, commonly found in a wide range of physics applications.; QuTiP is freely available for use and/or modification, and it can be used on all Unix-based platforms and on Windows.; Being free of any licensing fees, QuTiP is ideal for exploring quantum mechanics in research as well as in the classroom. Support; -------. [![Unitary Fund](https://img.shields.io/badge/Supported%20By-UNITARY%20FUND-brightgreen.svg?style=flat)](https://unitary.fund); [![Powered by NumFOCUS](https://img.shields.io/badge/powered%20by-NumFOCUS-orange.svg?style=flat&colorA=E1523D&colorB=007D8A)](https://numfocus.org). We are proud to be affiliated with [Unitary Fund](https://unitary.fund) and [numFOCUS](https://numfocus.org). We are grateful for [Nori's lab](https://dml.riken.jp/) at RIKEN and [Blais' lab](https://www.physique.usherbrooke.ca/blais/) at the Institut Quantique; for providing developer positions to work on QuTiP. We also tha",MatchSource.DOCS,README.md,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/README.md
Integrability,depend,dependence,"lls/qutip/qutip.svg?logo=Coveralls)](https://coveralls.io/r/qutip/qutip); [![Maintainability](https://api.codeclimate.com/v1/badges/df502674f1dfa1f1b67a/maintainability)](https://codeclimate.com/github/qutip/qutip/maintainability); [![license](https://img.shields.io/badge/license-New%20BSD-blue.svg)](https://opensource.org/licenses/BSD-3-Clause); [![PyPi Downloads](https://img.shields.io/pypi/dm/qutip?label=downloads%20%7C%20pip&logo=PyPI)](https://pypi.org/project/qutip); [![Conda-Forge Downloads](https://img.shields.io/conda/dn/conda-forge/qutip?label=downloads%20%7C%20conda&logo=Conda-Forge)](https://anaconda.org/conda-forge/qutip). QuTiP is open-source software for simulating the dynamics of closed and open quantum systems.; It uses the excellent Numpy, Scipy, and Cython packages as numerical backends, and graphical output is provided by Matplotlib.; QuTiP aims to provide user-friendly and efficient numerical simulations of a wide variety of quantum mechanical problems, including those with Hamiltonians and/or collapse operators with arbitrary time-dependence, commonly found in a wide range of physics applications.; QuTiP is freely available for use and/or modification, and it can be used on all Unix-based platforms and on Windows.; Being free of any licensing fees, QuTiP is ideal for exploring quantum mechanics in research as well as in the classroom. Support; -------. [![Unitary Fund](https://img.shields.io/badge/Supported%20By-UNITARY%20FUND-brightgreen.svg?style=flat)](https://unitary.fund); [![Powered by NumFOCUS](https://img.shields.io/badge/powered%20by-NumFOCUS-orange.svg?style=flat&colorA=E1523D&colorB=007D8A)](https://numfocus.org). We are proud to be affiliated with [Unitary Fund](https://unitary.fund) and [numFOCUS](https://numfocus.org). We are grateful for [Nori's lab](https://dml.riken.jp/) at RIKEN and [Blais' lab](https://www.physique.usherbrooke.ca/blais/) at the Institut Quantique; for providing developer positions to work on QuTiP. We also tha",MatchSource.DOCS,README.md,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/README.md
Modifiability,maintainab,maintainability,"nade](https://github.com/cgranade),; [A. Grimsmo](https://github.com/arnelg),; [N. Shammah](https://github.com/nathanshammah),; [S. Ahmed](https://github.com/quantshah),; [N. Lambert](https://github.com/nwlambert),; [E. Giguère](https://github.com/ericgig),; [B. Li](https://github.com/boxili),; [J. Lishman](https://github.com/jakelishman),; [S. Cross](https://github.com/hodgestar),; [A. Galicia](https://github.com/AGaliciaMartinez),; [P. Menczel](https://github.com/pmenczel),; [P. Hopf](https://github.com/flowerthrower/),; [P. D. Nation](https://github.com/nonhermitian),; and [J. R. Johansson](https://github.com/jrjohansson). [![Build Status](https://github.com/qutip/qutip/actions/workflows/tests.yml/badge.svg?branch=master)](https://github.com/qutip/qutip/actions/workflows/tests.yml); [![Coverage Status](https://img.shields.io/coveralls/qutip/qutip.svg?logo=Coveralls)](https://coveralls.io/r/qutip/qutip); [![Maintainability](https://api.codeclimate.com/v1/badges/df502674f1dfa1f1b67a/maintainability)](https://codeclimate.com/github/qutip/qutip/maintainability); [![license](https://img.shields.io/badge/license-New%20BSD-blue.svg)](https://opensource.org/licenses/BSD-3-Clause); [![PyPi Downloads](https://img.shields.io/pypi/dm/qutip?label=downloads%20%7C%20pip&logo=PyPI)](https://pypi.org/project/qutip); [![Conda-Forge Downloads](https://img.shields.io/conda/dn/conda-forge/qutip?label=downloads%20%7C%20conda&logo=Conda-Forge)](https://anaconda.org/conda-forge/qutip). QuTiP is open-source software for simulating the dynamics of closed and open quantum systems.; It uses the excellent Numpy, Scipy, and Cython packages as numerical backends, and graphical output is provided by Matplotlib.; QuTiP aims to provide user-friendly and efficient numerical simulations of a wide variety of quantum mechanical problems, including those with Hamiltonians and/or collapse operators with arbitrary time-dependence, commonly found in a wide range of physics applications.; QuTiP is freely a",MatchSource.DOCS,README.md,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/README.md
Testability,test,tests,"QuTiP: Quantum Toolbox in Python; ================================. [A. Pitchford](https://github.com/ajgpitch),; [C. Granade](https://github.com/cgranade),; [A. Grimsmo](https://github.com/arnelg),; [N. Shammah](https://github.com/nathanshammah),; [S. Ahmed](https://github.com/quantshah),; [N. Lambert](https://github.com/nwlambert),; [E. Giguère](https://github.com/ericgig),; [B. Li](https://github.com/boxili),; [J. Lishman](https://github.com/jakelishman),; [S. Cross](https://github.com/hodgestar),; [A. Galicia](https://github.com/AGaliciaMartinez),; [P. Menczel](https://github.com/pmenczel),; [P. Hopf](https://github.com/flowerthrower/),; [P. D. Nation](https://github.com/nonhermitian),; and [J. R. Johansson](https://github.com/jrjohansson). [![Build Status](https://github.com/qutip/qutip/actions/workflows/tests.yml/badge.svg?branch=master)](https://github.com/qutip/qutip/actions/workflows/tests.yml); [![Coverage Status](https://img.shields.io/coveralls/qutip/qutip.svg?logo=Coveralls)](https://coveralls.io/r/qutip/qutip); [![Maintainability](https://api.codeclimate.com/v1/badges/df502674f1dfa1f1b67a/maintainability)](https://codeclimate.com/github/qutip/qutip/maintainability); [![license](https://img.shields.io/badge/license-New%20BSD-blue.svg)](https://opensource.org/licenses/BSD-3-Clause); [![PyPi Downloads](https://img.shields.io/pypi/dm/qutip?label=downloads%20%7C%20pip&logo=PyPI)](https://pypi.org/project/qutip); [![Conda-Forge Downloads](https://img.shields.io/conda/dn/conda-forge/qutip?label=downloads%20%7C%20conda&logo=Conda-Forge)](https://anaconda.org/conda-forge/qutip). QuTiP is open-source software for simulating the dynamics of closed and open quantum systems.; It uses the excellent Numpy, Scipy, and Cython packages as numerical backends, and graphical output is provided by Matplotlib.; QuTiP aims to provide user-friendly and efficient numerical simulations of a wide variety of quantum mechanical problems, including those with Hamiltonians and/or coll",MatchSource.DOCS,README.md,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/README.md
Usability,user-friendly,user-friendly,"lls/qutip/qutip.svg?logo=Coveralls)](https://coveralls.io/r/qutip/qutip); [![Maintainability](https://api.codeclimate.com/v1/badges/df502674f1dfa1f1b67a/maintainability)](https://codeclimate.com/github/qutip/qutip/maintainability); [![license](https://img.shields.io/badge/license-New%20BSD-blue.svg)](https://opensource.org/licenses/BSD-3-Clause); [![PyPi Downloads](https://img.shields.io/pypi/dm/qutip?label=downloads%20%7C%20pip&logo=PyPI)](https://pypi.org/project/qutip); [![Conda-Forge Downloads](https://img.shields.io/conda/dn/conda-forge/qutip?label=downloads%20%7C%20conda&logo=Conda-Forge)](https://anaconda.org/conda-forge/qutip). QuTiP is open-source software for simulating the dynamics of closed and open quantum systems.; It uses the excellent Numpy, Scipy, and Cython packages as numerical backends, and graphical output is provided by Matplotlib.; QuTiP aims to provide user-friendly and efficient numerical simulations of a wide variety of quantum mechanical problems, including those with Hamiltonians and/or collapse operators with arbitrary time-dependence, commonly found in a wide range of physics applications.; QuTiP is freely available for use and/or modification, and it can be used on all Unix-based platforms and on Windows.; Being free of any licensing fees, QuTiP is ideal for exploring quantum mechanics in research as well as in the classroom. Support; -------. [![Unitary Fund](https://img.shields.io/badge/Supported%20By-UNITARY%20FUND-brightgreen.svg?style=flat)](https://unitary.fund); [![Powered by NumFOCUS](https://img.shields.io/badge/powered%20by-NumFOCUS-orange.svg?style=flat&colorA=E1523D&colorB=007D8A)](https://numfocus.org). We are proud to be affiliated with [Unitary Fund](https://unitary.fund) and [numFOCUS](https://numfocus.org). We are grateful for [Nori's lab](https://dml.riken.jp/) at RIKEN and [Blais' lab](https://www.physique.usherbrooke.ca/blais/) at the Institut Quantique; for providing developer positions to work on QuTiP. We also tha",MatchSource.DOCS,README.md,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/README.md
Deployability,update,update,"**Checklist**; Thank you for contributing to QuTiP! Please make sure you have finished the following tasks before opening the PR. - [ ] Please read [Contributing to QuTiP Development](http://qutip.org/docs/latest/development/contributing.html); - [ ] Contributions to qutip should follow the [pep8 style](https://www.python.org/dev/peps/pep-0008/).; You can use [pycodestyle](http://pycodestyle.pycqa.org/en/latest/index.html) to check your code automatically; - [ ] Please add tests to cover your changes if applicable.; - [ ] If the behavior of the code has changed or new feature has been added, please also update the documentation in the `doc` folder, and the [notebook](https://github.com/qutip/qutip-tutorials). Feel free to ask if you are not sure.; - [ ] Include the changelog in a file named: `doc/changes/<PR number>.<type>` 'type' can be one of the following: feature, bugfix, doc, removal, misc, or deprecation (see [here](http://qutip.org/docs/latest/development/contributing.html#changelog-generation) for more information). Delete this checklist after you have completed all the tasks. If you have not finished them all, you can also open a [Draft Pull Request](https://github.blog/2019-02-14-introducing-draft-pull-requests/) to let the others know this on-going work and keep this checklist in the PR description. **Description**; Describe here the proposed change. **Related issues or PRs**; Please mention the related issues or PRs here. If the PR fixes an issue, use the keyword fix/fixes/fixed followed by the issue id, e.g. fix #1184",MatchSource.DOCS,.github/pull_request_template.md,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/.github/pull_request_template.md
Testability,test,tests,"**Checklist**; Thank you for contributing to QuTiP! Please make sure you have finished the following tasks before opening the PR. - [ ] Please read [Contributing to QuTiP Development](http://qutip.org/docs/latest/development/contributing.html); - [ ] Contributions to qutip should follow the [pep8 style](https://www.python.org/dev/peps/pep-0008/).; You can use [pycodestyle](http://pycodestyle.pycqa.org/en/latest/index.html) to check your code automatically; - [ ] Please add tests to cover your changes if applicable.; - [ ] If the behavior of the code has changed or new feature has been added, please also update the documentation in the `doc` folder, and the [notebook](https://github.com/qutip/qutip-tutorials). Feel free to ask if you are not sure.; - [ ] Include the changelog in a file named: `doc/changes/<PR number>.<type>` 'type' can be one of the following: feature, bugfix, doc, removal, misc, or deprecation (see [here](http://qutip.org/docs/latest/development/contributing.html#changelog-generation) for more information). Delete this checklist after you have completed all the tasks. If you have not finished them all, you can also open a [Draft Pull Request](https://github.blog/2019-02-14-introducing-draft-pull-requests/) to let the others know this on-going work and keep this checklist in the PR description. **Description**; Describe here the proposed change. **Related issues or PRs**; Please mention the related issues or PRs here. If the PR fixes an issue, use the keyword fix/fixes/fixed followed by the issue id, e.g. fix #1184",MatchSource.DOCS,.github/pull_request_template.md,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/.github/pull_request_template.md
Deployability,install,install,"Repository for QuTiP documentation; ==================================. This repository contains the source files for the QuTiP documentation. For pre-built documentation, see https://www.qutip.org/documentation.html. Building; --------. The main Python requirements for the documentation are `sphinx`, `sphinx-gallery`, `sphinx_rtd_theme`, `numpydoc` and `ipython`.; You should build or install the version of QuTiP you want to build the documentation against in the same environment.; You will also need a sensible copy of `make`, and if you want to build the LaTeX documentation then also a `pdflatex` distribution.; As of 2021-04-20, the `conda` recipe for `sphinx_rtd_theme` is rather old compared to the `pip` version, so it's recommended to use a mostly `pip`-managed environment to do the documentation build. The simplest way to get a functional build environment is to use the `requirements.txt` file in this repository, which completely defines a known-good `pip` environment (tested on Python 3.8, but not necessarily limited to it).; If you typically use conda, the way to do this is; ```bash; $ conda create -n qutip-doc-build python=3.8; $ conda activate qutip-doc-build; $ pip install -r /path/to/qutip/doc/requirements.txt; ```; You will also need to build or install the main QuTiP library in the same environment.; If you simply want to build the documentation without editing the main library, you can install a release version of QuTiP with `pip install qutip`.; Otherwise, refer to [the main repository](https://github.com/qutip/qutip) for the current process to build from source.; You need to have the optional QuTiP dependency `Cython` to build the documentation, but this is included in this repository's `requirements.txt` so you do not need to do anything separately. After you have done this, you can effect the build with `make`.; The targets you might want are `html`, `latexpdf` and `clean`, which build the HTML pages, build the PDFs, and delete all built files respec",MatchSource.DOCS,doc/README.md,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/README.md
Integrability,depend,dependency,"heme` is rather old compared to the `pip` version, so it's recommended to use a mostly `pip`-managed environment to do the documentation build. The simplest way to get a functional build environment is to use the `requirements.txt` file in this repository, which completely defines a known-good `pip` environment (tested on Python 3.8, but not necessarily limited to it).; If you typically use conda, the way to do this is; ```bash; $ conda create -n qutip-doc-build python=3.8; $ conda activate qutip-doc-build; $ pip install -r /path/to/qutip/doc/requirements.txt; ```; You will also need to build or install the main QuTiP library in the same environment.; If you simply want to build the documentation without editing the main library, you can install a release version of QuTiP with `pip install qutip`.; Otherwise, refer to [the main repository](https://github.com/qutip/qutip) for the current process to build from source.; You need to have the optional QuTiP dependency `Cython` to build the documentation, but this is included in this repository's `requirements.txt` so you do not need to do anything separately. After you have done this, you can effect the build with `make`.; The targets you might want are `html`, `latexpdf` and `clean`, which build the HTML pages, build the PDFs, and delete all built files respectively.; For example, to build the HTML files only, use; ```bash; $ make html; ```. *Note (2021-04-20):* the documentation build is currently broken on Windows due to incompatibilities in the main library in multiprocessing components. Writing User Guides; -------------------. The user guide provides an overview of QuTiP's functionality. The guide is composed of individual reStructuredText (`.rst`) files which each get rendered as a webpage. Each page typically tackles one area of functionality. To learn more about how to write `.rst` files, it is useful to follow the [Sphinx Guide](https://www.sphinx-doc.org/en/master/usage/index.html). The documentation build als",MatchSource.DOCS,doc/README.md,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/README.md
Modifiability,config,configured," version of QuTiP with `pip install qutip`.; Otherwise, refer to [the main repository](https://github.com/qutip/qutip) for the current process to build from source.; You need to have the optional QuTiP dependency `Cython` to build the documentation, but this is included in this repository's `requirements.txt` so you do not need to do anything separately. After you have done this, you can effect the build with `make`.; The targets you might want are `html`, `latexpdf` and `clean`, which build the HTML pages, build the PDFs, and delete all built files respectively.; For example, to build the HTML files only, use; ```bash; $ make html; ```. *Note (2021-04-20):* the documentation build is currently broken on Windows due to incompatibilities in the main library in multiprocessing components. Writing User Guides; -------------------. The user guide provides an overview of QuTiP's functionality. The guide is composed of individual reStructuredText (`.rst`) files which each get rendered as a webpage. Each page typically tackles one area of functionality. To learn more about how to write `.rst` files, it is useful to follow the [Sphinx Guide](https://www.sphinx-doc.org/en/master/usage/index.html). The documentation build also utilizes a number of [Sphinx Extensions](https://www.sphinx-doc.org/en/master/usage/extensions/index.html) including but not limited to; [doctest](https://www.sphinx-doc.org/en/master/usage/extensions/doctest.html), [autodoc](https://www.sphinx-doc.org/en/master/usage/extensions/autodoc.html), [sphinx gallery](https://sphinx-gallery.github.io/stable/index.html), [plot](https://matthew-brett.github.io/nb2plots/nbplots.html#module-nb2plots.nbplots). Additional extensions can be configured in the `conf.py` file. Tests can also be run on examples in the documentation using the doctest extension; and plots are generated using the `plot` directive. For more specific; guidelines on how to incorporate code examples into the guide, refer to (insert reference).; ",MatchSource.DOCS,doc/README.md,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/README.md
Testability,test,tested,"Repository for QuTiP documentation; ==================================. This repository contains the source files for the QuTiP documentation. For pre-built documentation, see https://www.qutip.org/documentation.html. Building; --------. The main Python requirements for the documentation are `sphinx`, `sphinx-gallery`, `sphinx_rtd_theme`, `numpydoc` and `ipython`.; You should build or install the version of QuTiP you want to build the documentation against in the same environment.; You will also need a sensible copy of `make`, and if you want to build the LaTeX documentation then also a `pdflatex` distribution.; As of 2021-04-20, the `conda` recipe for `sphinx_rtd_theme` is rather old compared to the `pip` version, so it's recommended to use a mostly `pip`-managed environment to do the documentation build. The simplest way to get a functional build environment is to use the `requirements.txt` file in this repository, which completely defines a known-good `pip` environment (tested on Python 3.8, but not necessarily limited to it).; If you typically use conda, the way to do this is; ```bash; $ conda create -n qutip-doc-build python=3.8; $ conda activate qutip-doc-build; $ pip install -r /path/to/qutip/doc/requirements.txt; ```; You will also need to build or install the main QuTiP library in the same environment.; If you simply want to build the documentation without editing the main library, you can install a release version of QuTiP with `pip install qutip`.; Otherwise, refer to [the main repository](https://github.com/qutip/qutip) for the current process to build from source.; You need to have the optional QuTiP dependency `Cython` to build the documentation, but this is included in this repository's `requirements.txt` so you do not need to do anything separately. After you have done this, you can effect the build with `make`.; The targets you might want are `html`, `latexpdf` and `clean`, which build the HTML pages, build the PDFs, and delete all built files respec",MatchSource.DOCS,doc/README.md,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/README.md
Usability,simpl,simplest,"Repository for QuTiP documentation; ==================================. This repository contains the source files for the QuTiP documentation. For pre-built documentation, see https://www.qutip.org/documentation.html. Building; --------. The main Python requirements for the documentation are `sphinx`, `sphinx-gallery`, `sphinx_rtd_theme`, `numpydoc` and `ipython`.; You should build or install the version of QuTiP you want to build the documentation against in the same environment.; You will also need a sensible copy of `make`, and if you want to build the LaTeX documentation then also a `pdflatex` distribution.; As of 2021-04-20, the `conda` recipe for `sphinx_rtd_theme` is rather old compared to the `pip` version, so it's recommended to use a mostly `pip`-managed environment to do the documentation build. The simplest way to get a functional build environment is to use the `requirements.txt` file in this repository, which completely defines a known-good `pip` environment (tested on Python 3.8, but not necessarily limited to it).; If you typically use conda, the way to do this is; ```bash; $ conda create -n qutip-doc-build python=3.8; $ conda activate qutip-doc-build; $ pip install -r /path/to/qutip/doc/requirements.txt; ```; You will also need to build or install the main QuTiP library in the same environment.; If you simply want to build the documentation without editing the main library, you can install a release version of QuTiP with `pip install qutip`.; Otherwise, refer to [the main repository](https://github.com/qutip/qutip) for the current process to build from source.; You need to have the optional QuTiP dependency `Cython` to build the documentation, but this is included in this repository's `requirements.txt` so you do not need to do anything separately. After you have done this, you can effect the build with `make`.; The targets you might want are `html`, `latexpdf` and `clean`, which build the HTML pages, build the PDFs, and delete all built files respec",MatchSource.DOCS,doc/README.md,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/README.md
Performance,optimiz,optimization,"`1111.6950`. .. [dAless08]; D. d’Alessandro, *Introduction to Quantum Control and Dynamics*, (Chapman & Hall/CRC, 2008). .. [Byrd95]; R. H. Byrd, P. Lu, J. Nocedal, and C. Zhu, *A Limited Memory Algorithm for Bound Constrained Optimization*, SIAM J. Sci. Comput. **16**, 1190 (1995). :doi:`10.1137/0916069`. .. [Flo12]; F. F. Floether, P. de Fouquieres, and S. G. Schirmer, *Robust quantum gates for open systems via optimal control: Markovian versus non-Markovian dynamics*, New J. Phys. **14**, 073023 (2012). :doi:`10.1088/1367-2630/14/7/073023`. .. [Lloyd14]; S. Lloyd and S. Montangero, *Information theoretical analysis of quantum optimal control*, Phys. Rev. Lett. **113**, 010502 (2014). :doi:`10.1103/PhysRevLett.113.010502`. .. [Doria11]; P. Doria, T. Calarco & S. Montangero, *Optimal Control Technique for Many-Body Quantum Dynamics*, Phys. Rev. Lett. **106**, 190501 (2011). :doi:`10.1103/PhysRevLett.106.190501`. .. [Caneva11]; T. Caneva, T. Calarco, & S. Montangero, *Chopped random-basis quantum optimization*, Phys. Rev. A **84**, 022326 (2011). :doi:`10.1103/PhysRevA.84.022326`. .. [Rach15]; N. Rach, M. M. Müller, T. Calarco, and S. Montangero, *Dressing the chopped-random-basis optimization: A bandwidth-limited access to the trap-free landscape*, Phys. Rev. A. **92**, 062343 (2015). :doi:`10.1103/PhysRevA.92.062343`. .. [Wis09]. Wiseman, H. M. & Milburn, G. J. *Quantum Measurement and Control*, (Cambridge University Press, 2009). .. [NKanej]. N Khaneja et. al. *Optimal control of coupled spin dynamics: Design of NMR pulse sequences by gradient ascent algorithms.* J. Magn. Reson. **172**, 296–305 (2005). :doi:`10.1016/j.jmr.2004.11.004`. .. [Donvil22]; B. Donvil, P. Muratore-Ginanneschi, *Quantum trajectory framework for general time-local master equations*, Nat Commun **13**, 4140 (2022). :doi:`10.1038/s41467-022-31533-8`. .. [Abd19]; M. Abdelhafez, D. I. Schuster, J. Koch, *Gradient-based optimal control of open quantum systems using quantumtrajectories and autom",MatchSource.DOCS,doc/biblio.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/biblio.rst
Security,access,access,"apman & Hall/CRC, 2008). .. [Byrd95]; R. H. Byrd, P. Lu, J. Nocedal, and C. Zhu, *A Limited Memory Algorithm for Bound Constrained Optimization*, SIAM J. Sci. Comput. **16**, 1190 (1995). :doi:`10.1137/0916069`. .. [Flo12]; F. F. Floether, P. de Fouquieres, and S. G. Schirmer, *Robust quantum gates for open systems via optimal control: Markovian versus non-Markovian dynamics*, New J. Phys. **14**, 073023 (2012). :doi:`10.1088/1367-2630/14/7/073023`. .. [Lloyd14]; S. Lloyd and S. Montangero, *Information theoretical analysis of quantum optimal control*, Phys. Rev. Lett. **113**, 010502 (2014). :doi:`10.1103/PhysRevLett.113.010502`. .. [Doria11]; P. Doria, T. Calarco & S. Montangero, *Optimal Control Technique for Many-Body Quantum Dynamics*, Phys. Rev. Lett. **106**, 190501 (2011). :doi:`10.1103/PhysRevLett.106.190501`. .. [Caneva11]; T. Caneva, T. Calarco, & S. Montangero, *Chopped random-basis quantum optimization*, Phys. Rev. A **84**, 022326 (2011). :doi:`10.1103/PhysRevA.84.022326`. .. [Rach15]; N. Rach, M. M. Müller, T. Calarco, and S. Montangero, *Dressing the chopped-random-basis optimization: A bandwidth-limited access to the trap-free landscape*, Phys. Rev. A. **92**, 062343 (2015). :doi:`10.1103/PhysRevA.92.062343`. .. [Wis09]. Wiseman, H. M. & Milburn, G. J. *Quantum Measurement and Control*, (Cambridge University Press, 2009). .. [NKanej]. N Khaneja et. al. *Optimal control of coupled spin dynamics: Design of NMR pulse sequences by gradient ascent algorithms.* J. Magn. Reson. **172**, 296–305 (2005). :doi:`10.1016/j.jmr.2004.11.004`. .. [Donvil22]; B. Donvil, P. Muratore-Ginanneschi, *Quantum trajectory framework for general time-local master equations*, Nat Commun **13**, 4140 (2022). :doi:`10.1038/s41467-022-31533-8`. .. [Abd19]; M. Abdelhafez, D. I. Schuster, J. Koch, *Gradient-based optimal control of open quantum systems using quantumtrajectories and automatic differentiation*, Phys. Rev. A **99**, 052327 (2019). :doi:`10.1103/PhysRevA.99.052327`.; ",MatchSource.DOCS,doc/biblio.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/biblio.rst
Availability,error,error,".. _changelog:. **********; Change Log; **********. .. towncrier release notes start. QuTiP 5.0.4 (2024-08-30); ========================. Micro release to add support for numpy 2.1. Bug Fixes; ---------. - Fixed rounding error in dicke_trace_function that resulted in negative eigenvalues. (#2466, by Andrey Nikitin). QuTiP 5.0.3 (2024-06-20); ========================. Micro release to add support for numpy 2. Bug Fixes; ---------. - Bug Fix in Process Matrix Rendering. (#2400, by Anush Venkatakrishnan); - Fix steadystate permutation being reversed. (#2443); - Add parallelizing support for `vernN` methods with `mcsolve`. (#2454 by Utkarsh). Documentation; -------------. - Added `qutip.core.gates` to apidoc/functions.rst and a Gates section to guide-states.rst. (#2441, by alan-nala). Miscellaneous; -------------. - Add support for numpy 2 (#2421, #2457); - Add support for scipy 1.14 (#2469). QuTiP 5.0.2 (2024-05-16); ========================. Bug Fixes; ---------. - Use CSR as the default for expand_operator (#2380, by BoxiLi); - Fix import of the partial_transpose function.; Ensures that the negativity function can handle both kets and density operators as input. (#2371, by vikas-chaudhary-2802); - Ensure that end_condition of mcsolve result doesn't say target tolerance reached when it hasn't (#2382, by magzpavz); - Fix two bugs in steadystate floquet solver, and adjust tests to be sensitive to this issue. (#2393, by Neill Lambert). Documentation; -------------. - Correct a mistake in the doc (#2401, by PositroniumJS); - Fix #2156: Correct a sample of code in the doc (#2409, by PositroniumJS). Miscellaneous; -------------. - Better metadata management in operators creation functions (#2388); - Implicitly set minimum python version to 3.9 (#2413); - Qobj.__eq__ uses core's settings rtol. (#2425); - Only normalize solver states when the initial state is already normalized. (#2427). QuTiP 5.0.1 (2024-04-03); ========================. Patch update fixing small issues with ",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
Deployability,release,release,".. _changelog:. **********; Change Log; **********. .. towncrier release notes start. QuTiP 5.0.4 (2024-08-30); ========================. Micro release to add support for numpy 2.1. Bug Fixes; ---------. - Fixed rounding error in dicke_trace_function that resulted in negative eigenvalues. (#2466, by Andrey Nikitin). QuTiP 5.0.3 (2024-06-20); ========================. Micro release to add support for numpy 2. Bug Fixes; ---------. - Bug Fix in Process Matrix Rendering. (#2400, by Anush Venkatakrishnan); - Fix steadystate permutation being reversed. (#2443); - Add parallelizing support for `vernN` methods with `mcsolve`. (#2454 by Utkarsh). Documentation; -------------. - Added `qutip.core.gates` to apidoc/functions.rst and a Gates section to guide-states.rst. (#2441, by alan-nala). Miscellaneous; -------------. - Add support for numpy 2 (#2421, #2457); - Add support for scipy 1.14 (#2469). QuTiP 5.0.2 (2024-05-16); ========================. Bug Fixes; ---------. - Use CSR as the default for expand_operator (#2380, by BoxiLi); - Fix import of the partial_transpose function.; Ensures that the negativity function can handle both kets and density operators as input. (#2371, by vikas-chaudhary-2802); - Ensure that end_condition of mcsolve result doesn't say target tolerance reached when it hasn't (#2382, by magzpavz); - Fix two bugs in steadystate floquet solver, and adjust tests to be sensitive to this issue. (#2393, by Neill Lambert). Documentation; -------------. - Correct a mistake in the doc (#2401, by PositroniumJS); - Fix #2156: Correct a sample of code in the doc (#2409, by PositroniumJS). Miscellaneous; -------------. - Better metadata management in operators creation functions (#2388); - Implicitly set minimum python version to 3.9 (#2413); - Qobj.__eq__ uses core's settings rtol. (#2425); - Only normalize solver states when the initial state is already normalized. (#2427). QuTiP 5.0.1 (2024-04-03); ========================. Patch update fixing small issues with ",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
Energy Efficiency,reduce,reduced,"tal data layers backends were written either as part of Google Summer; of Code or as separate projects. While these are still alpha quality, they helped; significantly to test the data layer API:. - ``qutip-tensorflow``: a TensorFlow backend by Asier Galicia (`<https://github.com/qutip/qutip-tensorflow>`); - ``qutip-cupy``: a CuPy GPU backend by Felipe Bivort Haiek (`<https://github.com/qutip/qutip-cupy/>`)`; - ``qutip-tensornetwork``: a TensorNetwork backend by Asier Galicia (`<https://github.com/qutip/qutip-tensornetwork>`); - ``qutip-jax``: a JAX backend by Eric Giguère (`<https://github.com/qutip/qutip-jax/>`). Finally, Yuji Tamakoshi updated the visualization function and added animation; functions as part of Google Summer of Code project. We have also had many other contributors, whose specific contributions are; detailed below:. - Pieter Eendebak (updated the required SciPy to 1.5+, `#1982 <https://github.com/qutip/qutip/pull/1982>`).; - Pieter Eendebak (reduced import times by setting logger names, `#1981 <https://github.com/qutip/qutip/pull/1981>`); - Pieter Eendebak (Allow scipy 1.12 to be used with qutip, `#2354 <https://github.com/qutip/qutip/pull/2354>`); - Xavier Sproken (included C header files in the source distribution, `#1971 <https://github.com/qutip/qutip/pull/1971>`); - Christian Staufenbiel (added support for multiple collapse operators to the Floquet solver, `#1962 <https://github.com/qutip/qutip/pull/1962>`); - Christian Staufenbiel (fixed the basis used in the Floquet Master Equation solver, `#1952 <https://github.com/qutip/qutip/pull/1952>`); - Christian Staufenbiel (allowed the ``bloch_redfield_tensor`` function to accept strings and callables for `a_ops`, `#1951 <https://github.com/qutip/qutip/pull/1951>`); - Christian Staufenbiel (Add a guide on Superoperators, Pauli Basis and Channel Contraction, `#1984 <https://github.com/qutip/qutip/pull/1984>`); - Henrique Silvéro (allowed ``qutip_qip`` to be imported as ``qutip.qip``, `#1920 <https:",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
Integrability,depend,dependent,"t minimum python version to 3.9 (#2413); - Qobj.__eq__ uses core's settings rtol. (#2425); - Only normalize solver states when the initial state is already normalized. (#2427). QuTiP 5.0.1 (2024-04-03); ========================. Patch update fixing small issues with v5.0.0 release. - Fix broken links in the documentation when migrating to readthedocs; - Fix readthedocs search feature; - Add setuptools to runtime compilation requirements; - Fix mcsolve documentation for open systems; - Fix OverFlowError in progress bars. QuTiP 5.0.0 (2024-03-26); ========================. QuTiP 5 is a redesign of many of the core components of QuTiP (``Qobj``,; ``QobjEvo``, solvers) to make them more consistent and more flexible. ``Qobj`` may now be stored in either sparse or dense representations,; and the two may be mixed sensibly as needed. ``QobjEvo`` is now used; consistently throughout QuTiP, and the implementation has been; substantially cleaned up. A new ``Coefficient`` class is used to; represent the time-dependent factors inside ``QobjEvo``. The solvers have been rewritten to work well with the new data layer; and the concept of ``Integrators`` which solve ODEs has been introduced.; In future, new data layers may provide their own ``Integrators``; specialized to their representation of the underlying data. Much of the user-facing API of QuTiP remains familiar, but there have; had to be many small breaking changes. If we can make changes to; easy migrating code from QuTiP 4 to QuTiP 5, please let us know. An extensive list of changes follows. Contributors; ------------. QuTiP 5 has been a large effort by many people over the last three years. In particular:. - Jake Lishman led the implementation of the new data layer and coefficients.; - Eric Giguère led the implementation of the new QobjEvo interface and solvers.; - Boxi Li led the updating of QuTiP's QIP support and the creation of ``qutip_qip``. Other members of the QuTiP Admin team have been heavily involved in reviewing,",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
Modifiability,flexible,flexible," adjust tests to be sensitive to this issue. (#2393, by Neill Lambert). Documentation; -------------. - Correct a mistake in the doc (#2401, by PositroniumJS); - Fix #2156: Correct a sample of code in the doc (#2409, by PositroniumJS). Miscellaneous; -------------. - Better metadata management in operators creation functions (#2388); - Implicitly set minimum python version to 3.9 (#2413); - Qobj.__eq__ uses core's settings rtol. (#2425); - Only normalize solver states when the initial state is already normalized. (#2427). QuTiP 5.0.1 (2024-04-03); ========================. Patch update fixing small issues with v5.0.0 release. - Fix broken links in the documentation when migrating to readthedocs; - Fix readthedocs search feature; - Add setuptools to runtime compilation requirements; - Fix mcsolve documentation for open systems; - Fix OverFlowError in progress bars. QuTiP 5.0.0 (2024-03-26); ========================. QuTiP 5 is a redesign of many of the core components of QuTiP (``Qobj``,; ``QobjEvo``, solvers) to make them more consistent and more flexible. ``Qobj`` may now be stored in either sparse or dense representations,; and the two may be mixed sensibly as needed. ``QobjEvo`` is now used; consistently throughout QuTiP, and the implementation has been; substantially cleaned up. A new ``Coefficient`` class is used to; represent the time-dependent factors inside ``QobjEvo``. The solvers have been rewritten to work well with the new data layer; and the concept of ``Integrators`` which solve ODEs has been introduced.; In future, new data layers may provide their own ``Integrators``; specialized to their representation of the underlying data. Much of the user-facing API of QuTiP remains familiar, but there have; had to be many small breaking changes. If we can make changes to; easy migrating code from QuTiP 4 to QuTiP 5, please let us know. An extensive list of changes follows. Contributors; ------------. QuTiP 5 has been a large effort by many people over the last ",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
Performance,perform,performance,"167>`); - Andrey Rakhubovsky (Corrected grammar in Bloch-Redfield master equation documentation, `#2174 <https://github.com/qutip/qutip/pull/2174>`); - Rushiraj Gadhvi (qutip.ipynbtools.version_table() can now be called without Cython installed, `#2110 <https://github.com/qutip/qutip/pull/2110>`); - Harsh Khilawala (Moved HTMLProgressBar from qutip/ipynbtools.py to qutip/ui/progressbar.py, `#2112 <https://github.com/qutip/qutip/pull/2112>`); - Avatar Srinidhi P V (Added new argument bc_type to take boundary conditions when creating QobjEvo, `#2114 <https://github.com/qutip/qutip/pull/2114>`); - Andrey Rakhubovsky (Fix types in docstring of projection(), `#2363 <https://github.com/qutip/qutip/pull/2363>`). Qobj changes; ------------. Previously ``Qobj`` data was stored in a SciPy-like sparse matrix. Now the; representation is flexible. Implementations for dense and sparse formats are; included in QuTiP and custom implementations are possible. QuTiP's performance; on dense states and operators is significantly improved as a result. Some highlights:. - The data is still acessible via the ``.data`` attribute, but is now an; instance of the underlying data type instead of a SciPy-like sparse matrix.; The operations available in ``qutip.core.data`` may be used on ``.data``,; regardless of the data type.; - ``Qobj`` with different data types may be mixed in arithmetic and other; operations. A sensible output type will be automatically determined.; - The new ``.to(...)`` method may be used to convert a ``Qobj`` from one data type; to another. E.g. ``.to(""dense"")`` will convert to the dense representation and; ``.to(""csr"")`` will convert to the sparse type.; - Many ``Qobj`` methods and methods that create ``Qobj`` now accepted a ``dtype``; parameter that allows the data type of the returned ``Qobj`` to specified.; - The new ``&`` operator may be used to obtain the tensor product.; - The new ``@`` operator may be used to obtain the matrix / operator product.; ``bar @ ket`` re",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
Safety,timeout,timeout,"ods.; - QuTiP's own implementation of a solver that directly diagonalizes the; the system to be integrated is available as ``diag``. It only works on; time-independent systems and is slow to setup, but once the diagonalization; is complete, it generates solutions very quickly.; - QuTiP's own implementatoin of an approximate Krylov subspace integrator is; available as ``krylov``. This integrator is only usable with ``sesolve``. Result class:. - A new ``.e_data`` attribute provides expectation values as a dictionary.; Unlike ``.expect``, the values are provided in a Python list rather than; a numpy array, which better supports non-numeric types.; - The contents of the ``.stats`` attribute changed significantly and is; now more consistent across solvers. Monte-Carlo Solver (mcsolve):. - The system, H, may now be a super-operator.; - The ``seed`` parameter now supports supplying numpy ``SeedSequence`` or; ``Generator`` types.; - The new ``timeout`` and ``target_tol`` parameters allow the solver to exit; early if a timeout or target tolerance is reached.; - The ntraj option no longer supports a list of numbers of trajectories.; Instead, just run the solver multiple times and use the class ``MCSolver``; if setting up the solver uses a significant amount of time.; - The ``map_func`` parameter has been replaced by the ``map`` option.; - A loky based parallel map as been added.; - A mpi based parallel map as been added.; - The result returned by ``mcsolve`` now supports calculating photocurrents; and calculating the steady state over N trajectories.; - The old ``parfor`` parallel execution function has been removed from; ``qutip.parallel``. Use ``parallel_map``, ``loky_map`` or ``mpi_pmap`` instead.; - Added improved sampling options which converge much faster when the; probability of collapse is small. Non Markovian Monte-Carlo Solver (nm_mcsolve):. - New Monte-Carlo Solver supporting negative decay rates.; - Based on the influence martingale approach, Donvil et al., Nat Co",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
Security,access,accessible,"``Qobj`` or directly from solver results with saved states. Package reorganization; ----------------------. - ``qutip.qip`` has been moved into its own package, qutip-qip. Once installed, qutip-qip is available as either ``qutip.qip`` or ``qutip_qip``. Some widely useful gates have been retained in ``qutip.gates``.; - ``qutip.control`` has been moved to qutip-qtrl and once installed qutip-qtrl is available as either ``qutip.control`` or ``qutip_qtrl``. Note that ``quitp_qtrl`` is provided primarily for backwards compatibility. Improvements to optimal control will take place in the new ``qutip_qoc`` package.; - ``qutip.lattice`` has been moved into its own package, qutip-lattice. It is available from `<https://github.com/qutip/qutip-lattice>`.; - ``qutip.sparse`` has been removed. It contained the old sparse matrix representation and is replaced by the new implementation in ``qutip.data``.; - ``qutip.piqs`` functions are no longer available from the ``qutip`` namespace. They are accessible from ``qutip.piqs`` instead. Miscellaneous; -------------. - Support has been added for 64-bit integer sparse matrix indices, allowing; sparse matrices with up to 2**63 rows and columns. This support needs to; be enabled at compilation time by calling ``setup.py`` and passing; ``--with-idxint-64``. Feature removals; ----------------. - Support for OpenMP has been removed. If there is enough demand and a good plan for how to organize it, OpenMP support may return in a future QuTiP release.; - The ``qutip.parfor`` function has been removed. Use ``qutip.parallel_map`` instead.; - ``qutip.graph`` has been removed and replaced by SciPy's graph functions.; - ``qutip.topology`` has been removed. It contained only one function ``berry_curvature``.; - The ``~/.qutip/qutiprc`` config file is no longer supported. It contained settings for the OpenMP support.; - Deprecate ``three_level_atom``; - Deprecate ``orbital``. Changes from QuTiP 5.0.0b1:; ---------------------------. Features; --------",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
Testability,test,tests,"drey Nikitin). QuTiP 5.0.3 (2024-06-20); ========================. Micro release to add support for numpy 2. Bug Fixes; ---------. - Bug Fix in Process Matrix Rendering. (#2400, by Anush Venkatakrishnan); - Fix steadystate permutation being reversed. (#2443); - Add parallelizing support for `vernN` methods with `mcsolve`. (#2454 by Utkarsh). Documentation; -------------. - Added `qutip.core.gates` to apidoc/functions.rst and a Gates section to guide-states.rst. (#2441, by alan-nala). Miscellaneous; -------------. - Add support for numpy 2 (#2421, #2457); - Add support for scipy 1.14 (#2469). QuTiP 5.0.2 (2024-05-16); ========================. Bug Fixes; ---------. - Use CSR as the default for expand_operator (#2380, by BoxiLi); - Fix import of the partial_transpose function.; Ensures that the negativity function can handle both kets and density operators as input. (#2371, by vikas-chaudhary-2802); - Ensure that end_condition of mcsolve result doesn't say target tolerance reached when it hasn't (#2382, by magzpavz); - Fix two bugs in steadystate floquet solver, and adjust tests to be sensitive to this issue. (#2393, by Neill Lambert). Documentation; -------------. - Correct a mistake in the doc (#2401, by PositroniumJS); - Fix #2156: Correct a sample of code in the doc (#2409, by PositroniumJS). Miscellaneous; -------------. - Better metadata management in operators creation functions (#2388); - Implicitly set minimum python version to 3.9 (#2413); - Qobj.__eq__ uses core's settings rtol. (#2425); - Only normalize solver states when the initial state is already normalized. (#2427). QuTiP 5.0.1 (2024-04-03); ========================. Patch update fixing small issues with v5.0.0 release. - Fix broken links in the documentation when migrating to readthedocs; - Fix readthedocs search feature; - Add setuptools to runtime compilation requirements; - Fix mcsolve documentation for open systems; - Fix OverFlowError in progress bars. QuTiP 5.0.0 (2024-03-26); =================",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
Usability,guid,guide-states,".. _changelog:. **********; Change Log; **********. .. towncrier release notes start. QuTiP 5.0.4 (2024-08-30); ========================. Micro release to add support for numpy 2.1. Bug Fixes; ---------. - Fixed rounding error in dicke_trace_function that resulted in negative eigenvalues. (#2466, by Andrey Nikitin). QuTiP 5.0.3 (2024-06-20); ========================. Micro release to add support for numpy 2. Bug Fixes; ---------. - Bug Fix in Process Matrix Rendering. (#2400, by Anush Venkatakrishnan); - Fix steadystate permutation being reversed. (#2443); - Add parallelizing support for `vernN` methods with `mcsolve`. (#2454 by Utkarsh). Documentation; -------------. - Added `qutip.core.gates` to apidoc/functions.rst and a Gates section to guide-states.rst. (#2441, by alan-nala). Miscellaneous; -------------. - Add support for numpy 2 (#2421, #2457); - Add support for scipy 1.14 (#2469). QuTiP 5.0.2 (2024-05-16); ========================. Bug Fixes; ---------. - Use CSR as the default for expand_operator (#2380, by BoxiLi); - Fix import of the partial_transpose function.; Ensures that the negativity function can handle both kets and density operators as input. (#2371, by vikas-chaudhary-2802); - Ensure that end_condition of mcsolve result doesn't say target tolerance reached when it hasn't (#2382, by magzpavz); - Fix two bugs in steadystate floquet solver, and adjust tests to be sensitive to this issue. (#2393, by Neill Lambert). Documentation; -------------. - Correct a mistake in the doc (#2401, by PositroniumJS); - Fix #2156: Correct a sample of code in the doc (#2409, by PositroniumJS). Miscellaneous; -------------. - Better metadata management in operators creation functions (#2388); - Implicitly set minimum python version to 3.9 (#2413); - Qobj.__eq__ uses core's settings rtol. (#2425); - Only normalize solver states when the initial state is already normalized. (#2427). QuTiP 5.0.1 (2024-04-03); ========================. Patch update fixing small issues with ",MatchSource.DOCS,doc/changelog.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/changelog.rst
Deployability,patch,patches,".. _developers:. ************; Developers; ************. .. plot::; :context: close-figs; :include-source: False. import json; import urllib.request. import numpy as np; import matplotlib.pyplot as plt. from matplotlib.path import Path; from matplotlib.patches import PathPatch; from matplotlib.textpath import TextPath; from matplotlib.collections import PolyCollection; from matplotlib.font_manager import FontProperties; import PIL. LINK_CONTRIBUTORS = ""https://api.github.com/repos/qutip/qutip/contributors""; LINK_LOGO = ""https://qutip.org/images/logo.png"". # font properties; FONT_SIZE = 6; FONT_FAMILY = ""DejaVu Sans"". # figures properties; FIGURE_SIZE = 8; AXIS_SIZE = 50; FONT_COLOR = ""black""; LOGO_SIZE = 40; LOGO_TRANSPARENCY = 0.5. # load the list of contributors from qutip/qutip repo; url_object = urllib.request.urlopen(LINK_CONTRIBUTORS); list_contributors = json.loads(url_object.read()); qutip_contributors = [element[""login""] for element in list_contributors]; qutip_contributors = [s.lower() for s in qutip_contributors]; text = "" "".join(qutip_contributors). # load the QuTiP logo; img = PIL.Image.open(urllib.request.urlopen(LINK_LOGO)). # code below was inspired in the following link:; # https://github.com/dynamicwebpaige/nanowrimo-2021/blob/main/15_VS_Code_contributors.ipynb. n = 100; A = np.linspace(np.pi, n * 2 * np.pi, 10_000); R = 5 + np.linspace(np.pi, n * 2 * np.pi, 10_000); T = np.stack([R * np.cos(A), R * np.sin(A)], axis=1); dx = np.cos(A) - R * np.sin(A); dy = np.sin(A) + R * np.cos(A); O = np.stack([-dy, dx], axis=1); O = O / (np.linalg.norm(O, axis=1)).reshape(len(O), 1). L = np.zeros(len(T)); np.cumsum(np.sqrt(((T[1:] - T[:-1]) ** 2).sum(axis=1)), out=L[1:]). path = TextPath(; (0, 0), text,; size=FONT_SIZE,; prop=FontProperties(family=FONT_FAMILY),; ). vertices = path.vertices; codes = path.codes. Vx, Vy = vertices[:, 0], vertices[:, 1]; X = np.interp(Vx, L, T[:, 0]) + Vy * np.interp(Vx, L, O[:, 0]); Y = np.interp(Vx, L, T[:, 1]) + Vy * np.interp(Vx,",MatchSource.DOCS,doc/contributors.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/contributors.rst
Performance,load,load,".. _developers:. ************; Developers; ************. .. plot::; :context: close-figs; :include-source: False. import json; import urllib.request. import numpy as np; import matplotlib.pyplot as plt. from matplotlib.path import Path; from matplotlib.patches import PathPatch; from matplotlib.textpath import TextPath; from matplotlib.collections import PolyCollection; from matplotlib.font_manager import FontProperties; import PIL. LINK_CONTRIBUTORS = ""https://api.github.com/repos/qutip/qutip/contributors""; LINK_LOGO = ""https://qutip.org/images/logo.png"". # font properties; FONT_SIZE = 6; FONT_FAMILY = ""DejaVu Sans"". # figures properties; FIGURE_SIZE = 8; AXIS_SIZE = 50; FONT_COLOR = ""black""; LOGO_SIZE = 40; LOGO_TRANSPARENCY = 0.5. # load the list of contributors from qutip/qutip repo; url_object = urllib.request.urlopen(LINK_CONTRIBUTORS); list_contributors = json.loads(url_object.read()); qutip_contributors = [element[""login""] for element in list_contributors]; qutip_contributors = [s.lower() for s in qutip_contributors]; text = "" "".join(qutip_contributors). # load the QuTiP logo; img = PIL.Image.open(urllib.request.urlopen(LINK_LOGO)). # code below was inspired in the following link:; # https://github.com/dynamicwebpaige/nanowrimo-2021/blob/main/15_VS_Code_contributors.ipynb. n = 100; A = np.linspace(np.pi, n * 2 * np.pi, 10_000); R = 5 + np.linspace(np.pi, n * 2 * np.pi, 10_000); T = np.stack([R * np.cos(A), R * np.sin(A)], axis=1); dx = np.cos(A) - R * np.sin(A); dy = np.sin(A) + R * np.cos(A); O = np.stack([-dy, dx], axis=1); O = O / (np.linalg.norm(O, axis=1)).reshape(len(O), 1). L = np.zeros(len(T)); np.cumsum(np.sqrt(((T[1:] - T[:-1]) ** 2).sum(axis=1)), out=L[1:]). path = TextPath(; (0, 0), text,; size=FONT_SIZE,; prop=FontProperties(family=FONT_FAMILY),; ). vertices = path.vertices; codes = path.codes. Vx, Vy = vertices[:, 0], vertices[:, 1]; X = np.interp(Vx, L, T[:, 0]) + Vy * np.interp(Vx, L, O[:, 0]); Y = np.interp(Vx, L, T[:, 1]) + Vy * np.interp(Vx,",MatchSource.DOCS,doc/contributors.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/contributors.rst
Testability,log,logo,".. _developers:. ************; Developers; ************. .. plot::; :context: close-figs; :include-source: False. import json; import urllib.request. import numpy as np; import matplotlib.pyplot as plt. from matplotlib.path import Path; from matplotlib.patches import PathPatch; from matplotlib.textpath import TextPath; from matplotlib.collections import PolyCollection; from matplotlib.font_manager import FontProperties; import PIL. LINK_CONTRIBUTORS = ""https://api.github.com/repos/qutip/qutip/contributors""; LINK_LOGO = ""https://qutip.org/images/logo.png"". # font properties; FONT_SIZE = 6; FONT_FAMILY = ""DejaVu Sans"". # figures properties; FIGURE_SIZE = 8; AXIS_SIZE = 50; FONT_COLOR = ""black""; LOGO_SIZE = 40; LOGO_TRANSPARENCY = 0.5. # load the list of contributors from qutip/qutip repo; url_object = urllib.request.urlopen(LINK_CONTRIBUTORS); list_contributors = json.loads(url_object.read()); qutip_contributors = [element[""login""] for element in list_contributors]; qutip_contributors = [s.lower() for s in qutip_contributors]; text = "" "".join(qutip_contributors). # load the QuTiP logo; img = PIL.Image.open(urllib.request.urlopen(LINK_LOGO)). # code below was inspired in the following link:; # https://github.com/dynamicwebpaige/nanowrimo-2021/blob/main/15_VS_Code_contributors.ipynb. n = 100; A = np.linspace(np.pi, n * 2 * np.pi, 10_000); R = 5 + np.linspace(np.pi, n * 2 * np.pi, 10_000); T = np.stack([R * np.cos(A), R * np.sin(A)], axis=1); dx = np.cos(A) - R * np.sin(A); dy = np.sin(A) + R * np.cos(A); O = np.stack([-dy, dx], axis=1); O = O / (np.linalg.norm(O, axis=1)).reshape(len(O), 1). L = np.zeros(len(T)); np.cumsum(np.sqrt(((T[1:] - T[:-1]) ** 2).sum(axis=1)), out=L[1:]). path = TextPath(; (0, 0), text,; size=FONT_SIZE,; prop=FontProperties(family=FONT_FAMILY),; ). vertices = path.vertices; codes = path.codes. Vx, Vy = vertices[:, 0], vertices[:, 1]; X = np.interp(Vx, L, T[:, 0]) + Vy * np.interp(Vx, L, O[:, 0]); Y = np.interp(Vx, L, T[:, 1]) + Vy * np.interp(Vx,",MatchSource.DOCS,doc/contributors.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/contributors.rst
Availability,avail,available,".. _copyright:. ***********************; Copyright and Licensing; ***********************. The text of this documentation is licensed under the `Creative Commons Attribution 3.0 Unported License <https://creativecommons.org/licenses/by/3.0/>`_.; Unless specifically indicated otherwise, all code samples, the source code of QuTiP, and its reproductions in this documentation, are licensed under the terms of the 3-clause BSD license, reproduced below. License Terms for Documentation Text; ====================================. The canonical form of this license is available at `https://creativecommons.org/licenses/by/3.0/ <https://creativecommons.org/licenses/by/3.0/>`_, which should be considered the binding version of this license.; It is reproduced here for convenience. .. include:: LICENSE_cc-by-3.0.txt. License Terms for Source Code of QuTiP and Code Samples; =======================================================. .. include:: ../LICENSE.txt; ",MatchSource.DOCS,doc/copyright.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/copyright.rst
Availability,avail,available,".. _frontmatter:. *************; Frontmatter; *************. .. _about-docs:. About This Documentation; ==========================. This document contains a user guide and automatically generated API documentation for QuTiP. A PDF version of this text is available at the `documentation page <https://qutip.org/documentation.html>`_. **For more information see the** `QuTiP project web page`_. .. _QuTiP project web page: https://qutip.org/. :Author: J.R. Johansson. :Author: P.D. Nation. :Author: Alexander Pitchford. :Author: Arne Grimsmo. :Author: Chris Grenade. :Author: Nathan Shammah. :Author: Shahnawaz Ahmed. :Author: Neill Lambert. :Author: Eric Giguere. :Author: Boxi Li. :Author: Jake Lishman. :Author: Simon Cross. :Author: Asier Galicia. :Author: Paul Menczel. :Author: Patrick Hopf. :release: |release|. :copyright:; The text of this documentation is licensed under the Creative Commons Attribution 3.0 Unported License.; All contained code samples, and the source code of QuTiP, are licensed under the 3-clause BSD licence.; Full details of the copyright notices can be found on the `Copyright and Licensing <copyright>`_ page of this documentation. .. _citing-qutip:. Citing This Project; ==========================. If you find this project useful, then please cite:. .. centered:: J. R. Johansson, P.D. Nation, and F. Nori, ""QuTiP 2: A Python framework for the dynamics of open quantum systems"", Comp. Phys. Comm. **184**, 1234 (2013). or. .. centered:: J. R. Johansson, P.D. Nation, and F. Nori, ""QuTiP: An open-source Python framework for the dynamics of open quantum systems"", Comp. Phys. Comm. **183**, 1760 (2012). which may also be downloaded from https://arxiv.org/abs/1211.6518 or https://arxiv.org/abs/1110.0573, respectively. .. _funding-qutip:. Funding; =======; QuTiP is developed under the auspice of the non-profit organizations:. .. _image-numfocus:. .. figure:: figures/NumFocus_logo.png; :width: 3in; :figclass: align-center. .. _image-unitaryfund:. .. figure:: figu",MatchSource.DOCS,doc/frontmatter.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/frontmatter.rst
Deployability,release,release,".. _frontmatter:. *************; Frontmatter; *************. .. _about-docs:. About This Documentation; ==========================. This document contains a user guide and automatically generated API documentation for QuTiP. A PDF version of this text is available at the `documentation page <https://qutip.org/documentation.html>`_. **For more information see the** `QuTiP project web page`_. .. _QuTiP project web page: https://qutip.org/. :Author: J.R. Johansson. :Author: P.D. Nation. :Author: Alexander Pitchford. :Author: Arne Grimsmo. :Author: Chris Grenade. :Author: Nathan Shammah. :Author: Shahnawaz Ahmed. :Author: Neill Lambert. :Author: Eric Giguere. :Author: Boxi Li. :Author: Jake Lishman. :Author: Simon Cross. :Author: Asier Galicia. :Author: Paul Menczel. :Author: Patrick Hopf. :release: |release|. :copyright:; The text of this documentation is licensed under the Creative Commons Attribution 3.0 Unported License.; All contained code samples, and the source code of QuTiP, are licensed under the 3-clause BSD licence.; Full details of the copyright notices can be found on the `Copyright and Licensing <copyright>`_ page of this documentation. .. _citing-qutip:. Citing This Project; ==========================. If you find this project useful, then please cite:. .. centered:: J. R. Johansson, P.D. Nation, and F. Nori, ""QuTiP 2: A Python framework for the dynamics of open quantum systems"", Comp. Phys. Comm. **184**, 1234 (2013). or. .. centered:: J. R. Johansson, P.D. Nation, and F. Nori, ""QuTiP: An open-source Python framework for the dynamics of open quantum systems"", Comp. Phys. Comm. **183**, 1760 (2012). which may also be downloaded from https://arxiv.org/abs/1211.6518 or https://arxiv.org/abs/1110.0573, respectively. .. _funding-qutip:. Funding; =======; QuTiP is developed under the auspice of the non-profit organizations:. .. _image-numfocus:. .. figure:: figures/NumFocus_logo.png; :width: 3in; :figclass: align-center. .. _image-unitaryfund:. .. figure:: figu",MatchSource.DOCS,doc/frontmatter.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/frontmatter.rst
Energy Efficiency,efficient,efficiently,"system encountered in the real world is an open quantum system. For although much care is taken experimentally to eliminate the unwanted influence of external interactions, there remains, if ever so slight, a coupling between the system of interest and the external world. In addition, any measurement performed on the system necessarily involves coupling to the measuring device, therefore introducing an additional source of external influence. Consequently, developing the necessary tools, both theoretical and numerical, to account for the interactions between a system and its environment is an essential step in understanding the dynamics of practical quantum systems. In general, for all but the most basic of Hamiltonians, an analytical description of the system dynamics is not possible, and one must resort to numerical simulations of the equations of motion. In absence of a quantum computer, these simulations must be carried out using classical computing techniques, where the exponentially increasing dimensionality of the underlying Hilbert space severely limits the size of system that can be efficiently simulated. However, in many fields such as quantum optics, trapped ions, superconducting circuit devices, and most recently nanomechanical systems, it is possible to design systems using a small number of effective oscillator and spin components, excited by a limited number of quanta, that are amenable to classical simulation in a truncated Hilbert space. The Quantum Toolbox in Python, or QuTiP, is an open-source framework written in the Python programming language, designed for simulating the open quantum dynamics of systems such as those listed above. This framework distinguishes itself from other available software solutions in providing the following advantages:. * QuTiP relies entirely on open-source software. You are free to modify and use it as you wish with no licensing fees or limitations. * QuTiP is based on the Python scripting language, providing easy to ",MatchSource.DOCS,doc/frontmatter.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/frontmatter.rst
Integrability,depend,dependence,"amenable to classical simulation in a truncated Hilbert space. The Quantum Toolbox in Python, or QuTiP, is an open-source framework written in the Python programming language, designed for simulating the open quantum dynamics of systems such as those listed above. This framework distinguishes itself from other available software solutions in providing the following advantages:. * QuTiP relies entirely on open-source software. You are free to modify and use it as you wish with no licensing fees or limitations. * QuTiP is based on the Python scripting language, providing easy to read, fast code generation without the need to compile after modification. * The numerics underlying QuTiP are time-tested algorithms that run at C-code speeds, thanks to the `Numpy <https://numpy.org>`_, `Scipy <https://scipy.org>`_, and `Cython <https://cython.org>`_ libraries, and are based on many of the same algorithms used in propriety software. * QuTiP allows for solving the dynamics of Hamiltonians with (almost) arbitrary time-dependence, including collapse operators. * Time-dependent problems can be automatically compiled into C++-code at run-time for increased performance. * Takes advantage of the multiple processing cores found in essentially all modern computers. * QuTiP was designed from the start to require a minimal learning curve for those users who have experience using the popular quantum optics toolbox by Sze M. Tan. * Includes the ability to create high-quality plots, and animations, using the excellent `Matplotlib <https://matplotlib.org>`_ package. For detailed information about new features of each release of QuTiP, see the :ref:`changelog`. .. _plugin-qutip:. QuTiP Plugins; =============. Several libraries depend on QuTiP heavily making QuTiP a super-library. :Matsubara: `Matsubara <https://matsubara.readthedocs.io/en/latest/>`_ is a plugin to study the ultrastrong coupling regime with structured baths. :QNET: `QNET <https://qnet.readthedocs.io/en/latest/readme.html>`_ i",MatchSource.DOCS,doc/frontmatter.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/frontmatter.rst
Modifiability,coupling,coupling,"tps://arxiv.org/abs/1211.6518 or https://arxiv.org/abs/1110.0573, respectively. .. _funding-qutip:. Funding; =======; QuTiP is developed under the auspice of the non-profit organizations:. .. _image-numfocus:. .. figure:: figures/NumFocus_logo.png; :width: 3in; :figclass: align-center. .. _image-unitaryfund:. .. figure:: figures/unitaryfund_logo.png; :width: 3in; :figclass: align-center. QuTiP was partially supported by. .. _image-jsps:. .. figure:: figures/jsps.jpg; :width: 2in; :figclass: align-center. .. _image-riken:. .. figure:: figures/riken-logo.png; 	:width: 1.5in; 	:figclass: align-center. .. _image-korea:. .. figure:: figures/korea-logo.png; 	:width: 2in; 	:figclass: align-center. .. figure:: figures/inst_quant_sher.png; 	:width: 2in; 	:figclass: align-center. .. _about:. About QuTiP; ===========. Every quantum system encountered in the real world is an open quantum system. For although much care is taken experimentally to eliminate the unwanted influence of external interactions, there remains, if ever so slight, a coupling between the system of interest and the external world. In addition, any measurement performed on the system necessarily involves coupling to the measuring device, therefore introducing an additional source of external influence. Consequently, developing the necessary tools, both theoretical and numerical, to account for the interactions between a system and its environment is an essential step in understanding the dynamics of practical quantum systems. In general, for all but the most basic of Hamiltonians, an analytical description of the system dynamics is not possible, and one must resort to numerical simulations of the equations of motion. In absence of a quantum computer, these simulations must be carried out using classical computing techniques, where the exponentially increasing dimensionality of the underlying Hilbert space severely limits the size of system that can be efficiently simulated. However, in many fields such as quan",MatchSource.DOCS,doc/frontmatter.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/frontmatter.rst
Performance,perform,performed,"_image-numfocus:. .. figure:: figures/NumFocus_logo.png; :width: 3in; :figclass: align-center. .. _image-unitaryfund:. .. figure:: figures/unitaryfund_logo.png; :width: 3in; :figclass: align-center. QuTiP was partially supported by. .. _image-jsps:. .. figure:: figures/jsps.jpg; :width: 2in; :figclass: align-center. .. _image-riken:. .. figure:: figures/riken-logo.png; 	:width: 1.5in; 	:figclass: align-center. .. _image-korea:. .. figure:: figures/korea-logo.png; 	:width: 2in; 	:figclass: align-center. .. figure:: figures/inst_quant_sher.png; 	:width: 2in; 	:figclass: align-center. .. _about:. About QuTiP; ===========. Every quantum system encountered in the real world is an open quantum system. For although much care is taken experimentally to eliminate the unwanted influence of external interactions, there remains, if ever so slight, a coupling between the system of interest and the external world. In addition, any measurement performed on the system necessarily involves coupling to the measuring device, therefore introducing an additional source of external influence. Consequently, developing the necessary tools, both theoretical and numerical, to account for the interactions between a system and its environment is an essential step in understanding the dynamics of practical quantum systems. In general, for all but the most basic of Hamiltonians, an analytical description of the system dynamics is not possible, and one must resort to numerical simulations of the equations of motion. In absence of a quantum computer, these simulations must be carried out using classical computing techniques, where the exponentially increasing dimensionality of the underlying Hilbert space severely limits the size of system that can be efficiently simulated. However, in many fields such as quantum optics, trapped ions, superconducting circuit devices, and most recently nanomechanical systems, it is possible to design systems using a small number of effective oscillator and spin com",MatchSource.DOCS,doc/frontmatter.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/frontmatter.rst
Testability,log,logo,"=============. If you find this project useful, then please cite:. .. centered:: J. R. Johansson, P.D. Nation, and F. Nori, ""QuTiP 2: A Python framework for the dynamics of open quantum systems"", Comp. Phys. Comm. **184**, 1234 (2013). or. .. centered:: J. R. Johansson, P.D. Nation, and F. Nori, ""QuTiP: An open-source Python framework for the dynamics of open quantum systems"", Comp. Phys. Comm. **183**, 1760 (2012). which may also be downloaded from https://arxiv.org/abs/1211.6518 or https://arxiv.org/abs/1110.0573, respectively. .. _funding-qutip:. Funding; =======; QuTiP is developed under the auspice of the non-profit organizations:. .. _image-numfocus:. .. figure:: figures/NumFocus_logo.png; :width: 3in; :figclass: align-center. .. _image-unitaryfund:. .. figure:: figures/unitaryfund_logo.png; :width: 3in; :figclass: align-center. QuTiP was partially supported by. .. _image-jsps:. .. figure:: figures/jsps.jpg; :width: 2in; :figclass: align-center. .. _image-riken:. .. figure:: figures/riken-logo.png; 	:width: 1.5in; 	:figclass: align-center. .. _image-korea:. .. figure:: figures/korea-logo.png; 	:width: 2in; 	:figclass: align-center. .. figure:: figures/inst_quant_sher.png; 	:width: 2in; 	:figclass: align-center. .. _about:. About QuTiP; ===========. Every quantum system encountered in the real world is an open quantum system. For although much care is taken experimentally to eliminate the unwanted influence of external interactions, there remains, if ever so slight, a coupling between the system of interest and the external world. In addition, any measurement performed on the system necessarily involves coupling to the measuring device, therefore introducing an additional source of external influence. Consequently, developing the necessary tools, both theoretical and numerical, to account for the interactions between a system and its environment is an essential step in understanding the dynamics of practical quantum systems. In general, for all but the most basi",MatchSource.DOCS,doc/frontmatter.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/frontmatter.rst
Usability,guid,guide,".. _frontmatter:. *************; Frontmatter; *************. .. _about-docs:. About This Documentation; ==========================. This document contains a user guide and automatically generated API documentation for QuTiP. A PDF version of this text is available at the `documentation page <https://qutip.org/documentation.html>`_. **For more information see the** `QuTiP project web page`_. .. _QuTiP project web page: https://qutip.org/. :Author: J.R. Johansson. :Author: P.D. Nation. :Author: Alexander Pitchford. :Author: Arne Grimsmo. :Author: Chris Grenade. :Author: Nathan Shammah. :Author: Shahnawaz Ahmed. :Author: Neill Lambert. :Author: Eric Giguere. :Author: Boxi Li. :Author: Jake Lishman. :Author: Simon Cross. :Author: Asier Galicia. :Author: Paul Menczel. :Author: Patrick Hopf. :release: |release|. :copyright:; The text of this documentation is licensed under the Creative Commons Attribution 3.0 Unported License.; All contained code samples, and the source code of QuTiP, are licensed under the 3-clause BSD licence.; Full details of the copyright notices can be found on the `Copyright and Licensing <copyright>`_ page of this documentation. .. _citing-qutip:. Citing This Project; ==========================. If you find this project useful, then please cite:. .. centered:: J. R. Johansson, P.D. Nation, and F. Nori, ""QuTiP 2: A Python framework for the dynamics of open quantum systems"", Comp. Phys. Comm. **184**, 1234 (2013). or. .. centered:: J. R. Johansson, P.D. Nation, and F. Nori, ""QuTiP: An open-source Python framework for the dynamics of open quantum systems"", Comp. Phys. Comm. **183**, 1760 (2012). which may also be downloaded from https://arxiv.org/abs/1211.6518 or https://arxiv.org/abs/1110.0573, respectively. .. _funding-qutip:. Funding; =======; QuTiP is developed under the auspice of the non-profit organizations:. .. _image-numfocus:. .. figure:: figures/NumFocus_logo.png; :width: 3in; :figclass: align-center. .. _image-unitaryfund:. .. figure:: figu",MatchSource.DOCS,doc/frontmatter.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/frontmatter.rst
Deployability,install,installation,".. figure:: figures/logo.png; :align: center; :width: 7in. QuTiP: Quantum Toolbox in Python; ================================. This documentation contains a user guide and automatically generated API documentation for QuTiP.; For more information see the `QuTiP project web page <https://qutip.org/>`_.; Here, you can also find a collection of `tutorials for QuTiP <https://qutip.org/qutip-tutorials/>`_. .. toctree::; :maxdepth: 3. frontmatter.rst; installation.rst; guide/guide.rst; gallery/build/index.rst; apidoc/apidoc.rst. changelog.rst; contributors.rst; development/development.rst; biblio.rst; copyright.rst. Indices and tables; ====================. * :ref:`genindex`; * :ref:`modindex`; * :ref:`search`; ",MatchSource.DOCS,doc/index.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/index.rst
Testability,log,logo,".. figure:: figures/logo.png; :align: center; :width: 7in. QuTiP: Quantum Toolbox in Python; ================================. This documentation contains a user guide and automatically generated API documentation for QuTiP.; For more information see the `QuTiP project web page <https://qutip.org/>`_.; Here, you can also find a collection of `tutorials for QuTiP <https://qutip.org/qutip-tutorials/>`_. .. toctree::; :maxdepth: 3. frontmatter.rst; installation.rst; guide/guide.rst; gallery/build/index.rst; apidoc/apidoc.rst. changelog.rst; contributors.rst; development/development.rst; biblio.rst; copyright.rst. Indices and tables; ====================. * :ref:`genindex`; * :ref:`modindex`; * :ref:`search`; ",MatchSource.DOCS,doc/index.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/index.rst
Usability,guid,guide,".. figure:: figures/logo.png; :align: center; :width: 7in. QuTiP: Quantum Toolbox in Python; ================================. This documentation contains a user guide and automatically generated API documentation for QuTiP.; For more information see the `QuTiP project web page <https://qutip.org/>`_.; Here, you can also find a collection of `tutorials for QuTiP <https://qutip.org/qutip-tutorials/>`_. .. toctree::; :maxdepth: 3. frontmatter.rst; installation.rst; guide/guide.rst; gallery/build/index.rst; apidoc/apidoc.rst. changelog.rst; contributors.rst; development/development.rst; biblio.rst; copyright.rst. Indices and tables; ====================. * :ref:`genindex`; * :ref:`modindex`; * :ref:`search`; ",MatchSource.DOCS,doc/index.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/index.rst
Availability,avail,available," bars back-end. |; +--------------------------+--------------+-----------------------------------------------------+. In addition, there are several additional packages that are not dependencies, but may give you a better programming experience.; `IPython <https://ipython.org/>`_ provides an improved text-based Python interpreter that is far more full-featured that the default interpreter, and runs in a terminal.; If you prefer a more graphical set-up, `Jupyter <https://jupyter.org/>`_ provides a notebook-style interface to mix code and mathematical notes together.; Alternatively, `Spyder <https://www.spyder-ide.org/>`_ is a free integrated development environment for Python, with several nice features for debugging code.; QuTiP will detect if it is being used within one of these richer environments, and various outputs will have enhanced formatting. .. _install-with-conda:. Installing with conda; =====================. If you already have your conda environment set up, and have the ``conda-forge`` channel available, then you can install QuTiP using:. .. code-block:: bash. conda install qutip. This will install the minimum set of dependences, but none of the optional packages. .. _adding-conda-forge:. Adding the conda-forge channel; ------------------------------. To install QuTiP from conda, you will need to add the conda-forge channel.; The following command adds this channel with lowest priority, so conda will still try and install all other packages normally:. .. code-block:: bash. conda config --append channels conda-forge. If you want to change the order of your channels later, you can edit your ``.condarc`` (user home folder) file manually, but it is recommended to keep ``defaults`` as the highest priority. .. _building-conda-environment:. New conda environments; ----------------------. The default Anaconda environment has all the Python packages needed for running QuTiP installed already, so you will only need to add the ``conda-forge`` channel and then inst",MatchSource.DOCS,doc/installation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst
Deployability,install,install,".. This file can be edited using retext 6.1 https://github.com/retext-project/retext. .. _install:. **************; Installation; **************. .. _quick-start:. Quick Start; ===========. From QuTiP version 4.6 onwards, you should be able to get a working version of QuTiP with the standard. .. code-block:: bash. pip install qutip. It is not recommended to install any packages directly into the system Python environment; consider using ``pip`` or ``conda`` virtual environments to keep your operating system space clean, and to have more control over Python and other package versions. You do not need to worry about the details on the rest of this page unless this command did not work, but do also read the next section for the list of optional dependencies.; The rest of this page covers `installation directly from conda <install-with-conda_>`_, `installation from source <install-from-source_>`_, and `additional considerations when working on Windows <install-on-windows_>`_. .. _install-requires:. General Requirements; =====================. QuTiP depends on several open-source libraries for scientific computing in the Python programming language.; The following packages are currently required:. .. cssclass:: table-striped. +----------------+--------------+-----------------------------------------------------+; | Package | Version | Details |; +================+==============+=====================================================+; | **Python** | 3.9+ | 3.6+ for version 4.7 |; +----------------+--------------+-----------------------------------------------------+; | **NumPy** | 1.22+ <2.0 | 1.16+ for version 4.7 |; +----------------+--------------+-----------------------------------------------------+; | **SciPy** | 1.8+ | 1.0+ for version 4.7 |; +----------------+--------------+-----------------------------------------------------+. In addition, there are several optional packages that provide additional functionality:. .. cssclass:: table-striped. +--------------------",MatchSource.DOCS,doc/installation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst
Integrability,depend,dependencies,".. This file can be edited using retext 6.1 https://github.com/retext-project/retext. .. _install:. **************; Installation; **************. .. _quick-start:. Quick Start; ===========. From QuTiP version 4.6 onwards, you should be able to get a working version of QuTiP with the standard. .. code-block:: bash. pip install qutip. It is not recommended to install any packages directly into the system Python environment; consider using ``pip`` or ``conda`` virtual environments to keep your operating system space clean, and to have more control over Python and other package versions. You do not need to worry about the details on the rest of this page unless this command did not work, but do also read the next section for the list of optional dependencies.; The rest of this page covers `installation directly from conda <install-with-conda_>`_, `installation from source <install-from-source_>`_, and `additional considerations when working on Windows <install-on-windows_>`_. .. _install-requires:. General Requirements; =====================. QuTiP depends on several open-source libraries for scientific computing in the Python programming language.; The following packages are currently required:. .. cssclass:: table-striped. +----------------+--------------+-----------------------------------------------------+; | Package | Version | Details |; +================+==============+=====================================================+; | **Python** | 3.9+ | 3.6+ for version 4.7 |; +----------------+--------------+-----------------------------------------------------+; | **NumPy** | 1.22+ <2.0 | 1.16+ for version 4.7 |; +----------------+--------------+-----------------------------------------------------+; | **SciPy** | 1.8+ | 1.0+ for version 4.7 |; +----------------+--------------+-----------------------------------------------------+. In addition, there are several optional packages that provide additional functionality:. .. cssclass:: table-striped. +--------------------",MatchSource.DOCS,doc/installation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst
Modifiability,enhance,enhanced,"-------------+; | ``loky``, ``mpi4py`` | | Extra parallel map back-ends. |; +--------------------------+--------------+-----------------------------------------------------+; | ``tqdm`` | | Extra progress bars back-end. |; +--------------------------+--------------+-----------------------------------------------------+. In addition, there are several additional packages that are not dependencies, but may give you a better programming experience.; `IPython <https://ipython.org/>`_ provides an improved text-based Python interpreter that is far more full-featured that the default interpreter, and runs in a terminal.; If you prefer a more graphical set-up, `Jupyter <https://jupyter.org/>`_ provides a notebook-style interface to mix code and mathematical notes together.; Alternatively, `Spyder <https://www.spyder-ide.org/>`_ is a free integrated development environment for Python, with several nice features for debugging code.; QuTiP will detect if it is being used within one of these richer environments, and various outputs will have enhanced formatting. .. _install-with-conda:. Installing with conda; =====================. If you already have your conda environment set up, and have the ``conda-forge`` channel available, then you can install QuTiP using:. .. code-block:: bash. conda install qutip. This will install the minimum set of dependences, but none of the optional packages. .. _adding-conda-forge:. Adding the conda-forge channel; ------------------------------. To install QuTiP from conda, you will need to add the conda-forge channel.; The following command adds this channel with lowest priority, so conda will still try and install all other packages normally:. .. code-block:: bash. conda config --append channels conda-forge. If you want to change the order of your channels later, you can edit your ``.condarc`` (user home folder) file manually, but it is recommended to keep ``defaults`` as the highest priority. .. _building-conda-environment:. New conda environmen",MatchSource.DOCS,doc/installation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst
Performance,load,load,".toml`` file, in the ``build-system.requires`` key.; As of the 5.0.0 release, the build requirements can be installed with. .. code-block:: bash. pip install setuptools wheel packaging cython 'numpy<2.0.0' scipy. or similar with ``conda`` if you prefer.; You will also need to have a functional C++ compiler installed on your system.; This is likely already done for you if you are on Linux or macOS, but see the `section on Windows installations <install-on-windows_>`_ if that is your operating system. To install QuTiP from the source code run:. .. code-block:: bash. pip install . If you wish to contribute to the QuTiP project, then you will want to create your own fork of `the QuTiP git repository <https://github.com/qutip/qutip>`_, clone this to a local folder, and install it into your Python environment using:. .. code-block:: bash. python setup.py develop. When you do ``import qutip`` in this environment, you will then load the code from your local fork, enabling you to edit the Python files and have the changes immediately available when you restart your Python interpreter, without needing to rebuild the package.; Note that if you change any Cython files, you will need to rerun the build command. You should not need to use ``sudo`` (or other superuser privileges) to install into a personal virtual environment; if it feels like you need it, there is a good chance that you are installing into the system Python environment instead. .. _install-on-windows:. Installation on Windows; =======================. As with other operating systems, the easiest method is to use ``pip install qutip``, or use the ``conda`` procedure described above.; If you want to build from source or use runtime compilation with Cython, you will need to have a working C++ compiler. You can `download the Visual Studio IDE from Microsoft <https://visualstudio.microsoft.com/downloads/>`_, which has a free Community edition containing a sufficient C++ compiler.; This is the recommended compiler toolc",MatchSource.DOCS,doc/installation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst
Safety,detect,detect,"-------------+; | ``loky``, ``mpi4py`` | | Extra parallel map back-ends. |; +--------------------------+--------------+-----------------------------------------------------+; | ``tqdm`` | | Extra progress bars back-end. |; +--------------------------+--------------+-----------------------------------------------------+. In addition, there are several additional packages that are not dependencies, but may give you a better programming experience.; `IPython <https://ipython.org/>`_ provides an improved text-based Python interpreter that is far more full-featured that the default interpreter, and runs in a terminal.; If you prefer a more graphical set-up, `Jupyter <https://jupyter.org/>`_ provides a notebook-style interface to mix code and mathematical notes together.; Alternatively, `Spyder <https://www.spyder-ide.org/>`_ is a free integrated development environment for Python, with several nice features for debugging code.; QuTiP will detect if it is being used within one of these richer environments, and various outputs will have enhanced formatting. .. _install-with-conda:. Installing with conda; =====================. If you already have your conda environment set up, and have the ``conda-forge`` channel available, then you can install QuTiP using:. .. code-block:: bash. conda install qutip. This will install the minimum set of dependences, but none of the optional packages. .. _adding-conda-forge:. Adding the conda-forge channel; ------------------------------. To install QuTiP from conda, you will need to add the conda-forge channel.; The following command adds this channel with lowest priority, so conda will still try and install all other packages normally:. .. code-block:: bash. conda config --append channels conda-forge. If you want to change the order of your channels later, you can edit your ``.condarc`` (user home folder) file manually, but it is recommended to keep ``defaults`` as the highest priority. .. _building-conda-environment:. New conda environmen",MatchSource.DOCS,doc/installation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst
Testability,test,test,"------------------------+. In addition, there are several optional packages that provide additional functionality:. .. cssclass:: table-striped. +--------------------------+--------------+-----------------------------------------------------+; | Package | Version | Details |; +==========================+==============+=====================================================+; | ``matplotlib`` | 1.2.1+ | Needed for all visualisation tasks. |; +--------------------------+--------------+-----------------------------------------------------+; | ``cython`` | 0.29.20+ | Needed for compiling some time-dependent |; | ``setuptools`` | | Hamiltonians. Cython needs a working C++ compiler. |; | ``filelock`` | | |; +--------------------------+--------------+-----------------------------------------------------+; | ``cvxpy`` | 1.0+ | Needed to calculate diamond norms. |; +--------------------------+--------------+-----------------------------------------------------+; | ``pytest``, | 5.3+ | For running the test suite. |; | ``pytest-rerunfailures`` | | |; +--------------------------+--------------+-----------------------------------------------------+; | LaTeX | TeXLive 2009+| Needed if using LaTeX in matplotlib figures, or for |; | | | nice circuit drawings in IPython. |; +--------------------------+--------------+-----------------------------------------------------+; | ``loky``, ``mpi4py`` | | Extra parallel map back-ends. |; +--------------------------+--------------+-----------------------------------------------------+; | ``tqdm`` | | Extra progress bars back-end. |; +--------------------------+--------------+-----------------------------------------------------+. In addition, there are several additional packages that are not dependencies, but may give you a better programming experience.; `IPython <https://ipython.org/>`_ provides an improved text-based Python interpreter that is far more full-featured that the default interpreter, and runs in a terminal.; If you prefer a mor",MatchSource.DOCS,doc/installation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst
Usability,progress bar,progress bars,"-----------------------------------+; | ``cython`` | 0.29.20+ | Needed for compiling some time-dependent |; | ``setuptools`` | | Hamiltonians. Cython needs a working C++ compiler. |; | ``filelock`` | | |; +--------------------------+--------------+-----------------------------------------------------+; | ``cvxpy`` | 1.0+ | Needed to calculate diamond norms. |; +--------------------------+--------------+-----------------------------------------------------+; | ``pytest``, | 5.3+ | For running the test suite. |; | ``pytest-rerunfailures`` | | |; +--------------------------+--------------+-----------------------------------------------------+; | LaTeX | TeXLive 2009+| Needed if using LaTeX in matplotlib figures, or for |; | | | nice circuit drawings in IPython. |; +--------------------------+--------------+-----------------------------------------------------+; | ``loky``, ``mpi4py`` | | Extra parallel map back-ends. |; +--------------------------+--------------+-----------------------------------------------------+; | ``tqdm`` | | Extra progress bars back-end. |; +--------------------------+--------------+-----------------------------------------------------+. In addition, there are several additional packages that are not dependencies, but may give you a better programming experience.; `IPython <https://ipython.org/>`_ provides an improved text-based Python interpreter that is far more full-featured that the default interpreter, and runs in a terminal.; If you prefer a more graphical set-up, `Jupyter <https://jupyter.org/>`_ provides a notebook-style interface to mix code and mathematical notes together.; Alternatively, `Spyder <https://www.spyder-ide.org/>`_ is a free integrated development environment for Python, with several nice features for debugging code.; QuTiP will detect if it is being used within one of these richer environments, and various outputs will have enhanced formatting. .. _install-with-conda:. Installing with conda; =====================. If you a",MatchSource.DOCS,doc/installation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/installation.rst
Deployability,integrat,integrator,heom.Bath; :members:. .. autoclass:: qutip.solver.heom.BosonicBath; :members:. .. autoclass:: qutip.solver.heom.DrudeLorentzBath; :members:. .. autoclass:: qutip.solver.heom.DrudeLorentzPadeBath; :members:. .. autoclass:: qutip.solver.heom.UnderDampedBath; :members:. .. autoclass:: qutip.solver.heom.FermionicBath; :members:. .. autoclass:: qutip.solver.heom.LorentzianBath; :members:. .. autoclass:: qutip.solver.heom.LorentzianPadeBath; :members:. .. autoclass:: qutip.solver.heom.HierarchyADOs; :members:. .. autoclass:: qutip.solver.heom.HierarchyADOsState; :members:. .. autoclass:: qutip.solver.heom.HEOMResult; :members:. .. _classes-stochastic:. Stochastic Solver; -----------------. .. autoclass:: qutip.solver.stochastic.SMESolver; :members:; :inherited-members:; :exclude-members: add_integrator. .. autoclass:: qutip.solver.stochastic.SSESolver; :members:; :inherited-members:; :exclude-members: add_integrator. .. _classes-ode:. Integrator; ----------. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipyAdams; :members: options. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipyBDF; :members: options. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipylsoda; :members: options. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipyDop853; :members: options. .. autoclass:: qutip.solver.integrator.qutip_integrator.IntegratorVern7; :members: options. .. autoclass:: qutip.solver.integrator.qutip_integrator.IntegratorVern9; :members: options. .. autoclass:: qutip.solver.integrator.qutip_integrator.IntegratorDiag; :members: options. .. autoclass:: qutip.solver.integrator.krylov.IntegratorKrylov; :members: options. .. _classes-sode:. Stochastic Integrator; ---------------------. .. autoclass:: qutip.solver.sode.rouchon.RouchonSODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.EulerSODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Milstein_SODE; :members: options. .,MatchSource.DOCS,doc/apidoc/classes.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/classes.rst
Integrability,integrat,integrator,heom.Bath; :members:. .. autoclass:: qutip.solver.heom.BosonicBath; :members:. .. autoclass:: qutip.solver.heom.DrudeLorentzBath; :members:. .. autoclass:: qutip.solver.heom.DrudeLorentzPadeBath; :members:. .. autoclass:: qutip.solver.heom.UnderDampedBath; :members:. .. autoclass:: qutip.solver.heom.FermionicBath; :members:. .. autoclass:: qutip.solver.heom.LorentzianBath; :members:. .. autoclass:: qutip.solver.heom.LorentzianPadeBath; :members:. .. autoclass:: qutip.solver.heom.HierarchyADOs; :members:. .. autoclass:: qutip.solver.heom.HierarchyADOsState; :members:. .. autoclass:: qutip.solver.heom.HEOMResult; :members:. .. _classes-stochastic:. Stochastic Solver; -----------------. .. autoclass:: qutip.solver.stochastic.SMESolver; :members:; :inherited-members:; :exclude-members: add_integrator. .. autoclass:: qutip.solver.stochastic.SSESolver; :members:; :inherited-members:; :exclude-members: add_integrator. .. _classes-ode:. Integrator; ----------. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipyAdams; :members: options. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipyBDF; :members: options. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipylsoda; :members: options. .. autoclass:: qutip.solver.integrator.scipy_integrator.IntegratorScipyDop853; :members: options. .. autoclass:: qutip.solver.integrator.qutip_integrator.IntegratorVern7; :members: options. .. autoclass:: qutip.solver.integrator.qutip_integrator.IntegratorVern9; :members: options. .. autoclass:: qutip.solver.integrator.qutip_integrator.IntegratorDiag; :members: options. .. autoclass:: qutip.solver.integrator.krylov.IntegratorKrylov; :members: options. .. _classes-sode:. Stochastic Integrator; ---------------------. .. autoclass:: qutip.solver.sode.rouchon.RouchonSODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.EulerSODE; :members: options. .. autoclass:: qutip.solver.sode.itotaylor.Milstein_SODE; :members: options. .,MatchSource.DOCS,doc/apidoc/classes.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/classes.rst
Modifiability,inherit,inherited-members,.. _classes:. ***************; Classes; ***************. .. _classes-qobj:. Qobj; --------------. .. autoclass:: qutip.core.qobj.Qobj; :members:; :special-members: __call__. .. _classes-qobjevo:. QobjEvo; --------------. .. autoclass:: qutip.core.cy.qobjevo.QobjEvo; :members:; :special-members: __call__. .. _classes-bloch:. Bloch sphere; ---------------. .. autoclass:: qutip.bloch.Bloch; :members:. Distributions; -------------. .. autoclass:: qutip.QFunc; :members:. .. _classes-solver:. Solvers; -------. .. autoclass:: qutip.solver.sesolve.SESolver; :members:; :inherited-members:; :show-inheritance:; :exclude-members: add_integrator. .. autoclass:: qutip.solver.mesolve.MESolver; :members:; :inherited-members:; :show-inheritance:; :exclude-members: add_integrator. .. autoclass:: qutip.solver.brmesolve.BRSolver; :members:; :inherited-members:; :show-inheritance:; :exclude-members: add_integrator. .. autoclass:: qutip.solver.floquet.FMESolver; :members:; :inherited-members:; :show-inheritance:; :exclude-members: add_integrator. .. autoclass:: qutip.solver.floquet.FloquetBasis; :members:. .. autoclass:: qutip.solver.propagator.Propagator; :members:; :inherited-members:; :special-members: __call__. .. _classes-monte-carlo-solver:. Monte Carlo Solvers; -------------------. .. autoclass:: qutip.solver.mcsolve.MCSolver; :members:; :inherited-members:; :show-inheritance:; :exclude-members: add_integrator. .. autoclass:: qutip.solver.nm_mcsolve.NonMarkovianMCSolver; :members:; :inherited-members:; :show-inheritance:; :exclude-members: add_integrator. .. _classes-non_markov_heom:. Non-Markovian HEOM Solver; -------------------------. .. autoclass:: qutip.solver.heom.HEOMSolver; :members:. .. autoclass:: qutip.solver.heom.HSolverDL; :members:. .. autoclass:: qutip.solver.heom.BathExponent; :members:. .. autoclass:: qutip.solver.heom.Bath; :members:. .. autoclass:: qutip.solver.heom.BosonicBath; :members:. .. autoclass:: qutip.solver.heom.DrudeLorentzBath; :members:. .. autoclass,MatchSource.DOCS,doc/apidoc/classes.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/classes.rst
Energy Efficiency,charge,charge,".. _functions:. ***************; Functions; ***************. Manipulation and Creation of States and Operators; =================================================. Quantum States; --------------. .. automodule:: qutip.core.states; :members: basis, bell_state, bra, coherent, coherent_dm, fock, fock_dm, ghz_state, maximally_mixed_dm, ket, ket2dm, phase_basis, projection, qutrit_basis, singlet_state, spin_state, spin_coherent, state_number_enumerate, state_number_index, state_index_number, state_number_qobj, thermal_dm, triplet_states, w_state, zero_ket. Quantum Operators; -----------------. .. automodule:: qutip.core.operators; :members: charge, commutator, create, destroy, displace, fcreate, fdestroy, jmat, num, qeye, identity, momentum, phase, position, qdiags, qutrit_ops, qzero, sigmam, sigmap, sigmax, sigmay, sigmaz, spin_Jx, spin_Jy, spin_Jz, spin_Jm, spin_Jp, squeeze, squeezing, tunneling, qeye_like, qzero_like. Quantum Gates; -----------------. .. automodule:: qutip.core.gates; :members: rx, ry, rz, sqrtnot, snot, phasegate, qrot, cy_gate, cz_gate, s_gate, t_gate, cs_gate, ct_gate, cphase, cnot, csign, berkeley, swapalpha, swap, iswap, sqrtswap, sqrtiswap, fredkin, molmer_sorensen, toffoli, hadamard_transform, qubit_clifford_group, globalphase; . Energy Restricted Operators; ---------------------------. .. automodule:: qutip.core.energy_restricted; :members: enr_state_dictionaries, enr_thermal_dm, enr_fock, enr_destroy, enr_identity. .. _functions-rand:. Quantum Objects; ---------------. .. automodule:: qutip.core.qobj; :members: ptrace, issuper, isoper, isoperket, isoperbra, isket, isbra, isherm. Random Operators and States; ---------------------------. .. automodule:: qutip.random_objects; :members: rand_dm, rand_herm, rand_ket, rand_stochastic, rand_unitary, rand_super, rand_super_bcsz, rand_kraus_map. Superoperators and Liouvillians; -------------------------------. .. automodule:: qutip.core.superoperator; :members: operator_to_vector, vector_to_operator, li",MatchSource.DOCS,doc/apidoc/functions.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/functions.rst
Integrability,depend,dependent,"==. Schrödinger Equation; --------------------. .. automodule:: qutip.solver.sesolve; :members: sesolve. Master Equation; ---------------. .. automodule:: qutip.solver.mesolve; :members: mesolve. Monte Carlo Evolution; ---------------------. .. automodule:: qutip.solver.mcsolve; :members: mcsolve. .. automodule:: qutip.solver.nm_mcsolve; :members: nm_mcsolve. Krylov Subspace Solver; ----------------------. .. automodule:: qutip.solver.krylovsolve; :members: krylovsolve. Bloch-Redfield Master Equation; ------------------------------. .. automodule:: qutip.solver.brmesolve; :members: brmesolve. Floquet States and Floquet-Markov Master Equation; -------------------------------------------------. .. automodule:: qutip.solver.floquet; :members: fmmesolve, fsesolve, floquet_tensor. Stochastic Schrödinger Equation and Master Equation; ---------------------------------------------------. .. automodule:: qutip.solver.stochastic; :members: ssesolve, smesolve. Constructing time dependent systems; -----------------------------------. .. automodule:: qutip.core.coefficient; :members: coefficient. Hierarchical Equations of Motion; --------------------------------. .. automodule:: qutip.solver.heom; :members: heomsolve. Correlation Functions; ---------------------. .. automodule:: qutip.solver.correlation; :members: correlation_2op_1t, correlation_2op_2t, correlation_3op_1t, correlation_3op_2t, correlation_3op, coherence_function_g1, coherence_function_g2. .. automodule:: qutip.solver.spectrum; :members: spectrum, spectrum_correlation_fft. Steady-state Solvers; --------------------. .. automodule:: qutip.solver.steadystate; :members: steadystate, pseudo_inverse, steadystate_floquet; :undoc-members:. Propagators; -----------. .. automodule:: qutip.solver.propagator; :members: propagator, propagator_steadystate; :undoc-members:. Scattering in Quantum Optical Systems; -------------------------------------. .. automodule:: qutip.solver.scattering; :members: temporal_basis_vector, temp",MatchSource.DOCS,doc/apidoc/functions.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/functions.rst
Performance,concurren,concurrence," vector_to_operator, liouvillian, spost, spre, sprepost, lindblad_dissipator. Superoperator Representations; -----------------------------. .. automodule:: qutip.core.superop_reps; :members: kraus_to_choi, kraus_to_super, to_choi, to_chi, to_super, to_kraus, to_stinespring; :undoc-members:. Operators and Superoperator Dimensions; --------------------------------------. .. automodule:: qutip.core.dimensions; :members: to_tensor_rep, from_tensor_rep. Functions acting on states and operators; ========================================. Expectation Values; ------------------. .. automodule:: qutip.core.expect; :members: expect, variance. Tensor; ------. .. automodule:: qutip.core.tensor; :members: tensor, super_tensor, composite, tensor_contract. Partial Transpose; -----------------. .. automodule:: qutip.partial_transpose; :members: partial_transpose. .. _functions-entropy:. Entropy Functions; -----------------. .. automodule:: qutip.entropy; :members: concurrence, entropy_conditional, entropy_linear, entropy_mutual, entropy_relative, entropy_vn. Density Matrix Metrics; ----------------------. .. automodule:: qutip.core.metrics; :members: fidelity, tracedist, bures_dist, bures_angle, hellinger_dist, hilbert_dist, average_gate_fidelity, process_fidelity, unitarity, dnorm. Continuous Variables; --------------------. .. automodule:: qutip.continuous_variables; :members: correlation_matrix, covariance_matrix, correlation_matrix_field, correlation_matrix_quadrature, wigner_covariance_matrix, logarithmic_negativity. Measurement; ===========. Measurement of quantum states; -----------------------------. .. automodule:: qutip.measurement; :members: measure, measure_povm, measure_observable, measurement_statistics, measurement_statistics_observable, measurement_statistics_povm. Dynamics and Time-Evolution; ===========================. Schrödinger Equation; --------------------. .. automodule:: qutip.solver.sesolve; :members: sesolve. Master Equation; ---------------. .. automodul",MatchSource.DOCS,doc/apidoc/functions.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/functions.rst
Usability,undo,undoc-members,"ffoli, hadamard_transform, qubit_clifford_group, globalphase; . Energy Restricted Operators; ---------------------------. .. automodule:: qutip.core.energy_restricted; :members: enr_state_dictionaries, enr_thermal_dm, enr_fock, enr_destroy, enr_identity. .. _functions-rand:. Quantum Objects; ---------------. .. automodule:: qutip.core.qobj; :members: ptrace, issuper, isoper, isoperket, isoperbra, isket, isbra, isherm. Random Operators and States; ---------------------------. .. automodule:: qutip.random_objects; :members: rand_dm, rand_herm, rand_ket, rand_stochastic, rand_unitary, rand_super, rand_super_bcsz, rand_kraus_map. Superoperators and Liouvillians; -------------------------------. .. automodule:: qutip.core.superoperator; :members: operator_to_vector, vector_to_operator, liouvillian, spost, spre, sprepost, lindblad_dissipator. Superoperator Representations; -----------------------------. .. automodule:: qutip.core.superop_reps; :members: kraus_to_choi, kraus_to_super, to_choi, to_chi, to_super, to_kraus, to_stinespring; :undoc-members:. Operators and Superoperator Dimensions; --------------------------------------. .. automodule:: qutip.core.dimensions; :members: to_tensor_rep, from_tensor_rep. Functions acting on states and operators; ========================================. Expectation Values; ------------------. .. automodule:: qutip.core.expect; :members: expect, variance. Tensor; ------. .. automodule:: qutip.core.tensor; :members: tensor, super_tensor, composite, tensor_contract. Partial Transpose; -----------------. .. automodule:: qutip.partial_transpose; :members: partial_transpose. .. _functions-entropy:. Entropy Functions; -----------------. .. automodule:: qutip.entropy; :members: concurrence, entropy_conditional, entropy_linear, entropy_mutual, entropy_relative, entropy_vn. Density Matrix Metrics; ----------------------. .. automodule:: qutip.core.metrics; :members: fidelity, tracedist, bures_dist, bures_angle, hellinger_dist, hilbert_dist, a",MatchSource.DOCS,doc/apidoc/functions.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/apidoc/functions.rst
Availability,reliab,reliably,"rpreter, you should be able to ``import qutip`` from anywhere as long as the correct Python environment is active.; Any changes you make to the Python files in the git repository should be immediately present if you restart your Python interpreter and re-import ``qutip``. On the first run, the setup command will compile many C++ extension modules built from Cython sources (files ending ``.pxd`` and ``.pyx``).; Generally the low-level linear algebra routines that QuTiP uses are written in these files, not in pure Python.; Unlike Python files, changes you make to Cython files will not appear until you run ``python setup.py develop`` again; you will only need to re-run this if you are changing Cython files.; Cython will detect and compile only the files that have been changed, so this command will be faster on subsequent runs. .. note::. When undertaking Cython development, the reason we use ``python setup.py develop`` instead of ``pip install -e .`` is because Cython's changed-file detection does not reliably work in the latter.; ``pip`` tends to build in temporary virtual environments, which often makes Cython think its core library files have been updated, triggering a complete, slow rebuild of everything. .. note::. QuTiP follows `NEP29`_ when selecting the supported version of its dependencies.; To see which versions are planned to be supported in the next release, please refer to the :ref:`release roadmap`.; These coincide with the versions employed for testing in continuous integration. In the event of a feature requiring a version upgrade of python or a dependency, it will be considered appropriately in the pull request.; In any case, python and dependency upgrades will only happen in mayor or minor versions of QuTiP, not in a patch. .. _NEP29: https://numpy.org/neps/nep-0029-deprecation_policy.html. Code Style; ----------. The biggest concern you should always have is to make it easy for your code to be read and understood by the person who comes next. All new ",MatchSource.DOCS,doc/development/contributing.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst
Deployability,update,update,"u can check your changes work sensibly.; #. Run the tests for the repository (if it has them).; #. Push the changes to your fork (``git push -u origin <branch-name>``). You won't be able to push to the main QuTiP repositories directly.; #. Go to the GitHub website for the repository you are contributing to, click on the ""Pull Requests"" tab, click the ""New Pull Request"" button, and follow the instructions there. Once the pull request is created, some members of the QuTiP admin team will review the code to make sure it is suitable for inclusion in the library, to check the programming, and to ensure everything meets our standards.; For some repositories, several automated tests will run whenever you create or modify a pull request; in general these will be the same tests you can run locally, and all tests are required to pass online before your changes are merged.; There may be some feedback and possibly some requested changes.; You can add more commits to address these, and push them to the relevant branch of your fork to update the pull request. The rest of this document covers programming standards, and particular considerations for some of the more complicated repositories. .. _contributing-qutip:. Core Library: qutip/qutip; =========================. The core library is in the `qutip/qutip repository on GitHub <https://github.com/qutip/qutip>`_. Building; --------. Building the core library from source is typically a bit more difficult than simply installing the package for regular use.; You will most likely want to do this in a clean Python environment so that you do not compromise a working installation of a release version, for example by starting from ::. conda create -n qutip-dev python. :ref:`Complete instructions for the build <install>` are elsewhere in this guide, however beware that you will need to follow the :ref:`installation from source using setuptools section <build-setuptools>`, not the general installation.; You will need all the *build* and *te",MatchSource.DOCS,doc/development/contributing.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst
Integrability,depend,dependencies,">`, not the general installation.; You will need all the *build* and *tests* ""optional"" requirements for the package.; The build requirements can be found in the |pyproject.toml file|_, and the testing requirements are in the ``tests`` key of the ``options.extras_require`` section of |setup.cfg|_.; You will also need the requirements for any optional features you want to test as well. .. |pyproject.toml file| replace:: ``pyproject.toml`` file; .. _pyproject.toml file: https://github.com/qutip/qutip/blob/master/pyproject.toml; .. |setup.cfg| replace:: ``setup.cfg``; .. _setup.cfg: https://github.com/qutip/qutip/blob/master/setup.cfg. Refer to the main instructions for the most up-to-date version, however as of version 4.6 the requirements can be installed into a conda environment with ::. conda install setuptools wheel numpy scipy cython packaging pytest pytest-rerunfailures. Note that ``qutip`` should *not* be installed with ``conda install``. .. note::; If you prefer, you can also use ``pip`` to install all the dependencies.; We typically recommend ``conda`` when doing main-library development because it is easier to switch low-level packages around like BLAS implementations, but if this doesn't mean anything to you, feel free to use ``pip``. You will need to make sure you have a functioning C++ compiler to build QuTiP.; If you are on Linux or Mac, this is likely already done for you, however if you are on Windows, refer to the :ref:`Windows installation <install-on-windows>` section of the installation guide. The command to build QuTiP in editable mode is ::. python setup.py develop. from the repository directory.; If you now load up a Python interpreter, you should be able to ``import qutip`` from anywhere as long as the correct Python environment is active.; Any changes you make to the Python files in the git repository should be immediately present if you restart your Python interpreter and re-import ``qutip``. On the first run, the setup command will compile ma",MatchSource.DOCS,doc/development/contributing.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst
Modifiability,variab,variable,"g/neps/nep-0029-deprecation_policy.html. Code Style; ----------. The biggest concern you should always have is to make it easy for your code to be read and understood by the person who comes next. All new contributions must follow `PEP 8 style <https://peps.python.org/pep-0008/>`_; all pull requests will be passed through a linter that will complain if you violate it.; You should use the ``pycodestyle`` package locally (available on ``pip``) to test you satisfy the requirements before you push your commits, since this is rather faster than pushing 10 different commits trying to fix minor niggles.; Keep in mind that there is quite a lot of freedom in this style, especially when it comes to line breaks.; If a line is too long, consider the *best* way to split it up with the aim of making the code readable, not just the first thing that doesn't generate a warning. Try to stay consistent with the style of the surrounding code.; This includes using the same variable names, especially if they are function arguments, even if these ""break"" PEP 8 guidelines.; *Do not* change existing parameter, attribute or method names to ""match"" PEP 8; these are breaking user-facing changes, and cannot be made except in a new major release of QuTiP. Other than this, general ""good-practice"" Python standards apply: try not to duplicate code; try to keep functions short, descriptively-named and side-effect free; provide a docstring for every new function; and so on. Documenting; -----------. When you make changes in the core library, you should update the relevant documentation if needed.; If you are making a bug fix, or other relatively minor changes, you will probably only need to make sure that the docstrings of the modified functions and classes are up-to-date; changes here will propagate through to the documentation the next time it is built.; Be sure to follow the |numpydoc|_ when writing docstrings.; All docstrings will be parsed as reStructuredText, and will form the API documentation ",MatchSource.DOCS,doc/development/contributing.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst
Performance,load,load,"f version 4.6 the requirements can be installed into a conda environment with ::. conda install setuptools wheel numpy scipy cython packaging pytest pytest-rerunfailures. Note that ``qutip`` should *not* be installed with ``conda install``. .. note::; If you prefer, you can also use ``pip`` to install all the dependencies.; We typically recommend ``conda`` when doing main-library development because it is easier to switch low-level packages around like BLAS implementations, but if this doesn't mean anything to you, feel free to use ``pip``. You will need to make sure you have a functioning C++ compiler to build QuTiP.; If you are on Linux or Mac, this is likely already done for you, however if you are on Windows, refer to the :ref:`Windows installation <install-on-windows>` section of the installation guide. The command to build QuTiP in editable mode is ::. python setup.py develop. from the repository directory.; If you now load up a Python interpreter, you should be able to ``import qutip`` from anywhere as long as the correct Python environment is active.; Any changes you make to the Python files in the git repository should be immediately present if you restart your Python interpreter and re-import ``qutip``. On the first run, the setup command will compile many C++ extension modules built from Cython sources (files ending ``.pxd`` and ``.pyx``).; Generally the low-level linear algebra routines that QuTiP uses are written in these files, not in pure Python.; Unlike Python files, changes you make to Cython files will not appear until you run ``python setup.py develop`` again; you will only need to re-run this if you are changing Cython files.; Cython will detect and compile only the files that have been changed, so this command will be faster on subsequent runs. .. note::. When undertaking Cython development, the reason we use ``python setup.py develop`` instead of ``pip install -e .`` is because Cython's changed-file detection does not reliably work in the latte",MatchSource.DOCS,doc/development/contributing.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst
Safety,detect,detect,"e :ref:`Windows installation <install-on-windows>` section of the installation guide. The command to build QuTiP in editable mode is ::. python setup.py develop. from the repository directory.; If you now load up a Python interpreter, you should be able to ``import qutip`` from anywhere as long as the correct Python environment is active.; Any changes you make to the Python files in the git repository should be immediately present if you restart your Python interpreter and re-import ``qutip``. On the first run, the setup command will compile many C++ extension modules built from Cython sources (files ending ``.pxd`` and ``.pyx``).; Generally the low-level linear algebra routines that QuTiP uses are written in these files, not in pure Python.; Unlike Python files, changes you make to Cython files will not appear until you run ``python setup.py develop`` again; you will only need to re-run this if you are changing Cython files.; Cython will detect and compile only the files that have been changed, so this command will be faster on subsequent runs. .. note::. When undertaking Cython development, the reason we use ``python setup.py develop`` instead of ``pip install -e .`` is because Cython's changed-file detection does not reliably work in the latter.; ``pip`` tends to build in temporary virtual environments, which often makes Cython think its core library files have been updated, triggering a complete, slow rebuild of everything. .. note::. QuTiP follows `NEP29`_ when selecting the supported version of its dependencies.; To see which versions are planned to be supported in the next release, please refer to the :ref:`release roadmap`.; These coincide with the versions employed for testing in continuous integration. In the event of a feature requiring a version upgrade of python or a dependency, it will be considered appropriately in the pull request.; In any case, python and dependency upgrades will only happen in mayor or minor versions of QuTiP, not in a patch. .. _N",MatchSource.DOCS,doc/development/contributing.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst
Security,access,accessible," the repository root that fixes all package versions exactly into a known-good configuration for a completely empty environment, using ::. pip install -r requirements.txt. This known-good configuration was intended for Python 3.8, though in principle it is possible that other Python versions will work. .. note::. We recommend you use ``pip`` to install dependencies for the documentation rather than ``conda`` because several necessary packages can be slower to update their ``conda`` recipes, so suitable versions may not be available. The documentation build includes running many components of the main QuTiP library to generate figures and to test the output, and to generate all the API documentation.; You therefore need to have a version of QuTiP available in the same Python environment.; If you are only interested in updating the users' guide, you can use a release version of QuTiP, for example by running ``pip install qutip``.; If you are also modifying the main library, you need to make your development version accessible in this environment.; See the `above section on building QuTiP <contributing-qutip_>`_ for more details, though the ``requirements.txt`` file will have already installed all the build requirements, so you should be able to simply run ::. python setup.py develop. in the main library repository. The documentation is built by running the ``make`` command.; There are several targets to build, but the most useful will be ``html`` to build the webpage documentation, ``latexpdf`` to build the PDF documentation (you will also need a full ``pdflatex`` installation), and ``clean`` to remove all built files.; The most important command you will want to run is ::. make html. You should re-run this any time you make changes, and it should only update files that have been changed. .. important::; The documentation build includes running almost all the optional features of QuTiP.; If you get failure messages in red, make sure you have installed all of the option",MatchSource.DOCS,doc/development/contributing.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst
Testability,test,testing,".. _development-contributing:. *********************************; Contributing to QuTiP Development; *********************************. Quick Start; ===========. QuTiP is developed through wide collaboration using the ``git`` version-control system, with the main repositories hosted in the `qutip organisation on GitHub <https://github.com/qutip>`_.; You will need to be familiar with ``git`` as a tool, and the `GitHub Flow <https://docs.github.com/en/get-started/quickstart/github-flow>`_ workflow for branching and making pull requests.; The exact details of environment set-up, build process and testing vary by repository and are discussed below, however in overview, the steps to contribute are:. #. Consider creating an issue on the GitHub page of the relevant repository, describing the change you think should be made and why, so we can discuss details with you and make sure it is appropriate.; #. (If this is your first contribution.) Make a fork of the relevant repository on GitHub and clone it to your local computer. Also add our copy as a remote (``git remote add qutip https://github.com/qutip/<repo>``); #. Begin on the ``master`` branch (``git checkout master``), and pull in changes from the main QuTiP repository to make sure you have an up-to-date copy (``git pull qutip master``).; #. Switch to a new ``git`` branch (``git checkout -b <branch-name>``).; #. Make the changes you want to make, then create some commits with short, descriptive names (``git add <files>`` then ``git commit``).; #. Follow the build process for this repository to build the final result so you can check your changes work sensibly.; #. Run the tests for the repository (if it has them).; #. Push the changes to your fork (``git push -u origin <branch-name>``). You won't be able to push to the main QuTiP repositories directly.; #. Go to the GitHub website for the repository you are contributing to, click on the ""Pull Requests"" tab, click the ""New Pull Request"" button, and follow the instructions",MatchSource.DOCS,doc/development/contributing.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst
Usability,feedback,feedback,"it commit``).; #. Follow the build process for this repository to build the final result so you can check your changes work sensibly.; #. Run the tests for the repository (if it has them).; #. Push the changes to your fork (``git push -u origin <branch-name>``). You won't be able to push to the main QuTiP repositories directly.; #. Go to the GitHub website for the repository you are contributing to, click on the ""Pull Requests"" tab, click the ""New Pull Request"" button, and follow the instructions there. Once the pull request is created, some members of the QuTiP admin team will review the code to make sure it is suitable for inclusion in the library, to check the programming, and to ensure everything meets our standards.; For some repositories, several automated tests will run whenever you create or modify a pull request; in general these will be the same tests you can run locally, and all tests are required to pass online before your changes are merged.; There may be some feedback and possibly some requested changes.; You can add more commits to address these, and push them to the relevant branch of your fork to update the pull request. The rest of this document covers programming standards, and particular considerations for some of the more complicated repositories. .. _contributing-qutip:. Core Library: qutip/qutip; =========================. The core library is in the `qutip/qutip repository on GitHub <https://github.com/qutip/qutip>`_. Building; --------. Building the core library from source is typically a bit more difficult than simply installing the package for regular use.; You will most likely want to do this in a clean Python environment so that you do not compromise a working installation of a release version, for example by starting from ::. conda create -n qutip-dev python. :ref:`Complete instructions for the build <install>` are elsewhere in this guide, however beware that you will need to follow the :ref:`installation from source using setuptools sect",MatchSource.DOCS,doc/development/contributing.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/contributing.rst
Deployability,release,releases,".. _development:. *************************; Development Documentation; *************************. This chapter covers the development of QuTiP and its subpackages, including; a roadmap for upcoming releases and ideas for future improvements. .. toctree::; :maxdepth: 3. contributing.rst; roadmap.rst; ideas.rst; docs.rst; release_distribution.rst; ",MatchSource.DOCS,doc/development/development.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/development.rst
Modifiability,config,configured,".rst:. ************************************; Working with the QuTiP Documentation; ************************************. The user guide provides an overview of QuTiP's functionality.; The guide is composed of individual reStructuredText (``.rst``) files which each get rendered as a webpage.; Each page typically tackles one area of functionality.; To learn more about how to write ``.rst`` files, it is useful to follow the `sphinx guide <https://www.sphinx-doc.org/en/master/usage/index.html>`_. The documentation build also utilizes a number of; `Sphinx Extensions <https://www.sphinx-doc.org/en/master/usage/extensions/index.html>`_; including but not limited to; `doctest <https://www.sphinx-doc.org/en/master/usage/extensions/doctest.html>`_,; `autodoc <https://www.sphinx-doc.org/en/master/usage/extensions/autodoc.html>`_,; `sphinx gallery <https://sphinx-gallery.github.io/stable/index.html>`_ and; `plot <https://matplotlib.org/3.1.1/devel/plot_directive.html>`_.; Additional extensions can be configured in the `conf.py <https://github.com/qutip/qutip/blob/master/doc/conf.py>`_ file. .. _directives.rst:. Directives; ==========. There are two Sphinx directives that can be used to write code examples in the user guide:. - `Doctest <https://www.sphinx-doc.org/en/master/usage/extensions/doctest.html>`_; - `Plot <https://matplotlib.org/3.1.1/devel/plot_directive.html>`_. For a more comprehensive account of the usage of each directive, please refer to their individual pages. Here we outline some general guidelines on how to these directives while making a user guide. Doctest; -------. The doctest directive enables tests on interactive code examples.; The simplest way to do this is by specifying a prompt along with its respective output: ::. .. doctest::. >>> a = 2; >>> a; 2. This is rendered in the documentation as follows:. .. doctest::. >>> a = 2; >>> a; 2. While specifying code examples under the ``.. doctest::`` directive, either all statements must be specified by the ``>>",MatchSource.DOCS,doc/development/docs.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/docs.rst
Testability,test,tests,">`_; including but not limited to; `doctest <https://www.sphinx-doc.org/en/master/usage/extensions/doctest.html>`_,; `autodoc <https://www.sphinx-doc.org/en/master/usage/extensions/autodoc.html>`_,; `sphinx gallery <https://sphinx-gallery.github.io/stable/index.html>`_ and; `plot <https://matplotlib.org/3.1.1/devel/plot_directive.html>`_.; Additional extensions can be configured in the `conf.py <https://github.com/qutip/qutip/blob/master/doc/conf.py>`_ file. .. _directives.rst:. Directives; ==========. There are two Sphinx directives that can be used to write code examples in the user guide:. - `Doctest <https://www.sphinx-doc.org/en/master/usage/extensions/doctest.html>`_; - `Plot <https://matplotlib.org/3.1.1/devel/plot_directive.html>`_. For a more comprehensive account of the usage of each directive, please refer to their individual pages. Here we outline some general guidelines on how to these directives while making a user guide. Doctest; -------. The doctest directive enables tests on interactive code examples.; The simplest way to do this is by specifying a prompt along with its respective output: ::. .. doctest::. >>> a = 2; >>> a; 2. This is rendered in the documentation as follows:. .. doctest::. >>> a = 2; >>> a; 2. While specifying code examples under the ``.. doctest::`` directive, either all statements must be specified by the ``>>>`` prompt or without it.; For every prompt, any potential corresponding output must be specified immediately after it.; This directive is ideally used when there are a number of examples that need to be checked in quick succession. A different way to specify code examples (and test them) is using the associated ``.. testcode::`` directive which is effectively a code block: ::. .. testcode::. a = 2; print(a). followed by its results.; The result can be specified with the ``.. testoutput::`` block: ::. .. testoutput::. 2. The advantage of the ``testcode`` directive is that it is a lot simpler to; specify and amenable to copyi",MatchSource.DOCS,doc/development/docs.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/docs.rst
Usability,guid,guide,".. _user_guide.rst:. ************************************; Working with the QuTiP Documentation; ************************************. The user guide provides an overview of QuTiP's functionality.; The guide is composed of individual reStructuredText (``.rst``) files which each get rendered as a webpage.; Each page typically tackles one area of functionality.; To learn more about how to write ``.rst`` files, it is useful to follow the `sphinx guide <https://www.sphinx-doc.org/en/master/usage/index.html>`_. The documentation build also utilizes a number of; `Sphinx Extensions <https://www.sphinx-doc.org/en/master/usage/extensions/index.html>`_; including but not limited to; `doctest <https://www.sphinx-doc.org/en/master/usage/extensions/doctest.html>`_,; `autodoc <https://www.sphinx-doc.org/en/master/usage/extensions/autodoc.html>`_,; `sphinx gallery <https://sphinx-gallery.github.io/stable/index.html>`_ and; `plot <https://matplotlib.org/3.1.1/devel/plot_directive.html>`_.; Additional extensions can be configured in the `conf.py <https://github.com/qutip/qutip/blob/master/doc/conf.py>`_ file. .. _directives.rst:. Directives; ==========. There are two Sphinx directives that can be used to write code examples in the user guide:. - `Doctest <https://www.sphinx-doc.org/en/master/usage/extensions/doctest.html>`_; - `Plot <https://matplotlib.org/3.1.1/devel/plot_directive.html>`_. For a more comprehensive account of the usage of each directive, please refer to their individual pages. Here we outline some general guidelines on how to these directives while making a user guide. Doctest; -------. The doctest directive enables tests on interactive code examples.; The simplest way to do this is by specifying a prompt along with its respective output: ::. .. doctest::. >>> a = 2; >>> a; 2. This is rendered in the documentation as follows:. .. doctest::. >>> a = 2; >>> a; 2. While specifying code examples under the ``.. doctest::`` directive, either all statements must be specifi",MatchSource.DOCS,doc/development/docs.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/docs.rst
Availability,error,error-mitigation,".. _development_ideas:. **********************************; Ideas for future QuTiP development; **********************************. Ideas for significant new features are listed here. For the general roadmap,; see :doc:`roadmap`. .. toctree::; :maxdepth: 1. ideas/qutip-interactive.rst; ideas/pulse-level-quantum-circuits.rst; ideas/quantum-error-mitigation.rst; ideas/heom-gpu.rst. Google Summer of Code; =====================. Many possible extensions and improvements to QuTiP have been documented as; part of `Google Summer of Code <https://summerofcode.withgoogle.com/>`_:. * `GSoC 2021 <https://github.com/qutip/qutip/wiki/Google-Summer-of-Code-2021/>`_; * `GSoC 2022 <https://github.com/qutip/qutip/wiki/Google-Summer-of-Code-2022/>`_. Completed Projects; ==================. These projects have been completed:. .. toctree::; :maxdepth: 1. ideas/tensorflow-data-backend.rst; ",MatchSource.DOCS,doc/development/ideas.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas.rst
Availability,down,download," #. Push this branch to your fork, and make a pull request against the release branch.; On GitHub in the PR screen, you will need to change the ""Base"" branch to ``qutip-4.6.X`` (or whatever version), because GitHub will default to making it against ``master``.; It should be quite clear if you have forgotten to do this, because there will probably be many merge conflicts.; Once the tests have passed and you have another admin's approval, merge the PR. You should now see that the ``qutip-4.6.X`` (or whatever) branch on GitHub has been updated, and now includes all the changes you have just made.; If you have made a mistake, feel free to make additonal PRs to rectify the situation. You are now ready to actually perform the release.; Go to deploy_. .. _deploy:. Build Release Distribution and Deploy; +++++++++++++++++++++++++++++++++++++. This step builds the source (sdist) and binary (wheel) distributions, and uploads them to PyPI (pip).; You will also be able to download the built files yourself in order to upload them to the QuTiP website. Build and Deploy; ----------------. This is handled entirely by a GitHub Action.; Go to the `""Actions"" tab at the top of the QuTiP code repository <https://github.com/qutip/qutip/actions>`_.; Click on the ""Build wheels, optionally deploy to PyPI"" action in the left-hand sidebar.; Click the ""Run workflow"" dropdown in the header notification; it should look like the image below. .. image:: ../figures/release_guide_run_build_workflow.png. - Use the drop-down menu to choose the branch or tag you want to release from.; This should be called ``qutip-4.5.X`` or similar, depending on what you made earlier.; This must *never* be ``master``.; - To make the release to PyPI, type the branch name (e.g. ``qutip-4.5.X``) into the ""Confirm chosen branch name [...]"" field.; You *may* leave this field blank to skip the deployment and only build the package.; - (Special circumstances) If for some reason you need to override the version number (for exa",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
Deployability,update,updates,".. This file was created using retext 6.1 https://github.com/retext-project/retext. .. _release_distribution:. ************************; Release and Distribution; ************************. Preamble; ++++++++. This document covers the process for managing updates to the current minor release and making new releases.; Within this document, the git remote ``upstream`` refers to the main QuTiP organsiation repository, and ``origin`` refers to your personal fork. In short, the steps you need to take are:. 1. Prepare the release branch (see git_).; 2. Run the ""Build wheels, optionally deploy to PyPI"" GitHub action to build binary and source packages and upload them to PyPI (see deploy_).; 3. Create a GitHub release and uploaded the built files to it (see github_).; 4. Update `qutip.org <https://qutip.org/>`_ with the new links and documentation (web_).; 5. Update the conda feedstock, deploying the package to ``conda`` (cforge_). .. _git:. Setting Up The Release Branch; +++++++++++++++++++++++++++++. In this step you will prepare a git branch on the main QuTiP repository that has the state of the code that is going to be released.; This procedure is quite different if you are releasing a new minor or major version compared to if you are making a bugfix patch release.; For a new minor or major version, do update-changelog_ and then jump to release_.; For a bug fix to an existing release, do update-changelog_ and then jump to bugfix_. Changes that are not backwards-compatible may only be made in a major release.; New features that do not affect backwards-compatibility can be made in a minor release.; Bug fix releases should be small, only fix bugs, and not introduce any new features. There are a few steps that *should* have been kept up-to-date during day-to-day development, but might not be quite accurate.; For every change that is going to be part of your release, make sure that:. - The user guide in the documentation is updated with any new features, or changes to existing",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
Energy Efficiency,monitor,monitor,"d the package.; - (Special circumstances) If for some reason you need to override the version number (for example if the previous deployment to PyPI only partially succeeded), you can type a valid Python version identifier into the ""Override version number"" field.; You probably do not need to do this.; The mechanism is designed to make alpha-testing major upgrades with nightly releases easier.; For even a bugfix release, you should commit the change to the ``VERSION`` file.; - Click the lower ""Run workflow"" to perform the build and deployment. At this point, the deployment will take care of itself.; It should take between 30 minutes and an hour, after which the new version will be available for install by ``pip install qutip``.; You should see the new version appear on `QuTiP's PyPI page <https://pypi.org/project/qutip>`_. Download Built Files; --------------------. When the build is complete, click into its summary screen.; This is the main screen used to both monitor the build and see its output, and should look like the below image on a success. .. image:: ../figures/release_guide_after_workflow.png. The built binary wheels and the source distribution are the ""build artifacts"" at the bottom.; You need to download both the wheels and the source distribution.; Save them on your computer, and unzip both files; you should have many wheel ``qutip-*.whl`` files, and two sdist files: ``qutip-*.tar.gz`` and ``qutip-*.zip``.; These are the same files that have just been uploaded to PyPI. Monitoring Progress (optional); ------------------------------. While the build is in progress, you can monitor its progress by clicking on its entry in the list below the ""Run workflow"" button.; You should see several subjobs, like the completed screen, except they might not yet be completed. The ""Verify PyPI deployment confirmation"" should get ticked, no matter what.; If it fails, you have forgotten to choose the correct branch in the drop-down menu or you made a typo when confirming the",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
Integrability,depend,dependency,"s, or changes to existing features.; - Any new API classes or functions have entries in a suitable RST file in ``doc/apidoc``.; - Any new or changed docstrings are up-to-date and render correctly in the API documentation. Please make a normal PR to ``master`` correcting anything missing from these points and have it merged before you begin the release, if necessary. .. _update-requirement:. Updating the Requirements; -------------------------. Ensure that QuTiP's tests pass on the oldest version supported in the requirements.; On major and minor version, requirements can be adjusted upwards, but patch release must not change minimum requirements.; We follow `NEP29`_ for minimum supported versions ::. - All minor versions of Python released 42 months prior to the project, and at minimum the two latest minor versions.; - All minor versions of numpy and scipy released in the 24 months prior to the project, and at minimum the last three minor versions. If dependency versions need to be updated, update them in the master branch. The following files may need to be updated: `.github/workflows/tests.yml`, `setup.cfg` and `roadmap.rst`. Finally, ensure that PyPI wheels and conda builds cover at least these versions. .. _NEP29: https://numpy.org/neps/nep-0029-deprecation_policy.html. .. _update-changelog:. Updating the Changelog; ----------------------. This needs to be done no matter what type of release is being made. #. Create a new branch to use to make a pull request.; #. Update the changelog using ``towncrier``:. towncrier build --version=<version-number>. Where ``<version-number>`` is the expected version number of the release. #. Make a pull request on the main ``qutip/qutip`` repository with this changelog, and get other members of the admin team to approve it.; #. Merge this into ``master``. Now jump to release_ if you are making a major or minor release, or bugfix_ if you are only fixing bugs in a previous release. .. _release:. Create a New Minor or Major Release; ",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
Modifiability,config,config,"leases' section. - Edit ``_includes/sidebar.html``. * Add the new version and release date. Only actively developed version should be listed. Micro replace the previous entry but the last major can be kept.; * Link to the installation instruction, documentation, source code and changelog should be updated. - Edit ``documentation.html``. * For major and minor release, the previous release tags should be moved (copied) to the 'Previous releases' section and the links to the readthedocs of the new version added the to 'Latest releases' section. .. _cforge:. Conda Forge; +++++++++++. If not done previously then fork the `qutip-feedstock <https://github.com/conda-forge/qutip-feedstock>`_. Checkout a new branch on your fork, e.g. ::. $ git checkout -b version-4.0.2. Find the sha256 checksum for the tarball that the GitHub web interface generated when you produced the release called ""Source code"".; This is *not* the sdist that you downloaded earlier, it's a new file that GitHub labels ""Source code"".; When you download it, though, it will have a name that *looks* like it's the sdist ::. $ openssl sha256 qutip-4.0.2.tar.gz. Edit the ``recipe/meta.yaml`` file.; Change the version at the top of the file, and update the sha256 checksum.; Check that the recipe package version requirements at least match those in ``setup.cfg``, and that any changes to the build process are reflected in ``meta.yml``.; Also ensure that the build number is reset ::. build:; number: 0. Push changes to your fork, e.g. ::. $ git push --set-upstream origin version-4.0.2. Make a Pull Request.; This will trigger tests of the package build process. If (when) the tests pass, the PR can be merged, which will trigger the upload of the packages to the conda-forge channel.; To test the packages, add the conda-forge channel with lowest priority ::. $ conda config --append channels conda-forge. This should mean that the prerequistes come from the default channel, but the qutip packages are found in conda-forge.; ",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
Performance,perform,perform,"have passed, merge this in.; #. Finally, back on ``master``, make a new pull request that changes the ``VERSION`` file to be ``<next-expected-version>.dev``, for example ``4.8.0.dev``.; The ""Development Status"" in ``setup.cfg`` on ``master`` should not have changed, and should be ::. Development Status :: 2 - Pre-Alpha. because ``master`` is never directly released. You should now have a branch that you can see on the GitHub website that is called ``qutip-4.7.X`` (or whatever minor version), and the state of the code in it should be exactly what you want to release as the new minor release.; If you notice you have made a mistake, you can make additional pull requests to the release branch to fix it.; ``master`` should look pretty similar, except the ``VERSION`` will be higher and have a ``.dev`` suffix, and the ""Development Status"" in ``setup.cfg`` will be different. * Activate the readthedocs build for the newly created version branch and set it as the latest. You are now ready to actually perform the release.; Go to deploy_. .. _bugfix:. Create a Bug Fix Release; ------------------------. In this you will modify an already-released branch by ""cherry-picking"" one or more pull requests that have been merged to ``master`` (including your new changelog), and bump the ""patch"" part of the version number. #. On your machine, make sure your copy of ``master`` is up-to-date (``git checkout master; git pull upstream master``).; In particular, make sure the changelog you wrote in the first step is visible.; #. Find the branch of the release that you will be modifying.; This should already exist on the ``qutip/qutip`` repository, and be called ``qutip-<major>.<minor>.X`` (e.g. ``qutip-4.6.X``).; If you cannot see it, run ``git fetch upstream`` to update all the branch references from the main repository.; Checkout a new private branch, starting from the head of the release branch (``git checkout -b prepare-qutip-4.6.1 upstream/qutip-4.6.X``).; You can call this branch whatever",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
Security,hash,hash,"e branch references from the main repository.; Checkout a new private branch, starting from the head of the release branch (``git checkout -b prepare-qutip-4.6.1 upstream/qutip-4.6.X``).; You can call this branch whatever you like (in the example it is ``prepare-qutip-4.6.1``), because it will only be used to make a pull request.; #. Cherry-pick all the commits that will be added to this release in order, including your PR that wrote the new changelog entries (this will be the last one you cherry-pick).; You will want to use ``git log`` to find the relevant commits, going from **oldest to newest** (their ""age"" is when they were merged into ``master``, not when the PR was first opened).; The command is slightly different depending on which merge strategy was used for a particular PR:. - ""merge"": you only need to find one commit though the log will have included several; there will be an entry in ``git log`` with a title such as ""Merge pull request #1000 from <...>"".; Note the first 7 characters of its hash.; Cherry-pick this by ``git cherry-pick --mainline 1 <hash>``.; - ""squash and merge"": there will only be a single commit for the entire PR.; Its name will be ""<Name of the pull request> (#1000)"".; Note the first 7 characters of its hash.; Cherry-pick this by ``git cherry-pick <hash>``.; - ""rebase and merge"": this is the most difficult, because there will be many commits that you will have to find manually, and cherry-pick all of them.; Go to the GitHub page for this PR, and go to the ""Commits"" tab.; Using your local ``git log`` (you may find ``git log --oneline`` useful), find the hash for every single commit that is listed on the GitHub page, in order from **oldest to newest** (top-to-bottom in the GitHub view, which is bottom-to-top in ``git log``).; You will need to use the commit message to do this; the hashes that GitHub reports will probably not be the same as how they appear locally.; Find the first 7 characters of each of the hashes.; Cherry-pick these all ",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
Testability,test,tests,"e not backwards-compatible may only be made in a major release.; New features that do not affect backwards-compatibility can be made in a minor release.; Bug fix releases should be small, only fix bugs, and not introduce any new features. There are a few steps that *should* have been kept up-to-date during day-to-day development, but might not be quite accurate.; For every change that is going to be part of your release, make sure that:. - The user guide in the documentation is updated with any new features, or changes to existing features.; - Any new API classes or functions have entries in a suitable RST file in ``doc/apidoc``.; - Any new or changed docstrings are up-to-date and render correctly in the API documentation. Please make a normal PR to ``master`` correcting anything missing from these points and have it merged before you begin the release, if necessary. .. _update-requirement:. Updating the Requirements; -------------------------. Ensure that QuTiP's tests pass on the oldest version supported in the requirements.; On major and minor version, requirements can be adjusted upwards, but patch release must not change minimum requirements.; We follow `NEP29`_ for minimum supported versions ::. - All minor versions of Python released 42 months prior to the project, and at minimum the two latest minor versions.; - All minor versions of numpy and scipy released in the 24 months prior to the project, and at minimum the last three minor versions. If dependency versions need to be updated, update them in the master branch. The following files may need to be updated: `.github/workflows/tests.yml`, `setup.cfg` and `roadmap.rst`. Finally, ensure that PyPI wheels and conda builds cover at least these versions. .. _NEP29: https://numpy.org/neps/nep-0029-deprecation_policy.html. .. _update-changelog:. Updating the Changelog; ----------------------. This needs to be done no matter what type of release is being made. #. Create a new branch to use to make a pull request.; ",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
Usability,guid,guide,"The Release Branch; +++++++++++++++++++++++++++++. In this step you will prepare a git branch on the main QuTiP repository that has the state of the code that is going to be released.; This procedure is quite different if you are releasing a new minor or major version compared to if you are making a bugfix patch release.; For a new minor or major version, do update-changelog_ and then jump to release_.; For a bug fix to an existing release, do update-changelog_ and then jump to bugfix_. Changes that are not backwards-compatible may only be made in a major release.; New features that do not affect backwards-compatibility can be made in a minor release.; Bug fix releases should be small, only fix bugs, and not introduce any new features. There are a few steps that *should* have been kept up-to-date during day-to-day development, but might not be quite accurate.; For every change that is going to be part of your release, make sure that:. - The user guide in the documentation is updated with any new features, or changes to existing features.; - Any new API classes or functions have entries in a suitable RST file in ``doc/apidoc``.; - Any new or changed docstrings are up-to-date and render correctly in the API documentation. Please make a normal PR to ``master`` correcting anything missing from these points and have it merged before you begin the release, if necessary. .. _update-requirement:. Updating the Requirements; -------------------------. Ensure that QuTiP's tests pass on the oldest version supported in the requirements.; On major and minor version, requirements can be adjusted upwards, but patch release must not change minimum requirements.; We follow `NEP29`_ for minimum supported versions ::. - All minor versions of Python released 42 months prior to the project, and at minimum the two latest minor versions.; - All minor versions of numpy and scipy released in the 24 months prior to the project, and at minimum the last three minor versions. If dependency versio",MatchSource.DOCS,doc/development/release_distribution.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/release_distribution.rst
Availability,mainten,maintence,"elated to QuTiP, and specifically those that are maintained by the; QuTiP Admim Team. Herin QuTiP will refer to the project / organisation and qutip; to the library for simulating quantum dyanmics. Should we be starting again from scratch, then we would probably chose another; name for the main qutip library, such as qutip-quantdyn. However, qutip is; famous, and the name will stay. Library package structure; =========================. With a name as general as Quantum Toolkit in Python, the scope for new code; modules to be added to qutip is very wide. The library was becoming increasingly; difficult to maintain, and in c. 2020 the QuTiP Admim Team decided to limit the; scope of the 'main' (for want of a better name) qutip package. This scope is; restricted to components for the simulation (solving) of the dynamics of quantum; systems. The scope includes utilities to support this, including analysis and; visualisation of output. At the same time, again with the intention of easing maintence, a decision to; limit dependences was agreed upon. Main qutip runtime code components should; depend only upon Numpy and Scipy. Installation (from source) requires Cython,; and some optional components also require Cython at runtime. Unit testing; requires Pytest. Visualisation (optional) components require Matplotlib. Due to the all encompassing nature of the plan to abstract the linear algebra; data layer, this enhancement (developed as part of a GSoC project) was allowed; the freedom (potential for non-backward compatibility) of requiring a major; release. The timing of such allows for a restructuring of the qutip compoments,; such that some that could be deemed out of scope could be packaged in a; different way -- that is, not installed as part of the main qutip package. Hence; the proposal for different types of package described next. With reference to; the :ref:`discussion above <what-is-qutip>` on the name QuTiP/qutip, the planned; restructuring suffers from confusing na",MatchSource.DOCS,doc/development/roadmap.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst
Deployability,release,release,".. _development_roadmap:. *************************; QuTiP Development Roadmap; *************************. Preamble; ========. This document outlines plan and ideas for the current and future development of; QuTiP. The document is maintained by the QuTiP Admim team. Contributuions from; the QuTiP Community are very welcome. In particular this document outlines plans for the next major release of qutip,; which will be version 5. And also plans and dreams beyond the next major; version. There is lots of development going on in QuTiP that is not recorded in here.; This a just an attempt at coordinated stragetgy and ideas for the future. .. _what-is-qutip:. What is QuTiP?; --------------. The name QuTiP refers to a few things. Most famously, qutip is a Python library; for simulating quantum dynamics. To support this, the library also contains; various software tools (functions and classes) that have more generic; applications, such as linear algebra components and visualisation utilities, and; also tools that are specifically quantum related, but have applications beyond; just solving dynamics (for instance partial trace computation). QuTiP is also an organisation, in the Github sense, and in the sense of a group; of people working collaboratively towards common objectives, and also a web; presence `qutip.org <https://qutip.org/>`_. The QuTiP Community includes all the; people who have supported the project since in conception in 2010, including; manager, funders, developers, maintainers and users. These related, and overlapping, uses of the QuTiP name are of little consequence; until one starts to consider how to organise all the software packages that are; somehow related to QuTiP, and specifically those that are maintained by the; QuTiP Admim Team. Herin QuTiP will refer to the project / organisation and qutip; to the library for simulating quantum dyanmics. Should we be starting again from scratch, then we would probably chose another; name for the main qutip library",MatchSource.DOCS,doc/development/roadmap.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst
Integrability,depend,dependences,"elated to QuTiP, and specifically those that are maintained by the; QuTiP Admim Team. Herin QuTiP will refer to the project / organisation and qutip; to the library for simulating quantum dyanmics. Should we be starting again from scratch, then we would probably chose another; name for the main qutip library, such as qutip-quantdyn. However, qutip is; famous, and the name will stay. Library package structure; =========================. With a name as general as Quantum Toolkit in Python, the scope for new code; modules to be added to qutip is very wide. The library was becoming increasingly; difficult to maintain, and in c. 2020 the QuTiP Admim Team decided to limit the; scope of the 'main' (for want of a better name) qutip package. This scope is; restricted to components for the simulation (solving) of the dynamics of quantum; systems. The scope includes utilities to support this, including analysis and; visualisation of output. At the same time, again with the intention of easing maintence, a decision to; limit dependences was agreed upon. Main qutip runtime code components should; depend only upon Numpy and Scipy. Installation (from source) requires Cython,; and some optional components also require Cython at runtime. Unit testing; requires Pytest. Visualisation (optional) components require Matplotlib. Due to the all encompassing nature of the plan to abstract the linear algebra; data layer, this enhancement (developed as part of a GSoC project) was allowed; the freedom (potential for non-backward compatibility) of requiring a major; release. The timing of such allows for a restructuring of the qutip compoments,; such that some that could be deemed out of scope could be packaged in a; different way -- that is, not installed as part of the main qutip package. Hence; the proposal for different types of package described next. With reference to; the :ref:`discussion above <what-is-qutip>` on the name QuTiP/qutip, the planned; restructuring suffers from confusing na",MatchSource.DOCS,doc/development/roadmap.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst
Modifiability,enhance,enhancement,"me as general as Quantum Toolkit in Python, the scope for new code; modules to be added to qutip is very wide. The library was becoming increasingly; difficult to maintain, and in c. 2020 the QuTiP Admim Team decided to limit the; scope of the 'main' (for want of a better name) qutip package. This scope is; restricted to components for the simulation (solving) of the dynamics of quantum; systems. The scope includes utilities to support this, including analysis and; visualisation of output. At the same time, again with the intention of easing maintence, a decision to; limit dependences was agreed upon. Main qutip runtime code components should; depend only upon Numpy and Scipy. Installation (from source) requires Cython,; and some optional components also require Cython at runtime. Unit testing; requires Pytest. Visualisation (optional) components require Matplotlib. Due to the all encompassing nature of the plan to abstract the linear algebra; data layer, this enhancement (developed as part of a GSoC project) was allowed; the freedom (potential for non-backward compatibility) of requiring a major; release. The timing of such allows for a restructuring of the qutip compoments,; such that some that could be deemed out of scope could be packaged in a; different way -- that is, not installed as part of the main qutip package. Hence; the proposal for different types of package described next. With reference to; the :ref:`discussion above <what-is-qutip>` on the name QuTiP/qutip, the planned; restructuring suffers from confusing naming, which seems unavoidable without; remaining either the organisation or the main package (neither of which are; desirable). QuTiP family packages; The main qutip package already has sub-packages,; which are maintained in the main qutip repo. Any packages maitained by the; QuTiP organisation will be called QuTiP 'family' packages. Sub-packages within; qutip main will be called 'integrated' sub-packages. Some packages will be; maintained in the",MatchSource.DOCS,doc/development/roadmap.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst
Performance,perform,performance,"te this was true as; of Nov 2019, may be fixed now). There is a [not discussed with RJ & EK] plan to move this into the QuTiP family; to allow the Admin Team to maintain, develop and promote it. The 'Sympsi' name; is cute, but a little abstract, and qutip-symbolic is proposed as an; alternative, as it is plainer and more distinct from Sympy. Affilliated packages; --------------------. qucontrol-krotov; ^^^^^^^^^^^^^^^^. * **code repository**: https://github.com/qucontrol/krotov. A package for quantum control optimisation using Krotov, developed mainly by; Michael Goerz. Generally accepted by the Admin Team as well developed and maintained. A solid; candiate for affilliation. Development Projects; ====================. .. _solve-dl:. Solver data layer integration; -----------------------------. :tag: solve-dl; :status: development ongoing; :admin lead: `Eric <https://github.com/Ericgig>`_; :main dev: `Eric <https://github.com/Ericgig>`_. The new data layer gives opportunity for significantly improving performance of; the qutip solvers. Eric has been revamping the solvers by deploying `QobjEvo`; (the time-dependent quantum object) that he developed. `QobjEvo` will exploit; the data layer, and the solvers in turn exploit `QobjEvo`. .. _qtrl-mig:. Qtrl migration; --------------. :tag: qtrl-mig; :status: conceptualised; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. The components currently packaged as an integrated subpackage of qutip main will; be moved to separate package called Qtrl. This is the original codename of the; package before it was integrated into qutip. Also changes to exploit the new; data layer will be implemented. .. _ctrl-fw:. QuTiP control framework; -----------------------. :tag: ctrl-fw; :status: conceptualised; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. Create new package qutip-ctrlfw ""QuTiP Control Framework"". The aim is provide a; common framework that can be adopted by control optimisation packages,",MatchSource.DOCS,doc/development/roadmap.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst
Safety,avoid,avoided,"fy; to respect non-commuting operators. Produce user documentation. .. _status-mig:. Status messaging and recording; ------------------------------. :tag: status-msg; :status: conceptualised; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. QuTiP has various ways of recording and reporting status and progress. - `ProgressBar` used by some solvers; - Python logging used in qutip.control; - `Dump` used in qutip.control; - heom records `solver.Stats`. Some consolidation of these would be good. Some processes (some solvers, correlation, control optimisation) have many; stages and many layers. `Dump` was initially developed to help with debugging,; but it is also useful for recording data for analysis. qutip.logging_utils has; been criticised for the way it uses Python logging. The output goes to stderr; and hence the output looks like errors in Jupyter notebooks. Clearly, storing process stage data is costly in terms of memory and cpu time,; so any implementation must be able to be optionally switched on/off, and avoided; completely in low-level processes (cythonized components). Required features:. - optional recording (storing) of process stage data (states, operators etc); - optionally write subsets to stdout; - maybe other graphical representations; - option to save subsets to file; - should ideally replace use of `ProgressBar`, Python logging, `control.Dump`, `solver.Stats`. .. _qutip-gui:. qutip Interactive; -----------------. :status: conceptualised; :tag: qutip-gui; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. QuTiP is pretty simple to use at an entry level for anyone with basic Python; skills. However, *some* Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners. This would make an good GSoC project. It is independent and the scope is; flexible. The scope for this is broad an",MatchSource.DOCS,doc/development/roadmap.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst
Security,access,accessible,"icised for the way it uses Python logging. The output goes to stderr; and hence the output looks like errors in Jupyter notebooks. Clearly, storing process stage data is costly in terms of memory and cpu time,; so any implementation must be able to be optionally switched on/off, and avoided; completely in low-level processes (cythonized components). Required features:. - optional recording (storing) of process stage data (states, operators etc); - optionally write subsets to stdout; - maybe other graphical representations; - option to save subsets to file; - should ideally replace use of `ProgressBar`, Python logging, `control.Dump`, `solver.Stats`. .. _qutip-gui:. qutip Interactive; -----------------. :status: conceptualised; :tag: qutip-gui; :admin lead: `Alex <https://github.com/ajgpitch>`_; :main dev: TBA. QuTiP is pretty simple to use at an entry level for anyone with basic Python; skills. However, *some* Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners. This would make an good GSoC project. It is independent and the scope is; flexible. The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere; ^^^^^^^^^^^^^^^^^^^^^^^^. Matplotlib has some interactive features (sliders, radio buttons, cmd buttons); that can be used to control parameters. They are a bit clunky to use, but they; are there. Could maybe avoid these and develop our own GUI. An interactive Bloch; sphere could have sliders for qubit state angles. Buttons to add states, toggle; state evolution path. Interactive solvers; ^^^^^^^^^^^^^^^^^^^. Options to configure dynamics generators (Lindbladian / Hamiltonian args etc); and expectation operators. Then run solver and view state evolution. Animated circuits; ^^^^^^^^^^^^^^^^^. QIP circuits could be animated. Status lights showing evolution of states during; the",MatchSource.DOCS,doc/development/roadmap.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst
Testability,test,testing,"robably chose another; name for the main qutip library, such as qutip-quantdyn. However, qutip is; famous, and the name will stay. Library package structure; =========================. With a name as general as Quantum Toolkit in Python, the scope for new code; modules to be added to qutip is very wide. The library was becoming increasingly; difficult to maintain, and in c. 2020 the QuTiP Admim Team decided to limit the; scope of the 'main' (for want of a better name) qutip package. This scope is; restricted to components for the simulation (solving) of the dynamics of quantum; systems. The scope includes utilities to support this, including analysis and; visualisation of output. At the same time, again with the intention of easing maintence, a decision to; limit dependences was agreed upon. Main qutip runtime code components should; depend only upon Numpy and Scipy. Installation (from source) requires Cython,; and some optional components also require Cython at runtime. Unit testing; requires Pytest. Visualisation (optional) components require Matplotlib. Due to the all encompassing nature of the plan to abstract the linear algebra; data layer, this enhancement (developed as part of a GSoC project) was allowed; the freedom (potential for non-backward compatibility) of requiring a major; release. The timing of such allows for a restructuring of the qutip compoments,; such that some that could be deemed out of scope could be packaged in a; different way -- that is, not installed as part of the main qutip package. Hence; the proposal for different types of package described next. With reference to; the :ref:`discussion above <what-is-qutip>` on the name QuTiP/qutip, the planned; restructuring suffers from confusing naming, which seems unavoidable without; remaining either the organisation or the main package (neither of which are; desirable). QuTiP family packages; The main qutip package already has sub-packages,; which are maintained in the main qutip repo. Any packag",MatchSource.DOCS,doc/development/roadmap.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst
Usability,simpl,simplifcation,"The QIP subpackage has been deemed out of scope (feature-wise). It also depends; on `qutip.control` and hence would be out of scope for dependency reasons. A; separate repository has already been made for qutip-qip. qutip-symbolic; ^^^^^^^^^^^^^^. * **current package status**: independent package `sympsi`; * **planned package status**: family package `qutip-symbolic`. Long ago Robert Johansson and Eunjong Kim developed Sympsi. It is a fairly; coomplete library for quantum computer algebra (symbolic computation). It is; primarily a quantum wrapper for `Sympy <https://www.sympy.org>`_. It has fallen into unmaintained status. The latest version on the `sympsi repo; <https://github.com/sympsi/sympsi>`_ does not work with recent versions of; Sympy. Alex Pitchford has a `fork <https://github.com/ajgpitch/sympsi>`_ that; does 'work' with recent Sympy versions -- unit tests pass, and most examples; work. However, some (important) examples fail, due to lack of respect for; non-commuting operators in Sympy simplifcation functions (note this was true as; of Nov 2019, may be fixed now). There is a [not discussed with RJ & EK] plan to move this into the QuTiP family; to allow the Admin Team to maintain, develop and promote it. The 'Sympsi' name; is cute, but a little abstract, and qutip-symbolic is proposed as an; alternative, as it is plainer and more distinct from Sympy. Affilliated packages; --------------------. qucontrol-krotov; ^^^^^^^^^^^^^^^^. * **code repository**: https://github.com/qucontrol/krotov. A package for quantum control optimisation using Krotov, developed mainly by; Michael Goerz. Generally accepted by the Admin Team as well developed and maintained. A solid; candiate for affilliation. Development Projects; ====================. .. _solve-dl:. Solver data layer integration; -----------------------------. :tag: solve-dl; :status: development ongoing; :admin lead: `Eric <https://github.com/Ericgig>`_; :main dev: `Eric <https://github.com/Ericgig>`_. The new da",MatchSource.DOCS,doc/development/roadmap.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/roadmap.rst
Availability,avail,available,".. _basics:. ***********************************; Basic Operations on Quantum Objects; ***********************************. .. _basics-first:. First things first; ==================. .. warning:: Do not run QuTiP from the installation directory. To load the qutip modules, first call the import statement:. .. code-block:: Python. from qutip import *. This will load all of the user available functions. Often, we also need to import the NumPy and Matplotlib libraries with:. .. code-block:: Python. import numpy as np. import matplotlib.pyplot as plt. In the rest of the documentation, functions are written using `qutip.module.function()` notation which links to the corresponding function in the QuTiP API: :ref:`functions`. However, in calling `import *`, we have already loaded all of the QuTiP modules. Therefore, we will only need the function name and not the complete path when calling the function from the interpreter prompt, Python script, or Jupyter notebook. .. _basics-qobj:. The quantum object class; ========================. .. _basics-qobj-intro:. Introduction; ---------------. The key difference between classical and quantum mechanics is the use of operators instead of numbers as variables. Moreover, we need to specify state vectors and their properties. Therefore, in computing the dynamics of quantum systems, we need a data structure that encapsulates the properties of a quantum operator and ket/bra vectors. The quantum object class, :func:`qutip.Qobj`, accomplishes this using matrix representation. To begin, let us create a blank ``Qobj``:. .. testcode:: [basics]. print(Qobj()). **Output**:. .. testoutput:: [basics]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[1], [1]], shape = (1, 1), type = bra; Qobj data =; [[0.]]. where we see the blank ``Qobj`` object with dimensions, shape, and data. Here the data corresponds to a 1x1-dimensional matrix consisting of a single zero entry. .. Hint:: By convention, the names of Python classes, such as ``Qobj()`",MatchSource.DOCS,doc/guide/guide-basics.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-basics.rst
Deployability,install,installation,".. _basics:. ***********************************; Basic Operations on Quantum Objects; ***********************************. .. _basics-first:. First things first; ==================. .. warning:: Do not run QuTiP from the installation directory. To load the qutip modules, first call the import statement:. .. code-block:: Python. from qutip import *. This will load all of the user available functions. Often, we also need to import the NumPy and Matplotlib libraries with:. .. code-block:: Python. import numpy as np. import matplotlib.pyplot as plt. In the rest of the documentation, functions are written using `qutip.module.function()` notation which links to the corresponding function in the QuTiP API: :ref:`functions`. However, in calling `import *`, we have already loaded all of the QuTiP modules. Therefore, we will only need the function name and not the complete path when calling the function from the interpreter prompt, Python script, or Jupyter notebook. .. _basics-qobj:. The quantum object class; ========================. .. _basics-qobj-intro:. Introduction; ---------------. The key difference between classical and quantum mechanics is the use of operators instead of numbers as variables. Moreover, we need to specify state vectors and their properties. Therefore, in computing the dynamics of quantum systems, we need a data structure that encapsulates the properties of a quantum operator and ket/bra vectors. The quantum object class, :func:`qutip.Qobj`, accomplishes this using matrix representation. To begin, let us create a blank ``Qobj``:. .. testcode:: [basics]. print(Qobj()). **Output**:. .. testoutput:: [basics]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[1], [1]], shape = (1, 1), type = bra; Qobj data =; [[0.]]. where we see the blank ``Qobj`` object with dimensions, shape, and data. Here the data corresponds to a 1x1-dimensional matrix consisting of a single zero entry. .. Hint:: By convention, the names of Python classes, such as ``Qobj()`",MatchSource.DOCS,doc/guide/guide-basics.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-basics.rst
Energy Efficiency,charge,charge,"| | | for requested coherent state |; +--------------------------+----------------------------------+----------------------------------------+; | Coherent density matrix | ``coherent_dm(N,alpha)`` | same as coherent(N,alpha) |; | (outer product) | | |; +--------------------------+----------------------------------+----------------------------------------+; | Thermal density matrix | ``thermal_dm(N,n)`` | n = particle number expectation value |; | (for n particles) | | |; +--------------------------+----------------------------------+----------------------------------------+; | Maximally mixed density | ``maximally_mixed_dm(N)`` | N = number of levels in Hilbert space |; | matrix | | |; +--------------------------+----------------------------------+----------------------------------------+. .. cssclass:: table-striped. +--------------------------+----------------------------+----------------------------------------+; | Operators | Command (# means optional) | Inputs |; +==========================+============================+========================================+; | Charge operator | ``charge(N,M=-N)`` | Diagonal operator with entries |; | | | from M..0..N. |; +--------------------------+----------------------------+----------------------------------------+; | Commutator | ``commutator(A, B, kind)`` | Kind = 'normal' or 'anti'. |; +--------------------------+----------------------------+----------------------------------------+; | Diagonals operator | ``qdiags(N)`` | Quantum object created from arrays of |; | | | diagonals at given offsets. |; +--------------------------+----------------------------+----------------------------------------+; | Displacement operator | ``displace(N,alpha)`` | N=number of levels in Hilbert space, |; | (Single-mode) | | alpha = complex displacement amplitude.|; +--------------------------+----------------------------+----------------------------------------+; | Higher spin operators | ``jmat(j,#s)`` | j = integer or half-integer |; | ",MatchSource.DOCS,doc/guide/guide-basics.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-basics.rst
Modifiability,variab,variables," first; ==================. .. warning:: Do not run QuTiP from the installation directory. To load the qutip modules, first call the import statement:. .. code-block:: Python. from qutip import *. This will load all of the user available functions. Often, we also need to import the NumPy and Matplotlib libraries with:. .. code-block:: Python. import numpy as np. import matplotlib.pyplot as plt. In the rest of the documentation, functions are written using `qutip.module.function()` notation which links to the corresponding function in the QuTiP API: :ref:`functions`. However, in calling `import *`, we have already loaded all of the QuTiP modules. Therefore, we will only need the function name and not the complete path when calling the function from the interpreter prompt, Python script, or Jupyter notebook. .. _basics-qobj:. The quantum object class; ========================. .. _basics-qobj-intro:. Introduction; ---------------. The key difference between classical and quantum mechanics is the use of operators instead of numbers as variables. Moreover, we need to specify state vectors and their properties. Therefore, in computing the dynamics of quantum systems, we need a data structure that encapsulates the properties of a quantum operator and ket/bra vectors. The quantum object class, :func:`qutip.Qobj`, accomplishes this using matrix representation. To begin, let us create a blank ``Qobj``:. .. testcode:: [basics]. print(Qobj()). **Output**:. .. testoutput:: [basics]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[1], [1]], shape = (1, 1), type = bra; Qobj data =; [[0.]]. where we see the blank ``Qobj`` object with dimensions, shape, and data. Here the data corresponds to a 1x1-dimensional matrix consisting of a single zero entry. .. Hint:: By convention, the names of Python classes, such as ``Qobj()``, are capitalized whereas the names of functions are not. We can create a ``Qobj`` with a user defined data set by passing a list or array of data into t",MatchSource.DOCS,doc/guide/guide-basics.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-basics.rst
Performance,load,load,".. _basics:. ***********************************; Basic Operations on Quantum Objects; ***********************************. .. _basics-first:. First things first; ==================. .. warning:: Do not run QuTiP from the installation directory. To load the qutip modules, first call the import statement:. .. code-block:: Python. from qutip import *. This will load all of the user available functions. Often, we also need to import the NumPy and Matplotlib libraries with:. .. code-block:: Python. import numpy as np. import matplotlib.pyplot as plt. In the rest of the documentation, functions are written using `qutip.module.function()` notation which links to the corresponding function in the QuTiP API: :ref:`functions`. However, in calling `import *`, we have already loaded all of the QuTiP modules. Therefore, we will only need the function name and not the complete path when calling the function from the interpreter prompt, Python script, or Jupyter notebook. .. _basics-qobj:. The quantum object class; ========================. .. _basics-qobj-intro:. Introduction; ---------------. The key difference between classical and quantum mechanics is the use of operators instead of numbers as variables. Moreover, we need to specify state vectors and their properties. Therefore, in computing the dynamics of quantum systems, we need a data structure that encapsulates the properties of a quantum operator and ket/bra vectors. The quantum object class, :func:`qutip.Qobj`, accomplishes this using matrix representation. To begin, let us create a blank ``Qobj``:. .. testcode:: [basics]. print(Qobj()). **Output**:. .. testoutput:: [basics]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[1], [1]], shape = (1, 1), type = bra; Qobj data =; [[0.]]. where we see the blank ``Qobj`` object with dimensions, shape, and data. Here the data corresponds to a 1x1-dimensional matrix consisting of a single zero entry. .. Hint:: By convention, the names of Python classes, such as ``Qobj()`",MatchSource.DOCS,doc/guide/guide-basics.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-basics.rst
Safety,avoid,avoided,": [basics]; :options: +NORMALIZE_WHITESPACE. >>> q.data_as(""dia_matrix""); <4x4 sparse matrix of type '<class 'numpy.complex128'>'; with 3 stored elements (1 diagonals) in DIAgonal format>. Conversion between storage type is done using the :meth:`.Qobj.to` method. .. doctest:: [basics]; :options: +NORMALIZE_WHITESPACE. >>> q.to(""CSR"").data; CSR(shape=(4, 4), nnz=3). >>> q.to(""CSR"").data_as(""csr_matrix""); <4x4 sparse matrix of type '<class 'numpy.complex128'>'; with 3 stored elements in Compressed Sparse Row format>. Note that :meth:`.Qobj.data_as` does not do the conversion. QuTiP will do conversion when needed to keep everything working in any format.; However these conversions could slow down computation and it is recommended to keep to one format family where possible.; For example, core QuTiP ``Dense`` and ``CSR`` work well together and binary operations between these formats is efficient.; However binary operations between ``Dense`` and ``Jax`` should be avoided since it is not always clear whether the operation will be executed by Jax (possibly on a GPU if present) or numpy. .. _basics-qobj-math:. Qobj Math; ----------. The rules for mathematical operations on ``Qobj`` instances are similar to standard matrix arithmetic:. .. doctest:: [basics]; :options: +NORMALIZE_WHITESPACE. >>> q = destroy(4). >>> x = sigmax(). >>> q + 5; Quantum object: dims = [[4], [4]], shape = (4, 4), type = oper, isherm = False; Qobj data =; [[5. 1. 0. 0. ]; [0. 5. 1.41421356 0. ]; [0. 0. 5. 1.73205081]; [0. 0. 0. 5. ]]. >>> x * x; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[1. 0.]; [0. 1.]]. >>> q ** 3; Quantum object: dims = [[4], [4]], shape = (4, 4), type = oper, isherm = False; Qobj data =; [[0. 0. 0. 2.44948974]; [0. 0. 0. 0. ]; [0. 0. 0. 0. ]; [0. 0. 0. 0. ]]. >>> x / np.sqrt(2); Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[0. 0.70710678]; [0.70710678 0. ]]. Of course, like matrices,",MatchSource.DOCS,doc/guide/guide-basics.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-basics.rst
Security,access,accessed,"0.]]. >>> coherent(5,0.5-0.5j); Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[ 0.7788017 +0.j ]; [ 0.38939142-0.38939142j]; [ 0. -0.27545895j]; [-0.07898617-0.07898617j]; [-0.04314271+0.j ]]. >>> destroy(4); Quantum object: dims = [[4], [4]], shape = (4, 4), type = oper, isherm = False; Qobj data =; [[0. 1. 0. 0. ]; [0. 0. 1.41421356 0. ]; [0. 0. 0. 1.73205081]; [0. 0. 0. 0. ]]. >>> sigmaz(); Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[ 1. 0.]; [ 0. -1.]]. >>> jmat(5/2.0,'+'); Quantum object: dims = [[6], [6]], shape = (6, 6), type = oper, isherm = False; Qobj data =; [[0. 2.23606798 0. 0. 0. 0. ]; [0. 0. 2.82842712 0. 0. 0. ]; [0. 0. 0. 3. 0. 0. ]; [0. 0. 0. 0. 2.82842712 0. ]; [0. 0. 0. 0. 0. 2.23606798]; [0. 0. 0. 0. 0. 0. ]]. .. _basics-qobj-props:. Qobj attributes; ---------------. We have seen that a quantum object has several internal attributes, such as data, dims, and shape. These can be accessed in the following way:. .. doctest:: [basics]; :options: +NORMALIZE_WHITESPACE. >>> q = destroy(4). >>> q.dims; [[4], [4]]. >>> q.shape; (4, 4). In general, the attributes (properties) of a ``Qobj`` object (or any Python object) can be retrieved using the `Q.attribute` notation.; In addition to the those shown with the ``print`` function, an instance of the ``Qobj`` class also has the following attributes:. .. cssclass:: table-striped. +---------------+---------------+----------------------------------------+; | Property | Attribute | Description |; +===============+===============+========================================+; | Data | ``Q.data`` | Matrix representing state or operator |; +---------------+---------------+----------------------------------------+; | Dimensions | ``Q.dims`` | List keeping track of shapes for |; | | | individual components of a |; | | | multipartite system (for tensor |; | | | products and partial traces). |; +---------------+---------------+-----------------",MatchSource.DOCS,doc/guide/guide-basics.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-basics.rst
Testability,test,testcode,", functions are written using `qutip.module.function()` notation which links to the corresponding function in the QuTiP API: :ref:`functions`. However, in calling `import *`, we have already loaded all of the QuTiP modules. Therefore, we will only need the function name and not the complete path when calling the function from the interpreter prompt, Python script, or Jupyter notebook. .. _basics-qobj:. The quantum object class; ========================. .. _basics-qobj-intro:. Introduction; ---------------. The key difference between classical and quantum mechanics is the use of operators instead of numbers as variables. Moreover, we need to specify state vectors and their properties. Therefore, in computing the dynamics of quantum systems, we need a data structure that encapsulates the properties of a quantum operator and ket/bra vectors. The quantum object class, :func:`qutip.Qobj`, accomplishes this using matrix representation. To begin, let us create a blank ``Qobj``:. .. testcode:: [basics]. print(Qobj()). **Output**:. .. testoutput:: [basics]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[1], [1]], shape = (1, 1), type = bra; Qobj data =; [[0.]]. where we see the blank ``Qobj`` object with dimensions, shape, and data. Here the data corresponds to a 1x1-dimensional matrix consisting of a single zero entry. .. Hint:: By convention, the names of Python classes, such as ``Qobj()``, are capitalized whereas the names of functions are not. We can create a ``Qobj`` with a user defined data set by passing a list or array of data into the ``Qobj``:. .. testcode:: [basics]. print(Qobj([[1],[2],[3],[4],[5]])). **Output**:. .. testoutput:: [basics]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[1.]; [2.]; [3.]; [4.]; [5.]]. .. testcode:: [basics]. x = np.array([[1, 2, 3, 4, 5]]); print(Qobj(x)). **Output**:. .. testoutput:: [basics]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[1], [5]",MatchSource.DOCS,doc/guide/guide-basics.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-basics.rst
Usability,clear,clear,": [basics]; :options: +NORMALIZE_WHITESPACE. >>> q.data_as(""dia_matrix""); <4x4 sparse matrix of type '<class 'numpy.complex128'>'; with 3 stored elements (1 diagonals) in DIAgonal format>. Conversion between storage type is done using the :meth:`.Qobj.to` method. .. doctest:: [basics]; :options: +NORMALIZE_WHITESPACE. >>> q.to(""CSR"").data; CSR(shape=(4, 4), nnz=3). >>> q.to(""CSR"").data_as(""csr_matrix""); <4x4 sparse matrix of type '<class 'numpy.complex128'>'; with 3 stored elements in Compressed Sparse Row format>. Note that :meth:`.Qobj.data_as` does not do the conversion. QuTiP will do conversion when needed to keep everything working in any format.; However these conversions could slow down computation and it is recommended to keep to one format family where possible.; For example, core QuTiP ``Dense`` and ``CSR`` work well together and binary operations between these formats is efficient.; However binary operations between ``Dense`` and ``Jax`` should be avoided since it is not always clear whether the operation will be executed by Jax (possibly on a GPU if present) or numpy. .. _basics-qobj-math:. Qobj Math; ----------. The rules for mathematical operations on ``Qobj`` instances are similar to standard matrix arithmetic:. .. doctest:: [basics]; :options: +NORMALIZE_WHITESPACE. >>> q = destroy(4). >>> x = sigmax(). >>> q + 5; Quantum object: dims = [[4], [4]], shape = (4, 4), type = oper, isherm = False; Qobj data =; [[5. 1. 0. 0. ]; [0. 5. 1.41421356 0. ]; [0. 0. 5. 1.73205081]; [0. 0. 0. 5. ]]. >>> x * x; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[1. 0.]; [0. 1.]]. >>> q ** 3; Quantum object: dims = [[4], [4]], shape = (4, 4), type = oper, isherm = False; Qobj data =; [[0. 0. 0. 2.44948974]; [0. 0. 0. 0. ]; [0. 0. 0. 0. ]; [0. 0. 0. 0. ]]. >>> x / np.sqrt(2); Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[0. 0.70710678]; [0.70710678 0. ]]. Of course, like matrices,",MatchSource.DOCS,doc/guide/guide-basics.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-basics.rst
Availability,avail,available,".. _bloch:. ******************************; Plotting on the Bloch Sphere; ******************************. .. _bloch-intro:. Introduction; ============. When studying the dynamics of a two-level system, it is often convenient to visualize the state of the system by plotting the state-vector or density matrix on the Bloch sphere. In QuTiP, there is a class to allow for easy creation and manipulation of data sets, both vectors and data points, on the Bloch sphere. .. _bloch-class:. The Bloch Class; ===============. In QuTiP, creating a Bloch sphere is accomplished by calling either:. .. plot::; :context: reset. b = qutip.Bloch(). which will load an instance of the :class:`~qutip.bloch.Bloch` class.; Before getting into the details of these objects, we can simply plot the blank Bloch sphere associated with these instances via:. .. plot::; :context:. b.make_sphere(). In addition to the ``show`` command, see the API documentation for :class:`~qutip.bloch.Bloch` for a full list of other available functions.; As an example, we can add a single data point:. .. plot::; :context: close-figs. pnt = [1/np.sqrt(3), 1/np.sqrt(3), 1/np.sqrt(3)]; b.add_points(pnt); b.render(). and then a single vector:. .. plot::; :context: close-figs. b.fig.clf(); vec = [0, 1, 0]; b.add_vectors(vec); b.render(). and then add another vector corresponding to the :math:`\left|\rm up \right>` state:. .. plot::; :context: close-figs. up = qutip.basis(2, 0); b.add_states(up); b.render(). Notice that when we add more than a single vector (or data point), a different color will automatically be applied to the later data set (mod 4).; In total, the code for constructing our Bloch sphere with one vector, one state, and a single data point is:. .. plot::; :context: close-figs. b = qutip.Bloch(). pnt = [1./np.sqrt(3), 1./np.sqrt(3), 1./np.sqrt(3)]; b.add_points(pnt); vec = [0, 1, 0]; b.add_vectors(vec); up = qutip.basis(2, 0); b.add_states(up); b.render(). where we have removed the extra ``show()`` commands. We",MatchSource.DOCS,doc/guide/guide-bloch.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-bloch.rst
Deployability,install,installing,"both methods by looking at the decay of a qubit on the bloch sphere. .. _bloch-animate-decay:. Example: Qubit Decay; --------------------. The code for calculating the expectation values for the Pauli spin operators of a qubit decay is given below. This code is common to both animation examples. .. literalinclude:: scripts/ex_bloch_animation.py. .. _bloch-animate-decay-images:. Generating Images for Animation; ++++++++++++++++++++++++++++++++. An example of generating images for generating an animation outside of Python is given below::. import numpy as np; b = qutip.Bloch(); b.vector_color = ['r']; b.view = [-40, 30]; for i in range(len(sx)):; b.clear(); b.add_vectors([np.sin(theta), 0, np.cos(theta)]); b.add_points([sx[:i+1], sy[:i+1], sz[:i+1]]); b.save(dirc='temp') # saving images to temp directory in current working directory. Generating an animation using FFmpeg (for example) is fairly simple::. ffmpeg -i temp/bloch_%01d.png bloch.mp4. .. _bloch-animate-decay-direct:. Directly Generating an Animation; ++++++++++++++++++++++++++++++++. .. important::; Generating animations directly from Matplotlib requires installing either MEncoder or FFmpeg.; While either choice works on linux, it is best to choose FFmpeg when running on the Mac.; If using macports just do: ``sudo port install ffmpeg``. The code to directly generate an mp4 movie of the Qubit decay is as follows ::. from matplotlib import pyplot, animation. fig = pyplot.figure(); ax = fig.add_subplot(azim=-40, elev=30, projection=""3d""); sphere = qutip.Bloch(axes=ax). def animate(i):; sphere.clear(); sphere.add_vectors([np.sin(theta), 0, np.cos(theta)], [""r""]); sphere.add_points([sx[:i+1], sy[:i+1], sz[:i+1]]); sphere.make_sphere(); return ax. ani = animation.FuncAnimation(fig, animate, np.arange(len(sx)), blit=False, repeat=False); ani.save('bloch_sphere.mp4', fps=20). The resulting movie may be viewed here: `bloch_decay.mp4 <https://raw.githubusercontent.com/qutip/qutip/master/doc/figures/bloch_decay.mp4>`_; ",MatchSource.DOCS,doc/guide/guide-bloch.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-bloch.rst
Modifiability,config,config," multiple data points using the ``add_points`` function is interpreted, by default, to correspond to a single data point (single qubit state) plotted at different times. This is very useful when visualizing the dynamics of a qubit. An example of this is given in the example . If we want to plot additional qubit states we can call additional ``add_points`` functions:. .. plot::; :context: close-figs. xz = np.zeros(20); yz = np.sin(th); zz = np.cos(th); b.add_points([xz, yz, zz]); b.render(). The color and shape of the data points is varied automatically by the Bloch class. Notice how the color and point markers change for each set of data. Again, we have had to call ``add_points`` twice because adding more than one set of multiple data points is *not* supported by the ``add_points`` function. What if we want to vary the color of our points. We can tell the :class:`qutip.bloch.Bloch` class to vary the color of each point according to the colors listed in the ``b.point_color`` list (see :ref:`bloch-config` below). Again after ``clear()``:. .. plot::; :context: close-figs. b.clear(). xp = np.cos(th); yp = np.sin(th); zp = np.zeros(20); pnts = [xp, yp, zp]; b.add_points(pnts, 'm') # <-- add a 'm' string to signify 'multi' colored points; b.render(). Now, the data points cycle through a variety of predefined colors. Now lets add another set of points, but this time we want the set to be a single color, representing say a qubit going from the :math:`\left|\rm up\right>` state to the :math:`\left|\rm down\right>` state in the y-z plane:. .. plot::; :context: close-figs. xz = np.zeros(20); yz = np.sin(th); zz = np.cos(th). b.add_points([xz, yz, zz]) # no 'm'; b.render(). A more slick way of using this 'multi' color feature is also given in the example, where we set the color of the markers as a function of time. .. _bloch-config:. Configuring the Bloch sphere; ============================. Bloch Class Options; --------------------. At the end of the last section we saw that t",MatchSource.DOCS,doc/guide/guide-bloch.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-bloch.rst
Performance,load,load,".. _bloch:. ******************************; Plotting on the Bloch Sphere; ******************************. .. _bloch-intro:. Introduction; ============. When studying the dynamics of a two-level system, it is often convenient to visualize the state of the system by plotting the state-vector or density matrix on the Bloch sphere. In QuTiP, there is a class to allow for easy creation and manipulation of data sets, both vectors and data points, on the Bloch sphere. .. _bloch-class:. The Bloch Class; ===============. In QuTiP, creating a Bloch sphere is accomplished by calling either:. .. plot::; :context: reset. b = qutip.Bloch(). which will load an instance of the :class:`~qutip.bloch.Bloch` class.; Before getting into the details of these objects, we can simply plot the blank Bloch sphere associated with these instances via:. .. plot::; :context:. b.make_sphere(). In addition to the ``show`` command, see the API documentation for :class:`~qutip.bloch.Bloch` for a full list of other available functions.; As an example, we can add a single data point:. .. plot::; :context: close-figs. pnt = [1/np.sqrt(3), 1/np.sqrt(3), 1/np.sqrt(3)]; b.add_points(pnt); b.render(). and then a single vector:. .. plot::; :context: close-figs. b.fig.clf(); vec = [0, 1, 0]; b.add_vectors(vec); b.render(). and then add another vector corresponding to the :math:`\left|\rm up \right>` state:. .. plot::; :context: close-figs. up = qutip.basis(2, 0); b.add_states(up); b.render(). Notice that when we add more than a single vector (or data point), a different color will automatically be applied to the later data set (mod 4).; In total, the code for constructing our Bloch sphere with one vector, one state, and a single data point is:. .. plot::; :context: close-figs. b = qutip.Bloch(). pnt = [1./np.sqrt(3), 1./np.sqrt(3), 1./np.sqrt(3)]; b.add_points(pnt); vec = [0, 1, 0]; b.add_vectors(vec); up = qutip.basis(2, 0); b.add_states(up); b.render(). where we have removed the extra ``show()`` commands. We",MatchSource.DOCS,doc/guide/guide-bloch.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-bloch.rst
Security,access,accessed,"[1.1, -1.1]`` |; +---------------+---------------------------------------------------------+-------------------------------------------------+; | b.ylabel | Labels for y-axis | ``['$y$', '']`` +y and -y (labels use LaTeX) |; +---------------+---------------------------------------------------------+-------------------------------------------------+; | b.ylpos | Position of y-axis labels | ``[1.2, -1.2]`` |; +---------------+---------------------------------------------------------+-------------------------------------------------+; | b.zlabel | Labels for z-axis | ``['$\left|0\right>$', '$\left|1\right>$']`` |; | | | +z and -z (labels use LaTeX) |; +---------------+---------------------------------------------------------+-------------------------------------------------+; | b.zlpos | Position of z-axis labels | ``[1.2, -1.2]`` |; +---------------+---------------------------------------------------------+-------------------------------------------------+. These properties can also be accessed via the print command:. .. doctest::. >>> b = qutip.Bloch(). >>> print(b) # doctest: +NORMALIZE_WHITESPACE; Bloch data:; -----------; Number of points: 0; Number of vectors: 0; <BLANKLINE>; Bloch sphere properties:; ------------------------; font_color: black; font_size: 20; frame_alpha: 0.2; frame_color: gray; frame_width: 1; point_color: ['b', 'r', 'g', '#CC6600']; point_marker: ['o', 's', 'd', '^']; point_size: [25, 32, 35, 45]; sphere_alpha: 0.2; sphere_color: #FFDDDD; figsize: [5, 5]; vector_color: ['g', '#CC6600', 'b', 'r']; vector_width: 3; vector_style: -|>; vector_mutation: 20; view: [-60, 30]; xlabel: ['$x$', '']; xlpos: [1.2, -1.2]; ylabel: ['$y$', '']; ylpos: [1.2, -1.2]; zlabel: ['$\\left|0\\right>$', '$\\left|1\\right>$']; zlpos: [1.2, -1.2]; <BLANKLINE>. .. _bloch-animate:. Animating with the Bloch sphere; ===============================. The Bloch class was designed from the outset to generate animations. To animate a set of vectors or data points the basic idea",MatchSource.DOCS,doc/guide/guide-bloch.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-bloch.rst
Usability,simpl,simply,".. _bloch:. ******************************; Plotting on the Bloch Sphere; ******************************. .. _bloch-intro:. Introduction; ============. When studying the dynamics of a two-level system, it is often convenient to visualize the state of the system by plotting the state-vector or density matrix on the Bloch sphere. In QuTiP, there is a class to allow for easy creation and manipulation of data sets, both vectors and data points, on the Bloch sphere. .. _bloch-class:. The Bloch Class; ===============. In QuTiP, creating a Bloch sphere is accomplished by calling either:. .. plot::; :context: reset. b = qutip.Bloch(). which will load an instance of the :class:`~qutip.bloch.Bloch` class.; Before getting into the details of these objects, we can simply plot the blank Bloch sphere associated with these instances via:. .. plot::; :context:. b.make_sphere(). In addition to the ``show`` command, see the API documentation for :class:`~qutip.bloch.Bloch` for a full list of other available functions.; As an example, we can add a single data point:. .. plot::; :context: close-figs. pnt = [1/np.sqrt(3), 1/np.sqrt(3), 1/np.sqrt(3)]; b.add_points(pnt); b.render(). and then a single vector:. .. plot::; :context: close-figs. b.fig.clf(); vec = [0, 1, 0]; b.add_vectors(vec); b.render(). and then add another vector corresponding to the :math:`\left|\rm up \right>` state:. .. plot::; :context: close-figs. up = qutip.basis(2, 0); b.add_states(up); b.render(). Notice that when we add more than a single vector (or data point), a different color will automatically be applied to the later data set (mod 4).; In total, the code for constructing our Bloch sphere with one vector, one state, and a single data point is:. .. plot::; :context: close-figs. b = qutip.Bloch(). pnt = [1./np.sqrt(3), 1./np.sqrt(3), 1./np.sqrt(3)]; b.add_points(pnt); vec = [0, 1, 0]; b.add_vectors(vec); up = qutip.basis(2, 0); b.add_states(up); b.render(). where we have removed the extra ``show()`` commands. We",MatchSource.DOCS,doc/guide/guide-bloch.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-bloch.rst
Availability,error,error," where :math:`\Delta t_k` is the duration of the timeslot. The evolution up to (and including) any timeslot :math:`k` (including the full evolution :math:`k=M`) can the be calculated as. .. math::. X(t_k):=X_k X_{k-1}\cdots X_1 X_0. If the objective is state-to-state transfer then :math:`X_0=\ket{\psi_0}` and the target :math:`X_{targ}=\ket{\psi_1}`, for gate synthesis :math:`X_0 = U(0) = \mathbb{1}` and the target :math:`X_{targ}=U_{targ}`. A *figure of merit* or *fidelity* is some measure of how close the evolution is to the target, based on the control amplitudes in the timeslots. The typical figure of merit for unitary systems is the normalised overlap of the evolution and the target. .. math::. f_{PSU} = \tfrac{1}{d} \big| \tr \{X_{targ}^{\dagger} X(T)\} \big|. where :math:`d` is the system dimension. In this figure of merit the absolute value is taken to ignore any differences in global phase, and :math:`0 \le f \le 1`. Typically the fidelity error (or *infidelity*) is more useful, in this case defined as :math:`\varepsilon = 1 - f_{PSU}`. There are many other possible objectives, and hence figures of merit. As there are now :math:`N \times M` variables (the :math:`u_{jk}`) and one; parameter to minimise :math:`\varepsilon`, then the problem becomes a finite; multi-variable optimisation problem, for which there are many established; methods, often referred to as 'hill-climbing' methods. The simplest of these to; understand is that of steepest ascent (or descent). The gradient of the; fidelity with respect to all the variables is calculated (or approximated) and; a step is made in the variable space in the direction of steepest ascent (or; descent). This method is a first order gradient method. In two dimensions this; describes a method of climbing a hill by heading in the direction where the; ground rises fastest. This analogy also clearly illustrates one of the main; challenges in multi-variable optimisation, which is that all methods have a; tendency to get ",MatchSource.DOCS,doc/guide/guide-control.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-control.rst
Deployability,integrat,integration,"[Caneva11]_ comes into play: Since the pulse complexity is usually; very low, it is sufficient to transform the optimal control problem to a few; parameter search by introducing a physically motivated function basis that; builds up the pulse. Compared to the number of time slices needed to accurately; simulate quantum dynamics (often equals basis dimension for Gradient based; algorithms), this number is lower by orders of magnitude, allowing CRAB to; efficiently optimize smooth pulses with realistic experimental constraints. It; is important to point out, that CRAB does not make any suggestion on the basis; function to be used. The basis must be chosen carefully considered, taking into; account a priori knowledge of the system (such as symmetries, magnitudes of; scales,...) and solution (e.g. sign, smoothness, bang-bang behavior,; singularities, maximum excursion or rate of change,....). By doing so, this; algorithm allows for native integration of experimental constraints such as; maximum frequencies allowed, maximum amplitude, smooth ramping up and down of; the pulse and many more. Moreover initial guesses, if they are available, can; (however not have to) be included to speed up convergence. As mentioned in the GRAPE paragraph, for CRAB local minima arising from; algorithmic design can occur, too. However, for CRAB a 'dressed' version has; recently been introduced [Rach15]_ that allows to escape local minima. For some control objectives and/or dynamical quantum descriptions, it is either; not possible to derive the gradient for the cost functional with respect to; each time slice or it is computationally expensive to do so. The same can apply; for the necessary (reverse) propagation of the co-state. All this trouble does; not occur within CRAB as those elements are not in use here. CRAB, instead,; takes the time evolution as a black-box where the pulse goes as an input and; the cost (e.g. infidelity) value will be returned as an output. This concept,; on top, all",MatchSource.DOCS,doc/guide/guide-control.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-control.rst
Energy Efficiency,efficient,efficient,"stuck in local maxima. It is hard to determine whether one has; found a global maximum or not - a local peak is likely not to be the highest; mountain in the region. In quantum optimal control we can typically define an; infidelity that has a lower bound of zero. We can then look to minimise the; infidelity (from here on we will only consider optimising for infidelity; minima). This means that we can terminate any pulse optimisation when the; infidelity reaches zero (to a sufficient precision). This is however only; possible for fully controllable systems; otherwise it is hard (if not; impossible) to know that the minimum possible infidelity has been achieved. In; the hill walking analogy the step size is roughly fixed to a stride, however,; in computations the step size must be chosen. Clearly there is a trade-off here; between the number of steps (or iterations) required to reach the minima and; the possibility that we might step over a minima. In practice it is difficult; to determine an efficient and effective step size. The second order differentials of the infidelity with respect to the variables; can be used to approximate the local landscape to a parabola. This way a step; (or jump) can be made to where the minima would be if it were parabolic. This; typically vastly reduces the number of iterations, and removes the need to; guess a step size. The method where all the second differentials are calculated; explicitly is called the *Newton-Raphson* method. However, calculating the; second-order differentials (the Hessian matrix) can be computationally; expensive, and so there are a class of methods known as *quasi-Newton* that; approximate the Hessian based on successive iterations. The most popular of; these (in quantum optimal control) is the Broyden–Fletcher–Goldfarb–Shanno; algorithm (BFGS). The default method in the QuTiP Qtrl GRAPE implementation is; the L-BFGS-B method in Scipy, which is a wrapper to the implementation; described in [Byrd95]_. This limit",MatchSource.DOCS,doc/guide/guide-control.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-control.rst
Integrability,depend,dependent," to Schrödinger's equation are of the form:. .. math::. \ket{\psi(t)} = U(t)\ket{\psi_0}. where :math:`\psi_0` is the state of the system at :math:`t=0` and :math:`U(t)` is a unitary operator on the Hilbert space containing the states. :math:`U(t)` is a solution to the *Schrödinger operator equation*. .. math::. \tfrac{d}{dt}U = -i H(t)U ,\quad U(0) = \mathbb{1}. We can use optimal control algorithms to determine a set of :math:`u_j` that will drive our system from :math:`\ket{\psi_0}` to :math:`\ket{\psi_1}`, this is state-to-state transfer, or drive the system from some arbitary state to a given state :math:`\ket{\psi_1}`, which is state preparation, or effect some unitary transformation :math:`U_{target}`, called gate synthesis. The latter of these is most important in quantum computation. The GRAPE algorithm; ===================; The **GR**\ adient **A**\ scent **P**\ ulse **E**\ ngineering was first proposed in [NKanej]_. Solutions to Schrödinger's equation for a time-dependent Hamiltonian are not generally possible to obtain analytically. Therefore, a piecewise constant approximation to the pulse amplitudes is made. Time allowed for the system to evolve :math:`T` is split into :math:`M` timeslots (typically these are of equal duration), during which the control amplitude is assumed to remain constant. The combined Hamiltonian can then be approximated as:. .. math::. H(t) \approx H(t_k) = H_0 + \sum_{j=1}^N u_{jk} H_j\quad. where :math:`k` is a timeslot index, :math:`j` is the control index, and :math:`N` is the number of controls. Hence :math:`t_k` is the evolution time at the start of the timeslot, and :math:`u_{jk}` is the amplitude of control :math:`j` throughout timeslot :math:`k`. The time evolution operator, or propagator, within the timeslot can then be calculated as:. .. math::. X_k:=e^{-iH(t_k)\Delta t_k}. where :math:`\Delta t_k` is the duration of the timeslot. The evolution up to (and including) any timeslot :math:`k` (including the full evolution ",MatchSource.DOCS,doc/guide/guide-control.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-control.rst
Modifiability,evolve,evolve,"s. :math:`U(t)` is a solution to the *Schrödinger operator equation*. .. math::. \tfrac{d}{dt}U = -i H(t)U ,\quad U(0) = \mathbb{1}. We can use optimal control algorithms to determine a set of :math:`u_j` that will drive our system from :math:`\ket{\psi_0}` to :math:`\ket{\psi_1}`, this is state-to-state transfer, or drive the system from some arbitary state to a given state :math:`\ket{\psi_1}`, which is state preparation, or effect some unitary transformation :math:`U_{target}`, called gate synthesis. The latter of these is most important in quantum computation. The GRAPE algorithm; ===================; The **GR**\ adient **A**\ scent **P**\ ulse **E**\ ngineering was first proposed in [NKanej]_. Solutions to Schrödinger's equation for a time-dependent Hamiltonian are not generally possible to obtain analytically. Therefore, a piecewise constant approximation to the pulse amplitudes is made. Time allowed for the system to evolve :math:`T` is split into :math:`M` timeslots (typically these are of equal duration), during which the control amplitude is assumed to remain constant. The combined Hamiltonian can then be approximated as:. .. math::. H(t) \approx H(t_k) = H_0 + \sum_{j=1}^N u_{jk} H_j\quad. where :math:`k` is a timeslot index, :math:`j` is the control index, and :math:`N` is the number of controls. Hence :math:`t_k` is the evolution time at the start of the timeslot, and :math:`u_{jk}` is the amplitude of control :math:`j` throughout timeslot :math:`k`. The time evolution operator, or propagator, within the timeslot can then be calculated as:. .. math::. X_k:=e^{-iH(t_k)\Delta t_k}. where :math:`\Delta t_k` is the duration of the timeslot. The evolution up to (and including) any timeslot :math:`k` (including the full evolution :math:`k=M`) can the be calculated as. .. math::. X(t_k):=X_k X_{k-1}\cdots X_1 X_0. If the objective is state-to-state transfer then :math:`X_0=\ket{\psi_0}` and the target :math:`X_{targ}=\ket{\psi_1}`, for gate synthesis :math:`X_0",MatchSource.DOCS,doc/guide/guide-control.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-control.rst
Performance,perform,performing,"re Hessian, which reduces the computer memory required, and; allows bounds to be set for variable values, which considering these are field; amplitudes is often physical. The pulse optimisation is typically far more efficient if the gradients can be; calculated exactly, rather than approximated. For simple fidelity measures such; as :math:`f_{PSU}` this is possible. Firstly the propagator gradient for each; timeslot with respect to the control amplitudes is calculated. For closed; systems, with unitary dynamics, a method using the eigendecomposition is used,; which is efficient as it is also used in the propagator calculation (to; exponentiate the combined Hamiltonian). More generally (for example open; systems and symplectic dynamics) the Frechet derivative (or augmented matrix); method is used, which is described in [Flo12]_. For other optimisation goals it; may not be possible to calculate analytic gradients. In these cases it is; necessary to approximate the gradients, but this can be very expensive, and can; lead to other algorithms out-performing GRAPE. The CRAB Algorithm; ===================; It has been shown [Lloyd14]_, the dimension of a quantum optimal control; problem is a polynomial function of the dimension of the manifold of the; time-polynomial reachable states, when allowing for a finite control precision; and evolution time. You can think of this as the information content of the; pulse (as being the only effective input) being very limited e.g. the pulse is; compressible to a few bytes without loosing the target. This is where the **C**\ hopped **RA**\ ndom **B**\ asis (CRAB) algorithm; [Doria11]_, [Caneva11]_ comes into play: Since the pulse complexity is usually; very low, it is sufficient to transform the optimal control problem to a few; parameter search by introducing a physically motivated function basis that; builds up the pulse. Compared to the number of time slices needed to accurately; simulate quantum dynamics (often equals basis dimens",MatchSource.DOCS,doc/guide/guide-control.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-control.rst
Usability,simpl,simplest,"e of merit* or *fidelity* is some measure of how close the evolution is to the target, based on the control amplitudes in the timeslots. The typical figure of merit for unitary systems is the normalised overlap of the evolution and the target. .. math::. f_{PSU} = \tfrac{1}{d} \big| \tr \{X_{targ}^{\dagger} X(T)\} \big|. where :math:`d` is the system dimension. In this figure of merit the absolute value is taken to ignore any differences in global phase, and :math:`0 \le f \le 1`. Typically the fidelity error (or *infidelity*) is more useful, in this case defined as :math:`\varepsilon = 1 - f_{PSU}`. There are many other possible objectives, and hence figures of merit. As there are now :math:`N \times M` variables (the :math:`u_{jk}`) and one; parameter to minimise :math:`\varepsilon`, then the problem becomes a finite; multi-variable optimisation problem, for which there are many established; methods, often referred to as 'hill-climbing' methods. The simplest of these to; understand is that of steepest ascent (or descent). The gradient of the; fidelity with respect to all the variables is calculated (or approximated) and; a step is made in the variable space in the direction of steepest ascent (or; descent). This method is a first order gradient method. In two dimensions this; describes a method of climbing a hill by heading in the direction where the; ground rises fastest. This analogy also clearly illustrates one of the main; challenges in multi-variable optimisation, which is that all methods have a; tendency to get stuck in local maxima. It is hard to determine whether one has; found a global maximum or not - a local peak is likely not to be the highest; mountain in the region. In quantum optimal control we can typically define an; infidelity that has a lower bound of zero. We can then look to minimise the; infidelity (from here on we will only consider optimising for infidelity; minima). This means that we can terminate any pulse optimisation when the; infidel",MatchSource.DOCS,doc/guide/guide-control.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-control.rst
Availability,avail,available,"t> = {\rm Tr}\left[A V(t+\tau, t)\left\{B\rho(t)\right\}\right]; = {\rm Tr}\left[A V(t+\tau, t)\left\{BV(t, 0)\left\{\rho(0)\right\}\right\}\right]. We therefore first calculate :math:`\rho(t)=V(t, 0)\left\{\rho(0)\right\}` using one of the QuTiP evolution solvers with :math:`\rho(0)` as initial state, and then again use the same solver to calculate :math:`V(t+\tau, t)\left\{B\rho(t)\right\}` using :math:`B\rho(t)` as initial state. Note that if the initial state is the steady state, then :math:`\rho(t)=V(t, 0)\left\{\rho_{\rm ss}\right\}=\rho_{\rm ss}` and. .. math::. \left<A(t+\tau)B(t)\right> = {\rm Tr}\left[A V(t+\tau, t)\left\{B\rho_{\rm ss}\right\}\right]; = {\rm Tr}\left[A V(\tau, 0)\left\{B\rho_{\rm ss}\right\}\right] = \left<A(\tau)B(0)\right>,. which is independent of :math:`t`, so that we only have one time coordinate :math:`\tau`. QuTiP provides a family of functions that assists in the process of calculating two-time correlation functions. The available functions and their usage is shown in the table below. Each of these functions can use one of the following evolution solvers: Master-equation, Exponential series and the Monte-Carlo. The choice of solver is defined by the optional argument ``solver``. .. cssclass:: table-striped. +----------------------------------+--------------------------------------------------+; | QuTiP function | Correlation function |; +==================================+==================================================+; | | :math:`\left<A(t+\tau)B(t)\right>` or |; | :func:`qutip.correlation_2op_2t` | :math:`\left<A(t)B(t+\tau)\right>`. |; +----------------------------------+--------------------------------------------------+; | | :math:`\left<A(\tau)B(0)\right>` or |; | :func:`qutip.correlation_2op_1t` | :math:`\left<A(0)B(\tau)\right>`. |; +----------------------------------+--------------------------------------------------+; | :func:`qutip.correlation_3op_1t` | :math:`\left<A(0)B(\tau)C(0)\right>`. |; +----------------------",MatchSource.DOCS,doc/guide/guide-correlation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-correlation.rst
Energy Efficiency,power,power,"two times. Most importantly, this function accepts alternative solvers such as :func:`.brmesolve`. .. _correlation-steady:. Steadystate correlation function; ================================. The following code demonstrates how to calculate the :math:`\left<x(t)x(0)\right>` correlation for a leaky cavity with three different relaxation rates. .. plot::; :context: close-figs. times = np.linspace(0,10.0,200); a = destroy(10); x = a.dag() + a; H = a.dag() * a. corr1 = correlation_2op_1t(H, None, times, [np.sqrt(0.5) * a], x, x); corr2 = correlation_2op_1t(H, None, times, [np.sqrt(1.0) * a], x, x); corr3 = correlation_2op_1t(H, None, times, [np.sqrt(2.0) * a], x, x). plt.figure(); plt.plot(times, np.real(corr1)); plt.plot(times, np.real(corr2)); plt.plot(times, np.real(corr3)); plt.legend(['0.5','1.0','2.0']); plt.xlabel(r'Time $t$'); plt.ylabel(r'Correlation $\left<x(t)x(0)\right>$'); plt.show(). Emission spectrum; =================. Given a correlation function :math:`\left<A(\tau)B(0)\right>` we can define the corresponding power spectrum as. .. math::. S(\omega) = \int_{-\infty}^{\infty} \left<A(\tau)B(0)\right> e^{-i\omega\tau} d\tau. In QuTiP, we can calculate :math:`S(\omega)` using either :func:`.spectrum`, which first calculates the correlation function using one of the time-dependent solvers and then performs the Fourier transform semi-analytically, or we can use the function :func:`.spectrum_correlation_fft` to numerically calculate the Fourier transform of a given correlation data using FFT. The following example demonstrates how these two functions can be used to obtain the emission power spectrum. .. plot:: guide/scripts/spectrum_ex1.py; :width: 5.0in; :include-source:. .. _correlation-spectrum:. Non-steadystate correlation function; ====================================. More generally, we can also calculate correlation functions of the kind :math:`\left<A(t_1+t_2)B(t_1)\right>`, i.e., the correlation function of a system that is not in its steady state. In",MatchSource.DOCS,doc/guide/guide-correlation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-correlation.rst
Integrability,depend,dependent," different relaxation rates. .. plot::; :context: close-figs. times = np.linspace(0,10.0,200); a = destroy(10); x = a.dag() + a; H = a.dag() * a. corr1 = correlation_2op_1t(H, None, times, [np.sqrt(0.5) * a], x, x); corr2 = correlation_2op_1t(H, None, times, [np.sqrt(1.0) * a], x, x); corr3 = correlation_2op_1t(H, None, times, [np.sqrt(2.0) * a], x, x). plt.figure(); plt.plot(times, np.real(corr1)); plt.plot(times, np.real(corr2)); plt.plot(times, np.real(corr3)); plt.legend(['0.5','1.0','2.0']); plt.xlabel(r'Time $t$'); plt.ylabel(r'Correlation $\left<x(t)x(0)\right>$'); plt.show(). Emission spectrum; =================. Given a correlation function :math:`\left<A(\tau)B(0)\right>` we can define the corresponding power spectrum as. .. math::. S(\omega) = \int_{-\infty}^{\infty} \left<A(\tau)B(0)\right> e^{-i\omega\tau} d\tau. In QuTiP, we can calculate :math:`S(\omega)` using either :func:`.spectrum`, which first calculates the correlation function using one of the time-dependent solvers and then performs the Fourier transform semi-analytically, or we can use the function :func:`.spectrum_correlation_fft` to numerically calculate the Fourier transform of a given correlation data using FFT. The following example demonstrates how these two functions can be used to obtain the emission power spectrum. .. plot:: guide/scripts/spectrum_ex1.py; :width: 5.0in; :include-source:. .. _correlation-spectrum:. Non-steadystate correlation function; ====================================. More generally, we can also calculate correlation functions of the kind :math:`\left<A(t_1+t_2)B(t_1)\right>`, i.e., the correlation function of a system that is not in its steady state. In QuTiP, we can evaluate such correlation functions using the function :func:`.correlation_2op_2t`. The default behavior of this function is to return a matrix with the correlations as a function of the two time coordinates (:math:`t_1` and :math:`t_2`). .. plot:: guide/scripts/correlation_ex2.py; :width: 5.0in; :in",MatchSource.DOCS,doc/guide/guide-correlation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-correlation.rst
Modifiability,evolve,evolved,".. _correlation:. ******************************; Two-time correlation functions; ******************************. With the QuTiP time-evolution functions (for example :func:`.mesolve` and :func:`.mcsolve`), a state vector or density matrix can be evolved from an initial state at :math:`t_0` to an arbitrary time :math:`t`, :math:`\rho(t)=V(t, t_0)\left\{\rho(t_0)\right\}`, where :math:`V(t, t_0)` is the propagator defined by the equation of motion. The resulting density matrix can then be used to evaluate the expectation values of arbitrary combinations of *same-time* operators. To calculate *two-time* correlation functions on the form :math:`\left<A(t+\tau)B(t)\right>`, we can use the quantum regression theorem (see, e.g., [Gar03]_) to write. .. math::. \left<A(t+\tau)B(t)\right> = {\rm Tr}\left[A V(t+\tau, t)\left\{B\rho(t)\right\}\right]; = {\rm Tr}\left[A V(t+\tau, t)\left\{BV(t, 0)\left\{\rho(0)\right\}\right\}\right]. We therefore first calculate :math:`\rho(t)=V(t, 0)\left\{\rho(0)\right\}` using one of the QuTiP evolution solvers with :math:`\rho(0)` as initial state, and then again use the same solver to calculate :math:`V(t+\tau, t)\left\{B\rho(t)\right\}` using :math:`B\rho(t)` as initial state. Note that if the initial state is the steady state, then :math:`\rho(t)=V(t, 0)\left\{\rho_{\rm ss}\right\}=\rho_{\rm ss}` and. .. math::. \left<A(t+\tau)B(t)\right> = {\rm Tr}\left[A V(t+\tau, t)\left\{B\rho_{\rm ss}\right\}\right]; = {\rm Tr}\left[A V(\tau, 0)\left\{B\rho_{\rm ss}\right\}\right] = \left<A(\tau)B(0)\right>,. which is independent of :math:`t`, so that we only have one time coordinate :math:`\tau`. QuTiP provides a family of functions that assists in the process of calculating two-time correlation functions. The available functions and their usage is shown in the table below. Each of these functions can use one of the following evolution solvers: Master-equation, Exponential series and the Monte-Carlo. The choice of solver is defined by the optional ",MatchSource.DOCS,doc/guide/guide-correlation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-correlation.rst
Performance,perform,performs,"h:`\left<A(t)B(t+\tau)\right>`. |; +----------------------------------+--------------------------------------------------+; | | :math:`\left<A(\tau)B(0)\right>` or |; | :func:`qutip.correlation_2op_1t` | :math:`\left<A(0)B(\tau)\right>`. |; +----------------------------------+--------------------------------------------------+; | :func:`qutip.correlation_3op_1t` | :math:`\left<A(0)B(\tau)C(0)\right>`. |; +----------------------------------+--------------------------------------------------+; | :func:`qutip.correlation_3op_2t` | :math:`\left<A(t)B(t+\tau)C(t)\right>`. |; +----------------------------------+--------------------------------------------------+; | :func:`qutip.correlation_3op` | :math:`\left<A(t)B(t+\tau)C(t)\right>`. |; +----------------------------------+--------------------------------------------------+. The most common use-case is to calculate the two time correlation function :math:`\left<A(\tau)B(0)\right>`. :func:`.correlation_2op_1t` performs this task with sensible default values, but only allows using the :func:`.mesolve` solver. From QuTiP 5.0 we added :func:`.correlation_3op`. This function can also calculate correlation functions with two or three operators and with one or two times. Most importantly, this function accepts alternative solvers such as :func:`.brmesolve`. .. _correlation-steady:. Steadystate correlation function; ================================. The following code demonstrates how to calculate the :math:`\left<x(t)x(0)\right>` correlation for a leaky cavity with three different relaxation rates. .. plot::; :context: close-figs. times = np.linspace(0,10.0,200); a = destroy(10); x = a.dag() + a; H = a.dag() * a. corr1 = correlation_2op_1t(H, None, times, [np.sqrt(0.5) * a], x, x); corr2 = correlation_2op_1t(H, None, times, [np.sqrt(1.0) * a], x, x); corr3 = correlation_2op_1t(H, None, times, [np.sqrt(2.0) * a], x, x). plt.figure(); plt.plot(times, np.real(corr1)); plt.plot(times, np.real(corr2)); plt.plot(times, np.real(corr3))",MatchSource.DOCS,doc/guide/guide-correlation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-correlation.rst
Usability,guid,guide,"2.0) * a], x, x). plt.figure(); plt.plot(times, np.real(corr1)); plt.plot(times, np.real(corr2)); plt.plot(times, np.real(corr3)); plt.legend(['0.5','1.0','2.0']); plt.xlabel(r'Time $t$'); plt.ylabel(r'Correlation $\left<x(t)x(0)\right>$'); plt.show(). Emission spectrum; =================. Given a correlation function :math:`\left<A(\tau)B(0)\right>` we can define the corresponding power spectrum as. .. math::. S(\omega) = \int_{-\infty}^{\infty} \left<A(\tau)B(0)\right> e^{-i\omega\tau} d\tau. In QuTiP, we can calculate :math:`S(\omega)` using either :func:`.spectrum`, which first calculates the correlation function using one of the time-dependent solvers and then performs the Fourier transform semi-analytically, or we can use the function :func:`.spectrum_correlation_fft` to numerically calculate the Fourier transform of a given correlation data using FFT. The following example demonstrates how these two functions can be used to obtain the emission power spectrum. .. plot:: guide/scripts/spectrum_ex1.py; :width: 5.0in; :include-source:. .. _correlation-spectrum:. Non-steadystate correlation function; ====================================. More generally, we can also calculate correlation functions of the kind :math:`\left<A(t_1+t_2)B(t_1)\right>`, i.e., the correlation function of a system that is not in its steady state. In QuTiP, we can evaluate such correlation functions using the function :func:`.correlation_2op_2t`. The default behavior of this function is to return a matrix with the correlations as a function of the two time coordinates (:math:`t_1` and :math:`t_2`). .. plot:: guide/scripts/correlation_ex2.py; :width: 5.0in; :include-source:. However, in some cases we might be interested in the correlation functions on the form :math:`\left<A(t_1+t_2)B(t_1)\right>`, but only as a function of time coordinate :math:`t_2`. In this case we can also use the :func:`.correlation_2op_2t` function, if we pass the density matrix at time :math:`t_1` as second argument, a",MatchSource.DOCS,doc/guide/guide-correlation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-correlation.rst
Availability,down,down,"******************************; Measurement of Quantum Objects; ******************************. .. note::; New in QuTiP 4.6. .. _measurement-intro:. Introduction; ------------. Measurement is a fundamental part of the standard formulation of quantum; mechanics and is the process by which classical readings are obtained from; a quantum object. Although the interpretation of the procedure is at times; contentious, the procedure itself is mathematically straightforward and is; described in many good introductory texts. Here we will show you how to perform simple measurement operations on QuTiP; objects. The same functions :func:`~qutip.measurement.measure` and; :func:`~qutip.measurement.measurement_statistics` can be used; to handle both observable-style measurements and projective style measurements. .. _measurement-basic:. Performing a basic measurement (Observable); -------------------------------------------. First we need to select some states to measure. For now, let us create an *up*; state and a *down* state:. .. testcode::. up = basis(2, 0). down = basis(2, 1). which represent spin-1/2 particles with their spin pointing either up or down; along the z-axis. We choose what to measure (in this case) by selecting a **measurement operator**.; For example,; we could select :func:`.sigmaz` which measures the z-component of the; spin of a spin-1/2 particle, or :func:`.sigmax` which measures the; x-component:. .. testcode::. spin_z = sigmaz(). spin_x = sigmax(). How do we know what these operators measure? The answer lies in the measurement; procedure itself:. * A quantum measurement transforms the state being measured by projecting it into; one of the eigenvectors of the measurement operator. * Which eigenvector to project onto is chosen probabilistically according to the; square of the amplitude of the state in the direction of the eigenvector. * The value returned by the measurement is the eigenvalue corresponding to the; chosen eigenvector. .. note::. How to interpr",MatchSource.DOCS,doc/guide/guide-measurement.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst
Performance,perform,perform,".. _measurement:. ******************************; Measurement of Quantum Objects; ******************************. .. note::; New in QuTiP 4.6. .. _measurement-intro:. Introduction; ------------. Measurement is a fundamental part of the standard formulation of quantum; mechanics and is the process by which classical readings are obtained from; a quantum object. Although the interpretation of the procedure is at times; contentious, the procedure itself is mathematically straightforward and is; described in many good introductory texts. Here we will show you how to perform simple measurement operations on QuTiP; objects. The same functions :func:`~qutip.measurement.measure` and; :func:`~qutip.measurement.measurement_statistics` can be used; to handle both observable-style measurements and projective style measurements. .. _measurement-basic:. Performing a basic measurement (Observable); -------------------------------------------. First we need to select some states to measure. For now, let us create an *up*; state and a *down* state:. .. testcode::. up = basis(2, 0). down = basis(2, 1). which represent spin-1/2 particles with their spin pointing either up or down; along the z-axis. We choose what to measure (in this case) by selecting a **measurement operator**.; For example,; we could select :func:`.sigmaz` which measures the z-component of the; spin of a spin-1/2 particle, or :func:`.sigmax` which measures the; x-component:. .. testcode::. spin_z = sigmaz(). spin_x = sigmax(). How do we know what these operators measure? The answer lies in the measurement; procedure itself:. * A quantum measurement transforms the state being measured by projecting it into; one of the eigenvectors of the measurement operator. * Which eigenvector to project onto is chosen probabilistically according to the; square of the amplitude of the state in the direction of the eigenvector. * The value returned by the measurement is the eigenvalue corresponding to the; chosen eigenvector. .. note",MatchSource.DOCS,doc/guide/guide-measurement.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst
Testability,test,testcode,"ment of Quantum Objects; ******************************. .. note::; New in QuTiP 4.6. .. _measurement-intro:. Introduction; ------------. Measurement is a fundamental part of the standard formulation of quantum; mechanics and is the process by which classical readings are obtained from; a quantum object. Although the interpretation of the procedure is at times; contentious, the procedure itself is mathematically straightforward and is; described in many good introductory texts. Here we will show you how to perform simple measurement operations on QuTiP; objects. The same functions :func:`~qutip.measurement.measure` and; :func:`~qutip.measurement.measurement_statistics` can be used; to handle both observable-style measurements and projective style measurements. .. _measurement-basic:. Performing a basic measurement (Observable); -------------------------------------------. First we need to select some states to measure. For now, let us create an *up*; state and a *down* state:. .. testcode::. up = basis(2, 0). down = basis(2, 1). which represent spin-1/2 particles with their spin pointing either up or down; along the z-axis. We choose what to measure (in this case) by selecting a **measurement operator**.; For example,; we could select :func:`.sigmaz` which measures the z-component of the; spin of a spin-1/2 particle, or :func:`.sigmax` which measures the; x-component:. .. testcode::. spin_z = sigmaz(). spin_x = sigmax(). How do we know what these operators measure? The answer lies in the measurement; procedure itself:. * A quantum measurement transforms the state being measured by projecting it into; one of the eigenvectors of the measurement operator. * Which eigenvector to project onto is chosen probabilistically according to the; square of the amplitude of the state in the direction of the eigenvector. * The value returned by the measurement is the eigenvalue corresponding to the; chosen eigenvector. .. note::. How to interpret this ""random choosing"" is the famou",MatchSource.DOCS,doc/guide/guide-measurement.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst
Usability,simpl,simple,".. _measurement:. ******************************; Measurement of Quantum Objects; ******************************. .. note::; New in QuTiP 4.6. .. _measurement-intro:. Introduction; ------------. Measurement is a fundamental part of the standard formulation of quantum; mechanics and is the process by which classical readings are obtained from; a quantum object. Although the interpretation of the procedure is at times; contentious, the procedure itself is mathematically straightforward and is; described in many good introductory texts. Here we will show you how to perform simple measurement operations on QuTiP; objects. The same functions :func:`~qutip.measurement.measure` and; :func:`~qutip.measurement.measurement_statistics` can be used; to handle both observable-style measurements and projective style measurements. .. _measurement-basic:. Performing a basic measurement (Observable); -------------------------------------------. First we need to select some states to measure. For now, let us create an *up*; state and a *down* state:. .. testcode::. up = basis(2, 0). down = basis(2, 1). which represent spin-1/2 particles with their spin pointing either up or down; along the z-axis. We choose what to measure (in this case) by selecting a **measurement operator**.; For example,; we could select :func:`.sigmaz` which measures the z-component of the; spin of a spin-1/2 particle, or :func:`.sigmax` which measures the; x-component:. .. testcode::. spin_z = sigmaz(). spin_x = sigmax(). How do we know what these operators measure? The answer lies in the measurement; procedure itself:. * A quantum measurement transforms the state being measured by projecting it into; one of the eigenvectors of the measurement operator. * Which eigenvector to project onto is chosen probabilistically according to the; square of the amplitude of the state in the direction of the eigenvector. * The value returned by the measurement is the eigenvalue corresponding to the; chosen eigenvector. .. note",MatchSource.DOCS,doc/guide/guide-measurement.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-measurement.rst
Availability,avail,available,".. _overview:. ******************; Guide Overview; ******************. The goal of this guide is to introduce you to the basic structures and functions that make up QuTiP. This guide is divided up into several ; sections, each highlighting a specific set of functionalities. In combination with the examples that can be found on the project ; web page `https://qutip.org/tutorials.html <https://qutip.org/tutorials.html>`_, this guide should provide a more or less complete overview ; of QuTip. We also provide the API documentation in :ref:`apidoc`. .. _overview-org:. Organization; =============. QuTiP is designed to be a general framework for solving quantum mechanics problems such as systems composed of few-level quantum systems and harmonic oscillators. To this end, QuTiP is built from a large (and ever growing) library of functions and classes; from :func:`qutip.states.basis` to :func:`qutip.wigner`. The general organization of QuTiP, highlighting the important API available to the user, is shown in the figure below. .. _figure-qutip-org:. .. figure:: figures/qutip_tree.png; :align: center; :figwidth: 100%. Tree-diagram of the 468 user accessible functions and classes in QuTiP 4.6. A vector image of the code tree is in :download:`qutip_tree.pdf <doc/qutip_tree.pdf>`. ",MatchSource.DOCS,doc/guide/guide-overview.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-overview.rst
Security,access,accessible,".. _overview:. ******************; Guide Overview; ******************. The goal of this guide is to introduce you to the basic structures and functions that make up QuTiP. This guide is divided up into several ; sections, each highlighting a specific set of functionalities. In combination with the examples that can be found on the project ; web page `https://qutip.org/tutorials.html <https://qutip.org/tutorials.html>`_, this guide should provide a more or less complete overview ; of QuTip. We also provide the API documentation in :ref:`apidoc`. .. _overview-org:. Organization; =============. QuTiP is designed to be a general framework for solving quantum mechanics problems such as systems composed of few-level quantum systems and harmonic oscillators. To this end, QuTiP is built from a large (and ever growing) library of functions and classes; from :func:`qutip.states.basis` to :func:`qutip.wigner`. The general organization of QuTiP, highlighting the important API available to the user, is shown in the figure below. .. _figure-qutip-org:. .. figure:: figures/qutip_tree.png; :align: center; :figwidth: 100%. Tree-diagram of the 468 user accessible functions and classes in QuTiP 4.6. A vector image of the code tree is in :download:`qutip_tree.pdf <doc/qutip_tree.pdf>`. ",MatchSource.DOCS,doc/guide/guide-overview.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-overview.rst
Usability,guid,guide,".. _overview:. ******************; Guide Overview; ******************. The goal of this guide is to introduce you to the basic structures and functions that make up QuTiP. This guide is divided up into several ; sections, each highlighting a specific set of functionalities. In combination with the examples that can be found on the project ; web page `https://qutip.org/tutorials.html <https://qutip.org/tutorials.html>`_, this guide should provide a more or less complete overview ; of QuTip. We also provide the API documentation in :ref:`apidoc`. .. _overview-org:. Organization; =============. QuTiP is designed to be a general framework for solving quantum mechanics problems such as systems composed of few-level quantum systems and harmonic oscillators. To this end, QuTiP is built from a large (and ever growing) library of functions and classes; from :func:`qutip.states.basis` to :func:`qutip.wigner`. The general organization of QuTiP, highlighting the important API available to the user, is shown in the figure below. .. _figure-qutip-org:. .. figure:: figures/qutip_tree.png; :align: center; :figwidth: 100%. Tree-diagram of the 468 user accessible functions and classes in QuTiP 4.6. A vector image of the code tree is in :download:`qutip_tree.pdf <doc/qutip_tree.pdf>`. ",MatchSource.DOCS,doc/guide/guide-overview.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-overview.rst
Usability,simpl,simply,"um_{n=1}^{N}\left(; \frac{\gamma_\text{E}}{2}\mathcal{L}_{J_{-,n}}[\rho]; +\frac{\gamma_\text{D}}{2}\mathcal{L}_{J_{z,n}}[\rho]; +\frac{\gamma_\text{P}}{2}\mathcal{L}_{J_{+,n}}[\rho]\right). where :math:`J_{\alpha,n}=\frac{1}{2}\sigma_{\alpha,n}` are SU(2) Pauli spin operators, with :math:`{\alpha=x,y,z}` and :math:`J_{\pm,n}=\sigma_{\pm,n}`. The collective spin operators are :math:`J_{\alpha} = \sum_{n}J_{\alpha,n}` . The Lindblad super-operators are :math:`\mathcal{L}_{A} = 2A\rho A^\dagger - A^\dagger A \rho - \rho A^\dagger A`. The inclusion of local processes in the dynamics lead to using a Liouvillian space of dimension :math:`4^N`. By exploiting the permutational invariance of identical particles [2-8], the Liouvillian :math:`\mathcal{D}_\text{TLS}(\rho)` can be built as a block-diagonal matrix in the basis of Dicke states :math:`|j, m \rangle`. The system under study is defined by creating an object of the; :class:`~qutip.piqs.piqs.Dicke` class, e.g. simply named; :code:`system`, whose first attribute is. - :code:`system.N`, the number of TLSs of the system :math:`N`. The rates for collective and local processes are simply defined as. - :code:`collective_emission` defines :math:`\gamma_\text{CE}`, collective (superradiant) emission; - :code:`collective_dephasing` defines :math:`\gamma_\text{CD}`, collective dephasing; - :code:`collective_pumping` defines :math:`\gamma_\text{CP}`, collective pumping.; - :code:`emission` defines :math:`\gamma_\text{E}`, incoherent emission (losses); - :code:`dephasing` defines :math:`\gamma_\text{D}`, local dephasing; - :code:`pumping` defines :math:`\gamma_\text{P}`, incoherent pumping. Then the :code:`system.lindbladian()` creates the total TLS Lindbladian superoperator matrix. Similarly, :code:`system.hamiltonian` defines the TLS hamiltonian of the system :math:`H_\text{TLS}`. The system's Liouvillian can be built using :code:`system.liouvillian()`.; The properties of a Piqs object can be visualized by simply calling :code:",MatchSource.DOCS,doc/guide/guide-piqs.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-piqs.rst
Integrability,depend,depending,"[random]. >>> rand_super_bcsz(7).dims; [[[7], [7]], [[7], [7]]]; >>> rand_super_bcsz([[2, 3], [2, 3]]).dims; [[[2, 3], [2, 3]], [[2, 3], [2, 3]]]. Several of the random :class:`.Qobj` function in QuTiP support additional parameters as well, namely *density* and *distribution*.; :func:`.rand_dm`, :func:`.rand_herm`, :func:`.rand_unitary` and :func:`.rand_ket` can be created using multiple method controlled by *distribution*.; The :func:`.rand_ket`, :func:`.rand_herm` and :func:`.rand_unitary` functions can return quantum objects such that a fraction of the elements are identically equal to zero.; The ratio of nonzero elements is passed as the ``density`` keyword argument.; By contrast, `rand_super_bcsz` take as an argument the rank of the generated object, such that passing ``rank=1`` returns a random pure state or unitary channel, respectively.; Passing ``rank=None`` specifies that the generated object should be full-rank for the given dimension.; `rand_dm` can support *density* or *rank* depending on the chosen distribution. For example,. .. doctest:: [random]; :hide:. >>> np.random.seed(42). .. doctest:: [random]. >>> rand_dm(5, density=0.5, distribution=""herm""); Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[ 0.298+0.j , 0. +0.j , -0.095+0.1j , 0. +0.j ,-0.105+0.122j],; [ 0. +0.j , 0.088+0.j , 0. +0.j , -0.018-0.001j, 0. +0.j ],; [-0.095-0.1j , 0. +0.j , 0.328+0.j , 0. +0.j ,-0.077-0.033j],; [ 0. +0.j , -0.018+0.001j, 0. +0.j , 0.084+0.j , 0. +0.j ],; [-0.105-0.122j, 0. +0.j , -0.077+0.033j, 0. +0.j , 0.201+0.j ]]. >>> rand_dm_ginibre(5, rank=2); Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[ 0.307+0.j , -0.258+0.039j, -0.039+0.184j, 0.041-0.054j, 0.016+0.045j],; [-0.258-0.039j, 0.239+0.j , 0.075-0.15j , -0.053+0.008j,-0.057-0.078j],; [-0.039-0.184j, 0.075+0.15j , 0.136+0.j , -0.05 -0.052j,-0.028-0.058j],; [ 0.041+0.054j, -0.053-0.008j, -0.05 +0.052j, 0.083+0.j , 0.101-0",MatchSource.DOCS,doc/guide/guide-random.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-random.rst
Testability,test,testsetup,".. _random:. ********************************************; Generating Random Quantum States & Operators; ********************************************. .. testsetup:: [random]. from qutip import rand_herm, rand_dm, rand_super_bcsz, rand_dm_ginibre. QuTiP includes a collection of random state, unitary and channel generators for simulations, Monte Carlo evaluation, theorem evaluation, and code testing.; Each of these objects can be sampled from one of several different distributions. For example, a random Hermitian operator can be sampled by calling :func:`.rand_herm` function:. .. doctest:: [random]; :hide:. >>> np.random.seed(42). .. doctest:: [random]. >>> rand_herm(5) # doctest: +NORMALIZE_WHITESPACE; Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[-0.25091976+0.j 0. +0.j 0. +0.j; -0.21793701+0.47037633j -0.23212846-0.61607187j]; [ 0. +0.j -0.88383278+0.j 0.836086 -0.23956218j; -0.09464275+0.45370863j -0.15243356+0.65392096j]; [ 0. +0.j 0.836086 +0.23956218j 0.66488528+0.j; -0.26290446+0.64984451j -0.52603038-0.07991553j]; [-0.21793701-0.47037633j -0.09464275-0.45370863j -0.26290446-0.64984451j; -0.13610996+0.j -0.34240902-0.2879303j ]; [-0.23212846+0.61607187j -0.15243356-0.65392096j -0.52603038+0.07991553j; -0.34240902+0.2879303j 0. +0.j ]]. .. tabularcolumns:: | p{2cm} | p{3cm} | c |. .. cssclass:: table-striped. +-------------------------------+-----------------------------------------------+------------------------------------------+; | Random Variable Type | Sampling Functions | Dimensions |; +===============================+===============================================+==========================================+; | State vector (``ket``) | :func:`.rand_ket` | :math:`N \times 1` |; +-------------------------------+-----------------------------------------------+------------------------------------------+; | Hermitian operator (``oper``) | :func:`.rand_herm` | :math:`N \times N` |; +-------------------------------",MatchSource.DOCS,doc/guide/guide-random.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-random.rst
Performance,perform,performed,".. _saving:. **********************************; Saving QuTiP Objects and Data Sets; **********************************. With time-consuming calculations it is often necessary to store the results to files on disk, so it can be post-processed and archived. In QuTiP there are two facilities for storing data: Quantum objects can be stored to files and later read back as python pickles, and numerical data (vectors and matrices) can be exported as plain text files in for example CSV (comma-separated values), TSV (tab-separated values), etc. The former method is preferred when further calculations will be performed with the data, and the latter when the calculations are completed and data is to be imported into a post-processing tool (e.g. for generating figures). Storing and loading QuTiP objects; =================================. To store and load arbitrary QuTiP related objects (:class:`.Qobj`, :class:`.Result`, etc.) there are two functions: :func:`qutip.fileio.qsave` and :func:`qutip.fileio.qload`. The function :func:`qutip.fileio.qsave` takes an arbitrary object as first parameter and an optional filename as second parameter (default filename is `qutip_data.qu`). The filename extension is always `.qu`. The function :func:`qutip.fileio.qload` takes a mandatory filename as first argument and loads and returns the objects in the file. To illustrate how these functions can be used, consider a simple calculation of the steadystate of the harmonic oscillator ::. >>> a = destroy(10); H = a.dag() * a; >>> c_ops = [np.sqrt(0.5) * a, np.sqrt(0.25) * a.dag()]; >>> rho_ss = steadystate(H, c_ops). The steadystate density matrix `rho_ss` is an instance of :class:`.Qobj`. It can be stored to a file `steadystate.qu` using ::. >>> qsave(rho_ss, 'steadystate'); >>> !ls *.qu; density_matrix_vs_time.qu steadystate.qu. and it can later be loaded again, and used in further calculations ::. >>> rho_ss_loaded = qload('steadystate'); Loaded Qobj object:; Quantum object: dims = [[10], [10]]",MatchSource.DOCS,doc/guide/guide-saving.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-saving.rst
Testability,test,testing,"as first parameter and an optional filename as second parameter (default filename is `qutip_data.qu`). The filename extension is always `.qu`. The function :func:`qutip.fileio.qload` takes a mandatory filename as first argument and loads and returns the objects in the file. To illustrate how these functions can be used, consider a simple calculation of the steadystate of the harmonic oscillator ::. >>> a = destroy(10); H = a.dag() * a; >>> c_ops = [np.sqrt(0.5) * a, np.sqrt(0.25) * a.dag()]; >>> rho_ss = steadystate(H, c_ops). The steadystate density matrix `rho_ss` is an instance of :class:`.Qobj`. It can be stored to a file `steadystate.qu` using ::. >>> qsave(rho_ss, 'steadystate'); >>> !ls *.qu; density_matrix_vs_time.qu steadystate.qu. and it can later be loaded again, and used in further calculations ::. >>> rho_ss_loaded = qload('steadystate'); Loaded Qobj object:; Quantum object: dims = [[10], [10]], shape = (10, 10), type = oper, isHerm = True; >>> a = destroy(10); >>> np.testing.assert_almost_equal(expect(a.dag() * a, rho_ss_loaded), 0.9902248289345061). The nice thing about the :func:`qutip.fileio.qsave` and :func:`qutip.fileio.qload` functions is that almost any object can be stored and load again later on.; We can for example store a list of density matrices as returned by :func:`.mesolve` ::. >>> a = destroy(10); H = a.dag() * a ; c_ops = [np.sqrt(0.5) * a, np.sqrt(0.25) * a.dag()]; >>> psi0 = rand_ket(10); >>> times = np.linspace(0, 10, 10); >>> dm_list = mesolve(H, psi0, times, c_ops, []); >>> qsave(dm_list, 'density_matrix_vs_time'). And it can then be loaded and used again, for example in an other program ::. >>> dm_list_loaded = qload('density_matrix_vs_time'); Loaded Result object:; Result object with mesolve data.; --------------------------------; states = True; num_collapse = 0; >>> a = destroy(10); >>> expect(a.dag() * a, dm_list_loaded.states) # doctest: +SKIP; array([4.63317086, 3.59150315, 2.90590183, 2.41306641, 2.05120716,; 1.78312503, 1",MatchSource.DOCS,doc/guide/guide-saving.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-saving.rst
Usability,simpl,simple," matrices) can be exported as plain text files in for example CSV (comma-separated values), TSV (tab-separated values), etc. The former method is preferred when further calculations will be performed with the data, and the latter when the calculations are completed and data is to be imported into a post-processing tool (e.g. for generating figures). Storing and loading QuTiP objects; =================================. To store and load arbitrary QuTiP related objects (:class:`.Qobj`, :class:`.Result`, etc.) there are two functions: :func:`qutip.fileio.qsave` and :func:`qutip.fileio.qload`. The function :func:`qutip.fileio.qsave` takes an arbitrary object as first parameter and an optional filename as second parameter (default filename is `qutip_data.qu`). The filename extension is always `.qu`. The function :func:`qutip.fileio.qload` takes a mandatory filename as first argument and loads and returns the objects in the file. To illustrate how these functions can be used, consider a simple calculation of the steadystate of the harmonic oscillator ::. >>> a = destroy(10); H = a.dag() * a; >>> c_ops = [np.sqrt(0.5) * a, np.sqrt(0.25) * a.dag()]; >>> rho_ss = steadystate(H, c_ops). The steadystate density matrix `rho_ss` is an instance of :class:`.Qobj`. It can be stored to a file `steadystate.qu` using ::. >>> qsave(rho_ss, 'steadystate'); >>> !ls *.qu; density_matrix_vs_time.qu steadystate.qu. and it can later be loaded again, and used in further calculations ::. >>> rho_ss_loaded = qload('steadystate'); Loaded Qobj object:; Quantum object: dims = [[10], [10]], shape = (10, 10), type = oper, isHerm = True; >>> a = destroy(10); >>> np.testing.assert_almost_equal(expect(a.dag() * a, rho_ss_loaded), 0.9902248289345061). The nice thing about the :func:`qutip.fileio.qsave` and :func:`qutip.fileio.qload` functions is that almost any object can be stored and load again later on.; We can for example store a list of density matrices as returned by :func:`.mesolve` ::. >>> a = de",MatchSource.DOCS,doc/guide/guide-saving.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-saving.rst
Availability,toler,tolerance,"*********************; Modifying Internal QuTiP Settings; *********************************. .. _settings-params:. User Accessible Parameters; ==========================. In this section we show how to modify a few of the internal parameters used by QuTiP.; The settings that can be modified are given in the following table:. .. tabularcolumns:: | p{3cm} | p{5cm} | p{5cm} |. .. cssclass:: table-striped. +------------------------------+----------------------------------------------+------------------------------+; | Setting | Description | Options |; +==============================+==============================================+==============================+; | `auto_tidyup` | Automatically tidyup sparse quantum objects. | True / False |; +------------------------------+----------------------------------------------+------------------------------+; | `auto_tidyup_atol` | Tolerance used by tidyup. (sparse only) | float {1e-14} |; +------------------------------+----------------------------------------------+------------------------------+; | `atol` | General absolute tolerance. | float {1e-12} |; +------------------------------+----------------------------------------------+------------------------------+; | `rtol` | General relative tolerance. | float {1e-12} |; +------------------------------+----------------------------------------------+------------------------------+; | `function_coefficient_style` | Signature expected by function coefficients. | {""auto"", ""pythonic"", ""dict""} |; +------------------------------+----------------------------------------------+------------------------------+. .. _settings-usage:. Example: Changing Settings; ==========================. The two most important settings are ``auto_tidyup`` and ``auto_tidyup_atol`` as they control whether the small elements of a quantum object should be removed, and what number should be considered as the cut-off tolerance.; Modifying these, or any other parameters, is quite simple::. >>> qutip.settings.co",MatchSource.DOCS,doc/guide/guide-settings.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-settings.rst
Testability,assert,assert,"In this section we show how to modify a few of the internal parameters used by QuTiP.; The settings that can be modified are given in the following table:. .. tabularcolumns:: | p{3cm} | p{5cm} | p{5cm} |. .. cssclass:: table-striped. +------------------------------+----------------------------------------------+------------------------------+; | Setting | Description | Options |; +==============================+==============================================+==============================+; | `auto_tidyup` | Automatically tidyup sparse quantum objects. | True / False |; +------------------------------+----------------------------------------------+------------------------------+; | `auto_tidyup_atol` | Tolerance used by tidyup. (sparse only) | float {1e-14} |; +------------------------------+----------------------------------------------+------------------------------+; | `atol` | General absolute tolerance. | float {1e-12} |; +------------------------------+----------------------------------------------+------------------------------+; | `rtol` | General relative tolerance. | float {1e-12} |; +------------------------------+----------------------------------------------+------------------------------+; | `function_coefficient_style` | Signature expected by function coefficients. | {""auto"", ""pythonic"", ""dict""} |; +------------------------------+----------------------------------------------+------------------------------+. .. _settings-usage:. Example: Changing Settings; ==========================. The two most important settings are ``auto_tidyup`` and ``auto_tidyup_atol`` as they control whether the small elements of a quantum object should be removed, and what number should be considered as the cut-off tolerance.; Modifying these, or any other parameters, is quite simple::. >>> qutip.settings.core[""auto_tidyup""] = False. The settings can also be changed for a code block::. >>> with qutip.CoreOptions(atol=1e-5):; >>> assert qutip.qeye(2) * 1e-9 == qutip.qzero(2); ",MatchSource.DOCS,doc/guide/guide-settings.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-settings.rst
Usability,simpl,simple,"In this section we show how to modify a few of the internal parameters used by QuTiP.; The settings that can be modified are given in the following table:. .. tabularcolumns:: | p{3cm} | p{5cm} | p{5cm} |. .. cssclass:: table-striped. +------------------------------+----------------------------------------------+------------------------------+; | Setting | Description | Options |; +==============================+==============================================+==============================+; | `auto_tidyup` | Automatically tidyup sparse quantum objects. | True / False |; +------------------------------+----------------------------------------------+------------------------------+; | `auto_tidyup_atol` | Tolerance used by tidyup. (sparse only) | float {1e-14} |; +------------------------------+----------------------------------------------+------------------------------+; | `atol` | General absolute tolerance. | float {1e-12} |; +------------------------------+----------------------------------------------+------------------------------+; | `rtol` | General relative tolerance. | float {1e-12} |; +------------------------------+----------------------------------------------+------------------------------+; | `function_coefficient_style` | Signature expected by function coefficients. | {""auto"", ""pythonic"", ""dict""} |; +------------------------------+----------------------------------------------+------------------------------+. .. _settings-usage:. Example: Changing Settings; ==========================. The two most important settings are ``auto_tidyup`` and ``auto_tidyup_atol`` as they control whether the small elements of a quantum object should be removed, and what number should be considered as the cut-off tolerance.; Modifying these, or any other parameters, is quite simple::. >>> qutip.settings.core[""auto_tidyup""] = False. The settings can also be changed for a code block::. >>> with qutip.CoreOptions(atol=1e-5):; >>> assert qutip.qeye(2) * 1e-9 == qutip.qzero(2); ",MatchSource.DOCS,doc/guide/guide-settings.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-settings.rst
Availability,down,downarrow,"*:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[ 1. 0.]; [ 0. -1.]]. .. testcode:: [states]. print(sigmaz() * spin). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[1.]; [0.]]. .. testcode:: [states]. spin2 = basis(2, 1). print(spin2). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[0.]; [1.]]. .. testcode:: [states]. print(sigmaz() * spin2). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[ 0.]; [-1.]]. The answer is now apparent. Since the QuTiP :func:`.sigmaz` function uses the standard z-basis representation of the sigma-z spin operator, the ``spin`` state corresponds to the :math:`\left|\uparrow\right>` state of a two-level spin system while ``spin2`` gives the :math:`\left|\downarrow\right>` state. Therefore, in our previous example ``sigmap() * spin``, we raised the qubit state out of the truncated two-level Hilbert space resulting in the zero state. While at first glance this convention might seem somewhat odd, it is in fact quite handy. For one, the spin operators remain in the conventional form. Second, when the spin system is in the :math:`\left|\uparrow\right>` state:. .. testcode:: [states]. print(sigmaz() * spin). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[1.]; [0.]]. the non-zero component is the zeroth-element of the underlying matrix (remember that python uses c-indexing, and matrices start with the zeroth element). The :math:`\left|\downarrow\right>` state therefore has a non-zero entry in the first index position. This corresponds nicely",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
Energy Efficiency,energy,energy,":`T = \sqrt{1 - F^{2}}`, while the quantum Hellinger distance (QHE) between two pure states :math:`\left|\psi\right>` and :math:`\left|\phi\right>` is given by :math:`QHE = \sqrt{2 - 2\left|\left<\psi | \phi\right>\right|^2}`. .. testcode:: [states]. np.testing.assert_almost_equal(tracedist(y, x), np.sqrt(1 - fidelity(y, x) ** 2)). For a pure state and a mixed state, :math:`1 - F^{2} \le T` which can also be verified:. .. testcode:: [states]. assert 1 - fidelity(x, z) ** 2 < tracedist(x, z). .. _states-qubit:. Qubit (two-level) systems; =========================. Having spent a fair amount of time on basis states that represent harmonic oscillator states, we now move on to qubit, or two-level quantum systems (for example a spin-1/2). To create a state vector corresponding to a qubit system, we use the same :func:`.basis`, or :func:`.fock`, function with only two levels:. .. testcode:: [states]. spin = basis(2, 0). Now at this point one may ask how this state is different than that of a harmonic oscillator in the vacuum state truncated to two energy levels?. .. testcode:: [states]. vac = basis(2, 0). At this stage, there is no difference. This should not be surprising as we called the exact same function twice. The difference between the two comes from the action of the spin operators :func:`.sigmax`, :func:`.sigmay`, :func:`.sigmaz`, :func:`.sigmap`, and :func:`.sigmam` on these two-level states. For example, if ``vac`` corresponds to the vacuum state of a harmonic oscillator, then, as we have already seen, we can use the raising operator to get the :math:`\left|1\right>` state:. .. testcode:: [states]. print(vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[1.]; [0.]]. .. testcode:: [states]. c = create(2). print(c * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj ",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
Integrability,depend,dependence," function to make a raising operator:. .. testcode:: [states]. c = create(5). print(c * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [1.]; [0.]; [0.]; [0.]]. which does the same thing. We can raise the vacuum state more than once by successively apply the raising operator:. .. testcode:: [states]. print(c * c * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0. ]; [0. ]; [1.41421356]; [0. ]; [0. ]]. or just taking the square of the raising operator :math:`\left(\hat{a}^\dagger\right)^{2}`:. .. testcode:: [states]. print(c ** 2 * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0. ]; [0. ]; [1.41421356]; [0. ]; [0. ]]. Applying the raising operator twice gives the expected :math:`\sqrt{n + 1}` dependence. We can use the product of :math:`c * a` to also apply the number operator to the state vector ``vac``:. .. testcode:: [states]. print(c * a * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [0.]; [0.]; [0.]; [0.]]. or on the :math:`\left| 1\right>` state:. .. testcode:: [states]. print(c * a * (c * vac)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [1.]; [0.]; [0.]; [0.]]. or the :math:`\left| 2\right>` state:. .. testcode:: [states]. print(c * a * (c**2 * vac)). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0. ]; [0. ]; [2.82842712]; [0. ]; [0. ]]. Notice how in this last example, application of the number operator doe",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
Modifiability,extend,extended,"st(X.dag()) # Represents conjugation by X. Note that this is done automatically by the :obj:`.to_super` function when given; ``type='oper'`` input. .. testcode:: [states]. S2 = to_super(X). np.testing.assert_almost_equal((S - S2).norm(), 0). Quantum objects representing superoperators are denoted by ``type='super'``:. .. testcode:: [states]. print(S). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True; Qobj data =; [[0. 0. 0. 1.]; [0. 0. 1. 0.]; [0. 1. 0. 0.]; [1. 0. 0. 0.]]. Information about superoperators, such as whether they represent completely; positive maps, is exposed through the :attr:`.Qobj.iscp`, :attr:`.Qobj.istp`; and :attr:`.Qobj.iscptp` attributes:. .. testcode:: [states]. print(S.iscp, S.istp, S.iscptp). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. True True True. In addition, dynamical generators on this extended space, often called; *Liouvillian superoperators*, can be created using the :func:`.liouvillian` function. Each of these takes a Hamiltonian along with; a list of collapse operators, and returns a ``type=""super""`` object that can; be exponentiated to find the superoperator for that evolution. .. testcode:: [states]. H = 10 * sigmaz(). c1 = destroy(2). L = liouvillian(H, [c1]). print(L). S = (12 * L).expm(). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = False; Qobj data =; [[ 0. +0.j 0. +0.j 0. +0.j 1. +0.j]; [ 0. +0.j -0.5+20.j 0. +0.j 0. +0.j]; [ 0. +0.j 0. +0.j -0.5-20.j 0. +0.j]; [ 0. +0.j 0. +0.j 0. +0.j -1. +0.j]]. For qubits, a particularly useful way to visualize superoperators is to plot them in the Pauli basis,; such that :math:`S_{\mu,\nu} = \langle\!\langle \sigma_{\mu} | S[\sigma_{\nu}] \rangle\!\rangle`. Because; the Pauli basis is Hermitian, :math:`S_{\mu,\nu}` is a real numb",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
Performance,perform,performing,".. _states:. *************************************; Manipulating States and Operators; *************************************. .. _states-intro:. Introduction; =================. In the previous guide section :ref:`basics`, we saw how to create states and operators, using the functions built into QuTiP. In this portion of the guide, we will look at performing basic operations with states and operators. For more detailed demonstrations on how to use and manipulate these objects, see the examples on the `tutorials <https://qutip.org/tutorials.html>`_ web page. .. _states-vectors:. State Vectors (kets or bras); ==============================. Here we begin by creating a Fock :func:`.basis` vacuum state vector :math:`\left|0\right>` with in a Hilbert space with 5 number states, from 0 to 4:. .. testcode:: [states]. vac = basis(5, 0). print(vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]; [0.]]. and then create a lowering operator :math:`\left(\hat{a}\right)` corresponding to 5 number states using the :func:`.destroy` function:. .. testcode:: [states]. a = destroy(5). print(a). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = False; Qobj data =; [[0. 1. 0. 0. 0. ]; [0. 0. 1.41421356 0. 0. ]; [0. 0. 0. 1.73205081 0. ]; [0. 0. 0. 0. 2. ]; [0. 0. 0. 0. 0. ]]. Now lets apply the destruction operator to our vacuum state ``vac``,. .. testcode:: [states]. print(a * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [0.]; [0.]; [0.]; [0.]]. We see that, as expected, the vacuum is transformed to the zero vector. A more interesting example comes from using the adjoint of the lowering operator, the raising operator :math:`\hat{a}^\dagger`:. .. testcode::",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
Security,expose,exposed,"H}` is a vector space, linear maps; on this space can be represented as matrices, often called *superoperators*.; Using the :obj:`.Qobj`, the :obj:`.spre` and :obj:`.spost` functions, supermatrices; corresponding to left- and right-multiplication respectively can be quickly; constructed. .. testcode:: [states]. X = sigmax(). S = spre(X) * spost(X.dag()) # Represents conjugation by X. Note that this is done automatically by the :obj:`.to_super` function when given; ``type='oper'`` input. .. testcode:: [states]. S2 = to_super(X). np.testing.assert_almost_equal((S - S2).norm(), 0). Quantum objects representing superoperators are denoted by ``type='super'``:. .. testcode:: [states]. print(S). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True; Qobj data =; [[0. 0. 0. 1.]; [0. 0. 1. 0.]; [0. 1. 0. 0.]; [1. 0. 0. 0.]]. Information about superoperators, such as whether they represent completely; positive maps, is exposed through the :attr:`.Qobj.iscp`, :attr:`.Qobj.istp`; and :attr:`.Qobj.iscptp` attributes:. .. testcode:: [states]. print(S.iscp, S.istp, S.iscptp). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. True True True. In addition, dynamical generators on this extended space, often called; *Liouvillian superoperators*, can be created using the :func:`.liouvillian` function. Each of these takes a Hamiltonian along with; a list of collapse operators, and returns a ``type=""super""`` object that can; be exponentiated to find the superoperator for that evolution. .. testcode:: [states]. H = 10 * sigmaz(). c1 = destroy(2). L = liouvillian(H, [c1]). print(L). S = (12 * L).expm(). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = False; Qobj data =; [[ 0. +0.j 0. +0.j 0. +0.j 1. +0.j]; [ 0. +0.j -0.5+20.j 0. +0.j 0. +0.j]; [ 0. +",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
Testability,test,testcode,".. _states:. *************************************; Manipulating States and Operators; *************************************. .. _states-intro:. Introduction; =================. In the previous guide section :ref:`basics`, we saw how to create states and operators, using the functions built into QuTiP. In this portion of the guide, we will look at performing basic operations with states and operators. For more detailed demonstrations on how to use and manipulate these objects, see the examples on the `tutorials <https://qutip.org/tutorials.html>`_ web page. .. _states-vectors:. State Vectors (kets or bras); ==============================. Here we begin by creating a Fock :func:`.basis` vacuum state vector :math:`\left|0\right>` with in a Hilbert space with 5 number states, from 0 to 4:. .. testcode:: [states]. vac = basis(5, 0). print(vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]; [0.]]. and then create a lowering operator :math:`\left(\hat{a}\right)` corresponding to 5 number states using the :func:`.destroy` function:. .. testcode:: [states]. a = destroy(5). print(a). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = False; Qobj data =; [[0. 1. 0. 0. 0. ]; [0. 0. 1.41421356 0. 0. ]; [0. 0. 0. 1.73205081 0. ]; [0. 0. 0. 0. 2. ]; [0. 0. 0. 0. 0. ]]. Now lets apply the destruction operator to our vacuum state ``vac``,. .. testcode:: [states]. print(a * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [0.]; [0.]; [0.]; [0.]]. We see that, as expected, the vacuum is transformed to the zero vector. A more interesting example comes from using the adjoint of the lowering operator, the raising operator :math:`\hat{a}^\dagger`:. .. testcode::",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
Usability,guid,guide,".. _states:. *************************************; Manipulating States and Operators; *************************************. .. _states-intro:. Introduction; =================. In the previous guide section :ref:`basics`, we saw how to create states and operators, using the functions built into QuTiP. In this portion of the guide, we will look at performing basic operations with states and operators. For more detailed demonstrations on how to use and manipulate these objects, see the examples on the `tutorials <https://qutip.org/tutorials.html>`_ web page. .. _states-vectors:. State Vectors (kets or bras); ==============================. Here we begin by creating a Fock :func:`.basis` vacuum state vector :math:`\left|0\right>` with in a Hilbert space with 5 number states, from 0 to 4:. .. testcode:: [states]. vac = basis(5, 0). print(vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]; [0.]]. and then create a lowering operator :math:`\left(\hat{a}\right)` corresponding to 5 number states using the :func:`.destroy` function:. .. testcode:: [states]. a = destroy(5). print(a). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = False; Qobj data =; [[0. 1. 0. 0. 0. ]; [0. 0. 1.41421356 0. 0. ]; [0. 0. 0. 1.73205081 0. ]; [0. 0. 0. 0. 2. ]; [0. 0. 0. 0. 0. ]]. Now lets apply the destruction operator to our vacuum state ``vac``,. .. testcode:: [states]. print(a * vac). **Output**:. .. testoutput:: [states]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [0.]; [0.]; [0.]; [0.]]. We see that, as expected, the vacuum is transformed to the zero vector. A more interesting example comes from using the adjoint of the lowering operator, the raising operator :math:`\hat{a}^\dagger`:. .. testcode::",MatchSource.DOCS,doc/guide/guide-states.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-states.rst
Availability,avail,available,"ate`. This function implements a number of different methods for finding the steady state, each with their own pros and cons, where the method used can be chosen using the ``method`` keyword argument. .. cssclass:: table-striped. .. list-table::; :widths: 10 15 30; :header-rows: 1. * - Method; - Keyword; - Description; * - Direct (default); - 'direct'; - Direct solution solving :math:`Ax=b`.; * - Eigenvalue; - 'eigen'; - Iteratively find the zero eigenvalue of :math:`\mathcal{L}`.; * - Inverse-Power; - 'power'; - Solve using the inverse-power method.; * - SVD; - 'svd'; - Steady-state solution via the **dense** SVD of the Liouvillian. The function :func:`.steadystate` can take either a Hamiltonian and a list; of collapse operators as input, generating internally the corresponding; Liouvillian super operator in Lindblad form, or alternatively, a Liouvillian; passed by the user. Both the ``""direct""`` and ``""power""`` method need to solve a linear equation; system. To do so, there are multiple solvers available: ``. .. cssclass:: table-striped. .. list-table::; :widths: 10 15 20; :header-rows: 1. * - Solver; - Original function; - Description; * - ""solve""; - ``numpy.linalg.solve``; - Dense solver from numpy.; * - ""lstsq""; - ``numpy.linalg.lstsq``; - Dense least-squares solver.; * - ""spsolve""; - ``scipy.sparse.linalg.spsolve``; - Sparse solver from scipy.; * - ""gmres""; - ``scipy.sparse.linalg.gmres``; - Generalized Minimal RESidual iterative solver.; * - ""lgmres""; - ``scipy.sparse.linalg.lgmres``; - LGMRES iterative solver.; * - ""bicgstab""; - ``scipy.sparse.linalg.bicgstab``; - BIConjugate Gradient STABilized iterative solver.; * - ""mkl_spsolve""; - ``pardiso``; - Intel Pardiso LU solver from MKL. QuTiP can take advantage of the Intel Pardiso LU solver in the Intel Math; Kernel library that comes with the Anacoda (2.5+) and Intel Python; distributions. This gives a substantial increase in performance compared with; the standard SuperLU method used by SciPy. To verify that ",MatchSource.DOCS,doc/guide/guide-steady.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-steady.rst
Energy Efficiency,power,power,"be achieved using direct or iterative solution methods faster than using master equation or Monte Carlo simulations. Although the steady state equation has a simple mathematical form, the properties of the Liouvillian operator are such that the solutions to this equation are anything but straightforward to find. Steady State solvers in QuTiP; =============================. In QuTiP, the steady-state solution for a system Hamiltonian or Liouvillian is given by :func:`.steadystate`. This function implements a number of different methods for finding the steady state, each with their own pros and cons, where the method used can be chosen using the ``method`` keyword argument. .. cssclass:: table-striped. .. list-table::; :widths: 10 15 30; :header-rows: 1. * - Method; - Keyword; - Description; * - Direct (default); - 'direct'; - Direct solution solving :math:`Ax=b`.; * - Eigenvalue; - 'eigen'; - Iteratively find the zero eigenvalue of :math:`\mathcal{L}`.; * - Inverse-Power; - 'power'; - Solve using the inverse-power method.; * - SVD; - 'svd'; - Steady-state solution via the **dense** SVD of the Liouvillian. The function :func:`.steadystate` can take either a Hamiltonian and a list; of collapse operators as input, generating internally the corresponding; Liouvillian super operator in Lindblad form, or alternatively, a Liouvillian; passed by the user. Both the ``""direct""`` and ``""power""`` method need to solve a linear equation; system. To do so, there are multiple solvers available: ``. .. cssclass:: table-striped. .. list-table::; :widths: 10 15 20; :header-rows: 1. * - Solver; - Original function; - Description; * - ""solve""; - ``numpy.linalg.solve``; - Dense solver from numpy.; * - ""lstsq""; - ``numpy.linalg.lstsq``; - Dense least-squares solver.; * - ""spsolve""; - ``scipy.sparse.linalg.spsolve``; - Sparse solver from scipy.; * - ""gmres""; - ``scipy.sparse.linalg.gmres``; - Generalized Minimal RESidual iterative solver.; * - ""lgmres""; - ``scipy.sparse.linalg.lgmres``; - LG",MatchSource.DOCS,doc/guide/guide-steady.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-steady.rst
Integrability,rout,routine,", is the steady-state solution for the systems.; If no other keywords are passed to the solver, the default 'direct' method is; used with ``numpy.linalg.solve``, generating a solution that is exact to; machine precision at the expense of a large memory requirement. However; Liouvillians are often quite sparse and using a sparse solver may be preferred:. .. code-block:: python. rho_ss = steadystate(H, c_ops, method=""power"", solver=""spsolve""). where ``method='power'`` indicates that we are using the inverse-power solution; method, and ``solver=""spsolve""`` indicate to use the sparse solver. Sparse solvers may still use quite a large amount of memory when they factorize the; matrix since the Liouvillian usually has a large bandwidth.; To address this, :func:`.steadystate` allows one to use the bandwidth minimization algorithms; listed in :ref:`steady-args`. For example:. .. code-block:: python. rho_ss = steadystate(H, c_ops, solver=""spsolve"", use_rcm=True). where ``use_rcm=True`` turns on a bandwidth minimization routine. Although it is not obvious, the ``'direct'``, ``'eigen'``, and ``'power'``; methods all use an LU decomposition internally and thus can have a large; memory overhead. In contrast, iterative solvers such as the ``'gmres'``,; ``'lgmres'``, and ``'bicgstab'`` do not factor the matrix and thus take less; memory than the LU methods and allow, in principle, for extremely; large system sizes. The downside is that these methods can take much longer; than the direct method as the condition number of the Liouvillian matrix is; large, indicating that these iterative methods require a large number of; iterations for convergence. To overcome this, one can use a preconditioner; :math:`M` that solves for an approximate inverse for the (modified); Liouvillian, thus better conditioning the problem, leading to faster; convergence. The use of a preconditioner can actually make these iterative; methods faster than the other solution methods. The problem with precondioning",MatchSource.DOCS,doc/guide/guide-steady.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-steady.rst
Performance,perform,performance,"hod need to solve a linear equation; system. To do so, there are multiple solvers available: ``. .. cssclass:: table-striped. .. list-table::; :widths: 10 15 20; :header-rows: 1. * - Solver; - Original function; - Description; * - ""solve""; - ``numpy.linalg.solve``; - Dense solver from numpy.; * - ""lstsq""; - ``numpy.linalg.lstsq``; - Dense least-squares solver.; * - ""spsolve""; - ``scipy.sparse.linalg.spsolve``; - Sparse solver from scipy.; * - ""gmres""; - ``scipy.sparse.linalg.gmres``; - Generalized Minimal RESidual iterative solver.; * - ""lgmres""; - ``scipy.sparse.linalg.lgmres``; - LGMRES iterative solver.; * - ""bicgstab""; - ``scipy.sparse.linalg.bicgstab``; - BIConjugate Gradient STABilized iterative solver.; * - ""mkl_spsolve""; - ``pardiso``; - Intel Pardiso LU solver from MKL. QuTiP can take advantage of the Intel Pardiso LU solver in the Intel Math; Kernel library that comes with the Anacoda (2.5+) and Intel Python; distributions. This gives a substantial increase in performance compared with; the standard SuperLU method used by SciPy. To verify that QuTiP can find the; necessary libraries, one can check for ``INTEL MKL Ext: True`` in the QuTiP; about box (:func:`.about`). .. _steady-usage:. Using the Steadystate Solver; =============================. Solving for the steady state solution to the Lindblad master equation for a; general system with :func:`.steadystate` can be accomplished; using::. >>> rho_ss = steadystate(H, c_ops). where ``H`` is a quantum object representing the system Hamiltonian, and; ``c_ops`` is a list of quantum objects for the system collapse operators. The; output, labelled as ``rho_ss``, is the steady-state solution for the systems.; If no other keywords are passed to the solver, the default 'direct' method is; used with ``numpy.linalg.solve``, generating a solution that is exact to; machine precision at the expense of a large memory requirement. However; Liouvillians are often quite sparse and using a sparse solver may be preferred:. .. ",MatchSource.DOCS,doc/guide/guide-steady.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-steady.rst
Usability,simpl,simple,".. _steady:. *************************************; Solving for Steady-State Solutions; *************************************. .. _steady-intro:. Introduction; ============. For time-independent open quantum systems with decay rates larger than the corresponding excitation rates, the system will tend toward a steady state as :math:`t\rightarrow\infty` that satisfies the equation. .. math::; \frac{d\hat{\rho}_{ss}}{dt}=\mathcal{L}\hat{\rho}_{ss}=0. Although the requirement for time-independence seems quite resitrictive, one can often employ a transformation to the interaction picture that yields a time-independent Hamiltonian. For many these systems, solving for the asymptotic density matrix :math:`\hat{\rho}_{ss}` can be achieved using direct or iterative solution methods faster than using master equation or Monte Carlo simulations. Although the steady state equation has a simple mathematical form, the properties of the Liouvillian operator are such that the solutions to this equation are anything but straightforward to find. Steady State solvers in QuTiP; =============================. In QuTiP, the steady-state solution for a system Hamiltonian or Liouvillian is given by :func:`.steadystate`. This function implements a number of different methods for finding the steady state, each with their own pros and cons, where the method used can be chosen using the ``method`` keyword argument. .. cssclass:: table-striped. .. list-table::; :widths: 10 15 30; :header-rows: 1. * - Method; - Keyword; - Description; * - Direct (default); - 'direct'; - Direct solution solving :math:`Ax=b`.; * - Eigenvalue; - 'eigen'; - Iteratively find the zero eigenvalue of :math:`\mathcal{L}`.; * - Inverse-Power; - 'power'; - Solve using the inverse-power method.; * - SVD; - 'svd'; - Steady-state solution via the **dense** SVD of the Liouvillian. The function :func:`.steadystate` can take either a Hamiltonian and a list; of collapse operators as input, generating internally the corresponding; Li",MatchSource.DOCS,doc/guide/guide-steady.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-steady.rst
Energy Efficiency,reduce,reduced-channels,".gates import cnot, hadamard_transform. hinton(identity([2, 3]).unit()); hinton(Qobj([[1, 0.5], [0.5, 1]]).unit()). We show superoperators as matrices in the *Pauli basis*, such that any Hermicity-preserving map is represented by a real-valued matrix. This is especially convienent for use with Hinton diagrams, as the plot thus carries complete information about the channel. As an example, conjugation by :math:`\sigma_z` leaves :math:`\mathbb{1}` and :math:`\sigma_z` invariant, but flips the sign of :math:`\sigma_x` and :math:`\sigma_y`. This is indicated in Hinton diagrams by a negative-valued square for the sign change and a positive-valued square for a +1 sign. .. plot::; :context: close-figs. hinton(to_super(sigmaz())). As a couple more examples, we also consider the supermatrix for a Hadamard transform and for :math:`\sigma_z \otimes H`. .. plot::; :context: close-figs. hinton(to_super(hadamard_transform())); hinton(to_super(tensor(sigmaz(), hadamard_transform()))). .. _super-reduced-channels:. Reduced Channels; ================. As an example of tensor contraction, we now consider the map. .. math::. S(\rho)=\Tr_2 (\scriptstyle \rm CNOT (\rho \otimes \ket{0}\bra{0}) \scriptstyle \rm CNOT^\dagger). We can think of the :math:`\scriptstyle \rm CNOT` here as a system-environment representation of an open quantum process, in which an environment register is prepared in a state :math:`\rho_{\text{anc}}`, then a unitary acts jointly on the system of interest and environment. Finally, the environment is traced out, leaving a *channel* on the system alone. In terms of `Wood diagrams <http://arxiv.org/abs/1111.6950>`, this can be represented as the composition of a preparation map, evolution under the system-environment unitary, and then a measurement map. .. figure:: figures/sprep-wood-diagram.png; :align: center; :width: 2.5in. The two tensor wires on the left indicate where we must take a tensor contraction to obtain the measurement map.; Numbering the tensor wires fr",MatchSource.DOCS,doc/guide/guide-super.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-super.rst
Integrability,contract,contracts,".. _super:. *****************************************************; Superoperators, Pauli Basis and Channel Contraction; *****************************************************; written by `Christopher Granade <http://www.cgranade.com>`, Institute for Quantum Computing. In this guide, we will demonstrate the :func:`.tensor_contract` function, which contracts one or more pairs of indices of a Qobj. This functionality can be used to find rectangular superoperators that implement the partial trace channel :math:S(\rho) = \Tr_2(\rho)`, for instance. Using this functionality, we can quickly turn a system-environment representation of an open quantum process into a superoperator representation. .. _super-representation-plotting:. Superoperator Representations and Plotting; ==========================================. We start off by first demonstrating plotting of superoperators, as this will be useful to us in visualizing the results of a contracted channel. In particular, we will use Hinton diagrams as implemented by :func:`~qutip.visualization.hinton`, which; show the real parts of matrix elements as squares whose size and color both correspond to the magnitude of each element. To illustrate, we first plot a few density operators. .. plot::; :context: reset. from qutip import hinton, identity, Qobj, to_super, sigmaz, tensor, tensor_contract; from qutip.core.gates import cnot, hadamard_transform. hinton(identity([2, 3]).unit()); hinton(Qobj([[1, 0.5], [0.5, 1]]).unit()). We show superoperators as matrices in the *Pauli basis*, such that any Hermicity-preserving map is represented by a real-valued matrix. This is especially convienent for use with Hinton diagrams, as the plot thus carries complete information about the channel. As an example, conjugation by :math:`\sigma_z` leaves :math:`\mathbb{1}` and :math:`\sigma_z` invariant, but flips the sign of :math:`\sigma_x` and :math:`\sigma_y`. This is indicated in Hinton diagrams by a negative-valued square for the sign change a",MatchSource.DOCS,doc/guide/guide-super.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-super.rst
Usability,guid,guide,".. _super:. *****************************************************; Superoperators, Pauli Basis and Channel Contraction; *****************************************************; written by `Christopher Granade <http://www.cgranade.com>`, Institute for Quantum Computing. In this guide, we will demonstrate the :func:`.tensor_contract` function, which contracts one or more pairs of indices of a Qobj. This functionality can be used to find rectangular superoperators that implement the partial trace channel :math:S(\rho) = \Tr_2(\rho)`, for instance. Using this functionality, we can quickly turn a system-environment representation of an open quantum process into a superoperator representation. .. _super-representation-plotting:. Superoperator Representations and Plotting; ==========================================. We start off by first demonstrating plotting of superoperators, as this will be useful to us in visualizing the results of a contracted channel. In particular, we will use Hinton diagrams as implemented by :func:`~qutip.visualization.hinton`, which; show the real parts of matrix elements as squares whose size and color both correspond to the magnitude of each element. To illustrate, we first plot a few density operators. .. plot::; :context: reset. from qutip import hinton, identity, Qobj, to_super, sigmaz, tensor, tensor_contract; from qutip.core.gates import cnot, hadamard_transform. hinton(identity([2, 3]).unit()); hinton(Qobj([[1, 0.5], [0.5, 1]]).unit()). We show superoperators as matrices in the *Pauli basis*, such that any Hermicity-preserving map is represented by a real-valued matrix. This is especially convienent for use with Hinton diagrams, as the plot thus carries complete information about the channel. As an example, conjugation by :math:`\sigma_z` leaves :math:`\mathbb{1}` and :math:`\sigma_z` invariant, but flips the sign of :math:`\sigma_x` and :math:`\sigma_y`. This is indicated in Hinton diagrams by a negative-valued square for the sign change a",MatchSource.DOCS,doc/guide/guide-super.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-super.rst
Availability,down,down,", 2], [1, 1]], shape = (4, 1), type = ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]]. or equivalently using the ``list`` format:. .. testcode:: [tensor]. print(tensor([basis(2, 0), basis(2, 0)])). **Output**:. .. testoutput:: [tensor]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 2], [1, 1]], shape = (4, 1), type = ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]]. This is straightforward to generalize to more qubits by adding more component state vectors in the argument list to the :func:`~qutip.core.tensor.tensor` function, as illustrated in the following example:. .. testcode:: [tensor]. print(tensor((basis(2, 0) + basis(2, 1)).unit(), (basis(2, 0) + basis(2, 1)).unit(), basis(2, 0))). **Output**:. .. testoutput:: [tensor]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 2, 2], [1, 1, 1]], shape = (8, 1), type = ket; Qobj data =; [[0.5]; [0. ]; [0.5]; [0. ]; [0.5]; [0. ]; [0.5]; [0. ]]. This state is slightly more complicated, describing two qubits in a superposition between the up and down states, while the third qubit is in its ground state. To construct operators that act on an extended Hilbert space of a combined system, we similarly pass a list of operators for each component system to the :func:`~qutip.core.tensor.tensor` function. For example, to form the operator that represents the simultaneous action of the :math:`\sigma_x` operator on two qubits:. .. testcode:: [tensor]. print(tensor(sigmax(), sigmax())). **Output**:. .. testoutput:: [tensor]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True; Qobj data =; [[0. 0. 0. 1.]; [0. 0. 1. 0.]; [0. 1. 0. 0.]; [1. 0. 0. 0.]]. To create operators in a combined Hilbert space that only act on a single component, we take the tensor product of the operator acting on the subspace of interest, with the identity operators corresponding to the components that are to be unchanged. For example, the operator that represents :math:`\sigma_z",MatchSource.DOCS,doc/guide/guide-tensor.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-tensor.rst
Energy Efficiency,energy,energy,"s corresponding to the components that are to be unchanged. For example, the operator that represents :math:`\sigma_z` on the first qubit in a two-qubit system, while leaving the second qubit unaffected:. .. testcode:: [tensor]. print(tensor(sigmaz(), identity(2))). **Output**:. .. testoutput:: [tensor]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True; Qobj data =; [[ 1. 0. 0. 0.]; [ 0. 1. 0. 0.]; [ 0. 0. -1. 0.]; [ 0. 0. 0. -1.]]. .. _tensor-product-example:. Example: Constructing composite Hamiltonians; ============================================. The :func:`~qutip.core.tensor.tensor` function is extensively used when constructing Hamiltonians for composite systems. Here we'll look at some simple examples. .. _tensor-product-example-2qubits:. Two coupled qubits; ------------------. First, let's consider a system of two coupled qubits. Assume that both the qubits have equal energy splitting, and that the qubits are coupled through a :math:`\sigma_x\otimes\sigma_x` interaction with strength g = 0.05 (in units where the bare qubit energy splitting is unity). The Hamiltonian describing this system is:. .. testcode:: [tensor]. H = tensor(sigmaz(), identity(2)) + tensor(identity(2), sigmaz()) + 0.05 * tensor(sigmax(), sigmax()). print(H). **Output**:. .. testoutput:: [tensor]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True; Qobj data =; [[ 2. 0. 0. 0.05]; [ 0. 0. 0.05 0. ]; [ 0. 0.05 0. 0. ]; [ 0.05 0. 0. -2. ]]. .. _tensor-product-example-3qubits:. Three coupled qubits; --------------------. The two-qubit example is easily generalized to three coupled qubits:. .. testcode:: [tensor]. H = (tensor(sigmaz(), identity(2), identity(2)) + tensor(identity(2), sigmaz(), identity(2)) + tensor(identity(2), identity(2), sigmaz()) + 0.5 * tensor(sigmax(), sigmax(), identity(2)) + 0.25 * tensor(identity(2), sigmax(), sigmax())). print(H). **Out",MatchSource.DOCS,doc/guide/guide-tensor.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-tensor.rst
Integrability,contract,contracting,"er(A), to_super(B)).dims; [[[2], [2], [3], [3]], [[2], [2], [3], [3]]]. In the former case, the result correctly has four copies; of the compound index with dims ``[2, 3]``. In the latter; case, however, each of the Hilbert space indices is listed; independently and in the wrong order. The :func:`.super_tensor` function performs the needed; rearrangement, providing the most direct analog to :func:`.tensor` on; the underlying Hilbert space. In particular, for any two ``type=""oper""``; Qobjs ``A`` and ``B``, ``to_super(tensor(A, B)) == super_tensor(to_super(A), to_super(B))`` and; ``operator_to_vector(tensor(A, B)) == super_tensor(operator_to_vector(A), operator_to_vector(B))``. Returning to the previous example:. .. doctest:: [tensor]. >>> super_tensor(to_super(A), to_super(B)).dims; [[[2, 3], [2, 3]], [[2, 3], [2, 3]]]. The :func:`.composite` function automatically switches between; :func:`.tensor` and :func:`.super_tensor` based on the ``type``; of its arguments, such that ``composite(A, B)`` returns an appropriate Qobj to; represent the composition of two systems. .. doctest:: [tensor]. >>> composite(A, B).dims; [[2, 3], [2, 3]]. >>> composite(to_super(A), to_super(B)).dims; [[[2, 3], [2, 3]], [[2, 3], [2, 3]]]. QuTiP also allows more general tensor manipulations that are; useful for converting between superoperator representations [WBC11]_.; In particular, the :func:`~qutip.core.tensor.tensor_contract` function allows for; contracting one or more pairs of indices.; This can be used to find superoperators that represent partial trace maps.; Using this functionality, we can construct some quite exotic maps,; such as a map from :math:`3 \times 3` operators to :math:`2 \times 2`; operators:. .. doctest:: [tensor]. >>> tensor_contract(composite(to_super(A), to_super(B)), (1, 3), (4, 6)).dims; [[[2], [2]], [[3], [3]]]. ..; TODO: remake from notebook to tutorials; .. _channel contraction tutorial: github/qutip/qutip-notebooks/blob/master/examples/superop-contract.ipynb; ",MatchSource.DOCS,doc/guide/guide-tensor.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-tensor.rst
Modifiability,extend,extended,"basis(2, 0), basis(2, 0)])). **Output**:. .. testoutput:: [tensor]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 2], [1, 1]], shape = (4, 1), type = ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]]. This is straightforward to generalize to more qubits by adding more component state vectors in the argument list to the :func:`~qutip.core.tensor.tensor` function, as illustrated in the following example:. .. testcode:: [tensor]. print(tensor((basis(2, 0) + basis(2, 1)).unit(), (basis(2, 0) + basis(2, 1)).unit(), basis(2, 0))). **Output**:. .. testoutput:: [tensor]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 2, 2], [1, 1, 1]], shape = (8, 1), type = ket; Qobj data =; [[0.5]; [0. ]; [0.5]; [0. ]; [0.5]; [0. ]; [0.5]; [0. ]]. This state is slightly more complicated, describing two qubits in a superposition between the up and down states, while the third qubit is in its ground state. To construct operators that act on an extended Hilbert space of a combined system, we similarly pass a list of operators for each component system to the :func:`~qutip.core.tensor.tensor` function. For example, to form the operator that represents the simultaneous action of the :math:`\sigma_x` operator on two qubits:. .. testcode:: [tensor]. print(tensor(sigmax(), sigmax())). **Output**:. .. testoutput:: [tensor]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True; Qobj data =; [[0. 0. 0. 1.]; [0. 0. 1. 0.]; [0. 1. 0. 0.]; [1. 0. 0. 0.]]. To create operators in a combined Hilbert space that only act on a single component, we take the tensor product of the operator acting on the subspace of interest, with the identity operators corresponding to the components that are to be unchanged. For example, the operator that represents :math:`\sigma_z` on the first qubit in a two-qubit system, while leaving the second qubit unaffected:. .. testcode:: [tensor]. print(tensor(sigmaz(), identity(2))). **Output**:. ..",MatchSource.DOCS,doc/guide/guide-tensor.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-tensor.rst
Performance,perform,performs,"ed; using the isomorphism; :math:`\mathrm{vec} : \mathcal{L}(\mathcal{H}) \to \mathcal{H} \otimes \mathcal{H}` [Hav03]_, [Wat13]_.; To represent superoperators acting on :math:`\mathcal{L}(\mathcal{H}_1 \otimes \mathcal{H}_2)` thus takes some tensor rearrangement to get the desired ordering; :math:`\mathcal{H}_1 \otimes \mathcal{H}_2 \otimes \mathcal{H}_1 \otimes \mathcal{H}_2`. In particular, this means that :func:`.tensor` does not act as; one might expect on the results of :func:`.to_super`:. .. doctest:: [tensor]. >>> A = qeye([2]). >>> B = qeye([3]). >>> to_super(tensor(A, B)).dims; [[[2, 3], [2, 3]], [[2, 3], [2, 3]]]. >>> tensor(to_super(A), to_super(B)).dims; [[[2], [2], [3], [3]], [[2], [2], [3], [3]]]. In the former case, the result correctly has four copies; of the compound index with dims ``[2, 3]``. In the latter; case, however, each of the Hilbert space indices is listed; independently and in the wrong order. The :func:`.super_tensor` function performs the needed; rearrangement, providing the most direct analog to :func:`.tensor` on; the underlying Hilbert space. In particular, for any two ``type=""oper""``; Qobjs ``A`` and ``B``, ``to_super(tensor(A, B)) == super_tensor(to_super(A), to_super(B))`` and; ``operator_to_vector(tensor(A, B)) == super_tensor(operator_to_vector(A), operator_to_vector(B))``. Returning to the previous example:. .. doctest:: [tensor]. >>> super_tensor(to_super(A), to_super(B)).dims; [[[2, 3], [2, 3]], [[2, 3], [2, 3]]]. The :func:`.composite` function automatically switches between; :func:`.tensor` and :func:`.super_tensor` based on the ``type``; of its arguments, such that ``composite(A, B)`` returns an appropriate Qobj to; represent the composition of two systems. .. doctest:: [tensor]. >>> composite(A, B).dims; [[2, 3], [2, 3]]. >>> composite(to_super(A), to_super(B)).dims; [[[2, 3], [2, 3]], [[2, 3], [2, 3]]]. QuTiP also allows more general tensor manipulations that are; useful for converting between superoperator representati",MatchSource.DOCS,doc/guide/guide-tensor.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-tensor.rst
Testability,test,testcode,"ed to an oscillator, etc. - we need to expand the Hilbert space by taking the tensor product of the state vectors for each of the system components. Similarly, the operators acting on the state vectors in the combined Hilbert space (describing the coupled system) are formed by taking the tensor product of the individual operators. In QuTiP the function :func:`~qutip.core.tensor.tensor` is used to accomplish this task. This function takes as argument a collection::. >>> tensor(op1, op2, op3) # doctest: +SKIP. or a ``list``::. >>> tensor([op1, op2, op3]) # doctest: +SKIP. of state vectors *or* operators and returns a composite quantum object for the combined Hilbert space. The function accepts an arbitrary number of states or operators as argument. The type returned quantum object is the same as that of the input(s). For example, the state vector describing two qubits in their ground states is formed by taking the tensor product of the two single-qubit ground state vectors:. .. testcode:: [tensor]. print(tensor(basis(2, 0), basis(2, 0))). **Output**:. .. testoutput:: [tensor]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 2], [1, 1]], shape = (4, 1), type = ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]]. or equivalently using the ``list`` format:. .. testcode:: [tensor]. print(tensor([basis(2, 0), basis(2, 0)])). **Output**:. .. testoutput:: [tensor]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 2], [1, 1]], shape = (4, 1), type = ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]]. This is straightforward to generalize to more qubits by adding more component state vectors in the argument list to the :func:`~qutip.core.tensor.tensor` function, as illustrated in the following example:. .. testcode:: [tensor]. print(tensor((basis(2, 0) + basis(2, 1)).unit(), (basis(2, 0) + basis(2, 1)).unit(), basis(2, 0))). **Output**:. .. testoutput:: [tensor]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 2, 2], [1, 1, 1]], shape = (8, 1), type = ket; ",MatchSource.DOCS,doc/guide/guide-tensor.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-tensor.rst
Usability,simpl,simple,". 0. 1. 0.]; [0. 1. 0. 0.]; [1. 0. 0. 0.]]. To create operators in a combined Hilbert space that only act on a single component, we take the tensor product of the operator acting on the subspace of interest, with the identity operators corresponding to the components that are to be unchanged. For example, the operator that represents :math:`\sigma_z` on the first qubit in a two-qubit system, while leaving the second qubit unaffected:. .. testcode:: [tensor]. print(tensor(sigmaz(), identity(2))). **Output**:. .. testoutput:: [tensor]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True; Qobj data =; [[ 1. 0. 0. 0.]; [ 0. 1. 0. 0.]; [ 0. 0. -1. 0.]; [ 0. 0. 0. -1.]]. .. _tensor-product-example:. Example: Constructing composite Hamiltonians; ============================================. The :func:`~qutip.core.tensor.tensor` function is extensively used when constructing Hamiltonians for composite systems. Here we'll look at some simple examples. .. _tensor-product-example-2qubits:. Two coupled qubits; ------------------. First, let's consider a system of two coupled qubits. Assume that both the qubits have equal energy splitting, and that the qubits are coupled through a :math:`\sigma_x\otimes\sigma_x` interaction with strength g = 0.05 (in units where the bare qubit energy splitting is unity). The Hamiltonian describing this system is:. .. testcode:: [tensor]. H = tensor(sigmaz(), identity(2)) + tensor(identity(2), sigmaz()) + 0.05 * tensor(sigmax(), sigmax()). print(H). **Output**:. .. testoutput:: [tensor]; :options: +NORMALIZE_WHITESPACE. Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True; Qobj data =; [[ 2. 0. 0. 0.05]; [ 0. 0. 0.05 0. ]; [ 0. 0.05 0. 0. ]; [ 0.05 0. 0. -2. ]]. .. _tensor-product-example-3qubits:. Three coupled qubits; --------------------. The two-qubit example is easily generalized to three coupled qubits:. .. testcode:: [tensor]. H = (tensor(sigmaz(",MatchSource.DOCS,doc/guide/guide-tensor.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-tensor.rst
Availability,error,errors,"("""".join([lbls_list[k][inds[k]] for k in range(len(lbls_list))])). fig, ax = matrix_histogram(H, xlabels, xlabels, limits=[-4,4]). ax.view_init(azim=-55, elev=45). plt.show(). Similarly, we can use the function :func:`qutip.visualization.hinton`, which is; used below to visualize the corresponding steadystate density matrix:. .. plot::; :context: close-figs. rho_ss = steadystate(H, [np.sqrt(0.1) * a, np.sqrt(0.4) * b.dag()]). hinton(rho_ss). plt.show(). .. _visual-qpt:. Quantum process tomography; ==========================. Quantum process tomography (QPT) is a useful technique for characterizing experimental implementations of quantum gates involving a small number of qubits. It can also be a useful theoretical tool that can give insight in how a process transforms states, and it can be used for example to study how noise or other imperfections deteriorate a gate. Whereas a fidelity or distance measure can give a single number that indicates how far from ideal a gate is, a quantum process tomography analysis can give detailed information about exactly what kind of errors various imperfections introduce. The idea is to construct a transformation matrix for a quantum process (for example a quantum gate) that describes how the density matrix of a system is transformed by the process. We can then decompose the transformation in some operator basis that represent well-defined and easily interpreted transformations of the input states. To see how this works (see e.g. [Moh08]_ for more details), consider a process that is described by quantum map :math:`\epsilon(\rho_{\rm in}) = \rho_{\rm out}`, which can be written. .. math::; :label: qpt-quantum-map. \epsilon(\rho_{\rm in}) = \rho_{\rm out} = \sum_{i}^{N^2} A_i \rho_{\rm in} A_i^\dagger,. where :math:`N` is the number of states of the system (that is, :math:`\rho` is represented by an :math:`[N\times N]` matrix). Given an orthogonal operator basis of our choice :math:`\{B_i\}_i^{N^2}`, which satisfies :math:`{\rm Tr}[B",MatchSource.DOCS,doc/guide/guide-visualization.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-visualization.rst
Energy Efficiency,efficient,efficient,"---. The Husimi Q function is, like the Wigner function, a quasiprobability; distribution for harmonic modes. It is defined as. .. math::. Q(\alpha) = \frac{1}{\pi}\left<\alpha|\rho|\alpha\right>. where :math:`\left|\alpha\right>` is a coherent state and; :math:`\alpha = x + iy`. In QuTiP, the Husimi Q function can be computed given; a state ket or density matrix using the function :func:`.qfunc`, as; demonstrated below. .. plot::; :context: close-figs. Q_coherent = qfunc(rho_coherent, xvec, xvec); Q_thermal = qfunc(rho_thermal, xvec, xvec); Q_fock = qfunc(rho_fock, xvec, xvec); fig, axes = plt.subplots(1, 3, figsize=(12,3)); cont0 = axes[0].contourf(xvec, xvec, Q_coherent, 100); lbl0 = axes[0].set_title(""Coherent state""); cont1 = axes[1].contourf(xvec, xvec, Q_thermal, 100); lbl1 = axes[1].set_title(""Thermal state""); cont0 = axes[2].contourf(xvec, xvec, Q_fock, 100); lbl2 = axes[2].set_title(""Fock state""); plt.show(). If you need to calculate the Q function for many states with the same; phase-space coordinates, it is more efficient to use the :obj:`.QFunc` class.; This stores various intermediary results to achieve an order-of-magnitude; improvement compared to calling :obj:`.qfunc` in a loop. .. code-block:: python. xs = np.linspace(-1, 1, 101); qfunc_calculator = qutip.QFunc(xs, xs); q_state1 = qfunc_calculator(qutip.rand_dm(5)); q_state2 = qfunc_calculator(qutip.rand_ket(100)). .. _visual-oper:. Visualizing operators; =====================. Sometimes, it may also be useful to directly visualizing the underlying matrix; representation of an operator. The density matrix, for example, is an operator; whose elements can give insights about the state it represents, but one might; also be interesting in plotting the matrix of an Hamiltonian to inspect the; structure and relative importance of various elements. QuTiP offers a few functions for quickly visualizing matrix data in the; form of histograms, :func:`qutip.visualization.matrix_histogram` and; as Hinton diagra",MatchSource.DOCS,doc/guide/guide-visualization.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-visualization.rst
Integrability,depend,dependent,"rix :math:`M` with a size that is the square of the size of the superoperator for the system. Obviously, this scales very badly with increasing system size, but this method can still be a very useful for small systems (such as system comprised of a small number of coupled qubits). Implementation in QuTiP; -----------------------. In QuTiP, the procedure described above is implemented in the function :func:`qutip.tomography.qpt`, which returns the :math:`\chi` matrix given a density matrix propagator.; To illustrate how to use this function, let's consider the SWAP gate for two qubits. In QuTiP the function :func:`.swap` generates the unitary transformation for the state kets:. .. plot::; :context: close-figs. from qutip.core.gates import swap. U_psi = swap(). To be able to use this unitary transformation matrix as input to the function :func:`qutip.tomography.qpt`, we first need to convert it to a transformation matrix for the corresponding density matrix:. .. plot::; :context:. U_rho = spre(U_psi) * spost(U_psi.dag()). Next, we construct a list of operators that define the basis :math:`\{B_i\}` in the form of a list of operators for each composite system. At the same time, we also construct a list of corresponding labels that will be used when plotting the :math:`\chi` matrix. .. plot::; :context:. op_basis = [[qeye(2), sigmax(), sigmay(), sigmaz()]] * 2; op_label = [[""i"", ""x"", ""y"", ""z""]] * 2. We are now ready to compute :math:`\chi` using :func:`qutip.tomography.qpt`, and to plot it using :func:`qutip.tomography.qpt_plot_combined`. .. plot::; :context:. chi = qpt(U_rho, op_basis). fig = qpt_plot_combined(chi, op_label, r'SWAP'). plt.show(). For a slightly more advanced example, where the density matrix propagator is calculated from the dynamics of a system defined by its Hamiltonian and collapse operators using the function :func:`.propagator`, see notebook ""Time-dependent master equation: Landau-Zener transitions"" on the tutorials section on the QuTiP web site.; ",MatchSource.DOCS,doc/guide/guide-visualization.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-visualization.rst
Performance,perform,perform,".. _visual:. .. plot::; :include-source: False. import numpy as np. from qutip import *. import pylab as plt. from warnings import warn. plt.close(""all""). *********************************************; Visualization of quantum states and processes; *********************************************. Visualization is often an important complement to a simulation of a quantum; mechanical system. The first method of visualization that come to mind might be; to plot the expectation values of a few selected operators. But on top of that,; it can often be instructive to visualize for example the state vectors or; density matices that describe the state of the system, or how the state is; transformed as a function of time (see process tomography below). In this; section we demonstrate how QuTiP and matplotlib can be used to perform a few; types of visualizations that often can provide additional understanding of; quantum system. .. _visual-fock:. Fock-basis probability distribution; ===================================. In quantum mechanics probability distributions plays an important role, and as; in statistics, the expectation values computed from a probability distribution; does not reveal the full story. For example, consider an quantum harmonic; oscillator mode with Hamiltonian :math:`H = \hbar\omega a^\dagger a`, which is; in a state described by its density matrix :math:`\rho`, and which on average; is occupied by two photons, :math:`\mathrm{Tr}[\rho a^\dagger a] = 2`. Given; this information we cannot say whether the oscillator is in a Fock state,; a thermal state, a coherent state, etc. By visualizing the photon distribution; in the Fock state basis important clues about the underlying state can be; obtained. One convenient way to visualize a probability distribution is to use histograms.; Consider the following histogram visualization of the number-basis probability; distribution, which can be obtained from the diagonal of the density matrix,; for a few possible oscilla",MatchSource.DOCS,doc/guide/guide-visualization.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-visualization.rst
Security,access,access,"ider a process that is described by quantum map :math:`\epsilon(\rho_{\rm in}) = \rho_{\rm out}`, which can be written. .. math::; :label: qpt-quantum-map. \epsilon(\rho_{\rm in}) = \rho_{\rm out} = \sum_{i}^{N^2} A_i \rho_{\rm in} A_i^\dagger,. where :math:`N` is the number of states of the system (that is, :math:`\rho` is represented by an :math:`[N\times N]` matrix). Given an orthogonal operator basis of our choice :math:`\{B_i\}_i^{N^2}`, which satisfies :math:`{\rm Tr}[B_i^\dagger B_j] = N\delta_{ij}`, we can write the map as. .. math::; :label: qpt-quantum-map-transformed. \epsilon(\rho_{\rm in}) = \rho_{\rm out} = \sum_{mn} \chi_{mn} B_m \rho_{\rm in} B_n^\dagger. where :math:`\chi_{mn} = \sum_{ij} b_{im}b_{jn}^*` and :math:`A_i = \sum_{m} b_{im}B_{m}`. Here, matrix :math:`\chi` is the transformation matrix we are after, since it describes how much :math:`B_m \rho_{\rm in} B_n^\dagger` contributes to :math:`\rho_{\rm out}`. In a numerical simulation of a quantum process we usually do not have access to the quantum map in the form Eq. :eq:`qpt-quantum-map`. Instead, what we usually can do is to calculate the propagator :math:`U` for the density matrix in superoperator form, using for example the QuTiP function :func:`qutip.propagator.propagator`. We can then write. .. math::. \epsilon(\tilde{\rho}_{\rm in}) = U \tilde{\rho}_{\rm in} = \tilde{\rho}_{\rm out}. where :math:`\tilde{\rho}` is the vector representation of the density matrix :math:`\rho`. If we write Eq. :eq:`qpt-quantum-map-transformed` in superoperator form as well we obtain. .. math::. \tilde{\rho}_{\rm out} = \sum_{mn} \chi_{mn} \tilde{B}_m \tilde{B}_n^\dagger \tilde{\rho}_{\rm in} = U \tilde{\rho}_{\rm in}. so we can identify. .. math::. U = \sum_{mn} \chi_{mn} \tilde{B}_m \tilde{B}_n^\dagger. Now this is a linear equation systems for the :math:`N^2 \times N^2` elements in :math:`\chi`. We can solve it by writing :math:`\chi` and the superoperator propagator as :math:`[N^4]` vectors, and likewis",MatchSource.DOCS,doc/guide/guide-visualization.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide-visualization.rst
Usability,guid,guide-overview,.. _guide:. *******************; Users Guide; *******************. .. toctree::; :maxdepth: 2. guide-overview.rst; guide-basics.rst; guide-states.rst; guide-tensor.rst; guide-super.rst; guide-dynamics.rst; guide-heom.rst; guide-steady.rst; guide-piqs.rst; guide-correlation.rst; guide-bloch.rst; guide-visualization.rst; guide-saving.rst; guide-random.rst; guide-settings.rst; guide-measurement.rst; guide-control.rst; ,MatchSource.DOCS,doc/guide/guide.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/guide.rst
Modifiability,extend,extend,"**********************************************************; GPU implementation of the Hierarchical Equations of Motion; **********************************************************. .. contents:: Contents; :local:; :depth: 3. The Hierarchical Equations of Motion (HEOM) method is a non-perturbative; approach to simulate the evolution of the density matrix of dissipative quantum; systems. The underlying equations are a system of coupled ODEs which can be run; on a GPU. This will allow the study of larger systems as discussed in [1]_. The; goal of this project would be to extend QuTiP's HEOM method [2]_ and implement; it on a GPU. Since the method is related to simulating large, coupled ODEs, it can also be; quite general and extended to other solvers. Expected outcomes; =================. * A version of HEOM which runs on a GPU.; * Performance comparison with the CPU version.; * Implement dynamic scaling. Skills; ======. * Git, python and familiarity with the Python scientific computing stack; * CUDA and OpenCL knowledge. Difficulty; ==========. * Hard. Mentors; =======. * Neill Lambert (nwlambert@gmail.com); * Alex Pitchford (alex.pitchford@gmail.com); * Shahnawaz Ahmed (shahnawaz.ahmed95@gmail.com); * Simon Cross (hodgestar@gmail.com). References; ==========. .. [1] https://pubs.acs.org/doi/abs/10.1021/ct200126d?src=recsys&journalCode=jctcce; .. [2] https://arxiv.org/abs/2010.10806; ",MatchSource.DOCS,doc/development/ideas/heom-gpu.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/heom-gpu.rst
Integrability,depend,depend,"es and features, allowing the simulation both at the; level of gates and at the level of time evolution. To connect them, a compiler; is implemented to compile quantum gates into the Hamiltonian model. We would; like to further enhance this feature in QuTiP and the connection with other; libraries. Expected outcomes; =================. * APIs to import and export pulses to other libraries. Quantum compiler is a; current research topic in quantum engineering. Although QuTiP has a simple; compiler, many may want to try their own compiler which is more compatible; with their quantum device. Allowing importation and exportation of control; pulses will make this much easier. This will include a study of existing; libraries, such as `qiskit.pulse` and `OpenPulse` [1]_, comparing them with; `qutip.qip.pulse` module and building a more general and comprehensive; description of the pulse. * More examples of quantum system in the `qutip.qip.device` module. The circuit; simulation and compilation depend strongly on the physical system. At the; moment, we have two models: spin chain and cavity QED. We would like to; include some other commonly used planform such as Superconducting system [2]_,; Ion trap system [3]_ or silicon system. Each model will need a new set of; control Hamiltonian and a compiler that finds the control pulse of a quantum; gate. More involved noise models can also be added based on the physical; system. This part is going to involve some physics and study of commonly used; hardware platforms. The related code can be found in `qutip.qip.device` and; `qutip.qip.compiler`. Skills; ======. * Git, Python and familiarity with the Python scientific computing stack; * quantum information processing and quantum computing (quantum circuit formalism). Difficulty; ==========. * Medium. Mentors; =======. * Boxi Li (etamin1201@gmail.com) [QuTiP GSoC 2019 graduate]; * Nathan Shammah (nathan.shammah@gmail.com); * Alex Pitchford (alex.pitchford@gmail.com). References; ====",MatchSource.DOCS,doc/development/ideas/pulse-level-quantum-circuits.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/pulse-level-quantum-circuits.rst
Modifiability,enhance,enhance,"*******************************************; Pulse level description of quantum circuits; *******************************************. .. contents:: Contents; :local:; :depth: 3. The aim of this proposal is to enhance QuTiP quantum-circuit compilation; features with regard to quantum information processing. While QuTiP core modules; deal with dynamics simulation, there is also a module for quantum circuits; simulation. The two subsequent Google Summer of Code projects, in 2019 and 2020,; enhanced them in capabilities and features, allowing the simulation both at the; level of gates and at the level of time evolution. To connect them, a compiler; is implemented to compile quantum gates into the Hamiltonian model. We would; like to further enhance this feature in QuTiP and the connection with other; libraries. Expected outcomes; =================. * APIs to import and export pulses to other libraries. Quantum compiler is a; current research topic in quantum engineering. Although QuTiP has a simple; compiler, many may want to try their own compiler which is more compatible; with their quantum device. Allowing importation and exportation of control; pulses will make this much easier. This will include a study of existing; libraries, such as `qiskit.pulse` and `OpenPulse` [1]_, comparing them with; `qutip.qip.pulse` module and building a more general and comprehensive; description of the pulse. * More examples of quantum system in the `qutip.qip.device` module. The circuit; simulation and compilation depend strongly on the physical system. At the; moment, we have two models: spin chain and cavity QED. We would like to; include some other commonly used planform such as Superconducting system [2]_,; Ion trap system [3]_ or silicon system. Each model will need a new set of; control Hamiltonian and a compiler that finds the control pulse of a quantum; gate. More involved noise models can also be added based on the physical; system. This part is going to involve some physics a",MatchSource.DOCS,doc/development/ideas/pulse-level-quantum-circuits.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/pulse-level-quantum-circuits.rst
Usability,simpl,simple,"se level description of quantum circuits; *******************************************. .. contents:: Contents; :local:; :depth: 3. The aim of this proposal is to enhance QuTiP quantum-circuit compilation; features with regard to quantum information processing. While QuTiP core modules; deal with dynamics simulation, there is also a module for quantum circuits; simulation. The two subsequent Google Summer of Code projects, in 2019 and 2020,; enhanced them in capabilities and features, allowing the simulation both at the; level of gates and at the level of time evolution. To connect them, a compiler; is implemented to compile quantum gates into the Hamiltonian model. We would; like to further enhance this feature in QuTiP and the connection with other; libraries. Expected outcomes; =================. * APIs to import and export pulses to other libraries. Quantum compiler is a; current research topic in quantum engineering. Although QuTiP has a simple; compiler, many may want to try their own compiler which is more compatible; with their quantum device. Allowing importation and exportation of control; pulses will make this much easier. This will include a study of existing; libraries, such as `qiskit.pulse` and `OpenPulse` [1]_, comparing them with; `qutip.qip.pulse` module and building a more general and comprehensive; description of the pulse. * More examples of quantum system in the `qutip.qip.device` module. The circuit; simulation and compilation depend strongly on the physical system. At the; moment, we have two models: spin chain and cavity QED. We would like to; include some other commonly used planform such as Superconducting system [2]_,; Ion trap system [3]_ or silicon system. Each model will need a new set of; control Hamiltonian and a compiler that finds the control pulse of a quantum; gate. More involved noise models can also be added based on the physical; system. This part is going to involve some physics and study of commonly used; hardware platforms. ",MatchSource.DOCS,doc/development/ideas/pulse-level-quantum-circuits.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/pulse-level-quantum-circuits.rst
Availability,error,error,"************************; Quantum Error Mitigation; ************************. .. contents:: Contents; :local:; :depth: 3. From the QuTiP 4.5 release, the qutip.qip module now contains the noisy quantum; circuit simulator (which was a GSoC project) providing enhanced features for a; pulse-level description of quantum circuits and noise models. A new class; `Processor` and several subclasses are added to represent different platforms; for quantum computing. They can transfer a quantum circuit into the; corresponding control sequence and simulate the dynamics with QuTiP solvers.; Different noise models can be added to `qutip.qip.noise` to simulate noise in a; quantum device. This module is still young and many features can be improved, including new; device models, new noise models and integration with the existing general; framework for quantum circuits (`qutip.qip.circuit`). There are also possible; applications such as error mitigation techniques ([1]_, [2]_, [3]_). The tutorial notebooks can be found in the Quantum information processing; section of https://qutip.org/qutip-tutorials/index-v5.html. A; recent presentation on the FOSDEM conference may help you get an overview; (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github; Project page for a collection of related issues and ongoing Pull Requests. Expected outcomes; =================. - Make an overview of existing libraries and features in error mitigation,; similarly to a literature survey for a research article, but for a code; project (starting from Refs. [4]_, [5]_). This is done in order to best; integrate the features in QuTiP with existing libraries and avoid; reinventing the wheel.; - Features to perform error mitigation techniques in QuTiP, such as zero-noise; extrapolation by pulse stretching.; - Tutorials implementing basic quantum error mitigation protocols; - Possible integration with Mitiq [6]_. Skills; ======. * Background in quantum physics and quantum circuits.; * Git, py",MatchSource.DOCS,doc/development/ideas/quantum-error-mitigation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/quantum-error-mitigation.rst
Deployability,release,release,"************************; Quantum Error Mitigation; ************************. .. contents:: Contents; :local:; :depth: 3. From the QuTiP 4.5 release, the qutip.qip module now contains the noisy quantum; circuit simulator (which was a GSoC project) providing enhanced features for a; pulse-level description of quantum circuits and noise models. A new class; `Processor` and several subclasses are added to represent different platforms; for quantum computing. They can transfer a quantum circuit into the; corresponding control sequence and simulate the dynamics with QuTiP solvers.; Different noise models can be added to `qutip.qip.noise` to simulate noise in a; quantum device. This module is still young and many features can be improved, including new; device models, new noise models and integration with the existing general; framework for quantum circuits (`qutip.qip.circuit`). There are also possible; applications such as error mitigation techniques ([1]_, [2]_, [3]_). The tutorial notebooks can be found in the Quantum information processing; section of https://qutip.org/qutip-tutorials/index-v5.html. A; recent presentation on the FOSDEM conference may help you get an overview; (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github; Project page for a collection of related issues and ongoing Pull Requests. Expected outcomes; =================. - Make an overview of existing libraries and features in error mitigation,; similarly to a literature survey for a research article, but for a code; project (starting from Refs. [4]_, [5]_). This is done in order to best; integrate the features in QuTiP with existing libraries and avoid; reinventing the wheel.; - Features to perform error mitigation techniques in QuTiP, such as zero-noise; extrapolation by pulse stretching.; - Tutorials implementing basic quantum error mitigation protocols; - Possible integration with Mitiq [6]_. Skills; ======. * Background in quantum physics and quantum circuits.; * Git, py",MatchSource.DOCS,doc/development/ideas/quantum-error-mitigation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/quantum-error-mitigation.rst
Energy Efficiency,schedul,schedule,"s a GSoC project) providing enhanced features for a; pulse-level description of quantum circuits and noise models. A new class; `Processor` and several subclasses are added to represent different platforms; for quantum computing. They can transfer a quantum circuit into the; corresponding control sequence and simulate the dynamics with QuTiP solvers.; Different noise models can be added to `qutip.qip.noise` to simulate noise in a; quantum device. This module is still young and many features can be improved, including new; device models, new noise models and integration with the existing general; framework for quantum circuits (`qutip.qip.circuit`). There are also possible; applications such as error mitigation techniques ([1]_, [2]_, [3]_). The tutorial notebooks can be found in the Quantum information processing; section of https://qutip.org/qutip-tutorials/index-v5.html. A; recent presentation on the FOSDEM conference may help you get an overview; (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github; Project page for a collection of related issues and ongoing Pull Requests. Expected outcomes; =================. - Make an overview of existing libraries and features in error mitigation,; similarly to a literature survey for a research article, but for a code; project (starting from Refs. [4]_, [5]_). This is done in order to best; integrate the features in QuTiP with existing libraries and avoid; reinventing the wheel.; - Features to perform error mitigation techniques in QuTiP, such as zero-noise; extrapolation by pulse stretching.; - Tutorials implementing basic quantum error mitigation protocols; - Possible integration with Mitiq [6]_. Skills; ======. * Background in quantum physics and quantum circuits.; * Git, python and familiarity with the Python scientific computing stack. Difficulty; ==========. * Medium. Mentors; =======. * Nathan Shammah (nathan.shammah@gmail.com); * Alex Pitchford (alex.pitchford@gmail.com); * Eric Giguère (eric.g",MatchSource.DOCS,doc/development/ideas/quantum-error-mitigation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/quantum-error-mitigation.rst
Integrability,integrat,integration,"************************; Quantum Error Mitigation; ************************. .. contents:: Contents; :local:; :depth: 3. From the QuTiP 4.5 release, the qutip.qip module now contains the noisy quantum; circuit simulator (which was a GSoC project) providing enhanced features for a; pulse-level description of quantum circuits and noise models. A new class; `Processor` and several subclasses are added to represent different platforms; for quantum computing. They can transfer a quantum circuit into the; corresponding control sequence and simulate the dynamics with QuTiP solvers.; Different noise models can be added to `qutip.qip.noise` to simulate noise in a; quantum device. This module is still young and many features can be improved, including new; device models, new noise models and integration with the existing general; framework for quantum circuits (`qutip.qip.circuit`). There are also possible; applications such as error mitigation techniques ([1]_, [2]_, [3]_). The tutorial notebooks can be found in the Quantum information processing; section of https://qutip.org/qutip-tutorials/index-v5.html. A; recent presentation on the FOSDEM conference may help you get an overview; (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github; Project page for a collection of related issues and ongoing Pull Requests. Expected outcomes; =================. - Make an overview of existing libraries and features in error mitigation,; similarly to a literature survey for a research article, but for a code; project (starting from Refs. [4]_, [5]_). This is done in order to best; integrate the features in QuTiP with existing libraries and avoid; reinventing the wheel.; - Features to perform error mitigation techniques in QuTiP, such as zero-noise; extrapolation by pulse stretching.; - Tutorials implementing basic quantum error mitigation protocols; - Possible integration with Mitiq [6]_. Skills; ======. * Background in quantum physics and quantum circuits.; * Git, py",MatchSource.DOCS,doc/development/ideas/quantum-error-mitigation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/quantum-error-mitigation.rst
Modifiability,enhance,enhanced,"************************; Quantum Error Mitigation; ************************. .. contents:: Contents; :local:; :depth: 3. From the QuTiP 4.5 release, the qutip.qip module now contains the noisy quantum; circuit simulator (which was a GSoC project) providing enhanced features for a; pulse-level description of quantum circuits and noise models. A new class; `Processor` and several subclasses are added to represent different platforms; for quantum computing. They can transfer a quantum circuit into the; corresponding control sequence and simulate the dynamics with QuTiP solvers.; Different noise models can be added to `qutip.qip.noise` to simulate noise in a; quantum device. This module is still young and many features can be improved, including new; device models, new noise models and integration with the existing general; framework for quantum circuits (`qutip.qip.circuit`). There are also possible; applications such as error mitigation techniques ([1]_, [2]_, [3]_). The tutorial notebooks can be found in the Quantum information processing; section of https://qutip.org/qutip-tutorials/index-v5.html. A; recent presentation on the FOSDEM conference may help you get an overview; (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github; Project page for a collection of related issues and ongoing Pull Requests. Expected outcomes; =================. - Make an overview of existing libraries and features in error mitigation,; similarly to a literature survey for a research article, but for a code; project (starting from Refs. [4]_, [5]_). This is done in order to best; integrate the features in QuTiP with existing libraries and avoid; reinventing the wheel.; - Features to perform error mitigation techniques in QuTiP, such as zero-noise; extrapolation by pulse stretching.; - Tutorials implementing basic quantum error mitigation protocols; - Possible integration with Mitiq [6]_. Skills; ======. * Background in quantum physics and quantum circuits.; * Git, py",MatchSource.DOCS,doc/development/ideas/quantum-error-mitigation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/quantum-error-mitigation.rst
Performance,perform,perform,"ew; device models, new noise models and integration with the existing general; framework for quantum circuits (`qutip.qip.circuit`). There are also possible; applications such as error mitigation techniques ([1]_, [2]_, [3]_). The tutorial notebooks can be found in the Quantum information processing; section of https://qutip.org/qutip-tutorials/index-v5.html. A; recent presentation on the FOSDEM conference may help you get an overview; (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github; Project page for a collection of related issues and ongoing Pull Requests. Expected outcomes; =================. - Make an overview of existing libraries and features in error mitigation,; similarly to a literature survey for a research article, but for a code; project (starting from Refs. [4]_, [5]_). This is done in order to best; integrate the features in QuTiP with existing libraries and avoid; reinventing the wheel.; - Features to perform error mitigation techniques in QuTiP, such as zero-noise; extrapolation by pulse stretching.; - Tutorials implementing basic quantum error mitigation protocols; - Possible integration with Mitiq [6]_. Skills; ======. * Background in quantum physics and quantum circuits.; * Git, python and familiarity with the Python scientific computing stack. Difficulty; ==========. * Medium. Mentors; =======. * Nathan Shammah (nathan.shammah@gmail.com); * Alex Pitchford (alex.pitchford@gmail.com); * Eric Giguère (eric.giguere@usherbrooke.ca); * Neill Lambert (nwlambert@gmail.com); * Boxi Li (etamin1201@gmail.com) [QuTiP GSoC 2019 graduate]. References; ==========. .. [1] Kristan Temme, Sergey Bravyi, Jay M. Gambetta, **Error mitigation for short-depth quantum circuits**, Phys. Rev. Lett. 119, 180509 (2017). .. [2] Abhinav Kandala, Kristan Temme, Antonio D. Corcoles, Antonio Mezzacapo, Jerry M. Chow, Jay M. Gambetta,; **Extending the computational reach of a noisy superconducting quantum processor**, Nature *567*, 491 (2019). .. [3] S",MatchSource.DOCS,doc/development/ideas/quantum-error-mitigation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/quantum-error-mitigation.rst
Safety,avoid,avoid,"oise` to simulate noise in a; quantum device. This module is still young and many features can be improved, including new; device models, new noise models and integration with the existing general; framework for quantum circuits (`qutip.qip.circuit`). There are also possible; applications such as error mitigation techniques ([1]_, [2]_, [3]_). The tutorial notebooks can be found in the Quantum information processing; section of https://qutip.org/qutip-tutorials/index-v5.html. A; recent presentation on the FOSDEM conference may help you get an overview; (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github; Project page for a collection of related issues and ongoing Pull Requests. Expected outcomes; =================. - Make an overview of existing libraries and features in error mitigation,; similarly to a literature survey for a research article, but for a code; project (starting from Refs. [4]_, [5]_). This is done in order to best; integrate the features in QuTiP with existing libraries and avoid; reinventing the wheel.; - Features to perform error mitigation techniques in QuTiP, such as zero-noise; extrapolation by pulse stretching.; - Tutorials implementing basic quantum error mitigation protocols; - Possible integration with Mitiq [6]_. Skills; ======. * Background in quantum physics and quantum circuits.; * Git, python and familiarity with the Python scientific computing stack. Difficulty; ==========. * Medium. Mentors; =======. * Nathan Shammah (nathan.shammah@gmail.com); * Alex Pitchford (alex.pitchford@gmail.com); * Eric Giguère (eric.giguere@usherbrooke.ca); * Neill Lambert (nwlambert@gmail.com); * Boxi Li (etamin1201@gmail.com) [QuTiP GSoC 2019 graduate]. References; ==========. .. [1] Kristan Temme, Sergey Bravyi, Jay M. Gambetta, **Error mitigation for short-depth quantum circuits**, Phys. Rev. Lett. 119, 180509 (2017). .. [2] Abhinav Kandala, Kristan Temme, Antonio D. Corcoles, Antonio Mezzacapo, Jerry M. Chow, Jay M. Gambetta,; ",MatchSource.DOCS,doc/development/ideas/quantum-error-mitigation.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/quantum-error-mitigation.rst
Deployability,toggle,toggle,"*****************; QuTiP Interactive; *****************. .. contents:: Contents; :local:; :depth: 3. QuTiP is pretty simple to use at an entry level for anyone with basic Python; skills. However, *some* Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners. Ideally, interactive components could be embedded in web pages. Including, but; not limited to, Jupyter notebooks. The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere; ------------------------. QuTiP has a Bloch sphere virtualisation for qubit states. This could be made; interactive through sliders, radio buttons, cmd buttons etc. An interactive; Bloch sphere could have sliders for qubit state angles. Buttons to add states,; toggle state evolution path. Potential for recording animations. Matplotlib has; some interactive features (sliders, radio buttons, cmd buttons) that can be used; to control parameters. that could potentially be used. Interactive solvers; -------------------. Options to configure dynamics generators (Lindbladian / Hamiltonian args etc); and expectation operators. Then run solver and view state evolution. Animated circuits; -----------------. QIP circuits could be animated. Status lights showing evolution of states during; the processing. Animated Bloch spheres for qubits. Expected outcomes; =================. * Interactive graphical components for demonstrating quantum dynamics; * Web pages for qutip.org or Jupyter notebooks introducing quantum dynamics; using the new components. Skills; ======. * Git, Python and familiarity with the Python scientific computing stack; * elementary understanding of quantum dynamics. Difficulty; ==========. * Variable. Mentors; =======. * Nathan Shammah (nathan.shammah@gmail.com); * Alex Pitchford (alex.pitchford@gmail.com); * Simon Cross (hodgestar@gmail.com); * B",MatchSource.DOCS,doc/development/ideas/qutip-interactive.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/qutip-interactive.rst
Integrability,interface,interface,"*****************; QuTiP Interactive; *****************. .. contents:: Contents; :local:; :depth: 3. QuTiP is pretty simple to use at an entry level for anyone with basic Python; skills. However, *some* Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners. Ideally, interactive components could be embedded in web pages. Including, but; not limited to, Jupyter notebooks. The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere; ------------------------. QuTiP has a Bloch sphere virtualisation for qubit states. This could be made; interactive through sliders, radio buttons, cmd buttons etc. An interactive; Bloch sphere could have sliders for qubit state angles. Buttons to add states,; toggle state evolution path. Potential for recording animations. Matplotlib has; some interactive features (sliders, radio buttons, cmd buttons) that can be used; to control parameters. that could potentially be used. Interactive solvers; -------------------. Options to configure dynamics generators (Lindbladian / Hamiltonian args etc); and expectation operators. Then run solver and view state evolution. Animated circuits; -----------------. QIP circuits could be animated. Status lights showing evolution of states during; the processing. Animated Bloch spheres for qubits. Expected outcomes; =================. * Interactive graphical components for demonstrating quantum dynamics; * Web pages for qutip.org or Jupyter notebooks introducing quantum dynamics; using the new components. Skills; ======. * Git, Python and familiarity with the Python scientific computing stack; * elementary understanding of quantum dynamics. Difficulty; ==========. * Variable. Mentors; =======. * Nathan Shammah (nathan.shammah@gmail.com); * Alex Pitchford (alex.pitchford@gmail.com); * Simon Cross (hodgestar@gmail.com); * B",MatchSource.DOCS,doc/development/ideas/qutip-interactive.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/qutip-interactive.rst
Modifiability,flexible,flexible,"*****************; QuTiP Interactive; *****************. .. contents:: Contents; :local:; :depth: 3. QuTiP is pretty simple to use at an entry level for anyone with basic Python; skills. However, *some* Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners. Ideally, interactive components could be embedded in web pages. Including, but; not limited to, Jupyter notebooks. The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere; ------------------------. QuTiP has a Bloch sphere virtualisation for qubit states. This could be made; interactive through sliders, radio buttons, cmd buttons etc. An interactive; Bloch sphere could have sliders for qubit state angles. Buttons to add states,; toggle state evolution path. Potential for recording animations. Matplotlib has; some interactive features (sliders, radio buttons, cmd buttons) that can be used; to control parameters. that could potentially be used. Interactive solvers; -------------------. Options to configure dynamics generators (Lindbladian / Hamiltonian args etc); and expectation operators. Then run solver and view state evolution. Animated circuits; -----------------. QIP circuits could be animated. Status lights showing evolution of states during; the processing. Animated Bloch spheres for qubits. Expected outcomes; =================. * Interactive graphical components for demonstrating quantum dynamics; * Web pages for qutip.org or Jupyter notebooks introducing quantum dynamics; using the new components. Skills; ======. * Git, Python and familiarity with the Python scientific computing stack; * elementary understanding of quantum dynamics. Difficulty; ==========. * Variable. Mentors; =======. * Nathan Shammah (nathan.shammah@gmail.com); * Alex Pitchford (alex.pitchford@gmail.com); * Simon Cross (hodgestar@gmail.com); * B",MatchSource.DOCS,doc/development/ideas/qutip-interactive.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/qutip-interactive.rst
Security,access,accessible,"*****************; QuTiP Interactive; *****************. .. contents:: Contents; :local:; :depth: 3. QuTiP is pretty simple to use at an entry level for anyone with basic Python; skills. However, *some* Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners. Ideally, interactive components could be embedded in web pages. Including, but; not limited to, Jupyter notebooks. The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere; ------------------------. QuTiP has a Bloch sphere virtualisation for qubit states. This could be made; interactive through sliders, radio buttons, cmd buttons etc. An interactive; Bloch sphere could have sliders for qubit state angles. Buttons to add states,; toggle state evolution path. Potential for recording animations. Matplotlib has; some interactive features (sliders, radio buttons, cmd buttons) that can be used; to control parameters. that could potentially be used. Interactive solvers; -------------------. Options to configure dynamics generators (Lindbladian / Hamiltonian args etc); and expectation operators. Then run solver and view state evolution. Animated circuits; -----------------. QIP circuits could be animated. Status lights showing evolution of states during; the processing. Animated Bloch spheres for qubits. Expected outcomes; =================. * Interactive graphical components for demonstrating quantum dynamics; * Web pages for qutip.org or Jupyter notebooks introducing quantum dynamics; using the new components. Skills; ======. * Git, Python and familiarity with the Python scientific computing stack; * elementary understanding of quantum dynamics. Difficulty; ==========. * Variable. Mentors; =======. * Nathan Shammah (nathan.shammah@gmail.com); * Alex Pitchford (alex.pitchford@gmail.com); * Simon Cross (hodgestar@gmail.com); * B",MatchSource.DOCS,doc/development/ideas/qutip-interactive.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/qutip-interactive.rst
Usability,simpl,simple,"*****************; QuTiP Interactive; *****************. .. contents:: Contents; :local:; :depth: 3. QuTiP is pretty simple to use at an entry level for anyone with basic Python; skills. However, *some* Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners. Ideally, interactive components could be embedded in web pages. Including, but; not limited to, Jupyter notebooks. The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere; ------------------------. QuTiP has a Bloch sphere virtualisation for qubit states. This could be made; interactive through sliders, radio buttons, cmd buttons etc. An interactive; Bloch sphere could have sliders for qubit state angles. Buttons to add states,; toggle state evolution path. Potential for recording animations. Matplotlib has; some interactive features (sliders, radio buttons, cmd buttons) that can be used; to control parameters. that could potentially be used. Interactive solvers; -------------------. Options to configure dynamics generators (Lindbladian / Hamiltonian args etc); and expectation operators. Then run solver and view state evolution. Animated circuits; -----------------. QIP circuits could be animated. Status lights showing evolution of states during; the processing. Animated Bloch spheres for qubits. Expected outcomes; =================. * Interactive graphical components for demonstrating quantum dynamics; * Web pages for qutip.org or Jupyter notebooks introducing quantum dynamics; using the new components. Skills; ======. * Git, Python and familiarity with the Python scientific computing stack; * elementary understanding of quantum dynamics. Difficulty; ==========. * Variable. Mentors; =======. * Nathan Shammah (nathan.shammah@gmail.com); * Alex Pitchford (alex.pitchford@gmail.com); * Simon Cross (hodgestar@gmail.com); * B",MatchSource.DOCS,doc/development/ideas/qutip-interactive.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/qutip-interactive.rst
Energy Efficiency,efficient,efficiently,"***********************; TensorFlow Data Backend; ***********************. .. contents:: Contents; :local:; :depth: 3. .. note::; This project was completed as part of GSoC 2021 [3]_. QuTiP's data layer provides the mathematical operations needed to work with; quantum states and operators, i.e. ``Qobj``, inside QuTiP. As part of Google; Summer of Code 2020, the data layer was rewritten to allow new backends to; be added more easily and for different backends to interoperate with each; other. Backends using in-memory spares and dense matrices already exist,; and we would like to add a backend that implements the necessary operations; using TensorFlow [1]_. Why a TensorFlow backend?; -------------------------. TensorFlow supports distributing matrix operations across multiple GPUs and; multiple machines, and abstracts away some of the complexities of doing so; efficiently. We hope that by using TensorFlow we might enable QuTiP to scale; to bigger quantum systems (e.g. more qubits) and decrease the time taken to; simulate them. There is particular interest in trying the new backend with the; BoFiN HEOM (Hierarchical Equations of Motion) solver [2]_. Challenges; ----------. TensorFlow is a very different kind of computational framework to the existing; dense and sparse matrix backends. It uses flow graphs to describe operations,; and to work efficiently. Ideally large graphs of operations need to be; executed together in order to efficiently compute results. The QuTiP data layer might need to be adjusted to accommodate these; differences, and it is possible that this will prove challenging or even; that we will not find a reasonable way to achieve the desired performance. Expected outcomes; =================. * Add a ``qutip.core.data.tensorflow`` data type.; * Implement specialisations for some important operations (e.g. ``add``,; ``mul``, ``matmul``, ``eigen``, etc).; * Write a small benchmark to show how ``Qobj`` operations scale on the new; backend in comparison to t",MatchSource.DOCS,doc/development/ideas/tensorflow-data-backend.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/tensorflow-data-backend.rst
Performance,perform,performance,"d a backend that implements the necessary operations; using TensorFlow [1]_. Why a TensorFlow backend?; -------------------------. TensorFlow supports distributing matrix operations across multiple GPUs and; multiple machines, and abstracts away some of the complexities of doing so; efficiently. We hope that by using TensorFlow we might enable QuTiP to scale; to bigger quantum systems (e.g. more qubits) and decrease the time taken to; simulate them. There is particular interest in trying the new backend with the; BoFiN HEOM (Hierarchical Equations of Motion) solver [2]_. Challenges; ----------. TensorFlow is a very different kind of computational framework to the existing; dense and sparse matrix backends. It uses flow graphs to describe operations,; and to work efficiently. Ideally large graphs of operations need to be; executed together in order to efficiently compute results. The QuTiP data layer might need to be adjusted to accommodate these; differences, and it is possible that this will prove challenging or even; that we will not find a reasonable way to achieve the desired performance. Expected outcomes; =================. * Add a ``qutip.core.data.tensorflow`` data type.; * Implement specialisations for some important operations (e.g. ``add``,; ``mul``, ``matmul``, ``eigen``, etc).; * Write a small benchmark to show how ``Qobj`` operations scale on the new; backend in comparison to the existing backends. Run the benchmark both; with and without using a GPU.; * Implement enough for a solver to run on top of the new TensorFlow data; backend and benchmark that (stretch goal). Skills; ======. * Git, Python and familiarity with the Python scientific computing stack; * Familiarity with TensorFlow (beneficial, but not required); * Familiarity with Cython (beneficial, but not required). Difficulty; ==========. * Medium. Mentors; =======. * Simon Cross (hodgestar@gmail.com); * Jake Lishman (jake@binhbar.com); * Alex Pitchford (alex.pitchford@gmail.com). References; =",MatchSource.DOCS,doc/development/ideas/tensorflow-data-backend.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/tensorflow-data-backend.rst
Testability,benchmark,benchmark,"ow supports distributing matrix operations across multiple GPUs and; multiple machines, and abstracts away some of the complexities of doing so; efficiently. We hope that by using TensorFlow we might enable QuTiP to scale; to bigger quantum systems (e.g. more qubits) and decrease the time taken to; simulate them. There is particular interest in trying the new backend with the; BoFiN HEOM (Hierarchical Equations of Motion) solver [2]_. Challenges; ----------. TensorFlow is a very different kind of computational framework to the existing; dense and sparse matrix backends. It uses flow graphs to describe operations,; and to work efficiently. Ideally large graphs of operations need to be; executed together in order to efficiently compute results. The QuTiP data layer might need to be adjusted to accommodate these; differences, and it is possible that this will prove challenging or even; that we will not find a reasonable way to achieve the desired performance. Expected outcomes; =================. * Add a ``qutip.core.data.tensorflow`` data type.; * Implement specialisations for some important operations (e.g. ``add``,; ``mul``, ``matmul``, ``eigen``, etc).; * Write a small benchmark to show how ``Qobj`` operations scale on the new; backend in comparison to the existing backends. Run the benchmark both; with and without using a GPU.; * Implement enough for a solver to run on top of the new TensorFlow data; backend and benchmark that (stretch goal). Skills; ======. * Git, Python and familiarity with the Python scientific computing stack; * Familiarity with TensorFlow (beneficial, but not required); * Familiarity with Cython (beneficial, but not required). Difficulty; ==========. * Medium. Mentors; =======. * Simon Cross (hodgestar@gmail.com); * Jake Lishman (jake@binhbar.com); * Alex Pitchford (alex.pitchford@gmail.com). References; ==========. .. [1] https://www.tensorflow.org/; .. [2] https://github.com/tehruhn/bofin; .. [3] https://github.com/qutip/qutip-tensorflow/; ",MatchSource.DOCS,doc/development/ideas/tensorflow-data-backend.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/development/ideas/tensorflow-data-backend.rst
Availability,down,downside,"s, and in those cases the Lindblad master equation is usually the method of choice. However, in some cases, for example systems with varying energy biases and eigenstates and that couple to an environment in some well-defined manner (through a physically motivated system-environment interaction operator), it is often desirable to derive the master equation from more fundamental physical principles, and relate it to for example the noise-power spectrum of the environment. The Bloch-Redfield formalism is one such approach to derive a master equation from a microscopic system.; It starts from a combined system-environment perspective, and derives a perturbative master equation for the system alone, under the assumption of weak system-environment coupling.; One advantage of this approach is that the dissipation processes and rates are obtained directly from the properties of the environment.; On the downside, it does not intrinsically guarantee that the resulting master equation unconditionally preserves the physical properties of the density matrix (because it is a perturbative method).; The Bloch-Redfield master equation must therefore be used with care, and the assumptions made in the derivation must be honored.; (The Lindblad master equation is in a sense more robust -- it always results in a physical density matrix -- although some collapse operators might not be physically justified).; For a full derivation of the Bloch Redfield master equation, see e.g. [Coh92]_ or [Bre02]_.; Here we present only a brief version of the derivation, with the intention of introducing the notation and how it relates to the implementation in QuTiP. .. _bloch-redfield-derivation:. Brief Derivation and Definitions; ================================. The starting point of the Bloch-Redfield formalism is the total Hamiltonian for the system and the environment (bath): :math:`H = H_{\rm S} + H_{\rm B} + H_{\rm I}`, where :math:`H` is the total system+bath Hamiltonian, :math:`H_{\rm S}` and ",MatchSource.DOCS,doc/guide/dynamics/dynamics-bloch-redfield.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst
Deployability,integrat,integration,"the system and the bath, neither in the initial state nor at any time during the evolution.; *It is justified for weak system-bath interaction.*. The master equation :eq:`br-nonmarkovian-form-one` is non-Markovian, i.e., the change in the density matrix at a time :math:`t` depends on states at all times :math:`\tau < t`, making it intractable to solve both theoretically and numerically.; To make progress towards a manageable master equation, we now introduce the Markovian approximation, in which :math:`\rho_S(\tau)` is replaced by :math:`\rho_S(t)` in Eq. :eq:`br-nonmarkovian-form-one`.; The result is the Redfield equation. .. math::; :label: br-nonmarkovian-form-two. \frac{d}{dt}\rho_S(t) = - \hbar^{-2}\int_0^t d\tau\; {\rm Tr}_B [H_I(t), [H_I(\tau), \rho_S(t)\otimes\rho_B]],. which is local in time with respect the density matrix, but still not Markovian since it contains an implicit dependence on the initial state. By extending the integration to infinity and substituting :math:`\tau \rightarrow t-\tau`, a fully Markovian master equation is obtained:. .. math::; :label: br-markovian-form. \frac{d}{dt}\rho_S(t) = - \hbar^{-2}\int_0^\infty d\tau\; {\rm Tr}_B [H_I(t), [H_I(t-\tau), \rho_S(t)\otimes\rho_B]]. The two Markovian approximations introduced above are valid if the time-scale with which the system dynamics changes is large compared to the time-scale with which correlations in the bath decays (corresponding to a ""short-memory"" bath, which results in Markovian system dynamics). The master equation :eq:`br-markovian-form` is still on a too general form to be suitable for numerical implementation. We therefore assume that the system-bath interaction takes the form :math:`H_I = \sum_\alpha A_\alpha \otimes B_\alpha` and where :math:`A_\alpha` are system operators and :math:`B_\alpha` are bath operators.; This allows us to write master equation in terms of system operators and bath correlation functions:. .. math::. \frac{d}{dt}\rho_S(t) =; -\hbar^{-2}; \sum_{\alph",MatchSource.DOCS,doc/guide/dynamics/dynamics-bloch-redfield.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst
Energy Efficiency,energy,energy,"s plt; from scipy import *; from qutip import *; import numpy as np. .. _bloch-redfield-intro:. Introduction; ============. The Lindblad master equation introduced earlier is constructed so that it describes a physical evolution of the density matrix (i.e., trace and positivity preserving), but it does not provide a connection to any underlying microscopic physical model.; The Lindblad operators (collapse operators) describe phenomenological processes, such as for example dephasing and spin flips, and the rates of these processes are arbitrary parameters in the model.; In many situations the collapse operators and their corresponding rates have clear physical interpretation, such as dephasing and relaxation rates, and in those cases the Lindblad master equation is usually the method of choice. However, in some cases, for example systems with varying energy biases and eigenstates and that couple to an environment in some well-defined manner (through a physically motivated system-environment interaction operator), it is often desirable to derive the master equation from more fundamental physical principles, and relate it to for example the noise-power spectrum of the environment. The Bloch-Redfield formalism is one such approach to derive a master equation from a microscopic system.; It starts from a combined system-environment perspective, and derives a perturbative master equation for the system alone, under the assumption of weak system-environment coupling.; One advantage of this approach is that the dissipation processes and rates are obtained directly from the properties of the environment.; On the downside, it does not intrinsically guarantee that the resulting master equation unconditionally preserves the physical properties of the density matrix (because it is a perturbative method).; The Bloch-Redfield master equation must therefore be used with care, and the assumptions made in the derivation must be honored.; (The Lindblad master equation is in a sense mor",MatchSource.DOCS,doc/guide/dynamics/dynamics-bloch-redfield.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst
Integrability,depend,depends,"interaction Hamiltonian. The most general form of a master equation for the system dynamics is obtained by tracing out the bath from the von-Neumann equation of motion for the combined system (:math:`\dot\rho = -i\hbar^{-1}[H, \rho]`). In the interaction picture the result is. .. math::; :label: br-nonmarkovian-form-one. \frac{d}{dt}\rho_S(t) = - \hbar^{-2}\int_0^t d\tau\; {\rm Tr}_B [H_I(t), [H_I(\tau), \rho_S(\tau)\otimes\rho_B]],. where the additional assumption that the total system-bath density matrix can be factorized as :math:`\rho(t) \approx \rho_S(t) \otimes \rho_B`.; This assumption is known as the Born approximation, and it implies that there never is any entanglement between the system and the bath, neither in the initial state nor at any time during the evolution.; *It is justified for weak system-bath interaction.*. The master equation :eq:`br-nonmarkovian-form-one` is non-Markovian, i.e., the change in the density matrix at a time :math:`t` depends on states at all times :math:`\tau < t`, making it intractable to solve both theoretically and numerically.; To make progress towards a manageable master equation, we now introduce the Markovian approximation, in which :math:`\rho_S(\tau)` is replaced by :math:`\rho_S(t)` in Eq. :eq:`br-nonmarkovian-form-one`.; The result is the Redfield equation. .. math::; :label: br-nonmarkovian-form-two. \frac{d}{dt}\rho_S(t) = - \hbar^{-2}\int_0^t d\tau\; {\rm Tr}_B [H_I(t), [H_I(\tau), \rho_S(t)\otimes\rho_B]],. which is local in time with respect the density matrix, but still not Markovian since it contains an implicit dependence on the initial state. By extending the integration to infinity and substituting :math:`\tau \rightarrow t-\tau`, a fully Markovian master equation is obtained:. .. math::; :label: br-markovian-form. \frac{d}{dt}\rho_S(t) = - \hbar^{-2}\int_0^\infty d\tau\; {\rm Tr}_B [H_I(t), [H_I(t-\tau), \rho_S(t)\otimes\rho_B]]. The two Markovian approximations introduced above are valid if the time-scale",MatchSource.DOCS,doc/guide/dynamics/dynamics-bloch-redfield.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst
Modifiability,coupling,coupling,"rators (collapse operators) describe phenomenological processes, such as for example dephasing and spin flips, and the rates of these processes are arbitrary parameters in the model.; In many situations the collapse operators and their corresponding rates have clear physical interpretation, such as dephasing and relaxation rates, and in those cases the Lindblad master equation is usually the method of choice. However, in some cases, for example systems with varying energy biases and eigenstates and that couple to an environment in some well-defined manner (through a physically motivated system-environment interaction operator), it is often desirable to derive the master equation from more fundamental physical principles, and relate it to for example the noise-power spectrum of the environment. The Bloch-Redfield formalism is one such approach to derive a master equation from a microscopic system.; It starts from a combined system-environment perspective, and derives a perturbative master equation for the system alone, under the assumption of weak system-environment coupling.; One advantage of this approach is that the dissipation processes and rates are obtained directly from the properties of the environment.; On the downside, it does not intrinsically guarantee that the resulting master equation unconditionally preserves the physical properties of the density matrix (because it is a perturbative method).; The Bloch-Redfield master equation must therefore be used with care, and the assumptions made in the derivation must be honored.; (The Lindblad master equation is in a sense more robust -- it always results in a physical density matrix -- although some collapse operators might not be physically justified).; For a full derivation of the Bloch Redfield master equation, see e.g. [Coh92]_ or [Bre02]_.; Here we present only a brief version of the derivation, with the intention of introducing the notation and how it relates to the implementation in QuTiP. .. _bloch-red",MatchSource.DOCS,doc/guide/dynamics/dynamics-bloch-redfield.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst
Performance,scalab,scalability,"ll be neglected.; Its default value is 0.1 which corresponds to the secular approximation.; For example the command; ::. output = brmesolve(H, psi0, tlist, a_ops=[[sigmax(), ohmic_spectrum]],; e_ops=e_ops, sec_cutoff=-1). will simulate the same example as above without the secular approximation.; Note that using the non-secular version may lead to negativity issues. .. _td-bloch-redfield:. Time-dependent Bloch-Redfield Dynamics; =======================================. If you have not done so already, please read the section: :ref:`time`. As we have already discussed, the Bloch-Redfield master equation requires transforming; into the eigenbasis of the system Hamiltonian.; For time-independent systems, this transformation need only be done once.; However, for time-dependent systems, one must move to the instantaneous eigenbasis; at each time-step in the evolution, thus greatly increasing the computational complexity of the dynamics.; In addition, the requirement for computing all the eigenvalues severely limits the scalability of the method.; Fortunately, this eigen decomposition occurs at the Hamiltonian level, as opposed to the; super-operator level, and thus, with efficient programming, one can tackle many systems that are commonly encountered. For time-dependent Hamiltonians, the Hamiltonian itself can be passed into the solver; like any other time dependent Hamiltonian, as thus we will not discuss this topic further.; Instead, here the focus is on time-dependent bath coupling terms.; To this end, suppose that we have a dissipative harmonic oscillator, where the white-noise; dissipation rate decreases exponentially with time :math:`\kappa(t) = \kappa(0)\exp(-t)`.; In the Lindblad or Monte Carlo solvers, this could be implemented as a time-dependent; collapse operator list ``c_ops = [[a, 'sqrt(kappa*exp(-t))']]``.; In the Bloch-Redfield solver, the bath coupling terms must be Hermitian.; As such, in this example, our coupling operator is the position operator ``a+a",MatchSource.DOCS,doc/guide/dynamics/dynamics-bloch-redfield.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst
Testability,test,testcode,"-; A^\alpha_{ac} A^\alpha_{db} S_{\alpha}(\omega_{ca}); \right. \nonumber\\; +; \left.; \delta_{ac}\sum_n A^\alpha_{dn}A^\alpha_{nb} S_{\alpha}(\omega_{dn}); -; A^\alpha_{ac}A^\alpha_{db} S_{\alpha}(\omega_{db}); \right\}. .. _bloch-redfield-qutip:. Bloch-Redfield master equation in QuTiP; =======================================. In QuTiP, the Bloch-Redfield tensor Eq. :eq:`br-tensor` can be calculated using the function :func:`.bloch_redfield_tensor`.; It takes two mandatory arguments: The system Hamiltonian :math:`H`, a nested list of operator; :math:`A_\alpha`, spectral density functions :math:`S_\alpha(\omega)` pairs that characterize the coupling between system and bath.; The spectral density functions are Python callback functions that takes the (angular) frequency as a single argument. To illustrate how to calculate the Bloch-Redfield tensor, let's consider a two-level atom. .. math::; :label: qubit. H = -\frac{1}{2}\Delta\sigma_x - \frac{1}{2}\epsilon_0\sigma_z. .. testcode:: [dynamics-br]. delta = 0.2 * 2*np.pi; eps0 = 1.0 * 2*np.pi; gamma1 = 0.5. H = - delta/2.0 * sigmax() - eps0/2.0 * sigmaz(). def ohmic_spectrum(w):; if w == 0.0: # dephasing inducing noise; return gamma1; else: # relaxation inducing noise; return gamma1 / 2 * (w / (2 * np.pi)) * (w > 0.0). R, ekets = bloch_redfield_tensor(H, a_ops=[[sigmax(), ohmic_spectrum]]). print(R). **Output**:. .. testoutput:: [dynamics-br]. Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = False; Qobj data =; [[ 0. +0.j 0. +0.j 0. +0.j; 0.24514517+0.j ]; [ 0. +0.j -0.16103412-6.4076169j 0. +0.j; 0. +0.j ]; [ 0. +0.j 0. +0.j -0.16103412+6.4076169j; 0. +0.j ]; [ 0. +0.j 0. +0.j 0. +0.j; -0.24514517+0.j ]]. Note that it is also possible to add Lindblad dissipation superoperators in the; Bloch-Refield tensor by passing the operators via the ``c_ops`` keyword argument; like you would in the :func:`.mesolve` or :func:`.mcsolve` functions.; For convenience, the function :func:`.bloch",MatchSource.DOCS,doc/guide/dynamics/dynamics-bloch-redfield.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst
Usability,clear,clear,".. _bloch_redfield:. ******************************; Bloch-Redfield master equation; ******************************. .. plot::; :context: reset; :include-source: False. import pylab as plt; from scipy import *; from qutip import *; import numpy as np. .. _bloch-redfield-intro:. Introduction; ============. The Lindblad master equation introduced earlier is constructed so that it describes a physical evolution of the density matrix (i.e., trace and positivity preserving), but it does not provide a connection to any underlying microscopic physical model.; The Lindblad operators (collapse operators) describe phenomenological processes, such as for example dephasing and spin flips, and the rates of these processes are arbitrary parameters in the model.; In many situations the collapse operators and their corresponding rates have clear physical interpretation, such as dephasing and relaxation rates, and in those cases the Lindblad master equation is usually the method of choice. However, in some cases, for example systems with varying energy biases and eigenstates and that couple to an environment in some well-defined manner (through a physically motivated system-environment interaction operator), it is often desirable to derive the master equation from more fundamental physical principles, and relate it to for example the noise-power spectrum of the environment. The Bloch-Redfield formalism is one such approach to derive a master equation from a microscopic system.; It starts from a combined system-environment perspective, and derives a perturbative master equation for the system alone, under the assumption of weak system-environment coupling.; One advantage of this approach is that the dissipation processes and rates are obtained directly from the properties of the environment.; On the downside, it does not intrinsically guarantee that the resulting master equation unconditionally preserves the physical properties of the density matrix (because it is a perturbative metho",MatchSource.DOCS,doc/guide/dynamics/dynamics-bloch-redfield.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-bloch-redfield.rst
Deployability,update,updated," = [a.dag() * a, sm.dag() * sm]; H = QobjEvo(; [a.dag()*a + sm.dag()*sm, [(sm*a.dag() + sm.dag()*a), lambda t, A: A]],; args={""A"": 0.5*np.pi}; ). solver = MESolver(H, c_ops=[np.sqrt(0.1) * a], options={""atol"": 1e-8}); solver.options[""normalize_output""] = True; psi0 = tensor(fock(2, 0), fock(10, 5)); data1 = solver.run(psi0, times, e_ops=e_ops); psi1 = tensor(fock(2, 0), coherent(10, 2 - 1j)); data2 = solver.run(psi1, times, e_ops=e_ops). plt.figure(); plt.plot(times, data1.expect[0], ""b"", times, data1.expect[1], ""r"", lw=2); plt.plot(times, data2.expect[0], 'b--', times, data2.expect[1], 'r--', lw=2); plt.title('Master Equation time evolution'); plt.xlabel('Time', fontsize=14); plt.ylabel('Expectation values', fontsize=14); plt.legend((""cavity photon number"", ""atom excitation probability"")); plt.show(). Note that as shown, options can be set at initialization or with the; ``options`` property. The simulation parameters, the ``args`` of the :class:`.QobjEvo` passed as system; operators, can be updated at the start of a run:. .. plot::; :context: close-figs. data1 = solver.run(psi0, times, e_ops=e_ops); data2 = solver.run(psi0, times, e_ops=e_ops, args={""A"": 0.25*np.pi}); data3 = solver.run(psi0, times, e_ops=e_ops, args={""A"": 0.125*np.pi}). plt.figure(); plt.plot(times, data1.expect[0], label=""A=pi/2""); plt.plot(times, data2.expect[0], label=""A=pi/4""); plt.plot(times, data3.expect[0], label=""A=pi/8""); plt.title('Master Equation time evolution'); plt.xlabel('Time', fontsize=14); plt.ylabel('Expectation values', fontsize=14); plt.legend(); plt.show(). Stepping through the run; ------------------------. The solver class also allows to run through a simulation one step at a time, updating; args at each step:. .. plot::; :context: close-figs. data = [5.]; solver.start(state0=psi0, t0=times[0]); for t in times[1:]:; psi_t = solver.step(t, args={""A"": np.pi*np.exp(-(t-3)**2)}); data.append(expect(e_ops[0], psi_t)). plt.figure(); plt.plot(times, data); plt.title('Master Equati",MatchSource.DOCS,doc/guide/dynamics/dynamics-class.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-class.rst
Integrability,interface,interface,".. _solver_class:. *******************************************; Solver Class Interface; *******************************************. In QuTiP version 5 and later, solvers such as :func:`.mesolve`, :func:`.mcsolve` also have; a class interface. The class interface allows reusing the Hamiltonian and fine tuning; many details of how the solver is run. Examples of some of the solver class features are given below. Reusing Hamiltonian Data; ------------------------. There are many cases where one would like to study multiple evolutions of; the same quantum system, whether by changing the initial state or other parameters.; In order to evolve a given system as fast as possible, the solvers in QuTiP; take the given input operators (Hamiltonian, collapse operators, etc) and prepare; them for use with the selected ODE solver. These operations are usually reasonably fast, but for some solvers, such as; :func:`.brmesolve` or :func:`.fmmesolve`, the overhead can be significant.; Even for simpler solvers, the time spent organizing data can become appreciable; when repeatedly solving a system. The class interface allows us to setup the system once and reuse it with various; parameters. Most ``...solve`` function have a paired ``...Solver`` class, with a; ``..Solver.run`` method to run the evolution. At class; instance creation, the physics (``H``, ``c_ops``, ``a_ops``, etc.) and options; are passed. The initial state, times and expectation operators are only passed; when calling ``run``:. .. plot::; :context: close-figs. times = np.linspace(0.0, 6.0, 601); a = tensor(qeye(2), destroy(10)); sm = tensor(destroy(2), qeye(10)); e_ops = [a.dag() * a, sm.dag() * sm]; H = QobjEvo(; [a.dag()*a + sm.dag()*sm, [(sm*a.dag() + sm.dag()*a), lambda t, A: A]],; args={""A"": 0.5*np.pi}; ). solver = MESolver(H, c_ops=[np.sqrt(0.1) * a], options={""atol"": 1e-8}); solver.options[""normalize_output""] = True; psi0 = tensor(fock(2, 0), fock(10, 5)); data1 = solver.run(psi0, times, e_ops=e_ops); psi1 = tens",MatchSource.DOCS,doc/guide/dynamics/dynamics-class.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-class.rst
Modifiability,evolve,evolve,".. _solver_class:. *******************************************; Solver Class Interface; *******************************************. In QuTiP version 5 and later, solvers such as :func:`.mesolve`, :func:`.mcsolve` also have; a class interface. The class interface allows reusing the Hamiltonian and fine tuning; many details of how the solver is run. Examples of some of the solver class features are given below. Reusing Hamiltonian Data; ------------------------. There are many cases where one would like to study multiple evolutions of; the same quantum system, whether by changing the initial state or other parameters.; In order to evolve a given system as fast as possible, the solvers in QuTiP; take the given input operators (Hamiltonian, collapse operators, etc) and prepare; them for use with the selected ODE solver. These operations are usually reasonably fast, but for some solvers, such as; :func:`.brmesolve` or :func:`.fmmesolve`, the overhead can be significant.; Even for simpler solvers, the time spent organizing data can become appreciable; when repeatedly solving a system. The class interface allows us to setup the system once and reuse it with various; parameters. Most ``...solve`` function have a paired ``...Solver`` class, with a; ``..Solver.run`` method to run the evolution. At class; instance creation, the physics (``H``, ``c_ops``, ``a_ops``, etc.) and options; are passed. The initial state, times and expectation operators are only passed; when calling ``run``:. .. plot::; :context: close-figs. times = np.linspace(0.0, 6.0, 601); a = tensor(qeye(2), destroy(10)); sm = tensor(destroy(2), qeye(10)); e_ops = [a.dag() * a, sm.dag() * sm]; H = QobjEvo(; [a.dag()*a + sm.dag()*sm, [(sm*a.dag() + sm.dag()*a), lambda t, A: A]],; args={""A"": 0.5*np.pi}; ). solver = MESolver(H, c_ops=[np.sqrt(0.1) * a], options={""atol"": 1e-8}); solver.options[""normalize_output""] = True; psi0 = tensor(fock(2, 0), fock(10, 5)); data1 = solver.run(psi0, times, e_ops=e_ops); psi1 = tens",MatchSource.DOCS,doc/guide/dynamics/dynamics-class.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-class.rst
Performance,perform,performance,"show(). Stepping through the run; ------------------------. The solver class also allows to run through a simulation one step at a time, updating; args at each step:. .. plot::; :context: close-figs. data = [5.]; solver.start(state0=psi0, t0=times[0]); for t in times[1:]:; psi_t = solver.step(t, args={""A"": np.pi*np.exp(-(t-3)**2)}); data.append(expect(e_ops[0], psi_t)). plt.figure(); plt.plot(times, data); plt.title('Master Equation time evolution'); plt.xlabel('Time', fontsize=14); plt.ylabel('Expectation values', fontsize=14); plt.legend((""cavity photon number"")); plt.show(). .. note::. This is an example only, updating a constant ``args`` parameter between step; should not replace using a function as QobjEvo's coefficient. .. note::. It is possible to create multiple solvers and to advance them using ``step`` in; parallel. However, many ODE solver, including the default ``adams`` method, only; allow one instance at a time per process. QuTiP supports using multiple solver instances; of these ODE solvers but with a performance cost. In these situations, using; ``dop853`` or ``vern9`` integration method is recommended instead. Feedback: Accessing the solver state from evolution operators; =============================================================. The state of the system during the evolution is accessible via properties of the solver classes. Each solver has a ``StateFeedback`` and ``ExpectFeedback`` class method that can; be passed as arguments to time dependent systems. For example, ``ExpectFeedback``; can be used to create a system which uncouples when there are 5 or fewer photons in the; cavity. .. plot::; :context: close-figs. def f(t, e1):; ex = (e1.real - 5); return (ex > 0) * ex * 10. times = np.linspace(0.0, 1.0, 301); a = tensor(qeye(2), destroy(10)); sm = tensor(destroy(2), qeye(10)); e_ops = [a.dag() * a, sm.dag() * sm]; psi0 = tensor(fock(2, 0), fock(10, 8)); e_ops = [a.dag() * a, sm.dag() * sm]. H = [a*a.dag(), [sm*a.dag() + sm.dag()*a, f]]; data = ",MatchSource.DOCS,doc/guide/dynamics/dynamics-class.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-class.rst
Security,access,accessible,"xp(-(t-3)**2)}); data.append(expect(e_ops[0], psi_t)). plt.figure(); plt.plot(times, data); plt.title('Master Equation time evolution'); plt.xlabel('Time', fontsize=14); plt.ylabel('Expectation values', fontsize=14); plt.legend((""cavity photon number"")); plt.show(). .. note::. This is an example only, updating a constant ``args`` parameter between step; should not replace using a function as QobjEvo's coefficient. .. note::. It is possible to create multiple solvers and to advance them using ``step`` in; parallel. However, many ODE solver, including the default ``adams`` method, only; allow one instance at a time per process. QuTiP supports using multiple solver instances; of these ODE solvers but with a performance cost. In these situations, using; ``dop853`` or ``vern9`` integration method is recommended instead. Feedback: Accessing the solver state from evolution operators; =============================================================. The state of the system during the evolution is accessible via properties of the solver classes. Each solver has a ``StateFeedback`` and ``ExpectFeedback`` class method that can; be passed as arguments to time dependent systems. For example, ``ExpectFeedback``; can be used to create a system which uncouples when there are 5 or fewer photons in the; cavity. .. plot::; :context: close-figs. def f(t, e1):; ex = (e1.real - 5); return (ex > 0) * ex * 10. times = np.linspace(0.0, 1.0, 301); a = tensor(qeye(2), destroy(10)); sm = tensor(destroy(2), qeye(10)); e_ops = [a.dag() * a, sm.dag() * sm]; psi0 = tensor(fock(2, 0), fock(10, 8)); e_ops = [a.dag() * a, sm.dag() * sm]. H = [a*a.dag(), [sm*a.dag() + sm.dag()*a, f]]; data = mesolve(H, psi0, times, c_ops=[a], e_ops=e_ops,; args={""e1"": MESolver.ExpectFeedback(a.dag() * a)}; ).expect. plt.figure(); plt.plot(times, data[0]); plt.plot(times, data[1]); plt.title('Master Equation time evolution'); plt.xlabel('Time', fontsize=14); plt.ylabel('Expectation values', fontsize=14); plt.legend((""cavit",MatchSource.DOCS,doc/guide/dynamics/dynamics-class.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-class.rst
Usability,simpl,simpler,"************************; Solver Class Interface; *******************************************. In QuTiP version 5 and later, solvers such as :func:`.mesolve`, :func:`.mcsolve` also have; a class interface. The class interface allows reusing the Hamiltonian and fine tuning; many details of how the solver is run. Examples of some of the solver class features are given below. Reusing Hamiltonian Data; ------------------------. There are many cases where one would like to study multiple evolutions of; the same quantum system, whether by changing the initial state or other parameters.; In order to evolve a given system as fast as possible, the solvers in QuTiP; take the given input operators (Hamiltonian, collapse operators, etc) and prepare; them for use with the selected ODE solver. These operations are usually reasonably fast, but for some solvers, such as; :func:`.brmesolve` or :func:`.fmmesolve`, the overhead can be significant.; Even for simpler solvers, the time spent organizing data can become appreciable; when repeatedly solving a system. The class interface allows us to setup the system once and reuse it with various; parameters. Most ``...solve`` function have a paired ``...Solver`` class, with a; ``..Solver.run`` method to run the evolution. At class; instance creation, the physics (``H``, ``c_ops``, ``a_ops``, etc.) and options; are passed. The initial state, times and expectation operators are only passed; when calling ``run``:. .. plot::; :context: close-figs. times = np.linspace(0.0, 6.0, 601); a = tensor(qeye(2), destroy(10)); sm = tensor(destroy(2), qeye(10)); e_ops = [a.dag() * a, sm.dag() * sm]; H = QobjEvo(; [a.dag()*a + sm.dag()*sm, [(sm*a.dag() + sm.dag()*a), lambda t, A: A]],; args={""A"": 0.5*np.pi}; ). solver = MESolver(H, c_ops=[np.sqrt(0.1) * a], options={""atol"": 1e-8}); solver.options[""normalize_output""] = True; psi0 = tensor(fock(2, 0), fock(10, 5)); data1 = solver.run(psi0, times, e_ops=e_ops); psi1 = tensor(fock(2, 0), coherent(10, 2 - 1j));",MatchSource.DOCS,doc/guide/dynamics/dynamics-class.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-class.rst
Availability,avail,available,"es Solver Results; ====================================. Solver which compute multiple trajectories such as the Monte Carlo Equations; Solvers or the Stochastics Solvers result will differ depending on whether the; trajectories are flags to be saved.; For example:. .. doctest::; :options: +SKIP. >>> mcsolve(H, psi, np.linspace(0, 1, 11), c_ops, e_ops=[num(N)], ntraj=25, options={""keep_runs_results"": False}); >>> np.shape(result.expect); (1, 11). >>> mcsolve(H, psi, np.linspace(0, 1, 11), c_ops, e_ops=[num(N)], ntraj=25, options={""keep_runs_results"": True}); >>> np.shape(result.expect); (1, 25, 11). When the runs are not saved, the expectation values and states are averaged; over all trajectories, while a list over the runs are given when they are stored.; For a fix output format, ``average_expect`` return the average, while; ``runs_states`` return the list over trajectories. The ``runs_`` output will; return ``None`` when the trajectories are not saved. Standard derivation of the; expectation values is also available:. +-------------------------+----------------------+------------------------------------------------------------------------+; | Reduced result | Trajectories results | Description |; +=========================+======================+========================================================================+; | ``average_states`` | ``runs_states`` | State vectors or density matrices calculated at each times of tlist |; +-------------------------+----------------------+------------------------------------------------------------------------+; | ``average_final_state`` | ``runs_final_state`` | State vectors or density matrices calculated at the last time of tlist |; +-------------------------+----------------------+------------------------------------------------------------------------+; | ``average_expect`` | ``runs_expect`` | List/array of expectation values, if requested. |; +-------------------------+----------------------+------------------------------",MatchSource.DOCS,doc/guide/dynamics/dynamics-data.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-data.rst
Deployability,integrat,integration,"ata; ======================. To understand how to access the data in a Result object we will use an example; as a guide, although we do not worry about the simulation details at this stage.; Like all solvers, the Master Equation solver used in this example returns an; Result object, here called simply ``result``. To see what is contained inside; ``result`` we can use the print function:. .. doctest::; :options: +SKIP. >>> print(result); <Result; Solver: mesolve; Solver stats:; method: 'scipy zvode adams'; init time: 0.0001876354217529297; preparation time: 0.007544517517089844; run time: 0.001268625259399414; solver: 'Master Equation Evolution'; num_collapse: 1; Time interval: [0, 1.0] (2 steps); Number of e_ops: 1; State not saved.; >. The first line tells us that this data object was generated from the Master; Equation solver :func:`.mesolve`. Next we have the statistics including the ODE; solver used, setup time, number of collpases. Then the integration interval is; described, followed with the number of expectation value computed. Finally, it; says whether the states are stored. Now we have all the information needed to analyze the simulation results.; To access the data for the two expectation values one can do:. .. testcode::; :skipif: True. expt0 = result.expect[0]; expt1 = result.expect[1]. Recall that Python uses C-style indexing that begins with zero (i.e.,; [0] => 1st collapse operator data).; Alternatively, expectation values can be obtained as a dictionary:. .. testcode::; :skipif: True. e_ops = {""sx"": sigmax(), ""sy"": sigmay(), ""sz"": sigmaz()}; ...; expt_sx = result.e_data[""sx""]. When ``e_ops`` is a list, ``e_data`` ca be used with the list index. Together; with the array of times at which these expectation values are calculated:. .. testcode::; :skipif: True. times = result.times. we can plot the resulting expectation values:. .. testcode::; :skipif: True. plot(times, expt0); plot(times, expt1); show(). State vectors, or density matrices, are accessed ",MatchSource.DOCS,doc/guide/dynamics/dynamics-data.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-data.rst
Integrability,integrat,integration,"ata; ======================. To understand how to access the data in a Result object we will use an example; as a guide, although we do not worry about the simulation details at this stage.; Like all solvers, the Master Equation solver used in this example returns an; Result object, here called simply ``result``. To see what is contained inside; ``result`` we can use the print function:. .. doctest::; :options: +SKIP. >>> print(result); <Result; Solver: mesolve; Solver stats:; method: 'scipy zvode adams'; init time: 0.0001876354217529297; preparation time: 0.007544517517089844; run time: 0.001268625259399414; solver: 'Master Equation Evolution'; num_collapse: 1; Time interval: [0, 1.0] (2 steps); Number of e_ops: 1; State not saved.; >. The first line tells us that this data object was generated from the Master; Equation solver :func:`.mesolve`. Next we have the statistics including the ODE; solver used, setup time, number of collpases. Then the integration interval is; described, followed with the number of expectation value computed. Finally, it; says whether the states are stored. Now we have all the information needed to analyze the simulation results.; To access the data for the two expectation values one can do:. .. testcode::; :skipif: True. expt0 = result.expect[0]; expt1 = result.expect[1]. Recall that Python uses C-style indexing that begins with zero (i.e.,; [0] => 1st collapse operator data).; Alternatively, expectation values can be obtained as a dictionary:. .. testcode::; :skipif: True. e_ops = {""sx"": sigmax(), ""sy"": sigmay(), ""sz"": sigmaz()}; ...; expt_sx = result.e_data[""sx""]. When ``e_ops`` is a list, ``e_data`` ca be used with the list index. Together; with the array of times at which these expectation values are calculated:. .. testcode::; :skipif: True. times = result.times. we can plot the resulting expectation values:. .. testcode::; :skipif: True. plot(times, expt0); plot(times, expt1); show(). State vectors, or density matrices, are accessed ",MatchSource.DOCS,doc/guide/dynamics/dynamics-data.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-data.rst
Security,access,access,"----------------------------------------------------------------+; | ``result.expect`` | List/array of expectation values, if requested. |; +------------------------+-----------------------------------------------------------------------+; | ``result.e_data`` | Dictionary of expectation values, if requested. |; +------------------------+-----------------------------------------------------------------------+; | ``result.states`` | List/array of state vectors/density matrices calculated at ``times``, |; | | if requested. |; +------------------------+-----------------------------------------------------------------------+; | ``result.final_state`` | State vector or density matrix at the last time of the evolution. |; +------------------------+-----------------------------------------------------------------------+; | ``result.stats`` | Various statistics about the evolution. |; +------------------------+-----------------------------------------------------------------------+. .. _odedata-access:. Accessing Result Data; ======================. To understand how to access the data in a Result object we will use an example; as a guide, although we do not worry about the simulation details at this stage.; Like all solvers, the Master Equation solver used in this example returns an; Result object, here called simply ``result``. To see what is contained inside; ``result`` we can use the print function:. .. doctest::; :options: +SKIP. >>> print(result); <Result; Solver: mesolve; Solver stats:; method: 'scipy zvode adams'; init time: 0.0001876354217529297; preparation time: 0.007544517517089844; run time: 0.001268625259399414; solver: 'Master Equation Evolution'; num_collapse: 1; Time interval: [0, 1.0] (2 steps); Number of e_ops: 1; State not saved.; >. The first line tells us that this data object was generated from the Master; Equation solver :func:`.mesolve`. Next we have the statistics including the ODE; solver used, setup time, number of collpases. Then the integration ",MatchSource.DOCS,doc/guide/dynamics/dynamics-data.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-data.rst
Testability,test,testcode,"le returns an; Result object, here called simply ``result``. To see what is contained inside; ``result`` we can use the print function:. .. doctest::; :options: +SKIP. >>> print(result); <Result; Solver: mesolve; Solver stats:; method: 'scipy zvode adams'; init time: 0.0001876354217529297; preparation time: 0.007544517517089844; run time: 0.001268625259399414; solver: 'Master Equation Evolution'; num_collapse: 1; Time interval: [0, 1.0] (2 steps); Number of e_ops: 1; State not saved.; >. The first line tells us that this data object was generated from the Master; Equation solver :func:`.mesolve`. Next we have the statistics including the ODE; solver used, setup time, number of collpases. Then the integration interval is; described, followed with the number of expectation value computed. Finally, it; says whether the states are stored. Now we have all the information needed to analyze the simulation results.; To access the data for the two expectation values one can do:. .. testcode::; :skipif: True. expt0 = result.expect[0]; expt1 = result.expect[1]. Recall that Python uses C-style indexing that begins with zero (i.e.,; [0] => 1st collapse operator data).; Alternatively, expectation values can be obtained as a dictionary:. .. testcode::; :skipif: True. e_ops = {""sx"": sigmax(), ""sy"": sigmay(), ""sz"": sigmaz()}; ...; expt_sx = result.e_data[""sx""]. When ``e_ops`` is a list, ``e_data`` ca be used with the list index. Together; with the array of times at which these expectation values are calculated:. .. testcode::; :skipif: True. times = result.times. we can plot the resulting expectation values:. .. testcode::; :skipif: True. plot(times, expt0); plot(times, expt1); show(). State vectors, or density matrices, are accessed in a similar manner, although; typically one does not need an index (i.e [0]) since there is only one list for; each of these components. Some other solver can have other output,; :func:`.heomsolve`'s results can have ``ado_states`` output if the options",MatchSource.DOCS,doc/guide/dynamics/dynamics-data.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-data.rst
Usability,guid,guide," |; +------------------------+-----------------------------------------------------------------------+; | ``result.e_data`` | Dictionary of expectation values, if requested. |; +------------------------+-----------------------------------------------------------------------+; | ``result.states`` | List/array of state vectors/density matrices calculated at ``times``, |; | | if requested. |; +------------------------+-----------------------------------------------------------------------+; | ``result.final_state`` | State vector or density matrix at the last time of the evolution. |; +------------------------+-----------------------------------------------------------------------+; | ``result.stats`` | Various statistics about the evolution. |; +------------------------+-----------------------------------------------------------------------+. .. _odedata-access:. Accessing Result Data; ======================. To understand how to access the data in a Result object we will use an example; as a guide, although we do not worry about the simulation details at this stage.; Like all solvers, the Master Equation solver used in this example returns an; Result object, here called simply ``result``. To see what is contained inside; ``result`` we can use the print function:. .. doctest::; :options: +SKIP. >>> print(result); <Result; Solver: mesolve; Solver stats:; method: 'scipy zvode adams'; init time: 0.0001876354217529297; preparation time: 0.007544517517089844; run time: 0.001268625259399414; solver: 'Master Equation Evolution'; num_collapse: 1; Time interval: [0, 1.0] (2 steps); Number of e_ops: 1; State not saved.; >. The first line tells us that this data object was generated from the Master; Equation solver :func:`.mesolve`. Next we have the statistics including the ODE; solver used, setup time, number of collpases. Then the integration interval is; described, followed with the number of expectation value computed. Finally, it; says whether the states are stored. Now we h",MatchSource.DOCS,doc/guide/dynamics/dynamics-data.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-data.rst
Deployability,integrat,integration,".. _floquet:. *****************; Floquet Formalism; *****************. .. _floquet-intro:. Introduction; ============. Many time-dependent problems of interest are periodic. The dynamics of such systems can be solved for directly by numerical integration of the Schrödinger or Master equation, using the time-dependent Hamiltonian. But they can also be transformed into time-independent problems using the Floquet formalism. Time-independent problems can be solve much more efficiently, so such a transformation is often very desirable. In the standard derivations of the Lindblad and Bloch-Redfield master equations the Hamiltonian describing the system under consideration is assumed to be time independent. Thus, strictly speaking, the standard forms of these master equation formalisms should not blindly be applied to system with time-dependent Hamiltonians. However, in many relevant cases, in particular for weak driving, the standard master equations still turns out to be useful for many time-dependent problems. But a more rigorous approach would be to rederive the master equation taking the time-dependent nature of the Hamiltonian into account from the start. The Floquet-Markov Master equation is one such a formalism, with important applications for strongly driven systems (see e.g., [Gri98]_). Here we give an overview of how the Floquet and Floquet-Markov formalisms can be used for solving time-dependent problems in QuTiP. To introduce the terminology and naming conventions used in QuTiP we first give a brief summary of quantum Floquet theory. .. _floquet-unitary:. Floquet theory for unitary evolution; ====================================. The Schrödinger equation with a time-dependent Hamiltonian :math:`H(t)` is. .. math::; :label: eq_td_schrodinger. 	H(t)\Psi(t) = i\hbar\frac{\partial}{\partial t}\Psi(t),. where :math:`\Psi(t)` is the wave function solution. Here we are interested in problems with periodic time-dependence, i.e., the Hamiltonian satisfies :math:`H(t) = ",MatchSource.DOCS,doc/guide/dynamics/dynamics-floquet.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-floquet.rst
Energy Efficiency,efficient,efficiently,".. _floquet:. *****************; Floquet Formalism; *****************. .. _floquet-intro:. Introduction; ============. Many time-dependent problems of interest are periodic. The dynamics of such systems can be solved for directly by numerical integration of the Schrödinger or Master equation, using the time-dependent Hamiltonian. But they can also be transformed into time-independent problems using the Floquet formalism. Time-independent problems can be solve much more efficiently, so such a transformation is often very desirable. In the standard derivations of the Lindblad and Bloch-Redfield master equations the Hamiltonian describing the system under consideration is assumed to be time independent. Thus, strictly speaking, the standard forms of these master equation formalisms should not blindly be applied to system with time-dependent Hamiltonians. However, in many relevant cases, in particular for weak driving, the standard master equations still turns out to be useful for many time-dependent problems. But a more rigorous approach would be to rederive the master equation taking the time-dependent nature of the Hamiltonian into account from the start. The Floquet-Markov Master equation is one such a formalism, with important applications for strongly driven systems (see e.g., [Gri98]_). Here we give an overview of how the Floquet and Floquet-Markov formalisms can be used for solving time-dependent problems in QuTiP. To introduce the terminology and naming conventions used in QuTiP we first give a brief summary of quantum Floquet theory. .. _floquet-unitary:. Floquet theory for unitary evolution; ====================================. The Schrödinger equation with a time-dependent Hamiltonian :math:`H(t)` is. .. math::; :label: eq_td_schrodinger. 	H(t)\Psi(t) = i\hbar\frac{\partial}{\partial t}\Psi(t),. where :math:`\Psi(t)` is the wave function solution. Here we are interested in problems with periodic time-dependence, i.e., the Hamiltonian satisfies :math:`H(t) = ",MatchSource.DOCS,doc/guide/dynamics/dynamics-floquet.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-floquet.rst
Integrability,depend,dependent,".. _floquet:. *****************; Floquet Formalism; *****************. .. _floquet-intro:. Introduction; ============. Many time-dependent problems of interest are periodic. The dynamics of such systems can be solved for directly by numerical integration of the Schrödinger or Master equation, using the time-dependent Hamiltonian. But they can also be transformed into time-independent problems using the Floquet formalism. Time-independent problems can be solve much more efficiently, so such a transformation is often very desirable. In the standard derivations of the Lindblad and Bloch-Redfield master equations the Hamiltonian describing the system under consideration is assumed to be time independent. Thus, strictly speaking, the standard forms of these master equation formalisms should not blindly be applied to system with time-dependent Hamiltonians. However, in many relevant cases, in particular for weak driving, the standard master equations still turns out to be useful for many time-dependent problems. But a more rigorous approach would be to rederive the master equation taking the time-dependent nature of the Hamiltonian into account from the start. The Floquet-Markov Master equation is one such a formalism, with important applications for strongly driven systems (see e.g., [Gri98]_). Here we give an overview of how the Floquet and Floquet-Markov formalisms can be used for solving time-dependent problems in QuTiP. To introduce the terminology and naming conventions used in QuTiP we first give a brief summary of quantum Floquet theory. .. _floquet-unitary:. Floquet theory for unitary evolution; ====================================. The Schrödinger equation with a time-dependent Hamiltonian :math:`H(t)` is. .. math::; :label: eq_td_schrodinger. 	H(t)\Psi(t) = i\hbar\frac{\partial}{\partial t}\Psi(t),. where :math:`\Psi(t)` is the wave function solution. Here we are interested in problems with periodic time-dependence, i.e., the Hamiltonian satisfies :math:`H(t) = ",MatchSource.DOCS,doc/guide/dynamics/dynamics-floquet.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-floquet.rst
Modifiability,coupling,coupling,"ribed by the standard Lindblad master equation, since its dissipation process; could be time-dependent due to the driving. In such cases a rigorious approach would; be to take the driving into account when deriving the master equation. This can be; done in many different ways, but one way common approach is to derive the master; equation in the Floquet basis. That approach results in the so-called Floquet-Markov; master equation, see Grifoni et al., Physics Reports 304, 299 (1998) for details. For a brief summary of the derivation, the important contents for the implementation; in QuTiP are listed below. The floquet mode :math:`\ket{\phi_\alpha(t)}` refers to a full class of quasienergies; defined by :math:`\epsilon_\alpha + k \Omega` for arbitrary :math:`k`. Hence, the; quasienenergy difference between two floquet modes is given by. .. math::; \Delta_{\alpha \beta k} = \frac{\epsilon_\alpha - \epsilon_\beta}{\hbar} + k \Omega. For any coupling operator :math:`q` (given by the user) the matrix elements in; the floquet basis are calculated as:. .. math::; X_{\alpha \beta k} = \frac{1}{T} \int_0^T dt \; e^{-ik \Omega t} \bra{\phi_\alpha(t)}q\ket{\phi_\beta(t)}. From the matrix elements and the spectral density :math:`J(\omega)`, the decay; rate :math:`\gamma_{\alpha \beta k}` is defined:. .. math::; \gamma_{\alpha \beta k} = 2 \pi J(\Delta_{\alpha \beta k}) | X_{\alpha \beta k}|^2. The master equation is further simplified by the RWA, which makes the following matrix useful:. .. math::; A_{\alpha \beta} = \sum_{k = -\infty}^\infty [\gamma_{\alpha \beta k} + n_{th}(|\Delta_{\alpha \beta k}|)(\gamma_{\alpha \beta k} + \gamma_{\alpha \beta -k}). The density matrix of the system then evolves according to:. .. math::; \dot{\rho}_{\alpha \alpha}(t) = \sum_\nu (A_{\alpha \nu} \rho_{\nu \nu}(t) - A_{\nu \alpha} \rho_{\alpha \alpha} (t)). .. math::; \dot{\rho}_{\alpha \beta}(t) = -\frac{1}{2} \sum_\nu (A_{\nu \alpha} + A_{\nu \beta}) \rho_{\alpha \beta}(t) \qquad \alpha \neq \",MatchSource.DOCS,doc/guide/dynamics/dynamics-floquet.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-floquet.rst
Usability,guid,guide," original problem :eq:`eq_driven_qubit` given some initial state :math:`\left|\psi_0\right>`.; To do that, we first need to decompose the initial state in the Floquet states,; using the function :meth:`.FloquetBasis.to_floquet_basis`. .. plot::; :context: close-figs. >>> psi0 = rand_ket(2); >>> f_coeff = floquet_basis.to_floquet_basis(psi0); >>> f_coeff # doctest: +SKIP; [(-0.645265993068382+0.7304552549315746j),; (0.15517002114250228-0.1612116102238258j)]. and given this decomposition of the initial state in the Floquet states we can easily; evaluate the wavefunction that is the solution to :eq:`eq_driven_qubit` at an arbitrary; time :math:`t` using the function :meth:`.FloquetBasis.from_floquet_basis`:. .. plot::; :context: close-figs. >>> t = 10 * np.random.rand(); >>> psi_t = floquet_basis.from_floquet_basis(f_coeff, t). The following example illustrates how to use the functions introduced above to calculate; and plot the time-evolution of :eq:`eq_driven_qubit`. .. plot:: guide/scripts/floquet_ex1.py; :width: 4.0in; :include-source:. Pre-computing the Floquet modes for one period; ----------------------------------------------. When evaluating the Floquet states or the wavefunction at many points in time it; is useful to pre-compute the Floquet modes for the first period of the driving with; the required times. The list of times to pre-compute modes for may be passed to; :class:`.FloquetBasis` using ``precompute=tlist``, and then; :meth:`.FloquetBasis.from_floquet_basis` and :meth:`.FloquetBasis.to_floquet_basis`; can be used to efficiently retrieve the wave function at the pre-computed times.; The following example illustrates how the example from the previous section can be; solved more efficiently using these functions for pre-computing the Floquet modes:. .. plot:: guide/scripts/floquet_ex2.py; :width: 4.0in; :include-source:. Note that the parameters and the Hamiltonian used in this example is not the same as; in the previous section, and hence the differen",MatchSource.DOCS,doc/guide/dynamics/dynamics-floquet.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-floquet.rst
Modifiability,evolve,evolves,".. _intro:. ************; Introduction; ************. Although in some cases, we want to find the stationary states of; a quantum system, often we are interested in the dynamics:; how the state of a system or an ensemble of systems evolves with time.; QuTiP provides many ways to model dynamics. There are two kinds of quantum systems: open systems that interact; with a larger environment and closed systems that do not.; In a closed system, the state can be described by a state vector.; When we are modeling an open system, or an ensemble of systems,; the use of the density matrix is mandatory. The following table lists of the solvers QuTiP provides for dynamic; quantum systems and indicates the type of object returned by the solver:. .. list-table:: QuTiP Solvers; :widths: 50 25 25 25; :header-rows: 1. * - Equation; - Function; - Class; - Returns; * - Unitary evolution, Schrödinger equation.; - :func:`~qutip.solver.sesolve.sesolve`; - :obj:`~qutip.solver.sesolve.SESolver`; - :obj:`~qutip.solver.result.Result`; * - Periodic Schrödinger equation.; - :func:`~qutip.solver.floquet.fsesolve`; - None; - :obj:`~qutip.solver.result.Result`; * - Schrödinger equation using Krylov method; - :func:`~qutip.solver.krylovsolve.krylovsolve`; - None; - :obj:`~qutip.solver.result.Result`; * - Lindblad master eqn. or Von Neuman eqn.; - :func:`~qutip.solver.mesolve.mesolve`; - :obj:`~qutip.solver.mesolve.MESolver`; - :obj:`~qutip.solver.result.Result`; * - Monte Carlo evolution; - :func:`~qutip.solver.mcsolve.mcsolve`; - :obj:`~qutip.solver.mcsolve.MCSolver`; - :obj:`~qutip.solver.result.McResult`; * - Non-Markovian Monte Carlo; - :func:`~qutip.solver.nm_mcsolve.nm_mcsolve`; - :obj:`~qutip.solver.nm_mcsolve.NonMarkovianMCSolver`; - :obj:`~qutip.solver.result.NmmcResult`; * - Bloch-Redfield master equation; - :func:`~qutip.solver.mesolve.brmesolve`; - :obj:`~qutip.solver.mesolve.BRSolver`; - :obj:`~qutip.solver.result.Result`; * - Floquet-Markov master equation; - :func:`~qutip.solver.floqu",MatchSource.DOCS,doc/guide/dynamics/dynamics-intro.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-intro.rst
Availability,error,error,"ly for the last; two vectors in the basis. Written in this basis the time-evolved state can be approximated as. .. math::; 	:label: lanczoskrylov. 	|\psi(t)\rangle=e^{-iHt}|\psi\rangle\approx\mathbb{P}_{N}e^{-iHt}\mathbb{P}_{N}|\psi\rangle=\mathbb{V}_{N}^{\dagger}e^{-iT_{N}t}\mathbb{V}_{N}|\psi\rangle\equiv\left|\psi_{N}(t)\right\rangle,. where :math:`T_{N}=\mathbb{V}_{N} H \mathbb{V}_{N}^{\dagger}` is the Hamiltonian; reduced to the Krylov subspace (which takes a tridiagonal matrix form), and; :math:`\mathbb{V}_{N}^{\dagger}` is the matrix containing the vectors of the; Krylov basis as columns. With the above approximation, the time-evolution is calculated only with a; smaller square matrix of the desired size. Therefore, the Krylov method provides; huge speed-ups in computation of short-time evolutions when the dimension of the; Hamiltonian is very large, a point at which exact calculations on the complete; subspace are practically impossible. One of the biggest problems with this type of method is the control of the error.; After a short time, the error starts to grow exponentially. However, this can be; easily corrected by restarting the subspace when the error reaches a certain; threshold. Therefore, a series of :math:`M` Krylov-subspace time evolutions; provides accurate solutions for the complete time evolution. Within this scheme,; the magic of Krylov resides not only in its ability to capture complex time evolutions; from very large Hilbert spaces with very small dimenions :math:`M`, but also in; the computing speed-up it presents. For exceptional cases, the Lanczos algorithm might arrive at the exact evolution; of the initial state at a dimension :math:`M_{hb}<M`. This is called a happy; breakdown. For example, if a Hamiltonian has a symmetry subspace :math:`D_{\text{sim}}<M`,; then the algorithm will optimize using the value math:`M_{hb}<M`:, at which the; evolution is not only exact but also cheap. .. _krylov-qutip:. Krylov Solver in QuTiP; =============",MatchSource.DOCS,doc/guide/dynamics/dynamics-krylov.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-krylov.rst
Energy Efficiency,reduce,reduced,"ov subspace associated with that state and; Hamiltonian is given by. .. math::; 	:label: krylovsubspace. 	\mathcal{K}_{N}=\operatorname{span}\left\{|\psi\rangle, H|\psi\rangle, \ldots, H^{N-1}|\psi\rangle\right\},. where the dimension :math:`N<D` is a parameter of choice. To construct an; orthonormal basis :math:`B_N` for :math:`\mathcal{K}_{N}`, the simplest algorithm; is the well-known Lanczos algorithm, which provides a sort of Gram-Schmidt procedure; that harnesses the fact that orthonormalization needs to be imposed only for the last; two vectors in the basis. Written in this basis the time-evolved state can be approximated as. .. math::; 	:label: lanczoskrylov. 	|\psi(t)\rangle=e^{-iHt}|\psi\rangle\approx\mathbb{P}_{N}e^{-iHt}\mathbb{P}_{N}|\psi\rangle=\mathbb{V}_{N}^{\dagger}e^{-iT_{N}t}\mathbb{V}_{N}|\psi\rangle\equiv\left|\psi_{N}(t)\right\rangle,. where :math:`T_{N}=\mathbb{V}_{N} H \mathbb{V}_{N}^{\dagger}` is the Hamiltonian; reduced to the Krylov subspace (which takes a tridiagonal matrix form), and; :math:`\mathbb{V}_{N}^{\dagger}` is the matrix containing the vectors of the; Krylov basis as columns. With the above approximation, the time-evolution is calculated only with a; smaller square matrix of the desired size. Therefore, the Krylov method provides; huge speed-ups in computation of short-time evolutions when the dimension of the; Hamiltonian is very large, a point at which exact calculations on the complete; subspace are practically impossible. One of the biggest problems with this type of method is the control of the error.; After a short time, the error starts to grow exponentially. However, this can be; easily corrected by restarting the subspace when the error reaches a certain; threshold. Therefore, a series of :math:`M` Krylov-subspace time evolutions; provides accurate solutions for the complete time evolution. Within this scheme,; the magic of Krylov resides not only in its ability to capture complex time evolutions; from very large Hilbe",MatchSource.DOCS,doc/guide/dynamics/dynamics-krylov.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-krylov.rst
Integrability,depend,depend,"hen the error reaches a certain; threshold. Therefore, a series of :math:`M` Krylov-subspace time evolutions; provides accurate solutions for the complete time evolution. Within this scheme,; the magic of Krylov resides not only in its ability to capture complex time evolutions; from very large Hilbert spaces with very small dimenions :math:`M`, but also in; the computing speed-up it presents. For exceptional cases, the Lanczos algorithm might arrive at the exact evolution; of the initial state at a dimension :math:`M_{hb}<M`. This is called a happy; breakdown. For example, if a Hamiltonian has a symmetry subspace :math:`D_{\text{sim}}<M`,; then the algorithm will optimize using the value math:`M_{hb}<M`:, at which the; evolution is not only exact but also cheap. .. _krylov-qutip:. Krylov Solver in QuTiP; ======================. In QuTiP, Krylov-subspace evolution is implemented as the function :func:`.krylovsolve`.; Arguments are nearly the same as :func:`.sesolve` function for master-equation; evolution, except that the Hamiltonian cannot depend on time, the initial state; must always be a ket vector, (it cannot be used to compute propagators) and an; additional parameter ``krylov_dim`` is needed. ``krylov_dim`` defines the; maximum allowed Krylov-subspace dimension. Let's solve a simple example using the algorithm in QuTiP to get familiar with the method. .. plot::; :context: reset. >>> dim = 100; >>> jx = jmat((dim - 1) / 2.0, ""x""); >>> jy = jmat((dim - 1) / 2.0, ""y""); >>> jz = jmat((dim - 1) / 2.0, ""z""); >>> e_ops = [jx, jy, jz]; >>> H = (jz + jx) / 2; >>> psi0 = rand_ket(dim, seed=1); >>> tlist = np.linspace(0.0, 10.0, 200); >>> results = krylovsolve(H, psi0, tlist, krylov_dim=20, e_ops=e_ops); >>> plt.figure(); >>> for expect in results.expect:; >>> plt.plot(tlist, expect); >>> plt.legend(('jmat x', 'jmat y', 'jmat z')); >>> plt.xlabel('Time'); >>> plt.ylabel('Expectation values'); >>> plt.show(). .. plot::; :context: reset; :include-source: false; :nofigs:; ",MatchSource.DOCS,doc/guide/dynamics/dynamics-krylov.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-krylov.rst
Modifiability,evolve,evolves,".. _krylov:. *******************************************; Krylov Solver; *******************************************. .. _krylov-intro:. Introduction; =============. The Krylov-subspace method is a standard method to approximate quantum dynamics.; Let :math:`\left|\psi\right\rangle` be a state in a :math:`D`-dimensional; complex Hilbert space that evolves under a time-independent Hamiltonian :math:`H`.; Then, the :math:`N`-dimensional Krylov subspace associated with that state and; Hamiltonian is given by. .. math::; 	:label: krylovsubspace. 	\mathcal{K}_{N}=\operatorname{span}\left\{|\psi\rangle, H|\psi\rangle, \ldots, H^{N-1}|\psi\rangle\right\},. where the dimension :math:`N<D` is a parameter of choice. To construct an; orthonormal basis :math:`B_N` for :math:`\mathcal{K}_{N}`, the simplest algorithm; is the well-known Lanczos algorithm, which provides a sort of Gram-Schmidt procedure; that harnesses the fact that orthonormalization needs to be imposed only for the last; two vectors in the basis. Written in this basis the time-evolved state can be approximated as. .. math::; 	:label: lanczoskrylov. 	|\psi(t)\rangle=e^{-iHt}|\psi\rangle\approx\mathbb{P}_{N}e^{-iHt}\mathbb{P}_{N}|\psi\rangle=\mathbb{V}_{N}^{\dagger}e^{-iT_{N}t}\mathbb{V}_{N}|\psi\rangle\equiv\left|\psi_{N}(t)\right\rangle,. where :math:`T_{N}=\mathbb{V}_{N} H \mathbb{V}_{N}^{\dagger}` is the Hamiltonian; reduced to the Krylov subspace (which takes a tridiagonal matrix form), and; :math:`\mathbb{V}_{N}^{\dagger}` is the matrix containing the vectors of the; Krylov basis as columns. With the above approximation, the time-evolution is calculated only with a; smaller square matrix of the desired size. Therefore, the Krylov method provides; huge speed-ups in computation of short-time evolutions when the dimension of the; Hamiltonian is very large, a point at which exact calculations on the complete; subspace are practically impossible. One of the biggest problems with this type of method is the control o",MatchSource.DOCS,doc/guide/dynamics/dynamics-krylov.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-krylov.rst
Performance,optimiz,optimize,"e; Hamiltonian is very large, a point at which exact calculations on the complete; subspace are practically impossible. One of the biggest problems with this type of method is the control of the error.; After a short time, the error starts to grow exponentially. However, this can be; easily corrected by restarting the subspace when the error reaches a certain; threshold. Therefore, a series of :math:`M` Krylov-subspace time evolutions; provides accurate solutions for the complete time evolution. Within this scheme,; the magic of Krylov resides not only in its ability to capture complex time evolutions; from very large Hilbert spaces with very small dimenions :math:`M`, but also in; the computing speed-up it presents. For exceptional cases, the Lanczos algorithm might arrive at the exact evolution; of the initial state at a dimension :math:`M_{hb}<M`. This is called a happy; breakdown. For example, if a Hamiltonian has a symmetry subspace :math:`D_{\text{sim}}<M`,; then the algorithm will optimize using the value math:`M_{hb}<M`:, at which the; evolution is not only exact but also cheap. .. _krylov-qutip:. Krylov Solver in QuTiP; ======================. In QuTiP, Krylov-subspace evolution is implemented as the function :func:`.krylovsolve`.; Arguments are nearly the same as :func:`.sesolve` function for master-equation; evolution, except that the Hamiltonian cannot depend on time, the initial state; must always be a ket vector, (it cannot be used to compute propagators) and an; additional parameter ``krylov_dim`` is needed. ``krylov_dim`` defines the; maximum allowed Krylov-subspace dimension. Let's solve a simple example using the algorithm in QuTiP to get familiar with the method. .. plot::; :context: reset. >>> dim = 100; >>> jx = jmat((dim - 1) / 2.0, ""x""); >>> jy = jmat((dim - 1) / 2.0, ""y""); >>> jz = jmat((dim - 1) / 2.0, ""z""); >>> e_ops = [jx, jy, jz]; >>> H = (jz + jx) / 2; >>> psi0 = rand_ket(dim, seed=1); >>> tlist = np.linspace(0.0, 10.0, 200); >>> results",MatchSource.DOCS,doc/guide/dynamics/dynamics-krylov.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-krylov.rst
Usability,simpl,simplest,".. _krylov:. *******************************************; Krylov Solver; *******************************************. .. _krylov-intro:. Introduction; =============. The Krylov-subspace method is a standard method to approximate quantum dynamics.; Let :math:`\left|\psi\right\rangle` be a state in a :math:`D`-dimensional; complex Hilbert space that evolves under a time-independent Hamiltonian :math:`H`.; Then, the :math:`N`-dimensional Krylov subspace associated with that state and; Hamiltonian is given by. .. math::; 	:label: krylovsubspace. 	\mathcal{K}_{N}=\operatorname{span}\left\{|\psi\rangle, H|\psi\rangle, \ldots, H^{N-1}|\psi\rangle\right\},. where the dimension :math:`N<D` is a parameter of choice. To construct an; orthonormal basis :math:`B_N` for :math:`\mathcal{K}_{N}`, the simplest algorithm; is the well-known Lanczos algorithm, which provides a sort of Gram-Schmidt procedure; that harnesses the fact that orthonormalization needs to be imposed only for the last; two vectors in the basis. Written in this basis the time-evolved state can be approximated as. .. math::; 	:label: lanczoskrylov. 	|\psi(t)\rangle=e^{-iHt}|\psi\rangle\approx\mathbb{P}_{N}e^{-iHt}\mathbb{P}_{N}|\psi\rangle=\mathbb{V}_{N}^{\dagger}e^{-iT_{N}t}\mathbb{V}_{N}|\psi\rangle\equiv\left|\psi_{N}(t)\right\rangle,. where :math:`T_{N}=\mathbb{V}_{N} H \mathbb{V}_{N}^{\dagger}` is the Hamiltonian; reduced to the Krylov subspace (which takes a tridiagonal matrix form), and; :math:`\mathbb{V}_{N}^{\dagger}` is the matrix containing the vectors of the; Krylov basis as columns. With the above approximation, the time-evolution is calculated only with a; smaller square matrix of the desired size. Therefore, the Krylov method provides; huge speed-ups in computation of short-time evolutions when the dimension of the; Hamiltonian is very large, a point at which exact calculations on the complete; subspace are practically impossible. One of the biggest problems with this type of method is the control o",MatchSource.DOCS,doc/guide/dynamics/dynamics-krylov.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-krylov.rst
Energy Efficiency,efficient,efficient," in a set of basis functions that span the Hilbert space of the; Hamiltonian, and to write the equation in matrix and vector form. .. math::. i\hbar\frac{d}{dt}\left|\psi\right> = H \left|\psi\right>. where :math:`\left|\psi\right>` is the state vector and :math:`H` is the matrix; representation of the Hamiltonian. This matrix equation can, in principle, be; solved by diagonalizing the Hamiltonian matrix :math:`H`. In practice, however,; it is difficult to perform this diagonalization unless the size of the Hilbert; space (dimension of the matrix :math:`H`) is small. Analytically, it is a; formidable task to calculate the dynamics for systems with more than two states.; If, in addition, we consider dissipation due to the inevitable interaction with; a surrounding environment, the computational complexity grows even larger, and; we have to resort to numerical calculations in all realistic situations. This; illustrates the importance of numerical calculations in describing the dynamics; of open quantum systems, and the need for efficient and accessible tools for; this task. The Schrödinger equation, which governs the time-evolution of closed quantum; systems, is defined by its Hamiltonian and state vector. In the previous; section, :ref:`tensor`, we showed how Hamiltonians and state vectors are; constructed in QuTiP. Given a Hamiltonian, we can calculate the unitary; (non-dissipative) time-evolution of an arbitrary state vector; :math:`\left|\psi_0\right>` (``psi0``) using the QuTiP solver :obj:`.SESolver`; or the function :func:`.sesolve`. It evolves the state vector and evaluates the; expectation values for a set of operators ``e_ops`` at the points in time in; the list ``times``, using an ordinary differential equation solver. For example, the time evolution of a quantum spin-1/2 system with tunneling rate; 0.1 that initially is in the up state is calculated, and the expectation values; of the :math:`\sigma_z` operator evaluated, with the following code. .. plot::;",MatchSource.DOCS,doc/guide/dynamics/dynamics-master.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-master.rst
Modifiability,evolve,evolves," than two states.; If, in addition, we consider dissipation due to the inevitable interaction with; a surrounding environment, the computational complexity grows even larger, and; we have to resort to numerical calculations in all realistic situations. This; illustrates the importance of numerical calculations in describing the dynamics; of open quantum systems, and the need for efficient and accessible tools for; this task. The Schrödinger equation, which governs the time-evolution of closed quantum; systems, is defined by its Hamiltonian and state vector. In the previous; section, :ref:`tensor`, we showed how Hamiltonians and state vectors are; constructed in QuTiP. Given a Hamiltonian, we can calculate the unitary; (non-dissipative) time-evolution of an arbitrary state vector; :math:`\left|\psi_0\right>` (``psi0``) using the QuTiP solver :obj:`.SESolver`; or the function :func:`.sesolve`. It evolves the state vector and evaluates the; expectation values for a set of operators ``e_ops`` at the points in time in; the list ``times``, using an ordinary differential equation solver. For example, the time evolution of a quantum spin-1/2 system with tunneling rate; 0.1 that initially is in the up state is calculated, and the expectation values; of the :math:`\sigma_z` operator evaluated, with the following code. .. plot::; :context: reset. >>> H = 2*np.pi * 0.1 * sigmax(); >>> psi0 = basis(2, 0); >>> times = np.linspace(0.0, 10.0, 20); >>> solver = SESolver(H); >>> result = solver.run(psi0, times, e_ops=[sigmaz()]); >>> result.expect; [array([ 1. , 0.78914057, 0.24548543, -0.40169579, -0.87947417,; -0.98636112, -0.67728018, -0.08257665, 0.54695111, 0.94581862,; 0.94581574, 0.54694361, -0.08258559, -0.67728679, -0.9863626 ,; -0.87946979, -0.40168705, 0.24549517, 0.78914703, 1. ])]. See the next section for examples on evolution with dissipation using; :func:`.mesolve`. The function returns an instance of :class:`.Result`, as described in the; previous section :ref:`solver",MatchSource.DOCS,doc/guide/dynamics/dynamics-master.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-master.rst
Performance,perform,perform,"; The dynamics of a closed (pure) quantum system is governed by the Schrödinger equation. .. math::; :label: schrodinger. 	i\hbar\frac{\partial}{\partial t}\Psi = \hat H \Psi,. where :math:`\Psi` is the wave function, :math:`\hat H` the Hamiltonian, and; :math:`\hbar` is Planck's constant. In general, the Schrödinger equation is a; partial differential equation (PDE) where both :math:`\Psi` and :math:`\hat H`; are functions of space and time. For computational purposes it is useful to; expand the PDE in a set of basis functions that span the Hilbert space of the; Hamiltonian, and to write the equation in matrix and vector form. .. math::. i\hbar\frac{d}{dt}\left|\psi\right> = H \left|\psi\right>. where :math:`\left|\psi\right>` is the state vector and :math:`H` is the matrix; representation of the Hamiltonian. This matrix equation can, in principle, be; solved by diagonalizing the Hamiltonian matrix :math:`H`. In practice, however,; it is difficult to perform this diagonalization unless the size of the Hilbert; space (dimension of the matrix :math:`H`) is small. Analytically, it is a; formidable task to calculate the dynamics for systems with more than two states.; If, in addition, we consider dissipation due to the inevitable interaction with; a surrounding environment, the computational complexity grows even larger, and; we have to resort to numerical calculations in all realistic situations. This; illustrates the importance of numerical calculations in describing the dynamics; of open quantum systems, and the need for efficient and accessible tools for; this task. The Schrödinger equation, which governs the time-evolution of closed quantum; systems, is defined by its Hamiltonian and state vector. In the previous; section, :ref:`tensor`, we showed how Hamiltonians and state vectors are; constructed in QuTiP. Given a Hamiltonian, we can calculate the unitary; (non-dissipative) time-evolution of an arbitrary state vector; :math:`\left|\psi_0\right>` (``psi0``) using ",MatchSource.DOCS,doc/guide/dynamics/dynamics-master.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-master.rst
Security,access,accessible," in a set of basis functions that span the Hilbert space of the; Hamiltonian, and to write the equation in matrix and vector form. .. math::. i\hbar\frac{d}{dt}\left|\psi\right> = H \left|\psi\right>. where :math:`\left|\psi\right>` is the state vector and :math:`H` is the matrix; representation of the Hamiltonian. This matrix equation can, in principle, be; solved by diagonalizing the Hamiltonian matrix :math:`H`. In practice, however,; it is difficult to perform this diagonalization unless the size of the Hilbert; space (dimension of the matrix :math:`H`) is small. Analytically, it is a; formidable task to calculate the dynamics for systems with more than two states.; If, in addition, we consider dissipation due to the inevitable interaction with; a surrounding environment, the computational complexity grows even larger, and; we have to resort to numerical calculations in all realistic situations. This; illustrates the importance of numerical calculations in describing the dynamics; of open quantum systems, and the need for efficient and accessible tools for; this task. The Schrödinger equation, which governs the time-evolution of closed quantum; systems, is defined by its Hamiltonian and state vector. In the previous; section, :ref:`tensor`, we showed how Hamiltonians and state vectors are; constructed in QuTiP. Given a Hamiltonian, we can calculate the unitary; (non-dissipative) time-evolution of an arbitrary state vector; :math:`\left|\psi_0\right>` (``psi0``) using the QuTiP solver :obj:`.SESolver`; or the function :func:`.sesolve`. It evolves the state vector and evaluates the; expectation values for a set of operators ``e_ops`` at the points in time in; the list ``times``, using an ordinary differential equation solver. For example, the time evolution of a quantum spin-1/2 system with tunneling rate; 0.1 that initially is in the up state is calculated, and the expectation values; of the :math:`\sigma_z` operator evaluated, with the following code. .. plot::;",MatchSource.DOCS,doc/guide/dynamics/dynamics-master.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-master.rst
Availability,error,errors," a list over the expectation operators, trajectories and times in that order.; The averages are stored in ``result.average_expect`` and the standard derivation; of the expectation values in ``result.std_expect``. When the states are returned,; ``result.runs_states`` will be an array of length ``ntraj``. Each element; contains an array of ""Qobj"" type ket with the same number of elements as ``times``.; ``result.average_states`` is a list of density matrices computed as the average; of the states at each time step. Furthermore, the output will also contain a; list of times at which the collapse occurred, and which collapse operators did; the collapse. These can be obtained in ``result.col_times`` and; ``result.col_which`` respectively. .. _monte-ntraj:. Changing the Number of Trajectories; -----------------------------------. By default, the ``mcsolve`` function runs 500 trajectories.; This value was chosen because it gives good accuracy, Monte Carlo errors scale; as :math:`1/n` where :math:`n` is the number of trajectories, and simultaneously; does not take an excessive amount of time to run. However, you can change the; number of trajectories to fit your needs. In order to run 1000 trajectories in; the above example, we can simply modify the call to ``mcsolve`` like:. .. code-block::. data = mcsolve(H, psi0, times, c_ops e_ops=e_ops, ntraj=1000). where we have added the keyword argument ``ntraj=1000`` at the end of the inputs.; Now, the Monte Carlo solver will calculate expectation values for both operators,; ``a.dag() * a, sm.dag() * sm`` averaging over 1000 trajectories. Other than a target number of trajectories, it is possible to use a computation; time or errors bars as condition to stop computing trajectories. ``timeout`` is quite simple as ``mcsolve`` will stop starting the computation of; new trajectories when it is reached. Thus:. .. code-block::. data = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], e_ops=e_ops, ntraj=1000, timeout=60). Will compute 60 seconds ",MatchSource.DOCS,doc/guide/dynamics/dynamics-monte.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-monte.rst
Deployability,continuous,continuously,".. _monte:. *******************************************; Monte Carlo Solver; *******************************************. .. _monte-intro:. Introduction; =============. Where as the density matrix formalism describes the ensemble average over many; identical realizations of a quantum system, the Monte Carlo (MC), or; quantum-jump approach to wave function evolution, allows for simulating an; individual realization of the system dynamics. Here, the environment is; continuously monitored, resulting in a series of quantum jumps in the system; wave function, conditioned on the increase in information gained about the; state of the system via the environmental measurements. In general, this; evolution is governed by the Schrödinger equation with a **non-Hermitian**; effective Hamiltonian. .. math::; :label: heff. H_{\rm eff}=H_{\rm sys}-\frac{i\hbar}{2}\sum_{i}C^{+}_{n}C_{n},. where again, the :math:`C_{n}` are collapse operators, each corresponding to a; separate irreversible process with rate :math:`\gamma_{n}`. Here, the strictly; negative non-Hermitian portion of Eq. :eq:`heff` gives rise to a reduction in; the norm of the wave function, that to first-order in a small time; :math:`\delta t`, is given by; :math:`\left<\psi(t+\delta t)|\psi(t+\delta t)\right>=1-\delta p` where. .. math::; :label: jump. \delta p =\delta t \sum_{n}\left<\psi(t)|C^{+}_{n}C_{n}|\psi(t)\right>,. and :math:`\delta t` is such that :math:`\delta p \ll 1`. With a probability; of remaining in the state :math:`\left|\psi(t+\delta t)\right>` given by; :math:`1-\delta p`, the corresponding quantum jump probability is thus Eq.; :eq:`jump`. If the environmental measurements register a quantum jump, say via; the emission of a photon into the environment, or a change in the spin of a; quantum dot, the wave function undergoes a jump into a state defined by; projecting :math:`\left|\psi(t)\right>` using the collapse operator; :math:`C_{n}` corresponding to the measurement. .. math::; :label: project. \lef",MatchSource.DOCS,doc/guide/dynamics/dynamics-monte.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-monte.rst
Energy Efficiency,monitor,monitored,".. _monte:. *******************************************; Monte Carlo Solver; *******************************************. .. _monte-intro:. Introduction; =============. Where as the density matrix formalism describes the ensemble average over many; identical realizations of a quantum system, the Monte Carlo (MC), or; quantum-jump approach to wave function evolution, allows for simulating an; individual realization of the system dynamics. Here, the environment is; continuously monitored, resulting in a series of quantum jumps in the system; wave function, conditioned on the increase in information gained about the; state of the system via the environmental measurements. In general, this; evolution is governed by the Schrödinger equation with a **non-Hermitian**; effective Hamiltonian. .. math::; :label: heff. H_{\rm eff}=H_{\rm sys}-\frac{i\hbar}{2}\sum_{i}C^{+}_{n}C_{n},. where again, the :math:`C_{n}` are collapse operators, each corresponding to a; separate irreversible process with rate :math:`\gamma_{n}`. Here, the strictly; negative non-Hermitian portion of Eq. :eq:`heff` gives rise to a reduction in; the norm of the wave function, that to first-order in a small time; :math:`\delta t`, is given by; :math:`\left<\psi(t+\delta t)|\psi(t+\delta t)\right>=1-\delta p` where. .. math::; :label: jump. \delta p =\delta t \sum_{n}\left<\psi(t)|C^{+}_{n}C_{n}|\psi(t)\right>,. and :math:`\delta t` is such that :math:`\delta p \ll 1`. With a probability; of remaining in the state :math:`\left|\psi(t+\delta t)\right>` given by; :math:`1-\delta p`, the corresponding quantum jump probability is thus Eq.; :eq:`jump`. If the environmental measurements register a quantum jump, say via; the emission of a photon into the environment, or a change in the spin of a; quantum dot, the wave function undergoes a jump into a state defined by; projecting :math:`\left|\psi(t)\right>` using the collapse operator; :math:`C_{n}` corresponding to the measurement. .. math::; :label: project. \lef",MatchSource.DOCS,doc/guide/dynamics/dynamics-monte.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-monte.rst
Performance,perform,performed,"tor :math:`C_{n}` is chosen such that :math:`n` is the smallest; integer satisfying:. .. math::; :label: mc3. \sum_{i=1}^{n} P_{n}(\tau) \ge r_2. where the individual :math:`P_{n}` are given by Eq. :eq:`pcn`. Note that the; left hand side of Eq. :eq:`mc3` is, by definition, normalized to unity. - **IV:** Using the renormalized state from step III as the new initial; condition at time :math:`\tau`, draw a new random number, and repeat the; above procedure until the final simulation time is reached. .. _monte-qutip:. Monte Carlo in QuTiP; ====================. In QuTiP, Monte Carlo evolution is implemented with the :func:`.mcsolve`; function. It takes nearly the same arguments as the :func:`.mesolve`; function for master-equation evolution, except that the initial state must be a; ket vector, as oppose to a density matrix, and there is an optional keyword; parameter ``ntraj`` that defines the number of stochastic trajectories to be; simulated. By default, ``ntraj=500`` indicating that 500 Monte Carlo; trajectories will be performed. To illustrate the use of the Monte Carlo evolution of quantum systems in QuTiP,; let's again consider the case of a two-level atom coupled to a leaky cavity.; The only differences to the master-equation treatment is that in this case we; invoke the :func:`.mcsolve` function instead of :func:`.mesolve`. .. plot::; :context: reset. times = np.linspace(0.0, 10.0, 200); psi0 = tensor(fock(2, 0), fock(10, 8)); a = tensor(qeye(2), destroy(10)); sm = tensor(destroy(2), qeye(10)); H = 2*np.pi*a.dag()*a + 2*np.pi*sm.dag()*sm + 2*np.pi*0.25*(sm*a.dag() + sm.dag()*a); data = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], e_ops=[a.dag() * a, sm.dag() * sm]). plt.figure(); plt.plot(times, data.expect[0], times, data.expect[1]); plt.title('Monte Carlo time evolution'); plt.xlabel('Time'); plt.ylabel('Expectation values'); plt.legend((""cavity photon number"", ""atom excitation probability"")); plt.show(). .. guide-dynamics-mc1:. The advantage of the Monte Carlo",MatchSource.DOCS,doc/guide/dynamics/dynamics-monte.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-monte.rst
Safety,timeout,timeout,"------------------------------. By default, the ``mcsolve`` function runs 500 trajectories.; This value was chosen because it gives good accuracy, Monte Carlo errors scale; as :math:`1/n` where :math:`n` is the number of trajectories, and simultaneously; does not take an excessive amount of time to run. However, you can change the; number of trajectories to fit your needs. In order to run 1000 trajectories in; the above example, we can simply modify the call to ``mcsolve`` like:. .. code-block::. data = mcsolve(H, psi0, times, c_ops e_ops=e_ops, ntraj=1000). where we have added the keyword argument ``ntraj=1000`` at the end of the inputs.; Now, the Monte Carlo solver will calculate expectation values for both operators,; ``a.dag() * a, sm.dag() * sm`` averaging over 1000 trajectories. Other than a target number of trajectories, it is possible to use a computation; time or errors bars as condition to stop computing trajectories. ``timeout`` is quite simple as ``mcsolve`` will stop starting the computation of; new trajectories when it is reached. Thus:. .. code-block::. data = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], e_ops=e_ops, ntraj=1000, timeout=60). Will compute 60 seconds of trajectories or 1000, which ever is reached first.; The solver will finish any trajectory started when the timeout is reached. Therefore; if the computation time of a single trajectory is quite long, the overall computation; time can be much longer that the provided timeout. Lastly, ``mcsolve`` can be instructed to stop when the statistical error of the; expectation values get under a certain value. When computing the average over; trajectories, the error on these are computed using; `jackknife resampling <https://en.wikipedia.org/wiki/Jackknife_resampling>`_; for each expect and each time and the computation will be stopped when all these values; are under the tolerance passed to ``target_tol``. Therefore:. .. code-block::. data = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], e_ops=e_ops,; ",MatchSource.DOCS,doc/guide/dynamics/dynamics-monte.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-monte.rst
Usability,guid,guide-dynamics-,"y default, ``ntraj=500`` indicating that 500 Monte Carlo; trajectories will be performed. To illustrate the use of the Monte Carlo evolution of quantum systems in QuTiP,; let's again consider the case of a two-level atom coupled to a leaky cavity.; The only differences to the master-equation treatment is that in this case we; invoke the :func:`.mcsolve` function instead of :func:`.mesolve`. .. plot::; :context: reset. times = np.linspace(0.0, 10.0, 200); psi0 = tensor(fock(2, 0), fock(10, 8)); a = tensor(qeye(2), destroy(10)); sm = tensor(destroy(2), qeye(10)); H = 2*np.pi*a.dag()*a + 2*np.pi*sm.dag()*sm + 2*np.pi*0.25*(sm*a.dag() + sm.dag()*a); data = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], e_ops=[a.dag() * a, sm.dag() * sm]). plt.figure(); plt.plot(times, data.expect[0], times, data.expect[1]); plt.title('Monte Carlo time evolution'); plt.xlabel('Time'); plt.ylabel('Expectation values'); plt.legend((""cavity photon number"", ""atom excitation probability"")); plt.show(). .. guide-dynamics-mc1:. The advantage of the Monte Carlo method over the master equation approach is that; only the state vector is required to be kept in the computers memory, as opposed; to the entire density matrix. For large quantum system this becomes a significant; advantage, and the Monte Carlo solver is therefore generally recommended for such; systems. For example, simulating a Heisenberg spin-chain consisting of 10 spins; with random parameters and initial states takes almost 7 times longer using the; master equation rather than Monte Carlo approach with the default number of; trajectories running on a quad-CPU machine. Furthermore, it takes about 7 times; the memory as well. However, for small systems, the added overhead of averaging; a large number of stochastic trajectories to obtain the open system dynamics, as; well as starting the multiprocessing functionality, outweighs the benefit of the; minor (in this case) memory saving. Master equation methods are therefore; generally more eff",MatchSource.DOCS,doc/guide/dynamics/dynamics-monte.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-monte.rst
Deployability,integrat,integration,"csolve`` requires collapse operators :math:`A_n` and target ""rates""; :math:`\gamma_n` (which are allowed to take negative values) to be given in list; form ``[[C_1, gamma_1], [C_2, gamma_2], ...]``. Note that we give the actual; rate and not its square root, and that ``nm_mcsolve`` automatically computes; associated jump rates :math:`\Gamma_n(t)\geq0` appropriate for simulation. We conclude with a simple example demonstrating the usage of the ``nm_mcsolve``; function. For more elaborate, physically motivated examples, we refer to the; `accompanying tutorial notebook <https://github.com/qutip/qutip-tutorials/blob/main/tutorials-v5/time-evolution/013_nonmarkovian_monte_carlo.md>`_. .. plot::; :context: reset. times = np.linspace(0, 1, 201); psi0 = basis(2, 1); a0 = destroy(2); H = a0.dag() * a0. # Rate functions; gamma1 = ""kappa * nth""; gamma2 = ""kappa * (nth+1) + 12 * np.exp(-2*t**3) * (-np.sin(15*t)**2)""; # gamma2 becomes negative during some time intervals. # nm_mcsolve integration; ops_and_rates = []; ops_and_rates.append([a0.dag(), gamma1]); ops_and_rates.append([a0, gamma2]); MCSol = nm_mcsolve(H, psi0, times, ops_and_rates,; args={'kappa': 1.0 / 0.129, 'nth': 0.063},; e_ops=[a0.dag() * a0, a0 * a0.dag()],; options={'map': 'parallel'}, ntraj=2500). # mesolve integration for comparison; d_ops = [[lindblad_dissipator(a0.dag(), a0.dag()), gamma1],; [lindblad_dissipator(a0, a0), gamma2]]; MESol = mesolve(H, psi0, times, d_ops, e_ops=[a0.dag() * a0, a0 * a0.dag()],; args={'kappa': 1.0 / 0.129, 'nth': 0.063}). plt.figure(); plt.plot(times, MCSol.expect[0], 'g',; times, MCSol.expect[1], 'b',; times, MCSol.trace, 'r'); plt.plot(times, MESol.expect[0], 'g--',; times, MESol.expect[1], 'b--'); plt.title('Monte Carlo time evolution'); plt.xlabel('Time'); plt.ylabel('Expectation values'); plt.legend((r'$\langle 1 | \rho | 1 \rangle$',; r'$\langle 0 | \rho | 0 \rangle$',; r'$\operatorname{tr} \rho$')); plt.show(). .. plot::; :context: reset; :include-source: false; :nofigs:; ",MatchSource.DOCS,doc/guide/dynamics/dynamics-nmmonte.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-nmmonte.rst
Integrability,integrat,integration,"csolve`` requires collapse operators :math:`A_n` and target ""rates""; :math:`\gamma_n` (which are allowed to take negative values) to be given in list; form ``[[C_1, gamma_1], [C_2, gamma_2], ...]``. Note that we give the actual; rate and not its square root, and that ``nm_mcsolve`` automatically computes; associated jump rates :math:`\Gamma_n(t)\geq0` appropriate for simulation. We conclude with a simple example demonstrating the usage of the ``nm_mcsolve``; function. For more elaborate, physically motivated examples, we refer to the; `accompanying tutorial notebook <https://github.com/qutip/qutip-tutorials/blob/main/tutorials-v5/time-evolution/013_nonmarkovian_monte_carlo.md>`_. .. plot::; :context: reset. times = np.linspace(0, 1, 201); psi0 = basis(2, 1); a0 = destroy(2); H = a0.dag() * a0. # Rate functions; gamma1 = ""kappa * nth""; gamma2 = ""kappa * (nth+1) + 12 * np.exp(-2*t**3) * (-np.sin(15*t)**2)""; # gamma2 becomes negative during some time intervals. # nm_mcsolve integration; ops_and_rates = []; ops_and_rates.append([a0.dag(), gamma1]); ops_and_rates.append([a0, gamma2]); MCSol = nm_mcsolve(H, psi0, times, ops_and_rates,; args={'kappa': 1.0 / 0.129, 'nth': 0.063},; e_ops=[a0.dag() * a0, a0 * a0.dag()],; options={'map': 'parallel'}, ntraj=2500). # mesolve integration for comparison; d_ops = [[lindblad_dissipator(a0.dag(), a0.dag()), gamma1],; [lindblad_dissipator(a0, a0), gamma2]]; MESol = mesolve(H, psi0, times, d_ops, e_ops=[a0.dag() * a0, a0 * a0.dag()],; args={'kappa': 1.0 / 0.129, 'nth': 0.063}). plt.figure(); plt.plot(times, MCSol.expect[0], 'g',; times, MCSol.expect[1], 'b',; times, MCSol.trace, 'r'); plt.plot(times, MESol.expect[0], 'g--',; times, MESol.expect[1], 'b--'); plt.title('Monte Carlo time evolution'); plt.xlabel('Time'); plt.ylabel('Expectation values'); plt.legend((r'$\langle 1 | \rho | 1 \rangle$',; r'$\langle 0 | \rho | 0 \rangle$',; r'$\operatorname{tr} \rho$')); plt.show(). .. plot::; :context: reset; :include-source: false; :nofigs:; ",MatchSource.DOCS,doc/guide/dynamics/dynamics-nmmonte.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-nmmonte.rst
Modifiability,evolve,evolves," A_n^\dagger A_n - A_n^\dagger A_n \rho(t)\right]. with ""rates"" :math:`\gamma_n(t)` that can take negative values.; This can be done with the :func:`.nm_mcsolve` function.; The function is based on the influence martingale formalism [Donvil22]_ and; formally requires that the collapse operators :math:`A_n` satisfy a completeness; relation of the form. .. math::; :label: nmmcsolve_completeness. \sum_n A_n^\dagger A_n = \alpha \mathbb{I} ,. where :math:`\mathbb{I}` is the identity operator on the system Hilbert space; and :math:`\alpha>0`.; Note that when the collapse operators of a model don't satisfy such a relation,; ``nm_mcsolve`` automatically adds an extra collapse operator such that; :eq:`nmmcsolve_completeness` is satisfied.; The rate corresponding to this extra collapse operator is set to zero. Technically, the influence martingale formalism works as follows.; We introduce an influence martingale :math:`\mu(t)`, which follows the evolution; of the system state. When no jump happens, it evolves as. .. math::; :label: influence_cont. \mu(t) = \exp\left( \alpha\int_0^t K(\tau) d\tau \right). where :math:`K(t)` is for now an arbitrary function.; When a jump corresponding to the collapse operator :math:`A_n` happens, the; influence martingale becomes. .. math::; :label: influence_disc. \mu(t+\delta t) = \mu(t)\left(\frac{K(t)-\gamma_n(t)}{\gamma_n(t)}\right). Assuming that the state :math:`\bar\rho(t)` computed by the Monte Carlo average. .. math::; :label: mc_paired_state. \bar\rho(t) = \frac{1}{N}\sum_{l=1}^N |\psi_l(t)\rangle\langle \psi_l(t)|. solves a Lindblad master equation with collapse operators :math:`A_n` and rates; :math:`\Gamma_n(t)`, the state :math:`\rho(t)` defined by. .. math::; :label: mc_martingale_state. \rho(t) = \frac{1}{N}\sum_{l=1}^N \mu_l(t) |\psi_l(t)\rangle\langle \psi_l(t)|. solves a Lindblad master equation with collapse operators :math:`A_n` and shifted; rates :math:`\gamma_n(t)-K(t)`. Thus, while :math:`\Gamma_n(t) \geq 0`, the new; """,MatchSource.DOCS,doc/guide/dynamics/dynamics-nmmonte.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-nmmonte.rst
Usability,simpl,simple,"tate :math:`\rho(t)` defined by. .. math::; :label: mc_martingale_state. \rho(t) = \frac{1}{N}\sum_{l=1}^N \mu_l(t) |\psi_l(t)\rangle\langle \psi_l(t)|. solves a Lindblad master equation with collapse operators :math:`A_n` and shifted; rates :math:`\gamma_n(t)-K(t)`. Thus, while :math:`\Gamma_n(t) \geq 0`, the new; ""rates"" :math:`\gamma_n(t) = \Gamma_n(t) - K(t)` satisfy no positivity requirement. The input of :func:`.nm_mcsolve` is almost the same as for :func:`.mcsolve`.; The only difference is how the collapse operators and rate functions should be; defined. ``nm_mcsolve`` requires collapse operators :math:`A_n` and target ""rates""; :math:`\gamma_n` (which are allowed to take negative values) to be given in list; form ``[[C_1, gamma_1], [C_2, gamma_2], ...]``. Note that we give the actual; rate and not its square root, and that ``nm_mcsolve`` automatically computes; associated jump rates :math:`\Gamma_n(t)\geq0` appropriate for simulation. We conclude with a simple example demonstrating the usage of the ``nm_mcsolve``; function. For more elaborate, physically motivated examples, we refer to the; `accompanying tutorial notebook <https://github.com/qutip/qutip-tutorials/blob/main/tutorials-v5/time-evolution/013_nonmarkovian_monte_carlo.md>`_. .. plot::; :context: reset. times = np.linspace(0, 1, 201); psi0 = basis(2, 1); a0 = destroy(2); H = a0.dag() * a0. # Rate functions; gamma1 = ""kappa * nth""; gamma2 = ""kappa * (nth+1) + 12 * np.exp(-2*t**3) * (-np.sin(15*t)**2)""; # gamma2 becomes negative during some time intervals. # nm_mcsolve integration; ops_and_rates = []; ops_and_rates.append([a0.dag(), gamma1]); ops_and_rates.append([a0, gamma2]); MCSol = nm_mcsolve(H, psi0, times, ops_and_rates,; args={'kappa': 1.0 / 0.129, 'nth': 0.063},; e_ops=[a0.dag() * a0, a0 * a0.dag()],; options={'map': 'parallel'}, ntraj=2500). # mesolve integration for comparison; d_ops = [[lindblad_dissipator(a0.dag(), a0.dag()), gamma1],; [lindblad_dissipator(a0, a0), gamma2]]; MESol = mesolve",MatchSource.DOCS,doc/guide/dynamics/dynamics-nmmonte.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-nmmonte.rst
Availability,toler,tolerance,".. _options:. *********************************************; Setting Options for the Dynamics Solvers; *********************************************. .. testsetup:: [dynamics_options]. from qutip.solver.mesolve import MESolver, mesolve; import numpy as np. Occasionally it is necessary to change the built in parameters of the dynamics; solvers used by for example the :func:`.mesolve` and :func:`.mcsolve` functions.; The options for all dynamics solvers may be changed by using the dictionaries. .. testcode:: [dynamics_options]. options = {""store_states"": True, ""atol"": 1e-12}. Supported items come from 2 sources, the solver and the ODE integration method.; Supported solver options and their default can be seen using the class interface:. .. testcode:: [dynamics_options]. help(MESolver.options). Options supported by the ODE integration depend on the ""method"" options of the solver,; they can be listed through the integrator method of the solvers:. .. testcode:: [dynamics_options]. help(MESolver.integrator(""adams"").options). See :ref:`classes-ode` for a list of supported methods. As an example, let us consider changing the integrator, turn the GUI off, and; strengthen the absolute tolerance. .. testcode:: [dynamics_options]. options = {method=""bdf"", ""atol"": 1e-10, ""progress_bar"": False}. To use these new settings we can use the keyword argument ``options`` in either ; the :func:`.mesolve` and :func:`.mcsolve` function::. >>> mesolve(H0, psi0, tlist, c_op_list, [sigmaz()], options=options). or::. >>> MCSolver(H0, c_op_list, options=options); ",MatchSource.DOCS,doc/guide/dynamics/dynamics-options.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-options.rst
Deployability,integrat,integration,".. _options:. *********************************************; Setting Options for the Dynamics Solvers; *********************************************. .. testsetup:: [dynamics_options]. from qutip.solver.mesolve import MESolver, mesolve; import numpy as np. Occasionally it is necessary to change the built in parameters of the dynamics; solvers used by for example the :func:`.mesolve` and :func:`.mcsolve` functions.; The options for all dynamics solvers may be changed by using the dictionaries. .. testcode:: [dynamics_options]. options = {""store_states"": True, ""atol"": 1e-12}. Supported items come from 2 sources, the solver and the ODE integration method.; Supported solver options and their default can be seen using the class interface:. .. testcode:: [dynamics_options]. help(MESolver.options). Options supported by the ODE integration depend on the ""method"" options of the solver,; they can be listed through the integrator method of the solvers:. .. testcode:: [dynamics_options]. help(MESolver.integrator(""adams"").options). See :ref:`classes-ode` for a list of supported methods. As an example, let us consider changing the integrator, turn the GUI off, and; strengthen the absolute tolerance. .. testcode:: [dynamics_options]. options = {method=""bdf"", ""atol"": 1e-10, ""progress_bar"": False}. To use these new settings we can use the keyword argument ``options`` in either ; the :func:`.mesolve` and :func:`.mcsolve` function::. >>> mesolve(H0, psi0, tlist, c_op_list, [sigmaz()], options=options). or::. >>> MCSolver(H0, c_op_list, options=options); ",MatchSource.DOCS,doc/guide/dynamics/dynamics-options.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-options.rst
Integrability,integrat,integration,".. _options:. *********************************************; Setting Options for the Dynamics Solvers; *********************************************. .. testsetup:: [dynamics_options]. from qutip.solver.mesolve import MESolver, mesolve; import numpy as np. Occasionally it is necessary to change the built in parameters of the dynamics; solvers used by for example the :func:`.mesolve` and :func:`.mcsolve` functions.; The options for all dynamics solvers may be changed by using the dictionaries. .. testcode:: [dynamics_options]. options = {""store_states"": True, ""atol"": 1e-12}. Supported items come from 2 sources, the solver and the ODE integration method.; Supported solver options and their default can be seen using the class interface:. .. testcode:: [dynamics_options]. help(MESolver.options). Options supported by the ODE integration depend on the ""method"" options of the solver,; they can be listed through the integrator method of the solvers:. .. testcode:: [dynamics_options]. help(MESolver.integrator(""adams"").options). See :ref:`classes-ode` for a list of supported methods. As an example, let us consider changing the integrator, turn the GUI off, and; strengthen the absolute tolerance. .. testcode:: [dynamics_options]. options = {method=""bdf"", ""atol"": 1e-10, ""progress_bar"": False}. To use these new settings we can use the keyword argument ``options`` in either ; the :func:`.mesolve` and :func:`.mcsolve` function::. >>> mesolve(H0, psi0, tlist, c_op_list, [sigmaz()], options=options). or::. >>> MCSolver(H0, c_op_list, options=options); ",MatchSource.DOCS,doc/guide/dynamics/dynamics-options.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-options.rst
Testability,test,testsetup,".. _options:. *********************************************; Setting Options for the Dynamics Solvers; *********************************************. .. testsetup:: [dynamics_options]. from qutip.solver.mesolve import MESolver, mesolve; import numpy as np. Occasionally it is necessary to change the built in parameters of the dynamics; solvers used by for example the :func:`.mesolve` and :func:`.mcsolve` functions.; The options for all dynamics solvers may be changed by using the dictionaries. .. testcode:: [dynamics_options]. options = {""store_states"": True, ""atol"": 1e-12}. Supported items come from 2 sources, the solver and the ODE integration method.; Supported solver options and their default can be seen using the class interface:. .. testcode:: [dynamics_options]. help(MESolver.options). Options supported by the ODE integration depend on the ""method"" options of the solver,; they can be listed through the integrator method of the solvers:. .. testcode:: [dynamics_options]. help(MESolver.integrator(""adams"").options). See :ref:`classes-ode` for a list of supported methods. As an example, let us consider changing the integrator, turn the GUI off, and; strengthen the absolute tolerance. .. testcode:: [dynamics_options]. options = {method=""bdf"", ""atol"": 1e-10, ""progress_bar"": False}. To use these new settings we can use the keyword argument ``options`` in either ; the :func:`.mesolve` and :func:`.mcsolve` function::. >>> mesolve(H0, psi0, tlist, c_op_list, [sigmaz()], options=options). or::. >>> MCSolver(H0, c_op_list, options=options); ",MatchSource.DOCS,doc/guide/dynamics/dynamics-options.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-options.rst
Availability,avail,available,"cient and the full propagator; is desired. QuTiP has the :func:`.propagator` function to compute them:. .. code-block::. >>> H = sigmaz() + np.pi *sigmax(); >>> psi_t = sesolve(H, basis(2, 1), [0, 0.5, 1]).states; >>> prop = propagator(H, [0, 0.5, 1]). >>> print((psi_t[1] - prop[1] @ basis(2, 1)).norm()); 2.455965272327082e-06. >>> print((psi_t[2] - prop[2] @ basis(2, 1)).norm()); 2.0071900004562142e-06. The first argument is the Hamiltonian, any time dependent system format is; accepted. The function also accepts an optional `c_ops` argument for collapse operators.; When used, a propagator for density matrices is computed:; :math:`\rho(t) = U(t)(\rho(0))`:. .. code-block::. >>> rho_t = mesolve(H, fock_dm(2, 1), [0, 0.5, 1], c_ops=[sigmam()]).states; >>> prop = propagator(H, [0, 0.5, 1], c_ops=[sigmam()]). >>> print((rho_t[1] - prop[1](fock_dm(2, 1))).norm()); 7.23009476734681e-07. >>> print((rho_t[2] - prop[2](fock_dm(2, 1))).norm()); 1.2666967766644768e-06. The propagator function is also available as a class:. .. code-block::. >>> U = Propagator(H, c_ops=[sigmam()]). >>> state_0_5 = U(0.5)(fock_dm(2, 1)); >>> state_1 = U(1., t_start=0.5)(state_0_5). >>> print((rho_t[1] - state_0_5).norm()); 7.23009476734681e-07. >>> print((rho_t[2] - state_1).norm()); 8.355518501351504e-07. The :obj:`.Propagator` can take ``options`` and ``args`` as a solver instance. .. _propagator_solver:. Using a solver to compute a propagator; ======================================. Many solvers accept an operator as the initial state. When an identity matrix is; passed as the initial state, the propagator is computed. This can be used to compute; a propagator for Bloch-Redfield or Floquet equations:. .. code-block::. >>> delta = 0.2 * 2*np.pi; >>> eps0 = 1.0 * 2*np.pi; >>> gamma1 = 0.5. >>> H = - delta/2.0 * sigmax() - eps0/2.0 * sigmaz(). >>> def ohmic_spectrum(w):; >>> if w == 0.0: # dephasing inducing noise; >>> return gamma1; >>> else: # relaxation inducing noise; >>> return gamma1 / 2 * ",MatchSource.DOCS,doc/guide/dynamics/dynamics-propagator.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-propagator.rst
Integrability,depend,dependent,".. _propagator:. *********************; Computing propagators; *********************. Sometime the evolution of a single state is not sufficient and the full propagator; is desired. QuTiP has the :func:`.propagator` function to compute them:. .. code-block::. >>> H = sigmaz() + np.pi *sigmax(); >>> psi_t = sesolve(H, basis(2, 1), [0, 0.5, 1]).states; >>> prop = propagator(H, [0, 0.5, 1]). >>> print((psi_t[1] - prop[1] @ basis(2, 1)).norm()); 2.455965272327082e-06. >>> print((psi_t[2] - prop[2] @ basis(2, 1)).norm()); 2.0071900004562142e-06. The first argument is the Hamiltonian, any time dependent system format is; accepted. The function also accepts an optional `c_ops` argument for collapse operators.; When used, a propagator for density matrices is computed:; :math:`\rho(t) = U(t)(\rho(0))`:. .. code-block::. >>> rho_t = mesolve(H, fock_dm(2, 1), [0, 0.5, 1], c_ops=[sigmam()]).states; >>> prop = propagator(H, [0, 0.5, 1], c_ops=[sigmam()]). >>> print((rho_t[1] - prop[1](fock_dm(2, 1))).norm()); 7.23009476734681e-07. >>> print((rho_t[2] - prop[2](fock_dm(2, 1))).norm()); 1.2666967766644768e-06. The propagator function is also available as a class:. .. code-block::. >>> U = Propagator(H, c_ops=[sigmam()]). >>> state_0_5 = U(0.5)(fock_dm(2, 1)); >>> state_1 = U(1., t_start=0.5)(state_0_5). >>> print((rho_t[1] - state_0_5).norm()); 7.23009476734681e-07. >>> print((rho_t[2] - state_1).norm()); 8.355518501351504e-07. The :obj:`.Propagator` can take ``options`` and ``args`` as a solver instance. .. _propagator_solver:. Using a solver to compute a propagator; ======================================. Many solvers accept an operator as the initial state. When an identity matrix is; passed as the initial state, the propagator is computed. This can be used to compute; a propagator for Bloch-Redfield or Floquet equations:. .. code-block::. >>> delta = 0.2 * 2*np.pi; >>> eps0 = 1.0 * 2*np.pi; >>> gamma1 = 0.5. >>> H = - delta/2.0 * sigmax() - eps0/2.0 * sigmaz(). >>> def ohmic_sp",MatchSource.DOCS,doc/guide/dynamics/dynamics-propagator.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-propagator.rst
Availability,avail,available,"d :math:`S_n`:. .. math::; :label: liouvillian. d_1 = - i[H(t),\rho(t)]; + \sum_i D[C_i]\rho; + \sum_n D[S_n]\rho,. The stochastic part, :math:`d_{2,n}`, is given solely by the operators :math:`S_n`. .. math::; :label: stochastic_smesolve. d_{2,n} = S_n \rho(t) + \rho(t) S_n^\dagger - \mathrm{tr}\left(S_n \rho (t); + \rho(t) S_n^\dagger \right)\,\rho(t). As in the stochastic Schrodinger equation, heterodyne detection can be chosen by passing ``heterodyne=True``. Example; -------. Below, we solve the dynamics for an optical cavity at 0K whose output is monitored; using homodyne detection. The cavity decay rate is given by :math:`\kappa` and the; :math:`\Delta` is the cavity detuning with respect to the driving field.; The measurement operators can be passed using the option ``m_ops``. The homodyne; current :math:`J_x` is calculated using. .. math::; :label: measurement_result. J_x = \langle x \rangle + dW / dt,. where :math:`x` is the operator passed using ``m_ops``. The results are available; in ``result.measurements``. .. plot::; :context: reset. # parameters; DIM = 20 # Hilbert space dimension; DELTA = 5 * 2 * np.pi # cavity detuning; KAPPA = 2 # cavity decay rate; INTENSITY = 4 # intensity of initial state; NUMBER_OF_TRAJECTORIES = 500. # operators; a = destroy(DIM); x = a + a.dag(); H = DELTA * a.dag() * a. rho_0 = coherent(DIM, np.sqrt(INTENSITY)); times = np.arange(0, 1, 0.0025). stoc_solution = smesolve(; H, rho_0, times,; c_ops=[],; sc_ops=[np.sqrt(KAPPA) * a],; e_ops=[x],; ntraj=NUMBER_OF_TRAJECTORIES,; options={""dt"": 0.00125, ""store_measurement"": True,}; ). fig, ax = plt.subplots(); ax.set_title('Stochastic Master Equation - Homodyne Detection'); ax.plot(times[1:], np.array(stoc_solution.measurement).mean(axis=0)[0, :].real,; 'r', lw=2, label=r'$J_x$'); ax.plot(times, stoc_solution.expect[0], 'k', lw=2,; label=r'$\langle x \rangle$'); ax.set_xlabel('Time'); ax.legend(). ..; TODO merge qutip-tutorials#61; For other examples on :func:`qutip.solver.stochastic",MatchSource.DOCS,doc/guide/dynamics/dynamics-stochastic.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-stochastic.rst
Deployability,continuous,continuous,".. _stochastic:. *******************************************; Stochastic Solver; *******************************************. .. _stochastic-intro:. When a quantum system is subjected to continuous measurement, through homodyne detection for example, it is possible to simulate the conditional quantum state using stochastic Schrodinger and master equations.; The solution of these stochastic equations are quantum trajectories, which represent the conditioned evolution of the system given a specific measurement record. In general, the stochastic evolution of a quantum state is calculated in; QuTiP by solving the general equation. .. math::; :label: general_form. d \rho (t) = d_1 \rho \, dt + \sum_n d_{2,n} \rho \, dW_n,. where :math:`dW_n` is a Wiener increment, which has the expectation values :math:`E[dW] = 0` and :math:`E[dW^2] = dt`. Stochastic Schrodinger Equation; ===============================. .. _sse-solver:. The stochastic Schrodinger equation is given by (see section 4.4, [Wis09]_). .. math::; :label: jump_ssesolve. d \psi(t) = - i H \psi(t) dt; - \sum_n \left( \frac{S_n^\dagger S_n}{2} -\frac{e_n}{2} S_n; + \frac{e_n^2}{8} \right) \psi(t) dt; + \sum_n \left( S_n - \frac{e_n}{2} \right) \psi(t) dW_n,. where :math:`H` is the Hamiltonian, :math:`S_n` are the stochastic collapse operators, and :math:`e_n` is. .. math::; :label: jump_matrix_element. e_n = \left<\psi(t)|S_n + S_n^\dagger|\psi(t)\right>. In QuTiP, this equation can be solved using the function :func:`~qutip.solver.stochastic.ssesolve`,; which is implemented by defining :math:`d_1` and :math:`d_{2,n}` from Equation :eq:`general_form` as. .. math::; :label: d1_def. d_1 = -iH - \frac{1}{2} \sum_n \left(S_n^\dagger S_n - e_n S_n + \frac{e_i^2}{4} \right),. and. .. math::; :label: d2_def. d_{2, n} = S_n - \frac{e_n}{2}. The solver :func:`~qutip.solver.stochastic.ssesolve` will construct the operators; :math:`d_1` and :math:`d_{2,n}` once the user passes the Hamiltonian (``H``) and; the stochastic opera",MatchSource.DOCS,doc/guide/dynamics/dynamics-stochastic.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-stochastic.rst
Energy Efficiency,monitor,monitored,"development notebook <...TODO-Merge 61...>`_. Stochastic Master Equation; ==========================. .. Stochastic Master equation. When the initial state of the system is a density matrix :math:`\rho`, the stochastic master equation solver :func:`qutip.stochastic.smesolve` must be used.; The stochastic master equation is given by (see section 4.4, [Wis09]_). .. math::; :label: stochastic_master. d \rho (t) = -i[H, \rho(t)] dt + D[A]\rho(t) dt + \mathcal{H}[A]\rho dW(t). where. .. math::; :label: dissipator. D[A] \rho = \frac{1}{2} \left[2 A \rho A^\dagger; - \rho A^\dagger A - A^\dagger A \rho \right],. and. .. math::; :label: h_cal. \mathcal{H}[A]\rho = A\rho(t) + \rho(t) A^\dagger - \mathrm{tr}[A\rho(t) + \rho(t) A^\dagger]. In QuTiP, solutions for the stochastic master equation are obtained using the solver; :func:`~qutip.solver.stochastic.smesolve`. The implementation takes into account 2; types of collapse operators. :math:`C_i` (``c_ops``) represent the dissipation in; the environment, while :math:`S_n` (``sc_ops``) are monitored operators.; The deterministic part of the evolution, described by the :math:`d_1` in Equation; :eq:`general_form`, takes into account all operators :math:`C_i` and :math:`S_n`:. .. math::; :label: liouvillian. d_1 = - i[H(t),\rho(t)]; + \sum_i D[C_i]\rho; + \sum_n D[S_n]\rho,. The stochastic part, :math:`d_{2,n}`, is given solely by the operators :math:`S_n`. .. math::; :label: stochastic_smesolve. d_{2,n} = S_n \rho(t) + \rho(t) S_n^\dagger - \mathrm{tr}\left(S_n \rho (t); + \rho(t) S_n^\dagger \right)\,\rho(t). As in the stochastic Schrodinger equation, heterodyne detection can be chosen by passing ``heterodyne=True``. Example; -------. Below, we solve the dynamics for an optical cavity at 0K whose output is monitored; using homodyne detection. The cavity decay rate is given by :math:`\kappa` and the; :math:`\Delta` is the cavity detuning with respect to the driving field.; The measurement operators can be passed using the option `",MatchSource.DOCS,doc/guide/dynamics/dynamics-stochastic.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-stochastic.rst
Safety,detect,detection,".. _stochastic:. *******************************************; Stochastic Solver; *******************************************. .. _stochastic-intro:. When a quantum system is subjected to continuous measurement, through homodyne detection for example, it is possible to simulate the conditional quantum state using stochastic Schrodinger and master equations.; The solution of these stochastic equations are quantum trajectories, which represent the conditioned evolution of the system given a specific measurement record. In general, the stochastic evolution of a quantum state is calculated in; QuTiP by solving the general equation. .. math::; :label: general_form. d \rho (t) = d_1 \rho \, dt + \sum_n d_{2,n} \rho \, dW_n,. where :math:`dW_n` is a Wiener increment, which has the expectation values :math:`E[dW] = 0` and :math:`E[dW^2] = dt`. Stochastic Schrodinger Equation; ===============================. .. _sse-solver:. The stochastic Schrodinger equation is given by (see section 4.4, [Wis09]_). .. math::; :label: jump_ssesolve. d \psi(t) = - i H \psi(t) dt; - \sum_n \left( \frac{S_n^\dagger S_n}{2} -\frac{e_n}{2} S_n; + \frac{e_n^2}{8} \right) \psi(t) dt; + \sum_n \left( S_n - \frac{e_n}{2} \right) \psi(t) dW_n,. where :math:`H` is the Hamiltonian, :math:`S_n` are the stochastic collapse operators, and :math:`e_n` is. .. math::; :label: jump_matrix_element. e_n = \left<\psi(t)|S_n + S_n^\dagger|\psi(t)\right>. In QuTiP, this equation can be solved using the function :func:`~qutip.solver.stochastic.ssesolve`,; which is implemented by defining :math:`d_1` and :math:`d_{2,n}` from Equation :eq:`general_form` as. .. math::; :label: d1_def. d_1 = -iH - \frac{1}{2} \sum_n \left(S_n^\dagger S_n - e_n S_n + \frac{e_i^2}{4} \right),. and. .. math::; :label: d2_def. d_{2, n} = S_n - \frac{e_n}{2}. The solver :func:`~qutip.solver.stochastic.ssesolve` will construct the operators; :math:`d_1` and :math:`d_{2,n}` once the user passes the Hamiltonian (``H``) and; the stochastic opera",MatchSource.DOCS,doc/guide/dynamics/dynamics-stochastic.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-stochastic.rst
Usability,feedback,feedback,"ppa` and the; :math:`\Delta` is the cavity detuning with respect to the driving field.; The measurement operators can be passed using the option ``m_ops``. The homodyne; current :math:`J_x` is calculated using. .. math::; :label: measurement_result. J_x = \langle x \rangle + dW / dt,. where :math:`x` is the operator passed using ``m_ops``. The results are available; in ``result.measurements``. .. plot::; :context: reset. # parameters; DIM = 20 # Hilbert space dimension; DELTA = 5 * 2 * np.pi # cavity detuning; KAPPA = 2 # cavity decay rate; INTENSITY = 4 # intensity of initial state; NUMBER_OF_TRAJECTORIES = 500. # operators; a = destroy(DIM); x = a + a.dag(); H = DELTA * a.dag() * a. rho_0 = coherent(DIM, np.sqrt(INTENSITY)); times = np.arange(0, 1, 0.0025). stoc_solution = smesolve(; H, rho_0, times,; c_ops=[],; sc_ops=[np.sqrt(KAPPA) * a],; e_ops=[x],; ntraj=NUMBER_OF_TRAJECTORIES,; options={""dt"": 0.00125, ""store_measurement"": True,}; ). fig, ax = plt.subplots(); ax.set_title('Stochastic Master Equation - Homodyne Detection'); ax.plot(times[1:], np.array(stoc_solution.measurement).mean(axis=0)[0, :].real,; 'r', lw=2, label=r'$J_x$'); ax.plot(times, stoc_solution.expect[0], 'k', lw=2,; label=r'$\langle x \rangle$'); ax.set_xlabel('Time'); ax.legend(). ..; TODO merge qutip-tutorials#61; For other examples on :func:`qutip.solver.stochastic.smesolve`, see the; `following notebook <...>`_, as well as these notebooks available at; `QuTiP Tutorials page <https://qutip.org/tutorials.html>`_:; `heterodyne detection <...>`_,; `inefficient detection <...>`_, and; `feedback control <https://github.com/jrjohansson/reproduced-papers/blob/master/Reproduce-SIAM-JCO-46-445-2007-Mirrahimi.ipynb>`_. The stochastic solvers share many features with :func:`.mcsolve`, such as; end conditions, seed control and running in parallel. See the sections; :ref:`monte-ntraj`, :ref:`monte-seeds` and :ref:`monte-parallel` for details. .. plot::; :context: reset; :include-source: false; :nofigs:; ",MatchSource.DOCS,doc/guide/dynamics/dynamics-stochastic.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-stochastic.rst
Availability,avail,available,"; Qobj data =; [[0. 1.]; [2. 0.]]; >>> print(summed_evo(0, a=3, b=1)); Quantum object: dims=[[2], [2]], shape=(2, 2), type='oper', isherm=True; Qobj data =; [[0. 3.]; [3. 0.]]. Coefficients; ============. To build time dependent quantum system we often use a list of :obj:`.Qobj` and; :obj:`.Coefficient`. These :obj:`.Coefficient` represent the strength of the corresponding; quantum object a function that of time. Up to now, we used functions for these,; but QuTiP support multiple formats: ``callable``, ``strings``, ``array``. **Function coefficients** :; Use a callable with the signature ``f(t: double, ...) -> double`` as coefficient.; Any function or method that can be called by ``f(t, args)``, ``f(t, **args)`` is accepted. .. code-block:: python. def coeff(t, A, sigma):; return A * np.exp(-(t / sigma)**2). H = QobjEvo([H0, [H1, coeff]], args=args). **String coefficients** :; Use a string containing a simple Python expression.; The variable ``t``, common mathematical functions such as ``sin`` or ``exp`` an; variable in args will be available. If available, the string will be compiled using; cython, fixing variable type when possible, allowing slightly faster execution than function.; While the speed up is usually very small, in long evolution, numerous calls to the; functions are made and it's can accumulate. From version 5, compilation of the; coefficient is done only once and saved between sessions. When either the cython or; filelock modules are not available, the code will be executed in python using; ``exec`` with the same environment . This, however, as no advantage over using; python function. .. code-block:: python. coeff = ""A * exp(-(t / sigma)**2)"". H = QobjEvo([H0, [H1, coeff]], args=args). Here is a list of defined variables:; ``sin``, ``cos``, ``tan``, ``asin``, ``acos``, ``atan``, ``pi``,; ``sinh``, ``cosh``, ``tanh``, ``asinh``, ``acosh``, ``atanh``,; ``exp``, ``log``, ``log10``, ``erf``, ``zerf``, ``sqrt``,; ``real``, ``imag``, ``conj``, ``abs``, ``",MatchSource.DOCS,doc/guide/dynamics/dynamics-time.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst
Deployability,update,update,"o(1)); Quantum object: dims=[[2], [2]], shape=(2, 2), type='oper', isherm=True; Qobj data =; [[ 1. 8.64710495]; [ 8.64710495 -1. ]]; >>> print(qevo(1, {""A"": 5, ""sigma"": 0.2})); Quantum object: dims=[[2], [2]], shape=(2, 2), type='oper', isherm=True; Qobj data =; [[ 1.00000000e+00 6.94397193e-11]; [ 6.94397193e-11 -1.00000000e+00]]; >>> print(qevo(1, A=5)); Quantum object: dims=[[2], [2]], shape=(2, 2), type='oper', isherm=True; Qobj data =; [[ 1. 4.8039472]; [ 4.8039472 -1. ]]. Whether the original coefficient used the ``args`` or specific input does not matter.; It is fine to mix the different signatures. Solver calls take an ``args`` input that is used to build the time dependent system.; If the Hamiltonian or collapse operators are already :obj:`.QobjEvo`, their arguments will be overwritten. .. code-block:: python. def system(t, A, sigma):; return H0 + H1 * (A * np.exp(-(t / sigma)**2)). mesolve(system, ..., args=args). To update arguments of an existing time dependent quantum system, you can pass the; previous object as the input of a :obj:`.QobjEvo` with new ``args``:. .. code-block:: python. >>> new_qevo = QobjEvo(qevo, args={""A"": 5, ""sigma"": 0.2}); >>> new_qevo(1) == qevo(1, {""A"": 5, ""sigma"": 0.2}); True. :obj:`.QobjEvo` created from a monolithic function can also use arguments:. .. code-block:: python. def oper(t, w):; return num(N) + (destroy(N) + create(N)) * np.sin(t*w). H_t = QobjEvo(oper, args={""w"": np.pi}). When merging two or more :obj:`.QobjEvo`, each will keep it arguments, but; calling it with updated are will affect all parts:. .. code-block:: python. >>> qevo1 = QobjEvo([[sigmap(), lambda t, a: a]], args={""a"": 1}); >>> qevo2 = QobjEvo([[sigmam(), lambda t, a: a]], args={""a"": 2}); >>> summed_evo = qevo1 + qevo2; >>> print(summed_evo(0)); Quantum object: dims=[[2], [2]], shape=(2, 2), type='oper', isherm=False; Qobj data =; [[0. 1.]; [2. 0.]]; >>> print(summed_evo(0, a=3, b=1)); Quantum object: dims=[[2], [2]], shape=(2, 2), type='oper', isherm=Tr",MatchSource.DOCS,doc/guide/dynamics/dynamics-time.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst
Energy Efficiency,efficient,efficient,"in solver, if the time dependent quantum system is; in list format, the solver tlist is used as times of the array.; This is often not ideal as the interpolation is usually less precise close the extremities of the range.; It is therefore better to create the QobjEvo using an extended range prior to the solver:. .. plot::; :context: close-figs. N = 5; times = np.linspace(-0.1, 1.1, 13); coeff = np.exp(-times). c_ops = [QobjEvo([destroy(N), coeff], tlist=times)]; tlist = np.linspace(0, 1, 11); data = mesolve(qeye(N), basis(N, N-1), tlist, c_ops=c_ops, e_ops=[num(N)]).expect[0]; plt.plot(tlist, data). Different coefficient types can be mixed in a :obj:`.QobjEvo`. Given the multiple choices of input style, the first question that arises is which option to choose?; In short, the function based method (first option) is the most general,; allowing for essentially arbitrary coefficients expressed via user defined functions.; However, by automatically compiling your system into C++ code,; the second option (string based) tends to be more efficient and run faster.; Of course, for small system sizes and evolution times, the difference will be minor.; Lastly the spline method is usually as fast the string method, but it cannot be modified once created. .. _time_max_step:. Working with pulses; ===================. Special care is needed when working with pulses. ODE solvers select the step; length automatically and can miss thin pulses when not properly warned.; Integrations methods with variable step sizes have the ``max_step`` option that; control the maximum length of a single internal integration step. This value; should be set to under half the pulse width to be certain they are not missed. For example, the following pulse is missed without fixing the maximum step length. .. plot::; :context: close-figs. def pulse(t):; return 10 * np.pi * (0.7 < t < 0.75). tlist = np.linspace(0, 1, 201); H = [sigmaz(), [sigmax(), pulse]]; psi0 = basis(2,1). data1 = sesolve(H, psi0, tlist, e",MatchSource.DOCS,doc/guide/dynamics/dynamics-time.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst
Integrability,depend,dependent,".. _time:. *************************************************; Solving Problems with Time-dependent Hamiltonians; *************************************************. Time-Dependent Operators; ========================. In the previous examples of quantum evolution,; we assumed that the systems under consideration were described by time-independent Hamiltonians.; However, many systems have explicit time dependence in either the Hamiltonian,; or the collapse operators describing coupling to the environment, and sometimes; both components might depend on time. The time-evolutions solvers such as :func:`.sesolve`,; :func:`.brmesolve`, etc. are all capable of handling time-dependent Hamiltonians and collapse terms.; QuTiP use :obj:`.QobjEvo` to represent time-dependent quantum operators.; There are three different ways to build a :obj:`.QobjEvo`:. 1. **Function based**: Build the time dependent operator from a function returning a :obj:`.Qobj`:. .. code-block:: python. def oper(t):; return num(N) + (destroy(N) + create(N)) * np.sin(t). H_t = QobjEvo(oper). 1. **List based**: The time dependent quantum operator is represented as a list of ``qobj`` and ``[qobj, coefficient]`` pairs:. .. code-block:: python. H_t = QobjEvo([num(N), [create(N), lambda t: np.sin(t)], [destroy(N), lambda t: np.sin(t)]]). 3. **coefficent based**: The product of a :obj:`.Qobj` with a :obj:`.Coefficient`,; created by the :func:`.coefficient` function, result in a :obj:`.QobjEvo`:. .. code-block:: python. coeff = coefficent(lambda t: np.sin(t)); H_t = num(N) + (destroy(N) + create(N)) * coeff. These 3 examples will create the same time dependent operator, however the function; based method will usually be slower when used in solver. Most solvers accept a :obj:`.QobjEvo` when an operator is expected: this include; the Hamiltonian ``H``, collapse operators, expectation values operators, the operator; of :func:`.brmesolve`'s ``a_ops``, etc. Exception are :func:`.krylovsolve`'s; Hamiltonian and HEOM's Bath",MatchSource.DOCS,doc/guide/dynamics/dynamics-time.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst
Modifiability,coupling,coupling,".. _time:. *************************************************; Solving Problems with Time-dependent Hamiltonians; *************************************************. Time-Dependent Operators; ========================. In the previous examples of quantum evolution,; we assumed that the systems under consideration were described by time-independent Hamiltonians.; However, many systems have explicit time dependence in either the Hamiltonian,; or the collapse operators describing coupling to the environment, and sometimes; both components might depend on time. The time-evolutions solvers such as :func:`.sesolve`,; :func:`.brmesolve`, etc. are all capable of handling time-dependent Hamiltonians and collapse terms.; QuTiP use :obj:`.QobjEvo` to represent time-dependent quantum operators.; There are three different ways to build a :obj:`.QobjEvo`:. 1. **Function based**: Build the time dependent operator from a function returning a :obj:`.Qobj`:. .. code-block:: python. def oper(t):; return num(N) + (destroy(N) + create(N)) * np.sin(t). H_t = QobjEvo(oper). 1. **List based**: The time dependent quantum operator is represented as a list of ``qobj`` and ``[qobj, coefficient]`` pairs:. .. code-block:: python. H_t = QobjEvo([num(N), [create(N), lambda t: np.sin(t)], [destroy(N), lambda t: np.sin(t)]]). 3. **coefficent based**: The product of a :obj:`.Qobj` with a :obj:`.Coefficient`,; created by the :func:`.coefficient` function, result in a :obj:`.QobjEvo`:. .. code-block:: python. coeff = coefficent(lambda t: np.sin(t)); H_t = num(N) + (destroy(N) + create(N)) * coeff. These 3 examples will create the same time dependent operator, however the function; based method will usually be slower when used in solver. Most solvers accept a :obj:`.QobjEvo` when an operator is expected: this include; the Hamiltonian ``H``, collapse operators, expectation values operators, the operator; of :func:`.brmesolve`'s ``a_ops``, etc. Exception are :func:`.krylovsolve`'s; Hamiltonian and HEOM's Bath",MatchSource.DOCS,doc/guide/dynamics/dynamics-time.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst
Testability,log,log," string containing a simple Python expression.; The variable ``t``, common mathematical functions such as ``sin`` or ``exp`` an; variable in args will be available. If available, the string will be compiled using; cython, fixing variable type when possible, allowing slightly faster execution than function.; While the speed up is usually very small, in long evolution, numerous calls to the; functions are made and it's can accumulate. From version 5, compilation of the; coefficient is done only once and saved between sessions. When either the cython or; filelock modules are not available, the code will be executed in python using; ``exec`` with the same environment . This, however, as no advantage over using; python function. .. code-block:: python. coeff = ""A * exp(-(t / sigma)**2)"". H = QobjEvo([H0, [H1, coeff]], args=args). Here is a list of defined variables:; ``sin``, ``cos``, ``tan``, ``asin``, ``acos``, ``atan``, ``pi``,; ``sinh``, ``cosh``, ``tanh``, ``asinh``, ``acosh``, ``atanh``,; ``exp``, ``log``, ``log10``, ``erf``, ``zerf``, ``sqrt``,; ``real``, ``imag``, ``conj``, ``abs``, ``norm``, ``arg``, ``proj``,; ``np`` (numpy), ``spe`` (scipy.special) and ``cython_special``; (scipy cython interface). **Array coefficients** :; Use the spline interpolation of an array.; Useful when the coefficient is hard to define as a function or obtained from experimental data.; The times at which the array are defined must be passed as ``tlist``:. .. code-block:: python. times = np.linspace(-sigma*5, sigma*5, 500); coeff = A * exp(-(times / sigma)**2). H = QobjEvo([H0, [H1, coeff]], tlist=times). Per default, a cubic spline interpolation is used, but the order of the interpolation can be controlled with the order input:; Outside the interpolation range, the first or last value are used. .. plot::; :context: close-figs. times = np.array([0, 0.1, 0.3, 0.6, 1.0]); coeff = times * (1.1 - times); tlist = np.linspace(-0.1, 1.1, 25). H = QobjEvo([qeye(1), coeff], tlist=times); plt.plo",MatchSource.DOCS,doc/guide/dynamics/dynamics-time.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst
Usability,simpl,simply," # |u><e|; a = tensor(destroy(N), qeye(3)); ada = tensor(num(N), qeye(3)). c_ops = [] # Build collapse operators; kappa = 1.5 # Cavity decay rate; c_ops.append(np.sqrt(kappa) * a); gamma = 6 # Atomic decay rate; c_ops.append(np.sqrt(5*gamma/9) * sigma_ue) # Use Rb branching ratio of 5/9 e->u; c_ops.append(np.sqrt(4*gamma/9) * sigma_ge) # 4/9 e->g. t = np.linspace(-15, 15, 100) # Define time vector; psi0 = tensor(basis(N, 0), ustate) # Define initial state. state_GG = tensor(basis(N, 1), ground) # Define states onto which to project; sigma_GG = state_GG * state_GG.dag(); state_UU = tensor(basis(N, 0), ustate); sigma_UU = state_UU * state_UU.dag(). g = 5 # coupling strength; H0 = -g * (sigma_ge.dag() * a + a.dag() * sigma_ge) # time-independent term; H1 = (sigma_ue.dag() + sigma_ue) # time-dependent term. Given that we have a single time-dependent Hamiltonian term, and constant collapse terms,; we need to specify a single Python function for the coefficient :math:`f(t)`.; In this case, one can simply do. .. plot::; :context: close-figs; :nofigs:. def H1_coeff(t):; return 9 * np.exp(-(t / 5.) ** 2). In this case, the return value depends only on time. However it is possible to; add optional arguments to the call, see `Using arguments`_.; Having specified our coefficient function, we can now specify the Hamiltonian in; list format and call the solver (in this case :func:`.mesolve`). .. plot::; :context: close-figs. H = [H0, [H1, H1_coeff]]; output = mesolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). We can call the Monte Carlo solver in the exact same way (if using the default ``ntraj=500``):. ..; Hacky fix because plot has complicated conditional code execution. .. doctest::; :skipif: True. output = mcsolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). The output from the master equation solver is identical to that shown in the examples,; the Monte Carlo however will be noticeably off, suggesting we should increase the number; of trajectories for this example. In ",MatchSource.DOCS,doc/guide/dynamics/dynamics-time.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/dynamics/dynamics-time.rst
Availability,avail,available,"ch the state was evaluated (i.e. ``tlist``); - ``states``: the system states at each time; - ``expect``: a list with the values of each ``e_ops`` at each time; - ``e_data``: a dictionary with the values of each ``e_op`` at each time; - ``ado_states``: see below (an instance of; :class:`~qutip.solver.heom.HierarchyADOsState`). If ``ado_return=True`` is passed to ``.run(...)`` the full set of auxilliary; density operators (ADOs) that make up the hierarchy at each time will be; returned as ``.ado_states``. We will describe how to use these to determine; other properties, such as system-bath currents, later in the fermionic guide; (see :ref:`heom-determining-currents`). If one has a full set of ADOs from a previous call of ``.run(...)`` you may; supply it as the initial state of the solver by calling; ``.run(result.ado_states[-1], tlist, ado_init=True)``. As with other QuTiP solvers, if expectation operators or functions are supplied; using ``.run(..., e_ops=[...])`` the expectation values are available in; ``result.expect`` and ``result.e_data``. Below we run the solver again, but use ``e_ops`` to store the expectation; values of the population of the system states and the coherence:. .. plot::; :context:. # Define the operators that measure the populations of the two; # system states:; P11p = basis(2,0) * basis(2,0).dag(); P22p = basis(2,1) * basis(2,1).dag(). # Define the operator that measures the 0, 1 element of density matrix; # (corresonding to coherence):; P12p = basis(2,0) * basis(2,1).dag(). # Run the solver:; tlist = np.linspace(0, 20, 101); result = solver.run(rho0, tlist, e_ops={""11"": P11p, ""22"": P22p, ""12"": P12p}). # Plot the results:; fig, axes = plt.subplots(1, 1, sharex=True, figsize=(8,8)); axes.plot(result.times, result.e_data[""11""], 'b', linewidth=2, label=""P11""); axes.plot(result.times, result.e_data[""12""], 'r', linewidth=2, label=""P12""); axes.set_xlabel(r't', fontsize=28); axes.legend(loc=0, fontsize=12). Steady-state; ------------. Using the same s",MatchSource.DOCS,doc/guide/heom/bosonic.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/heom/bosonic.rst
Energy Efficiency,energy,energy,"th with a; truncated expansion and show how to include an approximation to all of the; remaining terms in the bath expansion. Afterwards, we will show how to calculate the bath expansion coefficients and to; use those coefficients to construct your own bath description so that you can; implement your own bosonic baths. Finally, we will demonstrate how to simulate a system coupled to multiple; independent baths, as occurs, for example, in certain photosynthesis processes. A notebook containing a complete example similar to this one implemented in; BoFiN can be found in; `example notebook 1a <https://github.com/tehruhn/bofin/blob/main/examples/example-1a-Spin-bath-model-basic.ipynb>`__. Describing the system and bath; ------------------------------. First, let us construct the system Hamiltonian, :math:`H_{sys}`, and the initial; system state, ``rho0``:. .. plot::; :context: reset; :nofigs:. from qutip import basis, sigmax, sigmaz. # The system Hamiltonian:; eps = 0.5 # energy of the 2-level system; Del = 1.0 # tunnelling term; H_sys = 0.5 * eps * sigmaz() + 0.5 * Del * sigmax(). # Initial state of the system:; rho0 = basis(2,0) * basis(2,0).dag(). Now let us describe the bath properties:. .. plot::; :context:; :nofigs:. # Bath properties:; gamma = 0.5 # cut off frequency; lam = 0.1 # coupling strength; T = 0.5 # temperature. # System-bath coupling operator:; Q = sigmaz(). where :math:`\gamma` (``gamma``), :math:`\lambda` (``lam``) and :math:`T` are; the parameters of a Drude-Lorentz bath, and ``Q`` is the coupling operator; between the system and the bath. We may the pass these parameters to either; :class:`~qutip.solver.heom.DrudeLorentzBath` or; :class:`~qutip.solver.heom.DrudeLorentzPadeBath` to construct an expansion of; the bath correlations:. .. plot::; :context:; :nofigs:. from qutip.solver.heom import DrudeLorentzBath; from qutip.solver.heom import DrudeLorentzPadeBath. # Number of expansion terms to retain:; Nk = 2. # Matsubara expansion:; bath = DrudeLorent",MatchSource.DOCS,doc/guide/heom/bosonic.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/heom/bosonic.rst
Modifiability,evolve,evolve,"####################; Bosonic Environments; ####################. In this section we consider a simple two-level system coupled to a; Drude-Lorentz bosonic bath. The system Hamiltonian, :math:`H_{sys}`, and the bath; spectral density, :math:`J_D`, are. .. math::. H_{sys} &= \frac{\epsilon \sigma_z}{2} + \frac{\Delta \sigma_x}{2}. J_D &= \frac{2\lambda \gamma \omega}{(\gamma^2 + \omega^2)},. We will demonstrate how to describe the bath using two different expansions; of the spectral density correlation function (Matsubara's expansion and; a Padé expansion), how to evolve the system in time, and how to calculate; the steady state. First we will do this in the simplest way, using the built-in implementations of; the two bath expansions, :class:`~qutip.solver.heom.DrudeLorentzBath` and; :class:`~qutip.solver.heom.DrudeLorentzPadeBath`. We will do this both with a; truncated expansion and show how to include an approximation to all of the; remaining terms in the bath expansion. Afterwards, we will show how to calculate the bath expansion coefficients and to; use those coefficients to construct your own bath description so that you can; implement your own bosonic baths. Finally, we will demonstrate how to simulate a system coupled to multiple; independent baths, as occurs, for example, in certain photosynthesis processes. A notebook containing a complete example similar to this one implemented in; BoFiN can be found in; `example notebook 1a <https://github.com/tehruhn/bofin/blob/main/examples/example-1a-Spin-bath-model-basic.ipynb>`__. Describing the system and bath; ------------------------------. First, let us construct the system Hamiltonian, :math:`H_{sys}`, and the initial; system state, ``rho0``:. .. plot::; :context: reset; :nofigs:. from qutip import basis, sigmax, sigmaz. # The system Hamiltonian:; eps = 0.5 # energy of the 2-level system; Del = 1.0 # tunnelling term; H_sys = 0.5 * eps * sigmaz() + 0.5 * Del * sigmax(). # Initial state of the system:; rho0 = basis",MatchSource.DOCS,doc/guide/heom/bosonic.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/heom/bosonic.rst
Usability,simpl,simple,"####################; Bosonic Environments; ####################. In this section we consider a simple two-level system coupled to a; Drude-Lorentz bosonic bath. The system Hamiltonian, :math:`H_{sys}`, and the bath; spectral density, :math:`J_D`, are. .. math::. H_{sys} &= \frac{\epsilon \sigma_z}{2} + \frac{\Delta \sigma_x}{2}. J_D &= \frac{2\lambda \gamma \omega}{(\gamma^2 + \omega^2)},. We will demonstrate how to describe the bath using two different expansions; of the spectral density correlation function (Matsubara's expansion and; a Padé expansion), how to evolve the system in time, and how to calculate; the steady state. First we will do this in the simplest way, using the built-in implementations of; the two bath expansions, :class:`~qutip.solver.heom.DrudeLorentzBath` and; :class:`~qutip.solver.heom.DrudeLorentzPadeBath`. We will do this both with a; truncated expansion and show how to include an approximation to all of the; remaining terms in the bath expansion. Afterwards, we will show how to calculate the bath expansion coefficients and to; use those coefficients to construct your own bath description so that you can; implement your own bosonic baths. Finally, we will demonstrate how to simulate a system coupled to multiple; independent baths, as occurs, for example, in certain photosynthesis processes. A notebook containing a complete example similar to this one implemented in; BoFiN can be found in; `example notebook 1a <https://github.com/tehruhn/bofin/blob/main/examples/example-1a-Spin-bath-model-basic.ipynb>`__. Describing the system and bath; ------------------------------. First, let us construct the system Hamiltonian, :math:`H_{sys}`, and the initial; system state, ``rho0``:. .. plot::; :context: reset; :nofigs:. from qutip import basis, sigmax, sigmaz. # The system Hamiltonian:; eps = 0.5 # energy of the 2-level system; Del = 1.0 # tunnelling term; H_sys = 0.5 * eps * sigmaz() + 0.5 * Del * sigmax(). # Initial state of the system:; rho0 = basis",MatchSource.DOCS,doc/guide/heom/bosonic.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/heom/bosonic.rst
Availability,down,down,">`_,; and :math:`Nk` specifies the cut-off in the expansion. Evaluating the integral for the correlation functions gives:. .. math::. C^{\sigma}(t) \approx \sum_{l=0}^{Nk} \eta^{\sigma,l} e^{-\gamma_{\sigma,l}t}. where:. .. math::. \eta_{\sigma, l} &= \begin{cases}; \frac{\Gamma W}{2} f_F^{approx}(i\beta W) & l = 0\\; -i\cdot \frac{k_l}{\beta} \cdot \frac{\Gamma W^2}{-\frac{\epsilon^2_l}{\beta^2} + W^2} & l \neq 0\\; \end{cases}. \gamma_{\sigma,l} &= \begin{cases}; W - \sigma i\mu & l = 0\\; \frac{\epsilon_l}{\beta} - \sigma i \mu & l \neq 0\\; \end{cases}. and :math:`\beta = \frac{1}{T}`. And now we calculate the same numbers in Python:. .. plot::; :context:; :nofigs:. # Imports; from numpy.linalg import eigvalsh. # Convenience functions and parameters:; def deltafun(j, k):; """""" Kronecker delta function. """"""; return 1.0 if j == k else 0. def f_approx(x, Nk):; """""" Padé approxmation to Fermi distribution. """"""; f = 0.5; for ll in range(1, Nk + 1):; # kappa and epsilon are calculated further down; f = f - 2 * kappa[ll] * x / (x**2 + epsilon[ll]**2); return f. def kappa_epsilon(Nk):; """""" Calculate kappa and epsilon coefficients. """""". alpha = np.zeros((2 * Nk, 2 * Nk)); for j in range(2 * Nk):; for k in range(2 * Nk):; alpha[j][k] = (; (deltafun(j, k + 1) + deltafun(j, k - 1)); / np.sqrt((2 * (j + 1) - 1) * (2 * (k + 1) - 1)); ). eps = [-2. / val for val in eigvalsh(alpha)[:Nk]]. alpha_p = np.zeros((2 * Nk - 1, 2 * Nk - 1)); for j in range(2 * Nk - 1):; for k in range(2 * Nk - 1):; alpha_p[j][k] = (; (deltafun(j, k + 1) + deltafun(j, k - 1)); / np.sqrt((2 * (j + 1) + 1) * (2 * (k + 1) + 1)); ). chi = [-2. / val for val in eigvalsh(alpha_p)[:Nk - 1]]. eta_list = [; 0.5 * Nk * (2 * (Nk + 1) - 1) * (; np.prod([chi[k]**2 - eps[j]**2 for k in range(Nk - 1)]) /; np.prod([; eps[k]**2 - eps[j]**2 + deltafun(j, k) for k in range(Nk); ]); ); for j in range(Nk); ]. kappa = [0] + eta_list; epsilon = [0] + eps. return kappa, epsilon. kappa, epsilon = kappa_epsilon(Nk). # Phew, we made",MatchSource.DOCS,doc/guide/heom/fermionic.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/heom/fermionic.rst
Energy Efficiency,energy,energy,"ass:`~qutip.solver.heom.LorentzianPadeBath`. Afterwards, we will show how to calculate the bath expansion coefficients and to; use those coefficients to construct your own bath description so that you can; implement your own fermionic baths. Our implementation of fermionic baths primarily follows the definitions used by; Christian Schinabeck in his dissertation (; https://opus4.kobv.de/opus4-fau/files/10984/DissertationChristianSchinabeck.pdf; ) and related publications. A notebook containing a complete example similar to this one implemented in; BoFiN can be found in `example notebook 4b; <https://github.com/tehruhn/bofin/blob/main/examples/example-4b-fermions-single-impurity-model.ipynb>`__. Describing the system and bath; ------------------------------. First, let us construct the system Hamiltonian, :math:`H_{sys}`, and the initial; system state, ``rho0``:. .. plot::; :context: reset; :nofigs:. from qutip import basis, destroy. # The system Hamiltonian:; e1 = 1. # site energy; H_sys = e1 * destroy(2).dag() * destroy(2). # Initial state of the system:; rho0 = basis(2,0) * basis(2,0).dag(). Now let us describe the bath properties:. .. plot::; :context:; :nofigs:. # Shared bath properties:; gamma = 0.01 # coupling strength; W = 1.0 # cut-off; T = 0.025851991 # temperature; beta = 1. / T. # Chemical potentials for the two baths:; mu_L = 1.; mu_R = -1. # System-bath coupling operator:; Q = destroy(2). where :math:`\Gamma` (``gamma``), :math:`W` and :math:`T` are the parameters of; an Lorentzian bath, :math:`\mu_L` (``mu_L``) and :math:`\mu_R` (``mu_R``) are; the chemical potentials of the left and right baths, and ``Q`` is the coupling; operator between the system and the baths. We may the pass these parameters to either ``LorentzianBath`` or; ``LorentzianPadeBath`` to construct an expansion of the bath correlations:. .. plot::; :context:; :nofigs:. from qutip.solver.heom import LorentzianBath; from qutip.solver.heom import LorentzianPadeBath. # Number of expansion t",MatchSource.DOCS,doc/guide/heom/fermionic.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/heom/fermionic.rst
Modifiability,evolve,evolve,"######################; Fermionic Environments; ######################. Here we model a single fermion coupled to two electronic leads or reservoirs; (e.g., this can describe a single quantum dot, a molecular transistor, etc).; The system hamiltonian, :math:`H_{sys}`, and bath spectral density, :math:`J_D`,; are. .. math::. H_{sys} &= c^{\dagger} c. J_D &= \frac{\Gamma W^2}{(w - \mu)^2 + W^2},. We will demonstrate how to describe the bath using two different expansions; of the spectral density correlation function (Matsubara's expansion and; a Padé expansion), how to evolve the system in time, and how to calculate; the steady state. Since our fermion is coupled to two reservoirs, we will construct two baths --; one for each reservoir or lead -- and call them the left (:math:`L`) and right; (:math:`R`) baths for convenience. Each bath will have a different chemical; potential :math:`\mu` which we will label :math:`\mu_L` and :math:`\mu_R`. First we will do this using the built-in implementations of the bath expansions,; :class:`~qutip.solver.heom.LorentzianBath` and; :class:`~qutip.solver.heom.LorentzianPadeBath`. Afterwards, we will show how to calculate the bath expansion coefficients and to; use those coefficients to construct your own bath description so that you can; implement your own fermionic baths. Our implementation of fermionic baths primarily follows the definitions used by; Christian Schinabeck in his dissertation (; https://opus4.kobv.de/opus4-fau/files/10984/DissertationChristianSchinabeck.pdf; ) and related publications. A notebook containing a complete example similar to this one implemented in; BoFiN can be found in `example notebook 4b; <https://github.com/tehruhn/bofin/blob/main/examples/example-4b-fermions-single-impurity-model.ipynb>`__. Describing the system and bath; ------------------------------. First, let us construct the system Hamiltonian, :math:`H_{sys}`, and the initial; system state, ``rho0``:. .. plot::; :context: reset; :nofigs:. fro",MatchSource.DOCS,doc/guide/heom/fermionic.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/heom/fermionic.rst
Security,access,access,"en the system and the two baths. We will plot; these in the next section using the auxiliary density operators (ADOs); returned by the solver. .. _heom-determining-currents:. Determining currents; --------------------. The currents between the system and a fermionic bath may be calculated from the; first level auxiliary density operators (ADOs) associated with the exponents; of that bath. The contribution to the current into a given bath from each exponent in that; bath is:. .. math::. \mathrm{Contribution from Exponent} = \pm i \mathrm{Tr}(Q^\pm \cdot A). where the :math:`\pm` sign is the sign of the exponent (see the; description later in :ref:`heom-fermionic-pade-expansion-coefficients`) and; :math:`Q^\pm` is :math:`Q` for ``+`` exponents and :math:`Q^{\dagger}` for; ``-`` exponents. The first-level exponents for the left bath are retrieved by calling; ``.filter(tags=[""L""])`` on ``ado_state`` which is an instance of; :class:`~qutip.solver.heom.HierarchyADOsState` and also provides access to; the methods of :class:`~qutip.solver.heom.HierarchyADOs` which describes the; structure of the hierarchy for a given problem. Here the tag ""L"" matches the tag passed when constructing ``bath_L`` earlier; in this example. Similarly, we may calculate the current to the right bath from the exponents; tagged with ""R"". .. plot::; :context:; :nofigs:. def exp_current(aux, exp):; """""" Calculate the current for a single exponent. """"""; sign = 1 if exp.type == exp.types[""+""] else -1; op = exp.Q if exp.type == exp.types[""+""] else exp.Q.dag(); return 1j * sign * (op * aux).tr(). def heom_current(tag, ado_state):; """""" Calculate the current between the system and the given bath. """"""; level_1_ados = [; (ado_state.extract(label), ado_state.exps(label)[0]); for label in ado_state.filter(tags=[tag]); ]; return np.real(sum(exp_current(aux, exp) for aux, exp in level_1_ados)). heom_left_current = lambda t, ado_state: heom_current(""L"", ado_state); heom_right_current = lambda t, ado_state: heom_curr",MatchSource.DOCS,doc/guide/heom/fermionic.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/heom/fermionic.rst
Availability,avail,available,"########################; Previous implementations; ########################. The current HEOM implementation in QuTiP is the latest in a succession of HEOM; implementations by various contributors:. HSolverDL; ---------. The original HEOM solver was implemented by Neill Lambert, Anubhav Vardhan,; and Alexander Pitchford. In QuTiP 4.7 it was still available as; ``qutip.solve.nonmarkov.dlheom_solver.HSolverDL`` but the legacy implementation; was removed in QuTiP 5. It only directly provided support for the Drude-Lorentz bath although there was; the possibility of sub-classing the solver to implement other baths. A compatible interface using the current implementation is still available; under the same name in :class:`qutip.solver.heom.HSolverDL`. BoFiN-HEOM; ----------. BoFiN-HEOM (the bosonic and fermionic HEOM solver) was a much more; flexible re-write of the original QuTiP ``HSolverDL`` that added support for; both bosonic and fermionic baths and for baths to be specified directly via; their correlation function expansion coefficients. Its authors were; Neill Lambert, Tarun Raheja, Shahnawaz Ahmed, and Alexander Pitchford. BoFiN was written outside of QuTiP and is can still be found in its original; repository at https://github.com/tehruhn/bofin. The construction of the right-hand side matrix for BoFiN was slow, so; BoFiN-fast, a hybrid C++ and Python implementation, was written that performed; the right-hand side construction in C++. It was otherwise identical to the; pure Python version. BoFiN-fast can be found at; https://github.com/tehruhn/bofin_fast. BoFiN also came with an extensive set of example notebooks that are available; at https://github.com/tehruhn/bofin/tree/main/examples. Current implementation; ----------------------. The current implementation is a rewrite of BoFiN in pure Python. It's right-hand; side construction has similar speed to BoFiN-fast, but is written in pure; Python. Built-in implementations of a variety of different baths are provided",MatchSource.DOCS,doc/guide/heom/history.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/heom/history.rst
Integrability,interface,interface,"########################; Previous implementations; ########################. The current HEOM implementation in QuTiP is the latest in a succession of HEOM; implementations by various contributors:. HSolverDL; ---------. The original HEOM solver was implemented by Neill Lambert, Anubhav Vardhan,; and Alexander Pitchford. In QuTiP 4.7 it was still available as; ``qutip.solve.nonmarkov.dlheom_solver.HSolverDL`` but the legacy implementation; was removed in QuTiP 5. It only directly provided support for the Drude-Lorentz bath although there was; the possibility of sub-classing the solver to implement other baths. A compatible interface using the current implementation is still available; under the same name in :class:`qutip.solver.heom.HSolverDL`. BoFiN-HEOM; ----------. BoFiN-HEOM (the bosonic and fermionic HEOM solver) was a much more; flexible re-write of the original QuTiP ``HSolverDL`` that added support for; both bosonic and fermionic baths and for baths to be specified directly via; their correlation function expansion coefficients. Its authors were; Neill Lambert, Tarun Raheja, Shahnawaz Ahmed, and Alexander Pitchford. BoFiN was written outside of QuTiP and is can still be found in its original; repository at https://github.com/tehruhn/bofin. The construction of the right-hand side matrix for BoFiN was slow, so; BoFiN-fast, a hybrid C++ and Python implementation, was written that performed; the right-hand side construction in C++. It was otherwise identical to the; pure Python version. BoFiN-fast can be found at; https://github.com/tehruhn/bofin_fast. BoFiN also came with an extensive set of example notebooks that are available; at https://github.com/tehruhn/bofin/tree/main/examples. Current implementation; ----------------------. The current implementation is a rewrite of BoFiN in pure Python. It's right-hand; side construction has similar speed to BoFiN-fast, but is written in pure; Python. Built-in implementations of a variety of different baths are provided",MatchSource.DOCS,doc/guide/heom/history.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/heom/history.rst
Modifiability,flexible,flexible,"########################; Previous implementations; ########################. The current HEOM implementation in QuTiP is the latest in a succession of HEOM; implementations by various contributors:. HSolverDL; ---------. The original HEOM solver was implemented by Neill Lambert, Anubhav Vardhan,; and Alexander Pitchford. In QuTiP 4.7 it was still available as; ``qutip.solve.nonmarkov.dlheom_solver.HSolverDL`` but the legacy implementation; was removed in QuTiP 5. It only directly provided support for the Drude-Lorentz bath although there was; the possibility of sub-classing the solver to implement other baths. A compatible interface using the current implementation is still available; under the same name in :class:`qutip.solver.heom.HSolverDL`. BoFiN-HEOM; ----------. BoFiN-HEOM (the bosonic and fermionic HEOM solver) was a much more; flexible re-write of the original QuTiP ``HSolverDL`` that added support for; both bosonic and fermionic baths and for baths to be specified directly via; their correlation function expansion coefficients. Its authors were; Neill Lambert, Tarun Raheja, Shahnawaz Ahmed, and Alexander Pitchford. BoFiN was written outside of QuTiP and is can still be found in its original; repository at https://github.com/tehruhn/bofin. The construction of the right-hand side matrix for BoFiN was slow, so; BoFiN-fast, a hybrid C++ and Python implementation, was written that performed; the right-hand side construction in C++. It was otherwise identical to the; pure Python version. BoFiN-fast can be found at; https://github.com/tehruhn/bofin_fast. BoFiN also came with an extensive set of example notebooks that are available; at https://github.com/tehruhn/bofin/tree/main/examples. Current implementation; ----------------------. The current implementation is a rewrite of BoFiN in pure Python. It's right-hand; side construction has similar speed to BoFiN-fast, but is written in pure; Python. Built-in implementations of a variety of different baths are provided",MatchSource.DOCS,doc/guide/heom/history.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/heom/history.rst
Performance,perform,performed,"``qutip.solve.nonmarkov.dlheom_solver.HSolverDL`` but the legacy implementation; was removed in QuTiP 5. It only directly provided support for the Drude-Lorentz bath although there was; the possibility of sub-classing the solver to implement other baths. A compatible interface using the current implementation is still available; under the same name in :class:`qutip.solver.heom.HSolverDL`. BoFiN-HEOM; ----------. BoFiN-HEOM (the bosonic and fermionic HEOM solver) was a much more; flexible re-write of the original QuTiP ``HSolverDL`` that added support for; both bosonic and fermionic baths and for baths to be specified directly via; their correlation function expansion coefficients. Its authors were; Neill Lambert, Tarun Raheja, Shahnawaz Ahmed, and Alexander Pitchford. BoFiN was written outside of QuTiP and is can still be found in its original; repository at https://github.com/tehruhn/bofin. The construction of the right-hand side matrix for BoFiN was slow, so; BoFiN-fast, a hybrid C++ and Python implementation, was written that performed; the right-hand side construction in C++. It was otherwise identical to the; pure Python version. BoFiN-fast can be found at; https://github.com/tehruhn/bofin_fast. BoFiN also came with an extensive set of example notebooks that are available; at https://github.com/tehruhn/bofin/tree/main/examples. Current implementation; ----------------------. The current implementation is a rewrite of BoFiN in pure Python. It's right-hand; side construction has similar speed to BoFiN-fast, but is written in pure; Python. Built-in implementations of a variety of different baths are provided,; and a single solver is used for both fermionic and bosonic baths. Multiple baths; of either the same kind, or a mixture of fermionic and bosonic baths, may be; specified in a single problem, and there is good support for working with the; auxiliary density operator (ADO) state and extracting information from it. The code was written by Neill Lambert and Simo",MatchSource.DOCS,doc/guide/heom/history.rst,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/heom/history.rst
Availability,avail,available,"f doubt, where the; Work is a musical work, performance or phonogram, the synchronization of; the Work in timed-relation with a moving image (""synching"") will be; considered an Adaptation for the purpose of this License. b. ""Collection"" means a collection of literary or artistic works, such as; encyclopedias and anthologies, or performances, phonograms or broadcasts,; or other works or subject matter other than works listed in Section 1(f); below, which, by reason of the selection and arrangement of their; contents, constitute intellectual creations, in which the Work is; included in its entirety in unmodified form along with one or more other; contributions, each constituting separate and independent works in; themselves, which together are assembled into a collective whole. A work; that constitutes a Collection will not be considered an Adaptation (as; defined above) for the purposes of this License. c. ""Distribute"" means to make available to the public the original and; copies of the Work or Adaptation, as appropriate, through sale or other; transfer of ownership. d. ""Licensor"" means the individual, individuals, entity or entities that; offer(s) the Work under the terms of this License. e. ""Original Author"" means, in the case of a literary or artistic work, the; individual, individuals, entity or entities who created the Work or if no; individual or entity can be identified, the publisher; and in addition; (i) in the case of a performance the actors, singers, musicians, dancers,; and other persons who act, sing, deliver, declaim, play in, interpret or; otherwise perform literary or artistic works or expressions of folklore;; (ii) in the case of a phonogram the producer being the person or legal; entity who first fixes the sounds of a performance or other sounds; and,; (iii) in the case of broadcasts, the organization that transmits the; broadcast. f. ""Work"" means the literary and/or artistic work offered under the terms of; this License including without limitatio",MatchSource.DOCS,doc/LICENSE_cc-by-3.0.txt,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/LICENSE_cc-by-3.0.txt
Deployability,release,release,"NCIDENTAL, CONSEQUENTIAL, PUNITIVE OR EXEMPLARY DAMAGES ARISING OUT OF THIS; LICENSE OR THE USE OF THE WORK, EVEN IF LICENSOR HAS BEEN ADVISED OF THE; POSSIBILITY OF SUCH DAMAGES. 7. Termination. a. This License and the rights granted hereunder will terminate automatically; upon any breach by You of the terms of this License. Individuals or; entities who have received Adaptations or Collections from You under this; License, however, will not have their licenses terminated provided such; individuals or entities remain in full compliance with those licenses.; Sections 1, 2, 5, 6, 7, and 8 will survive any termination of this; License. b. Subject to the above terms and conditions, the license granted here is; perpetual (for the duration of the applicable copyright in the Work).; Notwithstanding the above, Licensor reserves the right to release the Work; under different license terms or to stop distributing the Work at any; time; provided, however that any such election will not serve to withdraw; this License (or any other license that has been, or is required to be,; granted under the terms of this License), and this License will continue; in full force and effect unless terminated as stated above. 8. Miscellaneous. a. Each time You Distribute or Publicly Perform the Work or a Collection,; the Licensor offers to the recipient a license to the Work on the same; terms and conditions as the license granted to You under this License. b. Each time You Distribute or Publicly Perform an Adaptation, Licensor; offers to the recipient a license to the original Work on the same terms; and conditions as the license granted to You under this License. c. If any provision of this License is invalid or unenforceable under; applicable law, it shall not affect the validity or enforceability of the; remainder of the terms of this License, and without further action by the; parties to this agreement, such provision shall be reformed to the; minimum extent necessary to make such provision",MatchSource.DOCS,doc/LICENSE_cc-by-3.0.txt,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/LICENSE_cc-by-3.0.txt
Energy Efficiency,adapt,adaptation,"THE WORK (AS DEFINED BELOW) IS PROVIDED UNDER THE TERMS OF THIS CREATIVE COMMONS; PUBLIC LICENSE (""CCPL"" OR ""LICENSE""). THE WORK IS PROTECTED BY COPYRIGHT AND/OR; OTHER APPLICABLE LAW. ANY USE OF THE WORK OTHER THAN AS AUTHORIZED UNDER THIS; LICENSE OR COPYRIGHT LAW IS PROHIBITED. BY EXERCISING ANY RIGHTS TO THE WORK PROVIDED HERE, YOU ACCEPT AND AGREE TO BE; BOUND BY THE TERMS OF THIS LICENSE. TO THE EXTENT THIS LICENSE MAY BE CONSIDERED; TO BE A CONTRACT, THE LICENSOR GRANTS YOU THE RIGHTS CONTAINED HERE IN; CONSIDERATION OF YOUR ACCEPTANCE OF SUCH TERMS AND CONDITIONS. 1. Definitions. a. ""Adaptation"" means a work based upon the Work, or upon the Work and other; pre-existing works, such as a translation, adaptation, derivative work,; arrangement of music or other alterations of a literary or artistic work,; or phonogram or performance and includes cinematographic adaptations or; any other form in which the Work may be recast, transformed, or adapted; including in any form recognizably derived from the original, except that; a work that constitutes a Collection will not be considered an Adaptation; for the purpose of this License. For the avoidance of doubt, where the; Work is a musical work, performance or phonogram, the synchronization of; the Work in timed-relation with a moving image (""synching"") will be; considered an Adaptation for the purpose of this License. b. ""Collection"" means a collection of literary or artistic works, such as; encyclopedias and anthologies, or performances, phonograms or broadcasts,; or other works or subject matter other than works listed in Section 1(f); below, which, by reason of the selection and arrangement of their; contents, constitute intellectual creations, in which the Work is; included in its entirety in unmodified form along with one or more other; contributions, each constituting separate and independent works in; themselves, which together are assembled into a collective whole. A work; that constitutes a Collection will no",MatchSource.DOCS,doc/LICENSE_cc-by-3.0.txt,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/LICENSE_cc-by-3.0.txt
Integrability,synchroniz,synchronization," PROHIBITED. BY EXERCISING ANY RIGHTS TO THE WORK PROVIDED HERE, YOU ACCEPT AND AGREE TO BE; BOUND BY THE TERMS OF THIS LICENSE. TO THE EXTENT THIS LICENSE MAY BE CONSIDERED; TO BE A CONTRACT, THE LICENSOR GRANTS YOU THE RIGHTS CONTAINED HERE IN; CONSIDERATION OF YOUR ACCEPTANCE OF SUCH TERMS AND CONDITIONS. 1. Definitions. a. ""Adaptation"" means a work based upon the Work, or upon the Work and other; pre-existing works, such as a translation, adaptation, derivative work,; arrangement of music or other alterations of a literary or artistic work,; or phonogram or performance and includes cinematographic adaptations or; any other form in which the Work may be recast, transformed, or adapted; including in any form recognizably derived from the original, except that; a work that constitutes a Collection will not be considered an Adaptation; for the purpose of this License. For the avoidance of doubt, where the; Work is a musical work, performance or phonogram, the synchronization of; the Work in timed-relation with a moving image (""synching"") will be; considered an Adaptation for the purpose of this License. b. ""Collection"" means a collection of literary or artistic works, such as; encyclopedias and anthologies, or performances, phonograms or broadcasts,; or other works or subject matter other than works listed in Section 1(f); below, which, by reason of the selection and arrangement of their; contents, constitute intellectual creations, in which the Work is; included in its entirety in unmodified form along with one or more other; contributions, each constituting separate and independent works in; themselves, which together are assembled into a collective whole. A work; that constitutes a Collection will not be considered an Adaptation (as; defined above) for the purposes of this License. c. ""Distribute"" means to make available to the public the original and; copies of the Work or Adaptation, as appropriate, through sale or other; transfer of ownership. d. ""Licensor"" me",MatchSource.DOCS,doc/LICENSE_cc-by-3.0.txt,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/LICENSE_cc-by-3.0.txt
Modifiability,adapt,adaptation,"THE WORK (AS DEFINED BELOW) IS PROVIDED UNDER THE TERMS OF THIS CREATIVE COMMONS; PUBLIC LICENSE (""CCPL"" OR ""LICENSE""). THE WORK IS PROTECTED BY COPYRIGHT AND/OR; OTHER APPLICABLE LAW. ANY USE OF THE WORK OTHER THAN AS AUTHORIZED UNDER THIS; LICENSE OR COPYRIGHT LAW IS PROHIBITED. BY EXERCISING ANY RIGHTS TO THE WORK PROVIDED HERE, YOU ACCEPT AND AGREE TO BE; BOUND BY THE TERMS OF THIS LICENSE. TO THE EXTENT THIS LICENSE MAY BE CONSIDERED; TO BE A CONTRACT, THE LICENSOR GRANTS YOU THE RIGHTS CONTAINED HERE IN; CONSIDERATION OF YOUR ACCEPTANCE OF SUCH TERMS AND CONDITIONS. 1. Definitions. a. ""Adaptation"" means a work based upon the Work, or upon the Work and other; pre-existing works, such as a translation, adaptation, derivative work,; arrangement of music or other alterations of a literary or artistic work,; or phonogram or performance and includes cinematographic adaptations or; any other form in which the Work may be recast, transformed, or adapted; including in any form recognizably derived from the original, except that; a work that constitutes a Collection will not be considered an Adaptation; for the purpose of this License. For the avoidance of doubt, where the; Work is a musical work, performance or phonogram, the synchronization of; the Work in timed-relation with a moving image (""synching"") will be; considered an Adaptation for the purpose of this License. b. ""Collection"" means a collection of literary or artistic works, such as; encyclopedias and anthologies, or performances, phonograms or broadcasts,; or other works or subject matter other than works listed in Section 1(f); below, which, by reason of the selection and arrangement of their; contents, constitute intellectual creations, in which the Work is; included in its entirety in unmodified form along with one or more other; contributions, each constituting separate and independent works in; themselves, which together are assembled into a collective whole. A work; that constitutes a Collection will no",MatchSource.DOCS,doc/LICENSE_cc-by-3.0.txt,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/LICENSE_cc-by-3.0.txt
Performance,perform,performance,"THE WORK (AS DEFINED BELOW) IS PROVIDED UNDER THE TERMS OF THIS CREATIVE COMMONS; PUBLIC LICENSE (""CCPL"" OR ""LICENSE""). THE WORK IS PROTECTED BY COPYRIGHT AND/OR; OTHER APPLICABLE LAW. ANY USE OF THE WORK OTHER THAN AS AUTHORIZED UNDER THIS; LICENSE OR COPYRIGHT LAW IS PROHIBITED. BY EXERCISING ANY RIGHTS TO THE WORK PROVIDED HERE, YOU ACCEPT AND AGREE TO BE; BOUND BY THE TERMS OF THIS LICENSE. TO THE EXTENT THIS LICENSE MAY BE CONSIDERED; TO BE A CONTRACT, THE LICENSOR GRANTS YOU THE RIGHTS CONTAINED HERE IN; CONSIDERATION OF YOUR ACCEPTANCE OF SUCH TERMS AND CONDITIONS. 1. Definitions. a. ""Adaptation"" means a work based upon the Work, or upon the Work and other; pre-existing works, such as a translation, adaptation, derivative work,; arrangement of music or other alterations of a literary or artistic work,; or phonogram or performance and includes cinematographic adaptations or; any other form in which the Work may be recast, transformed, or adapted; including in any form recognizably derived from the original, except that; a work that constitutes a Collection will not be considered an Adaptation; for the purpose of this License. For the avoidance of doubt, where the; Work is a musical work, performance or phonogram, the synchronization of; the Work in timed-relation with a moving image (""synching"") will be; considered an Adaptation for the purpose of this License. b. ""Collection"" means a collection of literary or artistic works, such as; encyclopedias and anthologies, or performances, phonograms or broadcasts,; or other works or subject matter other than works listed in Section 1(f); below, which, by reason of the selection and arrangement of their; contents, constitute intellectual creations, in which the Work is; included in its entirety in unmodified form along with one or more other; contributions, each constituting separate and independent works in; themselves, which together are assembled into a collective whole. A work; that constitutes a Collection will no",MatchSource.DOCS,doc/LICENSE_cc-by-3.0.txt,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/LICENSE_cc-by-3.0.txt
Safety,avoid,avoidance," PROHIBITED. BY EXERCISING ANY RIGHTS TO THE WORK PROVIDED HERE, YOU ACCEPT AND AGREE TO BE; BOUND BY THE TERMS OF THIS LICENSE. TO THE EXTENT THIS LICENSE MAY BE CONSIDERED; TO BE A CONTRACT, THE LICENSOR GRANTS YOU THE RIGHTS CONTAINED HERE IN; CONSIDERATION OF YOUR ACCEPTANCE OF SUCH TERMS AND CONDITIONS. 1. Definitions. a. ""Adaptation"" means a work based upon the Work, or upon the Work and other; pre-existing works, such as a translation, adaptation, derivative work,; arrangement of music or other alterations of a literary or artistic work,; or phonogram or performance and includes cinematographic adaptations or; any other form in which the Work may be recast, transformed, or adapted; including in any form recognizably derived from the original, except that; a work that constitutes a Collection will not be considered an Adaptation; for the purpose of this License. For the avoidance of doubt, where the; Work is a musical work, performance or phonogram, the synchronization of; the Work in timed-relation with a moving image (""synching"") will be; considered an Adaptation for the purpose of this License. b. ""Collection"" means a collection of literary or artistic works, such as; encyclopedias and anthologies, or performances, phonograms or broadcasts,; or other works or subject matter other than works listed in Section 1(f); below, which, by reason of the selection and arrangement of their; contents, constitute intellectual creations, in which the Work is; included in its entirety in unmodified form along with one or more other; contributions, each constituting separate and independent works in; themselves, which together are assembled into a collective whole. A work; that constitutes a Collection will not be considered an Adaptation (as; defined above) for the purposes of this License. c. ""Distribute"" means to make available to the public the original and; copies of the Work or Adaptation, as appropriate, through sale or other; transfer of ownership. d. ""Licensor"" me",MatchSource.DOCS,doc/LICENSE_cc-by-3.0.txt,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/LICENSE_cc-by-3.0.txt
Security,access,access,"rk of applied art; an illustration, map, plan, sketch or; three-dimensional work relative to geography, topography, architecture or; science; a performance; a broadcast; a phonogram; a compilation of data; to the extent it is protected as a copyrightable work; or a work; performed by a variety or circus performer to the extent it is not; otherwise considered a literary or artistic work. g. ""You"" means an individual or entity exercising rights under this License; who has not previously violated the terms of this License with respect to; the Work, or who has received express permission from the Licensor to; exercise rights under this License despite a previous violation. h. ""Publicly Perform"" means to perform public recitations of the Work and to; communicate to the public those public recitations, by any means or; process, including by wire or wireless means or public digital; performances; to make available to the public Works in such a way that; members of the public may access these Works from a place and at a place; individually chosen by them; to perform the Work to the public by any; means or process and the communication to the public of the performances; of the Work, including by public digital performance; to broadcast and; rebroadcast the Work by any means including signs, sounds or images. i. ""Reproduce"" means to make copies of the Work by any means including; without limitation by sound or visual recordings and the right of; fixation and reproducing fixations of the Work, including storage of a; protected performance or phonogram in digital form or other electronic; medium. 2. Fair Dealing Rights. Nothing in this License is intended to reduce, limit, or; restrict any uses free from copyright or rights arising from limitations or; exceptions that are provided for in connection with the copyright protection; under copyright law or other applicable laws. 3. License Grant. Subject to the terms and conditions of this License, Licensor; hereby grants You a worl",MatchSource.DOCS,doc/LICENSE_cc-by-3.0.txt,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/LICENSE_cc-by-3.0.txt
Testability,assert,assert,"uch URI does not refer to the copyright notice or; licensing information for the Work; and (iv) , consistent with Section; 3(b), in the case of an Adaptation, a credit identifying the use of the; Work in the Adaptation (e.g., ""French translation of the Work by Original; Author,"" or ""Screenplay based on original Work by Original Author""). The; credit required by this Section 4 (b) may be implemented in any; reasonable manner; provided, however, that in the case of a Adaptation or; Collection, at a minimum such credit will appear, if a credit for all; contributing authors of the Adaptation or Collection appears, then as; part of these credits and in a manner at least as prominent as the; credits for the other contributing authors. For the avoidance of doubt,; You may only use the credit required by this Section for the purpose of; attribution in the manner set out above and, by exercising Your rights; under this License, You may not implicitly or explicitly assert or imply; any connection with, sponsorship or endorsement by the Original Author,; Licensor and/or Attribution Parties, as appropriate, of You or Your use; of the Work, without the separate, express prior written permission of; the Original Author, Licensor and/or Attribution Parties. c. Except as otherwise agreed in writing by the Licensor or as may be; otherwise permitted by applicable law, if You Reproduce, Distribute or; Publicly Perform the Work either by itself or as part of any Adaptations; or Collections, You must not distort, mutilate, modify or take other; derogatory action in relation to the Work which would be prejudicial to; the Original Author's honor or reputation. Licensor agrees that in those; jurisdictions (e.g. Japan), in which any exercise of the right granted in; Section 3(b) of this License (the right to make Adaptations) would be; deemed to be a distortion, mutilation, modification or other derogatory; action prejudicial to the Original Author's honor and reputation, the; Licensor will",MatchSource.DOCS,doc/LICENSE_cc-by-3.0.txt,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/LICENSE_cc-by-3.0.txt
Usability,clear,clearly,"d or visual recordings and the right of; fixation and reproducing fixations of the Work, including storage of a; protected performance or phonogram in digital form or other electronic; medium. 2. Fair Dealing Rights. Nothing in this License is intended to reduce, limit, or; restrict any uses free from copyright or rights arising from limitations or; exceptions that are provided for in connection with the copyright protection; under copyright law or other applicable laws. 3. License Grant. Subject to the terms and conditions of this License, Licensor; hereby grants You a worldwide, royalty-free, non-exclusive, perpetual (for; the duration of the applicable copyright) license to exercise the rights in; the Work as stated below:. a. to Reproduce the Work, to incorporate the Work into one or more; Collections, and to Reproduce the Work as incorporated in the; Collections;. b. to create and Reproduce Adaptations provided that any such Adaptation,; including any translation in any medium, takes reasonable steps to; clearly label, demarcate or otherwise identify that changes were made to; the original Work. For example, a translation could be marked ""The; original work was translated from English to Spanish,"" or a modification; could indicate ""The original work has been modified."";. c. to Distribute and Publicly Perform the Work including as incorporated in; Collections; and,. d. to Distribute and Publicly Perform Adaptations. For the avoidance of doubt:. i. Non-waivable Compulsory License Schemes. In those jurisdictions in; which the right to collect royalties through any statutory or; compulsory licensing scheme cannot be waived, the Licensor reserves; the exclusive right to collect such royalties for any exercise by You; of the rights granted under this License;. ii. Waivable Compulsory License Schemes. In those jurisdictions in which; the right to collect royalties through any statutory or compulsory; licensing scheme can be waived, the Licensor waives the exclusive; ri",MatchSource.DOCS,doc/LICENSE_cc-by-3.0.txt,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/LICENSE_cc-by-3.0.txt
Modifiability,extend,extends,"{# Import the theme's layout. #}; {% extends ""!layout.html"" %}. {# Custom CSS overrides #}; {% set bootswatch_css_custom = ['_static/site.css'] %}",MatchSource.DOCS,doc/templates/layout.html,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/templates/layout.html
Availability,error,error,". '''; Code for simulating secure key rate, twofolds, and quantum bit error rate; Written in Python and QuTIP by Catherine Holloway (c2hollow@iqc.ca). Detector model and squashing functions by Catherine Holloway,; based on code by Dr. Thomas Jennewein (tjennewe@iqc.ca). Contributed to the QuTiP project on June 06, 2012 by Catherine Holloway.; '''. #imports; from qutip import *; from numpy import *; from pylab import *; import matplotlib; import matplotlib.pyplot as plt. def choose(n, k):; 	""""""; 	Binomial coefficient function for the detector model.; 	; 	Parameters; 	----------; 	n : int; 	 Number of elements.; 	k : int; 	 Number of subelements.; 	; 	Returns; 	-------; 	coeff : int; 	 Binomial coefficient.; 	; 	""""""; 	if 0 <= k <= n:; 		ntok = 1; 		ktok = 1; 		for t in xrange(1, min(k, n - k) + 1):; 			ntok *= n; 			ktok *= t; 			n -= 1; 		return ntok // ktok; 	else:; 		return 0. def BucketDetector_realistic_detector(N,efficiency,n_factor):; 	""""""; 	Bucket detector model based on H. Lee, U. Yurtsever, P. Kok, G. Hockney, C. Adami, S. Braunstein,; 	and J. Dowling, ""Towards photostatistics from photon-number discriminating detectors,""; 	Journal of Modern Optics, vol. 51, p. 15171528, 2004.; 	; 	Parameters; 	----------; 	N : int ; 	 The Fock Space dimension.; 	efficiency : float; 	 The channel efficiency.; 	n_factor : float; 	 The average number of dark counts per detection window APD (Bucket Detector).; 	; 	Returns; 	-------; 	[proj, un_proj] : list; 	 The projection and unprojection operators.; 	; 	""""""; 	proj=zeros((N,N)); 	#APD (Bucket Detector) un_detector (=gives probability for 0-detection); 	un_proj=identity(N); 	#n_factor = 0;; 	for i in range(N):; 	 probs = 0;; 	 for k in range (1,100):; 	 for d in range(k+1):; 	 if k-d<=i:; 	 probs= probs+ (exp(-n_factor)*(n_factor)**(d))/factorial(d)*choose(i,k-d)*efficiency**(k-d)*(1-efficiency)**(i-k+d); 	 ; 	 proj[i,i]=probs; 	 ; 	; 	un_proj = un_proj-proj; 	un_proj = Qobj(un_proj); 	proj = Qobj(proj); 	return [proj,un_proj].",MatchSource.DOCS,doc/contrib/sim_ent_qkd/sim_ent_qkd.html,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.html
Deployability,configurat,configurations,"he entangled state to analyze; 	proj1 : qobj; 	 1st projection operator for the Channel between Alice and; 	the Channel between Bob.; 	proj2 : qobj; 	 2nd projection operator for the Channel between Alice and ; 	 the Channel between Bob.; 	; 	Returns; 	-------; 	[HH,HV,VH,VV] : list; 	 Two-fold probabilities.; 	; 	Notes; 	-----; 	The squashing (assigning double pairs to random bases) comes from two papers:; 	; 	 T. Moroder, O. Guhne, N. Beaudry, M. Piani, and N. Lutkenhaus,; 	 ""Entanglement verication with realistic measurement devices via squashing operations,""; 	 Phys. Rev. A, vol. 81, p. 052342, May 2010.; 	; 	 N. Lutkenhaus, ""Estimates for practical quantum cryptography,"" Phys. Rev.A,; 	 vol. 59, pp. 3301-3319, May 1999.; 	; 	""""""; 	ida=qeye(N); 	final_state=psi; 	det_exp = zeros((2,2,2,2)). 	#i,j,k,l means Ha,Va,Hb,Vb, 0 means detector clicked, 1 means detector did not click; 	for i in range(2):; 		for j in range(2):; 			for k in range(2):; 				for l in range(2):; 					#expectation values for different detector configurations; 					det_exp[i][j][k][l] = abs(expect(tensor(proj[i],proj[j],proj2[k],proj[l]),final_state)); 	#two fold probabilities; 	HH = det_exp[0][1][0][1]+0.5*(det_exp[0][0][0][1]+det_exp[0][1][0][0])+0.25*det_exp[0][0][0][0]; 	VV = det_exp[1][0][1][0]+0.5*(det_exp[0][0][1][0]+det_exp[1][0][0][0])+0.25*det_exp[0][0][0][0]; 	HV = det_exp[0][1][1][0]+0.5*(det_exp[0][0][1][0]+det_exp[0][1][0][0])+0.25*det_exp[0][0][0][0]; 	VH = det_exp[1][0][0][1]+0.5*(det_exp[0][0][0][1]+det_exp[1][0][0][0])+0.25*det_exp[0][0][0][0]. 	return [HH,HV,VH,VV]. def sim_qkd_entanglement(eps,loss_a,loss_b,n_factor_a,n_factor_b,N):; 	""""""; 	Simulate skr with an SPDC state.; 	; 	Parameters; 	----------; 	eps : float; 	 The squeezing factor, sort of analogous to the amount of ; 	 pumping power to the spdc source, but not really.; 	loss_a : float; 	 Efficiency of the quantum channel going to Alice.; 	loss_b : float; 	 Efficiency of the quantum channel going to Bob. ; 	n_factor_a",MatchSource.DOCS,doc/contrib/sim_ent_qkd/sim_ent_qkd.html,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.html
Energy Efficiency,power,power,"te=psi; 	det_exp = zeros((2,2,2,2)). 	#i,j,k,l means Ha,Va,Hb,Vb, 0 means detector clicked, 1 means detector did not click; 	for i in range(2):; 		for j in range(2):; 			for k in range(2):; 				for l in range(2):; 					#expectation values for different detector configurations; 					det_exp[i][j][k][l] = abs(expect(tensor(proj[i],proj[j],proj2[k],proj[l]),final_state)); 	#two fold probabilities; 	HH = det_exp[0][1][0][1]+0.5*(det_exp[0][0][0][1]+det_exp[0][1][0][0])+0.25*det_exp[0][0][0][0]; 	VV = det_exp[1][0][1][0]+0.5*(det_exp[0][0][1][0]+det_exp[1][0][0][0])+0.25*det_exp[0][0][0][0]; 	HV = det_exp[0][1][1][0]+0.5*(det_exp[0][0][1][0]+det_exp[0][1][0][0])+0.25*det_exp[0][0][0][0]; 	VH = det_exp[1][0][0][1]+0.5*(det_exp[0][0][0][1]+det_exp[1][0][0][0])+0.25*det_exp[0][0][0][0]. 	return [HH,HV,VH,VV]. def sim_qkd_entanglement(eps,loss_a,loss_b,n_factor_a,n_factor_b,N):; 	""""""; 	Simulate skr with an SPDC state.; 	; 	Parameters; 	----------; 	eps : float; 	 The squeezing factor, sort of analogous to the amount of ; 	 pumping power to the spdc source, but not really.; 	loss_a : float; 	 Efficiency of the quantum channel going to Alice.; 	loss_b : float; 	 Efficiency of the quantum channel going to Bob. ; 	n_factor_a : float; 	 Background noise in Alice's detection.; 	n_factor_b : float; 	 Background noise in Bob's detection.; 	N : int; 	 Size of the fock space that we allow for the states; 	; 	Returns; 	-------; 	qber : float; 	 The Quantum Bit Error Rate; 	twofolds : float; 	 Probability of Alice and Bob getting a simultaneous detection ; 	 of a photon pair (also referred to as coincidences) within a ; 	 timing window.; 	skr : float; 	 Probability of getting a secure key bit within a timing window, ; 	 assuming error correction and privacy amplification, in the ; 	 limit of many coincidences.; ; """"""; 	#make vaccuum state; 	vacc = basis(N,0). 	#make squeezing operator for SPDC; 	H_sq = 1j*eps*(tensor(create(N),create(N))+tensor(destroy(N),destroy(N))); 	; 	#exponentiate ",MatchSource.DOCS,doc/contrib/sim_ent_qkd/sim_ent_qkd.html,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.html
Modifiability,config,configurations,"he entangled state to analyze; 	proj1 : qobj; 	 1st projection operator for the Channel between Alice and; 	the Channel between Bob.; 	proj2 : qobj; 	 2nd projection operator for the Channel between Alice and ; 	 the Channel between Bob.; 	; 	Returns; 	-------; 	[HH,HV,VH,VV] : list; 	 Two-fold probabilities.; 	; 	Notes; 	-----; 	The squashing (assigning double pairs to random bases) comes from two papers:; 	; 	 T. Moroder, O. Guhne, N. Beaudry, M. Piani, and N. Lutkenhaus,; 	 ""Entanglement verication with realistic measurement devices via squashing operations,""; 	 Phys. Rev. A, vol. 81, p. 052342, May 2010.; 	; 	 N. Lutkenhaus, ""Estimates for practical quantum cryptography,"" Phys. Rev.A,; 	 vol. 59, pp. 3301-3319, May 1999.; 	; 	""""""; 	ida=qeye(N); 	final_state=psi; 	det_exp = zeros((2,2,2,2)). 	#i,j,k,l means Ha,Va,Hb,Vb, 0 means detector clicked, 1 means detector did not click; 	for i in range(2):; 		for j in range(2):; 			for k in range(2):; 				for l in range(2):; 					#expectation values for different detector configurations; 					det_exp[i][j][k][l] = abs(expect(tensor(proj[i],proj[j],proj2[k],proj[l]),final_state)); 	#two fold probabilities; 	HH = det_exp[0][1][0][1]+0.5*(det_exp[0][0][0][1]+det_exp[0][1][0][0])+0.25*det_exp[0][0][0][0]; 	VV = det_exp[1][0][1][0]+0.5*(det_exp[0][0][1][0]+det_exp[1][0][0][0])+0.25*det_exp[0][0][0][0]; 	HV = det_exp[0][1][1][0]+0.5*(det_exp[0][0][1][0]+det_exp[0][1][0][0])+0.25*det_exp[0][0][0][0]; 	VH = det_exp[1][0][0][1]+0.5*(det_exp[0][0][0][1]+det_exp[1][0][0][0])+0.25*det_exp[0][0][0][0]. 	return [HH,HV,VH,VV]. def sim_qkd_entanglement(eps,loss_a,loss_b,n_factor_a,n_factor_b,N):; 	""""""; 	Simulate skr with an SPDC state.; 	; 	Parameters; 	----------; 	eps : float; 	 The squeezing factor, sort of analogous to the amount of ; 	 pumping power to the spdc source, but not really.; 	loss_a : float; 	 Efficiency of the quantum channel going to Alice.; 	loss_b : float; 	 Efficiency of the quantum channel going to Bob. ; 	n_factor_a",MatchSource.DOCS,doc/contrib/sim_ent_qkd/sim_ent_qkd.html,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.html
Safety,detect,detector,". '''; Code for simulating secure key rate, twofolds, and quantum bit error rate; Written in Python and QuTIP by Catherine Holloway (c2hollow@iqc.ca). Detector model and squashing functions by Catherine Holloway,; based on code by Dr. Thomas Jennewein (tjennewe@iqc.ca). Contributed to the QuTiP project on June 06, 2012 by Catherine Holloway.; '''. #imports; from qutip import *; from numpy import *; from pylab import *; import matplotlib; import matplotlib.pyplot as plt. def choose(n, k):; 	""""""; 	Binomial coefficient function for the detector model.; 	; 	Parameters; 	----------; 	n : int; 	 Number of elements.; 	k : int; 	 Number of subelements.; 	; 	Returns; 	-------; 	coeff : int; 	 Binomial coefficient.; 	; 	""""""; 	if 0 <= k <= n:; 		ntok = 1; 		ktok = 1; 		for t in xrange(1, min(k, n - k) + 1):; 			ntok *= n; 			ktok *= t; 			n -= 1; 		return ntok // ktok; 	else:; 		return 0. def BucketDetector_realistic_detector(N,efficiency,n_factor):; 	""""""; 	Bucket detector model based on H. Lee, U. Yurtsever, P. Kok, G. Hockney, C. Adami, S. Braunstein,; 	and J. Dowling, ""Towards photostatistics from photon-number discriminating detectors,""; 	Journal of Modern Optics, vol. 51, p. 15171528, 2004.; 	; 	Parameters; 	----------; 	N : int ; 	 The Fock Space dimension.; 	efficiency : float; 	 The channel efficiency.; 	n_factor : float; 	 The average number of dark counts per detection window APD (Bucket Detector).; 	; 	Returns; 	-------; 	[proj, un_proj] : list; 	 The projection and unprojection operators.; 	; 	""""""; 	proj=zeros((N,N)); 	#APD (Bucket Detector) un_detector (=gives probability for 0-detection); 	un_proj=identity(N); 	#n_factor = 0;; 	for i in range(N):; 	 probs = 0;; 	 for k in range (1,100):; 	 for d in range(k+1):; 	 if k-d<=i:; 	 probs= probs+ (exp(-n_factor)*(n_factor)**(d))/factorial(d)*choose(i,k-d)*efficiency**(k-d)*(1-efficiency)**(i-k+d); 	 ; 	 proj[i,i]=probs; 	 ; 	; 	un_proj = un_proj-proj; 	un_proj = Qobj(un_proj); 	proj = Qobj(proj); 	return [proj,un_proj].",MatchSource.DOCS,doc/contrib/sim_ent_qkd/sim_ent_qkd.html,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.html
Security,secur,secure,". '''; Code for simulating secure key rate, twofolds, and quantum bit error rate; Written in Python and QuTIP by Catherine Holloway (c2hollow@iqc.ca). Detector model and squashing functions by Catherine Holloway,; based on code by Dr. Thomas Jennewein (tjennewe@iqc.ca). Contributed to the QuTiP project on June 06, 2012 by Catherine Holloway.; '''. #imports; from qutip import *; from numpy import *; from pylab import *; import matplotlib; import matplotlib.pyplot as plt. def choose(n, k):; 	""""""; 	Binomial coefficient function for the detector model.; 	; 	Parameters; 	----------; 	n : int; 	 Number of elements.; 	k : int; 	 Number of subelements.; 	; 	Returns; 	-------; 	coeff : int; 	 Binomial coefficient.; 	; 	""""""; 	if 0 <= k <= n:; 		ntok = 1; 		ktok = 1; 		for t in xrange(1, min(k, n - k) + 1):; 			ntok *= n; 			ktok *= t; 			n -= 1; 		return ntok // ktok; 	else:; 		return 0. def BucketDetector_realistic_detector(N,efficiency,n_factor):; 	""""""; 	Bucket detector model based on H. Lee, U. Yurtsever, P. Kok, G. Hockney, C. Adami, S. Braunstein,; 	and J. Dowling, ""Towards photostatistics from photon-number discriminating detectors,""; 	Journal of Modern Optics, vol. 51, p. 15171528, 2004.; 	; 	Parameters; 	----------; 	N : int ; 	 The Fock Space dimension.; 	efficiency : float; 	 The channel efficiency.; 	n_factor : float; 	 The average number of dark counts per detection window APD (Bucket Detector).; 	; 	Returns; 	-------; 	[proj, un_proj] : list; 	 The projection and unprojection operators.; 	; 	""""""; 	proj=zeros((N,N)); 	#APD (Bucket Detector) un_detector (=gives probability for 0-detection); 	un_proj=identity(N); 	#n_factor = 0;; 	for i in range(N):; 	 probs = 0;; 	 for k in range (1,100):; 	 for d in range(k+1):; 	 if k-d<=i:; 	 probs= probs+ (exp(-n_factor)*(n_factor)**(d))/factorial(d)*choose(i,k-d)*efficiency**(k-d)*(1-efficiency)**(i-k+d); 	 ; 	 proj[i,i]=probs; 	 ; 	; 	un_proj = un_proj-proj; 	un_proj = Qobj(un_proj); 	proj = Qobj(proj); 	return [proj,un_proj].",MatchSource.DOCS,doc/contrib/sim_ent_qkd/sim_ent_qkd.html,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.html
Testability,log,log,"N, N], [1, 1, 1, 1]]). 	# model detectors; 	a_det = BucketDetector_realistic_detector(N,loss_a,n_factor_a); 	b_det = BucketDetector_realistic_detector(N,loss_b,n_factor_b); 	; 	#measure detection probabilities; 	probs2f=measure_2folds_4modes_squashing(N,psi,a_det,b_det). 	#Rates returned are 'per pulse', so multiply by source rate; 	twofolds=probs2f[0]+probs2f[1]+probs2f[2]+probs2f[3]; 	#Determine QBER from returned detection probabilities; 	qber = (probs2f[0]+probs2f[3])/twofolds. 	#calculate the entropy of the qber ; 	if qber>0:; 		H2=-qber*log2(qber) - (1-qber)*log2(1-qber); 	else:; 		H2 = 0; 	# estimate error correction efficiency from the CASCADE algorithm ; 	f_e = 1.16904371810274 + qber; 	#security analysis - calculate skr in infinite key limit; 	#See Chris Erven's PhD thesis or Xiongfeng Ma's paper ; 	#to understand where this equation comes from; 	skr=real(twofolds*0.5*(1-(1+f_e)*H2)); 	return [qber, skr, twofolds]. if __name__=='__main__':; 	#Lets look at what happens to the secure key rate and ; 	#the quantum bit error rate as the loss gets worse.; 	#Analogous to distance with fiber optic links.; 	; 	#define the fock space; 	N = 7; 	#define the squeezing paramter; 	eps = 0.2; 	#define the noise factor; 	n_factor = 4.0e-5; 	#define the length of the coincidence window (in s); 	coinc_window = 2.0e-9; 	loss_db = arange(0,30); 	skr = zeros(30); 	qber = zeros(30); 	twofolds = zeros(30); ; #run calculation; 	for i in range(30):; 		exp_loss = 10.0**(-loss_db[i]/10.0);; 		[qber[i], skr[i], twofolds[i]] = sim_qkd_entanglement(eps,exp_loss,exp_loss,n_factor,n_factor,N); 	skr = skr/coinc_window; 	qber = qber*100; ; #plot results; 	fig = plt.figure(); 	ax = fig.add_subplot(211); 	ax.plot(loss_db, skr,lw=2); 	ax.set_yscale('log'); 	ax.set_ylabel('Secure Key Rate (bits/s)'); 	ax.set_xlabel('Loss (dB)'); 	ax = fig.add_subplot(212); 	ax.plot(loss_db, qber,lw=2); 	ax.set_ylabel('Quantum Bit Error Rate (%)'); 	ax.set_ylim([0,15]); 	ax.set_xlabel('Loss (dB)'); 	plt.show(). ",MatchSource.DOCS,doc/contrib/sim_ent_qkd/sim_ent_qkd.html,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.html
