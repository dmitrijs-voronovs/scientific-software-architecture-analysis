quality_attribute,keyword,matched_word,sentence,source,author,repo,version,wiki,url
Safety,redund,redundancies,"I'm usually for verbose names as they are clearer but in this case the basic regular rectilinear grid is something every user will interact with and will show up in at the top of each example/tutorial so I agree with @francispoulin that a shorter name (without redundancies) would be good. We probably need more than just 1 approval to merge this PR, preferably unanimous consent amongst ourselves?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1386#issuecomment-782316024
Usability,clear,clearer,"I'm usually for verbose names as they are clearer but in this case the basic regular rectilinear grid is something every user will interact with and will show up in at the top of each example/tutorial so I agree with @francispoulin that a shorter name (without redundancies) would be good. We probably need more than just 1 approval to merge this PR, preferably unanimous consent amongst ourselves?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1386#issuecomment-782316024
Safety,detect,detect,@tomchor I think it should automatically detect dimensions for `WindowedSpatialAverage` now but the solution is not pretty since `NetCDFOutputWriter` plays nicest with fields. Could probably be made clearer though.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-783762674
Usability,clear,clearer,@tomchor I think it should automatically detect dimensions for `WindowedSpatialAverage` now but the solution is not pretty since `NetCDFOutputWriter` plays nicest with fields. Could probably be made clearer though.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-783762674
Availability,error,errors,"This seems to work out-of-the box with our simple example, but I'm encountering errors when applying to one of my complex scripts. I'm getting errors of the kind `ERROR: LoadError: Custom output b_tot needs dimensions!`. And when I do specify the dimensions manually I get `Trying to write (1, 1, 16) elements while [17, 1] are expected`. So clearly we're missing something. Looking at the behavior of `AveragedField` I think we should not `dropdim` when doing the average anymore since `AveragedField` always returns a 3D array:. ```julia; julia> bmean = AveragedField(b, dims=(1, 2)); AveragedField over dims=(1, 2) located at (⋅, ⋅, Center) of Field located at (Center, Center, Center); ├── data: OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}}, size: (1, 1, 20); ├── grid: RegularRectilinearGrid{Float64, Periodic, Bounded, Bounded}(Nx=1, Ny=1024, Nz=16); ├── dims: (1, 2); ├── operand: Field located at (Center, Center, Center); └── status: time=0.0. julia> bmean.data; 1×1×20 OffsetArray(::Array{Float64,3}, 1:1, 1:1, -1:18) with eltype Float64 with indices 1:1×1:1×-1:18:; [:, :, -1] =; 0.0. [:, :, 0] =; 0.0. [:, :, 1] =; 0.0. ... [:, :, 16] =; 0.0. [:, :, 17] =; 0.0. [:, :, 18] =; 0.0; ```. But even without using `dropdim` I still get an error. I think maybe the issue is because `WindowedSpatialAverage` is returning an Array, and not an OffsetArray. Any thoughts?. ```julia; julia> bwind = WindowedSpatialAverage(b, dims=(1, 2), field_slicer=FieldSlicer(j=3:7)); WindowedSpatialAverage{Field{Center,Center,Center,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularRectilinearGrid{Float64,Periodic,Bounded,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{F",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-783777559
Usability,simpl,simple,"This seems to work out-of-the box with our simple example, but I'm encountering errors when applying to one of my complex scripts. I'm getting errors of the kind `ERROR: LoadError: Custom output b_tot needs dimensions!`. And when I do specify the dimensions manually I get `Trying to write (1, 1, 16) elements while [17, 1] are expected`. So clearly we're missing something. Looking at the behavior of `AveragedField` I think we should not `dropdim` when doing the average anymore since `AveragedField` always returns a 3D array:. ```julia; julia> bmean = AveragedField(b, dims=(1, 2)); AveragedField over dims=(1, 2) located at (⋅, ⋅, Center) of Field located at (Center, Center, Center); ├── data: OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}}, size: (1, 1, 20); ├── grid: RegularRectilinearGrid{Float64, Periodic, Bounded, Bounded}(Nx=1, Ny=1024, Nz=16); ├── dims: (1, 2); ├── operand: Field located at (Center, Center, Center); └── status: time=0.0. julia> bmean.data; 1×1×20 OffsetArray(::Array{Float64,3}, 1:1, 1:1, -1:18) with eltype Float64 with indices 1:1×1:1×-1:18:; [:, :, -1] =; 0.0. [:, :, 0] =; 0.0. [:, :, 1] =; 0.0. ... [:, :, 16] =; 0.0. [:, :, 17] =; 0.0. [:, :, 18] =; 0.0; ```. But even without using `dropdim` I still get an error. I think maybe the issue is because `WindowedSpatialAverage` is returning an Array, and not an OffsetArray. Any thoughts?. ```julia; julia> bwind = WindowedSpatialAverage(b, dims=(1, 2), field_slicer=FieldSlicer(j=3:7)); WindowedSpatialAverage{Field{Center,Center,Center,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularRectilinearGrid{Float64,Periodic,Bounded,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{F",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-783777559
Usability,learn,learning,"Thanks, everyone! Sorry it took so long, the learning curve was a little steeper than I thought. Next one will probably go smoother ;)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-788011056
Usability,clear,clear,"Just to be completely clear I am suggesting changing the above to. ```julia; convert_output(outputs::NamedTuple, writer) = ; NamedTuple{keys(outputs)}(Tuple(convert_output(output, writer) for output in outputs)); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1398#issuecomment-784318930
Usability,feedback,feedback,"> What is the limitation you're referring to?. I'm referring to the fact that if you calculate a new quantity inside the kernel and then try to differentiate it the differentiation will fail because the new quantity will be a number and not a field. At least that's what I understood is happening in the piece of code below based on your feedback:. ```julia; wp = ℑzᵃᵃᶠ(i, j, k, grid, p) * w[i, j, k]; ```. Also I'm closing the issue since my I've found a workaround to it based on your comments.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1401#issuecomment-786855273
Usability,clear,clear,"Great!. Just to clear up the conversation, I think its incorrect to refer to what we've discovered as a ""limitation"". Instead, we found a bug in the kernel function. The ""workaround"" is not a work around in the usual sense --- its just one _correct_ way to express the intent with code. There are several other ways to write this relatively simple kernel, which may be illuminating to explore. Exploiting the fact the the derivative function can be applied to functions of the form `f(i, j, k, grid, args...)` (as we have designed it) we might also write. ```julia; @inline wpᵃᵃᶠ(i, j, k, grid, w, p) = @inbounds ℑzᵃᵃᶠ(i, j, k, grid, p) * w[i, j, k] . @kernel function pressure_distribution_z_ccc!(dwpdz_ρ, grid, w, p, ρ₀); i, j, k = @index(Global, NTuple); @inbounds dwpdz_ρ[i, j, k] = (1/ρ₀) * ∂zᵃᵃᶜ(i, j, k, grid, wpᵃᵃᶠ, w, p) # C, C, F → C, C, C; end ; ```. An even more mundane to express our intent is to manually difference the product `wp`, eg:. ```julia; @kernel function pressure_distribution_z_ccc!(dwpdz_ρ, grid, w, p, ρ₀); i, j, k = @index(Global, NTuple); @inbounds wpᵃᵃᶠ_above = ℑzᵃᵃᶠ(i, j, k+1, grid, p) * w[i, j, k+1] ; @inbounds wpᵃᵃᶠ_below = ℑzᵃᵃᶠ(i, j, k, grid, p) * w[i, j, k] ; @inbounds dwpdz_ρ[i, j, k] = (1/ρ₀) * (wpᵃᵃᶠ_above - wpᵃᵃᶠ_below) / Δzᵃᵃᶜ(i, j, k, grid) # C, C, F → C, C, C; end ; ```. Using the differencing function is probably better (its what we do in the source) because it ensures that the indexing convection is treated correctly.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1401#issuecomment-786924993
Testability,test,tests,"We should now be able to create cubed sphere face grids from the JLD2 files in https://github.com/CliMA/OceananigansArtifacts.jl using. ```julia; using DataDeps; using Oceananigans. dd = DataDep(""cubed_sphere_32_grid"",; ""Conformal cubed sphere grid with 32×32 grid points on each face"",; ""https://github.com/CliMA/OceananigansArtifacts.jl/raw/main/cubed_sphere_grids/cubed_sphere_32_grid.jld2"",; ""3cc5d86290c3af028cddfa47e61e095ee470fe6f8d779c845de09da2f1abeb15"" # sha256sum; ). DataDeps.register(dd). cs32_filepath = datadep""cubed_sphere_32_grid/cubed_sphere_32_grid.jld2""; grid = ConformalCubedSphereFaceGrid(cs32_filepath, face=6, Nz=1, z=(-1, 0)); ```. so we should be able to start running some simple tests on single faces!. Should we merge and work on testing in subsequent PRs?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1417#issuecomment-797074745
Usability,simpl,simple,"We should now be able to create cubed sphere face grids from the JLD2 files in https://github.com/CliMA/OceananigansArtifacts.jl using. ```julia; using DataDeps; using Oceananigans. dd = DataDep(""cubed_sphere_32_grid"",; ""Conformal cubed sphere grid with 32×32 grid points on each face"",; ""https://github.com/CliMA/OceananigansArtifacts.jl/raw/main/cubed_sphere_grids/cubed_sphere_32_grid.jld2"",; ""3cc5d86290c3af028cddfa47e61e095ee470fe6f8d779c845de09da2f1abeb15"" # sha256sum; ). DataDeps.register(dd). cs32_filepath = datadep""cubed_sphere_32_grid/cubed_sphere_32_grid.jld2""; grid = ConformalCubedSphereFaceGrid(cs32_filepath, face=6, Nz=1, z=(-1, 0)); ```. so we should be able to start running some simple tests on single faces!. Should we merge and work on testing in subsequent PRs?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1417#issuecomment-797074745
Availability,error,errors,"I noticed this change last week but I thought it was intentional. I don't have a strong opinion here. . If we're trying to cater to more inexperienced users (of which Oceananigans will probably attract a lot of, since it's always portrayed as user-friendly) then it might make sense to try and guard against this somehow (since the errors you get when trying to do stuff with timedeltas that can't be done aren't very useful). . Otherwise I'd say it's up to the user to deal with this, since on the Oceananigans end the change was (imho) for the better.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1421#issuecomment-790717920
Usability,user-friendly,user-friendly,"I noticed this change last week but I thought it was intentional. I don't have a strong opinion here. . If we're trying to cater to more inexperienced users (of which Oceananigans will probably attract a lot of, since it's always portrayed as user-friendly) then it might make sense to try and guard against this somehow (since the errors you get when trying to do stuff with timedeltas that can't be done aren't very useful). . Otherwise I'd say it's up to the user to deal with this, since on the Oceananigans end the change was (imho) for the better.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1421#issuecomment-790717920
Usability,learn,learned,I was not calling the script correctl. I have since learned I should be doing the following . ```; mpiexec -n 4 julia --project mpi_shallow_water_turbulence.jl; ```,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1430#issuecomment-794318967
Testability,test,testing,"NaNs often occur either because the time step is too small, or because the problem being posed is too extreme or not physical (such that a reasonable and stable time step cannot be found). One issue is that the use of `ValueBoundaryCondition` is incorrect here:. ```julia; w_bcs = WVelocityBoundaryConditions(grid, top = ValueBoundaryCondition(0.0), bottom=ValueBoundaryCondition(0.0)); ```. You are trying to specify an impenetrable boundary condition on the vertical velocity, which requires `NormalFlowBoundaryCondition`:. ```julia; w_bcs = WVelocityBoundaryConditions(grid, top = NormalFlowBoundaryCondition(0.0), bottom=NormalFlowBoundaryCondition(0.0)); ```. this is also the default for a grid with `topology(grid) = (Periodic, Periodic, Bounded)`, so there's no need to specify it explicitly. In other words, try changing . ```julia; boundary_conditions = (u=u_bcs, v=v_bcs, w=w_bcs, T=T_bcs)); ```. to . ```julia; boundary_conditions = (u=u_bcs, v=v_bcs, T=T_bcs)); ```. in your constructor for `IncompressibleModel`. A good approach for developing a complex simulation is to start with something simple (or something that worked previously) and modify the script incrementally (slowly!), re-running and re-testing the script after each significant change. For this is useful to run either a two-dimensional version of the problem or a very low resolution simulation. I also suggest adding some lines at the bottom of your script to plot the solution so you can visually inspect it after a run. Your setup looks like a laboratory-scale simulation of convection. I think starting with uniform cooling (rather than spatially varying), omitting the effect of salinity, and using an `IsotropicDiffusivity` in two-dimensions (rather than starting out in three dimensions) might be a good path forward for working and building up your script.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1432#issuecomment-791953056
Usability,simpl,simple,"NaNs often occur either because the time step is too small, or because the problem being posed is too extreme or not physical (such that a reasonable and stable time step cannot be found). One issue is that the use of `ValueBoundaryCondition` is incorrect here:. ```julia; w_bcs = WVelocityBoundaryConditions(grid, top = ValueBoundaryCondition(0.0), bottom=ValueBoundaryCondition(0.0)); ```. You are trying to specify an impenetrable boundary condition on the vertical velocity, which requires `NormalFlowBoundaryCondition`:. ```julia; w_bcs = WVelocityBoundaryConditions(grid, top = NormalFlowBoundaryCondition(0.0), bottom=NormalFlowBoundaryCondition(0.0)); ```. this is also the default for a grid with `topology(grid) = (Periodic, Periodic, Bounded)`, so there's no need to specify it explicitly. In other words, try changing . ```julia; boundary_conditions = (u=u_bcs, v=v_bcs, w=w_bcs, T=T_bcs)); ```. to . ```julia; boundary_conditions = (u=u_bcs, v=v_bcs, T=T_bcs)); ```. in your constructor for `IncompressibleModel`. A good approach for developing a complex simulation is to start with something simple (or something that worked previously) and modify the script incrementally (slowly!), re-running and re-testing the script after each significant change. For this is useful to run either a two-dimensional version of the problem or a very low resolution simulation. I also suggest adding some lines at the bottom of your script to plot the solution so you can visually inspect it after a run. Your setup looks like a laboratory-scale simulation of convection. I think starting with uniform cooling (rather than spatially varying), omitting the effect of salinity, and using an `IsotropicDiffusivity` in two-dimensions (rather than starting out in three dimensions) might be a good path forward for working and building up your script.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1432#issuecomment-791953056
Availability,error,errors,"> We do need to strike a balance between being helicopter parents to users, and catching common mistakes. I don't think we should get in the business of curating science --- we should just provide useful software. Yes to be clear I should have said that I'm just advocating for printing warnings, not throwing errors. Users should be able to run whatever they want. I would say that these warnings make the software more useful.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1453#issuecomment-796846731
Usability,clear,clear,"> We do need to strike a balance between being helicopter parents to users, and catching common mistakes. I don't think we should get in the business of curating science --- we should just provide useful software. Yes to be clear I should have said that I'm just advocating for printing warnings, not throwing errors. Users should be able to run whatever they want. I would say that these warnings make the software more useful.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1453#issuecomment-796846731
Availability,mask,mask,"Note that the implementation in `IncompressibleModel` is really experimental and doesn't enforce boundary conditions or work for tracers. I think we might be able to improve on what's done for `IncompressibleModel`. A simple implementation would just mask the immersed boundary in `update_state!`. We have to work a bit harder to make sure that boundary conditions are satisfied, though.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1458#issuecomment-797812605
Usability,simpl,simple,"Note that the implementation in `IncompressibleModel` is really experimental and doesn't enforce boundary conditions or work for tracers. I think we might be able to improve on what's done for `IncompressibleModel`. A simple implementation would just mask the immersed boundary in `update_state!`. We have to work a bit harder to make sure that boundary conditions are satisfied, though.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1458#issuecomment-797812605
Testability,test,testing,thanks @glwagner . Maybe we could plan to meet for an hour this week and give this a try? It would be great for `ShallowWaterModel` and could also be helpful for testing the immersed boundary methods in a simpler model. Happy to disucss on slack as you like.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1458#issuecomment-798606318
Usability,simpl,simpler,thanks @glwagner . Maybe we could plan to meet for an hour this week and give this a try? It would be great for `ShallowWaterModel` and could also be helpful for testing the immersed boundary methods in a simpler model. Happy to disucss on slack as you like.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1458#issuecomment-798606318
Deployability,install,install,"Excellent advice @navidcy , I will probably do just that. I do install it on my ubuntu machine but suppose I need to learn to install it for a user only. A good thing to learn.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1468#issuecomment-799894716
Usability,learn,learn,"Excellent advice @navidcy , I will probably do just that. I do install it on my ubuntu machine but suppose I need to learn to install it for a user only. A good thing to learn.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1468#issuecomment-799894716
Usability,simpl,simpler,"Yes, should have mentioned it @tomchor. That's much simpler :) (no need to open issue etc..)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1473#issuecomment-799813301
Usability,learn,learned,"I learned today that cuda failed if I did not define a parameter as a constant, which I had no idea about before.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1478#issuecomment-800502949
Energy Efficiency,reduce,reduce,"From the talks we've had here and in [this discussion](https://github.com/CliMA/Oceananigans.jl/discussions/1482), as well me looking things I have some things we could include as tips. Please let me know if I'm missing something. ## General simulation tips; - In general defining variables (that are used in the calculations) as constants makes things faster as it helps the compiler optimize things; - It's probably worth inlining small functions that get called often to reduce function call overhead (at the very least it's worth playing with this). ## GPU simulation tips:; - Any global variable that needs to be accessed by the GPU needs to be a constant or the simulation will crash; - Complex `ComputedField`s may not work, so the user can either nest `ComputedField`s (simple, but costly; probably good for development) or use `KernelComputedField`s (complex but efficient; probably what you wanna use for production-ready code); - GPU runs are generally memory-limited, so it's good to both keep track of and try to reduce the size of your runs. Useful tips in this regard are; - Try to use higher-order schemes as you need fewer grid points to achieve the same resolution; - Use `nvidia-smi` to monitor the memory usage of the GPU; - Manually define scratch space to be reused in diagnostics, to avoid creating one scratch space for each separate diagnostic you have.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1478#issuecomment-802225575
Modifiability,variab,variables,"From the talks we've had here and in [this discussion](https://github.com/CliMA/Oceananigans.jl/discussions/1482), as well me looking things I have some things we could include as tips. Please let me know if I'm missing something. ## General simulation tips; - In general defining variables (that are used in the calculations) as constants makes things faster as it helps the compiler optimize things; - It's probably worth inlining small functions that get called often to reduce function call overhead (at the very least it's worth playing with this). ## GPU simulation tips:; - Any global variable that needs to be accessed by the GPU needs to be a constant or the simulation will crash; - Complex `ComputedField`s may not work, so the user can either nest `ComputedField`s (simple, but costly; probably good for development) or use `KernelComputedField`s (complex but efficient; probably what you wanna use for production-ready code); - GPU runs are generally memory-limited, so it's good to both keep track of and try to reduce the size of your runs. Useful tips in this regard are; - Try to use higher-order schemes as you need fewer grid points to achieve the same resolution; - Use `nvidia-smi` to monitor the memory usage of the GPU; - Manually define scratch space to be reused in diagnostics, to avoid creating one scratch space for each separate diagnostic you have.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1478#issuecomment-802225575
Performance,optimiz,optimize,"From the talks we've had here and in [this discussion](https://github.com/CliMA/Oceananigans.jl/discussions/1482), as well me looking things I have some things we could include as tips. Please let me know if I'm missing something. ## General simulation tips; - In general defining variables (that are used in the calculations) as constants makes things faster as it helps the compiler optimize things; - It's probably worth inlining small functions that get called often to reduce function call overhead (at the very least it's worth playing with this). ## GPU simulation tips:; - Any global variable that needs to be accessed by the GPU needs to be a constant or the simulation will crash; - Complex `ComputedField`s may not work, so the user can either nest `ComputedField`s (simple, but costly; probably good for development) or use `KernelComputedField`s (complex but efficient; probably what you wanna use for production-ready code); - GPU runs are generally memory-limited, so it's good to both keep track of and try to reduce the size of your runs. Useful tips in this regard are; - Try to use higher-order schemes as you need fewer grid points to achieve the same resolution; - Use `nvidia-smi` to monitor the memory usage of the GPU; - Manually define scratch space to be reused in diagnostics, to avoid creating one scratch space for each separate diagnostic you have.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1478#issuecomment-802225575
Safety,avoid,avoid,"From the talks we've had here and in [this discussion](https://github.com/CliMA/Oceananigans.jl/discussions/1482), as well me looking things I have some things we could include as tips. Please let me know if I'm missing something. ## General simulation tips; - In general defining variables (that are used in the calculations) as constants makes things faster as it helps the compiler optimize things; - It's probably worth inlining small functions that get called often to reduce function call overhead (at the very least it's worth playing with this). ## GPU simulation tips:; - Any global variable that needs to be accessed by the GPU needs to be a constant or the simulation will crash; - Complex `ComputedField`s may not work, so the user can either nest `ComputedField`s (simple, but costly; probably good for development) or use `KernelComputedField`s (complex but efficient; probably what you wanna use for production-ready code); - GPU runs are generally memory-limited, so it's good to both keep track of and try to reduce the size of your runs. Useful tips in this regard are; - Try to use higher-order schemes as you need fewer grid points to achieve the same resolution; - Use `nvidia-smi` to monitor the memory usage of the GPU; - Manually define scratch space to be reused in diagnostics, to avoid creating one scratch space for each separate diagnostic you have.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1478#issuecomment-802225575
Security,access,accessed,"From the talks we've had here and in [this discussion](https://github.com/CliMA/Oceananigans.jl/discussions/1482), as well me looking things I have some things we could include as tips. Please let me know if I'm missing something. ## General simulation tips; - In general defining variables (that are used in the calculations) as constants makes things faster as it helps the compiler optimize things; - It's probably worth inlining small functions that get called often to reduce function call overhead (at the very least it's worth playing with this). ## GPU simulation tips:; - Any global variable that needs to be accessed by the GPU needs to be a constant or the simulation will crash; - Complex `ComputedField`s may not work, so the user can either nest `ComputedField`s (simple, but costly; probably good for development) or use `KernelComputedField`s (complex but efficient; probably what you wanna use for production-ready code); - GPU runs are generally memory-limited, so it's good to both keep track of and try to reduce the size of your runs. Useful tips in this regard are; - Try to use higher-order schemes as you need fewer grid points to achieve the same resolution; - Use `nvidia-smi` to monitor the memory usage of the GPU; - Manually define scratch space to be reused in diagnostics, to avoid creating one scratch space for each separate diagnostic you have.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1478#issuecomment-802225575
Usability,simpl,simple,"From the talks we've had here and in [this discussion](https://github.com/CliMA/Oceananigans.jl/discussions/1482), as well me looking things I have some things we could include as tips. Please let me know if I'm missing something. ## General simulation tips; - In general defining variables (that are used in the calculations) as constants makes things faster as it helps the compiler optimize things; - It's probably worth inlining small functions that get called often to reduce function call overhead (at the very least it's worth playing with this). ## GPU simulation tips:; - Any global variable that needs to be accessed by the GPU needs to be a constant or the simulation will crash; - Complex `ComputedField`s may not work, so the user can either nest `ComputedField`s (simple, but costly; probably good for development) or use `KernelComputedField`s (complex but efficient; probably what you wanna use for production-ready code); - GPU runs are generally memory-limited, so it's good to both keep track of and try to reduce the size of your runs. Useful tips in this regard are; - Try to use higher-order schemes as you need fewer grid points to achieve the same resolution; - Use `nvidia-smi` to monitor the memory usage of the GPU; - Manually define scratch space to be reused in diagnostics, to avoid creating one scratch space for each separate diagnostic you have.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1478#issuecomment-802225575
Usability,guid,guidelines,"Leaving this here for future reference, but also for discussion: maybe include some guidelines on using, slicing, and even viewing arrays when working on GPUs. These are definitely not obvious. It might be useful for users using external data (as arrays) in simulations, such as https://github.com/CliMA/Oceananigans.jl/issues/1509.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1478#issuecomment-812678465
Usability,simpl,simply,"Good! :); If it runs, then before merging just add a remark before saying ""We construct the model to run on GPU by `architectures=...`; to run on CPU simply change to `architecture = CPU()`.""",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1495#issuecomment-802250849
Usability,simpl,simple,"> That'd be a nice name, but alas we may want to apply the same terminology to the Coriolis force, since it would also need to be rotated with the domain. Yeah, I'm all in favor of having a simple name that is unified for `FPlane()` and `Buoyancy()`. My vote goes to `vertical_unit_vector`, as it is intuitive and works for both (with the trade-off that the vertical direction doesn't always align perfectly with the geopotential normal, but I think that's okay). I'll make the PR as soon as we agree on a name.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1496#issuecomment-802037770
Usability,simpl,simply,"Thanks @maleadt! I didn't know about `Base.mapreducedim`. Will look into using it when I revisit this PR!. > I don't see any problem with this but as a user, since both are simply estiamtes (we need to pick a scaling factor in both cases) I am probably more inclined to pick the faster more conservative estimate, but why not give the user the choice and they can decide?. Yes definitely agree. The default can be the very fast `cell_advection_timescale` function while this PR can add a new `accurate_cell_advection_timescale`. The main use for `accurate_cell_advection_timescale` will be for curvilinear grids where a fast method is probably too conservative or for when you want an accurate CFL diagnostic. I've been using it on the cubed sphere in PR #1522 and it seems to work great fast enough on the CPU. > @ali-ramadhan can you explain in greater detail why this problem requires nested calls to mapreduce?. Yes. We essentially want to `mapreduce` over operations like `w / Δz` but `w` and `Δz` need to have the same size for `mapreduce` to work on multiple iterators (`w` and `Δz`). They have different sizes on all grids right now. Only way I could figure out how to do it using just `mapreduce` was to do an ""inner `mapreduce`"" where e.g. `w[i, j, :]` and `Δz` have the same size and the ""outer `mapreduce`"" iterates over the other dimensions. So we would also need slightly different `mapreduce` implementations for the different grids.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1497#issuecomment-811204289
Usability,guid,guides,"> > Can you add plotting code to the example so that we can reproduce the animation?; > ; > I can, but it might take a little since I'm not at all familiar with animating in Julia. I'd have to go off of the examples in the docs. I think the horizontal convection is our most state-of-art plotting example, right? If `FieldTimeSeries` works with NetCDF output thenit should be faster :). `FieldTimeSeries` doesn't work with `NetCDFOutputWriter` (we need to design a system for saving and extracting field location for that to work). The constructors for the two output writers are almost identical so it does not take long to switch between them. With `FieldTimeSeries` you don't interact with the file so you don't need to know anything about JLD2 in particular. I hope the examples are useful guides to animating...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1498#issuecomment-885189080
Usability,simpl,simplify,"@tomchor do you want help with this? I'd be happy to help move this along (looks like we need to merge with master). I'm also wondering if we can simplify the setup. For example, I don't think `BackgroundField` is essential --- we can just run an initial value problem and obtain very similar physics and visualizations. I also think we can get rid of the sponge layer at the top of the domain. I think these simplifications might make the example a little easier to interpret and focus attention on the novel parts of the example (mostly, the tilting of gravity + Coriolis).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1498#issuecomment-974127562
Safety,avoid,avoid,"> @tomchor do you want help with this? I'd be happy to help move this along (looks like we need to merge with master). I'm also wondering if we can simplify the setup. For example, I don't think `BackgroundField` is essential --- we can just run an initial value problem and obtain very similar physics and visualizations. I also think we can get rid of the sponge layer at the top of the domain. I think these simplifications might make the example a little easier to interpret and focus attention on the novel parts of the example (mostly, the tilting of gravity + Coriolis). Thanks for the offer! I'm actually making progress very slowly on this branch. I just haven't pushed it to avoid running CI (I have the feeling that the CI servers have been kinda overwhelmed lately?). But some help would definitely be nice :)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1498#issuecomment-974301910
Usability,simpl,simplify,"> @tomchor do you want help with this? I'd be happy to help move this along (looks like we need to merge with master). I'm also wondering if we can simplify the setup. For example, I don't think `BackgroundField` is essential --- we can just run an initial value problem and obtain very similar physics and visualizations. I also think we can get rid of the sponge layer at the top of the domain. I think these simplifications might make the example a little easier to interpret and focus attention on the novel parts of the example (mostly, the tilting of gravity + Coriolis). Thanks for the offer! I'm actually making progress very slowly on this branch. I just haven't pushed it to avoid running CI (I have the feeling that the CI servers have been kinda overwhelmed lately?). But some help would definitely be nice :)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1498#issuecomment-974301910
Energy Efficiency,efficient,efficient,"> Like @hdrake, I think we need a buoyancy background field to make the buoyancy (fluctuations) periodic, although we can probably get away without a background `v` field.; > ; > I can try removing the sponge layer, but the last time I tried I saw significant internal wave build up. I think the reason is that centrifugal-symmetric instabilities (of which we see a lot in this BBL example) are known to particularly efficient at exciting internal waves (compared to upper ocean convection, for example).; > ; > But I'll try it out and post the results. Sounds good. For the other boundary layer examples we don't use a sponge layer because the simulations are fairly short, I think. I realized after talking with @xiaozhour that it probably won't be simple to remove the background velocity field. The reason is that there is an (implicit) pressure gradient that maintains the flow. So, we either have to add this pressure gradient and a matching initial condition, or we have to use a background field for the velocity (using an initial condition `v=1` will produce an inertial oscillation, not a steady flow). With that consideration, it seems like it might probably simpler to use a background field. The main annoyance is the drag boundary condition, which requires explanation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1498#issuecomment-974318893
Usability,simpl,simple,"> Like @hdrake, I think we need a buoyancy background field to make the buoyancy (fluctuations) periodic, although we can probably get away without a background `v` field.; > ; > I can try removing the sponge layer, but the last time I tried I saw significant internal wave build up. I think the reason is that centrifugal-symmetric instabilities (of which we see a lot in this BBL example) are known to particularly efficient at exciting internal waves (compared to upper ocean convection, for example).; > ; > But I'll try it out and post the results. Sounds good. For the other boundary layer examples we don't use a sponge layer because the simulations are fairly short, I think. I realized after talking with @xiaozhour that it probably won't be simple to remove the background velocity field. The reason is that there is an (implicit) pressure gradient that maintains the flow. So, we either have to add this pressure gradient and a matching initial condition, or we have to use a background field for the velocity (using an initial condition `v=1` will produce an inertial oscillation, not a steady flow). With that consideration, it seems like it might probably simpler to use a background field. The main annoyance is the drag boundary condition, which requires explanation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1498#issuecomment-974318893
Usability,clear,clear,"Sorry for not being clear, wil try again with code. Consider the following. ```; grid = RegularRectilinearGrid(size=(4,4), extent=(1,1), topology=(Periodic,Periodic,Flat)); model = ShallowWaterModel(grid=grid, gravitational_acceleration=1); ```. The first line says we are using a `RegularRectilinearGrid` and the second line says we have `Flat` in the vertical. . The three options to compute the vertical grid spacing are the following,. ```; @inline ΔzF(i, j, k, grid::RegularRectilinearGrid) = grid.Δz; @inline ΔzF(i, j, k, grid::VerticallyStretchedRectilinearGrid) = @inbounds grid.Δzᵃᵃᶜ[k]; @inline ΔzF(i, j, k, grid::AbstractGrid{FT, TX, TY, Flat}) where {FT, TX, TY} = one(FT); ```; It seems like the first and third functions are both options. When I tried it, even though I had `Flat` in the vertical, it used the first and computed the spacing in the vertical to be `0` instead of `1`. This resulted in a lot of `NaNs`. I should say that I am calling it using the following syntax `ΔzF(i,j,k,grid)`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1499#issuecomment-804938362
Usability,learn,learned,"> > I guess I'm not sure how the grids are defined differently in the different cases.; > ; > What do you mean?. In the three methods we seem to have three different types of grids were considering,. ```; RegularRectilinearGrid; VerticallyStretchedRectilinearGrid; AbstractGrid{FT, TX, TY, Flat}; ```. From the above, it is definitely `RegularRectilinearGrid` with a `Flat` dimension I looked at `Grids.jl` and have learned that `RegularRectilinearGrid` is of type `AbstractRectilinearGrid` and this is a subtype of `AbstractGrid. I guess this explains the hiearchy.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1499#issuecomment-805044250
Usability,learn,learned,"> From the above, it is definitely RegularRectilinearGrid with a Flat dimension I looked at Grids.jl and have learned that RegularRectilinearGrid is of type AbstractRectilinearGrid and this is a subtype of `AbstractGrid. I guess this explains the hiearchy. Yes, that is the type hierarchy and why I thought the above code pattern would work.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1499#issuecomment-805147648
Usability,simpl,simply,"I simply paste the code from the README in a Julia REPL. ```Julia; julia> using Oceananigans; [ Info: Oceananigans will use 12 threads. julia> N = Nx = Ny = Nz = 128 # Number of grid points in each dimension.; 128. julia> L = Lx = Ly = Lz = 2000 # Length of each dimension.; 2000. julia> topology = (Periodic, Periodic, Bounded); (Periodic, Periodic, Bounded). julia> model = IncompressibleModel(; architecture = CPU(),; grid = RegularRectilinearGrid(topology=topology, size=(Nx, Ny, Nz), extent=(Lx, Ly, Lz)),; closure = IsotropicDiffusivity(ν=4e-2, κ=4e-2); ); IncompressibleModel{CPU, Float64}(time = 0 seconds, iteration = 0); ├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=128, Ny=128, Nz=128); ├── tracers: (:T, :S); ├── closure: IsotropicDiffusivity{Float64,NamedTuple{(:T, :S),Tuple{Float64,Float64}}}; ├── buoyancy: SeawaterBuoyancy{Float64,LinearEquationOfState{Float64},Nothing,Nothing}; └── coriolis: Nothing. julia> # Set a temperature perturbation with a Gaussian profile located at the center.; # This will create a buoyant thermal bubble that will rise with time.; x₀, z₀ = Lx/2, Lz/2; (1000.0, 1000.0). julia> T₀(x, y, z) = 20 + 0.01 * exp(-100 * ((x - x₀)^2 + (z - z₀)^2) / (Lx^2 + Lz^2)); T₀ (generic function with 1 method). julia> set!(model, T=T₀); julia> simulation = Simulation(model, Δt=10, stop_iteration=5000); Simulation{IncompressibleModel{CPU, Float64}}; ├── Model clock: time = 0 seconds, iteration = 0; ├── Next time step (Int64): 10 seconds; ├── Iteration interval: 1; ├── Stop criteria: Any[Oceananigans.Simulations.iteration_limit_exceeded, Oceananigans.Simulations.stop_time_exceeded, Oceananigans.Simulations.wall_time_limit_exceeded]; ├── Run time: 0 seconds, wall time limit: Inf; ├── Stop time: Inf years, stop iteration: 5000; ├── Diagnostics: OrderedCollections.OrderedDict with 1 entry:; │ └── nan_checker => NaNChecker; └── Output writers: OrderedCollections.OrderedDict with no entries. julia> run!(simulation); ```. How were you",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1507#issuecomment-807688276
Availability,error,errors,"For simple cases, like @francispoulin mentioned, changing the architecture from `CPU()` to `GPU()` are often enough. Although if you wanna run simulations that are a bit more complicated, there are a few other things you might need to worry about. You can see a recent discussion about it [here](https://github.com/CliMA/Oceananigans.jl/issues/1509). Mostly you have to define everything that is being used in the model calculations as a constant, otherwise the GPU won't know what to do with it. So for example you probably will need to change some of your lines to. ```julia; const Qo = sqrt(spl_taux(0)^2 + spl_tauy(0)^2). ## Random noise damped at top and bottom; const Hz = grid.Lz; Ξ(z) = randn() * z / Hz * (1 + z / Hz); # noise. ## Velocity initial condition: random noise scaled by the initial stress.; uᵢ(x, y, z) = abs(Qo) * 1e-3 * Ξ(z);; wᵢ(x, y, z) = abs(Qo) * 1e-6 * Ξ(z); # This was added to reduce the scale of the w profile; ```; (probably the same goes in other places too.). I recommend you first run the very simple examples that appear in the `README` document of this repo on a GPU to make sure that Oceananigans+GPU is working correctly. And then only after that you should try to change your example to a GPU one. If you come across some errors that you can't solve we can take it from there :)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1509#issuecomment-808567747
Energy Efficiency,reduce,reduce,"For simple cases, like @francispoulin mentioned, changing the architecture from `CPU()` to `GPU()` are often enough. Although if you wanna run simulations that are a bit more complicated, there are a few other things you might need to worry about. You can see a recent discussion about it [here](https://github.com/CliMA/Oceananigans.jl/issues/1509). Mostly you have to define everything that is being used in the model calculations as a constant, otherwise the GPU won't know what to do with it. So for example you probably will need to change some of your lines to. ```julia; const Qo = sqrt(spl_taux(0)^2 + spl_tauy(0)^2). ## Random noise damped at top and bottom; const Hz = grid.Lz; Ξ(z) = randn() * z / Hz * (1 + z / Hz); # noise. ## Velocity initial condition: random noise scaled by the initial stress.; uᵢ(x, y, z) = abs(Qo) * 1e-3 * Ξ(z);; wᵢ(x, y, z) = abs(Qo) * 1e-6 * Ξ(z); # This was added to reduce the scale of the w profile; ```; (probably the same goes in other places too.). I recommend you first run the very simple examples that appear in the `README` document of this repo on a GPU to make sure that Oceananigans+GPU is working correctly. And then only after that you should try to change your example to a GPU one. If you come across some errors that you can't solve we can take it from there :)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1509#issuecomment-808567747
Usability,simpl,simple,"For simple cases, like @francispoulin mentioned, changing the architecture from `CPU()` to `GPU()` are often enough. Although if you wanna run simulations that are a bit more complicated, there are a few other things you might need to worry about. You can see a recent discussion about it [here](https://github.com/CliMA/Oceananigans.jl/issues/1509). Mostly you have to define everything that is being used in the model calculations as a constant, otherwise the GPU won't know what to do with it. So for example you probably will need to change some of your lines to. ```julia; const Qo = sqrt(spl_taux(0)^2 + spl_tauy(0)^2). ## Random noise damped at top and bottom; const Hz = grid.Lz; Ξ(z) = randn() * z / Hz * (1 + z / Hz); # noise. ## Velocity initial condition: random noise scaled by the initial stress.; uᵢ(x, y, z) = abs(Qo) * 1e-3 * Ξ(z);; wᵢ(x, y, z) = abs(Qo) * 1e-6 * Ξ(z); # This was added to reduce the scale of the w profile; ```; (probably the same goes in other places too.). I recommend you first run the very simple examples that appear in the `README` document of this repo on a GPU to make sure that Oceananigans+GPU is working correctly. And then only after that you should try to change your example to a GPU one. If you come across some errors that you can't solve we can take it from there :)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1509#issuecomment-808567747
Availability,error,error,"`CUDA.CuArray`](https://juliagpu.gitlab.io/CUDA.jl/usage/array/https://juliagpu.gitlab.io/CUDA.jl/usage/array/). It looks like you are using an object called `df.taux` that comes out of the `CSV` package:. ```julia; spl_taux = Spline1D(secs, df.taux / ρₒ, k=1); ```. Provided that whatever `Spline1D` does is GPU-friendly (and it may not be), then you may only need to convert `df.taux / ρₒ` to a `CuArray` prior to passing it to `Spline1D`. I don't know if this code would work, but as an example of something you _might_ do:. ```julia; using CUDA. kinematic_x_momentum_flux = Array(df.taux / ρₒ); kinematic_x_momentum_flux = CuArray(kinematic_x_momentum_flux). spl_taux = Spline1D(secs, kinematic_x_momentum_flux, k=1); ```. The array `secs` may also need to be converted:. ```julia; secs = CuArray(secs); ```. `Spline1D` may not work on the GPU, but there seem to be other options. A google search for ""interpolation GPU julia"" turned up this page:. https://juliagpu.org/2020-10-30-cuda_2.1/. which has instructions for using some CUDA built-in interpolation functionality. In summary, if you're working with arrays on the GPU, you'll need to. * convert arrays to `CuArray` when using the GPU; * use interpolation / other functionality that's GPU-friendly. As a side note, a convenient way to program a script to be switchable from CPU to GPU easily is to include a line at the top like. ```julia; DeviceArrayType = arch isa GPU ? CuArray : Array; ```. and then use patterns like. ```julia; data = Array(df.data); data = convert(DeviceArrayType, data); ```. This allows you to switch between `arch = GPU()` and `arch = CPU()` with a single line at the top of your script. As a side, side note, julia does not require you to put semi-colons to end lines!. Please don't be afraid to simply try running your script and reporting the error you get (if any!) With a concrete error, we can make concrete suggestions to solve your problem (without having to run the script ourselves, which is more work).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1509#issuecomment-811561274
Usability,simpl,simply,"`CUDA.CuArray`](https://juliagpu.gitlab.io/CUDA.jl/usage/array/https://juliagpu.gitlab.io/CUDA.jl/usage/array/). It looks like you are using an object called `df.taux` that comes out of the `CSV` package:. ```julia; spl_taux = Spline1D(secs, df.taux / ρₒ, k=1); ```. Provided that whatever `Spline1D` does is GPU-friendly (and it may not be), then you may only need to convert `df.taux / ρₒ` to a `CuArray` prior to passing it to `Spline1D`. I don't know if this code would work, but as an example of something you _might_ do:. ```julia; using CUDA. kinematic_x_momentum_flux = Array(df.taux / ρₒ); kinematic_x_momentum_flux = CuArray(kinematic_x_momentum_flux). spl_taux = Spline1D(secs, kinematic_x_momentum_flux, k=1); ```. The array `secs` may also need to be converted:. ```julia; secs = CuArray(secs); ```. `Spline1D` may not work on the GPU, but there seem to be other options. A google search for ""interpolation GPU julia"" turned up this page:. https://juliagpu.org/2020-10-30-cuda_2.1/. which has instructions for using some CUDA built-in interpolation functionality. In summary, if you're working with arrays on the GPU, you'll need to. * convert arrays to `CuArray` when using the GPU; * use interpolation / other functionality that's GPU-friendly. As a side note, a convenient way to program a script to be switchable from CPU to GPU easily is to include a line at the top like. ```julia; DeviceArrayType = arch isa GPU ? CuArray : Array; ```. and then use patterns like. ```julia; data = Array(df.data); data = convert(DeviceArrayType, data); ```. This allows you to switch between `arch = GPU()` and `arch = CPU()` with a single line at the top of your script. As a side, side note, julia does not require you to put semi-colons to end lines!. Please don't be afraid to simply try running your script and reporting the error you get (if any!) With a concrete error, we can make concrete suggestions to solve your problem (without having to run the script ourselves, which is more work).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1509#issuecomment-811561274
Usability,simpl,simply,"It might be reasonable to simply generalize `parent_slice_indices` for `AbstractRange`s:. https://github.com/CliMA/Oceananigans.jl/blob/a4be062049b096ce20ac0908ee40f0b81b16d5ae/src/Diagnostics/field_slicer.jl#L61. We might want to use `minimum(rng)` rather than `rng[1]`:. https://github.com/CliMA/Oceananigans.jl/blob/a4be062049b096ce20ac0908ee40f0b81b16d5ae/src/Diagnostics/field_slicer.jl#L64. And we can return `StepRange(left, step(rng), right)` rather than `UnitRange(left, right)`:. https://github.com/CliMA/Oceananigans.jl/blob/a4be062049b096ce20ac0908ee40f0b81b16d5ae/src/Diagnostics/field_slicer.jl#L71",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1512#issuecomment-810573826
Energy Efficiency,adapt,adapt,"> I can't see the modifications to `geostrophic_adjustement.jl` that were made on this PR --- have these changes been pushed?; > ; > I don't think `Flat` will work in the vertical for `HydrostaticFreeSurfaceModel`. We have to inspect the way vertical velocities are calculated but I believe it will fail. Perhaps we need a more general algorithm, or we can write code to deal with that special case. I don't think its important (aside from testing) since if one wants to run a shallow water model they might be better off using `ShallowWaterModel`... Sorry, since that example didn't work I decided to restore that example to master. If you wanted to see the minor changes that I have done you can go here https://github.com/CliMA/Oceananigans.jl/pull/1513/commits/f372a5e5aa2c5d9cb3cdc9d0bc3104df5f1de184. I added in some `Flat` tests to `test_hydrostatic_free_surface_models.jl` and I'm happy to say all of those pass. Actualy, since last night all checks have passes so this PR seems to be in the clear. I should mention that I did adapt the `cell_advection_timescale` to deal with a vertically stretched grid and my solution might not be the cleanest but it does work. I do wonder whether something similar needs to be done to `cell_diffusion_timescale`. . One issue is that this version of `lid_driven_cavity.jl` is different from `master` but restoring that should be easy, if that's what we decided to do. Another thought: `HydrostaticFreeSurfaceModel` is labelled as experimental. If for some reason `Flat` does no work completely with that model, I suppose it's not as bad as it seems to work with the other two models, as far as I can tell. @glwagner if you are able to review this PR and tell me what other concerns you have or other tests we need to do, I can certainly try and do those.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1513#issuecomment-810123000
Modifiability,adapt,adapt,"> I can't see the modifications to `geostrophic_adjustement.jl` that were made on this PR --- have these changes been pushed?; > ; > I don't think `Flat` will work in the vertical for `HydrostaticFreeSurfaceModel`. We have to inspect the way vertical velocities are calculated but I believe it will fail. Perhaps we need a more general algorithm, or we can write code to deal with that special case. I don't think its important (aside from testing) since if one wants to run a shallow water model they might be better off using `ShallowWaterModel`... Sorry, since that example didn't work I decided to restore that example to master. If you wanted to see the minor changes that I have done you can go here https://github.com/CliMA/Oceananigans.jl/pull/1513/commits/f372a5e5aa2c5d9cb3cdc9d0bc3104df5f1de184. I added in some `Flat` tests to `test_hydrostatic_free_surface_models.jl` and I'm happy to say all of those pass. Actualy, since last night all checks have passes so this PR seems to be in the clear. I should mention that I did adapt the `cell_advection_timescale` to deal with a vertically stretched grid and my solution might not be the cleanest but it does work. I do wonder whether something similar needs to be done to `cell_diffusion_timescale`. . One issue is that this version of `lid_driven_cavity.jl` is different from `master` but restoring that should be easy, if that's what we decided to do. Another thought: `HydrostaticFreeSurfaceModel` is labelled as experimental. If for some reason `Flat` does no work completely with that model, I suppose it's not as bad as it seems to work with the other two models, as far as I can tell. @glwagner if you are able to review this PR and tell me what other concerns you have or other tests we need to do, I can certainly try and do those.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1513#issuecomment-810123000
Testability,test,testing,"> I can't see the modifications to `geostrophic_adjustement.jl` that were made on this PR --- have these changes been pushed?; > ; > I don't think `Flat` will work in the vertical for `HydrostaticFreeSurfaceModel`. We have to inspect the way vertical velocities are calculated but I believe it will fail. Perhaps we need a more general algorithm, or we can write code to deal with that special case. I don't think its important (aside from testing) since if one wants to run a shallow water model they might be better off using `ShallowWaterModel`... Sorry, since that example didn't work I decided to restore that example to master. If you wanted to see the minor changes that I have done you can go here https://github.com/CliMA/Oceananigans.jl/pull/1513/commits/f372a5e5aa2c5d9cb3cdc9d0bc3104df5f1de184. I added in some `Flat` tests to `test_hydrostatic_free_surface_models.jl` and I'm happy to say all of those pass. Actualy, since last night all checks have passes so this PR seems to be in the clear. I should mention that I did adapt the `cell_advection_timescale` to deal with a vertically stretched grid and my solution might not be the cleanest but it does work. I do wonder whether something similar needs to be done to `cell_diffusion_timescale`. . One issue is that this version of `lid_driven_cavity.jl` is different from `master` but restoring that should be easy, if that's what we decided to do. Another thought: `HydrostaticFreeSurfaceModel` is labelled as experimental. If for some reason `Flat` does no work completely with that model, I suppose it's not as bad as it seems to work with the other two models, as far as I can tell. @glwagner if you are able to review this PR and tell me what other concerns you have or other tests we need to do, I can certainly try and do those.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1513#issuecomment-810123000
Usability,clear,clear,"> I can't see the modifications to `geostrophic_adjustement.jl` that were made on this PR --- have these changes been pushed?; > ; > I don't think `Flat` will work in the vertical for `HydrostaticFreeSurfaceModel`. We have to inspect the way vertical velocities are calculated but I believe it will fail. Perhaps we need a more general algorithm, or we can write code to deal with that special case. I don't think its important (aside from testing) since if one wants to run a shallow water model they might be better off using `ShallowWaterModel`... Sorry, since that example didn't work I decided to restore that example to master. If you wanted to see the minor changes that I have done you can go here https://github.com/CliMA/Oceananigans.jl/pull/1513/commits/f372a5e5aa2c5d9cb3cdc9d0bc3104df5f1de184. I added in some `Flat` tests to `test_hydrostatic_free_surface_models.jl` and I'm happy to say all of those pass. Actualy, since last night all checks have passes so this PR seems to be in the clear. I should mention that I did adapt the `cell_advection_timescale` to deal with a vertically stretched grid and my solution might not be the cleanest but it does work. I do wonder whether something similar needs to be done to `cell_diffusion_timescale`. . One issue is that this version of `lid_driven_cavity.jl` is different from `master` but restoring that should be easy, if that's what we decided to do. Another thought: `HydrostaticFreeSurfaceModel` is labelled as experimental. If for some reason `Flat` does no work completely with that model, I suppose it's not as bad as it seems to work with the other two models, as far as I can tell. @glwagner if you are able to review this PR and tell me what other concerns you have or other tests we need to do, I can certainly try and do those.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1513#issuecomment-810123000
Performance,perform,performance,"That probably shouldn't have changed, can you file an issue on CUDA.jl/GPUArrays.jl? I'll have a look next week. The only change to `@allowscalar` that comes to mind is task/thread-safety, which does come at a certain performance cost (it now does a TLS lookup instead of a simple pointer check, but the cost of that should be negligible compared to the subsequent memory transfer).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-817088189
Safety,safe,safety,"That probably shouldn't have changed, can you file an issue on CUDA.jl/GPUArrays.jl? I'll have a look next week. The only change to `@allowscalar` that comes to mind is task/thread-safety, which does come at a certain performance cost (it now does a TLS lookup instead of a simple pointer check, but the cost of that should be negligible compared to the subsequent memory transfer).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-817088189
Usability,simpl,simple,"That probably shouldn't have changed, can you file an issue on CUDA.jl/GPUArrays.jl? I'll have a look next week. The only change to `@allowscalar` that comes to mind is task/thread-safety, which does come at a certain performance cost (it now does a TLS lookup instead of a simple pointer check, but the cost of that should be negligible compared to the subsequent memory transfer).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-817088189
Availability,error,error,"> That probably shouldn't have changed, can you file an issue on CUDA.jl/GPUArrays.jl? I'll have a look next week. The only change to `@allowscalar` that comes to mind is task/thread-safety, which does come at a certain performance cost (it now does a TLS lookup instead of a simple pointer check, but the cost of that should be negligible compared to the subsequent memory transfer). Seems I can't reproduce the supposed error so, sorry, my bad... Something else must have been the issue. 😔",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-817385393
Performance,perform,performance,"> That probably shouldn't have changed, can you file an issue on CUDA.jl/GPUArrays.jl? I'll have a look next week. The only change to `@allowscalar` that comes to mind is task/thread-safety, which does come at a certain performance cost (it now does a TLS lookup instead of a simple pointer check, but the cost of that should be negligible compared to the subsequent memory transfer). Seems I can't reproduce the supposed error so, sorry, my bad... Something else must have been the issue. 😔",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-817385393
Safety,safe,safety,"> That probably shouldn't have changed, can you file an issue on CUDA.jl/GPUArrays.jl? I'll have a look next week. The only change to `@allowscalar` that comes to mind is task/thread-safety, which does come at a certain performance cost (it now does a TLS lookup instead of a simple pointer check, but the cost of that should be negligible compared to the subsequent memory transfer). Seems I can't reproduce the supposed error so, sorry, my bad... Something else must have been the issue. 😔",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-817385393
Usability,simpl,simple,"> That probably shouldn't have changed, can you file an issue on CUDA.jl/GPUArrays.jl? I'll have a look next week. The only change to `@allowscalar` that comes to mind is task/thread-safety, which does come at a certain performance cost (it now does a TLS lookup instead of a simple pointer check, but the cost of that should be negligible compared to the subsequent memory transfer). Seems I can't reproduce the supposed error so, sorry, my bad... Something else must have been the issue. 😔",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-817385393
Testability,test,test,"Hmmm, not sure what the issue could be but dissipation field does look well-behaved. I agree that the time average isn't what I would expect based on the movie of the dissipation snapshots. Maybe the best way to approach this is to design a simple test that uses `KernelComputedField` + `TimeAveragedInterval`?. I'll have a look at the code to see if there's anything that stands out.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-809585691
Usability,simpl,simple,"Hmmm, not sure what the issue could be but dissipation field does look well-behaved. I agree that the time average isn't what I would expect based on the movie of the dissipation snapshots. Maybe the best way to approach this is to design a simple test that uses `KernelComputedField` + `TimeAveragedInterval`?. I'll have a look at the code to see if there's anything that stands out.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-809585691
Testability,test,tests,"veraged), which indicates that the issue doesn't necessarily have to do with `KernelComputedField`s. https://user-images.githubusercontent.com/13205162/112888062-c03b5d00-9088-11eb-9d70-82ecda21477b.mp4. https://user-images.githubusercontent.com/13205162/112888067-c3364d80-9088-11eb-8eb4-4c5174f45b62.mp4. Here are some line plots comparing dissipation calculated with both `ComputedFields` (cf) and `KernelComputedFields` (kcf) and output with both `TimeInterval` and `AveragedTimeInterval`. (Sorry for the colors being weird, but I wanna be able to see the overlaps.). ![Screenshot from 2021-03-29 12-23-18](https://user-images.githubusercontent.com/13205162/112888734-959dd400-9089-11eb-8423-44dfa0df94ff.png). As you can see the time-averaged results are consistent with each other, but not with the snapshot results. However, if I plot TKE I get somewhat different results:. ![Screenshot from 2021-03-29 12-22-55](https://user-images.githubusercontent.com/13205162/112888917-cbdb5380-9089-11eb-82c7-2de997138b1b.png). Here the snapshot results are consistent with each other, but the time-averaged TKE results computed with `ComputedFields` actually match the snapshots, but not the time-averaged TKE results computed with `KernelComputedFields`!. There's also a difference between the u-velocity using time-averaged results and snapshots:. ![Screenshot from 2021-03-29 12-32-23](https://user-images.githubusercontent.com/13205162/112889703-d8ac7700-908a-11eb-8e03-a5c3b6a70f02.png). I think this last plot provides us with a clue since the averages start at the right value, but the oscillations get dampened as time progresses. This may indicate that the average is being done with a window much bigger than the averaging period for some reason. Although this last one is hard to believe since, as @ali-ramadhan pointed out, there are many tests for `AveragedTimeInterval` and I feel like they'd have caught that. In any case, that's all I got for now! Some feedback is very much appreciated.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-809655170
Usability,feedback,feedback,"veraged), which indicates that the issue doesn't necessarily have to do with `KernelComputedField`s. https://user-images.githubusercontent.com/13205162/112888062-c03b5d00-9088-11eb-9d70-82ecda21477b.mp4. https://user-images.githubusercontent.com/13205162/112888067-c3364d80-9088-11eb-8eb4-4c5174f45b62.mp4. Here are some line plots comparing dissipation calculated with both `ComputedFields` (cf) and `KernelComputedFields` (kcf) and output with both `TimeInterval` and `AveragedTimeInterval`. (Sorry for the colors being weird, but I wanna be able to see the overlaps.). ![Screenshot from 2021-03-29 12-23-18](https://user-images.githubusercontent.com/13205162/112888734-959dd400-9089-11eb-8423-44dfa0df94ff.png). As you can see the time-averaged results are consistent with each other, but not with the snapshot results. However, if I plot TKE I get somewhat different results:. ![Screenshot from 2021-03-29 12-22-55](https://user-images.githubusercontent.com/13205162/112888917-cbdb5380-9089-11eb-82c7-2de997138b1b.png). Here the snapshot results are consistent with each other, but the time-averaged TKE results computed with `ComputedFields` actually match the snapshots, but not the time-averaged TKE results computed with `KernelComputedFields`!. There's also a difference between the u-velocity using time-averaged results and snapshots:. ![Screenshot from 2021-03-29 12-32-23](https://user-images.githubusercontent.com/13205162/112889703-d8ac7700-908a-11eb-8e03-a5c3b6a70f02.png). I think this last plot provides us with a clue since the averages start at the right value, but the oscillations get dampened as time progresses. This may indicate that the average is being done with a window much bigger than the averaging period for some reason. Although this last one is hard to believe since, as @ali-ramadhan pointed out, there are many tests for `AveragedTimeInterval` and I feel like they'd have caught that. In any case, that's all I got for now! Some feedback is very much appreciated.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-809655170
Integrability,message,messages,"> What is being plotted in the comparisons? It looks like 3D fields are being outputted, but the time series plots show some reduction of the 3D data. In the 1D comparisons I'm plotting the volume average over the whole domain. Sorry if that wasn't clear. > I think I might have missed something --- in the very first example, was TKE computed using a ComputedField or KernelComputedField? Are the later results in this post consistent with the first posted results?. My example script changed a bit throughout the day. In the beginning I was only using KernelComutedFields since I thought that was the source of the problem. Later I started computing the diagnostics with both KernelComputedFields and ComputedFields for comparison. Which is when I found that ComputedFields were also output incorrectly... So basically the code that I linked [in my previous comment](https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-809655170), which is the most up-to-date, should be the one we should continue to use to sort this out I think. > Is there any way that any of this has to do with time-step alignment?. It's possible, but I'm not sure how to test that for now... > Lastly, why is the window slightly different from the TimeInterval? What happens when the time-interval and averaging window are the same (which appears to be our default?). I think I reported it in an issue a while ago, but basically if I set the `window` to be exactly the same as `interval` I get warnings on Oceananigans telling me that I'm calculating the average before the window is complete or someting like that (this should be easy to fix I think...). So I always set the `window` to be slightly smaller than `interval` to avoid those messages. I tried setting the `window` exactly the same as `interval` and the results were the same (plus I got a lot of those warnings...).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-809905267
Safety,avoid,avoid,"> What is being plotted in the comparisons? It looks like 3D fields are being outputted, but the time series plots show some reduction of the 3D data. In the 1D comparisons I'm plotting the volume average over the whole domain. Sorry if that wasn't clear. > I think I might have missed something --- in the very first example, was TKE computed using a ComputedField or KernelComputedField? Are the later results in this post consistent with the first posted results?. My example script changed a bit throughout the day. In the beginning I was only using KernelComutedFields since I thought that was the source of the problem. Later I started computing the diagnostics with both KernelComputedFields and ComputedFields for comparison. Which is when I found that ComputedFields were also output incorrectly... So basically the code that I linked [in my previous comment](https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-809655170), which is the most up-to-date, should be the one we should continue to use to sort this out I think. > Is there any way that any of this has to do with time-step alignment?. It's possible, but I'm not sure how to test that for now... > Lastly, why is the window slightly different from the TimeInterval? What happens when the time-interval and averaging window are the same (which appears to be our default?). I think I reported it in an issue a while ago, but basically if I set the `window` to be exactly the same as `interval` I get warnings on Oceananigans telling me that I'm calculating the average before the window is complete or someting like that (this should be easy to fix I think...). So I always set the `window` to be slightly smaller than `interval` to avoid those messages. I tried setting the `window` exactly the same as `interval` and the results were the same (plus I got a lot of those warnings...).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-809905267
Testability,test,test,"> What is being plotted in the comparisons? It looks like 3D fields are being outputted, but the time series plots show some reduction of the 3D data. In the 1D comparisons I'm plotting the volume average over the whole domain. Sorry if that wasn't clear. > I think I might have missed something --- in the very first example, was TKE computed using a ComputedField or KernelComputedField? Are the later results in this post consistent with the first posted results?. My example script changed a bit throughout the day. In the beginning I was only using KernelComutedFields since I thought that was the source of the problem. Later I started computing the diagnostics with both KernelComputedFields and ComputedFields for comparison. Which is when I found that ComputedFields were also output incorrectly... So basically the code that I linked [in my previous comment](https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-809655170), which is the most up-to-date, should be the one we should continue to use to sort this out I think. > Is there any way that any of this has to do with time-step alignment?. It's possible, but I'm not sure how to test that for now... > Lastly, why is the window slightly different from the TimeInterval? What happens when the time-interval and averaging window are the same (which appears to be our default?). I think I reported it in an issue a while ago, but basically if I set the `window` to be exactly the same as `interval` I get warnings on Oceananigans telling me that I'm calculating the average before the window is complete or someting like that (this should be easy to fix I think...). So I always set the `window` to be slightly smaller than `interval` to avoid those messages. I tried setting the `window` exactly the same as `interval` and the results were the same (plus I got a lot of those warnings...).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-809905267
Usability,clear,clear,"> What is being plotted in the comparisons? It looks like 3D fields are being outputted, but the time series plots show some reduction of the 3D data. In the 1D comparisons I'm plotting the volume average over the whole domain. Sorry if that wasn't clear. > I think I might have missed something --- in the very first example, was TKE computed using a ComputedField or KernelComputedField? Are the later results in this post consistent with the first posted results?. My example script changed a bit throughout the day. In the beginning I was only using KernelComutedFields since I thought that was the source of the problem. Later I started computing the diagnostics with both KernelComputedFields and ComputedFields for comparison. Which is when I found that ComputedFields were also output incorrectly... So basically the code that I linked [in my previous comment](https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-809655170), which is the most up-to-date, should be the one we should continue to use to sort this out I think. > Is there any way that any of this has to do with time-step alignment?. It's possible, but I'm not sure how to test that for now... > Lastly, why is the window slightly different from the TimeInterval? What happens when the time-interval and averaging window are the same (which appears to be our default?). I think I reported it in an issue a while ago, but basically if I set the `window` to be exactly the same as `interval` I get warnings on Oceananigans telling me that I'm calculating the average before the window is complete or someting like that (this should be easy to fix I think...). So I always set the `window` to be slightly smaller than `interval` to avoid those messages. I tried setting the `window` exactly the same as `interval` and the results were the same (plus I got a lot of those warnings...).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-809905267
Safety,predict,predictably,"Sure we can do that. But before we start a PR with a new test, shouldn't we first make sure there isn't anything wrong with my script?. That said, I think the basic ingredients are. - A time-average (NetCDF?) output (obviously); - Some diagnostic (preferably a Field, not a ComputedField) that changes in time predictably. The issue with creating a truly _minimal_ MWE is that (like [your comment summed up well](https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-810496153)) it's not clear which outputs exhibit the issue and which ones don't. I _think_ we might be able to get away with simply starting a quiescent simulation apart from a uniform u velocity and see if the total momentum is conserved on average. (This should start inertial oscillations.)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-817971702
Testability,test,test,"Sure we can do that. But before we start a PR with a new test, shouldn't we first make sure there isn't anything wrong with my script?. That said, I think the basic ingredients are. - A time-average (NetCDF?) output (obviously); - Some diagnostic (preferably a Field, not a ComputedField) that changes in time predictably. The issue with creating a truly _minimal_ MWE is that (like [your comment summed up well](https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-810496153)) it's not clear which outputs exhibit the issue and which ones don't. I _think_ we might be able to get away with simply starting a quiescent simulation apart from a uniform u velocity and see if the total momentum is conserved on average. (This should start inertial oscillations.)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-817971702
Usability,clear,clear,"Sure we can do that. But before we start a PR with a new test, shouldn't we first make sure there isn't anything wrong with my script?. That said, I think the basic ingredients are. - A time-average (NetCDF?) output (obviously); - Some diagnostic (preferably a Field, not a ComputedField) that changes in time predictably. The issue with creating a truly _minimal_ MWE is that (like [your comment summed up well](https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-810496153)) it's not clear which outputs exhibit the issue and which ones don't. I _think_ we might be able to get away with simply starting a quiescent simulation apart from a uniform u velocity and see if the total momentum is conserved on average. (This should start inertial oscillations.)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-817971702
Testability,test,test,"I believe setting up a simple test is a quick way to determine whether there is a problem with your script and also improves Oceananigans.jl, making progress towards solving this problem, if there is one.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-817979922
Usability,simpl,simple,"I believe setting up a simple test is a quick way to determine whether there is a problem with your script and also improves Oceananigans.jl, making progress towards solving this problem, if there is one.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-817979922
Availability,ping,ping,"Here's what I posted earlier:. > Correct: time-averaging a TKE ComputedField; Wrong: time-averaging a TKE KernelComputedField; Wrong: time-averaging a dissipation ComputedField; Wrong: time-averaging a dissipation KernelComputedField. From this list I might infer that the two ingredients are 1) `KernelComputedField` OR 2) gradients. Gradients / interpolation ping boundary conditions, which are tricky so there's good reason to test that. Maybe two tests: one for `ComputedField` with interpolation or derivatives, and another with `KernelComputedField` (that's maybe a bit simpler)?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-817992499
Testability,test,test,"Here's what I posted earlier:. > Correct: time-averaging a TKE ComputedField; Wrong: time-averaging a TKE KernelComputedField; Wrong: time-averaging a dissipation ComputedField; Wrong: time-averaging a dissipation KernelComputedField. From this list I might infer that the two ingredients are 1) `KernelComputedField` OR 2) gradients. Gradients / interpolation ping boundary conditions, which are tricky so there's good reason to test that. Maybe two tests: one for `ComputedField` with interpolation or derivatives, and another with `KernelComputedField` (that's maybe a bit simpler)?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-817992499
Usability,simpl,simpler,"Here's what I posted earlier:. > Correct: time-averaging a TKE ComputedField; Wrong: time-averaging a TKE KernelComputedField; Wrong: time-averaging a dissipation ComputedField; Wrong: time-averaging a dissipation KernelComputedField. From this list I might infer that the two ingredients are 1) `KernelComputedField` OR 2) gradients. Gradients / interpolation ping boundary conditions, which are tricky so there's good reason to test that. Maybe two tests: one for `ComputedField` with interpolation or derivatives, and another with `KernelComputedField` (that's maybe a bit simpler)?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-817992499
Testability,test,test,I'll set up a simple test in which both tracers and velocity fields oscillate and see if we can reproduce the bug.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-818006716
Usability,simpl,simple,I'll set up a simple test in which both tracers and velocity fields oscillate and see if we can reproduce the bug.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-818006716
Energy Efficiency,schedul,schedule,"ans; using Oceananigans.Utils; using Oceananigans.Units. grid = RegularRectilinearGrid(size=(4, 4, 4), x=(0, 1e6), y=(0, 1e6), z=(-4e3, 0)); coriolis = FPlane(f=1e-4) # [s⁻¹]. model = IncompressibleModel(; architecture = CPU(),; grid = grid,; coriolis = coriolis,; tracers = NamedTuple(),; buoyancy = nothing,; closure = nothing,; ); set!(model, u=0.4). using Oceanostics: SingleLineProgressMessenger; Δt = 20minutes; simulation = Simulation(model, Δt = Δt, iteration_interval = 20,; stop_time = 3days,; progress = SingleLineProgressMessenger()). using Oceananigans.Fields: ComputedField; using Oceanostics: KineticEnergy. u, v, w = model.velocities # unpack velocity `Field`s. # Vertical vorticity [s⁻¹]; tke_k = KineticEnergy(model, u, v, w); tke_c = ComputedField(@at (Center, Center, Center) (u^2+v^2+w^2)/2). outputs = (tke_c=tke_c, u=u,). using Oceananigans.OutputWriters: NetCDFOutputWriter, TimeInterval, AveragedTimeInterval; simulation.output_writers[:snap] = NetCDFOutputWriter(model, outputs,; schedule = TimeInterval(2Δt),; filepath = ""snap.eady.nc"",; mode = ""c""); simulation.output_writers[:avg] = NetCDFOutputWriter(model, outputs,; schedule = AveragedTimeInterval(2Δt; window=1.999Δt, stride=1),; filepath = ""avg.eady.nc"",; mode = ""c""). @info ""Starting run""; run!(simulation); ```. This produces the wrong result for `u`, reproduced below. (Appears to be a cumulative mean.) . ![u_evolution](https://user-images.githubusercontent.com/13205162/124214589-537c9800-daa7-11eb-99cd-ef90fcc5b8cd.png). However, if I swap the line `outputs = (tke_c=tke_c, u=u,)` for ; ```julia; outputs = (tke_k=tke_k, u=u,); ```; (so basically I'm just changing the **TKE** calculation from being done with a `ComputedField` to being done with a `KernelComputedField`) then the output for **`u`** is correct!. ![u_evolution](https://user-images.githubusercontent.com/13205162/124214510-2c25cb00-daa7-11eb-9b48-c2c9c3bd5b4a.png). So just to be clear: the nature of the other diagnostics being calculated in ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-872684633
Security,access,accessed,"umulative mean.) . ![u_evolution](https://user-images.githubusercontent.com/13205162/124214589-537c9800-daa7-11eb-99cd-ef90fcc5b8cd.png). However, if I swap the line `outputs = (tke_c=tke_c, u=u,)` for ; ```julia; outputs = (tke_k=tke_k, u=u,); ```; (so basically I'm just changing the **TKE** calculation from being done with a `ComputedField` to being done with a `KernelComputedField`) then the output for **`u`** is correct!. ![u_evolution](https://user-images.githubusercontent.com/13205162/124214510-2c25cb00-daa7-11eb-9b48-c2c9c3bd5b4a.png). So just to be clear: the nature of the other diagnostics being calculated in the list of outputs changes the average result for `u`! Below is a list of what works and doesn't work (for `u`) when setting the list of outputs:. ```julia; outputs = (tke_c=tke_c, u=u,) # Doesn't work; outputs = (tke_k=tke_k, u=u,) # Works; outputs = (tke_k=tke_k, tke_c=tke_c, u=u,) # Doesn't work; outputs = (tke_k=tke_k, u=u, v=v, w=w) # Doesn't work; outputs = (tke_k=tke_k, u=u, v=v,) # Doesn't work; outputs = (u=u, v=v,) # Doesn't work; outputs = (u=u, w=w,) # Doesn't work; outputs = (u=u,) # Works; ```. Notes: . - I haven't checked the calculation of the other stuff yet; - I created [a branch](https://github.com/CliMA/Oceananigans.jl/tree/tc/fix-time-average) that lets me keep track of when each condition [here](https://github.com/CliMA/Oceananigans.jl/blob/d17f926b2c4787bf44f619439e81bfb82937aabf/src/OutputWriters/windowed_time_average.jl#L146) gets accessed and the number of times it accesses [this condition](https://github.com/CliMA/Oceananigans.jl/blob/d17f926b2c4787bf44f619439e81bfb82937aabf/src/OutputWriters/windowed_time_average.jl#L190) changes based on what's on the output list. Is this expected?; - I've reproduced this in two different machines but I still haven't got confirmation that anyone else reproduced this independently. Could someone please run this? Here's the [Python script to generate this plot](https://pastebin.com/1dSE1hGj)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-872684633
Testability,test,tests,"Okay, I did some tests and I'm just getting more confused. Here's a more minimal example where I'm creating a simulation with zero everywhere except for a uniform initial condition for `u` and I added Coriolis (to have an inertial oscillation):. ```julia; using Oceananigans; using Oceananigans.Utils; using Oceananigans.Units. grid = RegularRectilinearGrid(size=(4, 4, 4), x=(0, 1e6), y=(0, 1e6), z=(-4e3, 0)); coriolis = FPlane(f=1e-4) # [s⁻¹]. model = IncompressibleModel(; architecture = CPU(),; grid = grid,; coriolis = coriolis,; tracers = NamedTuple(),; buoyancy = nothing,; closure = nothing,; ); set!(model, u=0.4). using Oceanostics: SingleLineProgressMessenger; Δt = 20minutes; simulation = Simulation(model, Δt = Δt, iteration_interval = 20,; stop_time = 3days,; progress = SingleLineProgressMessenger()). using Oceananigans.Fields: ComputedField; using Oceanostics: KineticEnergy. u, v, w = model.velocities # unpack velocity `Field`s. # Vertical vorticity [s⁻¹]; tke_k = KineticEnergy(model, u, v, w); tke_c = ComputedField(@at (Center, Center, Center) (u^2+v^2+w^2)/2). outputs = (tke_c=tke_c, u=u,). using Oceananigans.OutputWriters: NetCDFOutputWriter, TimeInterval, AveragedTimeInterval; simulation.output_writers[:snap] = NetCDFOutputWriter(model, outputs,; schedule = TimeInterval(2Δt),; filepath = ""snap.eady.nc"",; mode = ""c""); simulation.output_writers[:avg] = NetCDFOutputWriter(model, outputs,; schedule = AveragedTimeInterval(2Δt; window=1.999Δt, stride=1),; filepath = ""avg.eady.nc"",; mode = ""c""). @info ""Starting run""; run!(simulation); ```. This produces the wrong result for `u`, reproduced below. (Appears to be a cumulative mean.) . ![u_evolution](https://user-images.githubusercontent.com/13205162/124214589-537c9800-daa7-11eb-99cd-ef90fcc5b8cd.png). However, if I swap the line `outputs = (tke_c=tke_c, u=u,)` for ; ```julia; outputs = (tke_k=tke_k, u=u,); ```; (so basically I'm just changing the **TKE** calculation from being done with a `ComputedField` to being do",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-872684633
Usability,clear,clear,",; filepath = ""snap.eady.nc"",; mode = ""c""); simulation.output_writers[:avg] = NetCDFOutputWriter(model, outputs,; schedule = AveragedTimeInterval(2Δt; window=1.999Δt, stride=1),; filepath = ""avg.eady.nc"",; mode = ""c""). @info ""Starting run""; run!(simulation); ```. This produces the wrong result for `u`, reproduced below. (Appears to be a cumulative mean.) . ![u_evolution](https://user-images.githubusercontent.com/13205162/124214589-537c9800-daa7-11eb-99cd-ef90fcc5b8cd.png). However, if I swap the line `outputs = (tke_c=tke_c, u=u,)` for ; ```julia; outputs = (tke_k=tke_k, u=u,); ```; (so basically I'm just changing the **TKE** calculation from being done with a `ComputedField` to being done with a `KernelComputedField`) then the output for **`u`** is correct!. ![u_evolution](https://user-images.githubusercontent.com/13205162/124214510-2c25cb00-daa7-11eb-9b48-c2c9c3bd5b4a.png). So just to be clear: the nature of the other diagnostics being calculated in the list of outputs changes the average result for `u`! Below is a list of what works and doesn't work (for `u`) when setting the list of outputs:. ```julia; outputs = (tke_c=tke_c, u=u,) # Doesn't work; outputs = (tke_k=tke_k, u=u,) # Works; outputs = (tke_k=tke_k, tke_c=tke_c, u=u,) # Doesn't work; outputs = (tke_k=tke_k, u=u, v=v, w=w) # Doesn't work; outputs = (tke_k=tke_k, u=u, v=v,) # Doesn't work; outputs = (u=u, v=v,) # Doesn't work; outputs = (u=u, w=w,) # Doesn't work; outputs = (u=u,) # Works; ```. Notes: . - I haven't checked the calculation of the other stuff yet; - I created [a branch](https://github.com/CliMA/Oceananigans.jl/tree/tc/fix-time-average) that lets me keep track of when each condition [here](https://github.com/CliMA/Oceananigans.jl/blob/d17f926b2c4787bf44f619439e81bfb82937aabf/src/OutputWriters/windowed_time_average.jl#L146) gets accessed and the number of times it accesses [this condition](https://github.com/CliMA/Oceananigans.jl/blob/d17f926b2c4787bf44f619439e81bfb82937aabf/src/OutputWriters",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-872684633
Security,access,access,"> What is the type of `tke_k`? With one exception it seems like there's an issue with two or more fields. Sorry, should have made it more clear. It's calculated with a `KernelComputedField`.; ; > I think it should access that condition `M * N` times, where `M` is the number of outputs being averaged. Okay, then I guess that part is fine.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-873158382
Usability,clear,clear,"> What is the type of `tke_k`? With one exception it seems like there's an issue with two or more fields. Sorry, should have made it more clear. It's calculated with a `KernelComputedField`.; ; > I think it should access that condition `M * N` times, where `M` is the number of outputs being averaged. Okay, then I guess that part is fine.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-873158382
Availability,failure,failure,"It's easy to extend the existing simple test to a two-output case, so I did that on #1807. If #1807 passes, then there is some other aspect of the setup that's producing a failure. It's also possible that there is more than one problem / cause of woe.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-873162947
Modifiability,extend,extend,"It's easy to extend the existing simple test to a two-output case, so I did that on #1807. If #1807 passes, then there is some other aspect of the setup that's producing a failure. It's also possible that there is more than one problem / cause of woe.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-873162947
Testability,test,test,"It's easy to extend the existing simple test to a two-output case, so I did that on #1807. If #1807 passes, then there is some other aspect of the setup that's producing a failure. It's also possible that there is more than one problem / cause of woe.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-873162947
Usability,simpl,simple,"It's easy to extend the existing simple test to a two-output case, so I did that on #1807. If #1807 passes, then there is some other aspect of the setup that's producing a failure. It's also possible that there is more than one problem / cause of woe.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-873162947
Availability,avail,available,"TODO list (some we might want to address before merging, some we probably should open issues about):. 1. We need a new `Connected` topology with N `Bounded` `Face`s instead of N+1. For MPI we might also need `LeftConnected` and `RightConnected`. . 2. For cubed sphere fields, re-use existing fields but with new types: `CubedSphereData` and `CubedSphereBoundaryConditions`. 3. Figure out a clean way of integrating `fill_horizontal_velocity_halos!` with the existing time-stepping. Perhaps we just need a `maybe_fill_horizontal_velocity_halos!` function that only does something on a connected cubed sphere. 4. We need values for the grid coordinates `λᶜᶠᵃ`, `λᶠᶜᵃ`, `φᶜᶠᵃ`, and `φᶠᶜᵃ` so that we can use `set!` for velocities on the cubed sphere. They are not provided by the file but we should be able to convert the available coordinates back to the cubed sphere face in (ξ, η) coordinates where -1 ≤ ξ, η ≤ 1 which forms a regular grid then interpolate in between and back to the sphere to get the other staggered grid coordinates. 5. We need to use the sine and cosine of the local angle between the grid orientation (e.g., u-velocity) and zonal west-east direction at the grid-cell centers to `set!` velocity fields. Right now we're limited to setting velocity fields from a streamfunction... 6. Should we be filling the halos of the grid metrics? Seems like they should be filled like velocity halos but without any sign changes. 7. Make sure that calling `fill_halo_regions!` on a horizontal velocity field only fills the halos with non-`CubedSphereExchange` boundary conditions. 8. Add the cubed sphere passive tracer advection and surface gravity waves validation experiments to validation CI pipeline. 9. Figure out a way to abstract and clean up `fill_horizontal_velocity_halos!` and `fill_*_halo!`... 10. Merge utils from `src/CubedSpheres/cubed_sphere_utils.jl` and `src/Distributed/distributed_utils.jl` into `Oceananigans.Grids`. 11. Figure out if the tests in `test_cubed_sphere_halo_",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1522#issuecomment-816631979
Deployability,integrat,integrating,"TODO list (some we might want to address before merging, some we probably should open issues about):. 1. We need a new `Connected` topology with N `Bounded` `Face`s instead of N+1. For MPI we might also need `LeftConnected` and `RightConnected`. . 2. For cubed sphere fields, re-use existing fields but with new types: `CubedSphereData` and `CubedSphereBoundaryConditions`. 3. Figure out a clean way of integrating `fill_horizontal_velocity_halos!` with the existing time-stepping. Perhaps we just need a `maybe_fill_horizontal_velocity_halos!` function that only does something on a connected cubed sphere. 4. We need values for the grid coordinates `λᶜᶠᵃ`, `λᶠᶜᵃ`, `φᶜᶠᵃ`, and `φᶠᶜᵃ` so that we can use `set!` for velocities on the cubed sphere. They are not provided by the file but we should be able to convert the available coordinates back to the cubed sphere face in (ξ, η) coordinates where -1 ≤ ξ, η ≤ 1 which forms a regular grid then interpolate in between and back to the sphere to get the other staggered grid coordinates. 5. We need to use the sine and cosine of the local angle between the grid orientation (e.g., u-velocity) and zonal west-east direction at the grid-cell centers to `set!` velocity fields. Right now we're limited to setting velocity fields from a streamfunction... 6. Should we be filling the halos of the grid metrics? Seems like they should be filled like velocity halos but without any sign changes. 7. Make sure that calling `fill_halo_regions!` on a horizontal velocity field only fills the halos with non-`CubedSphereExchange` boundary conditions. 8. Add the cubed sphere passive tracer advection and surface gravity waves validation experiments to validation CI pipeline. 9. Figure out a way to abstract and clean up `fill_horizontal_velocity_halos!` and `fill_*_halo!`... 10. Merge utils from `src/CubedSpheres/cubed_sphere_utils.jl` and `src/Distributed/distributed_utils.jl` into `Oceananigans.Grids`. 11. Figure out if the tests in `test_cubed_sphere_halo_",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1522#issuecomment-816631979
Integrability,integrat,integrating,"TODO list (some we might want to address before merging, some we probably should open issues about):. 1. We need a new `Connected` topology with N `Bounded` `Face`s instead of N+1. For MPI we might also need `LeftConnected` and `RightConnected`. . 2. For cubed sphere fields, re-use existing fields but with new types: `CubedSphereData` and `CubedSphereBoundaryConditions`. 3. Figure out a clean way of integrating `fill_horizontal_velocity_halos!` with the existing time-stepping. Perhaps we just need a `maybe_fill_horizontal_velocity_halos!` function that only does something on a connected cubed sphere. 4. We need values for the grid coordinates `λᶜᶠᵃ`, `λᶠᶜᵃ`, `φᶜᶠᵃ`, and `φᶠᶜᵃ` so that we can use `set!` for velocities on the cubed sphere. They are not provided by the file but we should be able to convert the available coordinates back to the cubed sphere face in (ξ, η) coordinates where -1 ≤ ξ, η ≤ 1 which forms a regular grid then interpolate in between and back to the sphere to get the other staggered grid coordinates. 5. We need to use the sine and cosine of the local angle between the grid orientation (e.g., u-velocity) and zonal west-east direction at the grid-cell centers to `set!` velocity fields. Right now we're limited to setting velocity fields from a streamfunction... 6. Should we be filling the halos of the grid metrics? Seems like they should be filled like velocity halos but without any sign changes. 7. Make sure that calling `fill_halo_regions!` on a horizontal velocity field only fills the halos with non-`CubedSphereExchange` boundary conditions. 8. Add the cubed sphere passive tracer advection and surface gravity waves validation experiments to validation CI pipeline. 9. Figure out a way to abstract and clean up `fill_horizontal_velocity_halos!` and `fill_*_halo!`... 10. Merge utils from `src/CubedSpheres/cubed_sphere_utils.jl` and `src/Distributed/distributed_utils.jl` into `Oceananigans.Grids`. 11. Figure out if the tests in `test_cubed_sphere_halo_",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1522#issuecomment-816631979
Performance,perform,performance,"ure out a clean way of integrating `fill_horizontal_velocity_halos!` with the existing time-stepping. Perhaps we just need a `maybe_fill_horizontal_velocity_halos!` function that only does something on a connected cubed sphere. 4. We need values for the grid coordinates `λᶜᶠᵃ`, `λᶠᶜᵃ`, `φᶜᶠᵃ`, and `φᶠᶜᵃ` so that we can use `set!` for velocities on the cubed sphere. They are not provided by the file but we should be able to convert the available coordinates back to the cubed sphere face in (ξ, η) coordinates where -1 ≤ ξ, η ≤ 1 which forms a regular grid then interpolate in between and back to the sphere to get the other staggered grid coordinates. 5. We need to use the sine and cosine of the local angle between the grid orientation (e.g., u-velocity) and zonal west-east direction at the grid-cell centers to `set!` velocity fields. Right now we're limited to setting velocity fields from a streamfunction... 6. Should we be filling the halos of the grid metrics? Seems like they should be filled like velocity halos but without any sign changes. 7. Make sure that calling `fill_halo_regions!` on a horizontal velocity field only fills the halos with non-`CubedSphereExchange` boundary conditions. 8. Add the cubed sphere passive tracer advection and surface gravity waves validation experiments to validation CI pipeline. 9. Figure out a way to abstract and clean up `fill_horizontal_velocity_halos!` and `fill_*_halo!`... 10. Merge utils from `src/CubedSpheres/cubed_sphere_utils.jl` and `src/Distributed/distributed_utils.jl` into `Oceananigans.Grids`. 11. Figure out if the tests in `test_cubed_sphere_halo_exchange.jl` can be abstracted and run for all six faces. It's tedious to have to type them out but could be clearer and easier to debug in its current form... 12. Fix tests!. 13. I think cubed sphere performance can be improved, especially for halo filling. We might need some benchmarks and profiling to figure out where cubed sphere simulations are allocating too much memory.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1522#issuecomment-816631979
Security,validat,validation,"ure out a clean way of integrating `fill_horizontal_velocity_halos!` with the existing time-stepping. Perhaps we just need a `maybe_fill_horizontal_velocity_halos!` function that only does something on a connected cubed sphere. 4. We need values for the grid coordinates `λᶜᶠᵃ`, `λᶠᶜᵃ`, `φᶜᶠᵃ`, and `φᶠᶜᵃ` so that we can use `set!` for velocities on the cubed sphere. They are not provided by the file but we should be able to convert the available coordinates back to the cubed sphere face in (ξ, η) coordinates where -1 ≤ ξ, η ≤ 1 which forms a regular grid then interpolate in between and back to the sphere to get the other staggered grid coordinates. 5. We need to use the sine and cosine of the local angle between the grid orientation (e.g., u-velocity) and zonal west-east direction at the grid-cell centers to `set!` velocity fields. Right now we're limited to setting velocity fields from a streamfunction... 6. Should we be filling the halos of the grid metrics? Seems like they should be filled like velocity halos but without any sign changes. 7. Make sure that calling `fill_halo_regions!` on a horizontal velocity field only fills the halos with non-`CubedSphereExchange` boundary conditions. 8. Add the cubed sphere passive tracer advection and surface gravity waves validation experiments to validation CI pipeline. 9. Figure out a way to abstract and clean up `fill_horizontal_velocity_halos!` and `fill_*_halo!`... 10. Merge utils from `src/CubedSpheres/cubed_sphere_utils.jl` and `src/Distributed/distributed_utils.jl` into `Oceananigans.Grids`. 11. Figure out if the tests in `test_cubed_sphere_halo_exchange.jl` can be abstracted and run for all six faces. It's tedious to have to type them out but could be clearer and easier to debug in its current form... 12. Fix tests!. 13. I think cubed sphere performance can be improved, especially for halo filling. We might need some benchmarks and profiling to figure out where cubed sphere simulations are allocating too much memory.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1522#issuecomment-816631979
Testability,test,tests,"ure out a clean way of integrating `fill_horizontal_velocity_halos!` with the existing time-stepping. Perhaps we just need a `maybe_fill_horizontal_velocity_halos!` function that only does something on a connected cubed sphere. 4. We need values for the grid coordinates `λᶜᶠᵃ`, `λᶠᶜᵃ`, `φᶜᶠᵃ`, and `φᶠᶜᵃ` so that we can use `set!` for velocities on the cubed sphere. They are not provided by the file but we should be able to convert the available coordinates back to the cubed sphere face in (ξ, η) coordinates where -1 ≤ ξ, η ≤ 1 which forms a regular grid then interpolate in between and back to the sphere to get the other staggered grid coordinates. 5. We need to use the sine and cosine of the local angle between the grid orientation (e.g., u-velocity) and zonal west-east direction at the grid-cell centers to `set!` velocity fields. Right now we're limited to setting velocity fields from a streamfunction... 6. Should we be filling the halos of the grid metrics? Seems like they should be filled like velocity halos but without any sign changes. 7. Make sure that calling `fill_halo_regions!` on a horizontal velocity field only fills the halos with non-`CubedSphereExchange` boundary conditions. 8. Add the cubed sphere passive tracer advection and surface gravity waves validation experiments to validation CI pipeline. 9. Figure out a way to abstract and clean up `fill_horizontal_velocity_halos!` and `fill_*_halo!`... 10. Merge utils from `src/CubedSpheres/cubed_sphere_utils.jl` and `src/Distributed/distributed_utils.jl` into `Oceananigans.Grids`. 11. Figure out if the tests in `test_cubed_sphere_halo_exchange.jl` can be abstracted and run for all six faces. It's tedious to have to type them out but could be clearer and easier to debug in its current form... 12. Fix tests!. 13. I think cubed sphere performance can be improved, especially for halo filling. We might need some benchmarks and profiling to figure out where cubed sphere simulations are allocating too much memory.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1522#issuecomment-816631979
Usability,clear,clearer,"ure out a clean way of integrating `fill_horizontal_velocity_halos!` with the existing time-stepping. Perhaps we just need a `maybe_fill_horizontal_velocity_halos!` function that only does something on a connected cubed sphere. 4. We need values for the grid coordinates `λᶜᶠᵃ`, `λᶠᶜᵃ`, `φᶜᶠᵃ`, and `φᶠᶜᵃ` so that we can use `set!` for velocities on the cubed sphere. They are not provided by the file but we should be able to convert the available coordinates back to the cubed sphere face in (ξ, η) coordinates where -1 ≤ ξ, η ≤ 1 which forms a regular grid then interpolate in between and back to the sphere to get the other staggered grid coordinates. 5. We need to use the sine and cosine of the local angle between the grid orientation (e.g., u-velocity) and zonal west-east direction at the grid-cell centers to `set!` velocity fields. Right now we're limited to setting velocity fields from a streamfunction... 6. Should we be filling the halos of the grid metrics? Seems like they should be filled like velocity halos but without any sign changes. 7. Make sure that calling `fill_halo_regions!` on a horizontal velocity field only fills the halos with non-`CubedSphereExchange` boundary conditions. 8. Add the cubed sphere passive tracer advection and surface gravity waves validation experiments to validation CI pipeline. 9. Figure out a way to abstract and clean up `fill_horizontal_velocity_halos!` and `fill_*_halo!`... 10. Merge utils from `src/CubedSpheres/cubed_sphere_utils.jl` and `src/Distributed/distributed_utils.jl` into `Oceananigans.Grids`. 11. Figure out if the tests in `test_cubed_sphere_halo_exchange.jl` can be abstracted and run for all six faces. It's tedious to have to type them out but could be clearer and easier to debug in its current form... 12. Fix tests!. 13. I think cubed sphere performance can be improved, especially for halo filling. We might need some benchmarks and profiling to figure out where cubed sphere simulations are allocating too much memory.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1522#issuecomment-816631979
Availability,avail,available,"e we might want to address before merging, some we probably should open issues about):; > ; > 1. We need a new `Connected` topology with N `Bounded` `Face`s instead of N+1. For MPI we might also need `LeftConnected` and `RightConnected`. In this PR!. > 2. For cubed sphere fields, re-use existing fields but with new types: `CubedSphereData` and `CubedSphereBoundaryConditions`. Soon. > 3. Figure out a clean way of integrating `fill_horizontal_velocity_halos!` with the existing time-stepping. Perhaps we just need a `maybe_fill_horizontal_velocity_halos!` function that only does something on a connected cubed sphere. Let's come up with an abstraction for vectors and use this for `HydrostaticFreeSurfaceModel`. > 4. We need values for the grid coordinates `λᶜᶠᵃ`, `λᶠᶜᵃ`, `φᶜᶠᵃ`, and `φᶠᶜᵃ` so that we can use `set!` for velocities on the cubed sphere. They are not provided by the file but we should be able to convert the available coordinates back to the cubed sphere face in (ξ, η) coordinates where -1 ≤ ξ, η ≤ 1 which forms a regular grid then interpolate in between and back to the sphere to get the other staggered grid coordinates. The file should provide this. > 5. We need to use the sine and cosine of the local angle between the grid orientation (e.g., u-velocity) and zonal west-east direction at the grid-cell centers to `set!` velocity fields. Right now we're limited to setting velocity fields from a streamfunction... Let's come up with an abstraction for vectors and use this for `HydrostaticFreeSurfaceModel`. > 6. Should we be filling the halos of the grid metrics? Seems like they should be filled like velocity halos but without any sign changes. Yes. > 7. Make sure that calling `fill_halo_regions!` on a horizontal velocity field only fills the halos with non-`CubedSphereExchange` boundary conditions. Seems easy, but setting boundary conditions will require an abstraction for vectors and coordinate system transformations. > 8. Add the cubed sphere passive tracer adve",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1522#issuecomment-818046333
Deployability,integrat,integrating,"My two cents:. > TODO list (some we might want to address before merging, some we probably should open issues about):; > ; > 1. We need a new `Connected` topology with N `Bounded` `Face`s instead of N+1. For MPI we might also need `LeftConnected` and `RightConnected`. In this PR!. > 2. For cubed sphere fields, re-use existing fields but with new types: `CubedSphereData` and `CubedSphereBoundaryConditions`. Soon. > 3. Figure out a clean way of integrating `fill_horizontal_velocity_halos!` with the existing time-stepping. Perhaps we just need a `maybe_fill_horizontal_velocity_halos!` function that only does something on a connected cubed sphere. Let's come up with an abstraction for vectors and use this for `HydrostaticFreeSurfaceModel`. > 4. We need values for the grid coordinates `λᶜᶠᵃ`, `λᶠᶜᵃ`, `φᶜᶠᵃ`, and `φᶠᶜᵃ` so that we can use `set!` for velocities on the cubed sphere. They are not provided by the file but we should be able to convert the available coordinates back to the cubed sphere face in (ξ, η) coordinates where -1 ≤ ξ, η ≤ 1 which forms a regular grid then interpolate in between and back to the sphere to get the other staggered grid coordinates. The file should provide this. > 5. We need to use the sine and cosine of the local angle between the grid orientation (e.g., u-velocity) and zonal west-east direction at the grid-cell centers to `set!` velocity fields. Right now we're limited to setting velocity fields from a streamfunction... Let's come up with an abstraction for vectors and use this for `HydrostaticFreeSurfaceModel`. > 6. Should we be filling the halos of the grid metrics? Seems like they should be filled like velocity halos but without any sign changes. Yes. > 7. Make sure that calling `fill_halo_regions!` on a horizontal velocity field only fills the halos with non-`CubedSphereExchange` boundary conditions. Seems easy, but setting boundary conditions will require an abstraction for vectors and coordinate system transformations. > 8. Add the cu",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1522#issuecomment-818046333
Integrability,integrat,integrating,"My two cents:. > TODO list (some we might want to address before merging, some we probably should open issues about):; > ; > 1. We need a new `Connected` topology with N `Bounded` `Face`s instead of N+1. For MPI we might also need `LeftConnected` and `RightConnected`. In this PR!. > 2. For cubed sphere fields, re-use existing fields but with new types: `CubedSphereData` and `CubedSphereBoundaryConditions`. Soon. > 3. Figure out a clean way of integrating `fill_horizontal_velocity_halos!` with the existing time-stepping. Perhaps we just need a `maybe_fill_horizontal_velocity_halos!` function that only does something on a connected cubed sphere. Let's come up with an abstraction for vectors and use this for `HydrostaticFreeSurfaceModel`. > 4. We need values for the grid coordinates `λᶜᶠᵃ`, `λᶠᶜᵃ`, `φᶜᶠᵃ`, and `φᶠᶜᵃ` so that we can use `set!` for velocities on the cubed sphere. They are not provided by the file but we should be able to convert the available coordinates back to the cubed sphere face in (ξ, η) coordinates where -1 ≤ ξ, η ≤ 1 which forms a regular grid then interpolate in between and back to the sphere to get the other staggered grid coordinates. The file should provide this. > 5. We need to use the sine and cosine of the local angle between the grid orientation (e.g., u-velocity) and zonal west-east direction at the grid-cell centers to `set!` velocity fields. Right now we're limited to setting velocity fields from a streamfunction... Let's come up with an abstraction for vectors and use this for `HydrostaticFreeSurfaceModel`. > 6. Should we be filling the halos of the grid metrics? Seems like they should be filled like velocity halos but without any sign changes. Yes. > 7. Make sure that calling `fill_halo_regions!` on a horizontal velocity field only fills the halos with non-`CubedSphereExchange` boundary conditions. Seems easy, but setting boundary conditions will require an abstraction for vectors and coordinate system transformations. > 8. Add the cu",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1522#issuecomment-818046333
Performance,perform,performance,"n interpolate in between and back to the sphere to get the other staggered grid coordinates. The file should provide this. > 5. We need to use the sine and cosine of the local angle between the grid orientation (e.g., u-velocity) and zonal west-east direction at the grid-cell centers to `set!` velocity fields. Right now we're limited to setting velocity fields from a streamfunction... Let's come up with an abstraction for vectors and use this for `HydrostaticFreeSurfaceModel`. > 6. Should we be filling the halos of the grid metrics? Seems like they should be filled like velocity halos but without any sign changes. Yes. > 7. Make sure that calling `fill_halo_regions!` on a horizontal velocity field only fills the halos with non-`CubedSphereExchange` boundary conditions. Seems easy, but setting boundary conditions will require an abstraction for vectors and coordinate system transformations. > 8. Add the cubed sphere passive tracer advection and surface gravity waves validation experiments to validation CI pipeline. Not urgent. > 9. Figure out a way to abstract and clean up `fill_horizontal_velocity_halos!` and `fill_*_halo!`... Let's come up with an abstraction for vectors and use this for `HydrostaticFreeSurfaceModel`. We want to write `fill_halo_regions!(::HorizontalVectorField, ...)`. > 10. Merge utils from `src/CubedSpheres/cubed_sphere_utils.jl` and `src/Distributed/distributed_utils.jl` into `Oceananigans.Grids`. No rush... > 11. Figure out if the tests in `test_cubed_sphere_halo_exchange.jl` can be abstracted and run for all six faces. It's tedious to have to type them out but could be clearer and easier to debug in its current form... I don't think less abstraction is more clear. > 12. Fix tests!. Tests must pass or we can't develop. > 13. I think cubed sphere performance can be improved, especially for halo filling. We might need some benchmarks and profiling to figure out where cubed sphere simulations are allocating too much memory. Not urgent for this PR.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1522#issuecomment-818046333
Security,validat,validation,"1 which forms a regular grid then interpolate in between and back to the sphere to get the other staggered grid coordinates. The file should provide this. > 5. We need to use the sine and cosine of the local angle between the grid orientation (e.g., u-velocity) and zonal west-east direction at the grid-cell centers to `set!` velocity fields. Right now we're limited to setting velocity fields from a streamfunction... Let's come up with an abstraction for vectors and use this for `HydrostaticFreeSurfaceModel`. > 6. Should we be filling the halos of the grid metrics? Seems like they should be filled like velocity halos but without any sign changes. Yes. > 7. Make sure that calling `fill_halo_regions!` on a horizontal velocity field only fills the halos with non-`CubedSphereExchange` boundary conditions. Seems easy, but setting boundary conditions will require an abstraction for vectors and coordinate system transformations. > 8. Add the cubed sphere passive tracer advection and surface gravity waves validation experiments to validation CI pipeline. Not urgent. > 9. Figure out a way to abstract and clean up `fill_horizontal_velocity_halos!` and `fill_*_halo!`... Let's come up with an abstraction for vectors and use this for `HydrostaticFreeSurfaceModel`. We want to write `fill_halo_regions!(::HorizontalVectorField, ...)`. > 10. Merge utils from `src/CubedSpheres/cubed_sphere_utils.jl` and `src/Distributed/distributed_utils.jl` into `Oceananigans.Grids`. No rush... > 11. Figure out if the tests in `test_cubed_sphere_halo_exchange.jl` can be abstracted and run for all six faces. It's tedious to have to type them out but could be clearer and easier to debug in its current form... I don't think less abstraction is more clear. > 12. Fix tests!. Tests must pass or we can't develop. > 13. I think cubed sphere performance can be improved, especially for halo filling. We might need some benchmarks and profiling to figure out where cubed sphere simulations are allocating too much",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1522#issuecomment-818046333
Testability,test,tests,"n interpolate in between and back to the sphere to get the other staggered grid coordinates. The file should provide this. > 5. We need to use the sine and cosine of the local angle between the grid orientation (e.g., u-velocity) and zonal west-east direction at the grid-cell centers to `set!` velocity fields. Right now we're limited to setting velocity fields from a streamfunction... Let's come up with an abstraction for vectors and use this for `HydrostaticFreeSurfaceModel`. > 6. Should we be filling the halos of the grid metrics? Seems like they should be filled like velocity halos but without any sign changes. Yes. > 7. Make sure that calling `fill_halo_regions!` on a horizontal velocity field only fills the halos with non-`CubedSphereExchange` boundary conditions. Seems easy, but setting boundary conditions will require an abstraction for vectors and coordinate system transformations. > 8. Add the cubed sphere passive tracer advection and surface gravity waves validation experiments to validation CI pipeline. Not urgent. > 9. Figure out a way to abstract and clean up `fill_horizontal_velocity_halos!` and `fill_*_halo!`... Let's come up with an abstraction for vectors and use this for `HydrostaticFreeSurfaceModel`. We want to write `fill_halo_regions!(::HorizontalVectorField, ...)`. > 10. Merge utils from `src/CubedSpheres/cubed_sphere_utils.jl` and `src/Distributed/distributed_utils.jl` into `Oceananigans.Grids`. No rush... > 11. Figure out if the tests in `test_cubed_sphere_halo_exchange.jl` can be abstracted and run for all six faces. It's tedious to have to type them out but could be clearer and easier to debug in its current form... I don't think less abstraction is more clear. > 12. Fix tests!. Tests must pass or we can't develop. > 13. I think cubed sphere performance can be improved, especially for halo filling. We might need some benchmarks and profiling to figure out where cubed sphere simulations are allocating too much memory. Not urgent for this PR.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1522#issuecomment-818046333
Usability,clear,clearer,"n interpolate in between and back to the sphere to get the other staggered grid coordinates. The file should provide this. > 5. We need to use the sine and cosine of the local angle between the grid orientation (e.g., u-velocity) and zonal west-east direction at the grid-cell centers to `set!` velocity fields. Right now we're limited to setting velocity fields from a streamfunction... Let's come up with an abstraction for vectors and use this for `HydrostaticFreeSurfaceModel`. > 6. Should we be filling the halos of the grid metrics? Seems like they should be filled like velocity halos but without any sign changes. Yes. > 7. Make sure that calling `fill_halo_regions!` on a horizontal velocity field only fills the halos with non-`CubedSphereExchange` boundary conditions. Seems easy, but setting boundary conditions will require an abstraction for vectors and coordinate system transformations. > 8. Add the cubed sphere passive tracer advection and surface gravity waves validation experiments to validation CI pipeline. Not urgent. > 9. Figure out a way to abstract and clean up `fill_horizontal_velocity_halos!` and `fill_*_halo!`... Let's come up with an abstraction for vectors and use this for `HydrostaticFreeSurfaceModel`. We want to write `fill_halo_regions!(::HorizontalVectorField, ...)`. > 10. Merge utils from `src/CubedSpheres/cubed_sphere_utils.jl` and `src/Distributed/distributed_utils.jl` into `Oceananigans.Grids`. No rush... > 11. Figure out if the tests in `test_cubed_sphere_halo_exchange.jl` can be abstracted and run for all six faces. It's tedious to have to type them out but could be clearer and easier to debug in its current form... I don't think less abstraction is more clear. > 12. Fix tests!. Tests must pass or we can't develop. > 13. I think cubed sphere performance can be improved, especially for halo filling. We might need some benchmarks and profiling to figure out where cubed sphere simulations are allocating too much memory. Not urgent for this PR.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1522#issuecomment-818046333
Usability,learn,learned,"> Nice catch haha. Seems that ~30 other commits made it into this PR though?. Yes, sadly, I didn't start off on `master` and do a git pull. In retrospect, I should have trashed the branch and started again but oh well. All those are basically to restore to master. Sorry. I hope that I learned my lesson.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1528#issuecomment-811116295
Availability,avail,available,"Thanks, everyone. I'll merge this for now and we can improve on it later based on feedback from users. @glwagner I'm thinking of opening another PR soon to address your [comment about using GPUs](https://github.com/CliMA/Oceananigans.jl/pull/1543#issuecomment-818076711). Like I mentioned, some of this info is already available in the ""Using GPUs"" page, but maybe it's useful to expand a bit on it and link this newly created page there.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1543#issuecomment-819606114
Usability,feedback,feedback,"Thanks, everyone. I'll merge this for now and we can improve on it later based on feedback from users. @glwagner I'm thinking of opening another PR soon to address your [comment about using GPUs](https://github.com/CliMA/Oceananigans.jl/pull/1543#issuecomment-818076711). Like I mentioned, some of this info is already available in the ""Using GPUs"" page, but maybe it's useful to expand a bit on it and link this newly created page there.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1543#issuecomment-819606114
Availability,redundant,redundant,"> I would think that passing a function instead of collect(0:Nz) would probably be cleaner but both can work. Yeah I definitely think passing a function is more intuitive and efficient. As long as that's still an option, I'm happy :). > VerticallyStretchedRectilinearGrid(FT, size=(1, 1, Nz), x=(0, 1), y=(0, 1), z=(0, Nz), z_stretch=collect(0:Nz)); What's nice about this is that you still specify the domain boundaries, as other grids do, and you specify the stretching function separately. This makes it easier to do a stretch in any direction, and #1532 does just that. Sorry, but I'm a but confused. Aren't `x`, `y` and `z` supposed to be dimensional? Meaning they are the physical bounds of the domain? In your example `z=(0, Nz)`, which does not correspond to the physical boundaries at all. Or did you mean to write something like. ```julia; VerticallyStretchedRectilinearGrid(FT, size=(1, 1, Nz), x=(0, 1), y=(0, 1), z=(0, Lz), z_stretch=collect(0:Δz:Lz)); ```. If so then it makes sense to me, but that's a bit redundant, no? (Sorry for the confusion!)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813445443
Energy Efficiency,efficient,efficient,"> I would think that passing a function instead of collect(0:Nz) would probably be cleaner but both can work. Yeah I definitely think passing a function is more intuitive and efficient. As long as that's still an option, I'm happy :). > VerticallyStretchedRectilinearGrid(FT, size=(1, 1, Nz), x=(0, 1), y=(0, 1), z=(0, Nz), z_stretch=collect(0:Nz)); What's nice about this is that you still specify the domain boundaries, as other grids do, and you specify the stretching function separately. This makes it easier to do a stretch in any direction, and #1532 does just that. Sorry, but I'm a but confused. Aren't `x`, `y` and `z` supposed to be dimensional? Meaning they are the physical bounds of the domain? In your example `z=(0, Nz)`, which does not correspond to the physical boundaries at all. Or did you mean to write something like. ```julia; VerticallyStretchedRectilinearGrid(FT, size=(1, 1, Nz), x=(0, 1), y=(0, 1), z=(0, Lz), z_stretch=collect(0:Δz:Lz)); ```. If so then it makes sense to me, but that's a bit redundant, no? (Sorry for the confusion!)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813445443
Safety,redund,redundant,"> I would think that passing a function instead of collect(0:Nz) would probably be cleaner but both can work. Yeah I definitely think passing a function is more intuitive and efficient. As long as that's still an option, I'm happy :). > VerticallyStretchedRectilinearGrid(FT, size=(1, 1, Nz), x=(0, 1), y=(0, 1), z=(0, Nz), z_stretch=collect(0:Nz)); What's nice about this is that you still specify the domain boundaries, as other grids do, and you specify the stretching function separately. This makes it easier to do a stretch in any direction, and #1532 does just that. Sorry, but I'm a but confused. Aren't `x`, `y` and `z` supposed to be dimensional? Meaning they are the physical bounds of the domain? In your example `z=(0, Nz)`, which does not correspond to the physical boundaries at all. Or did you mean to write something like. ```julia; VerticallyStretchedRectilinearGrid(FT, size=(1, 1, Nz), x=(0, 1), y=(0, 1), z=(0, Lz), z_stretch=collect(0:Δz:Lz)); ```. If so then it makes sense to me, but that's a bit redundant, no? (Sorry for the confusion!)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813445443
Usability,intuit,intuitive,"> I would think that passing a function instead of collect(0:Nz) would probably be cleaner but both can work. Yeah I definitely think passing a function is more intuitive and efficient. As long as that's still an option, I'm happy :). > VerticallyStretchedRectilinearGrid(FT, size=(1, 1, Nz), x=(0, 1), y=(0, 1), z=(0, Nz), z_stretch=collect(0:Nz)); What's nice about this is that you still specify the domain boundaries, as other grids do, and you specify the stretching function separately. This makes it easier to do a stretch in any direction, and #1532 does just that. Sorry, but I'm a but confused. Aren't `x`, `y` and `z` supposed to be dimensional? Meaning they are the physical bounds of the domain? In your example `z=(0, Nz)`, which does not correspond to the physical boundaries at all. Or did you mean to write something like. ```julia; VerticallyStretchedRectilinearGrid(FT, size=(1, 1, Nz), x=(0, 1), y=(0, 1), z=(0, Lz), z_stretch=collect(0:Δz:Lz)); ```. If so then it makes sense to me, but that's a bit redundant, no? (Sorry for the confusion!)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813445443
Availability,redundant,redundant,"> > I would think that passing a function instead of collect(0:Nz) would probably be cleaner but both can work.; > ; > Yeah I definitely think passing a function is more intuitive and efficient. As long as that's still an option, I'm happy :); > ; > > VerticallyStretchedRectilinearGrid(FT, size=(1, 1, Nz), x=(0, 1), y=(0, 1), z=(0, Nz), z_stretch=collect(0:Nz)); > > What's nice about this is that you still specify the domain boundaries, as other grids do, and you specify the stretching function separately. This makes it easier to do a stretch in any direction, and #1532 does just that.; > ; > Sorry, but I'm a but confused. Aren't `x`, `y` and `z` supposed to be dimensional? Meaning they are the physical bounds of the domain? In your example `z=(0, Nz)`, which does not correspond to the physical boundaries at all. Or did you mean to write something like; > ; > ```julia; > VerticallyStretchedRectilinearGrid(FT, size=(1, 1, Nz), x=(0, 1), y=(0, 1), z=(0, Lz), z_stretch=collect(0:Δz:Lz)); > ```; > ; > If so then it makes sense to me, but that's a bit redundant, no? (Sorry for the confusion!). First, yes, it will certainly be an option. Second, unfortunately I took this example from one of the tests, hence the strange choice of parameters. Sorry about that. . But yes, x,y,z are dimensional and are the physical bounds of the domain. What you propose is what I should have written down before. That would be how to specify the stretched grid using an array. Otherwise, you could pass a function.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813447822
Energy Efficiency,efficient,efficient,"> > I would think that passing a function instead of collect(0:Nz) would probably be cleaner but both can work.; > ; > Yeah I definitely think passing a function is more intuitive and efficient. As long as that's still an option, I'm happy :); > ; > > VerticallyStretchedRectilinearGrid(FT, size=(1, 1, Nz), x=(0, 1), y=(0, 1), z=(0, Nz), z_stretch=collect(0:Nz)); > > What's nice about this is that you still specify the domain boundaries, as other grids do, and you specify the stretching function separately. This makes it easier to do a stretch in any direction, and #1532 does just that.; > ; > Sorry, but I'm a but confused. Aren't `x`, `y` and `z` supposed to be dimensional? Meaning they are the physical bounds of the domain? In your example `z=(0, Nz)`, which does not correspond to the physical boundaries at all. Or did you mean to write something like; > ; > ```julia; > VerticallyStretchedRectilinearGrid(FT, size=(1, 1, Nz), x=(0, 1), y=(0, 1), z=(0, Lz), z_stretch=collect(0:Δz:Lz)); > ```; > ; > If so then it makes sense to me, but that's a bit redundant, no? (Sorry for the confusion!). First, yes, it will certainly be an option. Second, unfortunately I took this example from one of the tests, hence the strange choice of parameters. Sorry about that. . But yes, x,y,z are dimensional and are the physical bounds of the domain. What you propose is what I should have written down before. That would be how to specify the stretched grid using an array. Otherwise, you could pass a function.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813447822
Safety,redund,redundant,"> > I would think that passing a function instead of collect(0:Nz) would probably be cleaner but both can work.; > ; > Yeah I definitely think passing a function is more intuitive and efficient. As long as that's still an option, I'm happy :); > ; > > VerticallyStretchedRectilinearGrid(FT, size=(1, 1, Nz), x=(0, 1), y=(0, 1), z=(0, Nz), z_stretch=collect(0:Nz)); > > What's nice about this is that you still specify the domain boundaries, as other grids do, and you specify the stretching function separately. This makes it easier to do a stretch in any direction, and #1532 does just that.; > ; > Sorry, but I'm a but confused. Aren't `x`, `y` and `z` supposed to be dimensional? Meaning they are the physical bounds of the domain? In your example `z=(0, Nz)`, which does not correspond to the physical boundaries at all. Or did you mean to write something like; > ; > ```julia; > VerticallyStretchedRectilinearGrid(FT, size=(1, 1, Nz), x=(0, 1), y=(0, 1), z=(0, Lz), z_stretch=collect(0:Δz:Lz)); > ```; > ; > If so then it makes sense to me, but that's a bit redundant, no? (Sorry for the confusion!). First, yes, it will certainly be an option. Second, unfortunately I took this example from one of the tests, hence the strange choice of parameters. Sorry about that. . But yes, x,y,z are dimensional and are the physical bounds of the domain. What you propose is what I should have written down before. That would be how to specify the stretched grid using an array. Otherwise, you could pass a function.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813447822
Testability,test,tests,"> > I would think that passing a function instead of collect(0:Nz) would probably be cleaner but both can work.; > ; > Yeah I definitely think passing a function is more intuitive and efficient. As long as that's still an option, I'm happy :); > ; > > VerticallyStretchedRectilinearGrid(FT, size=(1, 1, Nz), x=(0, 1), y=(0, 1), z=(0, Nz), z_stretch=collect(0:Nz)); > > What's nice about this is that you still specify the domain boundaries, as other grids do, and you specify the stretching function separately. This makes it easier to do a stretch in any direction, and #1532 does just that.; > ; > Sorry, but I'm a but confused. Aren't `x`, `y` and `z` supposed to be dimensional? Meaning they are the physical bounds of the domain? In your example `z=(0, Nz)`, which does not correspond to the physical boundaries at all. Or did you mean to write something like; > ; > ```julia; > VerticallyStretchedRectilinearGrid(FT, size=(1, 1, Nz), x=(0, 1), y=(0, 1), z=(0, Lz), z_stretch=collect(0:Δz:Lz)); > ```; > ; > If so then it makes sense to me, but that's a bit redundant, no? (Sorry for the confusion!). First, yes, it will certainly be an option. Second, unfortunately I took this example from one of the tests, hence the strange choice of parameters. Sorry about that. . But yes, x,y,z are dimensional and are the physical bounds of the domain. What you propose is what I should have written down before. That would be how to specify the stretched grid using an array. Otherwise, you could pass a function.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813447822
Usability,intuit,intuitive,"> > I would think that passing a function instead of collect(0:Nz) would probably be cleaner but both can work.; > ; > Yeah I definitely think passing a function is more intuitive and efficient. As long as that's still an option, I'm happy :); > ; > > VerticallyStretchedRectilinearGrid(FT, size=(1, 1, Nz), x=(0, 1), y=(0, 1), z=(0, Nz), z_stretch=collect(0:Nz)); > > What's nice about this is that you still specify the domain boundaries, as other grids do, and you specify the stretching function separately. This makes it easier to do a stretch in any direction, and #1532 does just that.; > ; > Sorry, but I'm a but confused. Aren't `x`, `y` and `z` supposed to be dimensional? Meaning they are the physical bounds of the domain? In your example `z=(0, Nz)`, which does not correspond to the physical boundaries at all. Or did you mean to write something like; > ; > ```julia; > VerticallyStretchedRectilinearGrid(FT, size=(1, 1, Nz), x=(0, 1), y=(0, 1), z=(0, Lz), z_stretch=collect(0:Δz:Lz)); > ```; > ; > If so then it makes sense to me, but that's a bit redundant, no? (Sorry for the confusion!). First, yes, it will certainly be an option. Second, unfortunately I took this example from one of the tests, hence the strange choice of parameters. Sorry about that. . But yes, x,y,z are dimensional and are the physical bounds of the domain. What you propose is what I should have written down before. That would be how to specify the stretched grid using an array. Otherwise, you could pass a function.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813447822
Availability,down,down,"> > ; > > ; > > Sorry, but I'm a but confused. Aren't `x`, `y` and `z` supposed to be dimensional? Meaning they are the physical bounds of the domain? In your example `z=(0, Nz)`, which does not correspond to the physical boundaries at all. Or did you mean to write something like; > > ```julia; > > VerticallyStretchedRectilinearGrid(FT, size=(1, 1, Nz), x=(0, 1), y=(0, 1), z=(0, Lz), z_stretch=collect(0:Δz:Lz)); > > ```; > ; > But yes, x,y,z are dimensional and are the physical bounds of the domain. What you propose is what I should have written down before. That would be how to specify the stretched grid using an array. Otherwise, you could pass a function. Okay, thanks for the clarification! So you're proposing something like. ```julia; VerticallyStretchedRectilinearGrid(FT, size=(1, 1, Nz), x=(0, 1), y=(0, 1), z=(0, Lz), z_stretch=collect(0:Δz:Lz)); ```. But in my opinion something closer to the previous alternative is already good enough, no? Since you can infer `z=(0, Lz)` from `z_stretch=function_or_array`:. ```julia; VerticallyStretchedRectilinearGrid(FT, size=(1, 1, Nz), x=(0, 1), y=(0, 1), z_stretch=collect(0:Δz:Lz)); ```. One can envision a general form of this where the following alternatives are all valid and the rest is inferred from the constructor:. ```julia; z_grid = ArbitrarilyStretchedRectilinearGrid(FT, size=(1, 1, Nz), x=(0, 1), y=(0, 1), z_stretch=collect(0:Δz:Lz)); y_grid = ArbitrarilyStretchedRectilinearGrid(FT, size=(1, 1, Nz), x=(0, 1), z=(0, 1), y_stretch=collect(0:Δz:Lz)); x_grid = ArbitrarilyStretchedRectilinearGrid(FT, size=(1, 1, Nz), y=(0, 1), z=(0, 1), x_stretch=collect(0:Δz:Lz)); ```. In my opinion this is better since it's a little cleaner (although it may require some more programming on the background). Also, I think `z_stretch` is less clear than `zF`, no? At least to me it's not clear what I'm supposed to provide as the `z_stretch` argument.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813457987
Usability,clear,clear,"> > ; > > ; > > Sorry, but I'm a but confused. Aren't `x`, `y` and `z` supposed to be dimensional? Meaning they are the physical bounds of the domain? In your example `z=(0, Nz)`, which does not correspond to the physical boundaries at all. Or did you mean to write something like; > > ```julia; > > VerticallyStretchedRectilinearGrid(FT, size=(1, 1, Nz), x=(0, 1), y=(0, 1), z=(0, Lz), z_stretch=collect(0:Δz:Lz)); > > ```; > ; > But yes, x,y,z are dimensional and are the physical bounds of the domain. What you propose is what I should have written down before. That would be how to specify the stretched grid using an array. Otherwise, you could pass a function. Okay, thanks for the clarification! So you're proposing something like. ```julia; VerticallyStretchedRectilinearGrid(FT, size=(1, 1, Nz), x=(0, 1), y=(0, 1), z=(0, Lz), z_stretch=collect(0:Δz:Lz)); ```. But in my opinion something closer to the previous alternative is already good enough, no? Since you can infer `z=(0, Lz)` from `z_stretch=function_or_array`:. ```julia; VerticallyStretchedRectilinearGrid(FT, size=(1, 1, Nz), x=(0, 1), y=(0, 1), z_stretch=collect(0:Δz:Lz)); ```. One can envision a general form of this where the following alternatives are all valid and the rest is inferred from the constructor:. ```julia; z_grid = ArbitrarilyStretchedRectilinearGrid(FT, size=(1, 1, Nz), x=(0, 1), y=(0, 1), z_stretch=collect(0:Δz:Lz)); y_grid = ArbitrarilyStretchedRectilinearGrid(FT, size=(1, 1, Nz), x=(0, 1), z=(0, 1), y_stretch=collect(0:Δz:Lz)); x_grid = ArbitrarilyStretchedRectilinearGrid(FT, size=(1, 1, Nz), y=(0, 1), z=(0, 1), x_stretch=collect(0:Δz:Lz)); ```. In my opinion this is better since it's a little cleaner (although it may require some more programming on the background). Also, I think `z_stretch` is less clear than `zF`, no? At least to me it's not clear what I'm supposed to provide as the `z_stretch` argument.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813457987
Usability,intuit,intuitive,"es, I am suggesting this syntax; ```; VerticallyStretchedRectilinearGrid(FT, size=(1, 1, Nz), x=(0, 1), y=(0, 1), z=(0, Lz), z_stretch=collect(0:Δz:Lz)); ```; or the following where `stretch_function` is an `@inline function`; ```; VerticallyStretchedRectilinearGrid(FT, size=(1, 1, Nz), x=(0, 1), y=(0, 1), z=(0, Lz), z_stretch=stretch_function); ```; Both will work. There are pluses and minuses in the different approaches. Below are a few thoughts. - You are correct that if you pass an array you know the end points so there is no real need to have `z=(0,Lz)`. ; - However, if you want to pass an inline function, then you don't need to specify the bounds at all, and these then serve a purpose.; - As I mentioned before, I think that specifying the domain is more similar to what's done in other grids. I do think that normzlizing the grids so that they follow a similar framework is advantageous. Both to be able to switch from one to the other, but also to the user who sees that this function is only different that we add another argument. ; - There could and should be a check added it to make sure that the first element and lasta elements of the grid are equal to z. What you suggest is also possible but then when you want to have stretching in 2 or 3 dimenions, you can still do it but then you need to have `xF`, `yF`, `zF` and you no longer have `x,y,z`. In terms of the coding, it seems easy to write up and run code that would specify the domain in all three directions and then stretches in whatever directions the user wants to stretch, with checks. I choose the name `z_stretch` to denote the stretched grid in the `z` direction. I supposed we could use `z_stretched` or something else. `zF` is not intuitive to me, someone who never used the stretched grid before, since it just suggests the faces. In some code I have seen `zF_generator`, which is better than `zF` but generator is maybe not as explicit as stretched or something else. Maybe we can come up with a better name?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813465259
Usability,simpl,simpler,"Thanks for the explanation. I agree there are pros and cons. I still prefer the simpler approach, but I can see why this one might be desirable. I'm still a bit unclear on what `z_stretch` should be, though. If it's an array or a function, it should provide the location of the faces, no?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813479254
Usability,clear,clear,"Just trying to understand the conversation so far and I have a couple of questions:. 1. Is it correct to think of this PR as being a precursor to PR #1532 (I guess this PR should be merged first)?; 2. Am I right in thinking that the current discussion is around whether we want to specify `z=(-Lz, 0), z_stretch=something` vs. just `z_stretch=something` (and infering `z=(-Lz, 0)` from `z_stretch`)?. I think it would be awesome if users never had to think about the staggered grid but in this case it might be unavoidable? I guess `z_stretch` (`zF` in the main branch) specifies the location of the faces (of which there are Nz+1 if z is `Bounded`) so this should be made clear (could be in the docstring I suppose). I'm also not a fan of `zF`. I think `z_stretch` is better. What if we allowed the `z` kwarg to be either a function, an array, or a 2-tuple (inferred to be regularly spaced)? And we clearly explain in the docstring and docs that arrays and functions specify the location of the faces.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813490794
Usability,clear,clearly,"> What if we allowed the z kwarg to be either a function, an array, or a 2-tuple (inferred to be regularly spaced)? And we clearly explain in the docstring and docs that arrays and functions specify the location of the faces. I like this option!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813508041
Integrability,depend,depends,"To answer @tomchor's question, yes, the grid is formed at the faces and that's easy enough to do when building the grid. For @ali-ramadhan questions. 1. @glwagner suggested that I try doing this in `VerticallyStretchedGrid` to see what it looks like and then we can discuss it. I'm happy to say that was very successful and now we are talking about it. I guess whether this PR is merged or not depends on how we want to proceed.; 2. Yes, I guess the question is what is the best design for the average user. Whatever we do, not everyone is going to like it but we should strive for something that is ""easy`, since that's in the description of Oceananigans. As a user I think I would simply want to specify the domain and then say I want a tighter grid around a particular point, say the left boundary, or any other point for that matter. I don't think the average user is going to care whether it's quadratic, cubic or hyperbolic, as long as you get better resolution around the point of interest. Is this something we agree on? If yes I would ideally want to user to specify the domain, where they want the clustering and then boom it happens. . @glwagner also suggeted in #1532, that it would be nice for us to put together some functions that the user can use to define grids. Specifying the array is not too difficult but I think we can make it easier by having functions to do most of the work for the user. I like @ali-ramadhan 's suggestion of having options in terms of what the input is and I will certainly need some help doing this, after we decide what we want the input to be.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813526543
Usability,simpl,simply,"To answer @tomchor's question, yes, the grid is formed at the faces and that's easy enough to do when building the grid. For @ali-ramadhan questions. 1. @glwagner suggested that I try doing this in `VerticallyStretchedGrid` to see what it looks like and then we can discuss it. I'm happy to say that was very successful and now we are talking about it. I guess whether this PR is merged or not depends on how we want to proceed.; 2. Yes, I guess the question is what is the best design for the average user. Whatever we do, not everyone is going to like it but we should strive for something that is ""easy`, since that's in the description of Oceananigans. As a user I think I would simply want to specify the domain and then say I want a tighter grid around a particular point, say the left boundary, or any other point for that matter. I don't think the average user is going to care whether it's quadratic, cubic or hyperbolic, as long as you get better resolution around the point of interest. Is this something we agree on? If yes I would ideally want to user to specify the domain, where they want the clustering and then boom it happens. . @glwagner also suggeted in #1532, that it would be nice for us to put together some functions that the user can use to define grids. Specifying the array is not too difficult but I think we can make it easier by having functions to do most of the work for the user. I like @ali-ramadhan 's suggestion of having options in terms of what the input is and I will certainly need some help doing this, after we decide what we want the input to be.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813526543
Integrability,interface,interface,"Thanks for all the clarifications, @francispoulin. Just a few thoughts:. I think regardless of what interface we end up using (allowing `x` to be a constructor, or creating a separate keyword such as `z_strecthed`) it needs to be absolutely clear what each option is gonna do. For example the name `z_stretched` doesn't tell us in any way that that corresponds to face locations. As a last option we can specify this clearly in the docstring, but ideally the keyword itself should be somewhat self-explanatory. About your comment about users not caring about what kind of stretching is used: regardless of creating convenience functions or not for stretched directions, we should always allow arbitrary stretching from the user part. That's because it's not just a matter of at which depth to make the grid tighter. Take free convection for example. Some users like to define a grid that is the finest close to the boundary and monotonically stretch from there (which I guess is what you have in mind). However, many people (and I know @glwagner is one of those) prefer simulating the whole boundary layer with one uniform resolution and only stretch the grid in the thermocline, for example. This has technical advantages such as aliasing reduction, etc.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813558166
Usability,clear,clear,"Thanks for all the clarifications, @francispoulin. Just a few thoughts:. I think regardless of what interface we end up using (allowing `x` to be a constructor, or creating a separate keyword such as `z_strecthed`) it needs to be absolutely clear what each option is gonna do. For example the name `z_stretched` doesn't tell us in any way that that corresponds to face locations. As a last option we can specify this clearly in the docstring, but ideally the keyword itself should be somewhat self-explanatory. About your comment about users not caring about what kind of stretching is used: regardless of creating convenience functions or not for stretched directions, we should always allow arbitrary stretching from the user part. That's because it's not just a matter of at which depth to make the grid tighter. Take free convection for example. Some users like to define a grid that is the finest close to the boundary and monotonically stretch from there (which I guess is what you have in mind). However, many people (and I know @glwagner is one of those) prefer simulating the whole boundary layer with one uniform resolution and only stretch the grid in the thermocline, for example. This has technical advantages such as aliasing reduction, etc.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813558166
Availability,avail,available,"Thanks @tomchor for your feedback. It is greatly apprecaited. For the first point, I completely appreciate that we need to be clear. This can be done in the docstrings but it is certainly nice to pick variable names that are intuitive and make the code easier to read. I think Oceananigans does this very well and I very much want to continue in this direction. . I wonder if something like `zF_stretch` might do the trick? The `zF` suggests the result will be at faces and `stretch` suggests that this is a stretching of some kind. Or maybe `z_Faces_stretched`?. I am sorry if I mispoke. I did not mean to say that users do not care about what kind of stretched grid we use. This is clearly not the case. What I wanted to say is that a beginning user probably would be more concerned about having a stretched grid and probably not so much of the details. Some users would of course care a great deal about the kind of grid, and we definitely want to help both kinds of users. I agree with @glwagner 's suggestion of us supply a few basic examples for people to use, as a starting point. Users should certainly be able to take these examples, build on them, and build whatever kind of stretched grid they want. This is currently available and this should always be the case. When defining our examples we should not only define the region (or regions where we want it stretched, as it shouldn't only have to be one spot), but also the degree to which it decays. I don't necessarily have the language to describe this accurately now, but when putting together a sample function/array, I think a lot of this will beome clearer (to me at least).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813565145
Modifiability,variab,variable,"Thanks @tomchor for your feedback. It is greatly apprecaited. For the first point, I completely appreciate that we need to be clear. This can be done in the docstrings but it is certainly nice to pick variable names that are intuitive and make the code easier to read. I think Oceananigans does this very well and I very much want to continue in this direction. . I wonder if something like `zF_stretch` might do the trick? The `zF` suggests the result will be at faces and `stretch` suggests that this is a stretching of some kind. Or maybe `z_Faces_stretched`?. I am sorry if I mispoke. I did not mean to say that users do not care about what kind of stretched grid we use. This is clearly not the case. What I wanted to say is that a beginning user probably would be more concerned about having a stretched grid and probably not so much of the details. Some users would of course care a great deal about the kind of grid, and we definitely want to help both kinds of users. I agree with @glwagner 's suggestion of us supply a few basic examples for people to use, as a starting point. Users should certainly be able to take these examples, build on them, and build whatever kind of stretched grid they want. This is currently available and this should always be the case. When defining our examples we should not only define the region (or regions where we want it stretched, as it shouldn't only have to be one spot), but also the degree to which it decays. I don't necessarily have the language to describe this accurately now, but when putting together a sample function/array, I think a lot of this will beome clearer (to me at least).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813565145
Usability,feedback,feedback,"Thanks @tomchor for your feedback. It is greatly apprecaited. For the first point, I completely appreciate that we need to be clear. This can be done in the docstrings but it is certainly nice to pick variable names that are intuitive and make the code easier to read. I think Oceananigans does this very well and I very much want to continue in this direction. . I wonder if something like `zF_stretch` might do the trick? The `zF` suggests the result will be at faces and `stretch` suggests that this is a stretching of some kind. Or maybe `z_Faces_stretched`?. I am sorry if I mispoke. I did not mean to say that users do not care about what kind of stretched grid we use. This is clearly not the case. What I wanted to say is that a beginning user probably would be more concerned about having a stretched grid and probably not so much of the details. Some users would of course care a great deal about the kind of grid, and we definitely want to help both kinds of users. I agree with @glwagner 's suggestion of us supply a few basic examples for people to use, as a starting point. Users should certainly be able to take these examples, build on them, and build whatever kind of stretched grid they want. This is currently available and this should always be the case. When defining our examples we should not only define the region (or regions where we want it stretched, as it shouldn't only have to be one spot), but also the degree to which it decays. I don't necessarily have the language to describe this accurately now, but when putting together a sample function/array, I think a lot of this will beome clearer (to me at least).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813565145
Usability,feedback,feedback,"Thanks for the effort in this PR @francispoulin. And it's a good point that without much user feedback it's hard to anticipate what will be best for them. > One change that I would like to make is instead of having zF as input, I would prefer to have zFs or even zFaces, to emphasize that all the faces are specified. Usually, when I see zF I think of a face, and that's not the case here. @tomchor , what do you think about this?. I agree that `zFaces` is better than `zF` and `z_stretched`. Way more intuitive. To be inline with the Oceananigans/Julia naming conventions it might be best to use `z_faces` or `ZFaces` though. But that's up to you. I have no personal preference here.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-814119908
Usability,learn,learning,"Thanks @tomchor . Sadly, I'm still learning the naming conventions, but did you mean to suggest `z_Faces`? If yes I'm happy to use that, or `z_faces`, if that is more inline with convention.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-814124178
Usability,clear,clearer,"I don't know a lot about this (@ali-ramadhan and @glwagner can give you a much clearer picture) but I think up until last week KernelAbstractions.jl straight up didn't support AMD. It relied on defining CUDAKernels which are specific to Nvidia GPUs. Now I believe they also added ROCKernels, that are meant to take care of the AMD case. However I think we still need some work on our end since Oceananigans imports CUDA and uses some CUDA-specific functions in lots of places. I think something needs to be done in these instances.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1546#issuecomment-813560368
Availability,error,error,"So, I also tried upgrading my whole project without upgrading Julia (so still using Julia 1.5.2) and the error persists. . To be clear, before the upgrade below everything was working normally and after the upgrade the checkpointer stopped being created. Here's the upgrade:. ```; Updating registry at `~/.julia/registries/General`; ######################################################################## 100.0%; Installed Showoff ───── v1.0.2; Installed StructTypes ─ v1.6.0; Installed Tables ────── v1.4.2; Installed Plots ─────── v1.11.2; Installed ArgParse ──── v1.1.4; Installed GR ────────── v0.57.3; Updating `/glade/scratch/tomasc/ISI_jet/Project.toml`; [c7e460c6] ↑ ArgParse v1.1.2 ⇒ v1.1.4; [63c18a36] ↑ KernelAbstractions v0.5.4 ⇒ v0.5.5; [9e8cae18] ↑ Oceananigans v0.53.2 ⇒ v0.54.0; [91a5bcdd] ↑ Plots v1.11.0 ⇒ v1.11.2; Updating `/glade/scratch/tomasc/ISI_jet/Manifest.toml`; [79e6a3ab] ↑ Adapt v3.2.0 ⇒ v3.3.0; [c7e460c6] ↑ ArgParse v1.1.2 ⇒ v1.1.4; [4fba245c] ↑ ArrayInterface v3.1.6 ⇒ v3.1.7; [052768ef] ↑ CUDA v2.4.1 ⇒ v2.4.3; [d360d2e6] ↑ ChainRulesCore v0.9.34 ⇒ v0.9.37; [35d6a980] ↑ ColorSchemes v3.10.2 ⇒ v3.11.0; [5ae59095] ↑ Colors v0.12.6 ⇒ v0.12.7; [34da2185] ↑ Compat v3.25.0 ⇒ v3.27.0; [0c68f7d7] ↑ GPUArrays v6.2.0 ⇒ v6.2.2; [28b8d3ca] ↑ GR v0.55.0 ⇒ v0.57.3; [d2c73de3] ↑ GR_jll v0.56.1+0 ⇒ v0.57.2+0; [63c18a36] ↑ KernelAbstractions v0.5.4 ⇒ v0.5.5; [da04e1cc] ↑ MPI v0.17.1 ⇒ v0.17.2; [872c559c] ↑ NNlib v0.7.17 ⇒ v0.7.18; [9e8cae18] ↑ Oceananigans v0.53.2 ⇒ v0.54.0; [91a5bcdd] ↑ Plots v1.11.0 ⇒ v1.11.2; [ea2cea3b] + Qt5Base_jll v5.15.2+0; [ede63266] - Qt_jll v5.15.2+3; [01d81517] ↑ RecipesPipeline v0.3.1 ⇒ v0.3.2; [992d4aef] ↑ Showoff v0.3.2 ⇒ v1.0.2; [2913bbd2] ↑ StatsBase v0.33.4 ⇒ v0.33.5; [09ab397b] ↑ StructArrays v0.5.0 ⇒ v0.5.1; [856f2bd8] ↑ StructTypes v1.5.0 ⇒ v1.6.0; [3783bdb8] ↑ TableTraits v1.0.0 ⇒ v1.0.1; [bd369af6] ↑ Tables v1.4.1 ⇒ v1.4.2; [6aa5eb33] ↑ TaylorSeries v0.10.11 ⇒ v0.10.12; [0796e94c] ↑ Tokenize v0.5.15 ⇒ v0.5.16; ```. I was able t",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1547#issuecomment-818960260
Deployability,upgrade,upgrade,"So, I also tried upgrading my whole project without upgrading Julia (so still using Julia 1.5.2) and the error persists. . To be clear, before the upgrade below everything was working normally and after the upgrade the checkpointer stopped being created. Here's the upgrade:. ```; Updating registry at `~/.julia/registries/General`; ######################################################################## 100.0%; Installed Showoff ───── v1.0.2; Installed StructTypes ─ v1.6.0; Installed Tables ────── v1.4.2; Installed Plots ─────── v1.11.2; Installed ArgParse ──── v1.1.4; Installed GR ────────── v0.57.3; Updating `/glade/scratch/tomasc/ISI_jet/Project.toml`; [c7e460c6] ↑ ArgParse v1.1.2 ⇒ v1.1.4; [63c18a36] ↑ KernelAbstractions v0.5.4 ⇒ v0.5.5; [9e8cae18] ↑ Oceananigans v0.53.2 ⇒ v0.54.0; [91a5bcdd] ↑ Plots v1.11.0 ⇒ v1.11.2; Updating `/glade/scratch/tomasc/ISI_jet/Manifest.toml`; [79e6a3ab] ↑ Adapt v3.2.0 ⇒ v3.3.0; [c7e460c6] ↑ ArgParse v1.1.2 ⇒ v1.1.4; [4fba245c] ↑ ArrayInterface v3.1.6 ⇒ v3.1.7; [052768ef] ↑ CUDA v2.4.1 ⇒ v2.4.3; [d360d2e6] ↑ ChainRulesCore v0.9.34 ⇒ v0.9.37; [35d6a980] ↑ ColorSchemes v3.10.2 ⇒ v3.11.0; [5ae59095] ↑ Colors v0.12.6 ⇒ v0.12.7; [34da2185] ↑ Compat v3.25.0 ⇒ v3.27.0; [0c68f7d7] ↑ GPUArrays v6.2.0 ⇒ v6.2.2; [28b8d3ca] ↑ GR v0.55.0 ⇒ v0.57.3; [d2c73de3] ↑ GR_jll v0.56.1+0 ⇒ v0.57.2+0; [63c18a36] ↑ KernelAbstractions v0.5.4 ⇒ v0.5.5; [da04e1cc] ↑ MPI v0.17.1 ⇒ v0.17.2; [872c559c] ↑ NNlib v0.7.17 ⇒ v0.7.18; [9e8cae18] ↑ Oceananigans v0.53.2 ⇒ v0.54.0; [91a5bcdd] ↑ Plots v1.11.0 ⇒ v1.11.2; [ea2cea3b] + Qt5Base_jll v5.15.2+0; [ede63266] - Qt_jll v5.15.2+3; [01d81517] ↑ RecipesPipeline v0.3.1 ⇒ v0.3.2; [992d4aef] ↑ Showoff v0.3.2 ⇒ v1.0.2; [2913bbd2] ↑ StatsBase v0.33.4 ⇒ v0.33.5; [09ab397b] ↑ StructArrays v0.5.0 ⇒ v0.5.1; [856f2bd8] ↑ StructTypes v1.5.0 ⇒ v1.6.0; [3783bdb8] ↑ TableTraits v1.0.0 ⇒ v1.0.1; [bd369af6] ↑ Tables v1.4.1 ⇒ v1.4.2; [6aa5eb33] ↑ TaylorSeries v0.10.11 ⇒ v0.10.12; [0796e94c] ↑ Tokenize v0.5.15 ⇒ v0.5.16; ```. I was able t",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1547#issuecomment-818960260
Energy Efficiency,schedul,schedule,"e v0.33.4 ⇒ v0.33.5; [09ab397b] ↑ StructArrays v0.5.0 ⇒ v0.5.1; [856f2bd8] ↑ StructTypes v1.5.0 ⇒ v1.6.0; [3783bdb8] ↑ TableTraits v1.0.0 ⇒ v1.0.1; [bd369af6] ↑ Tables v1.4.1 ⇒ v1.4.2; [6aa5eb33] ↑ TaylorSeries v0.10.11 ⇒ v0.10.12; [0796e94c] ↑ Tokenize v0.5.15 ⇒ v0.5.16; ```. I was able to create a MWE this time:. ```julia; using Printf; using Oceananigans; using Oceananigans: Utils, Units; using Oceananigans.OutputWriters; using Oceanostics: SingleLineProgressMessenger. grid = RegularRectilinearGrid(size=(4, 4, 4), extent=(1,1,1)); model = IncompressibleModel(architecture = CPU(), grid = grid). start_time = 1e-9*time_ns(); simulation = Simulation(model, Δt=1, stop_time=50, iteration_interval=5,; progress=SingleLineProgressMessenger(LES=false, initial_wall_time_seconds=start_time),; ); println(""\n"", simulation,""\n"",). @info ""Setting up chk writer""; simulation.output_writers[:chk_writer] = Checkpointer(model; dir=""."",; prefix = ""chk.test"",; schedule = TimeInterval(5),; force = true, cleanup = true,; ); ; println(""\n"", simulation,""\n"",) . @printf(""---> Starting run!\n""); run!(simulation, pickup=true); ```. This results in the following output:. ```julia. Simulation{IncompressibleModel{CPU, Float64}}; ├── Model clock: time = 0 seconds, iteration = 0 ; ├── Next time step (Int64): 1 second ; ├── Iteration interval: 5; ├── Stop criteria: Any[Oceananigans.Simulations.iteration_limit_exceeded, Oceananigans.Simulations.stop_time_exceeded, Oceananigans.Simulations.wall_time_limit_exceeded]; ├── Run time: 0 seconds, wall time limit: Inf; ├── Stop time: 50 seconds, stop iteration: Inf; ├── Diagnostics: OrderedCollections.OrderedDict with 1 entry:; │ └── nan_checker => NaNChecker; └── Output writers: OrderedCollections.OrderedDict with no entries. [ Info: Setting up chk writer. Simulation{IncompressibleModel{CPU, Float64}}; ├── Model clock: time = 0 seconds, iteration = 0 ; ├── Next time step (Int64): 1 second ; ├── Iteration interval: 5; ├── Stop criteria: Any[Oceananigans.Sim",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1547#issuecomment-818960260
Testability,test,test,"e v0.33.4 ⇒ v0.33.5; [09ab397b] ↑ StructArrays v0.5.0 ⇒ v0.5.1; [856f2bd8] ↑ StructTypes v1.5.0 ⇒ v1.6.0; [3783bdb8] ↑ TableTraits v1.0.0 ⇒ v1.0.1; [bd369af6] ↑ Tables v1.4.1 ⇒ v1.4.2; [6aa5eb33] ↑ TaylorSeries v0.10.11 ⇒ v0.10.12; [0796e94c] ↑ Tokenize v0.5.15 ⇒ v0.5.16; ```. I was able to create a MWE this time:. ```julia; using Printf; using Oceananigans; using Oceananigans: Utils, Units; using Oceananigans.OutputWriters; using Oceanostics: SingleLineProgressMessenger. grid = RegularRectilinearGrid(size=(4, 4, 4), extent=(1,1,1)); model = IncompressibleModel(architecture = CPU(), grid = grid). start_time = 1e-9*time_ns(); simulation = Simulation(model, Δt=1, stop_time=50, iteration_interval=5,; progress=SingleLineProgressMessenger(LES=false, initial_wall_time_seconds=start_time),; ); println(""\n"", simulation,""\n"",). @info ""Setting up chk writer""; simulation.output_writers[:chk_writer] = Checkpointer(model; dir=""."",; prefix = ""chk.test"",; schedule = TimeInterval(5),; force = true, cleanup = true,; ); ; println(""\n"", simulation,""\n"",) . @printf(""---> Starting run!\n""); run!(simulation, pickup=true); ```. This results in the following output:. ```julia. Simulation{IncompressibleModel{CPU, Float64}}; ├── Model clock: time = 0 seconds, iteration = 0 ; ├── Next time step (Int64): 1 second ; ├── Iteration interval: 5; ├── Stop criteria: Any[Oceananigans.Simulations.iteration_limit_exceeded, Oceananigans.Simulations.stop_time_exceeded, Oceananigans.Simulations.wall_time_limit_exceeded]; ├── Run time: 0 seconds, wall time limit: Inf; ├── Stop time: 50 seconds, stop iteration: Inf; ├── Diagnostics: OrderedCollections.OrderedDict with 1 entry:; │ └── nan_checker => NaNChecker; └── Output writers: OrderedCollections.OrderedDict with no entries. [ Info: Setting up chk writer. Simulation{IncompressibleModel{CPU, Float64}}; ├── Model clock: time = 0 seconds, iteration = 0 ; ├── Next time step (Int64): 1 second ; ├── Iteration interval: 5; ├── Stop criteria: Any[Oceananigans.Sim",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1547#issuecomment-818960260
Usability,clear,clear,"So, I also tried upgrading my whole project without upgrading Julia (so still using Julia 1.5.2) and the error persists. . To be clear, before the upgrade below everything was working normally and after the upgrade the checkpointer stopped being created. Here's the upgrade:. ```; Updating registry at `~/.julia/registries/General`; ######################################################################## 100.0%; Installed Showoff ───── v1.0.2; Installed StructTypes ─ v1.6.0; Installed Tables ────── v1.4.2; Installed Plots ─────── v1.11.2; Installed ArgParse ──── v1.1.4; Installed GR ────────── v0.57.3; Updating `/glade/scratch/tomasc/ISI_jet/Project.toml`; [c7e460c6] ↑ ArgParse v1.1.2 ⇒ v1.1.4; [63c18a36] ↑ KernelAbstractions v0.5.4 ⇒ v0.5.5; [9e8cae18] ↑ Oceananigans v0.53.2 ⇒ v0.54.0; [91a5bcdd] ↑ Plots v1.11.0 ⇒ v1.11.2; Updating `/glade/scratch/tomasc/ISI_jet/Manifest.toml`; [79e6a3ab] ↑ Adapt v3.2.0 ⇒ v3.3.0; [c7e460c6] ↑ ArgParse v1.1.2 ⇒ v1.1.4; [4fba245c] ↑ ArrayInterface v3.1.6 ⇒ v3.1.7; [052768ef] ↑ CUDA v2.4.1 ⇒ v2.4.3; [d360d2e6] ↑ ChainRulesCore v0.9.34 ⇒ v0.9.37; [35d6a980] ↑ ColorSchemes v3.10.2 ⇒ v3.11.0; [5ae59095] ↑ Colors v0.12.6 ⇒ v0.12.7; [34da2185] ↑ Compat v3.25.0 ⇒ v3.27.0; [0c68f7d7] ↑ GPUArrays v6.2.0 ⇒ v6.2.2; [28b8d3ca] ↑ GR v0.55.0 ⇒ v0.57.3; [d2c73de3] ↑ GR_jll v0.56.1+0 ⇒ v0.57.2+0; [63c18a36] ↑ KernelAbstractions v0.5.4 ⇒ v0.5.5; [da04e1cc] ↑ MPI v0.17.1 ⇒ v0.17.2; [872c559c] ↑ NNlib v0.7.17 ⇒ v0.7.18; [9e8cae18] ↑ Oceananigans v0.53.2 ⇒ v0.54.0; [91a5bcdd] ↑ Plots v1.11.0 ⇒ v1.11.2; [ea2cea3b] + Qt5Base_jll v5.15.2+0; [ede63266] - Qt_jll v5.15.2+3; [01d81517] ↑ RecipesPipeline v0.3.1 ⇒ v0.3.2; [992d4aef] ↑ Showoff v0.3.2 ⇒ v1.0.2; [2913bbd2] ↑ StatsBase v0.33.4 ⇒ v0.33.5; [09ab397b] ↑ StructArrays v0.5.0 ⇒ v0.5.1; [856f2bd8] ↑ StructTypes v1.5.0 ⇒ v1.6.0; [3783bdb8] ↑ TableTraits v1.0.0 ⇒ v1.0.1; [bd369af6] ↑ Tables v1.4.1 ⇒ v1.4.2; [6aa5eb33] ↑ TaylorSeries v0.10.11 ⇒ v0.10.12; [0796e94c] ↑ Tokenize v0.5.15 ⇒ v0.5.16; ```. I was able t",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1547#issuecomment-818960260
Deployability,update,update,"@francispoulin thanks for starting this discussion!. Broadly speaking I think we would like to implement an arbitrary Lagrangian-Eulerian vertical coordinate in the long run. As far as I understand, implementing an ALE scheme would require more changes than just a new `AbstractGrid`. We need to modify the time-stepping to include a regridding / interpolation stage, and I believe we also need to change the equations being solved (the tendency kernels). . My preliminary thought on software design is that this might be a new model property, something like `HydrostaticFreeSurfaceModel.vertical_coordinate`. Then one needs to interpret the z-coordinate in the chosen `HydrostaticFreeSurfaceModel.grid` in light of the choice of `HydrostaticFreeSurfaceModel.vertical_coordinate`. Other design ideas are certainly welcome!. Something less clear is what happens if we design a terrain following coordinate. Perhaps you are write @francispoulin that terrain following coordinates can be implemented purely by introducing a new type of grid (because the grid is not moving... ?) I think terrain-following, curvilinear grid would require three-dimensionally curvilinear operators, correct? So we would have to update the implementation of the `HydrostaticFreeSurfaceModel` operators as well. As for a horizontal grid for `ShallowWaterModel`, since we have horizontally-curvilinear operators I think you might be able to do `boundary_following` in the horizontal once you refactor `ShallowWaterModel` to use horizontally-curvilinear operators.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1549#issuecomment-814206629
Modifiability,refactor,refactor,"@francispoulin thanks for starting this discussion!. Broadly speaking I think we would like to implement an arbitrary Lagrangian-Eulerian vertical coordinate in the long run. As far as I understand, implementing an ALE scheme would require more changes than just a new `AbstractGrid`. We need to modify the time-stepping to include a regridding / interpolation stage, and I believe we also need to change the equations being solved (the tendency kernels). . My preliminary thought on software design is that this might be a new model property, something like `HydrostaticFreeSurfaceModel.vertical_coordinate`. Then one needs to interpret the z-coordinate in the chosen `HydrostaticFreeSurfaceModel.grid` in light of the choice of `HydrostaticFreeSurfaceModel.vertical_coordinate`. Other design ideas are certainly welcome!. Something less clear is what happens if we design a terrain following coordinate. Perhaps you are write @francispoulin that terrain following coordinates can be implemented purely by introducing a new type of grid (because the grid is not moving... ?) I think terrain-following, curvilinear grid would require three-dimensionally curvilinear operators, correct? So we would have to update the implementation of the `HydrostaticFreeSurfaceModel` operators as well. As for a horizontal grid for `ShallowWaterModel`, since we have horizontally-curvilinear operators I think you might be able to do `boundary_following` in the horizontal once you refactor `ShallowWaterModel` to use horizontally-curvilinear operators.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1549#issuecomment-814206629
Usability,clear,clear,"@francispoulin thanks for starting this discussion!. Broadly speaking I think we would like to implement an arbitrary Lagrangian-Eulerian vertical coordinate in the long run. As far as I understand, implementing an ALE scheme would require more changes than just a new `AbstractGrid`. We need to modify the time-stepping to include a regridding / interpolation stage, and I believe we also need to change the equations being solved (the tendency kernels). . My preliminary thought on software design is that this might be a new model property, something like `HydrostaticFreeSurfaceModel.vertical_coordinate`. Then one needs to interpret the z-coordinate in the chosen `HydrostaticFreeSurfaceModel.grid` in light of the choice of `HydrostaticFreeSurfaceModel.vertical_coordinate`. Other design ideas are certainly welcome!. Something less clear is what happens if we design a terrain following coordinate. Perhaps you are write @francispoulin that terrain following coordinates can be implemented purely by introducing a new type of grid (because the grid is not moving... ?) I think terrain-following, curvilinear grid would require three-dimensionally curvilinear operators, correct? So we would have to update the implementation of the `HydrostaticFreeSurfaceModel` operators as well. As for a horizontal grid for `ShallowWaterModel`, since we have horizontally-curvilinear operators I think you might be able to do `boundary_following` in the horizontal once you refactor `ShallowWaterModel` to use horizontally-curvilinear operators.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1549#issuecomment-814206629
Energy Efficiency,charge,charge,"Thanks @glwagner for the quickly and in depth rely!. I don't know the details of AEL but sounds interesting, and complicated. I think what I am suggesting is much simpler, but certainly related. Maybe this could be a first step in that bigger problem? . Starting simple, `ShallowWaterModel` would be the place to start as it only has horizontal coordiantes and so there would not need to be any need (I don't think) to create any new operators. The steps to do this could include the following:. - [ ] Create a dispatch between `ConservationForm` and `VectorInvariantForm` (similar to `HydrostaticModel` I presume); - [ ] Define a new grid, maybe called `BoundaryFollowingGrid`; - [ ] Merge the two together. Could it be that easy? If @glwagner could help with the dispactching between the two forms, then I think I could borrow heavily from `HydrostaticModel` to put together the right equations. As a bonus, this would also allow us to do `SphericalShallowWater` free of charge. . As for the origninal problem I suggested, with terrain-following coordinates, since the grid is fixed all it needs is analogous versions of the operators in `xz` space. So the machinary is all there but some translation needs to be done. Starting with a 2D vertical slice would be very similar to shallow water but there is an incompressibility condition that needs to be imposed, but we have tools to solve that. I don't think we need to go to 3D curvlinear coordinates since it's only curvlinear in 2 dimensions. I can find references for this if that would help. Actually Allistair had some great news of a class he taught at MIT on the MITgcm, that explaines it very well. I know as that's where I learned it from. . But as per usual, maybe I will suggest doing shallow water first as it's easier.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1549#issuecomment-814256133
Usability,simpl,simpler,"Thanks @glwagner for the quickly and in depth rely!. I don't know the details of AEL but sounds interesting, and complicated. I think what I am suggesting is much simpler, but certainly related. Maybe this could be a first step in that bigger problem? . Starting simple, `ShallowWaterModel` would be the place to start as it only has horizontal coordiantes and so there would not need to be any need (I don't think) to create any new operators. The steps to do this could include the following:. - [ ] Create a dispatch between `ConservationForm` and `VectorInvariantForm` (similar to `HydrostaticModel` I presume); - [ ] Define a new grid, maybe called `BoundaryFollowingGrid`; - [ ] Merge the two together. Could it be that easy? If @glwagner could help with the dispactching between the two forms, then I think I could borrow heavily from `HydrostaticModel` to put together the right equations. As a bonus, this would also allow us to do `SphericalShallowWater` free of charge. . As for the origninal problem I suggested, with terrain-following coordinates, since the grid is fixed all it needs is analogous versions of the operators in `xz` space. So the machinary is all there but some translation needs to be done. Starting with a 2D vertical slice would be very similar to shallow water but there is an incompressibility condition that needs to be imposed, but we have tools to solve that. I don't think we need to go to 3D curvlinear coordinates since it's only curvlinear in 2 dimensions. I can find references for this if that would help. Actually Allistair had some great news of a class he taught at MIT on the MITgcm, that explaines it very well. I know as that's where I learned it from. . But as per usual, maybe I will suggest doing shallow water first as it's easier.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1549#issuecomment-814256133
Usability,clear,clear,"Here is a PDF from Allistar and section 1.2 is what describes what I'm suggesting. Clearly not my original idea. [main_ch10.pdf](https://github.com/CliMA/Oceananigans.jl/files/6266259/main_ch10.pdf). Sorry if I am not being clear. We agree that shallow water would be curvlinear in two dimesions, those dimensions are x and y. Consider the stratified of a 2D vertical slice, where the only dimensions are x,z. Clearly this problem is curvlinear in 2D as that's all there is. If we add on a y direction, that is regular, then it's still only 2D curvlinear. I guess the analogue wold be that the hydrostatic model is 3D but only curvlinear in the horizontal. This is the same thing but with a 90 degree rotation. I realize this is not what exists but I don't think there is any new methods here, it's a matter of relabeling. If this isn't clear than maybe we can chat sometime?. The ""flux_form"" operations sounds interesting, but I don't think I know what those are. . Sure, there must be a better name than what I suggested and will keep that in mind.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1549#issuecomment-814271048
Usability,clear,clear,"> Sorry if I am not being clear. We agree that shallow water would be curvlinear in two dimesions, those dimensions are x and y. Consider the stratified of a 2D vertical slice, where the only dimensions are x,z. Clearly this problem is curvlinear in 2D as that's all there is. If we add on a y direction, that is regular, then it's still only 2D curvlinear. I guess the analogue wold be that the hydrostatic model is 3D but only curvlinear in the horizontal. This is the same thing but with a 90 degree rotation. I realize this is not what exists but I don't think there is any new methods here, it's a matter of relabeling. If this isn't clear than maybe we can chat sometime?. I think to implement this problem we should generalize our operators to be curvilinear in all three directions (thus permitting 2D curvilinearity in x-z), rather than attempting some rotation of the model / physics.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1549#issuecomment-814273115
Usability,clear,clearer,"`z_faces` sounds good to me. As a newish user who will be reading examples and trying to figure things out, I think this is clearer than `zF`. Certainly people can learn to use either without much difficulty. Also, I thought that `zF` is mostly used for a face, wheres we want multiple, so plural. I suppose even `zFs` would be better in my mind.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1551#issuecomment-814950782
Availability,redundant,redundant,"I agree that `z_faces` is clearer! I just wanted to be sure we were talking about the same changes. I believe that specifying the grid with `z_faces` does indeed require knowledge of the number of grid points, because the user specification depends on the vertical _index_. The case of a uniform grid illustrates this point: `z_faces = k -> (k - 1) * Lz / (Nz + 1)` for `z = (0, Lz)`. Note that the keyword argument `z` is redundant, since it can be inferred from `z_faces` (by evaluating `z_faces(1)` and `z_faces(Nz+1)`. Thus I am not sure I agree that we should require the `z` keyword argument when `z_faces` is supplied. I think it'd be nice to have both a ""discrete"" interface that uses the `z_faces` or `z_cell_interfaces` keyword argument, as well as a ""continuous"" interface that accepts a ""mapping"" or ""stretching"" function as I described above. With a ""continuous"" interface, the interval kwarg `z` is required because it cannot be inferred from `z_stretching` or `z_map` (whichever we prefer).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1551#issuecomment-815159490
Deployability,continuous,continuous,"I agree that `z_faces` is clearer! I just wanted to be sure we were talking about the same changes. I believe that specifying the grid with `z_faces` does indeed require knowledge of the number of grid points, because the user specification depends on the vertical _index_. The case of a uniform grid illustrates this point: `z_faces = k -> (k - 1) * Lz / (Nz + 1)` for `z = (0, Lz)`. Note that the keyword argument `z` is redundant, since it can be inferred from `z_faces` (by evaluating `z_faces(1)` and `z_faces(Nz+1)`. Thus I am not sure I agree that we should require the `z` keyword argument when `z_faces` is supplied. I think it'd be nice to have both a ""discrete"" interface that uses the `z_faces` or `z_cell_interfaces` keyword argument, as well as a ""continuous"" interface that accepts a ""mapping"" or ""stretching"" function as I described above. With a ""continuous"" interface, the interval kwarg `z` is required because it cannot be inferred from `z_stretching` or `z_map` (whichever we prefer).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1551#issuecomment-815159490
Integrability,depend,depends,"I agree that `z_faces` is clearer! I just wanted to be sure we were talking about the same changes. I believe that specifying the grid with `z_faces` does indeed require knowledge of the number of grid points, because the user specification depends on the vertical _index_. The case of a uniform grid illustrates this point: `z_faces = k -> (k - 1) * Lz / (Nz + 1)` for `z = (0, Lz)`. Note that the keyword argument `z` is redundant, since it can be inferred from `z_faces` (by evaluating `z_faces(1)` and `z_faces(Nz+1)`. Thus I am not sure I agree that we should require the `z` keyword argument when `z_faces` is supplied. I think it'd be nice to have both a ""discrete"" interface that uses the `z_faces` or `z_cell_interfaces` keyword argument, as well as a ""continuous"" interface that accepts a ""mapping"" or ""stretching"" function as I described above. With a ""continuous"" interface, the interval kwarg `z` is required because it cannot be inferred from `z_stretching` or `z_map` (whichever we prefer).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1551#issuecomment-815159490
Safety,redund,redundant,"I agree that `z_faces` is clearer! I just wanted to be sure we were talking about the same changes. I believe that specifying the grid with `z_faces` does indeed require knowledge of the number of grid points, because the user specification depends on the vertical _index_. The case of a uniform grid illustrates this point: `z_faces = k -> (k - 1) * Lz / (Nz + 1)` for `z = (0, Lz)`. Note that the keyword argument `z` is redundant, since it can be inferred from `z_faces` (by evaluating `z_faces(1)` and `z_faces(Nz+1)`. Thus I am not sure I agree that we should require the `z` keyword argument when `z_faces` is supplied. I think it'd be nice to have both a ""discrete"" interface that uses the `z_faces` or `z_cell_interfaces` keyword argument, as well as a ""continuous"" interface that accepts a ""mapping"" or ""stretching"" function as I described above. With a ""continuous"" interface, the interval kwarg `z` is required because it cannot be inferred from `z_stretching` or `z_map` (whichever we prefer).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1551#issuecomment-815159490
Usability,clear,clearer,"I agree that `z_faces` is clearer! I just wanted to be sure we were talking about the same changes. I believe that specifying the grid with `z_faces` does indeed require knowledge of the number of grid points, because the user specification depends on the vertical _index_. The case of a uniform grid illustrates this point: `z_faces = k -> (k - 1) * Lz / (Nz + 1)` for `z = (0, Lz)`. Note that the keyword argument `z` is redundant, since it can be inferred from `z_faces` (by evaluating `z_faces(1)` and `z_faces(Nz+1)`. Thus I am not sure I agree that we should require the `z` keyword argument when `z_faces` is supplied. I think it'd be nice to have both a ""discrete"" interface that uses the `z_faces` or `z_cell_interfaces` keyword argument, as well as a ""continuous"" interface that accepts a ""mapping"" or ""stretching"" function as I described above. With a ""continuous"" interface, the interval kwarg `z` is required because it cannot be inferred from `z_stretching` or `z_map` (whichever we prefer).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1551#issuecomment-815159490
Usability,clear,clearly,"I agree that to define the grid with `z_faces` we need to know the number of grid points, but that can be done internally. I don't believe we need that in the arguments. In the example you showed previously, with a `cheb` grid, you specified it in terms of a function of `z`. I can imagine the user specifying `z=(0, Lz)`, `Nz` and some `f(z)`, and then we compute what the grid is. I guess if `f(z)=z`, then we get a linear or uniform grid. . I imagine some people might prefer to be more hands on and specify it in terms fo indices. Both clearly can work. What your suggesting sounds very general, which is nice, but also a bit complicated. I wonder if we might want to start with something simple, one of the two, and then as we get to use it then decide how we want to change it. I'm perfectly fine with specifying the index form, since that is consistent with what we are currently doing, I think.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1551#issuecomment-815163245
Integrability,interface,interface,"Are you proposing a third interface that takes a 3-argument function of `x, L, N`? I think that's fine as a proposal, I just want to be clear about what is being suggested, exactly. What I didn't understand is how one can specify the cell interface locations (call it the ""`z_faces` interface"" --- the one we currently have) without knowing the number of grid points:. > I agree that to define the grid with z_faces we need to know the number of grid points, but that can be done internally. I agree there are other possible interfaces that _do not_ require passing the number of grid points as a parameter; or rather simplify this process by performing calculations under the hood. It could be nice to design types such as `LinearStretching` or `ChebyshevStretching` that provide users with out-of-the-box stretched grids to be used with interface 2 proposed above (call this the ""coordinate map interface""). We can incorporate dispatch on such types (versus on plain functions) in the grid constructor. An example of this being used is. ```julia; grid = VerticallyStretchedRectilinearGrid(size = (Nx, Ny, Nz), ; x = (0, 2π),; y = (0, 2π),; z = (-1, 1),; z_stretching = ChebyshevStretching()); ```. or, when a parameter is involves such as for hyperbolic stretching, something like. ```julia; grid = VerticallyStretchedRectilinearGrid(size = (Nx, Ny, Nz), ; x = (0, 2π),; y = (0, 2π),; z = (-1, 1),; z_stretching = HyperbolicStretching(stretching_parameter=1.3)); ```. It seems like maybe there is a 3rd option too? It looks somewhat similar to the coordinate map interface, except that the map expects three arguments rather than one, and returns an array rather than a scalar value that represents the map?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1551#issuecomment-815419100
Performance,perform,performing,"Are you proposing a third interface that takes a 3-argument function of `x, L, N`? I think that's fine as a proposal, I just want to be clear about what is being suggested, exactly. What I didn't understand is how one can specify the cell interface locations (call it the ""`z_faces` interface"" --- the one we currently have) without knowing the number of grid points:. > I agree that to define the grid with z_faces we need to know the number of grid points, but that can be done internally. I agree there are other possible interfaces that _do not_ require passing the number of grid points as a parameter; or rather simplify this process by performing calculations under the hood. It could be nice to design types such as `LinearStretching` or `ChebyshevStretching` that provide users with out-of-the-box stretched grids to be used with interface 2 proposed above (call this the ""coordinate map interface""). We can incorporate dispatch on such types (versus on plain functions) in the grid constructor. An example of this being used is. ```julia; grid = VerticallyStretchedRectilinearGrid(size = (Nx, Ny, Nz), ; x = (0, 2π),; y = (0, 2π),; z = (-1, 1),; z_stretching = ChebyshevStretching()); ```. or, when a parameter is involves such as for hyperbolic stretching, something like. ```julia; grid = VerticallyStretchedRectilinearGrid(size = (Nx, Ny, Nz), ; x = (0, 2π),; y = (0, 2π),; z = (-1, 1),; z_stretching = HyperbolicStretching(stretching_parameter=1.3)); ```. It seems like maybe there is a 3rd option too? It looks somewhat similar to the coordinate map interface, except that the map expects three arguments rather than one, and returns an array rather than a scalar value that represents the map?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1551#issuecomment-815419100
Usability,clear,clear,"Are you proposing a third interface that takes a 3-argument function of `x, L, N`? I think that's fine as a proposal, I just want to be clear about what is being suggested, exactly. What I didn't understand is how one can specify the cell interface locations (call it the ""`z_faces` interface"" --- the one we currently have) without knowing the number of grid points:. > I agree that to define the grid with z_faces we need to know the number of grid points, but that can be done internally. I agree there are other possible interfaces that _do not_ require passing the number of grid points as a parameter; or rather simplify this process by performing calculations under the hood. It could be nice to design types such as `LinearStretching` or `ChebyshevStretching` that provide users with out-of-the-box stretched grids to be used with interface 2 proposed above (call this the ""coordinate map interface""). We can incorporate dispatch on such types (versus on plain functions) in the grid constructor. An example of this being used is. ```julia; grid = VerticallyStretchedRectilinearGrid(size = (Nx, Ny, Nz), ; x = (0, 2π),; y = (0, 2π),; z = (-1, 1),; z_stretching = ChebyshevStretching()); ```. or, when a parameter is involves such as for hyperbolic stretching, something like. ```julia; grid = VerticallyStretchedRectilinearGrid(size = (Nx, Ny, Nz), ; x = (0, 2π),; y = (0, 2π),; z = (-1, 1),; z_stretching = HyperbolicStretching(stretching_parameter=1.3)); ```. It seems like maybe there is a 3rd option too? It looks somewhat similar to the coordinate map interface, except that the map expects three arguments rather than one, and returns an array rather than a scalar value that represents the map?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1551#issuecomment-815419100
Integrability,interface,interfaces,"It seems natural to me to have a function of 3 arguments, `x, L, N`, as those are all needed to define the grid. There are other ways of doing it I'm sure, and I am open to other options. I agree with you that given the current setup using `zF`, we do need the number of interfaces. This other option would not as we are passing functions instead. I very much like the examples you set up and think that would be very attractive from the user perspective. . Another option that I think should be included in these functions, like the two you have above, is an argument saying where the center (or something else) is in the stretched grid. It could be the left boundary, right boundary, center or anywhere else. The physics should be the guide on where to concenrate the grid.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1551#issuecomment-815675071
Usability,guid,guide,"It seems natural to me to have a function of 3 arguments, `x, L, N`, as those are all needed to define the grid. There are other ways of doing it I'm sure, and I am open to other options. I agree with you that given the current setup using `zF`, we do need the number of interfaces. This other option would not as we are passing functions instead. I very much like the examples you set up and think that would be very attractive from the user perspective. . Another option that I think should be included in these functions, like the two you have above, is an argument saying where the center (or something else) is in the stretched grid. It could be the left boundary, right boundary, center or anywhere else. The physics should be the guide on where to concenrate the grid.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1551#issuecomment-815675071
Availability,down,downside,"I think the main downside of a separate package is that we have to maintain two CI pipelines, two docs, etc. The advantages are pretty clear though. It could make sense until there's some external interest in using the solvers in a standalone manner. Then we have both motivation and help to take on the work. The code is already modular with few circular dependencies so I don't think splitting up the repo would be difficult from a purely typing standpoint. I think it's fine if the solvers are specific to `Field` and `AbstractGrid`. One could envision an ecosystem of packages for finite volume calculations on staggered grids:. * `StaggeredVolumes.jl` or maybe `StaggeredFields.jl` (`Oceananigans.Grids, Oceananigans.Operators, Oceananigans.Fields, Oceananigans.AbstractOperations`); * `StaggeredEllipticSolvers.jl` (`Oceananigans.Solvers`) Note that these are both Poisson solvers and Helmholtz solvers.; * We may also want to put the `Simulation` infastructure in a standalone package, because this could be used by any model (not just ocean-specific models); * Anything else?. Then `Oceananigans.jl` is mainly just the physics, models, and time-steppers for ocean problems.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1553#issuecomment-815043149
Deployability,pipeline,pipelines,"I think the main downside of a separate package is that we have to maintain two CI pipelines, two docs, etc. The advantages are pretty clear though. It could make sense until there's some external interest in using the solvers in a standalone manner. Then we have both motivation and help to take on the work. The code is already modular with few circular dependencies so I don't think splitting up the repo would be difficult from a purely typing standpoint. I think it's fine if the solvers are specific to `Field` and `AbstractGrid`. One could envision an ecosystem of packages for finite volume calculations on staggered grids:. * `StaggeredVolumes.jl` or maybe `StaggeredFields.jl` (`Oceananigans.Grids, Oceananigans.Operators, Oceananigans.Fields, Oceananigans.AbstractOperations`); * `StaggeredEllipticSolvers.jl` (`Oceananigans.Solvers`) Note that these are both Poisson solvers and Helmholtz solvers.; * We may also want to put the `Simulation` infastructure in a standalone package, because this could be used by any model (not just ocean-specific models); * Anything else?. Then `Oceananigans.jl` is mainly just the physics, models, and time-steppers for ocean problems.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1553#issuecomment-815043149
Integrability,depend,dependencies,"I think the main downside of a separate package is that we have to maintain two CI pipelines, two docs, etc. The advantages are pretty clear though. It could make sense until there's some external interest in using the solvers in a standalone manner. Then we have both motivation and help to take on the work. The code is already modular with few circular dependencies so I don't think splitting up the repo would be difficult from a purely typing standpoint. I think it's fine if the solvers are specific to `Field` and `AbstractGrid`. One could envision an ecosystem of packages for finite volume calculations on staggered grids:. * `StaggeredVolumes.jl` or maybe `StaggeredFields.jl` (`Oceananigans.Grids, Oceananigans.Operators, Oceananigans.Fields, Oceananigans.AbstractOperations`); * `StaggeredEllipticSolvers.jl` (`Oceananigans.Solvers`) Note that these are both Poisson solvers and Helmholtz solvers.; * We may also want to put the `Simulation` infastructure in a standalone package, because this could be used by any model (not just ocean-specific models); * Anything else?. Then `Oceananigans.jl` is mainly just the physics, models, and time-steppers for ocean problems.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1553#issuecomment-815043149
Usability,clear,clear,"I think the main downside of a separate package is that we have to maintain two CI pipelines, two docs, etc. The advantages are pretty clear though. It could make sense until there's some external interest in using the solvers in a standalone manner. Then we have both motivation and help to take on the work. The code is already modular with few circular dependencies so I don't think splitting up the repo would be difficult from a purely typing standpoint. I think it's fine if the solvers are specific to `Field` and `AbstractGrid`. One could envision an ecosystem of packages for finite volume calculations on staggered grids:. * `StaggeredVolumes.jl` or maybe `StaggeredFields.jl` (`Oceananigans.Grids, Oceananigans.Operators, Oceananigans.Fields, Oceananigans.AbstractOperations`); * `StaggeredEllipticSolvers.jl` (`Oceananigans.Solvers`) Note that these are both Poisson solvers and Helmholtz solvers.; * We may also want to put the `Simulation` infastructure in a standalone package, because this could be used by any model (not just ocean-specific models); * Anything else?. Then `Oceananigans.jl` is mainly just the physics, models, and time-steppers for ocean problems.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1553#issuecomment-815043149
Availability,error,error,"Thansk for the quick feedback. 1. I should say this is not as much of a concern as I found a work around. In my definition of b\tilde, I changed `f` to `model.coriolis.f` and received an error. Below is the beginning and it's huge so can't copy the whole thing. I will stick to my simple solution for the moment but want to point this out, in case there was a concern. ```; include(""inertially_unstable_jet.jl""); ERROR: LoadError: InvalidIRError: compiling kernel gpu__compute!(Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(1, 64, 64)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(1, 1, 64)},KernelAbstractions.NDIteration.StaticSize{(1, 64, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks}, typeof(Oceananigans.Fields.gpu__compute!), OffsetArrays.OffsetArray{Float64,3,CuDeviceArray{Float64,3,1}}, Oceananigans.AbstractOperations.BinaryOperation{Center,Center,Center,typeof(-),OffsetArrays.OffsetArray{Float64,3,CuDeviceArray{Float64,3,1}},Oceananigans.Fields.FunctionField{Center,Center,Center,Nothing,Nothing,typeof(b̄),RegularRectilinearGrid{Float64,Flat,Bounded,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}},typeof(identity),typeof(identity),typeof(identity),RegularRectilinearGrid{Float64,Flat,Bounded,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}}) resulted in invalid LLVM IR; Reason: unsupported dynamic function invocation (call to overdub); Stacktrace:; [1] b̄ at /home/fpoulin/software/Oceananigans.jl/examples/inertially_unstable_jet.jl:39; [2] call_func at /home/fpoulin/software/Oceananigans.jl/src/Fields/function_field.jl:61; [3] getindex at /home/fpoulin/software/Oceananigans.jl/src/Fields/function_field.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1554#issuecomment-815099807
Performance,optimiz,optimize,"orted dynamic function invocation (call to getproperty); Stacktrace:; [1] call at /home/fpoulin/.julia/packages/Cassette/Wjztv/src/context.jl:456; [2] fallback at /home/fpoulin/.julia/packages/Cassette/Wjztv/src/context.jl:454; [3] overdub at /home/fpoulin/.julia/packages/Cassette/Wjztv/src/context.jl:279; [4] b̄ at /home/fpoulin/software/Oceananigans.jl/examples/inertially_unstable_jet.jl:39; [5] call_func at /home/fpoulin/software/Oceananigans.jl/src/Fields/function_field.jl:61; [6] getindex at /home/fpoulin/software/Oceananigans.jl/src/Fields/function_field.jl:63; [7] identity at /home/fpoulin/software/Oceananigans.jl/src/Operators/interpolation_utils.jl:6; [8] - at /home/fpoulin/software/Oceananigans.jl/src/AbstractOperations/binary_operations.jl:59; [9] identity at /home/fpoulin/software/Oceananigans.jl/src/Operators/interpolation_utils.jl:11; [10] getindex at /home/fpoulin/software/Oceananigans.jl/src/AbstractOperations/binary_operations.jl:34; [11] macro expansion at /home/fpoulin/software/Oceananigans.jl/src/Fields/computed_field.jl:114; [12] gpu__compute! at /home/fpoulin/.julia/packages/KernelAbstractions/mKsXc/src/macros.jl:80; [13] overdub at /home/fpoulin/.julia/packages/Cassette/Wjztv/src/overdub.jl:0; Stacktrace:; [1] check_ir(::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget,CUDA.CUDACompilerParams}, ::LLVM.Module) at /home/fpoulin/.julia/packages/GPUCompiler/uTpNx/src/validation.jl:123; [2] macro expansion at /home/fpoulin/.julia/packages/GPUCompiler/uTpNx/src/driver.jl:239 [inlined]; [3] macro expansion at /home/fpoulin/.julia/packages/TimerOutputs/4QAIk/src/TimerOutput.jl:206 [inlined]; [4] codegen(::Symbol, ::GPUCompiler.CompilerJob; libraries::Bool, deferred_codegen::Bool, optimize::Bool, strip::Bool, validate::Bool, only_entry::Bool) at /home/fpoulin/.julia/packages/GPUCompiler/uTpNx/src/driver.jl:237; [5] compile(::Symbol, ::GPUCompiler.CompilerJob; libraries::Bool, deferred_codegen::Bool, optimize::Bool, strip::Bool, validate:; ...; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1554#issuecomment-815099807
Security,validat,validation,"orted dynamic function invocation (call to getproperty); Stacktrace:; [1] call at /home/fpoulin/.julia/packages/Cassette/Wjztv/src/context.jl:456; [2] fallback at /home/fpoulin/.julia/packages/Cassette/Wjztv/src/context.jl:454; [3] overdub at /home/fpoulin/.julia/packages/Cassette/Wjztv/src/context.jl:279; [4] b̄ at /home/fpoulin/software/Oceananigans.jl/examples/inertially_unstable_jet.jl:39; [5] call_func at /home/fpoulin/software/Oceananigans.jl/src/Fields/function_field.jl:61; [6] getindex at /home/fpoulin/software/Oceananigans.jl/src/Fields/function_field.jl:63; [7] identity at /home/fpoulin/software/Oceananigans.jl/src/Operators/interpolation_utils.jl:6; [8] - at /home/fpoulin/software/Oceananigans.jl/src/AbstractOperations/binary_operations.jl:59; [9] identity at /home/fpoulin/software/Oceananigans.jl/src/Operators/interpolation_utils.jl:11; [10] getindex at /home/fpoulin/software/Oceananigans.jl/src/AbstractOperations/binary_operations.jl:34; [11] macro expansion at /home/fpoulin/software/Oceananigans.jl/src/Fields/computed_field.jl:114; [12] gpu__compute! at /home/fpoulin/.julia/packages/KernelAbstractions/mKsXc/src/macros.jl:80; [13] overdub at /home/fpoulin/.julia/packages/Cassette/Wjztv/src/overdub.jl:0; Stacktrace:; [1] check_ir(::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget,CUDA.CUDACompilerParams}, ::LLVM.Module) at /home/fpoulin/.julia/packages/GPUCompiler/uTpNx/src/validation.jl:123; [2] macro expansion at /home/fpoulin/.julia/packages/GPUCompiler/uTpNx/src/driver.jl:239 [inlined]; [3] macro expansion at /home/fpoulin/.julia/packages/TimerOutputs/4QAIk/src/TimerOutput.jl:206 [inlined]; [4] codegen(::Symbol, ::GPUCompiler.CompilerJob; libraries::Bool, deferred_codegen::Bool, optimize::Bool, strip::Bool, validate::Bool, only_entry::Bool) at /home/fpoulin/.julia/packages/GPUCompiler/uTpNx/src/driver.jl:237; [5] compile(::Symbol, ::GPUCompiler.CompilerJob; libraries::Bool, deferred_codegen::Bool, optimize::Bool, strip::Bool, validate:; ...; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1554#issuecomment-815099807
Usability,feedback,feedback,"Thansk for the quick feedback. 1. I should say this is not as much of a concern as I found a work around. In my definition of b\tilde, I changed `f` to `model.coriolis.f` and received an error. Below is the beginning and it's huge so can't copy the whole thing. I will stick to my simple solution for the moment but want to point this out, in case there was a concern. ```; include(""inertially_unstable_jet.jl""); ERROR: LoadError: InvalidIRError: compiling kernel gpu__compute!(Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(1, 64, 64)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(1, 1, 64)},KernelAbstractions.NDIteration.StaticSize{(1, 64, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks}, typeof(Oceananigans.Fields.gpu__compute!), OffsetArrays.OffsetArray{Float64,3,CuDeviceArray{Float64,3,1}}, Oceananigans.AbstractOperations.BinaryOperation{Center,Center,Center,typeof(-),OffsetArrays.OffsetArray{Float64,3,CuDeviceArray{Float64,3,1}},Oceananigans.Fields.FunctionField{Center,Center,Center,Nothing,Nothing,typeof(b̄),RegularRectilinearGrid{Float64,Flat,Bounded,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}},typeof(identity),typeof(identity),typeof(identity),RegularRectilinearGrid{Float64,Flat,Bounded,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}}) resulted in invalid LLVM IR; Reason: unsupported dynamic function invocation (call to overdub); Stacktrace:; [1] b̄ at /home/fpoulin/software/Oceananigans.jl/examples/inertially_unstable_jet.jl:39; [2] call_func at /home/fpoulin/software/Oceananigans.jl/src/Fields/function_field.jl:61; [3] getindex at /home/fpoulin/software/Oceananigans.jl/src/Fields/function_field.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1554#issuecomment-815099807
Availability,toler,tolerance,"Very good point. The background buoyancy does not satisfy the boundary conditions that are imposed. I will check it out later. If this is the case, then it is still mysterious why GPUs have a harder time with this than CPUs, but we will see and learn. Thanks for the suggestion. Francis; ________________________________; From: Gregory L. Wagner ***@***.***>; Sent: Wednesday, April 7, 2021 5:44:23 PM; To: CliMA/Oceananigans.jl ***@***.***>; Cc: Francis Poulin ***@***.***>; Mention ***@***.***>; Subject: Re: [CliMA/Oceananigans.jl] strange results on gpus (#1554). The second time-step is when QuasiAdamsBashforth2 uses tendency information saved from the previous time-step. On the first time-step it's equivalent to a forward Euler scheme. I know the differences are small, 8th decimal place or so, but on such a coarse grid should we be expecting the same answers?. Hardware differences can produce results that differ by something like sqrt(eps(Float64)) I think. This is the tolerance we use for regression tests (but even those sometimes fail to pass on the GPU for some reason). Since the background buoyancy field has a linear gradient and your domain is bounded, can you try running the same simulation but explicitly resolving the background buoyancy field? (This could suggest that the issue has to do with BackgroundField...). -; You are receiving this because you were mentioned.; Reply to this email directly, view it on GitHub<https://github.com/CliMA/Oceananigans.jl/issues/1554#issuecomment-815284094>, or unsubscribe<https://github.com/notifications/unsubscribe-auth/AB63PQICFGOXKMU4HFN3NOLTHTG3PANCNFSM42RDHB2Q>.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1554#issuecomment-815341207
Testability,test,tests,"Very good point. The background buoyancy does not satisfy the boundary conditions that are imposed. I will check it out later. If this is the case, then it is still mysterious why GPUs have a harder time with this than CPUs, but we will see and learn. Thanks for the suggestion. Francis; ________________________________; From: Gregory L. Wagner ***@***.***>; Sent: Wednesday, April 7, 2021 5:44:23 PM; To: CliMA/Oceananigans.jl ***@***.***>; Cc: Francis Poulin ***@***.***>; Mention ***@***.***>; Subject: Re: [CliMA/Oceananigans.jl] strange results on gpus (#1554). The second time-step is when QuasiAdamsBashforth2 uses tendency information saved from the previous time-step. On the first time-step it's equivalent to a forward Euler scheme. I know the differences are small, 8th decimal place or so, but on such a coarse grid should we be expecting the same answers?. Hardware differences can produce results that differ by something like sqrt(eps(Float64)) I think. This is the tolerance we use for regression tests (but even those sometimes fail to pass on the GPU for some reason). Since the background buoyancy field has a linear gradient and your domain is bounded, can you try running the same simulation but explicitly resolving the background buoyancy field? (This could suggest that the issue has to do with BackgroundField...). -; You are receiving this because you were mentioned.; Reply to this email directly, view it on GitHub<https://github.com/CliMA/Oceananigans.jl/issues/1554#issuecomment-815284094>, or unsubscribe<https://github.com/notifications/unsubscribe-auth/AB63PQICFGOXKMU4HFN3NOLTHTG3PANCNFSM42RDHB2Q>.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1554#issuecomment-815341207
Usability,learn,learn,"Very good point. The background buoyancy does not satisfy the boundary conditions that are imposed. I will check it out later. If this is the case, then it is still mysterious why GPUs have a harder time with this than CPUs, but we will see and learn. Thanks for the suggestion. Francis; ________________________________; From: Gregory L. Wagner ***@***.***>; Sent: Wednesday, April 7, 2021 5:44:23 PM; To: CliMA/Oceananigans.jl ***@***.***>; Cc: Francis Poulin ***@***.***>; Mention ***@***.***>; Subject: Re: [CliMA/Oceananigans.jl] strange results on gpus (#1554). The second time-step is when QuasiAdamsBashforth2 uses tendency information saved from the previous time-step. On the first time-step it's equivalent to a forward Euler scheme. I know the differences are small, 8th decimal place or so, but on such a coarse grid should we be expecting the same answers?. Hardware differences can produce results that differ by something like sqrt(eps(Float64)) I think. This is the tolerance we use for regression tests (but even those sometimes fail to pass on the GPU for some reason). Since the background buoyancy field has a linear gradient and your domain is bounded, can you try running the same simulation but explicitly resolving the background buoyancy field? (This could suggest that the issue has to do with BackgroundField...). -; You are receiving this because you were mentioned.; Reply to this email directly, view it on GitHub<https://github.com/CliMA/Oceananigans.jl/issues/1554#issuecomment-815284094>, or unsubscribe<https://github.com/notifications/unsubscribe-auth/AB63PQICFGOXKMU4HFN3NOLTHTG3PANCNFSM42RDHB2Q>.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1554#issuecomment-815341207
Availability,toler,tolerance,"do with the pressure solve. Could someone point me to an example that does this?; ________________________________; From: Francis Poulin ***@***.***>; Sent: Wednesday, April 7, 2021 7:43:11 PM; To: CliMA/Oceananigans.jl ***@***.***>; CliMA/Oceananigans.jl ***@***.***>; Cc: Mention ***@***.***>; Subject: Re: [CliMA/Oceananigans.jl] strange results on gpus (#1554). Very good point. The background buoyancy does not satisfy the boundary conditions that are imposed. I will check it out later. If this is the case, then it is still mysterious why GPUs have a harder time with this than CPUs, but we will see and learn. Thanks for the suggestion. Francis; ________________________________; From: Gregory L. Wagner ***@***.***>; Sent: Wednesday, April 7, 2021 5:44:23 PM; To: CliMA/Oceananigans.jl ***@***.***>; Cc: Francis Poulin ***@***.***>; Mention ***@***.***>; Subject: Re: [CliMA/Oceananigans.jl] strange results on gpus (#1554). The second time-step is when QuasiAdamsBashforth2 uses tendency information saved from the previous time-step. On the first time-step it's equivalent to a forward Euler scheme. I know the differences are small, 8th decimal place or so, but on such a coarse grid should we be expecting the same answers?. Hardware differences can produce results that differ by something like sqrt(eps(Float64)) I think. This is the tolerance we use for regression tests (but even those sometimes fail to pass on the GPU for some reason). Since the background buoyancy field has a linear gradient and your domain is bounded, can you try running the same simulation but explicitly resolving the background buoyancy field? (This could suggest that the issue has to do with BackgroundField...). -; You are receiving this because you were mentioned.; Reply to this email directly, view it on GitHub<https://github.com/CliMA/Oceananigans.jl/issues/1554#issuecomment-815284094>, or unsubscribe<https://github.com/notifications/unsubscribe-auth/AB63PQICFGOXKMU4HFN3NOLTHTG3PANCNFSM42RDHB2Q>.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1554#issuecomment-815368840
Modifiability,evolve,evolve,"I thought I would also try freezing the velocity field, if possible. If this still weirdness at the boundary still happens when the velocity doesn't evolve, then it has nothing to do with the pressure solve. Could someone point me to an example that does this?; ________________________________; From: Francis Poulin ***@***.***>; Sent: Wednesday, April 7, 2021 7:43:11 PM; To: CliMA/Oceananigans.jl ***@***.***>; CliMA/Oceananigans.jl ***@***.***>; Cc: Mention ***@***.***>; Subject: Re: [CliMA/Oceananigans.jl] strange results on gpus (#1554). Very good point. The background buoyancy does not satisfy the boundary conditions that are imposed. I will check it out later. If this is the case, then it is still mysterious why GPUs have a harder time with this than CPUs, but we will see and learn. Thanks for the suggestion. Francis; ________________________________; From: Gregory L. Wagner ***@***.***>; Sent: Wednesday, April 7, 2021 5:44:23 PM; To: CliMA/Oceananigans.jl ***@***.***>; Cc: Francis Poulin ***@***.***>; Mention ***@***.***>; Subject: Re: [CliMA/Oceananigans.jl] strange results on gpus (#1554). The second time-step is when QuasiAdamsBashforth2 uses tendency information saved from the previous time-step. On the first time-step it's equivalent to a forward Euler scheme. I know the differences are small, 8th decimal place or so, but on such a coarse grid should we be expecting the same answers?. Hardware differences can produce results that differ by something like sqrt(eps(Float64)) I think. This is the tolerance we use for regression tests (but even those sometimes fail to pass on the GPU for some reason). Since the background buoyancy field has a linear gradient and your domain is bounded, can you try running the same simulation but explicitly resolving the background buoyancy field? (This could suggest that the issue has to do with BackgroundField...). -; You are receiving this because you were mentioned.; Reply to this email directly, view it on GitHub<https://gi",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1554#issuecomment-815368840
Testability,test,tests,"do with the pressure solve. Could someone point me to an example that does this?; ________________________________; From: Francis Poulin ***@***.***>; Sent: Wednesday, April 7, 2021 7:43:11 PM; To: CliMA/Oceananigans.jl ***@***.***>; CliMA/Oceananigans.jl ***@***.***>; Cc: Mention ***@***.***>; Subject: Re: [CliMA/Oceananigans.jl] strange results on gpus (#1554). Very good point. The background buoyancy does not satisfy the boundary conditions that are imposed. I will check it out later. If this is the case, then it is still mysterious why GPUs have a harder time with this than CPUs, but we will see and learn. Thanks for the suggestion. Francis; ________________________________; From: Gregory L. Wagner ***@***.***>; Sent: Wednesday, April 7, 2021 5:44:23 PM; To: CliMA/Oceananigans.jl ***@***.***>; Cc: Francis Poulin ***@***.***>; Mention ***@***.***>; Subject: Re: [CliMA/Oceananigans.jl] strange results on gpus (#1554). The second time-step is when QuasiAdamsBashforth2 uses tendency information saved from the previous time-step. On the first time-step it's equivalent to a forward Euler scheme. I know the differences are small, 8th decimal place or so, but on such a coarse grid should we be expecting the same answers?. Hardware differences can produce results that differ by something like sqrt(eps(Float64)) I think. This is the tolerance we use for regression tests (but even those sometimes fail to pass on the GPU for some reason). Since the background buoyancy field has a linear gradient and your domain is bounded, can you try running the same simulation but explicitly resolving the background buoyancy field? (This could suggest that the issue has to do with BackgroundField...). -; You are receiving this because you were mentioned.; Reply to this email directly, view it on GitHub<https://github.com/CliMA/Oceananigans.jl/issues/1554#issuecomment-815284094>, or unsubscribe<https://github.com/notifications/unsubscribe-auth/AB63PQICFGOXKMU4HFN3NOLTHTG3PANCNFSM42RDHB2Q>.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1554#issuecomment-815368840
Usability,learn,learn,"I thought I would also try freezing the velocity field, if possible. If this still weirdness at the boundary still happens when the velocity doesn't evolve, then it has nothing to do with the pressure solve. Could someone point me to an example that does this?; ________________________________; From: Francis Poulin ***@***.***>; Sent: Wednesday, April 7, 2021 7:43:11 PM; To: CliMA/Oceananigans.jl ***@***.***>; CliMA/Oceananigans.jl ***@***.***>; Cc: Mention ***@***.***>; Subject: Re: [CliMA/Oceananigans.jl] strange results on gpus (#1554). Very good point. The background buoyancy does not satisfy the boundary conditions that are imposed. I will check it out later. If this is the case, then it is still mysterious why GPUs have a harder time with this than CPUs, but we will see and learn. Thanks for the suggestion. Francis; ________________________________; From: Gregory L. Wagner ***@***.***>; Sent: Wednesday, April 7, 2021 5:44:23 PM; To: CliMA/Oceananigans.jl ***@***.***>; Cc: Francis Poulin ***@***.***>; Mention ***@***.***>; Subject: Re: [CliMA/Oceananigans.jl] strange results on gpus (#1554). The second time-step is when QuasiAdamsBashforth2 uses tendency information saved from the previous time-step. On the first time-step it's equivalent to a forward Euler scheme. I know the differences are small, 8th decimal place or so, but on such a coarse grid should we be expecting the same answers?. Hardware differences can produce results that differ by something like sqrt(eps(Float64)) I think. This is the tolerance we use for regression tests (but even those sometimes fail to pass on the GPU for some reason). Since the background buoyancy field has a linear gradient and your domain is bounded, can you try running the same simulation but explicitly resolving the background buoyancy field? (This could suggest that the issue has to do with BackgroundField...). -; You are receiving this because you were mentioned.; Reply to this email directly, view it on GitHub<https://gi",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1554#issuecomment-815368840
Usability,simpl,simple,"I am happy to report that following @glwagner 's suggestion, I set the buoyancy frequency to zero and that seemed to solve the problem. Nothing formed at the boundary and therefore no numerical instability. This is good evidence to suggest that it's because the background state is not being consistent with the top and bottom boundary conditions, which require a Neuman (Derivative) boundary condtiion. A big step forward! . A few questions come to mind. - Where is it exactly that GPUs have difficulties dealing with this?; - Why can CPUs do this without any problem? Or maybe where is the difference between the two methods? . A simple solution to my problem is to change the boundary conditions to be consistent with the background state and that should fix things up nicely, i.e. set a non-zero Neumann (Derivative) Boundary Condition at the top and bottom. . I will give that a try tomorrow, but I am still interested in the differences between what the CPU and GPU are doing.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1554#issuecomment-815382772
Availability,error,error,"Ah, thanks for clarifying as clearly I was mistaken. I thought I needed to impose the boundary conditions on the total field, background + deviation. If that's not the case then the boundary conditions are set up correctly. I believe the next thing to try is the same set up but without `BackgroundField` and imposing the Neumann boundary conditions associated with the buoyancy frequency. If that behaves correctly, then the problem would appear to be in `BackgroundField`, as you suspect. . **Update:** ; I made the following changes,. - Removed the background field from model,; - Added `N^2 * (z + D)` into the initial conditiosn of the buoyancy,; - Imposed `buoyancy_gradient_bc` at the top and bottom of the domain. Unfortunately, the same problems occur at the boundary. . This does not seem to be imposing the correct boundary conditions on a tracer field at the top and bottom. **Periodic condition:**; I did try setting the vertical direction to periodic and unfortunately that gave an error, copied below. . Is this a seperate problem or do people think it's related?. ```; ERROR: LoadError: ArgumentError: batching dims must be sequential; Stacktrace:; [1] create_plan(::CUDA.CUFFT.cufftType_t, ::Tuple{Int64,Int64,Int64}, ::Array{Int64,1}) at /home/fpoulin/.julia/packages/CUDA/wTQsK/lib/cufft/fft.jl:140; [2] plan_fft! at /home/fpoulin/.julia/packages/CUDA/wTQsK/lib/cufft/fft.jl:256 [inlined]; [3] plan_forward_transform at /home/fpoulin/software/Oceananigans.jl/src/Solvers/plan_transforms.jl:42 [inlined]; [4] plan_transforms(::GPU, ::RegularRectilinearGrid{Float64,Flat,Bounded,Periodic,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}, ::CUDA.CuArray{Complex{Float64},3}, ::UInt32) at /home/fpoulin/software/Oceananigans.jl/src/Solvers/plan_transforms.jl:106; [5] Oceananigans.Solvers.FFTBasedPoissonSolver(::GPU, ::RegularRectilinearGrid{Float64,Flat,Bounded,Periodic,OffsetArrays.OffsetArray{Float64,1,StepRangeL",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1554#issuecomment-815670594
Usability,clear,clearly,"Ah, thanks for clarifying as clearly I was mistaken. I thought I needed to impose the boundary conditions on the total field, background + deviation. If that's not the case then the boundary conditions are set up correctly. I believe the next thing to try is the same set up but without `BackgroundField` and imposing the Neumann boundary conditions associated with the buoyancy frequency. If that behaves correctly, then the problem would appear to be in `BackgroundField`, as you suspect. . **Update:** ; I made the following changes,. - Removed the background field from model,; - Added `N^2 * (z + D)` into the initial conditiosn of the buoyancy,; - Imposed `buoyancy_gradient_bc` at the top and bottom of the domain. Unfortunately, the same problems occur at the boundary. . This does not seem to be imposing the correct boundary conditions on a tracer field at the top and bottom. **Periodic condition:**; I did try setting the vertical direction to periodic and unfortunately that gave an error, copied below. . Is this a seperate problem or do people think it's related?. ```; ERROR: LoadError: ArgumentError: batching dims must be sequential; Stacktrace:; [1] create_plan(::CUDA.CUFFT.cufftType_t, ::Tuple{Int64,Int64,Int64}, ::Array{Int64,1}) at /home/fpoulin/.julia/packages/CUDA/wTQsK/lib/cufft/fft.jl:140; [2] plan_fft! at /home/fpoulin/.julia/packages/CUDA/wTQsK/lib/cufft/fft.jl:256 [inlined]; [3] plan_forward_transform at /home/fpoulin/software/Oceananigans.jl/src/Solvers/plan_transforms.jl:42 [inlined]; [4] plan_transforms(::GPU, ::RegularRectilinearGrid{Float64,Flat,Bounded,Periodic,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}, ::CUDA.CuArray{Complex{Float64},3}, ::UInt32) at /home/fpoulin/software/Oceananigans.jl/src/Solvers/plan_transforms.jl:106; [5] Oceananigans.Solvers.FFTBasedPoissonSolver(::GPU, ::RegularRectilinearGrid{Float64,Flat,Bounded,Periodic,OffsetArrays.OffsetArray{Float64,1,StepRangeL",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1554#issuecomment-815670594
Testability,test,tests,"Yeah, I've been noticing that a lot of simple PRs have been having failing tests lately. I haven't had time to investigate but I do find it kinda odd...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1558#issuecomment-815947872
Usability,simpl,simple,"Yeah, I've been noticing that a lot of simple PRs have been having failing tests lately. I haven't had time to investigate but I do find it kinda odd...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1558#issuecomment-815947872
Testability,test,test,Thanks @glwagner for clarifying and I see the point. Thanks also in advance for fixing it up. . I encountered the same problem when I wanted to test `Flat` and in the end separted out the different dimensinal cases. Not ideal but it worked for my simple purposes. Will be nice to have something more elegant in the tests.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1560#issuecomment-820403743
Usability,simpl,simple,Thanks @glwagner for clarifying and I see the point. Thanks also in advance for fixing it up. . I encountered the same problem when I wanted to test `Flat` and in the end separted out the different dimensinal cases. Not ideal but it worked for my simple purposes. Will be nice to have something more elegant in the tests.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1560#issuecomment-820403743
Usability,simpl,simply,I'm simply confused with the whole shenanigans of this issue. I need a fresh start perhaps :),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1561#issuecomment-817043969
Deployability,update,updated,"Thanks for the feedback @glwagner and @tomchor . I will respond soon but I have an updated I wanted to share. I did a simulation in each for 100 time steps a few times each. I found sometimes the second simulation was way faster than the first. For different advection schemes I found, to my surprise, they do scale differently. ```; scheme ratio; ====== ===; C2 1.7; U3 2.4; C4 3; U5 2.4; W5 3.4; ```. I would not call these offical benchmarks but more back of the envelop calculations (between friends). But these numbers are, mostly, around 3, which is what I expected. . For fun, I will do the same thing with GPUs (and will find out if my new code runs on a GPU). I guess one mystery is why is it that my actual simulation ran so slowly? I will try it again for 2 hours instead of 2 days and see how the scalings look.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1564#issuecomment-816767845
Testability,benchmark,benchmarks,"Thanks for the feedback @glwagner and @tomchor . I will respond soon but I have an updated I wanted to share. I did a simulation in each for 100 time steps a few times each. I found sometimes the second simulation was way faster than the first. For different advection schemes I found, to my surprise, they do scale differently. ```; scheme ratio; ====== ===; C2 1.7; U3 2.4; C4 3; U5 2.4; W5 3.4; ```. I would not call these offical benchmarks but more back of the envelop calculations (between friends). But these numbers are, mostly, around 3, which is what I expected. . For fun, I will do the same thing with GPUs (and will find out if my new code runs on a GPU). I guess one mystery is why is it that my actual simulation ran so slowly? I will try it again for 2 hours instead of 2 days and see how the scalings look.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1564#issuecomment-816767845
Usability,feedback,feedback,"Thanks for the feedback @glwagner and @tomchor . I will respond soon but I have an updated I wanted to share. I did a simulation in each for 100 time steps a few times each. I found sometimes the second simulation was way faster than the first. For different advection schemes I found, to my surprise, they do scale differently. ```; scheme ratio; ====== ===; C2 1.7; U3 2.4; C4 3; U5 2.4; W5 3.4; ```. I would not call these offical benchmarks but more back of the envelop calculations (between friends). But these numbers are, mostly, around 3, which is what I expected. . For fun, I will do the same thing with GPUs (and will find out if my new code runs on a GPU). I guess one mystery is why is it that my actual simulation ran so slowly? I will try it again for 2 hours instead of 2 days and see how the scalings look.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1564#issuecomment-816767845
Usability,simpl,simply,"I see that you have very strong gravity, `g = 100 m/s^2`, to make things as barotropic as possible I presume. Without advection there seems to be a lot of giggling around. With advection there still seems to be something odd happening at the equator. . If you were to take `IncompressibleModel` and run it with one vertical grid point, that is essentially a barotropic model. If you initialize it with a planar Rossby Haurwitz wave, then it simply propagates westward. This might be worth setting up just to see what happens in the planar case. Just a thought.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1570#issuecomment-818746820
Security,validat,validation,"I believe this smells like validation rather than an example. Examples are nice if they are simple yet interesting. This is complicated, but boring (but super useful for validation, obviously!)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1570#issuecomment-820025945
Usability,simpl,simple,"I believe this smells like validation rather than an example. Examples are nice if they are simple yet interesting. This is complicated, but boring (but super useful for validation, obviously!)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1570#issuecomment-820025945
Usability,guid,guiding,"I think you've started in the right place by looking at the examples. I suggest reading a few more examples! The ""Model setup"" section in the documentation should also be useful. If you can describe your problem in more detail then we may be in a better position to help. Here's some guiding questions:. * What is the physical situation you are trying to model? Can you describe the geometry of your problem and its motivation?; * What is the dimensionality of your problem? Most fluids problems of interest are either two- or three-dimensional. You have implied that your problem is two-dimensional but did not state this explicitly.; * What boundary conditions would you like to impose? You have stated that you want to generate inlet and outlet boundary conditions. But the domain you mentioned is periodic in x and bounded in z. Would you like to impose an inlet and outlet flow in the z direction (thus you would impose inflow and outflow conditions on the vertical velocity)? Note, it may be challenging to impose outlet boundary conditions, but we are happy to help if this is what you want to do.; * Does your problem involve tracer fields? Would you like to simulate the trajectory of particles advected in your flow as well?. The term ""laminar flow"" is not specific --- it's possible to have laminar flows in both two and three dimensions, and in bounded or periodic domains and with a variety of boundary conditions. I'm not sure what you mean by ""single particle"". We have some functionality for modeling what we call ""Lagrangian particles"", which are like grains of sand that are advected by the flow. We can explain how to model a single Lagrangian particle, if that is indeed what you are trying to do.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1572#issuecomment-818273534
Usability,guid,guiding,"Thank you for your response and for providing the guiding questions. I summarized the motivation and context of the project below. > If you can describe your problem in more detail then we may be in a better position to help. Here's some guiding questions:; > What is the physical situation you are trying to model? Can you describe the geometry of your problem and its motivation? . It is a thesis project about the dispersal and migration of fish larvae in the sea. Juveniles from a coral reef fish population can return to their natal reef after being dispersed into the open ocean by the currents. Fish larvae, in particular, have the ability to swim directionally and increasingly fast during ontogeny, indicating that they may not only disperse, but also migrate to their natal reef using environmental signals. How and when larvae use local and large-scale cues remains a mystery. To bring light into this we want to build a simulation where we simulate the ocean including some Lagrangian particles in it(which simulate the larvae). Then we will try out several possible factors, which might help the larvae to find their natal reefs after being dispersed.; For this we picked Oceananigans as a tool. We want to use it to build a module where you can activate several simulated factors like odor(through a continuity equation), swarm behaviour or navigation. Ideally this would be another great example for Oceananigans as a whole.; Our plan is to use the laminar flow with single particle – case as a starting point to build the other cases (more particles, turbulent flow, etc.) on. > What is the dimensionality of your problem? Most fluids problems of interest are either two- or three-dimensional. You have implied that your problem is two-dimensional but did not state this explicitly. We plan to do this two-dimensionaly at first since it is „just“ a bachelor’s thesis. > What boundary conditions would you like to impose? You have stated that you want to generate inlet and outlet bound",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1572#issuecomment-819080471
Usability,simpl,simpler,"existing simulation will hopefully be straightforward. In Oceananigans, `Periodic`, `Bounded`, and `Flat` do not refer to boundary conditions, but to the ""topology"" of a domain. Envision a two-dimensional domain as a piece of paper. If the domain is `Bounded` in both direction, then by default no fluid can enter or leave the paper (in addition to other conditions imposed on the physics). If the domain is `Periodic` in one direction, then its as if the paper is curled into a cylinder: fluid leaving the right side of the domain reappears on the left side. This is what it means for a domain to be `Periodic`. When a direction has a `Periodic` topology, we impose ""periodic boundary conditions"" (though a better way to think about this scenario is that there is no boundary at all!) Periodic topologies are convenient for all sorts of problems, which is why you see them cropping up in the examples frequently. If you can use a domain that is periodic in the ""streamwise"" direction (the direction oriented with the primary direction of your flow), you may make your life a bit simpler. A `Flat` topology is the Oceananigans way of saying that your problem does not vary in that direction. If one direction is `Flat`, then your problem is two-dimensional. So you don't impose boundary conditions in `Flat` directions either. When a direction is `Bounded`, you may impose `Value`, `Gradient`, and `Flux` boundary conditions on tracers and the components of the velocity field that are _tangential_ to the boundary. (Note that the velocity component _normal_ to the boundary is special. It is trickier to set boundary conditions on this component, and I don't think you will need to do this for your project.) If your domain is periodic in x and bounded in z, then you only need to worry about imposing boundary conditions at the top and bottom on tracers, `u`, and `v`. I am happy to help more if you like. You can also try to _force_ your flow to drive motion, rather than by imposing boundary condi",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1572#issuecomment-819091284
Usability,simpl,simple,"Since there are only three cases it's probably simple to have `Connected`, `LeftConnected` and `RightConnected`. But another possibility is something like. ```julia; struct Connected{Side} end; ```. so theres `Connected{Left}`, `Connected{Both}`, `Connected{Right}` (or something)...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1582#issuecomment-819600334
Integrability,wrap,wrap,"> I don't think it matters that the full cubed sphere is Periodic. I think the topology is somewhat undefined especially since the i or ""x""-direction doesn't point in any particular dimension. Right, I guess I am thinking of a domain consisting of two connected grids in which the whole domain is bounded. It seems that if `Connected` behaved exactly as `Periodic` then we would have no need for a new type. (I think you understand this and imply it in your text, but I just want to be clear that the only reason `const Connected = Periodic` works is because we are considering a case in which the grids ""wrap around"", and thus having every grid behave like `Periodic` is valid).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1582#issuecomment-820016371
Usability,clear,clear,"> I don't think it matters that the full cubed sphere is Periodic. I think the topology is somewhat undefined especially since the i or ""x""-direction doesn't point in any particular dimension. Right, I guess I am thinking of a domain consisting of two connected grids in which the whole domain is bounded. It seems that if `Connected` behaved exactly as `Periodic` then we would have no need for a new type. (I think you understand this and imply it in your text, but I just want to be clear that the only reason `const Connected = Periodic` works is because we are considering a case in which the grids ""wrap around"", and thus having every grid behave like `Periodic` is valid).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1582#issuecomment-820016371
Energy Efficiency,reduce,reduced,"thub.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-738870593. There may be other problems that we haven't uncovered. An important additional case that doesn't work right now is operations that have embedded `AveragedField`. I think this is some kind of type inference issue. For `Field` on the GPU we ""throw away"" the wrapper and expose the underlying `OffsetArray` to GPU kernels. So compilation of functions of `Field` is ""no more difficult"" than compilation of functions with `OffsetArray`. This idealization is successful because indexing into the underlying `field.data` is identical indexing into the field itself, and because we don't require field locations _inside_ the kernel (we build expression trees for AbstractOperations on the CPU, prior to launching the kernel). But this idealization doesn't hold for `AveragedField` or any `ReducedField`. In particular, abstract operations index into these objects at all `i, j, k`. However, they don't vary on one or more of these directions; the indexing operation needs to be ""collapsed"" so that reduced indices are translated correctly. Thus when we adapt `AveragedField` for the GPU, we hold onto the wrapper:. https://github.com/CliMA/Oceananigans.jl/blob/98cd4f7a56aa581defc721a01d6e1ab89b534d26/src/Fields/averaged_field.jl#L94-L96. Peeking at the broadcasting code used by julia Base gives a hint. Broadcasting has to solve the same problem: we have to be able to make computations between arrays of size (Nx, Ny, 1) and (Nx, Ny, Nz), for example. In this case, the indices of the first array are ""extruded"" into the third dimension. There are [some shenanigans in `Base.Broadcast`](https://github.com/JuliaLang/julia/blob/e467661f080a1b14ca1a9cf6681a8c713a3ae20c/base/broadcast.jl#L572-L630) that look like they are solving some type instability problem (which would doom GPU compilation for us if it were occurring). So we might be able to learn / borrow code from `Base.Broadcast`. All speculation from a naive julia programmer...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1595#issuecomment-821847550
Integrability,wrap,wrapper,"ions on #1241 (and proposed as a solution there). Specifically, abstraction operations that failed to compile due to a recursive call to `identity` now compile, because we use different identity functions. The compiler doesn't complain and compiles these objects. This includes operators like `u - v + w` as demonstrated in my example. This hack doesn't allow us to execute arbitrarily complex abstract operations on the GPU. I don't think we can guarantee execution of arbitrary code in general. In this case, there are other issues that compiler might encounter that are not related to recursive calls to `identity`. We identified two additional issues on https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-738870593. There may be other problems that we haven't uncovered. An important additional case that doesn't work right now is operations that have embedded `AveragedField`. I think this is some kind of type inference issue. For `Field` on the GPU we ""throw away"" the wrapper and expose the underlying `OffsetArray` to GPU kernels. So compilation of functions of `Field` is ""no more difficult"" than compilation of functions with `OffsetArray`. This idealization is successful because indexing into the underlying `field.data` is identical indexing into the field itself, and because we don't require field locations _inside_ the kernel (we build expression trees for AbstractOperations on the CPU, prior to launching the kernel). But this idealization doesn't hold for `AveragedField` or any `ReducedField`. In particular, abstract operations index into these objects at all `i, j, k`. However, they don't vary on one or more of these directions; the indexing operation needs to be ""collapsed"" so that reduced indices are translated correctly. Thus when we adapt `AveragedField` for the GPU, we hold onto the wrapper:. https://github.com/CliMA/Oceananigans.jl/blob/98cd4f7a56aa581defc721a01d6e1ab89b534d26/src/Fields/averaged_field.jl#L94-L96. Peeking at the broadcasting code u",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1595#issuecomment-821847550
Modifiability,adapt,adapt,"thub.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-738870593. There may be other problems that we haven't uncovered. An important additional case that doesn't work right now is operations that have embedded `AveragedField`. I think this is some kind of type inference issue. For `Field` on the GPU we ""throw away"" the wrapper and expose the underlying `OffsetArray` to GPU kernels. So compilation of functions of `Field` is ""no more difficult"" than compilation of functions with `OffsetArray`. This idealization is successful because indexing into the underlying `field.data` is identical indexing into the field itself, and because we don't require field locations _inside_ the kernel (we build expression trees for AbstractOperations on the CPU, prior to launching the kernel). But this idealization doesn't hold for `AveragedField` or any `ReducedField`. In particular, abstract operations index into these objects at all `i, j, k`. However, they don't vary on one or more of these directions; the indexing operation needs to be ""collapsed"" so that reduced indices are translated correctly. Thus when we adapt `AveragedField` for the GPU, we hold onto the wrapper:. https://github.com/CliMA/Oceananigans.jl/blob/98cd4f7a56aa581defc721a01d6e1ab89b534d26/src/Fields/averaged_field.jl#L94-L96. Peeking at the broadcasting code used by julia Base gives a hint. Broadcasting has to solve the same problem: we have to be able to make computations between arrays of size (Nx, Ny, 1) and (Nx, Ny, Nz), for example. In this case, the indices of the first array are ""extruded"" into the third dimension. There are [some shenanigans in `Base.Broadcast`](https://github.com/JuliaLang/julia/blob/e467661f080a1b14ca1a9cf6681a8c713a3ae20c/base/broadcast.jl#L572-L630) that look like they are solving some type instability problem (which would doom GPU compilation for us if it were occurring). So we might be able to learn / borrow code from `Base.Broadcast`. All speculation from a naive julia programmer...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1595#issuecomment-821847550
Security,expose,expose,"ions on #1241 (and proposed as a solution there). Specifically, abstraction operations that failed to compile due to a recursive call to `identity` now compile, because we use different identity functions. The compiler doesn't complain and compiles these objects. This includes operators like `u - v + w` as demonstrated in my example. This hack doesn't allow us to execute arbitrarily complex abstract operations on the GPU. I don't think we can guarantee execution of arbitrary code in general. In this case, there are other issues that compiler might encounter that are not related to recursive calls to `identity`. We identified two additional issues on https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-738870593. There may be other problems that we haven't uncovered. An important additional case that doesn't work right now is operations that have embedded `AveragedField`. I think this is some kind of type inference issue. For `Field` on the GPU we ""throw away"" the wrapper and expose the underlying `OffsetArray` to GPU kernels. So compilation of functions of `Field` is ""no more difficult"" than compilation of functions with `OffsetArray`. This idealization is successful because indexing into the underlying `field.data` is identical indexing into the field itself, and because we don't require field locations _inside_ the kernel (we build expression trees for AbstractOperations on the CPU, prior to launching the kernel). But this idealization doesn't hold for `AveragedField` or any `ReducedField`. In particular, abstract operations index into these objects at all `i, j, k`. However, they don't vary on one or more of these directions; the indexing operation needs to be ""collapsed"" so that reduced indices are translated correctly. Thus when we adapt `AveragedField` for the GPU, we hold onto the wrapper:. https://github.com/CliMA/Oceananigans.jl/blob/98cd4f7a56aa581defc721a01d6e1ab89b534d26/src/Fields/averaged_field.jl#L94-L96. Peeking at the broadcasting code u",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1595#issuecomment-821847550
Usability,learn,learn,"thub.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-738870593. There may be other problems that we haven't uncovered. An important additional case that doesn't work right now is operations that have embedded `AveragedField`. I think this is some kind of type inference issue. For `Field` on the GPU we ""throw away"" the wrapper and expose the underlying `OffsetArray` to GPU kernels. So compilation of functions of `Field` is ""no more difficult"" than compilation of functions with `OffsetArray`. This idealization is successful because indexing into the underlying `field.data` is identical indexing into the field itself, and because we don't require field locations _inside_ the kernel (we build expression trees for AbstractOperations on the CPU, prior to launching the kernel). But this idealization doesn't hold for `AveragedField` or any `ReducedField`. In particular, abstract operations index into these objects at all `i, j, k`. However, they don't vary on one or more of these directions; the indexing operation needs to be ""collapsed"" so that reduced indices are translated correctly. Thus when we adapt `AveragedField` for the GPU, we hold onto the wrapper:. https://github.com/CliMA/Oceananigans.jl/blob/98cd4f7a56aa581defc721a01d6e1ab89b534d26/src/Fields/averaged_field.jl#L94-L96. Peeking at the broadcasting code used by julia Base gives a hint. Broadcasting has to solve the same problem: we have to be able to make computations between arrays of size (Nx, Ny, 1) and (Nx, Ny, Nz), for example. In this case, the indices of the first array are ""extruded"" into the third dimension. There are [some shenanigans in `Base.Broadcast`](https://github.com/JuliaLang/julia/blob/e467661f080a1b14ca1a9cf6681a8c713a3ae20c/base/broadcast.jl#L572-L630) that look like they are solving some type instability problem (which would doom GPU compilation for us if it were occurring). So we might be able to learn / borrow code from `Base.Broadcast`. All speculation from a naive julia programmer...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1595#issuecomment-821847550
Deployability,update,update,"> Sorry for not following, but I don't see what breaks here for the end user! Could someone give a quick example/explanation?. Apologies that my explanation was not clear. It's a breaking change because the same user input, such as. ```julia; tke = @at (Center, Center, Center) ((u - U)^2 + (v - V)^2 + w^2) / 2; ```. produces a different object after this update:. * Before this PR, `u - U` would be interpolated to `(Center, Center, Center)`, and then the binary operation `^(2, u - U)` would be calculated at `(Center, Center, Center)`.; * After this PR, both `u - U` and `^(2, u - U) = (u - U)^2` are calculated at `(Face, Center, Center)`. Interpolation is then performed to `(Center, Center, Center)` _after_ the exponentiation to form the three-part sum. Let me know if that makes sense or if another example would be useful.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1599#issuecomment-823698116
Performance,perform,performed,"> Sorry for not following, but I don't see what breaks here for the end user! Could someone give a quick example/explanation?. Apologies that my explanation was not clear. It's a breaking change because the same user input, such as. ```julia; tke = @at (Center, Center, Center) ((u - U)^2 + (v - V)^2 + w^2) / 2; ```. produces a different object after this update:. * Before this PR, `u - U` would be interpolated to `(Center, Center, Center)`, and then the binary operation `^(2, u - U)` would be calculated at `(Center, Center, Center)`.; * After this PR, both `u - U` and `^(2, u - U) = (u - U)^2` are calculated at `(Face, Center, Center)`. Interpolation is then performed to `(Center, Center, Center)` _after_ the exponentiation to form the three-part sum. Let me know if that makes sense or if another example would be useful.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1599#issuecomment-823698116
Usability,clear,clear,"> Sorry for not following, but I don't see what breaks here for the end user! Could someone give a quick example/explanation?. Apologies that my explanation was not clear. It's a breaking change because the same user input, such as. ```julia; tke = @at (Center, Center, Center) ((u - U)^2 + (v - V)^2 + w^2) / 2; ```. produces a different object after this update:. * Before this PR, `u - U` would be interpolated to `(Center, Center, Center)`, and then the binary operation `^(2, u - U)` would be calculated at `(Center, Center, Center)`.; * After this PR, both `u - U` and `^(2, u - U) = (u - U)^2` are calculated at `(Face, Center, Center)`. Interpolation is then performed to `(Center, Center, Center)` _after_ the exponentiation to form the three-part sum. Let me know if that makes sense or if another example would be useful.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1599#issuecomment-823698116
Usability,clear,clearly,The versions of some software are different. Should I delete the Julia clearly and re-run my previous steps?. How to delete Julia clearly?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1601#issuecomment-824065744
Usability,simpl,simple,"Great job with this so far @ali-ramadhan ! . I think your approximation for the zonal wind stress is very good. It may not be perfect but it's certainly very close. Also, I agree with @christophernhill , since there are no lateral boundaries to speak off, adding some bottom drag `-r*u` would be very simple and should help you to achieve a state that is in statistical equilibrum. . Looking forward to seeing more!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1602#issuecomment-824261073
Usability,simpl,simplify,"> A better solution might be to delete the code associated with the buoyancy modification term and simplify our lives. Pragmatically speaking, I think we can either keep it with a disclaimer in the docstring saying it's not properly implemented yet (because it needs some averaging that isn't done at the moment, correct?), or we can just dispose of it, like you said. I think the danger lies in leaving it there without caveats for an uninformed user to apply it thinking it's implemented correctly.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1619#issuecomment-826356857
Testability,test,testing,"> > A better solution might be to delete the code associated with the buoyancy modification term and simplify our lives.; > ; > Pragmatically speaking, I think we can either keep it with a disclaimer in the docstring saying it's not properly implemented yet (because it needs some averaging that isn't done at the moment, correct?), or we can just dispose of it, like you said. I think the danger lies in leaving it there without caveats for an uninformed user to apply it thinking it's implemented correctly. I guess the main motivation for not disposing of it is that we lose the code. But it's still there in git history and I think the main obstacle to implementing it is testing it properly rather than writing the kernel functions. Since I haven't heard great things about it (and it doesn't actually address the primary issues associated with strong stratification and LES closures) I'd rather spend my time working on other LES closures. So I'm in favor of nuking... But a warning / disclaimer is also a good solution. I'm up for both (this PR is as good a one as any to do this...)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1619#issuecomment-826419456
Usability,simpl,simplify,"> > A better solution might be to delete the code associated with the buoyancy modification term and simplify our lives.; > ; > Pragmatically speaking, I think we can either keep it with a disclaimer in the docstring saying it's not properly implemented yet (because it needs some averaging that isn't done at the moment, correct?), or we can just dispose of it, like you said. I think the danger lies in leaving it there without caveats for an uninformed user to apply it thinking it's implemented correctly. I guess the main motivation for not disposing of it is that we lose the code. But it's still there in git history and I think the main obstacle to implementing it is testing it properly rather than writing the kernel functions. Since I haven't heard great things about it (and it doesn't actually address the primary issues associated with strong stratification and LES closures) I'd rather spend my time working on other LES closures. So I'm in favor of nuking... But a warning / disclaimer is also a good solution. I'm up for both (this PR is as good a one as any to do this...)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1619#issuecomment-826419456
Usability,clear,clear,"> If you use the current IncompressibleModel without any tracers so the Boussinesq approximation doesn't come into play then isn't it truly an incompressible model?. It is, I agree with that. But then again, if you include a buoyancy model (which is the general case) then it's a Boussinesq model. . Also the first google result for ""boussinesq model"" gives the inexperienced user a wikipedia article that's quite clear (imo) in explaining explaining the model, so I think confusing new users wouldn't be much of a problem.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1620#issuecomment-827161847
Usability,clear,clear,"I agree that `BoussinesqModel` is the more general case. I also agree that Googling for ""Boussinesq model"" returns the relevant result but I wouldn't say it's super clear, especially to a newcomer (perhaps an undergrad), how it might relate to what they want to simulate. To someone wanting to simulate a simple CFD setup like a lid-driven cavity, having to read about approximations for buoyancy-driven flows on Wikipedia might obfuscate the fact that they indeed want to use the `BoussinesqModel` even though they're not using any buoyancy model. We could use both names if `IncompressibleModel` becomes an alias for `BoussinesqModel` but with `tracers = nothing, buoyancy = nothing`, etc. Not sure we want to use aliases though as we've been on a trend of using fewer aliases (e.g. https://github.com/CliMA/Oceananigans.jl/pull/613). As a side note: does it make sense to also consider renaming `HydrostaticFreeSurfaceModel` to something less wordy at the same time as we consider renaming `IncompressibleModel`?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1620#issuecomment-827170262
Usability,clear,clear,"I think we are never going to be both 100% accurate and 100% clear for everyone at the same time, so I guess we need to pick our poison. In this matter my personal opinion is that we should choose the more accurate name, but I'm not 100% sure either. And I also think this is a pretty big breaking change (given that atm most Oceananigans scripts probably use `IncompressibleModel`), so maybe it would be good to get input from other people as well?. CC: @glwagner @francispoulin @navidcy",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1620#issuecomment-827175522
Deployability,configurat,configurations,"Just to frame the discussion: this is probably most important in the context of new users or scientists trying to read examples, docs, and scripts that implement numerical experiments for scientific purposes. In that context I agree with @ali-ramadhan that `BoussinesqModel` is misleading for models with `tracers = nothing` and `buoyancy = nothing`. I think we've also discussed making this default, since its simple... As for the distinction between hydrostatic and non-hydrostatic models I agree that with currently supported configurations, `NonhydrostaticRigidLid` is better than `HydrostaticFreeSurfaceModel`. I'm only hesitant about this change because I wonder if we may want to combine these two models in the future. The motivation to develop `HydrostaticFreeSurfaceModel` separately is largely practical and caves to short term timeline pressures (it's easier to break things when nobody's using it, and we throw a warning right in the constructor so people know its experimental). In the long run it might make sense to have just a single interface to all incompressible models and support all combinations of hydrostatic, non-hydrostatic, free surface / rigid lid, etc through a single interface, similar to what MITgcm offers. The interfaces / model specific code is expensive to maintain, which motivates having just one interface. If this is our goal, it'd be premature to change the name of `IncompressibleModel`. If people feel they'd like to commit to maintaining two interfaces / model constructors / time-stepping code then I think changing the name to be clearer but less general is an option to consider. I personally would rather maintain as few `AbstractModel` as possible because I feel they are fairly expensive in terms of person-time to maintain. And we probably have a lot of improvements that need to be made (features like `model.auxiliary_fields`, `VectorField` for velocity field rather than baking in the coordinate system which fails on the cubed sphere), proper su",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1620#issuecomment-827842772
Integrability,interface,interface,"g to read examples, docs, and scripts that implement numerical experiments for scientific purposes. In that context I agree with @ali-ramadhan that `BoussinesqModel` is misleading for models with `tracers = nothing` and `buoyancy = nothing`. I think we've also discussed making this default, since its simple... As for the distinction between hydrostatic and non-hydrostatic models I agree that with currently supported configurations, `NonhydrostaticRigidLid` is better than `HydrostaticFreeSurfaceModel`. I'm only hesitant about this change because I wonder if we may want to combine these two models in the future. The motivation to develop `HydrostaticFreeSurfaceModel` separately is largely practical and caves to short term timeline pressures (it's easier to break things when nobody's using it, and we throw a warning right in the constructor so people know its experimental). In the long run it might make sense to have just a single interface to all incompressible models and support all combinations of hydrostatic, non-hydrostatic, free surface / rigid lid, etc through a single interface, similar to what MITgcm offers. The interfaces / model specific code is expensive to maintain, which motivates having just one interface. If this is our goal, it'd be premature to change the name of `IncompressibleModel`. If people feel they'd like to commit to maintaining two interfaces / model constructors / time-stepping code then I think changing the name to be clearer but less general is an option to consider. I personally would rather maintain as few `AbstractModel` as possible because I feel they are fairly expensive in terms of person-time to maintain. And we probably have a lot of improvements that need to be made (features like `model.auxiliary_fields`, `VectorField` for velocity field rather than baking in the coordinate system which fails on the cubed sphere), proper support for systems of coupled nonlinear boundary conditions, etc). It's a good discussion to have regardless.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1620#issuecomment-827842772
Modifiability,config,configurations,"Just to frame the discussion: this is probably most important in the context of new users or scientists trying to read examples, docs, and scripts that implement numerical experiments for scientific purposes. In that context I agree with @ali-ramadhan that `BoussinesqModel` is misleading for models with `tracers = nothing` and `buoyancy = nothing`. I think we've also discussed making this default, since its simple... As for the distinction between hydrostatic and non-hydrostatic models I agree that with currently supported configurations, `NonhydrostaticRigidLid` is better than `HydrostaticFreeSurfaceModel`. I'm only hesitant about this change because I wonder if we may want to combine these two models in the future. The motivation to develop `HydrostaticFreeSurfaceModel` separately is largely practical and caves to short term timeline pressures (it's easier to break things when nobody's using it, and we throw a warning right in the constructor so people know its experimental). In the long run it might make sense to have just a single interface to all incompressible models and support all combinations of hydrostatic, non-hydrostatic, free surface / rigid lid, etc through a single interface, similar to what MITgcm offers. The interfaces / model specific code is expensive to maintain, which motivates having just one interface. If this is our goal, it'd be premature to change the name of `IncompressibleModel`. If people feel they'd like to commit to maintaining two interfaces / model constructors / time-stepping code then I think changing the name to be clearer but less general is an option to consider. I personally would rather maintain as few `AbstractModel` as possible because I feel they are fairly expensive in terms of person-time to maintain. And we probably have a lot of improvements that need to be made (features like `model.auxiliary_fields`, `VectorField` for velocity field rather than baking in the coordinate system which fails on the cubed sphere), proper su",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1620#issuecomment-827842772
Usability,simpl,simple,"Just to frame the discussion: this is probably most important in the context of new users or scientists trying to read examples, docs, and scripts that implement numerical experiments for scientific purposes. In that context I agree with @ali-ramadhan that `BoussinesqModel` is misleading for models with `tracers = nothing` and `buoyancy = nothing`. I think we've also discussed making this default, since its simple... As for the distinction between hydrostatic and non-hydrostatic models I agree that with currently supported configurations, `NonhydrostaticRigidLid` is better than `HydrostaticFreeSurfaceModel`. I'm only hesitant about this change because I wonder if we may want to combine these two models in the future. The motivation to develop `HydrostaticFreeSurfaceModel` separately is largely practical and caves to short term timeline pressures (it's easier to break things when nobody's using it, and we throw a warning right in the constructor so people know its experimental). In the long run it might make sense to have just a single interface to all incompressible models and support all combinations of hydrostatic, non-hydrostatic, free surface / rigid lid, etc through a single interface, similar to what MITgcm offers. The interfaces / model specific code is expensive to maintain, which motivates having just one interface. If this is our goal, it'd be premature to change the name of `IncompressibleModel`. If people feel they'd like to commit to maintaining two interfaces / model constructors / time-stepping code then I think changing the name to be clearer but less general is an option to consider. I personally would rather maintain as few `AbstractModel` as possible because I feel they are fairly expensive in terms of person-time to maintain. And we probably have a lot of improvements that need to be made (features like `model.auxiliary_fields`, `VectorField` for velocity field rather than baking in the coordinate system which fails on the cubed sphere), proper su",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1620#issuecomment-827842772
Modifiability,refactor,refactor,"I think it's ok that ""rigid lid"" is implicit. In fact all the sides are rigid and there's no special direction at all. In fact, it might make sense to omit ""free surface"" from the hydrostatic model description. We could soon have a rigid lid option there, and then it wouldn't really make sense to continue calling it a ""HydrostaticFreeSurfaceModel"". There's a few things I think should go in before 1.0:. * Abstraction for vectors. It's only for simple grids that we can really get away with referring to the velocity field component wise with `u, v, w`. Building an abstraction for vectors changes the API because we'll specify boundary conditions on the whole velocity field, not just each component separately. I don't think we should do 1.0 without this.; * Resolve #1825 (specifying `architecture` when building `grid`). Another major API change, not to mention a substantial internal refactor.; * Simplify grids. We really only need one `RectilinearGrid`, one `LatitudeLongitudeGrid`, and one ""arbitrary"" (not aligned with a coordinate system, like what's used for the cubed sphere). Another API change because we don't need `RegularRectilinearGrid` and `VerticallyStretchedRectilinearGrid`. Also simplifies the code a lot. It could also make sense to build some experience with immersed boundaries in case there are change motivated by that feature.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1620#issuecomment-882075634
Usability,simpl,simple,"I think it's ok that ""rigid lid"" is implicit. In fact all the sides are rigid and there's no special direction at all. In fact, it might make sense to omit ""free surface"" from the hydrostatic model description. We could soon have a rigid lid option there, and then it wouldn't really make sense to continue calling it a ""HydrostaticFreeSurfaceModel"". There's a few things I think should go in before 1.0:. * Abstraction for vectors. It's only for simple grids that we can really get away with referring to the velocity field component wise with `u, v, w`. Building an abstraction for vectors changes the API because we'll specify boundary conditions on the whole velocity field, not just each component separately. I don't think we should do 1.0 without this.; * Resolve #1825 (specifying `architecture` when building `grid`). Another major API change, not to mention a substantial internal refactor.; * Simplify grids. We really only need one `RectilinearGrid`, one `LatitudeLongitudeGrid`, and one ""arbitrary"" (not aligned with a coordinate system, like what's used for the cubed sphere). Another API change because we don't need `RegularRectilinearGrid` and `VerticallyStretchedRectilinearGrid`. Also simplifies the code a lot. It could also make sense to build some experience with immersed boundaries in case there are change motivated by that feature.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1620#issuecomment-882075634
Modifiability,refactor,refactor,"> I think it's ok that ""rigid lid"" is implicit. In fact all the sides are rigid and there's no special direction at all.; > ; > In fact, it might make sense to omit ""free surface"" from the hydrostatic model description. We could soon have a rigid lid option there, and then it wouldn't really make sense to continue calling it a ""HydrostaticFreeSurfaceModel"".; > ; > There's a few things I think should go in before 1.0:; > ; > * Abstraction for vectors. It's only for simple grids that we can really get away with referring to the velocity field component wise with `u, v, w`. Building an abstraction for vectors changes the API because we'll specify boundary conditions on the whole velocity field, not just each component separately. I don't think we should do 1.0 without this.; > * Resolve [Should we store `architecture` in `grid`? #1825](https://github.com/CliMA/Oceananigans.jl/issues/1825) (specifying `architecture` when building `grid`). Another major API change, not to mention a substantial internal refactor.; > * Simplify grids. We really only need one `RectilinearGrid`, one `LatitudeLongitudeGrid`, and one ""arbitrary"" (not aligned with a coordinate system, like what's used for the cubed sphere). Another API change because we don't need `RegularRectilinearGrid` and `VerticallyStretchedRectilinearGrid`. Also simplifies the code a lot.; > ; > It could also make sense to build some experience with immersed boundaries in case there are change motivated by that feature. in my opinion, for v1.0 we should finalize spherical implementations and bathymetry also...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1620#issuecomment-882109635
Usability,simpl,simple,"> I think it's ok that ""rigid lid"" is implicit. In fact all the sides are rigid and there's no special direction at all.; > ; > In fact, it might make sense to omit ""free surface"" from the hydrostatic model description. We could soon have a rigid lid option there, and then it wouldn't really make sense to continue calling it a ""HydrostaticFreeSurfaceModel"".; > ; > There's a few things I think should go in before 1.0:; > ; > * Abstraction for vectors. It's only for simple grids that we can really get away with referring to the velocity field component wise with `u, v, w`. Building an abstraction for vectors changes the API because we'll specify boundary conditions on the whole velocity field, not just each component separately. I don't think we should do 1.0 without this.; > * Resolve [Should we store `architecture` in `grid`? #1825](https://github.com/CliMA/Oceananigans.jl/issues/1825) (specifying `architecture` when building `grid`). Another major API change, not to mention a substantial internal refactor.; > * Simplify grids. We really only need one `RectilinearGrid`, one `LatitudeLongitudeGrid`, and one ""arbitrary"" (not aligned with a coordinate system, like what's used for the cubed sphere). Another API change because we don't need `RegularRectilinearGrid` and `VerticallyStretchedRectilinearGrid`. Also simplifies the code a lot.; > ; > It could also make sense to build some experience with immersed boundaries in case there are change motivated by that feature. in my opinion, for v1.0 we should finalize spherical implementations and bathymetry also...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1620#issuecomment-882109635
Testability,test,test,"Rigid lid is actually just a short step from having an implicit free surface (and looks like we are about to have a direct solver for simple domains ala #1869...) --- the math is identical for the implicit solve, with a few terms zero'd out (eg, take the limit of an infinitely long time step). This implies too that models with an implicit free surface that take very long time steps compared to the gravity wave time-scale (most large scale models...) are effectively quite close mathematically to the rigid lid case (notwithstanding effects of runoff, precipitation, and evaporation). It seems an _explicit_ rigid lid formulation is not very practically useful, mostly because iterative solves take longer so rigid lid models in complex domains where there's no direct solve end up being slower. I'm not sure if there are any advantages re: tracer conservation. The story might get more interesting with generalized vertical coordinates, too. If anyone is keen to run problems with rigid lids, we can implement it and test it without too much trouble. MITgcm docs explain this well: https://mitgcm.readthedocs.io/en/latest/algorithm/algorithm.html#implicit-time-stepping-backward-method",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1620#issuecomment-882560379
Usability,simpl,simple,"Rigid lid is actually just a short step from having an implicit free surface (and looks like we are about to have a direct solver for simple domains ala #1869...) --- the math is identical for the implicit solve, with a few terms zero'd out (eg, take the limit of an infinitely long time step). This implies too that models with an implicit free surface that take very long time steps compared to the gravity wave time-scale (most large scale models...) are effectively quite close mathematically to the rigid lid case (notwithstanding effects of runoff, precipitation, and evaporation). It seems an _explicit_ rigid lid formulation is not very practically useful, mostly because iterative solves take longer so rigid lid models in complex domains where there's no direct solve end up being slower. I'm not sure if there are any advantages re: tracer conservation. The story might get more interesting with generalized vertical coordinates, too. If anyone is keen to run problems with rigid lids, we can implement it and test it without too much trouble. MITgcm docs explain this well: https://mitgcm.readthedocs.io/en/latest/algorithm/algorithm.html#implicit-time-stepping-backward-method",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1620#issuecomment-882560379
Usability,simpl,simple,"I know that the rigid-lid and linear free-surface models are very closely related as the grid doesn't change, and I would think that we could use the same solver on both cases. Is that true?. I guess one important difference is in the latter we have to evole the free-surrface but that is pretty cheap compared to everything else as it's only a two-dimensional field. Dealing with complex geometries is, well, complex, and I don't pretend to understand the nuances there, but in simple rectilinear geometries, I think it would be fairly easy to have an option to go between rigid-lid and linear free-surface in both `NonhydrostaticModel` and `HydrostaticModel`. Is this true? Would people want these options?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1620#issuecomment-882593053
Modifiability,refactor,refactor," well, complex, and I don't pretend to understand the nuances there, but in simple rectilinear geometries, I think it would be fairly easy to have an option to go between rigid-lid and linear free-surface in both `NonhydrostaticModel` and `HydrostaticModel`. Is this true? Would people want these options?. Yes, any solver for an implicit free surface can be generalized with some small code modifications to the rigid lid case. When using a _direct_ solve, there is negligible or actually zero difference in cost between an implicit free surface and rigid lid. When using an iterative solve, the rigid lid can be more expensive because the solution may not converge as quickly. I don't think a linear + porous free surface with a fixed grid is very useful in the non-hydrostatic model (in some respects the resulting model might be a worse approximation to any real ocean scenario). It can be done, but I don't think there is much benefit from a modeling perspective. With a breathing / moving grid that follows the surface the story might be a bit different. Having such an abstraction would enable some neat problems that are difficult to solve with any code. But for that someone would have to refactor the non hydrostatic model to use generalized vertical coordinates, and also develop a new pressure solver. This paper by Sullivan and McWilliams describe such a model for atmospheric simulations with a moving, weakly distorted lower boundary:. https://journals.ametsoc.org/view/journals/atsc/71/11/jas-d-14-0095.1.xml. In that paper the ""undistorted"" pressure solve is used a preconditioner for a fixed point iteration. We could do the same thing except with a conjugate gradient iteration (possibly slightly better than a fixed point iteration). It's possibly a nice project for someone interested in LES above or below weakly distorted boundaries. Note that this method probably won't work when the bathymetry is ""too big"", because the iterative solve may converge too slowly. cc @whitleyv .",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1620#issuecomment-882660514
Usability,simpl,simple,"> I know that the rigid-lid and linear free-surface models are very closely related as the grid doesn't change, and I would think that we could use the same solver on both cases. Is that true?; > ; > I guess one important difference is in the latter we have to evole the free-surrface but that is pretty cheap compared to everything else as it's only a two-dimensional field.; > ; > Dealing with complex geometries is, well, complex, and I don't pretend to understand the nuances there, but in simple rectilinear geometries, I think it would be fairly easy to have an option to go between rigid-lid and linear free-surface in both `NonhydrostaticModel` and `HydrostaticModel`. Is this true? Would people want these options?. Yes, any solver for an implicit free surface can be generalized with some small code modifications to the rigid lid case. When using a _direct_ solve, there is negligible or actually zero difference in cost between an implicit free surface and rigid lid. When using an iterative solve, the rigid lid can be more expensive because the solution may not converge as quickly. I don't think a linear + porous free surface with a fixed grid is very useful in the non-hydrostatic model (in some respects the resulting model might be a worse approximation to any real ocean scenario). It can be done, but I don't think there is much benefit from a modeling perspective. With a breathing / moving grid that follows the surface the story might be a bit different. Having such an abstraction would enable some neat problems that are difficult to solve with any code. But for that someone would have to refactor the non hydrostatic model to use generalized vertical coordinates, and also develop a new pressure solver. This paper by Sullivan and McWilliams describe such a model for atmospheric simulations with a moving, weakly distorted lower boundary:. https://journals.ametsoc.org/view/journals/atsc/71/11/jas-d-14-0095.1.xml. In that paper the ""undistorted"" pressure solve is used a ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1620#issuecomment-882660514
Usability,clear,clear,That is very clear and accurate. Agreed!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1630#issuecomment-829649309
Integrability,message,message,@ali-ramadhan and I created that warning message. Maybe it's too agressive and we should rethink it as people clearly become concerned by it? Will have to think about that a bit more but glad it's working!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1636#issuecomment-832330440
Usability,clear,clearly,@ali-ramadhan and I created that warning message. Maybe it's too agressive and we should rethink it as people clearly become concerned by it? Will have to think about that a bit more but glad it's working!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1636#issuecomment-832330440
Security,validat,validation,"Thanks for the feedback. . First, I used the formatting to get nicer output,; ```; Method = CenteredSecondOrder(), Rate of Convergence = 1.99, Expected = 2 ; Method = UpwindBiasedThirdOrder(), Rate of Convergence = 2.99, Expected = 3 ; Method = CenteredFourthOrder(), Rate of Convergence = 3.98, Expected = 4 ; Method = UpwindBiasedFifthOrder(), Rate of Convergence = 4.97, Expected = 5 ; Method = WENO5(), Rate of Convergence = 5.00, Expected = 5 ; ```. Second, sorry about the extra files. I will probably close this and create a new one rather than having a bunch of commits, as that will be cleaner. I presume that's the preferred option?. Third, can you point me to another validation experiment that uses a library not in the library?. Fourth, I won't do any other advection schemes for this PR. Fifth, I will move this into the validation folder and chane the name of the files appropriately.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1648#issuecomment-839144393
Usability,feedback,feedback,"Thanks for the feedback. . First, I used the formatting to get nicer output,; ```; Method = CenteredSecondOrder(), Rate of Convergence = 1.99, Expected = 2 ; Method = UpwindBiasedThirdOrder(), Rate of Convergence = 2.99, Expected = 3 ; Method = CenteredFourthOrder(), Rate of Convergence = 3.98, Expected = 4 ; Method = UpwindBiasedFifthOrder(), Rate of Convergence = 4.97, Expected = 5 ; Method = WENO5(), Rate of Convergence = 5.00, Expected = 5 ; ```. Second, sorry about the extra files. I will probably close this and create a new one rather than having a bunch of commits, as that will be cleaner. I presume that's the preferred option?. Third, can you point me to another validation experiment that uses a library not in the library?. Fourth, I won't do any other advection schemes for this PR. Fifth, I will move this into the validation folder and chane the name of the files appropriately.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1648#issuecomment-839144393
Usability,undo,undo,Sorry about that. Should I undo the merge and then try again?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1650#issuecomment-839884965
Usability,undo,undo,Ah it's not a big deal so I wouldn't worry about for this PR!. It's too late to undo right now since it's in git history and fully deleting it would involve rewriting git history which is usually bad haha. We did it once before (https://github.com/CliMA/Oceananigans.jl/issues/509) but we had lots of 50 MiB files so it was needed.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1650#issuecomment-839888796
Usability,undo,undo,Changing git history is also a bit annoying and somewhat labor intensive; there's no quick undo.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1650#issuecomment-839943210
Energy Efficiency,adapt,adapt,> I can adapt `GridFittedImmersedBoundary` for `IncompressibleModel` in a separate PR if that makes sense?. I think a separate PR is best. It's really a research PR since we don't have a recipe so the validation process will probably be more involved. It's not clear what algorithm we should choose for `IncompressibleModel`.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1654#issuecomment-839931448
Modifiability,adapt,adapt,> I can adapt `GridFittedImmersedBoundary` for `IncompressibleModel` in a separate PR if that makes sense?. I think a separate PR is best. It's really a research PR since we don't have a recipe so the validation process will probably be more involved. It's not clear what algorithm we should choose for `IncompressibleModel`.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1654#issuecomment-839931448
Security,validat,validation,> I can adapt `GridFittedImmersedBoundary` for `IncompressibleModel` in a separate PR if that makes sense?. I think a separate PR is best. It's really a research PR since we don't have a recipe so the validation process will probably be more involved. It's not clear what algorithm we should choose for `IncompressibleModel`.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1654#issuecomment-839931448
Usability,clear,clear,> I can adapt `GridFittedImmersedBoundary` for `IncompressibleModel` in a separate PR if that makes sense?. I think a separate PR is best. It's really a research PR since we don't have a recipe so the validation process will probably be more involved. It's not clear what algorithm we should choose for `IncompressibleModel`.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1654#issuecomment-839931448
Usability,learn,learn,"With my student, I wanted to look at flow over a tall seamount and icemount, like many people have done. That is a first step, but then I want her to look at sigma-coordinates, as we discussed. One goal is to compare the two and to learn more about their respective strengths and weaknesses. I have ran the example you created in this PR on my local computer and it's been 3 hours and it's still going. Is that to be expected?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1654#issuecomment-867209568
Usability,guid,guide,In #1722 we compared CPU vs GPU for the `ShallowWaterModel` for problems starting at 32x32 going as high as 16384x1634. Not quite the same model miind you but for 256x256 we found the speed up to be 7. This problem is 512x256 so it could be slightly beter but there is the pressure solve so this is just a guide. I know that the Poisson solves are a bit part of it and agree this will take time.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1654#issuecomment-868118543
Usability,simpl,simplest,"Hi @jmbeckers all topologies are supported now!. I think the issue is that on the staggered grid face-centered fields use N+1 grid cells along `Bounded` dimensions in Oceananigans.jl. So when `topology = (Periodic, Periodic, Flat)` like in the example then. ```julia; julia> size(model.velocities.u); (128, 128, 1). julia> size(model.velocities.v); (128, 128, 1); ```. but when you change to `topology = (Periodic, Bounded, Flat)` then the v field gets an extra grid cell in y:. ```julia; julia> size(model.velocities.u); (128, 128, 1). julia> size(model.velocities.v); (128, 129, 1); ```. so the initial condition from the example no longer works since it creates an array of size 128x128x1 to use for both u and v:. ```julia; u₀ = rand(size(model.grid)...); u₀ .-= mean(u₀). set!(model, u=u₀, v=u₀); ```. Perhaps the simplest solution would be to do something like. ```julia; u₀ = rand(size(model.velocities.u)...); u₀ .-= mean(u₀). v₀ = rand(size(model.velocities.v)...); v₀ .-= mean(v₀). set!(model, u=u₀, v=v₀); ```. so that u and v use different random noise arrays with the correct size. I think the example should still exhibit two-dimensional turbulence.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1656#issuecomment-839713415
Safety,avoid,avoids,"Thanks for the suggestion @jmbeckers! Since we can now use broadcasting on fields, another possibility is. ```julia; u₀(x, y, z) = rand(); set!(model, u = u₀, v = u₀). model.velocities.u .-= mean(model.velocities.u); model.velocities.v .-= mean(model.velocities.v); ```. This emphasizes using function input, which is generally a better way to work, and avoids annoyances associated with `size` (and is shorter and possibly clearer). However, I agree that @jmbeckers suggestion is better if we want to provide an example of array input. I like the idea of providing such an example, but I'm not sure if we want to put it in such a prominent place as the two dimensional turbulence example because it can be annoying and inconvenient to use them, as this issue illustrates...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1656#issuecomment-839940253
Usability,clear,clearer,"Thanks for the suggestion @jmbeckers! Since we can now use broadcasting on fields, another possibility is. ```julia; u₀(x, y, z) = rand(); set!(model, u = u₀, v = u₀). model.velocities.u .-= mean(model.velocities.u); model.velocities.v .-= mean(model.velocities.v); ```. This emphasizes using function input, which is generally a better way to work, and avoids annoyances associated with `size` (and is shorter and possibly clearer). However, I agree that @jmbeckers suggestion is better if we want to provide an example of array input. I like the idea of providing such an example, but I'm not sure if we want to put it in such a prominent place as the two dimensional turbulence example because it can be annoying and inconvenient to use them, as this issue illustrates...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1656#issuecomment-839940253
Usability,clear,clear,"I think it's nice to explain how to use array input but it's not clear to me that this example is the best place to do it. I like the idea of having a simple fix here, as was suggested above, and then another example that reads in data or something, as @jmbeckers suggested.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1656#issuecomment-842297531
Usability,simpl,simple,"> > I'm curious what a canonical / recommended use case for array input might be. It'd be nice to provide such an example.; > ; > Maybe a case using real observations or a case where a coarse resolution model is used to initialize a high resolution model ?. Yes, that seems promising! For some problems of that nature we have recommended that people write functions to interpolate their discrete data, since one can then change resolution seamlessly... but perhaps there's a case where writing an interpolator doesn't make sense or is too cumbersome for a simple setup. 🤔",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1656#issuecomment-842412515
Deployability,integrat,integration,"> Yes, that seems promising! For some problems of that nature we have recommended that people write functions to interpolate their discrete data, since one can then change resolution seamlessly... but perhaps there's a case where writing an interpolator doesn't make sense or is too cumbersome for a simple setup. 🤔. Writing an interpolator function would certainly be the most elegant way but some user might already be used to other regridding tools (like nco) and would prefer to read in some fields?. A simple fun example for using array inputs:. Prepare a tracer field by backward advecting the attached image or a logo in a Stommel gyre. Save the distorted image and now prepare the example using this distorted image as the initial condition for a forward advection :-). More seriously you could do the example including backward and forward integration to show the quality difference of several advection schemes. ![image](https://user-images.githubusercontent.com/19711382/118604859-ef7f6800-b7b5-11eb-87de-98934b4df17d.png)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1656#issuecomment-842903736
Integrability,integrat,integration,"> Yes, that seems promising! For some problems of that nature we have recommended that people write functions to interpolate their discrete data, since one can then change resolution seamlessly... but perhaps there's a case where writing an interpolator doesn't make sense or is too cumbersome for a simple setup. 🤔. Writing an interpolator function would certainly be the most elegant way but some user might already be used to other regridding tools (like nco) and would prefer to read in some fields?. A simple fun example for using array inputs:. Prepare a tracer field by backward advecting the attached image or a logo in a Stommel gyre. Save the distorted image and now prepare the example using this distorted image as the initial condition for a forward advection :-). More seriously you could do the example including backward and forward integration to show the quality difference of several advection schemes. ![image](https://user-images.githubusercontent.com/19711382/118604859-ef7f6800-b7b5-11eb-87de-98934b4df17d.png)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1656#issuecomment-842903736
Testability,log,logo,"> Yes, that seems promising! For some problems of that nature we have recommended that people write functions to interpolate their discrete data, since one can then change resolution seamlessly... but perhaps there's a case where writing an interpolator doesn't make sense or is too cumbersome for a simple setup. 🤔. Writing an interpolator function would certainly be the most elegant way but some user might already be used to other regridding tools (like nco) and would prefer to read in some fields?. A simple fun example for using array inputs:. Prepare a tracer field by backward advecting the attached image or a logo in a Stommel gyre. Save the distorted image and now prepare the example using this distorted image as the initial condition for a forward advection :-). More seriously you could do the example including backward and forward integration to show the quality difference of several advection schemes. ![image](https://user-images.githubusercontent.com/19711382/118604859-ef7f6800-b7b5-11eb-87de-98934b4df17d.png)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1656#issuecomment-842903736
Usability,simpl,simple,"> Yes, that seems promising! For some problems of that nature we have recommended that people write functions to interpolate their discrete data, since one can then change resolution seamlessly... but perhaps there's a case where writing an interpolator doesn't make sense or is too cumbersome for a simple setup. 🤔. Writing an interpolator function would certainly be the most elegant way but some user might already be used to other regridding tools (like nco) and would prefer to read in some fields?. A simple fun example for using array inputs:. Prepare a tracer field by backward advecting the attached image or a logo in a Stommel gyre. Save the distorted image and now prepare the example using this distorted image as the initial condition for a forward advection :-). More seriously you could do the example including backward and forward integration to show the quality difference of several advection schemes. ![image](https://user-images.githubusercontent.com/19711382/118604859-ef7f6800-b7b5-11eb-87de-98934b4df17d.png)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1656#issuecomment-842903736
Usability,simpl,simple,"In an ideal world we would illustrate visualization with a range of plotting utilities, including Plots, Makie, etc. I think if we found that Plots were unusual for a ""substantial"" number of people then we might consider not using it in examples. But as far as I know Plots is actively developed. If you can distill the problem you're encountering to a simple example, you might report it to Plots.jl?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1657#issuecomment-867001489
Usability,guid,guidance,I think I now have the ability to restart the build but don't know how. I'm happy to do it next time if I can get a bit of guidance as to how to do that.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843333581
Usability,simpl,simply,"I am looking into these changes (sorry for the delay) and I am a big puzzled on how to proceed. @glwagner said that we might want to remove `Δx` in favour of other terms like `Δxᶜᶜᵃ`. This sounds reasonable. However, it seems like the latter is defined in terms of the former. I take this to mean that we don't want to completely eliminate the `Δx` but simply not use it later?. ```; @inline Δxᶜᶜᵃ(i, j, k, grid::ARG) = Δx(i, j, k, grid); ```. It seems to me that there is a lot of room for cleaning things up in `spacings_and_arrays_and_volumnes.jl`, but since I don't understand all the models I'm pretty sure I'm not the ideal person to be suggesting these changes.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1663#issuecomment-847940744
Performance,optimiz,optimize,"Well, there was a major bug associated with the fact that we were trying to avoid precomputed the diffusivities. Basically, diffusivities cannot be computed on the fly due to the ""predictor-corrector"" algorithm we use for implicit time stepping. Opting to precompute diffusivities solves this problem, at the cost of three additional 3D model fields when using `TKEBasedVerticalDiffusivity`. I think this is not a huge price to pay considering that models with 3 velocities and n tracers have (3 + n) * 3 fields already; thus in the simplest case (one buoyancy tracer and one TKE tracer) we incur ~20% (3/15) additional memory allocation from diffusivity precomputation. We can optimize memory allocation further in the future as well, potentially. On the upside, things are looking pretty good now. From the wind mixing validation:. ![image](https://user-images.githubusercontent.com/15271942/118858897-14dba700-b886-11eb-93b2-b4be1a6ea8ed.png)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1664#issuecomment-844323514
Safety,avoid,avoid,"Well, there was a major bug associated with the fact that we were trying to avoid precomputed the diffusivities. Basically, diffusivities cannot be computed on the fly due to the ""predictor-corrector"" algorithm we use for implicit time stepping. Opting to precompute diffusivities solves this problem, at the cost of three additional 3D model fields when using `TKEBasedVerticalDiffusivity`. I think this is not a huge price to pay considering that models with 3 velocities and n tracers have (3 + n) * 3 fields already; thus in the simplest case (one buoyancy tracer and one TKE tracer) we incur ~20% (3/15) additional memory allocation from diffusivity precomputation. We can optimize memory allocation further in the future as well, potentially. On the upside, things are looking pretty good now. From the wind mixing validation:. ![image](https://user-images.githubusercontent.com/15271942/118858897-14dba700-b886-11eb-93b2-b4be1a6ea8ed.png)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1664#issuecomment-844323514
Security,validat,validation,"Well, there was a major bug associated with the fact that we were trying to avoid precomputed the diffusivities. Basically, diffusivities cannot be computed on the fly due to the ""predictor-corrector"" algorithm we use for implicit time stepping. Opting to precompute diffusivities solves this problem, at the cost of three additional 3D model fields when using `TKEBasedVerticalDiffusivity`. I think this is not a huge price to pay considering that models with 3 velocities and n tracers have (3 + n) * 3 fields already; thus in the simplest case (one buoyancy tracer and one TKE tracer) we incur ~20% (3/15) additional memory allocation from diffusivity precomputation. We can optimize memory allocation further in the future as well, potentially. On the upside, things are looking pretty good now. From the wind mixing validation:. ![image](https://user-images.githubusercontent.com/15271942/118858897-14dba700-b886-11eb-93b2-b4be1a6ea8ed.png)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1664#issuecomment-844323514
Usability,simpl,simplest,"Well, there was a major bug associated with the fact that we were trying to avoid precomputed the diffusivities. Basically, diffusivities cannot be computed on the fly due to the ""predictor-corrector"" algorithm we use for implicit time stepping. Opting to precompute diffusivities solves this problem, at the cost of three additional 3D model fields when using `TKEBasedVerticalDiffusivity`. I think this is not a huge price to pay considering that models with 3 velocities and n tracers have (3 + n) * 3 fields already; thus in the simplest case (one buoyancy tracer and one TKE tracer) we incur ~20% (3/15) additional memory allocation from diffusivity precomputation. We can optimize memory allocation further in the future as well, potentially. On the upside, things are looking pretty good now. From the wind mixing validation:. ![image](https://user-images.githubusercontent.com/15271942/118858897-14dba700-b886-11eb-93b2-b4be1a6ea8ed.png)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1664#issuecomment-844323514
Usability,simpl,simple,One example that reproduced this result was `benchmarks_shallow_water_mode.jl` but incompressible model also had the same issue. I think that @ali-ramadhan 's suggestion is a simple fix and our current and future windows users will appreciate this.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1672#issuecomment-844273400
Deployability,integrat,integration,"casa_token=K2HHnGIuaukAAAAA:5PhiRAM7tprmr73KhLpcARMloUdkxYFc0j8hukBAsr_MVpz6BlPSHTg-OoIajqdiaBvQbug-9w) (semi-Lagrangian vertical coordinate that follows high-pass filtered fast motions only and is restored to a target grid on a relatively short time scale). Other formulations, including classical sigma coordinates and quasi-Lagrangian methods that involve grid warping severe enough to require remapping, may fail unless we improve our method for calculating the horizontal pressure gradient force. In particular, the method we use now is essentially finite difference and requires a vertical coordinate that exactly or ""almost"" coincides with a geopotential surface. Finite volume treatment of the pressure gradient force is discussed by. * [Lin (1997)](https://rmets.onlinelibrary.wiley.com/doi/abs/10.1002/qj.49712354214?casa_token=AKlxv5lyqCcAAAAA:iRV8loXCjnioqxfxVDYQQX7oESyUjXPRF7KEZvYk7TCc_fRLhuiy0oGuza5KOGu9ucP63ZPbgCUI5sY) in the context of an atmospheric model with an effectively linear equation of state; * [Shchepetkin and McWilliams (2003)](https://agupubs.onlinelibrary.wiley.com/doi/full/10.1029/2001JC001047) which implements a high-order method for evaluating a contour integral around momentum elements for computing the pressure gradient force; * [Adcroft et al (2008)](https://www.sciencedirect.com/science/article/pii/S1463500308000243?casa_token=97k7TULeY9QAAAAA:_fsnUYOj7nBHPzGZXSO7jG31LMu4qlvJce8lsyof9jQPeICA4CFlsHA6KhH-81xRBiYoiMxElQ) that utilizes a crucial ""analytical integration"" step valid for for a nonlinear equation of state that can be written in a ""simplified"" form, which avoids the relatively more expensive numerical integration of part of the contour (and is more accurate); * [Engwirda et al (2017)](https://www.sciencedirect.com/science/article/pii/S1463500317300665?casa_token=egcQ20_UnnAAAAAA:WuCxxWYCfVpuL8-mrbSLJriY1z9W1TbiQNirtaJ9ZeIoIZkpOWbsod7AY7kLhxy8vcl5GfzcTw) using high-order numerical integration techniques for nonlinear equations of state",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1679#issuecomment-847224041
Integrability,integrat,integration,"casa_token=K2HHnGIuaukAAAAA:5PhiRAM7tprmr73KhLpcARMloUdkxYFc0j8hukBAsr_MVpz6BlPSHTg-OoIajqdiaBvQbug-9w) (semi-Lagrangian vertical coordinate that follows high-pass filtered fast motions only and is restored to a target grid on a relatively short time scale). Other formulations, including classical sigma coordinates and quasi-Lagrangian methods that involve grid warping severe enough to require remapping, may fail unless we improve our method for calculating the horizontal pressure gradient force. In particular, the method we use now is essentially finite difference and requires a vertical coordinate that exactly or ""almost"" coincides with a geopotential surface. Finite volume treatment of the pressure gradient force is discussed by. * [Lin (1997)](https://rmets.onlinelibrary.wiley.com/doi/abs/10.1002/qj.49712354214?casa_token=AKlxv5lyqCcAAAAA:iRV8loXCjnioqxfxVDYQQX7oESyUjXPRF7KEZvYk7TCc_fRLhuiy0oGuza5KOGu9ucP63ZPbgCUI5sY) in the context of an atmospheric model with an effectively linear equation of state; * [Shchepetkin and McWilliams (2003)](https://agupubs.onlinelibrary.wiley.com/doi/full/10.1029/2001JC001047) which implements a high-order method for evaluating a contour integral around momentum elements for computing the pressure gradient force; * [Adcroft et al (2008)](https://www.sciencedirect.com/science/article/pii/S1463500308000243?casa_token=97k7TULeY9QAAAAA:_fsnUYOj7nBHPzGZXSO7jG31LMu4qlvJce8lsyof9jQPeICA4CFlsHA6KhH-81xRBiYoiMxElQ) that utilizes a crucial ""analytical integration"" step valid for for a nonlinear equation of state that can be written in a ""simplified"" form, which avoids the relatively more expensive numerical integration of part of the contour (and is more accurate); * [Engwirda et al (2017)](https://www.sciencedirect.com/science/article/pii/S1463500317300665?casa_token=egcQ20_UnnAAAAAA:WuCxxWYCfVpuL8-mrbSLJriY1z9W1TbiQNirtaJ9ZeIoIZkpOWbsod7AY7kLhxy8vcl5GfzcTw) using high-order numerical integration techniques for nonlinear equations of state",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1679#issuecomment-847224041
Safety,avoid,avoids,"casa_token=K2HHnGIuaukAAAAA:5PhiRAM7tprmr73KhLpcARMloUdkxYFc0j8hukBAsr_MVpz6BlPSHTg-OoIajqdiaBvQbug-9w) (semi-Lagrangian vertical coordinate that follows high-pass filtered fast motions only and is restored to a target grid on a relatively short time scale). Other formulations, including classical sigma coordinates and quasi-Lagrangian methods that involve grid warping severe enough to require remapping, may fail unless we improve our method for calculating the horizontal pressure gradient force. In particular, the method we use now is essentially finite difference and requires a vertical coordinate that exactly or ""almost"" coincides with a geopotential surface. Finite volume treatment of the pressure gradient force is discussed by. * [Lin (1997)](https://rmets.onlinelibrary.wiley.com/doi/abs/10.1002/qj.49712354214?casa_token=AKlxv5lyqCcAAAAA:iRV8loXCjnioqxfxVDYQQX7oESyUjXPRF7KEZvYk7TCc_fRLhuiy0oGuza5KOGu9ucP63ZPbgCUI5sY) in the context of an atmospheric model with an effectively linear equation of state; * [Shchepetkin and McWilliams (2003)](https://agupubs.onlinelibrary.wiley.com/doi/full/10.1029/2001JC001047) which implements a high-order method for evaluating a contour integral around momentum elements for computing the pressure gradient force; * [Adcroft et al (2008)](https://www.sciencedirect.com/science/article/pii/S1463500308000243?casa_token=97k7TULeY9QAAAAA:_fsnUYOj7nBHPzGZXSO7jG31LMu4qlvJce8lsyof9jQPeICA4CFlsHA6KhH-81xRBiYoiMxElQ) that utilizes a crucial ""analytical integration"" step valid for for a nonlinear equation of state that can be written in a ""simplified"" form, which avoids the relatively more expensive numerical integration of part of the contour (and is more accurate); * [Engwirda et al (2017)](https://www.sciencedirect.com/science/article/pii/S1463500317300665?casa_token=egcQ20_UnnAAAAAA:WuCxxWYCfVpuL8-mrbSLJriY1z9W1TbiQNirtaJ9ZeIoIZkpOWbsod7AY7kLhxy8vcl5GfzcTw) using high-order numerical integration techniques for nonlinear equations of state",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1679#issuecomment-847224041
Usability,simpl,simplified,"casa_token=K2HHnGIuaukAAAAA:5PhiRAM7tprmr73KhLpcARMloUdkxYFc0j8hukBAsr_MVpz6BlPSHTg-OoIajqdiaBvQbug-9w) (semi-Lagrangian vertical coordinate that follows high-pass filtered fast motions only and is restored to a target grid on a relatively short time scale). Other formulations, including classical sigma coordinates and quasi-Lagrangian methods that involve grid warping severe enough to require remapping, may fail unless we improve our method for calculating the horizontal pressure gradient force. In particular, the method we use now is essentially finite difference and requires a vertical coordinate that exactly or ""almost"" coincides with a geopotential surface. Finite volume treatment of the pressure gradient force is discussed by. * [Lin (1997)](https://rmets.onlinelibrary.wiley.com/doi/abs/10.1002/qj.49712354214?casa_token=AKlxv5lyqCcAAAAA:iRV8loXCjnioqxfxVDYQQX7oESyUjXPRF7KEZvYk7TCc_fRLhuiy0oGuza5KOGu9ucP63ZPbgCUI5sY) in the context of an atmospheric model with an effectively linear equation of state; * [Shchepetkin and McWilliams (2003)](https://agupubs.onlinelibrary.wiley.com/doi/full/10.1029/2001JC001047) which implements a high-order method for evaluating a contour integral around momentum elements for computing the pressure gradient force; * [Adcroft et al (2008)](https://www.sciencedirect.com/science/article/pii/S1463500308000243?casa_token=97k7TULeY9QAAAAA:_fsnUYOj7nBHPzGZXSO7jG31LMu4qlvJce8lsyof9jQPeICA4CFlsHA6KhH-81xRBiYoiMxElQ) that utilizes a crucial ""analytical integration"" step valid for for a nonlinear equation of state that can be written in a ""simplified"" form, which avoids the relatively more expensive numerical integration of part of the contour (and is more accurate); * [Engwirda et al (2017)](https://www.sciencedirect.com/science/article/pii/S1463500317300665?casa_token=egcQ20_UnnAAAAAA:WuCxxWYCfVpuL8-mrbSLJriY1z9W1TbiQNirtaJ9ZeIoIZkpOWbsod7AY7kLhxy8vcl5GfzcTw) using high-order numerical integration techniques for nonlinear equations of state",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1679#issuecomment-847224041
Energy Efficiency,reduce,reduce,"Ah interesting. `SubArray` is what `view` returns. I'm hazy about why you see what you see, but we do know that _singly_ wrapped containers get special treatment. Possibly there have been some improvements for double+ wrapped containers like `view` of `OffsetArray`. As a sanity you could try removing `interior(r)` and just pass `r` instead... :-O. However, I believe this is a bug with CUDA so that would just be a workaround rather than a legitimate solution. Can you reproduce the bug with a simple code that tries to reduce to a `view` of `CuArray`? In other words use the same code as above but reduce to a view of `a` rather than a view of `o`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1684#issuecomment-845608494
Integrability,wrap,wrapped,"Ah interesting. `SubArray` is what `view` returns. I'm hazy about why you see what you see, but we do know that _singly_ wrapped containers get special treatment. Possibly there have been some improvements for double+ wrapped containers like `view` of `OffsetArray`. As a sanity you could try removing `interior(r)` and just pass `r` instead... :-O. However, I believe this is a bug with CUDA so that would just be a workaround rather than a legitimate solution. Can you reproduce the bug with a simple code that tries to reduce to a `view` of `CuArray`? In other words use the same code as above but reduce to a view of `a` rather than a view of `o`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1684#issuecomment-845608494
Usability,simpl,simple,"Ah interesting. `SubArray` is what `view` returns. I'm hazy about why you see what you see, but we do know that _singly_ wrapped containers get special treatment. Possibly there have been some improvements for double+ wrapped containers like `view` of `OffsetArray`. As a sanity you could try removing `interior(r)` and just pass `r` instead... :-O. However, I believe this is a bug with CUDA so that would just be a workaround rather than a legitimate solution. Can you reproduce the bug with a simple code that tries to reduce to a `view` of `CuArray`? In other words use the same code as above but reduce to a view of `a` rather than a view of `o`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1684#issuecomment-845608494
Energy Efficiency,reduce,reduce,"> Can you reproduce the bug with a simple code that tries to reduce to a `view` of `CuArray`?. Yeah I'm trying to reproduce in CUDA.jl so I tried this first but it seems to work:. ```julia; julia> using Statistics. julia> using CUDA. julia> N = 32;. julia> a = randn(N+2, N+2, N+2) |> CuArray;. julia> v = view(a, 2:N+1, 2:N+1, 2:N+1);. julia> V = zeros(1, 1, N) |> CuArray;. julia> mean!(V, v);; typeof(R) = CuArray{Float64, 3}; threads = 384; blocks = 96; reduce_blocks = 3; typeof(R) = CuArray{Float64, 4}; threads = 32; blocks = 32; reduce_blocks = 1; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1684#issuecomment-845609934
Usability,simpl,simple,"> Can you reproduce the bug with a simple code that tries to reduce to a `view` of `CuArray`?. Yeah I'm trying to reproduce in CUDA.jl so I tried this first but it seems to work:. ```julia; julia> using Statistics. julia> using CUDA. julia> N = 32;. julia> a = randn(N+2, N+2, N+2) |> CuArray;. julia> v = view(a, 2:N+1, 2:N+1, 2:N+1);. julia> V = zeros(1, 1, N) |> CuArray;. julia> mean!(V, v);; typeof(R) = CuArray{Float64, 3}; threads = 384; blocks = 96; reduce_blocks = 3; typeof(R) = CuArray{Float64, 4}; threads = 32; blocks = 32; reduce_blocks = 1; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1684#issuecomment-845609934
Availability,ping,ping,"Sure @francispoulin, this was just a placeholder.; I'll add more details and ping you to either chip in or simply have a look...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1690#issuecomment-846688815
Usability,simpl,simply,"Sure @francispoulin, this was just a placeholder.; I'll add more details and ping you to either chip in or simply have a look...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1690#issuecomment-846688815
Testability,test,tests,I'll proceed with nuking as soon as tests pass. But I do advocate for the need of a simple example on the sphere to appear in the docs soon... :),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1691#issuecomment-847373536
Usability,simpl,simple,I'll proceed with nuking as soon as tests pass. But I do advocate for the need of a simple example on the sphere to appear in the docs soon... :),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1691#issuecomment-847373536
Usability,simpl,simple,"Yes, a simple example would be great.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1691#issuecomment-847392951
Availability,error,error,"If we wanted to quantify the difference, we can simply find an exact solution and simulate it and compute the error. There are lots of examples to choose from.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1704#issuecomment-876063266
Usability,simpl,simply,"If we wanted to quantify the difference, we can simply find an exact solution and simulate it and compute the error. There are lots of examples to choose from.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1704#issuecomment-876063266
Usability,simpl,simple,"In the above, WENO-JS is the scheme we have now, and WENO-NM is the ""weighted"" scheme they propose. The weighted scheme is ~~extremely simple~~ fairly simple. ~~It's just a little algebra to get it to work for us.~~ On reading the paper again, I realize that the smoothness indicators are a bit annoying. But doable.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1704#issuecomment-876450169
Performance,perform,performance,"The results in [A simple algorithm to improve the performance of the WENO scheme on non-uniform grids](https://link.springer.com/article/10.1007/s10409-017-0715-2) show that WENO reverts to 2nd-order accuracy on stretched grids. So its not ""incorrect"", just less accurate. However, for any given problem, the convergence rate is only one aspect of the accuracy of a solution. It's possible that WENO5 is still more accurate than any other numerical scheme, even if the solution only _converges_ to the true solution at a 2nd order rate. It also seems likely that this is true for any reconstruction stencil. I'm not sure how much attention is paid to this issue in other codes.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1704#issuecomment-967312861
Usability,simpl,simple,"The results in [A simple algorithm to improve the performance of the WENO scheme on non-uniform grids](https://link.springer.com/article/10.1007/s10409-017-0715-2) show that WENO reverts to 2nd-order accuracy on stretched grids. So its not ""incorrect"", just less accurate. However, for any given problem, the convergence rate is only one aspect of the accuracy of a solution. It's possible that WENO5 is still more accurate than any other numerical scheme, even if the solution only _converges_ to the true solution at a 2nd order rate. It also seems likely that this is true for any reconstruction stencil. I'm not sure how much attention is paid to this issue in other codes.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1704#issuecomment-967312861
Usability,simpl,simplify,I'll simplify the ShallowWaterModel constructor in a new PR...,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1710#issuecomment-849945455
Integrability,depend,depend,"The difficulty with `Value` conditions is that they depend on the model / turbulence closure being used (in the simplest case, we can use the user-specification to calculate a gradient, and then infer the cross boundary flux with a diffusivity). We can implement this by implementing some standard notation for the turbulence closures (right now there is a function `viscosity`, for example, and `z_viscosity`. We need the `x` and `y` components as well). In the grid-aligned case we use halos to enforce `Value` boundary conditions, but this approach doesn't work with immersed boundaries. The `Flux` case is a bit more straightforward since it doesn't depend on the closure, but does require some reasoning about boundary normal.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1720#issuecomment-850498079
Usability,simpl,simplest,"The difficulty with `Value` conditions is that they depend on the model / turbulence closure being used (in the simplest case, we can use the user-specification to calculate a gradient, and then infer the cross boundary flux with a diffusivity). We can implement this by implementing some standard notation for the turbulence closures (right now there is a function `viscosity`, for example, and `z_viscosity`. We need the `x` and `y` components as well). In the grid-aligned case we use halos to enforce `Value` boundary conditions, but this approach doesn't work with immersed boundaries. The `Flux` case is a bit more straightforward since it doesn't depend on the closure, but does require some reasoning about boundary normal.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1720#issuecomment-850498079
Availability,mask,masking,"d specify what they want the two tangential and 1 normal direction to be instead of (u,v,w) specifically. Right, this is what I mean by having an ""abstraction for vectors"" --- awesome! If the momentum equation is treated in vector form then the three components are coupled. User specification is then on the vector momentum equation; users will specify `VelocityBoundaryConditions` (rather than boundary conditions for each component, and `VectorForcing`, rather than forcing on each component. It may also make sense to coalesce the kernels that compute tendencies for each velocity component (but I'm less sure about that). Either way this is a major change to the API at the very least, but probably necessary and something we also need for complex domains for GCM simulations, like the cubed sphere. > the original idea was to infer Flux from Gradient. This makes sense for a continuous immersed boundary where it's not possible to _discretely_ specify fluxes. If we can't discretely specify fluxes, we have to rely on a diffusivity extracted from the specified turbulence closure. This is simple for closures that have isotropic diffusivities, but gets more complicated for closures with anisotropic / tensor diffusivities. Even worse is supporting flux boundary conditions for the case that a closure doesn't use a diffusivity at all... Note also that flux boundary conditions are used almost exclusively except for direct numerical simulation, so this is indeed an important consideration. > I know this is a little different than the fitted version, because it's a little harder to specify a normal direction in that case,. For `GridFittedImmersedBoundary` the normal direction can be easily and efficiently inferred from the masking function by evaluating it at offset `i`, `j`, `k`. If fluid is adjacent to solid in any of those directions, you are on a boundary with a normal in the `x, y, z` direction (respectively), and the sign of the normal direction can be inferred from the offset.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1720#issuecomment-850559517
Deployability,continuous,continuous," can be pretty variable in made more sense for us to take this approach. So the user would specify what they want the two tangential and 1 normal direction to be instead of (u,v,w) specifically. Right, this is what I mean by having an ""abstraction for vectors"" --- awesome! If the momentum equation is treated in vector form then the three components are coupled. User specification is then on the vector momentum equation; users will specify `VelocityBoundaryConditions` (rather than boundary conditions for each component, and `VectorForcing`, rather than forcing on each component. It may also make sense to coalesce the kernels that compute tendencies for each velocity component (but I'm less sure about that). Either way this is a major change to the API at the very least, but probably necessary and something we also need for complex domains for GCM simulations, like the cubed sphere. > the original idea was to infer Flux from Gradient. This makes sense for a continuous immersed boundary where it's not possible to _discretely_ specify fluxes. If we can't discretely specify fluxes, we have to rely on a diffusivity extracted from the specified turbulence closure. This is simple for closures that have isotropic diffusivities, but gets more complicated for closures with anisotropic / tensor diffusivities. Even worse is supporting flux boundary conditions for the case that a closure doesn't use a diffusivity at all... Note also that flux boundary conditions are used almost exclusively except for direct numerical simulation, so this is indeed an important consideration. > I know this is a little different than the fitted version, because it's a little harder to specify a normal direction in that case,. For `GridFittedImmersedBoundary` the normal direction can be easily and efficiently inferred from the masking function by evaluating it at offset `i`, `j`, `k`. If fluid is adjacent to solid in any of those directions, you are on a boundary with a normal in the `x, y, z` direct",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1720#issuecomment-850559517
Energy Efficiency,efficient,efficiently,"d specify what they want the two tangential and 1 normal direction to be instead of (u,v,w) specifically. Right, this is what I mean by having an ""abstraction for vectors"" --- awesome! If the momentum equation is treated in vector form then the three components are coupled. User specification is then on the vector momentum equation; users will specify `VelocityBoundaryConditions` (rather than boundary conditions for each component, and `VectorForcing`, rather than forcing on each component. It may also make sense to coalesce the kernels that compute tendencies for each velocity component (but I'm less sure about that). Either way this is a major change to the API at the very least, but probably necessary and something we also need for complex domains for GCM simulations, like the cubed sphere. > the original idea was to infer Flux from Gradient. This makes sense for a continuous immersed boundary where it's not possible to _discretely_ specify fluxes. If we can't discretely specify fluxes, we have to rely on a diffusivity extracted from the specified turbulence closure. This is simple for closures that have isotropic diffusivities, but gets more complicated for closures with anisotropic / tensor diffusivities. Even worse is supporting flux boundary conditions for the case that a closure doesn't use a diffusivity at all... Note also that flux boundary conditions are used almost exclusively except for direct numerical simulation, so this is indeed an important consideration. > I know this is a little different than the fitted version, because it's a little harder to specify a normal direction in that case,. For `GridFittedImmersedBoundary` the normal direction can be easily and efficiently inferred from the masking function by evaluating it at offset `i`, `j`, `k`. If fluid is adjacent to solid in any of those directions, you are on a boundary with a normal in the `x, y, z` direction (respectively), and the sign of the normal direction can be inferred from the offset.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1720#issuecomment-850559517
Modifiability,variab,variable,"No worries about the late response! Here's a couple of comments, might have more later. > The current implementation I have going projects the velocity into tangential and normal directions (with respect to the immersed surface) before interpolating over the boundary. Since the boundary can be pretty variable in made more sense for us to take this approach. So the user would specify what they want the two tangential and 1 normal direction to be instead of (u,v,w) specifically. Right, this is what I mean by having an ""abstraction for vectors"" --- awesome! If the momentum equation is treated in vector form then the three components are coupled. User specification is then on the vector momentum equation; users will specify `VelocityBoundaryConditions` (rather than boundary conditions for each component, and `VectorForcing`, rather than forcing on each component. It may also make sense to coalesce the kernels that compute tendencies for each velocity component (but I'm less sure about that). Either way this is a major change to the API at the very least, but probably necessary and something we also need for complex domains for GCM simulations, like the cubed sphere. > the original idea was to infer Flux from Gradient. This makes sense for a continuous immersed boundary where it's not possible to _discretely_ specify fluxes. If we can't discretely specify fluxes, we have to rely on a diffusivity extracted from the specified turbulence closure. This is simple for closures that have isotropic diffusivities, but gets more complicated for closures with anisotropic / tensor diffusivities. Even worse is supporting flux boundary conditions for the case that a closure doesn't use a diffusivity at all... Note also that flux boundary conditions are used almost exclusively except for direct numerical simulation, so this is indeed an important consideration. > I know this is a little different than the fitted version, because it's a little harder to specify a normal direction in that",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1720#issuecomment-850559517
Usability,simpl,simple,"d specify what they want the two tangential and 1 normal direction to be instead of (u,v,w) specifically. Right, this is what I mean by having an ""abstraction for vectors"" --- awesome! If the momentum equation is treated in vector form then the three components are coupled. User specification is then on the vector momentum equation; users will specify `VelocityBoundaryConditions` (rather than boundary conditions for each component, and `VectorForcing`, rather than forcing on each component. It may also make sense to coalesce the kernels that compute tendencies for each velocity component (but I'm less sure about that). Either way this is a major change to the API at the very least, but probably necessary and something we also need for complex domains for GCM simulations, like the cubed sphere. > the original idea was to infer Flux from Gradient. This makes sense for a continuous immersed boundary where it's not possible to _discretely_ specify fluxes. If we can't discretely specify fluxes, we have to rely on a diffusivity extracted from the specified turbulence closure. This is simple for closures that have isotropic diffusivities, but gets more complicated for closures with anisotropic / tensor diffusivities. Even worse is supporting flux boundary conditions for the case that a closure doesn't use a diffusivity at all... Note also that flux boundary conditions are used almost exclusively except for direct numerical simulation, so this is indeed an important consideration. > I know this is a little different than the fitted version, because it's a little harder to specify a normal direction in that case,. For `GridFittedImmersedBoundary` the normal direction can be easily and efficiently inferred from the masking function by evaluating it at offset `i`, `j`, `k`. If fluid is adjacent to solid in any of those directions, you are on a boundary with a normal in the `x, y, z` direction (respectively), and the sign of the normal direction can be inferred from the offset.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1720#issuecomment-850559517
Availability,down,downside,"> 1. Should we change the flux convention in Oceananigans so that `FluxBoundaryCondition` specifies the flux along the _inward pointing normal_? This reverses the convention we use on ""right"" boundaries (west, north, top). For example, a negative buoyancy flux would cause cooling at the surface with this convention. This is a huge change, but I think is necessary to do things like specifying a drag boundary condition on vertical velocity (I can discuss further why this is the case if needed.). I quite like the current convention for specifying fluxes since (imho) it's more mathematically intuitive, so my vote goes to maintaining that convention if we can (although I agree that it makes it harder to apply it generally for immersed solids...). One way to do it would be to leave most of the heavy work for the user, which would have to specify fluxes in each of the immersed solid's interfaces separately. The user's script would look like what I did here:; https://github.com/CliMA/Oceananigans.jl/blob/faed0c4ac85409cb94811b0bdba2bbb7becf330a/sandbox/drag_test.jl#L25-L41. The downside is that this won't work for non-grid-fitted boundaries and requires more user-written code. The upside is that could (I think) re-use much of the inner-workings of the current BC implementation. > We can do 2. without 1. In that case we'll be able to support a lot of common cases, including ordinary oceanic cases (where boundaries do not overhang, and we only specify drag on tangential components). It's really LES cases that become tricky because we can't specify drag on vertical velocity components, or on tangential components when the boundary overhangs. Not sure I understand this point. Do you mind clarifying @glwagner? By ""overhang"" do you mean that there's no fluid-to-the-bottom-immersed-boundary-to-the-top interface?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1720#issuecomment-1086345975
Integrability,interface,interfaces,"> 1. Should we change the flux convention in Oceananigans so that `FluxBoundaryCondition` specifies the flux along the _inward pointing normal_? This reverses the convention we use on ""right"" boundaries (west, north, top). For example, a negative buoyancy flux would cause cooling at the surface with this convention. This is a huge change, but I think is necessary to do things like specifying a drag boundary condition on vertical velocity (I can discuss further why this is the case if needed.). I quite like the current convention for specifying fluxes since (imho) it's more mathematically intuitive, so my vote goes to maintaining that convention if we can (although I agree that it makes it harder to apply it generally for immersed solids...). One way to do it would be to leave most of the heavy work for the user, which would have to specify fluxes in each of the immersed solid's interfaces separately. The user's script would look like what I did here:; https://github.com/CliMA/Oceananigans.jl/blob/faed0c4ac85409cb94811b0bdba2bbb7becf330a/sandbox/drag_test.jl#L25-L41. The downside is that this won't work for non-grid-fitted boundaries and requires more user-written code. The upside is that could (I think) re-use much of the inner-workings of the current BC implementation. > We can do 2. without 1. In that case we'll be able to support a lot of common cases, including ordinary oceanic cases (where boundaries do not overhang, and we only specify drag on tangential components). It's really LES cases that become tricky because we can't specify drag on vertical velocity components, or on tangential components when the boundary overhangs. Not sure I understand this point. Do you mind clarifying @glwagner? By ""overhang"" do you mean that there's no fluid-to-the-bottom-immersed-boundary-to-the-top interface?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1720#issuecomment-1086345975
Modifiability,sandbox,sandbox,"> 1. Should we change the flux convention in Oceananigans so that `FluxBoundaryCondition` specifies the flux along the _inward pointing normal_? This reverses the convention we use on ""right"" boundaries (west, north, top). For example, a negative buoyancy flux would cause cooling at the surface with this convention. This is a huge change, but I think is necessary to do things like specifying a drag boundary condition on vertical velocity (I can discuss further why this is the case if needed.). I quite like the current convention for specifying fluxes since (imho) it's more mathematically intuitive, so my vote goes to maintaining that convention if we can (although I agree that it makes it harder to apply it generally for immersed solids...). One way to do it would be to leave most of the heavy work for the user, which would have to specify fluxes in each of the immersed solid's interfaces separately. The user's script would look like what I did here:; https://github.com/CliMA/Oceananigans.jl/blob/faed0c4ac85409cb94811b0bdba2bbb7becf330a/sandbox/drag_test.jl#L25-L41. The downside is that this won't work for non-grid-fitted boundaries and requires more user-written code. The upside is that could (I think) re-use much of the inner-workings of the current BC implementation. > We can do 2. without 1. In that case we'll be able to support a lot of common cases, including ordinary oceanic cases (where boundaries do not overhang, and we only specify drag on tangential components). It's really LES cases that become tricky because we can't specify drag on vertical velocity components, or on tangential components when the boundary overhangs. Not sure I understand this point. Do you mind clarifying @glwagner? By ""overhang"" do you mean that there's no fluid-to-the-bottom-immersed-boundary-to-the-top interface?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1720#issuecomment-1086345975
Testability,sandbox,sandbox,"> 1. Should we change the flux convention in Oceananigans so that `FluxBoundaryCondition` specifies the flux along the _inward pointing normal_? This reverses the convention we use on ""right"" boundaries (west, north, top). For example, a negative buoyancy flux would cause cooling at the surface with this convention. This is a huge change, but I think is necessary to do things like specifying a drag boundary condition on vertical velocity (I can discuss further why this is the case if needed.). I quite like the current convention for specifying fluxes since (imho) it's more mathematically intuitive, so my vote goes to maintaining that convention if we can (although I agree that it makes it harder to apply it generally for immersed solids...). One way to do it would be to leave most of the heavy work for the user, which would have to specify fluxes in each of the immersed solid's interfaces separately. The user's script would look like what I did here:; https://github.com/CliMA/Oceananigans.jl/blob/faed0c4ac85409cb94811b0bdba2bbb7becf330a/sandbox/drag_test.jl#L25-L41. The downside is that this won't work for non-grid-fitted boundaries and requires more user-written code. The upside is that could (I think) re-use much of the inner-workings of the current BC implementation. > We can do 2. without 1. In that case we'll be able to support a lot of common cases, including ordinary oceanic cases (where boundaries do not overhang, and we only specify drag on tangential components). It's really LES cases that become tricky because we can't specify drag on vertical velocity components, or on tangential components when the boundary overhangs. Not sure I understand this point. Do you mind clarifying @glwagner? By ""overhang"" do you mean that there's no fluid-to-the-bottom-immersed-boundary-to-the-top interface?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1720#issuecomment-1086345975
Usability,intuit,intuitive,"> 1. Should we change the flux convention in Oceananigans so that `FluxBoundaryCondition` specifies the flux along the _inward pointing normal_? This reverses the convention we use on ""right"" boundaries (west, north, top). For example, a negative buoyancy flux would cause cooling at the surface with this convention. This is a huge change, but I think is necessary to do things like specifying a drag boundary condition on vertical velocity (I can discuss further why this is the case if needed.). I quite like the current convention for specifying fluxes since (imho) it's more mathematically intuitive, so my vote goes to maintaining that convention if we can (although I agree that it makes it harder to apply it generally for immersed solids...). One way to do it would be to leave most of the heavy work for the user, which would have to specify fluxes in each of the immersed solid's interfaces separately. The user's script would look like what I did here:; https://github.com/CliMA/Oceananigans.jl/blob/faed0c4ac85409cb94811b0bdba2bbb7becf330a/sandbox/drag_test.jl#L25-L41. The downside is that this won't work for non-grid-fitted boundaries and requires more user-written code. The upside is that could (I think) re-use much of the inner-workings of the current BC implementation. > We can do 2. without 1. In that case we'll be able to support a lot of common cases, including ordinary oceanic cases (where boundaries do not overhang, and we only specify drag on tangential components). It's really LES cases that become tricky because we can't specify drag on vertical velocity components, or on tangential components when the boundary overhangs. Not sure I understand this point. Do you mind clarifying @glwagner? By ""overhang"" do you mean that there's no fluid-to-the-bottom-immersed-boundary-to-the-top interface?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1720#issuecomment-1086345975
Availability,error,error,"> > 1. Should we change the flux convention in Oceananigans so that `FluxBoundaryCondition` specifies the flux along the _inward pointing normal_? This reverses the convention we use on ""right"" boundaries (west, north, top). For example, a negative buoyancy flux would cause cooling at the surface with this convention. This is a huge change, but I think is necessary to do things like specifying a drag boundary condition on vertical velocity (I can discuss further why this is the case if needed.); > ; > I quite like the current convention for specifying fluxes since (imho) it's more mathematically intuitive, so my vote goes to maintaining that convention if we can (although I agree that it makes it harder to apply it generally for immersed solids...). Also making this change would mean that a bunch of scripts would fail silently. Meaning that, depending on what/where fluxes are prescribed, the fluxes would flip, producing a completely different result, without Oceananigans throwing an error (since I think we wouldn't change the interface). So if we do go that way I think we'd need to be really careful about it",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1720#issuecomment-1086349867
Integrability,depend,depending,"> > 1. Should we change the flux convention in Oceananigans so that `FluxBoundaryCondition` specifies the flux along the _inward pointing normal_? This reverses the convention we use on ""right"" boundaries (west, north, top). For example, a negative buoyancy flux would cause cooling at the surface with this convention. This is a huge change, but I think is necessary to do things like specifying a drag boundary condition on vertical velocity (I can discuss further why this is the case if needed.); > ; > I quite like the current convention for specifying fluxes since (imho) it's more mathematically intuitive, so my vote goes to maintaining that convention if we can (although I agree that it makes it harder to apply it generally for immersed solids...). Also making this change would mean that a bunch of scripts would fail silently. Meaning that, depending on what/where fluxes are prescribed, the fluxes would flip, producing a completely different result, without Oceananigans throwing an error (since I think we wouldn't change the interface). So if we do go that way I think we'd need to be really careful about it",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1720#issuecomment-1086349867
Usability,intuit,intuitive,"> > 1. Should we change the flux convention in Oceananigans so that `FluxBoundaryCondition` specifies the flux along the _inward pointing normal_? This reverses the convention we use on ""right"" boundaries (west, north, top). For example, a negative buoyancy flux would cause cooling at the surface with this convention. This is a huge change, but I think is necessary to do things like specifying a drag boundary condition on vertical velocity (I can discuss further why this is the case if needed.); > ; > I quite like the current convention for specifying fluxes since (imho) it's more mathematically intuitive, so my vote goes to maintaining that convention if we can (although I agree that it makes it harder to apply it generally for immersed solids...). Also making this change would mean that a bunch of scripts would fail silently. Meaning that, depending on what/where fluxes are prescribed, the fluxes would flip, producing a completely different result, without Oceananigans throwing an error (since I think we wouldn't change the interface). So if we do go that way I think we'd need to be really careful about it",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1720#issuecomment-1086349867
Testability,benchmark,benchmark,"This is a plot of the shallow water benchmark times: cpu vs gpu. What do you think?. *Absolute Times*. ![shallow_water_times](https://user-images.githubusercontent.com/8239041/120535459-fc54ac00-c3b0-11eb-90a6-71010d09b7fa.png). *Speed Up*. ![shallow_water_benchmarks2](https://user-images.githubusercontent.com/8239041/120205347-dcc65380-c1f7-11eb-9674-8bb2514b3045.png). In theory, it should be easy to include the code to create this image in the benchmark script. However, because the garbage collector does not clear the memory, we actually have to run the script separately for the high resolution runs. Any advice on how to resolve this issue?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1722#issuecomment-851504385
Usability,clear,clear,"This is a plot of the shallow water benchmark times: cpu vs gpu. What do you think?. *Absolute Times*. ![shallow_water_times](https://user-images.githubusercontent.com/8239041/120535459-fc54ac00-c3b0-11eb-90a6-71010d09b7fa.png). *Speed Up*. ![shallow_water_benchmarks2](https://user-images.githubusercontent.com/8239041/120205347-dcc65380-c1f7-11eb-9674-8bb2514b3045.png). In theory, it should be easy to include the code to create this image in the benchmark script. However, because the garbage collector does not clear the memory, we actually have to run the script separately for the high resolution runs. Any advice on how to resolve this issue?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1722#issuecomment-851504385
Usability,learn,learn,"Thanks @glwagner and I agree, speed up is better. WIll fix that that. The x-axis is the number of points in each direction. We could square it to get the total degrees of freedom, and that might be nice, but I keep on thinking that looking at the number of points in each direction on a square grid would be easier for the user to learn what to expect. But both are easy enough to produce. But I will keep this in mind when we are doing the `'IncompressibleModel`, where we would cube it. They should yield similar behaviour, I would think. But maybe the pressure solver makes things different. I hope to know better by tomorrow. I agree about this being enlightening. It seems to me that for high resolutions, the cpus and gpus have pretty much the same slopes, it just takes a lot for the gpu to start to increase. I didn't know this before and am happy to have learned it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1722#issuecomment-851711479
Usability,clear,clearly,Happy with any measure of resolution --- just asking for clarification. Perhaps instead of Resolution the plot can be labeled Nx (or some other word that indicates the meaning of the axis clearly.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1722#issuecomment-852424175
Usability,simpl,simple,"Thanks for the further thoughts. We don't actually want a `Value` boundary condition I just wanted to find a simple example to set something. Clearly I choose badly. Sorry. What I actually need to impose `NormalFlow` boundary condition, as I first mentoined to you. Unfortunately, when I tried that it didn't seem to have any effect. I should go back to the problem I wanted to solve originally and try and figure out why the boundary condtions were not being imposed. I'm pretty sure that normal flow is something we can impose without having second-order fluxes.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1730#issuecomment-852530819
Availability,down,downstream,"We don't support NormalFlow boundary conditions _emerging_ from an immersed boundary. The sponge is also centered on y = 0, where the southern boundary is. I think the means the solution is strongly damped throughout the entire domain?. An interesting case to simulate might be east-west flow _past_ a cape, idealized as a Gaussian excursion from the southern boundary. In this case we will want inflow in the west and outflow in the east. A simple starting point is to make the domain periodic in x and bounded in y, with an initial height h=1 and transport uh=1 everywhere. If that works, a sponge layer could be added downstream to idealize a cape embedded in a free stream. I wouldn't use NormalFlow unless it's really needed to shrink the domain, or something.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1730#issuecomment-852657583
Usability,simpl,simple,"We don't support NormalFlow boundary conditions _emerging_ from an immersed boundary. The sponge is also centered on y = 0, where the southern boundary is. I think the means the solution is strongly damped throughout the entire domain?. An interesting case to simulate might be east-west flow _past_ a cape, idealized as a Gaussian excursion from the southern boundary. In this case we will want inflow in the west and outflow in the east. A simple starting point is to make the domain periodic in x and bounded in y, with an initial height h=1 and transport uh=1 everywhere. If that works, a sponge layer could be added downstream to idealize a cape embedded in a free stream. I wouldn't use NormalFlow unless it's really needed to shrink the domain, or something.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1730#issuecomment-852657583
Usability,feedback,feedback,"Thanks all for the feedback! I chose the fake wall case because it permits a simple direct comparison between a ""true"" solution and the immersed boundary solution. But I agree that judging the fidelity of statistics and budgets in a more complicated case is also necessary. The challenge of more complicated cases is finding reference statistics to compare to. It'd be nice to find an ""[Askervein Hill](https://news.ucar.edu/126732/capturing-detailed-portrait-wind) of the ocean""... As for modifications to the pressure solver, we may be able to use an preconditioned conjugate gradient method (an iterative, matrix-free method) with the FFT-based solver as a preconditioner. I think a conjugate gradient method could provide some improvement over a ""naive"" iterative approach (iteratively applying the pressure correction step). We've already coded up such a solver to work with Oceananigans data structures:. https://github.com/CliMA/Oceananigans.jl/blob/master/src/Solvers/preconditioned_conjugate_gradient_solver.jl. A multigrid method would also be nice and might be even faster... ! But, probably a bit more difficult to code up I think. Getting the conjugate gradient solver to work might not take long.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1733#issuecomment-862712452
Availability,error,errors,"The xz and yz components of stress (called `viscous_flux_uz` and `viscous_flux_vz` in the code) are explicitly elided in the presence of an immersed boundary. For examle:. https://github.com/CliMA/Oceananigans.jl/blob/55500496bc76e5870a0e455d1dda059793e827d3/src/ImmersedBoundaries/grid_fitted_immersed_boundary.jl#L59. where. https://github.com/CliMA/Oceananigans.jl/blob/55500496bc76e5870a0e455d1dda059793e827d3/src/ImmersedBoundaries/grid_fitted_immersed_boundary.jl#L45. Since we can prescribe stresses / fluxes explicitly for grid fitted schemes (in principle --- its not implemented yet) I don't think we need to worry about errors in prescribed boundary fluxes. This issue may need to be revisited for other immersed boundary methods if they make approximations there. EDIT after I wrote this I also realized that maybe I don't understand what the boundary integrated stress is here. With a viscosity of 0, shouldn't the integrated stress be zero as well? Or perhaps this is the integrated strain?. Either way I think the simplest strategy for grid fitted boundaries (and relatives like partial cells and shaved cells) is to simply ""drop in"" the relevant prescribed flux where necessary.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1733#issuecomment-866295499
Deployability,integrat,integrated,"The xz and yz components of stress (called `viscous_flux_uz` and `viscous_flux_vz` in the code) are explicitly elided in the presence of an immersed boundary. For examle:. https://github.com/CliMA/Oceananigans.jl/blob/55500496bc76e5870a0e455d1dda059793e827d3/src/ImmersedBoundaries/grid_fitted_immersed_boundary.jl#L59. where. https://github.com/CliMA/Oceananigans.jl/blob/55500496bc76e5870a0e455d1dda059793e827d3/src/ImmersedBoundaries/grid_fitted_immersed_boundary.jl#L45. Since we can prescribe stresses / fluxes explicitly for grid fitted schemes (in principle --- its not implemented yet) I don't think we need to worry about errors in prescribed boundary fluxes. This issue may need to be revisited for other immersed boundary methods if they make approximations there. EDIT after I wrote this I also realized that maybe I don't understand what the boundary integrated stress is here. With a viscosity of 0, shouldn't the integrated stress be zero as well? Or perhaps this is the integrated strain?. Either way I think the simplest strategy for grid fitted boundaries (and relatives like partial cells and shaved cells) is to simply ""drop in"" the relevant prescribed flux where necessary.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1733#issuecomment-866295499
Integrability,integrat,integrated,"The xz and yz components of stress (called `viscous_flux_uz` and `viscous_flux_vz` in the code) are explicitly elided in the presence of an immersed boundary. For examle:. https://github.com/CliMA/Oceananigans.jl/blob/55500496bc76e5870a0e455d1dda059793e827d3/src/ImmersedBoundaries/grid_fitted_immersed_boundary.jl#L59. where. https://github.com/CliMA/Oceananigans.jl/blob/55500496bc76e5870a0e455d1dda059793e827d3/src/ImmersedBoundaries/grid_fitted_immersed_boundary.jl#L45. Since we can prescribe stresses / fluxes explicitly for grid fitted schemes (in principle --- its not implemented yet) I don't think we need to worry about errors in prescribed boundary fluxes. This issue may need to be revisited for other immersed boundary methods if they make approximations there. EDIT after I wrote this I also realized that maybe I don't understand what the boundary integrated stress is here. With a viscosity of 0, shouldn't the integrated stress be zero as well? Or perhaps this is the integrated strain?. Either way I think the simplest strategy for grid fitted boundaries (and relatives like partial cells and shaved cells) is to simply ""drop in"" the relevant prescribed flux where necessary.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1733#issuecomment-866295499
Usability,simpl,simplest,"The xz and yz components of stress (called `viscous_flux_uz` and `viscous_flux_vz` in the code) are explicitly elided in the presence of an immersed boundary. For examle:. https://github.com/CliMA/Oceananigans.jl/blob/55500496bc76e5870a0e455d1dda059793e827d3/src/ImmersedBoundaries/grid_fitted_immersed_boundary.jl#L59. where. https://github.com/CliMA/Oceananigans.jl/blob/55500496bc76e5870a0e455d1dda059793e827d3/src/ImmersedBoundaries/grid_fitted_immersed_boundary.jl#L45. Since we can prescribe stresses / fluxes explicitly for grid fitted schemes (in principle --- its not implemented yet) I don't think we need to worry about errors in prescribed boundary fluxes. This issue may need to be revisited for other immersed boundary methods if they make approximations there. EDIT after I wrote this I also realized that maybe I don't understand what the boundary integrated stress is here. With a viscosity of 0, shouldn't the integrated stress be zero as well? Or perhaps this is the integrated strain?. Either way I think the simplest strategy for grid fitted boundaries (and relatives like partial cells and shaved cells) is to simply ""drop in"" the relevant prescribed flux where necessary.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1733#issuecomment-866295499
Availability,error,error,"> Third, what exactly is computed in the last plot fo the integrated stress tensor? Also, have you computed these for the nonIBM case to see what the real wall does?. Sorry probably could have been clearer on this. This is just du/dy, calculated with a centered difference between the closest two fluid cells to the boundary, then integrated along the boundary line (ie. du/dy summed and multiplied by Lx). The plot above is the error between the IBM and nonIBM case. This plot here is the values themselves (dashed is nonIBM, solid is IBM); ![Bickley_dudy](https://user-images.githubusercontent.com/67593861/122993772-b4a0bf00-d375-11eb-9b60-2243077ce838.png); ; > > First, if `c` is the concentration of a tracer it should be non-negative. If you are picking it to be a `sine` I might suggest having `1 + sin` just to avoid negative values. That being said, I don't think it's going to have any impact on the results but might be worth trying.; > ; > Fair point; using `1 + sin(x)` as the initial condition would measure leakage since the total ""mass"" is then Lx * Ly. I propose adding another tracer though specifically for that purpose since it's easy. You are correct. I think the added tracer idea would be perfect. My mind was stuck on the cylinder concentration one I've done before, and didn't think about the difference here!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1733#issuecomment-866308816
Deployability,integrat,integrated,"> Third, what exactly is computed in the last plot fo the integrated stress tensor? Also, have you computed these for the nonIBM case to see what the real wall does?. Sorry probably could have been clearer on this. This is just du/dy, calculated with a centered difference between the closest two fluid cells to the boundary, then integrated along the boundary line (ie. du/dy summed and multiplied by Lx). The plot above is the error between the IBM and nonIBM case. This plot here is the values themselves (dashed is nonIBM, solid is IBM); ![Bickley_dudy](https://user-images.githubusercontent.com/67593861/122993772-b4a0bf00-d375-11eb-9b60-2243077ce838.png); ; > > First, if `c` is the concentration of a tracer it should be non-negative. If you are picking it to be a `sine` I might suggest having `1 + sin` just to avoid negative values. That being said, I don't think it's going to have any impact on the results but might be worth trying.; > ; > Fair point; using `1 + sin(x)` as the initial condition would measure leakage since the total ""mass"" is then Lx * Ly. I propose adding another tracer though specifically for that purpose since it's easy. You are correct. I think the added tracer idea would be perfect. My mind was stuck on the cylinder concentration one I've done before, and didn't think about the difference here!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1733#issuecomment-866308816
Integrability,integrat,integrated,"> Third, what exactly is computed in the last plot fo the integrated stress tensor? Also, have you computed these for the nonIBM case to see what the real wall does?. Sorry probably could have been clearer on this. This is just du/dy, calculated with a centered difference between the closest two fluid cells to the boundary, then integrated along the boundary line (ie. du/dy summed and multiplied by Lx). The plot above is the error between the IBM and nonIBM case. This plot here is the values themselves (dashed is nonIBM, solid is IBM); ![Bickley_dudy](https://user-images.githubusercontent.com/67593861/122993772-b4a0bf00-d375-11eb-9b60-2243077ce838.png); ; > > First, if `c` is the concentration of a tracer it should be non-negative. If you are picking it to be a `sine` I might suggest having `1 + sin` just to avoid negative values. That being said, I don't think it's going to have any impact on the results but might be worth trying.; > ; > Fair point; using `1 + sin(x)` as the initial condition would measure leakage since the total ""mass"" is then Lx * Ly. I propose adding another tracer though specifically for that purpose since it's easy. You are correct. I think the added tracer idea would be perfect. My mind was stuck on the cylinder concentration one I've done before, and didn't think about the difference here!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1733#issuecomment-866308816
Safety,avoid,avoid,"> Third, what exactly is computed in the last plot fo the integrated stress tensor? Also, have you computed these for the nonIBM case to see what the real wall does?. Sorry probably could have been clearer on this. This is just du/dy, calculated with a centered difference between the closest two fluid cells to the boundary, then integrated along the boundary line (ie. du/dy summed and multiplied by Lx). The plot above is the error between the IBM and nonIBM case. This plot here is the values themselves (dashed is nonIBM, solid is IBM); ![Bickley_dudy](https://user-images.githubusercontent.com/67593861/122993772-b4a0bf00-d375-11eb-9b60-2243077ce838.png); ; > > First, if `c` is the concentration of a tracer it should be non-negative. If you are picking it to be a `sine` I might suggest having `1 + sin` just to avoid negative values. That being said, I don't think it's going to have any impact on the results but might be worth trying.; > ; > Fair point; using `1 + sin(x)` as the initial condition would measure leakage since the total ""mass"" is then Lx * Ly. I propose adding another tracer though specifically for that purpose since it's easy. You are correct. I think the added tracer idea would be perfect. My mind was stuck on the cylinder concentration one I've done before, and didn't think about the difference here!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1733#issuecomment-866308816
Usability,clear,clearer,"> Third, what exactly is computed in the last plot fo the integrated stress tensor? Also, have you computed these for the nonIBM case to see what the real wall does?. Sorry probably could have been clearer on this. This is just du/dy, calculated with a centered difference between the closest two fluid cells to the boundary, then integrated along the boundary line (ie. du/dy summed and multiplied by Lx). The plot above is the error between the IBM and nonIBM case. This plot here is the values themselves (dashed is nonIBM, solid is IBM); ![Bickley_dudy](https://user-images.githubusercontent.com/67593861/122993772-b4a0bf00-d375-11eb-9b60-2243077ce838.png); ; > > First, if `c` is the concentration of a tracer it should be non-negative. If you are picking it to be a `sine` I might suggest having `1 + sin` just to avoid negative values. That being said, I don't think it's going to have any impact on the results but might be worth trying.; > ; > Fair point; using `1 + sin(x)` as the initial condition would measure leakage since the total ""mass"" is then Lx * Ly. I propose adding another tracer though specifically for that purpose since it's easy. You are correct. I think the added tracer idea would be perfect. My mind was stuck on the cylinder concentration one I've done before, and didn't think about the difference here!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1733#issuecomment-866308816
Availability,mask,masking,"> I believe for your implementation, since the tracer values are not corrected for pressure, any leakage will be due to the advection of tracer by momentum that _is_ impacted by the pressure correction. This advection should be less with a smaller spacial step if I remember correctly. Well, I agree that less leakage implies that less tracer is advected across the boundary. But why is less tracer advected across the boundary?. It occurs to me that we are not converging to a particular solution as we refine the grid in this case, because this problem has no viscosity. Perhaps we should do a convergence test for a case with finite viscosity. We do introduce grid-scale gradients in the predictor velocity field via masking, so it does seem possible to me that the leakage / pressure gradient error might scale with resolution. It'd be nice to have a solid mathematical explanation for this behavior. Another question might be whether the leakage / error depends on the extent of the masked region (holding resolution constant). I'm not sure whether its worth looking into all this stuff though --- it might be better simply to work on implementing an accurate pressure solver, since I don't think it would be too difficult.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1733#issuecomment-867965142
Integrability,depend,depends,"> I believe for your implementation, since the tracer values are not corrected for pressure, any leakage will be due to the advection of tracer by momentum that _is_ impacted by the pressure correction. This advection should be less with a smaller spacial step if I remember correctly. Well, I agree that less leakage implies that less tracer is advected across the boundary. But why is less tracer advected across the boundary?. It occurs to me that we are not converging to a particular solution as we refine the grid in this case, because this problem has no viscosity. Perhaps we should do a convergence test for a case with finite viscosity. We do introduce grid-scale gradients in the predictor velocity field via masking, so it does seem possible to me that the leakage / pressure gradient error might scale with resolution. It'd be nice to have a solid mathematical explanation for this behavior. Another question might be whether the leakage / error depends on the extent of the masked region (holding resolution constant). I'm not sure whether its worth looking into all this stuff though --- it might be better simply to work on implementing an accurate pressure solver, since I don't think it would be too difficult.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1733#issuecomment-867965142
Safety,predict,predictor,"> I believe for your implementation, since the tracer values are not corrected for pressure, any leakage will be due to the advection of tracer by momentum that _is_ impacted by the pressure correction. This advection should be less with a smaller spacial step if I remember correctly. Well, I agree that less leakage implies that less tracer is advected across the boundary. But why is less tracer advected across the boundary?. It occurs to me that we are not converging to a particular solution as we refine the grid in this case, because this problem has no viscosity. Perhaps we should do a convergence test for a case with finite viscosity. We do introduce grid-scale gradients in the predictor velocity field via masking, so it does seem possible to me that the leakage / pressure gradient error might scale with resolution. It'd be nice to have a solid mathematical explanation for this behavior. Another question might be whether the leakage / error depends on the extent of the masked region (holding resolution constant). I'm not sure whether its worth looking into all this stuff though --- it might be better simply to work on implementing an accurate pressure solver, since I don't think it would be too difficult.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1733#issuecomment-867965142
Testability,test,test,"> I believe for your implementation, since the tracer values are not corrected for pressure, any leakage will be due to the advection of tracer by momentum that _is_ impacted by the pressure correction. This advection should be less with a smaller spacial step if I remember correctly. Well, I agree that less leakage implies that less tracer is advected across the boundary. But why is less tracer advected across the boundary?. It occurs to me that we are not converging to a particular solution as we refine the grid in this case, because this problem has no viscosity. Perhaps we should do a convergence test for a case with finite viscosity. We do introduce grid-scale gradients in the predictor velocity field via masking, so it does seem possible to me that the leakage / pressure gradient error might scale with resolution. It'd be nice to have a solid mathematical explanation for this behavior. Another question might be whether the leakage / error depends on the extent of the masked region (holding resolution constant). I'm not sure whether its worth looking into all this stuff though --- it might be better simply to work on implementing an accurate pressure solver, since I don't think it would be too difficult.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1733#issuecomment-867965142
Usability,simpl,simply,"> I believe for your implementation, since the tracer values are not corrected for pressure, any leakage will be due to the advection of tracer by momentum that _is_ impacted by the pressure correction. This advection should be less with a smaller spacial step if I remember correctly. Well, I agree that less leakage implies that less tracer is advected across the boundary. But why is less tracer advected across the boundary?. It occurs to me that we are not converging to a particular solution as we refine the grid in this case, because this problem has no viscosity. Perhaps we should do a convergence test for a case with finite viscosity. We do introduce grid-scale gradients in the predictor velocity field via masking, so it does seem possible to me that the leakage / pressure gradient error might scale with resolution. It'd be nice to have a solid mathematical explanation for this behavior. Another question might be whether the leakage / error depends on the extent of the masked region (holding resolution constant). I'm not sure whether its worth looking into all this stuff though --- it might be better simply to work on implementing an accurate pressure solver, since I don't think it would be too difficult.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1733#issuecomment-867965142
Usability,clear,clearly,You can merge this --- the changes are clearly enough concentrated in docs.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1736#issuecomment-854990278
Usability,simpl,simpler,Branch off this branch to a new one and we can continue working there. Or branch off only the src changes and merge them. Whatever seems simpler.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1744#issuecomment-890349625
Usability,simpl,simple,"I created a new branch `glw-ncc/actual-overturning-channel-example` with the example, and I'm going to get rid of it in this PR (it'll probably simple just to copy/paste the example from that branch rather than continue developing from there when we decide to start working on it again in the future).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1744#issuecomment-903127221
Usability,feedback,feedback,Thanks for the feedback @francispoulin. Since this fixes two bugs I took the liberty of releasing a new version.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1750#issuecomment-865467286
Availability,down,down,It's all simple stuff... someone just has to sit down and do it...,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1751#issuecomment-866275736
Usability,simpl,simple,It's all simple stuff... someone just has to sit down and do it...,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1751#issuecomment-866275736
Integrability,interface,interfaces,"The difference operator doesn't use the grid metrics --- but maybe you mean the derivative / gradient operator?. Such a test would catch this issue, it's true. We could use a simple test with linear gradients. There might already be such a test, but not for all grids... ?. I think the fact that the cell spacings don't add up to the grid size could be an even worse problem because it means that integrals / budgets are not correct. But I'm not sure since the spacings at cell centers might be more important (these lines only manipulate the spacing at cell interfaces).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1755#issuecomment-866287834
Testability,test,test,"The difference operator doesn't use the grid metrics --- but maybe you mean the derivative / gradient operator?. Such a test would catch this issue, it's true. We could use a simple test with linear gradients. There might already be such a test, but not for all grids... ?. I think the fact that the cell spacings don't add up to the grid size could be an even worse problem because it means that integrals / budgets are not correct. But I'm not sure since the spacings at cell centers might be more important (these lines only manipulate the spacing at cell interfaces).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1755#issuecomment-866287834
Usability,simpl,simple,"The difference operator doesn't use the grid metrics --- but maybe you mean the derivative / gradient operator?. Such a test would catch this issue, it's true. We could use a simple test with linear gradients. There might already be such a test, but not for all grids... ?. I think the fact that the cell spacings don't add up to the grid size could be an even worse problem because it means that integrals / budgets are not correct. But I'm not sure since the spacings at cell centers might be more important (these lines only manipulate the spacing at cell interfaces).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1755#issuecomment-866287834
Usability,simpl,simpler,"I think you need. ```julia; ε = KernelFunctionOperation{Center, Center, Center}(isotropic_viscous_dissipation_rate_ccc, grid;; computed_dependencies=(u, v, w, ν)); ```. might be a good idea to implement a constructor thats consistent with the other field constructors though. Not sure which form we prefer (curly brackets, or plain function arguments). Probably the version without curly brackets is simpler.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1758#issuecomment-866548009
Usability,simpl,simple,"Agree its good to be able to build docs, but I wouldn't personally recommend building docs to debug a simple plot like this one. It'd be much slower than just running the example script.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1762#issuecomment-867200404
Usability,simpl,simple,">Agree its good to be able to build docs, but I wouldn't personally recommend building docs to debug a simple plot like this one. It'd be much slower than just running the example script. I mean, I can ""plot"" it running the script just fine. I'm doing it right now. I just don't know how it'll render when the docs are built (or if it will appear at all).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1762#issuecomment-867201125
Usability,simpl,simpler,"I've also used a slightly simpler stretching function:. ```julia; z_faces(k) = - Lz * (1 - tanh(s * (k - 1) / Nz) / tanh(s)); ```. not sure what the difference between this and the one being used in this example is, or relative benefits.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1762#issuecomment-867213169
Usability,simpl,simpler,"> I've also used a slightly simpler stretching function:; > ; > ```julia; > z_faces(k) = - Lz * (1 - tanh(s * (k - 1) / Nz) / tanh(s)); > ```; > ; > not sure what the difference between this and the one being used in this example is, or relative benefits. They're exactly the same, but I guess we should prefer your way since it's easier to understand.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1762#issuecomment-867217570
Usability,simpl,simple,"Right now with this current function for the faces the grid spacing looks like this:. ![Screenshot from 2021-06-23 16-53-31](https://user-images.githubusercontent.com/13205162/123182158-b33dc800-d443-11eb-82d6-1aac1ee34527.png). which means that the grid spacing is approximately constant at the bottom and changes rapidly at the top. I think it would be good to flip that and have Δz be approximately constant (but finer) at the top and change more rapidly at the bottom, no? I can't come up with a simple hyperbolic equation to do that though. Suggestions?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1762#issuecomment-867233421
Usability,clear,clear,"Just to be clear, I don't think that's a super important issue. We could just leave it like it is. But I do think it would be nice if the spacing varied only a little in the surface layer, which is where we care more about the physics.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1762#issuecomment-867672551
Testability,test,tests,"Yeah, I've run quite a bit of tests at this point, and the issue seems persistent and (as far as I could tell) independent of topology (although I haven't tried every single topology option). Thanks for looking into this, btw. Let's hope it's something simple. Let me know how I can help.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1764#issuecomment-868184351
Usability,simpl,simple,"Yeah, I've run quite a bit of tests at this point, and the issue seems persistent and (as far as I could tell) independent of topology (although I haven't tried every single topology option). Thanks for looking into this, btw. Let's hope it's something simple. Let me know how I can help.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1764#issuecomment-868184351
Deployability,integrat,integrated,"Profiling is a very good idea. It probably makes sense to use an integrated / application profiler (rather than simply timing functions), because WENO5 is itself composed of many small functions and we don't know which one is the bottleneck. I have never tried profiling on the GPU, but there's some info here: https://juliagpu.gitlab.io/CUDA.jl/development/profiling/. Specifically I think we need to install NSight: https://juliagpu.gitlab.io/CUDA.jl/development/profiling/#NVIDIA-Nsight-Systems",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1764#issuecomment-868829956
Integrability,integrat,integrated,"Profiling is a very good idea. It probably makes sense to use an integrated / application profiler (rather than simply timing functions), because WENO5 is itself composed of many small functions and we don't know which one is the bottleneck. I have never tried profiling on the GPU, but there's some info here: https://juliagpu.gitlab.io/CUDA.jl/development/profiling/. Specifically I think we need to install NSight: https://juliagpu.gitlab.io/CUDA.jl/development/profiling/#NVIDIA-Nsight-Systems",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1764#issuecomment-868829956
Performance,bottleneck,bottleneck,"Profiling is a very good idea. It probably makes sense to use an integrated / application profiler (rather than simply timing functions), because WENO5 is itself composed of many small functions and we don't know which one is the bottleneck. I have never tried profiling on the GPU, but there's some info here: https://juliagpu.gitlab.io/CUDA.jl/development/profiling/. Specifically I think we need to install NSight: https://juliagpu.gitlab.io/CUDA.jl/development/profiling/#NVIDIA-Nsight-Systems",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1764#issuecomment-868829956
Usability,simpl,simply,"Profiling is a very good idea. It probably makes sense to use an integrated / application profiler (rather than simply timing functions), because WENO5 is itself composed of many small functions and we don't know which one is the bottleneck. I have never tried profiling on the GPU, but there's some info here: https://juliagpu.gitlab.io/CUDA.jl/development/profiling/. Specifically I think we need to install NSight: https://juliagpu.gitlab.io/CUDA.jl/development/profiling/#NVIDIA-Nsight-Systems",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1764#issuecomment-868829956
Usability,simpl,simply,"Here's the wild thing. Calling `mean!` simply goes to this small piece of code in `Base`:. ```julia; function mean!(R::AbstractArray, A::AbstractArray); sum!(R, A; init=true); x = max(1, length(R)) // length(A); R .= R .* x ; return R; end; ```. Obviously, it seems that `sum!` is working. It's only the _subsequent_ code that doesn't work. I think this is an easy fix. The quick and dirty fix might be to define our own `mean!` with an appropriate `@sync` in it (or we can modify the subsequent lines to act on `parent(R)` rather than `R`; perhaps its the broadcasting that's screwed up). Longer term we can try to figure out why the lines after `sum!` don't always execute (?)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1767#issuecomment-868819298
Deployability,upgrade,upgrade,"Ah, thanks for that @maleadt. So microbenchmarks suggest squaring by `Float64` and `Int32` are virtually indistinguishable in simple code. Is there any way that this change is somehow affected by compiler heuristics; eg code inlining is somehow much more effective / optimized when we can invoke `nv_pow`... ? Otherwise I'm at a loss. I think prior to the changes we grouped into our ""upgrade to julia 1.6"" we were using the function `CUDA.pow` (from an ancient `CUDA.jl` version).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1770#issuecomment-869812530
Performance,optimiz,optimized,"Ah, thanks for that @maleadt. So microbenchmarks suggest squaring by `Float64` and `Int32` are virtually indistinguishable in simple code. Is there any way that this change is somehow affected by compiler heuristics; eg code inlining is somehow much more effective / optimized when we can invoke `nv_pow`... ? Otherwise I'm at a loss. I think prior to the changes we grouped into our ""upgrade to julia 1.6"" we were using the function `CUDA.pow` (from an ancient `CUDA.jl` version).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1770#issuecomment-869812530
Usability,simpl,simple,"Ah, thanks for that @maleadt. So microbenchmarks suggest squaring by `Float64` and `Int32` are virtually indistinguishable in simple code. Is there any way that this change is somehow affected by compiler heuristics; eg code inlining is somehow much more effective / optimized when we can invoke `nv_pow`... ? Otherwise I'm at a loss. I think prior to the changes we grouped into our ""upgrade to julia 1.6"" we were using the function `CUDA.pow` (from an ancient `CUDA.jl` version).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1770#issuecomment-869812530
Testability,test,tested,Thanks @hennyg888 for sharing this. I thought i tested the last PR with `WENO5` but cleared I messed up with that. Sorry.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1771#issuecomment-871689677
Usability,clear,cleared,Thanks @hennyg888 for sharing this. I thought i tested the last PR with `WENO5` but cleared I messed up with that. Sorry.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1771#issuecomment-871689677
Usability,undo,undone,"> Sure, that's what I started to do but that requires `grid` to be a positional argument in many functions --- doable thought.; > Was wondering if we can infer the float type from `ψ`? What is `ψ`, a field? Something like `eltype(ψ)(ε)` would be enough?. We need `grid` as a positional argument for other reasons so I don't think a short-term solution like using `eltype` (which would just have to be undone in the near future) is a good solution.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1771#issuecomment-873639102
Usability,clear,clear,"I am happy to say that I successflly built the docs on my local machine for the first, but not last time. @navidcy : Your instructions are very clear. The problem was with my `.julia` file, I think, but you should not have to account for this peculiar experience. Thanks to you and @tomchor for helping me along with this. I am happy to have learned more about this. Please merge away!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1772#issuecomment-869168362
Safety,avoid,avoid,> :/. Only if that will make your life simpler though. :) Just a suggestion so you avoid waiting for ever to see if the test actually fail.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1784#issuecomment-870915738
Testability,test,test,> :/. Only if that will make your life simpler though. :) Just a suggestion so you avoid waiting for ever to see if the test actually fail.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1784#issuecomment-870915738
Usability,simpl,simpler,> :/. Only if that will make your life simpler though. :) Just a suggestion so you avoid waiting for ever to see if the test actually fail.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1784#issuecomment-870915738
Safety,avoid,avoid,"> > :/; > ; > Only if that will make your life simpler though. :) Just a suggestion so you avoid waiting for ever to see if the test actually fail. I'm drinking coffee, but some might describe that as ""waiting""",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1784#issuecomment-870928976
Testability,test,test,"> > :/; > ; > Only if that will make your life simpler though. :) Just a suggestion so you avoid waiting for ever to see if the test actually fail. I'm drinking coffee, but some might describe that as ""waiting""",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1784#issuecomment-870928976
Usability,simpl,simpler,"> > :/; > ; > Only if that will make your life simpler though. :) Just a suggestion so you avoid waiting for ever to see if the test actually fail. I'm drinking coffee, but some might describe that as ""waiting""",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1784#issuecomment-870928976
Availability,error,error,"The top of the error message on #1780 is. ```; Stacktrace:; [1] overdub; @ ~/software/New_Oceananigans/Oceananigans.jl/src/Advection/upwind_biased_advective_fluxes.jl:98; [2] _advective_momentum_flux_Ww(::Int64, ::Int64, ::Int64, ::RegularRectilinearGrid{Float32, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float32, StepRangeLen{Float32, Float64, Float64}}}, ::WENO5, ::Oceananigans.Fields.ZeroField, ::OffsetArrays.OffsetArray{Float32, 3, CuDeviceArray{Float32, 3, 1}}); @ ~/software/New_Oceananigans/Oceananigans.jl/src/Advection/momentum_advection_operators.jl:16; ```. The function `_advective_momentum_flux_Ww(i, j, k, grid, scheme, W, w)` is called in `div_Uw`. Later on we see this:. ```; [6] div_Uw(::Int64, ::Int64, ::Int64, ::RegularRectilinearGrid{Float32, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float32, StepRangeLen{Float32, Float64, Float64}}}, ::WENO5, ::NamedTuple{(:u, :v, :w), Tuple{Oceananigans.Fields.ZeroField, Oceananigans.Fields.ZeroField, Oceananigans.Fields.ZeroField}}, ::OffsetArrays.OffsetArray{Float32, 3, CuDeviceArray{Float32, 3, 1}}); ```. Rewriting the error message makes it a bit clearer:. ```julia; div_Uw(::Int64, ::Int64, ::Int64, ; ::RegularRectilinearGrid{Float32, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float32, StepRangeLen{Float32, Float64, Float64}}}, ; ::WENO5, ; ::NamedTuple{(:u, :v, :w), Tuple{Oceananigans.Fields.ZeroField, Oceananigans.Fields.ZeroField, Oceananigans.Fields.ZeroField}}, ; ::OffsetArrays.OffsetArray{Float32, 3, CuDeviceArray{Float32, 3, 1}}); ```. We thus see that the first four arguments are `i, j, k, grid`, the fifth argument is `WENO5`, the sixth argument is a named tuple of `ZeroField`s, and the seventh argument is an `OffsetArray`. The sixth argument --- `U` --- is a tuple of `ZeroField`s when the default value of `background_fields.velocities` is the advecting velocity field:. https://github.com/CliMA/Oceananigans.jl/blob/78f63ff9329b15ce20c33faed11e96ebf0dbc67d/src/Models/In",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1790#issuecomment-871449828
Integrability,message,message,"The top of the error message on #1780 is. ```; Stacktrace:; [1] overdub; @ ~/software/New_Oceananigans/Oceananigans.jl/src/Advection/upwind_biased_advective_fluxes.jl:98; [2] _advective_momentum_flux_Ww(::Int64, ::Int64, ::Int64, ::RegularRectilinearGrid{Float32, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float32, StepRangeLen{Float32, Float64, Float64}}}, ::WENO5, ::Oceananigans.Fields.ZeroField, ::OffsetArrays.OffsetArray{Float32, 3, CuDeviceArray{Float32, 3, 1}}); @ ~/software/New_Oceananigans/Oceananigans.jl/src/Advection/momentum_advection_operators.jl:16; ```. The function `_advective_momentum_flux_Ww(i, j, k, grid, scheme, W, w)` is called in `div_Uw`. Later on we see this:. ```; [6] div_Uw(::Int64, ::Int64, ::Int64, ::RegularRectilinearGrid{Float32, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float32, StepRangeLen{Float32, Float64, Float64}}}, ::WENO5, ::NamedTuple{(:u, :v, :w), Tuple{Oceananigans.Fields.ZeroField, Oceananigans.Fields.ZeroField, Oceananigans.Fields.ZeroField}}, ::OffsetArrays.OffsetArray{Float32, 3, CuDeviceArray{Float32, 3, 1}}); ```. Rewriting the error message makes it a bit clearer:. ```julia; div_Uw(::Int64, ::Int64, ::Int64, ; ::RegularRectilinearGrid{Float32, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float32, StepRangeLen{Float32, Float64, Float64}}}, ; ::WENO5, ; ::NamedTuple{(:u, :v, :w), Tuple{Oceananigans.Fields.ZeroField, Oceananigans.Fields.ZeroField, Oceananigans.Fields.ZeroField}}, ; ::OffsetArrays.OffsetArray{Float32, 3, CuDeviceArray{Float32, 3, 1}}); ```. We thus see that the first four arguments are `i, j, k, grid`, the fifth argument is `WENO5`, the sixth argument is a named tuple of `ZeroField`s, and the seventh argument is an `OffsetArray`. The sixth argument --- `U` --- is a tuple of `ZeroField`s when the default value of `background_fields.velocities` is the advecting velocity field:. https://github.com/CliMA/Oceananigans.jl/blob/78f63ff9329b15ce20c33faed11e96ebf0dbc67d/src/Models/In",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1790#issuecomment-871449828
Safety,avoid,avoiding,"tVector{Float32, StepRangeLen{Float32, Float64, Float64}}}, ::WENO5, ::Oceananigans.Fields.ZeroField, ::OffsetArrays.OffsetArray{Float32, 3, CuDeviceArray{Float32, 3, 1}}); @ ~/software/New_Oceananigans/Oceananigans.jl/src/Advection/momentum_advection_operators.jl:16; ```. The function `_advective_momentum_flux_Ww(i, j, k, grid, scheme, W, w)` is called in `div_Uw`. Later on we see this:. ```; [6] div_Uw(::Int64, ::Int64, ::Int64, ::RegularRectilinearGrid{Float32, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float32, StepRangeLen{Float32, Float64, Float64}}}, ::WENO5, ::NamedTuple{(:u, :v, :w), Tuple{Oceananigans.Fields.ZeroField, Oceananigans.Fields.ZeroField, Oceananigans.Fields.ZeroField}}, ::OffsetArrays.OffsetArray{Float32, 3, CuDeviceArray{Float32, 3, 1}}); ```. Rewriting the error message makes it a bit clearer:. ```julia; div_Uw(::Int64, ::Int64, ::Int64, ; ::RegularRectilinearGrid{Float32, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float32, StepRangeLen{Float32, Float64, Float64}}}, ; ::WENO5, ; ::NamedTuple{(:u, :v, :w), Tuple{Oceananigans.Fields.ZeroField, Oceananigans.Fields.ZeroField, Oceananigans.Fields.ZeroField}}, ; ::OffsetArrays.OffsetArray{Float32, 3, CuDeviceArray{Float32, 3, 1}}); ```. We thus see that the first four arguments are `i, j, k, grid`, the fifth argument is `WENO5`, the sixth argument is a named tuple of `ZeroField`s, and the seventh argument is an `OffsetArray`. The sixth argument --- `U` --- is a tuple of `ZeroField`s when the default value of `background_fields.velocities` is the advecting velocity field:. https://github.com/CliMA/Oceananigans.jl/blob/78f63ff9329b15ce20c33faed11e96ebf0dbc67d/src/Models/IncompressibleModels/velocity_and_tracer_tendencies.jl#L140. This PR helps the compiler realize that `div_Uw` called when `U` is a tuple of `ZeroField` should return zero. By avoiding any attempt to compile a stencil for `div_Uw` when `U` is a tuple of `ZeroField` it also skips the step that produces the error.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1790#issuecomment-871449828
Usability,clear,clearer,"vection/upwind_biased_advective_fluxes.jl:98; [2] _advective_momentum_flux_Ww(::Int64, ::Int64, ::Int64, ::RegularRectilinearGrid{Float32, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float32, StepRangeLen{Float32, Float64, Float64}}}, ::WENO5, ::Oceananigans.Fields.ZeroField, ::OffsetArrays.OffsetArray{Float32, 3, CuDeviceArray{Float32, 3, 1}}); @ ~/software/New_Oceananigans/Oceananigans.jl/src/Advection/momentum_advection_operators.jl:16; ```. The function `_advective_momentum_flux_Ww(i, j, k, grid, scheme, W, w)` is called in `div_Uw`. Later on we see this:. ```; [6] div_Uw(::Int64, ::Int64, ::Int64, ::RegularRectilinearGrid{Float32, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float32, StepRangeLen{Float32, Float64, Float64}}}, ::WENO5, ::NamedTuple{(:u, :v, :w), Tuple{Oceananigans.Fields.ZeroField, Oceananigans.Fields.ZeroField, Oceananigans.Fields.ZeroField}}, ::OffsetArrays.OffsetArray{Float32, 3, CuDeviceArray{Float32, 3, 1}}); ```. Rewriting the error message makes it a bit clearer:. ```julia; div_Uw(::Int64, ::Int64, ::Int64, ; ::RegularRectilinearGrid{Float32, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float32, StepRangeLen{Float32, Float64, Float64}}}, ; ::WENO5, ; ::NamedTuple{(:u, :v, :w), Tuple{Oceananigans.Fields.ZeroField, Oceananigans.Fields.ZeroField, Oceananigans.Fields.ZeroField}}, ; ::OffsetArrays.OffsetArray{Float32, 3, CuDeviceArray{Float32, 3, 1}}); ```. We thus see that the first four arguments are `i, j, k, grid`, the fifth argument is `WENO5`, the sixth argument is a named tuple of `ZeroField`s, and the seventh argument is an `OffsetArray`. The sixth argument --- `U` --- is a tuple of `ZeroField`s when the default value of `background_fields.velocities` is the advecting velocity field:. https://github.com/CliMA/Oceananigans.jl/blob/78f63ff9329b15ce20c33faed11e96ebf0dbc67d/src/Models/IncompressibleModels/velocity_and_tracer_tendencies.jl#L140. This PR helps the compiler realize that `div_Uw` called when `U` i",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1790#issuecomment-871449828
Deployability,update,updated,"In terms of the validation experimens, from what I understand, they are created when someone does something new and the script is a proof by example, or sorts. Since they are never run in tests they do become stale, and a bunch no longer run, as has been pointed out. The same can be said for benchmarks. . Examples are great because they are continually tested and therefore updated as needed. There are a bunch, but still, I don't think as much is covered in the examples as we see in validation. It would be nice for people to see whats in validation, but if they don't work then that causes other problems. I don't claim there is a simple solution but I'm glad we're talking about it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1797#issuecomment-872510039
Security,validat,validation,"In terms of the validation experimens, from what I understand, they are created when someone does something new and the script is a proof by example, or sorts. Since they are never run in tests they do become stale, and a bunch no longer run, as has been pointed out. The same can be said for benchmarks. . Examples are great because they are continually tested and therefore updated as needed. There are a bunch, but still, I don't think as much is covered in the examples as we see in validation. It would be nice for people to see whats in validation, but if they don't work then that causes other problems. I don't claim there is a simple solution but I'm glad we're talking about it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1797#issuecomment-872510039
Testability,test,tests,"In terms of the validation experimens, from what I understand, they are created when someone does something new and the script is a proof by example, or sorts. Since they are never run in tests they do become stale, and a bunch no longer run, as has been pointed out. The same can be said for benchmarks. . Examples are great because they are continually tested and therefore updated as needed. There are a bunch, but still, I don't think as much is covered in the examples as we see in validation. It would be nice for people to see whats in validation, but if they don't work then that causes other problems. I don't claim there is a simple solution but I'm glad we're talking about it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1797#issuecomment-872510039
Usability,simpl,simple,"In terms of the validation experimens, from what I understand, they are created when someone does something new and the script is a proof by example, or sorts. Since they are never run in tests they do become stale, and a bunch no longer run, as has been pointed out. The same can be said for benchmarks. . Examples are great because they are continually tested and therefore updated as needed. There are a bunch, but still, I don't think as much is covered in the examples as we see in validation. It would be nice for people to see whats in validation, but if they don't work then that causes other problems. I don't claim there is a simple solution but I'm glad we're talking about it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1797#issuecomment-872510039
Availability,down,download,"OK, let me put my 2 cents. If we have the validations in the docs just because of the animations then we should just put the animations on YouTube or somewhere and point people there. Having the non-working versions of, e.g., `lid_cavity.jl` script in the repo and in the docs has lead many new users in the rabbit hole of figure it out. Then users feel that scripts are not working, sometimes they post an issue or ask in Slack. But who know how many other users are simply discouraged. Personally, if I download a code that includes non-working pieces of code I am very discouraged. Thus, bottom-line: I see @glwagner's point that the functionality or pipeline for maintaining healthy validations scripts (even a subset of them) then *only those* should be included in the Docs. `Sandbox`: I'm so against a `sandbox` directory! It's like keeping your trash bin in your house for ever in case there is something useful there. I used to to it all the time: I'd keep commented out code in my scripts... But I think it's a bad practice. We need to let go. The repository and the tagged versions should not include half-bake scripts and what not. I'm happy with a sandbox repository `Oceananigans.jl-sandbox` where we keep things. Or a `sandbox` branch even. Regarding this PR and what's should be kept in the Docs: I vote we keep the convergence tests in the docs and nuke the validations. I agree with the git history size issue and probably the method of including the `.png` files that @ali-ramadhan suggests would work -- I've never done it though. (btw, @ali-ramadhan, I've noticed an increase in the repo's size recently... :()",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1797#issuecomment-872556231
Deployability,pipeline,pipeline,"OK, let me put my 2 cents. If we have the validations in the docs just because of the animations then we should just put the animations on YouTube or somewhere and point people there. Having the non-working versions of, e.g., `lid_cavity.jl` script in the repo and in the docs has lead many new users in the rabbit hole of figure it out. Then users feel that scripts are not working, sometimes they post an issue or ask in Slack. But who know how many other users are simply discouraged. Personally, if I download a code that includes non-working pieces of code I am very discouraged. Thus, bottom-line: I see @glwagner's point that the functionality or pipeline for maintaining healthy validations scripts (even a subset of them) then *only those* should be included in the Docs. `Sandbox`: I'm so against a `sandbox` directory! It's like keeping your trash bin in your house for ever in case there is something useful there. I used to to it all the time: I'd keep commented out code in my scripts... But I think it's a bad practice. We need to let go. The repository and the tagged versions should not include half-bake scripts and what not. I'm happy with a sandbox repository `Oceananigans.jl-sandbox` where we keep things. Or a `sandbox` branch even. Regarding this PR and what's should be kept in the Docs: I vote we keep the convergence tests in the docs and nuke the validations. I agree with the git history size issue and probably the method of including the `.png` files that @ali-ramadhan suggests would work -- I've never done it though. (btw, @ali-ramadhan, I've noticed an increase in the repo's size recently... :()",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1797#issuecomment-872556231
Modifiability,sandbox,sandbox,"OK, let me put my 2 cents. If we have the validations in the docs just because of the animations then we should just put the animations on YouTube or somewhere and point people there. Having the non-working versions of, e.g., `lid_cavity.jl` script in the repo and in the docs has lead many new users in the rabbit hole of figure it out. Then users feel that scripts are not working, sometimes they post an issue or ask in Slack. But who know how many other users are simply discouraged. Personally, if I download a code that includes non-working pieces of code I am very discouraged. Thus, bottom-line: I see @glwagner's point that the functionality or pipeline for maintaining healthy validations scripts (even a subset of them) then *only those* should be included in the Docs. `Sandbox`: I'm so against a `sandbox` directory! It's like keeping your trash bin in your house for ever in case there is something useful there. I used to to it all the time: I'd keep commented out code in my scripts... But I think it's a bad practice. We need to let go. The repository and the tagged versions should not include half-bake scripts and what not. I'm happy with a sandbox repository `Oceananigans.jl-sandbox` where we keep things. Or a `sandbox` branch even. Regarding this PR and what's should be kept in the Docs: I vote we keep the convergence tests in the docs and nuke the validations. I agree with the git history size issue and probably the method of including the `.png` files that @ali-ramadhan suggests would work -- I've never done it though. (btw, @ali-ramadhan, I've noticed an increase in the repo's size recently... :()",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1797#issuecomment-872556231
Security,validat,validations,"OK, let me put my 2 cents. If we have the validations in the docs just because of the animations then we should just put the animations on YouTube or somewhere and point people there. Having the non-working versions of, e.g., `lid_cavity.jl` script in the repo and in the docs has lead many new users in the rabbit hole of figure it out. Then users feel that scripts are not working, sometimes they post an issue or ask in Slack. But who know how many other users are simply discouraged. Personally, if I download a code that includes non-working pieces of code I am very discouraged. Thus, bottom-line: I see @glwagner's point that the functionality or pipeline for maintaining healthy validations scripts (even a subset of them) then *only those* should be included in the Docs. `Sandbox`: I'm so against a `sandbox` directory! It's like keeping your trash bin in your house for ever in case there is something useful there. I used to to it all the time: I'd keep commented out code in my scripts... But I think it's a bad practice. We need to let go. The repository and the tagged versions should not include half-bake scripts and what not. I'm happy with a sandbox repository `Oceananigans.jl-sandbox` where we keep things. Or a `sandbox` branch even. Regarding this PR and what's should be kept in the Docs: I vote we keep the convergence tests in the docs and nuke the validations. I agree with the git history size issue and probably the method of including the `.png` files that @ali-ramadhan suggests would work -- I've never done it though. (btw, @ali-ramadhan, I've noticed an increase in the repo's size recently... :()",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1797#issuecomment-872556231
Testability,sandbox,sandbox,"OK, let me put my 2 cents. If we have the validations in the docs just because of the animations then we should just put the animations on YouTube or somewhere and point people there. Having the non-working versions of, e.g., `lid_cavity.jl` script in the repo and in the docs has lead many new users in the rabbit hole of figure it out. Then users feel that scripts are not working, sometimes they post an issue or ask in Slack. But who know how many other users are simply discouraged. Personally, if I download a code that includes non-working pieces of code I am very discouraged. Thus, bottom-line: I see @glwagner's point that the functionality or pipeline for maintaining healthy validations scripts (even a subset of them) then *only those* should be included in the Docs. `Sandbox`: I'm so against a `sandbox` directory! It's like keeping your trash bin in your house for ever in case there is something useful there. I used to to it all the time: I'd keep commented out code in my scripts... But I think it's a bad practice. We need to let go. The repository and the tagged versions should not include half-bake scripts and what not. I'm happy with a sandbox repository `Oceananigans.jl-sandbox` where we keep things. Or a `sandbox` branch even. Regarding this PR and what's should be kept in the Docs: I vote we keep the convergence tests in the docs and nuke the validations. I agree with the git history size issue and probably the method of including the `.png` files that @ali-ramadhan suggests would work -- I've never done it though. (btw, @ali-ramadhan, I've noticed an increase in the repo's size recently... :()",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1797#issuecomment-872556231
Usability,simpl,simply,"OK, let me put my 2 cents. If we have the validations in the docs just because of the animations then we should just put the animations on YouTube or somewhere and point people there. Having the non-working versions of, e.g., `lid_cavity.jl` script in the repo and in the docs has lead many new users in the rabbit hole of figure it out. Then users feel that scripts are not working, sometimes they post an issue or ask in Slack. But who know how many other users are simply discouraged. Personally, if I download a code that includes non-working pieces of code I am very discouraged. Thus, bottom-line: I see @glwagner's point that the functionality or pipeline for maintaining healthy validations scripts (even a subset of them) then *only those* should be included in the Docs. `Sandbox`: I'm so against a `sandbox` directory! It's like keeping your trash bin in your house for ever in case there is something useful there. I used to to it all the time: I'd keep commented out code in my scripts... But I think it's a bad practice. We need to let go. The repository and the tagged versions should not include half-bake scripts and what not. I'm happy with a sandbox repository `Oceananigans.jl-sandbox` where we keep things. Or a `sandbox` branch even. Regarding this PR and what's should be kept in the Docs: I vote we keep the convergence tests in the docs and nuke the validations. I agree with the git history size issue and probably the method of including the `.png` files that @ali-ramadhan suggests would work -- I've never done it though. (btw, @ali-ramadhan, I've noticed an increase in the repo's size recently... :()",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1797#issuecomment-872556231
Availability,down,download,"> But who know how many other users are simply discouraged. Personally, if I download a code that includes non-working pieces of code I am very discouraged. That's something very important to consider, I think, and I totally agree. It seems like we're converging to the ""no code is better than broken code"" perspective. Here's my pitch for this PR:. - Remove the Lid-drive cavity and Couette flow from the docs; - Keep the Convergence tests (maybe move it to the Appendix to make for a cleaner left menu); - Remove the `validation` directory from the master branch as well (that's broken code for now and it prompts users to test them and get errors); - Open another issue/PR to discuss what we'll do with the validation scripts (maybe another repo is a good idea). Thoughts?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1797#issuecomment-873153475
Security,validat,validation,"> But who know how many other users are simply discouraged. Personally, if I download a code that includes non-working pieces of code I am very discouraged. That's something very important to consider, I think, and I totally agree. It seems like we're converging to the ""no code is better than broken code"" perspective. Here's my pitch for this PR:. - Remove the Lid-drive cavity and Couette flow from the docs; - Keep the Convergence tests (maybe move it to the Appendix to make for a cleaner left menu); - Remove the `validation` directory from the master branch as well (that's broken code for now and it prompts users to test them and get errors); - Open another issue/PR to discuss what we'll do with the validation scripts (maybe another repo is a good idea). Thoughts?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1797#issuecomment-873153475
Testability,test,tests,"> But who know how many other users are simply discouraged. Personally, if I download a code that includes non-working pieces of code I am very discouraged. That's something very important to consider, I think, and I totally agree. It seems like we're converging to the ""no code is better than broken code"" perspective. Here's my pitch for this PR:. - Remove the Lid-drive cavity and Couette flow from the docs; - Keep the Convergence tests (maybe move it to the Appendix to make for a cleaner left menu); - Remove the `validation` directory from the master branch as well (that's broken code for now and it prompts users to test them and get errors); - Open another issue/PR to discuss what we'll do with the validation scripts (maybe another repo is a good idea). Thoughts?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1797#issuecomment-873153475
Usability,simpl,simply,"> But who know how many other users are simply discouraged. Personally, if I download a code that includes non-working pieces of code I am very discouraged. That's something very important to consider, I think, and I totally agree. It seems like we're converging to the ""no code is better than broken code"" perspective. Here's my pitch for this PR:. - Remove the Lid-drive cavity and Couette flow from the docs; - Keep the Convergence tests (maybe move it to the Appendix to make for a cleaner left menu); - Remove the `validation` directory from the master branch as well (that's broken code for now and it prompts users to test them and get errors); - Open another issue/PR to discuss what we'll do with the validation scripts (maybe another repo is a good idea). Thoughts?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1797#issuecomment-873153475
Usability,simpl,simplify,"As for the API, it might simplify matters to have `architecture` as a positional argument, so that we dispatch on it. So we might end up with syntax that looks something like. ```julia; grid = RegularRectilinearGrid(CPU(), float_type=Float32, size=(1, 1, 1), x=(0, 1), y=(1, 2), z=(-3, 0)); ```. We can also add an `architecture` kwarg if others think that's better, eg. ```julia; grid = RegularRectilinearGrid(architecture=CPU(), float_type=Float32, size=(1, 1, 1), x=(0, 1), y=(1, 2), z=(-3, 0)); ```. We will have to translate the `architecture` kwarg to a positional arg (so that we can dispatch on it for the purpose of `Oceananigans.Distributed`). This adds some boilerplate for all grids, but isn't ultimately a huge concern. @christophernhill might have some useful comments.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1825#issuecomment-880847069
Usability,simpl,simplicity,"How about using just one forcing function for simplicity?. I think something like this might work:. ```julia; @inline u_mask(i, j, k, grid, p) = exp(-(xnode(Face(), Center(), Center(), i, j, k, grid) - p.center)^2 / (2 * p.width^2)). @inline u_forcing_func(i, j, k, grid, clock, model_fields, p) = @inbounds - p.rate * u_mask(i, j, k, grid, p) * model_fields.u[i, j, k]. u_forcing = Forcing(u_forcing_func, discrete_form=true, parameters=(rate=1/10, center=-grid.Lz, width=grid.Lz/10)); ```. There's another example in the docs:. https://clima.github.io/OceananigansDocumentation/stable/model_setup/forcing_functions/#%22Discrete-form%22-forcing-functions",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1827#issuecomment-875666855
Availability,down,down,"Slow down of 10% when introducing `exp` could make sense. > With const rate=1/10 and DiscreteForcing things are as fast as with no forcing. Okay, that makes sense. > So this seems to be a CPU issue. So the problem is that `ContinuousForcing` is rather slow on the CPU. That is a bit annoying. Kind of like how WENO is really slow on the CPU for unknown reasons. At least we have a workaround with `DiscreteForcing`... > Would a MWE help here?. I think what would help the most is a simple benchmarking script that compares identical forcing function implementations with `ContinuousForcing` and `DiscreteForcing` to no forcing. I think we only need one forcing function, and it's probably best if its simple (eg `- p.mu * model_fields.u[i, j, k]`) and doesn't involve complicated functions like `exp`. Since it's only a CPU issue I think it's not the highest priority though (it might not be something we can easily solve either...)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1827#issuecomment-875762070
Testability,benchmark,benchmarking,"Slow down of 10% when introducing `exp` could make sense. > With const rate=1/10 and DiscreteForcing things are as fast as with no forcing. Okay, that makes sense. > So this seems to be a CPU issue. So the problem is that `ContinuousForcing` is rather slow on the CPU. That is a bit annoying. Kind of like how WENO is really slow on the CPU for unknown reasons. At least we have a workaround with `DiscreteForcing`... > Would a MWE help here?. I think what would help the most is a simple benchmarking script that compares identical forcing function implementations with `ContinuousForcing` and `DiscreteForcing` to no forcing. I think we only need one forcing function, and it's probably best if its simple (eg `- p.mu * model_fields.u[i, j, k]`) and doesn't involve complicated functions like `exp`. Since it's only a CPU issue I think it's not the highest priority though (it might not be something we can easily solve either...)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1827#issuecomment-875762070
Usability,simpl,simple,"Slow down of 10% when introducing `exp` could make sense. > With const rate=1/10 and DiscreteForcing things are as fast as with no forcing. Okay, that makes sense. > So this seems to be a CPU issue. So the problem is that `ContinuousForcing` is rather slow on the CPU. That is a bit annoying. Kind of like how WENO is really slow on the CPU for unknown reasons. At least we have a workaround with `DiscreteForcing`... > Would a MWE help here?. I think what would help the most is a simple benchmarking script that compares identical forcing function implementations with `ContinuousForcing` and `DiscreteForcing` to no forcing. I think we only need one forcing function, and it's probably best if its simple (eg `- p.mu * model_fields.u[i, j, k]`) and doesn't involve complicated functions like `exp`. Since it's only a CPU issue I think it's not the highest priority though (it might not be something we can easily solve either...)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1827#issuecomment-875762070
Usability,simpl,simple,"From talking to @ali-ramadhan , I wonder if it's as simple as adding a function to `regularize_background_field` that works for `Fields` in `background_fields.jl`. The third one below is what I think might work. I can give it a try but any thoughts are welcome. ```; regularize_background_field(X, Y, Z, f::BackgroundField{<:Function}, grid, clock) =; FunctionField{X, Y, Z}(f.func, grid; clock=clock, parameters=f.parameters). regularize_background_field(X, Y, Z, func::Function, grid, clock) =; FunctionField{X, Y, Z}(func, grid; clock=clock). regularize_background_field(X, Y, Z, ::Field, grid, clock) =; Field{X, Y, Z, arch, grid, bcs, data}. ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1831#issuecomment-875760641
Testability,test,tests,`test_dynamics.jl` has physics-based tests; `test_field.jl` has tests for `Field` construction and some simple computations (broadcasting I think). This issue regards the `IncompressibleModel` constructor (eg we want to pass a `Field` to the keyword argument `background_fields` in `IncompressibleModel`. So I think it belongs in. https://github.com/CliMA/Oceananigans.jl/blob/master/test/test_incompressible_models.jl,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1834#issuecomment-875936013
Usability,simpl,simple,`test_dynamics.jl` has physics-based tests; `test_field.jl` has tests for `Field` construction and some simple computations (broadcasting I think). This issue regards the `IncompressibleModel` constructor (eg we want to pass a `Field` to the keyword argument `background_fields` in `IncompressibleModel`. So I think it belongs in. https://github.com/CliMA/Oceananigans.jl/blob/master/test/test_incompressible_models.jl,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1834#issuecomment-875936013
Deployability,integrat,integrate,"Hmm. I think given general `u, v` we need to solve an elliptic equation to find `psi`, eg `lap(psi) = dx v - dy u`. Then the geostrophic buoyancy field is `b = f * dz(psi)`. For some boundary conditions or assumptions of homogeneity, we can possibly simplify this procedure. One could in principle use the conjugate gradient solver to write a fully general utility, though. Hopefully this task will be taken up once the hydrostatic model is operational. Some care must be taken with the geostrophic mode / computation of the geostrophic free surface displacement for the hydrostatic model. Or, given a geostrophic buoyancy field we can integrate in `z` (eg summation of `b * dz`). This would be the intent of `IntegratedField`, but nobody has implemented that yet. Absent those techniques I think the best method for idealized problems is to use a geostrophic streamfunction. This is illustrated by the Eady turbulence example:. https://github.com/CliMA/Oceananigans.jl/blob/0153dec98e58b7819ae8e1d57516fc7994694762/examples/eady_turbulence.jl#L38-L41. https://github.com/CliMA/Oceananigans.jl/blob/0153dec98e58b7819ae8e1d57516fc7994694762/examples/eady_turbulence.jl#L151-L152. It's also used in a number of validation cases, but those aren't always useful for general audiences.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1846#issuecomment-877480974
Integrability,integrat,integrate,"Hmm. I think given general `u, v` we need to solve an elliptic equation to find `psi`, eg `lap(psi) = dx v - dy u`. Then the geostrophic buoyancy field is `b = f * dz(psi)`. For some boundary conditions or assumptions of homogeneity, we can possibly simplify this procedure. One could in principle use the conjugate gradient solver to write a fully general utility, though. Hopefully this task will be taken up once the hydrostatic model is operational. Some care must be taken with the geostrophic mode / computation of the geostrophic free surface displacement for the hydrostatic model. Or, given a geostrophic buoyancy field we can integrate in `z` (eg summation of `b * dz`). This would be the intent of `IntegratedField`, but nobody has implemented that yet. Absent those techniques I think the best method for idealized problems is to use a geostrophic streamfunction. This is illustrated by the Eady turbulence example:. https://github.com/CliMA/Oceananigans.jl/blob/0153dec98e58b7819ae8e1d57516fc7994694762/examples/eady_turbulence.jl#L38-L41. https://github.com/CliMA/Oceananigans.jl/blob/0153dec98e58b7819ae8e1d57516fc7994694762/examples/eady_turbulence.jl#L151-L152. It's also used in a number of validation cases, but those aren't always useful for general audiences.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1846#issuecomment-877480974
Security,validat,validation,"Hmm. I think given general `u, v` we need to solve an elliptic equation to find `psi`, eg `lap(psi) = dx v - dy u`. Then the geostrophic buoyancy field is `b = f * dz(psi)`. For some boundary conditions or assumptions of homogeneity, we can possibly simplify this procedure. One could in principle use the conjugate gradient solver to write a fully general utility, though. Hopefully this task will be taken up once the hydrostatic model is operational. Some care must be taken with the geostrophic mode / computation of the geostrophic free surface displacement for the hydrostatic model. Or, given a geostrophic buoyancy field we can integrate in `z` (eg summation of `b * dz`). This would be the intent of `IntegratedField`, but nobody has implemented that yet. Absent those techniques I think the best method for idealized problems is to use a geostrophic streamfunction. This is illustrated by the Eady turbulence example:. https://github.com/CliMA/Oceananigans.jl/blob/0153dec98e58b7819ae8e1d57516fc7994694762/examples/eady_turbulence.jl#L38-L41. https://github.com/CliMA/Oceananigans.jl/blob/0153dec98e58b7819ae8e1d57516fc7994694762/examples/eady_turbulence.jl#L151-L152. It's also used in a number of validation cases, but those aren't always useful for general audiences.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1846#issuecomment-877480974
Usability,simpl,simplify,"Hmm. I think given general `u, v` we need to solve an elliptic equation to find `psi`, eg `lap(psi) = dx v - dy u`. Then the geostrophic buoyancy field is `b = f * dz(psi)`. For some boundary conditions or assumptions of homogeneity, we can possibly simplify this procedure. One could in principle use the conjugate gradient solver to write a fully general utility, though. Hopefully this task will be taken up once the hydrostatic model is operational. Some care must be taken with the geostrophic mode / computation of the geostrophic free surface displacement for the hydrostatic model. Or, given a geostrophic buoyancy field we can integrate in `z` (eg summation of `b * dz`). This would be the intent of `IntegratedField`, but nobody has implemented that yet. Absent those techniques I think the best method for idealized problems is to use a geostrophic streamfunction. This is illustrated by the Eady turbulence example:. https://github.com/CliMA/Oceananigans.jl/blob/0153dec98e58b7819ae8e1d57516fc7994694762/examples/eady_turbulence.jl#L38-L41. https://github.com/CliMA/Oceananigans.jl/blob/0153dec98e58b7819ae8e1d57516fc7994694762/examples/eady_turbulence.jl#L151-L152. It's also used in a number of validation cases, but those aren't always useful for general audiences.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1846#issuecomment-877480974
Deployability,integrat,integrate,"> Or, given a geostrophic buoyancy field we can integrate in z (eg summation of b * dz). This would be the intent of IntegratedField, but nobody has implemented that yet. That was more along the lines of what I was thinking. Basically showing users how to create a `u`, find out what `b` is, and then indicate if it's best to use that as `BackgroundField`, or an `Array` or something. But it seems like `IntegratedField` needs to be in place for something as simple as what I'm envisioning?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1846#issuecomment-877483764
Integrability,integrat,integrate,"> Or, given a geostrophic buoyancy field we can integrate in z (eg summation of b * dz). This would be the intent of IntegratedField, but nobody has implemented that yet. That was more along the lines of what I was thinking. Basically showing users how to create a `u`, find out what `b` is, and then indicate if it's best to use that as `BackgroundField`, or an `Array` or something. But it seems like `IntegratedField` needs to be in place for something as simple as what I'm envisioning?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1846#issuecomment-877483764
Usability,simpl,simple,"> Or, given a geostrophic buoyancy field we can integrate in z (eg summation of b * dz). This would be the intent of IntegratedField, but nobody has implemented that yet. That was more along the lines of what I was thinking. Basically showing users how to create a `u`, find out what `b` is, and then indicate if it's best to use that as `BackgroundField`, or an `Array` or something. But it seems like `IntegratedField` needs to be in place for something as simple as what I'm envisioning?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1846#issuecomment-877483764
Deployability,integrat,integrate,"> > Or, given a geostrophic buoyancy field we can integrate in z (eg summation of b * dz). This would be the intent of IntegratedField, but nobody has implemented that yet.; > ; > That was more along the lines of what I was thinking. Basically showing users how to create a `u`, find out what `b` is, and then indicate if it's best to use that as `BackgroundField`, or an `Array` or something.; > ; > But it seems like `IntegratedField` needs to be in place for something as simple as what I'm envisioning?. Just to clarify, the quoted example suggests integrating `b` to find `psi`. If `u` is a function of `y` only I think we can integrate the relation `dy(psi) = u` to find `psi`. If the geostrophic streamfunction is a function of `x, y` then I think solving an elliptic problem is required, probably?. To summarize:. * To obtain `psi(x, y, z)` from `b(x, y, z)`, we integrate the relation `b = f * dz(psi)`. `IntegratedField` is useful.; * To obtain `psi(x, y, z)` from from `u(x, y, z)`, `v(x, y, z)` I _think_ (might be worth thinking about this more) we solve the horizontal elliptic problem `hlap(psi) = dx(v) - dy(u)` at every vertical level.; * To obtain a 2D `psi(y, z)` (for example), we might be able to integrate `dy(psi) = u`. These techniques could be important when initializing from data, perhaps. I'm not sure. For example, if a 3D distribution of `T, S` were obtained from data without knowledge of the velocity field, it might make sense to initialize the problem with a geostrophic velocity field. It'd be great to have utilities for all of these cases eventually. For idealized work I think its better to specify the streamfunction `psi`. This method is demonstrated by the Eady turbulence example.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1846#issuecomment-877561795
Integrability,integrat,integrate,"> > Or, given a geostrophic buoyancy field we can integrate in z (eg summation of b * dz). This would be the intent of IntegratedField, but nobody has implemented that yet.; > ; > That was more along the lines of what I was thinking. Basically showing users how to create a `u`, find out what `b` is, and then indicate if it's best to use that as `BackgroundField`, or an `Array` or something.; > ; > But it seems like `IntegratedField` needs to be in place for something as simple as what I'm envisioning?. Just to clarify, the quoted example suggests integrating `b` to find `psi`. If `u` is a function of `y` only I think we can integrate the relation `dy(psi) = u` to find `psi`. If the geostrophic streamfunction is a function of `x, y` then I think solving an elliptic problem is required, probably?. To summarize:. * To obtain `psi(x, y, z)` from `b(x, y, z)`, we integrate the relation `b = f * dz(psi)`. `IntegratedField` is useful.; * To obtain `psi(x, y, z)` from from `u(x, y, z)`, `v(x, y, z)` I _think_ (might be worth thinking about this more) we solve the horizontal elliptic problem `hlap(psi) = dx(v) - dy(u)` at every vertical level.; * To obtain a 2D `psi(y, z)` (for example), we might be able to integrate `dy(psi) = u`. These techniques could be important when initializing from data, perhaps. I'm not sure. For example, if a 3D distribution of `T, S` were obtained from data without knowledge of the velocity field, it might make sense to initialize the problem with a geostrophic velocity field. It'd be great to have utilities for all of these cases eventually. For idealized work I think its better to specify the streamfunction `psi`. This method is demonstrated by the Eady turbulence example.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1846#issuecomment-877561795
Usability,simpl,simple,"> > Or, given a geostrophic buoyancy field we can integrate in z (eg summation of b * dz). This would be the intent of IntegratedField, but nobody has implemented that yet.; > ; > That was more along the lines of what I was thinking. Basically showing users how to create a `u`, find out what `b` is, and then indicate if it's best to use that as `BackgroundField`, or an `Array` or something.; > ; > But it seems like `IntegratedField` needs to be in place for something as simple as what I'm envisioning?. Just to clarify, the quoted example suggests integrating `b` to find `psi`. If `u` is a function of `y` only I think we can integrate the relation `dy(psi) = u` to find `psi`. If the geostrophic streamfunction is a function of `x, y` then I think solving an elliptic problem is required, probably?. To summarize:. * To obtain `psi(x, y, z)` from `b(x, y, z)`, we integrate the relation `b = f * dz(psi)`. `IntegratedField` is useful.; * To obtain `psi(x, y, z)` from from `u(x, y, z)`, `v(x, y, z)` I _think_ (might be worth thinking about this more) we solve the horizontal elliptic problem `hlap(psi) = dx(v) - dy(u)` at every vertical level.; * To obtain a 2D `psi(y, z)` (for example), we might be able to integrate `dy(psi) = u`. These techniques could be important when initializing from data, perhaps. I'm not sure. For example, if a 3D distribution of `T, S` were obtained from data without knowledge of the velocity field, it might make sense to initialize the problem with a geostrophic velocity field. It'd be great to have utilities for all of these cases eventually. For idealized work I think its better to specify the streamfunction `psi`. This method is demonstrated by the Eady turbulence example.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1846#issuecomment-877561795
Deployability,integrat,integrate,"To clarify: I think there is utility in a simple example. However, I also recommend using a streamfunction for idealized cases, since its easier to reproduce and understand. Idealized cases with simple geostrophic flows include experiments like the Eady turbulence problem, or LES cases that simulate turbulence in the presence of a simple geostrophic flow. Another class of experiments (likely more prevalent and important than LES around geostrophic flows?) are realistic / quasi-realistic simulations on the sphere initialized from data or complicated buoyancy distributions. For these it's often important to find a flow field that's in _discrete_ geostrophic balance with an arbitrary buoyancy field. We can show how to integrate the buoyancy field for this purpose; but having `IntegratedField` implemented will make it a bit cleaner. The problem of finding a streamfunction from a velocity field is likewise be important for simulations on the cubed sphere; or cases in which the grid coordinate system does not align with, for example, a geographic coordinate system. This is the case that @francispoulin was attempting to solve in #1826, I think. @navidcy may illustrate how to do this in post processing using the conjugate gradient solver in his horizontal convection example, perhaps.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1846#issuecomment-877651839
Integrability,integrat,integrate,"To clarify: I think there is utility in a simple example. However, I also recommend using a streamfunction for idealized cases, since its easier to reproduce and understand. Idealized cases with simple geostrophic flows include experiments like the Eady turbulence problem, or LES cases that simulate turbulence in the presence of a simple geostrophic flow. Another class of experiments (likely more prevalent and important than LES around geostrophic flows?) are realistic / quasi-realistic simulations on the sphere initialized from data or complicated buoyancy distributions. For these it's often important to find a flow field that's in _discrete_ geostrophic balance with an arbitrary buoyancy field. We can show how to integrate the buoyancy field for this purpose; but having `IntegratedField` implemented will make it a bit cleaner. The problem of finding a streamfunction from a velocity field is likewise be important for simulations on the cubed sphere; or cases in which the grid coordinate system does not align with, for example, a geographic coordinate system. This is the case that @francispoulin was attempting to solve in #1826, I think. @navidcy may illustrate how to do this in post processing using the conjugate gradient solver in his horizontal convection example, perhaps.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1846#issuecomment-877651839
Usability,simpl,simple,"To clarify: I think there is utility in a simple example. However, I also recommend using a streamfunction for idealized cases, since its easier to reproduce and understand. Idealized cases with simple geostrophic flows include experiments like the Eady turbulence problem, or LES cases that simulate turbulence in the presence of a simple geostrophic flow. Another class of experiments (likely more prevalent and important than LES around geostrophic flows?) are realistic / quasi-realistic simulations on the sphere initialized from data or complicated buoyancy distributions. For these it's often important to find a flow field that's in _discrete_ geostrophic balance with an arbitrary buoyancy field. We can show how to integrate the buoyancy field for this purpose; but having `IntegratedField` implemented will make it a bit cleaner. The problem of finding a streamfunction from a velocity field is likewise be important for simulations on the cubed sphere; or cases in which the grid coordinate system does not align with, for example, a geographic coordinate system. This is the case that @francispoulin was attempting to solve in #1826, I think. @navidcy may illustrate how to do this in post processing using the conjugate gradient solver in his horizontal convection example, perhaps.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1846#issuecomment-877651839
Usability,clear,clear,"@glwagner I need some help with:. - Top boundary condition: when I try constructing it with parameters, e.g.,; ```; b_surf(x, y, t, p) = p.b0 * cos(π * x / p.Lx); ```; the script does run. All the movies I made was like that. But when Documenter.jl run is it fails! I can reproduce this -- I know this is not so clear now. I tried all combinations of parameters/arguments and I can't understand what's happening. That's why I hard coded the values in the surface boundary condition at the moment. - Why do we get all these warnings from the Logger when we run the simulation? Perhaps these warnings hint something about the boundary condition issue? They seem boundary condition related... - As you can see from the movies this problem is ideal for VerticallyStretchedGrids as there for a boundary layer at the Any attempts adding a `VerticallyStretchedGrid` has given be blow ups, *even when the stretching on the grid is almost zero*, i.e., when the `VerticallyStretchedGrid` ≈ `RegularGrid`. - How do I setup the Poisson solver to obtain solution of ∇²b=0 with b(x, t) = cos(πx) and no flux boundary condition at all other walls.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1847#issuecomment-877709922
Availability,error,errors,"A more hierarchical organization of the docs is. 1. Introduction; * What's Oceananigans?; * Installation; * Writing your first script; * Do you want to save the world? (by contributing to Oceananigans); - Contributing guide; - Features that need validating; - Features that need documenting and examples; * Gallery; 2. Examples; 3. Building models, running simulations, and post processing; * Grids and computer architectures; * Fields, BoundaryCondition, and AbstractOperations; * IncompressibleModel; * HydrostaticFreeSurfaceModel; * ShallowWaterModel; * Setting initial conditions; * Diffusion, viscosity, and TurbulenceClosures; * Forcing functions; * Coriolis forces; * Buoyancy forces; * Simulation; * OutputWriters; * OutputReaders, post-processing, and plotting; 5. Useful tips; * Using Graphics Processing Units (GPUs); * Common errors and performance pitfalls; 8. Fluid dynamics and ocean physics; * Navier-Stokes and tracer conservation equations; * The hydrostatic approximation and shallow water equations; * The Boussinesq approximation and equations of state for seawater; * Rotating domains and Coriolis forces; * Diffusion, hyperdiffusion, and parameterization of subgrid processes; - Basic models for diffusive processes; - Large eddy simulation; - Boundary layer parameterization; 9. Numerical implementation; * The finite volume discretization on a staggered grid; * Interpolation, differencing, and advection schemes; * Boundary conditions and immersed boundaries; * The pressure correction method for enforcing mass conservation; * Discretization of hydrostatic and non-hydrostatic pressure; * Implicit time-stepping; * Multi-domain simulations and the cubed sphere; 10. Developer guide; 11. Appendix; * References",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1852#issuecomment-879259142
Modifiability,parameteriz,parameterization,"A more hierarchical organization of the docs is. 1. Introduction; * What's Oceananigans?; * Installation; * Writing your first script; * Do you want to save the world? (by contributing to Oceananigans); - Contributing guide; - Features that need validating; - Features that need documenting and examples; * Gallery; 2. Examples; 3. Building models, running simulations, and post processing; * Grids and computer architectures; * Fields, BoundaryCondition, and AbstractOperations; * IncompressibleModel; * HydrostaticFreeSurfaceModel; * ShallowWaterModel; * Setting initial conditions; * Diffusion, viscosity, and TurbulenceClosures; * Forcing functions; * Coriolis forces; * Buoyancy forces; * Simulation; * OutputWriters; * OutputReaders, post-processing, and plotting; 5. Useful tips; * Using Graphics Processing Units (GPUs); * Common errors and performance pitfalls; 8. Fluid dynamics and ocean physics; * Navier-Stokes and tracer conservation equations; * The hydrostatic approximation and shallow water equations; * The Boussinesq approximation and equations of state for seawater; * Rotating domains and Coriolis forces; * Diffusion, hyperdiffusion, and parameterization of subgrid processes; - Basic models for diffusive processes; - Large eddy simulation; - Boundary layer parameterization; 9. Numerical implementation; * The finite volume discretization on a staggered grid; * Interpolation, differencing, and advection schemes; * Boundary conditions and immersed boundaries; * The pressure correction method for enforcing mass conservation; * Discretization of hydrostatic and non-hydrostatic pressure; * Implicit time-stepping; * Multi-domain simulations and the cubed sphere; 10. Developer guide; 11. Appendix; * References",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1852#issuecomment-879259142
Performance,perform,performance,"A more hierarchical organization of the docs is. 1. Introduction; * What's Oceananigans?; * Installation; * Writing your first script; * Do you want to save the world? (by contributing to Oceananigans); - Contributing guide; - Features that need validating; - Features that need documenting and examples; * Gallery; 2. Examples; 3. Building models, running simulations, and post processing; * Grids and computer architectures; * Fields, BoundaryCondition, and AbstractOperations; * IncompressibleModel; * HydrostaticFreeSurfaceModel; * ShallowWaterModel; * Setting initial conditions; * Diffusion, viscosity, and TurbulenceClosures; * Forcing functions; * Coriolis forces; * Buoyancy forces; * Simulation; * OutputWriters; * OutputReaders, post-processing, and plotting; 5. Useful tips; * Using Graphics Processing Units (GPUs); * Common errors and performance pitfalls; 8. Fluid dynamics and ocean physics; * Navier-Stokes and tracer conservation equations; * The hydrostatic approximation and shallow water equations; * The Boussinesq approximation and equations of state for seawater; * Rotating domains and Coriolis forces; * Diffusion, hyperdiffusion, and parameterization of subgrid processes; - Basic models for diffusive processes; - Large eddy simulation; - Boundary layer parameterization; 9. Numerical implementation; * The finite volume discretization on a staggered grid; * Interpolation, differencing, and advection schemes; * Boundary conditions and immersed boundaries; * The pressure correction method for enforcing mass conservation; * Discretization of hydrostatic and non-hydrostatic pressure; * Implicit time-stepping; * Multi-domain simulations and the cubed sphere; 10. Developer guide; 11. Appendix; * References",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1852#issuecomment-879259142
Security,validat,validating,"A more hierarchical organization of the docs is. 1. Introduction; * What's Oceananigans?; * Installation; * Writing your first script; * Do you want to save the world? (by contributing to Oceananigans); - Contributing guide; - Features that need validating; - Features that need documenting and examples; * Gallery; 2. Examples; 3. Building models, running simulations, and post processing; * Grids and computer architectures; * Fields, BoundaryCondition, and AbstractOperations; * IncompressibleModel; * HydrostaticFreeSurfaceModel; * ShallowWaterModel; * Setting initial conditions; * Diffusion, viscosity, and TurbulenceClosures; * Forcing functions; * Coriolis forces; * Buoyancy forces; * Simulation; * OutputWriters; * OutputReaders, post-processing, and plotting; 5. Useful tips; * Using Graphics Processing Units (GPUs); * Common errors and performance pitfalls; 8. Fluid dynamics and ocean physics; * Navier-Stokes and tracer conservation equations; * The hydrostatic approximation and shallow water equations; * The Boussinesq approximation and equations of state for seawater; * Rotating domains and Coriolis forces; * Diffusion, hyperdiffusion, and parameterization of subgrid processes; - Basic models for diffusive processes; - Large eddy simulation; - Boundary layer parameterization; 9. Numerical implementation; * The finite volume discretization on a staggered grid; * Interpolation, differencing, and advection schemes; * Boundary conditions and immersed boundaries; * The pressure correction method for enforcing mass conservation; * Discretization of hydrostatic and non-hydrostatic pressure; * Implicit time-stepping; * Multi-domain simulations and the cubed sphere; 10. Developer guide; 11. Appendix; * References",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1852#issuecomment-879259142
Usability,guid,guide,"A more hierarchical organization of the docs is. 1. Introduction; * What's Oceananigans?; * Installation; * Writing your first script; * Do you want to save the world? (by contributing to Oceananigans); - Contributing guide; - Features that need validating; - Features that need documenting and examples; * Gallery; 2. Examples; 3. Building models, running simulations, and post processing; * Grids and computer architectures; * Fields, BoundaryCondition, and AbstractOperations; * IncompressibleModel; * HydrostaticFreeSurfaceModel; * ShallowWaterModel; * Setting initial conditions; * Diffusion, viscosity, and TurbulenceClosures; * Forcing functions; * Coriolis forces; * Buoyancy forces; * Simulation; * OutputWriters; * OutputReaders, post-processing, and plotting; 5. Useful tips; * Using Graphics Processing Units (GPUs); * Common errors and performance pitfalls; 8. Fluid dynamics and ocean physics; * Navier-Stokes and tracer conservation equations; * The hydrostatic approximation and shallow water equations; * The Boussinesq approximation and equations of state for seawater; * Rotating domains and Coriolis forces; * Diffusion, hyperdiffusion, and parameterization of subgrid processes; - Basic models for diffusive processes; - Large eddy simulation; - Boundary layer parameterization; 9. Numerical implementation; * The finite volume discretization on a staggered grid; * Interpolation, differencing, and advection schemes; * Boundary conditions and immersed boundaries; * The pressure correction method for enforcing mass conservation; * Discretization of hydrostatic and non-hydrostatic pressure; * Implicit time-stepping; * Multi-domain simulations and the cubed sphere; 10. Developer guide; 11. Appendix; * References",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1852#issuecomment-879259142
Availability,error,errors,"> A more hierarchical organization of the docs is; > ; > 1. Introduction; > ; > * What's Oceananigans?; > * Installation; > * Writing your first script; > 2. Examples; > 3. Model setup; > ; > * Fields, BoundaryCondition, and AbstractOperations; > * IncompressibleModel; > * HydrostaticFreeSurfaceModel; > * ShallowWaterModel; > * Setting initial conditions; > * Diffusion, viscosity, and TurbulenceClosures; > * Forcing functions; > * Coriolis forces; > * Buoyancy forces; > 4. Simulations and post processing; > ; > * Simulation; > * OutputWriters; > * OutputReaders, post-processing, and plotting; > 5. Useful tips; > ; > * Using Graphics Processing Units (GPUs); > * Common errors and performance pitfalls; > 6. Contributor's guide; > 7. Gallery (this should be way higher eventually, but we need more recent content to motivate that...); > 8. Physics and numerical implementation; > 9. Appendix. I wholeheartedly agree with this structure :)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1852#issuecomment-879265116
Performance,perform,performance,"> A more hierarchical organization of the docs is; > ; > 1. Introduction; > ; > * What's Oceananigans?; > * Installation; > * Writing your first script; > 2. Examples; > 3. Model setup; > ; > * Fields, BoundaryCondition, and AbstractOperations; > * IncompressibleModel; > * HydrostaticFreeSurfaceModel; > * ShallowWaterModel; > * Setting initial conditions; > * Diffusion, viscosity, and TurbulenceClosures; > * Forcing functions; > * Coriolis forces; > * Buoyancy forces; > 4. Simulations and post processing; > ; > * Simulation; > * OutputWriters; > * OutputReaders, post-processing, and plotting; > 5. Useful tips; > ; > * Using Graphics Processing Units (GPUs); > * Common errors and performance pitfalls; > 6. Contributor's guide; > 7. Gallery (this should be way higher eventually, but we need more recent content to motivate that...); > 8. Physics and numerical implementation; > 9. Appendix. I wholeheartedly agree with this structure :)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1852#issuecomment-879265116
Usability,guid,guide,"> A more hierarchical organization of the docs is; > ; > 1. Introduction; > ; > * What's Oceananigans?; > * Installation; > * Writing your first script; > 2. Examples; > 3. Model setup; > ; > * Fields, BoundaryCondition, and AbstractOperations; > * IncompressibleModel; > * HydrostaticFreeSurfaceModel; > * ShallowWaterModel; > * Setting initial conditions; > * Diffusion, viscosity, and TurbulenceClosures; > * Forcing functions; > * Coriolis forces; > * Buoyancy forces; > 4. Simulations and post processing; > ; > * Simulation; > * OutputWriters; > * OutputReaders, post-processing, and plotting; > 5. Useful tips; > ; > * Using Graphics Processing Units (GPUs); > * Common errors and performance pitfalls; > 6. Contributor's guide; > 7. Gallery (this should be way higher eventually, but we need more recent content to motivate that...); > 8. Physics and numerical implementation; > 9. Appendix. I wholeheartedly agree with this structure :)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1852#issuecomment-879265116
Performance,multi-thread,multi-threading,"Thanks everyone for your feedback. @vchuravy , great to know that multi-threading is built in! . I agree that profiling would be a good way to determine why we get not great efficiency. I have not used perf but we can look into it. Also, do you know of benchmarking others have done using `KernelAbstractions` on threads that we could look at for comparison?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-880844335
Testability,benchmark,benchmarking,"Thanks everyone for your feedback. @vchuravy , great to know that multi-threading is built in! . I agree that profiling would be a good way to determine why we get not great efficiency. I have not used perf but we can look into it. Also, do you know of benchmarking others have done using `KernelAbstractions` on threads that we could look at for comparison?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-880844335
Usability,feedback,feedback,"Thanks everyone for your feedback. @vchuravy , great to know that multi-threading is built in! . I agree that profiling would be a good way to determine why we get not great efficiency. I have not used perf but we can look into it. Also, do you know of benchmarking others have done using `KernelAbstractions` on threads that we could look at for comparison?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-880844335
Testability,test,testing,I put together some utilities for testing multithreading versus Base.threads for a simple kernel:. https://github.com/glwagner/multithreaded-stencils. I've used a new repo because it might be worthwhile to test threaded computations in other programming languages.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-885981005
Usability,simpl,simple,I put together some utilities for testing multithreading versus Base.threads for a simple kernel:. https://github.com/glwagner/multithreaded-stencils. I've used a new repo because it might be worthwhile to test threaded computations in other programming languages.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-885981005
Performance,multi-thread,multi-threading,"I agree that I would expect it to saturate at higher than 16 if there were 48 cores, but clearly I'm wrong. Getting another benchmark would be a good idea. I'm happy to consider the numba + parallel idea since that would be good to test the architecture. This [mini-course](https://github.com/omlins/parallel-gpu-workshop-JuliaCon21) did give some threaded examples to solve the diffusion equation in 3D. I wonder if we might want to ask Ludovic if they have done any scalings for multi-threading?. I'm happy to discuss this with @hennyg888 on Monday and see what we come up with. Others are happy to join the discussion if they like.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-886074548
Testability,benchmark,benchmark,"I agree that I would expect it to saturate at higher than 16 if there were 48 cores, but clearly I'm wrong. Getting another benchmark would be a good idea. I'm happy to consider the numba + parallel idea since that would be good to test the architecture. This [mini-course](https://github.com/omlins/parallel-gpu-workshop-JuliaCon21) did give some threaded examples to solve the diffusion equation in 3D. I wonder if we might want to ask Ludovic if they have done any scalings for multi-threading?. I'm happy to discuss this with @hennyg888 on Monday and see what we come up with. Others are happy to join the discussion if they like.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-886074548
Usability,clear,clearly,"I agree that I would expect it to saturate at higher than 16 if there were 48 cores, but clearly I'm wrong. Getting another benchmark would be a good idea. I'm happy to consider the numba + parallel idea since that would be good to test the architecture. This [mini-course](https://github.com/omlins/parallel-gpu-workshop-JuliaCon21) did give some threaded examples to solve the diffusion equation in 3D. I wonder if we might want to ask Ludovic if they have done any scalings for multi-threading?. I'm happy to discuss this with @hennyg888 on Monday and see what we come up with. Others are happy to join the discussion if they like.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-886074548
Testability,benchmark,benchmark,"I am open to trying whatever simple example you suggest @christophernhill , but I'm not sure what you mean by stream benchmark. Sorry.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-886218106
Usability,simpl,simple,"I am open to trying whatever simple example you suggest @christophernhill , but I'm not sure what you mean by stream benchmark. Sorry.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-886218106
Testability,log,log,"We could also introduce a new log level, eg `TIMINGS` or something. Might not be good to hijack `@debug` --- it's used for other stuff, so the timing logs might get buried. Like this 100-iteration simulation:. ```; Debug: PreconditionedConjugateGradientSolver 9, |r|: 2.0861651135626188e-13; └ @ Oceananigans.Solvers ~/Projects/Oceananigans.jl/src/Solvers/preconditioned_conjugate_gradient_solver.jl:185; ┌ Debug: PreconditionedConjugateGradientSolver 9, ρ: 4.352084881045736e-26; └ @ Oceananigans.Solvers ~/Projects/Oceananigans.jl/src/Solvers/preconditioned_conjugate_gradient_solver.jl:192; ┌ Debug: PreconditionedConjugateGradientSolver 9, |z|: 2.0861651135626188e-13; └ @ Oceananigans.Solvers ~/Projects/Oceananigans.jl/src/Solvers/preconditioned_conjugate_gradient_solver.jl:193; ┌ Debug: Launching kernel broadcast_xy! with worksize (128, 1); └ @ Oceananigans.Utils ~/Projects/Oceananigans.jl/src/Utils/kernel_launching.jl:85; ┌ Debug: PreconditionedConjugateGradientSolver 9, β: 0.1312038209706307; └ @ Oceananigans.Solvers ~/Projects/Oceananigans.jl/src/Solvers/preconditioned_conjugate_gradient_solver.jl:201; ┌ Debug: Launching kernel _fill_west_halo! with worksize (1, 1); └ @ Oceananigans.Utils ~/Projects/Oceananigans.jl/src/Utils/kernel_launching.jl:85; ┌ Debug: Launching kernel _fill_east_halo! with worksize (1, 1); └ @ Oceananigans.Utils ~/Projects/Oceananigans.jl/src/Utils/kernel_launching.jl:85; ┌ Debug: Launching kernel _implicit_free_surface_linear_operation! with worksize (128, 1); └ @ Oceananigans.Utils ~/Projects/Oceananigans.jl/src/Utils/kernel_launching.jl:85; ┌ Debug: Launching kernel _fill_west_halo! with worksize (1, 1); └ @ Oceananigans.Utils ~/Projects/Oceananigans.jl/src/Utils/kernel_launching.jl:85; ┌ Debug: Launching kernel _fill_east_halo! with worksize (1, 1); └ @ Oceananigans.Utils ~/Projects/Oceananigans.jl/src/Utils/kernel_launching.jl:85; ┌ Debug: PreconditionedConjugateGradientSolver 9, |q|: 3.772383893402093e-14; └ @ Oceananigans.Solvers ~/Proje",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1862#issuecomment-882111021
Usability,progress bar,progress bars,"east_west_u_velocity! with worksize (1, 1); └ @ Oceananigans.Utils ~/Projects/Oceananigans.jl/src/Utils/kernel_launching.jl:85; ┌ Debug: Launching kernel _fill_bottom_halo! with worksize (128, 1); └ @ Oceananigans.Utils ~/Projects/Oceananigans.jl/src/Utils/kernel_launching.jl:85; ┌ Debug: Launching kernel _fill_top_halo! with worksize (128, 1); └ @ Oceananigans.Utils ~/Projects/Oceananigans.jl/src/Utils/kernel_launching.jl:85; ┌ Debug: Launching kernel _fill_west_halo! with worksize (1, 1); └ @ Oceananigans.Utils ~/Projects/Oceananigans.jl/src/Utils/kernel_launching.jl:85; ┌ Debug: Launching kernel _fill_east_halo! with worksize (1, 1); └ @ Oceananigans.Utils ~/Projects/Oceananigans.jl/src/Utils/kernel_launching.jl:85; ┌ Debug: Launching kernel _fill_bottom_halo! with worksize (128, 1); └ @ Oceananigans.Utils ~/Projects/Oceananigans.jl/src/Utils/kernel_launching.jl:85; ┌ Debug: Launching kernel _fill_top_halo! with worksize (128, 1); └ @ Oceananigans.Utils ~/Projects/Oceananigans.jl/src/Utils/kernel_launching.jl:85; ┌ Debug: Launching kernel _fill_west_halo! with worksize (1, 1); └ @ Oceananigans.Utils ~/Projects/Oceananigans.jl/src/Utils/kernel_launching.jl:85; ┌ Debug: Launching kernel _fill_east_halo! with worksize (1, 1); └ @ Oceananigans.Utils ~/Projects/Oceananigans.jl/src/Utils/kernel_launching.jl:85; ┌ Debug: Launching kernel _fill_west_halo! with worksize (1, 1); └ @ Oceananigans.Utils ~/Projects/Oceananigans.jl/src/Utils/kernel_launching.jl:85; ┌ Debug: Launching kernel _fill_east_halo! with worksize (1, 1); └ @ Oceananigans.Utils ~/Projects/Oceananigans.jl/src/Utils/kernel_launching.jl:85; ┌ Debug: Launching kernel _fill_bottom_halo! with worksize (128, 1); └ @ Oceananigans.Utils ~/Projects/Oceananigans.jl/src/Utils/kernel_launching.jl:85; ```. I think I'll try to pepper a few `@info` here and there when resolving this issue. Ultimately it'd be slick to have some cool wigits, spinners, and progress bars like what happens when julia precompiles packages...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1862#issuecomment-882111021
Testability,test,test,"I see some stuff like `N2` in the [plankton example](https://clima.github.io/OceananigansDocumentation/stable/generated/convecting_plankton/#Boundary-conditions), which is a fixed problem parameter used in the BC but isn't a `const`. I haven't tried to test if making this a constant speeds up things, but I guess I should, no? Should I make a PR to make those alterations?. P.S.: I'm not super clear on which cases defining things as a const helps or not. I just know that the general rule is use something as a `const` if it really isn't gonna change in the problem. That general rule comes from the julia docs.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-881673256
Usability,clear,clear,"I see some stuff like `N2` in the [plankton example](https://clima.github.io/OceananigansDocumentation/stable/generated/convecting_plankton/#Boundary-conditions), which is a fixed problem parameter used in the BC but isn't a `const`. I haven't tried to test if making this a constant speeds up things, but I guess I should, no? Should I make a PR to make those alterations?. P.S.: I'm not super clear on which cases defining things as a const helps or not. I just know that the general rule is use something as a `const` if it really isn't gonna change in the problem. That general rule comes from the julia docs.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-881673256
Modifiability,variab,variable,"Also to be clear, declaring something as `const`, and then inserting that variable's value into another data structure does not guarantee that the value in the second data structure is fixed. `const` attaches to a name and does not ""propagate"" into other data structures like `ContinuousBoundaryFunction.parameters`. So things like the following are valid:. ```julia; julia> mutable struct Test{T}; a :: T; end. julia> const b = 2; 2. julia> t = Test(b); Test{Int64}(2). julia> t.a = 3; 3. julia> t; Test{Int64}(3); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-881686691
Usability,clear,clear,"Also to be clear, declaring something as `const`, and then inserting that variable's value into another data structure does not guarantee that the value in the second data structure is fixed. `const` attaches to a name and does not ""propagate"" into other data structures like `ContinuousBoundaryFunction.parameters`. So things like the following are valid:. ```julia; julia> mutable struct Test{T}; a :: T; end. julia> const b = 2; 2. julia> t = Test(b); Test{Int64}(2). julia> t.a = 3; 3. julia> t; Test{Int64}(3); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-881686691
Usability,clear,clearer,@francispoulin does it also make sense to write these divergences as two-dimensional (in xy) since that's what we are restricted to for ShallowWaterModel? It might make the code clearer.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1866#issuecomment-881938607
Usability,clear,clear,"Maybe part of my confusion is on whether the solution fields, `uh,vh,h`, are cell averaged quantities or not. If they are then do we need to multipy by the area?. Maybe having docs on the finite volume method, as discussed previously, would help to clear some of this up?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1866#issuecomment-882704896
Testability,test,test,"@glwagner : I don't know that this approaches achieves the high order that we can achieve and I am happy to try something else. . Also, it would be nice to have a test that does this. The test that we have for advection assumes that `h` is constant initially, and that migth be too simple to see whether we always achieve the high order that we want to achieve.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1866#issuecomment-1116367010
Usability,simpl,simple,"@glwagner : I don't know that this approaches achieves the high order that we can achieve and I am happy to try something else. . Also, it would be nice to have a test that does this. The test that we have for advection assumes that `h` is constant initially, and that migth be too simple to see whether we always achieve the high order that we want to achieve.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1866#issuecomment-1116367010
Usability,simpl,simply,"> > oh @glwagner, did you already did this in #1867?; > > If so then close this... :) (and link #1620 to #1867); > ; > No, I didn't! #1867 is just an issue, not a PR. ?. I simply got confused... :)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1870#issuecomment-882051618
Usability,clear,clear,"> The horizontal convection example with a boundary layer at the top is ideal for a VerticallyStretchedRectilinearGrid. I'm not sure I agree with this statement though. Just to be clear: I'm not saying I disagree, it's just not obvious to me that that's the case. From the videos in the example the viscous boundary layer seems pretty well-resolved to me (unless you're planning on changing the Pr (or Ra) number?). Plus the turbulence pretty much covers the whole domain, so I don't think we'd want a very coarse grid at the bottom. Is there a metric to look at to gauge the ""resolvedness"" of the viscous boundary layer?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1872#issuecomment-882572666
Usability,clear,clearly,Please go ahead @glwagner and get this started. I am happy to help where I can but clearly you understand what needs to be done here better than I do.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1874#issuecomment-882739134
Usability,simpl,simply,"I am open to trying something different with how vorticity is computed. I computed it exactly and used those analytical expressions, but this is a pain when you want to consider a different jet, and you have to compute this again. If we can simply state the initial velocity and height, and then compute the voriticty, that migth be easier.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1874#issuecomment-882740823
Modifiability,flexible,flexible,"> I am open to trying something different with how vorticity is computed. I computed it exactly and used those analytical expressions, but this is a pain when you want to consider a different jet, and you have to compute this again. If we can simply state the initial velocity and height, and then compute the voriticty, that migth be easier. Right! In addition to being more flexible and illustrating the diagnostic procedure in general, a discrete calculation is more ""exact"" than an analytical expression.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1874#issuecomment-882750311
Usability,simpl,simply,"> I am open to trying something different with how vorticity is computed. I computed it exactly and used those analytical expressions, but this is a pain when you want to consider a different jet, and you have to compute this again. If we can simply state the initial velocity and height, and then compute the voriticty, that migth be easier. Right! In addition to being more flexible and illustrating the diagnostic procedure in general, a discrete calculation is more ""exact"" than an analytical expression.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1874#issuecomment-882750311
Modifiability,flexible,flexible,"> > I am open to trying something different with how vorticity is computed. I computed it exactly and used those analytical expressions, but this is a pain when you want to consider a different jet, and you have to compute this again. If we can simply state the initial velocity and height, and then compute the voriticty, that migth be easier.; > ; > Right! In addition to being more flexible and illustrating the diagnostic procedure in general, a discrete calculation is more ""exact"" than an analytical expression. I am puzzled by your statement here. A discrete, i.e. numerical calculation, is more exact than the analytical (so called exact) expression? . I guess it's more appropriate for the discretization that we are using, which is probably the point you are making. Okay, I see that and agree it's probably the better way to go.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1874#issuecomment-882755027
Usability,simpl,simply,"> > I am open to trying something different with how vorticity is computed. I computed it exactly and used those analytical expressions, but this is a pain when you want to consider a different jet, and you have to compute this again. If we can simply state the initial velocity and height, and then compute the voriticty, that migth be easier.; > ; > Right! In addition to being more flexible and illustrating the diagnostic procedure in general, a discrete calculation is more ""exact"" than an analytical expression. I am puzzled by your statement here. A discrete, i.e. numerical calculation, is more exact than the analytical (so called exact) expression? . I guess it's more appropriate for the discretization that we are using, which is probably the point you are making. Okay, I see that and agree it's probably the better way to go.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1874#issuecomment-882755027
Deployability,continuous,continuous,"> > > I am open to trying something different with how vorticity is computed. I computed it exactly and used those analytical expressions, but this is a pain when you want to consider a different jet, and you have to compute this again. If we can simply state the initial velocity and height, and then compute the voriticty, that migth be easier.; > > ; > > ; > > Right! In addition to being more flexible and illustrating the diagnostic procedure in general, a discrete calculation is more ""exact"" than an analytical expression.; > ; > I am puzzled by your statement here. A discrete, i.e. numerical calculation, is more exact than the analytical (so called exact) expression?; > ; > I guess it's more appropriate for the discretization that we are using, which is probably the point you are making. Okay, I see that and agree it's probably the better way to go. Correct. There's a ""discrete vorticity"". The analytically calculated vorticity is close to the discrete vorticity, but not exactly equal to it. For example, the perturbation vorticity in the current definition may not be initially zero, even if there were no noise. If the ""mean vorticity"" were calculated discretely, then the perturbation vorticity would be identically zero initially. A similar concept holds for geostrophic balance. There is a discrete geostrophic balance condition contains in a model that's stratified and rotating. This discrete condition is close to, but not exactly identical to the continuous geostrophic balance condition. This point has to do with approximation / discretization in general, through for some discretization (eg spectral decompositions), discrete representations may be closer to continuous analytical representations.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1874#issuecomment-882757399
Modifiability,flexible,flexible,"> > > I am open to trying something different with how vorticity is computed. I computed it exactly and used those analytical expressions, but this is a pain when you want to consider a different jet, and you have to compute this again. If we can simply state the initial velocity and height, and then compute the voriticty, that migth be easier.; > > ; > > ; > > Right! In addition to being more flexible and illustrating the diagnostic procedure in general, a discrete calculation is more ""exact"" than an analytical expression.; > ; > I am puzzled by your statement here. A discrete, i.e. numerical calculation, is more exact than the analytical (so called exact) expression?; > ; > I guess it's more appropriate for the discretization that we are using, which is probably the point you are making. Okay, I see that and agree it's probably the better way to go. Correct. There's a ""discrete vorticity"". The analytically calculated vorticity is close to the discrete vorticity, but not exactly equal to it. For example, the perturbation vorticity in the current definition may not be initially zero, even if there were no noise. If the ""mean vorticity"" were calculated discretely, then the perturbation vorticity would be identically zero initially. A similar concept holds for geostrophic balance. There is a discrete geostrophic balance condition contains in a model that's stratified and rotating. This discrete condition is close to, but not exactly identical to the continuous geostrophic balance condition. This point has to do with approximation / discretization in general, through for some discretization (eg spectral decompositions), discrete representations may be closer to continuous analytical representations.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1874#issuecomment-882757399
Usability,simpl,simply,"> > > I am open to trying something different with how vorticity is computed. I computed it exactly and used those analytical expressions, but this is a pain when you want to consider a different jet, and you have to compute this again. If we can simply state the initial velocity and height, and then compute the voriticty, that migth be easier.; > > ; > > ; > > Right! In addition to being more flexible and illustrating the diagnostic procedure in general, a discrete calculation is more ""exact"" than an analytical expression.; > ; > I am puzzled by your statement here. A discrete, i.e. numerical calculation, is more exact than the analytical (so called exact) expression?; > ; > I guess it's more appropriate for the discretization that we are using, which is probably the point you are making. Okay, I see that and agree it's probably the better way to go. Correct. There's a ""discrete vorticity"". The analytically calculated vorticity is close to the discrete vorticity, but not exactly equal to it. For example, the perturbation vorticity in the current definition may not be initially zero, even if there were no noise. If the ""mean vorticity"" were calculated discretely, then the perturbation vorticity would be identically zero initially. A similar concept holds for geostrophic balance. There is a discrete geostrophic balance condition contains in a model that's stratified and rotating. This discrete condition is close to, but not exactly identical to the continuous geostrophic balance condition. This point has to do with approximation / discretization in general, through for some discretization (eg spectral decompositions), discrete representations may be closer to continuous analytical representations.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1874#issuecomment-882757399
Usability,clear,clear,"~One other option that might be easier to implement is to keep the store the tuple in `model.closures`, but only store the total viscosity (the sum of all closures in the tuple) in `model.diffusivities`. Maybe we'd have to rename it as `model.diffusivities.ν_tot` and `model.diffusivities.κ_tot` .~. ~I think that's as clear, but simpler.~. Scratch that! I was thinking of a specific example I had in mind and forgot that not every closure can be simplified to the sum of diffusivities times the nabla operator.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1878#issuecomment-883517465
Availability,down,downside,"Yeah I think this change would help! It would definitely make things; clearer. Here's a couple alternative thoughts though:. Would it be possible to get rid of diffusivities altogether and store the; precomputed fields in the closures directly? E.g. AMD would have an extra; field data, so would smagorinsky and so on. I think it'd simplify things,; although I'm not sure how feasible that would be. I guess in order to; calculate those, the closure would need to already be associated with a; model, so that's a downside right away... Another thought: why not just also store the constant viscosities in the; diffusivities property? I know it's not necessary, but it wouldn't take up; any significant space and it would make things more intuitive/organized I; think. On Tue, Jul 20, 2021, 12:40 Gregory L. Wagner ***@***.***>; wrote:. > Ah I see the confusion. The field model.diffusivities stores viscosities; > and diffusivities that have to be precomputed. For diffusivities prescribed; > as constants or functions we don't need to store the diffusivities; instead; > the information needed to compute the diffusivity or viscosity is bound to; > model.closure.; >; > Perhaps we could call this model property ""diffusivity_fields""? This would; > distinguish the information there from constant or function diffusivities.; >; > —; > You are receiving this because you authored the thread.; > Reply to this email directly, view it on GitHub; > <https://github.com/CliMA/Oceananigans.jl/issues/1878#issuecomment-883645905>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/ADEX5KSF44HXRQARFRTAQ6DTYXGJNANCNFSM5AV5LNJQ>; > .; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1878#issuecomment-883658908
Usability,clear,clearer,"Yeah I think this change would help! It would definitely make things; clearer. Here's a couple alternative thoughts though:. Would it be possible to get rid of diffusivities altogether and store the; precomputed fields in the closures directly? E.g. AMD would have an extra; field data, so would smagorinsky and so on. I think it'd simplify things,; although I'm not sure how feasible that would be. I guess in order to; calculate those, the closure would need to already be associated with a; model, so that's a downside right away... Another thought: why not just also store the constant viscosities in the; diffusivities property? I know it's not necessary, but it wouldn't take up; any significant space and it would make things more intuitive/organized I; think. On Tue, Jul 20, 2021, 12:40 Gregory L. Wagner ***@***.***>; wrote:. > Ah I see the confusion. The field model.diffusivities stores viscosities; > and diffusivities that have to be precomputed. For diffusivities prescribed; > as constants or functions we don't need to store the diffusivities; instead; > the information needed to compute the diffusivity or viscosity is bound to; > model.closure.; >; > Perhaps we could call this model property ""diffusivity_fields""? This would; > distinguish the information there from constant or function diffusivities.; >; > —; > You are receiving this because you authored the thread.; > Reply to this email directly, view it on GitHub; > <https://github.com/CliMA/Oceananigans.jl/issues/1878#issuecomment-883645905>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/ADEX5KSF44HXRQARFRTAQ6DTYXGJNANCNFSM5AV5LNJQ>; > .; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1878#issuecomment-883658908
Modifiability,refactor,refactor,"> Storing constant values in diffusivities is possible, but could be interpreted as boilerplate. The coefficients need to be stored in closure, because that's where users specify them. So copying the constants or functions into diffusivities (this would have to be done individually for all closures) requires additional code. We don't have that many closures that would need this though, right? I think only `IsotropicConstant`, `AnisotropicConstant` and the biharmonic one that I see in the docs. (I think you have a TKE-based one that isn't listed in the docs also?). > I think of all the changes to diffusivities, the one that makes the most sense is to eliminate that field and change the API so that grid is a required argument for closures that have fields associated with them. This is a substantial internal refactor, but perhaps someone wants to take it up?. I like this option, but keeping the user from creating a closure without a grid seems a bit counter-productive... It's still not clear to me which one I'd vote for. For the time being, should we do something for the problem title refers to?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1878#issuecomment-883732045
Usability,clear,clear,"> Storing constant values in diffusivities is possible, but could be interpreted as boilerplate. The coefficients need to be stored in closure, because that's where users specify them. So copying the constants or functions into diffusivities (this would have to be done individually for all closures) requires additional code. We don't have that many closures that would need this though, right? I think only `IsotropicConstant`, `AnisotropicConstant` and the biharmonic one that I see in the docs. (I think you have a TKE-based one that isn't listed in the docs also?). > I think of all the changes to diffusivities, the one that makes the most sense is to eliminate that field and change the API so that grid is a required argument for closures that have fields associated with them. This is a substantial internal refactor, but perhaps someone wants to take it up?. I like this option, but keeping the user from creating a closure without a grid seems a bit counter-productive... It's still not clear to me which one I'd vote for. For the time being, should we do something for the problem title refers to?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1878#issuecomment-883732045
Usability,simpl,simplest,"Just for the record, @glwagner and I decided to go with [this suggestion](https://github.com/CliMA/Oceananigans.jl/issues/1878#issuecomment-883645905) which is the simplest for the time being. The naming is more intuitive and (with the new name) is makes sense that an empty element is created when a closure doesn't require an auxiliary field.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1878#issuecomment-884589510
Integrability,interface,interface,"Ah, I see. I thought it was validated. > Perhaps you can come up with a nice validation experiment that we can use to gain confidence that it works correctly, and then add some documentation?. It's hard for me to come up with a validation experiment for that I think. Are we testing that the viscosities are calculated and added correctly? (Thus a simple analytical example might suffice or an example where we just add two constant diffusities.) Or are we testing that the interface is working?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1879#issuecomment-883511439
Security,validat,validated,"Ah, I see. I thought it was validated. > Perhaps you can come up with a nice validation experiment that we can use to gain confidence that it works correctly, and then add some documentation?. It's hard for me to come up with a validation experiment for that I think. Are we testing that the viscosities are calculated and added correctly? (Thus a simple analytical example might suffice or an example where we just add two constant diffusities.) Or are we testing that the interface is working?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1879#issuecomment-883511439
Testability,test,testing,"Ah, I see. I thought it was validated. > Perhaps you can come up with a nice validation experiment that we can use to gain confidence that it works correctly, and then add some documentation?. It's hard for me to come up with a validation experiment for that I think. Are we testing that the viscosities are calculated and added correctly? (Thus a simple analytical example might suffice or an example where we just add two constant diffusities.) Or are we testing that the interface is working?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1879#issuecomment-883511439
Usability,simpl,simple,"Ah, I see. I thought it was validated. > Perhaps you can come up with a nice validation experiment that we can use to gain confidence that it works correctly, and then add some documentation?. It's hard for me to come up with a validation experiment for that I think. Are we testing that the viscosities are calculated and added correctly? (Thus a simple analytical example might suffice or an example where we just add two constant diffusities.) Or are we testing that the interface is working?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1879#issuecomment-883511439
Usability,learn,learn,"I have tried running the library `ImplicitGlobalGrid.jl`in 1, 2 and 4 gpus and have actually found rather bad scaling as well, 57 and 35 percent. I have created an issue and hope they might have some suggestions as to how to improve the results. Maybe what I learn there might be transferable to Oceananigans?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-885260173
Usability,learn,learn,"> I have tried running the library `ImplicitGlobalGrid.jl`in 1, 2 and 4 gpus and have actually found rather bad scaling as well, 57 and 35 percent.; > ; > I have created an issue and hope they might have some suggestions as to how to improve the results. Maybe what I learn there might be transferable to Oceananigans?. This then sounds to me like you don't have a working CUDA-aware MPI. IGG should show >90% efficiency",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-885287770
Availability,down,downloaded,"> I have tried running the library `ImplicitGlobalGrid.jl`in 1, 2 and 4 gpus and have actually found rather bad scaling as well, 57 and 35 percent.; > ; > I have created an issue and hope they might have some suggestions as to how to improve the results. Maybe what I learn there might be transferable to Oceananigans?. @francispoulin (see my above comment). I think ImplictGlobalGrid.jl as downloaded is not configured to run across multiple GPUs. I added a line in a fork here ( https://github.com/christophernhill/ImplicitGlobalGrid.jl/blob/5e4fd0698b7087467d9314bfa253d6bc9a09a40a/diffusion3D_multigpu_CuArrays_novis.jl#L21 ) that is needed. With that I saw reasonable weak scaling - even with broken CUDA aware MPI support. Oceananigans.jl has some other things going on. I agree profiling with nvprof/nsight would be great. This link https://github.com/mit-satori/getting-started/blob/master/tutorial-examples/nvprof-profiling/Satori_NVProf_Intro.pdf and this https://mit-satori.github.io/tutorial-examples/nvprof-profiling/index.html?highlight=profiling might be helpful to get started. The slides also have links to various NVidia bits of documentation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-885336918
Modifiability,config,configured,"> I have tried running the library `ImplicitGlobalGrid.jl`in 1, 2 and 4 gpus and have actually found rather bad scaling as well, 57 and 35 percent.; > ; > I have created an issue and hope they might have some suggestions as to how to improve the results. Maybe what I learn there might be transferable to Oceananigans?. @francispoulin (see my above comment). I think ImplictGlobalGrid.jl as downloaded is not configured to run across multiple GPUs. I added a line in a fork here ( https://github.com/christophernhill/ImplicitGlobalGrid.jl/blob/5e4fd0698b7087467d9314bfa253d6bc9a09a40a/diffusion3D_multigpu_CuArrays_novis.jl#L21 ) that is needed. With that I saw reasonable weak scaling - even with broken CUDA aware MPI support. Oceananigans.jl has some other things going on. I agree profiling with nvprof/nsight would be great. This link https://github.com/mit-satori/getting-started/blob/master/tutorial-examples/nvprof-profiling/Satori_NVProf_Intro.pdf and this https://mit-satori.github.io/tutorial-examples/nvprof-profiling/index.html?highlight=profiling might be helpful to get started. The slides also have links to various NVidia bits of documentation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-885336918
Usability,learn,learn,"> I have tried running the library `ImplicitGlobalGrid.jl`in 1, 2 and 4 gpus and have actually found rather bad scaling as well, 57 and 35 percent.; > ; > I have created an issue and hope they might have some suggestions as to how to improve the results. Maybe what I learn there might be transferable to Oceananigans?. @francispoulin (see my above comment). I think ImplictGlobalGrid.jl as downloaded is not configured to run across multiple GPUs. I added a line in a fork here ( https://github.com/christophernhill/ImplicitGlobalGrid.jl/blob/5e4fd0698b7087467d9314bfa253d6bc9a09a40a/diffusion3D_multigpu_CuArrays_novis.jl#L21 ) that is needed. With that I saw reasonable weak scaling - even with broken CUDA aware MPI support. Oceananigans.jl has some other things going on. I agree profiling with nvprof/nsight would be great. This link https://github.com/mit-satori/getting-started/blob/master/tutorial-examples/nvprof-profiling/Satori_NVProf_Intro.pdf and this https://mit-satori.github.io/tutorial-examples/nvprof-profiling/index.html?highlight=profiling might be helpful to get started. The slides also have links to various NVidia bits of documentation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-885336918
Usability,learn,learn,"> > I have tried running the library `ImplicitGlobalGrid.jl`in 1, 2 and 4 gpus and have actually found rather bad scaling as well, 57 and 35 percent.; > > I have created an issue and hope they might have some suggestions as to how to improve the results. Maybe what I learn there might be transferable to Oceananigans?; > ; > This then sounds to me like you don't have a working CUDA-aware MPI. IGG should show >90% efficiency. Thanks @vchuravy . The runs for IGG were on a server that has CUDA-aware MPI, so that's not the problem. As @christophernhill points out, there are a lot of other possibilities though.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-885359367
Availability,down,down,"> As I said, please post your slurp script and other environment options. It is impossible to debug otherwise.; > ; > I have an annotated slurp script here https://github.com/CliMA/ClimateMachine.jl/wiki/Satori-Cluster which is what I used a while back for GPU scaling tests. A mossconfigured MPI can easily manifest itself as scaling this poor. @hennyg888 has been very busy this week so hasn't had a chance to response. The slurm script that he used was passed down from @christophernhill , and I will let him share that with you, but it might not happen until Monday. But I suppose I should learn to start running stuff on Satori as that is something that everyone else can use and people understand the configuration. I'll try to do that on Monday.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-885360274
Deployability,configurat,configuration,"> As I said, please post your slurp script and other environment options. It is impossible to debug otherwise.; > ; > I have an annotated slurp script here https://github.com/CliMA/ClimateMachine.jl/wiki/Satori-Cluster which is what I used a while back for GPU scaling tests. A mossconfigured MPI can easily manifest itself as scaling this poor. @hennyg888 has been very busy this week so hasn't had a chance to response. The slurm script that he used was passed down from @christophernhill , and I will let him share that with you, but it might not happen until Monday. But I suppose I should learn to start running stuff on Satori as that is something that everyone else can use and people understand the configuration. I'll try to do that on Monday.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-885360274
Modifiability,config,configuration,"> As I said, please post your slurp script and other environment options. It is impossible to debug otherwise.; > ; > I have an annotated slurp script here https://github.com/CliMA/ClimateMachine.jl/wiki/Satori-Cluster which is what I used a while back for GPU scaling tests. A mossconfigured MPI can easily manifest itself as scaling this poor. @hennyg888 has been very busy this week so hasn't had a chance to response. The slurm script that he used was passed down from @christophernhill , and I will let him share that with you, but it might not happen until Monday. But I suppose I should learn to start running stuff on Satori as that is something that everyone else can use and people understand the configuration. I'll try to do that on Monday.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-885360274
Testability,test,tests,"> As I said, please post your slurp script and other environment options. It is impossible to debug otherwise.; > ; > I have an annotated slurp script here https://github.com/CliMA/ClimateMachine.jl/wiki/Satori-Cluster which is what I used a while back for GPU scaling tests. A mossconfigured MPI can easily manifest itself as scaling this poor. @hennyg888 has been very busy this week so hasn't had a chance to response. The slurm script that he used was passed down from @christophernhill , and I will let him share that with you, but it might not happen until Monday. But I suppose I should learn to start running stuff on Satori as that is something that everyone else can use and people understand the configuration. I'll try to do that on Monday.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-885360274
Usability,learn,learn,"> As I said, please post your slurp script and other environment options. It is impossible to debug otherwise.; > ; > I have an annotated slurp script here https://github.com/CliMA/ClimateMachine.jl/wiki/Satori-Cluster which is what I used a while back for GPU scaling tests. A mossconfigured MPI can easily manifest itself as scaling this poor. @hennyg888 has been very busy this week so hasn't had a chance to response. The slurm script that he used was passed down from @christophernhill , and I will let him share that with you, but it might not happen until Monday. But I suppose I should learn to start running stuff on Satori as that is something that everyone else can use and people understand the configuration. I'll try to do that on Monday.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-885360274
Availability,down,downloaded,"> > I have tried running the library `ImplicitGlobalGrid.jl`in 1, 2 and 4 gpus and have actually found rather bad scaling as well, 57 and 35 percent.; > > I have created an issue and hope they might have some suggestions as to how to improve the results. Maybe what I learn there might be transferable to Oceananigans?; > ; > @francispoulin (see my above comment). I think ImplictGlobalGrid.jl as downloaded is not configured to run across multiple GPUs. I added a line in a fork here ( https://github.com/christophernhill/ImplicitGlobalGrid.jl/blob/5e4fd0698b7087467d9314bfa253d6bc9a09a40a/diffusion3D_multigpu_CuArrays_novis.jl#L21 ) that is needed. With that I saw reasonable weak scaling - even with broken CUDA aware MPI support. Oceananigans.jl has some other things going on.; > ; > I agree profiling with nvprof/nsight would be great. This link https://github.com/mit-satori/getting-started/blob/master/tutorial-examples/nvprof-profiling/Satori_NVProf_Intro.pdf and this https://mit-satori.github.io/tutorial-examples/nvprof-profiling/index.html?highlight=profiling might be helpful to get started. The slides also have links to various NVidia bits of documentation. Thanks @christophernhill for all this information. This will be most helpful. Unfortunately, tomorrow I am busy from 9am to 5pm so I don't think I can zoom, but maybe on Monday? I'll try and look into these resources before hand.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-885360570
Modifiability,config,configured,"> > I have tried running the library `ImplicitGlobalGrid.jl`in 1, 2 and 4 gpus and have actually found rather bad scaling as well, 57 and 35 percent.; > > I have created an issue and hope they might have some suggestions as to how to improve the results. Maybe what I learn there might be transferable to Oceananigans?; > ; > @francispoulin (see my above comment). I think ImplictGlobalGrid.jl as downloaded is not configured to run across multiple GPUs. I added a line in a fork here ( https://github.com/christophernhill/ImplicitGlobalGrid.jl/blob/5e4fd0698b7087467d9314bfa253d6bc9a09a40a/diffusion3D_multigpu_CuArrays_novis.jl#L21 ) that is needed. With that I saw reasonable weak scaling - even with broken CUDA aware MPI support. Oceananigans.jl has some other things going on.; > ; > I agree profiling with nvprof/nsight would be great. This link https://github.com/mit-satori/getting-started/blob/master/tutorial-examples/nvprof-profiling/Satori_NVProf_Intro.pdf and this https://mit-satori.github.io/tutorial-examples/nvprof-profiling/index.html?highlight=profiling might be helpful to get started. The slides also have links to various NVidia bits of documentation. Thanks @christophernhill for all this information. This will be most helpful. Unfortunately, tomorrow I am busy from 9am to 5pm so I don't think I can zoom, but maybe on Monday? I'll try and look into these resources before hand.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-885360570
Usability,learn,learn,"> > I have tried running the library `ImplicitGlobalGrid.jl`in 1, 2 and 4 gpus and have actually found rather bad scaling as well, 57 and 35 percent.; > > I have created an issue and hope they might have some suggestions as to how to improve the results. Maybe what I learn there might be transferable to Oceananigans?; > ; > @francispoulin (see my above comment). I think ImplictGlobalGrid.jl as downloaded is not configured to run across multiple GPUs. I added a line in a fork here ( https://github.com/christophernhill/ImplicitGlobalGrid.jl/blob/5e4fd0698b7087467d9314bfa253d6bc9a09a40a/diffusion3D_multigpu_CuArrays_novis.jl#L21 ) that is needed. With that I saw reasonable weak scaling - even with broken CUDA aware MPI support. Oceananigans.jl has some other things going on.; > ; > I agree profiling with nvprof/nsight would be great. This link https://github.com/mit-satori/getting-started/blob/master/tutorial-examples/nvprof-profiling/Satori_NVProf_Intro.pdf and this https://mit-satori.github.io/tutorial-examples/nvprof-profiling/index.html?highlight=profiling might be helpful to get started. The slides also have links to various NVidia bits of documentation. Thanks @christophernhill for all this information. This will be most helpful. Unfortunately, tomorrow I am busy from 9am to 5pm so I don't think I can zoom, but maybe on Monday? I'll try and look into these resources before hand.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-885360570
Performance,optimiz,optimize,"Another thought for @christophernhill . At the talk today on `ImplicitGlobalGrid.jl`, they were using `@view` in the simplest code but they dropped it as soon as they started to optimize the code. I believe they started using `LazyArrays.jl`. I don't know what it is but I suspect it doesn't have the problems that `@view` might have.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-885901320
Usability,simpl,simplest,"Another thought for @christophernhill . At the talk today on `ImplicitGlobalGrid.jl`, they were using `@view` in the simplest code but they dropped it as soon as they started to optimize the code. I believe they started using `LazyArrays.jl`. I don't know what it is but I suspect it doesn't have the problems that `@view` might have.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-885901320
Performance,optimiz,optimize,"> Another thought for @christophernhill; > ; > At the talk today on `ImplicitGlobalGrid.jl`, they were using `@view` in the simplest code but they dropped it as soon as they started to optimize the code. I believe they started using `LazyArrays.jl`. I don't know what it is but I suspect it doesn't have the problems that `@view` might have. We think that we cannot send non-contiguous data over MPI between GPUs (only CPUs). Thus certain `view`s will not work. Possibly in this case the data is transferred to CPU, sent over MPI, and then copied back to the GPU (slow).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-885935875
Usability,simpl,simplest,"> Another thought for @christophernhill; > ; > At the talk today on `ImplicitGlobalGrid.jl`, they were using `@view` in the simplest code but they dropped it as soon as they started to optimize the code. I believe they started using `LazyArrays.jl`. I don't know what it is but I suspect it doesn't have the problems that `@view` might have. We think that we cannot send non-contiguous data over MPI between GPUs (only CPUs). Thus certain `view`s will not work. Possibly in this case the data is transferred to CPU, sent over MPI, and then copied back to the GPU (slow).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-885935875
Performance,optimiz,optimize,"> Another thought for @christophernhill; > ; > At the talk today on `ImplicitGlobalGrid.jl`, they were using `@view` in the simplest code but they dropped it as soon as they started to optimize the code. I believe they started using `LazyArrays.jl`. I don't know what it is but I suspect it doesn't have the problems that `@view` might have. @francispoulin thanks. I think we probably just want to do some buffer. I looked at LazyArrays.jl and I could imagine how that could maybe also be included, but I suspect the main thing is having a buffer (which https://github.com/eth-cscs/ImplicitGlobalGrid.jl has). I don't see any sign of LazyArrays in https://github.com/eth-cscs/ImplicitGlobalGrid.jl code! We can check with Ludovic though.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-885972875
Usability,simpl,simplest,"> Another thought for @christophernhill; > ; > At the talk today on `ImplicitGlobalGrid.jl`, they were using `@view` in the simplest code but they dropped it as soon as they started to optimize the code. I believe they started using `LazyArrays.jl`. I don't know what it is but I suspect it doesn't have the problems that `@view` might have. @francispoulin thanks. I think we probably just want to do some buffer. I looked at LazyArrays.jl and I could imagine how that could maybe also be included, but I suspect the main thing is having a buffer (which https://github.com/eth-cscs/ImplicitGlobalGrid.jl has). I don't see any sign of LazyArrays in https://github.com/eth-cscs/ImplicitGlobalGrid.jl code! We can check with Ludovic though.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-885972875
Usability,simpl,simple,"> @francispoulin thanks. I think we probably just want to do some buffer. I looked at LazyArrays.jl and I could imagine how that could maybe also be included, but I suspect the main thing is having a buffer (which https://github.com/eth-cscs/ImplicitGlobalGrid.jl has). I don't see any sign of LazyArrays in https://github.com/eth-cscs/ImplicitGlobalGrid.jl code! We can check with Ludovic though. Thanks for looking at this @christophernhill and sorry that I misquoted. At the JuliaCon talk yesterday, they started off talking about a simple repo and then ended up talking about `ImplicitGlobalGrid.jl`. The link I should have given was [this](https://github.com/omlins/parallel-gpu-workshop-JuliaCon21). . If you think that buffering is the way to go then I'm certainly happy to give that a try. Maybe we can have a zoom meeting this week to discuss in more detail?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-886074108
Availability,down,downsides,"> When the model is created the velocities and tracers are initialized to 0 so I think the diffusivity is zero then (typically...)? I believe this is the case in your example --- isn't it correct that the diffusivities are zero?. Not in this case because it ends up not adding the molecular viscosity. > To cover the case that explicit tracer and velocity fields are supplied to a model with non-zero values, we could call update_state! in the constructor --- not a bad idea at all. That just requires changing this line:. I think this makes things more intuitive, no? Are there any downsides besides a slightly longer building time for `model`?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1889#issuecomment-885268477
Usability,intuit,intuitive,"> When the model is created the velocities and tracers are initialized to 0 so I think the diffusivity is zero then (typically...)? I believe this is the case in your example --- isn't it correct that the diffusivities are zero?. Not in this case because it ends up not adding the molecular viscosity. > To cover the case that explicit tracer and velocity fields are supplied to a model with non-zero values, we could call update_state! in the constructor --- not a bad idea at all. That just requires changing this line:. I think this makes things more intuitive, no? Are there any downsides besides a slightly longer building time for `model`?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1889#issuecomment-885268477
Availability,down,downsides,"> I think this makes things more intuitive, no? Are there any downsides besides a slightly longer building time for `model`?. There's no downside. `update_state!` has to be efficient for the model to run so I don't think there's a performance issue. I think it's more ""correct"", since without that call the auxiliary state may be wrong initially.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1889#issuecomment-885340708
Energy Efficiency,efficient,efficient,"> I think this makes things more intuitive, no? Are there any downsides besides a slightly longer building time for `model`?. There's no downside. `update_state!` has to be efficient for the model to run so I don't think there's a performance issue. I think it's more ""correct"", since without that call the auxiliary state may be wrong initially.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1889#issuecomment-885340708
Performance,perform,performance,"> I think this makes things more intuitive, no? Are there any downsides besides a slightly longer building time for `model`?. There's no downside. `update_state!` has to be efficient for the model to run so I don't think there's a performance issue. I think it's more ""correct"", since without that call the auxiliary state may be wrong initially.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1889#issuecomment-885340708
Usability,intuit,intuitive,"> I think this makes things more intuitive, no? Are there any downsides besides a slightly longer building time for `model`?. There's no downside. `update_state!` has to be efficient for the model to run so I don't think there's a performance issue. I think it's more ""correct"", since without that call the auxiliary state may be wrong initially.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1889#issuecomment-885340708
Usability,simpl,simple,"From #1372:. > On the other hand, it's a bit confusing that all Coriolis forces ultimately represent a ""background rotation rate""... Yeah I agree this might make it a bit confusing. For now I didn't delete anything and created `GeneralFPlane` as a placeholder. Would it be too bad to just have `FPlane` and let it default to `rotation_axis=ZDIrection()`? I think this is simple and would do the job well enough.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-886096063
Modifiability,refactor,refactoring,"On a refactoring note, currently `ZDirection` is defined here https://github.com/CliMA/Oceananigans.jl/blob/fafdf3c7caa6aa1431b9d6437036794ec5dcb8fc/src/BuoyancyModels/buoyancy.jl#L6. Which is after `Coriolis/coriolis.jl` is compiled. I think it makes more sense to move this definition to `Grids`. Everyone okay with that? That way any other module can use it (and I can use in Coriolis). I also think would be useful to use something like `validate_vertical_unit_vector()` to validate the rotation axis: https://github.com/CliMA/Oceananigans.jl/blob/fafdf3c7caa6aa1431b9d6437036794ec5dcb8fc/src/BuoyancyModels/buoyancy.jl#L37. So I was thinking of moving this to `Utils` (or maybe even `Grids`?) and renaming it to `validate_unit_vector()`. Since this would be refactoring code, I'll wait for some feedback before doing these modifications.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-886097464
Security,validat,validate,"On a refactoring note, currently `ZDirection` is defined here https://github.com/CliMA/Oceananigans.jl/blob/fafdf3c7caa6aa1431b9d6437036794ec5dcb8fc/src/BuoyancyModels/buoyancy.jl#L6. Which is after `Coriolis/coriolis.jl` is compiled. I think it makes more sense to move this definition to `Grids`. Everyone okay with that? That way any other module can use it (and I can use in Coriolis). I also think would be useful to use something like `validate_vertical_unit_vector()` to validate the rotation axis: https://github.com/CliMA/Oceananigans.jl/blob/fafdf3c7caa6aa1431b9d6437036794ec5dcb8fc/src/BuoyancyModels/buoyancy.jl#L37. So I was thinking of moving this to `Utils` (or maybe even `Grids`?) and renaming it to `validate_unit_vector()`. Since this would be refactoring code, I'll wait for some feedback before doing these modifications.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-886097464
Usability,feedback,feedback,"On a refactoring note, currently `ZDirection` is defined here https://github.com/CliMA/Oceananigans.jl/blob/fafdf3c7caa6aa1431b9d6437036794ec5dcb8fc/src/BuoyancyModels/buoyancy.jl#L6. Which is after `Coriolis/coriolis.jl` is compiled. I think it makes more sense to move this definition to `Grids`. Everyone okay with that? That way any other module can use it (and I can use in Coriolis). I also think would be useful to use something like `validate_vertical_unit_vector()` to validate the rotation axis: https://github.com/CliMA/Oceananigans.jl/blob/fafdf3c7caa6aa1431b9d6437036794ec5dcb8fc/src/BuoyancyModels/buoyancy.jl#L37. So I was thinking of moving this to `Utils` (or maybe even `Grids`?) and renaming it to `validate_unit_vector()`. Since this would be refactoring code, I'll wait for some feedback before doing these modifications.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-886097464
Integrability,interface,interface,"As of right now, as far as I can tell, `GeneralFPlane` is working and `NonTraditionalFPlane` got dumped. I'd like to get some feedback before I start changing the docs if that's okay. The interface I implemented is a bit simpler than `NonTraditionalFPlane` but I think that's okay. I'd like some feedback there if possible. Arguments now are:. - `coriolis_frequency` (instead of simply `f`). Defaults to `2Ω`; - `rotation_axis` (defaults to `ZDirection`); - `latitude` for convenience (which overwrites `rotation_axis`). I'm a bit unsure if I should keep this one. Maybe we should keep it simple since anyone can figure out `f` based on latitude easily. Questions:. - Should we keep the original `FPlane`? I think we could scrap it and only keep this one (which would then be renamed `FPlane`); - I didn't see any tests that `FPlane` or any other Coriolis implementation is dynamically correct. Should we implement a test to see if our rotation implementations are actually doing what they're supposed to?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-887056354
Testability,test,tests,"As of right now, as far as I can tell, `GeneralFPlane` is working and `NonTraditionalFPlane` got dumped. I'd like to get some feedback before I start changing the docs if that's okay. The interface I implemented is a bit simpler than `NonTraditionalFPlane` but I think that's okay. I'd like some feedback there if possible. Arguments now are:. - `coriolis_frequency` (instead of simply `f`). Defaults to `2Ω`; - `rotation_axis` (defaults to `ZDirection`); - `latitude` for convenience (which overwrites `rotation_axis`). I'm a bit unsure if I should keep this one. Maybe we should keep it simple since anyone can figure out `f` based on latitude easily. Questions:. - Should we keep the original `FPlane`? I think we could scrap it and only keep this one (which would then be renamed `FPlane`); - I didn't see any tests that `FPlane` or any other Coriolis implementation is dynamically correct. Should we implement a test to see if our rotation implementations are actually doing what they're supposed to?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-887056354
Usability,feedback,feedback,"As of right now, as far as I can tell, `GeneralFPlane` is working and `NonTraditionalFPlane` got dumped. I'd like to get some feedback before I start changing the docs if that's okay. The interface I implemented is a bit simpler than `NonTraditionalFPlane` but I think that's okay. I'd like some feedback there if possible. Arguments now are:. - `coriolis_frequency` (instead of simply `f`). Defaults to `2Ω`; - `rotation_axis` (defaults to `ZDirection`); - `latitude` for convenience (which overwrites `rotation_axis`). I'm a bit unsure if I should keep this one. Maybe we should keep it simple since anyone can figure out `f` based on latitude easily. Questions:. - Should we keep the original `FPlane`? I think we could scrap it and only keep this one (which would then be renamed `FPlane`); - I didn't see any tests that `FPlane` or any other Coriolis implementation is dynamically correct. Should we implement a test to see if our rotation implementations are actually doing what they're supposed to?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-887056354
Usability,feedback,feedback,"> > Closes #1372; > > For now I just wanted to save up the calculations. Once we decide how to implement the feature I'll finish the PR.; > ; > I've been asked to review --- is this still the state of this PR?. No it's not. Thanks, I forgot to change that. . It's now ready for review with the caveat that I'd like to wait until I get feedback on how it's working to change the docs if that's okay, as per [this comment](https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-887056354). I just wanna make sure you're all okay with the changes in functionality. But lmk if that's not okay and I'll change the docs too.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-887512348
Integrability,interface,interface,"> As of right now, as far as I can tell, `GeneralFPlane` is working and `NonTraditionalFPlane` got dumped. I'd like to get some feedback before I start changing the docs if that's okay.; > ; > The interface I implemented is a bit simpler than `NonTraditionalFPlane` but I think that's okay. I'd like some feedback there if possible. Arguments now are:; > ; > * `coriolis_frequency` (instead of simply `f`). Defaults to `2Ω`; > * `rotation_axis` (defaults to `ZDirection`); > * `latitude` for convenience (which overwrites `rotation_axis`). I'm a bit unsure if I should keep this one. Maybe we should keep it simple since anyone can figure out `f` based on latitude easily.; > ; > Questions:; > ; > * Should we keep the original `FPlane`? I think we could scrap it and only keep this one (which would then be renamed `FPlane`); > * I didn't see any tests that `FPlane` or any other Coriolis implementation is dynamically correct. Should we implement a test to see if our rotation implementations are actually doing what they're supposed to?. For API this is what I suggest:. Three ""modes"":. 1. A ""primitive"" mode whereby fx, fy, fz are all explicitly provided.; 2. A ""general rotation"" mode whereby `rotation_axis` and `rotation_rate` are provided. `fx`, `fy`, and `fz` are then calculated as a convenience.; 3. A ""tangent plane"" mode whereby `latitude` and `rotation_rate` are provided. This mode calculates `rotation_axis` based on `latitude` (and assuming that `y` is north-south). The code might look something like. ```julia; zero_if_nothing(f) = f; zero_if_nothing(::Nothing) = 0. function ConstantBackgroundRotation(FT=Float64; fx=nothing, fy=nothing, fz=nothing, rotation_rate=Ω_Earth, rotation_axis=nothing, latitude=nothing). if latitude !=nothing; isnothing(rotation_axis) && throw(ArgumentError(""Cannot specify latitude and rotation axis."")); all(isnothing.((fx, fy, fz)) || throw(ArgumentError(""Cannot specify latitude and (fx, fy, fz)."")); # calculate rotation axis; end. if rotation_axis",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-887527990
Performance,optimiz,optimization," based on latitude easily.; > ; > Questions:; > ; > * Should we keep the original `FPlane`? I think we could scrap it and only keep this one (which would then be renamed `FPlane`); > * I didn't see any tests that `FPlane` or any other Coriolis implementation is dynamically correct. Should we implement a test to see if our rotation implementations are actually doing what they're supposed to?. For API this is what I suggest:. Three ""modes"":. 1. A ""primitive"" mode whereby fx, fy, fz are all explicitly provided.; 2. A ""general rotation"" mode whereby `rotation_axis` and `rotation_rate` are provided. `fx`, `fy`, and `fz` are then calculated as a convenience.; 3. A ""tangent plane"" mode whereby `latitude` and `rotation_rate` are provided. This mode calculates `rotation_axis` based on `latitude` (and assuming that `y` is north-south). The code might look something like. ```julia; zero_if_nothing(f) = f; zero_if_nothing(::Nothing) = 0. function ConstantBackgroundRotation(FT=Float64; fx=nothing, fy=nothing, fz=nothing, rotation_rate=Ω_Earth, rotation_axis=nothing, latitude=nothing). if latitude !=nothing; isnothing(rotation_axis) && throw(ArgumentError(""Cannot specify latitude and rotation axis."")); all(isnothing.((fx, fy, fz)) || throw(ArgumentError(""Cannot specify latitude and (fx, fy, fz)."")); # calculate rotation axis; end. if rotation_axis != nothing; all(isnothing.((fx, fy, fz)) || throw(ArgumentError(""Cannot specify rotation_axis and (fx, fy, fz)."")); # calculate fx, fy, fz; end. fx, fy, fz = zero_if_nothing.((fx, fy, fz)) # set default fx, fy, fz. return ConstantBackgroundRotation(FT(fx), FT(fy), FT(fz)); end; ```. There's also the possibility of a somewhat minor optimization by keeping the possibility that `fx, fy, fz` might be `nothing`, and eliding the associated Coriolis operations in kernel functions for that case. This requires the struct to accomodate different types for each of them. I think `GeneralFPlane` is ambiguous, so I propose using a more specific name.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-887527990
Testability,test,tests,"> As of right now, as far as I can tell, `GeneralFPlane` is working and `NonTraditionalFPlane` got dumped. I'd like to get some feedback before I start changing the docs if that's okay.; > ; > The interface I implemented is a bit simpler than `NonTraditionalFPlane` but I think that's okay. I'd like some feedback there if possible. Arguments now are:; > ; > * `coriolis_frequency` (instead of simply `f`). Defaults to `2Ω`; > * `rotation_axis` (defaults to `ZDirection`); > * `latitude` for convenience (which overwrites `rotation_axis`). I'm a bit unsure if I should keep this one. Maybe we should keep it simple since anyone can figure out `f` based on latitude easily.; > ; > Questions:; > ; > * Should we keep the original `FPlane`? I think we could scrap it and only keep this one (which would then be renamed `FPlane`); > * I didn't see any tests that `FPlane` or any other Coriolis implementation is dynamically correct. Should we implement a test to see if our rotation implementations are actually doing what they're supposed to?. For API this is what I suggest:. Three ""modes"":. 1. A ""primitive"" mode whereby fx, fy, fz are all explicitly provided.; 2. A ""general rotation"" mode whereby `rotation_axis` and `rotation_rate` are provided. `fx`, `fy`, and `fz` are then calculated as a convenience.; 3. A ""tangent plane"" mode whereby `latitude` and `rotation_rate` are provided. This mode calculates `rotation_axis` based on `latitude` (and assuming that `y` is north-south). The code might look something like. ```julia; zero_if_nothing(f) = f; zero_if_nothing(::Nothing) = 0. function ConstantBackgroundRotation(FT=Float64; fx=nothing, fy=nothing, fz=nothing, rotation_rate=Ω_Earth, rotation_axis=nothing, latitude=nothing). if latitude !=nothing; isnothing(rotation_axis) && throw(ArgumentError(""Cannot specify latitude and rotation axis."")); all(isnothing.((fx, fy, fz)) || throw(ArgumentError(""Cannot specify latitude and (fx, fy, fz)."")); # calculate rotation axis; end. if rotation_axis",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-887527990
Usability,feedback,feedback,"> As of right now, as far as I can tell, `GeneralFPlane` is working and `NonTraditionalFPlane` got dumped. I'd like to get some feedback before I start changing the docs if that's okay.; > ; > The interface I implemented is a bit simpler than `NonTraditionalFPlane` but I think that's okay. I'd like some feedback there if possible. Arguments now are:; > ; > * `coriolis_frequency` (instead of simply `f`). Defaults to `2Ω`; > * `rotation_axis` (defaults to `ZDirection`); > * `latitude` for convenience (which overwrites `rotation_axis`). I'm a bit unsure if I should keep this one. Maybe we should keep it simple since anyone can figure out `f` based on latitude easily.; > ; > Questions:; > ; > * Should we keep the original `FPlane`? I think we could scrap it and only keep this one (which would then be renamed `FPlane`); > * I didn't see any tests that `FPlane` or any other Coriolis implementation is dynamically correct. Should we implement a test to see if our rotation implementations are actually doing what they're supposed to?. For API this is what I suggest:. Three ""modes"":. 1. A ""primitive"" mode whereby fx, fy, fz are all explicitly provided.; 2. A ""general rotation"" mode whereby `rotation_axis` and `rotation_rate` are provided. `fx`, `fy`, and `fz` are then calculated as a convenience.; 3. A ""tangent plane"" mode whereby `latitude` and `rotation_rate` are provided. This mode calculates `rotation_axis` based on `latitude` (and assuming that `y` is north-south). The code might look something like. ```julia; zero_if_nothing(f) = f; zero_if_nothing(::Nothing) = 0. function ConstantBackgroundRotation(FT=Float64; fx=nothing, fy=nothing, fz=nothing, rotation_rate=Ω_Earth, rotation_axis=nothing, latitude=nothing). if latitude !=nothing; isnothing(rotation_axis) && throw(ArgumentError(""Cannot specify latitude and rotation axis."")); all(isnothing.((fx, fy, fz)) || throw(ArgumentError(""Cannot specify latitude and (fx, fy, fz)."")); # calculate rotation axis; end. if rotation_axis",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-887527990
Usability,simpl,simplified,"> For API this is what I suggest:; > ; > Three ""modes"":; > ; > 1. A ""primitive"" mode whereby fx, fy, fz are all explicitly provided.; > 2. A ""general rotation"" mode whereby `rotation_axis` and `rotation_rate` are provided. `fx`, `fy`, and `fz` are then calculated as a convenience.; > 3. A ""tangent plane"" mode whereby `latitude` and `rotation_rate` are provided. This mode calculates `rotation_axis` based on `latitude` (and assuming that `y` is north-south). Thanks for the suggestion. That was kind of the API for `NonTradFPlane`. I actually think three modes is kinda overkill and it makes the constructor function unnecessarily complicated (which is why I simplified it this time), especially since it's really not hard to calculate one mode from another one. I'd suggest keeping two of them as a compromise: ""general rotation"" (to match the API in `Buoyancy`) and ""tangent plane"". What do you think?. > I think `GeneralFPlane` is ambiguous, so I propose using a more specific name. I completely agree. I used `GeneralFPlane` more as placeholder. But as you pointed out in #1372, `ConstantBackgroundRotation` is also kinda ambiguous since every rotation we have is technically a constant background rotation at its core. How about get descriptive and call it `ArbitraryAxisFPlane`?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-887537661
Usability,simpl,simplified,"> > For API this is what I suggest:; > > Three ""modes"":; > > ; > > 1. A ""primitive"" mode whereby fx, fy, fz are all explicitly provided.; > > 2. A ""general rotation"" mode whereby `rotation_axis` and `rotation_rate` are provided. `fx`, `fy`, and `fz` are then calculated as a convenience.; > > 3. A ""tangent plane"" mode whereby `latitude` and `rotation_rate` are provided. This mode calculates `rotation_axis` based on `latitude` (and assuming that `y` is north-south).; > ; > Thanks for the suggestion. That was kind of the API for `NonTradFPlane`. I actually think three modes is kinda overkill and it makes the constructor function unnecessarily complicated (which is why I simplified it this time), especially since it's really not hard to calculate one mode from another one. I'd suggest keeping two of them as a compromise: ""general rotation"" (to match the API in `Buoyancy`) and ""tangent plane"". What do you think?; > ; > > I think `GeneralFPlane` is ambiguous, so I propose using a more specific name.; > ; > I completely agree. I used `GeneralFPlane` more as placeholder. But as you pointed out in #1372, `ConstantBackgroundRotation` is also kinda ambiguous since every rotation we have is technically a constant background rotation at its core. How about get descriptive and call it `ArbitraryAxisFPlane`?. I made my suggestion because I disagree that supporting those keyword arguments is overkill. I am arguing that the complexity of the constructor is justified because. 1) not supporting this API moves part of the ""complexity"" from the constructor into user scripts, which is very undesirable in general; 2) having a consistent API with `FPlane` and `BetaPlane` (which both support a `latitude` keyword argument) is important; 3) I think it really is a useful and friendly simplification to abstract the projection of the rotation axis into a plane tangent with a spherical surface (I have personally benefited from this abstraction for setting up examples like the one proposed in #1744",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-887606452
Usability,simpl,simplification,"> I made my suggestion because I disagree that supporting those keyword arguments is overkill. I am arguing that the complexity of the constructor is justified because; > ; > 1. not supporting this API moves part of the ""complexity"" from the constructor into user scripts, which is very undesirable in general; > 2. having a consistent API with `FPlane` and `BetaPlane` (which both support a `latitude` keyword argument) is important; > 3. I think it really is a useful and friendly simplification to abstract the projection of the rotation axis into a plane tangent with a spherical surface (I have personally benefited from this abstraction for setting up examples like the one proposed in [Overturning, eddying channel example following Abernathey et al. 2011 #1744](https://github.com/CliMA/Oceananigans.jl/pull/1744), which I feel implies that many other users will also benefit). Fair enough. I was leaning towards simplicity as per our last conversation about simplifying the code to make it easier for development and (mostly) because I think a sine/cosine multiplication doesn't add much complexity on the user side. But it seems I'm voted out so I'll implement those functionalities back :)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-887626059
Usability,clear,clear," > ; > The thing is that `BetaPlane` is also a ""rectilinear Coriolis"" since it's a Coriolis implementation meant for rectilinear grids, no? I'm not very familiar with the implementation of the Coriolis acc in spherical grids, but if I understand correctly you can't use `FPlane` or `BetaPlane` on spherical grids?; > ; > If that's true, maybe we aim for consistency with the rectilinear grids for now and rename things to; > ; > * `RectilinearGridFPlane` (this one); > * `RectilinearGridBetaPlane` (what is now `BetaPlane`); > * Keep `FPlane` for now because, like you said, it's an easy name that's very commonly used; > ; > I do think that it's important to keep ""f-plane"" in the name of this implementation somewhere instead of just ""Coriolis"" because there are different approximations one can make when implementing the Coriolis acc, so it'd help to be specific. The f-plane refers to a tangent plane approximation for a fluid contained in a spherical shell. However, this type is more general than that case (this was also a problem with the undecorated `FPlane` type), and can be used to model any rotating fluid in a rectilinear domain with an arbitrary axis of rotation. Therefore, I argue not using `FPlane` in the name of this type. `BetaPlane` has no meaning outside of rectilinear geometries, therefore I propose not adding the superfluous `RectilinearGrid` in front of `BetaPlane`. As for `Grid` or not, the meaning of `RectilinearGrid` is specific to Oceananigans. However, the term ""rectilinear"" has a distinct meaning apart from ""grids"". Here, I think its clear if the name refers to the coordinate system (rather than the grid or mesh), I think I prefer simply ""RectilinearCoriolis"". Otherwise, we will also need to consider how to devise a similar name for ""HydrostaticSphericalCoriolis"" that somehow references the handful of grid types that we permit for in spherical domains. That said, RectilinearCoriolis is not perfect (its obscure), so I think there is room for improvement.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-887649059
Usability,simpl,simply,"My two cents. Both the f-plane and beta-plane approximations approximate the Coriolis pseudo-force from a spherical coordiante, using latitude \varphi, to a planar geometry using typicallay y and z. Since they are both approximations into a plane (which could be tilted as this PR is trying to do) how about `ConstantPlanarCoriolis` for `f-plane` and `LinearPlanarCoriolis` for `beta-plane`? . In Calculus, these approximations can be thought of as a constant approximation (`f-plane`) or linear approximation (`beta-plane`). Another idea is to call them simply `ConstantCoriolis` and `LinearCoriois`. . I agree that `Grid` is not really relevant since we always use a grid. Also, `Rectilinear` does not seem as descriptive as",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-887679066
Usability,simpl,simple,It seemed that @tomchor and I both came up with the idea of `ConstantCoriolis` within a short span of time. It's simple and accurate.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-887679972
Usability,clear,clear,"> Is it possible to calculate the components `fx, fy, fz` on the fly? Also, can we infer `rotation_axis` from user-specified `fx, fy, fz`? If so, we can have one type for a constant rotation rate (storing just the parameters `rotation_axis` and `rotation_rate`), and use it for both Cartesian / rectilinear and spherical geometries. We definitely can do those things, I'm just not sure how it'll work with kernels. Unless I'm missing something:. ```julia; fx = 2rotation_rate * rotation_axis[1]; fy = 2rotation_rate * rotation_axis[2]; fz = 2rotation_rate * rotation_axis[3]; ```. and then to get `rotation_axis`:. ```julia; rotation_axis = [fx, fy, fz] ./ √(fx^2 + fy^2 + fz^2); ```. This would be kind of a big change though, no? Is it worth doing it in this PR?. Also, we'd need to make the difference between rotation rate and Coriolis frequency clear (meaning `f = 2rotation_rate`).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-887764088
Usability,clear,clear,"> > Is it possible to calculate the components `fx, fy, fz` on the fly? Also, can we infer `rotation_axis` from user-specified `fx, fy, fz`? If so, we can have one type for a constant rotation rate (storing just the parameters `rotation_axis` and `rotation_rate`), and use it for both Cartesian / rectilinear and spherical geometries.; > ; > We definitely can do those things, I'm just not sure how it'll work with kernels. Unless I'm missing something:; > ; > ```julia; > fx = 2rotation_rate * rotation_axis[1]; > fy = 2rotation_rate * rotation_axis[2]; > fz = 2rotation_rate * rotation_axis[3]; > ```; > ; > and then to get `rotation_axis`:; > ; > ```julia; > rotation_axis = [fx, fy, fz] ./ √(fx^2 + fy^2 + fz^2); > ```; > ; > This would be kind of a big change though, no? Is it worth doing it in this PR?; > ; > Also, we'd need to make the difference between rotation rate and Coriolis frequency clear (meaning `f = 2rotation_rate`). Well, that would be just fine for kernels (only change is that we need to use a tuple rather than array, so `(fx, fy, fz)` rather than `[fx, fy, fz]`). But again I think about it a bit more and one annoyance is that we need a version that makes the hydrostatic approximation. *sigh* so maybe we are back to something cumbersome like `ConstantCartesianCoriolis`...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-887771743
Usability,clear,clear,"> We all agree that we need different Coriolis functions for Cartesian and Spherical coordinates. Why do we need different functions or nonhydrostatic (and shallow water I presumme) and hydrostatic?. I'm also not clear, although I'm assuming that it has to do with `w` being treated differently (since `w` appears in the equations for the horizontal rotation components). @glwagner can you clarify?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-888381697
Energy Efficiency,energy,energy,"> > We all agree that we need different Coriolis functions for Cartesian and Spherical coordinates. Why do we need different functions or nonhydrostatic (and shallow water I presumme) and hydrostatic?; > ; > I'm also not clear, although I'm assuming that it has to do with `w` being treated differently (since `w` appears in the equations for the horizontal rotation components). @glwagner can you clarify?. Yes, when we make the hydrostatic approximation, we assume that the aspect ratio is thin and H/L is small. The hydrostatic assumption specifically refers to the use of this scaling in the vertical momentum equation (reducing it to a diagnostic equation for hydrostatic pressure). This same scaling applied to the Coriolis force leads to the ""traditional"" approximation such that Coriolis terms involving the _vertical_ velocity are neglected from the horizontal momentum equations (likewise, the terms involving the horizontal momentum are neglected from the vertical momentum balance; neglecting these terms must be made consistently for the system to conserve kinetic energy). This thin-aspect-ratio approximation (probably best to avoid implicating ""tradition"" in model formulation...) also needs to be invoked to justify ""f-plane"" and ""beta-plane"" approximations to the Coriolis term when the numerical model is supposed to approximate oceanic motion away from the poles. (The so-called ""non-traditional"" terms --- the projection of the planetary vorticity into horizontal directions --- have been variously found to have a small effect on turbulent boundary layer motions. This is probably because the effect of Coriolis forces is most pronounced at the largest scales, and the effect of the horizontal Coriolis components on large scale vertical motions is suppressed by the presence of an impenetrable surface at the top and bottom.). In Oceananigans, we have to express this notion with a _type_ to avoid adding spurious terms to the horizontal momentum equations that depend on the ve",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-888419861
Integrability,depend,depend,"that we need different Coriolis functions for Cartesian and Spherical coordinates. Why do we need different functions or nonhydrostatic (and shallow water I presumme) and hydrostatic?; > ; > I'm also not clear, although I'm assuming that it has to do with `w` being treated differently (since `w` appears in the equations for the horizontal rotation components). @glwagner can you clarify?. Yes, when we make the hydrostatic approximation, we assume that the aspect ratio is thin and H/L is small. The hydrostatic assumption specifically refers to the use of this scaling in the vertical momentum equation (reducing it to a diagnostic equation for hydrostatic pressure). This same scaling applied to the Coriolis force leads to the ""traditional"" approximation such that Coriolis terms involving the _vertical_ velocity are neglected from the horizontal momentum equations (likewise, the terms involving the horizontal momentum are neglected from the vertical momentum balance; neglecting these terms must be made consistently for the system to conserve kinetic energy). This thin-aspect-ratio approximation (probably best to avoid implicating ""tradition"" in model formulation...) also needs to be invoked to justify ""f-plane"" and ""beta-plane"" approximations to the Coriolis term when the numerical model is supposed to approximate oceanic motion away from the poles. (The so-called ""non-traditional"" terms --- the projection of the planetary vorticity into horizontal directions --- have been variously found to have a small effect on turbulent boundary layer motions. This is probably because the effect of Coriolis forces is most pronounced at the largest scales, and the effect of the horizontal Coriolis components on large scale vertical motions is suppressed by the presence of an impenetrable surface at the top and bottom.). In Oceananigans, we have to express this notion with a _type_ to avoid adding spurious terms to the horizontal momentum equations that depend on the vertical velocity.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-888419861
Safety,avoid,avoid,"that we need different Coriolis functions for Cartesian and Spherical coordinates. Why do we need different functions or nonhydrostatic (and shallow water I presumme) and hydrostatic?; > ; > I'm also not clear, although I'm assuming that it has to do with `w` being treated differently (since `w` appears in the equations for the horizontal rotation components). @glwagner can you clarify?. Yes, when we make the hydrostatic approximation, we assume that the aspect ratio is thin and H/L is small. The hydrostatic assumption specifically refers to the use of this scaling in the vertical momentum equation (reducing it to a diagnostic equation for hydrostatic pressure). This same scaling applied to the Coriolis force leads to the ""traditional"" approximation such that Coriolis terms involving the _vertical_ velocity are neglected from the horizontal momentum equations (likewise, the terms involving the horizontal momentum are neglected from the vertical momentum balance; neglecting these terms must be made consistently for the system to conserve kinetic energy). This thin-aspect-ratio approximation (probably best to avoid implicating ""tradition"" in model formulation...) also needs to be invoked to justify ""f-plane"" and ""beta-plane"" approximations to the Coriolis term when the numerical model is supposed to approximate oceanic motion away from the poles. (The so-called ""non-traditional"" terms --- the projection of the planetary vorticity into horizontal directions --- have been variously found to have a small effect on turbulent boundary layer motions. This is probably because the effect of Coriolis forces is most pronounced at the largest scales, and the effect of the horizontal Coriolis components on large scale vertical motions is suppressed by the presence of an impenetrable surface at the top and bottom.). In Oceananigans, we have to express this notion with a _type_ to avoid adding spurious terms to the horizontal momentum equations that depend on the vertical velocity.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-888419861
Usability,clear,clear,"> > We all agree that we need different Coriolis functions for Cartesian and Spherical coordinates. Why do we need different functions or nonhydrostatic (and shallow water I presumme) and hydrostatic?; > ; > I'm also not clear, although I'm assuming that it has to do with `w` being treated differently (since `w` appears in the equations for the horizontal rotation components). @glwagner can you clarify?. Yes, when we make the hydrostatic approximation, we assume that the aspect ratio is thin and H/L is small. The hydrostatic assumption specifically refers to the use of this scaling in the vertical momentum equation (reducing it to a diagnostic equation for hydrostatic pressure). This same scaling applied to the Coriolis force leads to the ""traditional"" approximation such that Coriolis terms involving the _vertical_ velocity are neglected from the horizontal momentum equations (likewise, the terms involving the horizontal momentum are neglected from the vertical momentum balance; neglecting these terms must be made consistently for the system to conserve kinetic energy). This thin-aspect-ratio approximation (probably best to avoid implicating ""tradition"" in model formulation...) also needs to be invoked to justify ""f-plane"" and ""beta-plane"" approximations to the Coriolis term when the numerical model is supposed to approximate oceanic motion away from the poles. (The so-called ""non-traditional"" terms --- the projection of the planetary vorticity into horizontal directions --- have been variously found to have a small effect on turbulent boundary layer motions. This is probably because the effect of Coriolis forces is most pronounced at the largest scales, and the effect of the horizontal Coriolis components on large scale vertical motions is suppressed by the presence of an impenetrable surface at the top and bottom.). In Oceananigans, we have to express this notion with a _type_ to avoid adding spurious terms to the horizontal momentum equations that depend on the ve",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-888419861
Availability,toler,tolerance,"Added some dynamics tests for Coriolis with this last commit. It two a 0-D case for half an inertial period with a rotation about the `z` axis and `x` axis and then compares both to make sure they produce the same result (but rotated). There's one part that tests if the total velocity magnitude is approximately unchanged (magnitude=1), which relies on an implicit arbitrary tolerance which might be bad. I'd curious about your feedback on that one. > if the name is changed to include Cartesian then we can merge this and discuss further in an issue. Per the comment above I'm going to change the name to `ConstantCartesianCoriolis` and (provided the tests all pass and you're okay with my new test addition) I'll proceed to merge this into master and open an issue to further discuss the issues that emerged here.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-888495033
Testability,test,tests,"Added some dynamics tests for Coriolis with this last commit. It two a 0-D case for half an inertial period with a rotation about the `z` axis and `x` axis and then compares both to make sure they produce the same result (but rotated). There's one part that tests if the total velocity magnitude is approximately unchanged (magnitude=1), which relies on an implicit arbitrary tolerance which might be bad. I'd curious about your feedback on that one. > if the name is changed to include Cartesian then we can merge this and discuss further in an issue. Per the comment above I'm going to change the name to `ConstantCartesianCoriolis` and (provided the tests all pass and you're okay with my new test addition) I'll proceed to merge this into master and open an issue to further discuss the issues that emerged here.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-888495033
Usability,feedback,feedback,"Added some dynamics tests for Coriolis with this last commit. It two a 0-D case for half an inertial period with a rotation about the `z` axis and `x` axis and then compares both to make sure they produce the same result (but rotated). There's one part that tests if the total velocity magnitude is approximately unchanged (magnitude=1), which relies on an implicit arbitrary tolerance which might be bad. I'd curious about your feedback on that one. > if the name is changed to include Cartesian then we can merge this and discuss further in an issue. Per the comment above I'm going to change the name to `ConstantCartesianCoriolis` and (provided the tests all pass and you're okay with my new test addition) I'll proceed to merge this into master and open an issue to further discuss the issues that emerged here.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-888495033
Availability,toler,tolerance,"> Added some dynamics tests for Coriolis with this last commit. It two a 0-D case for half an inertial period with a rotation about the `z` axis and `x` axis and then compares both to make sure they produce the same result (but rotated).; > ; > There's one part that tests if the total velocity magnitude is approximately unchanged (magnitude=1), which relies on an implicit arbitrary tolerance which might be bad. I'd curious about your feedback on that one.; > ; > > if the name is changed to include Cartesian then we can merge this and discuss further in an issue.; > ; > Per the comment above I'm going to change the name to `ConstantCartesianCoriolis` and (provided the tests all pass and you're okay with my new test addition) I'll proceed to merge this into master and open an issue to further discuss the issues that emerged here. For physics tests we can't avoid introducing an arbitrary tolerance. So its ok. That's one reason why physics tests in CI are a bit problematic and we also need validation tests analyzed by humans.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-888549957
Safety,avoid,avoid,"> Added some dynamics tests for Coriolis with this last commit. It two a 0-D case for half an inertial period with a rotation about the `z` axis and `x` axis and then compares both to make sure they produce the same result (but rotated).; > ; > There's one part that tests if the total velocity magnitude is approximately unchanged (magnitude=1), which relies on an implicit arbitrary tolerance which might be bad. I'd curious about your feedback on that one.; > ; > > if the name is changed to include Cartesian then we can merge this and discuss further in an issue.; > ; > Per the comment above I'm going to change the name to `ConstantCartesianCoriolis` and (provided the tests all pass and you're okay with my new test addition) I'll proceed to merge this into master and open an issue to further discuss the issues that emerged here. For physics tests we can't avoid introducing an arbitrary tolerance. So its ok. That's one reason why physics tests in CI are a bit problematic and we also need validation tests analyzed by humans.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-888549957
Security,validat,validation,"> Added some dynamics tests for Coriolis with this last commit. It two a 0-D case for half an inertial period with a rotation about the `z` axis and `x` axis and then compares both to make sure they produce the same result (but rotated).; > ; > There's one part that tests if the total velocity magnitude is approximately unchanged (magnitude=1), which relies on an implicit arbitrary tolerance which might be bad. I'd curious about your feedback on that one.; > ; > > if the name is changed to include Cartesian then we can merge this and discuss further in an issue.; > ; > Per the comment above I'm going to change the name to `ConstantCartesianCoriolis` and (provided the tests all pass and you're okay with my new test addition) I'll proceed to merge this into master and open an issue to further discuss the issues that emerged here. For physics tests we can't avoid introducing an arbitrary tolerance. So its ok. That's one reason why physics tests in CI are a bit problematic and we also need validation tests analyzed by humans.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-888549957
Testability,test,tests,"> Added some dynamics tests for Coriolis with this last commit. It two a 0-D case for half an inertial period with a rotation about the `z` axis and `x` axis and then compares both to make sure they produce the same result (but rotated).; > ; > There's one part that tests if the total velocity magnitude is approximately unchanged (magnitude=1), which relies on an implicit arbitrary tolerance which might be bad. I'd curious about your feedback on that one.; > ; > > if the name is changed to include Cartesian then we can merge this and discuss further in an issue.; > ; > Per the comment above I'm going to change the name to `ConstantCartesianCoriolis` and (provided the tests all pass and you're okay with my new test addition) I'll proceed to merge this into master and open an issue to further discuss the issues that emerged here. For physics tests we can't avoid introducing an arbitrary tolerance. So its ok. That's one reason why physics tests in CI are a bit problematic and we also need validation tests analyzed by humans.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-888549957
Usability,feedback,feedback,"> Added some dynamics tests for Coriolis with this last commit. It two a 0-D case for half an inertial period with a rotation about the `z` axis and `x` axis and then compares both to make sure they produce the same result (but rotated).; > ; > There's one part that tests if the total velocity magnitude is approximately unchanged (magnitude=1), which relies on an implicit arbitrary tolerance which might be bad. I'd curious about your feedback on that one.; > ; > > if the name is changed to include Cartesian then we can merge this and discuss further in an issue.; > ; > Per the comment above I'm going to change the name to `ConstantCartesianCoriolis` and (provided the tests all pass and you're okay with my new test addition) I'll proceed to merge this into master and open an issue to further discuss the issues that emerged here. For physics tests we can't avoid introducing an arbitrary tolerance. So its ok. That's one reason why physics tests in CI are a bit problematic and we also need validation tests analyzed by humans.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-888549957
Usability,clear,clearest,"> Yeah... ""callback"" is an annoyingly obtuse but somehow standard name for this kind of thing. Yeah, definitely not the clearest name... but if it's standard I guess it's good to keep it. This sounds like it's unambiguously positive though! Nice contribution",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1894#issuecomment-885853182
Performance,tune,tune,Might have something to do with how many threads are running on how many physical cores. I'll try to tune how the threaded processes are launched and specify one thread per core more clearly. Hyperthreading seems to be what enables 2 threads to run on one core. There should be options to disable it either through slurm or julia.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1902#issuecomment-890031307
Usability,clear,clearly,Might have something to do with how many threads are running on how many physical cores. I'll try to tune how the threaded processes are launched and specify one thread per core more clearly. Hyperthreading seems to be what enables 2 threads to run on one core. There should be options to disable it either through slurm or julia.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1902#issuecomment-890031307
Performance,perform,performs,"d, apparently, `Σ² = S_ij S_ij` (if we believe we understand the notation here):. https://github.com/CliMA/Oceananigans.jl/blob/32c5c5a2d0f441a4b663866d511807d0f9413c90/src/TurbulenceClosures/turbulence_closure_implementations/smagorinsky_lilly.jl#L97. This means that our formula is identical to Pressel et al (2015), but the constant is wrong: Pressel proposes `Cs=0.17`, and we have a default of `Cs=0.23`:. https://github.com/CliMA/Oceananigans.jl/blob/32c5c5a2d0f441a4b663866d511807d0f9413c90/src/TurbulenceClosures/turbulence_closure_implementations/smagorinsky_lilly.jl#L63-L64. Amusingly, . ```julia; julia> 0.165 * sqrt(2); 0.23334523779156072; ```. which is probably not a coincidence. However, I'm not sure how an extra factor of `sqrt(2)` snuck into our constant. As for _clarification_, I don't have much to offer. Perhaps the constant was taken from some reference that used a different formulation than either us or Pressel et al. 2015. Nobody has submitted a validation test for this closure so I don't think we know how it performs. As a historical note, the paper cited by both Pressel et al (2015) and us is Lilly (1962), which does indeed use the same formulation:. ![image](https://user-images.githubusercontent.com/15271942/127507507-c7d11dfc-733a-4472-8216-dca4e5844b3f.png). where. ![image](https://user-images.githubusercontent.com/15271942/127507737-94aa05d4-6fa5-4d38-9a9d-b1bbcc8a1e79.png). @tomchor I can't tell if the formula you've pasted is actually different from ours (or what the definition of `|S|` is). Where does it come from?. It'd be fine to change the constant because there's no validation test. So the best we can do is theorize, and theorization on this issue suggests changing the default to `C=0.17`. If one wanted to set up a validation test, it could be nice to reproduce [Compte-Bellot and Corrsin (1964)](https://www.cambridge.org/core/journals/journal-of-fluid-mechanics/article/abs/simple-eulerian-time-correlation-of-fulland-narrowband-velocity-si",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1907#issuecomment-889189927
Security,validat,validation,"d, apparently, `Σ² = S_ij S_ij` (if we believe we understand the notation here):. https://github.com/CliMA/Oceananigans.jl/blob/32c5c5a2d0f441a4b663866d511807d0f9413c90/src/TurbulenceClosures/turbulence_closure_implementations/smagorinsky_lilly.jl#L97. This means that our formula is identical to Pressel et al (2015), but the constant is wrong: Pressel proposes `Cs=0.17`, and we have a default of `Cs=0.23`:. https://github.com/CliMA/Oceananigans.jl/blob/32c5c5a2d0f441a4b663866d511807d0f9413c90/src/TurbulenceClosures/turbulence_closure_implementations/smagorinsky_lilly.jl#L63-L64. Amusingly, . ```julia; julia> 0.165 * sqrt(2); 0.23334523779156072; ```. which is probably not a coincidence. However, I'm not sure how an extra factor of `sqrt(2)` snuck into our constant. As for _clarification_, I don't have much to offer. Perhaps the constant was taken from some reference that used a different formulation than either us or Pressel et al. 2015. Nobody has submitted a validation test for this closure so I don't think we know how it performs. As a historical note, the paper cited by both Pressel et al (2015) and us is Lilly (1962), which does indeed use the same formulation:. ![image](https://user-images.githubusercontent.com/15271942/127507507-c7d11dfc-733a-4472-8216-dca4e5844b3f.png). where. ![image](https://user-images.githubusercontent.com/15271942/127507737-94aa05d4-6fa5-4d38-9a9d-b1bbcc8a1e79.png). @tomchor I can't tell if the formula you've pasted is actually different from ours (or what the definition of `|S|` is). Where does it come from?. It'd be fine to change the constant because there's no validation test. So the best we can do is theorize, and theorization on this issue suggests changing the default to `C=0.17`. If one wanted to set up a validation test, it could be nice to reproduce [Compte-Bellot and Corrsin (1964)](https://www.cambridge.org/core/journals/journal-of-fluid-mechanics/article/abs/simple-eulerian-time-correlation-of-fulland-narrowband-velocity-si",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1907#issuecomment-889189927
Testability,test,test,"d, apparently, `Σ² = S_ij S_ij` (if we believe we understand the notation here):. https://github.com/CliMA/Oceananigans.jl/blob/32c5c5a2d0f441a4b663866d511807d0f9413c90/src/TurbulenceClosures/turbulence_closure_implementations/smagorinsky_lilly.jl#L97. This means that our formula is identical to Pressel et al (2015), but the constant is wrong: Pressel proposes `Cs=0.17`, and we have a default of `Cs=0.23`:. https://github.com/CliMA/Oceananigans.jl/blob/32c5c5a2d0f441a4b663866d511807d0f9413c90/src/TurbulenceClosures/turbulence_closure_implementations/smagorinsky_lilly.jl#L63-L64. Amusingly, . ```julia; julia> 0.165 * sqrt(2); 0.23334523779156072; ```. which is probably not a coincidence. However, I'm not sure how an extra factor of `sqrt(2)` snuck into our constant. As for _clarification_, I don't have much to offer. Perhaps the constant was taken from some reference that used a different formulation than either us or Pressel et al. 2015. Nobody has submitted a validation test for this closure so I don't think we know how it performs. As a historical note, the paper cited by both Pressel et al (2015) and us is Lilly (1962), which does indeed use the same formulation:. ![image](https://user-images.githubusercontent.com/15271942/127507507-c7d11dfc-733a-4472-8216-dca4e5844b3f.png). where. ![image](https://user-images.githubusercontent.com/15271942/127507737-94aa05d4-6fa5-4d38-9a9d-b1bbcc8a1e79.png). @tomchor I can't tell if the formula you've pasted is actually different from ours (or what the definition of `|S|` is). Where does it come from?. It'd be fine to change the constant because there's no validation test. So the best we can do is theorize, and theorization on this issue suggests changing the default to `C=0.17`. If one wanted to set up a validation test, it could be nice to reproduce [Compte-Bellot and Corrsin (1964)](https://www.cambridge.org/core/journals/journal-of-fluid-mechanics/article/abs/simple-eulerian-time-correlation-of-fulland-narrowband-velocity-si",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1907#issuecomment-889189927
Usability,simpl,simple-eulerian-time-correlation-of-fulland-narrowband-velocity-signals-in-gridgenerated-isotropic-turbulence," factor of `sqrt(2)` snuck into our constant. As for _clarification_, I don't have much to offer. Perhaps the constant was taken from some reference that used a different formulation than either us or Pressel et al. 2015. Nobody has submitted a validation test for this closure so I don't think we know how it performs. As a historical note, the paper cited by both Pressel et al (2015) and us is Lilly (1962), which does indeed use the same formulation:. ![image](https://user-images.githubusercontent.com/15271942/127507507-c7d11dfc-733a-4472-8216-dca4e5844b3f.png). where. ![image](https://user-images.githubusercontent.com/15271942/127507737-94aa05d4-6fa5-4d38-9a9d-b1bbcc8a1e79.png). @tomchor I can't tell if the formula you've pasted is actually different from ours (or what the definition of `|S|` is). Where does it come from?. It'd be fine to change the constant because there's no validation test. So the best we can do is theorize, and theorization on this issue suggests changing the default to `C=0.17`. If one wanted to set up a validation test, it could be nice to reproduce [Compte-Bellot and Corrsin (1964)](https://www.cambridge.org/core/journals/journal-of-fluid-mechanics/article/abs/simple-eulerian-time-correlation-of-fulland-narrowband-velocity-signals-in-gridgenerated-isotropic-turbulence/A3D7B0DD621DE46CB6CC543F65A66F93) (this wasn't possible when the closures were written because we didn't support triply periodic domains, but is possible now). This could also be used to validate Anisotropic Minimum Dissipation. Here's a figure with such a comparison from [Rozema et al 2015](https://aip.scitation.org/doi/pdf/10.1063/1.4928700):. ![image](https://user-images.githubusercontent.com/15271942/127508527-e5f7d150-56c4-4949-ad8e-90d67fdbee64.png). I believe for shear flows it has also been found that the constant needs to be as small as `C=0.1` or smaller? It'd be nice to mention and cite these in the docstring as well, if we can find those references. Hope that helps!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1907#issuecomment-889189927
Modifiability,variab,variable,"> > I made one extra change which is that I don't call `N^2 / S^2` a Richardson number anymore. Since the denominator is a strain rate, not the _vertical_ shear, I think it's odd to call it `Ri`. Also that variable (whatever you call it) only appears 3 times briefly so there's no need to give it a name.; > > It appears that our buoyancy modification doesn't really match Pressel's or Lilly's since we use an arbitrary `C_b` while they proposed to use `1/Pr_t`. @glwagner Is there any reference for that?; > ; > I don't quite understand the question --- what would you like a reference for?; > ; > It looks like for `Cb=0`, the reference is the original Smagorinsky paper, whereas for `Cb=1/Pr` one uses the model proposed by Lilly (1962). A number in between represents something different from either --- are you wondering if there are papers out there that have used `Cb` other than 0 or `1/Pr`? As to that I don't know.; > ; > We could change the default from `Cb=1` to `Cb=1/Pr` or `Cb=0`... ? The default `Pr` is `Pr=1` but I suppose one might inadvertently change `Pr` but leave `Cb=1` which would lead to a different LES model than proposed by Lilly (1962). Apparently my explanation wasn't needed! Yes, that's what I mean. I propose we either get rid of `C_b` and just use `1/Pr_t` or make it clear in the docs and docstring that we offer an extra degree of freedom, but that the model as proposed has `C_b=1/Pr_t`. I'm not sure which one is best since I do like the idea of Oceananigans allowing for easy (customization), but also that favors mistakes by un-attentive users (such as myself haha).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1908#issuecomment-889307399
Usability,clear,clear,"> > I made one extra change which is that I don't call `N^2 / S^2` a Richardson number anymore. Since the denominator is a strain rate, not the _vertical_ shear, I think it's odd to call it `Ri`. Also that variable (whatever you call it) only appears 3 times briefly so there's no need to give it a name.; > > It appears that our buoyancy modification doesn't really match Pressel's or Lilly's since we use an arbitrary `C_b` while they proposed to use `1/Pr_t`. @glwagner Is there any reference for that?; > ; > I don't quite understand the question --- what would you like a reference for?; > ; > It looks like for `Cb=0`, the reference is the original Smagorinsky paper, whereas for `Cb=1/Pr` one uses the model proposed by Lilly (1962). A number in between represents something different from either --- are you wondering if there are papers out there that have used `Cb` other than 0 or `1/Pr`? As to that I don't know.; > ; > We could change the default from `Cb=1` to `Cb=1/Pr` or `Cb=0`... ? The default `Pr` is `Pr=1` but I suppose one might inadvertently change `Pr` but leave `Cb=1` which would lead to a different LES model than proposed by Lilly (1962). Apparently my explanation wasn't needed! Yes, that's what I mean. I propose we either get rid of `C_b` and just use `1/Pr_t` or make it clear in the docs and docstring that we offer an extra degree of freedom, but that the model as proposed has `C_b=1/Pr_t`. I'm not sure which one is best since I do like the idea of Oceananigans allowing for easy (customization), but also that favors mistakes by un-attentive users (such as myself haha).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1908#issuecomment-889307399
Availability,error,error,"> So it seems that our model has an extra degree of freedom that neither Lilly nor Pressel propose. Quite! Though Lilly admits that his model amounts to ""little more than a scaling argument"" and that both `Pr_t` and the model ""constant"" are themselves unknown functions. So I actually think there is room to interpret Lilly as proposing a whole family of models. Since time is finite only one has been tested I guess (and also the structure of the model is questionable, so people have moved on to other formulations...). > I propose we either get rid of `C_b` and just use `1/Pr_t` or make it clear in the docs and docstring that we offer an extra degree of freedom, but that the model as proposed has `C_b=1/Pr_t`. I'm not sure which one is best since I do like the idea of Oceananigans allowing for easy (customization), but also that favors mistakes by un-attentive users (such as myself haha). Does the default `Cb = 1/Pr` both retain flexibility and also reduce the chances of unexpected behavior / mistakes?. If we get rid of `Cb` then we may want to introduce an alternative way to eliminate the buoyancy correction entirely (currently achievable with `Cb=0`). A further caveat is that using `1/Pr` only applies if `Pr` is the same for all tracers and if a linear equation of state links tracers to buoyancy. With nonlinear equations of state it's unclear what to use for `Cb`. I believe we also allow a different `Pr` for every tracer. In this case the default `Cb=1/Pr` will throw an error (probably a good thing, since you'd have to decide what to use for `Cb` in this case).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1908#issuecomment-889333799
Energy Efficiency,reduce,reduce,"> So it seems that our model has an extra degree of freedom that neither Lilly nor Pressel propose. Quite! Though Lilly admits that his model amounts to ""little more than a scaling argument"" and that both `Pr_t` and the model ""constant"" are themselves unknown functions. So I actually think there is room to interpret Lilly as proposing a whole family of models. Since time is finite only one has been tested I guess (and also the structure of the model is questionable, so people have moved on to other formulations...). > I propose we either get rid of `C_b` and just use `1/Pr_t` or make it clear in the docs and docstring that we offer an extra degree of freedom, but that the model as proposed has `C_b=1/Pr_t`. I'm not sure which one is best since I do like the idea of Oceananigans allowing for easy (customization), but also that favors mistakes by un-attentive users (such as myself haha). Does the default `Cb = 1/Pr` both retain flexibility and also reduce the chances of unexpected behavior / mistakes?. If we get rid of `Cb` then we may want to introduce an alternative way to eliminate the buoyancy correction entirely (currently achievable with `Cb=0`). A further caveat is that using `1/Pr` only applies if `Pr` is the same for all tracers and if a linear equation of state links tracers to buoyancy. With nonlinear equations of state it's unclear what to use for `Cb`. I believe we also allow a different `Pr` for every tracer. In this case the default `Cb=1/Pr` will throw an error (probably a good thing, since you'd have to decide what to use for `Cb` in this case).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1908#issuecomment-889333799
Testability,test,tested,"> So it seems that our model has an extra degree of freedom that neither Lilly nor Pressel propose. Quite! Though Lilly admits that his model amounts to ""little more than a scaling argument"" and that both `Pr_t` and the model ""constant"" are themselves unknown functions. So I actually think there is room to interpret Lilly as proposing a whole family of models. Since time is finite only one has been tested I guess (and also the structure of the model is questionable, so people have moved on to other formulations...). > I propose we either get rid of `C_b` and just use `1/Pr_t` or make it clear in the docs and docstring that we offer an extra degree of freedom, but that the model as proposed has `C_b=1/Pr_t`. I'm not sure which one is best since I do like the idea of Oceananigans allowing for easy (customization), but also that favors mistakes by un-attentive users (such as myself haha). Does the default `Cb = 1/Pr` both retain flexibility and also reduce the chances of unexpected behavior / mistakes?. If we get rid of `Cb` then we may want to introduce an alternative way to eliminate the buoyancy correction entirely (currently achievable with `Cb=0`). A further caveat is that using `1/Pr` only applies if `Pr` is the same for all tracers and if a linear equation of state links tracers to buoyancy. With nonlinear equations of state it's unclear what to use for `Cb`. I believe we also allow a different `Pr` for every tracer. In this case the default `Cb=1/Pr` will throw an error (probably a good thing, since you'd have to decide what to use for `Cb` in this case).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1908#issuecomment-889333799
Usability,clear,clear,"> So it seems that our model has an extra degree of freedom that neither Lilly nor Pressel propose. Quite! Though Lilly admits that his model amounts to ""little more than a scaling argument"" and that both `Pr_t` and the model ""constant"" are themselves unknown functions. So I actually think there is room to interpret Lilly as proposing a whole family of models. Since time is finite only one has been tested I guess (and also the structure of the model is questionable, so people have moved on to other formulations...). > I propose we either get rid of `C_b` and just use `1/Pr_t` or make it clear in the docs and docstring that we offer an extra degree of freedom, but that the model as proposed has `C_b=1/Pr_t`. I'm not sure which one is best since I do like the idea of Oceananigans allowing for easy (customization), but also that favors mistakes by un-attentive users (such as myself haha). Does the default `Cb = 1/Pr` both retain flexibility and also reduce the chances of unexpected behavior / mistakes?. If we get rid of `Cb` then we may want to introduce an alternative way to eliminate the buoyancy correction entirely (currently achievable with `Cb=0`). A further caveat is that using `1/Pr` only applies if `Pr` is the same for all tracers and if a linear equation of state links tracers to buoyancy. With nonlinear equations of state it's unclear what to use for `Cb`. I believe we also allow a different `Pr` for every tracer. In this case the default `Cb=1/Pr` will throw an error (probably a good thing, since you'd have to decide what to use for `Cb` in this case).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1908#issuecomment-889333799
Availability,error,error,"> @tomchor since you're the main person using the tilted gravity feature, I'm wondering if you can help provide some insight into this ""stratified fluid at rest"" test. The main issue is that the dynamics can be ""correct"" but the test can fail. I feel its a bad test for this reason. I don't have much to add to the discussion. I agree with you that a balanced state in a continuous system doesn't necessarily translate exactly to a discrete one. When I (or Ali?) came up with this test I figured this translation error would be small enough to be acceptable, and when the test actually passed I was happy enough with that. So if this translation error is indeed large enough with the new solver that the tests don't pass I'm very much okay with changing the test. I can't, for the moment, think of another simple test to replace it though. My best guess is to do something similar to what I did for the rotated Coriolis: solve a system with gravity pointing upwards and then the same system with gravity pointing to the `x` or `y` direction and see if they match after the proper rotation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890043769
Deployability,continuous,continuous,"> @tomchor since you're the main person using the tilted gravity feature, I'm wondering if you can help provide some insight into this ""stratified fluid at rest"" test. The main issue is that the dynamics can be ""correct"" but the test can fail. I feel its a bad test for this reason. I don't have much to add to the discussion. I agree with you that a balanced state in a continuous system doesn't necessarily translate exactly to a discrete one. When I (or Ali?) came up with this test I figured this translation error would be small enough to be acceptable, and when the test actually passed I was happy enough with that. So if this translation error is indeed large enough with the new solver that the tests don't pass I'm very much okay with changing the test. I can't, for the moment, think of another simple test to replace it though. My best guess is to do something similar to what I did for the rotated Coriolis: solve a system with gravity pointing upwards and then the same system with gravity pointing to the `x` or `y` direction and see if they match after the proper rotation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890043769
Testability,test,test,"> @tomchor since you're the main person using the tilted gravity feature, I'm wondering if you can help provide some insight into this ""stratified fluid at rest"" test. The main issue is that the dynamics can be ""correct"" but the test can fail. I feel its a bad test for this reason. I don't have much to add to the discussion. I agree with you that a balanced state in a continuous system doesn't necessarily translate exactly to a discrete one. When I (or Ali?) came up with this test I figured this translation error would be small enough to be acceptable, and when the test actually passed I was happy enough with that. So if this translation error is indeed large enough with the new solver that the tests don't pass I'm very much okay with changing the test. I can't, for the moment, think of another simple test to replace it though. My best guess is to do something similar to what I did for the rotated Coriolis: solve a system with gravity pointing upwards and then the same system with gravity pointing to the `x` or `y` direction and see if they match after the proper rotation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890043769
Usability,simpl,simple,"> @tomchor since you're the main person using the tilted gravity feature, I'm wondering if you can help provide some insight into this ""stratified fluid at rest"" test. The main issue is that the dynamics can be ""correct"" but the test can fail. I feel its a bad test for this reason. I don't have much to add to the discussion. I agree with you that a balanced state in a continuous system doesn't necessarily translate exactly to a discrete one. When I (or Ali?) came up with this test I figured this translation error would be small enough to be acceptable, and when the test actually passed I was happy enough with that. So if this translation error is indeed large enough with the new solver that the tests don't pass I'm very much okay with changing the test. I can't, for the moment, think of another simple test to replace it though. My best guess is to do something similar to what I did for the rotated Coriolis: solve a system with gravity pointing upwards and then the same system with gravity pointing to the `x` or `y` direction and see if they match after the proper rotation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890043769
Availability,error,error,"> > @tomchor since you're the main person using the tilted gravity feature, I'm wondering if you can help provide some insight into this ""stratified fluid at rest"" test. The main issue is that the dynamics can be ""correct"" but the test can fail. I feel its a bad test for this reason.; > ; > I don't have much to add to the discussion. I agree with you that a balanced state in a continuous system doesn't necessarily translate exactly to a discrete one. When I (or Ali?) came up with this test I figured this translation error would be small enough to be acceptable, and when the test actually passed I was happy enough with that.; > ; > So if this translation error is indeed large enough with the new solver that the tests don't pass I'm very much okay with changing the test. I can't, for the moment, think of another simple test to replace it though. My best guess is to do something similar to what I did for the rotated Coriolis: solve a system with gravity pointing upwards and then the same system with gravity pointing to the `x` or `y` direction and see if they match after the proper rotation. Can't we just test directly that the output of `x_dot_b` is as expected (as well as the others)? Along with a test that the constructor works without error this seems sufficient. More complicated integration tests, like testing that the discrete system has a balanced state analogous to the continuous one, seem better suited for a validation test, I think.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890058586
Deployability,continuous,continuous,"> > @tomchor since you're the main person using the tilted gravity feature, I'm wondering if you can help provide some insight into this ""stratified fluid at rest"" test. The main issue is that the dynamics can be ""correct"" but the test can fail. I feel its a bad test for this reason.; > ; > I don't have much to add to the discussion. I agree with you that a balanced state in a continuous system doesn't necessarily translate exactly to a discrete one. When I (or Ali?) came up with this test I figured this translation error would be small enough to be acceptable, and when the test actually passed I was happy enough with that.; > ; > So if this translation error is indeed large enough with the new solver that the tests don't pass I'm very much okay with changing the test. I can't, for the moment, think of another simple test to replace it though. My best guess is to do something similar to what I did for the rotated Coriolis: solve a system with gravity pointing upwards and then the same system with gravity pointing to the `x` or `y` direction and see if they match after the proper rotation. Can't we just test directly that the output of `x_dot_b` is as expected (as well as the others)? Along with a test that the constructor works without error this seems sufficient. More complicated integration tests, like testing that the discrete system has a balanced state analogous to the continuous one, seem better suited for a validation test, I think.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890058586
Integrability,integrat,integration,"> > @tomchor since you're the main person using the tilted gravity feature, I'm wondering if you can help provide some insight into this ""stratified fluid at rest"" test. The main issue is that the dynamics can be ""correct"" but the test can fail. I feel its a bad test for this reason.; > ; > I don't have much to add to the discussion. I agree with you that a balanced state in a continuous system doesn't necessarily translate exactly to a discrete one. When I (or Ali?) came up with this test I figured this translation error would be small enough to be acceptable, and when the test actually passed I was happy enough with that.; > ; > So if this translation error is indeed large enough with the new solver that the tests don't pass I'm very much okay with changing the test. I can't, for the moment, think of another simple test to replace it though. My best guess is to do something similar to what I did for the rotated Coriolis: solve a system with gravity pointing upwards and then the same system with gravity pointing to the `x` or `y` direction and see if they match after the proper rotation. Can't we just test directly that the output of `x_dot_b` is as expected (as well as the others)? Along with a test that the constructor works without error this seems sufficient. More complicated integration tests, like testing that the discrete system has a balanced state analogous to the continuous one, seem better suited for a validation test, I think.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890058586
Security,validat,validation,"> > @tomchor since you're the main person using the tilted gravity feature, I'm wondering if you can help provide some insight into this ""stratified fluid at rest"" test. The main issue is that the dynamics can be ""correct"" but the test can fail. I feel its a bad test for this reason.; > ; > I don't have much to add to the discussion. I agree with you that a balanced state in a continuous system doesn't necessarily translate exactly to a discrete one. When I (or Ali?) came up with this test I figured this translation error would be small enough to be acceptable, and when the test actually passed I was happy enough with that.; > ; > So if this translation error is indeed large enough with the new solver that the tests don't pass I'm very much okay with changing the test. I can't, for the moment, think of another simple test to replace it though. My best guess is to do something similar to what I did for the rotated Coriolis: solve a system with gravity pointing upwards and then the same system with gravity pointing to the `x` or `y` direction and see if they match after the proper rotation. Can't we just test directly that the output of `x_dot_b` is as expected (as well as the others)? Along with a test that the constructor works without error this seems sufficient. More complicated integration tests, like testing that the discrete system has a balanced state analogous to the continuous one, seem better suited for a validation test, I think.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890058586
Testability,test,test,"> > @tomchor since you're the main person using the tilted gravity feature, I'm wondering if you can help provide some insight into this ""stratified fluid at rest"" test. The main issue is that the dynamics can be ""correct"" but the test can fail. I feel its a bad test for this reason.; > ; > I don't have much to add to the discussion. I agree with you that a balanced state in a continuous system doesn't necessarily translate exactly to a discrete one. When I (or Ali?) came up with this test I figured this translation error would be small enough to be acceptable, and when the test actually passed I was happy enough with that.; > ; > So if this translation error is indeed large enough with the new solver that the tests don't pass I'm very much okay with changing the test. I can't, for the moment, think of another simple test to replace it though. My best guess is to do something similar to what I did for the rotated Coriolis: solve a system with gravity pointing upwards and then the same system with gravity pointing to the `x` or `y` direction and see if they match after the proper rotation. Can't we just test directly that the output of `x_dot_b` is as expected (as well as the others)? Along with a test that the constructor works without error this seems sufficient. More complicated integration tests, like testing that the discrete system has a balanced state analogous to the continuous one, seem better suited for a validation test, I think.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890058586
Usability,simpl,simple,"> > @tomchor since you're the main person using the tilted gravity feature, I'm wondering if you can help provide some insight into this ""stratified fluid at rest"" test. The main issue is that the dynamics can be ""correct"" but the test can fail. I feel its a bad test for this reason.; > ; > I don't have much to add to the discussion. I agree with you that a balanced state in a continuous system doesn't necessarily translate exactly to a discrete one. When I (or Ali?) came up with this test I figured this translation error would be small enough to be acceptable, and when the test actually passed I was happy enough with that.; > ; > So if this translation error is indeed large enough with the new solver that the tests don't pass I'm very much okay with changing the test. I can't, for the moment, think of another simple test to replace it though. My best guess is to do something similar to what I did for the rotated Coriolis: solve a system with gravity pointing upwards and then the same system with gravity pointing to the `x` or `y` direction and see if they match after the proper rotation. Can't we just test directly that the output of `x_dot_b` is as expected (as well as the others)? Along with a test that the constructor works without error this seems sufficient. More complicated integration tests, like testing that the discrete system has a balanced state analogous to the continuous one, seem better suited for a validation test, I think.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890058586
Availability,down,downside,"Removed the ""fluid at rest"" test that was failing and included another (simpler) one for tilted buoyancy along with constructors. The new test checks that `x_dot_g_b`, etc., match for two different domains: one with z-aligned gravity and another with y-aligned gravity. . The only downside is that I only included the `x_dot_g_b` test for `model=BuoyancyTracer()`. Another separate test is needed for `model=SeawaterBuoyancy()` if we think that's necessary. (Constructors are tested for both models, though.)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-913791965
Testability,test,test,"Removed the ""fluid at rest"" test that was failing and included another (simpler) one for tilted buoyancy along with constructors. The new test checks that `x_dot_g_b`, etc., match for two different domains: one with z-aligned gravity and another with y-aligned gravity. . The only downside is that I only included the `x_dot_g_b` test for `model=BuoyancyTracer()`. Another separate test is needed for `model=SeawaterBuoyancy()` if we think that's necessary. (Constructors are tested for both models, though.)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-913791965
Usability,simpl,simpler,"Removed the ""fluid at rest"" test that was failing and included another (simpler) one for tilted buoyancy along with constructors. The new test checks that `x_dot_g_b`, etc., match for two different domains: one with z-aligned gravity and another with y-aligned gravity. . The only downside is that I only included the `x_dot_g_b` test for `model=BuoyancyTracer()`. Another separate test is needed for `model=SeawaterBuoyancy()` if we think that's necessary. (Constructors are tested for both models, though.)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-913791965
Availability,down,downside,"> Removed the ""fluid at rest"" test that was failing and included another (simpler) one for tilted buoyancy along with constructors. The new test checks that `x_dot_g_b`, etc., match for two different domains: one with z-aligned gravity and another with y-aligned gravity.; > ; > The only downside is that I only included the `x_dot_g_b` test for `model=BuoyancyTracer()`. Another separate test is needed for `model=SeawaterBuoyancy()` if we think that's necessary.; > ; > (Constructors are tested for both models, though.). Thanks @tomchor !!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-914363399
Testability,test,test,"> Removed the ""fluid at rest"" test that was failing and included another (simpler) one for tilted buoyancy along with constructors. The new test checks that `x_dot_g_b`, etc., match for two different domains: one with z-aligned gravity and another with y-aligned gravity.; > ; > The only downside is that I only included the `x_dot_g_b` test for `model=BuoyancyTracer()`. Another separate test is needed for `model=SeawaterBuoyancy()` if we think that's necessary.; > ; > (Constructors are tested for both models, though.). Thanks @tomchor !!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-914363399
Usability,simpl,simpler,"> Removed the ""fluid at rest"" test that was failing and included another (simpler) one for tilted buoyancy along with constructors. The new test checks that `x_dot_g_b`, etc., match for two different domains: one with z-aligned gravity and another with y-aligned gravity.; > ; > The only downside is that I only included the `x_dot_g_b` test for `model=BuoyancyTracer()`. Another separate test is needed for `model=SeawaterBuoyancy()` if we think that's necessary.; > ; > (Constructors are tested for both models, though.). Thanks @tomchor !!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-914363399
Testability,benchmark,benchmark,"Nice, thanks!. I'm pretty surprised that `ab2_step_field!` dominates the cost. `ab2_step_field!` is this simple function:. https://github.com/CliMA/Oceananigans.jl/blob/9ecddac3fe2666e05f21e51b81ec2c403094e5ea/src/TimeSteppers/quasi_adams_bashforth_2.jl#L121. which seems much cheaper than something like `calculate_Gu!`. What's going on?. I'm also noticing that function is a bit sketchy because it uses the type of `χ` to convert `1.5` and `0.5`. This is fine if `χ` is a floating point number, but not otherwise... it should probably use `eltype(U)`. . How did you run the profiler? Does it make sense to add a new `profile` directory to the source code (or maybe just add something to `benchmark/`)?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-890001070
Usability,simpl,simple,"Nice, thanks!. I'm pretty surprised that `ab2_step_field!` dominates the cost. `ab2_step_field!` is this simple function:. https://github.com/CliMA/Oceananigans.jl/blob/9ecddac3fe2666e05f21e51b81ec2c403094e5ea/src/TimeSteppers/quasi_adams_bashforth_2.jl#L121. which seems much cheaper than something like `calculate_Gu!`. What's going on?. I'm also noticing that function is a bit sketchy because it uses the type of `χ` to convert `1.5` and `0.5`. This is fine if `χ` is a floating point number, but not otherwise... it should probably use `eltype(U)`. . How did you run the profiler? Does it make sense to add a new `profile` directory to the source code (or maybe just add something to `benchmark/`)?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-890001070
Performance,load,loaded,"Might be worthwhile to profile with `timestepper=:RungeKutta3` as a sanity check, considering that this benchmark suggests a simple time-stepping function is 12% (!) of the cost. Another thought --- we should probably benchmark ""fully loaded"" models that at least use WENO advection (and perhaps some turbulence closure?), since that's more realistic. I think most usage of `NonhydrostaticModel` also has one tracer, rather than two (someday, we should change that default...)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-890002262
Safety,sanity check,sanity check,"Might be worthwhile to profile with `timestepper=:RungeKutta3` as a sanity check, considering that this benchmark suggests a simple time-stepping function is 12% (!) of the cost. Another thought --- we should probably benchmark ""fully loaded"" models that at least use WENO advection (and perhaps some turbulence closure?), since that's more realistic. I think most usage of `NonhydrostaticModel` also has one tracer, rather than two (someday, we should change that default...)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-890002262
Testability,benchmark,benchmark,"Might be worthwhile to profile with `timestepper=:RungeKutta3` as a sanity check, considering that this benchmark suggests a simple time-stepping function is 12% (!) of the cost. Another thought --- we should probably benchmark ""fully loaded"" models that at least use WENO advection (and perhaps some turbulence closure?), since that's more realistic. I think most usage of `NonhydrostaticModel` also has one tracer, rather than two (someday, we should change that default...)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-890002262
Usability,simpl,simple,"Might be worthwhile to profile with `timestepper=:RungeKutta3` as a sanity check, considering that this benchmark suggests a simple time-stepping function is 12% (!) of the cost. Another thought --- we should probably benchmark ""fully loaded"" models that at least use WENO advection (and perhaps some turbulence closure?), since that's more realistic. I think most usage of `NonhydrostaticModel` also has one tracer, rather than two (someday, we should change that default...)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-890002262
Integrability,depend,dependent,"I just edited an old benchmarkable incompressible model script to only have the model setup and time stepping. I did not profile from the start, and only profiled the time_step! function line.; I feel like the profiles are more dependent on which system have which profiler, so it might make sense to just add a few simple scripts in `benchmark` that just consist of model setup and timestep and those can be called profiliables/benchmarkables.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-890004382
Testability,benchmark,benchmarkable,"I just edited an old benchmarkable incompressible model script to only have the model setup and time stepping. I did not profile from the start, and only profiled the time_step! function line.; I feel like the profiles are more dependent on which system have which profiler, so it might make sense to just add a few simple scripts in `benchmark` that just consist of model setup and timestep and those can be called profiliables/benchmarkables.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-890004382
Usability,simpl,simple,"I just edited an old benchmarkable incompressible model script to only have the model setup and time stepping. I did not profile from the start, and only profiled the time_step! function line.; I feel like the profiles are more dependent on which system have which profiler, so it might make sense to just add a few simple scripts in `benchmark` that just consist of model setup and timestep and those can be called profiliables/benchmarkables.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-890004382
Integrability,depend,dependent,"> I just edited an old benchmarkable incompressible model script to only have the model setup and time stepping. I did not profile from the start, and only profiled the time_step! function line.; > I feel like the profiles are more dependent on which system have which profiler, so it might make sense to just add a few simple scripts in `benchmark` that just consist of model setup and timestep and those can be called profiliables/benchmarkables. Ok! I can help with that.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-890025103
Testability,benchmark,benchmarkable,"> I just edited an old benchmarkable incompressible model script to only have the model setup and time stepping. I did not profile from the start, and only profiled the time_step! function line.; > I feel like the profiles are more dependent on which system have which profiler, so it might make sense to just add a few simple scripts in `benchmark` that just consist of model setup and timestep and those can be called profiliables/benchmarkables. Ok! I can help with that.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-890025103
Usability,simpl,simple,"> I just edited an old benchmarkable incompressible model script to only have the model setup and time stepping. I did not profile from the start, and only profiled the time_step! function line.; > I feel like the profiles are more dependent on which system have which profiler, so it might make sense to just add a few simple scripts in `benchmark` that just consist of model setup and timestep and those can be called profiliables/benchmarkables. Ok! I can help with that.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-890025103
Availability,error,error,"o @maleadt on the Julia slack's GPU channel and in regards to the shallow water model profiles:. > Don't focus on time spent in API calls to much. since GPU execution is asynchronous, you'll have to synchronize at some point, and that API call will then 'soak up' time until the stream has finished executing. and here that's literally the synchronize function, which is implemented using cuStreamQuery: https://github.com/JuliaGPU/CUDA.jl/blob/2b3ec03ff9774b65541fc88dd6b0f1f7aea5d9e0/lib/cudadrv/stream.jl#L115-L144. >use a timeline profiler (i.e. NSNight Systems) to profile your app, or nvpp if you really want to use the old profiler toolchain. plain nvprof results are too simple once your application hits some level of complexity. >now, it is possible that our CPU-side implementation of synchronize does too many API calls and could be optimized a little, but in the end the call serves to wait until the GPU has finished so it probably doesn't matter much. if it does, e.g. because you want to perform other useful work on another CPU task concurrently, you could try to profile that in isolation and file an issue. Essentially, Tim explains that `cuStreamQuery` takes up more time as the grid size increases because it's called in the synchronize function. The synchronize function as shown in the link above tends to be called more and soaks up more waiting time the bigger the problem hence why it scales positively to grid size. ; Taking a closer look at the shallow water gpu profiling results above, it seems that `cuStreamQuery` takes up a lot of time in the finer resolution runs because it is called many times and not because each call takes a lot of time. For example, in the 16k case, `cuSteamQuery` is called three order of magnitudes more times than `cuLaunchKernel` while both calls are measured in microseconds. ; I'm not sure if `cuStreamQuery` being called 400,000 times is an error with our code, an error with CUDA.jl, not an error at all, or an error with my profiling.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-899945654
Integrability,synchroniz,synchronize,"According to @maleadt on the Julia slack's GPU channel and in regards to the shallow water model profiles:. > Don't focus on time spent in API calls to much. since GPU execution is asynchronous, you'll have to synchronize at some point, and that API call will then 'soak up' time until the stream has finished executing. and here that's literally the synchronize function, which is implemented using cuStreamQuery: https://github.com/JuliaGPU/CUDA.jl/blob/2b3ec03ff9774b65541fc88dd6b0f1f7aea5d9e0/lib/cudadrv/stream.jl#L115-L144. >use a timeline profiler (i.e. NSNight Systems) to profile your app, or nvpp if you really want to use the old profiler toolchain. plain nvprof results are too simple once your application hits some level of complexity. >now, it is possible that our CPU-side implementation of synchronize does too many API calls and could be optimized a little, but in the end the call serves to wait until the GPU has finished so it probably doesn't matter much. if it does, e.g. because you want to perform other useful work on another CPU task concurrently, you could try to profile that in isolation and file an issue. Essentially, Tim explains that `cuStreamQuery` takes up more time as the grid size increases because it's called in the synchronize function. The synchronize function as shown in the link above tends to be called more and soaks up more waiting time the bigger the problem hence why it scales positively to grid size. ; Taking a closer look at the shallow water gpu profiling results above, it seems that `cuStreamQuery` takes up a lot of time in the finer resolution runs because it is called many times and not because each call takes a lot of time. For example, in the 16k case, `cuSteamQuery` is called three order of magnitudes more times than `cuLaunchKernel` while both calls are measured in microseconds. ; I'm not sure if `cuStreamQuery` being called 400,000 times is an error with our code, an error with CUDA.jl, not an error at all, or an error with my ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-899945654
Performance,optimiz,optimized,"According to @maleadt on the Julia slack's GPU channel and in regards to the shallow water model profiles:. > Don't focus on time spent in API calls to much. since GPU execution is asynchronous, you'll have to synchronize at some point, and that API call will then 'soak up' time until the stream has finished executing. and here that's literally the synchronize function, which is implemented using cuStreamQuery: https://github.com/JuliaGPU/CUDA.jl/blob/2b3ec03ff9774b65541fc88dd6b0f1f7aea5d9e0/lib/cudadrv/stream.jl#L115-L144. >use a timeline profiler (i.e. NSNight Systems) to profile your app, or nvpp if you really want to use the old profiler toolchain. plain nvprof results are too simple once your application hits some level of complexity. >now, it is possible that our CPU-side implementation of synchronize does too many API calls and could be optimized a little, but in the end the call serves to wait until the GPU has finished so it probably doesn't matter much. if it does, e.g. because you want to perform other useful work on another CPU task concurrently, you could try to profile that in isolation and file an issue. Essentially, Tim explains that `cuStreamQuery` takes up more time as the grid size increases because it's called in the synchronize function. The synchronize function as shown in the link above tends to be called more and soaks up more waiting time the bigger the problem hence why it scales positively to grid size. ; Taking a closer look at the shallow water gpu profiling results above, it seems that `cuStreamQuery` takes up a lot of time in the finer resolution runs because it is called many times and not because each call takes a lot of time. For example, in the 16k case, `cuSteamQuery` is called three order of magnitudes more times than `cuLaunchKernel` while both calls are measured in microseconds. ; I'm not sure if `cuStreamQuery` being called 400,000 times is an error with our code, an error with CUDA.jl, not an error at all, or an error with my ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-899945654
Usability,simpl,simple,"According to @maleadt on the Julia slack's GPU channel and in regards to the shallow water model profiles:. > Don't focus on time spent in API calls to much. since GPU execution is asynchronous, you'll have to synchronize at some point, and that API call will then 'soak up' time until the stream has finished executing. and here that's literally the synchronize function, which is implemented using cuStreamQuery: https://github.com/JuliaGPU/CUDA.jl/blob/2b3ec03ff9774b65541fc88dd6b0f1f7aea5d9e0/lib/cudadrv/stream.jl#L115-L144. >use a timeline profiler (i.e. NSNight Systems) to profile your app, or nvpp if you really want to use the old profiler toolchain. plain nvprof results are too simple once your application hits some level of complexity. >now, it is possible that our CPU-side implementation of synchronize does too many API calls and could be optimized a little, but in the end the call serves to wait until the GPU has finished so it probably doesn't matter much. if it does, e.g. because you want to perform other useful work on another CPU task concurrently, you could try to profile that in isolation and file an issue. Essentially, Tim explains that `cuStreamQuery` takes up more time as the grid size increases because it's called in the synchronize function. The synchronize function as shown in the link above tends to be called more and soaks up more waiting time the bigger the problem hence why it scales positively to grid size. ; Taking a closer look at the shallow water gpu profiling results above, it seems that `cuStreamQuery` takes up a lot of time in the finer resolution runs because it is called many times and not because each call takes a lot of time. For example, in the 16k case, `cuSteamQuery` is called three order of magnitudes more times than `cuLaunchKernel` while both calls are measured in microseconds. ; I'm not sure if `cuStreamQuery` being called 400,000 times is an error with our code, an error with CUDA.jl, not an error at all, or an error with my ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-899945654
Performance,bottleneck,bottleneck,"> Yeah this is pretty worrying... I'm pretty sure this is the cause of #1420 which has been open for a while so this slowdown must have been around for a while (and just flew under the radar). [Profiling](https://docs.julialang.org/en/v1/manual/profile/) might help pinpoint the bottleneck. It looks like there are some extra temporary arrays being created for the cases with non-trivial (although still pretty trivial) indexing patterns. Profiling could be good - also just turning off as much as possible and then building up from the FFT alone, simple stencil etc... - if that is possible?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1919#issuecomment-891443627
Usability,simpl,simple,"> Yeah this is pretty worrying... I'm pretty sure this is the cause of #1420 which has been open for a while so this slowdown must have been around for a while (and just flew under the radar). [Profiling](https://docs.julialang.org/en/v1/manual/profile/) might help pinpoint the bottleneck. It looks like there are some extra temporary arrays being created for the cases with non-trivial (although still pretty trivial) indexing patterns. Profiling could be good - also just turning off as much as possible and then building up from the FFT alone, simple stencil etc... - if that is possible?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1919#issuecomment-891443627
Performance,bottleneck,bottleneck,"> > Yeah this is pretty worrying... I'm pretty sure this is the cause of #1420 which has been open for a while so this slowdown must have been around for a while (and just flew under the radar). [Profiling](https://docs.julialang.org/en/v1/manual/profile/) might help pinpoint the bottleneck.; > ; > It looks like there are some extra temporary arrays being created for the cases with non-trivial (although still pretty trivial) indexing patterns. Profiling could be good - also just turning off as much as possible and then building up from the FFT alone, simple stencil etc... - if that is possible?. I did try with a different advection scheme (and `halo_size=(1, 1, 1)`) and the allocations were mitigated. This and @tomchor's result suggests that halo filling for periodic directions is a likely culprit. Profiling is a good idea. I also had the thought of commenting out much of the time-stepping loop and building up to try to pinpoint which functions trigger allocations as @christophernhill suggests.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1919#issuecomment-891521065
Usability,simpl,simple,"> > Yeah this is pretty worrying... I'm pretty sure this is the cause of #1420 which has been open for a while so this slowdown must have been around for a while (and just flew under the radar). [Profiling](https://docs.julialang.org/en/v1/manual/profile/) might help pinpoint the bottleneck.; > ; > It looks like there are some extra temporary arrays being created for the cases with non-trivial (although still pretty trivial) indexing patterns. Profiling could be good - also just turning off as much as possible and then building up from the FFT alone, simple stencil etc... - if that is possible?. I did try with a different advection scheme (and `halo_size=(1, 1, 1)`) and the allocations were mitigated. This and @tomchor's result suggests that halo filling for periodic directions is a likely culprit. Profiling is a good idea. I also had the thought of commenting out much of the time-stepping loop and building up to try to pinpoint which functions trigger allocations as @christophernhill suggests.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1919#issuecomment-891521065
Availability,checkpoint,checkpointing,"I think @tomchor is hitting on the right solution: we should separate ""output for analysis"" from ""output for checkpointing"", if possible. Typically we need output for analysis more frequently than output for checkpointing, and we don't require things like the tendency fields for analysis. This motivates creating multiple output writers that are dedicated to their specific tasks. . On the possibility of a NetCDF checkpointer: the first checkpointer design that utilized `restore_from_checkpoint` attempted to serialize as much of a model's data structures as possible. This requirement prevented us from using NetCDF and motivated using JLD2 (there are a few other data formats that can serialize, but JLD2 is fast, simple, and HDF5 compatible, which means it can be loaded from python with `h5py`). However, we now support a simpler paradigm whereby the original run script needs to be modified with `run!(simulation, pickup=true)` in order to ""pick up"" a simulation from a checkpoint. With this simpler design we require only all the prognostic fields and tendencies (for AB2) in the checkpointer file and we could in principle support NetCDF. This has the downside that it would require us to maintain more code. If you do need to inspect, plot, or analyze data in JLD2 files, check out the [JLD2 documentation](https://juliaio.github.io/JLD2.jl/dev/).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1929#issuecomment-899754924
Performance,load,loaded,"I think @tomchor is hitting on the right solution: we should separate ""output for analysis"" from ""output for checkpointing"", if possible. Typically we need output for analysis more frequently than output for checkpointing, and we don't require things like the tendency fields for analysis. This motivates creating multiple output writers that are dedicated to their specific tasks. . On the possibility of a NetCDF checkpointer: the first checkpointer design that utilized `restore_from_checkpoint` attempted to serialize as much of a model's data structures as possible. This requirement prevented us from using NetCDF and motivated using JLD2 (there are a few other data formats that can serialize, but JLD2 is fast, simple, and HDF5 compatible, which means it can be loaded from python with `h5py`). However, we now support a simpler paradigm whereby the original run script needs to be modified with `run!(simulation, pickup=true)` in order to ""pick up"" a simulation from a checkpoint. With this simpler design we require only all the prognostic fields and tendencies (for AB2) in the checkpointer file and we could in principle support NetCDF. This has the downside that it would require us to maintain more code. If you do need to inspect, plot, or analyze data in JLD2 files, check out the [JLD2 documentation](https://juliaio.github.io/JLD2.jl/dev/).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1929#issuecomment-899754924
Usability,simpl,simple,"I think @tomchor is hitting on the right solution: we should separate ""output for analysis"" from ""output for checkpointing"", if possible. Typically we need output for analysis more frequently than output for checkpointing, and we don't require things like the tendency fields for analysis. This motivates creating multiple output writers that are dedicated to their specific tasks. . On the possibility of a NetCDF checkpointer: the first checkpointer design that utilized `restore_from_checkpoint` attempted to serialize as much of a model's data structures as possible. This requirement prevented us from using NetCDF and motivated using JLD2 (there are a few other data formats that can serialize, but JLD2 is fast, simple, and HDF5 compatible, which means it can be loaded from python with `h5py`). However, we now support a simpler paradigm whereby the original run script needs to be modified with `run!(simulation, pickup=true)` in order to ""pick up"" a simulation from a checkpoint. With this simpler design we require only all the prognostic fields and tendencies (for AB2) in the checkpointer file and we could in principle support NetCDF. This has the downside that it would require us to maintain more code. If you do need to inspect, plot, or analyze data in JLD2 files, check out the [JLD2 documentation](https://juliaio.github.io/JLD2.jl/dev/).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1929#issuecomment-899754924
Testability,test,test,We test that `NonhydrostaticModel` maintains incompressibility on both fully regular and vertically-stretched grids:. https://github.com/CliMA/Oceananigans.jl/blob/e929631eb3a233ae3f3358d2146e5d6004f9a06c/test/test_time_stepping.jl#L311-L341. We don't have tests for the hydrostatic model however. A similar but possibly slightly simpler test might test that `compute_w_from_continuity!` correctly calculates a vertical velocity field given some horizontally divergent horizontal velocity field.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1934#issuecomment-899757319
Usability,simpl,simpler,We test that `NonhydrostaticModel` maintains incompressibility on both fully regular and vertically-stretched grids:. https://github.com/CliMA/Oceananigans.jl/blob/e929631eb3a233ae3f3358d2146e5d6004f9a06c/test/test_time_stepping.jl#L311-L341. We don't have tests for the hydrostatic model however. A similar but possibly slightly simpler test might test that `compute_w_from_continuity!` correctly calculates a vertical velocity field given some horizontally divergent horizontal velocity field.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1934#issuecomment-899757319
Usability,simpl,simple,"> What bit of the code do you think needs to be modified?. Good question! I think here:. https://github.com/CliMA/Oceananigans.jl/blob/79676db7707e1f4c4cb7d21b0924562d36b2790f/src/Fields/broadcasting_abstract_fields.jl#L20-L22. Here's how we figure that out. First we use `Meta.@lower` to find the code that runs when we use `.=`:. ```julia; julia> Meta.@lower c .= c0; :($(Expr(:thunk, CodeInfo(; @ none within `top-level scope'; 1 ─ %1 = Base.broadcasted(Base.identity, c0); │ %2 = Base.materialize!(c, %1); └── return %2; )))); ```. Now we can build the operation and use `@which` to figure out what it calls:. ```julia; julia> bc = Base.broadcasted(Base.identity, c0); Base.Broadcast.Broadcasted(identity, ([0.9778532419793966]. [0.5210723026166955],)). julia> Base.materialize!(c, bc). julia> @which Base.materialize!(c, bc); materialize!(dest::Oceananigans.Fields.AbstractField, bc::Base.Broadcast.Broadcasted{var""#s183"", Axes, F, Args} where {var""#s183""<:Base.Broadcast.DefaultArrayStyle, Axes, F, Args<:Tuple}) in Oceananigans.Fields at /Users/gregorywagner/Projects/Oceananigans.jl/src/Fields/broadcasting_abstract_fields.jl:21; ```. The indicated line is the one I've posted. Might be as simple as defining. ```julia; @inline Base.Broadcast.materialize!(dest::AbstractField, bc::Broadcasted{<:DefaultArrayStyle}) =; Base.Broadcast.materialize!(interior(dest), bc); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1942#issuecomment-902680649
Usability,guid,guiding,Wow! So many interesting things here and thanks for guiding me along the path to figure this out. . I will give this a try now and let you know if it resolves this problem.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1942#issuecomment-902684023
Usability,simpl,simpler,Thanks @Sumanshekhar17 for the simpler example and @glwagner has answered your question I believe. Why don't you try it without `prettytime(wizard)` to see if that works?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1946#issuecomment-902842128
Usability,simpl,simple,"I tried the simple example from #1942 and that worked great with this PR, so that's good news. Is there something in particular that you are expecting to fail? I will be keeping my fingers crossed.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1947#issuecomment-902687574
Modifiability,parameteriz,parameterization,The difference between this parameterization and the currently implemented `TwoDimensionalLeith` parameterization is that the diffusivities are user-provided rather than being a 3D field that's computed from the vorticity and divergence. That's why this parameterization is actually a simplification of `TwoDimensionalLeith`.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1972#issuecomment-916410470
Usability,simpl,simplification,The difference between this parameterization and the currently implemented `TwoDimensionalLeith` parameterization is that the diffusivities are user-provided rather than being a 3D field that's computed from the vorticity and divergence. That's why this parameterization is actually a simplification of `TwoDimensionalLeith`.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1972#issuecomment-916410470
Usability,simpl,simple,"@francispoulin you are in principle correct!. However, without the equality in the criterion, me and @glwagner were trying to setup a very simple, idealized example with linear background stratification and somehow the convective adjectment started working in the bottom of the ocean (!!) because the criterion was precisely zero there. This is the ""unphysical situation"" that @glwagner is referring to -- perhaps he can elaborate a bit more?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1980#issuecomment-918738850
Usability,simpl,simple,"> @francispoulin you are in principle correct!; > ; > However, without the equality in the criterion, me and @glwagner were trying to setup a very simple, idealized example with linear background stratification and somehow the convective adjectment started working in the bottom of the ocean (!!) because the criterion was precisely zero there. This is the ""unphysical situation"" that @glwagner is referring to -- perhaps he can elaborate a bit more?. Interesting... I wouldn't think this would be a problem (although I definitely see how it can be). I'd be curious to see some animations of this if you have them ready. (Just out of curiosity; no need to post them if it'll take work...)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1980#issuecomment-918755890
Usability,simpl,simply,"I didn't see any docstring explaining what's actually being done. Is it possible to add some? Maybe with a minimal example? (Unless I missed it, in which case please ignore the comment.). Also, if I understand correctly, this only regrids in the `z` direction, no? Can we change the same from simply `regrid` to something more specific? Like `regrid_z` or `vertical_regrid`?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1987#issuecomment-922972217
Availability,error,error,"> Also, if I understand correctly, this only regrids in the `z` direction, no? Can we change the same from simply `regrid` to something more specific? Like `regrid_z` or `vertical_regrid`?. The idea is that we will eventually support general regridding. In this PR, we only implement vertical regridding as a start. The next case to support would be regridding for Cartesian grids; after that, for curvilinear grids. We've attempted to write an informative error:. ```julia; msg = """"""Regridding; $(short_show(v)) on $(short_show(source_grid)); to $(short_show(u)) on $(short_show(target_grid)); is not supported.""""""; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1987#issuecomment-923014008
Usability,simpl,simply,"> Also, if I understand correctly, this only regrids in the `z` direction, no? Can we change the same from simply `regrid` to something more specific? Like `regrid_z` or `vertical_regrid`?. The idea is that we will eventually support general regridding. In this PR, we only implement vertical regridding as a start. The next case to support would be regridding for Cartesian grids; after that, for curvilinear grids. We've attempted to write an informative error:. ```julia; msg = """"""Regridding; $(short_show(v)) on $(short_show(source_grid)); to $(short_show(u)) on $(short_show(target_grid)); is not supported.""""""; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1987#issuecomment-923014008
Availability,error,error,"> > Also, if I understand correctly, this only regrids in the `z` direction, no? Can we change the same from simply `regrid` to something more specific? Like `regrid_z` or `vertical_regrid`?; > ; > The idea is that we will eventually support general regridding. In this PR, we only implement vertical regridding as a start. The next case to support would be regridding for Cartesian grids; after that, for curvilinear grids. We've attempted to write an informative error:; > ; > ```julia; > msg = """"""Regridding; > $(short_show(v)) on $(short_show(source_grid)); > to $(short_show(u)) on $(short_show(target_grid)); > is not supported.""""""; > ```. I see! I got a bit confused about this error because I'm not familiar with `SingleColumnGrid`, but it makes more sense now.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1987#issuecomment-923045151
Usability,simpl,simply,"> > Also, if I understand correctly, this only regrids in the `z` direction, no? Can we change the same from simply `regrid` to something more specific? Like `regrid_z` or `vertical_regrid`?; > ; > The idea is that we will eventually support general regridding. In this PR, we only implement vertical regridding as a start. The next case to support would be regridding for Cartesian grids; after that, for curvilinear grids. We've attempted to write an informative error:; > ; > ```julia; > msg = """"""Regridding; > $(short_show(v)) on $(short_show(source_grid)); > to $(short_show(u)) on $(short_show(target_grid)); > is not supported.""""""; > ```. I see! I got a bit confused about this error because I'm not familiar with `SingleColumnGrid`, but it makes more sense now.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1987#issuecomment-923045151
Availability,down,down,"Yes we definitely need to speed up the tests. I think 95% of the time it takes to run tests is spent in compilation, however, so creating fewer models may not help much. Instead we may need to be more strategic with how we run tests, and perhaps also work on speeding up compilation time using something like [SnoopCompile.jl](https://github.com/timholy/SnoopCompile.jl). On #1962 we add bars capability, which will allow us to separate the tests into a few categories: fast-running, crucial tests will run on every commit to a PR, and slower, more comprehensive integration tests will run only when `bors try` or `bors r+` is invoked. This might help streamline the development workflow. Also if we are using Caltech's central cluster for CI we can potentially split the jobs amongst more workers, which might help speed up tests overall. Even more important is simplifying the test implementation. Right now updating tests and validation experiments is a time sink for developers that change the API and has really slowed development down lately. So we shouldn't rewrite tests in a way that makes development more difficult (eg keeping the maintenance burden of the test infrastructure small is more important than decreasing the computational cost of tests). This is really a side comment --- we should be able to improve the tests both so they are faster _and_ easier to maintain, if we are careful.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1990#issuecomment-922526970
Deployability,integrat,integration,"Yes we definitely need to speed up the tests. I think 95% of the time it takes to run tests is spent in compilation, however, so creating fewer models may not help much. Instead we may need to be more strategic with how we run tests, and perhaps also work on speeding up compilation time using something like [SnoopCompile.jl](https://github.com/timholy/SnoopCompile.jl). On #1962 we add bars capability, which will allow us to separate the tests into a few categories: fast-running, crucial tests will run on every commit to a PR, and slower, more comprehensive integration tests will run only when `bors try` or `bors r+` is invoked. This might help streamline the development workflow. Also if we are using Caltech's central cluster for CI we can potentially split the jobs amongst more workers, which might help speed up tests overall. Even more important is simplifying the test implementation. Right now updating tests and validation experiments is a time sink for developers that change the API and has really slowed development down lately. So we shouldn't rewrite tests in a way that makes development more difficult (eg keeping the maintenance burden of the test infrastructure small is more important than decreasing the computational cost of tests). This is really a side comment --- we should be able to improve the tests both so they are faster _and_ easier to maintain, if we are careful.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1990#issuecomment-922526970
Integrability,integrat,integration,"Yes we definitely need to speed up the tests. I think 95% of the time it takes to run tests is spent in compilation, however, so creating fewer models may not help much. Instead we may need to be more strategic with how we run tests, and perhaps also work on speeding up compilation time using something like [SnoopCompile.jl](https://github.com/timholy/SnoopCompile.jl). On #1962 we add bars capability, which will allow us to separate the tests into a few categories: fast-running, crucial tests will run on every commit to a PR, and slower, more comprehensive integration tests will run only when `bors try` or `bors r+` is invoked. This might help streamline the development workflow. Also if we are using Caltech's central cluster for CI we can potentially split the jobs amongst more workers, which might help speed up tests overall. Even more important is simplifying the test implementation. Right now updating tests and validation experiments is a time sink for developers that change the API and has really slowed development down lately. So we shouldn't rewrite tests in a way that makes development more difficult (eg keeping the maintenance burden of the test infrastructure small is more important than decreasing the computational cost of tests). This is really a side comment --- we should be able to improve the tests both so they are faster _and_ easier to maintain, if we are careful.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1990#issuecomment-922526970
Modifiability,rewrite,rewrite,"Yes we definitely need to speed up the tests. I think 95% of the time it takes to run tests is spent in compilation, however, so creating fewer models may not help much. Instead we may need to be more strategic with how we run tests, and perhaps also work on speeding up compilation time using something like [SnoopCompile.jl](https://github.com/timholy/SnoopCompile.jl). On #1962 we add bars capability, which will allow us to separate the tests into a few categories: fast-running, crucial tests will run on every commit to a PR, and slower, more comprehensive integration tests will run only when `bors try` or `bors r+` is invoked. This might help streamline the development workflow. Also if we are using Caltech's central cluster for CI we can potentially split the jobs amongst more workers, which might help speed up tests overall. Even more important is simplifying the test implementation. Right now updating tests and validation experiments is a time sink for developers that change the API and has really slowed development down lately. So we shouldn't rewrite tests in a way that makes development more difficult (eg keeping the maintenance burden of the test infrastructure small is more important than decreasing the computational cost of tests). This is really a side comment --- we should be able to improve the tests both so they are faster _and_ easier to maintain, if we are careful.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1990#issuecomment-922526970
Security,validat,validation,"Yes we definitely need to speed up the tests. I think 95% of the time it takes to run tests is spent in compilation, however, so creating fewer models may not help much. Instead we may need to be more strategic with how we run tests, and perhaps also work on speeding up compilation time using something like [SnoopCompile.jl](https://github.com/timholy/SnoopCompile.jl). On #1962 we add bars capability, which will allow us to separate the tests into a few categories: fast-running, crucial tests will run on every commit to a PR, and slower, more comprehensive integration tests will run only when `bors try` or `bors r+` is invoked. This might help streamline the development workflow. Also if we are using Caltech's central cluster for CI we can potentially split the jobs amongst more workers, which might help speed up tests overall. Even more important is simplifying the test implementation. Right now updating tests and validation experiments is a time sink for developers that change the API and has really slowed development down lately. So we shouldn't rewrite tests in a way that makes development more difficult (eg keeping the maintenance burden of the test infrastructure small is more important than decreasing the computational cost of tests). This is really a side comment --- we should be able to improve the tests both so they are faster _and_ easier to maintain, if we are careful.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1990#issuecomment-922526970
Testability,test,tests,"Yes we definitely need to speed up the tests. I think 95% of the time it takes to run tests is spent in compilation, however, so creating fewer models may not help much. Instead we may need to be more strategic with how we run tests, and perhaps also work on speeding up compilation time using something like [SnoopCompile.jl](https://github.com/timholy/SnoopCompile.jl). On #1962 we add bars capability, which will allow us to separate the tests into a few categories: fast-running, crucial tests will run on every commit to a PR, and slower, more comprehensive integration tests will run only when `bors try` or `bors r+` is invoked. This might help streamline the development workflow. Also if we are using Caltech's central cluster for CI we can potentially split the jobs amongst more workers, which might help speed up tests overall. Even more important is simplifying the test implementation. Right now updating tests and validation experiments is a time sink for developers that change the API and has really slowed development down lately. So we shouldn't rewrite tests in a way that makes development more difficult (eg keeping the maintenance burden of the test infrastructure small is more important than decreasing the computational cost of tests). This is really a side comment --- we should be able to improve the tests both so they are faster _and_ easier to maintain, if we are careful.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1990#issuecomment-922526970
Usability,simpl,simplifying,"Yes we definitely need to speed up the tests. I think 95% of the time it takes to run tests is spent in compilation, however, so creating fewer models may not help much. Instead we may need to be more strategic with how we run tests, and perhaps also work on speeding up compilation time using something like [SnoopCompile.jl](https://github.com/timholy/SnoopCompile.jl). On #1962 we add bars capability, which will allow us to separate the tests into a few categories: fast-running, crucial tests will run on every commit to a PR, and slower, more comprehensive integration tests will run only when `bors try` or `bors r+` is invoked. This might help streamline the development workflow. Also if we are using Caltech's central cluster for CI we can potentially split the jobs amongst more workers, which might help speed up tests overall. Even more important is simplifying the test implementation. Right now updating tests and validation experiments is a time sink for developers that change the API and has really slowed development down lately. So we shouldn't rewrite tests in a way that makes development more difficult (eg keeping the maintenance burden of the test infrastructure small is more important than decreasing the computational cost of tests). This is really a side comment --- we should be able to improve the tests both so they are faster _and_ easier to maintain, if we are careful.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1990#issuecomment-922526970
Availability,down,down,">On #1962 we add bars capability, which will allow us to separate the tests into a few categories: fast-running, crucial tests will run on every commit to a PR, and slower, more comprehensive integration tests will run only when bors try or bors r+ is invoked. This might help streamline the development workflow. Also if we are using Caltech's central cluster for CI we can potentially split the jobs amongst more workers, which might help speed up tests overall. Definitely looking forward to that PR. > Even more important is simplifying the test implementation. Right now updating tests and validation experiments is a time sink for developers that change the API and has really slowed development down lately. So we shouldn't rewrite tests in a way that makes development more difficult (eg keeping the maintenance burden of the test infrastructure small is more important than decreasing the computational cost of tests). This is really a side comment --- we should be able to improve the tests both so they are faster and easier to maintain, if we are careful. I definitely agree with that. I just don't see how to do it. Being thorough with the tests (which I believe is something we want) necessarily comes with using the API many times, making changes to it a bit slower to implement, no?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1990#issuecomment-922529440
Deployability,integrat,integration,">On #1962 we add bars capability, which will allow us to separate the tests into a few categories: fast-running, crucial tests will run on every commit to a PR, and slower, more comprehensive integration tests will run only when bors try or bors r+ is invoked. This might help streamline the development workflow. Also if we are using Caltech's central cluster for CI we can potentially split the jobs amongst more workers, which might help speed up tests overall. Definitely looking forward to that PR. > Even more important is simplifying the test implementation. Right now updating tests and validation experiments is a time sink for developers that change the API and has really slowed development down lately. So we shouldn't rewrite tests in a way that makes development more difficult (eg keeping the maintenance burden of the test infrastructure small is more important than decreasing the computational cost of tests). This is really a side comment --- we should be able to improve the tests both so they are faster and easier to maintain, if we are careful. I definitely agree with that. I just don't see how to do it. Being thorough with the tests (which I believe is something we want) necessarily comes with using the API many times, making changes to it a bit slower to implement, no?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1990#issuecomment-922529440
Integrability,integrat,integration,">On #1962 we add bars capability, which will allow us to separate the tests into a few categories: fast-running, crucial tests will run on every commit to a PR, and slower, more comprehensive integration tests will run only when bors try or bors r+ is invoked. This might help streamline the development workflow. Also if we are using Caltech's central cluster for CI we can potentially split the jobs amongst more workers, which might help speed up tests overall. Definitely looking forward to that PR. > Even more important is simplifying the test implementation. Right now updating tests and validation experiments is a time sink for developers that change the API and has really slowed development down lately. So we shouldn't rewrite tests in a way that makes development more difficult (eg keeping the maintenance burden of the test infrastructure small is more important than decreasing the computational cost of tests). This is really a side comment --- we should be able to improve the tests both so they are faster and easier to maintain, if we are careful. I definitely agree with that. I just don't see how to do it. Being thorough with the tests (which I believe is something we want) necessarily comes with using the API many times, making changes to it a bit slower to implement, no?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1990#issuecomment-922529440
Modifiability,rewrite,rewrite,">On #1962 we add bars capability, which will allow us to separate the tests into a few categories: fast-running, crucial tests will run on every commit to a PR, and slower, more comprehensive integration tests will run only when bors try or bors r+ is invoked. This might help streamline the development workflow. Also if we are using Caltech's central cluster for CI we can potentially split the jobs amongst more workers, which might help speed up tests overall. Definitely looking forward to that PR. > Even more important is simplifying the test implementation. Right now updating tests and validation experiments is a time sink for developers that change the API and has really slowed development down lately. So we shouldn't rewrite tests in a way that makes development more difficult (eg keeping the maintenance burden of the test infrastructure small is more important than decreasing the computational cost of tests). This is really a side comment --- we should be able to improve the tests both so they are faster and easier to maintain, if we are careful. I definitely agree with that. I just don't see how to do it. Being thorough with the tests (which I believe is something we want) necessarily comes with using the API many times, making changes to it a bit slower to implement, no?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1990#issuecomment-922529440
Security,validat,validation,">On #1962 we add bars capability, which will allow us to separate the tests into a few categories: fast-running, crucial tests will run on every commit to a PR, and slower, more comprehensive integration tests will run only when bors try or bors r+ is invoked. This might help streamline the development workflow. Also if we are using Caltech's central cluster for CI we can potentially split the jobs amongst more workers, which might help speed up tests overall. Definitely looking forward to that PR. > Even more important is simplifying the test implementation. Right now updating tests and validation experiments is a time sink for developers that change the API and has really slowed development down lately. So we shouldn't rewrite tests in a way that makes development more difficult (eg keeping the maintenance burden of the test infrastructure small is more important than decreasing the computational cost of tests). This is really a side comment --- we should be able to improve the tests both so they are faster and easier to maintain, if we are careful. I definitely agree with that. I just don't see how to do it. Being thorough with the tests (which I believe is something we want) necessarily comes with using the API many times, making changes to it a bit slower to implement, no?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1990#issuecomment-922529440
Testability,test,tests,">On #1962 we add bars capability, which will allow us to separate the tests into a few categories: fast-running, crucial tests will run on every commit to a PR, and slower, more comprehensive integration tests will run only when bors try or bors r+ is invoked. This might help streamline the development workflow. Also if we are using Caltech's central cluster for CI we can potentially split the jobs amongst more workers, which might help speed up tests overall. Definitely looking forward to that PR. > Even more important is simplifying the test implementation. Right now updating tests and validation experiments is a time sink for developers that change the API and has really slowed development down lately. So we shouldn't rewrite tests in a way that makes development more difficult (eg keeping the maintenance burden of the test infrastructure small is more important than decreasing the computational cost of tests). This is really a side comment --- we should be able to improve the tests both so they are faster and easier to maintain, if we are careful. I definitely agree with that. I just don't see how to do it. Being thorough with the tests (which I believe is something we want) necessarily comes with using the API many times, making changes to it a bit slower to implement, no?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1990#issuecomment-922529440
Usability,simpl,simplifying,">On #1962 we add bars capability, which will allow us to separate the tests into a few categories: fast-running, crucial tests will run on every commit to a PR, and slower, more comprehensive integration tests will run only when bors try or bors r+ is invoked. This might help streamline the development workflow. Also if we are using Caltech's central cluster for CI we can potentially split the jobs amongst more workers, which might help speed up tests overall. Definitely looking forward to that PR. > Even more important is simplifying the test implementation. Right now updating tests and validation experiments is a time sink for developers that change the API and has really slowed development down lately. So we shouldn't rewrite tests in a way that makes development more difficult (eg keeping the maintenance burden of the test infrastructure small is more important than decreasing the computational cost of tests). This is really a side comment --- we should be able to improve the tests both so they are faster and easier to maintain, if we are careful. I definitely agree with that. I just don't see how to do it. Being thorough with the tests (which I believe is something we want) necessarily comes with using the API many times, making changes to it a bit slower to implement, no?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1990#issuecomment-922529440
Safety,avoid,avoid,"May I ask why it was decided to not call it Gent-McWilliams? I agree that in general it's good to avoid people's names in things, but in this case (imo) it makes it so much more clear what closure this is since that's what people always call it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1994#issuecomment-924418422
Usability,clear,clear,"May I ask why it was decided to not call it Gent-McWilliams? I agree that in general it's good to avoid people's names in things, but in this case (imo) it makes it so much more clear what closure this is since that's what people always call it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1994#issuecomment-924418422
Modifiability,parameteriz,parameterization,"> May I ask why it was decided to not call it Gent-McWilliams? I agree that in general it's good to avoid people's names in things, but in this case (imo) it makes it so much more clear what closure this is since that's what people always call it. As far as I can tell when people say they use ""Gent-McWilliams"" they are referring to a constant skew diffusivity (typically 0.3 m^2 / s). But in this closure, the diffusivity can be an arbitrary function or field. If anything it would have to be `GentMcWilliamsRedi` since we include the symmetric component as well as the skew component. Still though, I think it's important to emphasize that this closure is more general than Gent-McWilliams; not least because the only point in implementing this scheme is to develop a new, better, different parameterization.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1994#issuecomment-924962650
Safety,avoid,avoid,"> May I ask why it was decided to not call it Gent-McWilliams? I agree that in general it's good to avoid people's names in things, but in this case (imo) it makes it so much more clear what closure this is since that's what people always call it. As far as I can tell when people say they use ""Gent-McWilliams"" they are referring to a constant skew diffusivity (typically 0.3 m^2 / s). But in this closure, the diffusivity can be an arbitrary function or field. If anything it would have to be `GentMcWilliamsRedi` since we include the symmetric component as well as the skew component. Still though, I think it's important to emphasize that this closure is more general than Gent-McWilliams; not least because the only point in implementing this scheme is to develop a new, better, different parameterization.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1994#issuecomment-924962650
Usability,clear,clear,"> May I ask why it was decided to not call it Gent-McWilliams? I agree that in general it's good to avoid people's names in things, but in this case (imo) it makes it so much more clear what closure this is since that's what people always call it. As far as I can tell when people say they use ""Gent-McWilliams"" they are referring to a constant skew diffusivity (typically 0.3 m^2 / s). But in this closure, the diffusivity can be an arbitrary function or field. If anything it would have to be `GentMcWilliamsRedi` since we include the symmetric component as well as the skew component. Still though, I think it's important to emphasize that this closure is more general than Gent-McWilliams; not least because the only point in implementing this scheme is to develop a new, better, different parameterization.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1994#issuecomment-924962650
Modifiability,parameteriz,parameterization,"Was just looking through this, and not sure if there is still room for comments from noobs (happy to be ignored). Would `tensor_diffusivity` be a good name - skewsymmetric seems a bit like saying that a T-junction is a left_right_turn. :) . > > May I ask why it was decided to not call it Gent-McWilliams? I agree that in general it's good to avoid people's names in things, but in this case (imo) it makes it so much more clear what closure this is since that's what people always call it.; > ; > As far as I can tell when people say they use ""Gent-McWilliams"" they are referring to a constant skew diffusivity (typically 0.3 m^2 / s). But in this closure, the diffusivity can be an arbitrary function or field.; > ; > If anything it would have to be `GentMcWilliamsRedi` since we include the symmetric component as well as the skew component.; > ; > Still though, I think it's important to emphasize that this closure is more general than Gent-McWilliams; not least because the only point in implementing this scheme is to develop a new, better, different parameterization.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1994#issuecomment-971930449
Safety,avoid,avoid,"Was just looking through this, and not sure if there is still room for comments from noobs (happy to be ignored). Would `tensor_diffusivity` be a good name - skewsymmetric seems a bit like saying that a T-junction is a left_right_turn. :) . > > May I ask why it was decided to not call it Gent-McWilliams? I agree that in general it's good to avoid people's names in things, but in this case (imo) it makes it so much more clear what closure this is since that's what people always call it.; > ; > As far as I can tell when people say they use ""Gent-McWilliams"" they are referring to a constant skew diffusivity (typically 0.3 m^2 / s). But in this closure, the diffusivity can be an arbitrary function or field.; > ; > If anything it would have to be `GentMcWilliamsRedi` since we include the symmetric component as well as the skew component.; > ; > Still though, I think it's important to emphasize that this closure is more general than Gent-McWilliams; not least because the only point in implementing this scheme is to develop a new, better, different parameterization.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1994#issuecomment-971930449
Usability,clear,clear,"Was just looking through this, and not sure if there is still room for comments from noobs (happy to be ignored). Would `tensor_diffusivity` be a good name - skewsymmetric seems a bit like saying that a T-junction is a left_right_turn. :) . > > May I ask why it was decided to not call it Gent-McWilliams? I agree that in general it's good to avoid people's names in things, but in this case (imo) it makes it so much more clear what closure this is since that's what people always call it.; > ; > As far as I can tell when people say they use ""Gent-McWilliams"" they are referring to a constant skew diffusivity (typically 0.3 m^2 / s). But in this closure, the diffusivity can be an arbitrary function or field.; > ; > If anything it would have to be `GentMcWilliamsRedi` since we include the symmetric component as well as the skew component.; > ; > Still though, I think it's important to emphasize that this closure is more general than Gent-McWilliams; not least because the only point in implementing this scheme is to develop a new, better, different parameterization.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1994#issuecomment-971930449
Safety,safe,safe,"> I'm not sure I follow then. Are you saying that you're not sure all the versions in this range are bug-free? That being the case it's best to pin it to a version we know is safe?; > […](#); > On Tue, Oct 5, 2021, 17:05 Gregory L. Wagner ***@***.***> wrote: ***@***.**** commented on this pull request. ------------------------------ In Project.toml <[#1997 (comment)](https://github.com/CliMA/Oceananigans.jl/pull/1997#discussion_r722703022)> : > @@ -33,7 +33,7 @@ Tullio = ""bc48ee85-29a4-5162-ae0b-a64e1601d4bc"" [compat] Adapt = ""^3"" -CUDA = ""3"" +CUDA = ""3.0.0 - 3.3.6"" Note that Manifest.toml pins a specific version. Right, that's why I figured making it specific was the safest option. — You are receiving this because you were mentioned. Reply to this email directly, view it on GitHub <[#1997 (comment)](https://github.com/CliMA/Oceananigans.jl/pull/1997#discussion_r722703022)>, or unsubscribe <https://github.com/notifications/unsubscribe-auth/ADEX5KRJ3DYWCNI4IRO6RNTUFNSC3ANCNFSM5FKUICWQ> . Triage notifications on the go with GitHub Mobile for iOS <https://apps.apple.com/app/apple-store/id1477376905?ct=notification-email&mt=8&pt=524675> or Android <https://play.google.com/store/apps/details?id=com.github.android&referrer=utm_campaign%3Dnotification-email%26utm_medium%3Demail%26utm_source%3Dgithub>. Oh, I just can't remember how far back we're able to go. But if you've gone to the effort to test a whole range of versions then certainly we might as well use a range, since it has the benefits you mentioned! My thought was just that it'd be quick and simple to pin to the version in the Manifest.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1997#issuecomment-935031502
Testability,test,test,"> I'm not sure I follow then. Are you saying that you're not sure all the versions in this range are bug-free? That being the case it's best to pin it to a version we know is safe?; > […](#); > On Tue, Oct 5, 2021, 17:05 Gregory L. Wagner ***@***.***> wrote: ***@***.**** commented on this pull request. ------------------------------ In Project.toml <[#1997 (comment)](https://github.com/CliMA/Oceananigans.jl/pull/1997#discussion_r722703022)> : > @@ -33,7 +33,7 @@ Tullio = ""bc48ee85-29a4-5162-ae0b-a64e1601d4bc"" [compat] Adapt = ""^3"" -CUDA = ""3"" +CUDA = ""3.0.0 - 3.3.6"" Note that Manifest.toml pins a specific version. Right, that's why I figured making it specific was the safest option. — You are receiving this because you were mentioned. Reply to this email directly, view it on GitHub <[#1997 (comment)](https://github.com/CliMA/Oceananigans.jl/pull/1997#discussion_r722703022)>, or unsubscribe <https://github.com/notifications/unsubscribe-auth/ADEX5KRJ3DYWCNI4IRO6RNTUFNSC3ANCNFSM5FKUICWQ> . Triage notifications on the go with GitHub Mobile for iOS <https://apps.apple.com/app/apple-store/id1477376905?ct=notification-email&mt=8&pt=524675> or Android <https://play.google.com/store/apps/details?id=com.github.android&referrer=utm_campaign%3Dnotification-email%26utm_medium%3Demail%26utm_source%3Dgithub>. Oh, I just can't remember how far back we're able to go. But if you've gone to the effort to test a whole range of versions then certainly we might as well use a range, since it has the benefits you mentioned! My thought was just that it'd be quick and simple to pin to the version in the Manifest.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1997#issuecomment-935031502
Usability,simpl,simple,"> I'm not sure I follow then. Are you saying that you're not sure all the versions in this range are bug-free? That being the case it's best to pin it to a version we know is safe?; > […](#); > On Tue, Oct 5, 2021, 17:05 Gregory L. Wagner ***@***.***> wrote: ***@***.**** commented on this pull request. ------------------------------ In Project.toml <[#1997 (comment)](https://github.com/CliMA/Oceananigans.jl/pull/1997#discussion_r722703022)> : > @@ -33,7 +33,7 @@ Tullio = ""bc48ee85-29a4-5162-ae0b-a64e1601d4bc"" [compat] Adapt = ""^3"" -CUDA = ""3"" +CUDA = ""3.0.0 - 3.3.6"" Note that Manifest.toml pins a specific version. Right, that's why I figured making it specific was the safest option. — You are receiving this because you were mentioned. Reply to this email directly, view it on GitHub <[#1997 (comment)](https://github.com/CliMA/Oceananigans.jl/pull/1997#discussion_r722703022)>, or unsubscribe <https://github.com/notifications/unsubscribe-auth/ADEX5KRJ3DYWCNI4IRO6RNTUFNSC3ANCNFSM5FKUICWQ> . Triage notifications on the go with GitHub Mobile for iOS <https://apps.apple.com/app/apple-store/id1477376905?ct=notification-email&mt=8&pt=524675> or Android <https://play.google.com/store/apps/details?id=com.github.android&referrer=utm_campaign%3Dnotification-email%26utm_medium%3Demail%26utm_source%3Dgithub>. Oh, I just can't remember how far back we're able to go. But if you've gone to the effort to test a whole range of versions then certainly we might as well use a range, since it has the benefits you mentioned! My thought was just that it'd be quick and simple to pin to the version in the Manifest.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1997#issuecomment-935031502
Usability,undo,undo,Closing this since it'll undo https://github.com/CliMA/Oceananigans.jl/pull/1997,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1999#issuecomment-937048847
Safety,avoid,avoid,"Resolution is kinda used ambiguously, which is why we renamed ""resolution"" to ""size"", no?. While most people take ""resolution"" to mean grid spacing (myself included), as you yourself pointed out some can take it to mean grid size, so I feel we should avoid this word. I could just keep it as ""grid spacing"" which is absolutely clear and merge it as it is.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2010#issuecomment-942659233
Usability,clear,clear,"Resolution is kinda used ambiguously, which is why we renamed ""resolution"" to ""size"", no?. While most people take ""resolution"" to mean grid spacing (myself included), as you yourself pointed out some can take it to mean grid size, so I feel we should avoid this word. I could just keep it as ""grid spacing"" which is absolutely clear and merge it as it is.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2010#issuecomment-942659233
Usability,intuit,intuitive,This apparently has to do with the fact that . ```julia; julia> grid1.zᵃᵃᶜ === grid2.zᵃᵃᶜ; false. julia> grid1.zᵃᵃᶠ === grid2.zᵃᵃᶠ; false. ```. I don't think this is a due to the grid design as this appears to be standard Julia behavior for arrays:. ```julia; julia> zeros(3) == zeros(3); true. julia> zeros(3) === zeros(3); false. ```. which seems pretty counter-intuitive to me and apparently there's some discussion about this behavior in julia already: https://github.com/JuliaLang/julia/issues/4648,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2018#issuecomment-945144113
Usability,intuit,intuitive,"> This apparently has to do with the fact that; > ; > ```julia; > julia> grid1.zᵃᵃᶜ === grid2.zᵃᵃᶜ; > false; > ; > julia> grid1.zᵃᵃᶠ === grid2.zᵃᵃᶠ; > false; > ```; > ; > I don't think this is a due to the grid design as this appears to be standard Julia behavior for arrays:; > ; > ```julia; > julia> zeros(3) == zeros(3); > true; > ; > julia> zeros(3) === zeros(3); > false; > ```; > ; > which seems pretty counter-intuitive to me and apparently there's some discussion about this behavior in julia already: [JuliaLang/julia#4648](https://github.com/JuliaLang/julia/issues/4648). `===` means that ""no program can distinguish"" between the objects. For arrays this basically means they point to the same space in memory; changes to one imply changes in another. `==` is a weaker statement, usually about numerical equality. What's counter intuitive?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2018#issuecomment-945824870
Performance,perform,performing,"> === means that ""no program can distinguish"" between the objects. For arrays this basically means they point to the same space in memory; changes to one imply changes in another. == is a weaker statement, usually about numerical equality. What's counter intuitive?. Oh yeah I know about `===`. What I mean is that you test two grids with `==`, but Julia then tests each property with `===`. So the user is actually performing a much stricter operation than what it seems at first sight. That's the un-intuitive part to me. Although I may be missing something.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2018#issuecomment-945862255
Testability,test,test,"> === means that ""no program can distinguish"" between the objects. For arrays this basically means they point to the same space in memory; changes to one imply changes in another. == is a weaker statement, usually about numerical equality. What's counter intuitive?. Oh yeah I know about `===`. What I mean is that you test two grids with `==`, but Julia then tests each property with `===`. So the user is actually performing a much stricter operation than what it seems at first sight. That's the un-intuitive part to me. Although I may be missing something.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2018#issuecomment-945862255
Usability,intuit,intuitive,"> === means that ""no program can distinguish"" between the objects. For arrays this basically means they point to the same space in memory; changes to one imply changes in another. == is a weaker statement, usually about numerical equality. What's counter intuitive?. Oh yeah I know about `===`. What I mean is that you test two grids with `==`, but Julia then tests each property with `===`. So the user is actually performing a much stricter operation than what it seems at first sight. That's the un-intuitive part to me. Although I may be missing something.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2018#issuecomment-945862255
Usability,intuit,intuitive,"> That's because `==` falls back to `===`, right?. No idea! Like I said, it's not very intuitive behavior to me. You probably understand this way better.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2018#issuecomment-945891999
Usability,simpl,simplest,"> I intend to merge this though. It's just that apparently #1998 needs to be finished first, according to @navidcy at least, so I thought I'd wait for that. Are you suggesting we move on this one before other PRs and just for vertically stretched grids?. Nah... Well, I may have initially thought that #1998 was important to finish first, but I take it back :); Let's make this work for all grids in the simplest manner possible and merge it?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2019#issuecomment-946332878
Safety,avoid,avoid,"I agree that it'd be good to have a different name for them to avoid confusion. I think `thermodynamics` is not very intuitive, but I do agree with the name `active_tracers`. We would need to change the name `SeawaterBuoyancy` though, like you mentioned.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2022#issuecomment-949813544
Usability,intuit,intuitive,"I agree that it'd be good to have a different name for them to avoid confusion. I think `thermodynamics` is not very intuitive, but I do agree with the name `active_tracers`. We would need to change the name `SeawaterBuoyancy` though, like you mentioned.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2022#issuecomment-949813544
Usability,clear,clear,"Ah, sorry for not being clear. In summary: I agree with you. I can't think of anything better than `active_tracers` though. My suggestion is:. - Rename `buoyancy.model` to `buoyancy.active_tracers`; - Rename `SeawaterBuoyancy` to `TemperatureSalinityTracers`. Which I think is pretty clear.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2022#issuecomment-950020648
Usability,simpl,simpler,"Oh interesting there is a difference between `Integral` and `Average`. Another thing to try is something like `Reduction(sum!, c, dims=1)` which is even simpler...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2024#issuecomment-2168694876
Testability,test,test,"> @tomchor what do you think about this?; > ; > (I didn't wanna make changes to your branch in case you are using it for work, so I branched of there...). Thanks, that very thoughtful. I am indeed using that branch for research :). The PR also looks very good! This is exactly what I had in mind :+1:. Sorry I haven't done this yet in my original PR. I was actually planning on doing it this weekend but I got busy. . Should we add an equality test for grids? I think we can get away with something as simple as `@test grid == deepcopy(grid)` no? (This used to return false for vertically stretched grids.)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2028#issuecomment-950483789
Usability,simpl,simple,"> @tomchor what do you think about this?; > ; > (I didn't wanna make changes to your branch in case you are using it for work, so I branched of there...). Thanks, that very thoughtful. I am indeed using that branch for research :). The PR also looks very good! This is exactly what I had in mind :+1:. Sorry I haven't done this yet in my original PR. I was actually planning on doing it this weekend but I got busy. . Should we add an equality test for grids? I think we can get away with something as simple as `@test grid == deepcopy(grid)` no? (This used to return false for vertically stretched grids.)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2028#issuecomment-950483789
Testability,test,test,> Should we add an equality test for grids? I think we can get away with something as simple as `@test grid == deepcopy(grid)` no? (This used to return false for vertically stretched grids.). We should! But I'll try to test a few cases... different type of grids and on different architectures.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2028#issuecomment-950493532
Usability,simpl,simple,> Should we add an equality test for grids? I think we can get away with something as simple as `@test grid == deepcopy(grid)` no? (This used to return false for vertically stretched grids.). We should! But I'll try to test a few cases... different type of grids and on different architectures.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2028#issuecomment-950493532
Safety,avoid,avoided,"Calculating trigonometric functions is ""slow"" (compared to simple arithmetic operations) on _all_ hardware because they require various series expansions and iterative calculations. Division is also ""slow""; a single division operation requires something like 20 operations. An issue with any psuedo-anecdotal advice like this is that it may not be valid on all hardware. Just how ""slow"" is `sin` on various hardware? Is it slow on all Nvidia GPUs, or just some? Is it slow on AMD GPUs? What does ""slow"" mean, exactly?. Philosophically, I disagree that trigonometric functions should be avoided. Speed is not always a primary concern for computations. Other concerns that may be equally or more important are reproducibility, programmer productivity, accuracy, etc. I think that users will probably better served by a nice comprehensive reference to floating point calculations on various hardware on CPUs and GPUs...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2029#issuecomment-951424095
Usability,simpl,simple,"Calculating trigonometric functions is ""slow"" (compared to simple arithmetic operations) on _all_ hardware because they require various series expansions and iterative calculations. Division is also ""slow""; a single division operation requires something like 20 operations. An issue with any psuedo-anecdotal advice like this is that it may not be valid on all hardware. Just how ""slow"" is `sin` on various hardware? Is it slow on all Nvidia GPUs, or just some? Is it slow on AMD GPUs? What does ""slow"" mean, exactly?. Philosophically, I disagree that trigonometric functions should be avoided. Speed is not always a primary concern for computations. Other concerns that may be equally or more important are reproducibility, programmer productivity, accuracy, etc. I think that users will probably better served by a nice comprehensive reference to floating point calculations on various hardware on CPUs and GPUs...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2029#issuecomment-951424095
Performance,perform,performed,"> It seems very strange to me that evaluating trig functions is slow on GPUs. Is this we problem known to CUDA.jl?; > ; > The information you have here seems good to me. ""slow"" is ill-defined. We recently found that precomputing grid metrics for the latitude-longitude grid leads to a 2x speed up for simple 2D cases (less for more complex cases, probably). But it's all relative to other calculations that are being performed. For many ocean codes the limiting step is evaluating the nonlinear equation of state (a 55 term polynomial) at various locations on the grid. For these cases, the cost of trigonometric functions may not be noticeable.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2029#issuecomment-951425085
Usability,simpl,simple,"> It seems very strange to me that evaluating trig functions is slow on GPUs. Is this we problem known to CUDA.jl?; > ; > The information you have here seems good to me. ""slow"" is ill-defined. We recently found that precomputing grid metrics for the latitude-longitude grid leads to a 2x speed up for simple 2D cases (less for more complex cases, probably). But it's all relative to other calculations that are being performed. For many ocean codes the limiting step is evaluating the nonlinear equation of state (a 55 term polynomial) at various locations on the grid. For these cases, the cost of trigonometric functions may not be noticeable.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2029#issuecomment-951425085
Performance,perform,performed,"Instead of saying that trig functions should be avoided on gpus, which seems very strong, I suggest pointing out that there have been some examples where trig functions have performed much slower, and include this example. . This clearly problem needs further exploration but I don't want people to be scared to use sin and cos because sometimes they just make a lot of sense. My two cents worth.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2029#issuecomment-951478103
Safety,avoid,avoided,"Instead of saying that trig functions should be avoided on gpus, which seems very strong, I suggest pointing out that there have been some examples where trig functions have performed much slower, and include this example. . This clearly problem needs further exploration but I don't want people to be scared to use sin and cos because sometimes they just make a lot of sense. My two cents worth.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2029#issuecomment-951478103
Usability,clear,clearly,"Instead of saying that trig functions should be avoided on gpus, which seems very strong, I suggest pointing out that there have been some examples where trig functions have performed much slower, and include this example. . This clearly problem needs further exploration but I don't want people to be scared to use sin and cos because sometimes they just make a lot of sense. My two cents worth.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2029#issuecomment-951478103
Performance,perform,performed,"> Instead of saying that trig functions should be avoided on gpus, which seems very strong, I suggest pointing out that there have been some examples where trig functions have performed much slower, and include this example.; > ; > This clearly problem needs further exploration but I don't want people to be scared to use sin and cos because sometimes they just make a lot of sense. My two cents worth. I think there may be a bug in the setup that produces 100x slowdown. (@tomchor if you supply the whole script, we can investigate.) We've run many successful problems with trig functions. Some recent work by @simone-silvestri suggests we can get 2x speed up for _some_ problems by precomputing grid metrics for the `RegularLatitudeLongitudeGrid` rather than computing them on the fly:. https://github.com/CliMA/Oceananigans.jl/blob/da9c53ddd9e28d123b40726cfac2fad835284879/src/Operators/spacings_and_areas_and_volumes.jl#L178-L179. But I don't think we've definitely shown that we _always_ will get 2x speed up. Thus we are going to retain the option to compute metrics on the fly in #2025 so we can continue to investigate it. 2x is a long way from 100x though. If used in a boundary conditions, its basically irrelevant whether one uses a trig function or not. Even a forcing function is only evaluated once per grid point compared to 15x (or more?) for a `BackgroundField` velocity component with high-order advection. Some of these thoughts might be distilled into useful advice in this section of the docs. But we should definitely focus on _approaches_ to performance optimization rather than advice for specific scenarios.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2029#issuecomment-951555050
Safety,avoid,avoided,"> Instead of saying that trig functions should be avoided on gpus, which seems very strong, I suggest pointing out that there have been some examples where trig functions have performed much slower, and include this example.; > ; > This clearly problem needs further exploration but I don't want people to be scared to use sin and cos because sometimes they just make a lot of sense. My two cents worth. I think there may be a bug in the setup that produces 100x slowdown. (@tomchor if you supply the whole script, we can investigate.) We've run many successful problems with trig functions. Some recent work by @simone-silvestri suggests we can get 2x speed up for _some_ problems by precomputing grid metrics for the `RegularLatitudeLongitudeGrid` rather than computing them on the fly:. https://github.com/CliMA/Oceananigans.jl/blob/da9c53ddd9e28d123b40726cfac2fad835284879/src/Operators/spacings_and_areas_and_volumes.jl#L178-L179. But I don't think we've definitely shown that we _always_ will get 2x speed up. Thus we are going to retain the option to compute metrics on the fly in #2025 so we can continue to investigate it. 2x is a long way from 100x though. If used in a boundary conditions, its basically irrelevant whether one uses a trig function or not. Even a forcing function is only evaluated once per grid point compared to 15x (or more?) for a `BackgroundField` velocity component with high-order advection. Some of these thoughts might be distilled into useful advice in this section of the docs. But we should definitely focus on _approaches_ to performance optimization rather than advice for specific scenarios.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2029#issuecomment-951555050
Usability,clear,clearly,"> Instead of saying that trig functions should be avoided on gpus, which seems very strong, I suggest pointing out that there have been some examples where trig functions have performed much slower, and include this example.; > ; > This clearly problem needs further exploration but I don't want people to be scared to use sin and cos because sometimes they just make a lot of sense. My two cents worth. I think there may be a bug in the setup that produces 100x slowdown. (@tomchor if you supply the whole script, we can investigate.) We've run many successful problems with trig functions. Some recent work by @simone-silvestri suggests we can get 2x speed up for _some_ problems by precomputing grid metrics for the `RegularLatitudeLongitudeGrid` rather than computing them on the fly:. https://github.com/CliMA/Oceananigans.jl/blob/da9c53ddd9e28d123b40726cfac2fad835284879/src/Operators/spacings_and_areas_and_volumes.jl#L178-L179. But I don't think we've definitely shown that we _always_ will get 2x speed up. Thus we are going to retain the option to compute metrics on the fly in #2025 so we can continue to investigate it. 2x is a long way from 100x though. If used in a boundary conditions, its basically irrelevant whether one uses a trig function or not. Even a forcing function is only evaluated once per grid point compared to 15x (or more?) for a `BackgroundField` velocity component with high-order advection. Some of these thoughts might be distilled into useful advice in this section of the docs. But we should definitely focus on _approaches_ to performance optimization rather than advice for specific scenarios.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2029#issuecomment-951555050
Energy Efficiency,efficient,efficient,"t dropped it). I also slightly reworded it to have less absolute statements, but further rewording is necessary after we finish this discussion I think.; > ; > Some notes:; > ; > * The same code on CPUs isn't even close to have the same slowdown. So there's definitely something going on here for GPUs; > * I have struggled with this for quite some time until I found the culprit, so if we can't immediately find and fix the cause I'd suggest leaving a caution statement on the simulation tips page. But I agree it has to be less strongly worded...; > ; > I'll try to provide a MWE that reproduces the behavior, but I'm currently having trouble getting my hands on some GPU, so I'm not sure how fast I can do that. Ok, no rush!. Trig functions aren't generically slower on GPUs than CPUs. On CPUs I think our code is fairly non-optimal right now, so various sources of overhead (eg non-optimal threading) can ""hide"" slow operations on the CPU. On the GPU we are more efficient, so overall speed might depend more sensitively on user code when it's injected. (I'd also argue that the beginning of this section is a bit misleading in how it claims we ""try to optimize"" internal source code. In fact, we have performed almost no performance optimization, and this is an important topic for future work.). I found this reference for the cost of various floating point operations on the CPU:. https://latkin.org/blog/2014/11/09/a-simple-benchmark-of-various-math-operations/. We could reproduce this chart on a GPU with CUDA.jl if we want to provide some useful information to users. I think if we're talking about a _constant_ (the current case), then precomputation hardly harms code complexity (both examples are equally readable to me). Precomputing an _array_ is another story (for example, a forcing function or boundary condition that depends on `sin(x)`). This lesson is definitely not restricted to trigonometric functions or the GPU. The basic principle here is that _there is a trade-off_ betwe",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2029#issuecomment-952107151
Integrability,depend,depend,"t dropped it). I also slightly reworded it to have less absolute statements, but further rewording is necessary after we finish this discussion I think.; > ; > Some notes:; > ; > * The same code on CPUs isn't even close to have the same slowdown. So there's definitely something going on here for GPUs; > * I have struggled with this for quite some time until I found the culprit, so if we can't immediately find and fix the cause I'd suggest leaving a caution statement on the simulation tips page. But I agree it has to be less strongly worded...; > ; > I'll try to provide a MWE that reproduces the behavior, but I'm currently having trouble getting my hands on some GPU, so I'm not sure how fast I can do that. Ok, no rush!. Trig functions aren't generically slower on GPUs than CPUs. On CPUs I think our code is fairly non-optimal right now, so various sources of overhead (eg non-optimal threading) can ""hide"" slow operations on the CPU. On the GPU we are more efficient, so overall speed might depend more sensitively on user code when it's injected. (I'd also argue that the beginning of this section is a bit misleading in how it claims we ""try to optimize"" internal source code. In fact, we have performed almost no performance optimization, and this is an important topic for future work.). I found this reference for the cost of various floating point operations on the CPU:. https://latkin.org/blog/2014/11/09/a-simple-benchmark-of-various-math-operations/. We could reproduce this chart on a GPU with CUDA.jl if we want to provide some useful information to users. I think if we're talking about a _constant_ (the current case), then precomputation hardly harms code complexity (both examples are equally readable to me). Precomputing an _array_ is another story (for example, a forcing function or boundary condition that depends on `sin(x)`). This lesson is definitely not restricted to trigonometric functions or the GPU. The basic principle here is that _there is a trade-off_ betwe",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2029#issuecomment-952107151
Performance,optimiz,optimize,"inish this discussion I think.; > ; > Some notes:; > ; > * The same code on CPUs isn't even close to have the same slowdown. So there's definitely something going on here for GPUs; > * I have struggled with this for quite some time until I found the culprit, so if we can't immediately find and fix the cause I'd suggest leaving a caution statement on the simulation tips page. But I agree it has to be less strongly worded...; > ; > I'll try to provide a MWE that reproduces the behavior, but I'm currently having trouble getting my hands on some GPU, so I'm not sure how fast I can do that. Ok, no rush!. Trig functions aren't generically slower on GPUs than CPUs. On CPUs I think our code is fairly non-optimal right now, so various sources of overhead (eg non-optimal threading) can ""hide"" slow operations on the CPU. On the GPU we are more efficient, so overall speed might depend more sensitively on user code when it's injected. (I'd also argue that the beginning of this section is a bit misleading in how it claims we ""try to optimize"" internal source code. In fact, we have performed almost no performance optimization, and this is an important topic for future work.). I found this reference for the cost of various floating point operations on the CPU:. https://latkin.org/blog/2014/11/09/a-simple-benchmark-of-various-math-operations/. We could reproduce this chart on a GPU with CUDA.jl if we want to provide some useful information to users. I think if we're talking about a _constant_ (the current case), then precomputation hardly harms code complexity (both examples are equally readable to me). Precomputing an _array_ is another story (for example, a forcing function or boundary condition that depends on `sin(x)`). This lesson is definitely not restricted to trigonometric functions or the GPU. The basic principle here is that _there is a trade-off_ between precomputing a potentially expensive operation, and performing it on-the-fly. For constants, precomputation is harmless.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2029#issuecomment-952107151
Security,inject,injected,"t dropped it). I also slightly reworded it to have less absolute statements, but further rewording is necessary after we finish this discussion I think.; > ; > Some notes:; > ; > * The same code on CPUs isn't even close to have the same slowdown. So there's definitely something going on here for GPUs; > * I have struggled with this for quite some time until I found the culprit, so if we can't immediately find and fix the cause I'd suggest leaving a caution statement on the simulation tips page. But I agree it has to be less strongly worded...; > ; > I'll try to provide a MWE that reproduces the behavior, but I'm currently having trouble getting my hands on some GPU, so I'm not sure how fast I can do that. Ok, no rush!. Trig functions aren't generically slower on GPUs than CPUs. On CPUs I think our code is fairly non-optimal right now, so various sources of overhead (eg non-optimal threading) can ""hide"" slow operations on the CPU. On the GPU we are more efficient, so overall speed might depend more sensitively on user code when it's injected. (I'd also argue that the beginning of this section is a bit misleading in how it claims we ""try to optimize"" internal source code. In fact, we have performed almost no performance optimization, and this is an important topic for future work.). I found this reference for the cost of various floating point operations on the CPU:. https://latkin.org/blog/2014/11/09/a-simple-benchmark-of-various-math-operations/. We could reproduce this chart on a GPU with CUDA.jl if we want to provide some useful information to users. I think if we're talking about a _constant_ (the current case), then precomputation hardly harms code complexity (both examples are equally readable to me). Precomputing an _array_ is another story (for example, a forcing function or boundary condition that depends on `sin(x)`). This lesson is definitely not restricted to trigonometric functions or the GPU. The basic principle here is that _there is a trade-off_ betwe",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2029#issuecomment-952107151
Testability,benchmark,benchmark-of-various-math-operations,"uggest leaving a caution statement on the simulation tips page. But I agree it has to be less strongly worded...; > ; > I'll try to provide a MWE that reproduces the behavior, but I'm currently having trouble getting my hands on some GPU, so I'm not sure how fast I can do that. Ok, no rush!. Trig functions aren't generically slower on GPUs than CPUs. On CPUs I think our code is fairly non-optimal right now, so various sources of overhead (eg non-optimal threading) can ""hide"" slow operations on the CPU. On the GPU we are more efficient, so overall speed might depend more sensitively on user code when it's injected. (I'd also argue that the beginning of this section is a bit misleading in how it claims we ""try to optimize"" internal source code. In fact, we have performed almost no performance optimization, and this is an important topic for future work.). I found this reference for the cost of various floating point operations on the CPU:. https://latkin.org/blog/2014/11/09/a-simple-benchmark-of-various-math-operations/. We could reproduce this chart on a GPU with CUDA.jl if we want to provide some useful information to users. I think if we're talking about a _constant_ (the current case), then precomputation hardly harms code complexity (both examples are equally readable to me). Precomputing an _array_ is another story (for example, a forcing function or boundary condition that depends on `sin(x)`). This lesson is definitely not restricted to trigonometric functions or the GPU. The basic principle here is that _there is a trade-off_ between precomputing a potentially expensive operation, and performing it on-the-fly. For constants, precomputation is harmless. For arrays, on-the-fly computation has significant benefits, both for code readability and also possibly for performance (in memory-bound computations). Enlightening users on 1) the existence of this trade-off and 2) how to use benchmarking to find the optimal solution for their problem would probably be useful.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2029#issuecomment-952107151
Usability,simpl,simple-benchmark-of-various-math-operations,"uggest leaving a caution statement on the simulation tips page. But I agree it has to be less strongly worded...; > ; > I'll try to provide a MWE that reproduces the behavior, but I'm currently having trouble getting my hands on some GPU, so I'm not sure how fast I can do that. Ok, no rush!. Trig functions aren't generically slower on GPUs than CPUs. On CPUs I think our code is fairly non-optimal right now, so various sources of overhead (eg non-optimal threading) can ""hide"" slow operations on the CPU. On the GPU we are more efficient, so overall speed might depend more sensitively on user code when it's injected. (I'd also argue that the beginning of this section is a bit misleading in how it claims we ""try to optimize"" internal source code. In fact, we have performed almost no performance optimization, and this is an important topic for future work.). I found this reference for the cost of various floating point operations on the CPU:. https://latkin.org/blog/2014/11/09/a-simple-benchmark-of-various-math-operations/. We could reproduce this chart on a GPU with CUDA.jl if we want to provide some useful information to users. I think if we're talking about a _constant_ (the current case), then precomputation hardly harms code complexity (both examples are equally readable to me). Precomputing an _array_ is another story (for example, a forcing function or boundary condition that depends on `sin(x)`). This lesson is definitely not restricted to trigonometric functions or the GPU. The basic principle here is that _there is a trade-off_ between precomputing a potentially expensive operation, and performing it on-the-fly. For constants, precomputation is harmless. For arrays, on-the-fly computation has significant benefits, both for code readability and also possibly for performance (in memory-bound computations). Enlightening users on 1) the existence of this trade-off and 2) how to use benchmarking to find the optimal solution for their problem would probably be useful.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2029#issuecomment-952107151
Deployability,patch,patch,"> @tomchor:; > ; > * I don't understand what ""really"" means in ""it didn't really work"". Did it work or it didn't work?; > * In case there was an issue, can you elaborate what that was and why `Adapt` is the solution?; > * Last, if there is still an issue and this PR fixes it then it worths a patch release. There is no quota of patch releases. We can release as many as we need to. Sorry, let me be more clear:. - It _worked_ when I tried with a MWE that I had. I didn't try it with my main research code at the time because I only had limited GPU time and that code takes a while (I've been having trouble getting my hands on GPUs). However, I assume I must have done something wrong with my MWE because when I finally was able to test this with my main research code I wasn't able to start the simulation; - The issue that popped up was a scalar indexing one. I think basically the `z1==z2` equality uses scalar indexing, which doesn't work for GPUs. Wrapping the `nodes()` expression with `Adapt.adapt()` seemed to solve the issue on every instance that I was able to test so far. I guess `CUDA.@allowscalar` would also be a possibility.; - I will bump a patch release then. I just wasn't sure if we wanted to release a another version with just one PR.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2030#issuecomment-953477212
Energy Efficiency,adapt,adapt,"> @tomchor:; > ; > * I don't understand what ""really"" means in ""it didn't really work"". Did it work or it didn't work?; > * In case there was an issue, can you elaborate what that was and why `Adapt` is the solution?; > * Last, if there is still an issue and this PR fixes it then it worths a patch release. There is no quota of patch releases. We can release as many as we need to. Sorry, let me be more clear:. - It _worked_ when I tried with a MWE that I had. I didn't try it with my main research code at the time because I only had limited GPU time and that code takes a while (I've been having trouble getting my hands on GPUs). However, I assume I must have done something wrong with my MWE because when I finally was able to test this with my main research code I wasn't able to start the simulation; - The issue that popped up was a scalar indexing one. I think basically the `z1==z2` equality uses scalar indexing, which doesn't work for GPUs. Wrapping the `nodes()` expression with `Adapt.adapt()` seemed to solve the issue on every instance that I was able to test so far. I guess `CUDA.@allowscalar` would also be a possibility.; - I will bump a patch release then. I just wasn't sure if we wanted to release a another version with just one PR.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2030#issuecomment-953477212
Modifiability,adapt,adapt,"> @tomchor:; > ; > * I don't understand what ""really"" means in ""it didn't really work"". Did it work or it didn't work?; > * In case there was an issue, can you elaborate what that was and why `Adapt` is the solution?; > * Last, if there is still an issue and this PR fixes it then it worths a patch release. There is no quota of patch releases. We can release as many as we need to. Sorry, let me be more clear:. - It _worked_ when I tried with a MWE that I had. I didn't try it with my main research code at the time because I only had limited GPU time and that code takes a while (I've been having trouble getting my hands on GPUs). However, I assume I must have done something wrong with my MWE because when I finally was able to test this with my main research code I wasn't able to start the simulation; - The issue that popped up was a scalar indexing one. I think basically the `z1==z2` equality uses scalar indexing, which doesn't work for GPUs. Wrapping the `nodes()` expression with `Adapt.adapt()` seemed to solve the issue on every instance that I was able to test so far. I guess `CUDA.@allowscalar` would also be a possibility.; - I will bump a patch release then. I just wasn't sure if we wanted to release a another version with just one PR.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2030#issuecomment-953477212
Testability,test,test,"> @tomchor:; > ; > * I don't understand what ""really"" means in ""it didn't really work"". Did it work or it didn't work?; > * In case there was an issue, can you elaborate what that was and why `Adapt` is the solution?; > * Last, if there is still an issue and this PR fixes it then it worths a patch release. There is no quota of patch releases. We can release as many as we need to. Sorry, let me be more clear:. - It _worked_ when I tried with a MWE that I had. I didn't try it with my main research code at the time because I only had limited GPU time and that code takes a while (I've been having trouble getting my hands on GPUs). However, I assume I must have done something wrong with my MWE because when I finally was able to test this with my main research code I wasn't able to start the simulation; - The issue that popped up was a scalar indexing one. I think basically the `z1==z2` equality uses scalar indexing, which doesn't work for GPUs. Wrapping the `nodes()` expression with `Adapt.adapt()` seemed to solve the issue on every instance that I was able to test so far. I guess `CUDA.@allowscalar` would also be a possibility.; - I will bump a patch release then. I just wasn't sure if we wanted to release a another version with just one PR.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2030#issuecomment-953477212
Usability,clear,clear,"> @tomchor:; > ; > * I don't understand what ""really"" means in ""it didn't really work"". Did it work or it didn't work?; > * In case there was an issue, can you elaborate what that was and why `Adapt` is the solution?; > * Last, if there is still an issue and this PR fixes it then it worths a patch release. There is no quota of patch releases. We can release as many as we need to. Sorry, let me be more clear:. - It _worked_ when I tried with a MWE that I had. I didn't try it with my main research code at the time because I only had limited GPU time and that code takes a while (I've been having trouble getting my hands on GPUs). However, I assume I must have done something wrong with my MWE because when I finally was able to test this with my main research code I wasn't able to start the simulation; - The issue that popped up was a scalar indexing one. I think basically the `z1==z2` equality uses scalar indexing, which doesn't work for GPUs. Wrapping the `nodes()` expression with `Adapt.adapt()` seemed to solve the issue on every instance that I was able to test so far. I guess `CUDA.@allowscalar` would also be a possibility.; - I will bump a patch release then. I just wasn't sure if we wanted to release a another version with just one PR.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2030#issuecomment-953477212
Usability,simpl,simpler,"I never understood why a `CFL` object had to be pre-constructed, but I always assumed there was a good (probably GPU-related) reason for that. If there isn't, then I completely agree it's much simpler (without, I think, loss of functionality) to have it be two simple functions (advective and diffusive cfl). > is a hack that's not accurate (overly restrictive) on stretched grids. I think we can replace this with; > ```julia; > using Oceananigans.AbstractOperations: Δx, Δy, Δz; > ; > function cell_advection_timescale(grid, u, v, w); > arch = architecture(u); > ; > max_u_Δx = maximum(abs, u / Δx); > max_v_Δy = maximum(abs, v / Δy); > max_w_Δz = maximum(abs, w / Δz); > ; > return 1 / max(max_u_Δx, max_v_Δy, max_w_Δz); > end; > ```. I thought the reason we hadn't implemented the above is because it's slow to compute, no?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2037#issuecomment-958579038
Integrability,interface,interface,"> If it's slow, that's because of some implementation issue rather than an intrinsic reason. We _should_ be able to do fast reductions of abstract operations. Then I see no reason not to pursue the proposed changes :). On the user interface side: I believe ""diffusive CFL"" isn't quite correct, since the Courant-Friedrichs-Lewy condition is the advective one. (Although I agree that ""diffusive CFL"" is pretty easy to understand and intuitive.) Should we try to come up with a different name?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2037#issuecomment-958585293
Usability,intuit,intuitive,"> If it's slow, that's because of some implementation issue rather than an intrinsic reason. We _should_ be able to do fast reductions of abstract operations. Then I see no reason not to pursue the proposed changes :). On the user interface side: I believe ""diffusive CFL"" isn't quite correct, since the Courant-Friedrichs-Lewy condition is the advective one. (Although I agree that ""diffusive CFL"" is pretty easy to understand and intuitive.) Should we try to come up with a different name?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2037#issuecomment-958585293
Usability,clear,clear,"@simone-silvestri, I'm trying to understand how I build a stretched grid using the `RectilinearGrid` constructor. I can pass an array or function to, e.g., keyword argument `z = ...`. But it's not clear what would the constructor do. Will it take that array or function and construct the faces of `z` or the centers?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2050#issuecomment-966636899
Safety,avoid,avoids,"I would rather the first option (`avg_c = Field(Average(c, dims=1))`) because it avoids to have to code functions as `IntegrateField ....` and I think option option 1 is clearer than option 2 (you see that the average operation is applied to the fields c)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2052#issuecomment-969400613
Usability,clear,clearer,"I would rather the first option (`avg_c = Field(Average(c, dims=1))`) because it avoids to have to code functions as `IntegrateField ....` and I think option option 1 is clearer than option 2 (you see that the average operation is applied to the fields c)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2052#issuecomment-969400613
Deployability,update,updates,"> I think we want to introduce this major change to operators in a separate PR right? We also have to change derivatives, abstract operations, and grid metric operations?. @glwagner separate PR is fine too. I haven't been keeping up with where definitive immersed_boundary bits are. It seemed like there were some important updates in global-lat-lon. I am not clear if it can be a PR against main, since main may be missing some immersed bc bits this uses. There are still some bits to work on after the bits in this PR, to get everything fully consistent. I am surprised things run as well as they do at the moment!! I think somehow we must end up with the bathymetry shifted a bit weird. It would be nice to fix, both implicit solve and split explicit are going to struggle I think without this patched up somehow.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2055#issuecomment-966741761
Usability,clear,clear,"> I think we want to introduce this major change to operators in a separate PR right? We also have to change derivatives, abstract operations, and grid metric operations?. @glwagner separate PR is fine too. I haven't been keeping up with where definitive immersed_boundary bits are. It seemed like there were some important updates in global-lat-lon. I am not clear if it can be a PR against main, since main may be missing some immersed bc bits this uses. There are still some bits to work on after the bits in this PR, to get everything fully consistent. I am surprised things run as well as they do at the moment!! I think somehow we must end up with the bathymetry shifted a bit weird. It would be nice to fix, both implicit solve and split explicit are going to struggle I think without this patched up somehow.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2055#issuecomment-966741761
Usability,guid,guidelines,"I'm ok to advertise this. It seems maybe we need some guidelines about when to decide to document something. For practical purposes, we need to merge experimental features... My main uncertainty is that I don't know if this convective adjustment implementation is similar to the implementation in other ocean codes., but that definitely shouldn't prevent us from describe it in the docs. I'm not 100% happy with the implementation --- I want us to be able to prescribe a different diffusivity for each tracer (and I think we can get away with one fewer 3D array). That improvement would change the closure slightly, but it'd be easy to change the docs when we can do that.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2056#issuecomment-967178951
Deployability,update,update,"Just here to say that I had to update some code from using `grid.xC` to using `grid.Δxᵃᵃᶜ` which is more difficult to write, so I support a redesign or some more user-friendly way.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2058#issuecomment-1001101205
Usability,user-friendly,user-friendly,"Just here to say that I had to update some code from using `grid.xC` to using `grid.Δxᵃᵃᶜ` which is more difficult to write, so I support a redesign or some more user-friendly way.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2058#issuecomment-1001101205
Integrability,depend,depends,"I'm wondering if we should abandon the one-location methods. They are convenient, but don't generalize well. They may not even generalize to all immersed boundary methods; for example even with simple `GridFittedBottom` the vertical grid spacing depends on horizontal locations. My thought is that the overall system is simpler and we avoid ""dialects"" if we are disciplined and always require all three locations.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2058#issuecomment-1328371814
Safety,avoid,avoid,"I'm wondering if we should abandon the one-location methods. They are convenient, but don't generalize well. They may not even generalize to all immersed boundary methods; for example even with simple `GridFittedBottom` the vertical grid spacing depends on horizontal locations. My thought is that the overall system is simpler and we avoid ""dialects"" if we are disciplined and always require all three locations.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2058#issuecomment-1328371814
Usability,simpl,simple,"I'm wondering if we should abandon the one-location methods. They are convenient, but don't generalize well. They may not even generalize to all immersed boundary methods; for example even with simple `GridFittedBottom` the vertical grid spacing depends on horizontal locations. My thought is that the overall system is simpler and we avoid ""dialects"" if we are disciplined and always require all three locations.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2058#issuecomment-1328371814
Performance,perform,performance,"> By the way, i didn't use the scheme described in #1704 because it didn't give great results when implemented. I have implemented the ENO coefficients as derived before the assumption of uniform grid to the stencil interpolation (tomorrow I'll go back and check the report which describes them) . The smoothness functions are kept the same. That's interesting. Does that mean you were not able to reproduce the results reported in ""[A simple algorithm to improve the performance of the WENO scheme on non-uniform grids](https://link.springer.com/article/10.1007/s10409-017-0715-2)""?. > > By the way, it would be quite easy to modify the type to include the order of the WENO scheme which we could change at will. What do you think? Would it be usefull to do that?; > ; > If it's easy, then I definitely vote that we do that! A lower order, faster WENO scheme may be a good compromise between computational cost and accuracy. If that's true, we could use it as the default scheme for models. I think a higher order WENO scheme is more important than lower-order scheme. However, a low-order WENO method is proposed [here](https://link.springer.com/article/10.1007/s10915-020-01164-6). I think the 3rd order scheme may be quite diffusive and runs the risk of limiting to 1st order (?!). #995 attempts to implement nth order WENO but I think failed to achieve good CPU performance / compilation on the GPU. But @simone-silvestri perhaps you're able to achieve this?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-969290093
Safety,risk,risk,"> By the way, i didn't use the scheme described in #1704 because it didn't give great results when implemented. I have implemented the ENO coefficients as derived before the assumption of uniform grid to the stencil interpolation (tomorrow I'll go back and check the report which describes them) . The smoothness functions are kept the same. That's interesting. Does that mean you were not able to reproduce the results reported in ""[A simple algorithm to improve the performance of the WENO scheme on non-uniform grids](https://link.springer.com/article/10.1007/s10409-017-0715-2)""?. > > By the way, it would be quite easy to modify the type to include the order of the WENO scheme which we could change at will. What do you think? Would it be usefull to do that?; > ; > If it's easy, then I definitely vote that we do that! A lower order, faster WENO scheme may be a good compromise between computational cost and accuracy. If that's true, we could use it as the default scheme for models. I think a higher order WENO scheme is more important than lower-order scheme. However, a low-order WENO method is proposed [here](https://link.springer.com/article/10.1007/s10915-020-01164-6). I think the 3rd order scheme may be quite diffusive and runs the risk of limiting to 1st order (?!). #995 attempts to implement nth order WENO but I think failed to achieve good CPU performance / compilation on the GPU. But @simone-silvestri perhaps you're able to achieve this?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-969290093
Usability,simpl,simple,"> By the way, i didn't use the scheme described in #1704 because it didn't give great results when implemented. I have implemented the ENO coefficients as derived before the assumption of uniform grid to the stencil interpolation (tomorrow I'll go back and check the report which describes them) . The smoothness functions are kept the same. That's interesting. Does that mean you were not able to reproduce the results reported in ""[A simple algorithm to improve the performance of the WENO scheme on non-uniform grids](https://link.springer.com/article/10.1007/s10409-017-0715-2)""?. > > By the way, it would be quite easy to modify the type to include the order of the WENO scheme which we could change at will. What do you think? Would it be usefull to do that?; > ; > If it's easy, then I definitely vote that we do that! A lower order, faster WENO scheme may be a good compromise between computational cost and accuracy. If that's true, we could use it as the default scheme for models. I think a higher order WENO scheme is more important than lower-order scheme. However, a low-order WENO method is proposed [here](https://link.springer.com/article/10.1007/s10915-020-01164-6). I think the 3rd order scheme may be quite diffusive and runs the risk of limiting to 1st order (?!). #995 attempts to implement nth order WENO but I think failed to achieve good CPU performance / compilation on the GPU. But @simone-silvestri perhaps you're able to achieve this?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-969290093
Integrability,depend,dependent,"he face performed on different ""biased stencils"". <img src=""https://render.githubusercontent.com/render/math?math=v_{i %2B 1/2 ,r} = p_r(x_{i %2B 1/2}) = \sum_{j=0}^k c_{rj} \overline{v}_{i - r %2B j}"">. where <img src=""https://render.githubusercontent.com/render/math?math=p""> is the reconstruction polynomial constructed from the biased stencil <img src=""https://render.githubusercontent.com/render/math?math=r""> and <img src=""https://render.githubusercontent.com/render/math?math=k""> is the order of the polynomial. As we want a 5th order scheme, there will be three polynomials (<img src=""https://render.githubusercontent.com/render/math?math=r = 0, 1, 2"">) with (<img src=""https://render.githubusercontent.com/render/math?math=k = 2"">). Now the coefficients of these polynomials (<img src=""https://render.githubusercontent.com/render/math?math=c_{rj}"">) are based on the Lagrange interpolation of the integral of <img src=""https://render.githubusercontent.com/render/math?math=\overline{v}_{i}""> and, as such, are coordinate-dependent. The first thing to do, when wanting to implement the WENO scheme on a stretched grid, is then to make sure that the reconstruction is correctly done, and, as such, `WENO5(grid = grid)` takes care that (<img src=""https://render.githubusercontent.com/render/math?math=c_{rj}"">) are correctly calculated based on the underlying grid. Now, WENO schemes differ from ENO schemes since they do not just choose the ""smoothest stencil"" among the (in this case) three stencils, but weight them as such. <img src=""https://render.githubusercontent.com/render/math?math=v_{i %2B 1/2} = \sum_{r=0}^k w_{r} v_{i %2B 1/2,r} "">. Those weights have to satisfy <img src=""https://render.githubusercontent.com/render/math?math=\sum_{r=0}^k w_{r} = 1""> and are mostly a matter of choice (if the reconstruction is performed correctly for all stencils!). The general way to do this is to make them functions of a ""local smoothness indicator"" <img src=""https://render.githubusercontent",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-975649397
Performance,perform,performed,"@navidcy thanks for the review! ; Indeed maybe we should document it. . Just to give a quick explanation of the different flavours. WENO involves the reconstruction of the value of the advected quantity on the face performed on different ""biased stencils"". <img src=""https://render.githubusercontent.com/render/math?math=v_{i %2B 1/2 ,r} = p_r(x_{i %2B 1/2}) = \sum_{j=0}^k c_{rj} \overline{v}_{i - r %2B j}"">. where <img src=""https://render.githubusercontent.com/render/math?math=p""> is the reconstruction polynomial constructed from the biased stencil <img src=""https://render.githubusercontent.com/render/math?math=r""> and <img src=""https://render.githubusercontent.com/render/math?math=k""> is the order of the polynomial. As we want a 5th order scheme, there will be three polynomials (<img src=""https://render.githubusercontent.com/render/math?math=r = 0, 1, 2"">) with (<img src=""https://render.githubusercontent.com/render/math?math=k = 2"">). Now the coefficients of these polynomials (<img src=""https://render.githubusercontent.com/render/math?math=c_{rj}"">) are based on the Lagrange interpolation of the integral of <img src=""https://render.githubusercontent.com/render/math?math=\overline{v}_{i}""> and, as such, are coordinate-dependent. The first thing to do, when wanting to implement the WENO scheme on a stretched grid, is then to make sure that the reconstruction is correctly done, and, as such, `WENO5(grid = grid)` takes care that (<img src=""https://render.githubusercontent.com/render/math?math=c_{rj}"">) are correctly calculated based on the underlying grid. Now, WENO schemes differ from ENO schemes since they do not just choose the ""smoothest stencil"" among the (in this case) three stencils, but weight them as such. <img src=""https://render.githubusercontent.com/render/math?math=v_{i %2B 1/2} = \sum_{r=0}^k w_{r} v_{i %2B 1/2,r} "">. Those weights have to satisfy <img src=""https://render.githubusercontent.com/render/math?math=\sum_{r=0}^k w_{r} = 1""> and are mostly a matte",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-975649397
Usability,simpl,simplify,"on the underlying grid. Now, WENO schemes differ from ENO schemes since they do not just choose the ""smoothest stencil"" among the (in this case) three stencils, but weight them as such. <img src=""https://render.githubusercontent.com/render/math?math=v_{i %2B 1/2} = \sum_{r=0}^k w_{r} v_{i %2B 1/2,r} "">. Those weights have to satisfy <img src=""https://render.githubusercontent.com/render/math?math=\sum_{r=0}^k w_{r} = 1""> and are mostly a matter of choice (if the reconstruction is performed correctly for all stencils!). The general way to do this is to make them functions of a ""local smoothness indicator"" <img src=""https://render.githubusercontent.com/render/math?math=\beta_r""> which is calculated as such; <img src=""https://render.githubusercontent.com/render/math?math=\beta_{r} = \sum_{l=1}^k \int_{x_{i-1/2}}^{x_{i %2B 1/2}} \Delta x^{2l -1} \left( \frac{\partial^l p_r(x)}{\partial x^l} \right)^2 dx""> . These <img src=""https://render.githubusercontent.com/render/math?math=\beta_r""> simplify quite nicely for uniform grids. the `streched_smoothness=true` option calculates the coefficients of these smoothness indicators for a stretched grid, by assuming that (<img src=""https://render.githubusercontent.com/render/math?math=k = 2"">). Then the weights are calculated as such; <img src=""https://render.githubusercontent.com/render/math?math=w_{r} = \frac{\alpha_r}{\alpha_0 %2B \alpha_1 %2B \alpha_2}""> . where <img src=""https://render.githubusercontent.com/render/math?math=\alpha_r""> depends on the scheme used and differs between JS-WENO and Z-WENO. In the former; <img src=""https://render.githubusercontent.com/render/math?math=\alpha_r = \frac{d_r}{(\beta_r %2B \varepsilon)^2}"">; In the latter ; <img src=""https://render.githubusercontent.com/render/math?math=\alpha_r = d_r \left[ 1 %2B \left( \frac{ \left |\beta_2 - \beta_0 \right|}{\beta_r %2B \varepsilon} \right)^2 \right] "">; <img src=""https://render.githubusercontent.com/render/math?math=d_r""> are optimized constants equal ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-975649397
Testability,test,tested,"@navidcy I have made a couple of small changes. Anyways, I am a little hesitant to make Z-WENO the default as it does, yes, have slight benefits, but we tested only on small simplified problems. I would have a bit more testing before making it the default.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-976145373
Usability,simpl,simplified,"@navidcy I have made a couple of small changes. Anyways, I am a little hesitant to make Z-WENO the default as it does, yes, have slight benefits, but we tested only on small simplified problems. I would have a bit more testing before making it the default.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-976145373
Testability,test,tested,"> @navidcy I have made a couple of small changes. Anyways, I am a little hesitant to make Z-WENO the default as it does, yes, have slight benefits, but we tested only on small simplified problems. I would have a bit more testing before making it the default. Sounds good! I was just wondering. I made a formatting suggestion. I think you should merge as soon as tests pass!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-976148612
Usability,simpl,simplified,"> @navidcy I have made a couple of small changes. Anyways, I am a little hesitant to make Z-WENO the default as it does, yes, have slight benefits, but we tested only on small simplified problems. I would have a bit more testing before making it the default. Sounds good! I was just wondering. I made a formatting suggestion. I think you should merge as soon as tests pass!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-976148612
Usability,intuit,intuitive,"I agree very much with this decision, it would be very convenient (and intuitive) to be able to change boundary conditions like that.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2063#issuecomment-972916256
Usability,clear,clear,"- `extrema(Δz)` is not as clear... let's just write `min(Δz) = ..., max(Δz) = ...`; - I'd suggest something like; ```Julia; z ∈ [0.0, 1.0], min(Δz) = ..., max(Δz) = ...; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2064#issuecomment-971140218
Availability,down,downside,"I actually appreciate the verbose-ness of the grid show functions (actually most of Oceananigans show functions in general). So I can only assume that more beginner users appreciate that as well, since it makes extremely clear what the grid characteristics are. I also don't think there's a very important downside to being verbose here, so I'd vote to keep the same style. Although I agree that we could get rid of some redundant information. My suggestion would be something like:. ```julia; julia> grid = RectilinearGrid(size=3, z=[0.0, 0.2, 0.5, 1.0], topology=(Flat, Flat, Bounded)); RectilinearGrid{Float64, Flat, Flat, Bounded} on the CPU(); domain: x ∈ [1.0, 1.0], y ∈ [1.0, 1.0], z ∈ [0.0, 1.0]; topology: (Flat, Flat, Bounded); size (Nx, Ny, Nz): (1, 1, 3); halo (Hx, Hy, Hz): (0, 0, 1); z spacing: Stretched, with min=0.2, max=0.5; ```. In other words, I'd remove the flat dimensions (since that's unnecessary), and clean and align the `z` spacing statement. I'd also keep the ` topology: (Flat, Flat, Bounded)` because the line `RectilinearGrid{Float64, Flat, Flat, Bounded}` might not be very intuitive to everyone. If a shorter show is necessary in some places maybe we could create something like `short_show`? (Or maybe define `show` differently based on the display?: https://schurkus.com/2018/01/05/julia-print-show-display-dump-what-to-override-what-to-use/)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2064#issuecomment-971810297
Safety,redund,redundant,"I actually appreciate the verbose-ness of the grid show functions (actually most of Oceananigans show functions in general). So I can only assume that more beginner users appreciate that as well, since it makes extremely clear what the grid characteristics are. I also don't think there's a very important downside to being verbose here, so I'd vote to keep the same style. Although I agree that we could get rid of some redundant information. My suggestion would be something like:. ```julia; julia> grid = RectilinearGrid(size=3, z=[0.0, 0.2, 0.5, 1.0], topology=(Flat, Flat, Bounded)); RectilinearGrid{Float64, Flat, Flat, Bounded} on the CPU(); domain: x ∈ [1.0, 1.0], y ∈ [1.0, 1.0], z ∈ [0.0, 1.0]; topology: (Flat, Flat, Bounded); size (Nx, Ny, Nz): (1, 1, 3); halo (Hx, Hy, Hz): (0, 0, 1); z spacing: Stretched, with min=0.2, max=0.5; ```. In other words, I'd remove the flat dimensions (since that's unnecessary), and clean and align the `z` spacing statement. I'd also keep the ` topology: (Flat, Flat, Bounded)` because the line `RectilinearGrid{Float64, Flat, Flat, Bounded}` might not be very intuitive to everyone. If a shorter show is necessary in some places maybe we could create something like `short_show`? (Or maybe define `show` differently based on the display?: https://schurkus.com/2018/01/05/julia-print-show-display-dump-what-to-override-what-to-use/)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2064#issuecomment-971810297
Usability,clear,clear,"I actually appreciate the verbose-ness of the grid show functions (actually most of Oceananigans show functions in general). So I can only assume that more beginner users appreciate that as well, since it makes extremely clear what the grid characteristics are. I also don't think there's a very important downside to being verbose here, so I'd vote to keep the same style. Although I agree that we could get rid of some redundant information. My suggestion would be something like:. ```julia; julia> grid = RectilinearGrid(size=3, z=[0.0, 0.2, 0.5, 1.0], topology=(Flat, Flat, Bounded)); RectilinearGrid{Float64, Flat, Flat, Bounded} on the CPU(); domain: x ∈ [1.0, 1.0], y ∈ [1.0, 1.0], z ∈ [0.0, 1.0]; topology: (Flat, Flat, Bounded); size (Nx, Ny, Nz): (1, 1, 3); halo (Hx, Hy, Hz): (0, 0, 1); z spacing: Stretched, with min=0.2, max=0.5; ```. In other words, I'd remove the flat dimensions (since that's unnecessary), and clean and align the `z` spacing statement. I'd also keep the ` topology: (Flat, Flat, Bounded)` because the line `RectilinearGrid{Float64, Flat, Flat, Bounded}` might not be very intuitive to everyone. If a shorter show is necessary in some places maybe we could create something like `short_show`? (Or maybe define `show` differently based on the display?: https://schurkus.com/2018/01/05/julia-print-show-display-dump-what-to-override-what-to-use/)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2064#issuecomment-971810297
Usability,simpl,simpler,"> I don't really know what this comment: ""# Shift to adjust for Tridiagonal indexing convenction"" means: Does this means that we don't pick one of the 2 simpler conventions for indexing the tri-diagonal coeff, i.e, either by line/row or by columns ?. I believe this refers to the fact that julia's `Tridiagonal` (whose conventions are followed in the `BatchedTridiagonalSolver`) has three vectors: `d` (diagonal), `du` (upper diagonal) and `dl` (lower diagonal). `d` has length `N`, but `du` and `dl` both have length `N-1`. So for example the matrix component ""1, 2"" is index `1` in the lower diagonal vector (rather than index 2) --- I think?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2065#issuecomment-973702664
Performance,optimiz,optimization,"I was wondering if we can regrid in 3D simply by regridding in each dimension in serial. Eg first regrid in x, then, y, then z. It'll be a bit more computation, but we still have the option of future optimization...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2067#issuecomment-973673941
Usability,simpl,simply,"I was wondering if we can regrid in 3D simply by regridding in each dimension in serial. Eg first regrid in x, then, y, then z. It'll be a bit more computation, but we still have the option of future optimization...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2067#issuecomment-973673941
Integrability,depend,depend,"I think having `Distributed` depend on `Models` was intentional. Basically, the design is that the main code is written for single process modules; and `Distributed` simply provides some replacements for functions that are needed for distributed computations without interferring in the core algorithm. This represents a break from other code designs that weave particularities to distributed model deep into the code. What do you think about this?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2073#issuecomment-974594023
Usability,simpl,simply,"I think having `Distributed` depend on `Models` was intentional. Basically, the design is that the main code is written for single process modules; and `Distributed` simply provides some replacements for functions that are needed for distributed computations without interferring in the core algorithm. This represents a break from other code designs that weave particularities to distributed model deep into the code. What do you think about this?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2073#issuecomment-974594023
Availability,checkpoint,checkpointer,"> Perhaps the feature being asked for here is a checkpointer that avoids writing NaNs --- is that correct?. I actually think having an `error=true` option to `NaNChecker` would be useful for other purposes than avoiding a nan-filled checkpoint, so I personally still think that's the best solution here, since it's also pretty simple. If the script has plots or other analyses after `run!()`, a user might not want to waste resources running all that stuff if a `NaN` is detected. (Or they might! And hence the option :) ). Unless there's a reason why that's a bad idea that I'm missing...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2086#issuecomment-982910455
Safety,avoid,avoids,"> Perhaps the feature being asked for here is a checkpointer that avoids writing NaNs --- is that correct?. I actually think having an `error=true` option to `NaNChecker` would be useful for other purposes than avoiding a nan-filled checkpoint, so I personally still think that's the best solution here, since it's also pretty simple. If the script has plots or other analyses after `run!()`, a user might not want to waste resources running all that stuff if a `NaN` is detected. (Or they might! And hence the option :) ). Unless there's a reason why that's a bad idea that I'm missing...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2086#issuecomment-982910455
Usability,simpl,simple,"> Perhaps the feature being asked for here is a checkpointer that avoids writing NaNs --- is that correct?. I actually think having an `error=true` option to `NaNChecker` would be useful for other purposes than avoiding a nan-filled checkpoint, so I personally still think that's the best solution here, since it's also pretty simple. If the script has plots or other analyses after `run!()`, a user might not want to waste resources running all that stuff if a `NaN` is detected. (Or they might! And hence the option :) ). Unless there's a reason why that's a bad idea that I'm missing...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2086#issuecomment-982910455
Availability,error,error,"> I actually think having an error=true option to NaNChecker would be useful for other purposes than avoiding a nan-filled checkpoint. Okay. > I personally still think that's the best solution here. I disagree, because it only solves the problem for a narrow range of checkpointer schedules. If you checkpoint based on `TimeInterval` and check for NaNs based on `IterationInterval`, there is no guarantee that you won't write NaNs to a checkpoint file whether or not the NaNChecker throws an error. I think a better solution is to explicitly avoid writing a checkpoint file (or any other task) when NaNs are detected. > it's also pretty simple. There's hardly a difference in the simplicity of either implementation. > Unless there's a reason why that's a bad idea that I'm missing... I don't think there is an intrinsic problem with throwing an error, I just think that it's often a brittle hack that can damage productivity (errors thrown by the NaNChecker generate a long stacktrace of irrelevant information --- because the emergence of a NaN is not an error in the usual sense). So I think it's useful to think of more user-friendly solutions to various issues / tasks we face when setting up simulations.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2086#issuecomment-982934538
Energy Efficiency,schedul,schedules,"> I actually think having an error=true option to NaNChecker would be useful for other purposes than avoiding a nan-filled checkpoint. Okay. > I personally still think that's the best solution here. I disagree, because it only solves the problem for a narrow range of checkpointer schedules. If you checkpoint based on `TimeInterval` and check for NaNs based on `IterationInterval`, there is no guarantee that you won't write NaNs to a checkpoint file whether or not the NaNChecker throws an error. I think a better solution is to explicitly avoid writing a checkpoint file (or any other task) when NaNs are detected. > it's also pretty simple. There's hardly a difference in the simplicity of either implementation. > Unless there's a reason why that's a bad idea that I'm missing... I don't think there is an intrinsic problem with throwing an error, I just think that it's often a brittle hack that can damage productivity (errors thrown by the NaNChecker generate a long stacktrace of irrelevant information --- because the emergence of a NaN is not an error in the usual sense). So I think it's useful to think of more user-friendly solutions to various issues / tasks we face when setting up simulations.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2086#issuecomment-982934538
Safety,avoid,avoiding,"> I actually think having an error=true option to NaNChecker would be useful for other purposes than avoiding a nan-filled checkpoint. Okay. > I personally still think that's the best solution here. I disagree, because it only solves the problem for a narrow range of checkpointer schedules. If you checkpoint based on `TimeInterval` and check for NaNs based on `IterationInterval`, there is no guarantee that you won't write NaNs to a checkpoint file whether or not the NaNChecker throws an error. I think a better solution is to explicitly avoid writing a checkpoint file (or any other task) when NaNs are detected. > it's also pretty simple. There's hardly a difference in the simplicity of either implementation. > Unless there's a reason why that's a bad idea that I'm missing... I don't think there is an intrinsic problem with throwing an error, I just think that it's often a brittle hack that can damage productivity (errors thrown by the NaNChecker generate a long stacktrace of irrelevant information --- because the emergence of a NaN is not an error in the usual sense). So I think it's useful to think of more user-friendly solutions to various issues / tasks we face when setting up simulations.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2086#issuecomment-982934538
Usability,simpl,simple,"> I actually think having an error=true option to NaNChecker would be useful for other purposes than avoiding a nan-filled checkpoint. Okay. > I personally still think that's the best solution here. I disagree, because it only solves the problem for a narrow range of checkpointer schedules. If you checkpoint based on `TimeInterval` and check for NaNs based on `IterationInterval`, there is no guarantee that you won't write NaNs to a checkpoint file whether or not the NaNChecker throws an error. I think a better solution is to explicitly avoid writing a checkpoint file (or any other task) when NaNs are detected. > it's also pretty simple. There's hardly a difference in the simplicity of either implementation. > Unless there's a reason why that's a bad idea that I'm missing... I don't think there is an intrinsic problem with throwing an error, I just think that it's often a brittle hack that can damage productivity (errors thrown by the NaNChecker generate a long stacktrace of irrelevant information --- because the emergence of a NaN is not an error in the usual sense). So I think it's useful to think of more user-friendly solutions to various issues / tasks we face when setting up simulations.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2086#issuecomment-982934538
Usability,clear,clearer,"> We could also use `AndSchedule` (rather than `AllSchedule`) and `OrSchedule` (rather than `AnySchedule`). ""and"" / ""or"" refer to the underlying conditionals that are used in the reductions `all` / `any`. Is this easier to understand (I'm not sure)?. I think the `AndSchedule` and `OrSchedule` notation is clearer (or at least more explicit), so I'm leaning toward that one. But I don't feel strongly anyway so feel free to merge this whenever you're happy!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2088#issuecomment-991887660
Usability,learn,learning,"Thanks for the explanation @glwagner . No problem that you didn't understand this perfectly in the past as I am still learning the difference between `print`, `show`, and `summary`. It seems that all the advection schemes have the same structure, except `WENO5` but this is not a problem and therefore I am happy to close #2098 . This issue perhaps better addressed in a future PR, that focuses on the structure we would want in general. Agreed?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2099#issuecomment-986801723
Usability,usab,usability,"@whitleyv let us know if this feature allows you to compute the time-derivative of outputted quantities, and there's any changes or additional features that might help with its usability.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2100#issuecomment-987151360
Testability,test,test,"@glwagner, what about; https://github.com/CliMA/Oceananigans.jl/blob/3c86d8f37a3bf5ff050e233f7b946685f9057c26/test/test_boundary_conditions_integration.jl#L200. Should we simplify to `topo = (Bounded, Bounded, Bounded)`?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2103#issuecomment-988286053
Usability,simpl,simplify,"@glwagner, what about; https://github.com/CliMA/Oceananigans.jl/blob/3c86d8f37a3bf5ff050e233f7b946685f9057c26/test/test_boundary_conditions_integration.jl#L200. Should we simplify to `topo = (Bounded, Bounded, Bounded)`?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2103#issuecomment-988286053
Testability,benchmark,benchmarks,"> hey had a few comments, but nothing too serious; > ; > It's hard for me to check thoroughly the whole code. But I'm pleased with the benchmarks and tests -- they look very convincing. I'm approving but perhaps let's hear @glwagner?; > ; > (I'm going offline today in a bit for 2 weeks..). @navidcy thanks for the review, I ll check everything and improve the comments to make it clearer. Have nice vacations!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2105#issuecomment-996204166
Usability,clear,clearer,"> hey had a few comments, but nothing too serious; > ; > It's hard for me to check thoroughly the whole code. But I'm pleased with the benchmarks and tests -- they look very convincing. I'm approving but perhaps let's hear @glwagner?; > ; > (I'm going offline today in a bit for 2 weeks..). @navidcy thanks for the review, I ll check everything and improve the comments to make it clearer. Have nice vacations!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2105#issuecomment-996204166
Availability,mask,masking," one of its locations is `Nothing`, rather than `Face` or `Center`. I think the issue here is that there are a few flavors of ""reduced fields"":. * ""Sliced fields"", which have reduced dimensionality, but still have a ""position"" in 3D space. These may be fields that exist only on boundaries, like the free surface, ice concentration, boundary conditions, etc. It should also be valid to define ""sliced fields"" at other positions / indices, inside the domain. If one of the ranges has a length 1, then the field is ""2.5 dimensional""... ?; * _Truly_ two-dimensional fields derived from a reduction operation, like `Average` or `Integral`. These fields have no position in the reduced dimension. To express the above in code, we might introduce a new location, perhaps `Level` (`Slice`, `Layer`, `Plane`...), which maybe stores both an integer `index` and the ""underlying location"". The free surface might have the location `Level{Face}(grid.Nz+1)` in the vertical (for example). I'm unsure the best solution to the masking issue. For 2.5D fields, the answer is clear: we need to evaluate `solid_interface` at the actual ""location"" of the field. Right now `Nothing` in the vertical means `k -> 1`. But this is _wrong_, as this issue identifies. If we have a new location `Level`, we can evaluate `solid_interface` at `Level.index` (for example). For truly 2D fields, it's murkier. I think in _general_ if one wants to identify whether an _entire_ dimension is masked, there's little choice but to evaluate the masking function at every index in that dimension. But there are special cases for which the job is a bit easier, because we encode assumptions about the shape of the immersed boundary. For example, `GridFittedBottom` assumes that masking occurs at every location _below_ a specified depth. Thus, a column can be identified as masked by evaluating `solid_interface` at the upper grid point, eg `k = grid.Nz`. So, we have a design problem on our hands to figure out how to represent these ideas i",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2177#issuecomment-1021328044
Energy Efficiency,reduce,reduced,"Yes, this is interesting!. To clarify: we identify a field as ""reduced"" if one of its locations is `Nothing`, rather than `Face` or `Center`. I think the issue here is that there are a few flavors of ""reduced fields"":. * ""Sliced fields"", which have reduced dimensionality, but still have a ""position"" in 3D space. These may be fields that exist only on boundaries, like the free surface, ice concentration, boundary conditions, etc. It should also be valid to define ""sliced fields"" at other positions / indices, inside the domain. If one of the ranges has a length 1, then the field is ""2.5 dimensional""... ?; * _Truly_ two-dimensional fields derived from a reduction operation, like `Average` or `Integral`. These fields have no position in the reduced dimension. To express the above in code, we might introduce a new location, perhaps `Level` (`Slice`, `Layer`, `Plane`...), which maybe stores both an integer `index` and the ""underlying location"". The free surface might have the location `Level{Face}(grid.Nz+1)` in the vertical (for example). I'm unsure the best solution to the masking issue. For 2.5D fields, the answer is clear: we need to evaluate `solid_interface` at the actual ""location"" of the field. Right now `Nothing` in the vertical means `k -> 1`. But this is _wrong_, as this issue identifies. If we have a new location `Level`, we can evaluate `solid_interface` at `Level.index` (for example). For truly 2D fields, it's murkier. I think in _general_ if one wants to identify whether an _entire_ dimension is masked, there's little choice but to evaluate the masking function at every index in that dimension. But there are special cases for which the job is a bit easier, because we encode assumptions about the shape of the immersed boundary. For example, `GridFittedBottom` assumes that masking occurs at every location _below_ a specified depth. Thus, a column can be identified as masked by evaluating `solid_interface` at the upper grid point, eg `k = grid.Nz`. So, we have ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2177#issuecomment-1021328044
Usability,clear,clear,"r than `Face` or `Center`. I think the issue here is that there are a few flavors of ""reduced fields"":. * ""Sliced fields"", which have reduced dimensionality, but still have a ""position"" in 3D space. These may be fields that exist only on boundaries, like the free surface, ice concentration, boundary conditions, etc. It should also be valid to define ""sliced fields"" at other positions / indices, inside the domain. If one of the ranges has a length 1, then the field is ""2.5 dimensional""... ?; * _Truly_ two-dimensional fields derived from a reduction operation, like `Average` or `Integral`. These fields have no position in the reduced dimension. To express the above in code, we might introduce a new location, perhaps `Level` (`Slice`, `Layer`, `Plane`...), which maybe stores both an integer `index` and the ""underlying location"". The free surface might have the location `Level{Face}(grid.Nz+1)` in the vertical (for example). I'm unsure the best solution to the masking issue. For 2.5D fields, the answer is clear: we need to evaluate `solid_interface` at the actual ""location"" of the field. Right now `Nothing` in the vertical means `k -> 1`. But this is _wrong_, as this issue identifies. If we have a new location `Level`, we can evaluate `solid_interface` at `Level.index` (for example). For truly 2D fields, it's murkier. I think in _general_ if one wants to identify whether an _entire_ dimension is masked, there's little choice but to evaluate the masking function at every index in that dimension. But there are special cases for which the job is a bit easier, because we encode assumptions about the shape of the immersed boundary. For example, `GridFittedBottom` assumes that masking occurs at every location _below_ a specified depth. Thus, a column can be identified as masked by evaluating `solid_interface` at the upper grid point, eg `k = grid.Nz`. So, we have a design problem on our hands to figure out how to represent these ideas in the code. We might need more types ;-)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2177#issuecomment-1021328044
Energy Efficiency,reduce,reduced,"75096 0.631413; 0.357241 0.479499 0.0708911; 0.922986 0.979659 0.117883. [:, :, 3] =; 0.868073 0.0576275 0.328323; 0.522754 0.663369 0.840316; 0.40434 0.631349 0.577748. julia> b = view(a, :, 2:3, 2); 3×2 view(::Array{Float64, 3}, :, 2:3, 2) with eltype Float64:; 0.575096 0.631413; 0.479499 0.0708911; 0.979659 0.117883. julia> typeof(b); SubArray{Float64, 2, Array{Float64, 3}, Tuple{Base.Slice{Base.OneTo{Int64}}, UnitRange{Int64}, Int64}, true}. julia> b.indices; (Base.Slice(Base.OneTo(3)), 2:3, 2); ```. One key difference with `SubArray` is that we want to offset indices. For example with `SubArray` we have. ```julia; julia> b[1, 1, 1]; 0.5750957798298579. julia> a[1, 2, 2]; 0.5750957798298579; ```. But I think we instead want offset indices that behave something like. ```julia; julia> c = OffsetArray(view(a, :, 2:3, 2:2), 0, 1, 1); 3×2×1 OffsetArray(view(::Array{Float64, 3}, :, 2:3, 2:2), 1:3, 2:3, 2:2) with eltype Float64 with indices 1:3×2:3×2:2:; [:, :, 2] =; 0.575096 0.631413; 0.479499 0.0708911; 0.979659 0.117883. julia> c[1, 2, 2]; 0.5750957798298579; ```. So the indices for `c` and `a` are identical. Something also seems a bit clearer: when we are computing on fields with `indices`, we compute index ""intersections"" to figure out the range of the computation. For example if we want to compute something like. ```julia; u * η; ```. right now our infrastructure would assume this is a 3D computation defined at every level. But what we probably want is to return an object that just computes `u * η` at the _surface_. This will work if `η.indices = (:, :, Nz:Nz)` for example; then the product `u * η` is also defined over the indices `(:, :, Nz:Nz)`. We can also use this feature to support `FieldTimeSeries` of sliced output. If we use this then a `Nothing` location is truly _reduced_, ie, the field has no location in the reduced direction. But a field like the free surface displacement is not reduced; it's `IndexedField` (or something), with `!isnothing(η.indices)`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2177#issuecomment-1029994350
Usability,clear,clearer,"75096 0.631413; 0.357241 0.479499 0.0708911; 0.922986 0.979659 0.117883. [:, :, 3] =; 0.868073 0.0576275 0.328323; 0.522754 0.663369 0.840316; 0.40434 0.631349 0.577748. julia> b = view(a, :, 2:3, 2); 3×2 view(::Array{Float64, 3}, :, 2:3, 2) with eltype Float64:; 0.575096 0.631413; 0.479499 0.0708911; 0.979659 0.117883. julia> typeof(b); SubArray{Float64, 2, Array{Float64, 3}, Tuple{Base.Slice{Base.OneTo{Int64}}, UnitRange{Int64}, Int64}, true}. julia> b.indices; (Base.Slice(Base.OneTo(3)), 2:3, 2); ```. One key difference with `SubArray` is that we want to offset indices. For example with `SubArray` we have. ```julia; julia> b[1, 1, 1]; 0.5750957798298579. julia> a[1, 2, 2]; 0.5750957798298579; ```. But I think we instead want offset indices that behave something like. ```julia; julia> c = OffsetArray(view(a, :, 2:3, 2:2), 0, 1, 1); 3×2×1 OffsetArray(view(::Array{Float64, 3}, :, 2:3, 2:2), 1:3, 2:3, 2:2) with eltype Float64 with indices 1:3×2:3×2:2:; [:, :, 2] =; 0.575096 0.631413; 0.479499 0.0708911; 0.979659 0.117883. julia> c[1, 2, 2]; 0.5750957798298579; ```. So the indices for `c` and `a` are identical. Something also seems a bit clearer: when we are computing on fields with `indices`, we compute index ""intersections"" to figure out the range of the computation. For example if we want to compute something like. ```julia; u * η; ```. right now our infrastructure would assume this is a 3D computation defined at every level. But what we probably want is to return an object that just computes `u * η` at the _surface_. This will work if `η.indices = (:, :, Nz:Nz)` for example; then the product `u * η` is also defined over the indices `(:, :, Nz:Nz)`. We can also use this feature to support `FieldTimeSeries` of sliced output. If we use this then a `Nothing` location is truly _reduced_, ie, the field has no location in the reduced direction. But a field like the free surface displacement is not reduced; it's `IndexedField` (or something), with `!isnothing(η.indices)`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2177#issuecomment-1029994350
Usability,clear,clear,"I don't know. Is the `Vector` somehow a flattened 2D object? We can `reshape` at will without allocating memory:. ```julia; julia> a = Vector(1:16); 16-element Vector{Int64}:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16. julia> b = reshape(a, (4, 4)); 4×4 Matrix{Int64}:; 1 5 9 13; 2 6 10 14; 3 7 11 15; 4 8 12 16. julia> b[1, 1] = 0; 0. julia> a; 16-element Vector{Int64}:; 0; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; ```. But it's a little sketchy if this right hand side doesn't have halos. It's probably ok to allow `Fields` with no halos that don't use `OffsetArray`. Certainly, if it were a field, its physical nature might be a little more clear. As a vector I don't think we can figure out what it represents, just reading the code.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2184#issuecomment-1021881101
Availability,mask,mask,"For reducing any `AbstractField` over ""windows"", `ConditionalOperation` is sufficient. The task there is to define `condition` appropriately (`mask` is chosen as the ""neutral"" value for the particular reduction). I guess there isn't an ordinary constructor for `ConditionalOperand`, but there is a function `condition_operand`... https://github.com/CliMA/Oceananigans.jl/blob/b5bf45ed51587954f61ca7492e946fef69ff72ee/src/AbstractOperations/conditional_operations.jl#L23. (@simone-silvestri why is this function not simply a constructor for `ConditionalOperand`?) This feature is new so the API might change. We also need doc strings... ## On views of `Field`... We may also eventually want to implement the concept of `view`s of `Field`s. I think if that were implemented properly, we'd be able to reduce those objects. . #2177 is related; the location `Level` proposed there could handle slices across a whole dimension (but not necessarily ""windowing""...). This is for another issue, but field ""windows"" might be easy to support by using a `view` for `data`. Cause then:. ```julia; julia> a = rand(4); 4-element Vector{Float64}:; 0.5910896175675375; 0.19567937424038506; 0.14802797670131396; 0.17994410698438923. julia> b = OffsetArray(a, -1); 4-element OffsetArray(::Vector{Float64}, 0:3) with eltype Float64 with indices 0:3:; 0.5910896175675375; 0.19567937424038506; 0.14802797670131396; 0.17994410698438923. julia> c = view(b, 2:3); 2-element view(OffsetArray(::Vector{Float64}, 0:3), 2:3) with eltype Float64:; 0.14802797670131396; 0.17994410698438923. julia> typeof(c); SubArray{Float64, 1, OffsetVector{Float64, Vector{Float64}}, Tuple{UnitRange{Int64}}, true}. julia> c.indices; (2:3,); ```. we have our indices. The challenge here is, if we are doing computations (eg `compute!`, broadcasting, or calling a reduction), we have to somehow reduce / compute over a view of the _operand_, using the indices stored in the _target_ appropriately.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2185#issuecomment-1021875677
Energy Efficiency,reduce,reduce,"For reducing any `AbstractField` over ""windows"", `ConditionalOperation` is sufficient. The task there is to define `condition` appropriately (`mask` is chosen as the ""neutral"" value for the particular reduction). I guess there isn't an ordinary constructor for `ConditionalOperand`, but there is a function `condition_operand`... https://github.com/CliMA/Oceananigans.jl/blob/b5bf45ed51587954f61ca7492e946fef69ff72ee/src/AbstractOperations/conditional_operations.jl#L23. (@simone-silvestri why is this function not simply a constructor for `ConditionalOperand`?) This feature is new so the API might change. We also need doc strings... ## On views of `Field`... We may also eventually want to implement the concept of `view`s of `Field`s. I think if that were implemented properly, we'd be able to reduce those objects. . #2177 is related; the location `Level` proposed there could handle slices across a whole dimension (but not necessarily ""windowing""...). This is for another issue, but field ""windows"" might be easy to support by using a `view` for `data`. Cause then:. ```julia; julia> a = rand(4); 4-element Vector{Float64}:; 0.5910896175675375; 0.19567937424038506; 0.14802797670131396; 0.17994410698438923. julia> b = OffsetArray(a, -1); 4-element OffsetArray(::Vector{Float64}, 0:3) with eltype Float64 with indices 0:3:; 0.5910896175675375; 0.19567937424038506; 0.14802797670131396; 0.17994410698438923. julia> c = view(b, 2:3); 2-element view(OffsetArray(::Vector{Float64}, 0:3), 2:3) with eltype Float64:; 0.14802797670131396; 0.17994410698438923. julia> typeof(c); SubArray{Float64, 1, OffsetVector{Float64, Vector{Float64}}, Tuple{UnitRange{Int64}}, true}. julia> c.indices; (2:3,); ```. we have our indices. The challenge here is, if we are doing computations (eg `compute!`, broadcasting, or calling a reduction), we have to somehow reduce / compute over a view of the _operand_, using the indices stored in the _target_ appropriately.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2185#issuecomment-1021875677
Usability,simpl,simply,"For reducing any `AbstractField` over ""windows"", `ConditionalOperation` is sufficient. The task there is to define `condition` appropriately (`mask` is chosen as the ""neutral"" value for the particular reduction). I guess there isn't an ordinary constructor for `ConditionalOperand`, but there is a function `condition_operand`... https://github.com/CliMA/Oceananigans.jl/blob/b5bf45ed51587954f61ca7492e946fef69ff72ee/src/AbstractOperations/conditional_operations.jl#L23. (@simone-silvestri why is this function not simply a constructor for `ConditionalOperand`?) This feature is new so the API might change. We also need doc strings... ## On views of `Field`... We may also eventually want to implement the concept of `view`s of `Field`s. I think if that were implemented properly, we'd be able to reduce those objects. . #2177 is related; the location `Level` proposed there could handle slices across a whole dimension (but not necessarily ""windowing""...). This is for another issue, but field ""windows"" might be easy to support by using a `view` for `data`. Cause then:. ```julia; julia> a = rand(4); 4-element Vector{Float64}:; 0.5910896175675375; 0.19567937424038506; 0.14802797670131396; 0.17994410698438923. julia> b = OffsetArray(a, -1); 4-element OffsetArray(::Vector{Float64}, 0:3) with eltype Float64 with indices 0:3:; 0.5910896175675375; 0.19567937424038506; 0.14802797670131396; 0.17994410698438923. julia> c = view(b, 2:3); 2-element view(OffsetArray(::Vector{Float64}, 0:3), 2:3) with eltype Float64:; 0.14802797670131396; 0.17994410698438923. julia> typeof(c); SubArray{Float64, 1, OffsetVector{Float64, Vector{Float64}}, Tuple{UnitRange{Int64}}, true}. julia> c.indices; (2:3,); ```. we have our indices. The challenge here is, if we are doing computations (eg `compute!`, broadcasting, or calling a reduction), we have to somehow reduce / compute over a view of the _operand_, using the indices stored in the _target_ appropriately.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2185#issuecomment-1021875677
Availability,error,error,"I think the error is surprisingly clear actually! There's no pressure solver for grids that are stretched in `x` or `y`. But it won't be much effort to add a more specific warning in the constructor for `NonhydrostaticModel`. @simone-silvestri good point that the FFT/tridiagonal solver should work in other directions! Unfortunately though I think the tridiagonal solver is hard-coded to batch in `i, j` and solve in `k`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2191#issuecomment-1022767819
Usability,clear,clear,"I think the error is surprisingly clear actually! There's no pressure solver for grids that are stretched in `x` or `y`. But it won't be much effort to add a more specific warning in the constructor for `NonhydrostaticModel`. @simone-silvestri good point that the FFT/tridiagonal solver should work in other directions! Unfortunately though I think the tridiagonal solver is hard-coded to batch in `i, j` and solve in `k`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2191#issuecomment-1022767819
Availability,error,error,"The error is not as clear, @glwagner. ```; ERROR: MethodError: no method matching PressureSolver(::CPU, ::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}); ```. does not immediately reads ""no pressure solver for grids that are stretched in x or y"". One needs to infer that from the long types of the function arguments.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2191#issuecomment-1022770921
Usability,clear,clear,"The error is not as clear, @glwagner. ```; ERROR: MethodError: no method matching PressureSolver(::CPU, ::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}); ```. does not immediately reads ""no pressure solver for grids that are stretched in x or y"". One needs to infer that from the long types of the function arguments.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2191#issuecomment-1022770921
Availability,error,error,"> > I guess I just read the first part ""no method matching PressureSolver"" and that made sense to me: there's no pressure solver for my input!; > ; > Fair enough! But perhaps not what would come in mind to everyone ;). I tend to agree with @navidcy. For that error to be clear a user would have to be familiar with Julia's multiple dispatch feature and what ""method"" means. Clear for us, but not super clear for a new Julia user. > @simone-silvestri good point that the FFT/tridiagonal solver should work in other directions! Unfortunately though I think the tridiagonal solver is hard-coded to batch in i, j and solve in k. Is it worth to rotate x- and y-stretched grids so that the stretching is in the `z` direction and then use the tridiagonal solver behind the scenes? I have no idea how slow something like that would be on a GPU.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2191#issuecomment-1022800912
Usability,clear,clear,"> > I guess I just read the first part ""no method matching PressureSolver"" and that made sense to me: there's no pressure solver for my input!; > ; > Fair enough! But perhaps not what would come in mind to everyone ;). I tend to agree with @navidcy. For that error to be clear a user would have to be familiar with Julia's multiple dispatch feature and what ""method"" means. Clear for us, but not super clear for a new Julia user. > @simone-silvestri good point that the FFT/tridiagonal solver should work in other directions! Unfortunately though I think the tridiagonal solver is hard-coded to batch in i, j and solve in k. Is it worth to rotate x- and y-stretched grids so that the stretching is in the `z` direction and then use the tridiagonal solver behind the scenes? I have no idea how slow something like that would be on a GPU.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2191#issuecomment-1022800912
Availability,mainten,maintenance,"> > I think having a default but non-trivial CFL would be surprising and therefore undesirable, even if it's convenient for some users.; > > I was hoping we might be able to deprecate `diffusive_cfl` because it's a big maintenance burden, but let's keep it if its useful.; > ; > I wouldn't setting the `diffusive_cfl` is surprising. After all the diffusive cfl is as much of a necessary condition for convergence as the advective cfl, it just is a limiting-factor less often for oceanic simulations. But I'm okay with keeping the current behavior as well. I certainly don't disagree that it's convenient; the question is more whether the benefit justifies the cost. Users also want a code that's easy to maintain and extend because then they get more features! For constant diffusivities, the CFL constraint can be pre-calculated. For some common closures the calculation is simple, but this is not _generically_ the case for all turbulence closures. It's really only for variable diffusivities that we _need_ a feature for on-the-fly calculation. We could also use something like `diffusive_cfl=nothing` which completely avoids the calculation. Then we can justify supporting a diffusive CFL calculation for selected turbulence closures. That might be a good route (discussion for another issue).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2205#issuecomment-1025985247
Integrability,rout,route,"> > I think having a default but non-trivial CFL would be surprising and therefore undesirable, even if it's convenient for some users.; > > I was hoping we might be able to deprecate `diffusive_cfl` because it's a big maintenance burden, but let's keep it if its useful.; > ; > I wouldn't setting the `diffusive_cfl` is surprising. After all the diffusive cfl is as much of a necessary condition for convergence as the advective cfl, it just is a limiting-factor less often for oceanic simulations. But I'm okay with keeping the current behavior as well. I certainly don't disagree that it's convenient; the question is more whether the benefit justifies the cost. Users also want a code that's easy to maintain and extend because then they get more features! For constant diffusivities, the CFL constraint can be pre-calculated. For some common closures the calculation is simple, but this is not _generically_ the case for all turbulence closures. It's really only for variable diffusivities that we _need_ a feature for on-the-fly calculation. We could also use something like `diffusive_cfl=nothing` which completely avoids the calculation. Then we can justify supporting a diffusive CFL calculation for selected turbulence closures. That might be a good route (discussion for another issue).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2205#issuecomment-1025985247
Modifiability,extend,extend,"> > I think having a default but non-trivial CFL would be surprising and therefore undesirable, even if it's convenient for some users.; > > I was hoping we might be able to deprecate `diffusive_cfl` because it's a big maintenance burden, but let's keep it if its useful.; > ; > I wouldn't setting the `diffusive_cfl` is surprising. After all the diffusive cfl is as much of a necessary condition for convergence as the advective cfl, it just is a limiting-factor less often for oceanic simulations. But I'm okay with keeping the current behavior as well. I certainly don't disagree that it's convenient; the question is more whether the benefit justifies the cost. Users also want a code that's easy to maintain and extend because then they get more features! For constant diffusivities, the CFL constraint can be pre-calculated. For some common closures the calculation is simple, but this is not _generically_ the case for all turbulence closures. It's really only for variable diffusivities that we _need_ a feature for on-the-fly calculation. We could also use something like `diffusive_cfl=nothing` which completely avoids the calculation. Then we can justify supporting a diffusive CFL calculation for selected turbulence closures. That might be a good route (discussion for another issue).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2205#issuecomment-1025985247
Safety,avoid,avoids,"> > I think having a default but non-trivial CFL would be surprising and therefore undesirable, even if it's convenient for some users.; > > I was hoping we might be able to deprecate `diffusive_cfl` because it's a big maintenance burden, but let's keep it if its useful.; > ; > I wouldn't setting the `diffusive_cfl` is surprising. After all the diffusive cfl is as much of a necessary condition for convergence as the advective cfl, it just is a limiting-factor less often for oceanic simulations. But I'm okay with keeping the current behavior as well. I certainly don't disagree that it's convenient; the question is more whether the benefit justifies the cost. Users also want a code that's easy to maintain and extend because then they get more features! For constant diffusivities, the CFL constraint can be pre-calculated. For some common closures the calculation is simple, but this is not _generically_ the case for all turbulence closures. It's really only for variable diffusivities that we _need_ a feature for on-the-fly calculation. We could also use something like `diffusive_cfl=nothing` which completely avoids the calculation. Then we can justify supporting a diffusive CFL calculation for selected turbulence closures. That might be a good route (discussion for another issue).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2205#issuecomment-1025985247
Usability,simpl,simple,"> > I think having a default but non-trivial CFL would be surprising and therefore undesirable, even if it's convenient for some users.; > > I was hoping we might be able to deprecate `diffusive_cfl` because it's a big maintenance burden, but let's keep it if its useful.; > ; > I wouldn't setting the `diffusive_cfl` is surprising. After all the diffusive cfl is as much of a necessary condition for convergence as the advective cfl, it just is a limiting-factor less often for oceanic simulations. But I'm okay with keeping the current behavior as well. I certainly don't disagree that it's convenient; the question is more whether the benefit justifies the cost. Users also want a code that's easy to maintain and extend because then they get more features! For constant diffusivities, the CFL constraint can be pre-calculated. For some common closures the calculation is simple, but this is not _generically_ the case for all turbulence closures. It's really only for variable diffusivities that we _need_ a feature for on-the-fly calculation. We could also use something like `diffusive_cfl=nothing` which completely avoids the calculation. Then we can justify supporting a diffusive CFL calculation for selected turbulence closures. That might be a good route (discussion for another issue).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2205#issuecomment-1025985247
Availability,down,down,"I would first of all do _nothing_ that's intended to support `AnisotropicBiharmonicDiffusivity`. Instead we should delete this closure in favor of `HorizontallyCurvilinearAnisotropicBiharmonicDiffusivity` (or more appropriately, simply replace the existing `AnisotropicBiharmonicDiffusivity` with `HorizontallyCurvilinearAnisotropicBiharmonicDiffusivity`). See #2113 and a few other issues referenced there. Since `HorizontallyCurvilinearAnisotropicBiharmonicDiffusivity` uses `diffusive_flux_x` (unlike `AnisotropicBiharmonicDiffusivity` --- one of its many problems), there are no spurious _fluxes_ across immersed boundaries:. https://github.com/CliMA/Oceananigans.jl/blob/80c7064b42a47e68c90690d7ab32db187bbdf26a/src/TurbulenceClosures/turbulence_closure_implementations/horizontally_curvilinear_anisotropic_biharmonic_diffusivity.jl#L67. https://github.com/CliMA/Oceananigans.jl/blob/80c7064b42a47e68c90690d7ab32db187bbdf26a/src/ImmersedBoundaries/conditional_fluxes.jl#L48. But I think the point here is that the fluxes are calculated using ""wrong gradients"". Note that `conditional_flux_fcc` doesn't shut down fluxes within ""X"" cells of a boundary. It shuts down fluxes _across_ an immersed boundary. I think this issue is proposing to use `conditional_flux_fcc` for a _different_ purpose than what it's used for now --- to nullify fluxes for biharmonic diffusion in a buffer region around the boundary. The reason is that biharmonic fluxes are not correct on interfaces within one cell width of an immersed boundary, because they involve second order operators?. It's a little unclear to me what the right thing to do here is --- @simone-silvestri can you clarify what mathematical model you would like to implement when we have biharmonic diffusion in the presence of immersed boundaries?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2209#issuecomment-1027537708
Integrability,interface,interfaces,"I would first of all do _nothing_ that's intended to support `AnisotropicBiharmonicDiffusivity`. Instead we should delete this closure in favor of `HorizontallyCurvilinearAnisotropicBiharmonicDiffusivity` (or more appropriately, simply replace the existing `AnisotropicBiharmonicDiffusivity` with `HorizontallyCurvilinearAnisotropicBiharmonicDiffusivity`). See #2113 and a few other issues referenced there. Since `HorizontallyCurvilinearAnisotropicBiharmonicDiffusivity` uses `diffusive_flux_x` (unlike `AnisotropicBiharmonicDiffusivity` --- one of its many problems), there are no spurious _fluxes_ across immersed boundaries:. https://github.com/CliMA/Oceananigans.jl/blob/80c7064b42a47e68c90690d7ab32db187bbdf26a/src/TurbulenceClosures/turbulence_closure_implementations/horizontally_curvilinear_anisotropic_biharmonic_diffusivity.jl#L67. https://github.com/CliMA/Oceananigans.jl/blob/80c7064b42a47e68c90690d7ab32db187bbdf26a/src/ImmersedBoundaries/conditional_fluxes.jl#L48. But I think the point here is that the fluxes are calculated using ""wrong gradients"". Note that `conditional_flux_fcc` doesn't shut down fluxes within ""X"" cells of a boundary. It shuts down fluxes _across_ an immersed boundary. I think this issue is proposing to use `conditional_flux_fcc` for a _different_ purpose than what it's used for now --- to nullify fluxes for biharmonic diffusion in a buffer region around the boundary. The reason is that biharmonic fluxes are not correct on interfaces within one cell width of an immersed boundary, because they involve second order operators?. It's a little unclear to me what the right thing to do here is --- @simone-silvestri can you clarify what mathematical model you would like to implement when we have biharmonic diffusion in the presence of immersed boundaries?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2209#issuecomment-1027537708
Usability,simpl,simply,"I would first of all do _nothing_ that's intended to support `AnisotropicBiharmonicDiffusivity`. Instead we should delete this closure in favor of `HorizontallyCurvilinearAnisotropicBiharmonicDiffusivity` (or more appropriately, simply replace the existing `AnisotropicBiharmonicDiffusivity` with `HorizontallyCurvilinearAnisotropicBiharmonicDiffusivity`). See #2113 and a few other issues referenced there. Since `HorizontallyCurvilinearAnisotropicBiharmonicDiffusivity` uses `diffusive_flux_x` (unlike `AnisotropicBiharmonicDiffusivity` --- one of its many problems), there are no spurious _fluxes_ across immersed boundaries:. https://github.com/CliMA/Oceananigans.jl/blob/80c7064b42a47e68c90690d7ab32db187bbdf26a/src/TurbulenceClosures/turbulence_closure_implementations/horizontally_curvilinear_anisotropic_biharmonic_diffusivity.jl#L67. https://github.com/CliMA/Oceananigans.jl/blob/80c7064b42a47e68c90690d7ab32db187bbdf26a/src/ImmersedBoundaries/conditional_fluxes.jl#L48. But I think the point here is that the fluxes are calculated using ""wrong gradients"". Note that `conditional_flux_fcc` doesn't shut down fluxes within ""X"" cells of a boundary. It shuts down fluxes _across_ an immersed boundary. I think this issue is proposing to use `conditional_flux_fcc` for a _different_ purpose than what it's used for now --- to nullify fluxes for biharmonic diffusion in a buffer region around the boundary. The reason is that biharmonic fluxes are not correct on interfaces within one cell width of an immersed boundary, because they involve second order operators?. It's a little unclear to me what the right thing to do here is --- @simone-silvestri can you clarify what mathematical model you would like to implement when we have biharmonic diffusion in the presence of immersed boundaries?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2209#issuecomment-1027537708
Availability,down,downside,"> This came up on #2235.; > ; > The idea is to support syntax like; > ; > ```julia; > outputs = (ζ = ∂x(v) - ∂y(u), U = Average(u, dims=1)); > output_writer = JLD2OutputWriter(model, outputs, ... ); > ```; > ; > rather than requiring things to be wrapped in `Field` to work. I think this is certainly more intuitive for users!. > This wasn't easy to support previously, before we consolidate all the `Field` implementations (we had `ComputedField`, `Field`, `AveragedField`...). But now we can support it and it would reduce boilerplate (eg everything is `Field(this)`, `Field(that)` by quite a bit for the majority of use cases.; > ; > I think the downside is that users aren't immediately exposed to `Field` infrastructure. A good ""Fields tutorial"" in the docs might help with that though. Pardon if this question is naive but why is it important that users to exposed to the `Field` infrastructure?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2242#issuecomment-1036800103
Energy Efficiency,reduce,reduce,"> This came up on #2235.; > ; > The idea is to support syntax like; > ; > ```julia; > outputs = (ζ = ∂x(v) - ∂y(u), U = Average(u, dims=1)); > output_writer = JLD2OutputWriter(model, outputs, ... ); > ```; > ; > rather than requiring things to be wrapped in `Field` to work. I think this is certainly more intuitive for users!. > This wasn't easy to support previously, before we consolidate all the `Field` implementations (we had `ComputedField`, `Field`, `AveragedField`...). But now we can support it and it would reduce boilerplate (eg everything is `Field(this)`, `Field(that)` by quite a bit for the majority of use cases.; > ; > I think the downside is that users aren't immediately exposed to `Field` infrastructure. A good ""Fields tutorial"" in the docs might help with that though. Pardon if this question is naive but why is it important that users to exposed to the `Field` infrastructure?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2242#issuecomment-1036800103
Integrability,wrap,wrapped,"> This came up on #2235.; > ; > The idea is to support syntax like; > ; > ```julia; > outputs = (ζ = ∂x(v) - ∂y(u), U = Average(u, dims=1)); > output_writer = JLD2OutputWriter(model, outputs, ... ); > ```; > ; > rather than requiring things to be wrapped in `Field` to work. I think this is certainly more intuitive for users!. > This wasn't easy to support previously, before we consolidate all the `Field` implementations (we had `ComputedField`, `Field`, `AveragedField`...). But now we can support it and it would reduce boilerplate (eg everything is `Field(this)`, `Field(that)` by quite a bit for the majority of use cases.; > ; > I think the downside is that users aren't immediately exposed to `Field` infrastructure. A good ""Fields tutorial"" in the docs might help with that though. Pardon if this question is naive but why is it important that users to exposed to the `Field` infrastructure?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2242#issuecomment-1036800103
Security,expose,exposed,"> This came up on #2235.; > ; > The idea is to support syntax like; > ; > ```julia; > outputs = (ζ = ∂x(v) - ∂y(u), U = Average(u, dims=1)); > output_writer = JLD2OutputWriter(model, outputs, ... ); > ```; > ; > rather than requiring things to be wrapped in `Field` to work. I think this is certainly more intuitive for users!. > This wasn't easy to support previously, before we consolidate all the `Field` implementations (we had `ComputedField`, `Field`, `AveragedField`...). But now we can support it and it would reduce boilerplate (eg everything is `Field(this)`, `Field(that)` by quite a bit for the majority of use cases.; > ; > I think the downside is that users aren't immediately exposed to `Field` infrastructure. A good ""Fields tutorial"" in the docs might help with that though. Pardon if this question is naive but why is it important that users to exposed to the `Field` infrastructure?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2242#issuecomment-1036800103
Usability,intuit,intuitive,"> This came up on #2235.; > ; > The idea is to support syntax like; > ; > ```julia; > outputs = (ζ = ∂x(v) - ∂y(u), U = Average(u, dims=1)); > output_writer = JLD2OutputWriter(model, outputs, ... ); > ```; > ; > rather than requiring things to be wrapped in `Field` to work. I think this is certainly more intuitive for users!. > This wasn't easy to support previously, before we consolidate all the `Field` implementations (we had `ComputedField`, `Field`, `AveragedField`...). But now we can support it and it would reduce boilerplate (eg everything is `Field(this)`, `Field(that)` by quite a bit for the majority of use cases.; > ; > I think the downside is that users aren't immediately exposed to `Field` infrastructure. A good ""Fields tutorial"" in the docs might help with that though. Pardon if this question is naive but why is it important that users to exposed to the `Field` infrastructure?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2242#issuecomment-1036800103
Usability,simpl,simpler,"> I also see that @tomchor has done quite a bit of work with PRs #2652 and #3143. Also happy to help with those. I do see that grid spacings and metrics can be a thorny subject. Between these two, I'd say https://github.com/CliMA/Oceananigans.jl/pull/3143 should probably take priority. It should be simpler and I see it as a bug, which should be fixed. That PR didn't move forward because I unfortunately ran out of time, so feel free to take over it if you want! That said, it's a different issue than the one raised by @glwagner here.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2248#issuecomment-2350933066
Availability,toler,tolerance,"Very good questions. I don't have very good answers, but happy to share my thoughts. I don't know how things will change for velocity but it should be clearer after we figure out how to deal with the tracers. As for how the velocity is set, we always set the normal velocity to be zero at the interface. The only difference is the `ParitalCell` has a bottom that can be higher and we need to take this into account when computing the fluxes in and out of this region. We haven't gotten there yet but it's part of the plan. There aren't any essential differences between the current method, what we call `GridFitted` and Adcroft et al. call a `FullCell` method, and the `PartialCell` method. The former is the limit when we choose the height of the topography in a cell interface to be zero, whereas the latter can pick it to be between a tolerance (currently 0.2) and 1 of the full depth. So the `GridFitted` boundary must have the boundary between fluid and solid at a face, whereas `PartialCell` can have it anywhere in the interior. That means that the interface is really at i + alpha where 0 \le alpha < 1, or something like that. I can imagine that sometime in the future they are part of the same function, but much testing must happen before. I don't believe we need to change how `solid_interface` works but I need to look over how it's defined to make sure.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1042491748
Integrability,interface,interface,"Very good questions. I don't have very good answers, but happy to share my thoughts. I don't know how things will change for velocity but it should be clearer after we figure out how to deal with the tracers. As for how the velocity is set, we always set the normal velocity to be zero at the interface. The only difference is the `ParitalCell` has a bottom that can be higher and we need to take this into account when computing the fluxes in and out of this region. We haven't gotten there yet but it's part of the plan. There aren't any essential differences between the current method, what we call `GridFitted` and Adcroft et al. call a `FullCell` method, and the `PartialCell` method. The former is the limit when we choose the height of the topography in a cell interface to be zero, whereas the latter can pick it to be between a tolerance (currently 0.2) and 1 of the full depth. So the `GridFitted` boundary must have the boundary between fluid and solid at a face, whereas `PartialCell` can have it anywhere in the interior. That means that the interface is really at i + alpha where 0 \le alpha < 1, or something like that. I can imagine that sometime in the future they are part of the same function, but much testing must happen before. I don't believe we need to change how `solid_interface` works but I need to look over how it's defined to make sure.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1042491748
Testability,test,testing,"Very good questions. I don't have very good answers, but happy to share my thoughts. I don't know how things will change for velocity but it should be clearer after we figure out how to deal with the tracers. As for how the velocity is set, we always set the normal velocity to be zero at the interface. The only difference is the `ParitalCell` has a bottom that can be higher and we need to take this into account when computing the fluxes in and out of this region. We haven't gotten there yet but it's part of the plan. There aren't any essential differences between the current method, what we call `GridFitted` and Adcroft et al. call a `FullCell` method, and the `PartialCell` method. The former is the limit when we choose the height of the topography in a cell interface to be zero, whereas the latter can pick it to be between a tolerance (currently 0.2) and 1 of the full depth. So the `GridFitted` boundary must have the boundary between fluid and solid at a face, whereas `PartialCell` can have it anywhere in the interior. That means that the interface is really at i + alpha where 0 \le alpha < 1, or something like that. I can imagine that sometime in the future they are part of the same function, but much testing must happen before. I don't believe we need to change how `solid_interface` works but I need to look over how it's defined to make sure.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1042491748
Usability,clear,clearer,"Very good questions. I don't have very good answers, but happy to share my thoughts. I don't know how things will change for velocity but it should be clearer after we figure out how to deal with the tracers. As for how the velocity is set, we always set the normal velocity to be zero at the interface. The only difference is the `ParitalCell` has a bottom that can be higher and we need to take this into account when computing the fluxes in and out of this region. We haven't gotten there yet but it's part of the plan. There aren't any essential differences between the current method, what we call `GridFitted` and Adcroft et al. call a `FullCell` method, and the `PartialCell` method. The former is the limit when we choose the height of the topography in a cell interface to be zero, whereas the latter can pick it to be between a tolerance (currently 0.2) and 1 of the full depth. So the `GridFitted` boundary must have the boundary between fluid and solid at a face, whereas `PartialCell` can have it anywhere in the interior. That means that the interface is really at i + alpha where 0 \le alpha < 1, or something like that. I can imagine that sometime in the future they are part of the same function, but much testing must happen before. I don't believe we need to change how `solid_interface` works but I need to look over how it's defined to make sure.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1042491748
Usability,learn,learn,"I admit that I had to look up [Tullio.jl](https://github.com/mcabbott/Tullio.jl) to learn that it helps with matrix operations. Good for me to know, but if it's going away then maybe no longer essential. I gather that `abs` is being replaced with another version. Where does the new version come from?. Also, I remember a while ago having issues with computing norms on GPUs. Does this help with that at all?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2252#issuecomment-1044694374
Usability,simpl,simplest,"> I am trying to follow the code, and sorry that it's not obvious to me what's goipartition = XPartition([3, 3, 3, 3])ng on.; > ; > Because you have `devices=(0,1)`, I presume that means you are running on two GPUs?; > ; > But you also have `partition = XPartition([3, 3, 3, 3])`, which seems like you are partitioning it onto 4 regions, each of length 3, which sum to 12 (the length of the domain).; > ; > If you have two devices, wouldn't you normally have two partitions and not four?. We want to allow general partitioning across devices. For example the simplest implementation of the cubed sphere is a 6 region domain, but we won't always have 6 devices. The question to ask is not what our ""usual"" case is, but rather what the most general case that we want to support looks like.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1044754993
Availability,mainten,maintenance,"@simone-silvestri discussed the pros and cons of implementing this ""single process version"" of `MultiRegion`. ### Cons. The main con is the difficulty in maintaining code for `MultiRegionGrid` and `MultiRegionObject`, plus `apply_regionally!`. The difficulties we face here are identical to the issues that have plagued our maintenance of `CubedSphereGrid`: the need to redispatch and `apply_regionally!` a huge number of methods on `MultiRegionGrid` creates extensive cross dependencies between ""local"" implementations and their multi-region versions. This is unbelievably annoying to maintain when refactoring or adding features to existing local implementations. We can mitigate the above issue with (i) clever and careful code design and (ii) potentially a bit of metaprogramming, similar to how `@kernel` and `adapt(to, obj)` achieve CPU/GPU polymorphism. ### Pros. We identified 3 main pros:. 1. We can run problems distributed across many GPUs, or cubed sphere problems on GPU or CPU, on a single process without an MPI dependency. This is a huge win for user experience, interactivity, and ease-of-use (users don't need to invoke `mpiexec`). 2. Related to 1, we can debug complex multiregion applications (like the cubed sphere) without MPI. This is important, given the complexity of the cubed sphere (and extensions / generalizations of the quasi-unstructured cubed sphere algorithm). 3. CUDA provides functionality that works on multi-GPU nodes: CUDA FFT, matrix algebra, etc. Being able to launch these utilities from a single Julia process may greatly simplify the implementation of GPU-distributed elliptic solvers.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1050206426
Energy Efficiency,adapt,adapt,"@simone-silvestri discussed the pros and cons of implementing this ""single process version"" of `MultiRegion`. ### Cons. The main con is the difficulty in maintaining code for `MultiRegionGrid` and `MultiRegionObject`, plus `apply_regionally!`. The difficulties we face here are identical to the issues that have plagued our maintenance of `CubedSphereGrid`: the need to redispatch and `apply_regionally!` a huge number of methods on `MultiRegionGrid` creates extensive cross dependencies between ""local"" implementations and their multi-region versions. This is unbelievably annoying to maintain when refactoring or adding features to existing local implementations. We can mitigate the above issue with (i) clever and careful code design and (ii) potentially a bit of metaprogramming, similar to how `@kernel` and `adapt(to, obj)` achieve CPU/GPU polymorphism. ### Pros. We identified 3 main pros:. 1. We can run problems distributed across many GPUs, or cubed sphere problems on GPU or CPU, on a single process without an MPI dependency. This is a huge win for user experience, interactivity, and ease-of-use (users don't need to invoke `mpiexec`). 2. Related to 1, we can debug complex multiregion applications (like the cubed sphere) without MPI. This is important, given the complexity of the cubed sphere (and extensions / generalizations of the quasi-unstructured cubed sphere algorithm). 3. CUDA provides functionality that works on multi-GPU nodes: CUDA FFT, matrix algebra, etc. Being able to launch these utilities from a single Julia process may greatly simplify the implementation of GPU-distributed elliptic solvers.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1050206426
Integrability,depend,dependencies,"@simone-silvestri discussed the pros and cons of implementing this ""single process version"" of `MultiRegion`. ### Cons. The main con is the difficulty in maintaining code for `MultiRegionGrid` and `MultiRegionObject`, plus `apply_regionally!`. The difficulties we face here are identical to the issues that have plagued our maintenance of `CubedSphereGrid`: the need to redispatch and `apply_regionally!` a huge number of methods on `MultiRegionGrid` creates extensive cross dependencies between ""local"" implementations and their multi-region versions. This is unbelievably annoying to maintain when refactoring or adding features to existing local implementations. We can mitigate the above issue with (i) clever and careful code design and (ii) potentially a bit of metaprogramming, similar to how `@kernel` and `adapt(to, obj)` achieve CPU/GPU polymorphism. ### Pros. We identified 3 main pros:. 1. We can run problems distributed across many GPUs, or cubed sphere problems on GPU or CPU, on a single process without an MPI dependency. This is a huge win for user experience, interactivity, and ease-of-use (users don't need to invoke `mpiexec`). 2. Related to 1, we can debug complex multiregion applications (like the cubed sphere) without MPI. This is important, given the complexity of the cubed sphere (and extensions / generalizations of the quasi-unstructured cubed sphere algorithm). 3. CUDA provides functionality that works on multi-GPU nodes: CUDA FFT, matrix algebra, etc. Being able to launch these utilities from a single Julia process may greatly simplify the implementation of GPU-distributed elliptic solvers.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1050206426
Modifiability,refactor,refactoring,"@simone-silvestri discussed the pros and cons of implementing this ""single process version"" of `MultiRegion`. ### Cons. The main con is the difficulty in maintaining code for `MultiRegionGrid` and `MultiRegionObject`, plus `apply_regionally!`. The difficulties we face here are identical to the issues that have plagued our maintenance of `CubedSphereGrid`: the need to redispatch and `apply_regionally!` a huge number of methods on `MultiRegionGrid` creates extensive cross dependencies between ""local"" implementations and their multi-region versions. This is unbelievably annoying to maintain when refactoring or adding features to existing local implementations. We can mitigate the above issue with (i) clever and careful code design and (ii) potentially a bit of metaprogramming, similar to how `@kernel` and `adapt(to, obj)` achieve CPU/GPU polymorphism. ### Pros. We identified 3 main pros:. 1. We can run problems distributed across many GPUs, or cubed sphere problems on GPU or CPU, on a single process without an MPI dependency. This is a huge win for user experience, interactivity, and ease-of-use (users don't need to invoke `mpiexec`). 2. Related to 1, we can debug complex multiregion applications (like the cubed sphere) without MPI. This is important, given the complexity of the cubed sphere (and extensions / generalizations of the quasi-unstructured cubed sphere algorithm). 3. CUDA provides functionality that works on multi-GPU nodes: CUDA FFT, matrix algebra, etc. Being able to launch these utilities from a single Julia process may greatly simplify the implementation of GPU-distributed elliptic solvers.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1050206426
Usability,user experience,user experience,"@simone-silvestri discussed the pros and cons of implementing this ""single process version"" of `MultiRegion`. ### Cons. The main con is the difficulty in maintaining code for `MultiRegionGrid` and `MultiRegionObject`, plus `apply_regionally!`. The difficulties we face here are identical to the issues that have plagued our maintenance of `CubedSphereGrid`: the need to redispatch and `apply_regionally!` a huge number of methods on `MultiRegionGrid` creates extensive cross dependencies between ""local"" implementations and their multi-region versions. This is unbelievably annoying to maintain when refactoring or adding features to existing local implementations. We can mitigate the above issue with (i) clever and careful code design and (ii) potentially a bit of metaprogramming, similar to how `@kernel` and `adapt(to, obj)` achieve CPU/GPU polymorphism. ### Pros. We identified 3 main pros:. 1. We can run problems distributed across many GPUs, or cubed sphere problems on GPU or CPU, on a single process without an MPI dependency. This is a huge win for user experience, interactivity, and ease-of-use (users don't need to invoke `mpiexec`). 2. Related to 1, we can debug complex multiregion applications (like the cubed sphere) without MPI. This is important, given the complexity of the cubed sphere (and extensions / generalizations of the quasi-unstructured cubed sphere algorithm). 3. CUDA provides functionality that works on multi-GPU nodes: CUDA FFT, matrix algebra, etc. Being able to launch these utilities from a single Julia process may greatly simplify the implementation of GPU-distributed elliptic solvers.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1050206426
Performance,perform,performance,"I implemented a simple new validation test that runs a two-dimensional barotropic turbulence problem with `ExplicitFreeSurface`: https://github.com/CliMA/Oceananigans.jl/blob/ss/multi_region/validation/multi_region/multi_region_turbulence.jl. Here's some miscellaneous notes:. * `WENO5(vector_invariant=VelocityStencil())` is faster than `WENO5()`. Note that when we write ""WENO5(vector_invariant=stencil)"" we mean that we are using the vector invariant formulation of momentum with a WENO reconstruction for vorticity, using either ""velocity"" or ""vorticity"" in the WENO smoothness metric. The ""WENO, Vector Invariant"" scheme is probably faster because it has fewer WENO interpolations (just one per momentum component rather than 2).; * `WENO5(vector_invariant=VelocityStencil())` blows up with `MultiRegionGrid`. Some timings:. | Resolution | Grid | Advection scheme | Wall time for 1000 time steps |; | ------------- | ------------- | -- | -- |; | 128^2 | `RegularRectilinearGrid` | `WENO5()` | 3.9 s |; | 128^2 | `MultiRegionGrid` | `WENO5()` | 7.4 s |; | 128^2 | `RegularRectilinearGrid` | `WENO5(vector_invariant=VelocityStencil())` | 2.8 s |; | 256^2 | `RegularRectilinearGrid` | `WENO5()` | 14.3 s |; | 256^2 | `MultiRegionGrid ` | `WENO5()` | 18.9 s |; | 256^2 | `RegularRectilinearGrid` | `WENO5(vector_invariant=VelocityStencil())` | 10.3 s |; | 512^2 | `RegularRectilinearGrid` | `WENO5()` | 56.3 s |; | 512^2 | `MultiRegionGrid ` | `WENO5()` | 62.3 s |; | 512^2 | `RegularRectilinearGrid` | `WENO5(vector_invariant=VelocityStencil())` | 40.3 s |. I propose that we. 1) Close the gap between multi-region and single-region performance?; 2) Understand why WENO vector invariant blows up on a multi region grid.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1107942730
Security,validat,validation,"I implemented a simple new validation test that runs a two-dimensional barotropic turbulence problem with `ExplicitFreeSurface`: https://github.com/CliMA/Oceananigans.jl/blob/ss/multi_region/validation/multi_region/multi_region_turbulence.jl. Here's some miscellaneous notes:. * `WENO5(vector_invariant=VelocityStencil())` is faster than `WENO5()`. Note that when we write ""WENO5(vector_invariant=stencil)"" we mean that we are using the vector invariant formulation of momentum with a WENO reconstruction for vorticity, using either ""velocity"" or ""vorticity"" in the WENO smoothness metric. The ""WENO, Vector Invariant"" scheme is probably faster because it has fewer WENO interpolations (just one per momentum component rather than 2).; * `WENO5(vector_invariant=VelocityStencil())` blows up with `MultiRegionGrid`. Some timings:. | Resolution | Grid | Advection scheme | Wall time for 1000 time steps |; | ------------- | ------------- | -- | -- |; | 128^2 | `RegularRectilinearGrid` | `WENO5()` | 3.9 s |; | 128^2 | `MultiRegionGrid` | `WENO5()` | 7.4 s |; | 128^2 | `RegularRectilinearGrid` | `WENO5(vector_invariant=VelocityStencil())` | 2.8 s |; | 256^2 | `RegularRectilinearGrid` | `WENO5()` | 14.3 s |; | 256^2 | `MultiRegionGrid ` | `WENO5()` | 18.9 s |; | 256^2 | `RegularRectilinearGrid` | `WENO5(vector_invariant=VelocityStencil())` | 10.3 s |; | 512^2 | `RegularRectilinearGrid` | `WENO5()` | 56.3 s |; | 512^2 | `MultiRegionGrid ` | `WENO5()` | 62.3 s |; | 512^2 | `RegularRectilinearGrid` | `WENO5(vector_invariant=VelocityStencil())` | 40.3 s |. I propose that we. 1) Close the gap between multi-region and single-region performance?; 2) Understand why WENO vector invariant blows up on a multi region grid.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1107942730
Testability,test,test,"I implemented a simple new validation test that runs a two-dimensional barotropic turbulence problem with `ExplicitFreeSurface`: https://github.com/CliMA/Oceananigans.jl/blob/ss/multi_region/validation/multi_region/multi_region_turbulence.jl. Here's some miscellaneous notes:. * `WENO5(vector_invariant=VelocityStencil())` is faster than `WENO5()`. Note that when we write ""WENO5(vector_invariant=stencil)"" we mean that we are using the vector invariant formulation of momentum with a WENO reconstruction for vorticity, using either ""velocity"" or ""vorticity"" in the WENO smoothness metric. The ""WENO, Vector Invariant"" scheme is probably faster because it has fewer WENO interpolations (just one per momentum component rather than 2).; * `WENO5(vector_invariant=VelocityStencil())` blows up with `MultiRegionGrid`. Some timings:. | Resolution | Grid | Advection scheme | Wall time for 1000 time steps |; | ------------- | ------------- | -- | -- |; | 128^2 | `RegularRectilinearGrid` | `WENO5()` | 3.9 s |; | 128^2 | `MultiRegionGrid` | `WENO5()` | 7.4 s |; | 128^2 | `RegularRectilinearGrid` | `WENO5(vector_invariant=VelocityStencil())` | 2.8 s |; | 256^2 | `RegularRectilinearGrid` | `WENO5()` | 14.3 s |; | 256^2 | `MultiRegionGrid ` | `WENO5()` | 18.9 s |; | 256^2 | `RegularRectilinearGrid` | `WENO5(vector_invariant=VelocityStencil())` | 10.3 s |; | 512^2 | `RegularRectilinearGrid` | `WENO5()` | 56.3 s |; | 512^2 | `MultiRegionGrid ` | `WENO5()` | 62.3 s |; | 512^2 | `RegularRectilinearGrid` | `WENO5(vector_invariant=VelocityStencil())` | 40.3 s |. I propose that we. 1) Close the gap between multi-region and single-region performance?; 2) Understand why WENO vector invariant blows up on a multi region grid.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1107942730
Usability,simpl,simple,"I implemented a simple new validation test that runs a two-dimensional barotropic turbulence problem with `ExplicitFreeSurface`: https://github.com/CliMA/Oceananigans.jl/blob/ss/multi_region/validation/multi_region/multi_region_turbulence.jl. Here's some miscellaneous notes:. * `WENO5(vector_invariant=VelocityStencil())` is faster than `WENO5()`. Note that when we write ""WENO5(vector_invariant=stencil)"" we mean that we are using the vector invariant formulation of momentum with a WENO reconstruction for vorticity, using either ""velocity"" or ""vorticity"" in the WENO smoothness metric. The ""WENO, Vector Invariant"" scheme is probably faster because it has fewer WENO interpolations (just one per momentum component rather than 2).; * `WENO5(vector_invariant=VelocityStencil())` blows up with `MultiRegionGrid`. Some timings:. | Resolution | Grid | Advection scheme | Wall time for 1000 time steps |; | ------------- | ------------- | -- | -- |; | 128^2 | `RegularRectilinearGrid` | `WENO5()` | 3.9 s |; | 128^2 | `MultiRegionGrid` | `WENO5()` | 7.4 s |; | 128^2 | `RegularRectilinearGrid` | `WENO5(vector_invariant=VelocityStencil())` | 2.8 s |; | 256^2 | `RegularRectilinearGrid` | `WENO5()` | 14.3 s |; | 256^2 | `MultiRegionGrid ` | `WENO5()` | 18.9 s |; | 256^2 | `RegularRectilinearGrid` | `WENO5(vector_invariant=VelocityStencil())` | 10.3 s |; | 512^2 | `RegularRectilinearGrid` | `WENO5()` | 56.3 s |; | 512^2 | `MultiRegionGrid ` | `WENO5()` | 62.3 s |; | 512^2 | `RegularRectilinearGrid` | `WENO5(vector_invariant=VelocityStencil())` | 40.3 s |. I propose that we. 1) Close the gap between multi-region and single-region performance?; 2) Understand why WENO vector invariant blows up on a multi region grid.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1107942730
Modifiability,extend,extending,"Seems maybe that we want to output to a single file for every MultiRegionGrid, but in some special way by extending stuff in. https://github.com/CliMA/Oceananigans.jl/blob/main/src/OutputWriters/fetch_output.jl. Whatever we do there can then be interpretable by `FieldTimeSeries` to make sense of things. ""reconstructing"" output writers can probably be implemented with function output right now. indices seem like a challenge for the cubed sphere. For simpler stuff I guess we can partition the indices. That'd be just amazing if cuFFTxt works out of the box eh?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116865059
Usability,simpl,simpler,"Seems maybe that we want to output to a single file for every MultiRegionGrid, but in some special way by extending stuff in. https://github.com/CliMA/Oceananigans.jl/blob/main/src/OutputWriters/fetch_output.jl. Whatever we do there can then be interpretable by `FieldTimeSeries` to make sense of things. ""reconstructing"" output writers can probably be implemented with function output right now. indices seem like a challenge for the cubed sphere. For simpler stuff I guess we can partition the indices. That'd be just amazing if cuFFTxt works out of the box eh?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116865059
Integrability,depend,depends,"We can consider changing this kwarg to `directions`. I don't think we had much a conversation about it, but the two we considered originally were `direction` and `isotropy`. One motivation for using `isotropy` is to smoothly transition from ""IsotropicDiffusivity"" (with three-dimensionality implied) and ""AnisotropicDiffusivity"" (meaning, different in the horizontal and vertical directions) to a single struct. But having a clear meaning for most people is more important than that continuity. Isotropy in _one_ direction is accurate in my opinion, though I agree its the trivial case (like a ""set"" with one element) and therefore reads a little awkwardly. Diffusion can act in the ""horizontal directions"" while being horizontally-anisotropic (ie the diffusion of a vector depends on its orientation), so the meaning is a bit different. But, we can document that `ScalarDiffusivity` is isotropic in its `directions` for vectors like momentum. > To me setting a scalar diffusivity as `ScalarDiffusivity(..., isotropy=Horizontal())`, implies that the diffusivity is the same in the horizontal directions, but that you can also set a different diffusivity in the vertical direction. We can indeed use a second closure to set a vertical diffusivity.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2261#issuecomment-1046343693
Usability,clear,clear,"We can consider changing this kwarg to `directions`. I don't think we had much a conversation about it, but the two we considered originally were `direction` and `isotropy`. One motivation for using `isotropy` is to smoothly transition from ""IsotropicDiffusivity"" (with three-dimensionality implied) and ""AnisotropicDiffusivity"" (meaning, different in the horizontal and vertical directions) to a single struct. But having a clear meaning for most people is more important than that continuity. Isotropy in _one_ direction is accurate in my opinion, though I agree its the trivial case (like a ""set"" with one element) and therefore reads a little awkwardly. Diffusion can act in the ""horizontal directions"" while being horizontally-anisotropic (ie the diffusion of a vector depends on its orientation), so the meaning is a bit different. But, we can document that `ScalarDiffusivity` is isotropic in its `directions` for vectors like momentum. > To me setting a scalar diffusivity as `ScalarDiffusivity(..., isotropy=Horizontal())`, implies that the diffusivity is the same in the horizontal directions, but that you can also set a different diffusivity in the vertical direction. We can indeed use a second closure to set a vertical diffusivity.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2261#issuecomment-1046343693
Usability,simpl,simpler,"I agree with what you're saying (although I didn't know every calculation inside the solid was thrown away; I thought it was just some stuff like setting the velocities to zero). However, wouldn't using `xor` make the functions simpler and decrease the number of computations?. ```julia; east_bounded(LX, LY, LZ, i, j, k, grid) = !solid_node(LX, LY, LZ, i, j, k, grid) & solid_interface(flip(LX), LY, LZ, i, j, k, grid); ```. The above could be replaced by the following line. ```julia; east_bounded(LX, LY, LZ, i, j, k, grid) = solid_interface(flip(LX), LY, LZ, i, j, k, grid); ```. Idk if this makes a lot of difference in the grand scheme of a complete simulation, but as a rule `if` statements and comparisons are pretty expensive, so it might be better to try and decrease them, no?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2263#issuecomment-1047176248
Energy Efficiency,reduce,reduce,"> We won't reduce computations, because these operators are not short-circuiting (this is what we want to maximize performance for these inner functions).; > ; > Evaluating booleans isn't expensive. Short-circuiting logic can be expensive (or rather, prevent compiler optimizations) in hot inner loops. We've written the code so we don't use short-circuiting logic (`ifelse` rather than `if`, `&` rather than `&&`). Ah, I see. I hadn't noticed that. . > Either way we need both `east_bounded` _and_ `solid_interface` so the question is just how we shuffle logic between the two. We can consider changing `solid_interface`. If we change its behavior I would recommend calling it `fluid_solid_interface`. I think changing `solid_interface` to `fluid_solid_interface` (along with it's definition of course) is clearer. Especially because `solid_interface` confused me at first; I thought it effectively was supposed to test for the fluid-solid interface. But at this point I don't feel strongly about it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2263#issuecomment-1047193281
Integrability,interface,interface,"> We won't reduce computations, because these operators are not short-circuiting (this is what we want to maximize performance for these inner functions).; > ; > Evaluating booleans isn't expensive. Short-circuiting logic can be expensive (or rather, prevent compiler optimizations) in hot inner loops. We've written the code so we don't use short-circuiting logic (`ifelse` rather than `if`, `&` rather than `&&`). Ah, I see. I hadn't noticed that. . > Either way we need both `east_bounded` _and_ `solid_interface` so the question is just how we shuffle logic between the two. We can consider changing `solid_interface`. If we change its behavior I would recommend calling it `fluid_solid_interface`. I think changing `solid_interface` to `fluid_solid_interface` (along with it's definition of course) is clearer. Especially because `solid_interface` confused me at first; I thought it effectively was supposed to test for the fluid-solid interface. But at this point I don't feel strongly about it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2263#issuecomment-1047193281
Performance,perform,performance,"> We won't reduce computations, because these operators are not short-circuiting (this is what we want to maximize performance for these inner functions).; > ; > Evaluating booleans isn't expensive. Short-circuiting logic can be expensive (or rather, prevent compiler optimizations) in hot inner loops. We've written the code so we don't use short-circuiting logic (`ifelse` rather than `if`, `&` rather than `&&`). Ah, I see. I hadn't noticed that. . > Either way we need both `east_bounded` _and_ `solid_interface` so the question is just how we shuffle logic between the two. We can consider changing `solid_interface`. If we change its behavior I would recommend calling it `fluid_solid_interface`. I think changing `solid_interface` to `fluid_solid_interface` (along with it's definition of course) is clearer. Especially because `solid_interface` confused me at first; I thought it effectively was supposed to test for the fluid-solid interface. But at this point I don't feel strongly about it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2263#issuecomment-1047193281
Testability,log,logic,"> We won't reduce computations, because these operators are not short-circuiting (this is what we want to maximize performance for these inner functions).; > ; > Evaluating booleans isn't expensive. Short-circuiting logic can be expensive (or rather, prevent compiler optimizations) in hot inner loops. We've written the code so we don't use short-circuiting logic (`ifelse` rather than `if`, `&` rather than `&&`). Ah, I see. I hadn't noticed that. . > Either way we need both `east_bounded` _and_ `solid_interface` so the question is just how we shuffle logic between the two. We can consider changing `solid_interface`. If we change its behavior I would recommend calling it `fluid_solid_interface`. I think changing `solid_interface` to `fluid_solid_interface` (along with it's definition of course) is clearer. Especially because `solid_interface` confused me at first; I thought it effectively was supposed to test for the fluid-solid interface. But at this point I don't feel strongly about it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2263#issuecomment-1047193281
Usability,clear,clearer,"> We won't reduce computations, because these operators are not short-circuiting (this is what we want to maximize performance for these inner functions).; > ; > Evaluating booleans isn't expensive. Short-circuiting logic can be expensive (or rather, prevent compiler optimizations) in hot inner loops. We've written the code so we don't use short-circuiting logic (`ifelse` rather than `if`, `&` rather than `&&`). Ah, I see. I hadn't noticed that. . > Either way we need both `east_bounded` _and_ `solid_interface` so the question is just how we shuffle logic between the two. We can consider changing `solid_interface`. If we change its behavior I would recommend calling it `fluid_solid_interface`. I think changing `solid_interface` to `fluid_solid_interface` (along with it's definition of course) is clearer. Especially because `solid_interface` confused me at first; I thought it effectively was supposed to test for the fluid-solid interface. But at this point I don't feel strongly about it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2263#issuecomment-1047193281
Integrability,interface,interface,"> Depends if we wan tot exclude the points or edges or not (i.e where `solid_interface` is true but `solid_node` is not). Hmm yeah I am a little worried that I misunderstood the meaning of `solid_interface` since I think it does assume that the immersed boundary is ""referenced"" to a tracer cell (ie because `solid_interface(::C, ::C, ::C, i, j, k, grid) = solid_node(c, c, c, i, j, k, grid)`). But I'm not 100% sure. For example, it's presumably possible to have a solid interface at (c, c, c) even when the tracer cell is _not_ solid (ie it's a partial cell that's half-filled...). So I'm a little confused now. I think we need to distinguish between logic that's designed for enforcing impenetrability versus logic designed for enforcing boundary fluxes. We might be mixing those up right now, which works with simple immersed boundary implementations but won't generalize.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2263#issuecomment-1047270731
Testability,log,logic,"> Depends if we wan tot exclude the points or edges or not (i.e where `solid_interface` is true but `solid_node` is not). Hmm yeah I am a little worried that I misunderstood the meaning of `solid_interface` since I think it does assume that the immersed boundary is ""referenced"" to a tracer cell (ie because `solid_interface(::C, ::C, ::C, i, j, k, grid) = solid_node(c, c, c, i, j, k, grid)`). But I'm not 100% sure. For example, it's presumably possible to have a solid interface at (c, c, c) even when the tracer cell is _not_ solid (ie it's a partial cell that's half-filled...). So I'm a little confused now. I think we need to distinguish between logic that's designed for enforcing impenetrability versus logic designed for enforcing boundary fluxes. We might be mixing those up right now, which works with simple immersed boundary implementations but won't generalize.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2263#issuecomment-1047270731
Usability,simpl,simple,"> Depends if we wan tot exclude the points or edges or not (i.e where `solid_interface` is true but `solid_node` is not). Hmm yeah I am a little worried that I misunderstood the meaning of `solid_interface` since I think it does assume that the immersed boundary is ""referenced"" to a tracer cell (ie because `solid_interface(::C, ::C, ::C, i, j, k, grid) = solid_node(c, c, c, i, j, k, grid)`). But I'm not 100% sure. For example, it's presumably possible to have a solid interface at (c, c, c) even when the tracer cell is _not_ solid (ie it's a partial cell that's half-filled...). So I'm a little confused now. I think we need to distinguish between logic that's designed for enforcing impenetrability versus logic designed for enforcing boundary fluxes. We might be mixing those up right now, which works with simple immersed boundary implementations but won't generalize.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2263#issuecomment-1047270731
Availability,down,downside,"@glwagner and I talked yesterday and here are some points that emerged (@glwagner feel free to chime in if I'm forgetting/misrepresenting something). We agreed that the important points in this PR are two. (1) We should export all directions/formulations (`ZDirection`, `XYDirections`, `ThreeDimensional` or whatever we end up calling them) at the top level, and (2) we shouldn't reintroduce a `Vertical` direction in `TurbulenceClosures` when there already exists a `ZDirection` defined in `Grids` that's used for buoyancy purposes. However, we need to agree on a notation. A few main options emerged from our talk:. ### Option 1. First option is we keep calling the directions `Vertical` and `Horizontal`, since those names are pretty intuitive and play well with already-defined terms like `VerticallyImplicit` (which are also intuitive and widely used in the literature). The downside to this option, if we were to follow (2), appears as an inconsistency whenever we tilt the domain and need to use `buoyancy = Buoyancy(model=BuoyancyTracer(), vertical_unit_vector=ĝ)` (`ĝ` being a unit vector). So we could end up with a case where the vertical direction is implicitly defined as being tilted 45 degrees (by means of `Buoyancy`), but for `ScalarDiffusivity` `Vertical` will still mean the `z` direction, which is confusing. Furthermore, the default option for buoyancy would be called `buoyancy = Buoyancy(model=BuoyancyTracer(), vertical_unit_vector=Vertical())`, which is not helpful. ### Option 2. Second option is to change the notation to what I proposed here: `XYDirection` etc., which avoids this inconsistency. The downside is that it doesn't play well with terms like `VerticallyImplicit` anymore. Something we either would have to live with, or we'd need to change those terms as well (something like `ZImplicit` isn't wrong, but it's not what people generally call it). ### Option 3. We could also keep the names `Vertical` etc., but change the interface of `Buoyancy` so that it doe",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2266#issuecomment-1049975915
Integrability,interface,interface,"ever we tilt the domain and need to use `buoyancy = Buoyancy(model=BuoyancyTracer(), vertical_unit_vector=ĝ)` (`ĝ` being a unit vector). So we could end up with a case where the vertical direction is implicitly defined as being tilted 45 degrees (by means of `Buoyancy`), but for `ScalarDiffusivity` `Vertical` will still mean the `z` direction, which is confusing. Furthermore, the default option for buoyancy would be called `buoyancy = Buoyancy(model=BuoyancyTracer(), vertical_unit_vector=Vertical())`, which is not helpful. ### Option 2. Second option is to change the notation to what I proposed here: `XYDirection` etc., which avoids this inconsistency. The downside is that it doesn't play well with terms like `VerticallyImplicit` anymore. Something we either would have to live with, or we'd need to change those terms as well (something like `ZImplicit` isn't wrong, but it's not what people generally call it). ### Option 3. We could also keep the names `Vertical` etc., but change the interface of `Buoyancy` so that it doesn't implicitly define that the vertical direction is. So instead of having the interface be. `buoyancy = Buoyancy(model=BuoyancyTracer(), vertical_unit_vector=ĝ)`. it would be something like. `buoyancy = Buoyancy(model=BuoyancyTracer(), direction_antiparallel_to_gravity=ĝ)`. which is equally correct and doesn't assume that ""vertical"" is connected to the direction of gravity. The issue here is that the name `direction_antiparallel_to_gravity` is super long. ### Option 4. @simone-silvestri raised an interesting point that these aren't just ""directions"" they are also different formulations. In light of this, it might make sense to not do (2). That way we'd leave `ZDirection` in `Grids`, and define `VerticalFormulation`, `HorizontalFormulation` and `ThreeDimenionalFormulation` in `TurbulenceClosures`. Since these latter aren't ""directions"" anymore, there wouldn't be an overlap with `ZDirection` (which literally indicates only a direction). Thoughts?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2266#issuecomment-1049975915
Safety,avoid,avoids,"ur talk:. ### Option 1. First option is we keep calling the directions `Vertical` and `Horizontal`, since those names are pretty intuitive and play well with already-defined terms like `VerticallyImplicit` (which are also intuitive and widely used in the literature). The downside to this option, if we were to follow (2), appears as an inconsistency whenever we tilt the domain and need to use `buoyancy = Buoyancy(model=BuoyancyTracer(), vertical_unit_vector=ĝ)` (`ĝ` being a unit vector). So we could end up with a case where the vertical direction is implicitly defined as being tilted 45 degrees (by means of `Buoyancy`), but for `ScalarDiffusivity` `Vertical` will still mean the `z` direction, which is confusing. Furthermore, the default option for buoyancy would be called `buoyancy = Buoyancy(model=BuoyancyTracer(), vertical_unit_vector=Vertical())`, which is not helpful. ### Option 2. Second option is to change the notation to what I proposed here: `XYDirection` etc., which avoids this inconsistency. The downside is that it doesn't play well with terms like `VerticallyImplicit` anymore. Something we either would have to live with, or we'd need to change those terms as well (something like `ZImplicit` isn't wrong, but it's not what people generally call it). ### Option 3. We could also keep the names `Vertical` etc., but change the interface of `Buoyancy` so that it doesn't implicitly define that the vertical direction is. So instead of having the interface be. `buoyancy = Buoyancy(model=BuoyancyTracer(), vertical_unit_vector=ĝ)`. it would be something like. `buoyancy = Buoyancy(model=BuoyancyTracer(), direction_antiparallel_to_gravity=ĝ)`. which is equally correct and doesn't assume that ""vertical"" is connected to the direction of gravity. The issue here is that the name `direction_antiparallel_to_gravity` is super long. ### Option 4. @simone-silvestri raised an interesting point that these aren't just ""directions"" they are also different formulations. In light ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2266#issuecomment-1049975915
Usability,intuit,intuitive,"@glwagner and I talked yesterday and here are some points that emerged (@glwagner feel free to chime in if I'm forgetting/misrepresenting something). We agreed that the important points in this PR are two. (1) We should export all directions/formulations (`ZDirection`, `XYDirections`, `ThreeDimensional` or whatever we end up calling them) at the top level, and (2) we shouldn't reintroduce a `Vertical` direction in `TurbulenceClosures` when there already exists a `ZDirection` defined in `Grids` that's used for buoyancy purposes. However, we need to agree on a notation. A few main options emerged from our talk:. ### Option 1. First option is we keep calling the directions `Vertical` and `Horizontal`, since those names are pretty intuitive and play well with already-defined terms like `VerticallyImplicit` (which are also intuitive and widely used in the literature). The downside to this option, if we were to follow (2), appears as an inconsistency whenever we tilt the domain and need to use `buoyancy = Buoyancy(model=BuoyancyTracer(), vertical_unit_vector=ĝ)` (`ĝ` being a unit vector). So we could end up with a case where the vertical direction is implicitly defined as being tilted 45 degrees (by means of `Buoyancy`), but for `ScalarDiffusivity` `Vertical` will still mean the `z` direction, which is confusing. Furthermore, the default option for buoyancy would be called `buoyancy = Buoyancy(model=BuoyancyTracer(), vertical_unit_vector=Vertical())`, which is not helpful. ### Option 2. Second option is to change the notation to what I proposed here: `XYDirection` etc., which avoids this inconsistency. The downside is that it doesn't play well with terms like `VerticallyImplicit` anymore. Something we either would have to live with, or we'd need to change those terms as well (something like `ZImplicit` isn't wrong, but it's not what people generally call it). ### Option 3. We could also keep the names `Vertical` etc., but change the interface of `Buoyancy` so that it doe",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2266#issuecomment-1049975915
Safety,avoid,avoid,"I think option 4 -- `VerticalFormulation`, `HorizontalFormulation` -- probably makes the most sense for closures. I think it's important that users realize that these types indicate more than just the direction. We don't want to lose this distinction with the kwarg `directions` (or the kwarg `isotropy`, which we've learned will be interpreted as meaning ""direction""). I also think in terms of API there are a few choices:. ```julia; closure = ScalarDiffusivity(ν=1, κ=1, formulation=VerticalFormulation()) # kwarg; closure = ScalarDiffusivity(VerticalFormulation(), ν=1, κ=1) # positional argument; closure = ScalarDiffusivity{VerticalFormulation}(ν=1, κ=1) # explicit type parameter specification; closure = VerticalScalarDiffusivity(ν=1, κ=1) # alias; ```. Separately, this discussion make me think we should use `gravity_unit_vector` instead of `vertical_unit_vector` in the API for `Buoyancy` (to avoid conflicting defintions between ""vertical"" in `Buoyancy` and `TurbulenceClosures`). We can define `NegativeZDirection()` as the default for `gravity_unit_vector`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2266#issuecomment-1049988760
Usability,learn,learned,"I think option 4 -- `VerticalFormulation`, `HorizontalFormulation` -- probably makes the most sense for closures. I think it's important that users realize that these types indicate more than just the direction. We don't want to lose this distinction with the kwarg `directions` (or the kwarg `isotropy`, which we've learned will be interpreted as meaning ""direction""). I also think in terms of API there are a few choices:. ```julia; closure = ScalarDiffusivity(ν=1, κ=1, formulation=VerticalFormulation()) # kwarg; closure = ScalarDiffusivity(VerticalFormulation(), ν=1, κ=1) # positional argument; closure = ScalarDiffusivity{VerticalFormulation}(ν=1, κ=1) # explicit type parameter specification; closure = VerticalScalarDiffusivity(ν=1, κ=1) # alias; ```. Separately, this discussion make me think we should use `gravity_unit_vector` instead of `vertical_unit_vector` in the API for `Buoyancy` (to avoid conflicting defintions between ""vertical"" in `Buoyancy` and `TurbulenceClosures`). We can define `NegativeZDirection()` as the default for `gravity_unit_vector`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2266#issuecomment-1049988760
Usability,simpl,simply,"Couple random notes and questions:. https://github.com/CliMA/Oceananigans.jl/blob/b3ddbc84c8f35aaf5b93fbbfdb4cffcada5c6533/src/Advection/weno_fifth_order.jl#L177-L178. belong in `Grids`. Why `W isa Number` for `zweno == true`?. https://github.com/CliMA/Oceananigans.jl/blob/b3ddbc84c8f35aaf5b93fbbfdb4cffcada5c6533/src/Advection/weno_fifth_order.jl#L171. That line should be written. ```julia; W = zweno ? Number : Nothing; ```. but note we can also simply use `zweno` as the type parameter directly so . ```julia; const JSWENO = WENO5{<:Any, <:Any, <:Any, <:Any, <:Any, <:Any, <:Any, false}; const ZWENO = WENO5{<:Any, <:Any, <:Any, <:Any, <:Any, <:Any, <:Any, true}; ```. might make senes to move that parameter to the top of the struct. The weight calculations in the code are difficult to read and understand:. https://github.com/CliMA/Oceananigans.jl/blob/b3ddbc84c8f35aaf5b93fbbfdb4cffcada5c6533/src/Advection/weno_fifth_order.jl#L642-L668. How can we improve this? I think more describe names would help self-document at least (eg what are `j, c, m, num, l, i, op`?). We probably should add a specific reference to an equation in the comment / docstring.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2271#issuecomment-1047936316
Usability,simpl,simple,"@glwagner It would be great to have this option implemented! It's basically a function of the wind speed. This estimate gives the depth averaged Stokes drift so you can get the layer averaged Stokes drift profile by applying this estimate to each layer depth then compute the difference. [Here](https://github.com/gotm-model/code/blob/master/src/stokes_drift/stokes_drift_theory.F90) is the implementation in GOTM. . Another useful estimate of the Stokes drift is to use the wind-wave spectrum in [Donelan et al. (1985)](https://doi.org/10.1098/rsta.1979.0079). A modified version of it was used in the LESs of [Harcourt and D'Asaro, (2008)](https://doi.org/10.1175/2007JPO3842.1). See their Section 2b. Also see their Appendix B for computing the layer averaged Stokes drift. I used a simple version of it (without the directional spreading) in the LESs in [Li and Fox-Kemper, (2017)](https://doi.org/10.1175/JPO-D-17-0085.1). It's also [implemented in LANL's version of PALM](https://github.com/lanl/palm_lanl/blob/7f1444073b20ae81b451d4ab469d13e66b5358b7/trunk/SOURCE/stokes_drift_mod.f90#L234). . I think it will be wonderful to have a Stokes drift module in either LESbrary or Oceananigans that contains different options to estimate the Stokes drift profile. Is this something you are thinking of?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2290#issuecomment-1055347864
Usability,simpl,simple,"> I think it will be wonderful to have a Stokes drift module in either LESbrary or Oceananigans that contains different options to estimate the Stokes drift profile. Is this something you are thinking of?. Yes for sure! It's probably simple enough to include directly in Oceananigans. We'd put it here:. https://github.com/CliMA/Oceananigans.jl/blob/main/src/StokesDrift.jl. @qingli411 note that our input is the Stokes shear, so I think the most convenient thing to have is the Stokes drift at every level. We can difference that between the top and bottom of a cell to get the ""finite volume averaged Stokes shear"". What do you think about that?. Perhaps it makes sense to start with the Harcourt and D'Asaro 2008 model then? I'll look into that and document what I find here...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2290#issuecomment-1055347869
Energy Efficiency,adapt,adapting,"rsed_bc, velocities, tracers, clock, buoyancy); ```. This would allow the `immersed` boundary condition specified by the user to make its way into the tendency calculation. We think this might be simpler (in terms of the code) than passing `immersed_bc` into ` ∂ⱼ_τ₁ⱼ` (where we would throw it away unless we are on `ImmersedBoundaryGrid`.). Another advantage is that we can then isolate the code that calculates flux divergences for `Value` and `Gradient` (eg for no-slip boundary conditions), which could get a little complicated. I'm also trying to figure out if that would cover this case. I think we can use `ContinuousBoundaryCondition` for this kind of drag boundary condition. So in the user script we'd write something like. ```julia; u_drag(x, y, z, t, u, v, w, Cd) = - Cd * u * sqrt(u^2 + v^2 + w^2); v_drag(x, y, z, t, u, v, w, Cd) = - Cd * v * sqrt(u^2 + v^2 + w^2); w_drag(x, y, z, t, u, v, w, Cd) = - Cd * w * sqrt(u^2 + v^2 + w^2). u_immersed_bc = FluxBoundaryCondition(u_drag, parameters=Cd, field_dependencies=(:u, :v, :w)); v_immersed_bc = FluxBoundaryCondition(v_drag, parameters=Cd, field_dependencies=(:u, :v, :w)); w_immersed_bc = FluxBoundaryCondition(w_drag, parameters=Cd, field_dependencies=(:u, :v, :w)). u_boundary_conditions = FieldBoundaryConditions(immersed=u_immersed_bc); v_boundary_conditions = FieldBoundaryConditions(immersed=v_immersed_bc); w_boundary_conditions = FieldBoundaryConditions(immersed=w_immersed_bc); ```. and then under the hood, if we implement fluxes across immersed boundaries correctly, we'll get the right thing? Note the above code assumes that fluxes are along the ""inward facing normal"" --- one of the complications of the user API for this... The corresponding code for no-slip would be. ```julia; u_immersed_bc = ValueBoundaryCondition(0); v_immersed_bc = ValueBoundaryCondition(0); w_immersed_bc = ValueBoundaryCondition(0); ```. Should we work on adapting this PR in the direction of implementing such a user API? What do you recommend?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1075131624
Modifiability,adapt,adapting,"rsed_bc, velocities, tracers, clock, buoyancy); ```. This would allow the `immersed` boundary condition specified by the user to make its way into the tendency calculation. We think this might be simpler (in terms of the code) than passing `immersed_bc` into ` ∂ⱼ_τ₁ⱼ` (where we would throw it away unless we are on `ImmersedBoundaryGrid`.). Another advantage is that we can then isolate the code that calculates flux divergences for `Value` and `Gradient` (eg for no-slip boundary conditions), which could get a little complicated. I'm also trying to figure out if that would cover this case. I think we can use `ContinuousBoundaryCondition` for this kind of drag boundary condition. So in the user script we'd write something like. ```julia; u_drag(x, y, z, t, u, v, w, Cd) = - Cd * u * sqrt(u^2 + v^2 + w^2); v_drag(x, y, z, t, u, v, w, Cd) = - Cd * v * sqrt(u^2 + v^2 + w^2); w_drag(x, y, z, t, u, v, w, Cd) = - Cd * w * sqrt(u^2 + v^2 + w^2). u_immersed_bc = FluxBoundaryCondition(u_drag, parameters=Cd, field_dependencies=(:u, :v, :w)); v_immersed_bc = FluxBoundaryCondition(v_drag, parameters=Cd, field_dependencies=(:u, :v, :w)); w_immersed_bc = FluxBoundaryCondition(w_drag, parameters=Cd, field_dependencies=(:u, :v, :w)). u_boundary_conditions = FieldBoundaryConditions(immersed=u_immersed_bc); v_boundary_conditions = FieldBoundaryConditions(immersed=v_immersed_bc); w_boundary_conditions = FieldBoundaryConditions(immersed=w_immersed_bc); ```. and then under the hood, if we implement fluxes across immersed boundaries correctly, we'll get the right thing? Note the above code assumes that fluxes are along the ""inward facing normal"" --- one of the complications of the user API for this... The corresponding code for no-slip would be. ```julia; u_immersed_bc = ValueBoundaryCondition(0); v_immersed_bc = ValueBoundaryCondition(0); w_immersed_bc = ValueBoundaryCondition(0); ```. Should we work on adapting this PR in the direction of implementing such a user API? What do you recommend?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1075131624
Usability,simpl,simpler,"@tomchor @whitleyv what's the ultimate vision for this PR? @simone-silvestri and I discussed a method for adding immersed fluxes that would introduce a new term into the tendency kernels, eg here:. https://github.com/CliMA/Oceananigans.jl/blob/30ec599de5e3813d57b46e8d8fa4196bcdd250e0/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_tendency_kernel_functions.jl#L44. adding something like. ```julia; + ∂ⱼ_τ₁ⱼ_immersed(i, j, k, grid, closure, diffusivities, immersed_bc, velocities, tracers, clock, buoyancy); ```. This would allow the `immersed` boundary condition specified by the user to make its way into the tendency calculation. We think this might be simpler (in terms of the code) than passing `immersed_bc` into ` ∂ⱼ_τ₁ⱼ` (where we would throw it away unless we are on `ImmersedBoundaryGrid`.). Another advantage is that we can then isolate the code that calculates flux divergences for `Value` and `Gradient` (eg for no-slip boundary conditions), which could get a little complicated. I'm also trying to figure out if that would cover this case. I think we can use `ContinuousBoundaryCondition` for this kind of drag boundary condition. So in the user script we'd write something like. ```julia; u_drag(x, y, z, t, u, v, w, Cd) = - Cd * u * sqrt(u^2 + v^2 + w^2); v_drag(x, y, z, t, u, v, w, Cd) = - Cd * v * sqrt(u^2 + v^2 + w^2); w_drag(x, y, z, t, u, v, w, Cd) = - Cd * w * sqrt(u^2 + v^2 + w^2). u_immersed_bc = FluxBoundaryCondition(u_drag, parameters=Cd, field_dependencies=(:u, :v, :w)); v_immersed_bc = FluxBoundaryCondition(v_drag, parameters=Cd, field_dependencies=(:u, :v, :w)); w_immersed_bc = FluxBoundaryCondition(w_drag, parameters=Cd, field_dependencies=(:u, :v, :w)). u_boundary_conditions = FieldBoundaryConditions(immersed=u_immersed_bc); v_boundary_conditions = FieldBoundaryConditions(immersed=v_immersed_bc); w_boundary_conditions = FieldBoundaryConditions(immersed=w_immersed_bc); ```. and then under the hood, if we implement fluxes across immersed bo",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1075131624
Deployability,upgrade,upgrade,"sing the FFT-based solver + `NonhydrostaticModel`.; > ; > Exactly.; > ; > > It might be worthwhile benchmarking this problem on `main` with immersed boundaries but no drag. That's a more direct measurement of the cost of the drag law implemented here over no drag law, but still immersed boundary.; > ; > We can do that, but I'm keeping this branch up-to-date with `main` for now so (at least for now) it won't change results.; > ; > > I also suggest setting up a test that evaluates whether the drag boundary condition produces a measurable difference in a simulation that has a steppy boundary (like a constant slope, rather than a flat wall). You want to determine the relative contribution of this explicit drag compared to form drag for your setup of interest before investing lots of effort here.; > ; > That's a good point. Although I'd have to discuss this with @whitleyv since she's the main developer here. My thinking is that if indeed the form drag dominates, we can probably upgrade this to a partial cell grid-fitted IBM (much like @francispoulin intends to do in #2306). If my understanding is correct, you'd only need to change the definition of the volumes and areas to account for the partial step and it seems to significantly decrease form drag. Oh for sure, and hopefully we will also eventually have shaved cells which will reduce form drag even more. But you could also calculate that by the time we have partial cells working well with the FFT-based nonhydrostatic solver, et cetera, we might also have a more general implementation for boundary fluxes. But from a science point of view, if we simply need ""some drag"" to produce qualitatively useful results, then relying on form drag for `GridFittedBottom` is a simple and effective strategy to make initial progress. If we find that the numerical value of the drag exerts a strong control on the simulation results --- warranting an effort to implement a high-quality drag model, then the next question is whether the form dr",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1084707164
Energy Efficiency,reduce,reduce,", but I'm keeping this branch up-to-date with `main` for now so (at least for now) it won't change results.; > ; > > I also suggest setting up a test that evaluates whether the drag boundary condition produces a measurable difference in a simulation that has a steppy boundary (like a constant slope, rather than a flat wall). You want to determine the relative contribution of this explicit drag compared to form drag for your setup of interest before investing lots of effort here.; > ; > That's a good point. Although I'd have to discuss this with @whitleyv since she's the main developer here. My thinking is that if indeed the form drag dominates, we can probably upgrade this to a partial cell grid-fitted IBM (much like @francispoulin intends to do in #2306). If my understanding is correct, you'd only need to change the definition of the volumes and areas to account for the partial step and it seems to significantly decrease form drag. Oh for sure, and hopefully we will also eventually have shaved cells which will reduce form drag even more. But you could also calculate that by the time we have partial cells working well with the FFT-based nonhydrostatic solver, et cetera, we might also have a more general implementation for boundary fluxes. But from a science point of view, if we simply need ""some drag"" to produce qualitatively useful results, then relying on form drag for `GridFittedBottom` is a simple and effective strategy to make initial progress. If we find that the numerical value of the drag exerts a strong control on the simulation results --- warranting an effort to implement a high-quality drag model, then the next question is whether the form drag with `GridFittedBottom` is _less_ than what we think is realistic. If there is indeed too little drag then we have good justification for hard coding a drag boundary condition into `conditional_flux`. On the other hand, if there's too much drag, then the first thing to work on is an alternative representation of b",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1084707164
Testability,test,testing,"> > > Isn't this because of the implicit solve? What grid/model combination are you using?; > > > You can try testing again using a matrix solver for the non immersed model (if you are using the hydrostatic model). The timings should be similar.; > > ; > > ; > > They are probably using the FFT-based solver + `NonhydrostaticModel`.; > ; > Exactly.; > ; > > It might be worthwhile benchmarking this problem on `main` with immersed boundaries but no drag. That's a more direct measurement of the cost of the drag law implemented here over no drag law, but still immersed boundary.; > ; > We can do that, but I'm keeping this branch up-to-date with `main` for now so (at least for now) it won't change results.; > ; > > I also suggest setting up a test that evaluates whether the drag boundary condition produces a measurable difference in a simulation that has a steppy boundary (like a constant slope, rather than a flat wall). You want to determine the relative contribution of this explicit drag compared to form drag for your setup of interest before investing lots of effort here.; > ; > That's a good point. Although I'd have to discuss this with @whitleyv since she's the main developer here. My thinking is that if indeed the form drag dominates, we can probably upgrade this to a partial cell grid-fitted IBM (much like @francispoulin intends to do in #2306). If my understanding is correct, you'd only need to change the definition of the volumes and areas to account for the partial step and it seems to significantly decrease form drag. Oh for sure, and hopefully we will also eventually have shaved cells which will reduce form drag even more. But you could also calculate that by the time we have partial cells working well with the FFT-based nonhydrostatic solver, et cetera, we might also have a more general implementation for boundary fluxes. But from a science point of view, if we simply need ""some drag"" to produce qualitatively useful results, then relying on form drag for `GridF",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1084707164
Usability,simpl,simply,"change results.; > ; > > I also suggest setting up a test that evaluates whether the drag boundary condition produces a measurable difference in a simulation that has a steppy boundary (like a constant slope, rather than a flat wall). You want to determine the relative contribution of this explicit drag compared to form drag for your setup of interest before investing lots of effort here.; > ; > That's a good point. Although I'd have to discuss this with @whitleyv since she's the main developer here. My thinking is that if indeed the form drag dominates, we can probably upgrade this to a partial cell grid-fitted IBM (much like @francispoulin intends to do in #2306). If my understanding is correct, you'd only need to change the definition of the volumes and areas to account for the partial step and it seems to significantly decrease form drag. Oh for sure, and hopefully we will also eventually have shaved cells which will reduce form drag even more. But you could also calculate that by the time we have partial cells working well with the FFT-based nonhydrostatic solver, et cetera, we might also have a more general implementation for boundary fluxes. But from a science point of view, if we simply need ""some drag"" to produce qualitatively useful results, then relying on form drag for `GridFittedBottom` is a simple and effective strategy to make initial progress. If we find that the numerical value of the drag exerts a strong control on the simulation results --- warranting an effort to implement a high-quality drag model, then the next question is whether the form drag with `GridFittedBottom` is _less_ than what we think is realistic. If there is indeed too little drag then we have good justification for hard coding a drag boundary condition into `conditional_flux`. On the other hand, if there's too much drag, then the first thing to work on is an alternative representation of bathymetry. We can then repeat the form drag analysis with the new bathymetry representation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1084707164
Availability,mask,masking,"That region doesn't exist in the domain without IBM. The fluid region starts at z=0 in all cases, but for the IBM case, z<0 is; inside the immersed solid, while for the cases without IBM functionality; it's simply outside the domain. On Mon, Mar 21, 2022, 10:36 Francis J. Poulin ***@***.***>; wrote:. > Thanks @tomchor <https://github.com/tomchor> , and very nice.; >; > What would the difference of those two curves look like in the region; > where there is no masking? Are they identicial or just similar?; >; > —; > Reply to this email directly, view it on GitHub; > <https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1074212306>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/ADEX5KXCYAVHO3HLQ3KWYM3VBCXRRANCNFSM5PH5P4HA>; > .; > You are receiving this because you were mentioned.Message ID:; > ***@***.***>; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1274324882
Usability,simpl,simply,"That region doesn't exist in the domain without IBM. The fluid region starts at z=0 in all cases, but for the IBM case, z<0 is; inside the immersed solid, while for the cases without IBM functionality; it's simply outside the domain. On Mon, Mar 21, 2022, 10:36 Francis J. Poulin ***@***.***>; wrote:. > Thanks @tomchor <https://github.com/tomchor> , and very nice.; >; > What would the difference of those two curves look like in the region; > where there is no masking? Are they identicial or just similar?; >; > —; > Reply to this email directly, view it on GitHub; > <https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1074212306>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/ADEX5KXCYAVHO3HLQ3KWYM3VBCXRRANCNFSM5PH5P4HA>; > .; > You are receiving this because you were mentioned.Message ID:; > ***@***.***>; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1274324882
Usability,intuit,intuitive,This is intuitive and a good idea moving forward. I like it!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2292#issuecomment-1055498269
Usability,simpl,simplification,"A lot of code simplification, nice!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2295#issuecomment-1055989896
Availability,error,error,"Another possibility is to get rid of `diffusivity_fields` altogether and put fields inside the closures. Then users have to write things like `AnisotropicMinimumDissipation(grid)`, and we probably also need to stop ""auto halo inflation"" (instead throwing an error). Might be worth it though. Also if we have `halo = (3, 3, 3)` by default then users will basically never have issues with grid construction / halo sizes. Putting fields inside the closures also makes `OceanLearning.jl` more complicated. For example, if we want to change the parameters of a model closure, we ""only"" have to build a new closure with the same type but different parameters. If we put fields inside the closures, we have to work a little harder to combine the existing closure fields with new closure parameters. Those problems are all solvable, so it's just a question of whether simplifications here are worth complications elsewhere.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2295#issuecomment-1064169065
Usability,simpl,simplifications,"Another possibility is to get rid of `diffusivity_fields` altogether and put fields inside the closures. Then users have to write things like `AnisotropicMinimumDissipation(grid)`, and we probably also need to stop ""auto halo inflation"" (instead throwing an error). Might be worth it though. Also if we have `halo = (3, 3, 3)` by default then users will basically never have issues with grid construction / halo sizes. Putting fields inside the closures also makes `OceanLearning.jl` more complicated. For example, if we want to change the parameters of a model closure, we ""only"" have to build a new closure with the same type but different parameters. If we put fields inside the closures, we have to work a little harder to combine the existing closure fields with new closure parameters. Those problems are all solvable, so it's just a question of whether simplifications here are worth complications elsewhere.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2295#issuecomment-1064169065
Usability,simpl,simplicity,"I would go with the second option for one reason:; If a user knows enough to pass a tuple of closures to the model constructor they are well aware that `closure` is a tuple. There is no need to go the extra mile to sum them together. We can also have a function that returns a `tuple` of viscosities associated with the `tuple` of closures but maybe it would require a different name like `closure_viscosities`; ```; closure = (AnisotropicMinimumDissipation(), ScalarDiffusivity(ν=1.05e-6, κ=1e-7)); closure_viscosities(model) #returns (1.05e-6, νₑ); closure_diffusivities(model, :b) # returns (1e-7, κₑ); closure_diffusivities(model) # returns a tuple of named tuples with all tracer diffusivities; ```. The problem is that not every closure might have a diffusivity or viscosity associated with it (like mass flux models), in that case we will have to think at something else. In addition, I am convinced of the simplicity of keeping the `diffusivity_fields`, nesting too many structs might make code too complex (thinking also at future development of `MultiRegion`)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2295#issuecomment-1064188091
Usability,simpl,simplicity,"> In addition, I am convinced of the simplicity of keeping the `diffusivity_fields`, nesting too many structs might make code too complex (thinking also at future development of `MultiRegion`). Ok to clarify you're saying we _should keep_ `diffusivity_fields` / `closure_fields`?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2295#issuecomment-1064194104
Availability,error,errors,"> Quickly looking at Lin 1997, they compare the results of their method with a finite volume (FV) method. Their method does better. I wonder if their FV method is at all similar to what the MITgcm uses?; > ; > Is it fair to say the first is easier and the second has the potential to be more accurate?. MITgcm does not use Lin 1997. Instead, they use vertical spacing from the _underlying_ grid (not the partial cell grid) to calculate the hydrostatic pressure. This somehow reduces the accuracy of the hydrostatic pressure calculation, but results in an approximation that does not have spurious pressure gradient errors. It's simple and effective. Lin 1997 _is_ a finite volume method. @glwagner and @francispoulin I think starting with Lin makes sense.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1087701963
Energy Efficiency,reduce,reduces,"> Quickly looking at Lin 1997, they compare the results of their method with a finite volume (FV) method. Their method does better. I wonder if their FV method is at all similar to what the MITgcm uses?; > ; > Is it fair to say the first is easier and the second has the potential to be more accurate?. MITgcm does not use Lin 1997. Instead, they use vertical spacing from the _underlying_ grid (not the partial cell grid) to calculate the hydrostatic pressure. This somehow reduces the accuracy of the hydrostatic pressure calculation, but results in an approximation that does not have spurious pressure gradient errors. It's simple and effective. Lin 1997 _is_ a finite volume method. @glwagner and @francispoulin I think starting with Lin makes sense.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1087701963
Usability,simpl,simple,"> Quickly looking at Lin 1997, they compare the results of their method with a finite volume (FV) method. Their method does better. I wonder if their FV method is at all similar to what the MITgcm uses?; > ; > Is it fair to say the first is easier and the second has the potential to be more accurate?. MITgcm does not use Lin 1997. Instead, they use vertical spacing from the _underlying_ grid (not the partial cell grid) to calculate the hydrostatic pressure. This somehow reduces the accuracy of the hydrostatic pressure calculation, but results in an approximation that does not have spurious pressure gradient errors. It's simple and effective. Lin 1997 _is_ a finite volume method. @glwagner and @francispoulin I think starting with Lin makes sense.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1087701963
Security,validat,validation,Thanks @tomchor for fixing this PR so that the tests pass. So far what we have only tested the case when there is buoyancy with no motion. It would be nice to have a problem with non-zero velocities work. . I see there is this script [here](https://github.com/CliMA/Oceananigans.jl/blob/main/validation/immersed_boundaries/flow_over_hills.jl) that we could play with but it does not seem like a minimal working example. Do you know of a simple script that looks at flow over a bump we could look at?. @glwagner also suggested we test this with lat-lon grids and create tests.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1125406301
Testability,test,tests,Thanks @tomchor for fixing this PR so that the tests pass. So far what we have only tested the case when there is buoyancy with no motion. It would be nice to have a problem with non-zero velocities work. . I see there is this script [here](https://github.com/CliMA/Oceananigans.jl/blob/main/validation/immersed_boundaries/flow_over_hills.jl) that we could play with but it does not seem like a minimal working example. Do you know of a simple script that looks at flow over a bump we could look at?. @glwagner also suggested we test this with lat-lon grids and create tests.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1125406301
Usability,simpl,simple,Thanks @tomchor for fixing this PR so that the tests pass. So far what we have only tested the case when there is buoyancy with no motion. It would be nice to have a problem with non-zero velocities work. . I see there is this script [here](https://github.com/CliMA/Oceananigans.jl/blob/main/validation/immersed_boundaries/flow_over_hills.jl) that we could play with but it does not seem like a minimal working example. Do you know of a simple script that looks at flow over a bump we could look at?. @glwagner also suggested we test this with lat-lon grids and create tests.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1125406301
Security,validat,validation,"> So far what we have only tested the case when there is buoyancy with no motion. It would be nice to have a problem with non-zero velocities work. Agreed. I most likely will be using IBMs starting now so I probably will be testing IBMs on a variety of settings. > I see there is this script [here](https://github.com/CliMA/Oceananigans.jl/blob/main/validation/immersed_boundaries/flow_over_hills.jl) that we could play with but it does not seem like a minimal working example. Do you know of a simple script that looks at flow over a bump we could look at?. I don't have anything ready but that script looks pretty good to me. We just need to tweak it a bit? What would be the goal here as a validation script?. > @glwagner also suggested we test this with lat-lon grids and create tests. I think that should be the case for lat-lon and rectilinear grids, no? At the moment I think we're kinda limited with IBM tests:. ```; ~/repos/Oceananigans.jl/test $ grep -r ""\<Immersed"" * ; test_boundary_conditions_integration.jl: immersed_rectilinear_grid(topology) = ImmersedBoundaryGrid(RectilinearGrid(arch; topology, z=(-Lz, Lz), grid_kw...), ib); test_boundary_conditions_integration.jl: if grid isa ImmersedBoundaryGrid && side == :bottom; test_boundary_conditions_integration.jl: if grid isa ImmersedBoundaryGrid && side == :bottom; test_boundary_conditions_integration.jl: # Omit ImmersedBoundaryGrid from vertically-periodic test; test_conditional_reductions.jl:using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBoundary; test_conditional_reductions.jl:using Oceananigans.ImmersedBoundaries: conditional_length; test_conditional_reductions.jl: @info "" Testing Reductions on Immersed fields""; test_conditional_reductions.jl: ibg = ImmersedBoundaryGrid(grid, GridFittedBoundary((x, y, z) -> (x < 0.5))); test_dynamics.jl:using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBoundary, GridFittedBottom, mask_immersed_field!; test_dynamics.jl: grid = ImmersedBounda",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1126367199
Testability,test,tested,"> So far what we have only tested the case when there is buoyancy with no motion. It would be nice to have a problem with non-zero velocities work. Agreed. I most likely will be using IBMs starting now so I probably will be testing IBMs on a variety of settings. > I see there is this script [here](https://github.com/CliMA/Oceananigans.jl/blob/main/validation/immersed_boundaries/flow_over_hills.jl) that we could play with but it does not seem like a minimal working example. Do you know of a simple script that looks at flow over a bump we could look at?. I don't have anything ready but that script looks pretty good to me. We just need to tweak it a bit? What would be the goal here as a validation script?. > @glwagner also suggested we test this with lat-lon grids and create tests. I think that should be the case for lat-lon and rectilinear grids, no? At the moment I think we're kinda limited with IBM tests:. ```; ~/repos/Oceananigans.jl/test $ grep -r ""\<Immersed"" * ; test_boundary_conditions_integration.jl: immersed_rectilinear_grid(topology) = ImmersedBoundaryGrid(RectilinearGrid(arch; topology, z=(-Lz, Lz), grid_kw...), ib); test_boundary_conditions_integration.jl: if grid isa ImmersedBoundaryGrid && side == :bottom; test_boundary_conditions_integration.jl: if grid isa ImmersedBoundaryGrid && side == :bottom; test_boundary_conditions_integration.jl: # Omit ImmersedBoundaryGrid from vertically-periodic test; test_conditional_reductions.jl:using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBoundary; test_conditional_reductions.jl:using Oceananigans.ImmersedBoundaries: conditional_length; test_conditional_reductions.jl: @info "" Testing Reductions on Immersed fields""; test_conditional_reductions.jl: ibg = ImmersedBoundaryGrid(grid, GridFittedBoundary((x, y, z) -> (x < 0.5))); test_dynamics.jl:using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBoundary, GridFittedBottom, mask_immersed_field!; test_dynamics.jl: grid = ImmersedBounda",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1126367199
Usability,simpl,simple,"> So far what we have only tested the case when there is buoyancy with no motion. It would be nice to have a problem with non-zero velocities work. Agreed. I most likely will be using IBMs starting now so I probably will be testing IBMs on a variety of settings. > I see there is this script [here](https://github.com/CliMA/Oceananigans.jl/blob/main/validation/immersed_boundaries/flow_over_hills.jl) that we could play with but it does not seem like a minimal working example. Do you know of a simple script that looks at flow over a bump we could look at?. I don't have anything ready but that script looks pretty good to me. We just need to tweak it a bit? What would be the goal here as a validation script?. > @glwagner also suggested we test this with lat-lon grids and create tests. I think that should be the case for lat-lon and rectilinear grids, no? At the moment I think we're kinda limited with IBM tests:. ```; ~/repos/Oceananigans.jl/test $ grep -r ""\<Immersed"" * ; test_boundary_conditions_integration.jl: immersed_rectilinear_grid(topology) = ImmersedBoundaryGrid(RectilinearGrid(arch; topology, z=(-Lz, Lz), grid_kw...), ib); test_boundary_conditions_integration.jl: if grid isa ImmersedBoundaryGrid && side == :bottom; test_boundary_conditions_integration.jl: if grid isa ImmersedBoundaryGrid && side == :bottom; test_boundary_conditions_integration.jl: # Omit ImmersedBoundaryGrid from vertically-periodic test; test_conditional_reductions.jl:using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBoundary; test_conditional_reductions.jl:using Oceananigans.ImmersedBoundaries: conditional_length; test_conditional_reductions.jl: @info "" Testing Reductions on Immersed fields""; test_conditional_reductions.jl: ibg = ImmersedBoundaryGrid(grid, GridFittedBoundary((x, y, z) -> (x < 0.5))); test_dynamics.jl:using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBoundary, GridFittedBottom, mask_immersed_field!; test_dynamics.jl: grid = ImmersedBounda",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1126367199
Usability,intuit,intuitive,"Could someone please explain why `minimum_fractional_Δz` is necessary? For example, why is the default value not 0, which would be (imo) more intuitive? I couldn't find this anywhere.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1131700908
Usability,intuit,intuitive,"> Could someone please explain why `minimum_fractional_Δz` is necessary? For example, why is the default value not 0, which would be (imo) more intuitive? I couldn't find this anywhere. The problem is that we don't want a cell to be too small because this could cause a serious restriction for numerical stability because of the CFL condition. I haven't faced this yet, but this is common practice in the MITgcm, so we are doing the same. But probably worth playing with it to see if/when it matters?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1131853922
Energy Efficiency,reduce,reduces,"> Could someone please explain why `minimum_fractional_Δz` is necessary? For example, why is the default value not 0, which would be (imo) more intuitive? I couldn't find this anywhere. I don't know what you mean that it's not ""intuitive"" (what role does intuition play here?) As for finding information about it, a basic reference for partial cell methods is [""Representation of Topography by Shaved Cells in a Height Coordinate Ocean Model"" by Adcroft et al. 1997](https://journals.ametsoc.org/view/journals/mwre/125/9/1520-0493_1997_125_2293_rotbsc_2.0.co_2.xml). A ""partial cell"" method is one in which the height of the bottom most cell in the domain is _reduced_. This reduces cell height, interface areas, and volumes (in our current implementation --- other models are possible as well). Grid spacing is the dominant factor in the numerical stability of a model. One basic determinant of numerical stability is the CFL condition, which, for example, requires `w dt / dz < 1`. It's thus wise to modify grid metrics with care. Usually, it's undesirable to have 1 or some small number of cells with much smaller spacings / areas / volumes than the rest, because that single cell will impose severe time step restrictions on the entire model. `minimum_fractional_Δz` limits the amount by which we can reduce cell size to prevent the creation of very thin cells with severe time-step restrictions. Setting this value to 0 is likely to produce a model with impractably short time-step restrictions. MITgcm uses a default value of 0.1.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1132039324
Integrability,interface,interface,"> Could someone please explain why `minimum_fractional_Δz` is necessary? For example, why is the default value not 0, which would be (imo) more intuitive? I couldn't find this anywhere. I don't know what you mean that it's not ""intuitive"" (what role does intuition play here?) As for finding information about it, a basic reference for partial cell methods is [""Representation of Topography by Shaved Cells in a Height Coordinate Ocean Model"" by Adcroft et al. 1997](https://journals.ametsoc.org/view/journals/mwre/125/9/1520-0493_1997_125_2293_rotbsc_2.0.co_2.xml). A ""partial cell"" method is one in which the height of the bottom most cell in the domain is _reduced_. This reduces cell height, interface areas, and volumes (in our current implementation --- other models are possible as well). Grid spacing is the dominant factor in the numerical stability of a model. One basic determinant of numerical stability is the CFL condition, which, for example, requires `w dt / dz < 1`. It's thus wise to modify grid metrics with care. Usually, it's undesirable to have 1 or some small number of cells with much smaller spacings / areas / volumes than the rest, because that single cell will impose severe time step restrictions on the entire model. `minimum_fractional_Δz` limits the amount by which we can reduce cell size to prevent the creation of very thin cells with severe time-step restrictions. Setting this value to 0 is likely to produce a model with impractably short time-step restrictions. MITgcm uses a default value of 0.1.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1132039324
Usability,intuit,intuitive,"> Could someone please explain why `minimum_fractional_Δz` is necessary? For example, why is the default value not 0, which would be (imo) more intuitive? I couldn't find this anywhere. I don't know what you mean that it's not ""intuitive"" (what role does intuition play here?) As for finding information about it, a basic reference for partial cell methods is [""Representation of Topography by Shaved Cells in a Height Coordinate Ocean Model"" by Adcroft et al. 1997](https://journals.ametsoc.org/view/journals/mwre/125/9/1520-0493_1997_125_2293_rotbsc_2.0.co_2.xml). A ""partial cell"" method is one in which the height of the bottom most cell in the domain is _reduced_. This reduces cell height, interface areas, and volumes (in our current implementation --- other models are possible as well). Grid spacing is the dominant factor in the numerical stability of a model. One basic determinant of numerical stability is the CFL condition, which, for example, requires `w dt / dz < 1`. It's thus wise to modify grid metrics with care. Usually, it's undesirable to have 1 or some small number of cells with much smaller spacings / areas / volumes than the rest, because that single cell will impose severe time step restrictions on the entire model. `minimum_fractional_Δz` limits the amount by which we can reduce cell size to prevent the creation of very thin cells with severe time-step restrictions. Setting this value to 0 is likely to produce a model with impractably short time-step restrictions. MITgcm uses a default value of 0.1.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1132039324
Testability,test,tests,I'd like to help and hopefully clean up or simplify the tests along the way.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2307#issuecomment-1120209140
Usability,simpl,simplify,I'd like to help and hopefully clean up or simplify the tests along the way.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2307#issuecomment-1120209140
Usability,learn,learning,I think we should link to https://julialang.org/learning/getting-started/. and also take care not to repeat any material there. @tomchor do you mind if I edit this PR?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2312#issuecomment-1060052035
Deployability,install,install,"> I think we should link to https://julialang.org/learning/getting-started/; > ; > and also take care not to repeat any material there. I actually think we should give a bit of the gist here too. A little overlap is okay because I think it helps users get an overview in one place before committing to install Oceananigans (lets them know how easy it is). Although I agree we should link Julia's ""getting started page"" too and what I wrote may be on the side of too much information. > @tomchor do you mind if I edit this PR?. Not at all. Go for it!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2312#issuecomment-1060054262
Usability,learn,learning,"> I think we should link to https://julialang.org/learning/getting-started/; > ; > and also take care not to repeat any material there. I actually think we should give a bit of the gist here too. A little overlap is okay because I think it helps users get an overview in one place before committing to install Oceananigans (lets them know how easy it is). Although I agree we should link Julia's ""getting started page"" too and what I wrote may be on the side of too much information. > @tomchor do you mind if I edit this PR?. Not at all. Go for it!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2312#issuecomment-1060054262
Deployability,install,install,"I think the hard part on giving instructions for running it on HPCs is that it all depends on the distribution, permissions, jobs manager etc.. . It is hard to generalize, unless there is an easy way to do so that I haven't thought. I thought about creating a Docker image that could simply run for Julia with all dependencies, but Chris warned on how tricky it is to make Docker work with the GPU efficiently. So I just think this is not applicable. I am trying to install Julia with the main packages and Oceananigans dependencies on the HPCs that I have access and this is not being easy. Sometimes Julia is outdated, or it doesn't precompile packages properly etc. . Python's Conda is very handy for these situations, but It might just be the case I am too new in Julia for the things I am trying to do.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2312#issuecomment-1062495328
Energy Efficiency,efficient,efficiently,"I think the hard part on giving instructions for running it on HPCs is that it all depends on the distribution, permissions, jobs manager etc.. . It is hard to generalize, unless there is an easy way to do so that I haven't thought. I thought about creating a Docker image that could simply run for Julia with all dependencies, but Chris warned on how tricky it is to make Docker work with the GPU efficiently. So I just think this is not applicable. I am trying to install Julia with the main packages and Oceananigans dependencies on the HPCs that I have access and this is not being easy. Sometimes Julia is outdated, or it doesn't precompile packages properly etc. . Python's Conda is very handy for these situations, but It might just be the case I am too new in Julia for the things I am trying to do.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2312#issuecomment-1062495328
Integrability,depend,depends,"I think the hard part on giving instructions for running it on HPCs is that it all depends on the distribution, permissions, jobs manager etc.. . It is hard to generalize, unless there is an easy way to do so that I haven't thought. I thought about creating a Docker image that could simply run for Julia with all dependencies, but Chris warned on how tricky it is to make Docker work with the GPU efficiently. So I just think this is not applicable. I am trying to install Julia with the main packages and Oceananigans dependencies on the HPCs that I have access and this is not being easy. Sometimes Julia is outdated, or it doesn't precompile packages properly etc. . Python's Conda is very handy for these situations, but It might just be the case I am too new in Julia for the things I am trying to do.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2312#issuecomment-1062495328
Security,access,access,"I think the hard part on giving instructions for running it on HPCs is that it all depends on the distribution, permissions, jobs manager etc.. . It is hard to generalize, unless there is an easy way to do so that I haven't thought. I thought about creating a Docker image that could simply run for Julia with all dependencies, but Chris warned on how tricky it is to make Docker work with the GPU efficiently. So I just think this is not applicable. I am trying to install Julia with the main packages and Oceananigans dependencies on the HPCs that I have access and this is not being easy. Sometimes Julia is outdated, or it doesn't precompile packages properly etc. . Python's Conda is very handy for these situations, but It might just be the case I am too new in Julia for the things I am trying to do.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2312#issuecomment-1062495328
Usability,simpl,simply,"I think the hard part on giving instructions for running it on HPCs is that it all depends on the distribution, permissions, jobs manager etc.. . It is hard to generalize, unless there is an easy way to do so that I haven't thought. I thought about creating a Docker image that could simply run for Julia with all dependencies, but Chris warned on how tricky it is to make Docker work with the GPU efficiently. So I just think this is not applicable. I am trying to install Julia with the main packages and Oceananigans dependencies on the HPCs that I have access and this is not being easy. Sometimes Julia is outdated, or it doesn't precompile packages properly etc. . Python's Conda is very handy for these situations, but It might just be the case I am too new in Julia for the things I am trying to do.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2312#issuecomment-1062495328
Deployability,install,install,"> I think the hard part on giving instructions for running it on HPCs is that it all depends on the distribution, permissions, jobs manager etc..; > ; > It is hard to generalize, unless there is an easy way to do so that I haven't thought. I thought about creating a Docker image that could simply run for Julia with all dependencies, but Chris warned on how tricky it is to make Docker work with the GPU efficiently. So I just think this is not applicable.; > ; > I am trying to install Julia with the main packages and Oceananigans dependencies on the HPCs that I have access and this is not being easy. Sometimes Julia is outdated, or it doesn't precompile packages properly etc.; > ; > Python's Conda is very handy for these situations, but It might just be the case I am too new in Julia for the things I am trying to do. I hear ya. @glwagner suggested something interesting which is to leave a discussion open on installing Julia on HPCs where people could post their experiences and help each other. I quite like that idea and if you're willing to open a discussion you can be the first one to benefit from it :). We could you out regarding the troubles you've been having",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2312#issuecomment-1062500978
Energy Efficiency,efficient,efficiently,"> I think the hard part on giving instructions for running it on HPCs is that it all depends on the distribution, permissions, jobs manager etc..; > ; > It is hard to generalize, unless there is an easy way to do so that I haven't thought. I thought about creating a Docker image that could simply run for Julia with all dependencies, but Chris warned on how tricky it is to make Docker work with the GPU efficiently. So I just think this is not applicable.; > ; > I am trying to install Julia with the main packages and Oceananigans dependencies on the HPCs that I have access and this is not being easy. Sometimes Julia is outdated, or it doesn't precompile packages properly etc.; > ; > Python's Conda is very handy for these situations, but It might just be the case I am too new in Julia for the things I am trying to do. I hear ya. @glwagner suggested something interesting which is to leave a discussion open on installing Julia on HPCs where people could post their experiences and help each other. I quite like that idea and if you're willing to open a discussion you can be the first one to benefit from it :). We could you out regarding the troubles you've been having",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2312#issuecomment-1062500978
Integrability,depend,depends,"> I think the hard part on giving instructions for running it on HPCs is that it all depends on the distribution, permissions, jobs manager etc..; > ; > It is hard to generalize, unless there is an easy way to do so that I haven't thought. I thought about creating a Docker image that could simply run for Julia with all dependencies, but Chris warned on how tricky it is to make Docker work with the GPU efficiently. So I just think this is not applicable.; > ; > I am trying to install Julia with the main packages and Oceananigans dependencies on the HPCs that I have access and this is not being easy. Sometimes Julia is outdated, or it doesn't precompile packages properly etc.; > ; > Python's Conda is very handy for these situations, but It might just be the case I am too new in Julia for the things I am trying to do. I hear ya. @glwagner suggested something interesting which is to leave a discussion open on installing Julia on HPCs where people could post their experiences and help each other. I quite like that idea and if you're willing to open a discussion you can be the first one to benefit from it :). We could you out regarding the troubles you've been having",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2312#issuecomment-1062500978
Security,access,access,"> I think the hard part on giving instructions for running it on HPCs is that it all depends on the distribution, permissions, jobs manager etc..; > ; > It is hard to generalize, unless there is an easy way to do so that I haven't thought. I thought about creating a Docker image that could simply run for Julia with all dependencies, but Chris warned on how tricky it is to make Docker work with the GPU efficiently. So I just think this is not applicable.; > ; > I am trying to install Julia with the main packages and Oceananigans dependencies on the HPCs that I have access and this is not being easy. Sometimes Julia is outdated, or it doesn't precompile packages properly etc.; > ; > Python's Conda is very handy for these situations, but It might just be the case I am too new in Julia for the things I am trying to do. I hear ya. @glwagner suggested something interesting which is to leave a discussion open on installing Julia on HPCs where people could post their experiences and help each other. I quite like that idea and if you're willing to open a discussion you can be the first one to benefit from it :). We could you out regarding the troubles you've been having",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2312#issuecomment-1062500978
Usability,simpl,simply,"> I think the hard part on giving instructions for running it on HPCs is that it all depends on the distribution, permissions, jobs manager etc..; > ; > It is hard to generalize, unless there is an easy way to do so that I haven't thought. I thought about creating a Docker image that could simply run for Julia with all dependencies, but Chris warned on how tricky it is to make Docker work with the GPU efficiently. So I just think this is not applicable.; > ; > I am trying to install Julia with the main packages and Oceananigans dependencies on the HPCs that I have access and this is not being easy. Sometimes Julia is outdated, or it doesn't precompile packages properly etc.; > ; > Python's Conda is very handy for these situations, but It might just be the case I am too new in Julia for the things I am trying to do. I hear ya. @glwagner suggested something interesting which is to leave a discussion open on installing Julia on HPCs where people could post their experiences and help each other. I quite like that idea and if you're willing to open a discussion you can be the first one to benefit from it :). We could you out regarding the troubles you've been having",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2312#issuecomment-1062500978
Deployability,install,install,"> > I think the hard part on giving instructions for running it on HPCs is that it all depends on the distribution, permissions, jobs manager etc..; > > It is hard to generalize, unless there is an easy way to do so that I haven't thought. I thought about creating a Docker image that could simply run for Julia with all dependencies, but Chris warned on how tricky it is to make Docker work with the GPU efficiently. So I just think this is not applicable.; > > I am trying to install Julia with the main packages and Oceananigans dependencies on the HPCs that I have access and this is not being easy. Sometimes Julia is outdated, or it doesn't precompile packages properly etc.; > > Python's Conda is very handy for these situations, but It might just be the case I am too new in Julia for the things I am trying to do.; > ; > I hear ya. @glwagner suggested something interesting which is to leave a discussion open on installing Julia on HPCs where people could post their experiences and help each other. I quite like that idea and if you're willing to open a discussion you can be the first one to benefit from it :); > ; > We could you out regarding the troubles you've been having. I just did that, but here are so many problems I don't know where to start with. I will try to choose the one that seems easier and go for it. Haha",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2312#issuecomment-1062503237
Energy Efficiency,efficient,efficiently,"> > I think the hard part on giving instructions for running it on HPCs is that it all depends on the distribution, permissions, jobs manager etc..; > > It is hard to generalize, unless there is an easy way to do so that I haven't thought. I thought about creating a Docker image that could simply run for Julia with all dependencies, but Chris warned on how tricky it is to make Docker work with the GPU efficiently. So I just think this is not applicable.; > > I am trying to install Julia with the main packages and Oceananigans dependencies on the HPCs that I have access and this is not being easy. Sometimes Julia is outdated, or it doesn't precompile packages properly etc.; > > Python's Conda is very handy for these situations, but It might just be the case I am too new in Julia for the things I am trying to do.; > ; > I hear ya. @glwagner suggested something interesting which is to leave a discussion open on installing Julia on HPCs where people could post their experiences and help each other. I quite like that idea and if you're willing to open a discussion you can be the first one to benefit from it :); > ; > We could you out regarding the troubles you've been having. I just did that, but here are so many problems I don't know where to start with. I will try to choose the one that seems easier and go for it. Haha",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2312#issuecomment-1062503237
Integrability,depend,depends,"> > I think the hard part on giving instructions for running it on HPCs is that it all depends on the distribution, permissions, jobs manager etc..; > > It is hard to generalize, unless there is an easy way to do so that I haven't thought. I thought about creating a Docker image that could simply run for Julia with all dependencies, but Chris warned on how tricky it is to make Docker work with the GPU efficiently. So I just think this is not applicable.; > > I am trying to install Julia with the main packages and Oceananigans dependencies on the HPCs that I have access and this is not being easy. Sometimes Julia is outdated, or it doesn't precompile packages properly etc.; > > Python's Conda is very handy for these situations, but It might just be the case I am too new in Julia for the things I am trying to do.; > ; > I hear ya. @glwagner suggested something interesting which is to leave a discussion open on installing Julia on HPCs where people could post their experiences and help each other. I quite like that idea and if you're willing to open a discussion you can be the first one to benefit from it :); > ; > We could you out regarding the troubles you've been having. I just did that, but here are so many problems I don't know where to start with. I will try to choose the one that seems easier and go for it. Haha",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2312#issuecomment-1062503237
Security,access,access,"> > I think the hard part on giving instructions for running it on HPCs is that it all depends on the distribution, permissions, jobs manager etc..; > > It is hard to generalize, unless there is an easy way to do so that I haven't thought. I thought about creating a Docker image that could simply run for Julia with all dependencies, but Chris warned on how tricky it is to make Docker work with the GPU efficiently. So I just think this is not applicable.; > > I am trying to install Julia with the main packages and Oceananigans dependencies on the HPCs that I have access and this is not being easy. Sometimes Julia is outdated, or it doesn't precompile packages properly etc.; > > Python's Conda is very handy for these situations, but It might just be the case I am too new in Julia for the things I am trying to do.; > ; > I hear ya. @glwagner suggested something interesting which is to leave a discussion open on installing Julia on HPCs where people could post their experiences and help each other. I quite like that idea and if you're willing to open a discussion you can be the first one to benefit from it :); > ; > We could you out regarding the troubles you've been having. I just did that, but here are so many problems I don't know where to start with. I will try to choose the one that seems easier and go for it. Haha",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2312#issuecomment-1062503237
Usability,simpl,simply,"> > I think the hard part on giving instructions for running it on HPCs is that it all depends on the distribution, permissions, jobs manager etc..; > > It is hard to generalize, unless there is an easy way to do so that I haven't thought. I thought about creating a Docker image that could simply run for Julia with all dependencies, but Chris warned on how tricky it is to make Docker work with the GPU efficiently. So I just think this is not applicable.; > > I am trying to install Julia with the main packages and Oceananigans dependencies on the HPCs that I have access and this is not being easy. Sometimes Julia is outdated, or it doesn't precompile packages properly etc.; > > Python's Conda is very handy for these situations, but It might just be the case I am too new in Julia for the things I am trying to do.; > ; > I hear ya. @glwagner suggested something interesting which is to leave a discussion open on installing Julia on HPCs where people could post their experiences and help each other. I quite like that idea and if you're willing to open a discussion you can be the first one to benefit from it :); > ; > We could you out regarding the troubles you've been having. I just did that, but here are so many problems I don't know where to start with. I will try to choose the one that seems easier and go for it. Haha",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2312#issuecomment-1062503237
Testability,test,tested,"> ```julia; > julia> using CUDA; CUDA.allowscalar(true); > ; > julia> model.velocities.u.data; > ```. This also isn't working for me now. Although I'm sure it did work at some point because I've tested this. I'm okay removing parts of this page this and linking to some CUDA docs. What led me to write that instead of referring to a link is that I don't find the [Julia GPU docs](https://juliagpu.org/cuda/) very helpful and couldn't find a docs page that explained the differences very clearly. I still can't, actually, but if anyone can suggest a page I also think it's best to just link to that.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2316#issuecomment-1060811190
Usability,clear,clearly,"> ```julia; > julia> using CUDA; CUDA.allowscalar(true); > ; > julia> model.velocities.u.data; > ```. This also isn't working for me now. Although I'm sure it did work at some point because I've tested this. I'm okay removing parts of this page this and linking to some CUDA docs. What led me to write that instead of referring to a link is that I don't find the [Julia GPU docs](https://juliagpu.org/cuda/) very helpful and couldn't find a docs page that explained the differences very clearly. I still can't, actually, but if anyone can suggest a page I also think it's best to just link to that.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2316#issuecomment-1060811190
Usability,learn,learned,"> Indeed, I am not completely sure about the correctness of the solution showed in the videos above... The scheme is for sure more stable, but I think it's just the byproduct of numerical diffusion being too high (there is no viscosity!). A few ideas to make progress. * Attempt to measure a rate of convergence for this case with a resolution study?. * Implement both WENO and third-order reconstruction of vorticity to see what the difference is (perhaps measuring numerical dissipation). If we get nothing from WENO (or they exhibit similar dissipation somehow) then maybe we've learned something. On that last point, it'd be fun to support. ```julia; momentum_advection = VectorInvariant(vorticity=WENO5()); ```. or something. > (there is no viscosity!). I think we can still aim for stable simulations with zero explicit dissipation... see results on https://github.com/CliMA/GeophysicalDissipation.jl",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1060823690
Testability,test,test,"Thanks @simone-silvestri for clarifying. I checkede and the RH-wave is an exact solution in the case of a rigid-lid. Since the hydrostatic model must have a free-surface, taking gravity to be very big should make the solution even better. . It is impressive that everything is stable and can run with such a large time step considering how strong gravity is. . The advection of a bump is a simpler test case but not nearly as interesting as the RH-wave.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1061780426
Usability,simpl,simpler,"Thanks @simone-silvestri for clarifying. I checkede and the RH-wave is an exact solution in the case of a rigid-lid. Since the hydrostatic model must have a free-surface, taking gravity to be very big should make the solution even better. . It is impressive that everything is stable and can run with such a large time step considering how strong gravity is. . The advection of a bump is a simpler test case but not nearly as interesting as the RH-wave.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1061780426
Usability,simpl,simplify,"@simone-silvestri : That sounds great!. If you point me to the `VectorInvariant` form I can certainly help simplify the current form to shallow water. One issue to think about is how to switch between the current shallow water model, which is in conservative form, but that's just a detail.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1062146789
Usability,simpl,simpler,"Just note that you'll have to redo any work you do in the context of shallow water because the formulation is different. `ShallowWaterModel` uses a conservative form and thus solves for `uh`, rather than `u = uh / h`. It was coded in this way explicitly to have different conservation properties. So you should probably not expect that things like numerical dissipation will be consistent between `ShallowWaterModel` and `HydrostaticFreeSurfaceModel`. Note that a single layer `HydrostaticFreeSurfaceModel` is _simpler_ than `ShallowWaterModel` because it linearizes the free surface. In other words, a `HydrostaticFreeSurfaceModel` with one vertical layer is a ""shallow water model"", but with a linear free surface. You can use that fact if you like if you want to derive analytical solutions. I'd just caution that working with `ShallowWaterModel` probably makes the problem _more complex_ rather than simpler. So while interesting in its own right, it doesn't seem like the easiest way to make progress towards getting an advection scheme working for `HydrostaticFreeSurfaceModel`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1062924033
Availability,robust,robust,"uspect.; 3. Note: these forms of viscosity are not strictly positive preserving and they can increase kinetic energy. I know of a form of the harmonic case that is positive preserving and we could include that. But does anyone case about those levels of details? If yes I can include the form in the writeup and even a short derivation of how to get it from the 3D equations.; 4. @glwagner pointed out that `ShallowWaterModel` is very separate from everything else in Oceananigans and that is a bit of a pain to maintain. One advantage of a `VectorInvariant` form is that it could rely heavily on `HydrostaticModel`, that way they grow together. It might even ben an embarassingly simply application.; 5. I would like there to be a switch from free-surface to rigid-lid. In the latter we have to solve an elliptic problem, and again probably easier with a `VectorInvariant` form but probably not difficult with a conservative form either. How do people suggest this would work?; 6. I would like to have both `VectorInvariant` and `Conservative` forms. Each has their advantages and if you wanted to know if your results were robust, you could try both and if they give you the same result then you would have confidence in your results. But maybe people would think this is too much effort to maintain?. As for the utility of the shallow water model, I would like to get some students using it in Oceananigans to study oceanographic problems, and if we wanted to include coastlines I think we could do this using the `VectorInvariant` form but not the `Conservative` form. I don't expect this will be of huge demand, but it is also be useful for pedagogical reasons, for students learning about GFD and oceanography. I also think it's a nice way to test advection schemes as with the free-surface version we don't have to solve for the pressure, so it's simpler. I am of course very interested as to what others think about these issues as well. Maybe this should move to an issue instead of this PR?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1064259381
Deployability,integrat,integrate,"dvantages compared to other methods: i.e. doesn't help with conserving anything and does not easily extend to other geometries. **Q2**: The pressure term in the momentum equation is ` 1/\rho_0 \nabla p`. In the case of a rigid lid we have that `p` is the surface pressure. I thought that redefining pressure with ` p/\rho_p -> p` might be easier, to get rid of the constant, but it's easy enough to include the coefficent. We should continue to do whatever Oceananigans is currently doing, and I thought it was absorving the constant density, but I could be wrong. **Q3**: In the shallow water model with a free-surface the pressure is always hydrostatic, `p = p_0 + g \rho_0 (h - z)`, where `h` is the total depth. The case of a rigid lid is a bit different since we just have the surface pressure `p`. You are correct that the free-surface shallow water model is very similar to the 3D compressible Euler equations. The free-surface SW is a compressible model, which is why we don't have to solve any elliptic problem, and instead we simply integrate the three prognostic equations. . The rigid-lid SW model (which we don't have yet) is different of course. I am sure we can use the existing solves to determine the surface pressure as the hydrostatic model currently does. Here are some thoughts to consider:. 1. Introducing topography is pretty easy but when we do so, we should probably introduce a free-surface. Following the convention of the hydrostatic model seems like the way to proceed. Agreed?; 2. Visosity is not difficult to include but there's a question of which form of viscosity to include. The standard harmonic or biharmonic diffiusivities would be good choices, where they act on the velocities not the transport velocities. If we had a `VectorInvariant` form then I think we could use the current libraries. For the conservative forms, I think we have to adapt them, which will take more effort I suspect.; 3. Note: these forms of viscosity are not strictly positive preserving ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1064259381
Energy Efficiency,adapt,adapt,"o the 3D compressible Euler equations. The free-surface SW is a compressible model, which is why we don't have to solve any elliptic problem, and instead we simply integrate the three prognostic equations. . The rigid-lid SW model (which we don't have yet) is different of course. I am sure we can use the existing solves to determine the surface pressure as the hydrostatic model currently does. Here are some thoughts to consider:. 1. Introducing topography is pretty easy but when we do so, we should probably introduce a free-surface. Following the convention of the hydrostatic model seems like the way to proceed. Agreed?; 2. Visosity is not difficult to include but there's a question of which form of viscosity to include. The standard harmonic or biharmonic diffiusivities would be good choices, where they act on the velocities not the transport velocities. If we had a `VectorInvariant` form then I think we could use the current libraries. For the conservative forms, I think we have to adapt them, which will take more effort I suspect.; 3. Note: these forms of viscosity are not strictly positive preserving and they can increase kinetic energy. I know of a form of the harmonic case that is positive preserving and we could include that. But does anyone case about those levels of details? If yes I can include the form in the writeup and even a short derivation of how to get it from the 3D equations.; 4. @glwagner pointed out that `ShallowWaterModel` is very separate from everything else in Oceananigans and that is a bit of a pain to maintain. One advantage of a `VectorInvariant` form is that it could rely heavily on `HydrostaticModel`, that way they grow together. It might even ben an embarassingly simply application.; 5. I would like there to be a switch from free-surface to rigid-lid. In the latter we have to solve an elliptic problem, and again probably easier with a `VectorInvariant` form but probably not difficult with a conservative form either. How do people sugge",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1064259381
Integrability,integrat,integrate,"dvantages compared to other methods: i.e. doesn't help with conserving anything and does not easily extend to other geometries. **Q2**: The pressure term in the momentum equation is ` 1/\rho_0 \nabla p`. In the case of a rigid lid we have that `p` is the surface pressure. I thought that redefining pressure with ` p/\rho_p -> p` might be easier, to get rid of the constant, but it's easy enough to include the coefficent. We should continue to do whatever Oceananigans is currently doing, and I thought it was absorving the constant density, but I could be wrong. **Q3**: In the shallow water model with a free-surface the pressure is always hydrostatic, `p = p_0 + g \rho_0 (h - z)`, where `h` is the total depth. The case of a rigid lid is a bit different since we just have the surface pressure `p`. You are correct that the free-surface shallow water model is very similar to the 3D compressible Euler equations. The free-surface SW is a compressible model, which is why we don't have to solve any elliptic problem, and instead we simply integrate the three prognostic equations. . The rigid-lid SW model (which we don't have yet) is different of course. I am sure we can use the existing solves to determine the surface pressure as the hydrostatic model currently does. Here are some thoughts to consider:. 1. Introducing topography is pretty easy but when we do so, we should probably introduce a free-surface. Following the convention of the hydrostatic model seems like the way to proceed. Agreed?; 2. Visosity is not difficult to include but there's a question of which form of viscosity to include. The standard harmonic or biharmonic diffiusivities would be good choices, where they act on the velocities not the transport velocities. If we had a `VectorInvariant` form then I think we could use the current libraries. For the conservative forms, I think we have to adapt them, which will take more effort I suspect.; 3. Note: these forms of viscosity are not strictly positive preserving ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1064259381
Modifiability,extend,extend,"Thanks for the questions @simone-silvestri . I'll answer them here as it's probably easier for the discussion. **Q1**: You can certainly solve the equations in the non-conservative form and the method should work. But it does't have any advantages compared to other methods: i.e. doesn't help with conserving anything and does not easily extend to other geometries. **Q2**: The pressure term in the momentum equation is ` 1/\rho_0 \nabla p`. In the case of a rigid lid we have that `p` is the surface pressure. I thought that redefining pressure with ` p/\rho_p -> p` might be easier, to get rid of the constant, but it's easy enough to include the coefficent. We should continue to do whatever Oceananigans is currently doing, and I thought it was absorving the constant density, but I could be wrong. **Q3**: In the shallow water model with a free-surface the pressure is always hydrostatic, `p = p_0 + g \rho_0 (h - z)`, where `h` is the total depth. The case of a rigid lid is a bit different since we just have the surface pressure `p`. You are correct that the free-surface shallow water model is very similar to the 3D compressible Euler equations. The free-surface SW is a compressible model, which is why we don't have to solve any elliptic problem, and instead we simply integrate the three prognostic equations. . The rigid-lid SW model (which we don't have yet) is different of course. I am sure we can use the existing solves to determine the surface pressure as the hydrostatic model currently does. Here are some thoughts to consider:. 1. Introducing topography is pretty easy but when we do so, we should probably introduce a free-surface. Following the convention of the hydrostatic model seems like the way to proceed. Agreed?; 2. Visosity is not difficult to include but there's a question of which form of viscosity to include. The standard harmonic or biharmonic diffiusivities would be good choices, where they act on the velocities not the transport velocities. If we had a `Vec",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1064259381
Testability,test,test,"uspect.; 3. Note: these forms of viscosity are not strictly positive preserving and they can increase kinetic energy. I know of a form of the harmonic case that is positive preserving and we could include that. But does anyone case about those levels of details? If yes I can include the form in the writeup and even a short derivation of how to get it from the 3D equations.; 4. @glwagner pointed out that `ShallowWaterModel` is very separate from everything else in Oceananigans and that is a bit of a pain to maintain. One advantage of a `VectorInvariant` form is that it could rely heavily on `HydrostaticModel`, that way they grow together. It might even ben an embarassingly simply application.; 5. I would like there to be a switch from free-surface to rigid-lid. In the latter we have to solve an elliptic problem, and again probably easier with a `VectorInvariant` form but probably not difficult with a conservative form either. How do people suggest this would work?; 6. I would like to have both `VectorInvariant` and `Conservative` forms. Each has their advantages and if you wanted to know if your results were robust, you could try both and if they give you the same result then you would have confidence in your results. But maybe people would think this is too much effort to maintain?. As for the utility of the shallow water model, I would like to get some students using it in Oceananigans to study oceanographic problems, and if we wanted to include coastlines I think we could do this using the `VectorInvariant` form but not the `Conservative` form. I don't expect this will be of huge demand, but it is also be useful for pedagogical reasons, for students learning about GFD and oceanography. I also think it's a nice way to test advection schemes as with the free-surface version we don't have to solve for the pressure, so it's simpler. I am of course very interested as to what others think about these issues as well. Maybe this should move to an issue instead of this PR?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1064259381
Usability,simpl,simply,"dvantages compared to other methods: i.e. doesn't help with conserving anything and does not easily extend to other geometries. **Q2**: The pressure term in the momentum equation is ` 1/\rho_0 \nabla p`. In the case of a rigid lid we have that `p` is the surface pressure. I thought that redefining pressure with ` p/\rho_p -> p` might be easier, to get rid of the constant, but it's easy enough to include the coefficent. We should continue to do whatever Oceananigans is currently doing, and I thought it was absorving the constant density, but I could be wrong. **Q3**: In the shallow water model with a free-surface the pressure is always hydrostatic, `p = p_0 + g \rho_0 (h - z)`, where `h` is the total depth. The case of a rigid lid is a bit different since we just have the surface pressure `p`. You are correct that the free-surface shallow water model is very similar to the 3D compressible Euler equations. The free-surface SW is a compressible model, which is why we don't have to solve any elliptic problem, and instead we simply integrate the three prognostic equations. . The rigid-lid SW model (which we don't have yet) is different of course. I am sure we can use the existing solves to determine the surface pressure as the hydrostatic model currently does. Here are some thoughts to consider:. 1. Introducing topography is pretty easy but when we do so, we should probably introduce a free-surface. Following the convention of the hydrostatic model seems like the way to proceed. Agreed?; 2. Visosity is not difficult to include but there's a question of which form of viscosity to include. The standard harmonic or biharmonic diffiusivities would be good choices, where they act on the velocities not the transport velocities. If we had a `VectorInvariant` form then I think we could use the current libraries. For the conservative forms, I think we have to adapt them, which will take more effort I suspect.; 3. Note: these forms of viscosity are not strictly positive preserving ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1064259381
Usability,simpl,simplest,"Very exciting results! Thanks for sharing the plots and animations @simone-silvestri . I am very keen to help with the `ShallowWaterModel` and am sure we can get something working, after we figure out exactly what we want. I am a little surprised that Coriolis might play a problem as those terms don't invovle any derivitaves and so are usually the simplest. But there is probably something I'm not getting. I am happy to think about this more tomorrow.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1064730470
Usability,learn,learn,"The movies look great, and I agree that the top row looks much better than the bottom row. @glwagner You mentioned that the top right (vorticity) is more dissipative than the top left (velocity). It's hard for me to see this from the movies. Did you look at other diagnostics to determine this or maybe you are much more perceptive to the fine details than I am. @simone-silvestri : I would be very interested to learn how your scheme difffers from the published method above. I have read through the paper and know it pretty well. Can you give me an idea as to what you do differently? Otherwise, I suppose I can look at the code I suppose.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1081905400
Usability,learn,learn,Thanks @glwagner and great we have both options. I imagine that @pvthinker (Guillaume) would be very interesting to learn about this.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1081963426
Usability,simpl,simple,"We can apply 4 pretty immediately and start speeding up things if everyone agrees. . @glwagner I'm curious as to why you think we should remove that example. Also, do we need the diffusion example? One might argue that the 2D turbulence example is almost as simple and introductory, while being more illustrative of ocean simulations.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2326#issuecomment-1063185935
Usability,clear,clearly,"> > > @glwagner, @tomchor, @francispoulin: have a look at the baroclinic adjustment example :); > > ; > > ; > > I did now and it looks great! Nice to see both a vertical slice and a 3D image at the same time. Interesting how at the beginning it seems to be jittering almost before it becomes unstable. I think this is a great addition!; > ; > The jitters are gravity waves from the geostrophic adjustment. Nice. I suppose to see those more clearly one could plot the vertical velocity? I am not suggesting we do that here, but might try it out of my own interests sake.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2333#issuecomment-1077657834
Usability,clear,clearly,"> > > > @glwagner, @tomchor, @francispoulin: have a look at the baroclinic adjustment example :); > > > ; > > > ; > > > I did now and it looks great! Nice to see both a vertical slice and a 3D image at the same time. Interesting how at the beginning it seems to be jittering almost before it becomes unstable. I think this is a great addition!; > > ; > > ; > > The jitters are gravity waves from the geostrophic adjustment.; > ; > Nice. I suppose to see those more clearly one could plot the vertical velocity? I am not suggesting we do that here, but might try it out of my own interests sake. That's not a bad idea since the experiment is apparently _about_ the adjustment. I think the plotting could use some work anyways, there's a lot of white space. Probably the plot title / label can't be it's own box, we have to somehow make it floating text...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2333#issuecomment-1077667610
Availability,down,downside,"losure = ScalarDiffusivity(; ν, κ=(; b=κᵇ)); true_model = NonhydrostaticModel(; grid, closure, velocities, tracers, buoyancy=BuoyancyTracer()); ```. which produces. ```julia; julia> true_model = NonhydrostaticModel(; grid, closure, velocities, tracers, buoyancy=BuoyancyTracer()); NonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0); ├── grid: 1×1×128 RectilinearGrid{Float64, Flat, Flat, Bounded} on CPU with 0×0×3 halo; ├── timestepper: QuasiAdamsBashforth2TimeStepper; ├── tracers: b; ├── closure: ScalarDiffusivity{ExplicitTimeDiscretization}(ν=BinaryOperation at (Center, Center, Center), κ=(b=UnaryOperation at (Center, Center, Center),)); ├── buoyancy: BuoyancyTracer with -ĝ = ZDirection; └── coriolis: Nothing; ```. note the type of `model.closure`. (Also note this doesn't work with `HydrostaticFreeSurfaceModel` apparently... we need to fix that.). One downside of this method is that it precludes `VerticallyImplicitTimeDiscretization()`: because we use a predictor-corrector method for implicit time discretization, diffusivities that are treated implicitly _must_ be precomputed. ## Subtleties. There's more. There are subtleties peculiar to using `Ri` in a closure, because `Ri` easily becomes NaN when both the buoyancy gradient and shear are zero. The usual solution to this for ocean modeling is to use the ""hack"" that 0/0 = 0. In other words, NaNs are intercepted and set to 0. There are again a few solutions to this. One is simply to set all `NaN` to zero in side the function that computes `Ri`, eg. ```julia; u, v, w = model.velocities; b = model.tracers.b; Ri_op = @at (Center, Center, Center) ∂z(b) / (∂z(u)^2 + ∂z(v)^2). """""" Compute the Richardson number and store in `Ri`. """"""; function compute_Ri!(sim); Ri .= Ri_op. # Zero out NaNs; Ri_parent = parent(Ri); parent(Ri_parent)[isnan.(Ri_parent)] .= 0. fill_halo_regions!(Ri, sim.model.architecture); return nothing; end; ```. Other possibilities are 1) use `ConditionalOperation` to intercept `0/0` ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1065995186
Energy Efficiency,efficient,efficient,"licitTimeDiscretization(); ν, κ=(; b=κᵇ)); ```. _Then_, you need to compute `Ri` in a `Simulation.callback` (you also need to fill it's halo regions, which is a bit annoying but we show you how below). This is pretty advanced usage (and there are subtleties as I mention below) so I'll write a script that implements Pacanowski-Philander as an example. Note that it is currently a limitation of our turbulence closures that viscosities diffusivities must be defined at `(Center, Center, Center)`. #2295 makes some changes that will permit this restriction to be relaxed in the future, but we aren't quite there yet. ## Solution 2: precreate `velocities` and `tracers`. Another solution is to pre-create `velocities` and `tracers` by pre-creating a ""fake model"". Then, the viscosity / diffusivities can be defined directly as abstract operations of `fake_model.velocities` and `fake_model.tracers`, and these named tuples can be passed on to a ""true"" model. This _could_ be slightly more efficient than computing and storing `Ri` every time-step. This would look something like. ```julia; grid = RectilinearGrid(size=128, z=(-100, 0), halo=3, topology=(Flat, Flat, Bounded)); fake_model = NonhydrostaticModel(; grid, tracers=:b, buoyancy=nothing). velocities = fake_model.velocities; tracers = fake_model.tracers; Ri = ∂z(b) / (∂z(u)^2 + ∂z(v)^2). ν₀ = 1e-4; ν₁ = 1e-2; κ₀ = 1e-5; κ₁ = 1e-2; c = 5; n = 2. ν = @at (Center, Center, Center) ν₀ + ν₁ / (1 + c * Ri^n); κᵇ = @at (Center, Center, Center) κ₀ + κ₁ / (1 + c * Ri^(n+1)); closure = ScalarDiffusivity(; ν, κ=(; b=κᵇ)); true_model = NonhydrostaticModel(; grid, closure, velocities, tracers, buoyancy=BuoyancyTracer()); ```. which produces. ```julia; julia> true_model = NonhydrostaticModel(; grid, closure, velocities, tracers, buoyancy=BuoyancyTracer()); NonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0); ├── grid: 1×1×128 RectilinearGrid{Float64, Flat, Flat, Bounded} on CPU with 0×0×3 halo; ├── timestepper: QuasiAdams",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1065995186
Safety,predict,predictor-corrector,"losure = ScalarDiffusivity(; ν, κ=(; b=κᵇ)); true_model = NonhydrostaticModel(; grid, closure, velocities, tracers, buoyancy=BuoyancyTracer()); ```. which produces. ```julia; julia> true_model = NonhydrostaticModel(; grid, closure, velocities, tracers, buoyancy=BuoyancyTracer()); NonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0); ├── grid: 1×1×128 RectilinearGrid{Float64, Flat, Flat, Bounded} on CPU with 0×0×3 halo; ├── timestepper: QuasiAdamsBashforth2TimeStepper; ├── tracers: b; ├── closure: ScalarDiffusivity{ExplicitTimeDiscretization}(ν=BinaryOperation at (Center, Center, Center), κ=(b=UnaryOperation at (Center, Center, Center),)); ├── buoyancy: BuoyancyTracer with -ĝ = ZDirection; └── coriolis: Nothing; ```. note the type of `model.closure`. (Also note this doesn't work with `HydrostaticFreeSurfaceModel` apparently... we need to fix that.). One downside of this method is that it precludes `VerticallyImplicitTimeDiscretization()`: because we use a predictor-corrector method for implicit time discretization, diffusivities that are treated implicitly _must_ be precomputed. ## Subtleties. There's more. There are subtleties peculiar to using `Ri` in a closure, because `Ri` easily becomes NaN when both the buoyancy gradient and shear are zero. The usual solution to this for ocean modeling is to use the ""hack"" that 0/0 = 0. In other words, NaNs are intercepted and set to 0. There are again a few solutions to this. One is simply to set all `NaN` to zero in side the function that computes `Ri`, eg. ```julia; u, v, w = model.velocities; b = model.tracers.b; Ri_op = @at (Center, Center, Center) ∂z(b) / (∂z(u)^2 + ∂z(v)^2). """""" Compute the Richardson number and store in `Ri`. """"""; function compute_Ri!(sim); Ri .= Ri_op. # Zero out NaNs; Ri_parent = parent(Ri); parent(Ri_parent)[isnan.(Ri_parent)] .= 0. fill_halo_regions!(Ri, sim.model.architecture); return nothing; end; ```. Other possibilities are 1) use `ConditionalOperation` to intercept `0/0` ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1065995186
Usability,simpl,simplest,"@iuryt this is a great question! Do you mind if I convert this to a discussion? I think there are multiple answers and a discussion might be better suited for keeping track of the solutions for future users. There are a few possible solutions. Note that the diffusivities can also be `AbstractArray`, which include `Field` and `AbstractOperations`. Using either a concrete `Field` or `AbstractOperation` is how you'll solve this problem. ## Solution: pre-define a Richardson number field and compute in `Simulation.callbacks`. This is perhaps the simplest solution: create a field `Ri = Field{Center, Center, Face}(grid)`, and then to define an abstract operation that's a function of this field as your diffusivity, something like:. ```julia; # Pacanowski-Philander (eg https://glwagner.github.io/OceanTurb.jl/latest/models/pacanowskiphilander/); Ri = Field{Center, Center, Face}(grid) # ∂z(b) / (∂z(u)^2 + ∂z(v)^2); ν₀ = 1e-4; ν₁ = 1e-2; κ₀ = 1e-5; κ₁ = 1e-2; c = 5; n = 2. ν = @at (Center, Center, Center) ν₀ + ν₁ / (1 + c * Ri^n); κᵇ = @at (Center, Center, Center) κ₀ + κ₁ / (1 + c * Ri^(n+1)). @show ν # it's an operation... closure = ScalarDiffusivity(VerticallyImplicitTimeDiscretization(); ν, κ=(; b=κᵇ)); ```. _Then_, you need to compute `Ri` in a `Simulation.callback` (you also need to fill it's halo regions, which is a bit annoying but we show you how below). This is pretty advanced usage (and there are subtleties as I mention below) so I'll write a script that implements Pacanowski-Philander as an example. Note that it is currently a limitation of our turbulence closures that viscosities diffusivities must be defined at `(Center, Center, Center)`. #2295 makes some changes that will permit this restriction to be relaxed in the future, but we aren't quite there yet. ## Solution 2: precreate `velocities` and `tracers`. Another solution is to pre-create `velocities` and `tracers` by pre-creating a ""fake model"". Then, the viscosity / diffusivities can be defined directly as abstr",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1065995186
Deployability,update,update,"@glwagner ; I am really impressed with your effort to explain to me all details of the implementation. Thanks you!; In the past few days I am learning a lot reading the code/documentation and examples of Oceananigans. When I started this issue, I wasn't really expecting to have Pacanowski-Philander parameterization implemented in a few hours. Kudos to you!!; I know this parameterization is very simple, but implementing it on a FORTRAN-based GCM from scratch would take waaaay more time, at least for me. Can you help me to see if I understood everything correctly? Please, sorry if I am asking too-trivial questions. Why you need to define `f²`, wouldn't work simply using `∂zᶠᶜᶠ` and squaring the operation?. I understand that you create a fake model and don't run it, simply use it to update the auxiliary field. I don't understand why you could not do the same for the main model. For instance, you could first create the model, define Ri and closure and then `set!` the model with this new closure and auxiliary field. Does that makes sense? I understand the in the background this might not work the way it is now. Something like this:. ```; model = HydrostaticFreeSurfaceModel(; grid, tracers=:b, buoyancy=BuoyancyTracer()). Ri = Field(KernelFunctionOperation{Center, Center, Center}(Riᶜᶜᶜ, grid, computed_dependencies=(model.velocities, model.tracers.b))). ν = ν₀ + ν₁ / (1 + c * Ri^n); κᵇ = κ₀ + κ₁ / (1 + c * Ri^(n+1)). closure = ScalarDiffusivity(VerticallyImplicitTimeDiscretization(); ν, κ=(; b=κᵇ)). set!(model, closure = closure, auxiliary_fields = (; Ri)); ```. Thinking on a more general way, it would be awesome to give a general function that could depend on any field in the model, including auxiliary. I am thinking that this way it would be easier for users to create and implement their own parameterizations. Including using any model in general that could come in a form of a function. For instance, a ML model could be simply used as a turbulence closure. Again, thanks fo",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066110688
Integrability,depend,depend,"e code/documentation and examples of Oceananigans. When I started this issue, I wasn't really expecting to have Pacanowski-Philander parameterization implemented in a few hours. Kudos to you!!; I know this parameterization is very simple, but implementing it on a FORTRAN-based GCM from scratch would take waaaay more time, at least for me. Can you help me to see if I understood everything correctly? Please, sorry if I am asking too-trivial questions. Why you need to define `f²`, wouldn't work simply using `∂zᶠᶜᶠ` and squaring the operation?. I understand that you create a fake model and don't run it, simply use it to update the auxiliary field. I don't understand why you could not do the same for the main model. For instance, you could first create the model, define Ri and closure and then `set!` the model with this new closure and auxiliary field. Does that makes sense? I understand the in the background this might not work the way it is now. Something like this:. ```; model = HydrostaticFreeSurfaceModel(; grid, tracers=:b, buoyancy=BuoyancyTracer()). Ri = Field(KernelFunctionOperation{Center, Center, Center}(Riᶜᶜᶜ, grid, computed_dependencies=(model.velocities, model.tracers.b))). ν = ν₀ + ν₁ / (1 + c * Ri^n); κᵇ = κ₀ + κ₁ / (1 + c * Ri^(n+1)). closure = ScalarDiffusivity(VerticallyImplicitTimeDiscretization(); ν, κ=(; b=κᵇ)). set!(model, closure = closure, auxiliary_fields = (; Ri)); ```. Thinking on a more general way, it would be awesome to give a general function that could depend on any field in the model, including auxiliary. I am thinking that this way it would be easier for users to create and implement their own parameterizations. Including using any model in general that could come in a form of a function. For instance, a ML model could be simply used as a turbulence closure. Again, thanks for all attention you are giving to me. As a new user, it makes me learn more and more and maybe sometime I can also retribute by contributing to the model development.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066110688
Modifiability,parameteriz,parameterization,"@glwagner ; I am really impressed with your effort to explain to me all details of the implementation. Thanks you!; In the past few days I am learning a lot reading the code/documentation and examples of Oceananigans. When I started this issue, I wasn't really expecting to have Pacanowski-Philander parameterization implemented in a few hours. Kudos to you!!; I know this parameterization is very simple, but implementing it on a FORTRAN-based GCM from scratch would take waaaay more time, at least for me. Can you help me to see if I understood everything correctly? Please, sorry if I am asking too-trivial questions. Why you need to define `f²`, wouldn't work simply using `∂zᶠᶜᶠ` and squaring the operation?. I understand that you create a fake model and don't run it, simply use it to update the auxiliary field. I don't understand why you could not do the same for the main model. For instance, you could first create the model, define Ri and closure and then `set!` the model with this new closure and auxiliary field. Does that makes sense? I understand the in the background this might not work the way it is now. Something like this:. ```; model = HydrostaticFreeSurfaceModel(; grid, tracers=:b, buoyancy=BuoyancyTracer()). Ri = Field(KernelFunctionOperation{Center, Center, Center}(Riᶜᶜᶜ, grid, computed_dependencies=(model.velocities, model.tracers.b))). ν = ν₀ + ν₁ / (1 + c * Ri^n); κᵇ = κ₀ + κ₁ / (1 + c * Ri^(n+1)). closure = ScalarDiffusivity(VerticallyImplicitTimeDiscretization(); ν, κ=(; b=κᵇ)). set!(model, closure = closure, auxiliary_fields = (; Ri)); ```. Thinking on a more general way, it would be awesome to give a general function that could depend on any field in the model, including auxiliary. I am thinking that this way it would be easier for users to create and implement their own parameterizations. Including using any model in general that could come in a form of a function. For instance, a ML model could be simply used as a turbulence closure. Again, thanks fo",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066110688
Usability,learn,learning,"@glwagner ; I am really impressed with your effort to explain to me all details of the implementation. Thanks you!; In the past few days I am learning a lot reading the code/documentation and examples of Oceananigans. When I started this issue, I wasn't really expecting to have Pacanowski-Philander parameterization implemented in a few hours. Kudos to you!!; I know this parameterization is very simple, but implementing it on a FORTRAN-based GCM from scratch would take waaaay more time, at least for me. Can you help me to see if I understood everything correctly? Please, sorry if I am asking too-trivial questions. Why you need to define `f²`, wouldn't work simply using `∂zᶠᶜᶠ` and squaring the operation?. I understand that you create a fake model and don't run it, simply use it to update the auxiliary field. I don't understand why you could not do the same for the main model. For instance, you could first create the model, define Ri and closure and then `set!` the model with this new closure and auxiliary field. Does that makes sense? I understand the in the background this might not work the way it is now. Something like this:. ```; model = HydrostaticFreeSurfaceModel(; grid, tracers=:b, buoyancy=BuoyancyTracer()). Ri = Field(KernelFunctionOperation{Center, Center, Center}(Riᶜᶜᶜ, grid, computed_dependencies=(model.velocities, model.tracers.b))). ν = ν₀ + ν₁ / (1 + c * Ri^n); κᵇ = κ₀ + κ₁ / (1 + c * Ri^(n+1)). closure = ScalarDiffusivity(VerticallyImplicitTimeDiscretization(); ν, κ=(; b=κᵇ)). set!(model, closure = closure, auxiliary_fields = (; Ri)); ```. Thinking on a more general way, it would be awesome to give a general function that could depend on any field in the model, including auxiliary. I am thinking that this way it would be easier for users to create and implement their own parameterizations. Including using any model in general that could come in a form of a function. For instance, a ML model could be simply used as a turbulence closure. Again, thanks fo",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066110688
Energy Efficiency,reduce,reduces," using `ℑxzᶜᵃᶜ`. Note that Oceananigans operators (derivatives, interpolation, differences) are _composable_. The function `f²` is used in this composition --- it squares a _function_, rather than a _field_. So `ℑxzᶜᵃᶜ(i, j, k, grid, f², ∂zᶠᶜᶠ, U.u)` represents a stencil that interpolates `∂zᶠᶜᶠ(i, j, k, grid, u)^2` from `Face` to `Center` in both x and z. > For instance, you could first create the model, define Ri and closure and then set! the model with this new closure and auxiliary field. Yes, your question makes a lot of sense! The reason we can't do that is because _type_ of any of the properties of `model` cannot change. This means we need to know the type of `model.closure` _before_ we build it. Another way to say this is that `HydrostaticFreeSurfaceModel` is _concretely typed_, which means that functions of `model` can be optimized based on the types of _every_ property of `HydrostaticFreeSurfaceModel`. This gives us performance advantages / reduces overhead, but also creates some limitations like: we have to define a `closure` before building model. Here's a simple example:. ```julia; julia> mutable struct Test{T}; a :: T; end. julia> t = Test(1.0); Test{Float64}(1.0). julia> t.a = 2.0; 2.0. julia> t.a = ""hi""; ERROR: MethodError: Cannot `convert` an object of type String to an object of type Float64; Closest candidates are:; convert(::Type{T}, ::T) where T<:Number at number.jl:6; convert(::Type{T}, ::Number) where T<:Number at number.jl:7; convert(::Type{T}, ::Base.TwicePrecision) where T<:Number at twiceprecision.jl:250; ...; Stacktrace:; [1] setproperty!(x::Test{Float64}, f::Symbol, v::String); @ Base ./Base.jl:34; [2] top-level scope; @ REPL[6]:1; ```. Here, `t` is `Test{Float64}`. We can change `a` as long as the new value can be converted to `Float64` via `convert(Float64, new_value)`. Otherwise we can't and we just have to write `s = Test(""hi"")` instead. Another possible solution is to build a ""dummy"" closure with the correct type, and then replace i",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066113513
Integrability,depend,depend,"this is that `HydrostaticFreeSurfaceModel` is _concretely typed_, which means that functions of `model` can be optimized based on the types of _every_ property of `HydrostaticFreeSurfaceModel`. This gives us performance advantages / reduces overhead, but also creates some limitations like: we have to define a `closure` before building model. Here's a simple example:. ```julia; julia> mutable struct Test{T}; a :: T; end. julia> t = Test(1.0); Test{Float64}(1.0). julia> t.a = 2.0; 2.0. julia> t.a = ""hi""; ERROR: MethodError: Cannot `convert` an object of type String to an object of type Float64; Closest candidates are:; convert(::Type{T}, ::T) where T<:Number at number.jl:6; convert(::Type{T}, ::Number) where T<:Number at number.jl:7; convert(::Type{T}, ::Base.TwicePrecision) where T<:Number at twiceprecision.jl:250; ...; Stacktrace:; [1] setproperty!(x::Test{Float64}, f::Symbol, v::String); @ Base ./Base.jl:34; [2] top-level scope; @ REPL[6]:1; ```. Here, `t` is `Test{Float64}`. We can change `a` as long as the new value can be converted to `Float64` via `convert(Float64, new_value)`. Otherwise we can't and we just have to write `s = Test(""hi"")` instead. Another possible solution is to build a ""dummy"" closure with the correct type, and then replace it with the ""real"" closure after constructing model by writing `model.closure = real_closure`. It could be fun to try that and see if the code is simpler. I suspect it might not be but it's worth a shot (you might learn something). . > Thinking on a more general way, it would be awesome to give a general function that could depend on any field in the model, including auxiliary. I am thinking that this way it would be easier for users to create and implement their own parameterizations. I guess that's sort of what we're doing here. The main issue is reducing boilerplate / making this as easy as possible. It'd be nice to write parameterizations with more abstract syntax rather than having to write a low-level kernel function.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066113513
Modifiability,parameteriz,parameterization,"> When I started this issue, I wasn't really expecting to have Pacanowski-Philander parameterization implemented in a few hours. Kudos to you!!. Thanks for asking the question! Also is it ok if I convert to discussion? If it remains an issue we might lose track of it when the issue is closed. But this might be useful to people if its more visible. > Why you need to define f², wouldn't work simply using ∂zᶠᶜᶠ and squaring the operation?. Because we need to interpolate `∂zᶠᶜᶠ` using `ℑxzᶜᵃᶜ`. Note that Oceananigans operators (derivatives, interpolation, differences) are _composable_. The function `f²` is used in this composition --- it squares a _function_, rather than a _field_. So `ℑxzᶜᵃᶜ(i, j, k, grid, f², ∂zᶠᶜᶠ, U.u)` represents a stencil that interpolates `∂zᶠᶜᶠ(i, j, k, grid, u)^2` from `Face` to `Center` in both x and z. > For instance, you could first create the model, define Ri and closure and then set! the model with this new closure and auxiliary field. Yes, your question makes a lot of sense! The reason we can't do that is because _type_ of any of the properties of `model` cannot change. This means we need to know the type of `model.closure` _before_ we build it. Another way to say this is that `HydrostaticFreeSurfaceModel` is _concretely typed_, which means that functions of `model` can be optimized based on the types of _every_ property of `HydrostaticFreeSurfaceModel`. This gives us performance advantages / reduces overhead, but also creates some limitations like: we have to define a `closure` before building model. Here's a simple example:. ```julia; julia> mutable struct Test{T}; a :: T; end. julia> t = Test(1.0); Test{Float64}(1.0). julia> t.a = 2.0; 2.0. julia> t.a = ""hi""; ERROR: MethodError: Cannot `convert` an object of type String to an object of type Float64; Closest candidates are:; convert(::Type{T}, ::T) where T<:Number at number.jl:6; convert(::Type{T}, ::Number) where T<:Number at number.jl:7; convert(::Type{T}, ::Base.TwicePrecision) where ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066113513
Performance,optimiz,optimized," this might be useful to people if its more visible. > Why you need to define f², wouldn't work simply using ∂zᶠᶜᶠ and squaring the operation?. Because we need to interpolate `∂zᶠᶜᶠ` using `ℑxzᶜᵃᶜ`. Note that Oceananigans operators (derivatives, interpolation, differences) are _composable_. The function `f²` is used in this composition --- it squares a _function_, rather than a _field_. So `ℑxzᶜᵃᶜ(i, j, k, grid, f², ∂zᶠᶜᶠ, U.u)` represents a stencil that interpolates `∂zᶠᶜᶠ(i, j, k, grid, u)^2` from `Face` to `Center` in both x and z. > For instance, you could first create the model, define Ri and closure and then set! the model with this new closure and auxiliary field. Yes, your question makes a lot of sense! The reason we can't do that is because _type_ of any of the properties of `model` cannot change. This means we need to know the type of `model.closure` _before_ we build it. Another way to say this is that `HydrostaticFreeSurfaceModel` is _concretely typed_, which means that functions of `model` can be optimized based on the types of _every_ property of `HydrostaticFreeSurfaceModel`. This gives us performance advantages / reduces overhead, but also creates some limitations like: we have to define a `closure` before building model. Here's a simple example:. ```julia; julia> mutable struct Test{T}; a :: T; end. julia> t = Test(1.0); Test{Float64}(1.0). julia> t.a = 2.0; 2.0. julia> t.a = ""hi""; ERROR: MethodError: Cannot `convert` an object of type String to an object of type Float64; Closest candidates are:; convert(::Type{T}, ::T) where T<:Number at number.jl:6; convert(::Type{T}, ::Number) where T<:Number at number.jl:7; convert(::Type{T}, ::Base.TwicePrecision) where T<:Number at twiceprecision.jl:250; ...; Stacktrace:; [1] setproperty!(x::Test{Float64}, f::Symbol, v::String); @ Base ./Base.jl:34; [2] top-level scope; @ REPL[6]:1; ```. Here, `t` is `Test{Float64}`. We can change `a` as long as the new value can be converted to `Float64` via `convert(Float64, ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066113513
Usability,simpl,simply,"> When I started this issue, I wasn't really expecting to have Pacanowski-Philander parameterization implemented in a few hours. Kudos to you!!. Thanks for asking the question! Also is it ok if I convert to discussion? If it remains an issue we might lose track of it when the issue is closed. But this might be useful to people if its more visible. > Why you need to define f², wouldn't work simply using ∂zᶠᶜᶠ and squaring the operation?. Because we need to interpolate `∂zᶠᶜᶠ` using `ℑxzᶜᵃᶜ`. Note that Oceananigans operators (derivatives, interpolation, differences) are _composable_. The function `f²` is used in this composition --- it squares a _function_, rather than a _field_. So `ℑxzᶜᵃᶜ(i, j, k, grid, f², ∂zᶠᶜᶠ, U.u)` represents a stencil that interpolates `∂zᶠᶜᶠ(i, j, k, grid, u)^2` from `Face` to `Center` in both x and z. > For instance, you could first create the model, define Ri and closure and then set! the model with this new closure and auxiliary field. Yes, your question makes a lot of sense! The reason we can't do that is because _type_ of any of the properties of `model` cannot change. This means we need to know the type of `model.closure` _before_ we build it. Another way to say this is that `HydrostaticFreeSurfaceModel` is _concretely typed_, which means that functions of `model` can be optimized based on the types of _every_ property of `HydrostaticFreeSurfaceModel`. This gives us performance advantages / reduces overhead, but also creates some limitations like: we have to define a `closure` before building model. Here's a simple example:. ```julia; julia> mutable struct Test{T}; a :: T; end. julia> t = Test(1.0); Test{Float64}(1.0). julia> t.a = 2.0; 2.0. julia> t.a = ""hi""; ERROR: MethodError: Cannot `convert` an object of type String to an object of type Float64; Closest candidates are:; convert(::Type{T}, ::T) where T<:Number at number.jl:6; convert(::Type{T}, ::Number) where T<:Number at number.jl:7; convert(::Type{T}, ::Base.TwicePrecision) where ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066113513
Deployability,update,updated,"After adding `MPI.Init()` back to `distributed_nonhydrostatic_model_mpi.jl`, the script seems to run (it's still running...). Here's a few idle thoughts (independent of this PR, just leaving here for future reference):. * The ""Benchmarks"" module in `/benchmarks/src` causes a few issues like:; ```julia; ┌ Warning: Package Benchmarks does not have Oceananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for Benchmarks are suppressed.; ```; It'd be nice to fix that eventually. * The output is kind of annoying:. ```julia; [2022/03/13 13:17:49.875] INFO Benchmarking weak scaling nonhydrostatic model with Slab decomposition [N=(128, 128, 32), ranks=(1, 2, 1)]...; Invalid MIT-MAGIC-COOKIE-1 keyInvalid MIT-MAGIC-COOKIE-1 keyNo protocol specified; [ Info: Oceananigans will use 24 threads; [ Info: Oceananigans will use 24 threads; ┌ Warning: Package Benchmarks does not have Oceananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for Benchmarks are suppressed.; ┌ Warning: Package Benchmarks does not have Oceananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2338#issuecomment-1066145590
Integrability,depend,dependencies,"After adding `MPI.Init()` back to `distributed_nonhydrostatic_model_mpi.jl`, the script seems to run (it's still running...). Here's a few idle thoughts (independent of this PR, just leaving here for future reference):. * The ""Benchmarks"" module in `/benchmarks/src` causes a few issues like:; ```julia; ┌ Warning: Package Benchmarks does not have Oceananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for Benchmarks are suppressed.; ```; It'd be nice to fix that eventually. * The output is kind of annoying:. ```julia; [2022/03/13 13:17:49.875] INFO Benchmarking weak scaling nonhydrostatic model with Slab decomposition [N=(128, 128, 32), ranks=(1, 2, 1)]...; Invalid MIT-MAGIC-COOKIE-1 keyInvalid MIT-MAGIC-COOKIE-1 keyNo protocol specified; [ Info: Oceananigans will use 24 threads; [ Info: Oceananigans will use 24 threads; ┌ Warning: Package Benchmarks does not have Oceananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for Benchmarks are suppressed.; ┌ Warning: Package Benchmarks does not have Oceananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2338#issuecomment-1066145590
Testability,benchmark,benchmarks,"After adding `MPI.Init()` back to `distributed_nonhydrostatic_model_mpi.jl`, the script seems to run (it's still running...). Here's a few idle thoughts (independent of this PR, just leaving here for future reference):. * The ""Benchmarks"" module in `/benchmarks/src` causes a few issues like:; ```julia; ┌ Warning: Package Benchmarks does not have Oceananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for Benchmarks are suppressed.; ```; It'd be nice to fix that eventually. * The output is kind of annoying:. ```julia; [2022/03/13 13:17:49.875] INFO Benchmarking weak scaling nonhydrostatic model with Slab decomposition [N=(128, 128, 32), ranks=(1, 2, 1)]...; Invalid MIT-MAGIC-COOKIE-1 keyInvalid MIT-MAGIC-COOKIE-1 keyNo protocol specified; [ Info: Oceananigans will use 24 threads; [ Info: Oceananigans will use 24 threads; ┌ Warning: Package Benchmarks does not have Oceananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for Benchmarks are suppressed.; ┌ Warning: Package Benchmarks does not have Oceananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2338#issuecomment-1066145590
Usability,clear,clearer,"eananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for Benchmarks are suppressed.; ```; It'd be nice to fix that eventually. * The output is kind of annoying:. ```julia; [2022/03/13 13:17:49.875] INFO Benchmarking weak scaling nonhydrostatic model with Slab decomposition [N=(128, 128, 32), ranks=(1, 2, 1)]...; Invalid MIT-MAGIC-COOKIE-1 keyInvalid MIT-MAGIC-COOKIE-1 keyNo protocol specified; [ Info: Oceananigans will use 24 threads; [ Info: Oceananigans will use 24 threads; ┌ Warning: Package Benchmarks does not have Oceananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for Benchmarks are suppressed.; ┌ Warning: Package Benchmarks does not have Oceananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for Benchmarks are suppressed.; [ Info: Oceananigans will use 24 threads; [ Info: Oceananigans will use 24 threads; ```; We don't need to be told `N` times how many threads Oceananigans is using. * I think the `README.md` could be clearer and the scripts could have better names (eg which script runs the benchmark versus which script sets up the model)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2338#issuecomment-1066145590
Usability,clear,clearer,"Kinda. The current behavior is this https://github.com/CliMA/Oceananigans.jl/blob/470fd110a99b1967510979fbc313093dac060636/src/OutputWriters/netcdf_output_writer.jl#L302-L308. So the default is similar to what it was when this issue was posted, although I think it's formulated a little clearer now. I'm okay with this and also okay with closing this issue, but I'm not sure everyone else feels this way. You mentioned at some point that we could move this part to after `run!()` is called and I don't think we discussed that.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2339#issuecomment-1100262668
Integrability,depend,dependencies,"> most of the time we are just using ordinary numbers, fields, etc as ""computed dependencies"" and in that case it's silly to call them ""computed dependencies"". My impression is that that's why the `parameters` argument existed (but please correct me if I'm wrong). In the current way `computed_dependencies` and `parameters` clearly indicate what's what (and what happens behind the scenes). So on that note, personally, I like that `computed_dependencies` keeps things explicit. Also, I can't say for other people, but I frequently pass fields that require computation to `KFO`. (Usually passing `u-U` to calculate fluctuations, etc.)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2340#issuecomment-1066240786
Usability,clear,clearly,"> most of the time we are just using ordinary numbers, fields, etc as ""computed dependencies"" and in that case it's silly to call them ""computed dependencies"". My impression is that that's why the `parameters` argument existed (but please correct me if I'm wrong). In the current way `computed_dependencies` and `parameters` clearly indicate what's what (and what happens behind the scenes). So on that note, personally, I like that `computed_dependencies` keeps things explicit. Also, I can't say for other people, but I frequently pass fields that require computation to `KFO`. (Usually passing `u-U` to calculate fluctuations, etc.)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2340#issuecomment-1066240786
Usability,clear,clear,"If it's the same, then I'm okay calling compute on everything and don't separate between `parameters` and `computed_dependencies` anymore. I think we gotta make that clear on the docstring though!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2340#issuecomment-1069134148
Availability,ping,ping,"Hi, PencilArrays / PencilFFTs author here. I'd be happy to help solving this issue, and I'd also welcome any ideas that would help improve the PencilArrays interface and docs. I am not familiar with how you define your domain partition. However, from the point of view of PencilFFTs, there is one restriction, which is that the first dimension (`x`) must *not* be decomposed in physical space. This is because FFTs are first performed along this dimension (along which data is contiguous, as usual for Julia arrays). Also, to avoid potential issues, your eigenvalues should be `PencilArray` wrappers. For now, PencilArrays allows broadcasting together `PencilArray`s and regular `Array`s, but I'm thinking this is not a good idea since the behaviour is non-intuitive and can lead to precisely this kind of issue. So I'm thinking about changing the current behaviour in the future -- and improving documentation on this. Finally, when you write:. ```julia; xc = b = solver.storage[2]; ```. you probably mean `xc = solver.storage[3]` (or, equivalently, `last(solver.storage)`, as in [this example](https://jipolanco.github.io/PencilFFTs.jl/dev/generated/in-place/#Applying-plans)). `storage[2]` holds an intermediate state that has no ""physical"" meaning, since it has been overwritten by the end of a transform. I should clarify all this in the in-place transforms example... Feel free to ping me if things are unclear in the docs or if I can provide any other information.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2347#issuecomment-1102319088
Integrability,interface,interface,"Hi, PencilArrays / PencilFFTs author here. I'd be happy to help solving this issue, and I'd also welcome any ideas that would help improve the PencilArrays interface and docs. I am not familiar with how you define your domain partition. However, from the point of view of PencilFFTs, there is one restriction, which is that the first dimension (`x`) must *not* be decomposed in physical space. This is because FFTs are first performed along this dimension (along which data is contiguous, as usual for Julia arrays). Also, to avoid potential issues, your eigenvalues should be `PencilArray` wrappers. For now, PencilArrays allows broadcasting together `PencilArray`s and regular `Array`s, but I'm thinking this is not a good idea since the behaviour is non-intuitive and can lead to precisely this kind of issue. So I'm thinking about changing the current behaviour in the future -- and improving documentation on this. Finally, when you write:. ```julia; xc = b = solver.storage[2]; ```. you probably mean `xc = solver.storage[3]` (or, equivalently, `last(solver.storage)`, as in [this example](https://jipolanco.github.io/PencilFFTs.jl/dev/generated/in-place/#Applying-plans)). `storage[2]` holds an intermediate state that has no ""physical"" meaning, since it has been overwritten by the end of a transform. I should clarify all this in the in-place transforms example... Feel free to ping me if things are unclear in the docs or if I can provide any other information.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2347#issuecomment-1102319088
Performance,perform,performed,"Hi, PencilArrays / PencilFFTs author here. I'd be happy to help solving this issue, and I'd also welcome any ideas that would help improve the PencilArrays interface and docs. I am not familiar with how you define your domain partition. However, from the point of view of PencilFFTs, there is one restriction, which is that the first dimension (`x`) must *not* be decomposed in physical space. This is because FFTs are first performed along this dimension (along which data is contiguous, as usual for Julia arrays). Also, to avoid potential issues, your eigenvalues should be `PencilArray` wrappers. For now, PencilArrays allows broadcasting together `PencilArray`s and regular `Array`s, but I'm thinking this is not a good idea since the behaviour is non-intuitive and can lead to precisely this kind of issue. So I'm thinking about changing the current behaviour in the future -- and improving documentation on this. Finally, when you write:. ```julia; xc = b = solver.storage[2]; ```. you probably mean `xc = solver.storage[3]` (or, equivalently, `last(solver.storage)`, as in [this example](https://jipolanco.github.io/PencilFFTs.jl/dev/generated/in-place/#Applying-plans)). `storage[2]` holds an intermediate state that has no ""physical"" meaning, since it has been overwritten by the end of a transform. I should clarify all this in the in-place transforms example... Feel free to ping me if things are unclear in the docs or if I can provide any other information.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2347#issuecomment-1102319088
Safety,avoid,avoid,"Hi, PencilArrays / PencilFFTs author here. I'd be happy to help solving this issue, and I'd also welcome any ideas that would help improve the PencilArrays interface and docs. I am not familiar with how you define your domain partition. However, from the point of view of PencilFFTs, there is one restriction, which is that the first dimension (`x`) must *not* be decomposed in physical space. This is because FFTs are first performed along this dimension (along which data is contiguous, as usual for Julia arrays). Also, to avoid potential issues, your eigenvalues should be `PencilArray` wrappers. For now, PencilArrays allows broadcasting together `PencilArray`s and regular `Array`s, but I'm thinking this is not a good idea since the behaviour is non-intuitive and can lead to precisely this kind of issue. So I'm thinking about changing the current behaviour in the future -- and improving documentation on this. Finally, when you write:. ```julia; xc = b = solver.storage[2]; ```. you probably mean `xc = solver.storage[3]` (or, equivalently, `last(solver.storage)`, as in [this example](https://jipolanco.github.io/PencilFFTs.jl/dev/generated/in-place/#Applying-plans)). `storage[2]` holds an intermediate state that has no ""physical"" meaning, since it has been overwritten by the end of a transform. I should clarify all this in the in-place transforms example... Feel free to ping me if things are unclear in the docs or if I can provide any other information.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2347#issuecomment-1102319088
Usability,intuit,intuitive,"Hi, PencilArrays / PencilFFTs author here. I'd be happy to help solving this issue, and I'd also welcome any ideas that would help improve the PencilArrays interface and docs. I am not familiar with how you define your domain partition. However, from the point of view of PencilFFTs, there is one restriction, which is that the first dimension (`x`) must *not* be decomposed in physical space. This is because FFTs are first performed along this dimension (along which data is contiguous, as usual for Julia arrays). Also, to avoid potential issues, your eigenvalues should be `PencilArray` wrappers. For now, PencilArrays allows broadcasting together `PencilArray`s and regular `Array`s, but I'm thinking this is not a good idea since the behaviour is non-intuitive and can lead to precisely this kind of issue. So I'm thinking about changing the current behaviour in the future -- and improving documentation on this. Finally, when you write:. ```julia; xc = b = solver.storage[2]; ```. you probably mean `xc = solver.storage[3]` (or, equivalently, `last(solver.storage)`, as in [this example](https://jipolanco.github.io/PencilFFTs.jl/dev/generated/in-place/#Applying-plans)). `storage[2]` holds an intermediate state that has no ""physical"" meaning, since it has been overwritten by the end of a transform. I should clarify all this in the in-place transforms example... Feel free to ping me if things are unclear in the docs or if I can provide any other information.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2347#issuecomment-1102319088
Deployability,integrat,integration,"Thanks so much @jipolanco ! And thanks for the beautiful package. > For now, PencilArrays allows broadcasting together PencilArrays and regular Arrays, but I'm thinking this is not a good idea since the behaviour is non-intuitive and can lead to precisely this kind of issue. Right! I think that's a conservative design choice and well-justified if there aren't important use cases for PencilArrays / Arrays broadcasting... It looks like the relevant docs are https://jipolanco.github.io/PencilArrays.jl/stable/Pencils/#Dimension-permutations. and based on. https://github.com/CliMA/Oceananigans.jl/blob/6ceeb012f1432bf936edd977fa1390dc694a0adc/src/Distributed/distributed_fft_based_poisson_solver.jl#L33-L44. we want something like. ```julia; transform_space_permutation = Permutation(2, 1, 3); λx_pencil = Pencil(size(global_grid), comm; permute = transform_space_permutation); # somehow set λx_pencil data to λx; ```. Reading through the docs also suggests to me that we need tighter integration with PencilArrays overall (eg we have our own notion of grids, so we may want to make these compatible with PencilArray's grids).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2347#issuecomment-1102789255
Integrability,integrat,integration,"Thanks so much @jipolanco ! And thanks for the beautiful package. > For now, PencilArrays allows broadcasting together PencilArrays and regular Arrays, but I'm thinking this is not a good idea since the behaviour is non-intuitive and can lead to precisely this kind of issue. Right! I think that's a conservative design choice and well-justified if there aren't important use cases for PencilArrays / Arrays broadcasting... It looks like the relevant docs are https://jipolanco.github.io/PencilArrays.jl/stable/Pencils/#Dimension-permutations. and based on. https://github.com/CliMA/Oceananigans.jl/blob/6ceeb012f1432bf936edd977fa1390dc694a0adc/src/Distributed/distributed_fft_based_poisson_solver.jl#L33-L44. we want something like. ```julia; transform_space_permutation = Permutation(2, 1, 3); λx_pencil = Pencil(size(global_grid), comm; permute = transform_space_permutation); # somehow set λx_pencil data to λx; ```. Reading through the docs also suggests to me that we need tighter integration with PencilArrays overall (eg we have our own notion of grids, so we may want to make these compatible with PencilArray's grids).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2347#issuecomment-1102789255
Usability,intuit,intuitive,"Thanks so much @jipolanco ! And thanks for the beautiful package. > For now, PencilArrays allows broadcasting together PencilArrays and regular Arrays, but I'm thinking this is not a good idea since the behaviour is non-intuitive and can lead to precisely this kind of issue. Right! I think that's a conservative design choice and well-justified if there aren't important use cases for PencilArrays / Arrays broadcasting... It looks like the relevant docs are https://jipolanco.github.io/PencilArrays.jl/stable/Pencils/#Dimension-permutations. and based on. https://github.com/CliMA/Oceananigans.jl/blob/6ceeb012f1432bf936edd977fa1390dc694a0adc/src/Distributed/distributed_fft_based_poisson_solver.jl#L33-L44. we want something like. ```julia; transform_space_permutation = Permutation(2, 1, 3); λx_pencil = Pencil(size(global_grid), comm; permute = transform_space_permutation); # somehow set λx_pencil data to λx; ```. Reading through the docs also suggests to me that we need tighter integration with PencilArrays overall (eg we have our own notion of grids, so we may want to make these compatible with PencilArray's grids).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2347#issuecomment-1102789255
Testability,test,tests,"> With this change the whole pressure field is found through the nonhydrostatic solve. This seems like a very minor change to the temporal discretization, but it does cause the regression tests to fail (and I think @tomchor noticed some differences in the solution for ocean problems --- maybe there was a bit more noise?). The video here: https://clima.github.io/OceananigansDocumentation/previews/PR1910/generated/internal_wave/; (using the preview from https://github.com/CliMA/Oceananigans.jl/pull/1910) is what more clearly illustrates the differences. The difference is more subtle in the other examples",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2347#issuecomment-1107074113
Usability,clear,clearly,"> With this change the whole pressure field is found through the nonhydrostatic solve. This seems like a very minor change to the temporal discretization, but it does cause the regression tests to fail (and I think @tomchor noticed some differences in the solution for ocean problems --- maybe there was a bit more noise?). The video here: https://clima.github.io/OceananigansDocumentation/previews/PR1910/generated/internal_wave/; (using the preview from https://github.com/CliMA/Oceananigans.jl/pull/1910) is what more clearly illustrates the differences. The difference is more subtle in the other examples",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2347#issuecomment-1107074113
Usability,clear,clear,"Just to be clear, I'm not suggesting that we document experimental features to the level that we document mature ones. That'd be impossibly hard to maintain. But maybe a page somewhere with a list of experimental features (all I know about are immersed boundaries and parallelism, although I'm sure there are more that I'm not aware) that links to the relevant issues/PRs/discussions and maybe to relevant files in `src`? Otherwise I think it's hard for users to know what experimental features there are since they have to browse issues/PRs/discussions looking for stuff in the titles.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2355#issuecomment-1068043951
Integrability,interface,interface,"My issue with changing the code (if I understand what you guys are proposing) is that it negatively impacts other aspects of the code. For example, right now this plays nice with the Coriolis parameter definition on a tilted/rotated domain. Currently we can model a domain tilt with. ```julia; buoyancy = Buoyancy(model=BuoyancyTracer(), gravity_unit_vector=ĝ); coriolis = ConstantCartesianCoriolis(f=params.f₀, rotation_axis=ĝ); ```; which makes for a really seamless and simple user interface. It wouldn't be as nice if we flipped the unit vector for buoyancy in the code. Also we'd need to define another direction in addition to `ZDirection()` that would replace it as the default for the unit vector. It'd probably be something more verbose like `NegativeZDirection()` or `AntiparallelZDirection()`. (The default for `ConstantCartesianCoriolis` would still be `ZDirection()` though.). By changing `gravity_unit_vector` to `buoyancy_unit_vector` (or whatever other word we decide) we only need to change one thing and it doesn't add any verbosity to the code/interface.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2356#issuecomment-1069316028
Usability,simpl,simple,"My issue with changing the code (if I understand what you guys are proposing) is that it negatively impacts other aspects of the code. For example, right now this plays nice with the Coriolis parameter definition on a tilted/rotated domain. Currently we can model a domain tilt with. ```julia; buoyancy = Buoyancy(model=BuoyancyTracer(), gravity_unit_vector=ĝ); coriolis = ConstantCartesianCoriolis(f=params.f₀, rotation_axis=ĝ); ```; which makes for a really seamless and simple user interface. It wouldn't be as nice if we flipped the unit vector for buoyancy in the code. Also we'd need to define another direction in addition to `ZDirection()` that would replace it as the default for the unit vector. It'd probably be something more verbose like `NegativeZDirection()` or `AntiparallelZDirection()`. (The default for `ConstantCartesianCoriolis` would still be `ZDirection()` though.). By changing `gravity_unit_vector` to `buoyancy_unit_vector` (or whatever other word we decide) we only need to change one thing and it doesn't add any verbosity to the code/interface.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2356#issuecomment-1069316028
Usability,clear,clearer,I am okay with a change of names. If the new name is clearer then probably better to change it sooner than later.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2356#issuecomment-1457014531
Usability,clear,clears,"Indeed, it seems like . ```; @inline tank(x, y) = ifelse(radius(x, y) < L, -H, Float64(0.0)); ```; clears the problem. Interesting... ; Do you guys have any idea why that could influence the `fill_halo_bottom`?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2367#issuecomment-1083925352
Availability,down,downstream,"> Indeed, it seems like; > ; > ```; > @inline tank(x, y) = ifelse(radius(x, y) < L, -H, Float64(0.0)); > ```; > ; > clears the problem. Interesting... Do you guys have any idea why that could influence the `fill_halo_bottom`?. If there's a function that can return two possible types (which is inferred to a type `Union` I think) then this might propagate downstream in the compiled code (ie two possible scenarios must be maintained; one when the returned value is `Float64`, and another with different intrinsics for when the returned value is `Int`). I think in principle this can greatly complicate the kernel function for filling the boundary condition. Broadly speaking, for functions that must be inlined into complicated kernels, it's safest to use functions that can only return one type. But I don't have a good answer for why we get the specific error `an illegal memory access was encountered`. This could be a bug in `CUDA.jl`. However, we are using an old version of `CUDA.jl` so there's not much point in raising an issue. The behavior very well may be different in the latest version... Someone with deeper knowledge of the Julia compiler / compilation system might have a better answer too...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2367#issuecomment-1084049440
Safety,safe,safest,"> Indeed, it seems like; > ; > ```; > @inline tank(x, y) = ifelse(radius(x, y) < L, -H, Float64(0.0)); > ```; > ; > clears the problem. Interesting... Do you guys have any idea why that could influence the `fill_halo_bottom`?. If there's a function that can return two possible types (which is inferred to a type `Union` I think) then this might propagate downstream in the compiled code (ie two possible scenarios must be maintained; one when the returned value is `Float64`, and another with different intrinsics for when the returned value is `Int`). I think in principle this can greatly complicate the kernel function for filling the boundary condition. Broadly speaking, for functions that must be inlined into complicated kernels, it's safest to use functions that can only return one type. But I don't have a good answer for why we get the specific error `an illegal memory access was encountered`. This could be a bug in `CUDA.jl`. However, we are using an old version of `CUDA.jl` so there's not much point in raising an issue. The behavior very well may be different in the latest version... Someone with deeper knowledge of the Julia compiler / compilation system might have a better answer too...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2367#issuecomment-1084049440
Security,access,access,"> Indeed, it seems like; > ; > ```; > @inline tank(x, y) = ifelse(radius(x, y) < L, -H, Float64(0.0)); > ```; > ; > clears the problem. Interesting... Do you guys have any idea why that could influence the `fill_halo_bottom`?. If there's a function that can return two possible types (which is inferred to a type `Union` I think) then this might propagate downstream in the compiled code (ie two possible scenarios must be maintained; one when the returned value is `Float64`, and another with different intrinsics for when the returned value is `Int`). I think in principle this can greatly complicate the kernel function for filling the boundary condition. Broadly speaking, for functions that must be inlined into complicated kernels, it's safest to use functions that can only return one type. But I don't have a good answer for why we get the specific error `an illegal memory access was encountered`. This could be a bug in `CUDA.jl`. However, we are using an old version of `CUDA.jl` so there's not much point in raising an issue. The behavior very well may be different in the latest version... Someone with deeper knowledge of the Julia compiler / compilation system might have a better answer too...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2367#issuecomment-1084049440
Usability,clear,clears,"> Indeed, it seems like; > ; > ```; > @inline tank(x, y) = ifelse(radius(x, y) < L, -H, Float64(0.0)); > ```; > ; > clears the problem. Interesting... Do you guys have any idea why that could influence the `fill_halo_bottom`?. If there's a function that can return two possible types (which is inferred to a type `Union` I think) then this might propagate downstream in the compiled code (ie two possible scenarios must be maintained; one when the returned value is `Float64`, and another with different intrinsics for when the returned value is `Int`). I think in principle this can greatly complicate the kernel function for filling the boundary condition. Broadly speaking, for functions that must be inlined into complicated kernels, it's safest to use functions that can only return one type. But I don't have a good answer for why we get the specific error `an illegal memory access was encountered`. This could be a bug in `CUDA.jl`. However, we are using an old version of `CUDA.jl` so there's not much point in raising an issue. The behavior very well may be different in the latest version... Someone with deeper knowledge of the Julia compiler / compilation system might have a better answer too...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2367#issuecomment-1084049440
Availability,error,error,"> I suggest that the grid constructor does not restrict the `z` topology then but instead the `HydrostaticFreeSurface` does so. Right?. That's fine with me, perhaps the error message will be clearer.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2372#issuecomment-1073394255
Integrability,message,message,"> I suggest that the grid constructor does not restrict the `z` topology then but instead the `HydrostaticFreeSurface` does so. Right?. That's fine with me, perhaps the error message will be clearer.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2372#issuecomment-1073394255
Usability,clear,clearer,"> I suggest that the grid constructor does not restrict the `z` topology then but instead the `HydrostaticFreeSurface` does so. Right?. That's fine with me, perhaps the error message will be clearer.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2372#issuecomment-1073394255
Energy Efficiency,energy,energy,"I propose we change the API for vector invariant with WENO interpolation to read something like. ```julia; momentum_advection = VectorInvariant(WENO5(), VelocitySmoothness()); ```. or something like that. In other words I think the nesting should be reversed: the _first_ question is whether we are using the vector invariant or flux form formulation (flux form is default right now). The _second_ question is how we interpolate vorticity. The _third_ question is the field used in the smoothness metric. I also think we should disentangle the smoothness indicators (eg velocity and vorticity) from the WENO5 struct; we can express this concept simply by re-writing the functions to accept two fields: one for reconstruction, and one for smoothness. The default uses the reconstructed field for smoothness. `VectorInvariant` will handle passing vorticity or velocity into those kernels. We'll then need. ```julia; struct VectorInvariant; vorticity_stencil # energy or enstrophy conserving; vorticity_reconstruction # any advection scheme but we focus on `WENO5` and `CenteredSecondOrder()`; smoothness_indicator # `VelocitySmoothness()` or `VorticitySmoothness()`; end; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2388#issuecomment-1081946138
Usability,simpl,simply,"I propose we change the API for vector invariant with WENO interpolation to read something like. ```julia; momentum_advection = VectorInvariant(WENO5(), VelocitySmoothness()); ```. or something like that. In other words I think the nesting should be reversed: the _first_ question is whether we are using the vector invariant or flux form formulation (flux form is default right now). The _second_ question is how we interpolate vorticity. The _third_ question is the field used in the smoothness metric. I also think we should disentangle the smoothness indicators (eg velocity and vorticity) from the WENO5 struct; we can express this concept simply by re-writing the functions to accept two fields: one for reconstruction, and one for smoothness. The default uses the reconstructed field for smoothness. `VectorInvariant` will handle passing vorticity or velocity into those kernels. We'll then need. ```julia; struct VectorInvariant; vorticity_stencil # energy or enstrophy conserving; vorticity_reconstruction # any advection scheme but we focus on `WENO5` and `CenteredSecondOrder()`; smoothness_indicator # `VelocitySmoothness()` or `VorticitySmoothness()`; end; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2388#issuecomment-1081946138
Security,validat,validation,> @iuryt do you want to help set up a validation case for this feature?. Yep. I will be working on the NP model with a P sinking velocity this week. Any idea for an experiment that changes MLD with time? ; Maybe making it 1D for simplicity? But I would like to test for 3D to make sure I am programming it correctly. Maybe buoyancy=nothing and diffuse a tanh-like temp profile? But would be better to have a shallowing mld instead.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1081795184
Testability,test,test,> @iuryt do you want to help set up a validation case for this feature?. Yep. I will be working on the NP model with a P sinking velocity this week. Any idea for an experiment that changes MLD with time? ; Maybe making it 1D for simplicity? But I would like to test for 3D to make sure I am programming it correctly. Maybe buoyancy=nothing and diffuse a tanh-like temp profile? But would be better to have a shallowing mld instead.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1081795184
Usability,simpl,simplicity,> @iuryt do you want to help set up a validation case for this feature?. Yep. I will be working on the NP model with a P sinking velocity this week. Any idea for an experiment that changes MLD with time? ; Maybe making it 1D for simplicity? But I would like to test for 3D to make sure I am programming it correctly. Maybe buoyancy=nothing and diffuse a tanh-like temp profile? But would be better to have a shallowing mld instead.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1081795184
Safety,avoid,avoid,> > @iuryt do you want to help set up a validation case for this feature?; > ; > Yep. I will be working on the NP model with a P sinking velocity this week. Any idea for an experiment that changes MLD with time? Maybe making it 1D for simplicity? But I would like to test for 3D to make sure I am programming it correctly. Maybe buoyancy=nothing and diffuse a tanh-like temp profile? But would be better to have a shallowing mld instead. I think a 2D example with turbulence + reactions + sinking would be neat. Probably best to keep it simple and avoid an MLD calculation. Now I'm thinking maybe just a sinking tracer with a source near the surface would be good.. 🤔,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1081819313
Security,validat,validation,> > @iuryt do you want to help set up a validation case for this feature?; > ; > Yep. I will be working on the NP model with a P sinking velocity this week. Any idea for an experiment that changes MLD with time? Maybe making it 1D for simplicity? But I would like to test for 3D to make sure I am programming it correctly. Maybe buoyancy=nothing and diffuse a tanh-like temp profile? But would be better to have a shallowing mld instead. I think a 2D example with turbulence + reactions + sinking would be neat. Probably best to keep it simple and avoid an MLD calculation. Now I'm thinking maybe just a sinking tracer with a source near the surface would be good.. 🤔,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1081819313
Testability,test,test,> > @iuryt do you want to help set up a validation case for this feature?; > ; > Yep. I will be working on the NP model with a P sinking velocity this week. Any idea for an experiment that changes MLD with time? Maybe making it 1D for simplicity? But I would like to test for 3D to make sure I am programming it correctly. Maybe buoyancy=nothing and diffuse a tanh-like temp profile? But would be better to have a shallowing mld instead. I think a 2D example with turbulence + reactions + sinking would be neat. Probably best to keep it simple and avoid an MLD calculation. Now I'm thinking maybe just a sinking tracer with a source near the surface would be good.. 🤔,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1081819313
Usability,simpl,simplicity,> > @iuryt do you want to help set up a validation case for this feature?; > ; > Yep. I will be working on the NP model with a P sinking velocity this week. Any idea for an experiment that changes MLD with time? Maybe making it 1D for simplicity? But I would like to test for 3D to make sure I am programming it correctly. Maybe buoyancy=nothing and diffuse a tanh-like temp profile? But would be better to have a shallowing mld instead. I think a 2D example with turbulence + reactions + sinking would be neat. Probably best to keep it simple and avoid an MLD calculation. Now I'm thinking maybe just a sinking tracer with a source near the surface would be good.. 🤔,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1081819313
Energy Efficiency,meter,meters,"> This is great, thanks @glwagner and @iuryt! Si Chen has been testing the code with a buouyant tracer added through forcing like this and he is running a comparison with Jenny Dingwall's simulations with Diablo. The extra `slip' velocity needs to vanish at the boundaries in order to conserve tracer, but then adding the advection term to the RHS forcing like @glwagner suggested seems to work and conserves tracer. We did something like this: . ```julia; lambda = 1 # decay scale for slip velocity in meters; for k=0:Nz+2; slip_vel.w[:,:,k].+=(tanh(max(-grid.zᵃᵃᶠ[k]/lambda,0))*tanh(max((grid.zᵃᵃᶠ[k]+Lz)/lambda,0))); end; ```. Makes sense!. Since there's a `dw/dz`, this means that the ""additional"" velocity field has divergence and thus tracer still not exactly conserved, right? But perhaps the divergence is small enough that it's almost conserved. Should we implement the advection differently (ie not using flux form) so that it's correct even when the velocity field is divergent? Another possibility is to have a flag, something like. ```julia; forcing = AdvectiveForcing(w=prescribed_w, flux_form=true); ```. Or, perhaps `divergent=true`, or something like that. Whatever's least surprising / intuitive...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1082403863
Testability,test,testing,"> This is great, thanks @glwagner and @iuryt! Si Chen has been testing the code with a buouyant tracer added through forcing like this and he is running a comparison with Jenny Dingwall's simulations with Diablo. The extra `slip' velocity needs to vanish at the boundaries in order to conserve tracer, but then adding the advection term to the RHS forcing like @glwagner suggested seems to work and conserves tracer. We did something like this: . ```julia; lambda = 1 # decay scale for slip velocity in meters; for k=0:Nz+2; slip_vel.w[:,:,k].+=(tanh(max(-grid.zᵃᵃᶠ[k]/lambda,0))*tanh(max((grid.zᵃᵃᶠ[k]+Lz)/lambda,0))); end; ```. Makes sense!. Since there's a `dw/dz`, this means that the ""additional"" velocity field has divergence and thus tracer still not exactly conserved, right? But perhaps the divergence is small enough that it's almost conserved. Should we implement the advection differently (ie not using flux form) so that it's correct even when the velocity field is divergent? Another possibility is to have a flag, something like. ```julia; forcing = AdvectiveForcing(w=prescribed_w, flux_form=true); ```. Or, perhaps `divergent=true`, or something like that. Whatever's least surprising / intuitive...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1082403863
Usability,intuit,intuitive,"> This is great, thanks @glwagner and @iuryt! Si Chen has been testing the code with a buouyant tracer added through forcing like this and he is running a comparison with Jenny Dingwall's simulations with Diablo. The extra `slip' velocity needs to vanish at the boundaries in order to conserve tracer, but then adding the advection term to the RHS forcing like @glwagner suggested seems to work and conserves tracer. We did something like this: . ```julia; lambda = 1 # decay scale for slip velocity in meters; for k=0:Nz+2; slip_vel.w[:,:,k].+=(tanh(max(-grid.zᵃᵃᶠ[k]/lambda,0))*tanh(max((grid.zᵃᵃᶠ[k]+Lz)/lambda,0))); end; ```. Makes sense!. Since there's a `dw/dz`, this means that the ""additional"" velocity field has divergence and thus tracer still not exactly conserved, right? But perhaps the divergence is small enough that it's almost conserved. Should we implement the advection differently (ie not using flux form) so that it's correct even when the velocity field is divergent? Another possibility is to have a flag, something like. ```julia; forcing = AdvectiveForcing(w=prescribed_w, flux_form=true); ```. Or, perhaps `divergent=true`, or something like that. Whatever's least surprising / intuitive...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1082403863
Usability,simpl,simply,"The explanations that @johnryantaylor gave are worth for a textbook. I was just about to write that we usually assume no flux at the boundaries in order to conserve the tracer, but he gave a new perspective to this. Taking an example from [PSOM](https://github.com/PSOM/V1.0/blob/master/code/NA/src/tracersource_nut.f90), they forced phytoplankton flux to zero at the boundaries, but using a first-order upwind scheme. ```fortran; flux(0)= 0.0; flux(NK)= 0.0; do k=NK-1,1,-1; ! Kz is at cell faces; dpdz= (Tr(1,i,j,k+1,0)-Tr(1,i,j,k,0))*wz(i,j,k)*DLinv; flux(k) = KzmaxTr*Kz(i,j,k)*dpdz + wsink*Tr(1,i,j,k+1,0); end do; ```. What if we leave for the users to give the velocity in which it will be advected?; Does that makes sense to simply give `w` as a function of `z` in which relax to 0 a the boundaries?; But you mentioned that Oceananigans assume non-divergent velocity field, but that's for the forcing, so it should be fine, right?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1082454081
Usability,simpl,simplicity,"Good point @iuryt. The slip velocity is proportional to the difference between the particle and fluid densities. Its common to assume that the slip velocity is constant for simplicity, but there are plenty of applications where the user might want the slip velocity to vary in space and time with the fluid density. I think that should be straightforward when adding the extra advection as a forcing term since you could make the slip velocity a function of the fluid density.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1082485930
Integrability,depend,depend,"So then should we simply use `SlipVelocity` for the sake of the generality and leave the user to define a function for that velocity that could depend on field variables.; Should we also leave for users to define the way it will diverge at the boundary?; What do you think it could be the simplest example we could use for this validation, @johnryantaylor ?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1082494830
Modifiability,variab,variables,"So then should we simply use `SlipVelocity` for the sake of the generality and leave the user to define a function for that velocity that could depend on field variables.; Should we also leave for users to define the way it will diverge at the boundary?; What do you think it could be the simplest example we could use for this validation, @johnryantaylor ?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1082494830
Security,validat,validation,"So then should we simply use `SlipVelocity` for the sake of the generality and leave the user to define a function for that velocity that could depend on field variables.; Should we also leave for users to define the way it will diverge at the boundary?; What do you think it could be the simplest example we could use for this validation, @johnryantaylor ?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1082494830
Usability,simpl,simply,"So then should we simply use `SlipVelocity` for the sake of the generality and leave the user to define a function for that velocity that could depend on field variables.; Should we also leave for users to define the way it will diverge at the boundary?; What do you think it could be the simplest example we could use for this validation, @johnryantaylor ?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1082494830
Usability,simpl,simply,"> It could also be interesting to add this slip velocity to the convecting plankton example. I am developing an NPP model to run on Oceananigans, maybe instead of giving a new example, a could simply add the other terms on the plankton example. What do you think?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1082511065
Availability,error,error,"> I'm a bit stumped. The error is; > ; > ```; > Test threw exception; > --; >   | Expression: advective_and_multiple_forcing(arch); >   | TaskFailedException; >   |  ; >   | nested task error: BoundsError; > ```; > ; > But I can't reproduce this locally.; > ; > I can fathom a `BoundsError` when we use a high-order advection scheme and our halos aren't big enough. Right now we check the ""model advection scheme"" and the grid halos to catch this issue, but we don't check the forcings. However, the test uses `halo = (3, 3, 3)` right now:; > ; > https://github.com/CliMA/Oceananigans.jl/blob/791bb83e4c49386cc31292bf391762f1cd96bdee/test/test_forcings.jl#L115; > ; > On the other hand, if I time step a model for which I _know_ the halos are too small (locally), I don't get an error (even though I'd like to). So maybe there _is_ something fishy... I don't know how to help, but I am following to see if can learn something and maybe next time I can be a better helper.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1092154547
Testability,test,test,"> I'm a bit stumped. The error is; > ; > ```; > Test threw exception; > --; >   | Expression: advective_and_multiple_forcing(arch); >   | TaskFailedException; >   |  ; >   | nested task error: BoundsError; > ```; > ; > But I can't reproduce this locally.; > ; > I can fathom a `BoundsError` when we use a high-order advection scheme and our halos aren't big enough. Right now we check the ""model advection scheme"" and the grid halos to catch this issue, but we don't check the forcings. However, the test uses `halo = (3, 3, 3)` right now:; > ; > https://github.com/CliMA/Oceananigans.jl/blob/791bb83e4c49386cc31292bf391762f1cd96bdee/test/test_forcings.jl#L115; > ; > On the other hand, if I time step a model for which I _know_ the halos are too small (locally), I don't get an error (even though I'd like to). So maybe there _is_ something fishy... I don't know how to help, but I am following to see if can learn something and maybe next time I can be a better helper.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1092154547
Usability,learn,learn,"> I'm a bit stumped. The error is; > ; > ```; > Test threw exception; > --; >   | Expression: advective_and_multiple_forcing(arch); >   | TaskFailedException; >   |  ; >   | nested task error: BoundsError; > ```; > ; > But I can't reproduce this locally.; > ; > I can fathom a `BoundsError` when we use a high-order advection scheme and our halos aren't big enough. Right now we check the ""model advection scheme"" and the grid halos to catch this issue, but we don't check the forcings. However, the test uses `halo = (3, 3, 3)` right now:; > ; > https://github.com/CliMA/Oceananigans.jl/blob/791bb83e4c49386cc31292bf391762f1cd96bdee/test/test_forcings.jl#L115; > ; > On the other hand, if I time step a model for which I _know_ the halos are too small (locally), I don't get an error (even though I'd like to). So maybe there _is_ something fishy... I don't know how to help, but I am following to see if can learn something and maybe next time I can be a better helper.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1092154547
Availability,error,error,"> I don't know how to help, but I am following to see if can learn something and maybe next time I can be a better helper. Can you reproduce the error in the test locally? You can try navigating to `/test`, starting with `julia --project`, and then. ```julia; julia> include(""test_forcings.jl""); ```. you might need to add a few packages to your global environment like `Test` to make this work. Also running. ```; TEST_GROUP=time_stepping_2 julia --project -e 'using Pkg; Pkg.test()'; ```. will run the forcing tests (and a few others). If you do that, do you see an error like in the CI or do the tests pass?. Also running just the problematic test in isolation can be useful:. https://github.com/CliMA/Oceananigans.jl/blob/791bb83e4c49386cc31292bf391762f1cd96bdee/test/test_forcings.jl#L114-L130",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1092171683
Testability,test,test,"> I don't know how to help, but I am following to see if can learn something and maybe next time I can be a better helper. Can you reproduce the error in the test locally? You can try navigating to `/test`, starting with `julia --project`, and then. ```julia; julia> include(""test_forcings.jl""); ```. you might need to add a few packages to your global environment like `Test` to make this work. Also running. ```; TEST_GROUP=time_stepping_2 julia --project -e 'using Pkg; Pkg.test()'; ```. will run the forcing tests (and a few others). If you do that, do you see an error like in the CI or do the tests pass?. Also running just the problematic test in isolation can be useful:. https://github.com/CliMA/Oceananigans.jl/blob/791bb83e4c49386cc31292bf391762f1cd96bdee/test/test_forcings.jl#L114-L130",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1092171683
Usability,learn,learn,"> I don't know how to help, but I am following to see if can learn something and maybe next time I can be a better helper. Can you reproduce the error in the test locally? You can try navigating to `/test`, starting with `julia --project`, and then. ```julia; julia> include(""test_forcings.jl""); ```. you might need to add a few packages to your global environment like `Test` to make this work. Also running. ```; TEST_GROUP=time_stepping_2 julia --project -e 'using Pkg; Pkg.test()'; ```. will run the forcing tests (and a few others). If you do that, do you see an error like in the CI or do the tests pass?. Also running just the problematic test in isolation can be useful:. https://github.com/CliMA/Oceananigans.jl/blob/791bb83e4c49386cc31292bf391762f1cd96bdee/test/test_forcings.jl#L114-L130",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1092171683
Availability,error,error,"> > I don't know how to help, but I am following to see if can learn something and maybe next time I can be a better helper.; > ; > Can you reproduce the error in the test locally? You can try navigating to `/test`, starting with `julia --project`, and then; > ; > ```julia; > julia> include(""test_forcings.jl""); > ```; > ; > you might need to add a few packages to your global environment like `Test` to make this work.; > ; > Also running; > ; > ```; > TEST_GROUP=time_stepping_2 julia --project -e 'using Pkg; Pkg.test()'; > ```; > ; > will run the forcing tests (and a few others). If you do that, do you see an error like in the CI or do the tests pass?; > ; > Also running just the problematic test in isolation can be useful:; > ; > https://github.com/CliMA/Oceananigans.jl/blob/791bb83e4c49386cc31292bf391762f1cd96bdee/test/test_forcings.jl#L114-L130. @iuryt this is no longer needed since I fixed the issue (now we wrap constant velocities in `ConstantField` and that seems to work). The remaining error is a GPU compilation issue...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1094117884
Integrability,wrap,wrap,"> > I don't know how to help, but I am following to see if can learn something and maybe next time I can be a better helper.; > ; > Can you reproduce the error in the test locally? You can try navigating to `/test`, starting with `julia --project`, and then; > ; > ```julia; > julia> include(""test_forcings.jl""); > ```; > ; > you might need to add a few packages to your global environment like `Test` to make this work.; > ; > Also running; > ; > ```; > TEST_GROUP=time_stepping_2 julia --project -e 'using Pkg; Pkg.test()'; > ```; > ; > will run the forcing tests (and a few others). If you do that, do you see an error like in the CI or do the tests pass?; > ; > Also running just the problematic test in isolation can be useful:; > ; > https://github.com/CliMA/Oceananigans.jl/blob/791bb83e4c49386cc31292bf391762f1cd96bdee/test/test_forcings.jl#L114-L130. @iuryt this is no longer needed since I fixed the issue (now we wrap constant velocities in `ConstantField` and that seems to work). The remaining error is a GPU compilation issue...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1094117884
Testability,test,test,"> > I don't know how to help, but I am following to see if can learn something and maybe next time I can be a better helper.; > ; > Can you reproduce the error in the test locally? You can try navigating to `/test`, starting with `julia --project`, and then; > ; > ```julia; > julia> include(""test_forcings.jl""); > ```; > ; > you might need to add a few packages to your global environment like `Test` to make this work.; > ; > Also running; > ; > ```; > TEST_GROUP=time_stepping_2 julia --project -e 'using Pkg; Pkg.test()'; > ```; > ; > will run the forcing tests (and a few others). If you do that, do you see an error like in the CI or do the tests pass?; > ; > Also running just the problematic test in isolation can be useful:; > ; > https://github.com/CliMA/Oceananigans.jl/blob/791bb83e4c49386cc31292bf391762f1cd96bdee/test/test_forcings.jl#L114-L130. @iuryt this is no longer needed since I fixed the issue (now we wrap constant velocities in `ConstantField` and that seems to work). The remaining error is a GPU compilation issue...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1094117884
Usability,learn,learn,"> > I don't know how to help, but I am following to see if can learn something and maybe next time I can be a better helper.; > ; > Can you reproduce the error in the test locally? You can try navigating to `/test`, starting with `julia --project`, and then; > ; > ```julia; > julia> include(""test_forcings.jl""); > ```; > ; > you might need to add a few packages to your global environment like `Test` to make this work.; > ; > Also running; > ; > ```; > TEST_GROUP=time_stepping_2 julia --project -e 'using Pkg; Pkg.test()'; > ```; > ; > will run the forcing tests (and a few others). If you do that, do you see an error like in the CI or do the tests pass?; > ; > Also running just the problematic test in isolation can be useful:; > ; > https://github.com/CliMA/Oceananigans.jl/blob/791bb83e4c49386cc31292bf391762f1cd96bdee/test/test_forcings.jl#L114-L130. @iuryt this is no longer needed since I fixed the issue (now we wrap constant velocities in `ConstantField` and that seems to work). The remaining error is a GPU compilation issue...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1094117884
Energy Efficiency,efficient,efficient,"Ahh I see now, thank you very much! That is very clear. May I ask why you have implemented it this way? Wouldn't it be easier to add and subtract the term off each diagonal element rather than deep copy the constructors? It certainly simplifies the `update_diag!` function but is it more efficient overall?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1179425989
Usability,clear,clear,"Ahh I see now, thank you very much! That is very clear. May I ask why you have implemented it this way? Wouldn't it be easier to add and subtract the term off each diagonal element rather than deep copy the constructors? It certainly simplifies the `update_diag!` function but is it more efficient overall?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1179425989
Modifiability,parameteriz,parameterizations,"> I want to merge this then use it to develop the user API for immersed boundary fluxes.; > ; > Also, did anyone use this?. I haven't used this, but I can test it if you want. > Partly I am wondering whether we may actually need shaved cells for accurate LES computations in complex domains with non-straight immersed boundaries) ... otherwise our boundaries will always have ""effective roughness"", and form drag may dominate. It is actually possible that form drag dominance is ok as a model for rough boundaries. But it'd be nice to have the possibility of ""smooth"" boundaries where fluxes can be controlled via parameterizations.; > ; > It's also interesting that PALM, which uses an almost identical numerical method that we use, is primarily used for atmospheric LES in urban environments. So their boundaries _are mostly flat_ (the sides of buildings, etc...). Shaved cells are definitely preferred in terms of accuracy (and convergence with resolution), but might not be necessary in a number of cases. My intuition from seeing results from papers (and from previous LES+IBM at my previous group) is that partial step cells would be almost as accurate as shaved cells (at least for oceanic cases with mild bathymetry slopes) but significantly simpler to implement. Since we already have the full-cell grid-fitted IBM it might be better to just focus on that for now and later modify it to make it partial-step when everything is working well (I think we'd just need to modify the calculation of vertical areas and volumes, no?). Also, when running ocean LES the aspect ratios are generally isotropic (Δz/Δx~1) but the bathymetry slopes are very small, which means that for some cases even full-step grid-fitted IBM might be enough. Only some tests will tell for sure though.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2402#issuecomment-1100238266
Testability,test,test,"> I want to merge this then use it to develop the user API for immersed boundary fluxes.; > ; > Also, did anyone use this?. I haven't used this, but I can test it if you want. > Partly I am wondering whether we may actually need shaved cells for accurate LES computations in complex domains with non-straight immersed boundaries) ... otherwise our boundaries will always have ""effective roughness"", and form drag may dominate. It is actually possible that form drag dominance is ok as a model for rough boundaries. But it'd be nice to have the possibility of ""smooth"" boundaries where fluxes can be controlled via parameterizations.; > ; > It's also interesting that PALM, which uses an almost identical numerical method that we use, is primarily used for atmospheric LES in urban environments. So their boundaries _are mostly flat_ (the sides of buildings, etc...). Shaved cells are definitely preferred in terms of accuracy (and convergence with resolution), but might not be necessary in a number of cases. My intuition from seeing results from papers (and from previous LES+IBM at my previous group) is that partial step cells would be almost as accurate as shaved cells (at least for oceanic cases with mild bathymetry slopes) but significantly simpler to implement. Since we already have the full-cell grid-fitted IBM it might be better to just focus on that for now and later modify it to make it partial-step when everything is working well (I think we'd just need to modify the calculation of vertical areas and volumes, no?). Also, when running ocean LES the aspect ratios are generally isotropic (Δz/Δx~1) but the bathymetry slopes are very small, which means that for some cases even full-step grid-fitted IBM might be enough. Only some tests will tell for sure though.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2402#issuecomment-1100238266
Usability,intuit,intuition,"> I want to merge this then use it to develop the user API for immersed boundary fluxes.; > ; > Also, did anyone use this?. I haven't used this, but I can test it if you want. > Partly I am wondering whether we may actually need shaved cells for accurate LES computations in complex domains with non-straight immersed boundaries) ... otherwise our boundaries will always have ""effective roughness"", and form drag may dominate. It is actually possible that form drag dominance is ok as a model for rough boundaries. But it'd be nice to have the possibility of ""smooth"" boundaries where fluxes can be controlled via parameterizations.; > ; > It's also interesting that PALM, which uses an almost identical numerical method that we use, is primarily used for atmospheric LES in urban environments. So their boundaries _are mostly flat_ (the sides of buildings, etc...). Shaved cells are definitely preferred in terms of accuracy (and convergence with resolution), but might not be necessary in a number of cases. My intuition from seeing results from papers (and from previous LES+IBM at my previous group) is that partial step cells would be almost as accurate as shaved cells (at least for oceanic cases with mild bathymetry slopes) but significantly simpler to implement. Since we already have the full-cell grid-fitted IBM it might be better to just focus on that for now and later modify it to make it partial-step when everything is working well (I think we'd just need to modify the calculation of vertical areas and volumes, no?). Also, when running ocean LES the aspect ratios are generally isotropic (Δz/Δx~1) but the bathymetry slopes are very small, which means that for some cases even full-step grid-fitted IBM might be enough. Only some tests will tell for sure though.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2402#issuecomment-1100238266
Integrability,interface,interface,"> > Since we already have the full-cell grid-fitted IBM it might be better to just focus on that for now and later modify it to make it partial-step when everything is working well (I think we'd just need to modify the calculation of vertical areas and volumes, no?).; > ; > Not sure what you mean in terms of ""focus"". I wasn't proposing any work, just speculating about the potential advantages of shaved cells. Do you mean focus on full cell IBM for this particular test? I agree with that --- we don't have shaved cells so we can't test it ?. Sorry for not being clear. I meant focus for development. For example, I see you're planning on implementing a more general BC interface for IBMs in https://github.com/CliMA/Oceananigans.jl/pull/2437. My point is that I think it would probably be easier to focus efforts on that kind of stuff first, make the full-step grid-fitted IBM (and its interface) functional, to only then try to improve the IBM implementation itself. Hope that clarifies it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2402#issuecomment-1100253538
Testability,test,test,"> > Since we already have the full-cell grid-fitted IBM it might be better to just focus on that for now and later modify it to make it partial-step when everything is working well (I think we'd just need to modify the calculation of vertical areas and volumes, no?).; > ; > Not sure what you mean in terms of ""focus"". I wasn't proposing any work, just speculating about the potential advantages of shaved cells. Do you mean focus on full cell IBM for this particular test? I agree with that --- we don't have shaved cells so we can't test it ?. Sorry for not being clear. I meant focus for development. For example, I see you're planning on implementing a more general BC interface for IBMs in https://github.com/CliMA/Oceananigans.jl/pull/2437. My point is that I think it would probably be easier to focus efforts on that kind of stuff first, make the full-step grid-fitted IBM (and its interface) functional, to only then try to improve the IBM implementation itself. Hope that clarifies it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2402#issuecomment-1100253538
Usability,clear,clear,"> > Since we already have the full-cell grid-fitted IBM it might be better to just focus on that for now and later modify it to make it partial-step when everything is working well (I think we'd just need to modify the calculation of vertical areas and volumes, no?).; > ; > Not sure what you mean in terms of ""focus"". I wasn't proposing any work, just speculating about the potential advantages of shaved cells. Do you mean focus on full cell IBM for this particular test? I agree with that --- we don't have shaved cells so we can't test it ?. Sorry for not being clear. I meant focus for development. For example, I see you're planning on implementing a more general BC interface for IBMs in https://github.com/CliMA/Oceananigans.jl/pull/2437. My point is that I think it would probably be easier to focus efforts on that kind of stuff first, make the full-step grid-fitted IBM (and its interface) functional, to only then try to improve the IBM implementation itself. Hope that clarifies it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2402#issuecomment-1100253538
Integrability,interface,interface,"> > > Since we already have the full-cell grid-fitted IBM it might be better to just focus on that for now and later modify it to make it partial-step when everything is working well (I think we'd just need to modify the calculation of vertical areas and volumes, no?).; > > ; > > ; > > Not sure what you mean in terms of ""focus"". I wasn't proposing any work, just speculating about the potential advantages of shaved cells. Do you mean focus on full cell IBM for this particular test? I agree with that --- we don't have shaved cells so we can't test it ?; > ; > Sorry for not being clear. I meant focus for development. For example, I see you're planning on implementing a more general BC interface for IBMs in #2437. My point is that I think it would probably be easier to focus efforts on that kind of stuff first, make the full-step grid-fitted IBM (and its interface) functional, to only then try to improve the IBM implementation itself.; > ; > Hope that clarifies it. Oh for sure, we hope to have that stuff merged soon. Shaved cells are eons away (unless some intrepid external contrib wants to focus it) --- we can't look at that within Climate Modeling Alliance until we have realistic global solutions.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2402#issuecomment-1100260081
Testability,test,test,"> > > Since we already have the full-cell grid-fitted IBM it might be better to just focus on that for now and later modify it to make it partial-step when everything is working well (I think we'd just need to modify the calculation of vertical areas and volumes, no?).; > > ; > > ; > > Not sure what you mean in terms of ""focus"". I wasn't proposing any work, just speculating about the potential advantages of shaved cells. Do you mean focus on full cell IBM for this particular test? I agree with that --- we don't have shaved cells so we can't test it ?; > ; > Sorry for not being clear. I meant focus for development. For example, I see you're planning on implementing a more general BC interface for IBMs in #2437. My point is that I think it would probably be easier to focus efforts on that kind of stuff first, make the full-step grid-fitted IBM (and its interface) functional, to only then try to improve the IBM implementation itself.; > ; > Hope that clarifies it. Oh for sure, we hope to have that stuff merged soon. Shaved cells are eons away (unless some intrepid external contrib wants to focus it) --- we can't look at that within Climate Modeling Alliance until we have realistic global solutions.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2402#issuecomment-1100260081
Usability,clear,clear,"> > > Since we already have the full-cell grid-fitted IBM it might be better to just focus on that for now and later modify it to make it partial-step when everything is working well (I think we'd just need to modify the calculation of vertical areas and volumes, no?).; > > ; > > ; > > Not sure what you mean in terms of ""focus"". I wasn't proposing any work, just speculating about the potential advantages of shaved cells. Do you mean focus on full cell IBM for this particular test? I agree with that --- we don't have shaved cells so we can't test it ?; > ; > Sorry for not being clear. I meant focus for development. For example, I see you're planning on implementing a more general BC interface for IBMs in #2437. My point is that I think it would probably be easier to focus efforts on that kind of stuff first, make the full-step grid-fitted IBM (and its interface) functional, to only then try to improve the IBM implementation itself.; > ; > Hope that clarifies it. Oh for sure, we hope to have that stuff merged soon. Shaved cells are eons away (unless some intrepid external contrib wants to focus it) --- we can't look at that within Climate Modeling Alliance until we have realistic global solutions.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2402#issuecomment-1100260081
Usability,simpl,simple,"Ok, multiplying by `h` then it would seem the possible models are. ```; 1. ∇ ⋅ (ν h ∇u); 2. ∇ ⋅ (ν ∇hu); 3. h ∇ ⋅ (ν ∇u); ```. ? These all have the same dimensions but different properties. I think 3. is what we get if we derive the closure from horizontal dissipation in Navier-Stokes. 2. is simple because it requires no code changes (ie it's the ordinary viscosity, except with `u -> hu`). 1. is supported by the theoretical arguments you listed. Also, I agree that this is first and foremost a _closure_, so ""derivability from Navier-Stokes"" is not paramount.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2403#issuecomment-1089686499
Testability,test,test,"I see what you mean that `h ∇ ⋅ (ν ∇u)` also satisfies some nice properties. I haven't seen that before but why not? Seems like a viable option. Maybe add that to the list of possible viscosity for shallow water?. It would be fun to test what difference these terms have on a simple problem. Just need to think about the problem, and of course get the code working.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2403#issuecomment-1090416474
Usability,simpl,simple,"I see what you mean that `h ∇ ⋅ (ν ∇u)` also satisfies some nice properties. I haven't seen that before but why not? Seems like a viable option. Maybe add that to the list of possible viscosity for shallow water?. It would be fun to test what difference these terms have on a simple problem. Just need to think about the problem, and of course get the code working.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2403#issuecomment-1090416474
Deployability,update,updated,"> 1. Should we enforce `.nc` in `NetCDFOutputWriter`? I think it's nice to enforce this. I think the benefit of enforcing it for NetCDF is less clear than for JLD2, so I chose to not place any requirements that NCDatasets.jl doesn't. But again I don't have a strong opinion here. > 2. Related to 1., we may want to provide an interface that omits the extension entirely (eg `filename` has no extension). This leads to an interface that is truly independent --- just change `JLD2` to `NetCDF` and you change the file format (and the extension is updated for you, which is nice!); ; Yeah I like that. Although then it wouldn't be able to be called `filename` imo, since you're not giving the filename anymore :). > Both can be resolved later. Btw the bump is very important because this fixes broken docs!. Can we deal with these in other PRs though? I won't be able to work on these anymore for a couple of weeks and I don't want this PR to go stale (especially because it has doc fixes, like you mentioned).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2416#issuecomment-1096764096
Integrability,interface,interface,"> 1. Should we enforce `.nc` in `NetCDFOutputWriter`? I think it's nice to enforce this. I think the benefit of enforcing it for NetCDF is less clear than for JLD2, so I chose to not place any requirements that NCDatasets.jl doesn't. But again I don't have a strong opinion here. > 2. Related to 1., we may want to provide an interface that omits the extension entirely (eg `filename` has no extension). This leads to an interface that is truly independent --- just change `JLD2` to `NetCDF` and you change the file format (and the extension is updated for you, which is nice!); ; Yeah I like that. Although then it wouldn't be able to be called `filename` imo, since you're not giving the filename anymore :). > Both can be resolved later. Btw the bump is very important because this fixes broken docs!. Can we deal with these in other PRs though? I won't be able to work on these anymore for a couple of weeks and I don't want this PR to go stale (especially because it has doc fixes, like you mentioned).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2416#issuecomment-1096764096
Usability,clear,clear,"> 1. Should we enforce `.nc` in `NetCDFOutputWriter`? I think it's nice to enforce this. I think the benefit of enforcing it for NetCDF is less clear than for JLD2, so I chose to not place any requirements that NCDatasets.jl doesn't. But again I don't have a strong opinion here. > 2. Related to 1., we may want to provide an interface that omits the extension entirely (eg `filename` has no extension). This leads to an interface that is truly independent --- just change `JLD2` to `NetCDF` and you change the file format (and the extension is updated for you, which is nice!); ; Yeah I like that. Although then it wouldn't be able to be called `filename` imo, since you're not giving the filename anymore :). > Both can be resolved later. Btw the bump is very important because this fixes broken docs!. Can we deal with these in other PRs though? I won't be able to work on these anymore for a couple of weeks and I don't want this PR to go stale (especially because it has doc fixes, like you mentioned).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2416#issuecomment-1096764096
Usability,clear,clear,"I think I still prefer to not append the extension and leave things the way they are mainly for three reasons:. - If you don't include the extension, then (using [usual jargon](https://www.computerhope.com/jargon/f/filename.htm)) it's not a complete file name anymore since it doesn't uniquely identify the file. To be correct I think we'd need to go back to `prefix` which isn't super clear imo; - It leads to less clear code if you're postprocessing the output in the name script. Like this pseudo code:. ```julia; simulation.output_writers[:writer] = JLD2OutputWriter(model, outputs, filename=filename). run!(simulation); real_filename = filename * "".jld2""; jldopen(real_filename); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2435#issuecomment-1098252695
Usability,feedback,feedback,"> * Like this pseudo code:; > ; > ```julia; > simulation.output_writers[:writer] = JLD2OutputWriter(model, outputs, filename=filename); > ; > run!(simulation); > real_filename = filename * "".jld2""; > jldopen(real_filename); > ```. I appreciate this feedback but can you clarify why this code is ""unclear""?. I think there _is_ a detriment to convenience --- which we have been accepting (without any loss of productivity, if we can be real...) since time eternal with the `prefix` kwarg, before #2416). I do think it'd be nice to solve this with `FieldTimeSeries` so we can write. ```julia; simulation.output_writers[:writer] = JLD2OutputWriter(model, outputs, filename=filename); run!(simulation); u = FieldTimeSeries(filename, ""u""); ```. This is easy... Balanced against the convenience detriment, I think the _cost_ of allowing arbitrary extensions is relatively higher (sharing data, figuring out the format of other people's data...). We also may have many more output writers in the future (Zarr, BSON, whatever), and I think it's friendly to relieve users from the burden of changing the filename.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2435#issuecomment-1098294955
Usability,feedback,feedback,"> > * Like this pseudo code:; > > ; > > ```julia; > > simulation.output_writers[:writer] = JLD2OutputWriter(model, outputs, filename=filename); > > ; > > run!(simulation); > > real_filename = filename * "".jld2""; > > jldopen(real_filename); > > ```; > ; > I appreciate this feedback but can you clarify why this code is ""unclear""?; ; Maybe unclear isn't the right word to use here, but I'm just pointing out that you'd end up with two things that a human would call a file name: `filename` (without extension) and `real_filename` (with extension).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2435#issuecomment-1098376380
Integrability,interface,interface,"This may be beyond the point of this PR, but I feel like lots of these discussions that ultimately mostly impact user interface and experience would hugely benefit from, well, user input! . This fact, coupled with the fact that Oceananigans probably now has a decently-sized user-base, may mean that we could start using polls and directly asking users about user-interface decisions. That way we can get more hard data on what makes the code easier and clearer to most users and weight that more accurately against other aspects of the decision. Just a thought...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2435#issuecomment-1098382999
Usability,clear,clearer,"This may be beyond the point of this PR, but I feel like lots of these discussions that ultimately mostly impact user interface and experience would hugely benefit from, well, user input! . This fact, coupled with the fact that Oceananigans probably now has a decently-sized user-base, may mean that we could start using polls and directly asking users about user-interface decisions. That way we can get more hard data on what makes the code easier and clearer to most users and weight that more accurately against other aspects of the decision. Just a thought...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2435#issuecomment-1098382999
Integrability,interface,interface,"Here's a summary of the current design:. I've introduced a new type called `ImmersedBoundaryCondition` to represent boundary conditions on immersed boundaries. The type has 6 fields for each direction, west, east, south, north, bottom, top. I believe this covers the general case in which we might have different fluxes on any face of a cell that's the boundary between a wet node and an immersed node. For example, we can implement ""bottom drag"" for large scale ocean models, with no ""side drag"". In practice this is really just a performance optimization rather than a physical model (the horizontal drag has no effect on the solution), but it's probably important that we can support it. This low-level, but fully general interface allow advanced users to specify any kind of immersed flux / boundary condition they need to. The next challenge is to design a convenient API that interprets user-input and builds `ImmersedBoundaryCondition` appropriately under the hood. For constant `ValueBoundaryCondition` (eg no-slip) or constant `FluxBoundaryCondition`, this is simple --- just copy the boundary condition into every direction. For `FluxBoundaryCondition` we orient the flux along the inward normal (eg positive for `west, south, bottom` and negative for `east, north, top`. This breaks existing convention for fluxes... but we really don't have a choice. We may want to change the convention for the _other_ boundaries eventually. `ContinuousBoundaryFunction` is perhaps the most important case since we'll use this to implement drag boundary conditions. For this I believe we can use the existing infrastructure for `ContinuousBoundaryFunction` (eg we have a way to properly interpolate fields in a manner consistent with the application of drag boundary conditions, etc). It's functionality will have to be extended to accept functions of `i, j, k` (the way it works now is that the ""third"" index (normal to the boundary) is stored inside the object; for immersed boundary conditions we don'",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100563991
Modifiability,extend,extended,"-input and builds `ImmersedBoundaryCondition` appropriately under the hood. For constant `ValueBoundaryCondition` (eg no-slip) or constant `FluxBoundaryCondition`, this is simple --- just copy the boundary condition into every direction. For `FluxBoundaryCondition` we orient the flux along the inward normal (eg positive for `west, south, bottom` and negative for `east, north, top`. This breaks existing convention for fluxes... but we really don't have a choice. We may want to change the convention for the _other_ boundaries eventually. `ContinuousBoundaryFunction` is perhaps the most important case since we'll use this to implement drag boundary conditions. For this I believe we can use the existing infrastructure for `ContinuousBoundaryFunction` (eg we have a way to properly interpolate fields in a manner consistent with the application of drag boundary conditions, etc). It's functionality will have to be extended to accept functions of `i, j, k` (the way it works now is that the ""third"" index (normal to the boundary) is stored inside the object; for immersed boundary conditions we don't need that). `DiscreteBoundaryFunction` won't be very convenient for most people for immersed boundary conditions, but we can treat it the same way we treat constant `Value` or `Flux`. I wasn't planning to implement support for `Gradient` just yet, though this can be done too. Finally, one remaining task is to define or generalize the existing `conditional_flux` so that it adds fluxes only on _immersed_ boundaries. It looks like right now it's too eager and will add fluxes on non-immersed boundaries. Associated with this development I'd like to refactor our naming scheme for the boolean tools we have. Right now these are `solid_node` and `solid_interface`. I'd like to change `solid_node` to `external_node` (ie external to the active domain) and perhaps something like `external_or_boundary_node` for `solid_interface` to represent _both_ nodes that are completely external, or which lie",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100563991
Performance,perform,performance,"Here's a summary of the current design:. I've introduced a new type called `ImmersedBoundaryCondition` to represent boundary conditions on immersed boundaries. The type has 6 fields for each direction, west, east, south, north, bottom, top. I believe this covers the general case in which we might have different fluxes on any face of a cell that's the boundary between a wet node and an immersed node. For example, we can implement ""bottom drag"" for large scale ocean models, with no ""side drag"". In practice this is really just a performance optimization rather than a physical model (the horizontal drag has no effect on the solution), but it's probably important that we can support it. This low-level, but fully general interface allow advanced users to specify any kind of immersed flux / boundary condition they need to. The next challenge is to design a convenient API that interprets user-input and builds `ImmersedBoundaryCondition` appropriately under the hood. For constant `ValueBoundaryCondition` (eg no-slip) or constant `FluxBoundaryCondition`, this is simple --- just copy the boundary condition into every direction. For `FluxBoundaryCondition` we orient the flux along the inward normal (eg positive for `west, south, bottom` and negative for `east, north, top`. This breaks existing convention for fluxes... but we really don't have a choice. We may want to change the convention for the _other_ boundaries eventually. `ContinuousBoundaryFunction` is perhaps the most important case since we'll use this to implement drag boundary conditions. For this I believe we can use the existing infrastructure for `ContinuousBoundaryFunction` (eg we have a way to properly interpolate fields in a manner consistent with the application of drag boundary conditions, etc). It's functionality will have to be extended to accept functions of `i, j, k` (the way it works now is that the ""third"" index (normal to the boundary) is stored inside the object; for immersed boundary conditions we don'",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100563991
Usability,simpl,simple,"ced a new type called `ImmersedBoundaryCondition` to represent boundary conditions on immersed boundaries. The type has 6 fields for each direction, west, east, south, north, bottom, top. I believe this covers the general case in which we might have different fluxes on any face of a cell that's the boundary between a wet node and an immersed node. For example, we can implement ""bottom drag"" for large scale ocean models, with no ""side drag"". In practice this is really just a performance optimization rather than a physical model (the horizontal drag has no effect on the solution), but it's probably important that we can support it. This low-level, but fully general interface allow advanced users to specify any kind of immersed flux / boundary condition they need to. The next challenge is to design a convenient API that interprets user-input and builds `ImmersedBoundaryCondition` appropriately under the hood. For constant `ValueBoundaryCondition` (eg no-slip) or constant `FluxBoundaryCondition`, this is simple --- just copy the boundary condition into every direction. For `FluxBoundaryCondition` we orient the flux along the inward normal (eg positive for `west, south, bottom` and negative for `east, north, top`. This breaks existing convention for fluxes... but we really don't have a choice. We may want to change the convention for the _other_ boundaries eventually. `ContinuousBoundaryFunction` is perhaps the most important case since we'll use this to implement drag boundary conditions. For this I believe we can use the existing infrastructure for `ContinuousBoundaryFunction` (eg we have a way to properly interpolate fields in a manner consistent with the application of drag boundary conditions, etc). It's functionality will have to be extended to accept functions of `i, j, k` (the way it works now is that the ""third"" index (normal to the boundary) is stored inside the object; for immersed boundary conditions we don't need that). `DiscreteBoundaryFunction` won't be ve",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100563991
Integrability,interface,interfaces,"mage"" src=""https://user-images.githubusercontent.com/15271942/163682350-9c0e83e4-48c2-488d-8a2a-67c1c896faf8.png"">. Since I had to dig deep into the immersed boundary implementation, I made a few more long-needed changes:. * Finally, we directly serialize `ImmersedBoundaryGrid`; * I changed `ImmersedBoundaryGrid.grid` (eminently confusing!) to `ImmersedBoundaryGrid.underlying_grid` to emphasize that there are ""two grids"" --- one underlying rectangular grid, and an overlying ""immersed grid""; * I cleaned up the output writers utilities a bit as well.; * I built out and hopefully clarified out ""node condition"" functionality. There are now a few functions:; - `external_cell` identifies whether a _tracer cell_ (or perhaps the ""reference cell"" --- the one located at center, center, center) is outside the `Bounded` domain (this has no effect in `Periodic` directions); - `external_node` identifies whether a _location_ is external to the `Bounded` domain. We use the term ""node"" because this can be used for cells _or_ cell interfaces. `external_node` is `false` for locations that ""touch"" wet cells.; - `peripheral_node` identifies whether a location is either _on or external_ to the `Bounded` domain. So this intersects with `external_node` in the exterior, but additionally contains locations that touch wet cells.; - `immersed_peripheral_node` identifies locations that are on or external to the immersed domain, but _not_ external to the underlying grid domain (we need this so that we don't apply immersed boundary conditions at all peripheral nodes).; - `immersed_cell` is now the name of the function `is_immersed` --- immersed boundary implementations define this to obtain correct logic for boundary conditions. We then extend `external_cell` to cover both the external cells of the underlying bounded domain and the immersed cells. I think there's still a fair amount of work to do on this interface but hopefully this is a good step forward. Here's a few more thoughts:. * It seems ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100699430
Modifiability,extend,extend,"center) is outside the `Bounded` domain (this has no effect in `Periodic` directions); - `external_node` identifies whether a _location_ is external to the `Bounded` domain. We use the term ""node"" because this can be used for cells _or_ cell interfaces. `external_node` is `false` for locations that ""touch"" wet cells.; - `peripheral_node` identifies whether a location is either _on or external_ to the `Bounded` domain. So this intersects with `external_node` in the exterior, but additionally contains locations that touch wet cells.; - `immersed_peripheral_node` identifies locations that are on or external to the immersed domain, but _not_ external to the underlying grid domain (we need this so that we don't apply immersed boundary conditions at all peripheral nodes).; - `immersed_cell` is now the name of the function `is_immersed` --- immersed boundary implementations define this to obtain correct logic for boundary conditions. We then extend `external_cell` to cover both the external cells of the underlying bounded domain and the immersed cells. I think there's still a fair amount of work to do on this interface but hopefully this is a good step forward. Here's a few more thoughts:. * It seems that we should really use `Bounded` topology to be synonymous with ""impenetrable"". This might help us disentangle a few issues (eg satisfying impenetrability, correct divergences, etc.) I think we are discovering that in some cases its better to hard code certain ""assumed boundary conditions"" directly into operators, such as impenetrable conditions (considering complex domains is the key to realize the right abstractions here, since there are many simple solutions for non-complex domains and no obvious way to distinguish their tradeoffs). This means that we need to ""assume"" boundary conditions based on grid topology (information centralized on the grid), rather than requiring knowledge of the field boundary conditions (information scattered throughout the fields); * Related to ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100699430
Testability,log,logic," few functions:; - `external_cell` identifies whether a _tracer cell_ (or perhaps the ""reference cell"" --- the one located at center, center, center) is outside the `Bounded` domain (this has no effect in `Periodic` directions); - `external_node` identifies whether a _location_ is external to the `Bounded` domain. We use the term ""node"" because this can be used for cells _or_ cell interfaces. `external_node` is `false` for locations that ""touch"" wet cells.; - `peripheral_node` identifies whether a location is either _on or external_ to the `Bounded` domain. So this intersects with `external_node` in the exterior, but additionally contains locations that touch wet cells.; - `immersed_peripheral_node` identifies locations that are on or external to the immersed domain, but _not_ external to the underlying grid domain (we need this so that we don't apply immersed boundary conditions at all peripheral nodes).; - `immersed_cell` is now the name of the function `is_immersed` --- immersed boundary implementations define this to obtain correct logic for boundary conditions. We then extend `external_cell` to cover both the external cells of the underlying bounded domain and the immersed cells. I think there's still a fair amount of work to do on this interface but hopefully this is a good step forward. Here's a few more thoughts:. * It seems that we should really use `Bounded` topology to be synonymous with ""impenetrable"". This might help us disentangle a few issues (eg satisfying impenetrability, correct divergences, etc.) I think we are discovering that in some cases its better to hard code certain ""assumed boundary conditions"" directly into operators, such as impenetrable conditions (considering complex domains is the key to realize the right abstractions here, since there are many simple solutions for non-complex domains and no obvious way to distinguish their tradeoffs). This means that we need to ""assume"" boundary conditions based on grid topology (information centrali",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100699430
Usability,simpl,simple," locations that are on or external to the immersed domain, but _not_ external to the underlying grid domain (we need this so that we don't apply immersed boundary conditions at all peripheral nodes).; - `immersed_cell` is now the name of the function `is_immersed` --- immersed boundary implementations define this to obtain correct logic for boundary conditions. We then extend `external_cell` to cover both the external cells of the underlying bounded domain and the immersed cells. I think there's still a fair amount of work to do on this interface but hopefully this is a good step forward. Here's a few more thoughts:. * It seems that we should really use `Bounded` topology to be synonymous with ""impenetrable"". This might help us disentangle a few issues (eg satisfying impenetrability, correct divergences, etc.) I think we are discovering that in some cases its better to hard code certain ""assumed boundary conditions"" directly into operators, such as impenetrable conditions (considering complex domains is the key to realize the right abstractions here, since there are many simple solutions for non-complex domains and no obvious way to distinguish their tradeoffs). This means that we need to ""assume"" boundary conditions based on grid topology (information centralized on the grid), rather than requiring knowledge of the field boundary conditions (information scattered throughout the fields); * Related to the above, when we support ""open"" boundaries, I think we may actually want an ""Open"" topology that functions similarly to the topologies we use for distributed models work (perhaps, in fact, we can reuse those abstractions). I think the design assumed (though it was never implemented) that we could use ""open boundary condition"" for open boundaries, rather than changing the topology. But with complex domains, it's helpful to _assume_ certain boundary conditions based on _grid topology_ (rather than boundary conditions applied to fields). ImmersedBoundaries are hard-coded",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100699430
Integrability,interface,interfaces,"Wow, awesome work!. Here are a few thoughts/comments:. > * I changed `ImmersedBoundaryGrid.grid` (eminently confusing!) to `ImmersedBoundaryGrid.underlying_grid` to emphasize that there are ""two grids"" --- one underlying rectangular grid, and an overlying ""immersed grid"". :+1: much clearer. > * I built out and hopefully clarified out ""node condition"" functionality. There are now a few functions:; > ; > * `external_cell` identifies whether a _tracer cell_ (or perhaps the ""reference cell"" --- the one located at center, center, center) is outside the `Bounded` domain (this has no effect in `Periodic` directions); > * `external_node` identifies whether a _location_ is external to the `Bounded` domain. We use the term ""node"" because this can be used for cells _or_ cell interfaces. `external_node` is `false` for locations that ""touch"" wet cells. So `external_cell` is just a special case `external_node`, correct? It also seems to me that this for now assumes a full-step grid-fitted IBM, no?. > * `peripheral_node` identifies whether a location is either _on or external_ to the `Bounded` domain. So this intersects with `external_node` in the exterior, but additionally contains locations that touch wet cells. Not sure I understand this. Is this trying to check whether a location is _adjacent_ to an IBM in addition to a location that's far (i.e. more than one grid point away) from an IBM?. > * `immersed_peripheral_node` identifies locations that are on or external to the immersed domain, but _not_ external to the underlying grid domain (we need this so that we don't apply immersed boundary conditions at all peripheral nodes). Also a bit confused. Sounds to me that this is the same as the previous one but excluding halo regions, which probably isn't right... > * `immersed_cell` is now the name of the function `is_immersed` --- immersed boundary implementations define this to obtain correct logic for boundary conditions. We then extend `external_cell` to cover both the external c",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100732847
Modifiability,extend,extend," functions:; > ; > * `external_cell` identifies whether a _tracer cell_ (or perhaps the ""reference cell"" --- the one located at center, center, center) is outside the `Bounded` domain (this has no effect in `Periodic` directions); > * `external_node` identifies whether a _location_ is external to the `Bounded` domain. We use the term ""node"" because this can be used for cells _or_ cell interfaces. `external_node` is `false` for locations that ""touch"" wet cells. So `external_cell` is just a special case `external_node`, correct? It also seems to me that this for now assumes a full-step grid-fitted IBM, no?. > * `peripheral_node` identifies whether a location is either _on or external_ to the `Bounded` domain. So this intersects with `external_node` in the exterior, but additionally contains locations that touch wet cells. Not sure I understand this. Is this trying to check whether a location is _adjacent_ to an IBM in addition to a location that's far (i.e. more than one grid point away) from an IBM?. > * `immersed_peripheral_node` identifies locations that are on or external to the immersed domain, but _not_ external to the underlying grid domain (we need this so that we don't apply immersed boundary conditions at all peripheral nodes). Also a bit confused. Sounds to me that this is the same as the previous one but excluding halo regions, which probably isn't right... > * `immersed_cell` is now the name of the function `is_immersed` --- immersed boundary implementations define this to obtain correct logic for boundary conditions. We then extend `external_cell` to cover both the external cells of the underlying bounded domain and the immersed cells.; > ; > I think there's still a fair amount of work to do on this interface but hopefully this is a good step forward. Here's a few more thoughts:. Quick question: Have you checked the performance here? I ask because the model was running pretty slowly when I was testing https://github.com/CliMA/Oceananigans.jl/pull/2275...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100732847
Performance,perform,performance," functions:; > ; > * `external_cell` identifies whether a _tracer cell_ (or perhaps the ""reference cell"" --- the one located at center, center, center) is outside the `Bounded` domain (this has no effect in `Periodic` directions); > * `external_node` identifies whether a _location_ is external to the `Bounded` domain. We use the term ""node"" because this can be used for cells _or_ cell interfaces. `external_node` is `false` for locations that ""touch"" wet cells. So `external_cell` is just a special case `external_node`, correct? It also seems to me that this for now assumes a full-step grid-fitted IBM, no?. > * `peripheral_node` identifies whether a location is either _on or external_ to the `Bounded` domain. So this intersects with `external_node` in the exterior, but additionally contains locations that touch wet cells. Not sure I understand this. Is this trying to check whether a location is _adjacent_ to an IBM in addition to a location that's far (i.e. more than one grid point away) from an IBM?. > * `immersed_peripheral_node` identifies locations that are on or external to the immersed domain, but _not_ external to the underlying grid domain (we need this so that we don't apply immersed boundary conditions at all peripheral nodes). Also a bit confused. Sounds to me that this is the same as the previous one but excluding halo regions, which probably isn't right... > * `immersed_cell` is now the name of the function `is_immersed` --- immersed boundary implementations define this to obtain correct logic for boundary conditions. We then extend `external_cell` to cover both the external cells of the underlying bounded domain and the immersed cells.; > ; > I think there's still a fair amount of work to do on this interface but hopefully this is a good step forward. Here's a few more thoughts:. Quick question: Have you checked the performance here? I ask because the model was running pretty slowly when I was testing https://github.com/CliMA/Oceananigans.jl/pull/2275...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100732847
Testability,log,logic," functions:; > ; > * `external_cell` identifies whether a _tracer cell_ (or perhaps the ""reference cell"" --- the one located at center, center, center) is outside the `Bounded` domain (this has no effect in `Periodic` directions); > * `external_node` identifies whether a _location_ is external to the `Bounded` domain. We use the term ""node"" because this can be used for cells _or_ cell interfaces. `external_node` is `false` for locations that ""touch"" wet cells. So `external_cell` is just a special case `external_node`, correct? It also seems to me that this for now assumes a full-step grid-fitted IBM, no?. > * `peripheral_node` identifies whether a location is either _on or external_ to the `Bounded` domain. So this intersects with `external_node` in the exterior, but additionally contains locations that touch wet cells. Not sure I understand this. Is this trying to check whether a location is _adjacent_ to an IBM in addition to a location that's far (i.e. more than one grid point away) from an IBM?. > * `immersed_peripheral_node` identifies locations that are on or external to the immersed domain, but _not_ external to the underlying grid domain (we need this so that we don't apply immersed boundary conditions at all peripheral nodes). Also a bit confused. Sounds to me that this is the same as the previous one but excluding halo regions, which probably isn't right... > * `immersed_cell` is now the name of the function `is_immersed` --- immersed boundary implementations define this to obtain correct logic for boundary conditions. We then extend `external_cell` to cover both the external cells of the underlying bounded domain and the immersed cells.; > ; > I think there's still a fair amount of work to do on this interface but hopefully this is a good step forward. Here's a few more thoughts:. Quick question: Have you checked the performance here? I ask because the model was running pretty slowly when I was testing https://github.com/CliMA/Oceananigans.jl/pull/2275...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100732847
Usability,clear,clearer,"Wow, awesome work!. Here are a few thoughts/comments:. > * I changed `ImmersedBoundaryGrid.grid` (eminently confusing!) to `ImmersedBoundaryGrid.underlying_grid` to emphasize that there are ""two grids"" --- one underlying rectangular grid, and an overlying ""immersed grid"". :+1: much clearer. > * I built out and hopefully clarified out ""node condition"" functionality. There are now a few functions:; > ; > * `external_cell` identifies whether a _tracer cell_ (or perhaps the ""reference cell"" --- the one located at center, center, center) is outside the `Bounded` domain (this has no effect in `Periodic` directions); > * `external_node` identifies whether a _location_ is external to the `Bounded` domain. We use the term ""node"" because this can be used for cells _or_ cell interfaces. `external_node` is `false` for locations that ""touch"" wet cells. So `external_cell` is just a special case `external_node`, correct? It also seems to me that this for now assumes a full-step grid-fitted IBM, no?. > * `peripheral_node` identifies whether a location is either _on or external_ to the `Bounded` domain. So this intersects with `external_node` in the exterior, but additionally contains locations that touch wet cells. Not sure I understand this. Is this trying to check whether a location is _adjacent_ to an IBM in addition to a location that's far (i.e. more than one grid point away) from an IBM?. > * `immersed_peripheral_node` identifies locations that are on or external to the immersed domain, but _not_ external to the underlying grid domain (we need this so that we don't apply immersed boundary conditions at all peripheral nodes). Also a bit confused. Sounds to me that this is the same as the previous one but excluding halo regions, which probably isn't right... > * `immersed_cell` is now the name of the function `is_immersed` --- immersed boundary implementations define this to obtain correct logic for boundary conditions. We then extend `external_cell` to cover both the external c",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100732847
Testability,test,test,"> > The type infererence issue seems to be fixed. For `flow_over_hills.jl` the cost per time-step is approximately the same on my CPU for the ""reference case"" (no immersed boundary), and either free-slip or no-slip immersed boundary.; > ; > That's awesome! Just out of curiosity (since I also investigated this I couldn't figure it out), how did you fix the type inference issue?; > ; > cc @wenegrat @whitleyv. Here the issue was introduced in an early commit on this PR --- so it may not be exactly the same issue you faced. On the other hand, I think it happened with the same function that you modified (`conditional_flux`) so there may be a lesson you can glean. I also changed the design of the function (previously it took a function argument, `flux`, now it simply takes the scalar value of the flux). That subtle change might have made an important difference, since in the first case a function is being passed into another function (requiring the compiler to specialize on a function argument, sometimes a tricky thing), and another case it was just a floating point number being passed in (relatively vanilla in comparison). Did you test that kind of change in your PR?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1101520394
Usability,simpl,simply,"> > The type infererence issue seems to be fixed. For `flow_over_hills.jl` the cost per time-step is approximately the same on my CPU for the ""reference case"" (no immersed boundary), and either free-slip or no-slip immersed boundary.; > ; > That's awesome! Just out of curiosity (since I also investigated this I couldn't figure it out), how did you fix the type inference issue?; > ; > cc @wenegrat @whitleyv. Here the issue was introduced in an early commit on this PR --- so it may not be exactly the same issue you faced. On the other hand, I think it happened with the same function that you modified (`conditional_flux`) so there may be a lesson you can glean. I also changed the design of the function (previously it took a function argument, `flux`, now it simply takes the scalar value of the flux). That subtle change might have made an important difference, since in the first case a function is being passed into another function (requiring the compiler to specialize on a function argument, sometimes a tricky thing), and another case it was just a floating point number being passed in (relatively vanilla in comparison). Did you test that kind of change in your PR?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1101520394
Energy Efficiency,energy,energy,> > Does the total energy do the same thing or is it just the momentum?; > ; > I'll add that to `flow_over_hills.jl`!. Thanks. . Given the fact that the reference case flows over a flat bottom it doesn't suprise me that the mometum decreases monotonically. . The 2nd and 3rd case are flowing over topography and there should be a periodic effect of the topography on the momentum. No? Total momentum must vary because of the forcing and I don't know exactly what that should look like. But if the energy is not monotonic that would be a clear sign that something is going wrong.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1101532112
Usability,clear,clear,> > Does the total energy do the same thing or is it just the momentum?; > ; > I'll add that to `flow_over_hills.jl`!. Thanks. . Given the fact that the reference case flows over a flat bottom it doesn't suprise me that the mometum decreases monotonically. . The 2nd and 3rd case are flowing over topography and there should be a periodic effect of the topography on the momentum. No? Total momentum must vary because of the forcing and I don't know exactly what that should look like. But if the energy is not monotonic that would be a clear sign that something is going wrong.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1101532112
Integrability,interface,interface,"A few other things that this PR inspired me to think about:. 1. I think it'd be nice if `FieldBoundaryConditions` accepted a positional argument to specify the ""default"" boundary condition in `Bounded` directions. This would simplify scripts where every boundary is no-slip (for example) since we could write. ```julia; no_slip = ValueBoundaryCondition(0); u_bcs = FieldBoundaryConditions(no_slip); ```. Since the positional argument specifies the default we can also override it:. ```julia; u_bcs = FieldBoundaryConditions(no_slip, top=FluxBoundaryCondition(nothing)); ```. to have no-slip on all boundaries except the top, where we have free-slip / zero flux. 2. I think we do really need a convenience constructor for drag boundary conditions because a) this is friendly for a very common case and b) the drag boundary condition involves uncertain free parameters (Von Karman, roughness...) which we may want to calibrate via ParameterEstimocean and c) similar to the last point, it's crucial that these parameters are obviated in user scripts for reproducibility; defining an interface for drag will help. I think some simple struct called `QuadraticDrag`, which `regularize_boundary_condition` knows how to deal with (since it knows `field_name`, we know how to treat the different velocity components), will suffice for this.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1101540638
Usability,simpl,simplify,"A few other things that this PR inspired me to think about:. 1. I think it'd be nice if `FieldBoundaryConditions` accepted a positional argument to specify the ""default"" boundary condition in `Bounded` directions. This would simplify scripts where every boundary is no-slip (for example) since we could write. ```julia; no_slip = ValueBoundaryCondition(0); u_bcs = FieldBoundaryConditions(no_slip); ```. Since the positional argument specifies the default we can also override it:. ```julia; u_bcs = FieldBoundaryConditions(no_slip, top=FluxBoundaryCondition(nothing)); ```. to have no-slip on all boundaries except the top, where we have free-slip / zero flux. 2. I think we do really need a convenience constructor for drag boundary conditions because a) this is friendly for a very common case and b) the drag boundary condition involves uncertain free parameters (Von Karman, roughness...) which we may want to calibrate via ParameterEstimocean and c) similar to the last point, it's crucial that these parameters are obviated in user scripts for reproducibility; defining an interface for drag will help. I think some simple struct called `QuadraticDrag`, which `regularize_boundary_condition` knows how to deal with (since it knows `field_name`, we know how to treat the different velocity components), will suffice for this.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1101540638
Usability,clear,clearn,I like the proposed idea for how to specify `FieldBoundaryConditions`. That seems very clearn and friendly.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1101585372
Availability,down,down,"I'm seeing some significant slow down with the boundary condition. ```julia; # Monin-Obukhov drag coefficient; z₀ = 1e-4 # Charnock roughness; κ = 0.4 # Von Karman constant; Cᴰ(Δz) = (κ / log(Δz / 2z₀))^2. @inline bottom_drag_u(x, y, t, u, w, Cᴰ) = - Cᴰ * u * sqrt(u^2 + w^2); @inline bottom_drag_w(x, y, t, u, w, Cᴰ) = - Cᴰ * w * sqrt(u^2 + w^2); @inline bottom_drag_u(x, y, z, t, u, w, Cᴰ) = - Cᴰ * u * sqrt(u^2 + w^2); @inline bottom_drag_w(x, y, z, t, u, w, Cᴰ) = - Cᴰ * w * sqrt(u^2 + w^2). Δz = 1 / Nz; Δx = 2π / Nz; u_drag_bc = FluxBoundaryCondition(bottom_drag_u, field_dependencies=(:u, :w), parameters=Cᴰ(Δz)); w_drag_bc = FluxBoundaryCondition(bottom_drag_w, field_dependencies=(:u, :w), parameters=Cᴰ(Δx)); u_bcs = FieldBoundaryConditions(bottom=u_drag_bc, immersed=u_drag_bc); w_bcs = FieldBoundaryConditions(immersed=w_drag_bc); ```. This is the basic way to implement a quadratic drag from the interface in this PR. In this case what happens under the hood is that we create 4 `ContinuousBoundaryFunction` for the relevant faces of boundary-adjacent cells (the other 2 faces are normal to the given velocity component, so receive a no-penetration boundary condition). So there could be a type instability compiling all of those (which have been notoriously fickle to compile in the past). We clearly need to hard code quadratic drag though, because for stretched grids and partial cells (and other types of immersed boundaries in the future) we have to do precompute the logarithm of the grid metrics (to use in a Monin-Obukhov-type model) in each direction independently, as well as the logarithm of the roughness. It's too much for this PR though, so I think we should just document how to specify no-slip on immersed boundaries (which appears to be performant), and add a few tests. Then in a future PR we can add a `QuadraticDrag` utility (I have a prototype for this object; others are welcome to collaborate on implementing the necessary functions to support it).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1104673081
Integrability,interface,interface,"I'm seeing some significant slow down with the boundary condition. ```julia; # Monin-Obukhov drag coefficient; z₀ = 1e-4 # Charnock roughness; κ = 0.4 # Von Karman constant; Cᴰ(Δz) = (κ / log(Δz / 2z₀))^2. @inline bottom_drag_u(x, y, t, u, w, Cᴰ) = - Cᴰ * u * sqrt(u^2 + w^2); @inline bottom_drag_w(x, y, t, u, w, Cᴰ) = - Cᴰ * w * sqrt(u^2 + w^2); @inline bottom_drag_u(x, y, z, t, u, w, Cᴰ) = - Cᴰ * u * sqrt(u^2 + w^2); @inline bottom_drag_w(x, y, z, t, u, w, Cᴰ) = - Cᴰ * w * sqrt(u^2 + w^2). Δz = 1 / Nz; Δx = 2π / Nz; u_drag_bc = FluxBoundaryCondition(bottom_drag_u, field_dependencies=(:u, :w), parameters=Cᴰ(Δz)); w_drag_bc = FluxBoundaryCondition(bottom_drag_w, field_dependencies=(:u, :w), parameters=Cᴰ(Δx)); u_bcs = FieldBoundaryConditions(bottom=u_drag_bc, immersed=u_drag_bc); w_bcs = FieldBoundaryConditions(immersed=w_drag_bc); ```. This is the basic way to implement a quadratic drag from the interface in this PR. In this case what happens under the hood is that we create 4 `ContinuousBoundaryFunction` for the relevant faces of boundary-adjacent cells (the other 2 faces are normal to the given velocity component, so receive a no-penetration boundary condition). So there could be a type instability compiling all of those (which have been notoriously fickle to compile in the past). We clearly need to hard code quadratic drag though, because for stretched grids and partial cells (and other types of immersed boundaries in the future) we have to do precompute the logarithm of the grid metrics (to use in a Monin-Obukhov-type model) in each direction independently, as well as the logarithm of the roughness. It's too much for this PR though, so I think we should just document how to specify no-slip on immersed boundaries (which appears to be performant), and add a few tests. Then in a future PR we can add a `QuadraticDrag` utility (I have a prototype for this object; others are welcome to collaborate on implementing the necessary functions to support it).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1104673081
Performance,perform,performant,"I'm seeing some significant slow down with the boundary condition. ```julia; # Monin-Obukhov drag coefficient; z₀ = 1e-4 # Charnock roughness; κ = 0.4 # Von Karman constant; Cᴰ(Δz) = (κ / log(Δz / 2z₀))^2. @inline bottom_drag_u(x, y, t, u, w, Cᴰ) = - Cᴰ * u * sqrt(u^2 + w^2); @inline bottom_drag_w(x, y, t, u, w, Cᴰ) = - Cᴰ * w * sqrt(u^2 + w^2); @inline bottom_drag_u(x, y, z, t, u, w, Cᴰ) = - Cᴰ * u * sqrt(u^2 + w^2); @inline bottom_drag_w(x, y, z, t, u, w, Cᴰ) = - Cᴰ * w * sqrt(u^2 + w^2). Δz = 1 / Nz; Δx = 2π / Nz; u_drag_bc = FluxBoundaryCondition(bottom_drag_u, field_dependencies=(:u, :w), parameters=Cᴰ(Δz)); w_drag_bc = FluxBoundaryCondition(bottom_drag_w, field_dependencies=(:u, :w), parameters=Cᴰ(Δx)); u_bcs = FieldBoundaryConditions(bottom=u_drag_bc, immersed=u_drag_bc); w_bcs = FieldBoundaryConditions(immersed=w_drag_bc); ```. This is the basic way to implement a quadratic drag from the interface in this PR. In this case what happens under the hood is that we create 4 `ContinuousBoundaryFunction` for the relevant faces of boundary-adjacent cells (the other 2 faces are normal to the given velocity component, so receive a no-penetration boundary condition). So there could be a type instability compiling all of those (which have been notoriously fickle to compile in the past). We clearly need to hard code quadratic drag though, because for stretched grids and partial cells (and other types of immersed boundaries in the future) we have to do precompute the logarithm of the grid metrics (to use in a Monin-Obukhov-type model) in each direction independently, as well as the logarithm of the roughness. It's too much for this PR though, so I think we should just document how to specify no-slip on immersed boundaries (which appears to be performant), and add a few tests. Then in a future PR we can add a `QuadraticDrag` utility (I have a prototype for this object; others are welcome to collaborate on implementing the necessary functions to support it).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1104673081
Testability,log,log,"I'm seeing some significant slow down with the boundary condition. ```julia; # Monin-Obukhov drag coefficient; z₀ = 1e-4 # Charnock roughness; κ = 0.4 # Von Karman constant; Cᴰ(Δz) = (κ / log(Δz / 2z₀))^2. @inline bottom_drag_u(x, y, t, u, w, Cᴰ) = - Cᴰ * u * sqrt(u^2 + w^2); @inline bottom_drag_w(x, y, t, u, w, Cᴰ) = - Cᴰ * w * sqrt(u^2 + w^2); @inline bottom_drag_u(x, y, z, t, u, w, Cᴰ) = - Cᴰ * u * sqrt(u^2 + w^2); @inline bottom_drag_w(x, y, z, t, u, w, Cᴰ) = - Cᴰ * w * sqrt(u^2 + w^2). Δz = 1 / Nz; Δx = 2π / Nz; u_drag_bc = FluxBoundaryCondition(bottom_drag_u, field_dependencies=(:u, :w), parameters=Cᴰ(Δz)); w_drag_bc = FluxBoundaryCondition(bottom_drag_w, field_dependencies=(:u, :w), parameters=Cᴰ(Δx)); u_bcs = FieldBoundaryConditions(bottom=u_drag_bc, immersed=u_drag_bc); w_bcs = FieldBoundaryConditions(immersed=w_drag_bc); ```. This is the basic way to implement a quadratic drag from the interface in this PR. In this case what happens under the hood is that we create 4 `ContinuousBoundaryFunction` for the relevant faces of boundary-adjacent cells (the other 2 faces are normal to the given velocity component, so receive a no-penetration boundary condition). So there could be a type instability compiling all of those (which have been notoriously fickle to compile in the past). We clearly need to hard code quadratic drag though, because for stretched grids and partial cells (and other types of immersed boundaries in the future) we have to do precompute the logarithm of the grid metrics (to use in a Monin-Obukhov-type model) in each direction independently, as well as the logarithm of the roughness. It's too much for this PR though, so I think we should just document how to specify no-slip on immersed boundaries (which appears to be performant), and add a few tests. Then in a future PR we can add a `QuadraticDrag` utility (I have a prototype for this object; others are welcome to collaborate on implementing the necessary functions to support it).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1104673081
Usability,clear,clearly,"I'm seeing some significant slow down with the boundary condition. ```julia; # Monin-Obukhov drag coefficient; z₀ = 1e-4 # Charnock roughness; κ = 0.4 # Von Karman constant; Cᴰ(Δz) = (κ / log(Δz / 2z₀))^2. @inline bottom_drag_u(x, y, t, u, w, Cᴰ) = - Cᴰ * u * sqrt(u^2 + w^2); @inline bottom_drag_w(x, y, t, u, w, Cᴰ) = - Cᴰ * w * sqrt(u^2 + w^2); @inline bottom_drag_u(x, y, z, t, u, w, Cᴰ) = - Cᴰ * u * sqrt(u^2 + w^2); @inline bottom_drag_w(x, y, z, t, u, w, Cᴰ) = - Cᴰ * w * sqrt(u^2 + w^2). Δz = 1 / Nz; Δx = 2π / Nz; u_drag_bc = FluxBoundaryCondition(bottom_drag_u, field_dependencies=(:u, :w), parameters=Cᴰ(Δz)); w_drag_bc = FluxBoundaryCondition(bottom_drag_w, field_dependencies=(:u, :w), parameters=Cᴰ(Δx)); u_bcs = FieldBoundaryConditions(bottom=u_drag_bc, immersed=u_drag_bc); w_bcs = FieldBoundaryConditions(immersed=w_drag_bc); ```. This is the basic way to implement a quadratic drag from the interface in this PR. In this case what happens under the hood is that we create 4 `ContinuousBoundaryFunction` for the relevant faces of boundary-adjacent cells (the other 2 faces are normal to the given velocity component, so receive a no-penetration boundary condition). So there could be a type instability compiling all of those (which have been notoriously fickle to compile in the past). We clearly need to hard code quadratic drag though, because for stretched grids and partial cells (and other types of immersed boundaries in the future) we have to do precompute the logarithm of the grid metrics (to use in a Monin-Obukhov-type model) in each direction independently, as well as the logarithm of the roughness. It's too much for this PR though, so I think we should just document how to specify no-slip on immersed boundaries (which appears to be performant), and add a few tests. Then in a future PR we can add a `QuadraticDrag` utility (I have a prototype for this object; others are welcome to collaborate on implementing the necessary functions to support it).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1104673081
Testability,log,logarithm,"> We clearly need to hard code quadratic drag though, because for stretched grids and partial cells (and other types of immersed boundaries in the future) we have to do precompute the logarithm of the grid metrics (to use in a Monin-Obukhov-type model) in each direction independently, as well as the logarithm of the roughness. That's what @whitleyv and I found also on #2275. I agree that may be better left for another PR...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1105075269
Usability,clear,clearly,"> We clearly need to hard code quadratic drag though, because for stretched grids and partial cells (and other types of immersed boundaries in the future) we have to do precompute the logarithm of the grid metrics (to use in a Monin-Obukhov-type model) in each direction independently, as well as the logarithm of the roughness. That's what @whitleyv and I found also on #2275. I agree that may be better left for another PR...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1105075269
Testability,log,logarithm,"> > We clearly need to hard code quadratic drag though, because for stretched grids and partial cells (and other types of immersed boundaries in the future) we have to do precompute the logarithm of the grid metrics (to use in a Monin-Obukhov-type model) in each direction independently, as well as the logarithm of the roughness.; > ; > That's what @whitleyv and I found also on #2275. I agree that may be better left for another PR... Ah, can't you link to the relevant results? It's good to keep track of all this.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1105370240
Usability,clear,clearly,"> > We clearly need to hard code quadratic drag though, because for stretched grids and partial cells (and other types of immersed boundaries in the future) we have to do precompute the logarithm of the grid metrics (to use in a Monin-Obukhov-type model) in each direction independently, as well as the logarithm of the roughness.; > ; > That's what @whitleyv and I found also on #2275. I agree that may be better left for another PR... Ah, can't you link to the relevant results? It's good to keep track of all this.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1105370240
Deployability,update,update,"Also update on correctness / testing: there are now tests that fluxes are correctly imposed:. https://github.com/CliMA/Oceananigans.jl/blob/22739d6a5d410317b0a6fa5cf538ba43dabe16bf/test/test_boundary_conditions_integration.jl#L226-L227. I don't believe there are any simple tests that `Value` / `Gradient` boundary conditions are imposed correctly --- even without an immersed boundary. Instead, we have relied on validation tests to check that. I think it does make sense though to have some tests in that direction... maybe something like a test that 1D couette flow is maintained (for momentum) and that a simple linear tracer gradient is maintained (for tracers). Those would go here: https://github.com/CliMA/Oceananigans.jl/blob/glw/immersed-bcs/test/test_dynamics.jl. Since we don't have that yet we should probably add in another PR. It'd be nice therefore to have a few validation experiments in hand before merging that indicate no-slip ""seems to work"". cc @raphaelouillon",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1105451882
Security,validat,validation,"Also update on correctness / testing: there are now tests that fluxes are correctly imposed:. https://github.com/CliMA/Oceananigans.jl/blob/22739d6a5d410317b0a6fa5cf538ba43dabe16bf/test/test_boundary_conditions_integration.jl#L226-L227. I don't believe there are any simple tests that `Value` / `Gradient` boundary conditions are imposed correctly --- even without an immersed boundary. Instead, we have relied on validation tests to check that. I think it does make sense though to have some tests in that direction... maybe something like a test that 1D couette flow is maintained (for momentum) and that a simple linear tracer gradient is maintained (for tracers). Those would go here: https://github.com/CliMA/Oceananigans.jl/blob/glw/immersed-bcs/test/test_dynamics.jl. Since we don't have that yet we should probably add in another PR. It'd be nice therefore to have a few validation experiments in hand before merging that indicate no-slip ""seems to work"". cc @raphaelouillon",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1105451882
Testability,test,testing,"Also update on correctness / testing: there are now tests that fluxes are correctly imposed:. https://github.com/CliMA/Oceananigans.jl/blob/22739d6a5d410317b0a6fa5cf538ba43dabe16bf/test/test_boundary_conditions_integration.jl#L226-L227. I don't believe there are any simple tests that `Value` / `Gradient` boundary conditions are imposed correctly --- even without an immersed boundary. Instead, we have relied on validation tests to check that. I think it does make sense though to have some tests in that direction... maybe something like a test that 1D couette flow is maintained (for momentum) and that a simple linear tracer gradient is maintained (for tracers). Those would go here: https://github.com/CliMA/Oceananigans.jl/blob/glw/immersed-bcs/test/test_dynamics.jl. Since we don't have that yet we should probably add in another PR. It'd be nice therefore to have a few validation experiments in hand before merging that indicate no-slip ""seems to work"". cc @raphaelouillon",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1105451882
Usability,simpl,simple,"Also update on correctness / testing: there are now tests that fluxes are correctly imposed:. https://github.com/CliMA/Oceananigans.jl/blob/22739d6a5d410317b0a6fa5cf538ba43dabe16bf/test/test_boundary_conditions_integration.jl#L226-L227. I don't believe there are any simple tests that `Value` / `Gradient` boundary conditions are imposed correctly --- even without an immersed boundary. Instead, we have relied on validation tests to check that. I think it does make sense though to have some tests in that direction... maybe something like a test that 1D couette flow is maintained (for momentum) and that a simple linear tracer gradient is maintained (for tracers). Those would go here: https://github.com/CliMA/Oceananigans.jl/blob/glw/immersed-bcs/test/test_dynamics.jl. Since we don't have that yet we should probably add in another PR. It'd be nice therefore to have a few validation experiments in hand before merging that indicate no-slip ""seems to work"". cc @raphaelouillon",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1105451882
Availability,error,error,"> @glwagner I am running into issues when setting up a 3D simulation. I am not sure where the error is coming from but I suspect it comes from a typo in `/Oceananigans/MuMNB/src/Operators/divergence_operators.jl` line 62, where `Ayᵂ ` is defined but not used. Should it be `Ayˢ`?. Nice catch! Thank you!!! Indeed, all the cases I was running were `Flat` in `y` and so I didn't catch that bug. The issue is clear:. https://github.com/CliMA/Oceananigans.jl/blob/22286264ced8707fcdcb3d983b0b53e7f73907d2/src/Operators/divergence_operators.jl#L62-L68. PS you might already know but just in case, here's some tips for github: you can generate a link by browsing the code and clicking on the line number to bring up a prompt:. <img width=""473"" alt=""image"" src=""https://user-images.githubusercontent.com/15271942/164772983-7776dd60-7da0-4371-88b7-0475156f35fb.png"">. when you paste the link in a PR like this one it will show the line:. https://github.com/CliMA/Oceananigans.jl/blob/22286264ced8707fcdcb3d983b0b53e7f73907d2/src/Operators/divergence_operators.jl#L67. In addition, you can actually go into ""Files changed"" on this PR and _suggest_ the change directly: https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/reviewing-changes-in-pull-requests/incorporating-feedback-in-your-pull-request",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1106758714
Usability,clear,clear,"> @glwagner I am running into issues when setting up a 3D simulation. I am not sure where the error is coming from but I suspect it comes from a typo in `/Oceananigans/MuMNB/src/Operators/divergence_operators.jl` line 62, where `Ayᵂ ` is defined but not used. Should it be `Ayˢ`?. Nice catch! Thank you!!! Indeed, all the cases I was running were `Flat` in `y` and so I didn't catch that bug. The issue is clear:. https://github.com/CliMA/Oceananigans.jl/blob/22286264ced8707fcdcb3d983b0b53e7f73907d2/src/Operators/divergence_operators.jl#L62-L68. PS you might already know but just in case, here's some tips for github: you can generate a link by browsing the code and clicking on the line number to bring up a prompt:. <img width=""473"" alt=""image"" src=""https://user-images.githubusercontent.com/15271942/164772983-7776dd60-7da0-4371-88b7-0475156f35fb.png"">. when you paste the link in a PR like this one it will show the line:. https://github.com/CliMA/Oceananigans.jl/blob/22286264ced8707fcdcb3d983b0b53e7f73907d2/src/Operators/divergence_operators.jl#L67. In addition, you can actually go into ""Files changed"" on this PR and _suggest_ the change directly: https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/reviewing-changes-in-pull-requests/incorporating-feedback-in-your-pull-request",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1106758714
Usability,clear,clear,The name seems very clear and I like how this is structured.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2454#issuecomment-1130039874
Integrability,interface,interfaces,"@adelinehillier reports the following optimal values for CATKE to match the LESbrary (these values occur at iteration 10 -- we have to read these off the plots, as we do not have the actual numerical values. But a rough guideline should be good enough):. ![image](https://user-images.githubusercontent.com/15271942/166294013-00a64681-18f7-4abf-a35b-7f7c9b0ed3fb.png). Note that these are optimal values for an _older_ version of CATKE that calculated diffusivities at cell centers:. https://github.com/CliMA/Oceananigans.jl/blob/00c98a72943cfaaa3b034770561b7ed6a408de40/src/TurbulenceClosures/turbulence_closure_implementations/CATKEVerticalDiffusivities/CATKEVerticalDiffusivities.jl#L140-L143. which was the case for Oceananigans v0.74.2. Therefore work still remains to recalibrate CATKE for current numerics, which calculate diffusivities at vertical cell interfaces.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2461#issuecomment-1115142024
Usability,guid,guideline,"@adelinehillier reports the following optimal values for CATKE to match the LESbrary (these values occur at iteration 10 -- we have to read these off the plots, as we do not have the actual numerical values. But a rough guideline should be good enough):. ![image](https://user-images.githubusercontent.com/15271942/166294013-00a64681-18f7-4abf-a35b-7f7c9b0ed3fb.png). Note that these are optimal values for an _older_ version of CATKE that calculated diffusivities at cell centers:. https://github.com/CliMA/Oceananigans.jl/blob/00c98a72943cfaaa3b034770561b7ed6a408de40/src/TurbulenceClosures/turbulence_closure_implementations/CATKEVerticalDiffusivities/CATKEVerticalDiffusivities.jl#L140-L143. which was the case for Oceananigans v0.74.2. Therefore work still remains to recalibrate CATKE for current numerics, which calculate diffusivities at vertical cell interfaces.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2461#issuecomment-1115142024
Usability,simpl,simply,"I see that the two animations are similar, but not exactly the same. I presume the initial condigurations aren't simply rotated by 90 degrees?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1107520465
Security,validat,validation,"Bah sorry @francispoulin I meant to respond to your comment, but accidentally edited instead. Then I tried to delete my edit, but accidentally deleted the original comment! . Anyways... hopefully the info is clear:. The setup is here: https://github.com/CliMA/Oceananigans.jl/blob/glw-as/near-global-one-degree/validation/mesoscale_turbulence/coarse_lat_lon_baroclinic_adjustment.jl. It spans 10 deg from latitude 40-50. In one case the gradient is meridional, in the other, zonal.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1107521777
Usability,clear,clear,"Bah sorry @francispoulin I meant to respond to your comment, but accidentally edited instead. Then I tried to delete my edit, but accidentally deleted the original comment! . Anyways... hopefully the info is clear:. The setup is here: https://github.com/CliMA/Oceananigans.jl/blob/glw-as/near-global-one-degree/validation/mesoscale_turbulence/coarse_lat_lon_baroclinic_adjustment.jl. It spans 10 deg from latitude 40-50. In one case the gradient is meridional, in the other, zonal.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1107521777
Usability,clear,clear,"> > If we all agree, maybe we should add some of that info that I just mentioned to the documentation (ie a statement of purpose for the documentation, and the places to look for other kinds of information). How about that?; > ; > I was about to write that :). But mostly, to elaborate, I think the docs can be ""shaped"" and curated in many ways and still be super useful. What you're proposing is definitely one good way to do it, and I agree especially with your third point. But I think no matter what we decide, we should make that clear somewhere that's relatively easy to find. Following your proposal, we should exclude the references to the PRs and issues and only keep the link to the discussion in this PR. Also we should probably create a discussion for multi-GPUs and link that as well since the distributed discussion that exists rn only focuses on MPI. How does that sounds @glwagner ?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2464#issuecomment-1107245548
Deployability,update,update,"> > > If we all agree, maybe we should add some of that info that I just mentioned to the documentation (ie a statement of purpose for the documentation, and the places to look for other kinds of information). How about that?; > > ; > > ; > > I was about to write that :); > ; > But mostly, to elaborate, I think the docs can be ""shaped"" and curated in many ways and still be super useful. What you're proposing is definitely one good way to do it, and I agree especially with your third point. But I think no matter what we decide, we should make that clear somewhere that's relatively easy to find.; > ; > Following your proposal, we should exclude the references to the PRs and issues and only keep the link to the discussion in this PR. Also we should probably create a discussion for multi-GPUs and link that as well since the distributed discussion that exists rn only focuses on MPI.; > ; > How does that sounds @glwagner ?. That sounds good, except that there's nothing to discuss yet about multi-GPU so we probably don't need to create a discussion about it. I'd also propose not linking to any specific discussions in the docs. The reason is that the discussions are organic and different threads may rise or fall in importance over time. We don't want to have to update the docs when that happens.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2464#issuecomment-1107259562
Usability,clear,clear,"> > > If we all agree, maybe we should add some of that info that I just mentioned to the documentation (ie a statement of purpose for the documentation, and the places to look for other kinds of information). How about that?; > > ; > > ; > > I was about to write that :); > ; > But mostly, to elaborate, I think the docs can be ""shaped"" and curated in many ways and still be super useful. What you're proposing is definitely one good way to do it, and I agree especially with your third point. But I think no matter what we decide, we should make that clear somewhere that's relatively easy to find.; > ; > Following your proposal, we should exclude the references to the PRs and issues and only keep the link to the discussion in this PR. Also we should probably create a discussion for multi-GPUs and link that as well since the distributed discussion that exists rn only focuses on MPI.; > ; > How does that sounds @glwagner ?. That sounds good, except that there's nothing to discuss yet about multi-GPU so we probably don't need to create a discussion about it. I'd also propose not linking to any specific discussions in the docs. The reason is that the discussions are organic and different threads may rise or fall in importance over time. We don't want to have to update the docs when that happens.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2464#issuecomment-1107259562
Availability,down,down,"What drew me down this route is that the discrete continuity equation involves lateral face areas and so these are what show up when the continuity equation is summed up and the boundary condition is applied to arrive at an equation for dt(eta). It's this equation which is then discretized implicitly in time. Perhaps the most important argument is exactly what we are talking about --- the above derivation makes clear that the terms which arise in the implicit eta equation are indeed the barotropic pressure gradient terms (with some further manipulations). So if one can come to another conclusion by the other method, that is a proof that we cannot switch the order of the discretization.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2475#issuecomment-1109709917
Integrability,rout,route,"What drew me down this route is that the discrete continuity equation involves lateral face areas and so these are what show up when the continuity equation is summed up and the boundary condition is applied to arrive at an equation for dt(eta). It's this equation which is then discretized implicitly in time. Perhaps the most important argument is exactly what we are talking about --- the above derivation makes clear that the terms which arise in the implicit eta equation are indeed the barotropic pressure gradient terms (with some further manipulations). So if one can come to another conclusion by the other method, that is a proof that we cannot switch the order of the discretization.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2475#issuecomment-1109709917
Usability,clear,clear,"What drew me down this route is that the discrete continuity equation involves lateral face areas and so these are what show up when the continuity equation is summed up and the boundary condition is applied to arrive at an equation for dt(eta). It's this equation which is then discretized implicitly in time. Perhaps the most important argument is exactly what we are talking about --- the above derivation makes clear that the terms which arise in the implicit eta equation are indeed the barotropic pressure gradient terms (with some further manipulations). So if one can come to another conclusion by the other method, that is a proof that we cannot switch the order of the discretization.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2475#issuecomment-1109709917
Deployability,integrat,integrate,"I wanted to comment on the first step, just to make sure everything is perfectly clear. The x-component of the momentum equation can be written as. `` ; ∂ₜu + g ∂ₓη = Gₓ; ``. The first step of the finite volume method is to integrate over the volume and then divide by the volume. This leads to . ``; ∂ₜū + g/Vfcc ∭ ∂ₓη dV = 1/Vfcc ∭ G_x dV; ``. So far we all agree. If we integrate the term with the free-surface we don't get a line integral, we get a surface integral. Using integration by parts, second integral yields. ``; ∭ ∂ₓη dV = ∬ [ η ]_{west}^{east} dy dz; ``. Line integrals happen from Green's/Stokes' theorems but those begin with area integrals. Unless you are keeping the vertical integral fixed and using Green's theorem on the horizontal integral over the area?. If you wanted to use Green's Theorem in the horizontal, then I believe you would get. ``; ∭ ∂ₓη dV = ∫ [∮ η dy ] dz; ``. I just want to make sure we are being careful and using the right theorem here.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2475#issuecomment-1109830407
Integrability,integrat,integrate,"I wanted to comment on the first step, just to make sure everything is perfectly clear. The x-component of the momentum equation can be written as. `` ; ∂ₜu + g ∂ₓη = Gₓ; ``. The first step of the finite volume method is to integrate over the volume and then divide by the volume. This leads to . ``; ∂ₜū + g/Vfcc ∭ ∂ₓη dV = 1/Vfcc ∭ G_x dV; ``. So far we all agree. If we integrate the term with the free-surface we don't get a line integral, we get a surface integral. Using integration by parts, second integral yields. ``; ∭ ∂ₓη dV = ∬ [ η ]_{west}^{east} dy dz; ``. Line integrals happen from Green's/Stokes' theorems but those begin with area integrals. Unless you are keeping the vertical integral fixed and using Green's theorem on the horizontal integral over the area?. If you wanted to use Green's Theorem in the horizontal, then I believe you would get. ``; ∭ ∂ₓη dV = ∫ [∮ η dy ] dz; ``. I just want to make sure we are being careful and using the right theorem here.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2475#issuecomment-1109830407
Usability,clear,clear,"I wanted to comment on the first step, just to make sure everything is perfectly clear. The x-component of the momentum equation can be written as. `` ; ∂ₜu + g ∂ₓη = Gₓ; ``. The first step of the finite volume method is to integrate over the volume and then divide by the volume. This leads to . ``; ∂ₜū + g/Vfcc ∭ ∂ₓη dV = 1/Vfcc ∭ G_x dV; ``. So far we all agree. If we integrate the term with the free-surface we don't get a line integral, we get a surface integral. Using integration by parts, second integral yields. ``; ∭ ∂ₓη dV = ∬ [ η ]_{west}^{east} dy dz; ``. Line integrals happen from Green's/Stokes' theorems but those begin with area integrals. Unless you are keeping the vertical integral fixed and using Green's theorem on the horizontal integral over the area?. If you wanted to use Green's Theorem in the horizontal, then I believe you would get. ``; ∭ ∂ₓη dV = ∫ [∮ η dy ] dz; ``. I just want to make sure we are being careful and using the right theorem here.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2475#issuecomment-1109830407
Usability,clear,clear,"How about `set!(u, something)` (I'm not sure I was clear about what I asked, sorry about that)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2479#issuecomment-1117371351
Availability,error,error,"Ah yes indeed, sorry I should have specified that the data sets were still usable, I was just confused by the error.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2479#issuecomment-1125115817
Usability,usab,usable,"Ah yes indeed, sorry I should have specified that the data sets were still usable, I was just confused by the error.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2479#issuecomment-1125115817
Usability,clear,clear,"> oh sorry you mean we just didn't register it?. Yes, sorry if that wasn't clear!. I thought registering and tagging could be used interchangeably since the registrator automatically registers _and_ tags a new version, no? I'll try to be more precise with the language in the future",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2484#issuecomment-1111551048
Deployability,release,release,I [paused](https://github.com/JuliaRegistries/General/pull/59278) the release of 0.75.3 when I realised the pinning was not done correctly.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2488#issuecomment-1112090393
Usability,pause,paused,I [paused](https://github.com/JuliaRegistries/General/pull/59278) the release of 0.75.3 when I realised the pinning was not done correctly.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2488#issuecomment-1112090393
Deployability,release,release,"> I [paused](https://github.com/JuliaRegistries/General/pull/59278) the release of 0.75.3 when I realised the pinning was not done correctly. wow, I didn't know you could do that",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2488#issuecomment-1112098203
Usability,pause,paused,"> I [paused](https://github.com/JuliaRegistries/General/pull/59278) the release of 0.75.3 when I realised the pinning was not done correctly. wow, I didn't know you could do that",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2488#issuecomment-1112098203
Usability,clear,clear,@glwagner @christophernhill can we clear this pull request?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1115048138
Usability,learn,learning,"@matinraayai I am just setting up a buildkite CI . Unfortunately I don't know how buildkite works, but learning!!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1115055787
Availability,error,error,"> You're right that it's a little bit misleading. It is not technically a ""divergence damping"", because the actual operator is; > ; > ```; > ∇(ν(∇ ⋅ Δu)); > ```; > ; > So it damps the laplacian of the velocity (here we switched the divergence and the laplacian operators). Thanks! And now I get why this is called biharmonic divergence damping. . We could also write the term as . ``; ∇ ( ν Δ (∇ ⋅ u)); ``. to show that it depends explicitly on the divergence of the velocity. If we ever get a divergence free solver then this would be exactly zero. But the damping occurs here because of the error of the divergence. . Not a problem, but I just wanted to make sure I understand this as I didn't know about this before today. Incidently, we don't have the rotational equivalent that was mentioned before? I presume for that we would just use the Laplacian, which is simpler.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2495#issuecomment-1112559461
Integrability,depend,depends,"> You're right that it's a little bit misleading. It is not technically a ""divergence damping"", because the actual operator is; > ; > ```; > ∇(ν(∇ ⋅ Δu)); > ```; > ; > So it damps the laplacian of the velocity (here we switched the divergence and the laplacian operators). Thanks! And now I get why this is called biharmonic divergence damping. . We could also write the term as . ``; ∇ ( ν Δ (∇ ⋅ u)); ``. to show that it depends explicitly on the divergence of the velocity. If we ever get a divergence free solver then this would be exactly zero. But the damping occurs here because of the error of the divergence. . Not a problem, but I just wanted to make sure I understand this as I didn't know about this before today. Incidently, we don't have the rotational equivalent that was mentioned before? I presume for that we would just use the Laplacian, which is simpler.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2495#issuecomment-1112559461
Usability,simpl,simpler,"> You're right that it's a little bit misleading. It is not technically a ""divergence damping"", because the actual operator is; > ; > ```; > ∇(ν(∇ ⋅ Δu)); > ```; > ; > So it damps the laplacian of the velocity (here we switched the divergence and the laplacian operators). Thanks! And now I get why this is called biharmonic divergence damping. . We could also write the term as . ``; ∇ ( ν Δ (∇ ⋅ u)); ``. to show that it depends explicitly on the divergence of the velocity. If we ever get a divergence free solver then this would be exactly zero. But the damping occurs here because of the error of the divergence. . Not a problem, but I just wanted to make sure I understand this as I didn't know about this before today. Incidently, we don't have the rotational equivalent that was mentioned before? I presume for that we would just use the Laplacian, which is simpler.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2495#issuecomment-1112559461
Integrability,wrap,wrapped,"https://github.com/CliMA/Oceananigans.jl/pull/2502/commits/75f423d276352ecf96d845a64e46578b7f7a3a7d adds a method that allows us to broadcast with windowed fields. GPUArrays / CUDA include utilities for ""one-level"" wrapped arrays, ie `SubArray` / `view` of `CuArray`. But they do not include utilities for `OffsetArray` of GPU array (or heaven forbid, `OffsetArray` of `SubArray` of `CuArray`). So that commit supports experimental syntax for broadcasting with ""windowed fields"" which are created by `view`. It might only work with 3D windows (ie if a field is _not_ windowed in some direction it won't have expected behavior). But I think that experimental support is ok for now since it simplifies our tests...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2502#issuecomment-1114900588
Testability,test,tests,"https://github.com/CliMA/Oceananigans.jl/pull/2502/commits/75f423d276352ecf96d845a64e46578b7f7a3a7d adds a method that allows us to broadcast with windowed fields. GPUArrays / CUDA include utilities for ""one-level"" wrapped arrays, ie `SubArray` / `view` of `CuArray`. But they do not include utilities for `OffsetArray` of GPU array (or heaven forbid, `OffsetArray` of `SubArray` of `CuArray`). So that commit supports experimental syntax for broadcasting with ""windowed fields"" which are created by `view`. It might only work with 3D windows (ie if a field is _not_ windowed in some direction it won't have expected behavior). But I think that experimental support is ok for now since it simplifies our tests...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2502#issuecomment-1114900588
Usability,simpl,simplifies,"https://github.com/CliMA/Oceananigans.jl/pull/2502/commits/75f423d276352ecf96d845a64e46578b7f7a3a7d adds a method that allows us to broadcast with windowed fields. GPUArrays / CUDA include utilities for ""one-level"" wrapped arrays, ie `SubArray` / `view` of `CuArray`. But they do not include utilities for `OffsetArray` of GPU array (or heaven forbid, `OffsetArray` of `SubArray` of `CuArray`). So that commit supports experimental syntax for broadcasting with ""windowed fields"" which are created by `view`. It might only work with 3D windows (ie if a field is _not_ windowed in some direction it won't have expected behavior). But I think that experimental support is ok for now since it simplifies our tests...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2502#issuecomment-1114900588
Availability,down,down,"@iuryt you're right, the environment here is really amazing! . I will think and write down some FV discretisation equations by the time we zoom in. I'm not the best person to talk on how we should implement it in Oceananigans in terms of using z-coordinate as different levels, but it seems like a great and innovative idea. . Perhaps I'm asking a silly question but it's not clear to me that the equations I've written up (and I'll double check this with someone else too) seems to consider varying bathymetry, and I'm not sure if Oceananigans explicitly models bathymetry by adding a pressure gradient, and whether we would be double counting the effects of bathymetry using the equations I shared above. I agree with @francispoulin, maybe it doesn't matter much whether we use density or buoyancy as our vertical coordinate. I do like the idea of using buoyancy instead of density, but that's just a personal preference.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1117301031
Usability,clear,clear,"@iuryt you're right, the environment here is really amazing! . I will think and write down some FV discretisation equations by the time we zoom in. I'm not the best person to talk on how we should implement it in Oceananigans in terms of using z-coordinate as different levels, but it seems like a great and innovative idea. . Perhaps I'm asking a silly question but it's not clear to me that the equations I've written up (and I'll double check this with someone else too) seems to consider varying bathymetry, and I'm not sure if Oceananigans explicitly models bathymetry by adding a pressure gradient, and whether we would be double counting the effects of bathymetry using the equations I shared above. I agree with @francispoulin, maybe it doesn't matter much whether we use density or buoyancy as our vertical coordinate. I do like the idea of using buoyancy instead of density, but that's just a personal preference.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1117301031
Energy Efficiency,reduce,reduced,"The notes look great! . One question though. In your definition for the reduced gravity, why not divide by $\rho_j$ instead of $\rho_{j+1}$, since that's what naturally apprears in the pressure graident term? I know that because the densities are almsot the same, it won't matter much, but it is not clear why you make this approximation when you don't need to.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1146884348
Usability,clear,clear,"The notes look great! . One question though. In your definition for the reduced gravity, why not divide by $\rho_j$ instead of $\rho_{j+1}$, since that's what naturally apprears in the pressure graident term? I know that because the densities are almsot the same, it won't matter much, but it is not clear why you make this approximation when you don't need to.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1146884348
Integrability,wrap,wrapped,"It's out of bounds because the indices of. > 1×2×10 view. are 1:1, 1:2, and 1:10. If you create a windowed `Field`, then `Field.data` is double-wrapped:. * `field.data` is an _OffsetArray_; * `parent(field.data)` is a `SubArray` (the thing that's created by `view`). Both of them have indices. `field.data` has ""global"" indices, or the indices of `field.grid`. But `field.data.parent` has ""simple"" indices, ie `1:1, 1:2, 1:10` in your case. Hopefully studying this code will help:. https://github.com/CliMA/Oceananigans.jl/blob/f1cd43fbfbb5520122f75b2d3fea84f43b4a22e5/src/Fields/field.jl#L271-L293. `offset_windowed_data` creates an `OffsetArray` (with global indices) around ""windowed data"", ie a `view` of the underlying array:. https://github.com/CliMA/Oceananigans.jl/blob/f1cd43fbfbb5520122f75b2d3fea84f43b4a22e5/src/Fields/field.jl#L217-L230. `offset_data` is here:. https://github.com/CliMA/Oceananigans.jl/blob/f1cd43fbfbb5520122f75b2d3fea84f43b4a22e5/src/Grids/new_data.jl#L33-L38",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1116283706
Usability,simpl,simple,"It's out of bounds because the indices of. > 1×2×10 view. are 1:1, 1:2, and 1:10. If you create a windowed `Field`, then `Field.data` is double-wrapped:. * `field.data` is an _OffsetArray_; * `parent(field.data)` is a `SubArray` (the thing that's created by `view`). Both of them have indices. `field.data` has ""global"" indices, or the indices of `field.grid`. But `field.data.parent` has ""simple"" indices, ie `1:1, 1:2, 1:10` in your case. Hopefully studying this code will help:. https://github.com/CliMA/Oceananigans.jl/blob/f1cd43fbfbb5520122f75b2d3fea84f43b4a22e5/src/Fields/field.jl#L271-L293. `offset_windowed_data` creates an `OffsetArray` (with global indices) around ""windowed data"", ie a `view` of the underlying array:. https://github.com/CliMA/Oceananigans.jl/blob/f1cd43fbfbb5520122f75b2d3fea84f43b4a22e5/src/Fields/field.jl#L217-L230. `offset_data` is here:. https://github.com/CliMA/Oceananigans.jl/blob/f1cd43fbfbb5520122f75b2d3fea84f43b4a22e5/src/Grids/new_data.jl#L33-L38",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1116283706
Availability,error,error,"Let's review what we want to support here:. 1. `user_output` is an AbstractOperation or a Reduction. Therefore it has no indices, and we can allocate only the data we need for output. Easy and supported prior to this PR.; 2. `user_output` is pre-allocated `Field` with full indices. We compute the output indices given `user_indices` and `with_halo` (this is what we supported previously), and then construct a `view(field, indices...)`. Supported prior to this PR.; 3. `user_output` is a pre-allocated `Field` with _non-default indices_. This case is tricker, because there are several possible scenarios:; - `user_output` is a view over a full field (aka `WindowedField`). In this case, we can in principle re-index at will, since we have access to the full underlying data.; - `user_output` is a ""partial field"" with data that covers only part of the grid. In this case, not all indices are valid. We don't have any infrastructure for constructing views into ""partial fields"" in the code right now. This is probably the source of the error we are seeing. I guess the simplest solution is just to ignore ""output writer indices"" for fields that have non-default indices. And this is the first solution discussed on this PR... but then we can't respect the argument `with_halos`. To respect `with_halos` it looks to me like we need more infrastructure for calculating index intersections. For example, we have to be able to deduce that a field with already-chopped halos should not have their indices ""re-chopped"". `parent_index_range` as written knows nothing about ""partial fields"" with non-standard parent indices.; It's certainly possible to support this and probably just a little careful arithmetic to get it right. Doesn't seem super high priority though...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1127145178
Energy Efficiency,allocate,allocate,"Let's review what we want to support here:. 1. `user_output` is an AbstractOperation or a Reduction. Therefore it has no indices, and we can allocate only the data we need for output. Easy and supported prior to this PR.; 2. `user_output` is pre-allocated `Field` with full indices. We compute the output indices given `user_indices` and `with_halo` (this is what we supported previously), and then construct a `view(field, indices...)`. Supported prior to this PR.; 3. `user_output` is a pre-allocated `Field` with _non-default indices_. This case is tricker, because there are several possible scenarios:; - `user_output` is a view over a full field (aka `WindowedField`). In this case, we can in principle re-index at will, since we have access to the full underlying data.; - `user_output` is a ""partial field"" with data that covers only part of the grid. In this case, not all indices are valid. We don't have any infrastructure for constructing views into ""partial fields"" in the code right now. This is probably the source of the error we are seeing. I guess the simplest solution is just to ignore ""output writer indices"" for fields that have non-default indices. And this is the first solution discussed on this PR... but then we can't respect the argument `with_halos`. To respect `with_halos` it looks to me like we need more infrastructure for calculating index intersections. For example, we have to be able to deduce that a field with already-chopped halos should not have their indices ""re-chopped"". `parent_index_range` as written knows nothing about ""partial fields"" with non-standard parent indices.; It's certainly possible to support this and probably just a little careful arithmetic to get it right. Doesn't seem super high priority though...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1127145178
Security,access,access,"Let's review what we want to support here:. 1. `user_output` is an AbstractOperation or a Reduction. Therefore it has no indices, and we can allocate only the data we need for output. Easy and supported prior to this PR.; 2. `user_output` is pre-allocated `Field` with full indices. We compute the output indices given `user_indices` and `with_halo` (this is what we supported previously), and then construct a `view(field, indices...)`. Supported prior to this PR.; 3. `user_output` is a pre-allocated `Field` with _non-default indices_. This case is tricker, because there are several possible scenarios:; - `user_output` is a view over a full field (aka `WindowedField`). In this case, we can in principle re-index at will, since we have access to the full underlying data.; - `user_output` is a ""partial field"" with data that covers only part of the grid. In this case, not all indices are valid. We don't have any infrastructure for constructing views into ""partial fields"" in the code right now. This is probably the source of the error we are seeing. I guess the simplest solution is just to ignore ""output writer indices"" for fields that have non-default indices. And this is the first solution discussed on this PR... but then we can't respect the argument `with_halos`. To respect `with_halos` it looks to me like we need more infrastructure for calculating index intersections. For example, we have to be able to deduce that a field with already-chopped halos should not have their indices ""re-chopped"". `parent_index_range` as written knows nothing about ""partial fields"" with non-standard parent indices.; It's certainly possible to support this and probably just a little careful arithmetic to get it right. Doesn't seem super high priority though...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1127145178
Usability,simpl,simplest,"Let's review what we want to support here:. 1. `user_output` is an AbstractOperation or a Reduction. Therefore it has no indices, and we can allocate only the data we need for output. Easy and supported prior to this PR.; 2. `user_output` is pre-allocated `Field` with full indices. We compute the output indices given `user_indices` and `with_halo` (this is what we supported previously), and then construct a `view(field, indices...)`. Supported prior to this PR.; 3. `user_output` is a pre-allocated `Field` with _non-default indices_. This case is tricker, because there are several possible scenarios:; - `user_output` is a view over a full field (aka `WindowedField`). In this case, we can in principle re-index at will, since we have access to the full underlying data.; - `user_output` is a ""partial field"" with data that covers only part of the grid. In this case, not all indices are valid. We don't have any infrastructure for constructing views into ""partial fields"" in the code right now. This is probably the source of the error we are seeing. I guess the simplest solution is just to ignore ""output writer indices"" for fields that have non-default indices. And this is the first solution discussed on this PR... but then we can't respect the argument `with_halos`. To respect `with_halos` it looks to me like we need more infrastructure for calculating index intersections. For example, we have to be able to deduce that a field with already-chopped halos should not have their indices ""re-chopped"". `parent_index_range` as written knows nothing about ""partial fields"" with non-standard parent indices.; It's certainly possible to support this and probably just a little careful arithmetic to get it right. Doesn't seem super high priority though...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1127145178
Usability,simpl,simplest,"> I guess the simplest solution is just to ignore ""output writer indices"" for fields that have non-default indices. And this is the first solution discussed on this PR... but then we can't respect the argument `with_halos`.; > ; > To respect `with_halos` it looks to me like we need more infrastructure for calculating index intersections. For example, we have to be able to deduce that a field with already-chopped halos should not have their indices ""re-chopped"". `parent_index_range` as written knows nothing about ""partial fields"" with non-standard parent indices. It's certainly possible to support this and probably just a little careful arithmetic to get it right. Doesn't seem super high priority though... I'm good with both options for `with_halo`. IMO the only important thing is for this PR is to support the output of sliced `Field`s. It definitely would be nice to also support `with_halos`, but given how tricky it can be and the low priority, I'm definitely okay merging this without `with_halo` support for sliced fields. I'll leave the call up to you.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1127152305
Energy Efficiency,allocate,allocate,"This sounds interesting but I'm not sure if I complete understand. . Can we think of an example of a prognistic field as velocity: `𝐯`, and a diagnostic field as vorticity: ζ?. If yes, I see that you need to fill halos to evolve the velocity and then you need to fill halos when you compute the vorticity. Are you simply saying we allocate the space for the two sets of halos at the same time?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2509#issuecomment-1116396860
Modifiability,evolve,evolve,"This sounds interesting but I'm not sure if I complete understand. . Can we think of an example of a prognistic field as velocity: `𝐯`, and a diagnostic field as vorticity: ζ?. If yes, I see that you need to fill halos to evolve the velocity and then you need to fill halos when you compute the vorticity. Are you simply saying we allocate the space for the two sets of halos at the same time?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2509#issuecomment-1116396860
Usability,simpl,simply,"This sounds interesting but I'm not sure if I complete understand. . Can we think of an example of a prognistic field as velocity: `𝐯`, and a diagnostic field as vorticity: ζ?. If yes, I see that you need to fill halos to evolve the velocity and then you need to fill halos when you compute the vorticity. Are you simply saying we allocate the space for the two sets of halos at the same time?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2509#issuecomment-1116396860
Modifiability,parameteriz,parameterized,"I draft a repo on this matter [here](https://github.com/iuryt/Bioceananigans.jl).; I tried to summarize my ideas in the README:. > Most of the interelationships between biogeochemical tracers could be implemented using the **forcing functions** (see [Convecting Plankton](https://clima.github.io/OceananigansDocumentation/stable/generated/convecting_plankton/) example from Oceananigans documentation), but commonly the light or light-limiting growth of the phytoplankton are **averaged over the mixed layer** in order to parameterized the effects of the mixing in the upper boundary layer. In other words, the mixing timescale is usually longer than photosynthesis, but shorter than cell-division time, which makes phytoplankton **see the average light or grow at the average light-limiting growth rate** while on the mixed layer. Other example of processes that are not easily implemented on Oceananigans include the **shading of phytoplankton** to deeper layers and the **sinking velocity**. The latter is currently being implemented on Oceananigans by this [Pull Request](https://github.com/CliMA/Oceananigans.jl/pull/2389) with a new forcing called `AdvectiveForcing`.; > ; > For now, this repository basically gives a set of modules that can be used to estimate the mixed-layer depth, estimate the phytoplankton shading and calculate the light-limiting growth, which is defined by the user as a function, and then the light (or the light-limiting growth) can be averaged over the mixed layer. So basically the repository can simply give all auxiliary functions that are needed for the biogeochemical models, but not the interelationship functions, which can be defined as forcing functions and added to a list of examples on the documentation. I don't mind giving up this repository and merging or adding it to the organization if this is somehow a good starting point.; I am also interested in seeing what the others think about that.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2512#issuecomment-1116856781
Usability,simpl,simply,"I draft a repo on this matter [here](https://github.com/iuryt/Bioceananigans.jl).; I tried to summarize my ideas in the README:. > Most of the interelationships between biogeochemical tracers could be implemented using the **forcing functions** (see [Convecting Plankton](https://clima.github.io/OceananigansDocumentation/stable/generated/convecting_plankton/) example from Oceananigans documentation), but commonly the light or light-limiting growth of the phytoplankton are **averaged over the mixed layer** in order to parameterized the effects of the mixing in the upper boundary layer. In other words, the mixing timescale is usually longer than photosynthesis, but shorter than cell-division time, which makes phytoplankton **see the average light or grow at the average light-limiting growth rate** while on the mixed layer. Other example of processes that are not easily implemented on Oceananigans include the **shading of phytoplankton** to deeper layers and the **sinking velocity**. The latter is currently being implemented on Oceananigans by this [Pull Request](https://github.com/CliMA/Oceananigans.jl/pull/2389) with a new forcing called `AdvectiveForcing`.; > ; > For now, this repository basically gives a set of modules that can be used to estimate the mixed-layer depth, estimate the phytoplankton shading and calculate the light-limiting growth, which is defined by the user as a function, and then the light (or the light-limiting growth) can be averaged over the mixed layer. So basically the repository can simply give all auxiliary functions that are needed for the biogeochemical models, but not the interelationship functions, which can be defined as forcing functions and added to a list of examples on the documentation. I don't mind giving up this repository and merging or adding it to the organization if this is somehow a good starting point.; I am also interested in seeing what the others think about that.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2512#issuecomment-1116856781
Deployability,integrat,integration,"> > The more the merrier! Contributors are generally welcome on our end too. Links @christophernhill in his comment were broken. So just in case:; > > ; > > * [JOSS issue (accepted)](https://github.com/openjournals/joss-reviews/issues/4207), [paper (proofs)](https://github.com/openjournals/joss-papers/blob/joss.04207/joss.04207/10.21105.joss.04207.pdf); > > * [Github repo (JuliaOcean)](https://github.com/JuliaOcean/PlanktonIndividuals.jl); > > ; > > _PlanktonIndividuals.jl: A GPU supported individual-based phytoplankton life cycle model_; > ; > @gaelforget it looks like you might have some Oceananigans examples which is super cool!! Can you point to them for us? Have you considered expanding to ""online"" capabilities? What are the pros and cons of that?. The two models we currently have some support for (offline) are `MITgcm` and `oceananigans.jl`. . I have examples for both models in <https://gaelforget.github.io/ClimateModels.jl/dev/examples/> which you can run the JuliaClimate sandbox <https://juliaclimate.github.io/Notebooks/> and generate the kind of model output that `PlanktonIndividuals.jl` or `IndividualDisplacement.jl` can then ingest as input for offline computation. The `PlanktonIndividuals.jl` documentation has corresponding examples on the ecology + bgc side. An online mode with models like `MITgcm` and `oceananigans.jl` would be useful in my view, in the case of both `PlanktonIndividuals.jl` or `IndividualDisplacement.jl`. With this being said, I tend to most like the idea of small'ish modeling components developed outside of monolitic modeling efforts that emphasize code re-usability and integration with multiple models. . For completeness, here is the reference to the JOSS paper on [IndividualDisplacement.jl](https://joss.theoj.org/papers/10.21105/joss.02813) -- https://joss.theoj.org/papers/10.21105/joss.02813.pdf -- and the [GitHub repo](https://github.com/JuliaClimate/IndividualDisplacements.jl)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2512#issuecomment-1117637509
Integrability,integrat,integration,"> > The more the merrier! Contributors are generally welcome on our end too. Links @christophernhill in his comment were broken. So just in case:; > > ; > > * [JOSS issue (accepted)](https://github.com/openjournals/joss-reviews/issues/4207), [paper (proofs)](https://github.com/openjournals/joss-papers/blob/joss.04207/joss.04207/10.21105.joss.04207.pdf); > > * [Github repo (JuliaOcean)](https://github.com/JuliaOcean/PlanktonIndividuals.jl); > > ; > > _PlanktonIndividuals.jl: A GPU supported individual-based phytoplankton life cycle model_; > ; > @gaelforget it looks like you might have some Oceananigans examples which is super cool!! Can you point to them for us? Have you considered expanding to ""online"" capabilities? What are the pros and cons of that?. The two models we currently have some support for (offline) are `MITgcm` and `oceananigans.jl`. . I have examples for both models in <https://gaelforget.github.io/ClimateModels.jl/dev/examples/> which you can run the JuliaClimate sandbox <https://juliaclimate.github.io/Notebooks/> and generate the kind of model output that `PlanktonIndividuals.jl` or `IndividualDisplacement.jl` can then ingest as input for offline computation. The `PlanktonIndividuals.jl` documentation has corresponding examples on the ecology + bgc side. An online mode with models like `MITgcm` and `oceananigans.jl` would be useful in my view, in the case of both `PlanktonIndividuals.jl` or `IndividualDisplacement.jl`. With this being said, I tend to most like the idea of small'ish modeling components developed outside of monolitic modeling efforts that emphasize code re-usability and integration with multiple models. . For completeness, here is the reference to the JOSS paper on [IndividualDisplacement.jl](https://joss.theoj.org/papers/10.21105/joss.02813) -- https://joss.theoj.org/papers/10.21105/joss.02813.pdf -- and the [GitHub repo](https://github.com/JuliaClimate/IndividualDisplacements.jl)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2512#issuecomment-1117637509
Modifiability,sandbox,sandbox,"> > The more the merrier! Contributors are generally welcome on our end too. Links @christophernhill in his comment were broken. So just in case:; > > ; > > * [JOSS issue (accepted)](https://github.com/openjournals/joss-reviews/issues/4207), [paper (proofs)](https://github.com/openjournals/joss-papers/blob/joss.04207/joss.04207/10.21105.joss.04207.pdf); > > * [Github repo (JuliaOcean)](https://github.com/JuliaOcean/PlanktonIndividuals.jl); > > ; > > _PlanktonIndividuals.jl: A GPU supported individual-based phytoplankton life cycle model_; > ; > @gaelforget it looks like you might have some Oceananigans examples which is super cool!! Can you point to them for us? Have you considered expanding to ""online"" capabilities? What are the pros and cons of that?. The two models we currently have some support for (offline) are `MITgcm` and `oceananigans.jl`. . I have examples for both models in <https://gaelforget.github.io/ClimateModels.jl/dev/examples/> which you can run the JuliaClimate sandbox <https://juliaclimate.github.io/Notebooks/> and generate the kind of model output that `PlanktonIndividuals.jl` or `IndividualDisplacement.jl` can then ingest as input for offline computation. The `PlanktonIndividuals.jl` documentation has corresponding examples on the ecology + bgc side. An online mode with models like `MITgcm` and `oceananigans.jl` would be useful in my view, in the case of both `PlanktonIndividuals.jl` or `IndividualDisplacement.jl`. With this being said, I tend to most like the idea of small'ish modeling components developed outside of monolitic modeling efforts that emphasize code re-usability and integration with multiple models. . For completeness, here is the reference to the JOSS paper on [IndividualDisplacement.jl](https://joss.theoj.org/papers/10.21105/joss.02813) -- https://joss.theoj.org/papers/10.21105/joss.02813.pdf -- and the [GitHub repo](https://github.com/JuliaClimate/IndividualDisplacements.jl)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2512#issuecomment-1117637509
Testability,sandbox,sandbox,"> > The more the merrier! Contributors are generally welcome on our end too. Links @christophernhill in his comment were broken. So just in case:; > > ; > > * [JOSS issue (accepted)](https://github.com/openjournals/joss-reviews/issues/4207), [paper (proofs)](https://github.com/openjournals/joss-papers/blob/joss.04207/joss.04207/10.21105.joss.04207.pdf); > > * [Github repo (JuliaOcean)](https://github.com/JuliaOcean/PlanktonIndividuals.jl); > > ; > > _PlanktonIndividuals.jl: A GPU supported individual-based phytoplankton life cycle model_; > ; > @gaelforget it looks like you might have some Oceananigans examples which is super cool!! Can you point to them for us? Have you considered expanding to ""online"" capabilities? What are the pros and cons of that?. The two models we currently have some support for (offline) are `MITgcm` and `oceananigans.jl`. . I have examples for both models in <https://gaelforget.github.io/ClimateModels.jl/dev/examples/> which you can run the JuliaClimate sandbox <https://juliaclimate.github.io/Notebooks/> and generate the kind of model output that `PlanktonIndividuals.jl` or `IndividualDisplacement.jl` can then ingest as input for offline computation. The `PlanktonIndividuals.jl` documentation has corresponding examples on the ecology + bgc side. An online mode with models like `MITgcm` and `oceananigans.jl` would be useful in my view, in the case of both `PlanktonIndividuals.jl` or `IndividualDisplacement.jl`. With this being said, I tend to most like the idea of small'ish modeling components developed outside of monolitic modeling efforts that emphasize code re-usability and integration with multiple models. . For completeness, here is the reference to the JOSS paper on [IndividualDisplacement.jl](https://joss.theoj.org/papers/10.21105/joss.02813) -- https://joss.theoj.org/papers/10.21105/joss.02813.pdf -- and the [GitHub repo](https://github.com/JuliaClimate/IndividualDisplacements.jl)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2512#issuecomment-1117637509
Usability,usab,usability,"> > The more the merrier! Contributors are generally welcome on our end too. Links @christophernhill in his comment were broken. So just in case:; > > ; > > * [JOSS issue (accepted)](https://github.com/openjournals/joss-reviews/issues/4207), [paper (proofs)](https://github.com/openjournals/joss-papers/blob/joss.04207/joss.04207/10.21105.joss.04207.pdf); > > * [Github repo (JuliaOcean)](https://github.com/JuliaOcean/PlanktonIndividuals.jl); > > ; > > _PlanktonIndividuals.jl: A GPU supported individual-based phytoplankton life cycle model_; > ; > @gaelforget it looks like you might have some Oceananigans examples which is super cool!! Can you point to them for us? Have you considered expanding to ""online"" capabilities? What are the pros and cons of that?. The two models we currently have some support for (offline) are `MITgcm` and `oceananigans.jl`. . I have examples for both models in <https://gaelforget.github.io/ClimateModels.jl/dev/examples/> which you can run the JuliaClimate sandbox <https://juliaclimate.github.io/Notebooks/> and generate the kind of model output that `PlanktonIndividuals.jl` or `IndividualDisplacement.jl` can then ingest as input for offline computation. The `PlanktonIndividuals.jl` documentation has corresponding examples on the ecology + bgc side. An online mode with models like `MITgcm` and `oceananigans.jl` would be useful in my view, in the case of both `PlanktonIndividuals.jl` or `IndividualDisplacement.jl`. With this being said, I tend to most like the idea of small'ish modeling components developed outside of monolitic modeling efforts that emphasize code re-usability and integration with multiple models. . For completeness, here is the reference to the JOSS paper on [IndividualDisplacement.jl](https://joss.theoj.org/papers/10.21105/joss.02813) -- https://joss.theoj.org/papers/10.21105/joss.02813.pdf -- and the [GitHub repo](https://github.com/JuliaClimate/IndividualDisplacements.jl)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2512#issuecomment-1117637509
Energy Efficiency,reduce,reduce,"> @glwagner : I agree that the major savings would be the lack of vertical grid points, but having a full free-surface will likely force a smaller time step because of CFL. There would be two ways to reduce this constraint (in the future).; > ; > 1. Rigid lid (solve for the surface pressure); > 2. Implicit free-surface (treat the free-surface implicitly in the time-stepping); > ; > Both of these would borrow from the hydrostatic model, but the ingrediants are there, and would make it a lot faster. I would vote for implementing a rigid lid / vertically-`Flat` mode for the hydrostatic model instead, in order to keep the shallow water model as simple as possible (generalizing to multiple layers as an alternative direction would be nice I think). Have you benchmarked this? It is true that vertically `Flat` avoids a few vertical operations in the vertical advection term but since the kernel sizes are the same I'd be surprised if the performance differences are huge in terms of cost per time step.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119195736
Modifiability,layers,layers,"> @glwagner : I agree that the major savings would be the lack of vertical grid points, but having a full free-surface will likely force a smaller time step because of CFL. There would be two ways to reduce this constraint (in the future).; > ; > 1. Rigid lid (solve for the surface pressure); > 2. Implicit free-surface (treat the free-surface implicitly in the time-stepping); > ; > Both of these would borrow from the hydrostatic model, but the ingrediants are there, and would make it a lot faster. I would vote for implementing a rigid lid / vertically-`Flat` mode for the hydrostatic model instead, in order to keep the shallow water model as simple as possible (generalizing to multiple layers as an alternative direction would be nice I think). Have you benchmarked this? It is true that vertically `Flat` avoids a few vertical operations in the vertical advection term but since the kernel sizes are the same I'd be surprised if the performance differences are huge in terms of cost per time step.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119195736
Performance,perform,performance,"> @glwagner : I agree that the major savings would be the lack of vertical grid points, but having a full free-surface will likely force a smaller time step because of CFL. There would be two ways to reduce this constraint (in the future).; > ; > 1. Rigid lid (solve for the surface pressure); > 2. Implicit free-surface (treat the free-surface implicitly in the time-stepping); > ; > Both of these would borrow from the hydrostatic model, but the ingrediants are there, and would make it a lot faster. I would vote for implementing a rigid lid / vertically-`Flat` mode for the hydrostatic model instead, in order to keep the shallow water model as simple as possible (generalizing to multiple layers as an alternative direction would be nice I think). Have you benchmarked this? It is true that vertically `Flat` avoids a few vertical operations in the vertical advection term but since the kernel sizes are the same I'd be surprised if the performance differences are huge in terms of cost per time step.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119195736
Safety,avoid,avoids,"> @glwagner : I agree that the major savings would be the lack of vertical grid points, but having a full free-surface will likely force a smaller time step because of CFL. There would be two ways to reduce this constraint (in the future).; > ; > 1. Rigid lid (solve for the surface pressure); > 2. Implicit free-surface (treat the free-surface implicitly in the time-stepping); > ; > Both of these would borrow from the hydrostatic model, but the ingrediants are there, and would make it a lot faster. I would vote for implementing a rigid lid / vertically-`Flat` mode for the hydrostatic model instead, in order to keep the shallow water model as simple as possible (generalizing to multiple layers as an alternative direction would be nice I think). Have you benchmarked this? It is true that vertically `Flat` avoids a few vertical operations in the vertical advection term but since the kernel sizes are the same I'd be surprised if the performance differences are huge in terms of cost per time step.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119195736
Testability,benchmark,benchmarked,"> @glwagner : I agree that the major savings would be the lack of vertical grid points, but having a full free-surface will likely force a smaller time step because of CFL. There would be two ways to reduce this constraint (in the future).; > ; > 1. Rigid lid (solve for the surface pressure); > 2. Implicit free-surface (treat the free-surface implicitly in the time-stepping); > ; > Both of these would borrow from the hydrostatic model, but the ingrediants are there, and would make it a lot faster. I would vote for implementing a rigid lid / vertically-`Flat` mode for the hydrostatic model instead, in order to keep the shallow water model as simple as possible (generalizing to multiple layers as an alternative direction would be nice I think). Have you benchmarked this? It is true that vertically `Flat` avoids a few vertical operations in the vertical advection term but since the kernel sizes are the same I'd be surprised if the performance differences are huge in terms of cost per time step.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119195736
Usability,simpl,simple,"> @glwagner : I agree that the major savings would be the lack of vertical grid points, but having a full free-surface will likely force a smaller time step because of CFL. There would be two ways to reduce this constraint (in the future).; > ; > 1. Rigid lid (solve for the surface pressure); > 2. Implicit free-surface (treat the free-surface implicitly in the time-stepping); > ; > Both of these would borrow from the hydrostatic model, but the ingrediants are there, and would make it a lot faster. I would vote for implementing a rigid lid / vertically-`Flat` mode for the hydrostatic model instead, in order to keep the shallow water model as simple as possible (generalizing to multiple layers as an alternative direction would be nice I think). Have you benchmarked this? It is true that vertically `Flat` avoids a few vertical operations in the vertical advection term but since the kernel sizes are the same I'd be surprised if the performance differences are huge in terms of cost per time step.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119195736
Energy Efficiency,reduce,reduce,"@simone-silvestri : if you wanted to reproduce something like what you did in the one-degree simulations, with a simple closure scheme, we could try this, ; ```; ∇⋅(ν∇⃗ u⃗); ```; which in the case of constant viscosity we have the regular Laplacian. By the same rights you could also as in biharmonic viscoisty in a similar way. In the future I think it would be better to have something like this, . ```; 1/h ∇⋅(ν h ∇⃗ u⃗); ```. since it ensures that viscosity will always reduce the visocisty but I think this is harder to apply in a finite volume formulation because of the function in front. Best saved for a future PR.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119857936
Usability,simpl,simple,"@simone-silvestri : if you wanted to reproduce something like what you did in the one-degree simulations, with a simple closure scheme, we could try this, ; ```; ∇⋅(ν∇⃗ u⃗); ```; which in the case of constant viscosity we have the regular Laplacian. By the same rights you could also as in biharmonic viscoisty in a similar way. In the future I think it would be better to have something like this, . ```; 1/h ∇⋅(ν h ∇⃗ u⃗); ```. since it ensures that viscosity will always reduce the visocisty but I think this is harder to apply in a finite volume formulation because of the function in front. Best saved for a future PR.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119857936
Energy Efficiency,reduce,reduce,"> @simone-silvestri : if you wanted to reproduce something like what you did in the one-degree simulations, with a simple closure scheme, we could try this,; > ; > ```; > ∇⋅(ν∇⃗ u⃗); > ```; > ; > which in the case of constant viscosity we have the regular Laplacian. By the same rights you could also as in biharmonic viscoisty in a similar way.; > ; > In the future I think it would be better to have something like this,; > ; > ```; > 1/h ∇⋅(ν h ∇⃗ u⃗); > ```; > ; > since it ensures that viscosity will always reduce the visocisty but I think this is harder to apply in a finite volume formulation because of the function in front. Best saved for a future PR. This depends on the formulation right?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119865980
Integrability,depend,depends,"> @simone-silvestri : if you wanted to reproduce something like what you did in the one-degree simulations, with a simple closure scheme, we could try this,; > ; > ```; > ∇⋅(ν∇⃗ u⃗); > ```; > ; > which in the case of constant viscosity we have the regular Laplacian. By the same rights you could also as in biharmonic viscoisty in a similar way.; > ; > In the future I think it would be better to have something like this,; > ; > ```; > 1/h ∇⋅(ν h ∇⃗ u⃗); > ```; > ; > since it ensures that viscosity will always reduce the visocisty but I think this is harder to apply in a finite volume formulation because of the function in front. Best saved for a future PR. This depends on the formulation right?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119865980
Usability,simpl,simple,"> @simone-silvestri : if you wanted to reproduce something like what you did in the one-degree simulations, with a simple closure scheme, we could try this,; > ; > ```; > ∇⋅(ν∇⃗ u⃗); > ```; > ; > which in the case of constant viscosity we have the regular Laplacian. By the same rights you could also as in biharmonic viscoisty in a similar way.; > ; > In the future I think it would be better to have something like this,; > ; > ```; > 1/h ∇⋅(ν h ∇⃗ u⃗); > ```; > ; > since it ensures that viscosity will always reduce the visocisty but I think this is harder to apply in a finite volume formulation because of the function in front. Best saved for a future PR. This depends on the formulation right?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119865980
Energy Efficiency,reduce,reduce,"> > @simone-silvestri : if you wanted to reproduce something like what you did in the one-degree simulations, with a simple closure scheme, we could try this,; > > ```; > > ∇⋅(ν∇⃗ u⃗); > > ```; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > which in the case of constant viscosity we have the regular Laplacian. By the same rights you could also as in biharmonic viscoisty in a similar way.; > > In the future I think it would be better to have something like this,; > > ```; > > 1/h ∇⋅(ν h ∇⃗ u⃗); > > ```; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > since it ensures that viscosity will always reduce the visocisty but I think this is harder to apply in a finite volume formulation because of the function in front. Best saved for a future PR.; > ; > This depends on the formulation right?. Yes, what I was suggesting above is for the vector invariant form, since we need this form to have continents. For the conservative form, I think it would be easiest to have. ```; ∇⋅(ν h ∇⃗ u⃗); ```. which does insure that viscosity does not increase kinetic energy.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119868306
Integrability,depend,depends,"> > @simone-silvestri : if you wanted to reproduce something like what you did in the one-degree simulations, with a simple closure scheme, we could try this,; > > ```; > > ∇⋅(ν∇⃗ u⃗); > > ```; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > which in the case of constant viscosity we have the regular Laplacian. By the same rights you could also as in biharmonic viscoisty in a similar way.; > > In the future I think it would be better to have something like this,; > > ```; > > 1/h ∇⋅(ν h ∇⃗ u⃗); > > ```; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > since it ensures that viscosity will always reduce the visocisty but I think this is harder to apply in a finite volume formulation because of the function in front. Best saved for a future PR.; > ; > This depends on the formulation right?. Yes, what I was suggesting above is for the vector invariant form, since we need this form to have continents. For the conservative form, I think it would be easiest to have. ```; ∇⋅(ν h ∇⃗ u⃗); ```. which does insure that viscosity does not increase kinetic energy.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119868306
Usability,simpl,simple,"> > @simone-silvestri : if you wanted to reproduce something like what you did in the one-degree simulations, with a simple closure scheme, we could try this,; > > ```; > > ∇⋅(ν∇⃗ u⃗); > > ```; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > which in the case of constant viscosity we have the regular Laplacian. By the same rights you could also as in biharmonic viscoisty in a similar way.; > > In the future I think it would be better to have something like this,; > > ```; > > 1/h ∇⋅(ν h ∇⃗ u⃗); > > ```; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > since it ensures that viscosity will always reduce the visocisty but I think this is harder to apply in a finite volume formulation because of the function in front. Best saved for a future PR.; > ; > This depends on the formulation right?. Yes, what I was suggesting above is for the vector invariant form, since we need this form to have continents. For the conservative form, I think it would be easiest to have. ```; ∇⋅(ν h ∇⃗ u⃗); ```. which does insure that viscosity does not increase kinetic energy.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119868306
Energy Efficiency,reduce,reduce,"> > > @simone-silvestri : if you wanted to reproduce something like what you did in the one-degree simulations, with a simple closure scheme, we could try this,; > > > ```; > > > ∇⋅(ν∇⃗ u⃗); > > > ```; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > which in the case of constant viscosity we have the regular Laplacian. By the same rights you could also as in biharmonic viscoisty in a similar way.; > > > In the future I think it would be better to have something like this,; > > > ```; > > > 1/h ∇⋅(ν h ∇⃗ u⃗); > > > ```; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > since it ensures that viscosity will always reduce the visocisty but I think this is harder to apply in a finite volume formulation because of the function in front. Best saved for a future PR.; > > ; > > ; > > This depends on the formulation right?; > ; > Yes, what I was suggesting above is for the vector invariant form, since we need this form to have continents.; > ; > For the conservative form, I think it would be easiest to have; > ; > ```; > ∇⋅(ν h ∇⃗ u⃗); > ```; > ; > which does insure that viscosity does not increase kinetic energy. Cool!. We have to write this as a ""rotational"" and ""divergence"" term to reproduce our other results, which only use divergence damping (relying on WENO vector invariant to dissipation enstrophy).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119871091
Integrability,depend,depends,"> > > @simone-silvestri : if you wanted to reproduce something like what you did in the one-degree simulations, with a simple closure scheme, we could try this,; > > > ```; > > > ∇⋅(ν∇⃗ u⃗); > > > ```; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > which in the case of constant viscosity we have the regular Laplacian. By the same rights you could also as in biharmonic viscoisty in a similar way.; > > > In the future I think it would be better to have something like this,; > > > ```; > > > 1/h ∇⋅(ν h ∇⃗ u⃗); > > > ```; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > since it ensures that viscosity will always reduce the visocisty but I think this is harder to apply in a finite volume formulation because of the function in front. Best saved for a future PR.; > > ; > > ; > > This depends on the formulation right?; > ; > Yes, what I was suggesting above is for the vector invariant form, since we need this form to have continents.; > ; > For the conservative form, I think it would be easiest to have; > ; > ```; > ∇⋅(ν h ∇⃗ u⃗); > ```; > ; > which does insure that viscosity does not increase kinetic energy. Cool!. We have to write this as a ""rotational"" and ""divergence"" term to reproduce our other results, which only use divergence damping (relying on WENO vector invariant to dissipation enstrophy).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119871091
Usability,simpl,simple,"> > > @simone-silvestri : if you wanted to reproduce something like what you did in the one-degree simulations, with a simple closure scheme, we could try this,; > > > ```; > > > ∇⋅(ν∇⃗ u⃗); > > > ```; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > which in the case of constant viscosity we have the regular Laplacian. By the same rights you could also as in biharmonic viscoisty in a similar way.; > > > In the future I think it would be better to have something like this,; > > > ```; > > > 1/h ∇⋅(ν h ∇⃗ u⃗); > > > ```; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > since it ensures that viscosity will always reduce the visocisty but I think this is harder to apply in a finite volume formulation because of the function in front. Best saved for a future PR.; > > ; > > ; > > This depends on the formulation right?; > ; > Yes, what I was suggesting above is for the vector invariant form, since we need this form to have continents.; > ; > For the conservative form, I think it would be easiest to have; > ; > ```; > ∇⋅(ν h ∇⃗ u⃗); > ```; > ; > which does insure that viscosity does not increase kinetic energy. Cool!. We have to write this as a ""rotational"" and ""divergence"" term to reproduce our other results, which only use divergence damping (relying on WENO vector invariant to dissipation enstrophy).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119871091
Usability,learn,learn,Thanks for clarifying @glwagner . . I guess I need to learn how this is done in the other models.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119880246
Usability,learn,learn,"> Thanks for clarifying @glwagner .; > ; > I guess I need to learn how this is done in the other models. But for one layer, WENO vector invariant plus WENO for mass flux may be sufficient, and we don't need any other dissipation (which is nice, less work for us).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119920762
Usability,learn,learn,"> > Thanks for clarifying @glwagner .; > > I guess I need to learn how this is done in the other models.; > ; > But for one layer, WENO vector invariant plus WENO for mass flux may be sufficient, and we don't need any other dissipation (which is nice, less work for us). I agree. If we try using whatever closure here that is used in the hydrostatic model, I would think that it should yield a similar result. But that's maybe better saved for a future PR?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119938028
Deployability,configurat,configuration,"> > > Thanks for clarifying @glwagner .; > > > I guess I need to learn how this is done in the other models.; > > ; > > ; > > But for one layer, WENO vector invariant plus WENO for mass flux may be sufficient, and we don't need any other dissipation (which is nice, less work for us).; > ; > I agree. If we try using whatever closure here that is used in the hydrostatic model, I would think that it should yield a similar result. But that's maybe better saved for a future PR?. Let me clarify. We've never run the hydrostatic model with a single layer on the sphere, but this is a good idea. Most of our runs have been with 50 vertical levels. In the 3D configuration with 50 vertical levels, we smooth results with 1) WENO5 vector invariant advection and 2) biharmonic ""divergence damping"" of the divergence component of the flow. If we are going to compare the shallow water on a sphere to they hydrostatic model, we will have to produce additional runs with just 1 vertical level. In other words, there are no results to compare with right now. When we perform additional runs, we may choose to include divergence damping, or another kind of closure, if we want to. The results presented in #2317 also use a single layer hydrostatic model, and these did not require any explicit dissipation. Therefore, there is reason to believe that divergence damping is only required for 3D simulations. An additional point is that in the shallow water equations we can introduce a WENO reconstruction of the mass flux. This reconstruction may provide divergence damping (whether or not we need it!). In summary, if we would like to perform a comparison, we can choose to either 1) produce a comparison between the shallow water model and one layer hydrostatic model with no explicit closure on the sphere or 2) run new 1 layer hydrostatic simulations with some closure (of our choosing) and then _also_ implement that closure in the shallow water model. My opinion is that with these nice WENO5 numerics there",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119959226
Modifiability,config,configuration,"> > > Thanks for clarifying @glwagner .; > > > I guess I need to learn how this is done in the other models.; > > ; > > ; > > But for one layer, WENO vector invariant plus WENO for mass flux may be sufficient, and we don't need any other dissipation (which is nice, less work for us).; > ; > I agree. If we try using whatever closure here that is used in the hydrostatic model, I would think that it should yield a similar result. But that's maybe better saved for a future PR?. Let me clarify. We've never run the hydrostatic model with a single layer on the sphere, but this is a good idea. Most of our runs have been with 50 vertical levels. In the 3D configuration with 50 vertical levels, we smooth results with 1) WENO5 vector invariant advection and 2) biharmonic ""divergence damping"" of the divergence component of the flow. If we are going to compare the shallow water on a sphere to they hydrostatic model, we will have to produce additional runs with just 1 vertical level. In other words, there are no results to compare with right now. When we perform additional runs, we may choose to include divergence damping, or another kind of closure, if we want to. The results presented in #2317 also use a single layer hydrostatic model, and these did not require any explicit dissipation. Therefore, there is reason to believe that divergence damping is only required for 3D simulations. An additional point is that in the shallow water equations we can introduce a WENO reconstruction of the mass flux. This reconstruction may provide divergence damping (whether or not we need it!). In summary, if we would like to perform a comparison, we can choose to either 1) produce a comparison between the shallow water model and one layer hydrostatic model with no explicit closure on the sphere or 2) run new 1 layer hydrostatic simulations with some closure (of our choosing) and then _also_ implement that closure in the shallow water model. My opinion is that with these nice WENO5 numerics there",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119959226
Performance,perform,perform,"; > > ; > > ; > > But for one layer, WENO vector invariant plus WENO for mass flux may be sufficient, and we don't need any other dissipation (which is nice, less work for us).; > ; > I agree. If we try using whatever closure here that is used in the hydrostatic model, I would think that it should yield a similar result. But that's maybe better saved for a future PR?. Let me clarify. We've never run the hydrostatic model with a single layer on the sphere, but this is a good idea. Most of our runs have been with 50 vertical levels. In the 3D configuration with 50 vertical levels, we smooth results with 1) WENO5 vector invariant advection and 2) biharmonic ""divergence damping"" of the divergence component of the flow. If we are going to compare the shallow water on a sphere to they hydrostatic model, we will have to produce additional runs with just 1 vertical level. In other words, there are no results to compare with right now. When we perform additional runs, we may choose to include divergence damping, or another kind of closure, if we want to. The results presented in #2317 also use a single layer hydrostatic model, and these did not require any explicit dissipation. Therefore, there is reason to believe that divergence damping is only required for 3D simulations. An additional point is that in the shallow water equations we can introduce a WENO reconstruction of the mass flux. This reconstruction may provide divergence damping (whether or not we need it!). In summary, if we would like to perform a comparison, we can choose to either 1) produce a comparison between the shallow water model and one layer hydrostatic model with no explicit closure on the sphere or 2) run new 1 layer hydrostatic simulations with some closure (of our choosing) and then _also_ implement that closure in the shallow water model. My opinion is that with these nice WENO5 numerics there may not be a need for using explicit dissipation right now, so we might as well do the easy thing and avoid",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119959226
Safety,avoid,avoid," ; > > ; > > But for one layer, WENO vector invariant plus WENO for mass flux may be sufficient, and we don't need any other dissipation (which is nice, less work for us).; > ; > I agree. If we try using whatever closure here that is used in the hydrostatic model, I would think that it should yield a similar result. But that's maybe better saved for a future PR?. Let me clarify. We've never run the hydrostatic model with a single layer on the sphere, but this is a good idea. Most of our runs have been with 50 vertical levels. In the 3D configuration with 50 vertical levels, we smooth results with 1) WENO5 vector invariant advection and 2) biharmonic ""divergence damping"" of the divergence component of the flow. If we are going to compare the shallow water on a sphere to they hydrostatic model, we will have to produce additional runs with just 1 vertical level. In other words, there are no results to compare with right now. When we perform additional runs, we may choose to include divergence damping, or another kind of closure, if we want to. The results presented in #2317 also use a single layer hydrostatic model, and these did not require any explicit dissipation. Therefore, there is reason to believe that divergence damping is only required for 3D simulations. An additional point is that in the shallow water equations we can introduce a WENO reconstruction of the mass flux. This reconstruction may provide divergence damping (whether or not we need it!). In summary, if we would like to perform a comparison, we can choose to either 1) produce a comparison between the shallow water model and one layer hydrostatic model with no explicit closure on the sphere or 2) run new 1 layer hydrostatic simulations with some closure (of our choosing) and then _also_ implement that closure in the shallow water model. My opinion is that with these nice WENO5 numerics there may not be a need for using explicit dissipation right now, so we might as well do the easy thing and avoid it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119959226
Usability,learn,learn,"> > > Thanks for clarifying @glwagner .; > > > I guess I need to learn how this is done in the other models.; > > ; > > ; > > But for one layer, WENO vector invariant plus WENO for mass flux may be sufficient, and we don't need any other dissipation (which is nice, less work for us).; > ; > I agree. If we try using whatever closure here that is used in the hydrostatic model, I would think that it should yield a similar result. But that's maybe better saved for a future PR?. Let me clarify. We've never run the hydrostatic model with a single layer on the sphere, but this is a good idea. Most of our runs have been with 50 vertical levels. In the 3D configuration with 50 vertical levels, we smooth results with 1) WENO5 vector invariant advection and 2) biharmonic ""divergence damping"" of the divergence component of the flow. If we are going to compare the shallow water on a sphere to they hydrostatic model, we will have to produce additional runs with just 1 vertical level. In other words, there are no results to compare with right now. When we perform additional runs, we may choose to include divergence damping, or another kind of closure, if we want to. The results presented in #2317 also use a single layer hydrostatic model, and these did not require any explicit dissipation. Therefore, there is reason to believe that divergence damping is only required for 3D simulations. An additional point is that in the shallow water equations we can introduce a WENO reconstruction of the mass flux. This reconstruction may provide divergence damping (whether or not we need it!). In summary, if we would like to perform a comparison, we can choose to either 1) produce a comparison between the shallow water model and one layer hydrostatic model with no explicit closure on the sphere or 2) run new 1 layer hydrostatic simulations with some closure (of our choosing) and then _also_ implement that closure in the shallow water model. My opinion is that with these nice WENO5 numerics there",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119959226
Usability,simpl,simple,@francispoulin those figures are simple heatmaps:. https://makie.juliaplots.org/stable/examples/plotting_functions/heatmap/. The code you are writing looks like code for producing a surface plot on the sphere. Heatmap might be easier!. It might help to start from scratch rather than fixing whatever’s there too.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1126723606
Availability,error,error,"> What happens if you first create Figure and Axis, and draw the heatmap into Axis? You'll want to use ""heatmap!"" rather than ""heatmap"". Sadly, I still get the error. Just to be clear, I am trying the following:. ```; fig = Figure(resolution = (1000, 1000)); ax = Axis(fig[1,1], xlabel = ""x"", ylabel = ""y"", title=""vorticity""); heatmap!(ax, x, y, ζ′, colormap=:balance, colorrange=clims); ```. In our case, `x,y`, are arrays, but in the examples, `x,y`, are vectors. Maybe heatmap doesn't work so well for this type of data?. For fun I tried `surface!`, which is used in the other visualization.jl code, and that does plot, but i get it on a desk. Not so easy to sort out.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1126779047
Usability,clear,clear,"> What happens if you first create Figure and Axis, and draw the heatmap into Axis? You'll want to use ""heatmap!"" rather than ""heatmap"". Sadly, I still get the error. Just to be clear, I am trying the following:. ```; fig = Figure(resolution = (1000, 1000)); ax = Axis(fig[1,1], xlabel = ""x"", ylabel = ""y"", title=""vorticity""); heatmap!(ax, x, y, ζ′, colormap=:balance, colorrange=clims); ```. In our case, `x,y`, are arrays, but in the examples, `x,y`, are vectors. Maybe heatmap doesn't work so well for this type of data?. For fun I tried `surface!`, which is used in the other visualization.jl code, and that does plot, but i get it on a desk. Not so easy to sort out.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1126779047
Usability,learn,learn,Thanks @navidcy ! That definitely did the trick. Now to learn how to make an animation.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1126796762
Usability,learn,learn,"This definitely needs some polishing, and it only contains the results for the first 200 days (165 days still yet to be computed), but it looks promising. Thanks @navidcy and @glwagner for helping me learn more about `Makie`. Any suggestions on what I should do to improve this are very welcome. https://user-images.githubusercontent.com/8239041/168451788-556cf7ca-ade4-415f-ad84-40c57bfb303c.mp4",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1126828919
Usability,learn,learn,"> This definitely needs some polishing, and it only contains the results for the first 200 days (165 days still yet to be computed), but it looks promising. Thanks @navidcy and @glwagner for helping me learn more about `Makie`.; > ; > Any suggestions on what I should do to improve this are very welcome.; > ; > near_global_lat_lon_1440_600__fine_surface.mp4. I suggest changing the color scale to reveal more detail. You can set the limits of `colorrange` to something like 1/4 or 1/10 of the maximum(abs, vorticity).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1127181498
Integrability,wrap,wrapper,"> hmmm, can you read a jld2 file with NCDatasets? I am not sure how that package works. NCDatasets is a wrapper on top of the NetCDF C API which is based (in part) on the HDF5 library. As JLD2 is a julia implementation of HDF5, some simple JLD2 files are (surprisingly) readable NCDatasets but this is not generally the case, and arbitrary HDF5 files are [not supported by the NetCDF C library](https://docs.unidata.ucar.edu/netcdf-c/current/interoperability_hdf5.html). It is indeed better to use JLD2.jl for JLD2 files.😃",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1127385759
Usability,simpl,simple,"> hmmm, can you read a jld2 file with NCDatasets? I am not sure how that package works. NCDatasets is a wrapper on top of the NetCDF C API which is based (in part) on the HDF5 library. As JLD2 is a julia implementation of HDF5, some simple JLD2 files are (surprisingly) readable NCDatasets but this is not generally the case, and arbitrary HDF5 files are [not supported by the NetCDF C library](https://docs.unidata.ucar.edu/netcdf-c/current/interoperability_hdf5.html). It is indeed better to use JLD2.jl for JLD2 files.😃",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1127385759
Usability,undo,undo,"I agree. So I pushed [8eaf216](https://github.com/CliMA/Oceananigans.jl/pull/2522/commits/8eaf216f277bf245d4035b277bbe7d65766d2fec). If there are opposing opinions we can undo this. With this export we can do:. ```Julia; julia> ShallowWaterModel(; gravitational_acceleration=1, grid, formulation=VectorInvariantFormulation(), momentum_advection = VectorInvariant()); ```; instead of ; ```julia; julia> ShallowWaterModel(; gravitational_acceleration=1, grid, formulation=Oceananigans.Models.ShallowWaterModels.VectorInvariantFormulation(), momentum_advection = VectorInvariant()); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1144247947
Security,validat,validation,I compared them and I don't see anything that is in the validation that we don't have in the example. I am going to close this PR and create a new one that simply removes that file.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2545#issuecomment-1123086468
Usability,simpl,simply,I compared them and I don't see anything that is in the validation that we don't have in the example. I am going to close this PR and create a new one that simply removes that file.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2545#issuecomment-1123086468
Availability,down,down,"Well, the usage is limited here because we always ""count from 1"". For an atmospheric simulation with a sponge layer on top, you might have a stretched coordinate as the domain gets higher and higher. Then you could keep your levels fixed and reduce the height of the domain by changing Nz. This might be convenient if you've carefully designed your vertical coordinate to get the spacings ""right"" at the bottom of the domain, but care a lot less about what happens higher up. Then if you get more computational power, you can increase Nz (decreasing the dependence of the stuff lower down on your ""sponge region""). We actually have a similar situation in the ocean where the vertical coordinate is carefully designed in the upper ocean; we could in principle ask for fewer ""lower"" levels --- now that would be a feature we might want to add too!. I think that's why it's good to have a guideline like ""throw an error when we _know_ things are incorrect"". Because if we get into the business of trying to ""predict what users want to do"", we'll quickly find our imaginations are limited! Personally my philosophy is to allow as much as possible because it lets people exercise creativity as freely as possible (not limited by what I personally think people should do). What do you think about that?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2550#issuecomment-1126381524
Energy Efficiency,reduce,reduce,"Well, the usage is limited here because we always ""count from 1"". For an atmospheric simulation with a sponge layer on top, you might have a stretched coordinate as the domain gets higher and higher. Then you could keep your levels fixed and reduce the height of the domain by changing Nz. This might be convenient if you've carefully designed your vertical coordinate to get the spacings ""right"" at the bottom of the domain, but care a lot less about what happens higher up. Then if you get more computational power, you can increase Nz (decreasing the dependence of the stuff lower down on your ""sponge region""). We actually have a similar situation in the ocean where the vertical coordinate is carefully designed in the upper ocean; we could in principle ask for fewer ""lower"" levels --- now that would be a feature we might want to add too!. I think that's why it's good to have a guideline like ""throw an error when we _know_ things are incorrect"". Because if we get into the business of trying to ""predict what users want to do"", we'll quickly find our imaginations are limited! Personally my philosophy is to allow as much as possible because it lets people exercise creativity as freely as possible (not limited by what I personally think people should do). What do you think about that?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2550#issuecomment-1126381524
Integrability,depend,dependence,"Well, the usage is limited here because we always ""count from 1"". For an atmospheric simulation with a sponge layer on top, you might have a stretched coordinate as the domain gets higher and higher. Then you could keep your levels fixed and reduce the height of the domain by changing Nz. This might be convenient if you've carefully designed your vertical coordinate to get the spacings ""right"" at the bottom of the domain, but care a lot less about what happens higher up. Then if you get more computational power, you can increase Nz (decreasing the dependence of the stuff lower down on your ""sponge region""). We actually have a similar situation in the ocean where the vertical coordinate is carefully designed in the upper ocean; we could in principle ask for fewer ""lower"" levels --- now that would be a feature we might want to add too!. I think that's why it's good to have a guideline like ""throw an error when we _know_ things are incorrect"". Because if we get into the business of trying to ""predict what users want to do"", we'll quickly find our imaginations are limited! Personally my philosophy is to allow as much as possible because it lets people exercise creativity as freely as possible (not limited by what I personally think people should do). What do you think about that?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2550#issuecomment-1126381524
Safety,predict,predict,"Well, the usage is limited here because we always ""count from 1"". For an atmospheric simulation with a sponge layer on top, you might have a stretched coordinate as the domain gets higher and higher. Then you could keep your levels fixed and reduce the height of the domain by changing Nz. This might be convenient if you've carefully designed your vertical coordinate to get the spacings ""right"" at the bottom of the domain, but care a lot less about what happens higher up. Then if you get more computational power, you can increase Nz (decreasing the dependence of the stuff lower down on your ""sponge region""). We actually have a similar situation in the ocean where the vertical coordinate is carefully designed in the upper ocean; we could in principle ask for fewer ""lower"" levels --- now that would be a feature we might want to add too!. I think that's why it's good to have a guideline like ""throw an error when we _know_ things are incorrect"". Because if we get into the business of trying to ""predict what users want to do"", we'll quickly find our imaginations are limited! Personally my philosophy is to allow as much as possible because it lets people exercise creativity as freely as possible (not limited by what I personally think people should do). What do you think about that?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2550#issuecomment-1126381524
Usability,guid,guideline,"Well, the usage is limited here because we always ""count from 1"". For an atmospheric simulation with a sponge layer on top, you might have a stretched coordinate as the domain gets higher and higher. Then you could keep your levels fixed and reduce the height of the domain by changing Nz. This might be convenient if you've carefully designed your vertical coordinate to get the spacings ""right"" at the bottom of the domain, but care a lot less about what happens higher up. Then if you get more computational power, you can increase Nz (decreasing the dependence of the stuff lower down on your ""sponge region""). We actually have a similar situation in the ocean where the vertical coordinate is carefully designed in the upper ocean; we could in principle ask for fewer ""lower"" levels --- now that would be a feature we might want to add too!. I think that's why it's good to have a guideline like ""throw an error when we _know_ things are incorrect"". Because if we get into the business of trying to ""predict what users want to do"", we'll quickly find our imaginations are limited! Personally my philosophy is to allow as much as possible because it lets people exercise creativity as freely as possible (not limited by what I personally think people should do). What do you think about that?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2550#issuecomment-1126381524
Availability,error,error,"You should use `FluxBoundaryCondition(nothing)` for zero flux boundary condition since it simplifies the code _slightly_ (the difference between ""adding 0"", and not calling a function at all). It's also the default so you shouldn't have to set it (this might've been an MWE --- just want to make sure people know). I think we should ""regularize"" boundary conditions with `Number` to `Float64`; we've seen this error a few times.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2558#issuecomment-1128947176
Usability,simpl,simplifies,"You should use `FluxBoundaryCondition(nothing)` for zero flux boundary condition since it simplifies the code _slightly_ (the difference between ""adding 0"", and not calling a function at all). It's also the default so you shouldn't have to set it (this might've been an MWE --- just want to make sure people know). I think we should ""regularize"" boundary conditions with `Number` to `Float64`; we've seen this error a few times.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2558#issuecomment-1128947176
Usability,learn,learn,"> If that's the case, then the syntax; > ; > ```julia; > δ = ∂x(u) + ∂y(v); > ```; > ; > is valid on all grids --- isn't it?. Yes, I agree that it should be the case. . By the same rationale, the formulas for vorticity should also work on all grids, except maybe a cubed sphere?. I will experiment with the two approaches on the lat-lon grid and see what I can learn. . I will close this and return to it if I think there's a need.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2575#issuecomment-1136259842
Availability,mask,mask,"It's because on an immersed boundary grid, reduced operations are wrapped in `ConditionalOperation` in order to mask the reduction --- and `ConditionalOperation` had a bug; namely it was missing a definition of `compute_at!` (which all the other abstract operations have, eg `BinaryOperation`). For `compute!` on a reduction to be correct, we first have to compute all of the fields that are involved in the reduction. To make this work, we call `compute_at!` on `reduction.operand`. This in turn has to trigger the computation of _any_ fields that are in the expression tree associated with `reduction.operand`. Thus all `AbstractOperations` with field operands must define `compute_at!`. The difference between `compute_at!` and `compute!` is that `compute_at!` has a ""time"" associated with it. This allows us to avoid ""recomputing"" fields --- if possible (eg, if a field is not sharing its data with another field). PS I think a better descriptor than ""Odd behavior"" would be ""Wrong behavior"". ""Odd"" is a bit too general... by the title, it's not clear that something is actually amiss! ""Odd"" might just mean ""unexpected"", but somehow technically correct. Here that's not the case, the results are definitely wrong.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2581#issuecomment-1139758191
Energy Efficiency,reduce,reduced,"It's because on an immersed boundary grid, reduced operations are wrapped in `ConditionalOperation` in order to mask the reduction --- and `ConditionalOperation` had a bug; namely it was missing a definition of `compute_at!` (which all the other abstract operations have, eg `BinaryOperation`). For `compute!` on a reduction to be correct, we first have to compute all of the fields that are involved in the reduction. To make this work, we call `compute_at!` on `reduction.operand`. This in turn has to trigger the computation of _any_ fields that are in the expression tree associated with `reduction.operand`. Thus all `AbstractOperations` with field operands must define `compute_at!`. The difference between `compute_at!` and `compute!` is that `compute_at!` has a ""time"" associated with it. This allows us to avoid ""recomputing"" fields --- if possible (eg, if a field is not sharing its data with another field). PS I think a better descriptor than ""Odd behavior"" would be ""Wrong behavior"". ""Odd"" is a bit too general... by the title, it's not clear that something is actually amiss! ""Odd"" might just mean ""unexpected"", but somehow technically correct. Here that's not the case, the results are definitely wrong.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2581#issuecomment-1139758191
Integrability,wrap,wrapped,"It's because on an immersed boundary grid, reduced operations are wrapped in `ConditionalOperation` in order to mask the reduction --- and `ConditionalOperation` had a bug; namely it was missing a definition of `compute_at!` (which all the other abstract operations have, eg `BinaryOperation`). For `compute!` on a reduction to be correct, we first have to compute all of the fields that are involved in the reduction. To make this work, we call `compute_at!` on `reduction.operand`. This in turn has to trigger the computation of _any_ fields that are in the expression tree associated with `reduction.operand`. Thus all `AbstractOperations` with field operands must define `compute_at!`. The difference between `compute_at!` and `compute!` is that `compute_at!` has a ""time"" associated with it. This allows us to avoid ""recomputing"" fields --- if possible (eg, if a field is not sharing its data with another field). PS I think a better descriptor than ""Odd behavior"" would be ""Wrong behavior"". ""Odd"" is a bit too general... by the title, it's not clear that something is actually amiss! ""Odd"" might just mean ""unexpected"", but somehow technically correct. Here that's not the case, the results are definitely wrong.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2581#issuecomment-1139758191
Safety,avoid,avoid,"It's because on an immersed boundary grid, reduced operations are wrapped in `ConditionalOperation` in order to mask the reduction --- and `ConditionalOperation` had a bug; namely it was missing a definition of `compute_at!` (which all the other abstract operations have, eg `BinaryOperation`). For `compute!` on a reduction to be correct, we first have to compute all of the fields that are involved in the reduction. To make this work, we call `compute_at!` on `reduction.operand`. This in turn has to trigger the computation of _any_ fields that are in the expression tree associated with `reduction.operand`. Thus all `AbstractOperations` with field operands must define `compute_at!`. The difference between `compute_at!` and `compute!` is that `compute_at!` has a ""time"" associated with it. This allows us to avoid ""recomputing"" fields --- if possible (eg, if a field is not sharing its data with another field). PS I think a better descriptor than ""Odd behavior"" would be ""Wrong behavior"". ""Odd"" is a bit too general... by the title, it's not clear that something is actually amiss! ""Odd"" might just mean ""unexpected"", but somehow technically correct. Here that's not the case, the results are definitely wrong.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2581#issuecomment-1139758191
Usability,clear,clear,"It's because on an immersed boundary grid, reduced operations are wrapped in `ConditionalOperation` in order to mask the reduction --- and `ConditionalOperation` had a bug; namely it was missing a definition of `compute_at!` (which all the other abstract operations have, eg `BinaryOperation`). For `compute!` on a reduction to be correct, we first have to compute all of the fields that are involved in the reduction. To make this work, we call `compute_at!` on `reduction.operand`. This in turn has to trigger the computation of _any_ fields that are in the expression tree associated with `reduction.operand`. Thus all `AbstractOperations` with field operands must define `compute_at!`. The difference between `compute_at!` and `compute!` is that `compute_at!` has a ""time"" associated with it. This allows us to avoid ""recomputing"" fields --- if possible (eg, if a field is not sharing its data with another field). PS I think a better descriptor than ""Odd behavior"" would be ""Wrong behavior"". ""Odd"" is a bit too general... by the title, it's not clear that something is actually amiss! ""Odd"" might just mean ""unexpected"", but somehow technically correct. Here that's not the case, the results are definitely wrong.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2581#issuecomment-1139758191
Usability,clear,clear,"> PS I think a better descriptor than ""Odd behavior"" would be ""Wrong behavior"". ""Odd"" is a bit too general... by the title, it's not clear that something is actually amiss! ""Odd"" might just mean ""unexpected"", but somehow technically correct. Here that's not the case, the results are definitely wrong. I've been accused of being too harsh with my words before in issues, so I try to be conservative with by adjectives whenever I can :). Thanks for the explanation! It makes perfect sense",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2581#issuecomment-1139763353
Availability,error,error,"@glwagner do you mind if I merge main here? I wanna re-run my simulations after https://github.com/CliMA/Oceananigans.jl/pull/2587 but also with this bugfix. I can also take a look at the tests that are failing and fix them so that we can merge this. On recent versions of Oceananigans with IBM some of the more complex abstract operations that used to compile (without IBM) are not compiling anymore for me and are instead throwing this error: `CUDA error: device kernel image is invalid (code 200, ERROR_INVALID_IMAGE)`. So I'm pretty sure is what's happening here and we just have to simplify the abstract operations used here: https://github.com/CliMA/Oceananigans.jl/blob/525984e8d013517fb40fc9a374fa99b46544d9fd/test/test_computed_field.jl#L529-L534",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2582#issuecomment-1142591200
Testability,test,tests,"@glwagner do you mind if I merge main here? I wanna re-run my simulations after https://github.com/CliMA/Oceananigans.jl/pull/2587 but also with this bugfix. I can also take a look at the tests that are failing and fix them so that we can merge this. On recent versions of Oceananigans with IBM some of the more complex abstract operations that used to compile (without IBM) are not compiling anymore for me and are instead throwing this error: `CUDA error: device kernel image is invalid (code 200, ERROR_INVALID_IMAGE)`. So I'm pretty sure is what's happening here and we just have to simplify the abstract operations used here: https://github.com/CliMA/Oceananigans.jl/blob/525984e8d013517fb40fc9a374fa99b46544d9fd/test/test_computed_field.jl#L529-L534",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2582#issuecomment-1142591200
Usability,simpl,simplify,"@glwagner do you mind if I merge main here? I wanna re-run my simulations after https://github.com/CliMA/Oceananigans.jl/pull/2587 but also with this bugfix. I can also take a look at the tests that are failing and fix them so that we can merge this. On recent versions of Oceananigans with IBM some of the more complex abstract operations that used to compile (without IBM) are not compiling anymore for me and are instead throwing this error: `CUDA error: device kernel image is invalid (code 200, ERROR_INVALID_IMAGE)`. So I'm pretty sure is what's happening here and we just have to simplify the abstract operations used here: https://github.com/CliMA/Oceananigans.jl/blob/525984e8d013517fb40fc9a374fa99b46544d9fd/test/test_computed_field.jl#L529-L534",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2582#issuecomment-1142591200
Usability,simpl,simple,Maybe a lat-lon barotropic double gyre like MITgcm has? . https://mitgcm.readthedocs.io/en/latest/examples/barotropic_gyre/barotropic_gyre.html. Let's keep it as simple as possible too...,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2584#issuecomment-1140507140
Usability,simpl,simpler,"oh, you suggested barotropic... yeah, that'd be even simpler!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2584#issuecomment-1140522625
Modifiability,layers,layers,"Right, and we are essentially looking for a keyword that the user can use to specify they want to use layers. This keyword can be anything we want, right? . I was advocating for something that seemed intuitive to me but any layered shallow water model is a plus for me.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2600#issuecomment-1155740343
Usability,intuit,intuitive,"Right, and we are essentially looking for a keyword that the user can use to specify they want to use layers. This keyword can be anything we want, right? . I was advocating for something that seemed intuitive to me but any layered shallow water model is a plus for me.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2600#issuecomment-1155740343
Modifiability,layers,layers,"> Right, and we are essentially looking for a keyword that the user can use to specify they want to use layers. This keyword can be anything we want, right?; > ; > I was advocating for something that seemed intuitive to me but any layered shallow water model is a plus for me. I'm talking about the relationship between the vertical grid topology and the algorithm used by `ShallowWaterModel` to solve a problem on that grid.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2600#issuecomment-1156641717
Usability,intuit,intuitive,"> Right, and we are essentially looking for a keyword that the user can use to specify they want to use layers. This keyword can be anything we want, right?; > ; > I was advocating for something that seemed intuitive to me but any layered shallow water model is a plus for me. I'm talking about the relationship between the vertical grid topology and the algorithm used by `ShallowWaterModel` to solve a problem on that grid.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2600#issuecomment-1156641717
Availability,error,error,"I think the problem comes from the fact that you build the advection scheme _outside_ the model with `WENO(grid)` but the grid changes inside the model and this change is not recorded in the advection scheme. . What do you think about just spitting out an error then? In that way the user is forced to rebuild the grid and any error which derives from inconsistencies between model grid and preliminary grid is solved. . We can always regularize the advection scheme _inside_ the model (as I am already planning to do, and will do in #2642) and that will clear the error with advection. . The downside of inflating the grid inside the model is that we always have to make sure that _anything_ that we build outside the model is regularized when inflating the halos (functions, auxiliary fields, viscosity functions, etc). This might be a little bit unsustainable. . For this reason, I am in favour of just spitting out an error, which might be a little bit inconvenient for the user (not extremely though) but is much safer. . In general a decision has to be made, I lean towards the latter, what do you guys think? @tomchor @navidcy @glwagner @francispoulin",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1181850072
Safety,safe,safer,"I think the problem comes from the fact that you build the advection scheme _outside_ the model with `WENO(grid)` but the grid changes inside the model and this change is not recorded in the advection scheme. . What do you think about just spitting out an error then? In that way the user is forced to rebuild the grid and any error which derives from inconsistencies between model grid and preliminary grid is solved. . We can always regularize the advection scheme _inside_ the model (as I am already planning to do, and will do in #2642) and that will clear the error with advection. . The downside of inflating the grid inside the model is that we always have to make sure that _anything_ that we build outside the model is regularized when inflating the halos (functions, auxiliary fields, viscosity functions, etc). This might be a little bit unsustainable. . For this reason, I am in favour of just spitting out an error, which might be a little bit inconvenient for the user (not extremely though) but is much safer. . In general a decision has to be made, I lean towards the latter, what do you guys think? @tomchor @navidcy @glwagner @francispoulin",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1181850072
Usability,clear,clear,"I think the problem comes from the fact that you build the advection scheme _outside_ the model with `WENO(grid)` but the grid changes inside the model and this change is not recorded in the advection scheme. . What do you think about just spitting out an error then? In that way the user is forced to rebuild the grid and any error which derives from inconsistencies between model grid and preliminary grid is solved. . We can always regularize the advection scheme _inside_ the model (as I am already planning to do, and will do in #2642) and that will clear the error with advection. . The downside of inflating the grid inside the model is that we always have to make sure that _anything_ that we build outside the model is regularized when inflating the halos (functions, auxiliary fields, viscosity functions, etc). This might be a little bit unsustainable. . For this reason, I am in favour of just spitting out an error, which might be a little bit inconvenient for the user (not extremely though) but is much safer. . In general a decision has to be made, I lean towards the latter, what do you guys think? @tomchor @navidcy @glwagner @francispoulin",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1181850072
Availability,error,error,Usually restarting the test works for me to clear that error,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2607#issuecomment-1157789828
Testability,test,test,Usually restarting the test works for me to clear that error,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2607#issuecomment-1157789828
Usability,clear,clear,Usually restarting the test works for me to clear that error,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2607#issuecomment-1157789828
Availability,error,error,> Usually restarting the test works for me to clear that error. Good to know. How can I do that?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2607#issuecomment-1157900045
Testability,test,test,> Usually restarting the test works for me to clear that error. Good to know. How can I do that?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2607#issuecomment-1157900045
Usability,clear,clear,> Usually restarting the test works for me to clear that error. Good to know. How can I do that?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2607#issuecomment-1157900045
Availability,error,error,> > Usually restarting the test works for me to clear that error; > ; > Good to know. How can I do that?. I don't think you can because you need access to the Clima buildkite. But @simone-silvestri can do it.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2607#issuecomment-1157917180
Security,access,access,> > Usually restarting the test works for me to clear that error; > ; > Good to know. How can I do that?. I don't think you can because you need access to the Clima buildkite. But @simone-silvestri can do it.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2607#issuecomment-1157917180
Testability,test,test,> > Usually restarting the test works for me to clear that error; > ; > Good to know. How can I do that?. I don't think you can because you need access to the Clima buildkite. But @simone-silvestri can do it.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2607#issuecomment-1157917180
Usability,clear,clear,> > Usually restarting the test works for me to clear that error; > ; > Good to know. How can I do that?. I don't think you can because you need access to the Clima buildkite. But @simone-silvestri can do it.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2607#issuecomment-1157917180
Safety,avoid,avoid,"Thank you @navidcy! . Mind if I ask how? I feel like I might have been given permission to do this last year, but just never tried it. If I don't have permission, no problem, but if I do I can learn to do this to avoid bothering others with this.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2607#issuecomment-1158802256
Usability,learn,learn,"Thank you @navidcy! . Mind if I ask how? I feel like I might have been given permission to do this last year, but just never tried it. If I don't have permission, no problem, but if I do I can learn to do this to avoid bothering others with this.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2607#issuecomment-1158802256
Safety,avoid,avoid,"> Thank you @navidcy! ; > ; > ; > ; > Mind if I ask how? I feel like I might have been given permission to do this last year, but just never tried it. If I don't have permission, no problem, but if I do I can learn to do this to avoid bothering others with this. . I don't have permission to give you permission. :(",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2607#issuecomment-1158827707
Usability,learn,learn,"> Thank you @navidcy! ; > ; > ; > ; > Mind if I ask how? I feel like I might have been given permission to do this last year, but just never tried it. If I don't have permission, no problem, but if I do I can learn to do this to avoid bothering others with this. . I don't have permission to give you permission. :(",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2607#issuecomment-1158827707
Usability,clear,clear,"I am including the link from above [here](https://github.com/CliMA/Oceananigans.jl/blob/e76deefc1fdf115e05856a18977c593d0b5d3b0d/src/Advection/centered_second_order.jl#L30). . This shows that areas, or lenghts for shallow water, do appear but they are at the last step of the inbedded functions. It's not clear to me that points 1 and 2 are a bug since the areas do appear in the calculations. The evidence to support that is the above plots where the conservative scheme is very similar to the vector invariant scheme. Point 3 no long is relevant to the code. Point 4 is not a bug but a matter of maybe reducing the accuracy to second order, which might be the highest we can do anyhow.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2615#issuecomment-1165819827
Usability,clear,clearer,"I see your point @simone-silvestri . I thought these changes would make things clearer but perhaps they have done the opposite. My apologies. If you wanted to change them back to volumes, I'm perfectly happy with that. Also, can you confirm that we don't need any extra metrics on the calculation of the momentum, as @glwagner originaly asked about it #1866 ?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2615#issuecomment-1165832984
Availability,down,downwards,"Okay, thank you very much for the clarification about hydrostatic vs. nonhydrostatic pressure! The hydrostatic pressure integral:. https://github.com/CliMA/Oceananigans.jl/blob/e76deefc1fdf115e05856a18977c593d0b5d3b0d/src/Models/NonhydrostaticModels/update_hydrostatic_pressure.jl#L15. does indeed use tracers; in addition it involves a reconstruction / interpolation that _might_ be affecting results here. Bug perhaps? I say ""might"" and ""perhaps"" because the precise mechanism isn't clear to me. Since we integrate downwards, there's only an error in the hydrostatic pressure _below_ the immersed boundary. Hmm... Note, this particular issue is not fixed by ""unmasking"" tracers (it's just that the bug / error is different, and perhaps less innocuous). This bug is also not fixed by #2603.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1165800793
Deployability,integrat,integrate,"Okay, thank you very much for the clarification about hydrostatic vs. nonhydrostatic pressure! The hydrostatic pressure integral:. https://github.com/CliMA/Oceananigans.jl/blob/e76deefc1fdf115e05856a18977c593d0b5d3b0d/src/Models/NonhydrostaticModels/update_hydrostatic_pressure.jl#L15. does indeed use tracers; in addition it involves a reconstruction / interpolation that _might_ be affecting results here. Bug perhaps? I say ""might"" and ""perhaps"" because the precise mechanism isn't clear to me. Since we integrate downwards, there's only an error in the hydrostatic pressure _below_ the immersed boundary. Hmm... Note, this particular issue is not fixed by ""unmasking"" tracers (it's just that the bug / error is different, and perhaps less innocuous). This bug is also not fixed by #2603.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1165800793
Integrability,integrat,integrate,"Okay, thank you very much for the clarification about hydrostatic vs. nonhydrostatic pressure! The hydrostatic pressure integral:. https://github.com/CliMA/Oceananigans.jl/blob/e76deefc1fdf115e05856a18977c593d0b5d3b0d/src/Models/NonhydrostaticModels/update_hydrostatic_pressure.jl#L15. does indeed use tracers; in addition it involves a reconstruction / interpolation that _might_ be affecting results here. Bug perhaps? I say ""might"" and ""perhaps"" because the precise mechanism isn't clear to me. Since we integrate downwards, there's only an error in the hydrostatic pressure _below_ the immersed boundary. Hmm... Note, this particular issue is not fixed by ""unmasking"" tracers (it's just that the bug / error is different, and perhaps less innocuous). This bug is also not fixed by #2603.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1165800793
Usability,clear,clear,"Okay, thank you very much for the clarification about hydrostatic vs. nonhydrostatic pressure! The hydrostatic pressure integral:. https://github.com/CliMA/Oceananigans.jl/blob/e76deefc1fdf115e05856a18977c593d0b5d3b0d/src/Models/NonhydrostaticModels/update_hydrostatic_pressure.jl#L15. does indeed use tracers; in addition it involves a reconstruction / interpolation that _might_ be affecting results here. Bug perhaps? I say ""might"" and ""perhaps"" because the precise mechanism isn't clear to me. Since we integrate downwards, there's only an error in the hydrostatic pressure _below_ the immersed boundary. Hmm... Note, this particular issue is not fixed by ""unmasking"" tracers (it's just that the bug / error is different, and perhaps less innocuous). This bug is also not fixed by #2603.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1165800793
Usability,feedback,feedback,I don't know the details here to provide useful feedback. Sorry... :(,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1223170867
Deployability,update,updated,"> I don't know the details here to provide useful feedback. Sorry... :(. That's a good point. This PR changed from when it was first introduced and it's much simpler in scope, so I updated the PR description. If that's enough for you to give me feedback, feel free to do so :). I'm only modifying the `NonhydrostaticModel` for now, as I'm not familiar with the hydrostatic one. (Not sure if eventually the same thing should be that for that...)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1223371379
Usability,feedback,feedback,"> I don't know the details here to provide useful feedback. Sorry... :(. That's a good point. This PR changed from when it was first introduced and it's much simpler in scope, so I updated the PR description. If that's enough for you to give me feedback, feel free to do so :). I'm only modifying the `NonhydrostaticModel` for now, as I'm not familiar with the hydrostatic one. (Not sure if eventually the same thing should be that for that...)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1223371379
Availability,mask,masking,"> We should make the changes needed for both nonhydrostatic and hydrostatic models. @glwagner the reason why I hadn't removed masking from the hydrostatic model is that I'm really not familiar with it at all. So it's harder for me to figure out where it's okay to remove it, and testing it. I just did a best guess and removed it from shallow water and nonhydrostatic models in the places I thought appropriate. It would be good to have some feedback from someone more familiar with the code though on that, though.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1223429496
Testability,test,testing,"> We should make the changes needed for both nonhydrostatic and hydrostatic models. @glwagner the reason why I hadn't removed masking from the hydrostatic model is that I'm really not familiar with it at all. So it's harder for me to figure out where it's okay to remove it, and testing it. I just did a best guess and removed it from shallow water and nonhydrostatic models in the places I thought appropriate. It would be good to have some feedback from someone more familiar with the code though on that, though.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1223429496
Usability,feedback,feedback,"> We should make the changes needed for both nonhydrostatic and hydrostatic models. @glwagner the reason why I hadn't removed masking from the hydrostatic model is that I'm really not familiar with it at all. So it's harder for me to figure out where it's okay to remove it, and testing it. I just did a best guess and removed it from shallow water and nonhydrostatic models in the places I thought appropriate. It would be good to have some feedback from someone more familiar with the code though on that, though.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1223429496
Deployability,continuous,continuous,"> I think the immersed boundary condition should be an `ImmersedBoundaryCondition`; > ; > ```; > @inline linear_drag(i, j, k, grid, clock, fields) = - 0.2 * fields.u[i, j, k]; > ; > drag_u = FluxBoundaryCondition(linear_drag, discrete_form=true); > u_immersed_bc = ImmersedBoundaryCondition(bottom = drag_u); > u_bcs = FieldBoundaryConditions(bottom = drag_u, immersed = u_immersed_bc); > ```; > ; > I do not think we can use the continuous form because `ImmersedBoundaryCondition` should behave just as another `FieldBoundaryCondition` which is 3D instead of 2D and I do not see a `getbc` defined for a `3DBoundaryFunction` (they are only defined for `XBoundaryFunction`, `YBoundaryFunction` and `ZBoundaryFunction`); > ; > we can probably add here the `getbc` method for a _continuous_ immersed boundary condition. This is a specific choice that depends on the boundary condition one is trying to implement. For ""simple"" boundary conditions, we don't need to invoke `ImmersedBoundaryCondition` because. https://github.com/CliMA/Oceananigans.jl/blob/95206ae73e10460beebb2ce9d5fc9945523e5724/src/ImmersedBoundaries/immersed_boundary_condition.jl#L242-L245. For boundary conditions that impose _only bottom drag_ but _not_ side drag, then we do need to use `ImmersedBoundaryCondition` as indicated.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2632#issuecomment-1171935502
Integrability,depend,depends,"> I think the immersed boundary condition should be an `ImmersedBoundaryCondition`; > ; > ```; > @inline linear_drag(i, j, k, grid, clock, fields) = - 0.2 * fields.u[i, j, k]; > ; > drag_u = FluxBoundaryCondition(linear_drag, discrete_form=true); > u_immersed_bc = ImmersedBoundaryCondition(bottom = drag_u); > u_bcs = FieldBoundaryConditions(bottom = drag_u, immersed = u_immersed_bc); > ```; > ; > I do not think we can use the continuous form because `ImmersedBoundaryCondition` should behave just as another `FieldBoundaryCondition` which is 3D instead of 2D and I do not see a `getbc` defined for a `3DBoundaryFunction` (they are only defined for `XBoundaryFunction`, `YBoundaryFunction` and `ZBoundaryFunction`); > ; > we can probably add here the `getbc` method for a _continuous_ immersed boundary condition. This is a specific choice that depends on the boundary condition one is trying to implement. For ""simple"" boundary conditions, we don't need to invoke `ImmersedBoundaryCondition` because. https://github.com/CliMA/Oceananigans.jl/blob/95206ae73e10460beebb2ce9d5fc9945523e5724/src/ImmersedBoundaries/immersed_boundary_condition.jl#L242-L245. For boundary conditions that impose _only bottom drag_ but _not_ side drag, then we do need to use `ImmersedBoundaryCondition` as indicated.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2632#issuecomment-1171935502
Usability,simpl,simple,"> I think the immersed boundary condition should be an `ImmersedBoundaryCondition`; > ; > ```; > @inline linear_drag(i, j, k, grid, clock, fields) = - 0.2 * fields.u[i, j, k]; > ; > drag_u = FluxBoundaryCondition(linear_drag, discrete_form=true); > u_immersed_bc = ImmersedBoundaryCondition(bottom = drag_u); > u_bcs = FieldBoundaryConditions(bottom = drag_u, immersed = u_immersed_bc); > ```; > ; > I do not think we can use the continuous form because `ImmersedBoundaryCondition` should behave just as another `FieldBoundaryCondition` which is 3D instead of 2D and I do not see a `getbc` defined for a `3DBoundaryFunction` (they are only defined for `XBoundaryFunction`, `YBoundaryFunction` and `ZBoundaryFunction`); > ; > we can probably add here the `getbc` method for a _continuous_ immersed boundary condition. This is a specific choice that depends on the boundary condition one is trying to implement. For ""simple"" boundary conditions, we don't need to invoke `ImmersedBoundaryCondition` because. https://github.com/CliMA/Oceananigans.jl/blob/95206ae73e10460beebb2ce9d5fc9945523e5724/src/ImmersedBoundaries/immersed_boundary_condition.jl#L242-L245. For boundary conditions that impose _only bottom drag_ but _not_ side drag, then we do need to use `ImmersedBoundaryCondition` as indicated.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2632#issuecomment-1171935502
Deployability,continuous,continuous,"> > I think the immersed boundary condition should be an `ImmersedBoundaryCondition`; > > ```; > > @inline linear_drag(i, j, k, grid, clock, fields) = - 0.2 * fields.u[i, j, k]; > > ; > > drag_u = FluxBoundaryCondition(linear_drag, discrete_form=true); > > u_immersed_bc = ImmersedBoundaryCondition(bottom = drag_u); > > u_bcs = FieldBoundaryConditions(bottom = drag_u, immersed = u_immersed_bc); > > ```; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > I do not think we can use the continuous form because `ImmersedBoundaryCondition` should behave just as another `FieldBoundaryCondition` which is 3D instead of 2D and I do not see a `getbc` defined for a `3DBoundaryFunction` (they are only defined for `XBoundaryFunction`, `YBoundaryFunction` and `ZBoundaryFunction`); > > we can probably add here the `getbc` method for a _continuous_ immersed boundary condition; > ; > This is a specific choice that depends on the boundary condition one is trying to implement. For ""simple"" boundary conditions, we don't need to invoke `ImmersedBoundaryCondition` because; > ; > https://github.com/CliMA/Oceananigans.jl/blob/95206ae73e10460beebb2ce9d5fc9945523e5724/src/ImmersedBoundaries/immersed_boundary_condition.jl#L242-L245; > ; > For boundary conditions that impose _only bottom drag_ but _not_ side drag, then we do need to use `ImmersedBoundaryCondition` as indicated. Shall I leave it like this? Bottom drag is usually applied at the bottom (not the sides) so the example is relevant and useful to many applications. Is it too elaborate though?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2632#issuecomment-1171942524
Integrability,depend,depends,"> > I think the immersed boundary condition should be an `ImmersedBoundaryCondition`; > > ```; > > @inline linear_drag(i, j, k, grid, clock, fields) = - 0.2 * fields.u[i, j, k]; > > ; > > drag_u = FluxBoundaryCondition(linear_drag, discrete_form=true); > > u_immersed_bc = ImmersedBoundaryCondition(bottom = drag_u); > > u_bcs = FieldBoundaryConditions(bottom = drag_u, immersed = u_immersed_bc); > > ```; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > I do not think we can use the continuous form because `ImmersedBoundaryCondition` should behave just as another `FieldBoundaryCondition` which is 3D instead of 2D and I do not see a `getbc` defined for a `3DBoundaryFunction` (they are only defined for `XBoundaryFunction`, `YBoundaryFunction` and `ZBoundaryFunction`); > > we can probably add here the `getbc` method for a _continuous_ immersed boundary condition; > ; > This is a specific choice that depends on the boundary condition one is trying to implement. For ""simple"" boundary conditions, we don't need to invoke `ImmersedBoundaryCondition` because; > ; > https://github.com/CliMA/Oceananigans.jl/blob/95206ae73e10460beebb2ce9d5fc9945523e5724/src/ImmersedBoundaries/immersed_boundary_condition.jl#L242-L245; > ; > For boundary conditions that impose _only bottom drag_ but _not_ side drag, then we do need to use `ImmersedBoundaryCondition` as indicated. Shall I leave it like this? Bottom drag is usually applied at the bottom (not the sides) so the example is relevant and useful to many applications. Is it too elaborate though?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2632#issuecomment-1171942524
Usability,simpl,simple,"> > I think the immersed boundary condition should be an `ImmersedBoundaryCondition`; > > ```; > > @inline linear_drag(i, j, k, grid, clock, fields) = - 0.2 * fields.u[i, j, k]; > > ; > > drag_u = FluxBoundaryCondition(linear_drag, discrete_form=true); > > u_immersed_bc = ImmersedBoundaryCondition(bottom = drag_u); > > u_bcs = FieldBoundaryConditions(bottom = drag_u, immersed = u_immersed_bc); > > ```; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > I do not think we can use the continuous form because `ImmersedBoundaryCondition` should behave just as another `FieldBoundaryCondition` which is 3D instead of 2D and I do not see a `getbc` defined for a `3DBoundaryFunction` (they are only defined for `XBoundaryFunction`, `YBoundaryFunction` and `ZBoundaryFunction`); > > we can probably add here the `getbc` method for a _continuous_ immersed boundary condition; > ; > This is a specific choice that depends on the boundary condition one is trying to implement. For ""simple"" boundary conditions, we don't need to invoke `ImmersedBoundaryCondition` because; > ; > https://github.com/CliMA/Oceananigans.jl/blob/95206ae73e10460beebb2ce9d5fc9945523e5724/src/ImmersedBoundaries/immersed_boundary_condition.jl#L242-L245; > ; > For boundary conditions that impose _only bottom drag_ but _not_ side drag, then we do need to use `ImmersedBoundaryCondition` as indicated. Shall I leave it like this? Bottom drag is usually applied at the bottom (not the sides) so the example is relevant and useful to many applications. Is it too elaborate though?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2632#issuecomment-1171942524
Deployability,continuous,continuous,"> > > I think the immersed boundary condition should be an `ImmersedBoundaryCondition`; > > > ```; > > > @inline linear_drag(i, j, k, grid, clock, fields) = - 0.2 * fields.u[i, j, k]; > > > ; > > > drag_u = FluxBoundaryCondition(linear_drag, discrete_form=true); > > > u_immersed_bc = ImmersedBoundaryCondition(bottom = drag_u); > > > u_bcs = FieldBoundaryConditions(bottom = drag_u, immersed = u_immersed_bc); > > > ```; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > I do not think we can use the continuous form because `ImmersedBoundaryCondition` should behave just as another `FieldBoundaryCondition` which is 3D instead of 2D and I do not see a `getbc` defined for a `3DBoundaryFunction` (they are only defined for `XBoundaryFunction`, `YBoundaryFunction` and `ZBoundaryFunction`); > > > we can probably add here the `getbc` method for a _continuous_ immersed boundary condition; > > ; > > ; > > This is a specific choice that depends on the boundary condition one is trying to implement. For ""simple"" boundary conditions, we don't need to invoke `ImmersedBoundaryCondition` because; > > https://github.com/CliMA/Oceananigans.jl/blob/95206ae73e10460beebb2ce9d5fc9945523e5724/src/ImmersedBoundaries/immersed_boundary_condition.jl#L242-L245; > > ; > > For boundary conditions that impose _only bottom drag_ but _not_ side drag, then we do need to use `ImmersedBoundaryCondition` as indicated.; > ; > Shall I leave it like this? Bottom drag is usually applied at the bottom (not the sides) so the example is relevant and useful to many applications. Is it too elaborate though?. I think if its a common application, it's important to demonstrate.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2632#issuecomment-1171946378
Integrability,depend,depends,"> > > I think the immersed boundary condition should be an `ImmersedBoundaryCondition`; > > > ```; > > > @inline linear_drag(i, j, k, grid, clock, fields) = - 0.2 * fields.u[i, j, k]; > > > ; > > > drag_u = FluxBoundaryCondition(linear_drag, discrete_form=true); > > > u_immersed_bc = ImmersedBoundaryCondition(bottom = drag_u); > > > u_bcs = FieldBoundaryConditions(bottom = drag_u, immersed = u_immersed_bc); > > > ```; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > I do not think we can use the continuous form because `ImmersedBoundaryCondition` should behave just as another `FieldBoundaryCondition` which is 3D instead of 2D and I do not see a `getbc` defined for a `3DBoundaryFunction` (they are only defined for `XBoundaryFunction`, `YBoundaryFunction` and `ZBoundaryFunction`); > > > we can probably add here the `getbc` method for a _continuous_ immersed boundary condition; > > ; > > ; > > This is a specific choice that depends on the boundary condition one is trying to implement. For ""simple"" boundary conditions, we don't need to invoke `ImmersedBoundaryCondition` because; > > https://github.com/CliMA/Oceananigans.jl/blob/95206ae73e10460beebb2ce9d5fc9945523e5724/src/ImmersedBoundaries/immersed_boundary_condition.jl#L242-L245; > > ; > > For boundary conditions that impose _only bottom drag_ but _not_ side drag, then we do need to use `ImmersedBoundaryCondition` as indicated.; > ; > Shall I leave it like this? Bottom drag is usually applied at the bottom (not the sides) so the example is relevant and useful to many applications. Is it too elaborate though?. I think if its a common application, it's important to demonstrate.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2632#issuecomment-1171946378
Usability,simpl,simple,"> > > I think the immersed boundary condition should be an `ImmersedBoundaryCondition`; > > > ```; > > > @inline linear_drag(i, j, k, grid, clock, fields) = - 0.2 * fields.u[i, j, k]; > > > ; > > > drag_u = FluxBoundaryCondition(linear_drag, discrete_form=true); > > > u_immersed_bc = ImmersedBoundaryCondition(bottom = drag_u); > > > u_bcs = FieldBoundaryConditions(bottom = drag_u, immersed = u_immersed_bc); > > > ```; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > I do not think we can use the continuous form because `ImmersedBoundaryCondition` should behave just as another `FieldBoundaryCondition` which is 3D instead of 2D and I do not see a `getbc` defined for a `3DBoundaryFunction` (they are only defined for `XBoundaryFunction`, `YBoundaryFunction` and `ZBoundaryFunction`); > > > we can probably add here the `getbc` method for a _continuous_ immersed boundary condition; > > ; > > ; > > This is a specific choice that depends on the boundary condition one is trying to implement. For ""simple"" boundary conditions, we don't need to invoke `ImmersedBoundaryCondition` because; > > https://github.com/CliMA/Oceananigans.jl/blob/95206ae73e10460beebb2ce9d5fc9945523e5724/src/ImmersedBoundaries/immersed_boundary_condition.jl#L242-L245; > > ; > > For boundary conditions that impose _only bottom drag_ but _not_ side drag, then we do need to use `ImmersedBoundaryCondition` as indicated.; > ; > Shall I leave it like this? Bottom drag is usually applied at the bottom (not the sides) so the example is relevant and useful to many applications. Is it too elaborate though?. I think if its a common application, it's important to demonstrate.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2632#issuecomment-1171946378
Integrability,depend,depends,"> Do we currently have a function to retrieve spacings that considers whether a cell is ""wet"" or not?. ```julia; inactive_node(i, j, k, grid, lx, ly, lz); ```. returns `true` if a cell is immersed / inactive, and `false` if a cell is active. The boundary points are special, because their status depends on whether they are a prognostic or diagnostic field. Therefore we have another function,. ```julia; peripheral_node(i, j, k, grid, lx, ly, lz); ```. which returns true if a cell is inactive _or_ if it lies on the boundary between active and inactive (ie, the ""periphery"" of the domain). This distinction is only meaningful for `Face`-centered fields: `Center` locations cannot lie on the boundary. > ```julia; > julia> using Oceananigans; > ; > julia> grid = RectilinearGrid(size = (4, 4, 4), x=(0,1), y=(0,1), z=0:0.25:1); > 4×4×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; > ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.25; > ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=0.25; > └── Bounded z ∈ [0.0, 1.0] variably spaced with min(Δz)=0.25, max(Δz)=0.25; > ; > julia> grid.Δzᵃᵃᶠ[1:grid.Nz+1]; > 5-element Vector{Float64}:; > 0.25; > 0.25; > 0.25; > 0.25; > 0.25; > ```; > ; > To be in line with [`xgcm`'s standards for metrics](https://github.com/xgcm/xgcm/issues/306#issuecomment-776124591) the output in the above case (considering only the ""wet"" or interior or fluid-filled cells when calculating `Δz`) should be; > ; > ```julia; > julia> grid.Δzᵃᵃᶠ[1:grid.Nz+1]; > 5-element Vector{Float64}:; > 0.125; > 0.25; > 0.25; > 0.25; > 0.125; > ```; > ; > since the first and last spacings on a bounded grid are ""half inside the domain and half outside"". Are you sure? For immersed boundaries, this would mean that all the metrics must be 3D arrays even when the grid directions are separable --- greatly inflating the size of your output file. > Or maybe there's a way to use abstract operation metrics to do this that I'm not aware?. It is sim",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2652#issuecomment-1516655561
Modifiability,variab,variably,"cell is ""wet"" or not?. ```julia; inactive_node(i, j, k, grid, lx, ly, lz); ```. returns `true` if a cell is immersed / inactive, and `false` if a cell is active. The boundary points are special, because their status depends on whether they are a prognostic or diagnostic field. Therefore we have another function,. ```julia; peripheral_node(i, j, k, grid, lx, ly, lz); ```. which returns true if a cell is inactive _or_ if it lies on the boundary between active and inactive (ie, the ""periphery"" of the domain). This distinction is only meaningful for `Face`-centered fields: `Center` locations cannot lie on the boundary. > ```julia; > julia> using Oceananigans; > ; > julia> grid = RectilinearGrid(size = (4, 4, 4), x=(0,1), y=(0,1), z=0:0.25:1); > 4×4×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; > ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.25; > ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=0.25; > └── Bounded z ∈ [0.0, 1.0] variably spaced with min(Δz)=0.25, max(Δz)=0.25; > ; > julia> grid.Δzᵃᵃᶠ[1:grid.Nz+1]; > 5-element Vector{Float64}:; > 0.25; > 0.25; > 0.25; > 0.25; > 0.25; > ```; > ; > To be in line with [`xgcm`'s standards for metrics](https://github.com/xgcm/xgcm/issues/306#issuecomment-776124591) the output in the above case (considering only the ""wet"" or interior or fluid-filled cells when calculating `Δz`) should be; > ; > ```julia; > julia> grid.Δzᵃᵃᶠ[1:grid.Nz+1]; > 5-element Vector{Float64}:; > 0.125; > 0.25; > 0.25; > 0.25; > 0.125; > ```; > ; > since the first and last spacings on a bounded grid are ""half inside the domain and half outside"". Are you sure? For immersed boundaries, this would mean that all the metrics must be 3D arrays even when the grid directions are separable --- greatly inflating the size of your output file. > Or maybe there's a way to use abstract operation metrics to do this that I'm not aware?. It is simple. Write a `KernelFunctionOperation` that checks if a node is `peripheral_nod",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2652#issuecomment-1516655561
Usability,simpl,simple," > julia> grid = RectilinearGrid(size = (4, 4, 4), x=(0,1), y=(0,1), z=0:0.25:1); > 4×4×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; > ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.25; > ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=0.25; > └── Bounded z ∈ [0.0, 1.0] variably spaced with min(Δz)=0.25, max(Δz)=0.25; > ; > julia> grid.Δzᵃᵃᶠ[1:grid.Nz+1]; > 5-element Vector{Float64}:; > 0.25; > 0.25; > 0.25; > 0.25; > 0.25; > ```; > ; > To be in line with [`xgcm`'s standards for metrics](https://github.com/xgcm/xgcm/issues/306#issuecomment-776124591) the output in the above case (considering only the ""wet"" or interior or fluid-filled cells when calculating `Δz`) should be; > ; > ```julia; > julia> grid.Δzᵃᵃᶠ[1:grid.Nz+1]; > 5-element Vector{Float64}:; > 0.125; > 0.25; > 0.25; > 0.25; > 0.125; > ```; > ; > since the first and last spacings on a bounded grid are ""half inside the domain and half outside"". Are you sure? For immersed boundaries, this would mean that all the metrics must be 3D arrays even when the grid directions are separable --- greatly inflating the size of your output file. > Or maybe there's a way to use abstract operation metrics to do this that I'm not aware?. It is simple. Write a `KernelFunctionOperation` that checks if a node is `peripheral_node`. If `true`, divide the metric by 2, otherwise, return the metric unchanged. However, as noted above, I'm not sure this is what you want. Perhaps there is a purpose to the convention that divides the cell sizes on the boundary by 2. However, I'm worried this could be misleading regarding how the staggered finite volume grid and its diagnostics are interpreted. Another concern is that modifying metrics prior to output will lead to difficulties in reproducible diagnostics in the future between xgcm computations and native Oceanangians computations. So in this case I hope we can keep things simple and simply save whatever `xspacings`, etc outputs, if possible.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2652#issuecomment-1516655561
Usability,simpl,simply,"Perhaps this simply means that we should keep the name `taper_factor_ccc`, but redefine its implementation to be more stable along the lines you're suggesting?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2664#issuecomment-1185957960
Usability,undo,undo,We can undo this. Didn't know.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2699#issuecomment-1235829416
Usability,undo,undoing,Def not worth undoing!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2699#issuecomment-1235869936
Availability,error,error,"> Edit: Possibly could just remove a lot of the information from the fields using the `adapt_structure` method from [PR #1057](https://github.com/CliMA/Oceananigans.jl/pull/1057)?. We already do ""unwrap"" data from fields on the GPU:. https://github.com/CliMA/Oceananigans.jl/blob/ea6826fd2ffaed3f0df330cc952667ec878deb6a/src/Fields/field.jl#L368. > I realised it would be much harder to reduce the parameter size of the tracer tendency function if the tracers depend on lots of other tracers. Okay, this makes sense. Solving the problem for `calculate_Gu` just bumps the error down to `calculate_tracer_tendency`, and the issue isn't tractable in that case, since it's clearly important to support tracer forcing functions that depend on other tracers (eg for biogeochemical models). Can you provide a minimum script that reproduces the error? I do think many tracers is an important use case so solving this could warrant reducing the kinds of forcing functions we support --- if that's necessary. I think there also may be solutions that don't change what we support while still solving this problem; eg we provide some features that extend model capabilities specifically for the case of large numbers of tracers. For example, we could avoid passing the tracers explicitly into the kernels. Instead, we can attach references _only_ to the relevant / used fields directly in `Forcing` (we'd have to change the user API to `DiscreteForcing` to support this, but the changes need not be major). This way one might be able to support systems of reacting tracers, as well as many ""additional"" passive tracers that are not involved in a forcing function. Or, we can explore https://github.com/JuliaGPU/CUDA.jl/issues/267.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2700#issuecomment-1223989878
Energy Efficiency,reduce,reduce,"> Edit: Possibly could just remove a lot of the information from the fields using the `adapt_structure` method from [PR #1057](https://github.com/CliMA/Oceananigans.jl/pull/1057)?. We already do ""unwrap"" data from fields on the GPU:. https://github.com/CliMA/Oceananigans.jl/blob/ea6826fd2ffaed3f0df330cc952667ec878deb6a/src/Fields/field.jl#L368. > I realised it would be much harder to reduce the parameter size of the tracer tendency function if the tracers depend on lots of other tracers. Okay, this makes sense. Solving the problem for `calculate_Gu` just bumps the error down to `calculate_tracer_tendency`, and the issue isn't tractable in that case, since it's clearly important to support tracer forcing functions that depend on other tracers (eg for biogeochemical models). Can you provide a minimum script that reproduces the error? I do think many tracers is an important use case so solving this could warrant reducing the kinds of forcing functions we support --- if that's necessary. I think there also may be solutions that don't change what we support while still solving this problem; eg we provide some features that extend model capabilities specifically for the case of large numbers of tracers. For example, we could avoid passing the tracers explicitly into the kernels. Instead, we can attach references _only_ to the relevant / used fields directly in `Forcing` (we'd have to change the user API to `DiscreteForcing` to support this, but the changes need not be major). This way one might be able to support systems of reacting tracers, as well as many ""additional"" passive tracers that are not involved in a forcing function. Or, we can explore https://github.com/JuliaGPU/CUDA.jl/issues/267.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2700#issuecomment-1223989878
Integrability,depend,depend,"> Edit: Possibly could just remove a lot of the information from the fields using the `adapt_structure` method from [PR #1057](https://github.com/CliMA/Oceananigans.jl/pull/1057)?. We already do ""unwrap"" data from fields on the GPU:. https://github.com/CliMA/Oceananigans.jl/blob/ea6826fd2ffaed3f0df330cc952667ec878deb6a/src/Fields/field.jl#L368. > I realised it would be much harder to reduce the parameter size of the tracer tendency function if the tracers depend on lots of other tracers. Okay, this makes sense. Solving the problem for `calculate_Gu` just bumps the error down to `calculate_tracer_tendency`, and the issue isn't tractable in that case, since it's clearly important to support tracer forcing functions that depend on other tracers (eg for biogeochemical models). Can you provide a minimum script that reproduces the error? I do think many tracers is an important use case so solving this could warrant reducing the kinds of forcing functions we support --- if that's necessary. I think there also may be solutions that don't change what we support while still solving this problem; eg we provide some features that extend model capabilities specifically for the case of large numbers of tracers. For example, we could avoid passing the tracers explicitly into the kernels. Instead, we can attach references _only_ to the relevant / used fields directly in `Forcing` (we'd have to change the user API to `DiscreteForcing` to support this, but the changes need not be major). This way one might be able to support systems of reacting tracers, as well as many ""additional"" passive tracers that are not involved in a forcing function. Or, we can explore https://github.com/JuliaGPU/CUDA.jl/issues/267.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2700#issuecomment-1223989878
Modifiability,extend,extend,"> Edit: Possibly could just remove a lot of the information from the fields using the `adapt_structure` method from [PR #1057](https://github.com/CliMA/Oceananigans.jl/pull/1057)?. We already do ""unwrap"" data from fields on the GPU:. https://github.com/CliMA/Oceananigans.jl/blob/ea6826fd2ffaed3f0df330cc952667ec878deb6a/src/Fields/field.jl#L368. > I realised it would be much harder to reduce the parameter size of the tracer tendency function if the tracers depend on lots of other tracers. Okay, this makes sense. Solving the problem for `calculate_Gu` just bumps the error down to `calculate_tracer_tendency`, and the issue isn't tractable in that case, since it's clearly important to support tracer forcing functions that depend on other tracers (eg for biogeochemical models). Can you provide a minimum script that reproduces the error? I do think many tracers is an important use case so solving this could warrant reducing the kinds of forcing functions we support --- if that's necessary. I think there also may be solutions that don't change what we support while still solving this problem; eg we provide some features that extend model capabilities specifically for the case of large numbers of tracers. For example, we could avoid passing the tracers explicitly into the kernels. Instead, we can attach references _only_ to the relevant / used fields directly in `Forcing` (we'd have to change the user API to `DiscreteForcing` to support this, but the changes need not be major). This way one might be able to support systems of reacting tracers, as well as many ""additional"" passive tracers that are not involved in a forcing function. Or, we can explore https://github.com/JuliaGPU/CUDA.jl/issues/267.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2700#issuecomment-1223989878
Safety,avoid,avoid,"> Edit: Possibly could just remove a lot of the information from the fields using the `adapt_structure` method from [PR #1057](https://github.com/CliMA/Oceananigans.jl/pull/1057)?. We already do ""unwrap"" data from fields on the GPU:. https://github.com/CliMA/Oceananigans.jl/blob/ea6826fd2ffaed3f0df330cc952667ec878deb6a/src/Fields/field.jl#L368. > I realised it would be much harder to reduce the parameter size of the tracer tendency function if the tracers depend on lots of other tracers. Okay, this makes sense. Solving the problem for `calculate_Gu` just bumps the error down to `calculate_tracer_tendency`, and the issue isn't tractable in that case, since it's clearly important to support tracer forcing functions that depend on other tracers (eg for biogeochemical models). Can you provide a minimum script that reproduces the error? I do think many tracers is an important use case so solving this could warrant reducing the kinds of forcing functions we support --- if that's necessary. I think there also may be solutions that don't change what we support while still solving this problem; eg we provide some features that extend model capabilities specifically for the case of large numbers of tracers. For example, we could avoid passing the tracers explicitly into the kernels. Instead, we can attach references _only_ to the relevant / used fields directly in `Forcing` (we'd have to change the user API to `DiscreteForcing` to support this, but the changes need not be major). This way one might be able to support systems of reacting tracers, as well as many ""additional"" passive tracers that are not involved in a forcing function. Or, we can explore https://github.com/JuliaGPU/CUDA.jl/issues/267.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2700#issuecomment-1223989878
Usability,clear,clearly,"> Edit: Possibly could just remove a lot of the information from the fields using the `adapt_structure` method from [PR #1057](https://github.com/CliMA/Oceananigans.jl/pull/1057)?. We already do ""unwrap"" data from fields on the GPU:. https://github.com/CliMA/Oceananigans.jl/blob/ea6826fd2ffaed3f0df330cc952667ec878deb6a/src/Fields/field.jl#L368. > I realised it would be much harder to reduce the parameter size of the tracer tendency function if the tracers depend on lots of other tracers. Okay, this makes sense. Solving the problem for `calculate_Gu` just bumps the error down to `calculate_tracer_tendency`, and the issue isn't tractable in that case, since it's clearly important to support tracer forcing functions that depend on other tracers (eg for biogeochemical models). Can you provide a minimum script that reproduces the error? I do think many tracers is an important use case so solving this could warrant reducing the kinds of forcing functions we support --- if that's necessary. I think there also may be solutions that don't change what we support while still solving this problem; eg we provide some features that extend model capabilities specifically for the case of large numbers of tracers. For example, we could avoid passing the tracers explicitly into the kernels. Instead, we can attach references _only_ to the relevant / used fields directly in `Forcing` (we'd have to change the user API to `DiscreteForcing` to support this, but the changes need not be major). This way one might be able to support systems of reacting tracers, as well as many ""additional"" passive tracers that are not involved in a forcing function. Or, we can explore https://github.com/JuliaGPU/CUDA.jl/issues/267.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2700#issuecomment-1223989878
Usability,intuit,intuitive,"I would argue that `SpecifiedTimes` shouldn't be actuated in iteration 0 since, if that is desired by the user, it's trivially easy to add zero to the list of times. I also think it's counter-intuitive to have something with `SpecifiedTimes([5, 10])` to actuate at `t=[0, 5, 10]` in practice, although I guess that's up for debate. If no one opposes this, I can open a PR to make this change.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2719#issuecomment-1233399368
Energy Efficiency,schedul,schedule,"What if we add this feature to `Callback`? I.e. ```julia; struct Callback{P, F, S, I}; func :: F; schedule :: S; parameters :: P; initialize :: I; end; ```. Then by default we set. ```julia; Callback(; ..., initialize=call_at_iteration_0); ```. where. ```julia; call_at_iteration_0(callback, simulation) = iteration(simulation) == 0 && callback(simulation); ```. so the default ""initialization"" is simply to ""call"" the callback at iteration 0 (as we currently do). Users can cancel this by setting `initialize=nothing` or providing some alternative function. Finally, rather than calling all the callbacks at iteration 0, we instead call `Callback.initialize!` for every callback inside `initalize_simulation!`:. https://github.com/CliMA/Oceananigans.jl/blob/af21542ba01afe92e7fc4de6251dec55ed5182c7/src/Simulations/run.jl#L166. For ""finalization"" we need a bit more work, since I think we want to add the concept of finalizing a simulation as well, so we might need `Simulation.finalized`. That's probably a nice idea too though.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2719#issuecomment-1238518501
Usability,simpl,simply,"What if we add this feature to `Callback`? I.e. ```julia; struct Callback{P, F, S, I}; func :: F; schedule :: S; parameters :: P; initialize :: I; end; ```. Then by default we set. ```julia; Callback(; ..., initialize=call_at_iteration_0); ```. where. ```julia; call_at_iteration_0(callback, simulation) = iteration(simulation) == 0 && callback(simulation); ```. so the default ""initialization"" is simply to ""call"" the callback at iteration 0 (as we currently do). Users can cancel this by setting `initialize=nothing` or providing some alternative function. Finally, rather than calling all the callbacks at iteration 0, we instead call `Callback.initialize!` for every callback inside `initalize_simulation!`:. https://github.com/CliMA/Oceananigans.jl/blob/af21542ba01afe92e7fc4de6251dec55ed5182c7/src/Simulations/run.jl#L166. For ""finalization"" we need a bit more work, since I think we want to add the concept of finalizing a simulation as well, so we might need `Simulation.finalized`. That's probably a nice idea too though.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2719#issuecomment-1238518501
Integrability,message,message,I tested this with the simple case from discussion #2720 and with the Bickley Jet example adding a CFL calculation to a status message. It looks like CFL is calculated correctly and the `TimeStepWizard` is functioning properly now.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2721#issuecomment-1239578989
Testability,test,tested,I tested this with the simple case from discussion #2720 and with the Bickley Jet example adding a CFL calculation to a status message. It looks like CFL is calculated correctly and the `TimeStepWizard` is functioning properly now.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2721#issuecomment-1239578989
Usability,simpl,simple,I tested this with the simple case from discussion #2720 and with the Bickley Jet example adding a CFL calculation to a status message. It looks like CFL is calculated correctly and the `TimeStepWizard` is functioning properly now.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2721#issuecomment-1239578989
Usability,simpl,simple,"now `norm` seems that it's not working for simple RectilinearGrid :); E.g., in the pgc solver, `residual_norm = norm(solver.residual)` gives zero... even when q=0 but rhs $\ne$ 0.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2723#issuecomment-1247693563
Deployability,integrat,integrate,"> Particle setup: particles can get a parameter called active_properties which is a tuple of named tuples of particle properties and tracers (e.g. ((property=:t, tracer=:x),).) The idea being that the particle dynamics function (as already implemented) changes the particle property to set a rate of uptake/exudation of a tracer, and the below function would integrate this change to the specified tracer. Can you please restate this? I think a code example would be helpful with an explanation on what's being accomplished. Also can you explain why this can't be implemented with a Callback (or forcing function)? I.e., why do we desire this as a source code feature? Just to be clear, I'm not saying it should be one way or another, but it's good to have explicit justification for source code features (which are expensive to maintain and require resources to test)!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1238507827
Integrability,integrat,integrate,"> Particle setup: particles can get a parameter called active_properties which is a tuple of named tuples of particle properties and tracers (e.g. ((property=:t, tracer=:x),).) The idea being that the particle dynamics function (as already implemented) changes the particle property to set a rate of uptake/exudation of a tracer, and the below function would integrate this change to the specified tracer. Can you please restate this? I think a code example would be helpful with an explanation on what's being accomplished. Also can you explain why this can't be implemented with a Callback (or forcing function)? I.e., why do we desire this as a source code feature? Just to be clear, I'm not saying it should be one way or another, but it's good to have explicit justification for source code features (which are expensive to maintain and require resources to test)!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1238507827
Testability,test,test,"> Particle setup: particles can get a parameter called active_properties which is a tuple of named tuples of particle properties and tracers (e.g. ((property=:t, tracer=:x),).) The idea being that the particle dynamics function (as already implemented) changes the particle property to set a rate of uptake/exudation of a tracer, and the below function would integrate this change to the specified tracer. Can you please restate this? I think a code example would be helpful with an explanation on what's being accomplished. Also can you explain why this can't be implemented with a Callback (or forcing function)? I.e., why do we desire this as a source code feature? Just to be clear, I'm not saying it should be one way or another, but it's good to have explicit justification for source code features (which are expensive to maintain and require resources to test)!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1238507827
Usability,clear,clear,"> Particle setup: particles can get a parameter called active_properties which is a tuple of named tuples of particle properties and tracers (e.g. ((property=:t, tracer=:x),).) The idea being that the particle dynamics function (as already implemented) changes the particle property to set a rate of uptake/exudation of a tracer, and the below function would integrate this change to the specified tracer. Can you please restate this? I think a code example would be helpful with an explanation on what's being accomplished. Also can you explain why this can't be implemented with a Callback (or forcing function)? I.e., why do we desire this as a source code feature? Just to be clear, I'm not saying it should be one way or another, but it's good to have explicit justification for source code features (which are expensive to maintain and require resources to test)!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1238507827
Deployability,release,release,"> Can you please restate this? I think a code example would be helpful with an explanation on what's being accomplished. Also can you explain why this can't be implemented with a Callback (or forcing function)? I.e., why do we desire this as a source code feature? Just to be clear, I'm not saying it should be one way or another, but it's good to have explicit justification for source code features (which are expensive to maintain and require resources to test)!. No problem at all, [heres](https://gist.github.com/jagoosw/213d7f2ce3707768d4ddb07f8827cdd2) an example (not sure where best to put this/if you'd want it in the examples folder). This is about the simplest version I could think of where we have a particle randomly walking around converting tracer a into tracer b. The specific use case we've been using this for is modelling kelp fronds as particles which grow (variety of particle properties change) depending on how much nutrients the particles uptake from a biogeochemical model, and also release tracer back into the model. I also envisage using this to exert drag on the flow at some point. ![test](https://user-images.githubusercontent.com/26657828/188803448-86bc2fe2-dbbc-447a-93c6-ff238f6dde06.gif). Although I've had this working as custom dynamics of the particles the effect of the particles tendency can only be integrated with explicit Euler, i.e. at each substep it just does `tracer[i, j, k] += value*Δt`, where as this solution allows it to be properly integrated along with the other tendencies. I couldn't think of a way to implement this as a forcing function before, but perhaps I could use a callback to update an auxiliary field with the tendencies of the particles, and then add this as a forcing function, although I imagine that could use a lot more memory if there were a large grid and small amount of particles. (I fix the tests that's failed until we've discussed the other changes since its only failed because I forgot to change `getmask` to `get_mask`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1238958939
Integrability,depend,depending,"> Can you please restate this? I think a code example would be helpful with an explanation on what's being accomplished. Also can you explain why this can't be implemented with a Callback (or forcing function)? I.e., why do we desire this as a source code feature? Just to be clear, I'm not saying it should be one way or another, but it's good to have explicit justification for source code features (which are expensive to maintain and require resources to test)!. No problem at all, [heres](https://gist.github.com/jagoosw/213d7f2ce3707768d4ddb07f8827cdd2) an example (not sure where best to put this/if you'd want it in the examples folder). This is about the simplest version I could think of where we have a particle randomly walking around converting tracer a into tracer b. The specific use case we've been using this for is modelling kelp fronds as particles which grow (variety of particle properties change) depending on how much nutrients the particles uptake from a biogeochemical model, and also release tracer back into the model. I also envisage using this to exert drag on the flow at some point. ![test](https://user-images.githubusercontent.com/26657828/188803448-86bc2fe2-dbbc-447a-93c6-ff238f6dde06.gif). Although I've had this working as custom dynamics of the particles the effect of the particles tendency can only be integrated with explicit Euler, i.e. at each substep it just does `tracer[i, j, k] += value*Δt`, where as this solution allows it to be properly integrated along with the other tendencies. I couldn't think of a way to implement this as a forcing function before, but perhaps I could use a callback to update an auxiliary field with the tendencies of the particles, and then add this as a forcing function, although I imagine that could use a lot more memory if there were a large grid and small amount of particles. (I fix the tests that's failed until we've discussed the other changes since its only failed because I forgot to change `getmask` to `get_mask`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1238958939
Testability,test,test,"> Can you please restate this? I think a code example would be helpful with an explanation on what's being accomplished. Also can you explain why this can't be implemented with a Callback (or forcing function)? I.e., why do we desire this as a source code feature? Just to be clear, I'm not saying it should be one way or another, but it's good to have explicit justification for source code features (which are expensive to maintain and require resources to test)!. No problem at all, [heres](https://gist.github.com/jagoosw/213d7f2ce3707768d4ddb07f8827cdd2) an example (not sure where best to put this/if you'd want it in the examples folder). This is about the simplest version I could think of where we have a particle randomly walking around converting tracer a into tracer b. The specific use case we've been using this for is modelling kelp fronds as particles which grow (variety of particle properties change) depending on how much nutrients the particles uptake from a biogeochemical model, and also release tracer back into the model. I also envisage using this to exert drag on the flow at some point. ![test](https://user-images.githubusercontent.com/26657828/188803448-86bc2fe2-dbbc-447a-93c6-ff238f6dde06.gif). Although I've had this working as custom dynamics of the particles the effect of the particles tendency can only be integrated with explicit Euler, i.e. at each substep it just does `tracer[i, j, k] += value*Δt`, where as this solution allows it to be properly integrated along with the other tendencies. I couldn't think of a way to implement this as a forcing function before, but perhaps I could use a callback to update an auxiliary field with the tendencies of the particles, and then add this as a forcing function, although I imagine that could use a lot more memory if there were a large grid and small amount of particles. (I fix the tests that's failed until we've discussed the other changes since its only failed because I forgot to change `getmask` to `get_mask`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1238958939
Usability,clear,clear,"> Can you please restate this? I think a code example would be helpful with an explanation on what's being accomplished. Also can you explain why this can't be implemented with a Callback (or forcing function)? I.e., why do we desire this as a source code feature? Just to be clear, I'm not saying it should be one way or another, but it's good to have explicit justification for source code features (which are expensive to maintain and require resources to test)!. No problem at all, [heres](https://gist.github.com/jagoosw/213d7f2ce3707768d4ddb07f8827cdd2) an example (not sure where best to put this/if you'd want it in the examples folder). This is about the simplest version I could think of where we have a particle randomly walking around converting tracer a into tracer b. The specific use case we've been using this for is modelling kelp fronds as particles which grow (variety of particle properties change) depending on how much nutrients the particles uptake from a biogeochemical model, and also release tracer back into the model. I also envisage using this to exert drag on the flow at some point. ![test](https://user-images.githubusercontent.com/26657828/188803448-86bc2fe2-dbbc-447a-93c6-ff238f6dde06.gif). Although I've had this working as custom dynamics of the particles the effect of the particles tendency can only be integrated with explicit Euler, i.e. at each substep it just does `tracer[i, j, k] += value*Δt`, where as this solution allows it to be properly integrated along with the other tendencies. I couldn't think of a way to implement this as a forcing function before, but perhaps I could use a callback to update an auxiliary field with the tendencies of the particles, and then add this as a forcing function, although I imagine that could use a lot more memory if there were a large grid and small amount of particles. (I fix the tests that's failed until we've discussed the other changes since its only failed because I forgot to change `getmask` to `get_mask`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1238958939
Deployability,release,release,"> > Can you please restate this? I think a code example would be helpful with an explanation on what's being accomplished. Also can you explain why this can't be implemented with a Callback (or forcing function)? I.e., why do we desire this as a source code feature? Just to be clear, I'm not saying it should be one way or another, but it's good to have explicit justification for source code features (which are expensive to maintain and require resources to test)!; > ; > No problem at all, [heres](https://gist.github.com/jagoosw/213d7f2ce3707768d4ddb07f8827cdd2) an example (not sure where best to put this/if you'd want it in the examples folder). This is about the simplest version I could think of where we have a particle randomly walking around converting tracer a into tracer b. The specific use case we've been using this for is modelling kelp fronds as particles which grow (variety of particle properties change) depending on how much nutrients the particles uptake from a biogeochemical model, and also release tracer back into the model. I also envisage using this to exert drag on the flow at some point.; > ; > ![test](https://user-images.githubusercontent.com/26657828/188803448-86bc2fe2-dbbc-447a-93c6-ff238f6dde06.gif) [ ![test](https://user-images.githubusercontent.com/26657828/188803448-86bc2fe2-dbbc-447a-93c6-ff238f6dde06.gif) ](https://user-images.githubusercontent.com/26657828/188803448-86bc2fe2-dbbc-447a-93c6-ff238f6dde06.gif) [ ](https://user-images.githubusercontent.com/26657828/188803448-86bc2fe2-dbbc-447a-93c6-ff238f6dde06.gif); > ; > Although I've had this working as custom dynamics of the particles the effect of the particles tendency can only be integrated with explicit Euler, i.e. at each substep it just does `tracer[i, j, k] += value*Δt`, where as this solution allows it to be properly integrated along with the other tendencies. I couldn't think of a way to implement this as a forcing function before, but perhaps I could use a callback to update an au",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1239608678
Integrability,depend,depending,"> > Can you please restate this? I think a code example would be helpful with an explanation on what's being accomplished. Also can you explain why this can't be implemented with a Callback (or forcing function)? I.e., why do we desire this as a source code feature? Just to be clear, I'm not saying it should be one way or another, but it's good to have explicit justification for source code features (which are expensive to maintain and require resources to test)!; > ; > No problem at all, [heres](https://gist.github.com/jagoosw/213d7f2ce3707768d4ddb07f8827cdd2) an example (not sure where best to put this/if you'd want it in the examples folder). This is about the simplest version I could think of where we have a particle randomly walking around converting tracer a into tracer b. The specific use case we've been using this for is modelling kelp fronds as particles which grow (variety of particle properties change) depending on how much nutrients the particles uptake from a biogeochemical model, and also release tracer back into the model. I also envisage using this to exert drag on the flow at some point.; > ; > ![test](https://user-images.githubusercontent.com/26657828/188803448-86bc2fe2-dbbc-447a-93c6-ff238f6dde06.gif) [ ![test](https://user-images.githubusercontent.com/26657828/188803448-86bc2fe2-dbbc-447a-93c6-ff238f6dde06.gif) ](https://user-images.githubusercontent.com/26657828/188803448-86bc2fe2-dbbc-447a-93c6-ff238f6dde06.gif) [ ](https://user-images.githubusercontent.com/26657828/188803448-86bc2fe2-dbbc-447a-93c6-ff238f6dde06.gif); > ; > Although I've had this working as custom dynamics of the particles the effect of the particles tendency can only be integrated with explicit Euler, i.e. at each substep it just does `tracer[i, j, k] += value*Δt`, where as this solution allows it to be properly integrated along with the other tendencies. I couldn't think of a way to implement this as a forcing function before, but perhaps I could use a callback to update an au",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1239608678
Testability,test,test,"> > Can you please restate this? I think a code example would be helpful with an explanation on what's being accomplished. Also can you explain why this can't be implemented with a Callback (or forcing function)? I.e., why do we desire this as a source code feature? Just to be clear, I'm not saying it should be one way or another, but it's good to have explicit justification for source code features (which are expensive to maintain and require resources to test)!; > ; > No problem at all, [heres](https://gist.github.com/jagoosw/213d7f2ce3707768d4ddb07f8827cdd2) an example (not sure where best to put this/if you'd want it in the examples folder). This is about the simplest version I could think of where we have a particle randomly walking around converting tracer a into tracer b. The specific use case we've been using this for is modelling kelp fronds as particles which grow (variety of particle properties change) depending on how much nutrients the particles uptake from a biogeochemical model, and also release tracer back into the model. I also envisage using this to exert drag on the flow at some point.; > ; > ![test](https://user-images.githubusercontent.com/26657828/188803448-86bc2fe2-dbbc-447a-93c6-ff238f6dde06.gif) [ ![test](https://user-images.githubusercontent.com/26657828/188803448-86bc2fe2-dbbc-447a-93c6-ff238f6dde06.gif) ](https://user-images.githubusercontent.com/26657828/188803448-86bc2fe2-dbbc-447a-93c6-ff238f6dde06.gif) [ ](https://user-images.githubusercontent.com/26657828/188803448-86bc2fe2-dbbc-447a-93c6-ff238f6dde06.gif); > ; > Although I've had this working as custom dynamics of the particles the effect of the particles tendency can only be integrated with explicit Euler, i.e. at each substep it just does `tracer[i, j, k] += value*Δt`, where as this solution allows it to be properly integrated along with the other tendencies. I couldn't think of a way to implement this as a forcing function before, but perhaps I could use a callback to update an au",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1239608678
Usability,clear,clear,"> > Can you please restate this? I think a code example would be helpful with an explanation on what's being accomplished. Also can you explain why this can't be implemented with a Callback (or forcing function)? I.e., why do we desire this as a source code feature? Just to be clear, I'm not saying it should be one way or another, but it's good to have explicit justification for source code features (which are expensive to maintain and require resources to test)!; > ; > No problem at all, [heres](https://gist.github.com/jagoosw/213d7f2ce3707768d4ddb07f8827cdd2) an example (not sure where best to put this/if you'd want it in the examples folder). This is about the simplest version I could think of where we have a particle randomly walking around converting tracer a into tracer b. The specific use case we've been using this for is modelling kelp fronds as particles which grow (variety of particle properties change) depending on how much nutrients the particles uptake from a biogeochemical model, and also release tracer back into the model. I also envisage using this to exert drag on the flow at some point.; > ; > ![test](https://user-images.githubusercontent.com/26657828/188803448-86bc2fe2-dbbc-447a-93c6-ff238f6dde06.gif) [ ![test](https://user-images.githubusercontent.com/26657828/188803448-86bc2fe2-dbbc-447a-93c6-ff238f6dde06.gif) ](https://user-images.githubusercontent.com/26657828/188803448-86bc2fe2-dbbc-447a-93c6-ff238f6dde06.gif) [ ](https://user-images.githubusercontent.com/26657828/188803448-86bc2fe2-dbbc-447a-93c6-ff238f6dde06.gif); > ; > Although I've had this working as custom dynamics of the particles the effect of the particles tendency can only be integrated with explicit Euler, i.e. at each substep it just does `tracer[i, j, k] += value*Δt`, where as this solution allows it to be properly integrated along with the other tendencies. I couldn't think of a way to implement this as a forcing function before, but perhaps I could use a callback to update an au",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1239608678
Energy Efficiency,energy,energy,"The advection-like Coriolis scheme was a non-sequitur because `f` is a very regular field, so upwinding it was just decreasing performance without a significative increase in quality of the simulation. On the other hand, upwinding `u` is very much discouraged because the energy builds up rapidly (by upwinding the velocity the divergence of the reconstructed tangential velocity is not a direct interpolation of the divergence of the original velocity, which is a necessary condition to maintain the algorithm stable). The only thing I can think to increase the order of velocity interpolation in the Coriolis force is to use a centered high-order scheme to interpolate velocity, but that would not help with the noise since a centered scheme is dispersive in nature. . I converted this PR to implement a `WetPointCoriolisScheme` (described in [Numerical boundary layers and spurious residual flows](https://agupubs.onlinelibrary.wiley.com/doi/abs/10.1029/JC091iC09p10621)). ; This is just a simple addition to an enstrophy conserving scheme where edge (""dry"") points are neglected in the interpolation of the velocity in the tangential direction. A comparison of the output of this scheme in a global 1 degree setup will follow",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2729#issuecomment-1252445272
Modifiability,layers,layers,"The advection-like Coriolis scheme was a non-sequitur because `f` is a very regular field, so upwinding it was just decreasing performance without a significative increase in quality of the simulation. On the other hand, upwinding `u` is very much discouraged because the energy builds up rapidly (by upwinding the velocity the divergence of the reconstructed tangential velocity is not a direct interpolation of the divergence of the original velocity, which is a necessary condition to maintain the algorithm stable). The only thing I can think to increase the order of velocity interpolation in the Coriolis force is to use a centered high-order scheme to interpolate velocity, but that would not help with the noise since a centered scheme is dispersive in nature. . I converted this PR to implement a `WetPointCoriolisScheme` (described in [Numerical boundary layers and spurious residual flows](https://agupubs.onlinelibrary.wiley.com/doi/abs/10.1029/JC091iC09p10621)). ; This is just a simple addition to an enstrophy conserving scheme where edge (""dry"") points are neglected in the interpolation of the velocity in the tangential direction. A comparison of the output of this scheme in a global 1 degree setup will follow",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2729#issuecomment-1252445272
Performance,perform,performance,"The advection-like Coriolis scheme was a non-sequitur because `f` is a very regular field, so upwinding it was just decreasing performance without a significative increase in quality of the simulation. On the other hand, upwinding `u` is very much discouraged because the energy builds up rapidly (by upwinding the velocity the divergence of the reconstructed tangential velocity is not a direct interpolation of the divergence of the original velocity, which is a necessary condition to maintain the algorithm stable). The only thing I can think to increase the order of velocity interpolation in the Coriolis force is to use a centered high-order scheme to interpolate velocity, but that would not help with the noise since a centered scheme is dispersive in nature. . I converted this PR to implement a `WetPointCoriolisScheme` (described in [Numerical boundary layers and spurious residual flows](https://agupubs.onlinelibrary.wiley.com/doi/abs/10.1029/JC091iC09p10621)). ; This is just a simple addition to an enstrophy conserving scheme where edge (""dry"") points are neglected in the interpolation of the velocity in the tangential direction. A comparison of the output of this scheme in a global 1 degree setup will follow",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2729#issuecomment-1252445272
Usability,simpl,simple,"The advection-like Coriolis scheme was a non-sequitur because `f` is a very regular field, so upwinding it was just decreasing performance without a significative increase in quality of the simulation. On the other hand, upwinding `u` is very much discouraged because the energy builds up rapidly (by upwinding the velocity the divergence of the reconstructed tangential velocity is not a direct interpolation of the divergence of the original velocity, which is a necessary condition to maintain the algorithm stable). The only thing I can think to increase the order of velocity interpolation in the Coriolis force is to use a centered high-order scheme to interpolate velocity, but that would not help with the noise since a centered scheme is dispersive in nature. . I converted this PR to implement a `WetPointCoriolisScheme` (described in [Numerical boundary layers and spurious residual flows](https://agupubs.onlinelibrary.wiley.com/doi/abs/10.1029/JC091iC09p10621)). ; This is just a simple addition to an enstrophy conserving scheme where edge (""dry"") points are neglected in the interpolation of the velocity in the tangential direction. A comparison of the output of this scheme in a global 1 degree setup will follow",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2729#issuecomment-1252445272
Usability,intuit,intuitive,"The traditional 2.5D model retains $\partial_y vu + \partial_z wu$. Even in a QG setup, background field advection is still important. ; `flat` in the previous version means no variation in the `flat` direction but it now assumes no momentum flux variation in all directions for the `flat` direction velocity. . That's why I don't think turning off $\nabla \cdot \vec{u} u$ as `flat` default is GFD intuitive. Especially, it is not clearly indicated in the documentation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2742#issuecomment-1252888555
Integrability,interface,interface,"These functions do not all have the same purpose. Functions like `νᶜᶜᶜ`, which are defined starting here:. https://github.com/CliMA/Oceananigans.jl/blob/main/src/TurbulenceClosures/abstract_scalar_diffusivity_closure.jl#L80. are designed to return the diffusivity at the specific index `i, j, k` and location `ᶜᶜᶜ`, given a closure and possibly _precalculated_ diffusivity fields. `calc_κᶜᶜᶜ` pertains to the precalculation itself, which is associated with the interface function `calculate_diffusivities!`. As you've noted, there is no standardized interface for _precalculating_ diffusivities --- because it's not clear what purpose that interface would serve. Therefore, for convenience, closures are allowed to use any code they like to precalculate the diffusivity. @tomchor, are you proposing to define an interface for _precalculating_ diffusivities? What's the purpose of that interface?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2751#issuecomment-1260785400
Usability,clear,clear,"These functions do not all have the same purpose. Functions like `νᶜᶜᶜ`, which are defined starting here:. https://github.com/CliMA/Oceananigans.jl/blob/main/src/TurbulenceClosures/abstract_scalar_diffusivity_closure.jl#L80. are designed to return the diffusivity at the specific index `i, j, k` and location `ᶜᶜᶜ`, given a closure and possibly _precalculated_ diffusivity fields. `calc_κᶜᶜᶜ` pertains to the precalculation itself, which is associated with the interface function `calculate_diffusivities!`. As you've noted, there is no standardized interface for _precalculating_ diffusivities --- because it's not clear what purpose that interface would serve. Therefore, for convenience, closures are allowed to use any code they like to precalculate the diffusivity. @tomchor, are you proposing to define an interface for _precalculating_ diffusivities? What's the purpose of that interface?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2751#issuecomment-1260785400
Availability,down,down,"on for our more adventurous users that want to experiment with new viscosities/diffusivities. Is the issue about what we define as ""feasible""? It's simple to add a new struct with a custom `calculate_diffusivities!`. I agree though that this could result in more boilerplate. So, the difference is really just ""how much code"" one needs to write to get to a custom `calculate_diffusivities!`. I think I would prefer a simple interface that allows users to dispatch on the type of `closure.ν`, ie something like. ```julia; calculate_diffusivities!(diffusivities, closure::ScalarDiffusivity, args...) =; calculate_diffusivities!(closure.ν, closure.κ, diffusivities, closure, args...) =; ```. Then if users have special viscosities that require computation, they can define a custom `calculate_diffusivities!(ν::MyCustomViscosity, ...)`. Another interface could un-comment these fields:. https://github.com/CliMA/Oceananigans.jl/blob/1a288c175d07b3d4262e965c7e75376d5541e24d/src/TurbulenceClosures/turbulence_closure_implementations/scalar_diffusivity.jl#L117-L121. and then users can define fields with custom `compute!` definitions. If we have an interface like the one above, we may not need a separate struct for `AnisotropicMinimumDissipation` at all. It really boils down to where we put information about the closure, such as free parameters. Right now we have an interface that encourages a new struct that subtypes `AbstractScalarDiffusivity`. An alternative is to do away with ""abstract"" scalar diffusivity, and generalize the concrete `ScalarDiffusivity` to any computed viscosity / diffusivity. This would then cover cases like `AnisotropicMinimumDissipation`, and move the free parameters associated with AMD from the turbulence closure struct into the viscosity struct. The first design is ""flatter"", and therefore exposes data like free parameters a bit more. The second design is more ""hierarchical"", which reduces boilerplate but is a little bit more complex. That's the trade-off I see.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2751#issuecomment-1261037943
Energy Efficiency,reduce,reduces,"on for our more adventurous users that want to experiment with new viscosities/diffusivities. Is the issue about what we define as ""feasible""? It's simple to add a new struct with a custom `calculate_diffusivities!`. I agree though that this could result in more boilerplate. So, the difference is really just ""how much code"" one needs to write to get to a custom `calculate_diffusivities!`. I think I would prefer a simple interface that allows users to dispatch on the type of `closure.ν`, ie something like. ```julia; calculate_diffusivities!(diffusivities, closure::ScalarDiffusivity, args...) =; calculate_diffusivities!(closure.ν, closure.κ, diffusivities, closure, args...) =; ```. Then if users have special viscosities that require computation, they can define a custom `calculate_diffusivities!(ν::MyCustomViscosity, ...)`. Another interface could un-comment these fields:. https://github.com/CliMA/Oceananigans.jl/blob/1a288c175d07b3d4262e965c7e75376d5541e24d/src/TurbulenceClosures/turbulence_closure_implementations/scalar_diffusivity.jl#L117-L121. and then users can define fields with custom `compute!` definitions. If we have an interface like the one above, we may not need a separate struct for `AnisotropicMinimumDissipation` at all. It really boils down to where we put information about the closure, such as free parameters. Right now we have an interface that encourages a new struct that subtypes `AbstractScalarDiffusivity`. An alternative is to do away with ""abstract"" scalar diffusivity, and generalize the concrete `ScalarDiffusivity` to any computed viscosity / diffusivity. This would then cover cases like `AnisotropicMinimumDissipation`, and move the free parameters associated with AMD from the turbulence closure struct into the viscosity struct. The first design is ""flatter"", and therefore exposes data like free parameters a bit more. The second design is more ""hierarchical"", which reduces boilerplate but is a little bit more complex. That's the trade-off I see.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2751#issuecomment-1261037943
Integrability,interface,interface,"Well, I agree this is a discussion worth having. Users need not add a new turbulence closure in the source code --- they can be added externally (eg in a model script) easily via multiple dispatch. We've illustrated this before, but I can't find the issue (the closest is discussion https://github.com/CliMA/Oceananigans.jl/discussions/2344). > we need a computationally feasible option for our more adventurous users that want to experiment with new viscosities/diffusivities. Is the issue about what we define as ""feasible""? It's simple to add a new struct with a custom `calculate_diffusivities!`. I agree though that this could result in more boilerplate. So, the difference is really just ""how much code"" one needs to write to get to a custom `calculate_diffusivities!`. I think I would prefer a simple interface that allows users to dispatch on the type of `closure.ν`, ie something like. ```julia; calculate_diffusivities!(diffusivities, closure::ScalarDiffusivity, args...) =; calculate_diffusivities!(closure.ν, closure.κ, diffusivities, closure, args...) =; ```. Then if users have special viscosities that require computation, they can define a custom `calculate_diffusivities!(ν::MyCustomViscosity, ...)`. Another interface could un-comment these fields:. https://github.com/CliMA/Oceananigans.jl/blob/1a288c175d07b3d4262e965c7e75376d5541e24d/src/TurbulenceClosures/turbulence_closure_implementations/scalar_diffusivity.jl#L117-L121. and then users can define fields with custom `compute!` definitions. If we have an interface like the one above, we may not need a separate struct for `AnisotropicMinimumDissipation` at all. It really boils down to where we put information about the closure, such as free parameters. Right now we have an interface that encourages a new struct that subtypes `AbstractScalarDiffusivity`. An alternative is to do away with ""abstract"" scalar diffusivity, and generalize the concrete `ScalarDiffusivity` to any computed viscosity / diffusivity. This would the",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2751#issuecomment-1261037943
Security,expose,exposes,"on for our more adventurous users that want to experiment with new viscosities/diffusivities. Is the issue about what we define as ""feasible""? It's simple to add a new struct with a custom `calculate_diffusivities!`. I agree though that this could result in more boilerplate. So, the difference is really just ""how much code"" one needs to write to get to a custom `calculate_diffusivities!`. I think I would prefer a simple interface that allows users to dispatch on the type of `closure.ν`, ie something like. ```julia; calculate_diffusivities!(diffusivities, closure::ScalarDiffusivity, args...) =; calculate_diffusivities!(closure.ν, closure.κ, diffusivities, closure, args...) =; ```. Then if users have special viscosities that require computation, they can define a custom `calculate_diffusivities!(ν::MyCustomViscosity, ...)`. Another interface could un-comment these fields:. https://github.com/CliMA/Oceananigans.jl/blob/1a288c175d07b3d4262e965c7e75376d5541e24d/src/TurbulenceClosures/turbulence_closure_implementations/scalar_diffusivity.jl#L117-L121. and then users can define fields with custom `compute!` definitions. If we have an interface like the one above, we may not need a separate struct for `AnisotropicMinimumDissipation` at all. It really boils down to where we put information about the closure, such as free parameters. Right now we have an interface that encourages a new struct that subtypes `AbstractScalarDiffusivity`. An alternative is to do away with ""abstract"" scalar diffusivity, and generalize the concrete `ScalarDiffusivity` to any computed viscosity / diffusivity. This would then cover cases like `AnisotropicMinimumDissipation`, and move the free parameters associated with AMD from the turbulence closure struct into the viscosity struct. The first design is ""flatter"", and therefore exposes data like free parameters a bit more. The second design is more ""hierarchical"", which reduces boilerplate but is a little bit more complex. That's the trade-off I see.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2751#issuecomment-1261037943
Usability,simpl,simple,"Well, I agree this is a discussion worth having. Users need not add a new turbulence closure in the source code --- they can be added externally (eg in a model script) easily via multiple dispatch. We've illustrated this before, but I can't find the issue (the closest is discussion https://github.com/CliMA/Oceananigans.jl/discussions/2344). > we need a computationally feasible option for our more adventurous users that want to experiment with new viscosities/diffusivities. Is the issue about what we define as ""feasible""? It's simple to add a new struct with a custom `calculate_diffusivities!`. I agree though that this could result in more boilerplate. So, the difference is really just ""how much code"" one needs to write to get to a custom `calculate_diffusivities!`. I think I would prefer a simple interface that allows users to dispatch on the type of `closure.ν`, ie something like. ```julia; calculate_diffusivities!(diffusivities, closure::ScalarDiffusivity, args...) =; calculate_diffusivities!(closure.ν, closure.κ, diffusivities, closure, args...) =; ```. Then if users have special viscosities that require computation, they can define a custom `calculate_diffusivities!(ν::MyCustomViscosity, ...)`. Another interface could un-comment these fields:. https://github.com/CliMA/Oceananigans.jl/blob/1a288c175d07b3d4262e965c7e75376d5541e24d/src/TurbulenceClosures/turbulence_closure_implementations/scalar_diffusivity.jl#L117-L121. and then users can define fields with custom `compute!` definitions. If we have an interface like the one above, we may not need a separate struct for `AnisotropicMinimumDissipation` at all. It really boils down to where we put information about the closure, such as free parameters. Right now we have an interface that encourages a new struct that subtypes `AbstractScalarDiffusivity`. An alternative is to do away with ""abstract"" scalar diffusivity, and generalize the concrete `ScalarDiffusivity` to any computed viscosity / diffusivity. This would the",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2751#issuecomment-1261037943
Integrability,interface,interfaces,"> We could also just change the signature of the `calc_` functions to pass all the fields instead of just velocities and tracers separately `fields(model)`. Yeah I like that idea. Also, is there anything that keeps us from passing `model` itself? It seems like it'd simplify the interfaces",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2752#issuecomment-1258413483
Usability,simpl,simplify,"> We could also just change the signature of the `calc_` functions to pass all the fields instead of just velocities and tracers separately `fields(model)`. Yeah I like that idea. Also, is there anything that keeps us from passing `model` itself? It seems like it'd simplify the interfaces",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2752#issuecomment-1258413483
Usability,simpl,simple,"> I see. It would be nice to have this as a user API convenience, but then to be complete we must include all the other entries of the tensor. It might get a bit tedious when you want to include isopycnal diffusivities like `TwoDimensionalLeith` or GM (`IsopycnalSkewSymmetricDiffusivity`) for which we do not compute the tensor but directly the flux. I think the other tensor entries are much less frequently needed, so I'd propose we start only with the simple stuff and add the rest when needed. I was also thinking that for inner-working purposes it's best to keep the current `viscosity()` behavior (always returning a 'Number`) and create a second function that can be exported to the user which has the array behavior I described. Thoughts?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2752#issuecomment-1266041565
Integrability,interface,interface,"> Why is a vector that represents the diagonal elements of a hypothetical viscosity tensor useful?. Because I think most of the tuple closures used are `(HorizontalDiffusivity, VerticalDiffusivity)`, where the diagonal is what you need. Although that intuition might be wrong. But most of the reason for my attempted changes to `viscosity()` here is that apparently [`viscosity()` is the user interface to retrieve the viscosities regardless of closure](https://github.com/CliMA/Oceananigans.jl/issues/2751#issuecomment-1261039114). However, if a user uses that in the example below, the output isn't correct considering the physics:. ```julia; julia> grid = RectilinearGrid(size=(4, 4, 4), extent=(1, 1, 1));. julia> closure = (HorizontalScalarDiffusivity(ν=1), VerticalScalarDiffusivity(ν=2));. julia> model = NonhydrostaticModel(grid=grid, closure=closure);. julia> using Oceananigans.TurbulenceClosures: viscosity. julia> viscosity(model.closure, model.diffusivity_fields); 3.0; ```. Maybe the best way to move forward isn't to change `viscosity()`, but IMO a user-facing function to get viscosities that works as expected (i.e., returns something like `[1, 1, 2]` in the above example) would be helpful.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2752#issuecomment-1270199938
Usability,intuit,intuition,"> Why is a vector that represents the diagonal elements of a hypothetical viscosity tensor useful?. Because I think most of the tuple closures used are `(HorizontalDiffusivity, VerticalDiffusivity)`, where the diagonal is what you need. Although that intuition might be wrong. But most of the reason for my attempted changes to `viscosity()` here is that apparently [`viscosity()` is the user interface to retrieve the viscosities regardless of closure](https://github.com/CliMA/Oceananigans.jl/issues/2751#issuecomment-1261039114). However, if a user uses that in the example below, the output isn't correct considering the physics:. ```julia; julia> grid = RectilinearGrid(size=(4, 4, 4), extent=(1, 1, 1));. julia> closure = (HorizontalScalarDiffusivity(ν=1), VerticalScalarDiffusivity(ν=2));. julia> model = NonhydrostaticModel(grid=grid, closure=closure);. julia> using Oceananigans.TurbulenceClosures: viscosity. julia> viscosity(model.closure, model.diffusivity_fields); 3.0; ```. Maybe the best way to move forward isn't to change `viscosity()`, but IMO a user-facing function to get viscosities that works as expected (i.e., returns something like `[1, 1, 2]` in the above example) would be helpful.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2752#issuecomment-1270199938
Usability,simpl,simple,"I think what I'm asking is what you envision using this vector for. I don't see the purpose of it. One could just as easily inspect each closure in the tuple individually to see what the viscosity for each closure type is. This method is unambiguous and more general than developing a ""vector abstraction"" for the diagonal components of a viscosity tensor. That said, I agree that the output of `viscosity` for a closure tuple isn't useful. It's summing the viscosities together. This makes sense when the formulations are the same for each component, but not when they are different. So we should change that. The main use case envisioned is when you have two `ScalarDiffusivity` with `ThreeDimensionalFormulation`. In that case, `viscosity` returns an object (a `BinaryOperation`) representing the sum of a the nonlinear diffusivity (a field) and the background molecular component (a number). This can be used in subsequent `AbstractOperations`. When the closure tuple involves multiple `ScalarDiffusivity` with heterogeneous formulations, we need a different abstraction. We also need to deal with the case where the closure tuple contains non-scalar-diffusivity closures. To design an abstraction, I think we should start with a use case, which can help us develop requirements for the abstraction. Once we have requirements, we can implement something minimal and simple that's easy to reason with and that will generalize to more complicated use cases we may want to consider in the future (hopefully).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2752#issuecomment-1271046814
Availability,error,error,"> I think what I'm asking is what you envision using this vector for. I don't see the purpose of it. One could just as easily inspect each closure in the tuple individually to see what the viscosity for each closure type is. This method is unambiguous and far more general than developing a ""vector abstraction"" for the diagonal components of a viscosity tensor.; > ; > That said, I agree that the output of `viscosity` for a closure tuple isn't useful. It's summing the viscosities together. This makes sense when the formulations are the same for each component, but not when they are different. So we should change that.; > ; > The main use case envisioned is when you have two `ScalarDiffusivity` with `ThreeDimensionalFormulation`. In that case, `viscosity` returns an object (a `BinaryOperation`) representing the sum of a the nonlinear diffusivity (a field) and the background molecular component (a number). This can then be used in subsequent `AbstractOperations` for calculations.; > ; > When the closure tuple involves multiple `ScalarDiffusivity` with heterogeneous formulations, we need a different abstraction.; > ; > We also need to deal with the case where the closure tuple contains non-scalar-diffusivity closures.; > ; > To design an abstraction, I think we should start with a use case, which can help us develop requirements for the abstraction. Once we have requirements, we can implement something minimal and simple that's easy to reason with and that will generalize to more complicated use cases we may want to consider in the future (hopefully). I agree with this. I'll revert `viscosity()` to its original formulation for now. My only question/suggestion is: should we check in `viscosity(::Tuple)` that the all the elements have the same formulation? That way we can throw a warning (or maybe even an error) when trying to add different formulation closures.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2752#issuecomment-1272625541
Usability,simpl,simple,"> I think what I'm asking is what you envision using this vector for. I don't see the purpose of it. One could just as easily inspect each closure in the tuple individually to see what the viscosity for each closure type is. This method is unambiguous and far more general than developing a ""vector abstraction"" for the diagonal components of a viscosity tensor.; > ; > That said, I agree that the output of `viscosity` for a closure tuple isn't useful. It's summing the viscosities together. This makes sense when the formulations are the same for each component, but not when they are different. So we should change that.; > ; > The main use case envisioned is when you have two `ScalarDiffusivity` with `ThreeDimensionalFormulation`. In that case, `viscosity` returns an object (a `BinaryOperation`) representing the sum of a the nonlinear diffusivity (a field) and the background molecular component (a number). This can then be used in subsequent `AbstractOperations` for calculations.; > ; > When the closure tuple involves multiple `ScalarDiffusivity` with heterogeneous formulations, we need a different abstraction.; > ; > We also need to deal with the case where the closure tuple contains non-scalar-diffusivity closures.; > ; > To design an abstraction, I think we should start with a use case, which can help us develop requirements for the abstraction. Once we have requirements, we can implement something minimal and simple that's easy to reason with and that will generalize to more complicated use cases we may want to consider in the future (hopefully). I agree with this. I'll revert `viscosity()` to its original formulation for now. My only question/suggestion is: should we check in `viscosity(::Tuple)` that the all the elements have the same formulation? That way we can throw a warning (or maybe even an error) when trying to add different formulation closures.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2752#issuecomment-1272625541
Usability,clear,clear,Thank you! That is very clear. Could you also please point me in the direction of a resourse to understand the asymptotic diagonal approximation of the inverse?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2753#issuecomment-1258929817
Usability,clear,clear,> Thank you! That is very clear. Could you also please point me in the direction of a resourse to understand the asymptotic diagonal approximation of the inverse?. It is not well documented actually. You can find some (albeit simple) explanation here https://agupubs.onlinelibrary.wiley.com/doi/abs/10.1029/96JC02775. There is also an explanation in the docstrings,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2753#issuecomment-1259433162
Testability,test,test,"Ah I see. Well from what I see everything in the [TurbulentStatistic.jl](https://github.com/CliMA/LESbrary.jl/tree/main/src/TurbulenceStatistics) module is compatible with new versions of Oceananigans (except maybe GPU usage). Since that is what you are using, you can maybe use it locally?. This is just a quick fix to try out the new Oceananigans. ; Also, to try out if the problem persists it is enough to test some simple second-order moments. ; The ones you have in your script should do the job; ```; u, v, w = model.velocities; t = model.tracers.T. U = Average(u, dims=(1, 2)) ; V = Average(v, dims=(1, 2)); T = Average(t, dims=(1, 2)); wu = Average(w * u, dims=(1, 2)); wv = Average(w * v, dims=(1, 2)); uu = Average(u * u, dims=(1, 2)); vv = Average(v * v, dims=(1, 2)); ww = Average(w * w, dims=(1, 2)); www = Average(w * w * w, dims=(1, 2)); wT = Average(w * t, dims=(1, 2)); uv = Average(u * v, dims=(1, 2)); uT = Average(u * t, dims=(1, 2)); vT = Average(v * t, dims=(1, 2)); TT = Average(t * t, dims=(1, 2)); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1266331571
Usability,simpl,simple,"Ah I see. Well from what I see everything in the [TurbulentStatistic.jl](https://github.com/CliMA/LESbrary.jl/tree/main/src/TurbulenceStatistics) module is compatible with new versions of Oceananigans (except maybe GPU usage). Since that is what you are using, you can maybe use it locally?. This is just a quick fix to try out the new Oceananigans. ; Also, to try out if the problem persists it is enough to test some simple second-order moments. ; The ones you have in your script should do the job; ```; u, v, w = model.velocities; t = model.tracers.T. U = Average(u, dims=(1, 2)) ; V = Average(v, dims=(1, 2)); T = Average(t, dims=(1, 2)); wu = Average(w * u, dims=(1, 2)); wv = Average(w * v, dims=(1, 2)); uu = Average(u * u, dims=(1, 2)); vv = Average(v * v, dims=(1, 2)); ww = Average(w * w, dims=(1, 2)); www = Average(w * w * w, dims=(1, 2)); wT = Average(w * t, dims=(1, 2)); uv = Average(u * v, dims=(1, 2)); uT = Average(u * t, dims=(1, 2)); vT = Average(v * t, dims=(1, 2)); TT = Average(t * t, dims=(1, 2)); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1266331571
Availability,failure,failure,"Okay, apologies. I just didn't quite understand what you meant when you said they _seem_ identical. Typically we would just write something like `T1 == T2`, which will return `true` or `false`, or equivalently something like `all(T1 .== T2)`. Another test is to use `isapprox` (also written `≈`) as in `all(T1 .≈ T2)`. Here's a bit more background on the reproducibility tests we currently have:. We have [""regression tests""](https://github.com/CliMA/Oceananigans.jl/tree/main/test/regression_tests) that test to ensure that output from a certain simulation remains identical across PRs, including tests that involve LES closures. These tests involve ~10 time steps. We conclude that results are ""identical"" when every grid point is within `sqrt(eps(T))`, where `T` is the floating point type (eg `Float64` or `Float32`), for example:. https://github.com/CliMA/Oceananigans.jl/blob/fc84215f76661e9f1cfb103dc18f86442cec9d89/test/regression_tests/hydrostatic_free_turbulence_regression_test.jl#L112. Many of our other tests also implicitly rely on reproducibility. I think, therefore, that we do have reproduciblity in many cases. However, it is quite possible that your case exposes some particular feature that leads to a loss of reprodicibility. I think perhaps the next step in order to make progress is to code up a ""minimal working example"" (often called an MWE), which involves relentlessly simplifying the examle until we isolate the essential complication that leads to a failure of the test. With that knowledge in hand, we can dig deeper to find the underlying cause (and hopefully fix it). Often, the process of simplying a script in order to isolate the MWE also produces some insight about the issue (and potentially about the test).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1273675416
Security,expose,exposes,"Okay, apologies. I just didn't quite understand what you meant when you said they _seem_ identical. Typically we would just write something like `T1 == T2`, which will return `true` or `false`, or equivalently something like `all(T1 .== T2)`. Another test is to use `isapprox` (also written `≈`) as in `all(T1 .≈ T2)`. Here's a bit more background on the reproducibility tests we currently have:. We have [""regression tests""](https://github.com/CliMA/Oceananigans.jl/tree/main/test/regression_tests) that test to ensure that output from a certain simulation remains identical across PRs, including tests that involve LES closures. These tests involve ~10 time steps. We conclude that results are ""identical"" when every grid point is within `sqrt(eps(T))`, where `T` is the floating point type (eg `Float64` or `Float32`), for example:. https://github.com/CliMA/Oceananigans.jl/blob/fc84215f76661e9f1cfb103dc18f86442cec9d89/test/regression_tests/hydrostatic_free_turbulence_regression_test.jl#L112. Many of our other tests also implicitly rely on reproducibility. I think, therefore, that we do have reproduciblity in many cases. However, it is quite possible that your case exposes some particular feature that leads to a loss of reprodicibility. I think perhaps the next step in order to make progress is to code up a ""minimal working example"" (often called an MWE), which involves relentlessly simplifying the examle until we isolate the essential complication that leads to a failure of the test. With that knowledge in hand, we can dig deeper to find the underlying cause (and hopefully fix it). Often, the process of simplying a script in order to isolate the MWE also produces some insight about the issue (and potentially about the test).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1273675416
Testability,test,test,"Okay, apologies. I just didn't quite understand what you meant when you said they _seem_ identical. Typically we would just write something like `T1 == T2`, which will return `true` or `false`, or equivalently something like `all(T1 .== T2)`. Another test is to use `isapprox` (also written `≈`) as in `all(T1 .≈ T2)`. Here's a bit more background on the reproducibility tests we currently have:. We have [""regression tests""](https://github.com/CliMA/Oceananigans.jl/tree/main/test/regression_tests) that test to ensure that output from a certain simulation remains identical across PRs, including tests that involve LES closures. These tests involve ~10 time steps. We conclude that results are ""identical"" when every grid point is within `sqrt(eps(T))`, where `T` is the floating point type (eg `Float64` or `Float32`), for example:. https://github.com/CliMA/Oceananigans.jl/blob/fc84215f76661e9f1cfb103dc18f86442cec9d89/test/regression_tests/hydrostatic_free_turbulence_regression_test.jl#L112. Many of our other tests also implicitly rely on reproducibility. I think, therefore, that we do have reproduciblity in many cases. However, it is quite possible that your case exposes some particular feature that leads to a loss of reprodicibility. I think perhaps the next step in order to make progress is to code up a ""minimal working example"" (often called an MWE), which involves relentlessly simplifying the examle until we isolate the essential complication that leads to a failure of the test. With that knowledge in hand, we can dig deeper to find the underlying cause (and hopefully fix it). Often, the process of simplying a script in order to isolate the MWE also produces some insight about the issue (and potentially about the test).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1273675416
Usability,simpl,simplifying,"Okay, apologies. I just didn't quite understand what you meant when you said they _seem_ identical. Typically we would just write something like `T1 == T2`, which will return `true` or `false`, or equivalently something like `all(T1 .== T2)`. Another test is to use `isapprox` (also written `≈`) as in `all(T1 .≈ T2)`. Here's a bit more background on the reproducibility tests we currently have:. We have [""regression tests""](https://github.com/CliMA/Oceananigans.jl/tree/main/test/regression_tests) that test to ensure that output from a certain simulation remains identical across PRs, including tests that involve LES closures. These tests involve ~10 time steps. We conclude that results are ""identical"" when every grid point is within `sqrt(eps(T))`, where `T` is the floating point type (eg `Float64` or `Float32`), for example:. https://github.com/CliMA/Oceananigans.jl/blob/fc84215f76661e9f1cfb103dc18f86442cec9d89/test/regression_tests/hydrostatic_free_turbulence_regression_test.jl#L112. Many of our other tests also implicitly rely on reproducibility. I think, therefore, that we do have reproduciblity in many cases. However, it is quite possible that your case exposes some particular feature that leads to a loss of reprodicibility. I think perhaps the next step in order to make progress is to code up a ""minimal working example"" (often called an MWE), which involves relentlessly simplifying the examle until we isolate the essential complication that leads to a failure of the test. With that knowledge in hand, we can dig deeper to find the underlying cause (and hopefully fix it). Often, the process of simplying a script in order to isolate the MWE also produces some insight about the issue (and potentially about the test).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1273675416
Usability,clear,clear,"My bad. I was not clear. Yes, T1 - T2 = 0",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1273701074
Usability,learn,learned,"It might make sense to convert this to a discussion and change the title to ""Building reproducible LES setups"". The info here could be useful for future Oceananigans users that would like to build reproducible setups (thanks for your efforts in this department @fspereira1). Of note, the lessons learned here are mostly about achieving reproducibility with Julia and FFTW (the lessons are not Oceananigans specific, and are applicable to other Julia applications). And to summarize the important points:. * Reproducible initial conditions must be constructed with care. If using random initial conditions, we have to set the seed of the random number generator, and ensure that any random arrays are constructed deterministically (for example, we can't use `rand()` inside an initial condition function because loop ordering is not deterministic in Oceananigans). There could be special concerns for random array initial conditions on GPU.; * Reproducible results from solvers that use FFTW (either 3D pressure solvers, or the 2D free surface solvers for `HydrostaticFreeSurfaceModel`) must use the `FFTW.ESTIMATE` planner flag (see solver documentation for how to do this in each case).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1295914743
Availability,error,error,"I'm not sure I grasp the issue. @jagoosw it might help if you include a simple example (eg some code, and the error that gets produced) that illustrates the issue. > With indices=(:, :, :) we should be able to output any field. I agree with this. Is the problem associated with trying to ""remove halos"" from output? Does it go away when we write `with_halos=true`?. In addition to problems with `parent_index_range`, it looks like there is potentially a problem with the user API (in addition to other bugs). The `indices` keyword in the output writers is a useful convenience but doesn't generalize well to being able to slice both 3D and reduced or sliced fields. Here's what we have:. * All `Field`s have `indices`. We can define fields that are essentialy _views_ into other fields, but ""sliced"" at particular indices. We can also define abstract operations that slice a portion of the domain.; * We have output writers that can compute and output sliced fields. ; * We have an `indices` kwarg for output writers that _automagically_ will _slice every output_ along the provided indices. This is convenient, but fails to cover the case that we want to slice all 3D fields, but leave fields that are _already sliced_ untouched. A few solutions:. * Throw a `BoundsError` when we attempt to ""re-slice"" a field in a way that's invalid. For example, we cannot slice a field with `k=Nz+1` at the index `k=Nz`. This is how Base julia works:. ```julia; julia> a = rand(2, 3); 2×3 Matrix{Float64}:; 0.493349 0.161279 0.244427; 0.288415 0.0111998 0.543645. julia> b = view(a, :, 4:4); ERROR: BoundsError: attempt to access 2×3 Matrix{Float64} at index [1:2, 4:4]; Stacktrace:; [1] throw_boundserror(A::Matrix{Float64}, I::Tuple{Base.Slice{Base.OneTo{Int64}}, UnitRange{Int64}}); @ Base ./abstractarray.jl:651; [2] checkbounds; @ ./abstractarray.jl:616 [inlined]; [3] view(::Matrix{Float64}, ::Function, ::UnitRange{Int64}); @ Base ./subarray.jl:177; [4] top-level scope; @ REPL[36]:1; ```. * Add new feature",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2770#issuecomment-1268590520
Energy Efficiency,reduce,reduced,"I'm not sure I grasp the issue. @jagoosw it might help if you include a simple example (eg some code, and the error that gets produced) that illustrates the issue. > With indices=(:, :, :) we should be able to output any field. I agree with this. Is the problem associated with trying to ""remove halos"" from output? Does it go away when we write `with_halos=true`?. In addition to problems with `parent_index_range`, it looks like there is potentially a problem with the user API (in addition to other bugs). The `indices` keyword in the output writers is a useful convenience but doesn't generalize well to being able to slice both 3D and reduced or sliced fields. Here's what we have:. * All `Field`s have `indices`. We can define fields that are essentialy _views_ into other fields, but ""sliced"" at particular indices. We can also define abstract operations that slice a portion of the domain.; * We have output writers that can compute and output sliced fields. ; * We have an `indices` kwarg for output writers that _automagically_ will _slice every output_ along the provided indices. This is convenient, but fails to cover the case that we want to slice all 3D fields, but leave fields that are _already sliced_ untouched. A few solutions:. * Throw a `BoundsError` when we attempt to ""re-slice"" a field in a way that's invalid. For example, we cannot slice a field with `k=Nz+1` at the index `k=Nz`. This is how Base julia works:. ```julia; julia> a = rand(2, 3); 2×3 Matrix{Float64}:; 0.493349 0.161279 0.244427; 0.288415 0.0111998 0.543645. julia> b = view(a, :, 4:4); ERROR: BoundsError: attempt to access 2×3 Matrix{Float64} at index [1:2, 4:4]; Stacktrace:; [1] throw_boundserror(A::Matrix{Float64}, I::Tuple{Base.Slice{Base.OneTo{Int64}}, UnitRange{Int64}}); @ Base ./abstractarray.jl:651; [2] checkbounds; @ ./abstractarray.jl:616 [inlined]; [3] view(::Matrix{Float64}, ::Function, ::UnitRange{Int64}); @ Base ./subarray.jl:177; [4] top-level scope; @ REPL[36]:1; ```. * Add new feature",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2770#issuecomment-1268590520
Security,access,access," to other bugs). The `indices` keyword in the output writers is a useful convenience but doesn't generalize well to being able to slice both 3D and reduced or sliced fields. Here's what we have:. * All `Field`s have `indices`. We can define fields that are essentialy _views_ into other fields, but ""sliced"" at particular indices. We can also define abstract operations that slice a portion of the domain.; * We have output writers that can compute and output sliced fields. ; * We have an `indices` kwarg for output writers that _automagically_ will _slice every output_ along the provided indices. This is convenient, but fails to cover the case that we want to slice all 3D fields, but leave fields that are _already sliced_ untouched. A few solutions:. * Throw a `BoundsError` when we attempt to ""re-slice"" a field in a way that's invalid. For example, we cannot slice a field with `k=Nz+1` at the index `k=Nz`. This is how Base julia works:. ```julia; julia> a = rand(2, 3); 2×3 Matrix{Float64}:; 0.493349 0.161279 0.244427; 0.288415 0.0111998 0.543645. julia> b = view(a, :, 4:4); ERROR: BoundsError: attempt to access 2×3 Matrix{Float64} at index [1:2, 4:4]; Stacktrace:; [1] throw_boundserror(A::Matrix{Float64}, I::Tuple{Base.Slice{Base.OneTo{Int64}}, UnitRange{Int64}}); @ Base ./abstractarray.jl:651; [2] checkbounds; @ ./abstractarray.jl:616 [inlined]; [3] view(::Matrix{Float64}, ::Function, ::UnitRange{Int64}); @ Base ./subarray.jl:177; [4] top-level scope; @ REPL[36]:1; ```. * Add new features that help us build output in a sensible way. One idea is a macro that looks something like. ```julia; us, vs, ws, Ts = @indices (:, :, Nz) u v w T; ```. This would be equivalent to writing something like. ```julia; us = Field(u, indices=(:, :, Nz)); vs = Field(v, indices=(:, :, Nz)); ws = Field(w, indices=(:, :, Nz)); Ts = Field(T, indices=(:, :, Nz)); ```. Then, if users want to output surface fields _and_ the free surface, they should use this method rather than the `indices` kwarg.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2770#issuecomment-1268590520
Usability,simpl,simple,"I'm not sure I grasp the issue. @jagoosw it might help if you include a simple example (eg some code, and the error that gets produced) that illustrates the issue. > With indices=(:, :, :) we should be able to output any field. I agree with this. Is the problem associated with trying to ""remove halos"" from output? Does it go away when we write `with_halos=true`?. In addition to problems with `parent_index_range`, it looks like there is potentially a problem with the user API (in addition to other bugs). The `indices` keyword in the output writers is a useful convenience but doesn't generalize well to being able to slice both 3D and reduced or sliced fields. Here's what we have:. * All `Field`s have `indices`. We can define fields that are essentialy _views_ into other fields, but ""sliced"" at particular indices. We can also define abstract operations that slice a portion of the domain.; * We have output writers that can compute and output sliced fields. ; * We have an `indices` kwarg for output writers that _automagically_ will _slice every output_ along the provided indices. This is convenient, but fails to cover the case that we want to slice all 3D fields, but leave fields that are _already sliced_ untouched. A few solutions:. * Throw a `BoundsError` when we attempt to ""re-slice"" a field in a way that's invalid. For example, we cannot slice a field with `k=Nz+1` at the index `k=Nz`. This is how Base julia works:. ```julia; julia> a = rand(2, 3); 2×3 Matrix{Float64}:; 0.493349 0.161279 0.244427; 0.288415 0.0111998 0.543645. julia> b = view(a, :, 4:4); ERROR: BoundsError: attempt to access 2×3 Matrix{Float64} at index [1:2, 4:4]; Stacktrace:; [1] throw_boundserror(A::Matrix{Float64}, I::Tuple{Base.Slice{Base.OneTo{Int64}}, UnitRange{Int64}}); @ Base ./abstractarray.jl:651; [2] checkbounds; @ ./abstractarray.jl:616 [inlined]; [3] view(::Matrix{Float64}, ::Function, ::UnitRange{Int64}); @ Base ./subarray.jl:177; [4] top-level scope; @ REPL[36]:1; ```. * Add new feature",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2770#issuecomment-1268590520
Testability,test,tests,"Ok! To summarize, we currently have. https://github.com/CliMA/Oceananigans.jl/blob/b288527ccf34fc17ec4b31a1e9da7bd8b8d25a10/src/Grids/grid_utils.jl#L213. which you propose to change to. ```julia; parent_index_range(index::UnitRange, loc, topo, halo) = 1:(last(index) - first(index) + 1); ```. I definitely agree that the parent index range of a field with indices `4:4` is `1:1` and your code seems correct to me. This is a clear bug --- should we add this to the indices tests? (I'm not sure what the state of the tests is for indices, but this is an obvious gap.). Note that with this change, none of the methods for `parent_index_range` will use the argument `halo`. So that should be removed. (I think `loc` and `topo` are needed to support slicing into ""ensemble grids"" that have a flat direction with more than one grid point... I think.). > since the output writer is trying to view the underlying data at [4:23, 4:23, 4:23]. I think @navidcy discovered a problem with `validate_indices` that may be related. But `restrict_to_interior` may also be broken for sliced fields.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2770#issuecomment-1269256387
Usability,clear,clear,"Ok! To summarize, we currently have. https://github.com/CliMA/Oceananigans.jl/blob/b288527ccf34fc17ec4b31a1e9da7bd8b8d25a10/src/Grids/grid_utils.jl#L213. which you propose to change to. ```julia; parent_index_range(index::UnitRange, loc, topo, halo) = 1:(last(index) - first(index) + 1); ```. I definitely agree that the parent index range of a field with indices `4:4` is `1:1` and your code seems correct to me. This is a clear bug --- should we add this to the indices tests? (I'm not sure what the state of the tests is for indices, but this is an obvious gap.). Note that with this change, none of the methods for `parent_index_range` will use the argument `halo`. So that should be removed. (I think `loc` and `topo` are needed to support slicing into ""ensemble grids"" that have a flat direction with more than one grid point... I think.). > since the output writer is trying to view the underlying data at [4:23, 4:23, 4:23]. I think @navidcy discovered a problem with `validate_indices` that may be related. But `restrict_to_interior` may also be broken for sliced fields.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2770#issuecomment-1269256387
Usability,simpl,simple,"I see. I was thinking that we could solve the issue with the sliced fields' outputwriter in that simple way, but it turns out it is a deeper problem since `view(field, indices(field)...)` does not work for sliced fields.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2771#issuecomment-1267784624
Security,access,access,"My concern with associating it with the simulation was that, unless we pass the simulation to `time_step!` as well, the callback can't access it which might be confusing since normal callbacks are `func(sim)`. So I thought it may be clearer if callbacks associated with the model were `func(model)` instead. Not sure what the best solution is though?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2773#issuecomment-1271682713
Usability,clear,clearer,"My concern with associating it with the simulation was that, unless we pass the simulation to `time_step!` as well, the callback can't access it which might be confusing since normal callbacks are `func(sim)`. So I thought it may be clearer if callbacks associated with the model were `func(model)` instead. Not sure what the best solution is though?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2773#issuecomment-1271682713
Security,access,access,"> My concern with associating it with the simulation was that, unless we pass the simulation to `time_step!` as well, the callback can't access it which might be confusing since normal callbacks are `func(sim)`. So I thought it may be clearer if callbacks associated with the model were `func(model)` instead. Not sure what the best solution is though?. Ah, I see your point and it's a good one! Let's see if anyone else has thoughts.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2773#issuecomment-1271755659
Usability,clear,clearer,"> My concern with associating it with the simulation was that, unless we pass the simulation to `time_step!` as well, the callback can't access it which might be confusing since normal callbacks are `func(sim)`. So I thought it may be clearer if callbacks associated with the model were `func(model)` instead. Not sure what the best solution is though?. Ah, I see your point and it's a good one! Let's see if anyone else has thoughts.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2773#issuecomment-1271755659
Usability,intuit,intuitively,I'd also intuitively prefer if this is part of simulation.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2773#issuecomment-1278791010
Testability,test,testing,"> (this is how PISCES implements a lot of the growth to prevent repetitive calculation of the same values, I don't know if this would be faster in this setting without testing but just as an example). I agree that we need this feature, but from a software design perspective one might argue that such an invasive change to model dynamics belongs in the source code itself, rather than a callback (and this of course how it works for PISCES, or any model other than Oceananigans --- since Oceananigans is the only model where we can envision such a fine-grained callback schema). I think having a callback infrastructure like this effectively allows people who implement advanced / custom applications to keep their code up to date with other changes to Oceananigans. The alternative model for software design, which is simply to create a new version of the source code for your custom application, leads to much more code duplication. So you could say that the callback feature could be important for the community to share advanced custom modifications to Oceananigans, without creating a terrible tangle in `main`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2773#issuecomment-1279336660
Usability,simpl,simply,"> (this is how PISCES implements a lot of the growth to prevent repetitive calculation of the same values, I don't know if this would be faster in this setting without testing but just as an example). I agree that we need this feature, but from a software design perspective one might argue that such an invasive change to model dynamics belongs in the source code itself, rather than a callback (and this of course how it works for PISCES, or any model other than Oceananigans --- since Oceananigans is the only model where we can envision such a fine-grained callback schema). I think having a callback infrastructure like this effectively allows people who implement advanced / custom applications to keep their code up to date with other changes to Oceananigans. The alternative model for software design, which is simply to create a new version of the source code for your custom application, leads to much more code duplication. So you could say that the callback feature could be important for the community to share advanced custom modifications to Oceananigans, without creating a terrible tangle in `main`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2773#issuecomment-1279336660
Deployability,upgrade,upgraded,"Interesting, thanks for those details! That's odd that there are changes in memory allocation associated with building diagnostics. I don't think there's been changes to `Field` between 0.77.5 and 0.78.0. @navidcy might be able to say more. I think 0.78.0 only upgraded the tests to julia 1.8?. I'm also curious why the diagnostics consume so much memory. Are you producing a lot of 3D time averages (which can't be constructed in post-processing?) We've attempted to design the code so that reductions can be performed with minimal memory allocation. 3D diagnostics can simply be calculated from snapshots of the model state, so there's no need to allocate memory (assuming that static memory greatly exceeds GPU memory, this would be preferred). Are we missing a feature to help reduce memory requirements of diagnostics perhaps?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1299561134
Energy Efficiency,allocate,allocate,"Interesting, thanks for those details! That's odd that there are changes in memory allocation associated with building diagnostics. I don't think there's been changes to `Field` between 0.77.5 and 0.78.0. @navidcy might be able to say more. I think 0.78.0 only upgraded the tests to julia 1.8?. I'm also curious why the diagnostics consume so much memory. Are you producing a lot of 3D time averages (which can't be constructed in post-processing?) We've attempted to design the code so that reductions can be performed with minimal memory allocation. 3D diagnostics can simply be calculated from snapshots of the model state, so there's no need to allocate memory (assuming that static memory greatly exceeds GPU memory, this would be preferred). Are we missing a feature to help reduce memory requirements of diagnostics perhaps?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1299561134
Performance,perform,performed,"Interesting, thanks for those details! That's odd that there are changes in memory allocation associated with building diagnostics. I don't think there's been changes to `Field` between 0.77.5 and 0.78.0. @navidcy might be able to say more. I think 0.78.0 only upgraded the tests to julia 1.8?. I'm also curious why the diagnostics consume so much memory. Are you producing a lot of 3D time averages (which can't be constructed in post-processing?) We've attempted to design the code so that reductions can be performed with minimal memory allocation. 3D diagnostics can simply be calculated from snapshots of the model state, so there's no need to allocate memory (assuming that static memory greatly exceeds GPU memory, this would be preferred). Are we missing a feature to help reduce memory requirements of diagnostics perhaps?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1299561134
Testability,test,tests,"Interesting, thanks for those details! That's odd that there are changes in memory allocation associated with building diagnostics. I don't think there's been changes to `Field` between 0.77.5 and 0.78.0. @navidcy might be able to say more. I think 0.78.0 only upgraded the tests to julia 1.8?. I'm also curious why the diagnostics consume so much memory. Are you producing a lot of 3D time averages (which can't be constructed in post-processing?) We've attempted to design the code so that reductions can be performed with minimal memory allocation. 3D diagnostics can simply be calculated from snapshots of the model state, so there's no need to allocate memory (assuming that static memory greatly exceeds GPU memory, this would be preferred). Are we missing a feature to help reduce memory requirements of diagnostics perhaps?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1299561134
Usability,simpl,simply,"Interesting, thanks for those details! That's odd that there are changes in memory allocation associated with building diagnostics. I don't think there's been changes to `Field` between 0.77.5 and 0.78.0. @navidcy might be able to say more. I think 0.78.0 only upgraded the tests to julia 1.8?. I'm also curious why the diagnostics consume so much memory. Are you producing a lot of 3D time averages (which can't be constructed in post-processing?) We've attempted to design the code so that reductions can be performed with minimal memory allocation. 3D diagnostics can simply be calculated from snapshots of the model state, so there's no need to allocate memory (assuming that static memory greatly exceeds GPU memory, this would be preferred). Are we missing a feature to help reduce memory requirements of diagnostics perhaps?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1299561134
Deployability,upgrade,upgraded,"> Interesting, thanks for those details! That's odd that there are changes in memory allocation associated with building diagnostics. I don't think there's been changes to `Field` between 0.77.5 and 0.78.0. @navidcy might be able to say more. I think 0.78.0 only upgraded the tests to julia 1.8?; ; Maybe this indicates that the changes are due to changes in the dependencies when upgrading to 1.8?. > I'm also curious why the diagnostics consume so much memory. Are you producing a lot of 3D time averages (which can't be constructed in post-processing?) We've attempted to design the code so that reductions can be performed with minimal memory allocation. 3D diagnostics can simply be calculated from snapshots of the model state, so there's no need to allocate memory (assuming that static memory greatly exceeds GPU memory, this would be preferred). Are we missing a feature to help reduce memory requirements of diagnostics perhaps?. That's interesting. I'm actually also performing a significant amount of 3D averages, as you picked up on. The reason for that is because I want them at a higher frequency than the 3D snapshots that I'm outputting. I'd need a lot of disk-space to output the 3D fields at such high frequencies, so it's a storage limitation issue. That said, I wasn't aware that 3D averages in particular were memory-intensive, so I might rethink that rationale.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300682800
Energy Efficiency,allocate,allocate,"> Interesting, thanks for those details! That's odd that there are changes in memory allocation associated with building diagnostics. I don't think there's been changes to `Field` between 0.77.5 and 0.78.0. @navidcy might be able to say more. I think 0.78.0 only upgraded the tests to julia 1.8?; ; Maybe this indicates that the changes are due to changes in the dependencies when upgrading to 1.8?. > I'm also curious why the diagnostics consume so much memory. Are you producing a lot of 3D time averages (which can't be constructed in post-processing?) We've attempted to design the code so that reductions can be performed with minimal memory allocation. 3D diagnostics can simply be calculated from snapshots of the model state, so there's no need to allocate memory (assuming that static memory greatly exceeds GPU memory, this would be preferred). Are we missing a feature to help reduce memory requirements of diagnostics perhaps?. That's interesting. I'm actually also performing a significant amount of 3D averages, as you picked up on. The reason for that is because I want them at a higher frequency than the 3D snapshots that I'm outputting. I'd need a lot of disk-space to output the 3D fields at such high frequencies, so it's a storage limitation issue. That said, I wasn't aware that 3D averages in particular were memory-intensive, so I might rethink that rationale.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300682800
Integrability,depend,dependencies,"> Interesting, thanks for those details! That's odd that there are changes in memory allocation associated with building diagnostics. I don't think there's been changes to `Field` between 0.77.5 and 0.78.0. @navidcy might be able to say more. I think 0.78.0 only upgraded the tests to julia 1.8?; ; Maybe this indicates that the changes are due to changes in the dependencies when upgrading to 1.8?. > I'm also curious why the diagnostics consume so much memory. Are you producing a lot of 3D time averages (which can't be constructed in post-processing?) We've attempted to design the code so that reductions can be performed with minimal memory allocation. 3D diagnostics can simply be calculated from snapshots of the model state, so there's no need to allocate memory (assuming that static memory greatly exceeds GPU memory, this would be preferred). Are we missing a feature to help reduce memory requirements of diagnostics perhaps?. That's interesting. I'm actually also performing a significant amount of 3D averages, as you picked up on. The reason for that is because I want them at a higher frequency than the 3D snapshots that I'm outputting. I'd need a lot of disk-space to output the 3D fields at such high frequencies, so it's a storage limitation issue. That said, I wasn't aware that 3D averages in particular were memory-intensive, so I might rethink that rationale.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300682800
Performance,perform,performed,"> Interesting, thanks for those details! That's odd that there are changes in memory allocation associated with building diagnostics. I don't think there's been changes to `Field` between 0.77.5 and 0.78.0. @navidcy might be able to say more. I think 0.78.0 only upgraded the tests to julia 1.8?; ; Maybe this indicates that the changes are due to changes in the dependencies when upgrading to 1.8?. > I'm also curious why the diagnostics consume so much memory. Are you producing a lot of 3D time averages (which can't be constructed in post-processing?) We've attempted to design the code so that reductions can be performed with minimal memory allocation. 3D diagnostics can simply be calculated from snapshots of the model state, so there's no need to allocate memory (assuming that static memory greatly exceeds GPU memory, this would be preferred). Are we missing a feature to help reduce memory requirements of diagnostics perhaps?. That's interesting. I'm actually also performing a significant amount of 3D averages, as you picked up on. The reason for that is because I want them at a higher frequency than the 3D snapshots that I'm outputting. I'd need a lot of disk-space to output the 3D fields at such high frequencies, so it's a storage limitation issue. That said, I wasn't aware that 3D averages in particular were memory-intensive, so I might rethink that rationale.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300682800
Testability,test,tests,"> Interesting, thanks for those details! That's odd that there are changes in memory allocation associated with building diagnostics. I don't think there's been changes to `Field` between 0.77.5 and 0.78.0. @navidcy might be able to say more. I think 0.78.0 only upgraded the tests to julia 1.8?; ; Maybe this indicates that the changes are due to changes in the dependencies when upgrading to 1.8?. > I'm also curious why the diagnostics consume so much memory. Are you producing a lot of 3D time averages (which can't be constructed in post-processing?) We've attempted to design the code so that reductions can be performed with minimal memory allocation. 3D diagnostics can simply be calculated from snapshots of the model state, so there's no need to allocate memory (assuming that static memory greatly exceeds GPU memory, this would be preferred). Are we missing a feature to help reduce memory requirements of diagnostics perhaps?. That's interesting. I'm actually also performing a significant amount of 3D averages, as you picked up on. The reason for that is because I want them at a higher frequency than the 3D snapshots that I'm outputting. I'd need a lot of disk-space to output the 3D fields at such high frequencies, so it's a storage limitation issue. That said, I wasn't aware that 3D averages in particular were memory-intensive, so I might rethink that rationale.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300682800
Usability,simpl,simply,"> Interesting, thanks for those details! That's odd that there are changes in memory allocation associated with building diagnostics. I don't think there's been changes to `Field` between 0.77.5 and 0.78.0. @navidcy might be able to say more. I think 0.78.0 only upgraded the tests to julia 1.8?; ; Maybe this indicates that the changes are due to changes in the dependencies when upgrading to 1.8?. > I'm also curious why the diagnostics consume so much memory. Are you producing a lot of 3D time averages (which can't be constructed in post-processing?) We've attempted to design the code so that reductions can be performed with minimal memory allocation. 3D diagnostics can simply be calculated from snapshots of the model state, so there's no need to allocate memory (assuming that static memory greatly exceeds GPU memory, this would be preferred). Are we missing a feature to help reduce memory requirements of diagnostics perhaps?. That's interesting. I'm actually also performing a significant amount of 3D averages, as you picked up on. The reason for that is because I want them at a higher frequency than the 3D snapshots that I'm outputting. I'd need a lot of disk-space to output the 3D fields at such high frequencies, so it's a storage limitation issue. That said, I wasn't aware that 3D averages in particular were memory-intensive, so I might rethink that rationale.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300682800
Usability,clear,clear,"> You can also accumulate the time-average on the CPU. Just to be clear though, I have plenty of 3D spatial (volume) averages, but no time-averages on my runs! I know the time-averaging does take more memory because of the accumulation process, but the spatial average is kind of a surprise for me.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1301495852
Availability,error,error,"Regarding the comment [here](https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1304574572), can anyone help me understand some things?. The following MWE works:. ```julia; grid_base = RectilinearGrid(topology=(Bounded, Periodic, Bounded), size=(4, 4, 4), extent = (1,1,1)); grid = MultiRegionGrid(grid_base, partition = XPartition(2), devices = 2); model = NonhydrostaticModel(grid = grid). simulation = Simulation(model, Δt=1, stop_iteration=10,); wizard = TimeStepWizard(max_change=1.02, cfl=0.8); simulation.callbacks[:wizard] = Callback(wizard, IterationInterval(4)); ```. And I can confirm that Δt is indeed changed by the end of the simulation. However, when I issue `wizard.cell_advection_timescale(model)` I get error above. I also get errors when using `wizard.cell_advection_timescale(model.grid, model.velocities)`. . So I'm clearly missing something here. It seems to me the answer includes `construct_regionally` or `@apply_regionally`, but I couldn't figure it out from the available docs and code. PS: for now I'm using only one CPU core to run things, but still passing two devices to the `MultiRegionGrid` constructor, in case that's important.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1304897071
Usability,clear,clearly,"Regarding the comment [here](https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1304574572), can anyone help me understand some things?. The following MWE works:. ```julia; grid_base = RectilinearGrid(topology=(Bounded, Periodic, Bounded), size=(4, 4, 4), extent = (1,1,1)); grid = MultiRegionGrid(grid_base, partition = XPartition(2), devices = 2); model = NonhydrostaticModel(grid = grid). simulation = Simulation(model, Δt=1, stop_iteration=10,); wizard = TimeStepWizard(max_change=1.02, cfl=0.8); simulation.callbacks[:wizard] = Callback(wizard, IterationInterval(4)); ```. And I can confirm that Δt is indeed changed by the end of the simulation. However, when I issue `wizard.cell_advection_timescale(model)` I get error above. I also get errors when using `wizard.cell_advection_timescale(model.grid, model.velocities)`. . So I'm clearly missing something here. It seems to me the answer includes `construct_regionally` or `@apply_regionally`, but I couldn't figure it out from the available docs and code. PS: for now I'm using only one CPU core to run things, but still passing two devices to the `MultiRegionGrid` constructor, in case that's important.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1304897071
Testability,test,test,"I've had a play implementing an NPD model in this framework now and think that the other way to define the source functions is preferential:; https://github.com/CliMA/Oceananigans.jl/blob/45971e4b113182958aac43357e2a4633510617db/test/test_biogeochemistry.jl#L33-L37. We could even go one step further and define a model like this:; ```julia; struct NPD; Kₙ :: Float64; m :: Float64; nitrif :: Float64; end. validate_biogeochemistry(::NPD, tracernames) = all([T ∈ tracernames for T in [:N, :P, :D]]). @inline function (model::NPD)(i, j, k, grid, ::Val{:N}, clock, fields); P = @inbounds fields.P[i, j, k]; N = @inbounds fields.N[i, j, k]; D = @inbounds fields.D[i, j, k]. return model.nitrif*D - P*N/(N+model.Kₙ) ; end. @inline function (model::NPD)(i, j, k, grid, ::Val{:P}, clock, fields); P = @inbounds fields.P[i, j, k]; N = @inbounds fields.N[i, j, k]; return P*N/(N+model.Kₙ) - model.m*P; end. @inline function (model::NPD)(i, j, k, grid, ::Val{:D}, clock, fields); P = @inbounds fields.P[i, j, k]; D = @inbounds fields.D[i, j, k]. return model.m*P - model.nitrif*D; end. @inline (model::NPD)(args...) = 0.0; ```; This negates the need to define a `get_biogeochemial_forcing` function, but you do have to define the zero function (last line) and I'm not sure how clear and usable this API is to most users?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1304900744
Usability,clear,clear,"I've had a play implementing an NPD model in this framework now and think that the other way to define the source functions is preferential:; https://github.com/CliMA/Oceananigans.jl/blob/45971e4b113182958aac43357e2a4633510617db/test/test_biogeochemistry.jl#L33-L37. We could even go one step further and define a model like this:; ```julia; struct NPD; Kₙ :: Float64; m :: Float64; nitrif :: Float64; end. validate_biogeochemistry(::NPD, tracernames) = all([T ∈ tracernames for T in [:N, :P, :D]]). @inline function (model::NPD)(i, j, k, grid, ::Val{:N}, clock, fields); P = @inbounds fields.P[i, j, k]; N = @inbounds fields.N[i, j, k]; D = @inbounds fields.D[i, j, k]. return model.nitrif*D - P*N/(N+model.Kₙ) ; end. @inline function (model::NPD)(i, j, k, grid, ::Val{:P}, clock, fields); P = @inbounds fields.P[i, j, k]; N = @inbounds fields.N[i, j, k]; return P*N/(N+model.Kₙ) - model.m*P; end. @inline function (model::NPD)(i, j, k, grid, ::Val{:D}, clock, fields); P = @inbounds fields.P[i, j, k]; D = @inbounds fields.D[i, j, k]. return model.m*P - model.nitrif*D; end. @inline (model::NPD)(args...) = 0.0; ```; This negates the need to define a `get_biogeochemial_forcing` function, but you do have to define the zero function (last line) and I'm not sure how clear and usable this API is to most users?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1304900744
Availability,error,error,"Instead of `validate_biogeochemistry`, maybe. ```julia; required_biogeochemical_tracers(::NutrientsPlanktonDetritus) = (:N, :P, :D); ```. is a better syntax. Then users don't have to write their own error messages (we'll handle that in Oceananigans). It also gives us flexibility regarding the choice between 1) automagically adding the biogeochemical tracers or 2) requiring the user to add tracers themselves. We starting to use tracers for a few important things (TKE, biogeochemistry, buoyancy models). We may also need to come up with a system for handling ""name clashes"" gracefully. For example, someone might introduce a biogeochemistry model with tracer `e`, not realizing that this would prevent them from using the biogeochemistry model with CATKE. There's a tension between simplicity and readability (which we get with short, intuitive tracer names like `e`, `T`, `S`), and catastrophic ""name clashes"" that will inevitably occur as model complexity increases.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1305838390
Integrability,message,messages,"Instead of `validate_biogeochemistry`, maybe. ```julia; required_biogeochemical_tracers(::NutrientsPlanktonDetritus) = (:N, :P, :D); ```. is a better syntax. Then users don't have to write their own error messages (we'll handle that in Oceananigans). It also gives us flexibility regarding the choice between 1) automagically adding the biogeochemical tracers or 2) requiring the user to add tracers themselves. We starting to use tracers for a few important things (TKE, biogeochemistry, buoyancy models). We may also need to come up with a system for handling ""name clashes"" gracefully. For example, someone might introduce a biogeochemistry model with tracer `e`, not realizing that this would prevent them from using the biogeochemistry model with CATKE. There's a tension between simplicity and readability (which we get with short, intuitive tracer names like `e`, `T`, `S`), and catastrophic ""name clashes"" that will inevitably occur as model complexity increases.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1305838390
Usability,simpl,simplicity,"Instead of `validate_biogeochemistry`, maybe. ```julia; required_biogeochemical_tracers(::NutrientsPlanktonDetritus) = (:N, :P, :D); ```. is a better syntax. Then users don't have to write their own error messages (we'll handle that in Oceananigans). It also gives us flexibility regarding the choice between 1) automagically adding the biogeochemical tracers or 2) requiring the user to add tracers themselves. We starting to use tracers for a few important things (TKE, biogeochemistry, buoyancy models). We may also need to come up with a system for handling ""name clashes"" gracefully. For example, someone might introduce a biogeochemistry model with tracer `e`, not realizing that this would prevent them from using the biogeochemistry model with CATKE. There's a tension between simplicity and readability (which we get with short, intuitive tracer names like `e`, `T`, `S`), and catastrophic ""name clashes"" that will inevitably occur as model complexity increases.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1305838390
Deployability,integrat,integrating,"I've had a go at implementing a proper NPZD model (rather than one I just made up on the fly) and have some thoughts on how we should modify the API:; - I think we need an `required_biogeochemical_auxiliary_fields` like `required_biogeochemical_tracers` because for most models we're going to want the user to at least specify a PAR field (I suppose we may want this to also check the shape of the field because some models may have a pre defined depth dependence of PAR so we might want the user to specify a 2D PAR field rather than doing it properly by integrating a 3D field); - Given what you said the other day about callbacks only being used for features that should be built into Oceananigans we might want to have a think about how a BGC model can specify the attenuation of PAR. You've mentioned that we could define some kind of integrated field?; - It might be helpful to have a simpler interface for advection in biogeochemical models. Although a user could just add another forcing, I think the only way for a model to automatically add an advective forcing is how I've implimented it in the below example. I Think this works quite well since a lot of BGC models write the sinking terms with the other forcing terms, but its a little cumbersome to write e.g. `sinking = div_Uc(i, j, k, grid, bgc.adv_scheme, bgc.u⃗ᵖ, fields.P)`, and model makers will need to do the setup stuff I've done to make the advective velocity fields. You can see my implementation [here](https://github.com/OceanBioME/OceanBioME.jl/blob/Oceananigans-Update/src/Models/AdvectedPopulations/NPZD.jl) and a script using it [here](https://github.com/OceanBioME/OceanBioME.jl/blob/Oceananigans-Update/examples/NPZD.jl) since I thought it was probably too complicated for the test (and will change that back to a 1 variable model later). Not finished making it work but yet but will be done soon.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1310609242
Integrability,depend,dependence,"I've had a go at implementing a proper NPZD model (rather than one I just made up on the fly) and have some thoughts on how we should modify the API:; - I think we need an `required_biogeochemical_auxiliary_fields` like `required_biogeochemical_tracers` because for most models we're going to want the user to at least specify a PAR field (I suppose we may want this to also check the shape of the field because some models may have a pre defined depth dependence of PAR so we might want the user to specify a 2D PAR field rather than doing it properly by integrating a 3D field); - Given what you said the other day about callbacks only being used for features that should be built into Oceananigans we might want to have a think about how a BGC model can specify the attenuation of PAR. You've mentioned that we could define some kind of integrated field?; - It might be helpful to have a simpler interface for advection in biogeochemical models. Although a user could just add another forcing, I think the only way for a model to automatically add an advective forcing is how I've implimented it in the below example. I Think this works quite well since a lot of BGC models write the sinking terms with the other forcing terms, but its a little cumbersome to write e.g. `sinking = div_Uc(i, j, k, grid, bgc.adv_scheme, bgc.u⃗ᵖ, fields.P)`, and model makers will need to do the setup stuff I've done to make the advective velocity fields. You can see my implementation [here](https://github.com/OceanBioME/OceanBioME.jl/blob/Oceananigans-Update/src/Models/AdvectedPopulations/NPZD.jl) and a script using it [here](https://github.com/OceanBioME/OceanBioME.jl/blob/Oceananigans-Update/examples/NPZD.jl) since I thought it was probably too complicated for the test (and will change that back to a 1 variable model later). Not finished making it work but yet but will be done soon.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1310609242
Modifiability,variab,variable,"I've had a go at implementing a proper NPZD model (rather than one I just made up on the fly) and have some thoughts on how we should modify the API:; - I think we need an `required_biogeochemical_auxiliary_fields` like `required_biogeochemical_tracers` because for most models we're going to want the user to at least specify a PAR field (I suppose we may want this to also check the shape of the field because some models may have a pre defined depth dependence of PAR so we might want the user to specify a 2D PAR field rather than doing it properly by integrating a 3D field); - Given what you said the other day about callbacks only being used for features that should be built into Oceananigans we might want to have a think about how a BGC model can specify the attenuation of PAR. You've mentioned that we could define some kind of integrated field?; - It might be helpful to have a simpler interface for advection in biogeochemical models. Although a user could just add another forcing, I think the only way for a model to automatically add an advective forcing is how I've implimented it in the below example. I Think this works quite well since a lot of BGC models write the sinking terms with the other forcing terms, but its a little cumbersome to write e.g. `sinking = div_Uc(i, j, k, grid, bgc.adv_scheme, bgc.u⃗ᵖ, fields.P)`, and model makers will need to do the setup stuff I've done to make the advective velocity fields. You can see my implementation [here](https://github.com/OceanBioME/OceanBioME.jl/blob/Oceananigans-Update/src/Models/AdvectedPopulations/NPZD.jl) and a script using it [here](https://github.com/OceanBioME/OceanBioME.jl/blob/Oceananigans-Update/examples/NPZD.jl) since I thought it was probably too complicated for the test (and will change that back to a 1 variable model later). Not finished making it work but yet but will be done soon.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1310609242
Testability,test,test,"I've had a go at implementing a proper NPZD model (rather than one I just made up on the fly) and have some thoughts on how we should modify the API:; - I think we need an `required_biogeochemical_auxiliary_fields` like `required_biogeochemical_tracers` because for most models we're going to want the user to at least specify a PAR field (I suppose we may want this to also check the shape of the field because some models may have a pre defined depth dependence of PAR so we might want the user to specify a 2D PAR field rather than doing it properly by integrating a 3D field); - Given what you said the other day about callbacks only being used for features that should be built into Oceananigans we might want to have a think about how a BGC model can specify the attenuation of PAR. You've mentioned that we could define some kind of integrated field?; - It might be helpful to have a simpler interface for advection in biogeochemical models. Although a user could just add another forcing, I think the only way for a model to automatically add an advective forcing is how I've implimented it in the below example. I Think this works quite well since a lot of BGC models write the sinking terms with the other forcing terms, but its a little cumbersome to write e.g. `sinking = div_Uc(i, j, k, grid, bgc.adv_scheme, bgc.u⃗ᵖ, fields.P)`, and model makers will need to do the setup stuff I've done to make the advective velocity fields. You can see my implementation [here](https://github.com/OceanBioME/OceanBioME.jl/blob/Oceananigans-Update/src/Models/AdvectedPopulations/NPZD.jl) and a script using it [here](https://github.com/OceanBioME/OceanBioME.jl/blob/Oceananigans-Update/examples/NPZD.jl) since I thought it was probably too complicated for the test (and will change that back to a 1 variable model later). Not finished making it work but yet but will be done soon.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1310609242
Usability,simpl,simpler,"I've had a go at implementing a proper NPZD model (rather than one I just made up on the fly) and have some thoughts on how we should modify the API:; - I think we need an `required_biogeochemical_auxiliary_fields` like `required_biogeochemical_tracers` because for most models we're going to want the user to at least specify a PAR field (I suppose we may want this to also check the shape of the field because some models may have a pre defined depth dependence of PAR so we might want the user to specify a 2D PAR field rather than doing it properly by integrating a 3D field); - Given what you said the other day about callbacks only being used for features that should be built into Oceananigans we might want to have a think about how a BGC model can specify the attenuation of PAR. You've mentioned that we could define some kind of integrated field?; - It might be helpful to have a simpler interface for advection in biogeochemical models. Although a user could just add another forcing, I think the only way for a model to automatically add an advective forcing is how I've implimented it in the below example. I Think this works quite well since a lot of BGC models write the sinking terms with the other forcing terms, but its a little cumbersome to write e.g. `sinking = div_Uc(i, j, k, grid, bgc.adv_scheme, bgc.u⃗ᵖ, fields.P)`, and model makers will need to do the setup stuff I've done to make the advective velocity fields. You can see my implementation [here](https://github.com/OceanBioME/OceanBioME.jl/blob/Oceananigans-Update/src/Models/AdvectedPopulations/NPZD.jl) and a script using it [here](https://github.com/OceanBioME/OceanBioME.jl/blob/Oceananigans-Update/examples/NPZD.jl) since I thought it was probably too complicated for the test (and will change that back to a 1 variable model later). Not finished making it work but yet but will be done soon.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1310609242
Integrability,interface,interface,"> It might be helpful to have a simpler interface for advection in biogeochemical models. Although a user could just add another forcing, I think the only way for a model to automatically add an advective forcing is how I've implimented it in the below example. I Think this works quite well since a lot of BGC models write the sinking terms with the other forcing terms, but its a little cumbersome to write e.g. sinking = div_Uc(i, j, k, grid, bgc.adv_scheme, bgc.u⃗ᵖ, fields.P), and model makers will need to do the setup stuff I've done to make the advective velocity fields. Can't we add advective terms via the biogeochemical forcing term?. edit: I see you mentioned that, so I might be missing something... I'll take a look at your examples. PS we should add those scripts to `validation/biogeochemistry/`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1310890224
Security,validat,validation,"> It might be helpful to have a simpler interface for advection in biogeochemical models. Although a user could just add another forcing, I think the only way for a model to automatically add an advective forcing is how I've implimented it in the below example. I Think this works quite well since a lot of BGC models write the sinking terms with the other forcing terms, but its a little cumbersome to write e.g. sinking = div_Uc(i, j, k, grid, bgc.adv_scheme, bgc.u⃗ᵖ, fields.P), and model makers will need to do the setup stuff I've done to make the advective velocity fields. Can't we add advective terms via the biogeochemical forcing term?. edit: I see you mentioned that, so I might be missing something... I'll take a look at your examples. PS we should add those scripts to `validation/biogeochemistry/`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1310890224
Usability,simpl,simpler,"> It might be helpful to have a simpler interface for advection in biogeochemical models. Although a user could just add another forcing, I think the only way for a model to automatically add an advective forcing is how I've implimented it in the below example. I Think this works quite well since a lot of BGC models write the sinking terms with the other forcing terms, but its a little cumbersome to write e.g. sinking = div_Uc(i, j, k, grid, bgc.adv_scheme, bgc.u⃗ᵖ, fields.P), and model makers will need to do the setup stuff I've done to make the advective velocity fields. Can't we add advective terms via the biogeochemical forcing term?. edit: I see you mentioned that, so I might be missing something... I'll take a look at your examples. PS we should add those scripts to `validation/biogeochemistry/`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1310890224
Availability,avail,available,"I would suggest sticking with PAR rather than light.  PAR is very common in biogeochemistry and it is made up of specific bands of light and hence “light” and PAR aren’t exactly equivalent.  Calling it “light” could cause confusion if someone calculates PAR from the incoming solar radiation (light).; On Nov 18, 2022 at 3:07 PM +0000, Jago Strong-Wright ***@***.***>, wrote:; > @jagoosw commented on this pull request.; > In test/test_biogeochemistry.jl:; > > + wait(device(model.architecture), par_calculation); >; > +end; >; > +; >; > +biogeochemistry_parameters = (; >; > + growth_rate = 1/day,; >; > + light_limit = 3.5,; >; > + mortality_rate = 0.1/day,; >; > +; >; > + water_light_attenuation_coefficient = 0.12,; >; > + phytoplankton_light_attenuation_coefficient = 0.06,; >; > + phytoplankton_light_attenuation_exponent = 0.6,; >; > + surface_PAR = t -> 100*max(0.0, sin(t*π/(12hours))); >; > +); >; > +; >; > +biogeochemistry = SomethingBiogeochemistry(tracers = :P,; >; > + auxiliary_fields = :PAR,; >; > Makses sense, after I started I realised it was a bigger challenge than I thought it would be!; > I'll try and make these changes later.; > PAR stands for photosynthetically available radiation, perhaps it would be more clear to call it light here.; > —; > Reply to this email directly, view it on GitHub, or unsubscribe.; > You are receiving this because you were mentioned.Message ID: ***@***.***>",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1320161513
Testability,test,test,"I would suggest sticking with PAR rather than light.  PAR is very common in biogeochemistry and it is made up of specific bands of light and hence “light” and PAR aren’t exactly equivalent.  Calling it “light” could cause confusion if someone calculates PAR from the incoming solar radiation (light).; On Nov 18, 2022 at 3:07 PM +0000, Jago Strong-Wright ***@***.***>, wrote:; > @jagoosw commented on this pull request.; > In test/test_biogeochemistry.jl:; > > + wait(device(model.architecture), par_calculation); >; > +end; >; > +; >; > +biogeochemistry_parameters = (; >; > + growth_rate = 1/day,; >; > + light_limit = 3.5,; >; > + mortality_rate = 0.1/day,; >; > +; >; > + water_light_attenuation_coefficient = 0.12,; >; > + phytoplankton_light_attenuation_coefficient = 0.06,; >; > + phytoplankton_light_attenuation_exponent = 0.6,; >; > + surface_PAR = t -> 100*max(0.0, sin(t*π/(12hours))); >; > +); >; > +; >; > +biogeochemistry = SomethingBiogeochemistry(tracers = :P,; >; > + auxiliary_fields = :PAR,; >; > Makses sense, after I started I realised it was a bigger challenge than I thought it would be!; > I'll try and make these changes later.; > PAR stands for photosynthetically available radiation, perhaps it would be more clear to call it light here.; > —; > Reply to this email directly, view it on GitHub, or unsubscribe.; > You are receiving this because you were mentioned.Message ID: ***@***.***>",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1320161513
Usability,clear,clear,"I would suggest sticking with PAR rather than light.  PAR is very common in biogeochemistry and it is made up of specific bands of light and hence “light” and PAR aren’t exactly equivalent.  Calling it “light” could cause confusion if someone calculates PAR from the incoming solar radiation (light).; On Nov 18, 2022 at 3:07 PM +0000, Jago Strong-Wright ***@***.***>, wrote:; > @jagoosw commented on this pull request.; > In test/test_biogeochemistry.jl:; > > + wait(device(model.architecture), par_calculation); >; > +end; >; > +; >; > +biogeochemistry_parameters = (; >; > + growth_rate = 1/day,; >; > + light_limit = 3.5,; >; > + mortality_rate = 0.1/day,; >; > +; >; > + water_light_attenuation_coefficient = 0.12,; >; > + phytoplankton_light_attenuation_coefficient = 0.06,; >; > + phytoplankton_light_attenuation_exponent = 0.6,; >; > + surface_PAR = t -> 100*max(0.0, sin(t*π/(12hours))); >; > +); >; > +; >; > +biogeochemistry = SomethingBiogeochemistry(tracers = :P,; >; > + auxiliary_fields = :PAR,; >; > Makses sense, after I started I realised it was a bigger challenge than I thought it would be!; > I'll try and make these changes later.; > PAR stands for photosynthetically available radiation, perhaps it would be more clear to call it light here.; > —; > Reply to this email directly, view it on GitHub, or unsubscribe.; > You are receiving this because you were mentioned.Message ID: ***@***.***>",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1320161513
Deployability,update,update,"> If it is a parameter then the update state would need to check if there is a parameter before which might be more ambiguous to set up?. The user has to define `update_biogeochemical_state!` for the particular `BasicBiogeochemistry` they would like to use; if they want to compute light attenuation, they'll have to write that. However, I can envision child packages to Oceananigans providing more structured functionality for users. I think we just want to keep the Oceananigans interface as simple and general as possible since we expected it to be used by many different types of chemistry and biology models.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1335278999
Integrability,interface,interface,"> If it is a parameter then the update state would need to check if there is a parameter before which might be more ambiguous to set up?. The user has to define `update_biogeochemical_state!` for the particular `BasicBiogeochemistry` they would like to use; if they want to compute light attenuation, they'll have to write that. However, I can envision child packages to Oceananigans providing more structured functionality for users. I think we just want to keep the Oceananigans interface as simple and general as possible since we expected it to be used by many different types of chemistry and biology models.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1335278999
Usability,simpl,simple,"> If it is a parameter then the update state would need to check if there is a parameter before which might be more ambiguous to set up?. The user has to define `update_biogeochemical_state!` for the particular `BasicBiogeochemistry` they would like to use; if they want to compute light attenuation, they'll have to write that. However, I can envision child packages to Oceananigans providing more structured functionality for users. I think we just want to keep the Oceananigans interface as simple and general as possible since we expected it to be used by many different types of chemistry and biology models.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1335278999
Usability,simpl,simple,"Can we come up with a MWE, maybe a simple 2 point single column model that can be copy/pasted here?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809#issuecomment-1308123094
Testability,test,test,"> Can we come up with a MWE, maybe a simple 2 point single column model that can be copy/pasted here?. This test _is_ done using 2-point single column models :). https://github.com/CliMA/Oceananigans.jl/blob/99ad4c151095835c21ca899561429be30e8181cb/test/test_ensemble_hydrostatic_free_surface_models.jl#L56-L58",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809#issuecomment-1308126156
Usability,simpl,simple,"> Can we come up with a MWE, maybe a simple 2 point single column model that can be copy/pasted here?. This test _is_ done using 2-point single column models :). https://github.com/CliMA/Oceananigans.jl/blob/99ad4c151095835c21ca899561429be30e8181cb/test/test_ensemble_hydrostatic_free_surface_models.jl#L56-L58",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809#issuecomment-1308126156
Usability,simpl,simple,"The issue with `Δx` is that these are already defined as ""GridMetricOperation""s, eg objects that can be used within abstract operations. A simple solution is to follow the ""nodes"" semantics (might be better anyways)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2842#issuecomment-1328167577
Usability,simpl,simple,"Personally I think it makes sense to start simple from an API perspective, and add convenience when its warranted",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2842#issuecomment-1464621131
Energy Efficiency,energy,energy-conserving,"Adapting Smagorinsky seems an easy avenue. . In terms of Implicit LES, you could try using just WENO without any closure, but if you are in a true LES regime it would probably be too dissipative. A Smagorinsky viscosity combined with an energy-conserving advection scheme has been found to be less dissipative although noisier (here is an example applied to Burgers equation https://reader.elsevier.com/reader/sd/pii/S0377042717303035?token=83A413B5659B8B16B96E1D0CBDAD5865D8552AE5B2FF2FDFE78FFDEF064F2820B38D1BBFF646D3F7B75D58FE010DF7DB&originRegion=us-east-1&originCreation=20230125193548). You can always try with higher order (maybe 7th?) but the higher the order the lower the stability (i.e. at a certain order your implicit dissipation will be so low that you will start to generate grid-scale noise). . The KE dissipation is there with `closure=nothing` and a WENO scheme, it is just not strictly physical: it's (roughly) akin to a 4th to a 6th-order hyperviscosity. You can compare this to using `UpwindBiased(order = 5)` which would give you everywhere a dissipation that converges to a 6th-order hyperviscosity. In general:. $$\partial_x {uu}^{Upwind_N} \sim \partial_x {uu}^{Centered_{N+1}} + \partial_x {K_{numerical}} \partial_x^{N} u$$. where $K_{numerical} \sim \Delta x u$ and $N$ is the order. The nice thing about using WENO instead of a simple Upwind discretization is that the order of the hyperviscosity adapts to the smoothness of the field. Therefore, where the field is noisier (like in regions of higher gradients) the dissipation is more aggressive. . This procedure not only ensures a smooth field but can be thought of as mimicking the subgrid-scale dissipation (which also increases with the gradient of resolved scale variables. As such people have referred to using particularly diffusive advective schemes (such as WENO) as _Implicit_ LES. I like the idea of implicit LES because it allows you to ""fill in"" for the subgrid-scale dissipation without committing to any s",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2869#issuecomment-1404144433
Modifiability,adapt,adapts,"er.elsevier.com/reader/sd/pii/S0377042717303035?token=83A413B5659B8B16B96E1D0CBDAD5865D8552AE5B2FF2FDFE78FFDEF064F2820B38D1BBFF646D3F7B75D58FE010DF7DB&originRegion=us-east-1&originCreation=20230125193548). You can always try with higher order (maybe 7th?) but the higher the order the lower the stability (i.e. at a certain order your implicit dissipation will be so low that you will start to generate grid-scale noise). . The KE dissipation is there with `closure=nothing` and a WENO scheme, it is just not strictly physical: it's (roughly) akin to a 4th to a 6th-order hyperviscosity. You can compare this to using `UpwindBiased(order = 5)` which would give you everywhere a dissipation that converges to a 6th-order hyperviscosity. In general:. $$\partial_x {uu}^{Upwind_N} \sim \partial_x {uu}^{Centered_{N+1}} + \partial_x {K_{numerical}} \partial_x^{N} u$$. where $K_{numerical} \sim \Delta x u$ and $N$ is the order. The nice thing about using WENO instead of a simple Upwind discretization is that the order of the hyperviscosity adapts to the smoothness of the field. Therefore, where the field is noisier (like in regions of higher gradients) the dissipation is more aggressive. . This procedure not only ensures a smooth field but can be thought of as mimicking the subgrid-scale dissipation (which also increases with the gradient of resolved scale variables. As such people have referred to using particularly diffusive advective schemes (such as WENO) as _Implicit_ LES. I like the idea of implicit LES because it allows you to ""fill in"" for the subgrid-scale dissipation without committing to any sophisticated formulation derived in a particularly idealized situation (take the example of Leith derived in homogeneous 2D turbulence and the geostrophic eddies in the ocean), and guarantees (or at least helps) stability. For this reason, it's pretty handy when you have different unresolved processes at different scales that may be characterized by different dissipation characteristi",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2869#issuecomment-1404144433
Usability,simpl,simple,"er.elsevier.com/reader/sd/pii/S0377042717303035?token=83A413B5659B8B16B96E1D0CBDAD5865D8552AE5B2FF2FDFE78FFDEF064F2820B38D1BBFF646D3F7B75D58FE010DF7DB&originRegion=us-east-1&originCreation=20230125193548). You can always try with higher order (maybe 7th?) but the higher the order the lower the stability (i.e. at a certain order your implicit dissipation will be so low that you will start to generate grid-scale noise). . The KE dissipation is there with `closure=nothing` and a WENO scheme, it is just not strictly physical: it's (roughly) akin to a 4th to a 6th-order hyperviscosity. You can compare this to using `UpwindBiased(order = 5)` which would give you everywhere a dissipation that converges to a 6th-order hyperviscosity. In general:. $$\partial_x {uu}^{Upwind_N} \sim \partial_x {uu}^{Centered_{N+1}} + \partial_x {K_{numerical}} \partial_x^{N} u$$. where $K_{numerical} \sim \Delta x u$ and $N$ is the order. The nice thing about using WENO instead of a simple Upwind discretization is that the order of the hyperviscosity adapts to the smoothness of the field. Therefore, where the field is noisier (like in regions of higher gradients) the dissipation is more aggressive. . This procedure not only ensures a smooth field but can be thought of as mimicking the subgrid-scale dissipation (which also increases with the gradient of resolved scale variables. As such people have referred to using particularly diffusive advective schemes (such as WENO) as _Implicit_ LES. I like the idea of implicit LES because it allows you to ""fill in"" for the subgrid-scale dissipation without committing to any sophisticated formulation derived in a particularly idealized situation (take the example of Leith derived in homogeneous 2D turbulence and the geostrophic eddies in the ocean), and guarantees (or at least helps) stability. For this reason, it's pretty handy when you have different unresolved processes at different scales that may be characterized by different dissipation characteristi",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2869#issuecomment-1404144433
Testability,test,tests,> It seemed quite easy but now all tests are broken for a weird reason sweat_smile. Very strange. I can't believe this one simple change would cause all these problems. Is there something else going on here?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2877#issuecomment-1403898162
Usability,simpl,simple,> It seemed quite easy but now all tests are broken for a weird reason sweat_smile. Very strange. I can't believe this one simple change would cause all these problems. Is there something else going on here?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2877#issuecomment-1403898162
Usability,clear,clear,"> btw the function belongs to a generic `matrix_utils.jl` file or something and instead of `initialize_matrix` it should be called `build_matrix`. ""operator"" might be more clear? Or some other semantics. We want to say something like ""Solve A*x=b, where A is..."" I don't think we want to say ""A is The Matrix"". Something more specific?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2885#issuecomment-1412113470
Testability,test,test,"> > best-practices way to do things, but afaik it works; > ; > it only works within the Oceananigans environment, not for users of Oceananigans. True. Although I wasn't able to reproduce the failing test results in any of the several GPUs I tried (they were either Tesla V100s or Quadro GP100). Every single time I tried to run GPU tests locally, they passed. Is it possible that the tests are running on a GPU that simply isn't supported anymore by one of the packages?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2900#issuecomment-1418273665
Usability,simpl,simply,"> > best-practices way to do things, but afaik it works; > ; > it only works within the Oceananigans environment, not for users of Oceananigans. True. Although I wasn't able to reproduce the failing test results in any of the several GPUs I tried (they were either Tesla V100s or Quadro GP100). Every single time I tried to run GPU tests locally, they passed. Is it possible that the tests are running on a GPU that simply isn't supported anymore by one of the packages?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2900#issuecomment-1418273665
Testability,test,test,"> True. Although I wasn't able to reproduce the failing test results in any of the several GPUs I tried (they were either Tesla V100s or Quadro GP100). Every single time I tried to run GPU tests locally, they passed. Is it possible that the tests are running on a GPU that simply isn't supported anymore by one of the packages?. Here's GPU + driver info. ```; glwagner@sverdrup:~$ nvidia-smi -q. ==============NVSMI LOG==============. Timestamp : Sun Feb 5 17:58:59 2023; Driver Version : 465.27; CUDA Version : 11.3. Attached GPUs : 1; GPU 00000000:82:00.0; Product Name : NVIDIA Quadro P6000; Product Brand : Quadro; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2900#issuecomment-1418288880
Usability,simpl,simply,"> True. Although I wasn't able to reproduce the failing test results in any of the several GPUs I tried (they were either Tesla V100s or Quadro GP100). Every single time I tried to run GPU tests locally, they passed. Is it possible that the tests are running on a GPU that simply isn't supported anymore by one of the packages?. Here's GPU + driver info. ```; glwagner@sverdrup:~$ nvidia-smi -q. ==============NVSMI LOG==============. Timestamp : Sun Feb 5 17:58:59 2023; Driver Version : 465.27; CUDA Version : 11.3. Attached GPUs : 1; GPU 00000000:82:00.0; Product Name : NVIDIA Quadro P6000; Product Brand : Quadro; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2900#issuecomment-1418288880
Usability,clear,clear,"> On that branch you are still forming the `BinaryOperation` which is the problem. You also need to remove the `BinaryOperation`. If you open a PR we can work on it?. Sure, I'll open a new PR soon then!. But just to be clear, I totally get that the problem is that I'm still passing the binary operations. I kept them there because (if I understan correctly) if don't pass $\kappa_e$ in `DiffusivityFields()` then `model.diffusivity_fields` won't get populated, right? Or is your point that we don't have to populate `model.diffusivity_fields` for Smagorinsky?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2904#issuecomment-1419525329
Usability,clear,clear,"> The change I suggested will still put the eddy viscosity into diffusivity_fields, and removes the eddy diffusivities (calculating them on the fly from Pr and eddy viscosity). Yes! Sorry I wasn't clear enough. I got that. I meant populate it with the diffuvisities specifically, so we're on the same page.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2904#issuecomment-1419719914
Usability,clear,clearer,"y for going slow on this, but if I understand correctly what you're proposing is:. - Remove the calculation of diffusivities from `DiffusivityFields()` (and thus remove tracer diffusivities from `model.diffusivity_fields`); - Specialize `κᶠᶜᶜ()` functions for `SmagoriknskyLilly` so that diffusivities are calculated on the fly. As opposed to what I'm doing here which is just to change the calculation of diffusivities in `DiffusivityFields()` from using a `BinaryOperation` to a kernel (keeping them in `model.diffusivity_fields`). If I understand correctly both methods do the same number of operations (one calculation of $\nu_e$, a division by `Pr` and one interpolation for each face of each grid cell), no?. So I guess the advantage of what you're proposing is that it saves memory (since diffusivities are calculated on the fly), at the cost of a bit more code complexity (i.e., one more specialization). Conversely, the direction this PR is going atm uses more memory (for the diffusivities) but in my opinion the code is a bit clearer, since there's one fewer specialization (i.e. `κᶠᶜᶜ()` remains the same) and the code in `smagorinsky_lilly.jl` looks more like the code in `anisotropic_minimum_dissipation.jl`, which makes things more standardized. I'll defer to you either way, but I vote that we take the approach that this PR is currently doing since, as we discussed before in a few PRs, the code in `TurbulenceClosures` is already a bit on the complex side and not super easy to understand. So I think the standardization of having `smagorinsky_lilly.jl` have the same structure as `anisotropic_minimum_dissipation.jl` I'd argue is a benefit. If we follow with this PR, the increase in memory should be around 15% for one tracer and less for more tracers, so relatively small, plus the memory limitation is about to become less severe since hopefully https://github.com/CliMA/Oceananigans.jl/pull/2795 will be merged soon?. @glwagner like I said I'll defer to you either way. So if y",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2904#issuecomment-1419759789
Modifiability,extend,extending,I think extending `κᶠᶜᶜ` is simpler --- less code and less memory usage.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2904#issuecomment-1419777537
Usability,simpl,simpler,I think extending `κᶠᶜᶜ` is simpler --- less code and less memory usage.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2904#issuecomment-1419777537
Availability,error,errors,"> @glwagner I'm not sure whats causing these tests to fail now?. @jagoosw afaik sometimes we get errors of the kind. `ERROR: LoadError: SystemError: opening file ""/data5/glwagner/.julia-10703/compiled/v1.8/Oceananigans/hU93i_Y0P9A.ji"": No such file or directory`. on the gpu tests. Which is what's hapenning now. It's now clear to me at least what the cause is, but restarting the tests generally makes them pass. I just restarted them so it be fine. I should note that we got an error of the kind. `Expression: all(test_fields.v .≈ truth_fields.v)`. in the GPU shallow water tests, which I thought were corrected. Is this something we need to worry about?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2912#issuecomment-1481364658
Testability,test,tests,"> @glwagner I'm not sure whats causing these tests to fail now?. @jagoosw afaik sometimes we get errors of the kind. `ERROR: LoadError: SystemError: opening file ""/data5/glwagner/.julia-10703/compiled/v1.8/Oceananigans/hU93i_Y0P9A.ji"": No such file or directory`. on the gpu tests. Which is what's hapenning now. It's now clear to me at least what the cause is, but restarting the tests generally makes them pass. I just restarted them so it be fine. I should note that we got an error of the kind. `Expression: all(test_fields.v .≈ truth_fields.v)`. in the GPU shallow water tests, which I thought were corrected. Is this something we need to worry about?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2912#issuecomment-1481364658
Usability,clear,clear,"> @glwagner I'm not sure whats causing these tests to fail now?. @jagoosw afaik sometimes we get errors of the kind. `ERROR: LoadError: SystemError: opening file ""/data5/glwagner/.julia-10703/compiled/v1.8/Oceananigans/hU93i_Y0P9A.ji"": No such file or directory`. on the gpu tests. Which is what's hapenning now. It's now clear to me at least what the cause is, but restarting the tests generally makes them pass. I just restarted them so it be fine. I should note that we got an error of the kind. `Expression: all(test_fields.v .≈ truth_fields.v)`. in the GPU shallow water tests, which I thought were corrected. Is this something we need to worry about?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2912#issuecomment-1481364658
Usability,undo,undo,@jagoosw I committed a few changes. Feel free to undo or comment!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2912#issuecomment-1487558579
Usability,undo,undo,"> @jagoosw I committed a few changes. Feel free to undo or comment!. Looks good, thank you!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2912#issuecomment-1487694853
Testability,test,tests,"> the tests were not passing here. Yeah, I should have been more clear that I approved to merge after tests were passing, I didn't know we could even merge without tests passing. I thought that behavior was blocked",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2919#issuecomment-1427136695
Usability,clear,clear,"> the tests were not passing here. Yeah, I should have been more clear that I approved to merge after tests were passing, I didn't know we could even merge without tests passing. I thought that behavior was blocked",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2919#issuecomment-1427136695
Usability,simpl,simply,"Ah yes, we will have to change the user API so that it no longer accepts an advection scheme. We would also need a utility like. ```julia; total_velocities = with_advective_forcing(forcing, total_velocities); ```. that would add the forcing velocity when `forcing::AdvectiveForcing` (and otherwise simply returns `total_velocities`). That utility probably belongs in `advective_forcing.jl`. And `SumOfArrays` needs to support 3?. https://github.com/CliMA/Oceananigans.jl/blob/fa5e280115f619d01a460f012328bd7e6d253b38/src/Models/NonhydrostaticModels/nonhydrostatic_tendency_kernel_functions.jl#L64-L66",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2928#issuecomment-1679169187
Usability,simpl,simplify,I also have trouble understanding it... Perhaps @tomchor can elaborate? Or simplify it to exemplify the issue?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2931#issuecomment-1436096348
Usability,simpl,simplify,"> I also have trouble understanding it...; > ; > Perhaps @tomchor can elaborate? Or simplify it to exemplify the issue?. > So you can run for 18 steps instead of 4. (@tomchor why 18?). Sorry for the unclear example, guys and thanks for the help. I posted this after many hours of trying to catch the culprit in a _very_ complex simulation and at the time I was so tired that the MWE seemed reasonable to me. Now I see it's pretty badly set up. I'm gonna work a bit on this today and come up with a better MWE if we need one. But to explain a bit better, the main goal of this snippet (other than showing the issue) is to write (in the same file) an xz-slice (at `j=1`) and a y-average (using `Average(field, dims=(2,))`. For that I first create a tuple of ""full"" fields (fields without slicing or averaging, which I call `outputs_full`). Then, based on that tuple, get each element and average it in `y`, creating the tuple `outputs_yavg`. When I pass both of those tuples (merged) to the `NetCDFOutputWriter` along with the option `indices=(:,1,:)`, I get, in the same file, sliced fields (which are called `wτ1`, etc.) and y-averaged fields (called `wτ1_yavg`, etc.). I just ran @glwagner's MWE locally and the issue doesn't appear, even though at first it does exactly what my MWE does, so I need to track what's the important change there.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2931#issuecomment-1437230261
Availability,error,error,"That's some great debugging there, @glwagner. Thanks!. Yeah I agree passing indices alongside averages is unclear to say the least. When I first set up the output writer to do this (with only one tracer) I was surprised that it worked out of the box since I expected an error or warning. But since it made code simpler and it worked, I kept it. Then this error creeped up on me :grimacing: . I'd be okay if you want to not allow that, or throw a warning or something in this case.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2931#issuecomment-1438636158
Usability,simpl,simpler,"That's some great debugging there, @glwagner. Thanks!. Yeah I agree passing indices alongside averages is unclear to say the least. When I first set up the output writer to do this (with only one tracer) I was surprised that it worked out of the box since I expected an error or warning. But since it made code simpler and it worked, I kept it. Then this error creeped up on me :grimacing: . I'd be okay if you want to not allow that, or throw a warning or something in this case.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2931#issuecomment-1438636158
Energy Efficiency,energy,energy,"With no background diffusivity I also find the energy increases slowly. This is with WENO advection scheme. https://user-images.githubusercontent.com/15271942/221060649-86deb92a-45c3-401d-96ac-3dceabacc686.mp4. Perhaps one could compute the discrete conservation laws for the linear wave equations here given our staggered discretization of buoyancy / hydrostatic pressure + nonhydrostatic pressure... I'm not sure what we would find. It's not that simple, because nonhydrostatic pressure is treated implicitly / with a fractional step. Our hydrostatic pressure scheme is not the only possible scheme one might use. Perhaps other schemes have different numerical properties.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2935#issuecomment-1442609489
Usability,simpl,simple,"With no background diffusivity I also find the energy increases slowly. This is with WENO advection scheme. https://user-images.githubusercontent.com/15271942/221060649-86deb92a-45c3-401d-96ac-3dceabacc686.mp4. Perhaps one could compute the discrete conservation laws for the linear wave equations here given our staggered discretization of buoyancy / hydrostatic pressure + nonhydrostatic pressure... I'm not sure what we would find. It's not that simple, because nonhydrostatic pressure is treated implicitly / with a fractional step. Our hydrostatic pressure scheme is not the only possible scheme one might use. Perhaps other schemes have different numerical properties.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2935#issuecomment-1442609489
Deployability,continuous,continuous,"In this case if we see convergence with decreasing time-step (spatial resolution isn't relevant for these dynamics, which are at the grid scale and therefore not physical) then I suppose that would be an indication the issue is due to a finite time step. It's important to recognize that the dynamics of the _discrete_ linear equations are different than the continuous. When we have a smooth solution, such that our spatial discretization should approximate some exact smooth solution, we can test that refining the grid and time step leads to convergence to an exact solution. Moreover, we can estimate the time-scale of the dynamics using the time-scales of the smooth dynamics as a guide. An example is a resolved buoyancy oscillation: it has a timescale of roughly 1/N. This example is dominated by small amplitude (eg linear) noise at the grid scale. Therefore my initial time scale estimate of 1/N may not hold. Instead, we'd have to look at the discrete eigenvalues of the system at the very higheset wavenumbers (ie the Nyquist number 2pi / dx). We could then calculate the time-step that would be required to resolve these (completely unphysical) dynamics. I'm not sure what a lower bound on such spurious discrete dynamics might be. It could be far smaller than any physical time scale, ie as small as 1e-16, or smaller? Perhaps the evolution of grid scale noise also has to do with spatial resolution, so that could be another knob to vary. So if we want to investigate this further, we should conduct a systematic study of the dynamics of this grid-scale noise system affected by buoyancy, decreasing the time-step to zero. Or we can convince ourselves that non-noisy dynamics _are_ accurate --- eg by analyzing a system like the one we use for our ""internal wave"" dynamics test:. https://github.com/CliMA/Oceananigans.jl/blob/main/test/test_internal_wave_dynamics.jl. that test verifies that a wave packet in our code propagates at the correct group speed, for example. But one could div",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2935#issuecomment-1444451423
Integrability,depend,depends,"ue to a finite time step. It's important to recognize that the dynamics of the _discrete_ linear equations are different than the continuous. When we have a smooth solution, such that our spatial discretization should approximate some exact smooth solution, we can test that refining the grid and time step leads to convergence to an exact solution. Moreover, we can estimate the time-scale of the dynamics using the time-scales of the smooth dynamics as a guide. An example is a resolved buoyancy oscillation: it has a timescale of roughly 1/N. This example is dominated by small amplitude (eg linear) noise at the grid scale. Therefore my initial time scale estimate of 1/N may not hold. Instead, we'd have to look at the discrete eigenvalues of the system at the very higheset wavenumbers (ie the Nyquist number 2pi / dx). We could then calculate the time-step that would be required to resolve these (completely unphysical) dynamics. I'm not sure what a lower bound on such spurious discrete dynamics might be. It could be far smaller than any physical time scale, ie as small as 1e-16, or smaller? Perhaps the evolution of grid scale noise also has to do with spatial resolution, so that could be another knob to vary. So if we want to investigate this further, we should conduct a systematic study of the dynamics of this grid-scale noise system affected by buoyancy, decreasing the time-step to zero. Or we can convince ourselves that non-noisy dynamics _are_ accurate --- eg by analyzing a system like the one we use for our ""internal wave"" dynamics test:. https://github.com/CliMA/Oceananigans.jl/blob/main/test/test_internal_wave_dynamics.jl. that test verifies that a wave packet in our code propagates at the correct group speed, for example. But one could dive much deeper into that example and test a wide variety of wave numbers. It depends whether you are interested in the grid-scale noise system, or whether you are interested in verifying that smooth resolved dynamics are correct.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2935#issuecomment-1444451423
Testability,test,test,"In this case if we see convergence with decreasing time-step (spatial resolution isn't relevant for these dynamics, which are at the grid scale and therefore not physical) then I suppose that would be an indication the issue is due to a finite time step. It's important to recognize that the dynamics of the _discrete_ linear equations are different than the continuous. When we have a smooth solution, such that our spatial discretization should approximate some exact smooth solution, we can test that refining the grid and time step leads to convergence to an exact solution. Moreover, we can estimate the time-scale of the dynamics using the time-scales of the smooth dynamics as a guide. An example is a resolved buoyancy oscillation: it has a timescale of roughly 1/N. This example is dominated by small amplitude (eg linear) noise at the grid scale. Therefore my initial time scale estimate of 1/N may not hold. Instead, we'd have to look at the discrete eigenvalues of the system at the very higheset wavenumbers (ie the Nyquist number 2pi / dx). We could then calculate the time-step that would be required to resolve these (completely unphysical) dynamics. I'm not sure what a lower bound on such spurious discrete dynamics might be. It could be far smaller than any physical time scale, ie as small as 1e-16, or smaller? Perhaps the evolution of grid scale noise also has to do with spatial resolution, so that could be another knob to vary. So if we want to investigate this further, we should conduct a systematic study of the dynamics of this grid-scale noise system affected by buoyancy, decreasing the time-step to zero. Or we can convince ourselves that non-noisy dynamics _are_ accurate --- eg by analyzing a system like the one we use for our ""internal wave"" dynamics test:. https://github.com/CliMA/Oceananigans.jl/blob/main/test/test_internal_wave_dynamics.jl. that test verifies that a wave packet in our code propagates at the correct group speed, for example. But one could div",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2935#issuecomment-1444451423
Usability,guid,guide,"In this case if we see convergence with decreasing time-step (spatial resolution isn't relevant for these dynamics, which are at the grid scale and therefore not physical) then I suppose that would be an indication the issue is due to a finite time step. It's important to recognize that the dynamics of the _discrete_ linear equations are different than the continuous. When we have a smooth solution, such that our spatial discretization should approximate some exact smooth solution, we can test that refining the grid and time step leads to convergence to an exact solution. Moreover, we can estimate the time-scale of the dynamics using the time-scales of the smooth dynamics as a guide. An example is a resolved buoyancy oscillation: it has a timescale of roughly 1/N. This example is dominated by small amplitude (eg linear) noise at the grid scale. Therefore my initial time scale estimate of 1/N may not hold. Instead, we'd have to look at the discrete eigenvalues of the system at the very higheset wavenumbers (ie the Nyquist number 2pi / dx). We could then calculate the time-step that would be required to resolve these (completely unphysical) dynamics. I'm not sure what a lower bound on such spurious discrete dynamics might be. It could be far smaller than any physical time scale, ie as small as 1e-16, or smaller? Perhaps the evolution of grid scale noise also has to do with spatial resolution, so that could be another knob to vary. So if we want to investigate this further, we should conduct a systematic study of the dynamics of this grid-scale noise system affected by buoyancy, decreasing the time-step to zero. Or we can convince ourselves that non-noisy dynamics _are_ accurate --- eg by analyzing a system like the one we use for our ""internal wave"" dynamics test:. https://github.com/CliMA/Oceananigans.jl/blob/main/test/test_internal_wave_dynamics.jl. that test verifies that a wave packet in our code propagates at the correct group speed, for example. But one could div",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2935#issuecomment-1444451423
Energy Efficiency,reduce,reduce,"@glwagner Thanks for the detailed analyses and good points about the noise being grid-scale. That may indeed reduce the necessary time step for stability to unphysical values. Also, just to be clear, I'm not saying that I think there's a bug in the code. I'm just saying that I, personally, wouldn't rule it out yet. I guess part of my reasoning is due to the fact that I arrived at this MWE because of unphysical oscillations like these emerging due to physical (and as far as I can tell well-resolved) instabilities in my simulations. In these simulations the instabilities propagated into the stably-stratified, quasi-quiescent regions of the flow, and amplified similarly to the ones that the MWE above reproduces. Of course the fact that these behaviors look alike to the naked eye doesn't prove they are indeed the same phenomenon and, like @glwagner suggested, the fact that we're starting with grid-scale noise here possibly matters. If that's okay I'll try to investigate this a little more with grid-resolved noise before we move/close the issue. If the behavior goes away when everything is well-resolved, then I'm happy to close the issue.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2935#issuecomment-1445221865
Usability,clear,clear,"@glwagner Thanks for the detailed analyses and good points about the noise being grid-scale. That may indeed reduce the necessary time step for stability to unphysical values. Also, just to be clear, I'm not saying that I think there's a bug in the code. I'm just saying that I, personally, wouldn't rule it out yet. I guess part of my reasoning is due to the fact that I arrived at this MWE because of unphysical oscillations like these emerging due to physical (and as far as I can tell well-resolved) instabilities in my simulations. In these simulations the instabilities propagated into the stably-stratified, quasi-quiescent regions of the flow, and amplified similarly to the ones that the MWE above reproduces. Of course the fact that these behaviors look alike to the naked eye doesn't prove they are indeed the same phenomenon and, like @glwagner suggested, the fact that we're starting with grid-scale noise here possibly matters. If that's okay I'll try to investigate this a little more with grid-resolved noise before we move/close the issue. If the behavior goes away when everything is well-resolved, then I'm happy to close the issue.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2935#issuecomment-1445221865
Integrability,depend,depending,"Okay so indeed I think this issue only happens due to poor resolution of the initial noise. I cooked up a MWE where I fixed the random seed, then used that to sprinkle 256 Gaussians (that are also horizontally periodic) throughout the domain. I did this because I wanted to have the ""same noise"", but change it from being under-resolved to well-resolved. I ran this for a few cases ranging from poorly resolved (1 to 2 grid-points per gaussian) to well-resolved (about 8 grid-points per gaussian). I'm plotting three of the animations I got in order or increasing resolution (2, 4, and 8 grid-points per gaussian):. https://user-images.githubusercontent.com/13205162/224089407-ee82f95f-1c71-4857-b69b-745ae20749f6.mp4. https://user-images.githubusercontent.com/13205162/224089438-a49d7c94-391c-4f5d-b4ac-fb658ea672c3.mp4. https://user-images.githubusercontent.com/13205162/224089523-5e485a2b-b7b4-4eb6-b793-e1123345eebc.mp4. We can clearly see that the odd behavior decreases and then finally goes away as we start resolving the initial fluctuations more and more. Some things caught my eye here though. Firstly, this is an example of the long-time solution depending on the initial conditions, which is really odd to me. Although I guess I shouldn't be so surprised, since this isn't physical turbulence, it's something else (and it's poorly resolved), but still I think it's interesting. Also as the time progresses, even in the most resolved simulation, some grid-scale noise starts to emerge (which probably has to do with the advection scheme?). However, this grid-scale noise, contrary to the _initial_ grid-scale noise, doesn't cause any trouble. I wonder why... In any case, @glwagner please feel free to convert this issue to a discussion and thanks for the help!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2935#issuecomment-1462387712
Usability,clear,clearly,"Okay so indeed I think this issue only happens due to poor resolution of the initial noise. I cooked up a MWE where I fixed the random seed, then used that to sprinkle 256 Gaussians (that are also horizontally periodic) throughout the domain. I did this because I wanted to have the ""same noise"", but change it from being under-resolved to well-resolved. I ran this for a few cases ranging from poorly resolved (1 to 2 grid-points per gaussian) to well-resolved (about 8 grid-points per gaussian). I'm plotting three of the animations I got in order or increasing resolution (2, 4, and 8 grid-points per gaussian):. https://user-images.githubusercontent.com/13205162/224089407-ee82f95f-1c71-4857-b69b-745ae20749f6.mp4. https://user-images.githubusercontent.com/13205162/224089438-a49d7c94-391c-4f5d-b4ac-fb658ea672c3.mp4. https://user-images.githubusercontent.com/13205162/224089523-5e485a2b-b7b4-4eb6-b793-e1123345eebc.mp4. We can clearly see that the odd behavior decreases and then finally goes away as we start resolving the initial fluctuations more and more. Some things caught my eye here though. Firstly, this is an example of the long-time solution depending on the initial conditions, which is really odd to me. Although I guess I shouldn't be so surprised, since this isn't physical turbulence, it's something else (and it's poorly resolved), but still I think it's interesting. Also as the time progresses, even in the most resolved simulation, some grid-scale noise starts to emerge (which probably has to do with the advection scheme?). However, this grid-scale noise, contrary to the _initial_ grid-scale noise, doesn't cause any trouble. I wonder why... In any case, @glwagner please feel free to convert this issue to a discussion and thanks for the help!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2935#issuecomment-1462387712
Usability,simpl,simple,"> I don't really get why returning 0 is useful though. You say ""for writing general code from the user perspective"" but I don't quite understand that. What I mean is that it's makes it easier for a user to write something like:. ```julia; u_sgs_flux(model) = - viscosity(model.closure, model.diffusivity_fields) * ∂z(model.velocities.u); ```. and have it (correctly) return 0 when `closure=nothing`. I've been writing utilities of this kind for the past couple of months for a project which has simulations both without and without closure, and I've been using if-else statements to deal with that. It's not the worst thing, but having these extra two lines in Oceananigans would help me (and possibly other users) have cleaner code in these instances. Although admittedly I don't expect a big chunk of users to need that. The main reasons for me to propose this is that the behavior of `viscosity()` and `diffusivity()` will now be more consistent (i.e. they would work for all (?) closures we have so far), and it's only a simple two-line addition.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2951#issuecomment-1450657876
Modifiability,extend,extend,"> > I don't really get why returning 0 is useful though. You say ""for writing general code from the user perspective"" but I don't quite understand that.; > ; > What I mean is that it's makes it easier for a user to write something like:; > ; > ```julia; > u_sgs_flux(model) = - viscosity(model.closure, model.diffusivity_fields) * ∂z(model.velocities.u); > ```; > ; > and have it (correctly) return 0 when `closure=nothing`.; > ; > I've been writing utilities of this kind for the past couple of months for a project which has simulations both without and without closure, and I've been using if-else statements to deal with that. It's not the worst thing, but having these extra two lines in Oceananigans would help me (and possibly other users) have cleaner code in these instances.; > ; > Although admittedly I don't expect a big chunk of users to need that. The main reasons for me to propose this is that the behavior of `viscosity()` and `diffusivity()` will now be more consistent (i.e. they would work for all (?) closures we have so far), and it's only a simple two-line addition. In the future instead of using an if-statement, you can extend `viscosity` and `diffusivity` in your own code (temporarily, until a PR like this one is merged)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2951#issuecomment-1454777192
Usability,simpl,simple,"> > I don't really get why returning 0 is useful though. You say ""for writing general code from the user perspective"" but I don't quite understand that.; > ; > What I mean is that it's makes it easier for a user to write something like:; > ; > ```julia; > u_sgs_flux(model) = - viscosity(model.closure, model.diffusivity_fields) * ∂z(model.velocities.u); > ```; > ; > and have it (correctly) return 0 when `closure=nothing`.; > ; > I've been writing utilities of this kind for the past couple of months for a project which has simulations both without and without closure, and I've been using if-else statements to deal with that. It's not the worst thing, but having these extra two lines in Oceananigans would help me (and possibly other users) have cleaner code in these instances.; > ; > Although admittedly I don't expect a big chunk of users to need that. The main reasons for me to propose this is that the behavior of `viscosity()` and `diffusivity()` will now be more consistent (i.e. they would work for all (?) closures we have so far), and it's only a simple two-line addition. In the future instead of using an if-statement, you can extend `viscosity` and `diffusivity` in your own code (temporarily, until a PR like this one is merged)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2951#issuecomment-1454777192
Modifiability,evolve,evolve,"> > I suggest we remove the parameter for `gravitational_acceleration`.; > > @francispoulin any objection to that?; > ; > Please don't remove the parameter. It appears in the model equations and we need it to evolve the momentum equations. I only meant removing the explicit type declaration of the parameter. Sorry, should have been clearer. :); But we decided not to. Thanks!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2955#issuecomment-1453564182
Usability,clear,clearer,"> > I suggest we remove the parameter for `gravitational_acceleration`.; > > @francispoulin any objection to that?; > ; > Please don't remove the parameter. It appears in the model equations and we need it to evolve the momentum equations. I only meant removing the explicit type declaration of the parameter. Sorry, should have been clearer. :); But we decided not to. Thanks!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2955#issuecomment-1453564182
Deployability,deploy,deploy,"The difficulty is that there's no end to useful tricks one might be able to deploy if they get a little more proficient with Julia. I'm learning new things all the time too. I'd rather put this kind of stuff in the wiki rather than putting stuff in the docs that's not really Oceananigans-specific (these things fall more in to the category ""general Julia knowledge applicable to Oceananigans""). In fact I thought we were moving towards that but it does seem like there's still some overlap between that simulation tips section and the wiki now.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2960#issuecomment-1458718824
Usability,learn,learning,"The difficulty is that there's no end to useful tricks one might be able to deploy if they get a little more proficient with Julia. I'm learning new things all the time too. I'd rather put this kind of stuff in the wiki rather than putting stuff in the docs that's not really Oceananigans-specific (these things fall more in to the category ""general Julia knowledge applicable to Oceananigans""). In fact I thought we were moving towards that but it does seem like there's still some overlap between that simulation tips section and the wiki now.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2960#issuecomment-1458718824
Availability,error,errors,"How do we deal with errors of this kind in the doctests?:. ```;   | │;   | │ diff =;   | │ ┌ Warning: The behavior of `gravity_unit_vector` changed in version 0.80.0.;   | │ │ Prior to this version, `gravity_unit_vector` indicated the direction _opposite_ to gravity.;   | │ │ After version 0.80.0, `gravity_unit_vector` indicates the direction of the gravitional acceleration;   | │ └ @ Oceananigans.BuoyancyModels ~/repos/Oceananigans.jl/src/BuoyancyModels/buoyancy.jl:44;   | │ ~/builds/tartarus-13/clima/oceananigans/src/BuoyancyModels/buoyancy.jl:48; ...; ```. i.e. when the warning message is the same but it's thrown in a different machine to the path to the warning-generation line is different. I remember there was a relatively simple way to deal with this, but I can't find it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2963#issuecomment-1460567603
Integrability,message,message,"How do we deal with errors of this kind in the doctests?:. ```;   | │;   | │ diff =;   | │ ┌ Warning: The behavior of `gravity_unit_vector` changed in version 0.80.0.;   | │ │ Prior to this version, `gravity_unit_vector` indicated the direction _opposite_ to gravity.;   | │ │ After version 0.80.0, `gravity_unit_vector` indicates the direction of the gravitional acceleration;   | │ └ @ Oceananigans.BuoyancyModels ~/repos/Oceananigans.jl/src/BuoyancyModels/buoyancy.jl:44;   | │ ~/builds/tartarus-13/clima/oceananigans/src/BuoyancyModels/buoyancy.jl:48; ...; ```. i.e. when the warning message is the same but it's thrown in a different machine to the path to the warning-generation line is different. I remember there was a relatively simple way to deal with this, but I can't find it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2963#issuecomment-1460567603
Usability,simpl,simple,"How do we deal with errors of this kind in the doctests?:. ```;   | │;   | │ diff =;   | │ ┌ Warning: The behavior of `gravity_unit_vector` changed in version 0.80.0.;   | │ │ Prior to this version, `gravity_unit_vector` indicated the direction _opposite_ to gravity.;   | │ │ After version 0.80.0, `gravity_unit_vector` indicates the direction of the gravitional acceleration;   | │ └ @ Oceananigans.BuoyancyModels ~/repos/Oceananigans.jl/src/BuoyancyModels/buoyancy.jl:44;   | │ ~/builds/tartarus-13/clima/oceananigans/src/BuoyancyModels/buoyancy.jl:48; ...; ```. i.e. when the warning message is the same but it's thrown in a different machine to the path to the warning-generation line is different. I remember there was a relatively simple way to deal with this, but I can't find it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2963#issuecomment-1460567603
Availability,error,errors,"> How do we deal with errors of this kind in the doctests?:; > ; > ```; >   | │; >   | │ diff =; >   | │ ┌ Warning: The behavior of `gravity_unit_vector` changed in version 0.80.0.; >   | │ │ Prior to this version, `gravity_unit_vector` indicated the direction _opposite_ to gravity.; >   | │ │ After version 0.80.0, `gravity_unit_vector` indicates the direction of the gravitional acceleration; >   | │ └ @ Oceananigans.BuoyancyModels ~/repos/Oceananigans.jl/src/BuoyancyModels/buoyancy.jl:44; >   | │ ~/builds/tartarus-13/clima/oceananigans/src/BuoyancyModels/buoyancy.jl:48; > ...; > ```; > ; > i.e. when the warning message is the same but it's thrown in a different machine to the path to the warning-generation line is different.; > ; > I remember there was a relatively simple way to deal with this, but I can't find it. Damn... I remember the issue... Something with filter doctests. I can try to sort it out. Ignore it for now :)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2963#issuecomment-1460574200
Integrability,message,message,"> How do we deal with errors of this kind in the doctests?:; > ; > ```; >   | │; >   | │ diff =; >   | │ ┌ Warning: The behavior of `gravity_unit_vector` changed in version 0.80.0.; >   | │ │ Prior to this version, `gravity_unit_vector` indicated the direction _opposite_ to gravity.; >   | │ │ After version 0.80.0, `gravity_unit_vector` indicates the direction of the gravitional acceleration; >   | │ └ @ Oceananigans.BuoyancyModels ~/repos/Oceananigans.jl/src/BuoyancyModels/buoyancy.jl:44; >   | │ ~/builds/tartarus-13/clima/oceananigans/src/BuoyancyModels/buoyancy.jl:48; > ...; > ```; > ; > i.e. when the warning message is the same but it's thrown in a different machine to the path to the warning-generation line is different.; > ; > I remember there was a relatively simple way to deal with this, but I can't find it. Damn... I remember the issue... Something with filter doctests. I can try to sort it out. Ignore it for now :)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2963#issuecomment-1460574200
Usability,simpl,simple,"> How do we deal with errors of this kind in the doctests?:; > ; > ```; >   | │; >   | │ diff =; >   | │ ┌ Warning: The behavior of `gravity_unit_vector` changed in version 0.80.0.; >   | │ │ Prior to this version, `gravity_unit_vector` indicated the direction _opposite_ to gravity.; >   | │ │ After version 0.80.0, `gravity_unit_vector` indicates the direction of the gravitional acceleration; >   | │ └ @ Oceananigans.BuoyancyModels ~/repos/Oceananigans.jl/src/BuoyancyModels/buoyancy.jl:44; >   | │ ~/builds/tartarus-13/clima/oceananigans/src/BuoyancyModels/buoyancy.jl:48; > ...; > ```; > ; > i.e. when the warning message is the same but it's thrown in a different machine to the path to the warning-generation line is different.; > ; > I remember there was a relatively simple way to deal with this, but I can't find it. Damn... I remember the issue... Something with filter doctests. I can try to sort it out. Ignore it for now :)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2963#issuecomment-1460574200
Deployability,update,updated," get this feature is to refactor the output writers to have a more generic interface for splitting. If we have a property called `file_splitting` that _is_ a schedule, then we can write. ```julia; NetCDFOutputWriter(model, outputs; file_splitting = TimeInterval(30days), ...); ```. Then the decision about whether to start a new file will change from. https://github.com/CliMA/Oceananigans.jl/blob/9f3f8e6d1469e570b0778f328ab864e879785ffd/src/OutputWriters/jld2_output_writer.jl#L275. to. ```julia; writer.file_splitting(model) && start_next_file(model, writer) ; ```. Next, you will have to add a new schedule in `Utils/schedules.jl` that can split based on filesize:. ```julia; mutable struct FileSizeLargerThan <: AbstractSchedule; max_filesize :: Float64; path :: String; end. (fslt::FileSizeLargerThan)(model) = filesize(fslt.path) >= fslt.max_filesize; ```. Finally, you need to add a user interface for initializing and modifying the schedules to smooth out the user experience (for example, we don't want users to have to specify the file path more than once, and the file path that is checked by the schedule has to be updated). This will have to take two parts. In `Utils/schedules.jl`, a constructor:. ```julia; FileSizeLargerThan(max_filesize) = FileSizeLargerThan(max_filesize, """"); ```. Then in output writers, an interface to be used in both the model constructor and `write_output!`:. ```julia; update_schedule!(schedule, path) = nothing; update_schedule!(schedule::FileSizeLargerThan, path) = schedule.path = path; ```. This function `update_schedule!(writer.schedule, path)` then replaces this line. https://github.com/CliMA/Oceananigans.jl/blob/9f3f8e6d1469e570b0778f328ab864e879785ffd/src/OutputWriters/jld2_output_writer.jl#L276. and also needs to be added in the output writer constructor so that. https://github.com/CliMA/Oceananigans.jl/blob/9f3f8e6d1469e570b0778f328ab864e879785ffd/src/OutputWriters/jld2_output_writer.jl#L176. becomes. ```julia; filepath = joinpath(dir, fil",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2967#issuecomment-2000029793
Energy Efficiency,schedul,schedule,"A ""schedule"" is a function or callable object with a method. ```julia; schedule(model); ```. that returns true or false based on a criterion. `true` means ""do something"". The cleanest way to get this feature is to refactor the output writers to have a more generic interface for splitting. If we have a property called `file_splitting` that _is_ a schedule, then we can write. ```julia; NetCDFOutputWriter(model, outputs; file_splitting = TimeInterval(30days), ...); ```. Then the decision about whether to start a new file will change from. https://github.com/CliMA/Oceananigans.jl/blob/9f3f8e6d1469e570b0778f328ab864e879785ffd/src/OutputWriters/jld2_output_writer.jl#L275. to. ```julia; writer.file_splitting(model) && start_next_file(model, writer) ; ```. Next, you will have to add a new schedule in `Utils/schedules.jl` that can split based on filesize:. ```julia; mutable struct FileSizeLargerThan <: AbstractSchedule; max_filesize :: Float64; path :: String; end. (fslt::FileSizeLargerThan)(model) = filesize(fslt.path) >= fslt.max_filesize; ```. Finally, you need to add a user interface for initializing and modifying the schedules to smooth out the user experience (for example, we don't want users to have to specify the file path more than once, and the file path that is checked by the schedule has to be updated). This will have to take two parts. In `Utils/schedules.jl`, a constructor:. ```julia; FileSizeLargerThan(max_filesize) = FileSizeLargerThan(max_filesize, """"); ```. Then in output writers, an interface to be used in both the model constructor and `write_output!`:. ```julia; update_schedule!(schedule, path) = nothing; update_schedule!(schedule::FileSizeLargerThan, path) = schedule.path = path; ```. This function `update_schedule!(writer.schedule, path)` then replaces this line. https://github.com/CliMA/Oceananigans.jl/blob/9f3f8e6d1469e570b0778f328ab864e879785ffd/src/OutputWriters/jld2_output_writer.jl#L276. and also needs to be added in the output writer constructor ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2967#issuecomment-2000029793
Integrability,interface,interface,"A ""schedule"" is a function or callable object with a method. ```julia; schedule(model); ```. that returns true or false based on a criterion. `true` means ""do something"". The cleanest way to get this feature is to refactor the output writers to have a more generic interface for splitting. If we have a property called `file_splitting` that _is_ a schedule, then we can write. ```julia; NetCDFOutputWriter(model, outputs; file_splitting = TimeInterval(30days), ...); ```. Then the decision about whether to start a new file will change from. https://github.com/CliMA/Oceananigans.jl/blob/9f3f8e6d1469e570b0778f328ab864e879785ffd/src/OutputWriters/jld2_output_writer.jl#L275. to. ```julia; writer.file_splitting(model) && start_next_file(model, writer) ; ```. Next, you will have to add a new schedule in `Utils/schedules.jl` that can split based on filesize:. ```julia; mutable struct FileSizeLargerThan <: AbstractSchedule; max_filesize :: Float64; path :: String; end. (fslt::FileSizeLargerThan)(model) = filesize(fslt.path) >= fslt.max_filesize; ```. Finally, you need to add a user interface for initializing and modifying the schedules to smooth out the user experience (for example, we don't want users to have to specify the file path more than once, and the file path that is checked by the schedule has to be updated). This will have to take two parts. In `Utils/schedules.jl`, a constructor:. ```julia; FileSizeLargerThan(max_filesize) = FileSizeLargerThan(max_filesize, """"); ```. Then in output writers, an interface to be used in both the model constructor and `write_output!`:. ```julia; update_schedule!(schedule, path) = nothing; update_schedule!(schedule::FileSizeLargerThan, path) = schedule.path = path; ```. This function `update_schedule!(writer.schedule, path)` then replaces this line. https://github.com/CliMA/Oceananigans.jl/blob/9f3f8e6d1469e570b0778f328ab864e879785ffd/src/OutputWriters/jld2_output_writer.jl#L276. and also needs to be added in the output writer constructor ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2967#issuecomment-2000029793
Modifiability,refactor,refactor,"A ""schedule"" is a function or callable object with a method. ```julia; schedule(model); ```. that returns true or false based on a criterion. `true` means ""do something"". The cleanest way to get this feature is to refactor the output writers to have a more generic interface for splitting. If we have a property called `file_splitting` that _is_ a schedule, then we can write. ```julia; NetCDFOutputWriter(model, outputs; file_splitting = TimeInterval(30days), ...); ```. Then the decision about whether to start a new file will change from. https://github.com/CliMA/Oceananigans.jl/blob/9f3f8e6d1469e570b0778f328ab864e879785ffd/src/OutputWriters/jld2_output_writer.jl#L275. to. ```julia; writer.file_splitting(model) && start_next_file(model, writer) ; ```. Next, you will have to add a new schedule in `Utils/schedules.jl` that can split based on filesize:. ```julia; mutable struct FileSizeLargerThan <: AbstractSchedule; max_filesize :: Float64; path :: String; end. (fslt::FileSizeLargerThan)(model) = filesize(fslt.path) >= fslt.max_filesize; ```. Finally, you need to add a user interface for initializing and modifying the schedules to smooth out the user experience (for example, we don't want users to have to specify the file path more than once, and the file path that is checked by the schedule has to be updated). This will have to take two parts. In `Utils/schedules.jl`, a constructor:. ```julia; FileSizeLargerThan(max_filesize) = FileSizeLargerThan(max_filesize, """"); ```. Then in output writers, an interface to be used in both the model constructor and `write_output!`:. ```julia; update_schedule!(schedule, path) = nothing; update_schedule!(schedule::FileSizeLargerThan, path) = schedule.path = path; ```. This function `update_schedule!(writer.schedule, path)` then replaces this line. https://github.com/CliMA/Oceananigans.jl/blob/9f3f8e6d1469e570b0778f328ab864e879785ffd/src/OutputWriters/jld2_output_writer.jl#L276. and also needs to be added in the output writer constructor ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2967#issuecomment-2000029793
Usability,user experience,user experience," get this feature is to refactor the output writers to have a more generic interface for splitting. If we have a property called `file_splitting` that _is_ a schedule, then we can write. ```julia; NetCDFOutputWriter(model, outputs; file_splitting = TimeInterval(30days), ...); ```. Then the decision about whether to start a new file will change from. https://github.com/CliMA/Oceananigans.jl/blob/9f3f8e6d1469e570b0778f328ab864e879785ffd/src/OutputWriters/jld2_output_writer.jl#L275. to. ```julia; writer.file_splitting(model) && start_next_file(model, writer) ; ```. Next, you will have to add a new schedule in `Utils/schedules.jl` that can split based on filesize:. ```julia; mutable struct FileSizeLargerThan <: AbstractSchedule; max_filesize :: Float64; path :: String; end. (fslt::FileSizeLargerThan)(model) = filesize(fslt.path) >= fslt.max_filesize; ```. Finally, you need to add a user interface for initializing and modifying the schedules to smooth out the user experience (for example, we don't want users to have to specify the file path more than once, and the file path that is checked by the schedule has to be updated). This will have to take two parts. In `Utils/schedules.jl`, a constructor:. ```julia; FileSizeLargerThan(max_filesize) = FileSizeLargerThan(max_filesize, """"); ```. Then in output writers, an interface to be used in both the model constructor and `write_output!`:. ```julia; update_schedule!(schedule, path) = nothing; update_schedule!(schedule::FileSizeLargerThan, path) = schedule.path = path; ```. This function `update_schedule!(writer.schedule, path)` then replaces this line. https://github.com/CliMA/Oceananigans.jl/blob/9f3f8e6d1469e570b0778f328ab864e879785ffd/src/OutputWriters/jld2_output_writer.jl#L276. and also needs to be added in the output writer constructor so that. https://github.com/CliMA/Oceananigans.jl/blob/9f3f8e6d1469e570b0778f328ab864e879785ffd/src/OutputWriters/jld2_output_writer.jl#L176. becomes. ```julia; filepath = joinpath(dir, fil",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2967#issuecomment-2000029793
Energy Efficiency,reduce,reduces,"It's just a suggestion... Perhaps it's not needed. But having it as a parameter of the type could be useful, even if the parameter is the same value as `grid.Nz` because if it's part of type you can write methods that do different things based on the number of layers your model has. E.g.,. ```Julia; function compute_this_and_that(model::ShallowWaterModel{1}); a = 1 # simple calculation for single-layer models; return a; end. function compute_this_and_that(model::ShallowWaterModel); number_of_layers = model.number_of_layers; a = sum(rand(number_of_layers)) # more complicated stuff only needed for multi-layer models; return a; end; ```. This way we don't use `if number_of_layers > 1; do this; else; do that` which reduces performance because the compiler has to compile all cases and check every time the value of layers and do this or the other....",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2975#issuecomment-1469188127
Modifiability,layers,layers,"It's just a suggestion... Perhaps it's not needed. But having it as a parameter of the type could be useful, even if the parameter is the same value as `grid.Nz` because if it's part of type you can write methods that do different things based on the number of layers your model has. E.g.,. ```Julia; function compute_this_and_that(model::ShallowWaterModel{1}); a = 1 # simple calculation for single-layer models; return a; end. function compute_this_and_that(model::ShallowWaterModel); number_of_layers = model.number_of_layers; a = sum(rand(number_of_layers)) # more complicated stuff only needed for multi-layer models; return a; end; ```. This way we don't use `if number_of_layers > 1; do this; else; do that` which reduces performance because the compiler has to compile all cases and check every time the value of layers and do this or the other....",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2975#issuecomment-1469188127
Performance,perform,performance,"It's just a suggestion... Perhaps it's not needed. But having it as a parameter of the type could be useful, even if the parameter is the same value as `grid.Nz` because if it's part of type you can write methods that do different things based on the number of layers your model has. E.g.,. ```Julia; function compute_this_and_that(model::ShallowWaterModel{1}); a = 1 # simple calculation for single-layer models; return a; end. function compute_this_and_that(model::ShallowWaterModel); number_of_layers = model.number_of_layers; a = sum(rand(number_of_layers)) # more complicated stuff only needed for multi-layer models; return a; end; ```. This way we don't use `if number_of_layers > 1; do this; else; do that` which reduces performance because the compiler has to compile all cases and check every time the value of layers and do this or the other....",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2975#issuecomment-1469188127
Usability,simpl,simple,"It's just a suggestion... Perhaps it's not needed. But having it as a parameter of the type could be useful, even if the parameter is the same value as `grid.Nz` because if it's part of type you can write methods that do different things based on the number of layers your model has. E.g.,. ```Julia; function compute_this_and_that(model::ShallowWaterModel{1}); a = 1 # simple calculation for single-layer models; return a; end. function compute_this_and_that(model::ShallowWaterModel); number_of_layers = model.number_of_layers; a = sum(rand(number_of_layers)) # more complicated stuff only needed for multi-layer models; return a; end; ```. This way we don't use `if number_of_layers > 1; do this; else; do that` which reduces performance because the compiler has to compile all cases and check every time the value of layers and do this or the other....",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2975#issuecomment-1469188127
Usability,resume,resume,@dhruvbhagtani I'm closing this as it seems stale you (or anyone!) should feel free to re-open and resume whenever.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2975#issuecomment-1791223957
Usability,resume,resume,"OK, now we should resume working on this ;)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2979#issuecomment-1482207594
Energy Efficiency,adapt,adapt,"Something a little puzzling to me is that we clearly succeed at type inference when running on the GPU. Do we have a better chance of succeeding there because of `adapt`? We do make some critical simplifications via `adapt`, most notably. https://github.com/CliMA/Oceananigans.jl/blob/f70d0949f7688df89a7f8a9e7d44177cde27091a/src/Fields/field.jl#L400",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2996#issuecomment-1480467620
Modifiability,adapt,adapt,"Something a little puzzling to me is that we clearly succeed at type inference when running on the GPU. Do we have a better chance of succeeding there because of `adapt`? We do make some critical simplifications via `adapt`, most notably. https://github.com/CliMA/Oceananigans.jl/blob/f70d0949f7688df89a7f8a9e7d44177cde27091a/src/Fields/field.jl#L400",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2996#issuecomment-1480467620
Usability,clear,clearly,"Something a little puzzling to me is that we clearly succeed at type inference when running on the GPU. Do we have a better chance of succeeding there because of `adapt`? We do make some critical simplifications via `adapt`, most notably. https://github.com/CliMA/Oceananigans.jl/blob/f70d0949f7688df89a7f8a9e7d44177cde27091a/src/Fields/field.jl#L400",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2996#issuecomment-1480467620
Testability,benchmark,benchmarks,I haven't done any profiling --- just simple benchmarks. (Short example coming soon),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2996#issuecomment-1481266449
Usability,simpl,simple,I haven't done any profiling --- just simple benchmarks. (Short example coming soon),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2996#issuecomment-1481266449
Performance,perform,performance,"Ok here's something simple:. ```julia; using Oceananigans; using BenchmarkTools. grid = RectilinearGrid(CPU(), size=(128, 128, 1), x=(0, 2π), y=(0, 2π), z=(0, 1)); model = NonhydrostaticModel(; grid, advection=WENO()). function lots_of_steps!(model, Δt, steps=100); for _ = 1:steps; time_step!(model, Δt); end; end. @btime lots_of_steps!(model, 0.01); ```. Here's what I've done:. * Run this on fresh clone of `main`. This returns. ```julia; julia> include(""../simple_benchmark.jl""); [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; 20.460 s (144483404 allocations: 94.43 GiB); ```. * Restrict compat on KernelAbstractions to 0.7.2 and CUDAKernels to 0.3.3. This returns:. ```julia; julia> include(""../simple_benchmark.jl""); [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; 2.202 s (118604 allocations: 52.20 MiB); ```. I'm running on a single core, Mac M1. Here the performance loss is just 10x so I'll change the somewhat dramatic title of this issue.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2996#issuecomment-1481304842
Usability,simpl,simple,"Ok here's something simple:. ```julia; using Oceananigans; using BenchmarkTools. grid = RectilinearGrid(CPU(), size=(128, 128, 1), x=(0, 2π), y=(0, 2π), z=(0, 1)); model = NonhydrostaticModel(; grid, advection=WENO()). function lots_of_steps!(model, Δt, steps=100); for _ = 1:steps; time_step!(model, Δt); end; end. @btime lots_of_steps!(model, 0.01); ```. Here's what I've done:. * Run this on fresh clone of `main`. This returns. ```julia; julia> include(""../simple_benchmark.jl""); [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; 20.460 s (144483404 allocations: 94.43 GiB); ```. * Restrict compat on KernelAbstractions to 0.7.2 and CUDAKernels to 0.3.3. This returns:. ```julia; julia> include(""../simple_benchmark.jl""); [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; 2.202 s (118604 allocations: 52.20 MiB); ```. I'm running on a single core, Mac M1. Here the performance loss is just 10x so I'll change the somewhat dramatic title of this issue.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2996#issuecomment-1481304842
Availability,down,down,"With `advection = CenteredSecondOrder()`, the differences are more dramatic (maybe explains the 100x slow down I saw with a simple setup):. ```julia; 17.859 s (144483404 allocations: 94.43 GiB) # KA 0.8; 294.401 ms (118604 allocations: 52.20 MiB) # KA 0.7; ```. If we look just at `calculate_tendencies!` via. ```julia; using Oceananigans; using Oceananigans.TimeSteppers: calculate_tendencies!; using BenchmarkTools. grid = RectilinearGrid(CPU(), size=(128, 128, 1), x=(0, 2π), y=(0, 2π), z=(0, 1)); model = NonhydrostaticModel(; grid, advection=WENO()). function lots_of_steps!(model, Δt, steps=100); for _ = 1:steps; #time_step!(model, Δt); calculate_tendencies!(model, []); end; end. @btime lots_of_steps!(model, 0.01); ```. results are (`advection = WENO()`). ```julia; 5.268 s (23061000 allocations: 11.73 GiB) # KA 0.8; 1.989 s (14600 allocations: 13.03 MiB) # KA 0.7; ```. and `advection = CenteredSecondOrder()`. ```julia; 2.846 s (23061000 allocations: 11.73 GiB) # KA 0.8; 105.867 ms (14600 allocations: 13.03 MiB) # KA 0.7; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2996#issuecomment-1481310062
Usability,simpl,simple,"With `advection = CenteredSecondOrder()`, the differences are more dramatic (maybe explains the 100x slow down I saw with a simple setup):. ```julia; 17.859 s (144483404 allocations: 94.43 GiB) # KA 0.8; 294.401 ms (118604 allocations: 52.20 MiB) # KA 0.7; ```. If we look just at `calculate_tendencies!` via. ```julia; using Oceananigans; using Oceananigans.TimeSteppers: calculate_tendencies!; using BenchmarkTools. grid = RectilinearGrid(CPU(), size=(128, 128, 1), x=(0, 2π), y=(0, 2π), z=(0, 1)); model = NonhydrostaticModel(; grid, advection=WENO()). function lots_of_steps!(model, Δt, steps=100); for _ = 1:steps; #time_step!(model, Δt); calculate_tendencies!(model, []); end; end. @btime lots_of_steps!(model, 0.01); ```. results are (`advection = WENO()`). ```julia; 5.268 s (23061000 allocations: 11.73 GiB) # KA 0.8; 1.989 s (14600 allocations: 13.03 MiB) # KA 0.7; ```. and `advection = CenteredSecondOrder()`. ```julia; 2.846 s (23061000 allocations: 11.73 GiB) # KA 0.8; 105.867 ms (14600 allocations: 13.03 MiB) # KA 0.7; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2996#issuecomment-1481310062
Availability,down,downgraded,"Re-posting from #3026... that PR solved performance problems with `NonhydrostaticModel`, but `HydrostaticFreeSurfaceModel` is still 2x slower roughly than when using KA 0.7.2. Here's a simple benchmark:. ```julia; using Oceananigans; using BenchmarkTools. grid = RectilinearGrid(CPU(), size=(128, 128, 1), x=(0, 2π), y=(0, 2π), z=(0, 1), topology=(Periodic, Periodic, Bounded)); model = HydrostaticFreeSurfaceModel(; grid, momentum_advection=WENO(), tracer_advection=WENO()); ϵ(x, y, z) = 2rand() - 1; set!(model, u=ϵ, v=ϵ). function lots_of_steps!(model, Δt, steps=100); for _ = 1:steps; time_step!(model, Δt); end; end. @btime lots_of_steps!(model, 0.01); ```. Results. ```; 10.220 s (85845109 allocations: 37.94 GiB) # main; 6.284 s (66184308 allocations: 16.31 GiB) # main with KA downgraded to 0.7.2; ```. cc @simone-silvestri",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2996#issuecomment-1482198037
Performance,perform,performance,"Re-posting from #3026... that PR solved performance problems with `NonhydrostaticModel`, but `HydrostaticFreeSurfaceModel` is still 2x slower roughly than when using KA 0.7.2. Here's a simple benchmark:. ```julia; using Oceananigans; using BenchmarkTools. grid = RectilinearGrid(CPU(), size=(128, 128, 1), x=(0, 2π), y=(0, 2π), z=(0, 1), topology=(Periodic, Periodic, Bounded)); model = HydrostaticFreeSurfaceModel(; grid, momentum_advection=WENO(), tracer_advection=WENO()); ϵ(x, y, z) = 2rand() - 1; set!(model, u=ϵ, v=ϵ). function lots_of_steps!(model, Δt, steps=100); for _ = 1:steps; time_step!(model, Δt); end; end. @btime lots_of_steps!(model, 0.01); ```. Results. ```; 10.220 s (85845109 allocations: 37.94 GiB) # main; 6.284 s (66184308 allocations: 16.31 GiB) # main with KA downgraded to 0.7.2; ```. cc @simone-silvestri",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2996#issuecomment-1482198037
Testability,benchmark,benchmark,"Re-posting from #3026... that PR solved performance problems with `NonhydrostaticModel`, but `HydrostaticFreeSurfaceModel` is still 2x slower roughly than when using KA 0.7.2. Here's a simple benchmark:. ```julia; using Oceananigans; using BenchmarkTools. grid = RectilinearGrid(CPU(), size=(128, 128, 1), x=(0, 2π), y=(0, 2π), z=(0, 1), topology=(Periodic, Periodic, Bounded)); model = HydrostaticFreeSurfaceModel(; grid, momentum_advection=WENO(), tracer_advection=WENO()); ϵ(x, y, z) = 2rand() - 1; set!(model, u=ϵ, v=ϵ). function lots_of_steps!(model, Δt, steps=100); for _ = 1:steps; time_step!(model, Δt); end; end. @btime lots_of_steps!(model, 0.01); ```. Results. ```; 10.220 s (85845109 allocations: 37.94 GiB) # main; 6.284 s (66184308 allocations: 16.31 GiB) # main with KA downgraded to 0.7.2; ```. cc @simone-silvestri",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2996#issuecomment-1482198037
Usability,simpl,simple,"Re-posting from #3026... that PR solved performance problems with `NonhydrostaticModel`, but `HydrostaticFreeSurfaceModel` is still 2x slower roughly than when using KA 0.7.2. Here's a simple benchmark:. ```julia; using Oceananigans; using BenchmarkTools. grid = RectilinearGrid(CPU(), size=(128, 128, 1), x=(0, 2π), y=(0, 2π), z=(0, 1), topology=(Periodic, Periodic, Bounded)); model = HydrostaticFreeSurfaceModel(; grid, momentum_advection=WENO(), tracer_advection=WENO()); ϵ(x, y, z) = 2rand() - 1; set!(model, u=ϵ, v=ϵ). function lots_of_steps!(model, Δt, steps=100); for _ = 1:steps; time_step!(model, Δt); end; end. @btime lots_of_steps!(model, 0.01); ```. Results. ```; 10.220 s (85845109 allocations: 37.94 GiB) # main; 6.284 s (66184308 allocations: 16.31 GiB) # main with KA downgraded to 0.7.2; ```. cc @simone-silvestri",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2996#issuecomment-1482198037
Deployability,rolling,rolling,"> Since we need the performance provided by KA 0.7, and we need to use KA 0.8+ on GPU, does that mean that we should invest in developing our own CPU infrastructure (replicating what KA 0.7 offered) to achieve that performance?; > ; > Another possibility is that we re-write much of the code base to avoid the performance pitfalls we are currently facing in order to get back to the level of performance we have with current code + KA 0.7. I believe the issue is basically an interaction between some of the abstractions / indirection we have developed and the compiler, so possibly rolling back that abstraction / indirection will bring us back to where we were previously. To follow up with @vchuravy, it seems that rewriting just _some_ of the code was sufficient, so we are (probably) in the clear! The lesson learned is that we cannot slurp / splat `@kernel` function arguments, because it prevents the kernel code from being inlined.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2996#issuecomment-1482198741
Performance,perform,performance,"> Since we need the performance provided by KA 0.7, and we need to use KA 0.8+ on GPU, does that mean that we should invest in developing our own CPU infrastructure (replicating what KA 0.7 offered) to achieve that performance?; > ; > Another possibility is that we re-write much of the code base to avoid the performance pitfalls we are currently facing in order to get back to the level of performance we have with current code + KA 0.7. I believe the issue is basically an interaction between some of the abstractions / indirection we have developed and the compiler, so possibly rolling back that abstraction / indirection will bring us back to where we were previously. To follow up with @vchuravy, it seems that rewriting just _some_ of the code was sufficient, so we are (probably) in the clear! The lesson learned is that we cannot slurp / splat `@kernel` function arguments, because it prevents the kernel code from being inlined.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2996#issuecomment-1482198741
Safety,avoid,avoid,"> Since we need the performance provided by KA 0.7, and we need to use KA 0.8+ on GPU, does that mean that we should invest in developing our own CPU infrastructure (replicating what KA 0.7 offered) to achieve that performance?; > ; > Another possibility is that we re-write much of the code base to avoid the performance pitfalls we are currently facing in order to get back to the level of performance we have with current code + KA 0.7. I believe the issue is basically an interaction between some of the abstractions / indirection we have developed and the compiler, so possibly rolling back that abstraction / indirection will bring us back to where we were previously. To follow up with @vchuravy, it seems that rewriting just _some_ of the code was sufficient, so we are (probably) in the clear! The lesson learned is that we cannot slurp / splat `@kernel` function arguments, because it prevents the kernel code from being inlined.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2996#issuecomment-1482198741
Usability,clear,clear,"> Since we need the performance provided by KA 0.7, and we need to use KA 0.8+ on GPU, does that mean that we should invest in developing our own CPU infrastructure (replicating what KA 0.7 offered) to achieve that performance?; > ; > Another possibility is that we re-write much of the code base to avoid the performance pitfalls we are currently facing in order to get back to the level of performance we have with current code + KA 0.7. I believe the issue is basically an interaction between some of the abstractions / indirection we have developed and the compiler, so possibly rolling back that abstraction / indirection will bring us back to where we were previously. To follow up with @vchuravy, it seems that rewriting just _some_ of the code was sufficient, so we are (probably) in the clear! The lesson learned is that we cannot slurp / splat `@kernel` function arguments, because it prevents the kernel code from being inlined.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2996#issuecomment-1482198741
Deployability,integrat,integrate,"Just to be clear, the auxiliary field I'm using in my example has nothing to do with the forcing. The forcing is needed for physical reasons and I was using the auxiliary field (together with a callback) as a way to integrate something in time for a budget. Since that worked for CPU I assumed it was supposed to work for GPUs as well. But since that's not the case and scalars aren't supported, I'll close this issue. Thanks",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3025#issuecomment-1482933583
Integrability,integrat,integrate,"Just to be clear, the auxiliary field I'm using in my example has nothing to do with the forcing. The forcing is needed for physical reasons and I was using the auxiliary field (together with a callback) as a way to integrate something in time for a budget. Since that worked for CPU I assumed it was supposed to work for GPUs as well. But since that's not the case and scalars aren't supported, I'll close this issue. Thanks",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3025#issuecomment-1482933583
Usability,clear,clear,"Just to be clear, the auxiliary field I'm using in my example has nothing to do with the forcing. The forcing is needed for physical reasons and I was using the auxiliary field (together with a callback) as a way to integrate something in time for a budget. Since that worked for CPU I assumed it was supposed to work for GPUs as well. But since that's not the case and scalars aren't supported, I'll close this issue. Thanks",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3025#issuecomment-1482933583
Deployability,integrat,integration,"To be sure, I didn't know that it would fail with scalars on the GPU and I don't really know why that happens... !. Note that you can also simply output a scalar to file every time-step and do the time-integration offline. JLD2 is lightning fast so you probably won't pay for that. That's actually the simplest method, and as a bonus you get the time history.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3025#issuecomment-1482943609
Integrability,integrat,integration,"To be sure, I didn't know that it would fail with scalars on the GPU and I don't really know why that happens... !. Note that you can also simply output a scalar to file every time-step and do the time-integration offline. JLD2 is lightning fast so you probably won't pay for that. That's actually the simplest method, and as a bonus you get the time history.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3025#issuecomment-1482943609
Usability,simpl,simply,"To be sure, I didn't know that it would fail with scalars on the GPU and I don't really know why that happens... !. Note that you can also simply output a scalar to file every time-step and do the time-integration offline. JLD2 is lightning fast so you probably won't pay for that. That's actually the simplest method, and as a bonus you get the time history.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3025#issuecomment-1482943609
Deployability,integrat,integrate,"> Just to be clear, the auxiliary field I'm using in my example has nothing to do with the forcing. The forcing is needed for physical reasons and I was using the auxiliary field (together with a callback) as a way to integrate something in time for a budget.; > ; > Since that worked for CPU I assumed it was supposed to work for GPUs as well. But since that's not the case and scalars aren't supported, I'll close this issue. I see. Did you try `Oceananigans.Fields.ConstantField`?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3025#issuecomment-1483381766
Integrability,integrat,integrate,"> Just to be clear, the auxiliary field I'm using in my example has nothing to do with the forcing. The forcing is needed for physical reasons and I was using the auxiliary field (together with a callback) as a way to integrate something in time for a budget.; > ; > Since that worked for CPU I assumed it was supposed to work for GPUs as well. But since that's not the case and scalars aren't supported, I'll close this issue. I see. Did you try `Oceananigans.Fields.ConstantField`?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3025#issuecomment-1483381766
Usability,clear,clear,"> Just to be clear, the auxiliary field I'm using in my example has nothing to do with the forcing. The forcing is needed for physical reasons and I was using the auxiliary field (together with a callback) as a way to integrate something in time for a budget.; > ; > Since that worked for CPU I assumed it was supposed to work for GPUs as well. But since that's not the case and scalars aren't supported, I'll close this issue. I see. Did you try `Oceananigans.Fields.ConstantField`?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3025#issuecomment-1483381766
Availability,down,downgraded,"Here's a simple hydrostatic model benchmark. ```julia; using Oceananigans; using BenchmarkTools. grid = RectilinearGrid(CPU(), size=(128, 128, 1), x=(0, 2π), y=(0, 2π), z=(0, 1), topology=(Periodic, Periodic, Bounded)); model = HydrostaticFreeSurfaceModel(; grid, momentum_advection=WENO(), tracer_advection=WENO()); ϵ(x, y, z) = 2rand() - 1; set!(model, u=ϵ, v=ϵ). function lots_of_steps!(model, Δt, steps=100); for _ = 1:steps; time_step!(model, Δt); end; end. @btime lots_of_steps!(model, 0.01); ```. Results. ```julia; 10.220 s (85845109 allocations: 37.94 GiB) # this PR; 6.284 s (66184308 allocations: 16.31 GiB) # this PR with KA downgraded to 0.7.2; ```. So we are close but not there yet. What about solvers ... ?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3026#issuecomment-1482146085
Testability,benchmark,benchmark,"Here's a simple hydrostatic model benchmark. ```julia; using Oceananigans; using BenchmarkTools. grid = RectilinearGrid(CPU(), size=(128, 128, 1), x=(0, 2π), y=(0, 2π), z=(0, 1), topology=(Periodic, Periodic, Bounded)); model = HydrostaticFreeSurfaceModel(; grid, momentum_advection=WENO(), tracer_advection=WENO()); ϵ(x, y, z) = 2rand() - 1; set!(model, u=ϵ, v=ϵ). function lots_of_steps!(model, Δt, steps=100); for _ = 1:steps; time_step!(model, Δt); end; end. @btime lots_of_steps!(model, 0.01); ```. Results. ```julia; 10.220 s (85845109 allocations: 37.94 GiB) # this PR; 6.284 s (66184308 allocations: 16.31 GiB) # this PR with KA downgraded to 0.7.2; ```. So we are close but not there yet. What about solvers ... ?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3026#issuecomment-1482146085
Usability,simpl,simple,"Here's a simple hydrostatic model benchmark. ```julia; using Oceananigans; using BenchmarkTools. grid = RectilinearGrid(CPU(), size=(128, 128, 1), x=(0, 2π), y=(0, 2π), z=(0, 1), topology=(Periodic, Periodic, Bounded)); model = HydrostaticFreeSurfaceModel(; grid, momentum_advection=WENO(), tracer_advection=WENO()); ϵ(x, y, z) = 2rand() - 1; set!(model, u=ϵ, v=ϵ). function lots_of_steps!(model, Δt, steps=100); for _ = 1:steps; time_step!(model, Δt); end; end. @btime lots_of_steps!(model, 0.01); ```. Results. ```julia; 10.220 s (85845109 allocations: 37.94 GiB) # this PR; 6.284 s (66184308 allocations: 16.31 GiB) # this PR with KA downgraded to 0.7.2; ```. So we are close but not there yet. What about solvers ... ?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3026#issuecomment-1482146085
Usability,undo,undo,We can undo the merging by `git reset --hard ae12376d1e31128e2e17e6b9447e75d37510e550`?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3026#issuecomment-1482192734
Performance,perform,performance,"> > @simone-silvestri will the changes here impact CATKE on [CliMA/ClimaOcean.jl#17](https://github.com/CliMA/ClimaOcean.jl/pull/17) ?; > ; > not on the GPU, this PR affects only CPU performance. sorry, I was not clear... I was asking whether any syntax for adding parametrization with additional tracers changed. (But I think, no, right?)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3030#issuecomment-1487536293
Usability,clear,clear,"> > @simone-silvestri will the changes here impact CATKE on [CliMA/ClimaOcean.jl#17](https://github.com/CliMA/ClimaOcean.jl/pull/17) ?; > ; > not on the GPU, this PR affects only CPU performance. sorry, I was not clear... I was asking whether any syntax for adding parametrization with additional tracers changed. (But I think, no, right?)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3030#issuecomment-1487536293
Deployability,continuous,continuously,"> that looks very weird! But it is structured in some sense, it looks like the initial condition has some inbalances that generate noise which gets cleaned up by numerical diffusion. Interesting also that buoyancy extrema are continuously increasing in magnitude. If this is not happening with z-directed gravity, it might really be that there is some bug/incorrectness in the buoyancy model. A way to test this would be to recreate the same setup with z-directed gravity and use an immersed boundary to represent the tilt. If that case behaves as expected we know where to focus. @simone-silvestri I'm not sure if that'd be an apples-to-apples comparison. We'd be comparing a domain with smooth tilted boundaries (using the rotated buoyancy) against a domain with jagged tilted boundaries (using our grid-fitted IB). So I'm not sure what we could learn there (please lmk if I'm missing something here). That said, I think it's worth the shot so I might try to implement that soon and see what happens.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3036#issuecomment-1517948385
Testability,test,test,"> that looks very weird! But it is structured in some sense, it looks like the initial condition has some inbalances that generate noise which gets cleaned up by numerical diffusion. Interesting also that buoyancy extrema are continuously increasing in magnitude. If this is not happening with z-directed gravity, it might really be that there is some bug/incorrectness in the buoyancy model. A way to test this would be to recreate the same setup with z-directed gravity and use an immersed boundary to represent the tilt. If that case behaves as expected we know where to focus. @simone-silvestri I'm not sure if that'd be an apples-to-apples comparison. We'd be comparing a domain with smooth tilted boundaries (using the rotated buoyancy) against a domain with jagged tilted boundaries (using our grid-fitted IB). So I'm not sure what we could learn there (please lmk if I'm missing something here). That said, I think it's worth the shot so I might try to implement that soon and see what happens.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3036#issuecomment-1517948385
Usability,learn,learn,"> that looks very weird! But it is structured in some sense, it looks like the initial condition has some inbalances that generate noise which gets cleaned up by numerical diffusion. Interesting also that buoyancy extrema are continuously increasing in magnitude. If this is not happening with z-directed gravity, it might really be that there is some bug/incorrectness in the buoyancy model. A way to test this would be to recreate the same setup with z-directed gravity and use an immersed boundary to represent the tilt. If that case behaves as expected we know where to focus. @simone-silvestri I'm not sure if that'd be an apples-to-apples comparison. We'd be comparing a domain with smooth tilted boundaries (using the rotated buoyancy) against a domain with jagged tilted boundaries (using our grid-fitted IB). So I'm not sure what we could learn there (please lmk if I'm missing something here). That said, I think it's worth the shot so I might try to implement that soon and see what happens.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3036#issuecomment-1517948385
Usability,clear,clear,"> Yes I did. The issue still persists with all advection schemes I've tried so far and with any ""reasonable"" value of molecular diffusion. Maybe I wasn't clear, the point is that if the dynamics are linear or small-amplitude then advection doesn't play a role; it wouldn't matter what advection scheme you use. The term is small. Does hyperviscosity / hyperdiffusion allow stable simulations with non-trivial dynamics?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3036#issuecomment-1517987325
Usability,clear,clear,"> > Yes I did. The issue still persists with all advection schemes I've tried so far and with any ""reasonable"" value of molecular diffusion.; > ; > Maybe I wasn't clear, the point is that if the dynamics are linear or small-amplitude then advection doesn't play a role; it wouldn't matter what advection scheme you use. The term is small. I see. Agreed. > Does hyperviscosity / hyperdiffusion allow stable simulations with non-trivial dynamics?. I haven't tried it. Possibly. But the simulations I'm using this set-up for are LES. Assuming adding hyperviscosity does do what you're suggesting, I'm not sure how ""correct"" it is to use that along with a large-eddy simulation closure. (I think here are arguments to be made for both sides.). That said, it's worth the shot. Although tbh I have no idea what a reasonable value for hyperviscosity is since I've never used it :joy: . What would be a fair value to include in this MWE?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3036#issuecomment-1518004444
Safety,avoid,avoiding,"he problem. It only fails intermittently.; > ; > We have some validation of the shallow water model in the example. I propose that in order to move forward, we should generate a few additional validation tests including some with bathymetry. Once we have those and have analyzed them to ensure we are satisfied with the dynamics, we should then work on designing a better regression test --- one that won't ""pass"" when it should not. Then we can add that better regression test to our test suite, and remove the warning from the shallow water model constructor.; > ; > Probably best to also resolve the issue with the pressure gradient in presence of bathymetry. Maybe a topographic Rossby wave or some such would help build confidence that we are treating non-uniform bathymetry correctly with both of the formulations that we have. Thanks for the explanation. I agree that looking at a topographic Rossby wave is a good test to have. In the case of a small linear slope and small amplitude wave, it should be close to an exact solution so that will be easy. If we want more challenging tests, there are no shortage of those. Lots of tests have shocks and people like to test those but I would suggest avoiding those, as shocks mean the aspect ratio is order one or larger, and that violates the underyling hydrostatic assumption in the model. We could take the Bicklet jet example we have and put it over topography and compute the growth rates. There is a Poulin and Flierl (2005) in JPO that studies that and it would be easy enough to put to get linear stability code to compute the growth rates. That way we also have some theory to support the code. Also, we could look at a wind-driven gyre problem with and without topography. Not a simple test but would help to validate the global simulations that @simone-silvestri did a while ago with the shallow water model. Lots we can do!. I don't remember the issue about the pressure gradient term with bathymetry but happy to get into it sometime.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3050#issuecomment-1498158496
Security,validat,validation,"> It's ready @navidcy; > ; > @francispoulin right, that's why it's so hard to understand the problem. It only fails intermittently.; > ; > We have some validation of the shallow water model in the example. I propose that in order to move forward, we should generate a few additional validation tests including some with bathymetry. Once we have those and have analyzed them to ensure we are satisfied with the dynamics, we should then work on designing a better regression test --- one that won't ""pass"" when it should not. Then we can add that better regression test to our test suite, and remove the warning from the shallow water model constructor.; > ; > Probably best to also resolve the issue with the pressure gradient in presence of bathymetry. Maybe a topographic Rossby wave or some such would help build confidence that we are treating non-uniform bathymetry correctly with both of the formulations that we have. Thanks for the explanation. I agree that looking at a topographic Rossby wave is a good test to have. In the case of a small linear slope and small amplitude wave, it should be close to an exact solution so that will be easy. If we want more challenging tests, there are no shortage of those. Lots of tests have shocks and people like to test those but I would suggest avoiding those, as shocks mean the aspect ratio is order one or larger, and that violates the underyling hydrostatic assumption in the model. We could take the Bicklet jet example we have and put it over topography and compute the growth rates. There is a Poulin and Flierl (2005) in JPO that studies that and it would be easy enough to put to get linear stability code to compute the growth rates. That way we also have some theory to support the code. Also, we could look at a wind-driven gyre problem with and without topography. Not a simple test but would help to validate the global simulations that @simone-silvestri did a while ago with the shallow water model. Lots we can do!. I don't remember the ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3050#issuecomment-1498158496
Testability,test,tests,"> It's ready @navidcy; > ; > @francispoulin right, that's why it's so hard to understand the problem. It only fails intermittently.; > ; > We have some validation of the shallow water model in the example. I propose that in order to move forward, we should generate a few additional validation tests including some with bathymetry. Once we have those and have analyzed them to ensure we are satisfied with the dynamics, we should then work on designing a better regression test --- one that won't ""pass"" when it should not. Then we can add that better regression test to our test suite, and remove the warning from the shallow water model constructor.; > ; > Probably best to also resolve the issue with the pressure gradient in presence of bathymetry. Maybe a topographic Rossby wave or some such would help build confidence that we are treating non-uniform bathymetry correctly with both of the formulations that we have. Thanks for the explanation. I agree that looking at a topographic Rossby wave is a good test to have. In the case of a small linear slope and small amplitude wave, it should be close to an exact solution so that will be easy. If we want more challenging tests, there are no shortage of those. Lots of tests have shocks and people like to test those but I would suggest avoiding those, as shocks mean the aspect ratio is order one or larger, and that violates the underyling hydrostatic assumption in the model. We could take the Bicklet jet example we have and put it over topography and compute the growth rates. There is a Poulin and Flierl (2005) in JPO that studies that and it would be easy enough to put to get linear stability code to compute the growth rates. That way we also have some theory to support the code. Also, we could look at a wind-driven gyre problem with and without topography. Not a simple test but would help to validate the global simulations that @simone-silvestri did a while ago with the shallow water model. Lots we can do!. I don't remember the ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3050#issuecomment-1498158496
Usability,simpl,simple,"he problem. It only fails intermittently.; > ; > We have some validation of the shallow water model in the example. I propose that in order to move forward, we should generate a few additional validation tests including some with bathymetry. Once we have those and have analyzed them to ensure we are satisfied with the dynamics, we should then work on designing a better regression test --- one that won't ""pass"" when it should not. Then we can add that better regression test to our test suite, and remove the warning from the shallow water model constructor.; > ; > Probably best to also resolve the issue with the pressure gradient in presence of bathymetry. Maybe a topographic Rossby wave or some such would help build confidence that we are treating non-uniform bathymetry correctly with both of the formulations that we have. Thanks for the explanation. I agree that looking at a topographic Rossby wave is a good test to have. In the case of a small linear slope and small amplitude wave, it should be close to an exact solution so that will be easy. If we want more challenging tests, there are no shortage of those. Lots of tests have shocks and people like to test those but I would suggest avoiding those, as shocks mean the aspect ratio is order one or larger, and that violates the underyling hydrostatic assumption in the model. We could take the Bicklet jet example we have and put it over topography and compute the growth rates. There is a Poulin and Flierl (2005) in JPO that studies that and it would be easy enough to put to get linear stability code to compute the growth rates. That way we also have some theory to support the code. Also, we could look at a wind-driven gyre problem with and without topography. Not a simple test but would help to validate the global simulations that @simone-silvestri did a while ago with the shallow water model. Lots we can do!. I don't remember the issue about the pressure gradient term with bathymetry but happy to get into it sometime.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3050#issuecomment-1498158496
Testability,test,tests,"> Btw, as a side-note, I wanted to revisit those global SWE simulations. I had the feeling that the bathymetry was flipped (and possibly that's why some currents were moving the other way!). Glad you mentioned it as we never figured out why. Definitely something to revisit after some simple tests. If we start off with a topographic Rossby wave it will be very easy to know whether things are flipped.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3050#issuecomment-1498162680
Usability,simpl,simple,"> Btw, as a side-note, I wanted to revisit those global SWE simulations. I had the feeling that the bathymetry was flipped (and possibly that's why some currents were moving the other way!). Glad you mentioned it as we never figured out why. Definitely something to revisit after some simple tests. If we start off with a topographic Rossby wave it will be very easy to know whether things are flipped.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3050#issuecomment-1498162680
Usability,clear,clear,"> we could actually keep a general version maybe by just; > ; > ```; > for dir in (:x, :y, :z) ; > diffusive_flux = Symbol(:diffusive_flux_, dir) ; > viscous_flux_u = Symbol(:viscous_flux_u, dir) ; > viscous_flux_v = Symbol(:viscous_flux_v, dir) ; > viscous_flux_w = Symbol(:viscous_flux_w, dir) ; > @eval begin ; > @inline $diffusive_flux(i, j, k, grid, clo::AbstractTurbulenceClosure, args...) = zero(grid) ; > @inline $viscous_flux_u(i, j, k, grid, clo::AbstractTurbulenceClosure, args...) = zero(grid) ; > @inline $viscous_flux_v(i, j, k, grid, clo::AbstractTurbulenceClosure, args...) = zero(grid) ; > @inline $viscous_flux_w(i, j, k, grid, clo::AbstractTurbulenceClosure, args...) = zero(grid) ; > end ; > end ; > ```; > ; > (and maybe move this to `closure_kernel_operators.jl`) So that we can have the best of both scenarios. But anyways I am fine with both. this makes sense to me. Maybe put it at the top-level in `TurbulenceClosures.jl` where `AbstractTurbulenceClosure` is defined (makes it clear what one gets from dispatching on `AbstractTurbulenceClosure`)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3057#issuecomment-1502347491
Usability,simpl,simple,Let’s discuss the user API here though it’s pretty simple,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3061#issuecomment-1526887412
Availability,mask,mask,"I think that's a good one. So we have:. * `immersed_value = 0`; * `immersed_mask_value = 0`; * `mask_immersed = 0`; * `fill_immersed = 0`. Would even just `mask = 0` be sufficient? I've also been annoyed about ""mask_immersed_field"" and wondered whether simply `mask!(field)` would be clear and a little cleaner",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3061#issuecomment-1527950210
Usability,simpl,simply,"I think that's a good one. So we have:. * `immersed_value = 0`; * `immersed_mask_value = 0`; * `mask_immersed = 0`; * `fill_immersed = 0`. Would even just `mask = 0` be sufficient? I've also been annoyed about ""mask_immersed_field"" and wondered whether simply `mask!(field)` would be clear and a little cleaner",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3061#issuecomment-1527950210
Availability,mask,mask,I vote for simply `mask = default_value` and `mask!(field)`,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3061#issuecomment-1528003302
Usability,simpl,simply,I vote for simply `mask = default_value` and `mask!(field)`,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3061#issuecomment-1528003302
Availability,mask,masking,"I think it's important to have the word `immersed` somewhere in the flag name otherwise it might not be clear that we're masking. I vote for `immersed _mask_value` flag. It's kinda verbose, but imo 100% clear.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3061#issuecomment-1528069200
Usability,clear,clear,"I think it's important to have the word `immersed` somewhere in the flag name otherwise it might not be clear that we're masking. I vote for `immersed _mask_value` flag. It's kinda verbose, but imo 100% clear.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3061#issuecomment-1528069200
Usability,simpl,simply,"Simple example why this doesn't make sense: `immersed_peripheral_node` is. https://github.com/CliMA/Oceananigans.jl/blob/72e2197e640ddf308fd40aa4658e7686e596bccd/src/ImmersedBoundaries/ImmersedBoundaries.jl#L217-L218. So, for example, if the entire bottom of a grid is immersed, then it will be _included_ in the reduction --- because those nodes _are_ on the periphery of the underlying grid, so. ```julia; !peripheral_node(i, j, k, ibg.underlying_grid, LX, LY, LZ); ```. is `false`. Including the bottom row of cells in the reduction makes no sense because these nodes are far beneath the immersed boundary. As a quick fix we could add another condition that also ignores `inactive_node`. But I'd also like to understand why we don't simply ignore all peripheral_nodes...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3064#issuecomment-1506411904
Usability,simpl,simply,"Since `[2]` is resolved at compile time and `2` is known I believe this can get compiled away, ie the result will simply be evaluating the second component of tuple",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3074#issuecomment-1516999602
Testability,test,tests,"As the diff shows, this PR reconstructs buoyancy at the location it's needed. For example, `x_dot_g_b` must reconstruct the buoyancy perturbation, which is located at tracer locations `ccc`, at the location `fcc`. . Similarly, `z_dot_g_b` should be reconstructed at `ccf` (the location of vertical velocity). Note that we _also_ do this reconstructed when computing the hydrostatic pressure integral, therefore:. $$ p_h = \int^0_z \bar b^z \text{ } dz $$. where $\overline{()}^z$ indicates a reconstruction in $z$. Previously, we were assuming within the hydrsotatic pressure integral that `z_dot_g_b` returned at `ccc`. The first commit on this PR changed the reconstruction for `z_dot_g_b` so it returns at `ccf`. However, making this change also requires ""undoing"" the reconstruction in the hyrostatic pressure integral, which previously assumed that `z_dot_g_b` returned at `ccc`. With both changes, the regression tests should pass _and_ tilted gravity should be fixed. Hope that clears things up.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3079#issuecomment-1518051721
Usability,undo,undoing,"As the diff shows, this PR reconstructs buoyancy at the location it's needed. For example, `x_dot_g_b` must reconstruct the buoyancy perturbation, which is located at tracer locations `ccc`, at the location `fcc`. . Similarly, `z_dot_g_b` should be reconstructed at `ccf` (the location of vertical velocity). Note that we _also_ do this reconstructed when computing the hydrostatic pressure integral, therefore:. $$ p_h = \int^0_z \bar b^z \text{ } dz $$. where $\overline{()}^z$ indicates a reconstruction in $z$. Previously, we were assuming within the hydrsotatic pressure integral that `z_dot_g_b` returned at `ccc`. The first commit on this PR changed the reconstruction for `z_dot_g_b` so it returns at `ccf`. However, making this change also requires ""undoing"" the reconstruction in the hyrostatic pressure integral, which previously assumed that `z_dot_g_b` returned at `ccc`. With both changes, the regression tests should pass _and_ tilted gravity should be fixed. Hope that clears things up.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3079#issuecomment-1518051721
Deployability,update,update,"Another benefit of removing the hydrostatic pressure is that we can improve the documentation and user interface too. For example, the hydrostatic pressure in the hydrostatic model is stored in something like. ```; model.pressure.pHY; ```. since for the nonhydrostatic model its. ```; model.pressures.pNHS; model.pressures.pHY; ```. With just one pressure field we should simply write `model.pressure` for both cases. It's a significant refactor to remove hydrostatic pressure --- I don't think we want to do the hacky thing that we did to set up that PR that just keeps the same structures but sets pressure to `nothing`, we want to do it properly and update the docs.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3079#issuecomment-1518172281
Integrability,interface,interface,"Another benefit of removing the hydrostatic pressure is that we can improve the documentation and user interface too. For example, the hydrostatic pressure in the hydrostatic model is stored in something like. ```; model.pressure.pHY; ```. since for the nonhydrostatic model its. ```; model.pressures.pNHS; model.pressures.pHY; ```. With just one pressure field we should simply write `model.pressure` for both cases. It's a significant refactor to remove hydrostatic pressure --- I don't think we want to do the hacky thing that we did to set up that PR that just keeps the same structures but sets pressure to `nothing`, we want to do it properly and update the docs.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3079#issuecomment-1518172281
Modifiability,refactor,refactor,"Another benefit of removing the hydrostatic pressure is that we can improve the documentation and user interface too. For example, the hydrostatic pressure in the hydrostatic model is stored in something like. ```; model.pressure.pHY; ```. since for the nonhydrostatic model its. ```; model.pressures.pNHS; model.pressures.pHY; ```. With just one pressure field we should simply write `model.pressure` for both cases. It's a significant refactor to remove hydrostatic pressure --- I don't think we want to do the hacky thing that we did to set up that PR that just keeps the same structures but sets pressure to `nothing`, we want to do it properly and update the docs.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3079#issuecomment-1518172281
Usability,simpl,simply,"Another benefit of removing the hydrostatic pressure is that we can improve the documentation and user interface too. For example, the hydrostatic pressure in the hydrostatic model is stored in something like. ```; model.pressure.pHY; ```. since for the nonhydrostatic model its. ```; model.pressures.pNHS; model.pressures.pHY; ```. With just one pressure field we should simply write `model.pressure` for both cases. It's a significant refactor to remove hydrostatic pressure --- I don't think we want to do the hacky thing that we did to set up that PR that just keeps the same structures but sets pressure to `nothing`, we want to do it properly and update the docs.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3079#issuecomment-1518172281
Availability,failure,failures,"Docs are previewing here: https://clima.github.io/OceananigansDocumentation/previews/PR3080/. I checked all the examples with `NonhdyrostaticModel` and they all look the same as they do on the `stable` branch. Furthermore, the few tests failures that we have are all something like. ```; JLD2 output writer [CPU]: Test Failed at /var/lib/buildkite-agent/builds/tartarus-1/clima/oceananigans/test/test_jld2_output_writer.jl:131; --;   | Expression: wu == zero(FT);   | Evaluated: -3.009265538105056e-35 == 0.0; ```. i.e. very small approximation errors that aren't indicative of any significant errors in the model. In other words, I think this is working well! I vote we simplify the model and get rid of the hydrostatic separation. @glwagner as you mentioned, this isn't a trivial change. If you wanna move forward with it, feel free to push to this PR or close this one and open another. I can also help if you want, just lmk what I should focus on. PS: Just like we did in https://github.com/CliMA/Oceananigans.jl/pull/1910 we might need/want to replace the `stratified_fluid_remains_at_rest_with_tilted_gravity_buoyancy_tracer()` test for something simpler.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3080#issuecomment-1518394718
Testability,test,tests,"Docs are previewing here: https://clima.github.io/OceananigansDocumentation/previews/PR3080/. I checked all the examples with `NonhdyrostaticModel` and they all look the same as they do on the `stable` branch. Furthermore, the few tests failures that we have are all something like. ```; JLD2 output writer [CPU]: Test Failed at /var/lib/buildkite-agent/builds/tartarus-1/clima/oceananigans/test/test_jld2_output_writer.jl:131; --;   | Expression: wu == zero(FT);   | Evaluated: -3.009265538105056e-35 == 0.0; ```. i.e. very small approximation errors that aren't indicative of any significant errors in the model. In other words, I think this is working well! I vote we simplify the model and get rid of the hydrostatic separation. @glwagner as you mentioned, this isn't a trivial change. If you wanna move forward with it, feel free to push to this PR or close this one and open another. I can also help if you want, just lmk what I should focus on. PS: Just like we did in https://github.com/CliMA/Oceananigans.jl/pull/1910 we might need/want to replace the `stratified_fluid_remains_at_rest_with_tilted_gravity_buoyancy_tracer()` test for something simpler.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3080#issuecomment-1518394718
Usability,simpl,simplify,"Docs are previewing here: https://clima.github.io/OceananigansDocumentation/previews/PR3080/. I checked all the examples with `NonhdyrostaticModel` and they all look the same as they do on the `stable` branch. Furthermore, the few tests failures that we have are all something like. ```; JLD2 output writer [CPU]: Test Failed at /var/lib/buildkite-agent/builds/tartarus-1/clima/oceananigans/test/test_jld2_output_writer.jl:131; --;   | Expression: wu == zero(FT);   | Evaluated: -3.009265538105056e-35 == 0.0; ```. i.e. very small approximation errors that aren't indicative of any significant errors in the model. In other words, I think this is working well! I vote we simplify the model and get rid of the hydrostatic separation. @glwagner as you mentioned, this isn't a trivial change. If you wanna move forward with it, feel free to push to this PR or close this one and open another. I can also help if you want, just lmk what I should focus on. PS: Just like we did in https://github.com/CliMA/Oceananigans.jl/pull/1910 we might need/want to replace the `stratified_fluid_remains_at_rest_with_tilted_gravity_buoyancy_tracer()` test for something simpler.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3080#issuecomment-1518394718
Testability,test,tests,"I think code-wise, this is pretty much ready (save some occasional polishing like [here](https://github.com/CliMA/Oceananigans.jl/pull/3080#discussion_r1192737129)). `pHY` and `pNHS` are no more, and both both hydrostatic and nonhydrostaic models, the pressure is simply `model.pressure`. The only tests that are failing and some regression tests, whose data will have to be re-done, and a scalar-index issue on GPUs. I think the only major change that's left is the documentation. @glwagner, in the past you preferred to make big changes to the docs yourself. Do you wanna remove the pressure separation part from the docs and push it here?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3080#issuecomment-1550241035
Usability,simpl,simply,"I think code-wise, this is pretty much ready (save some occasional polishing like [here](https://github.com/CliMA/Oceananigans.jl/pull/3080#discussion_r1192737129)). `pHY` and `pNHS` are no more, and both both hydrostatic and nonhydrostaic models, the pressure is simply `model.pressure`. The only tests that are failing and some regression tests, whose data will have to be re-done, and a scalar-index issue on GPUs. I think the only major change that's left is the documentation. @glwagner, in the past you preferred to make big changes to the docs yourself. Do you wanna remove the pressure separation part from the docs and push it here?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3080#issuecomment-1550241035
Testability,test,tests,"> What are the differences?. I haven't plotted/analyzed the solutions for the regression tests carefully yet (tbh I'm not familiar yet with how the regression tests work and how the data is stored), but I have carefully compared my own simulations and a couple of the examples using `main` and this branch. The only differences I see are the usual turbulence IC ""issue"" where small disturbances in the flow amplify and lead to a different solution (pointwise speaking) but with the same statistics, qualitative behavior, etc. Given my unfamiliarity with the regression tests I'm not sure how to proceed solving the tests. So I'd appreciate some guidance here on how to move forward to get all the tests passing.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3080#issuecomment-1558355827
Usability,guid,guidance,"> What are the differences?. I haven't plotted/analyzed the solutions for the regression tests carefully yet (tbh I'm not familiar yet with how the regression tests work and how the data is stored), but I have carefully compared my own simulations and a couple of the examples using `main` and this branch. The only differences I see are the usual turbulence IC ""issue"" where small disturbances in the flow amplify and lead to a different solution (pointwise speaking) but with the same statistics, qualitative behavior, etc. Given my unfamiliarity with the regression tests I'm not sure how to proceed solving the tests. So I'd appreciate some guidance here on how to move forward to get all the tests passing.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3080#issuecomment-1558355827
Availability,avail,available,"> @tomchor the description of this issue is a little vague. The dynamics weren't ""weird"" --- the problem was a bug in reconstructing buoyancy in the momentum equations, right? It'd be nice to add a little more explicit description of the original issue. I think there is a PR that fixed the bug that we can point to as well. The issue is that the videos aren't available anymore and, apart from the internal wave packet example, I don't really remember what was happening well enough to be able describe it objectively. That said, I did my best to make the description more clear and linked the PR that solved the bug.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3080#issuecomment-1616803081
Usability,clear,clear,"> @tomchor the description of this issue is a little vague. The dynamics weren't ""weird"" --- the problem was a bug in reconstructing buoyancy in the momentum equations, right? It'd be nice to add a little more explicit description of the original issue. I think there is a PR that fixed the bug that we can point to as well. The issue is that the videos aren't available anymore and, apart from the internal wave packet example, I don't really remember what was happening well enough to be able describe it objectively. That said, I did my best to make the description more clear and linked the PR that solved the bug.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3080#issuecomment-1616803081
Availability,avail,available,"> > @tomchor the description of this issue is a little vague. The dynamics weren't ""weird"" --- the problem was a bug in reconstructing buoyancy in the momentum equations, right? It'd be nice to add a little more explicit description of the original issue. I think there is a PR that fixed the bug that we can point to as well.; > ; > The issue is that the videos aren't available anymore and, apart from the internal wave packet example, I don't really remember what was happening well enough to be able describe it objectively.; > ; > That said, I did my best to make the description more clear and linked the PR that solved the bug. The issue was that buoyancy was not reconstructed properly in the vertical. (There was also a problem with reconstructing buoyancy in the horizontal, but this only affects tilted domains.) So there was a bug and the discretization was incorrect.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3080#issuecomment-1621989632
Usability,clear,clear,"> > @tomchor the description of this issue is a little vague. The dynamics weren't ""weird"" --- the problem was a bug in reconstructing buoyancy in the momentum equations, right? It'd be nice to add a little more explicit description of the original issue. I think there is a PR that fixed the bug that we can point to as well.; > ; > The issue is that the videos aren't available anymore and, apart from the internal wave packet example, I don't really remember what was happening well enough to be able describe it objectively.; > ; > That said, I did my best to make the description more clear and linked the PR that solved the bug. The issue was that buoyancy was not reconstructed properly in the vertical. (There was also a problem with reconstructing buoyancy in the horizontal, but this only affects tilted domains.) So there was a bug and the discretization was incorrect.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3080#issuecomment-1621989632
Deployability,update,updated,"> The issue was that buoyancy was not reconstructed properly in the vertical. (There was also a problem with reconstructing buoyancy in the horizontal, but this only affects tilted domains.) So there was a bug and the discretization was incorrect. I'm aware of that. My point was more that I don't quite remember how the issue was manifested in the dynamics (the recognition of which was what prompted us to abandon https://github.com/CliMA/Oceananigans.jl/pull/1910). > @tomchor I updated the PR description. Feel free to edit it further. Thanks, that's a great detailed description. I only added one item to the advantages: simpler code and user interface.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3080#issuecomment-1622165197
Integrability,interface,interface,"> The issue was that buoyancy was not reconstructed properly in the vertical. (There was also a problem with reconstructing buoyancy in the horizontal, but this only affects tilted domains.) So there was a bug and the discretization was incorrect. I'm aware of that. My point was more that I don't quite remember how the issue was manifested in the dynamics (the recognition of which was what prompted us to abandon https://github.com/CliMA/Oceananigans.jl/pull/1910). > @tomchor I updated the PR description. Feel free to edit it further. Thanks, that's a great detailed description. I only added one item to the advantages: simpler code and user interface.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3080#issuecomment-1622165197
Usability,simpl,simpler,"> The issue was that buoyancy was not reconstructed properly in the vertical. (There was also a problem with reconstructing buoyancy in the horizontal, but this only affects tilted domains.) So there was a bug and the discretization was incorrect. I'm aware of that. My point was more that I don't quite remember how the issue was manifested in the dynamics (the recognition of which was what prompted us to abandon https://github.com/CliMA/Oceananigans.jl/pull/1910). > @tomchor I updated the PR description. Feel free to edit it further. Thanks, that's a great detailed description. I only added one item to the advantages: simpler code and user interface.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3080#issuecomment-1622165197
Usability,simpl,simpler,> What do you mean by cleaner code? You mean `update_state!`? We need all of these functions still for the hydrostatic model so I don't think on the whole there's much of a change to the source code. I'm referring to the fact that dealing with just one pressure makes for cleaner/simpler code in general. But feel free to remove that statement if you don't agree.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3080#issuecomment-1622336006
Usability,simpl,simply,Note that the divergence is calculated by dividing by area:. https://github.com/CliMA/Oceananigans.jl/blob/98bcdde7ae679583ea88474ec0909469abccfc90/src/Operators/divergence_operators.jl#L35-L37. So this change could be more simply explained as reconstructing `δx(Δy * u) + δy(Δx * v)` (it may be silly to divide by A then multiply by A).,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3091#issuecomment-1528951908
Usability,clear,clearer,"> Why (or when) did we change the pattern of `FT(number)` to `convert(FT, number)` (I actually prefer the former but I am ok changing it). I think it's clearer. If it appears 20 times in 3-4 lines (like, e.g. in https://github.com/CliMA/Oceananigans.jl/blob/c030aac826215bdcbdaa942f2832fa4ba16ade97/src/Advection/multi_dimensional_reconstruction.jl#L50-L58) then `FT(number)` is fine! But if it's just an isolated incident then convert is more verbose sort of like saying in English what is happening.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3091#issuecomment-1605896632
Usability,clear,clear,"I agree that maybe `convert` is more clear, but still, I would rather have one way to do things, and for this reason: ; to develop the code you must need to know what it means in those lines where it is repeated 20 times, so I do not think writing it in another way improves clarity. It might actually beg the question as to why the pattern is different and if there are concrete differences between the two ways of writing it, on the other hand, if you are familiar with Oceananigans, you just have to know `FT()` once and you're done",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3091#issuecomment-1606894945
Usability,clear,clear,"> I agree that maybe `convert` is more clear, but still, I would rather have one way to do things, and for this reason: to develop the code you must need to know what it means in those lines where it is repeated 20 times, so I do not think writing it in another way improves clarity. It might actually beg the question as to why the pattern is different and if there are concrete differences between the two ways of writing it, on the other hand, if you are familiar with Oceananigans, you just have to know `FT()` once and you're done. We agreed long ago to only use `convert` --- why are we still using patterns like `FT(num)`?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3091#issuecomment-1607573233
Usability,simpl,simpler,"> > This PR adds a `parameters` keyword to `UniformStokesDrift`.; > > At the moment this only gets activated if `parameters isa NamedTuple`. Do we want to be more general than that?; > > Closes #2960; > ; > It's better to fallback to the signature `(z, t)` when `parameters::Nothing`, and then otherwise include. @glwagner Can you check now? I think it's simpler now and it does what you suggested.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3096#issuecomment-1535576793
Usability,undo,undo,"OK, I'm merging! We can always undo. I think it's a step fwd.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3100#issuecomment-1619192341
Testability,test,tested,"@glwagner nice. I think it's indeed clearer. @navidcy I think the `SmagLilly` closure is tested in [time-stepping](https://github.com/CliMA/Oceananigans.jl/blob/main/test/test_time_stepping.jl), [closures](https://github.com/CliMA/Oceananigans.jl/blob/main/test/test_turbulence_closures.jl) and in [nonhydrostatic regression](https://github.com/CliMA/Oceananigans.jl/blob/main/test/test_nonhydrostatic_regression.jl#L63-L72). But I think the only instance where we're testing actual values (and not just compilation of trivial (i.e. zero) values) is in . https://github.com/CliMA/Oceananigans.jl/blob/8b42137e4224b86fe1f3f1744bd5076aa8821085/test/test_nonhydrostatic_regression.jl#L63-L72. Which does seem to pass, so I'm approving this.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3102#issuecomment-1540354682
Usability,clear,clearer,"@glwagner nice. I think it's indeed clearer. @navidcy I think the `SmagLilly` closure is tested in [time-stepping](https://github.com/CliMA/Oceananigans.jl/blob/main/test/test_time_stepping.jl), [closures](https://github.com/CliMA/Oceananigans.jl/blob/main/test/test_turbulence_closures.jl) and in [nonhydrostatic regression](https://github.com/CliMA/Oceananigans.jl/blob/main/test/test_nonhydrostatic_regression.jl#L63-L72). But I think the only instance where we're testing actual values (and not just compilation of trivial (i.e. zero) values) is in . https://github.com/CliMA/Oceananigans.jl/blob/8b42137e4224b86fe1f3f1744bd5076aa8821085/test/test_nonhydrostatic_regression.jl#L63-L72. Which does seem to pass, so I'm approving this.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3102#issuecomment-1540354682
Energy Efficiency,adapt,adapted,"I think this PR is finally ready. Thanks to @simone-silvestri for the help!. Here a simple simulation (roughly adapted from the [ocean wind mixing example](https://clima.github.io/OceananigansDocumentation/stable/generated/ocean_wind_mixing_and_convection/)) using stretched grids in the x, y, and z directions respectively:. https://github.com/CliMA/Oceananigans.jl/assets/13205162/fba0fa71-92b0-4f7b-978e-7bb24f7060fb. https://github.com/CliMA/Oceananigans.jl/assets/13205162/dea0309f-3b2f-499a-81b2-f5de819dc992. https://github.com/CliMA/Oceananigans.jl/assets/13205162/17e2c3e1-71be-4d9a-9bbe-378bbb657150",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3111#issuecomment-1597796977
Modifiability,adapt,adapted,"I think this PR is finally ready. Thanks to @simone-silvestri for the help!. Here a simple simulation (roughly adapted from the [ocean wind mixing example](https://clima.github.io/OceananigansDocumentation/stable/generated/ocean_wind_mixing_and_convection/)) using stretched grids in the x, y, and z directions respectively:. https://github.com/CliMA/Oceananigans.jl/assets/13205162/fba0fa71-92b0-4f7b-978e-7bb24f7060fb. https://github.com/CliMA/Oceananigans.jl/assets/13205162/dea0309f-3b2f-499a-81b2-f5de819dc992. https://github.com/CliMA/Oceananigans.jl/assets/13205162/17e2c3e1-71be-4d9a-9bbe-378bbb657150",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3111#issuecomment-1597796977
Usability,simpl,simple,"I think this PR is finally ready. Thanks to @simone-silvestri for the help!. Here a simple simulation (roughly adapted from the [ocean wind mixing example](https://clima.github.io/OceananigansDocumentation/stable/generated/ocean_wind_mixing_and_convection/)) using stretched grids in the x, y, and z directions respectively:. https://github.com/CliMA/Oceananigans.jl/assets/13205162/fba0fa71-92b0-4f7b-978e-7bb24f7060fb. https://github.com/CliMA/Oceananigans.jl/assets/13205162/dea0309f-3b2f-499a-81b2-f5de819dc992. https://github.com/CliMA/Oceananigans.jl/assets/13205162/17e2c3e1-71be-4d9a-9bbe-378bbb657150",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3111#issuecomment-1597796977
Availability,error,error,"> Same error... no idea what's happening since there are no more scaped characters. Would changing `r"".jld2""` to `raw"".jld2""` do anything?. error is in line 168 so I'm wondering if it's simply the docstring!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3113#issuecomment-1562014188
Usability,simpl,simply,"> Same error... no idea what's happening since there are no more scaped characters. Would changing `r"".jld2""` to `raw"".jld2""` do anything?. error is in line 168 so I'm wondering if it's simply the docstring!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3113#issuecomment-1562014188
Integrability,interface,interface,"The issue is a little tricky. Typically we expect abstract operations to be computed during time-stepping. In that case, the halos should be correctly filled. However, @navidcy expects that abstract operations should be correct at any time and does not expect to have to call fill halo regions. Thus for `compute!` to be more generally useful to users I think we do want this behavior. The problem is that fill halo regions can be expensive eg for distributed models. Therefore to both serve expected user behavior and provide a performant interface we perhaps have to add a flag to `compute!` like `fill_halo_regions=false` so that computation for output does not trigger extra calls to fill halo regions. Note @navidcy you can also use the simpler and more transparent . ```julia; parent(model.velocities.u) .= 1; ```. or just `fill!(model.velocities.u, 1)`. I think your result would be correct then. But still if we are setting to functions then we need `set!`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3114#issuecomment-1559611530
Performance,perform,performant,"The issue is a little tricky. Typically we expect abstract operations to be computed during time-stepping. In that case, the halos should be correctly filled. However, @navidcy expects that abstract operations should be correct at any time and does not expect to have to call fill halo regions. Thus for `compute!` to be more generally useful to users I think we do want this behavior. The problem is that fill halo regions can be expensive eg for distributed models. Therefore to both serve expected user behavior and provide a performant interface we perhaps have to add a flag to `compute!` like `fill_halo_regions=false` so that computation for output does not trigger extra calls to fill halo regions. Note @navidcy you can also use the simpler and more transparent . ```julia; parent(model.velocities.u) .= 1; ```. or just `fill!(model.velocities.u, 1)`. I think your result would be correct then. But still if we are setting to functions then we need `set!`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3114#issuecomment-1559611530
Usability,simpl,simpler,"The issue is a little tricky. Typically we expect abstract operations to be computed during time-stepping. In that case, the halos should be correctly filled. However, @navidcy expects that abstract operations should be correct at any time and does not expect to have to call fill halo regions. Thus for `compute!` to be more generally useful to users I think we do want this behavior. The problem is that fill halo regions can be expensive eg for distributed models. Therefore to both serve expected user behavior and provide a performant interface we perhaps have to add a flag to `compute!` like `fill_halo_regions=false` so that computation for output does not trigger extra calls to fill halo regions. Note @navidcy you can also use the simpler and more transparent . ```julia; parent(model.velocities.u) .= 1; ```. or just `fill!(model.velocities.u, 1)`. I think your result would be correct then. But still if we are setting to functions then we need `set!`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3114#issuecomment-1559611530
Testability,test,test,Sure! I was just doing what the test does to reproduce why CI fails... :) Let's simplify the test also!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3114#issuecomment-1560123791
Usability,simpl,simplify,Sure! I was just doing what the test does to reproduce why CI fails... :) Let's simplify the test also!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3114#issuecomment-1560123791
Usability,clear,clear,"> Sent approval; the last major question is whether we should use `ZDirection()` and `::ZDirection` instead of `:z` and `::Val{:z}` -- and then `XDirection` and `YDirection`. Hmm, that's a good point. Honestly I have no opinion here since both are equally clear, so I'll defer to you/others.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3117#issuecomment-1564811587
Usability,clear,clear,"> > Sent approval; the last major question is whether we should use `ZDirection()` and `::ZDirection` instead of `:z` and `::Val{:z}` -- and then `XDirection` and `YDirection`.; > ; > Hmm, that's a good point. Honestly I have no opinion here since both are equally clear, so I'll defer to you/others. . Maybe one thing to keep in mind is that the `ZDirection` approach requires an explicit `using Oceananigans.Grids: ZDirection` when using `BatchedTridiagSolver` (plus defining `XDirection` and `YDirection`), while using `:x`, `:y`, `:z` doesn't.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3117#issuecomment-1564814148
Usability,undo,undo,I pushed [e852f50](https://github.com/CliMA/Oceananigans.jl/pull/3117/commits/e852f50548f33c5e5cf5004a77c95680b62209c6) because it was easier for me to commit than add code suggestion. but. feel free to undo it!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3117#issuecomment-1565986013
Testability,test,tests,Oh I see. This was not at all clear to me from your previous question. I thought you were asking whether the new versions dropped support to CuArrays and therefore explain why tests were failing!. Let me get back on your question now that I understand!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3121#issuecomment-1613661175
Usability,clear,clear,Oh I see. This was not at all clear to me from your previous question. I thought you were asking whether the new versions dropped support to CuArrays and therefore explain why tests were failing!. Let me get back on your question now that I understand!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3121#issuecomment-1613661175
Integrability,wrap,wrapping,"the offender is this line ; https://github.com/CliMA/Oceananigans.jl/blob/17e6fc045a32fcbd685737878ccf9638197c7b50/src/ImmersedBoundaries/grid_fitted_bottom.jl#L75. `MultiRegionGrid` is created by wrapping around an `ImmersedBoundaryGrid` where the letter are constructed with `construct_regionally(construct_grid, args...)`; https://github.com/CliMA/Oceananigans.jl/blob/eb38eeade577eca5056b99ca8839ca6c674ae0e2/src/MultiRegion/multi_region_grid.jl#L83; https://github.com/CliMA/Oceananigans.jl/blob/eb38eeade577eca5056b99ca8839ca6c674ae0e2/src/MultiRegion/multi_region_grid.jl#L110. `fill_halo_regions!` cannot be called within a regional `@apply_regionally` call, so we probably have to shift around the construction when there is an ImmersedBoundaryGrid. (I wonder how this test is passing on main). I see two solutions here:; 1) change the constructor of `MultiRegionGrid` to make sure that fill_halo is called outside, aka partition the immersed_boundary outside the `construct_regionally`, fill_halo and then build the immersed grid with an offsetarray (simple but probably worst long term); 2) Make `ImmersedBoundaryGrid` wrap around `MultiRegionGrid`(slightly more complex, maybe for another PR, but probably useful for the cubed sphere grid?)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3122#issuecomment-1603029063
Testability,test,test,"the offender is this line ; https://github.com/CliMA/Oceananigans.jl/blob/17e6fc045a32fcbd685737878ccf9638197c7b50/src/ImmersedBoundaries/grid_fitted_bottom.jl#L75. `MultiRegionGrid` is created by wrapping around an `ImmersedBoundaryGrid` where the letter are constructed with `construct_regionally(construct_grid, args...)`; https://github.com/CliMA/Oceananigans.jl/blob/eb38eeade577eca5056b99ca8839ca6c674ae0e2/src/MultiRegion/multi_region_grid.jl#L83; https://github.com/CliMA/Oceananigans.jl/blob/eb38eeade577eca5056b99ca8839ca6c674ae0e2/src/MultiRegion/multi_region_grid.jl#L110. `fill_halo_regions!` cannot be called within a regional `@apply_regionally` call, so we probably have to shift around the construction when there is an ImmersedBoundaryGrid. (I wonder how this test is passing on main). I see two solutions here:; 1) change the constructor of `MultiRegionGrid` to make sure that fill_halo is called outside, aka partition the immersed_boundary outside the `construct_regionally`, fill_halo and then build the immersed grid with an offsetarray (simple but probably worst long term); 2) Make `ImmersedBoundaryGrid` wrap around `MultiRegionGrid`(slightly more complex, maybe for another PR, but probably useful for the cubed sphere grid?)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3122#issuecomment-1603029063
Usability,simpl,simple,"the offender is this line ; https://github.com/CliMA/Oceananigans.jl/blob/17e6fc045a32fcbd685737878ccf9638197c7b50/src/ImmersedBoundaries/grid_fitted_bottom.jl#L75. `MultiRegionGrid` is created by wrapping around an `ImmersedBoundaryGrid` where the letter are constructed with `construct_regionally(construct_grid, args...)`; https://github.com/CliMA/Oceananigans.jl/blob/eb38eeade577eca5056b99ca8839ca6c674ae0e2/src/MultiRegion/multi_region_grid.jl#L83; https://github.com/CliMA/Oceananigans.jl/blob/eb38eeade577eca5056b99ca8839ca6c674ae0e2/src/MultiRegion/multi_region_grid.jl#L110. `fill_halo_regions!` cannot be called within a regional `@apply_regionally` call, so we probably have to shift around the construction when there is an ImmersedBoundaryGrid. (I wonder how this test is passing on main). I see two solutions here:; 1) change the constructor of `MultiRegionGrid` to make sure that fill_halo is called outside, aka partition the immersed_boundary outside the `construct_regionally`, fill_halo and then build the immersed grid with an offsetarray (simple but probably worst long term); 2) Make `ImmersedBoundaryGrid` wrap around `MultiRegionGrid`(slightly more complex, maybe for another PR, but probably useful for the cubed sphere grid?)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3122#issuecomment-1603029063
Integrability,wrap,wrapping,"> the offender is this line; > ; > https://github.com/CliMA/Oceananigans.jl/blob/17e6fc045a32fcbd685737878ccf9638197c7b50/src/ImmersedBoundaries/grid_fitted_bottom.jl#L75; > ; > `MultiRegionGrid` is created by wrapping around an `ImmersedBoundaryGrid` where the letter are constructed with `construct_regionally(construct_grid, args...)`; > ; > https://github.com/CliMA/Oceananigans.jl/blob/eb38eeade577eca5056b99ca8839ca6c674ae0e2/src/MultiRegion/multi_region_grid.jl#L83; > ; > ; > https://github.com/CliMA/Oceananigans.jl/blob/eb38eeade577eca5056b99ca8839ca6c674ae0e2/src/MultiRegion/multi_region_grid.jl#L110; > ; > `fill_halo_regions!` cannot be called within a regional `@apply_regionally` call, so we probably have to shift around the construction when there is an ImmersedBoundaryGrid. (I wonder how this test is passing on main); > ; > I see two solutions here:; > ; > 1. change the constructor of `MultiRegionGrid` to make sure that fill_halo is called outside, aka partition the immersed_boundary outside the `construct_regionally`, fill_halo and then build the immersed grid with an offsetarray (simple but probably worst long term); > 2. Make `ImmersedBoundaryGrid` wrap around `MultiRegionGrid`(slightly more complex, maybe for another PR, but probably useful for the cubed sphere grid?). The main criteria for the design is ease of use. So that's what we have to discuss.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3122#issuecomment-1603164230
Testability,test,test,"> the offender is this line; > ; > https://github.com/CliMA/Oceananigans.jl/blob/17e6fc045a32fcbd685737878ccf9638197c7b50/src/ImmersedBoundaries/grid_fitted_bottom.jl#L75; > ; > `MultiRegionGrid` is created by wrapping around an `ImmersedBoundaryGrid` where the letter are constructed with `construct_regionally(construct_grid, args...)`; > ; > https://github.com/CliMA/Oceananigans.jl/blob/eb38eeade577eca5056b99ca8839ca6c674ae0e2/src/MultiRegion/multi_region_grid.jl#L83; > ; > ; > https://github.com/CliMA/Oceananigans.jl/blob/eb38eeade577eca5056b99ca8839ca6c674ae0e2/src/MultiRegion/multi_region_grid.jl#L110; > ; > `fill_halo_regions!` cannot be called within a regional `@apply_regionally` call, so we probably have to shift around the construction when there is an ImmersedBoundaryGrid. (I wonder how this test is passing on main); > ; > I see two solutions here:; > ; > 1. change the constructor of `MultiRegionGrid` to make sure that fill_halo is called outside, aka partition the immersed_boundary outside the `construct_regionally`, fill_halo and then build the immersed grid with an offsetarray (simple but probably worst long term); > 2. Make `ImmersedBoundaryGrid` wrap around `MultiRegionGrid`(slightly more complex, maybe for another PR, but probably useful for the cubed sphere grid?). The main criteria for the design is ease of use. So that's what we have to discuss.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3122#issuecomment-1603164230
Usability,simpl,simple,"> the offender is this line; > ; > https://github.com/CliMA/Oceananigans.jl/blob/17e6fc045a32fcbd685737878ccf9638197c7b50/src/ImmersedBoundaries/grid_fitted_bottom.jl#L75; > ; > `MultiRegionGrid` is created by wrapping around an `ImmersedBoundaryGrid` where the letter are constructed with `construct_regionally(construct_grid, args...)`; > ; > https://github.com/CliMA/Oceananigans.jl/blob/eb38eeade577eca5056b99ca8839ca6c674ae0e2/src/MultiRegion/multi_region_grid.jl#L83; > ; > ; > https://github.com/CliMA/Oceananigans.jl/blob/eb38eeade577eca5056b99ca8839ca6c674ae0e2/src/MultiRegion/multi_region_grid.jl#L110; > ; > `fill_halo_regions!` cannot be called within a regional `@apply_regionally` call, so we probably have to shift around the construction when there is an ImmersedBoundaryGrid. (I wonder how this test is passing on main); > ; > I see two solutions here:; > ; > 1. change the constructor of `MultiRegionGrid` to make sure that fill_halo is called outside, aka partition the immersed_boundary outside the `construct_regionally`, fill_halo and then build the immersed grid with an offsetarray (simple but probably worst long term); > 2. Make `ImmersedBoundaryGrid` wrap around `MultiRegionGrid`(slightly more complex, maybe for another PR, but probably useful for the cubed sphere grid?). The main criteria for the design is ease of use. So that's what we have to discuss.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3122#issuecomment-1603164230
Usability,learn,learn,thank you so much for the detailed response @glwagner - that's very helpful - it's a great idea to turn this into a discussion - I'll close this issue - very exited to learn more about Oceananigans (and Veros!),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3126#issuecomment-1572621436
Usability,clear,clearer,"I think it would be clearer to call this ""internal tide"" or ""barotropic tide over seamount"". The point is not the barotropic tide, the point is to showcase the generation of internal waves.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3132#issuecomment-1575762100
Usability,simpl,simple,"> hm... I don't know about a mixed layer...; > ; > let's just ignore the dz(b)=0 at the top&bottom _or_ we can add a remark in the example about it?. Yes definitely ignore. What we want to focus on is providing an example that is a useful starting point for other, new simulations. This is the key priority. This is why it makes sense to prioritize relatively simple examples (and also simple visualization) that can be quickly digested and are amenable to generalization. We want to _deprioritize_ bespoke or niche cases that are a dead-end. For example, if we use `GradientBoundaryCondition` at the top in this case, then most users will have to delete / change that line in order to generalize this example into the case they are interested in using.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3132#issuecomment-1987303814
Usability,clear,clearer,"I like the idea of having the same ""name"" for all grids when it comes to length, number of points, and halos. . Having different descriptors might be a tad clearer but much more of a nuisance. Maybe instead of `x`, `y` and `z` we can generalize the names with `1` `2` and `3` referring to the three directions",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3134#issuecomment-1575643780
Testability,benchmark,benchmark,> What's the point?. Only to benchmark against the examples before you simplified them to see how faster the docs built. The other pr also includes a simpler bci example now.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3139#issuecomment-1583172591
Usability,simpl,simplified,> What's the point?. Only to benchmark against the examples before you simplified them to see how faster the docs built. The other pr also includes a simpler bci example now.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3139#issuecomment-1583172591
Usability,simpl,simpler,"You are passing too many parameters in the `compute!` kernel, unfortunately. GPUs have a limit on the size of the parameters you can pass (4352 bytes, and you are using 4592 bytes). Try to split your computation into simpler abstract trees:; ```; @inline function vector_projection_aaa(i, j, k, grid, ϕˣ, ϕᶻ, params); return @inbounds ϕˣ[i,j,k]*params.xdirection + ϕᶻ[i,j,k]*params.zdirection; end. using Oceananigans.AbstractOperations: ∂x, ∂y, ∂z; u, v, w = model.velocities; dudx_tilt = compute!(Field(∂x(u) + 1e-7)); dudz_tilt = compute!(Field(∂z(u)). using Oceananigans.Grids: Center, Face; dudz_op = KernelFunctionOperation{Center, Center, Face}(vector_projection_aaa, model.grid,; dudx_tilt, dudz_tilt,; (xdirection=0.9,; zdirection=0.1)); dudz = Field(Average(dudz_op, dims=(1,2))); compute!(dudz). ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3140#issuecomment-1581675497
Usability,clear,clear,"Ok, I agree that is a bug if that's how it is implemented. I was responding to this:. > The current implementation of ImmersedBondaryCondition has opposite conventions as FieldBoundaryConditions. which is also true. But I guess there's a miscommunication because it's not clear what ""conventions"" means.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3141#issuecomment-1582815705
Deployability,patch,patches,"ell, ok. I see how using `ImmersedBoundaryCondition` is _convenient_. I disagree that this is a ""better"" model, however. It is an approximate model that leverages (what is hopefully) the thin aspect ratio of your simulation. Note, I don't think these issues are intrinsic to lego topography. In fact, I think this approach could completely fail if we had cut cells, which represents another caveat. The problem is that, when the cell facets are no longer oriented along one of x, y, z, we need to define what a flux across the bottom _means_. Is it a flux normal to the boundary, or is it a flux projected along one of the orthogonal directions? I'm not sure interpreting `ImmersedBoundaryCondition(bottom=flux)` as representing _only_ the vertical component of the bottom flux is sensible, especially when we consider the small scale limit or large eddy simulation or direct numerical simulation. We'll have to discuss that. To elaborate on the details, the geological constraint we have from observations is on the heat flux averaged over large patches of the ocean basin:. $$ Q_\text{obs} \approx \frac{1}{A} \int \boldsymbol{q} \cdot \boldsymbol{n} d A $$. where $A$ is the surface area of the ocean bottom (not the horizontal area). As you have noted, we can reproduce this constraint by applying the flux $Q$ across all upward facing facets. Then the total flux in our model is. $$ Q_\text{model} = \frac{1}{A_h} \int Q_\text{obs} d A_h $$. where $A_h$ is the horizontal area of the ocean basin and $d A_h$ is the horizontal projection of the surface area of the bottom. Clearly we obtain $Q_\text{model} = Q_\text{obs}$ and our goal is achieved. At small scales, this approximate model becomes questionable (but of course, it is also questionable to use a constant heat flux at small scales). Basically, I think that using this convenience actually obscures the true physics. So while it produces the right answer, it leads to confusion about what the observed geological heat flux actually re",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3141#issuecomment-1587736510
Security,expose,expose,"pproach could completely fail if we had cut cells, which represents another caveat. The problem is that, when the cell facets are no longer oriented along one of x, y, z, we need to define what a flux across the bottom _means_. Is it a flux normal to the boundary, or is it a flux projected along one of the orthogonal directions? I'm not sure interpreting `ImmersedBoundaryCondition(bottom=flux)` as representing _only_ the vertical component of the bottom flux is sensible, especially when we consider the small scale limit or large eddy simulation or direct numerical simulation. We'll have to discuss that. To elaborate on the details, the geological constraint we have from observations is on the heat flux averaged over large patches of the ocean basin:. $$ Q_\text{obs} \approx \frac{1}{A} \int \boldsymbol{q} \cdot \boldsymbol{n} d A $$. where $A$ is the surface area of the ocean bottom (not the horizontal area). As you have noted, we can reproduce this constraint by applying the flux $Q$ across all upward facing facets. Then the total flux in our model is. $$ Q_\text{model} = \frac{1}{A_h} \int Q_\text{obs} d A_h $$. where $A_h$ is the horizontal area of the ocean basin and $d A_h$ is the horizontal projection of the surface area of the bottom. Clearly we obtain $Q_\text{model} = Q_\text{obs}$ and our goal is achieved. At small scales, this approximate model becomes questionable (but of course, it is also questionable to use a constant heat flux at small scales). Basically, I think that using this convenience actually obscures the true physics. So while it produces the right answer, it leads to confusion about what the observed geological heat flux actually represents, and the detailed physics of heat flux across irregular boundaries... That said, I take the very important point that the convenience greatly simplifies applying this kind of model at large scales. So I am more convinced that we should expose `ImmersedBoundaryCondition` to users --- despite the dangers...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3141#issuecomment-1587736510
Usability,simpl,simplifies,"pproach could completely fail if we had cut cells, which represents another caveat. The problem is that, when the cell facets are no longer oriented along one of x, y, z, we need to define what a flux across the bottom _means_. Is it a flux normal to the boundary, or is it a flux projected along one of the orthogonal directions? I'm not sure interpreting `ImmersedBoundaryCondition(bottom=flux)` as representing _only_ the vertical component of the bottom flux is sensible, especially when we consider the small scale limit or large eddy simulation or direct numerical simulation. We'll have to discuss that. To elaborate on the details, the geological constraint we have from observations is on the heat flux averaged over large patches of the ocean basin:. $$ Q_\text{obs} \approx \frac{1}{A} \int \boldsymbol{q} \cdot \boldsymbol{n} d A $$. where $A$ is the surface area of the ocean bottom (not the horizontal area). As you have noted, we can reproduce this constraint by applying the flux $Q$ across all upward facing facets. Then the total flux in our model is. $$ Q_\text{model} = \frac{1}{A_h} \int Q_\text{obs} d A_h $$. where $A_h$ is the horizontal area of the ocean basin and $d A_h$ is the horizontal projection of the surface area of the bottom. Clearly we obtain $Q_\text{model} = Q_\text{obs}$ and our goal is achieved. At small scales, this approximate model becomes questionable (but of course, it is also questionable to use a constant heat flux at small scales). Basically, I think that using this convenience actually obscures the true physics. So while it produces the right answer, it leads to confusion about what the observed geological heat flux actually represents, and the detailed physics of heat flux across irregular boundaries... That said, I take the very important point that the convenience greatly simplifies applying this kind of model at large scales. So I am more convinced that we should expose `ImmersedBoundaryCondition` to users --- despite the dangers...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3141#issuecomment-1587736510
Availability,error,error,"in` is. Taking a `RectilinearGrid` and `zspacing` at the `Center` as an example. ---. ### Current behavior for `RectilinearGrid`. Without immersed boundaries, this is pretty straightforward. The call to `zspacings()` dispatches to . https://github.com/CliMA/Oceananigans.jl/blob/56fc69bcb08623424afe25e39ae616c29208095e/src/Grids/rectilinear_grid.jl#L477-L478. which directly accesses the `grid`'s `Δzᵃᵃᶜ` property. The call to `zspacing()` goes through some metaprogramming [here](https://github.com/CliMA/Oceananigans.jl/blob/56fc69bcb08623424afe25e39ae616c29208095e/src/Operators/spacings_and_areas_and_volumes.jl#L247-L269) but ultimately also directly accesses the `grid`'s `Δzᵃᵃᶜ` property here:. https://github.com/CliMA/Oceananigans.jl/blob/56fc69bcb08623424afe25e39ae616c29208095e/src/Operators/spacings_and_areas_and_volumes.jl#L104-L112. ---. ### Current behavior for `ImmersedBoundaryGrid`. For the same grid wrapped around an `ImmersedBoundaryGrid` on `main`, when calling `zspacings()` we get the error at the top comment (`MethodError: no method matching`; which this PR aims to fix). The call to `zspacing()` works the same way as with `RectilinearGrid`, with the exception of an extra dispatch [here](https://github.com/CliMA/Oceananigans.jl/blob/56fc69bcb08623424afe25e39ae616c29208095e/src/ImmersedBoundaries/immersed_grid_metrics.jl#L16-L31). ---. ### Summary of the PR as of this post. This PR is originally trying to fix the issue with `zspacings(::IBG)` simply by adding. ```julia; zspacings(grid::IBG, args...; kwargs...) = zspacings(grid.underlying_grid, args...; kwargs...); ```. If I understand correctly, @glwagner's point is that this is wrong in cases where cells have a fraction of ""wet"" volume and a fraction of ""immersed solid"" volume. (For now the two such cases in sight are `PartialCellBottom` and `CutCellBottom` (for which there's open PR https://github.com/CliMA/Oceananigans.jl/pull/3146).). Again, if I understand correctly, the simple solution would be to red",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-1636851041
Integrability,wrap,wrapped,"in` is. Taking a `RectilinearGrid` and `zspacing` at the `Center` as an example. ---. ### Current behavior for `RectilinearGrid`. Without immersed boundaries, this is pretty straightforward. The call to `zspacings()` dispatches to . https://github.com/CliMA/Oceananigans.jl/blob/56fc69bcb08623424afe25e39ae616c29208095e/src/Grids/rectilinear_grid.jl#L477-L478. which directly accesses the `grid`'s `Δzᵃᵃᶜ` property. The call to `zspacing()` goes through some metaprogramming [here](https://github.com/CliMA/Oceananigans.jl/blob/56fc69bcb08623424afe25e39ae616c29208095e/src/Operators/spacings_and_areas_and_volumes.jl#L247-L269) but ultimately also directly accesses the `grid`'s `Δzᵃᵃᶜ` property here:. https://github.com/CliMA/Oceananigans.jl/blob/56fc69bcb08623424afe25e39ae616c29208095e/src/Operators/spacings_and_areas_and_volumes.jl#L104-L112. ---. ### Current behavior for `ImmersedBoundaryGrid`. For the same grid wrapped around an `ImmersedBoundaryGrid` on `main`, when calling `zspacings()` we get the error at the top comment (`MethodError: no method matching`; which this PR aims to fix). The call to `zspacing()` works the same way as with `RectilinearGrid`, with the exception of an extra dispatch [here](https://github.com/CliMA/Oceananigans.jl/blob/56fc69bcb08623424afe25e39ae616c29208095e/src/ImmersedBoundaries/immersed_grid_metrics.jl#L16-L31). ---. ### Summary of the PR as of this post. This PR is originally trying to fix the issue with `zspacings(::IBG)` simply by adding. ```julia; zspacings(grid::IBG, args...; kwargs...) = zspacings(grid.underlying_grid, args...; kwargs...); ```. If I understand correctly, @glwagner's point is that this is wrong in cases where cells have a fraction of ""wet"" volume and a fraction of ""immersed solid"" volume. (For now the two such cases in sight are `PartialCellBottom` and `CutCellBottom` (for which there's open PR https://github.com/CliMA/Oceananigans.jl/pull/3146).). Again, if I understand correctly, the simple solution would be to red",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-1636851041
Security,access,accesses,"I'm going to try and put some some into this, but I'm a bit unsure of what to do. First, to summarize what the current state on `main` is. Taking a `RectilinearGrid` and `zspacing` at the `Center` as an example. ---. ### Current behavior for `RectilinearGrid`. Without immersed boundaries, this is pretty straightforward. The call to `zspacings()` dispatches to . https://github.com/CliMA/Oceananigans.jl/blob/56fc69bcb08623424afe25e39ae616c29208095e/src/Grids/rectilinear_grid.jl#L477-L478. which directly accesses the `grid`'s `Δzᵃᵃᶜ` property. The call to `zspacing()` goes through some metaprogramming [here](https://github.com/CliMA/Oceananigans.jl/blob/56fc69bcb08623424afe25e39ae616c29208095e/src/Operators/spacings_and_areas_and_volumes.jl#L247-L269) but ultimately also directly accesses the `grid`'s `Δzᵃᵃᶜ` property here:. https://github.com/CliMA/Oceananigans.jl/blob/56fc69bcb08623424afe25e39ae616c29208095e/src/Operators/spacings_and_areas_and_volumes.jl#L104-L112. ---. ### Current behavior for `ImmersedBoundaryGrid`. For the same grid wrapped around an `ImmersedBoundaryGrid` on `main`, when calling `zspacings()` we get the error at the top comment (`MethodError: no method matching`; which this PR aims to fix). The call to `zspacing()` works the same way as with `RectilinearGrid`, with the exception of an extra dispatch [here](https://github.com/CliMA/Oceananigans.jl/blob/56fc69bcb08623424afe25e39ae616c29208095e/src/ImmersedBoundaries/immersed_grid_metrics.jl#L16-L31). ---. ### Summary of the PR as of this post. This PR is originally trying to fix the issue with `zspacings(::IBG)` simply by adding. ```julia; zspacings(grid::IBG, args...; kwargs...) = zspacings(grid.underlying_grid, args...; kwargs...); ```. If I understand correctly, @glwagner's point is that this is wrong in cases where cells have a fraction of ""wet"" volume and a fraction of ""immersed solid"" volume. (For now the two such cases in sight are `PartialCellBottom` and `CutCellBottom` (for which there's o",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-1636851041
Usability,simpl,simply,"ugh some metaprogramming [here](https://github.com/CliMA/Oceananigans.jl/blob/56fc69bcb08623424afe25e39ae616c29208095e/src/Operators/spacings_and_areas_and_volumes.jl#L247-L269) but ultimately also directly accesses the `grid`'s `Δzᵃᵃᶜ` property here:. https://github.com/CliMA/Oceananigans.jl/blob/56fc69bcb08623424afe25e39ae616c29208095e/src/Operators/spacings_and_areas_and_volumes.jl#L104-L112. ---. ### Current behavior for `ImmersedBoundaryGrid`. For the same grid wrapped around an `ImmersedBoundaryGrid` on `main`, when calling `zspacings()` we get the error at the top comment (`MethodError: no method matching`; which this PR aims to fix). The call to `zspacing()` works the same way as with `RectilinearGrid`, with the exception of an extra dispatch [here](https://github.com/CliMA/Oceananigans.jl/blob/56fc69bcb08623424afe25e39ae616c29208095e/src/ImmersedBoundaries/immersed_grid_metrics.jl#L16-L31). ---. ### Summary of the PR as of this post. This PR is originally trying to fix the issue with `zspacings(::IBG)` simply by adding. ```julia; zspacings(grid::IBG, args...; kwargs...) = zspacings(grid.underlying_grid, args...; kwargs...); ```. If I understand correctly, @glwagner's point is that this is wrong in cases where cells have a fraction of ""wet"" volume and a fraction of ""immersed solid"" volume. (For now the two such cases in sight are `PartialCellBottom` and `CutCellBottom` (for which there's open PR https://github.com/CliMA/Oceananigans.jl/pull/3146).). Again, if I understand correctly, the simple solution would be to redirect `zspacings()` calls to. 1. Create a `KernelFunctionOperation` using `zspacing()`, which we know has the correct behavior for all cases; 2. Calculate and collect the values in a Array; 3. Return to user. The main challenge here (imo) is that . - if we wanna keep the user-interface simple (e.g. return a float or a 1D array from calls to `zspacings(::RectilinearGrid)` instead of a `Field` or a 3D array), then we lose consistency (because in t",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-1636851041
Usability,clear,clear,"My take is that I don't think there's a way around the choices I just mentioned in the previous post. To make it ever harder, based on @glwagner's comment I think we also need to discuss what exactly (regardless of format) `zspacings` should return to the user. Taking `PartialGridBottom` as an example, if we're to mimic the internals of the code, then it `zspacings(ibm_grid::IBG)` should return. 1. `zspacings(ibm_grid.underlying_grid)` if `z` is above the immersed boundary; 2. `zspacing(ibm_grid)` if the grid is at the immersed boundary (i.e. if the cell is partially wet, partially immersed); 3. `zspacings(ibm_grid.underlying_grid)` if `z` is fully below/inside the immersed boundary/solid. afaik this is exactly how the code internals work. However, since `zspacings` (and I guess also `zspacing`?) is a user-facing function, it's not clear if this is the best approach. For example, as a user, I wonder why we don't include the space occupied by the solid object when the cell is in the immersed _boundary_, but we do include it fully when the cell is completely inside/below the immersed boundary? In other words, why don't we do:. 1. `zspacings(ibm_grid.underlying_grid)` if `z` is above the immersed boundary; 2. `zspacing(ibm_grid)` if the grid is at the immersed boundary (i.e. if the cell is partially wet, partially immersed); 3. zero. ?. I think this latter option is more consistent (i.e. a solid _never_ counts as ""wet space"") and it makes stuff like offline integrals easier (since `sum(quantity * Δz) / sum(Δz)` will return the correct integral (ignoring x and y)). This is also more in line with the `xgcm` (also SGRID I think) conventions that I'm trying to implement in https://github.com/CliMA/Oceananigans.jl/pull/2652. I'm proposing the name `active_zspacing()` there:. https://github.com/CliMA/Oceananigans.jl/blob/b8b80598fb7250495f0d1925bfb406e15b3305b2/src/Grids/grid_utils.jl#L482-L496. (The main difference there is that the space _outside_ the domain (i.e. halos) al",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-1636853738
Usability,intuit,intuitive,"> If so, then we can have a generic KernelFunctionOperation that returns a 3D array of spacings, and specialize via dispatch wherever possible to return 2D and 1D arrays. Again I think this is a plotting issue and not a spacing issues. The strategy that our plotting extension takes is to drop singleton dimensions:. https://github.com/CliMA/Oceananigans.jl/blob/f2a8fb32251135f9cd9b230e0873f7bc1936f762/ext/OceananigansMakieExt.jl#L69-L83. maybe other approaches will be needed but this seems to be fairly intuitive so far",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-2450514567
Usability,feedback,feedback,"@tomchor Yes! Thanks for catching that. @glwagner Thanks for the feedback! I think I know where to start. Although I may be approaching this from a NetCDF output perspective rather than a plotting perspective, I think the one solution we're discussing should satisfy both needs.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-2450646793
Integrability,interface,interface,"I know it's documented in the code but also: https://github.com/CliMA/Oceananigans.jl/blob/bf04295910ef02ca3d4105bee801070deef99175/src/OutputReaders/field_time_series_reductions.jl#L17. Would something simple like this work?. ```julia; function reduce_4d(spatial_reduction::Function, temporal_reduction::Function, f::Function, fts::FTS4D; dims, kw...); reduced_snapshots = [; spatial_reduction(f, fts[n]; dims=filter(d -> d != 4, dims), kw...); for n in 1:length(fts.times); ]; return temporal_reduction(reduced_snapshots); end; ```. I guess we might want a similar interface to the 3D reductions but this should work for all the reductions in `field_time_series.jl`: `(:sum, :maximum, :minimum, :all, :any, :prod)`. It wouldn't work for things like `median` or `quantile` which need to act on the entire 4D array at once, but maybe these aren't _actually_ reductions?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3144#issuecomment-2322107151
Usability,simpl,simple,"I know it's documented in the code but also: https://github.com/CliMA/Oceananigans.jl/blob/bf04295910ef02ca3d4105bee801070deef99175/src/OutputReaders/field_time_series_reductions.jl#L17. Would something simple like this work?. ```julia; function reduce_4d(spatial_reduction::Function, temporal_reduction::Function, f::Function, fts::FTS4D; dims, kw...); reduced_snapshots = [; spatial_reduction(f, fts[n]; dims=filter(d -> d != 4, dims), kw...); for n in 1:length(fts.times); ]; return temporal_reduction(reduced_snapshots); end; ```. I guess we might want a similar interface to the 3D reductions but this should work for all the reductions in `field_time_series.jl`: `(:sum, :maximum, :minimum, :all, :any, :prod)`. It wouldn't work for things like `median` or `quantile` which need to act on the entire 4D array at once, but maybe these aren't _actually_ reductions?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3144#issuecomment-2322107151
Usability,simpl,simple,Perhaps I should know this but is there a simple summary of why supporting reductions across the 4th dimension are hard?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3144#issuecomment-2322240720
Availability,mask,mask,"Hmm... I guess reductions in the time-dimension should actually return a `Field` rather than a `FieldTimeSeries`. That's different than how reductions for `Field` work, which also return `Field` but with a ""reduced location"", eg called here. https://github.com/CliMA/Oceananigans.jl/blob/3c95e7ee6772a2597e206ae35202500be1ef5b32/src/Fields/field.jl#L710. and defined simply as. https://github.com/CliMA/Oceananigans.jl/blob/3c95e7ee6772a2597e206ae35202500be1ef5b32/src/Fields/field.jl#L629-L635. So maybe there is no special challenge except writing code similar to what we have for `Field` that's specialized for the time-dimension. . Reductions over time + other dimensions might work then, if the further reduction is done over the additional dimensions after the special case is handled that converts from `FieldTimeSeries` to `Field`. `Field`s also support ""conditioning"" the operation (which mostly would probably be used to mask immersed areas). But we won't have a ""time mask"", so I think possibly that doesn't pose any particular problems. . Ok, then if we want to support reductions of `FieldTimeSeries` that _dont_ act on the time dimension, that's where we basically have to replicate everything we have for `Field` I guess. For example if you average a `FieldTimeSeries` in `x` then you get a `FieldTimeSeries` back. That's a bit more annoying but still possible...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3144#issuecomment-2322747097
Energy Efficiency,reduce,reduced,"Hmm... I guess reductions in the time-dimension should actually return a `Field` rather than a `FieldTimeSeries`. That's different than how reductions for `Field` work, which also return `Field` but with a ""reduced location"", eg called here. https://github.com/CliMA/Oceananigans.jl/blob/3c95e7ee6772a2597e206ae35202500be1ef5b32/src/Fields/field.jl#L710. and defined simply as. https://github.com/CliMA/Oceananigans.jl/blob/3c95e7ee6772a2597e206ae35202500be1ef5b32/src/Fields/field.jl#L629-L635. So maybe there is no special challenge except writing code similar to what we have for `Field` that's specialized for the time-dimension. . Reductions over time + other dimensions might work then, if the further reduction is done over the additional dimensions after the special case is handled that converts from `FieldTimeSeries` to `Field`. `Field`s also support ""conditioning"" the operation (which mostly would probably be used to mask immersed areas). But we won't have a ""time mask"", so I think possibly that doesn't pose any particular problems. . Ok, then if we want to support reductions of `FieldTimeSeries` that _dont_ act on the time dimension, that's where we basically have to replicate everything we have for `Field` I guess. For example if you average a `FieldTimeSeries` in `x` then you get a `FieldTimeSeries` back. That's a bit more annoying but still possible...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3144#issuecomment-2322747097
Usability,simpl,simply,"Hmm... I guess reductions in the time-dimension should actually return a `Field` rather than a `FieldTimeSeries`. That's different than how reductions for `Field` work, which also return `Field` but with a ""reduced location"", eg called here. https://github.com/CliMA/Oceananigans.jl/blob/3c95e7ee6772a2597e206ae35202500be1ef5b32/src/Fields/field.jl#L710. and defined simply as. https://github.com/CliMA/Oceananigans.jl/blob/3c95e7ee6772a2597e206ae35202500be1ef5b32/src/Fields/field.jl#L629-L635. So maybe there is no special challenge except writing code similar to what we have for `Field` that's specialized for the time-dimension. . Reductions over time + other dimensions might work then, if the further reduction is done over the additional dimensions after the special case is handled that converts from `FieldTimeSeries` to `Field`. `Field`s also support ""conditioning"" the operation (which mostly would probably be used to mask immersed areas). But we won't have a ""time mask"", so I think possibly that doesn't pose any particular problems. . Ok, then if we want to support reductions of `FieldTimeSeries` that _dont_ act on the time dimension, that's where we basically have to replicate everything we have for `Field` I guess. For example if you average a `FieldTimeSeries` in `x` then you get a `FieldTimeSeries` back. That's a bit more annoying but still possible...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3144#issuecomment-2322747097
Availability,avail,available,"@glwagner @simone-silvestri I took the liberty to modifying the [release notes for v0.84.0](https://github.com/CliMA/Oceananigans.jl/releases/tag/v0.84.0) to illustrate what my idea here was. @glwagner had already included something but I extended it a bit. Basically a user reading the release notes know quickly what changed: `compression` kwarg is gone and is replaced by `deflatelevel` (which also link directly to https://github.com/CliMA/Oceananigans.jl/pull/3153 for more info) and there's a quick summary of changes to `VectorInvariant` also with a link to https://github.com/CliMA/Oceananigans.jl/pull/3091. @simone-silvestri reading the description of https://github.com/CliMA/Oceananigans.jl/pull/3091 I couldn't understand what was breaking about that change. Seems like it just added more features/kwargs, with isn't necessarily breaking. Feel free to modify my description to clairfy. I also included a ""highlights"" section, which quickly points to a user what new features are available. At this point it only references to https://github.com/CliMA/Oceananigans.jl/pull/3145, but I think https://github.com/CliMA/Oceananigans.jl/pull/3145 probably should be there too; I just don't understand it well enough to be sure and summarize everything with a simple sentence. Feel free to add. This ""highlights"" section may be a bit repetitive, since similar information is contained in the list of PRs at the bottom. But my rationale is that most of those PRs don't really affect an average user (for example the doc examples parallelization is super important, but not relevant to users), so most people probably won't read their description. In any case, feel free to modify or undo what I wrote there. I did it mostly for illustration purposes :)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3147#issuecomment-1613894754
Deployability,release,release,"@glwagner @simone-silvestri I took the liberty to modifying the [release notes for v0.84.0](https://github.com/CliMA/Oceananigans.jl/releases/tag/v0.84.0) to illustrate what my idea here was. @glwagner had already included something but I extended it a bit. Basically a user reading the release notes know quickly what changed: `compression` kwarg is gone and is replaced by `deflatelevel` (which also link directly to https://github.com/CliMA/Oceananigans.jl/pull/3153 for more info) and there's a quick summary of changes to `VectorInvariant` also with a link to https://github.com/CliMA/Oceananigans.jl/pull/3091. @simone-silvestri reading the description of https://github.com/CliMA/Oceananigans.jl/pull/3091 I couldn't understand what was breaking about that change. Seems like it just added more features/kwargs, with isn't necessarily breaking. Feel free to modify my description to clairfy. I also included a ""highlights"" section, which quickly points to a user what new features are available. At this point it only references to https://github.com/CliMA/Oceananigans.jl/pull/3145, but I think https://github.com/CliMA/Oceananigans.jl/pull/3145 probably should be there too; I just don't understand it well enough to be sure and summarize everything with a simple sentence. Feel free to add. This ""highlights"" section may be a bit repetitive, since similar information is contained in the list of PRs at the bottom. But my rationale is that most of those PRs don't really affect an average user (for example the doc examples parallelization is super important, but not relevant to users), so most people probably won't read their description. In any case, feel free to modify or undo what I wrote there. I did it mostly for illustration purposes :)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3147#issuecomment-1613894754
Modifiability,extend,extended,"@glwagner @simone-silvestri I took the liberty to modifying the [release notes for v0.84.0](https://github.com/CliMA/Oceananigans.jl/releases/tag/v0.84.0) to illustrate what my idea here was. @glwagner had already included something but I extended it a bit. Basically a user reading the release notes know quickly what changed: `compression` kwarg is gone and is replaced by `deflatelevel` (which also link directly to https://github.com/CliMA/Oceananigans.jl/pull/3153 for more info) and there's a quick summary of changes to `VectorInvariant` also with a link to https://github.com/CliMA/Oceananigans.jl/pull/3091. @simone-silvestri reading the description of https://github.com/CliMA/Oceananigans.jl/pull/3091 I couldn't understand what was breaking about that change. Seems like it just added more features/kwargs, with isn't necessarily breaking. Feel free to modify my description to clairfy. I also included a ""highlights"" section, which quickly points to a user what new features are available. At this point it only references to https://github.com/CliMA/Oceananigans.jl/pull/3145, but I think https://github.com/CliMA/Oceananigans.jl/pull/3145 probably should be there too; I just don't understand it well enough to be sure and summarize everything with a simple sentence. Feel free to add. This ""highlights"" section may be a bit repetitive, since similar information is contained in the list of PRs at the bottom. But my rationale is that most of those PRs don't really affect an average user (for example the doc examples parallelization is super important, but not relevant to users), so most people probably won't read their description. In any case, feel free to modify or undo what I wrote there. I did it mostly for illustration purposes :)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3147#issuecomment-1613894754
Usability,simpl,simple,"@glwagner @simone-silvestri I took the liberty to modifying the [release notes for v0.84.0](https://github.com/CliMA/Oceananigans.jl/releases/tag/v0.84.0) to illustrate what my idea here was. @glwagner had already included something but I extended it a bit. Basically a user reading the release notes know quickly what changed: `compression` kwarg is gone and is replaced by `deflatelevel` (which also link directly to https://github.com/CliMA/Oceananigans.jl/pull/3153 for more info) and there's a quick summary of changes to `VectorInvariant` also with a link to https://github.com/CliMA/Oceananigans.jl/pull/3091. @simone-silvestri reading the description of https://github.com/CliMA/Oceananigans.jl/pull/3091 I couldn't understand what was breaking about that change. Seems like it just added more features/kwargs, with isn't necessarily breaking. Feel free to modify my description to clairfy. I also included a ""highlights"" section, which quickly points to a user what new features are available. At this point it only references to https://github.com/CliMA/Oceananigans.jl/pull/3145, but I think https://github.com/CliMA/Oceananigans.jl/pull/3145 probably should be there too; I just don't understand it well enough to be sure and summarize everything with a simple sentence. Feel free to add. This ""highlights"" section may be a bit repetitive, since similar information is contained in the list of PRs at the bottom. But my rationale is that most of those PRs don't really affect an average user (for example the doc examples parallelization is super important, but not relevant to users), so most people probably won't read their description. In any case, feel free to modify or undo what I wrote there. I did it mostly for illustration purposes :)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3147#issuecomment-1613894754
Usability,simpl,simply,"I agree, it seems best simply to add drag to the internal tide example for the time being.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3148#issuecomment-1599991092
Integrability,depend,dependence,"And right, for thin aspect ratios (H/L << 1), we typically neglect the dependence on `w` for two reasons: (1) `w` is small (eg `w ~ u * H/L`), and (2) `w` is non-zero only on side-walls, which make a negligible contribution to the overall flux, because side-wall areas are O(H/L) smaller than vertical-normal areas. For this example, we can either use a hydrostatic-specific drag, or we can use a more general formulation and comment on how it could be simplified using an assumption of thin-aspect ratio (which is also the basis for the hydrostatic approximation). In the context of Oceananigans, it turns out to be _simpler_ to specify a 3D drag. So the ""simplification"" for thin-aspect ratio isn't as important as it is, for example, for analytical / theoretical calculations.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3148#issuecomment-1607565370
Usability,simpl,simplified,"And right, for thin aspect ratios (H/L << 1), we typically neglect the dependence on `w` for two reasons: (1) `w` is small (eg `w ~ u * H/L`), and (2) `w` is non-zero only on side-walls, which make a negligible contribution to the overall flux, because side-wall areas are O(H/L) smaller than vertical-normal areas. For this example, we can either use a hydrostatic-specific drag, or we can use a more general formulation and comment on how it could be simplified using an assumption of thin-aspect ratio (which is also the basis for the hydrostatic approximation). In the context of Oceananigans, it turns out to be _simpler_ to specify a 3D drag. So the ""simplification"" for thin-aspect ratio isn't as important as it is, for example, for analytical / theoretical calculations.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3148#issuecomment-1607565370
Security,access,access,"Thanks, everyone. I agree with the major points here. To answer some specific comments:. > Btw, when I am doing small exploratory runs I only need to ""pay compilation time"" once per model. Constructing another model in the same REPL session doesn't have any extra compilation costs unless I change something in the source code (Oceananigans source code; node my scripts). This is mostly because the majority of my exploratory runs are run in the GPU, and since I have limited GPU time I try to not leave interactive GPU sessions open. If I unlimited access to a GPU (or in the cases where I can explore on the CPU), then I agree with your point. > I agree with Navid, it is better to have a more complicated script for cases this specific than a complicated source code. Again, agree. I posted this more because, if this was something a lot of other people were doing, it might be worth to maintain the infrastructure. But since it sounds like that's not the case, then I agree it's best to have complex user scripts and keep the source code simple. > Does @navidcy's suggestion work for you @tomchor ?. Yes, thanks for the suggestion @navidcy. I think this is the next best thing. The one disadvantage for me is that is ""wastes"" computation advecting tracers in the spin-up, but it has the huge advantage of keeping the source code simple, with also a readable user script.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3154#issuecomment-1606169386
Usability,simpl,simple,"Thanks, everyone. I agree with the major points here. To answer some specific comments:. > Btw, when I am doing small exploratory runs I only need to ""pay compilation time"" once per model. Constructing another model in the same REPL session doesn't have any extra compilation costs unless I change something in the source code (Oceananigans source code; node my scripts). This is mostly because the majority of my exploratory runs are run in the GPU, and since I have limited GPU time I try to not leave interactive GPU sessions open. If I unlimited access to a GPU (or in the cases where I can explore on the CPU), then I agree with your point. > I agree with Navid, it is better to have a more complicated script for cases this specific than a complicated source code. Again, agree. I posted this more because, if this was something a lot of other people were doing, it might be worth to maintain the infrastructure. But since it sounds like that's not the case, then I agree it's best to have complex user scripts and keep the source code simple. > Does @navidcy's suggestion work for you @tomchor ?. Yes, thanks for the suggestion @navidcy. I think this is the next best thing. The one disadvantage for me is that is ""wastes"" computation advecting tracers in the spin-up, but it has the huge advantage of keeping the source code simple, with also a readable user script.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3154#issuecomment-1606169386
Availability,down,down,"By ""mutable"" function you mean one that modifies its args? But don't they all return nothing?. Seems you are getting down to the bottom it yourself... Perhaps try writing a simple code of your own then and running the debugger there? E.g. ```julia; function my_own_function!(a); a = 2a; return nothing; end. a = 17. my_own_function!(a). b = 10a; ```. or something like that and see if you get the same error?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3171#issuecomment-1616937963
Usability,simpl,simple,"By ""mutable"" function you mean one that modifies its args? But don't they all return nothing?. Seems you are getting down to the bottom it yourself... Perhaps try writing a simple code of your own then and running the debugger there? E.g. ```julia; function my_own_function!(a); a = 2a; return nothing; end. a = 17. my_own_function!(a). b = 10a; ```. or something like that and see if you get the same error?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3171#issuecomment-1616937963
Usability,feedback,feedback,thank you for replying - I've never tried the debugger on any package that uses KernelAbstractions. I've opened an issue on the julia-vscode extension github repo (linked above) - I'll open an issue on the KernelAbstractions github repo to get their feedback. thank you for helping me - I'll spend some more time on this,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3171#issuecomment-1622057678
Availability,error,error,"Ok, can you reproduce the error by trying to loop over a simple kernel that returns `nothing` using `KernelAbstractions`?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3171#issuecomment-1624165878
Usability,simpl,simple,"Ok, can you reproduce the error by trying to loop over a simple kernel that returns `nothing` using `KernelAbstractions`?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3171#issuecomment-1624165878
Availability,mainten,maintenance,"I would like to start working on this. Note that in terms of maintenance burden, the docs already depend extensively on plotting. So I'm not sure a plotting extension will increase CI significantly. On the contrary we can start with a minimalist approach that simply uses the examples to test the functionality in the extension. I'd like to discuss design before starting. I think the basic functionality we need is to support automatically plotting of 2D fields. Basically we want to be able to write `heatmap!(ax, c)` and have it work automatically, eg if `c` is two-dimensional, then the non-trivial dimensions are automatically detected and appropriate node values inserted. I think this should work even if the dimensions are not `Flat`, so basically we just want to take a look at `size(c)`. We can also support `lines!` and `scatter!` and `scatterlines!` for 1D fields. Is there a streamlined way to do this for all situations, or do we need to add support for each method like `heatmap!`, `contour!`, `contourf!`, etc, individually?. A second question is how to support inspection of 3D fields. I think this is pretty hard. @Sbozzolo has some experience with this so he might have some valuable input.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3178#issuecomment-2271718591
Integrability,depend,depend,"I would like to start working on this. Note that in terms of maintenance burden, the docs already depend extensively on plotting. So I'm not sure a plotting extension will increase CI significantly. On the contrary we can start with a minimalist approach that simply uses the examples to test the functionality in the extension. I'd like to discuss design before starting. I think the basic functionality we need is to support automatically plotting of 2D fields. Basically we want to be able to write `heatmap!(ax, c)` and have it work automatically, eg if `c` is two-dimensional, then the non-trivial dimensions are automatically detected and appropriate node values inserted. I think this should work even if the dimensions are not `Flat`, so basically we just want to take a look at `size(c)`. We can also support `lines!` and `scatter!` and `scatterlines!` for 1D fields. Is there a streamlined way to do this for all situations, or do we need to add support for each method like `heatmap!`, `contour!`, `contourf!`, etc, individually?. A second question is how to support inspection of 3D fields. I think this is pretty hard. @Sbozzolo has some experience with this so he might have some valuable input.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3178#issuecomment-2271718591
Safety,detect,detected,"I would like to start working on this. Note that in terms of maintenance burden, the docs already depend extensively on plotting. So I'm not sure a plotting extension will increase CI significantly. On the contrary we can start with a minimalist approach that simply uses the examples to test the functionality in the extension. I'd like to discuss design before starting. I think the basic functionality we need is to support automatically plotting of 2D fields. Basically we want to be able to write `heatmap!(ax, c)` and have it work automatically, eg if `c` is two-dimensional, then the non-trivial dimensions are automatically detected and appropriate node values inserted. I think this should work even if the dimensions are not `Flat`, so basically we just want to take a look at `size(c)`. We can also support `lines!` and `scatter!` and `scatterlines!` for 1D fields. Is there a streamlined way to do this for all situations, or do we need to add support for each method like `heatmap!`, `contour!`, `contourf!`, etc, individually?. A second question is how to support inspection of 3D fields. I think this is pretty hard. @Sbozzolo has some experience with this so he might have some valuable input.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3178#issuecomment-2271718591
Testability,test,test,"I would like to start working on this. Note that in terms of maintenance burden, the docs already depend extensively on plotting. So I'm not sure a plotting extension will increase CI significantly. On the contrary we can start with a minimalist approach that simply uses the examples to test the functionality in the extension. I'd like to discuss design before starting. I think the basic functionality we need is to support automatically plotting of 2D fields. Basically we want to be able to write `heatmap!(ax, c)` and have it work automatically, eg if `c` is two-dimensional, then the non-trivial dimensions are automatically detected and appropriate node values inserted. I think this should work even if the dimensions are not `Flat`, so basically we just want to take a look at `size(c)`. We can also support `lines!` and `scatter!` and `scatterlines!` for 1D fields. Is there a streamlined way to do this for all situations, or do we need to add support for each method like `heatmap!`, `contour!`, `contourf!`, etc, individually?. A second question is how to support inspection of 3D fields. I think this is pretty hard. @Sbozzolo has some experience with this so he might have some valuable input.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3178#issuecomment-2271718591
Usability,simpl,simply,"I would like to start working on this. Note that in terms of maintenance burden, the docs already depend extensively on plotting. So I'm not sure a plotting extension will increase CI significantly. On the contrary we can start with a minimalist approach that simply uses the examples to test the functionality in the extension. I'd like to discuss design before starting. I think the basic functionality we need is to support automatically plotting of 2D fields. Basically we want to be able to write `heatmap!(ax, c)` and have it work automatically, eg if `c` is two-dimensional, then the non-trivial dimensions are automatically detected and appropriate node values inserted. I think this should work even if the dimensions are not `Flat`, so basically we just want to take a look at `size(c)`. We can also support `lines!` and `scatter!` and `scatterlines!` for 1D fields. Is there a streamlined way to do this for all situations, or do we need to add support for each method like `heatmap!`, `contour!`, `contourf!`, etc, individually?. A second question is how to support inspection of 3D fields. I think this is pretty hard. @Sbozzolo has some experience with this so he might have some valuable input.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3178#issuecomment-2271718591
Usability,simpl,simple,"My understanding is that you can write `convert_arguments` methods and then all the different plot types just work, for example (obviously not what you'd want in a finished extension but just as a simple example):; ```julia; using CairoMakie . import MakieCore: convert_arguments. convert_arguments(P::Type{<:AbstractPlot}, f::Field) = convert_arguments(P, xnodes(f), ynodes(f), interior(f, :, :, 1)). fig = Figure(); ax = Axis(fig[1, 1]); heatmap!(ax, c); ```; correctly plots the bottom level of a field `c` and puts the `x` and `y` axes in. I think you can pass other arguments too like:; ```julia; convert_arguments(P::Type{<:AbstractPlot}, f::Field, indices = (:, :, 1)) = convert_arguments(P, xnodes(f)[indices[1]], ynodes(f)[indices[2]], interior(f, indices...)); heatmap!(ax, c, (1:10, :, 1)); ```. so you could deal with slicing up 3D fields that way?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3178#issuecomment-2272112363
Integrability,depend,depends,"This is an ok idea but the warning really needs to be better. It isn't clear who is ""recommending"" what; also it doesn't really make sense because the CFL depends on the time stepping method and in principle, someone can use `TimeStepWizard` with any time stepper (for example there are models external to Oceananigans that use the `Simulation`). Presumably 0.8 is some rule of thumb for RK3. Note that we envision moving `Simulation` to an external package eventually, where it could be used by other models (eg atmospheric models). Since ClimaAtmos supports all sorts of time-steppers, I'm not sure this ""recommendation"" would continue to make sense. So I'm a little skeptical about how this is put together. You could write something like ""When using 3rd order Runge-Kutta time-stepping, a time-step that produces a CFL number `cfl > sqrt(3) ≈ 1.7` is unconditionally unstable. As a rule of thumb, we recommend using time-steps that lie well within the realm of stability: for a 3rd order Runge-Kutta scheme, for example, we recommend `cfl < 0.8`. For an Adams-Bashforth scheme, which requires `cfl < XX` for stability, we recommend `cfl < 0.2`. Other time-stepping methods have different stability constraints. For more information see [a reference].""",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3183#issuecomment-1637706893
Usability,clear,clear,"This is an ok idea but the warning really needs to be better. It isn't clear who is ""recommending"" what; also it doesn't really make sense because the CFL depends on the time stepping method and in principle, someone can use `TimeStepWizard` with any time stepper (for example there are models external to Oceananigans that use the `Simulation`). Presumably 0.8 is some rule of thumb for RK3. Note that we envision moving `Simulation` to an external package eventually, where it could be used by other models (eg atmospheric models). Since ClimaAtmos supports all sorts of time-steppers, I'm not sure this ""recommendation"" would continue to make sense. So I'm a little skeptical about how this is put together. You could write something like ""When using 3rd order Runge-Kutta time-stepping, a time-step that produces a CFL number `cfl > sqrt(3) ≈ 1.7` is unconditionally unstable. As a rule of thumb, we recommend using time-steps that lie well within the realm of stability: for a 3rd order Runge-Kutta scheme, for example, we recommend `cfl < 0.8`. For an Adams-Bashforth scheme, which requires `cfl < XX` for stability, we recommend `cfl < 0.2`. Other time-stepping methods have different stability constraints. For more information see [a reference].""",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3183#issuecomment-1637706893
Usability,simpl,simple,"> @xkykai I propose the following to move forward, let me know what you think:; > ; > 1. Change the names a bit because technically, ImmersedPoissonSolver can be used as a general Poisson solver that works even on a lat lon grid. I think just `ConjugateGradientPoissonSolver` is good.; > ; > 2. Make it default to an FFT-based preconditioner when possible, and otherwise to the ""diagonally dominant preconditioner""; > ; > 3. Since I feel we don't want to drop this just yet, let's not make it the default yet. However, I will put a note in the warning that currently accompanies NonhydrostaticModel on ImmersedBoundaryGrid about the possibility of using it. I agree with all 3 points. One thing that I think would be useful is to come up with one example to put in the docs about the choices of preconditioners and how to use it. We can perhaps use a simple example of a staircase convection to illustrate the point, advertising the FFT-preconditioned solver at the same time as well. Currently there's no section about solver choices, and I suspect some users (me included) might not have been aware that different solver choices could be made. I'd be happy to put together the example case. > It keeps tripping me up that NonhydrostaticModel calls it a ""pressure solver"" but everywhere else we use the term ""Poisson solver"". Should we call it `NonhydrostaticModel.poisson_solver`?. Of course! It doesn't only solve the pressure",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3188#issuecomment-2377469350
Usability,simpl,simple,"> One thing that I think would be useful is to come up with one example to put in the docs about the choices of preconditioners and how to use it. We can perhaps use a simple example of a staircase convection to illustrate the point, advertising the FFT-preconditioned solver at the same time as well. I like this idea though I am not sure it should be an example. There are no other examples like that. We are sort of in the process of revamping the docs to add more ""tutorials"". For example, this is a tutorial on grids: https://clima.github.io/OceananigansDocumentation/stable/grids/. I think what you're proposing is a ""tutorial"" on pressure solvers. What do you think?. I think we probably should wait though. It'd be nice to publish a paper about the solver first, and then put what we learned from the paper into the tutorial.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3188#issuecomment-2377809861
Usability,learn,learnt,"> I think what you're proposing is a ""tutorial"" on pressure solvers. What do you think?. Yes I think a tutorial is what I meant. We can do this after the paper is done so we encapsulate what we have learnt.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3188#issuecomment-2377862921
Integrability,message,message,"> Something seemed to change with 0.81.1; > ; > <img alt=""image"" width=""928"" src=""https://user-images.githubusercontent.com/15271942/266183487-81cae28b-12ee-480f-b40c-1502701b97d5.png"">. That's because oftentimes I had to manually clear up the repo. That would imply creating an orphan branch and copying and committing all content back to this new orphan branch, force push, and then rename it to `gh-pages`. So the ""v0.8*"" is a manual commit message I had written while committing contents of `gh-pages` to the new orphan branch while the messages ""build based on ..."" are the automated commit messages by Documenter.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3191#issuecomment-1711358161
Usability,clear,clear,"> Something seemed to change with 0.81.1; > ; > <img alt=""image"" width=""928"" src=""https://user-images.githubusercontent.com/15271942/266183487-81cae28b-12ee-480f-b40c-1502701b97d5.png"">. That's because oftentimes I had to manually clear up the repo. That would imply creating an orphan branch and copying and committing all content back to this new orphan branch, force push, and then rename it to `gh-pages`. So the ""v0.8*"" is a manual commit message I had written while committing contents of `gh-pages` to the new orphan branch while the messages ""build based on ..."" are the automated commit messages by Documenter.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3191#issuecomment-1711358161
Usability,clear,clear,"Thank you for your reply! And apologies for have not been clear.; Firstly, we want to simulate a ""half-channel flow"", so we only use no-slip boundary condition at the bottom. Secondly, we have used periodic boundary condition in x (streamwise) and y (crosswise) direction.; Finally, in this case the z-axis is range from -15 to 0, so I can't use ``` const z₁ = -1*znodes(Center,grid)[1] ``` because if I do that, the value of z1 will change to 14.88. My code ``` const z₁ = -1*znodes(Center,grid)[grid.Nz] ``` will keep z1 equals to Closest grid center to the bottom (0.12).; Everything seems right, but the result seems strange!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3195#issuecomment-1648882721
Safety,predict,predicted," have met some strange things in a simple channel flow case, the velocity profile is larger than the log-low profile, and the momentum flux of the second and third points are obviously lower than bottom boundary condition (or other point near the bottom boundary). The code is written below, what causes this difference? ![u_profile (2)](https://user-images.githubusercontent.com/117068415/255586911-14e2c865-ec3b-4065-a13a-213a99257d31.png) ![uw_flux (1)](https://user-images.githubusercontent.com/117068415/255630762-1cd16836-6f59-465b-8d02-0577052b52ba.png); > ; > ```julia; > const H=15 #/m; > grid = RectilinearGrid(GPU(),size=(64,64,64), extent=(π*H, π*H, H)); > const u★=0.01 #friction velocity; > Fx(x,y,z,t)=u★^2/H #forcing; > ; > const z₀ = H*1e-4 # m (roughness length); > const κ = 0.4 # von Karman constant; > const z₁ = -1*znodes(Center,grid)[grid.Nz] # Closest grid center to the bottom; > const cᴰᵇ = (κ / log(z₁ / z₀))^2 # Drag coefficient; > ; > @inline drag_u(x, y, t, u, v, p) = - p.cᴰᵇ * √(u^2 + v^2) * (u); > @inline drag_v(x, y, t, u, v, p) = - p.cᴰᵇ * √(u^2 + v^2) * (v); > ; > drag_bc_u = FluxBoundaryCondition(drag_u, field_dependencies=(:u, :v), parameters=(; cᴰᵇ)); > drag_bc_v = FluxBoundaryCondition(drag_v, field_dependencies=(:u, :v), parameters=(; cᴰᵇ)); > ; > u_bcs = FieldBoundaryConditions(top=FluxBoundaryCondition(0.0),bottom = drag_bc_u); > v_bcs = FieldBoundaryConditions(bottom = drag_bc_v); > ; > model = NonhydrostaticModel(; grid, coriolis,; > advection = WENO(),; > timestepper = :RungeKutta3,; > tracers =(:T,:S),; > buoyancy = SeawaterBuoyancy(),; > closure = AnisotropicMinimumDissipation(),; > boundary_conditions = (u=u_bcs,v=v_bcs,T=T_bcs,S=S_bcs),; > forcing=(u=Fx,)); > ```. I also have the same problem here. I am trying to simulate the neutral turbulent boundary layer here. However, I found that the velocity shear at the first grid points is much larger than that predicted by the Monin-Obukhov similarity theory. Any ideas? @glwagner @tomchor",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3195#issuecomment-1649204834
Testability,log,log-low,"> Hi all, I have met some strange things in a simple channel flow case, the velocity profile is larger than the log-low profile, and the momentum flux of the second and third points are obviously lower than bottom boundary condition (or other point near the bottom boundary). The code is written below, what causes this difference? ![u_profile (2)](https://user-images.githubusercontent.com/117068415/255586911-14e2c865-ec3b-4065-a13a-213a99257d31.png) ![uw_flux (1)](https://user-images.githubusercontent.com/117068415/255630762-1cd16836-6f59-465b-8d02-0577052b52ba.png); > ; > ```julia; > const H=15 #/m; > grid = RectilinearGrid(GPU(),size=(64,64,64), extent=(π*H, π*H, H)); > const u★=0.01 #friction velocity; > Fx(x,y,z,t)=u★^2/H #forcing; > ; > const z₀ = H*1e-4 # m (roughness length); > const κ = 0.4 # von Karman constant; > const z₁ = -1*znodes(Center,grid)[grid.Nz] # Closest grid center to the bottom; > const cᴰᵇ = (κ / log(z₁ / z₀))^2 # Drag coefficient; > ; > @inline drag_u(x, y, t, u, v, p) = - p.cᴰᵇ * √(u^2 + v^2) * (u); > @inline drag_v(x, y, t, u, v, p) = - p.cᴰᵇ * √(u^2 + v^2) * (v); > ; > drag_bc_u = FluxBoundaryCondition(drag_u, field_dependencies=(:u, :v), parameters=(; cᴰᵇ)); > drag_bc_v = FluxBoundaryCondition(drag_v, field_dependencies=(:u, :v), parameters=(; cᴰᵇ)); > ; > u_bcs = FieldBoundaryConditions(top=FluxBoundaryCondition(0.0),bottom = drag_bc_u); > v_bcs = FieldBoundaryConditions(bottom = drag_bc_v); > ; > model = NonhydrostaticModel(; grid, coriolis,; > advection = WENO(),; > timestepper = :RungeKutta3,; > tracers =(:T,:S),; > buoyancy = SeawaterBuoyancy(),; > closure = AnisotropicMinimumDissipation(),; > boundary_conditions = (u=u_bcs,v=v_bcs,T=T_bcs,S=S_bcs),; > forcing=(u=Fx,)); > ```. I also have the same problem here. I am trying to simulate the neutral turbulent boundary layer here. However, I found that the velocity shear at the first grid points is much larger than that predicted by the Monin-Obukhov similarity theory. Any ideas? @glwagne",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3195#issuecomment-1649204834
Usability,simpl,simple,"> Hi all, I have met some strange things in a simple channel flow case, the velocity profile is larger than the log-low profile, and the momentum flux of the second and third points are obviously lower than bottom boundary condition (or other point near the bottom boundary). The code is written below, what causes this difference? ![u_profile (2)](https://user-images.githubusercontent.com/117068415/255586911-14e2c865-ec3b-4065-a13a-213a99257d31.png) ![uw_flux (1)](https://user-images.githubusercontent.com/117068415/255630762-1cd16836-6f59-465b-8d02-0577052b52ba.png); > ; > ```julia; > const H=15 #/m; > grid = RectilinearGrid(GPU(),size=(64,64,64), extent=(π*H, π*H, H)); > const u★=0.01 #friction velocity; > Fx(x,y,z,t)=u★^2/H #forcing; > ; > const z₀ = H*1e-4 # m (roughness length); > const κ = 0.4 # von Karman constant; > const z₁ = -1*znodes(Center,grid)[grid.Nz] # Closest grid center to the bottom; > const cᴰᵇ = (κ / log(z₁ / z₀))^2 # Drag coefficient; > ; > @inline drag_u(x, y, t, u, v, p) = - p.cᴰᵇ * √(u^2 + v^2) * (u); > @inline drag_v(x, y, t, u, v, p) = - p.cᴰᵇ * √(u^2 + v^2) * (v); > ; > drag_bc_u = FluxBoundaryCondition(drag_u, field_dependencies=(:u, :v), parameters=(; cᴰᵇ)); > drag_bc_v = FluxBoundaryCondition(drag_v, field_dependencies=(:u, :v), parameters=(; cᴰᵇ)); > ; > u_bcs = FieldBoundaryConditions(top=FluxBoundaryCondition(0.0),bottom = drag_bc_u); > v_bcs = FieldBoundaryConditions(bottom = drag_bc_v); > ; > model = NonhydrostaticModel(; grid, coriolis,; > advection = WENO(),; > timestepper = :RungeKutta3,; > tracers =(:T,:S),; > buoyancy = SeawaterBuoyancy(),; > closure = AnisotropicMinimumDissipation(),; > boundary_conditions = (u=u_bcs,v=v_bcs,T=T_bcs,S=S_bcs),; > forcing=(u=Fx,)); > ```. I also have the same problem here. I am trying to simulate the neutral turbulent boundary layer here. However, I found that the velocity shear at the first grid points is much larger than that predicted by the Monin-Obukhov similarity theory. Any ideas? @glwagne",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3195#issuecomment-1649204834
Availability,robust,robust,"Here are a couple of comments that come to mind when looking at your code. 1. You're using a call to `znodes(Center,grid)`, which indicates that you're using an out-of-date version of the code. I suggest you update the code to the latest version and then try again. It's good to always keep your code up-to-date (especially when posting here) because the code is always being improved upon (and in some instances some bugs get fixed which may be important to your example!). 2. That said, about this:. > Finally, in this case the z-axis is range from -15 to 0, so I can't use `const z₁ = -1*znodes(Center,grid)[1]` because if I do that, the value of z1 will change to 14.88. My code `const z₁ = -1*znodes(Center,grid)[grid.Nz]` will keep z1 equals to Closest grid center to the bottom (0.12). This isn't the best way to define $z_1$. The current statement will break if you, for example, decide to stretch the grid vertically. The more robust way to define $z_1$ is. ```julia; julia> grid = RectilinearGrid(CPU(), size=(64,64,64), extent=(π*H, π*H, H)); 64×64×64 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── Periodic x ∈ [1.54466e-16, 47.1239) regularly spaced with Δx=0.736311; ├── Periodic y ∈ [1.54466e-16, 47.1239) regularly spaced with Δy=0.736311; └── Bounded z ∈ [-15.0, 0.0] regularly spaced with Δz=0.234375. julia> using Oceananigans.Grids: zspacing. julia> zspacing(1, 1, 1, grid, Center(), Center(), Center())/2 # Half the distance around a center point; 0.1171875; ```. This is clearer, and will give you the correct value even if you change the grid in the future. Note that in the call to `zspacing()` above, we need to specify the x, y and z positions to get the spacing, but in a `RectilinearGrid` Δz is constant in x and y so those arguments don't really matter. Also note that the code above is written for the most recent Oceananigans version (for which you'll need Julia 1.9). 3. Now to your main point (sorry for the tangents! :grimacing:), I",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3195#issuecomment-1649999408
Deployability,update,update,"Here are a couple of comments that come to mind when looking at your code. 1. You're using a call to `znodes(Center,grid)`, which indicates that you're using an out-of-date version of the code. I suggest you update the code to the latest version and then try again. It's good to always keep your code up-to-date (especially when posting here) because the code is always being improved upon (and in some instances some bugs get fixed which may be important to your example!). 2. That said, about this:. > Finally, in this case the z-axis is range from -15 to 0, so I can't use `const z₁ = -1*znodes(Center,grid)[1]` because if I do that, the value of z1 will change to 14.88. My code `const z₁ = -1*znodes(Center,grid)[grid.Nz]` will keep z1 equals to Closest grid center to the bottom (0.12). This isn't the best way to define $z_1$. The current statement will break if you, for example, decide to stretch the grid vertically. The more robust way to define $z_1$ is. ```julia; julia> grid = RectilinearGrid(CPU(), size=(64,64,64), extent=(π*H, π*H, H)); 64×64×64 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── Periodic x ∈ [1.54466e-16, 47.1239) regularly spaced with Δx=0.736311; ├── Periodic y ∈ [1.54466e-16, 47.1239) regularly spaced with Δy=0.736311; └── Bounded z ∈ [-15.0, 0.0] regularly spaced with Δz=0.234375. julia> using Oceananigans.Grids: zspacing. julia> zspacing(1, 1, 1, grid, Center(), Center(), Center())/2 # Half the distance around a center point; 0.1171875; ```. This is clearer, and will give you the correct value even if you change the grid in the future. Note that in the call to `zspacing()` above, we need to specify the x, y and z positions to get the spacing, but in a `RectilinearGrid` Δz is constant in x and y so those arguments don't really matter. Also note that the code above is written for the most recent Oceananigans version (for which you'll need Julia 1.9). 3. Now to your main point (sorry for the tangents! :grimacing:), I",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3195#issuecomment-1649999408
Testability,test,test,"rGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── Periodic x ∈ [1.54466e-16, 47.1239) regularly spaced with Δx=0.736311; ├── Periodic y ∈ [1.54466e-16, 47.1239) regularly spaced with Δy=0.736311; └── Bounded z ∈ [-15.0, 0.0] regularly spaced with Δz=0.234375. julia> using Oceananigans.Grids: zspacing. julia> zspacing(1, 1, 1, grid, Center(), Center(), Center())/2 # Half the distance around a center point; 0.1171875; ```. This is clearer, and will give you the correct value even if you change the grid in the future. Note that in the call to `zspacing()` above, we need to specify the x, y and z positions to get the spacing, but in a `RectilinearGrid` Δz is constant in x and y so those arguments don't really matter. Also note that the code above is written for the most recent Oceananigans version (for which you'll need Julia 1.9). 3. Now to your main point (sorry for the tangents! :grimacing:), I don't see anything obviously wrong with the code. Just from looking at it, it looks like it _should_ work. (Btw, when I say that, I assume this is a _only snippet, and not the full-code_, since I get errors when I try to run your code (`coriolis`, `T_bcs` and `S_bcs` aren't defined, `Fx` looks like it'd cause an error, etc.), so I haven't been able to properly run and test your snippet.). That said, there are things I personally would try:; - Have you tried better resolving the model? A 64^3 model _should_ be able to achieve a log-law, but it's still worth investigating.; - Have you tried using the `SmagorinskyLilly` closure? I've had some issues with AMD in the past (although not exactly the same as yours), and I remember @glwagner mentioning having an issue with AMD near boundaries that could explain the behavior you're seeing.; - Finally, I'd suggest starting with a very simple model first for debugging/investigating. Just the bare minimum to reproduce a log-law. (i.e., no tracers, buoyancy, Coriolis, forcing...). @Tinydog8 @chabbymark Hope this helps!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3195#issuecomment-1649999408
Usability,clear,clearer,"an't use `const z₁ = -1*znodes(Center,grid)[1]` because if I do that, the value of z1 will change to 14.88. My code `const z₁ = -1*znodes(Center,grid)[grid.Nz]` will keep z1 equals to Closest grid center to the bottom (0.12). This isn't the best way to define $z_1$. The current statement will break if you, for example, decide to stretch the grid vertically. The more robust way to define $z_1$ is. ```julia; julia> grid = RectilinearGrid(CPU(), size=(64,64,64), extent=(π*H, π*H, H)); 64×64×64 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── Periodic x ∈ [1.54466e-16, 47.1239) regularly spaced with Δx=0.736311; ├── Periodic y ∈ [1.54466e-16, 47.1239) regularly spaced with Δy=0.736311; └── Bounded z ∈ [-15.0, 0.0] regularly spaced with Δz=0.234375. julia> using Oceananigans.Grids: zspacing. julia> zspacing(1, 1, 1, grid, Center(), Center(), Center())/2 # Half the distance around a center point; 0.1171875; ```. This is clearer, and will give you the correct value even if you change the grid in the future. Note that in the call to `zspacing()` above, we need to specify the x, y and z positions to get the spacing, but in a `RectilinearGrid` Δz is constant in x and y so those arguments don't really matter. Also note that the code above is written for the most recent Oceananigans version (for which you'll need Julia 1.9). 3. Now to your main point (sorry for the tangents! :grimacing:), I don't see anything obviously wrong with the code. Just from looking at it, it looks like it _should_ work. (Btw, when I say that, I assume this is a _only snippet, and not the full-code_, since I get errors when I try to run your code (`coriolis`, `T_bcs` and `S_bcs` aren't defined, `Fx` looks like it'd cause an error, etc.), so I haven't been able to properly run and test your snippet.). That said, there are things I personally would try:; - Have you tried better resolving the model? A 64^3 model _should_ be able to achieve a log-law, but it's still worth in",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3195#issuecomment-1649999408
Integrability,depend,dependent,"@glwagner @tomchor ; I have just tested the turbulent boundary layer with wall model using Oceananigans on Julia 1.6.7 and Julia 1.9.2. The performances of AMD in both versions are exactly the same. It turns to overestimate the velocity shear at the second node from the wall, therefore, turns to overestimate the velocity in the middle and upper parts of the boundary layers. I used to use the SGS model based on the Lagrangian-averaged scale-dependent dynamic model (LASD) (https://pubs.aip.org/aip/pof/article/17/2/025105/895722/A-scale-dependent-Lagrangian-dynamic-model-for). @tomchor is very familiar with this SGS model. The performance of the LASD close to the wall is usually good, as you can see here; ![025105_1_f2](https://github.com/CliMA/Oceananigans.jl/assets/20816949/e4aa1b73-d37e-4afa-b3ec-317d2edf7769). I guess the problem of AMD is partly solved in reference Yang et al. (2017). Now the problem is that if someone can implement this filtering in the code or not. I am stilling learning the Oceananigans and Julia. I hope that someday in the future, I am able to implement this technique.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3195#issuecomment-1652877426
Modifiability,layers,layers,"@glwagner @tomchor ; I have just tested the turbulent boundary layer with wall model using Oceananigans on Julia 1.6.7 and Julia 1.9.2. The performances of AMD in both versions are exactly the same. It turns to overestimate the velocity shear at the second node from the wall, therefore, turns to overestimate the velocity in the middle and upper parts of the boundary layers. I used to use the SGS model based on the Lagrangian-averaged scale-dependent dynamic model (LASD) (https://pubs.aip.org/aip/pof/article/17/2/025105/895722/A-scale-dependent-Lagrangian-dynamic-model-for). @tomchor is very familiar with this SGS model. The performance of the LASD close to the wall is usually good, as you can see here; ![025105_1_f2](https://github.com/CliMA/Oceananigans.jl/assets/20816949/e4aa1b73-d37e-4afa-b3ec-317d2edf7769). I guess the problem of AMD is partly solved in reference Yang et al. (2017). Now the problem is that if someone can implement this filtering in the code or not. I am stilling learning the Oceananigans and Julia. I hope that someday in the future, I am able to implement this technique.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3195#issuecomment-1652877426
Performance,perform,performances,"@glwagner @tomchor ; I have just tested the turbulent boundary layer with wall model using Oceananigans on Julia 1.6.7 and Julia 1.9.2. The performances of AMD in both versions are exactly the same. It turns to overestimate the velocity shear at the second node from the wall, therefore, turns to overestimate the velocity in the middle and upper parts of the boundary layers. I used to use the SGS model based on the Lagrangian-averaged scale-dependent dynamic model (LASD) (https://pubs.aip.org/aip/pof/article/17/2/025105/895722/A-scale-dependent-Lagrangian-dynamic-model-for). @tomchor is very familiar with this SGS model. The performance of the LASD close to the wall is usually good, as you can see here; ![025105_1_f2](https://github.com/CliMA/Oceananigans.jl/assets/20816949/e4aa1b73-d37e-4afa-b3ec-317d2edf7769). I guess the problem of AMD is partly solved in reference Yang et al. (2017). Now the problem is that if someone can implement this filtering in the code or not. I am stilling learning the Oceananigans and Julia. I hope that someday in the future, I am able to implement this technique.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3195#issuecomment-1652877426
Testability,test,tested,"@glwagner @tomchor ; I have just tested the turbulent boundary layer with wall model using Oceananigans on Julia 1.6.7 and Julia 1.9.2. The performances of AMD in both versions are exactly the same. It turns to overestimate the velocity shear at the second node from the wall, therefore, turns to overestimate the velocity in the middle and upper parts of the boundary layers. I used to use the SGS model based on the Lagrangian-averaged scale-dependent dynamic model (LASD) (https://pubs.aip.org/aip/pof/article/17/2/025105/895722/A-scale-dependent-Lagrangian-dynamic-model-for). @tomchor is very familiar with this SGS model. The performance of the LASD close to the wall is usually good, as you can see here; ![025105_1_f2](https://github.com/CliMA/Oceananigans.jl/assets/20816949/e4aa1b73-d37e-4afa-b3ec-317d2edf7769). I guess the problem of AMD is partly solved in reference Yang et al. (2017). Now the problem is that if someone can implement this filtering in the code or not. I am stilling learning the Oceananigans and Julia. I hope that someday in the future, I am able to implement this technique.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3195#issuecomment-1652877426
Usability,learn,learning,"@glwagner @tomchor ; I have just tested the turbulent boundary layer with wall model using Oceananigans on Julia 1.6.7 and Julia 1.9.2. The performances of AMD in both versions are exactly the same. It turns to overestimate the velocity shear at the second node from the wall, therefore, turns to overestimate the velocity in the middle and upper parts of the boundary layers. I used to use the SGS model based on the Lagrangian-averaged scale-dependent dynamic model (LASD) (https://pubs.aip.org/aip/pof/article/17/2/025105/895722/A-scale-dependent-Lagrangian-dynamic-model-for). @tomchor is very familiar with this SGS model. The performance of the LASD close to the wall is usually good, as you can see here; ![025105_1_f2](https://github.com/CliMA/Oceananigans.jl/assets/20816949/e4aa1b73-d37e-4afa-b3ec-317d2edf7769). I guess the problem of AMD is partly solved in reference Yang et al. (2017). Now the problem is that if someone can implement this filtering in the code or not. I am stilling learning the Oceananigans and Julia. I hope that someday in the future, I am able to implement this technique.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3195#issuecomment-1652877426
Modifiability,extend,extended,"It's very exciting! I was just remarking about ""we have to comment X out"". Extending a method that doesn't work on the cubed sphere is practically the same amount of work (in this case), and illustrates the proper workflow when developing a new feature (often methods will have to be extended, since they may make assumptions that are no longer valid). So I wanted to point that out in case people run into this in the future and use it as a template for their own development. Also if you are working with others, being clear about the development that's needed can help coordinate efforts.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3204#issuecomment-1719386432
Usability,clear,clear,"It's very exciting! I was just remarking about ""we have to comment X out"". Extending a method that doesn't work on the cubed sphere is practically the same amount of work (in this case), and illustrates the proper workflow when developing a new feature (often methods will have to be extended, since they may make assumptions that are no longer valid). So I wanted to point that out in case people run into this in the future and use it as a template for their own development. Also if you are working with others, being clear about the development that's needed can help coordinate efforts.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3204#issuecomment-1719386432
Usability,simpl,simply,"Possibly you want to invent a new function (or keyword argument) for this? Something like. ```julia; set!(model, checkpoint_file; with_halos=false); ```. Hopefully this can be done simply. I was going to suggest using `FieldTimeSeries`. But then I realized that can't be done with `Checkpointer`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3206#issuecomment-1659126401
Deployability,integrat,integrated,"Float32 global simulations are near!. This is the u-velocity at the surface of a simple baroclinic adjustment case: left -> Float64, center -> Float32 right -> difference (u64 - u32). https://github.com/CliMA/Oceananigans.jl/assets/33547697/4ed0e547-416f-4597-8e2c-a38de7cb9fa5. integrated KE energy time series. ![ke](https://github.com/CliMA/Oceananigans.jl/assets/33547697/941883a9-84a8-4e92-90b0-277fdc2a2063). more in-depth statistics from @milankl incoming",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3212#issuecomment-1670259168
Energy Efficiency,energy,energy,"Float32 global simulations are near!. This is the u-velocity at the surface of a simple baroclinic adjustment case: left -> Float64, center -> Float32 right -> difference (u64 - u32). https://github.com/CliMA/Oceananigans.jl/assets/33547697/4ed0e547-416f-4597-8e2c-a38de7cb9fa5. integrated KE energy time series. ![ke](https://github.com/CliMA/Oceananigans.jl/assets/33547697/941883a9-84a8-4e92-90b0-277fdc2a2063). more in-depth statistics from @milankl incoming",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3212#issuecomment-1670259168
Integrability,integrat,integrated,"Float32 global simulations are near!. This is the u-velocity at the surface of a simple baroclinic adjustment case: left -> Float64, center -> Float32 right -> difference (u64 - u32). https://github.com/CliMA/Oceananigans.jl/assets/33547697/4ed0e547-416f-4597-8e2c-a38de7cb9fa5. integrated KE energy time series. ![ke](https://github.com/CliMA/Oceananigans.jl/assets/33547697/941883a9-84a8-4e92-90b0-277fdc2a2063). more in-depth statistics from @milankl incoming",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3212#issuecomment-1670259168
Usability,simpl,simple,"Float32 global simulations are near!. This is the u-velocity at the surface of a simple baroclinic adjustment case: left -> Float64, center -> Float32 right -> difference (u64 - u32). https://github.com/CliMA/Oceananigans.jl/assets/33547697/4ed0e547-416f-4597-8e2c-a38de7cb9fa5. integrated KE energy time series. ![ke](https://github.com/CliMA/Oceananigans.jl/assets/33547697/941883a9-84a8-4e92-90b0-277fdc2a2063). more in-depth statistics from @milankl incoming",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3212#issuecomment-1670259168
Usability,undo,undo,@siddharthabishnu this PR changes 73 files at the moment. Are you sure this is intentional?. A lot of commits seem to have happened between _this post_ and my previous post. But they are mostly things already merged in main? But this PR seems to re-introduce the changes and sometimes undo them?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3222#issuecomment-1723710908
Usability,undo,undo,> @siddharthabishnu this PR changes 73 files at the moment. Are you sure this is intentional?; > ; > A lot of commits seem to have happened between _this post_ and my previous post. But they are mostly things already merged in main? But this PR seems to re-introduce the changes and sometimes undo them?. Please see my response above.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3222#issuecomment-1724412295
Usability,intuit,intuitive,"> a better approach for the horizontal convection example is to save halo regions using `with_halos=true` when building the output writer. Maybe I am misunderstanding you, but isn't that already what is done in the horizontal convection example?; https://github.com/CliMA/Oceananigans.jl/blob/cca182a11bcd1881e20316fc80ac7782286a8bfe/examples/horizontal_convection.jl#L153-L157. It seems like this is indeed saving grids with halos, but erroneously filling them with zeros rather than the correct values? Is the intended behavior that output writers automatically call `fill_halo_region!` before saving when `with_halos=true`? That would be an intuitive enough API, even if the default was still `with_halos=false`, but I think separate from this issue.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3224#issuecomment-1689073910
Usability,clear,clear,"> I am actually not even sure that it would be possible to do easily in this case. Just to be clear, this is just for offline diagnostics, right? Online diagnostic operations on prognostic fields still correctly feel the boundary conditions?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3224#issuecomment-1689980077
Integrability,interface,interface,"I'm pretty sure this is trivial to support because `FunctionField` has the same interface as `AbstractOperation`, so we can simply extend these methods:. https://github.com/CliMA/Oceananigans.jl/blob/main/src/AbstractOperations/computed_field.jl",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3226#issuecomment-1690265122
Modifiability,extend,extend,"I'm pretty sure this is trivial to support because `FunctionField` has the same interface as `AbstractOperation`, so we can simply extend these methods:. https://github.com/CliMA/Oceananigans.jl/blob/main/src/AbstractOperations/computed_field.jl",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3226#issuecomment-1690265122
Usability,simpl,simply,"I'm pretty sure this is trivial to support because `FunctionField` has the same interface as `AbstractOperation`, so we can simply extend these methods:. https://github.com/CliMA/Oceananigans.jl/blob/main/src/AbstractOperations/computed_field.jl",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3226#issuecomment-1690265122
Energy Efficiency,allocate,allocate,"On the user interface side, @simone-silvestri discussed a refactor that would implement something like:. ```julia; # To fix the number of substeps at 200; free_surface = SplitExplicitFreeSurface(time_step=FixedNumber(200)). # To fix the number of substeps according to CFL criteria, given the time-step passed to simulation; free_surface = SplitExplicitFreeSurface(time_step=FixedNumber(simulation_Δt=2minutes, cfl=0.7)). # Fixed time-step (variable number of substeps); free_surface = SplitExplicitFreeSurface(time_step=FixedSize(cfl=0.7)); ```. Do you have any feedback on that? Partly, this was motivated by my own confusion with the API. (Note, we also discussed some internal changes like getting rid of `settings`.) One detail is that we shouldn't have to pass `grid` because the free surface already must be ""materialized"" on the model grid in order to allocate memory for fields. My opinion is that we _either_ should pass `grid` and cut out the materialization, or we should not pass `grid` and materialize under the hood. But not both because that's the worst of both words (less convenient for users, complicated under the hood). We're waiting for #3125 to do this since there are some changes introduced there",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3238#issuecomment-1695593342
Integrability,interface,interface,"On the user interface side, @simone-silvestri discussed a refactor that would implement something like:. ```julia; # To fix the number of substeps at 200; free_surface = SplitExplicitFreeSurface(time_step=FixedNumber(200)). # To fix the number of substeps according to CFL criteria, given the time-step passed to simulation; free_surface = SplitExplicitFreeSurface(time_step=FixedNumber(simulation_Δt=2minutes, cfl=0.7)). # Fixed time-step (variable number of substeps); free_surface = SplitExplicitFreeSurface(time_step=FixedSize(cfl=0.7)); ```. Do you have any feedback on that? Partly, this was motivated by my own confusion with the API. (Note, we also discussed some internal changes like getting rid of `settings`.) One detail is that we shouldn't have to pass `grid` because the free surface already must be ""materialized"" on the model grid in order to allocate memory for fields. My opinion is that we _either_ should pass `grid` and cut out the materialization, or we should not pass `grid` and materialize under the hood. But not both because that's the worst of both words (less convenient for users, complicated under the hood). We're waiting for #3125 to do this since there are some changes introduced there",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3238#issuecomment-1695593342
Modifiability,refactor,refactor,"On the user interface side, @simone-silvestri discussed a refactor that would implement something like:. ```julia; # To fix the number of substeps at 200; free_surface = SplitExplicitFreeSurface(time_step=FixedNumber(200)). # To fix the number of substeps according to CFL criteria, given the time-step passed to simulation; free_surface = SplitExplicitFreeSurface(time_step=FixedNumber(simulation_Δt=2minutes, cfl=0.7)). # Fixed time-step (variable number of substeps); free_surface = SplitExplicitFreeSurface(time_step=FixedSize(cfl=0.7)); ```. Do you have any feedback on that? Partly, this was motivated by my own confusion with the API. (Note, we also discussed some internal changes like getting rid of `settings`.) One detail is that we shouldn't have to pass `grid` because the free surface already must be ""materialized"" on the model grid in order to allocate memory for fields. My opinion is that we _either_ should pass `grid` and cut out the materialization, or we should not pass `grid` and materialize under the hood. But not both because that's the worst of both words (less convenient for users, complicated under the hood). We're waiting for #3125 to do this since there are some changes introduced there",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3238#issuecomment-1695593342
Usability,feedback,feedback,"On the user interface side, @simone-silvestri discussed a refactor that would implement something like:. ```julia; # To fix the number of substeps at 200; free_surface = SplitExplicitFreeSurface(time_step=FixedNumber(200)). # To fix the number of substeps according to CFL criteria, given the time-step passed to simulation; free_surface = SplitExplicitFreeSurface(time_step=FixedNumber(simulation_Δt=2minutes, cfl=0.7)). # Fixed time-step (variable number of substeps); free_surface = SplitExplicitFreeSurface(time_step=FixedSize(cfl=0.7)); ```. Do you have any feedback on that? Partly, this was motivated by my own confusion with the API. (Note, we also discussed some internal changes like getting rid of `settings`.) One detail is that we shouldn't have to pass `grid` because the free surface already must be ""materialized"" on the model grid in order to allocate memory for fields. My opinion is that we _either_ should pass `grid` and cut out the materialization, or we should not pass `grid` and materialize under the hood. But not both because that's the worst of both words (less convenient for users, complicated under the hood). We're waiting for #3125 to do this since there are some changes introduced there",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3238#issuecomment-1695593342
Energy Efficiency,schedul,schedule,"A simple fix to manage to output $\eta$ will be to pass `indices=(:,:,1-grid.Hz)` in the `JLD2OutputWriter`. i.e.:; ```; simulation.output_writers[:surface] = JLD2OutputWriter(model, ; (η=eta,),; indices=(:,:,,1-grid.Hz),; schedule = TimeInterval(200),; filename = ""surface"",; with_halos = false,; overwrite_existing = true); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3260#issuecomment-2014687259
Usability,simpl,simple,"A simple fix to manage to output $\eta$ will be to pass `indices=(:,:,1-grid.Hz)` in the `JLD2OutputWriter`. i.e.:; ```; simulation.output_writers[:surface] = JLD2OutputWriter(model, ; (η=eta,),; indices=(:,:,,1-grid.Hz),; schedule = TimeInterval(200),; filename = ""surface"",; with_halos = false,; overwrite_existing = true); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3260#issuecomment-2014687259
Energy Efficiency,schedul,schedule,"> A simple fix to manage to output η will be to pass `indices=(:,:,1-grid.Hz)` in the `JLD2OutputWriter`. i.e.:; > ; > ```; > simulation.output_writers[:surface] = JLD2OutputWriter(model, ; > (η=eta,),; > indices=(:,:,,1-grid.Hz),; > schedule = TimeInterval(200),; > filename = ""surface"",; > with_halos = false,; > overwrite_existing = true); > ```. Good to know but definitely we want to fix the underlying issue",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3260#issuecomment-2018365052
Usability,simpl,simple,"> A simple fix to manage to output η will be to pass `indices=(:,:,1-grid.Hz)` in the `JLD2OutputWriter`. i.e.:; > ; > ```; > simulation.output_writers[:surface] = JLD2OutputWriter(model, ; > (η=eta,),; > indices=(:,:,,1-grid.Hz),; > schedule = TimeInterval(200),; > filename = ""surface"",; > with_halos = false,; > overwrite_existing = true); > ```. Good to know but definitely we want to fix the underlying issue",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3260#issuecomment-2018365052
Availability,down,downsides,"> Ah yeah this makes sense.; > ; > The case that I can't think of a different way around is for scaling negative tracers as implemented in OceanBioME. Previously we had just defined this as a callback so when it got setup you could pass it the model and the tracer symbols could be converted indices appropriately. But now making it part of the model (which I think in the philosophy of models vs simulations it is since it's a key part of the dynamics in the same way as a timestepper) we can't do that without materialising the full list of tracers before.; > ; > So in this case all that we should change is returning the exact same model but with a list of symbols changed to indices. Would this not be an issue if users have to explicitly declare the list of tracers?. Working on some biogeochemistry stuff with @seamanticscience, I came to the conclusion that the ""auto-adding"" of tracers has some definite downsides, like you easily forget what the tracer names are. The fact is that you have to know what the tracer names are anyways to set initial conditions. So I'm leaning towards requiring that users add tracers explicitly. It's also nice to get the error message that tells you what tracers you need, reminding you of their names. Not sure if that would help, but we may want to make that usability improvement first if its a related issue?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3262#issuecomment-1715593319
Integrability,message,message,"> Ah yeah this makes sense.; > ; > The case that I can't think of a different way around is for scaling negative tracers as implemented in OceanBioME. Previously we had just defined this as a callback so when it got setup you could pass it the model and the tracer symbols could be converted indices appropriately. But now making it part of the model (which I think in the philosophy of models vs simulations it is since it's a key part of the dynamics in the same way as a timestepper) we can't do that without materialising the full list of tracers before.; > ; > So in this case all that we should change is returning the exact same model but with a list of symbols changed to indices. Would this not be an issue if users have to explicitly declare the list of tracers?. Working on some biogeochemistry stuff with @seamanticscience, I came to the conclusion that the ""auto-adding"" of tracers has some definite downsides, like you easily forget what the tracer names are. The fact is that you have to know what the tracer names are anyways to set initial conditions. So I'm leaning towards requiring that users add tracers explicitly. It's also nice to get the error message that tells you what tracers you need, reminding you of their names. Not sure if that would help, but we may want to make that usability improvement first if its a related issue?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3262#issuecomment-1715593319
Usability,usab,usability,"> Ah yeah this makes sense.; > ; > The case that I can't think of a different way around is for scaling negative tracers as implemented in OceanBioME. Previously we had just defined this as a callback so when it got setup you could pass it the model and the tracer symbols could be converted indices appropriately. But now making it part of the model (which I think in the philosophy of models vs simulations it is since it's a key part of the dynamics in the same way as a timestepper) we can't do that without materialising the full list of tracers before.; > ; > So in this case all that we should change is returning the exact same model but with a list of symbols changed to indices. Would this not be an issue if users have to explicitly declare the list of tracers?. Working on some biogeochemistry stuff with @seamanticscience, I came to the conclusion that the ""auto-adding"" of tracers has some definite downsides, like you easily forget what the tracer names are. The fact is that you have to know what the tracer names are anyways to set initial conditions. So I'm leaning towards requiring that users add tracers explicitly. It's also nice to get the error message that tells you what tracers you need, reminding you of their names. Not sure if that would help, but we may want to make that usability improvement first if its a related issue?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3262#issuecomment-1715593319
Usability,simpl,simpler,"Why not just extract the tracers to be scaled in advance of launching the kernel?. ```julia; tracers_to_scale = Tuple(fields[name] for name in keys(scale.tracers)); # launch kernel, indexing from 1:length(tracers_to_scale); ```. You can also launch one kernel per tracer which might be ok and a bit simpler which is nice.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3262#issuecomment-1718747355
Usability,clear,clear,"I was thinking about it. The problem is that they do in fact encode some physical statements, like, for example, impenetrability for U (XFaceFields) and V (YFaceFields) and no flux for center-fields (C). ; Periodic topologies act according to periodic BC.; We probably need a way to make this clear. I am afraid a compact notation would not convey this entirely, maybe we can be a bit more verbose like; ```julia; δyᵃᶜᵃ_nopenetration; δxᶠᵃᵃ_noflux; ```; ?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-1775917629
Usability,clear,clear,"> I was thinking about it. The problem is that they do in fact encode some physical statements, like, for example, impenetrability for U (XFaceFields) and V (YFaceFields) and no flux for center-fields (C). Periodic topologies act according to periodic BC. We probably need a way to make this clear. I am afraid a compact notation would not convey this entirely, maybe we can be a bit more verbose like; > ; > ```julia; > δyᵃᶜᵃ_nopenetration; > δxᶠᵃᵃ_noflux; > ```; > ; > ?. Two thoughts:; - ""penetration"" and ""flux"" are physical concepts. More precisely the operator returns zero when differenced across a `Bounded` direction.; - The operator names are ""mathematical"" rather than English, ie we use symbols like `δx`, rather than `x_difference`. I think we should try to strive to keep names in one category or another rather than blending them",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-1775922222
Availability,down,down,"To get this PR merged, it sounds like we just want to agree on a naming convention and move the topologically-aware operators to the `Operators` module?. I like the `T` for topology suggestion, e.g. `δxTᶜᵃᵃ`. These operators are not exported so they don't need to have user-friendly names, only developer-friendly names. I'm happy to move forward with this suggestion and try to get this PR review-ready. I also don't think operators should depend on boundary conditions. But I can write down some thoughts in a more appropriate issue.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-2397520652
Integrability,depend,depend,"To get this PR merged, it sounds like we just want to agree on a naming convention and move the topologically-aware operators to the `Operators` module?. I like the `T` for topology suggestion, e.g. `δxTᶜᵃᵃ`. These operators are not exported so they don't need to have user-friendly names, only developer-friendly names. I'm happy to move forward with this suggestion and try to get this PR review-ready. I also don't think operators should depend on boundary conditions. But I can write down some thoughts in a more appropriate issue.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-2397520652
Usability,user-friendly,user-friendly,"To get this PR merged, it sounds like we just want to agree on a naming convention and move the topologically-aware operators to the `Operators` module?. I like the `T` for topology suggestion, e.g. `δxTᶜᵃᵃ`. These operators are not exported so they don't need to have user-friendly names, only developer-friendly names. I'm happy to move forward with this suggestion and try to get this PR review-ready. I also don't think operators should depend on boundary conditions. But I can write down some thoughts in a more appropriate issue.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-2397520652
Performance,perform,performance,"> The main issues are when the entirety of a heavy kernel (like one that calculates a tendency) may be promoted to higher precision. `fill(var, 0)` is cheap and unlikely to affect performance.; > ; > That said it's just more precise to write `fill(var, zero(eltype(var)))` (this is _exactly_ what you are trying to do) and therefore the preferred way to write it. You were meant to write `fill!` not `fill` right? For `fill!(::AbstractArray,0)` this is what happens. ```julia; julia> a = Float32[1,2,3]; 3-element Vector{Float32}:; 1.0; 2.0; 3.0. julia> @code_llvm fill!(a,0); ; @ array.jl:346 within `fill!`; define nonnull {}* @""julia_fill!_127""({}* noundef nonnull align 16 dereferenceable(40) %0, i64 signext %1) #0 {; top:; ; @ array.jl:347 within `fill!`; ; ┌ @ number.jl:7 within `convert`; ; │┌ @ float.jl:159 within `Float32`; %2 = sitofp i64 %1 to float; ; └└; ```. So the very first thing is that if `eltype` of the array and type of second argument aren't the same then it's converted (the `%2 ...` line); Using `fill!(var, zero(eltype(var)))` then can skip this conversion (it's compiled away) but the result is the same. You can make and educated guess of the type of the zero, but honestly, I wouldn't even bother. It has probably zero impact on performance for any larger than a few elements and I find `fill!(A,0)` very clear to read too, so that's what I now always try to write.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3271#issuecomment-1723777023
Usability,clear,clear,"> The main issues are when the entirety of a heavy kernel (like one that calculates a tendency) may be promoted to higher precision. `fill(var, 0)` is cheap and unlikely to affect performance.; > ; > That said it's just more precise to write `fill(var, zero(eltype(var)))` (this is _exactly_ what you are trying to do) and therefore the preferred way to write it. You were meant to write `fill!` not `fill` right? For `fill!(::AbstractArray,0)` this is what happens. ```julia; julia> a = Float32[1,2,3]; 3-element Vector{Float32}:; 1.0; 2.0; 3.0. julia> @code_llvm fill!(a,0); ; @ array.jl:346 within `fill!`; define nonnull {}* @""julia_fill!_127""({}* noundef nonnull align 16 dereferenceable(40) %0, i64 signext %1) #0 {; top:; ; @ array.jl:347 within `fill!`; ; ┌ @ number.jl:7 within `convert`; ; │┌ @ float.jl:159 within `Float32`; %2 = sitofp i64 %1 to float; ; └└; ```. So the very first thing is that if `eltype` of the array and type of second argument aren't the same then it's converted (the `%2 ...` line); Using `fill!(var, zero(eltype(var)))` then can skip this conversion (it's compiled away) but the result is the same. You can make and educated guess of the type of the zero, but honestly, I wouldn't even bother. It has probably zero impact on performance for any larger than a few elements and I find `fill!(A,0)` very clear to read too, so that's what I now always try to write.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3271#issuecomment-1723777023
Performance,perform,performance,"Ok. That makes sense, since CPU is not our goal; we can accept some loss of performance on CPU in order to simplify the code. The other question is why we are not implementing this in PencilArrays / PencilFFTs. Having an independent implementation may not be the best practice (we want to be good open source community members), but could be justified, maybe.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-1727562842
Usability,simpl,simplify,"Ok. That makes sense, since CPU is not our goal; we can accept some loss of performance on CPU in order to simplify the code. The other question is why we are not implementing this in PencilArrays / PencilFFTs. Having an independent implementation may not be the best practice (we want to be good open source community members), but could be justified, maybe.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-1727562842
Deployability,configurat,configuration,"@matinraayai is working on making PencilArrays performant. This PR is exploratory and is a fallback that might not be merged if we find an efficient way to do GPU transposes with PencilArrays (requires reducing memory allocations and improving the efficiency of permute operations) and implement r2r Fourier transforms in PencilFFTs. ; For the moment those two elements are part of this PR. This PR follows the (simple) configuration of the 2decomp library https://github.com/2decomp-fft/2decomp-fft,; the difference between PencilFFT/PencilArray and this PR (a part bounded domain ffts) is that here (at the moment) we impose the stricter limitation that `Ny` has to be divisible by `Rx` and `Ry` while `Nz` has to be divisible by `Ry`, where `Rx` and `Ry` are the number of ranks (divisions) in the x and y direction. Relaxing the requirements should not be too difficult.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-1727661521
Energy Efficiency,efficient,efficient,"@matinraayai is working on making PencilArrays performant. This PR is exploratory and is a fallback that might not be merged if we find an efficient way to do GPU transposes with PencilArrays (requires reducing memory allocations and improving the efficiency of permute operations) and implement r2r Fourier transforms in PencilFFTs. ; For the moment those two elements are part of this PR. This PR follows the (simple) configuration of the 2decomp library https://github.com/2decomp-fft/2decomp-fft,; the difference between PencilFFT/PencilArray and this PR (a part bounded domain ffts) is that here (at the moment) we impose the stricter limitation that `Ny` has to be divisible by `Rx` and `Ry` while `Nz` has to be divisible by `Ry`, where `Rx` and `Ry` are the number of ranks (divisions) in the x and y direction. Relaxing the requirements should not be too difficult.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-1727661521
Modifiability,config,configuration,"@matinraayai is working on making PencilArrays performant. This PR is exploratory and is a fallback that might not be merged if we find an efficient way to do GPU transposes with PencilArrays (requires reducing memory allocations and improving the efficiency of permute operations) and implement r2r Fourier transforms in PencilFFTs. ; For the moment those two elements are part of this PR. This PR follows the (simple) configuration of the 2decomp library https://github.com/2decomp-fft/2decomp-fft,; the difference between PencilFFT/PencilArray and this PR (a part bounded domain ffts) is that here (at the moment) we impose the stricter limitation that `Ny` has to be divisible by `Rx` and `Ry` while `Nz` has to be divisible by `Ry`, where `Rx` and `Ry` are the number of ranks (divisions) in the x and y direction. Relaxing the requirements should not be too difficult.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-1727661521
Performance,perform,performant,"@matinraayai is working on making PencilArrays performant. This PR is exploratory and is a fallback that might not be merged if we find an efficient way to do GPU transposes with PencilArrays (requires reducing memory allocations and improving the efficiency of permute operations) and implement r2r Fourier transforms in PencilFFTs. ; For the moment those two elements are part of this PR. This PR follows the (simple) configuration of the 2decomp library https://github.com/2decomp-fft/2decomp-fft,; the difference between PencilFFT/PencilArray and this PR (a part bounded domain ffts) is that here (at the moment) we impose the stricter limitation that `Ny` has to be divisible by `Rx` and `Ry` while `Nz` has to be divisible by `Ry`, where `Rx` and `Ry` are the number of ranks (divisions) in the x and y direction. Relaxing the requirements should not be too difficult.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-1727661521
Usability,simpl,simple,"@matinraayai is working on making PencilArrays performant. This PR is exploratory and is a fallback that might not be merged if we find an efficient way to do GPU transposes with PencilArrays (requires reducing memory allocations and improving the efficiency of permute operations) and implement r2r Fourier transforms in PencilFFTs. ; For the moment those two elements are part of this PR. This PR follows the (simple) configuration of the 2decomp library https://github.com/2decomp-fft/2decomp-fft,; the difference between PencilFFT/PencilArray and this PR (a part bounded domain ffts) is that here (at the moment) we impose the stricter limitation that `Ny` has to be divisible by `Rx` and `Ry` while `Nz` has to be divisible by `Ry`, where `Rx` and `Ry` are the number of ranks (divisions) in the x and y direction. Relaxing the requirements should not be too difficult.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-1727661521
Deployability,configurat,configuration,"> @matinraayai is working on making PencilArrays performant. This PR is exploratory and is a fallback that might not be merged if we find an efficient way to do GPU transposes with PencilArrays (requires reducing memory allocations and improving the efficiency of permute operations) and implement r2r Fourier transforms in PencilFFTs. For the moment those two elements are part of this PR.; > ; > This PR follows the (simple) configuration of the 2decomp library https://github.com/2decomp-fft/2decomp-fft, the difference between PencilFFT/PencilArray and this PR (a part bounded domain ffts) is that here (at the moment) we impose the stricter limitation that `Ny` has to be divisible by `Rx` and `Ry` while `Nz` has to be divisible by `Ry`, where `Rx` and `Ry` are the number of ranks (divisions) in the x and y direction. Relaxing the requirements should not be too difficult. Nice, thanks for that explanation. Why are we following 2decomp? PencilArrays has some benchmarking that shows it can compete with the fastest codes out there. I don't see anything similar for 2decomp, so I can't figure out what the motivation for following that strategy would be. I'm not sure if they are different, either. Something we do not previously support (but which is implemented in https://github.com/CliMA/Oceananigans.jl/pull/2538) was an algorithm that could support any topology with vertically-stretched grids. What is the relationship between this PR and https://github.com/CliMA/Oceananigans.jl/pull/2538, and does this PR support vertically stretched grids?. One of the main limitations of PencilArrays from our perspective is that it could not distribute an array along the first dimension. Since we almost always would like to use vertically stretched grids (and for various reasons, we may want to also compute the hydrostatic pressure with a vertical integral), ocean LES are typically distributed in x and y. Therefore, in order to support 2D domain decompositions, we were faced with somehow ch",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-1728278859
Energy Efficiency,efficient,efficient,"> @matinraayai is working on making PencilArrays performant. This PR is exploratory and is a fallback that might not be merged if we find an efficient way to do GPU transposes with PencilArrays (requires reducing memory allocations and improving the efficiency of permute operations) and implement r2r Fourier transforms in PencilFFTs. For the moment those two elements are part of this PR.; > ; > This PR follows the (simple) configuration of the 2decomp library https://github.com/2decomp-fft/2decomp-fft, the difference between PencilFFT/PencilArray and this PR (a part bounded domain ffts) is that here (at the moment) we impose the stricter limitation that `Ny` has to be divisible by `Rx` and `Ry` while `Nz` has to be divisible by `Ry`, where `Rx` and `Ry` are the number of ranks (divisions) in the x and y direction. Relaxing the requirements should not be too difficult. Nice, thanks for that explanation. Why are we following 2decomp? PencilArrays has some benchmarking that shows it can compete with the fastest codes out there. I don't see anything similar for 2decomp, so I can't figure out what the motivation for following that strategy would be. I'm not sure if they are different, either. Something we do not previously support (but which is implemented in https://github.com/CliMA/Oceananigans.jl/pull/2538) was an algorithm that could support any topology with vertically-stretched grids. What is the relationship between this PR and https://github.com/CliMA/Oceananigans.jl/pull/2538, and does this PR support vertically stretched grids?. One of the main limitations of PencilArrays from our perspective is that it could not distribute an array along the first dimension. Since we almost always would like to use vertically stretched grids (and for various reasons, we may want to also compute the hydrostatic pressure with a vertical integral), ocean LES are typically distributed in x and y. Therefore, in order to support 2D domain decompositions, we were faced with somehow ch",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-1728278859
Modifiability,config,configuration,"> @matinraayai is working on making PencilArrays performant. This PR is exploratory and is a fallback that might not be merged if we find an efficient way to do GPU transposes with PencilArrays (requires reducing memory allocations and improving the efficiency of permute operations) and implement r2r Fourier transforms in PencilFFTs. For the moment those two elements are part of this PR.; > ; > This PR follows the (simple) configuration of the 2decomp library https://github.com/2decomp-fft/2decomp-fft, the difference between PencilFFT/PencilArray and this PR (a part bounded domain ffts) is that here (at the moment) we impose the stricter limitation that `Ny` has to be divisible by `Rx` and `Ry` while `Nz` has to be divisible by `Ry`, where `Rx` and `Ry` are the number of ranks (divisions) in the x and y direction. Relaxing the requirements should not be too difficult. Nice, thanks for that explanation. Why are we following 2decomp? PencilArrays has some benchmarking that shows it can compete with the fastest codes out there. I don't see anything similar for 2decomp, so I can't figure out what the motivation for following that strategy would be. I'm not sure if they are different, either. Something we do not previously support (but which is implemented in https://github.com/CliMA/Oceananigans.jl/pull/2538) was an algorithm that could support any topology with vertically-stretched grids. What is the relationship between this PR and https://github.com/CliMA/Oceananigans.jl/pull/2538, and does this PR support vertically stretched grids?. One of the main limitations of PencilArrays from our perspective is that it could not distribute an array along the first dimension. Since we almost always would like to use vertically stretched grids (and for various reasons, we may want to also compute the hydrostatic pressure with a vertical integral), ocean LES are typically distributed in x and y. Therefore, in order to support 2D domain decompositions, we were faced with somehow ch",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-1728278859
Performance,perform,performant,"> @matinraayai is working on making PencilArrays performant. This PR is exploratory and is a fallback that might not be merged if we find an efficient way to do GPU transposes with PencilArrays (requires reducing memory allocations and improving the efficiency of permute operations) and implement r2r Fourier transforms in PencilFFTs. For the moment those two elements are part of this PR.; > ; > This PR follows the (simple) configuration of the 2decomp library https://github.com/2decomp-fft/2decomp-fft, the difference between PencilFFT/PencilArray and this PR (a part bounded domain ffts) is that here (at the moment) we impose the stricter limitation that `Ny` has to be divisible by `Rx` and `Ry` while `Nz` has to be divisible by `Ry`, where `Rx` and `Ry` are the number of ranks (divisions) in the x and y direction. Relaxing the requirements should not be too difficult. Nice, thanks for that explanation. Why are we following 2decomp? PencilArrays has some benchmarking that shows it can compete with the fastest codes out there. I don't see anything similar for 2decomp, so I can't figure out what the motivation for following that strategy would be. I'm not sure if they are different, either. Something we do not previously support (but which is implemented in https://github.com/CliMA/Oceananigans.jl/pull/2538) was an algorithm that could support any topology with vertically-stretched grids. What is the relationship between this PR and https://github.com/CliMA/Oceananigans.jl/pull/2538, and does this PR support vertically stretched grids?. One of the main limitations of PencilArrays from our perspective is that it could not distribute an array along the first dimension. Since we almost always would like to use vertically stretched grids (and for various reasons, we may want to also compute the hydrostatic pressure with a vertical integral), ocean LES are typically distributed in x and y. Therefore, in order to support 2D domain decompositions, we were faced with somehow ch",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-1728278859
Testability,benchmark,benchmarking,"> @matinraayai is working on making PencilArrays performant. This PR is exploratory and is a fallback that might not be merged if we find an efficient way to do GPU transposes with PencilArrays (requires reducing memory allocations and improving the efficiency of permute operations) and implement r2r Fourier transforms in PencilFFTs. For the moment those two elements are part of this PR.; > ; > This PR follows the (simple) configuration of the 2decomp library https://github.com/2decomp-fft/2decomp-fft, the difference between PencilFFT/PencilArray and this PR (a part bounded domain ffts) is that here (at the moment) we impose the stricter limitation that `Ny` has to be divisible by `Rx` and `Ry` while `Nz` has to be divisible by `Ry`, where `Rx` and `Ry` are the number of ranks (divisions) in the x and y direction. Relaxing the requirements should not be too difficult. Nice, thanks for that explanation. Why are we following 2decomp? PencilArrays has some benchmarking that shows it can compete with the fastest codes out there. I don't see anything similar for 2decomp, so I can't figure out what the motivation for following that strategy would be. I'm not sure if they are different, either. Something we do not previously support (but which is implemented in https://github.com/CliMA/Oceananigans.jl/pull/2538) was an algorithm that could support any topology with vertically-stretched grids. What is the relationship between this PR and https://github.com/CliMA/Oceananigans.jl/pull/2538, and does this PR support vertically stretched grids?. One of the main limitations of PencilArrays from our perspective is that it could not distribute an array along the first dimension. Since we almost always would like to use vertically stretched grids (and for various reasons, we may want to also compute the hydrostatic pressure with a vertical integral), ocean LES are typically distributed in x and y. Therefore, in order to support 2D domain decompositions, we were faced with somehow ch",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-1728278859
Usability,simpl,simple,"> @matinraayai is working on making PencilArrays performant. This PR is exploratory and is a fallback that might not be merged if we find an efficient way to do GPU transposes with PencilArrays (requires reducing memory allocations and improving the efficiency of permute operations) and implement r2r Fourier transforms in PencilFFTs. For the moment those two elements are part of this PR.; > ; > This PR follows the (simple) configuration of the 2decomp library https://github.com/2decomp-fft/2decomp-fft, the difference between PencilFFT/PencilArray and this PR (a part bounded domain ffts) is that here (at the moment) we impose the stricter limitation that `Ny` has to be divisible by `Rx` and `Ry` while `Nz` has to be divisible by `Ry`, where `Rx` and `Ry` are the number of ranks (divisions) in the x and y direction. Relaxing the requirements should not be too difficult. Nice, thanks for that explanation. Why are we following 2decomp? PencilArrays has some benchmarking that shows it can compete with the fastest codes out there. I don't see anything similar for 2decomp, so I can't figure out what the motivation for following that strategy would be. I'm not sure if they are different, either. Something we do not previously support (but which is implemented in https://github.com/CliMA/Oceananigans.jl/pull/2538) was an algorithm that could support any topology with vertically-stretched grids. What is the relationship between this PR and https://github.com/CliMA/Oceananigans.jl/pull/2538, and does this PR support vertically stretched grids?. One of the main limitations of PencilArrays from our perspective is that it could not distribute an array along the first dimension. Since we almost always would like to use vertically stretched grids (and for various reasons, we may want to also compute the hydrostatic pressure with a vertical integral), ocean LES are typically distributed in x and y. Therefore, in order to support 2D domain decompositions, we were faced with somehow ch",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-1728278859
Usability,clear,clearer,I have added a bit of documentation for the `transpose` functions. Now everything should be a bit clearer,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-2233468948
Availability,down,down,"Interesting! Good find. This not the only thing to worry about regarding the entrainment diffusivity. It's effect also seems to depend on vertical resolution, and it only seems useful at low resolutions. In general, I recommend switching to CATKEVerticalDiffusivity, where we have put a lot of effort into solving those problems. I'm going to suggest a different solution that setting some maximum capping diffusivity. I think setting a maximum diffusivity could work, but that there are better solutions that more directly address the underlying issue. I think the issue here is that ""entrainment"" should not occur across low stratification regions. Thus this model for ""entrainment"" assumes the stratification is ""strong"". More generally, we are dividing the boundary layer into a convecting region and an entraining region. We identify the convecting region by `N² < 0`. However, in reality the convecting region should extend further down into regions of stable, but still weak stratification below the unstable region. The ""entraining"" layer is more properly where stratification significantly increases over the weakly stratified lower part of the convecting region. (This analysis is based on LES.) `RiBasedVerticalDiffusivity`'s formulation --- apart from being overly simple --- simply cannot cope with the complexity of real boundary layer structure because it is not truly non-local. Really addressing this issue (eg implementing a more physically accurate model of boundary layer structure) might require using a vertical integral instead of a 3D kernel. (We decided that because CATKE seems like a decent parameterization, it's not worth it to pursue those accuracy improvements). One way to fix the issue but retaining a 3D kernel is to change the way we estimate ""convecting"" and ""entraining"" regions. Those criteria are. https://github.com/CliMA/Oceananigans.jl/blob/94e99e1d5fb3d121a6d801a931987bb6ff59f20e/src/TurbulenceClosures/turbulence_closure_implementations/ri_based_vertical_d",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3283#issuecomment-1731439718
Integrability,depend,depend,"Interesting! Good find. This not the only thing to worry about regarding the entrainment diffusivity. It's effect also seems to depend on vertical resolution, and it only seems useful at low resolutions. In general, I recommend switching to CATKEVerticalDiffusivity, where we have put a lot of effort into solving those problems. I'm going to suggest a different solution that setting some maximum capping diffusivity. I think setting a maximum diffusivity could work, but that there are better solutions that more directly address the underlying issue. I think the issue here is that ""entrainment"" should not occur across low stratification regions. Thus this model for ""entrainment"" assumes the stratification is ""strong"". More generally, we are dividing the boundary layer into a convecting region and an entraining region. We identify the convecting region by `N² < 0`. However, in reality the convecting region should extend further down into regions of stable, but still weak stratification below the unstable region. The ""entraining"" layer is more properly where stratification significantly increases over the weakly stratified lower part of the convecting region. (This analysis is based on LES.) `RiBasedVerticalDiffusivity`'s formulation --- apart from being overly simple --- simply cannot cope with the complexity of real boundary layer structure because it is not truly non-local. Really addressing this issue (eg implementing a more physically accurate model of boundary layer structure) might require using a vertical integral instead of a 3D kernel. (We decided that because CATKE seems like a decent parameterization, it's not worth it to pursue those accuracy improvements). One way to fix the issue but retaining a 3D kernel is to change the way we estimate ""convecting"" and ""entraining"" regions. Those criteria are. https://github.com/CliMA/Oceananigans.jl/blob/94e99e1d5fb3d121a6d801a931987bb6ff59f20e/src/TurbulenceClosures/turbulence_closure_implementations/ri_based_vertical_d",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3283#issuecomment-1731439718
Modifiability,extend,extend,"Interesting! Good find. This not the only thing to worry about regarding the entrainment diffusivity. It's effect also seems to depend on vertical resolution, and it only seems useful at low resolutions. In general, I recommend switching to CATKEVerticalDiffusivity, where we have put a lot of effort into solving those problems. I'm going to suggest a different solution that setting some maximum capping diffusivity. I think setting a maximum diffusivity could work, but that there are better solutions that more directly address the underlying issue. I think the issue here is that ""entrainment"" should not occur across low stratification regions. Thus this model for ""entrainment"" assumes the stratification is ""strong"". More generally, we are dividing the boundary layer into a convecting region and an entraining region. We identify the convecting region by `N² < 0`. However, in reality the convecting region should extend further down into regions of stable, but still weak stratification below the unstable region. The ""entraining"" layer is more properly where stratification significantly increases over the weakly stratified lower part of the convecting region. (This analysis is based on LES.) `RiBasedVerticalDiffusivity`'s formulation --- apart from being overly simple --- simply cannot cope with the complexity of real boundary layer structure because it is not truly non-local. Really addressing this issue (eg implementing a more physically accurate model of boundary layer structure) might require using a vertical integral instead of a 3D kernel. (We decided that because CATKE seems like a decent parameterization, it's not worth it to pursue those accuracy improvements). One way to fix the issue but retaining a 3D kernel is to change the way we estimate ""convecting"" and ""entraining"" regions. Those criteria are. https://github.com/CliMA/Oceananigans.jl/blob/94e99e1d5fb3d121a6d801a931987bb6ff59f20e/src/TurbulenceClosures/turbulence_closure_implementations/ri_based_vertical_d",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3283#issuecomment-1731439718
Usability,simpl,simple,"t into solving those problems. I'm going to suggest a different solution that setting some maximum capping diffusivity. I think setting a maximum diffusivity could work, but that there are better solutions that more directly address the underlying issue. I think the issue here is that ""entrainment"" should not occur across low stratification regions. Thus this model for ""entrainment"" assumes the stratification is ""strong"". More generally, we are dividing the boundary layer into a convecting region and an entraining region. We identify the convecting region by `N² < 0`. However, in reality the convecting region should extend further down into regions of stable, but still weak stratification below the unstable region. The ""entraining"" layer is more properly where stratification significantly increases over the weakly stratified lower part of the convecting region. (This analysis is based on LES.) `RiBasedVerticalDiffusivity`'s formulation --- apart from being overly simple --- simply cannot cope with the complexity of real boundary layer structure because it is not truly non-local. Really addressing this issue (eg implementing a more physically accurate model of boundary layer structure) might require using a vertical integral instead of a 3D kernel. (We decided that because CATKE seems like a decent parameterization, it's not worth it to pursue those accuracy improvements). One way to fix the issue but retaining a 3D kernel is to change the way we estimate ""convecting"" and ""entraining"" regions. Those criteria are. https://github.com/CliMA/Oceananigans.jl/blob/94e99e1d5fb3d121a6d801a931987bb6ff59f20e/src/TurbulenceClosures/turbulence_closure_implementations/ri_based_vertical_diffusivity.jl#L247-L248. If we introduce a new parameter, say `minimum_entrainment_buoyancy_frequency`, then we can modify this criteria to read. ```julia; convecting = N² < 0 # applies regardless of Qᵇ . N²_entrainment = minimum_entrainment_buoyancy_frequency; entraining = (N²_above < 0) & (N² > ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3283#issuecomment-1731439718
Integrability,interface,interface,"Is this extra simplicity in the user interface worth the extra code to maintain?. I personally think it's nice to have all IC signatures, etc., the same independently of grid topology. It makes it easy to catch newbie mistakes when reviewing code. I also think a user can easily infer that `z` in the signature can be ignored if they just defined a grid with a `Flat` z topology, so I think the added user-friendliness is minor. (Maybe even negative since the signatures now can change based on `topology(grid)`?)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3285#issuecomment-1776250680
Usability,simpl,simplicity,"Is this extra simplicity in the user interface worth the extra code to maintain?. I personally think it's nice to have all IC signatures, etc., the same independently of grid topology. It makes it easy to catch newbie mistakes when reviewing code. I also think a user can easily infer that `z` in the signature can be ignored if they just defined a grid with a `Flat` z topology, so I think the added user-friendliness is minor. (Maybe even negative since the signatures now can change based on `topology(grid)`?)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3285#issuecomment-1776250680
Energy Efficiency,meter,meter,"eans that more changes are required to port a script from having a `Flat` direction to being fully three-dimensional. I'm not sure I understand the point about newbie mistakes though. > I also think a user can easily infer that z in the signature can be ignored if they just defined a grid with a Flat z topology, so I think the added user-friendliness is minor. It's true that in our examples, `set!` is typically invoked close to the grid definition. But such proximity is not guaranteed. In complicated applications (say for example a realistic simulation on the globe), a grid may be constructed ""for"" the user. One case that's come up recently is coupled ocean, sea-ice simulations. For a realistic case covering the globe, the user script may well not include the creation of the grid (which would happen within a helper function like `build_global_ocean_sea_ice_simulation`). Even if the grid construction is immediately readable, I think it's still weird to read. ```julia; initial_ice_thickness(x, y, z) = 1 # meter; ```. as determining sea ice thickness --- its nonsensical for the ice thickness to depend on `z`. Ice thickness _cannot_ depend on `z`. The z topology of a slab ice model cannot be anything but `Flat`; it doesn't make sense to have a z-coordinate. That's also true for the `ShallowWaterModel`. Also there function signatures depend on `z` despite that no shallow water field can possibly depend on the third coordinate. > (Maybe even negative since the signatures now can change based on topology(grid)?). I think it's correct to observe that this change does not prioritize _writing_ scripts --- it prioritizes the experience of _reading_ scripts. I think the scripts read better with this change. The purpose of ""function notation"" is to indicate the variables on which the function depends (usually including just dependent coordinates, like `x`, `y`, or `z`). In almost all contexts, we should not include irrelevant variables in a function signature. So I feel this chan",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3285#issuecomment-1776585405
Integrability,interface,interface,"> Is this extra simplicity in the user interface worth the extra code to maintain?. Given the minor code changes required and the priority we place on user interface, I think so. > I personally think it's nice to have all IC signatures, etc., the same independently of grid topology. It makes it easy to catch newbie mistakes when reviewing code. I do agree that this change means that more changes are required to port a script from having a `Flat` direction to being fully three-dimensional. I'm not sure I understand the point about newbie mistakes though. > I also think a user can easily infer that z in the signature can be ignored if they just defined a grid with a Flat z topology, so I think the added user-friendliness is minor. It's true that in our examples, `set!` is typically invoked close to the grid definition. But such proximity is not guaranteed. In complicated applications (say for example a realistic simulation on the globe), a grid may be constructed ""for"" the user. One case that's come up recently is coupled ocean, sea-ice simulations. For a realistic case covering the globe, the user script may well not include the creation of the grid (which would happen within a helper function like `build_global_ocean_sea_ice_simulation`). Even if the grid construction is immediately readable, I think it's still weird to read. ```julia; initial_ice_thickness(x, y, z) = 1 # meter; ```. as determining sea ice thickness --- its nonsensical for the ice thickness to depend on `z`. Ice thickness _cannot_ depend on `z`. The z topology of a slab ice model cannot be anything but `Flat`; it doesn't make sense to have a z-coordinate. That's also true for the `ShallowWaterModel`. Also there function signatures depend on `z` despite that no shallow water field can possibly depend on the third coordinate. > (Maybe even negative since the signatures now can change based on topology(grid)?). I think it's correct to observe that this change does not prioritize _writing_ scripts --- it",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3285#issuecomment-1776585405
Modifiability,variab,variables,"e-dimensional. I'm not sure I understand the point about newbie mistakes though. > I also think a user can easily infer that z in the signature can be ignored if they just defined a grid with a Flat z topology, so I think the added user-friendliness is minor. It's true that in our examples, `set!` is typically invoked close to the grid definition. But such proximity is not guaranteed. In complicated applications (say for example a realistic simulation on the globe), a grid may be constructed ""for"" the user. One case that's come up recently is coupled ocean, sea-ice simulations. For a realistic case covering the globe, the user script may well not include the creation of the grid (which would happen within a helper function like `build_global_ocean_sea_ice_simulation`). Even if the grid construction is immediately readable, I think it's still weird to read. ```julia; initial_ice_thickness(x, y, z) = 1 # meter; ```. as determining sea ice thickness --- its nonsensical for the ice thickness to depend on `z`. Ice thickness _cannot_ depend on `z`. The z topology of a slab ice model cannot be anything but `Flat`; it doesn't make sense to have a z-coordinate. That's also true for the `ShallowWaterModel`. Also there function signatures depend on `z` despite that no shallow water field can possibly depend on the third coordinate. > (Maybe even negative since the signatures now can change based on topology(grid)?). I think it's correct to observe that this change does not prioritize _writing_ scripts --- it prioritizes the experience of _reading_ scripts. I think the scripts read better with this change. The purpose of ""function notation"" is to indicate the variables on which the function depends (usually including just dependent coordinates, like `x`, `y`, or `z`). In almost all contexts, we should not include irrelevant variables in a function signature. So I feel this change brings the experience of reading Oceananigans code into better alignment with most scientific text.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3285#issuecomment-1776585405
Usability,simpl,simplicity,"> Is this extra simplicity in the user interface worth the extra code to maintain?. Given the minor code changes required and the priority we place on user interface, I think so. > I personally think it's nice to have all IC signatures, etc., the same independently of grid topology. It makes it easy to catch newbie mistakes when reviewing code. I do agree that this change means that more changes are required to port a script from having a `Flat` direction to being fully three-dimensional. I'm not sure I understand the point about newbie mistakes though. > I also think a user can easily infer that z in the signature can be ignored if they just defined a grid with a Flat z topology, so I think the added user-friendliness is minor. It's true that in our examples, `set!` is typically invoked close to the grid definition. But such proximity is not guaranteed. In complicated applications (say for example a realistic simulation on the globe), a grid may be constructed ""for"" the user. One case that's come up recently is coupled ocean, sea-ice simulations. For a realistic case covering the globe, the user script may well not include the creation of the grid (which would happen within a helper function like `build_global_ocean_sea_ice_simulation`). Even if the grid construction is immediately readable, I think it's still weird to read. ```julia; initial_ice_thickness(x, y, z) = 1 # meter; ```. as determining sea ice thickness --- its nonsensical for the ice thickness to depend on `z`. Ice thickness _cannot_ depend on `z`. The z topology of a slab ice model cannot be anything but `Flat`; it doesn't make sense to have a z-coordinate. That's also true for the `ShallowWaterModel`. Also there function signatures depend on `z` despite that no shallow water field can possibly depend on the third coordinate. > (Maybe even negative since the signatures now can change based on topology(grid)?). I think it's correct to observe that this change does not prioritize _writing_ scripts --- it",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3285#issuecomment-1776585405
Availability,error,errors,"> > I personally think it's nice to have all IC signatures, etc., the same independently of grid topology. It makes it easy to catch newbie mistakes when reviewing code.; > ; > I do agree that this change means that more changes are required to port a script from having a `Flat` direction to being fully three-dimensional. I'm not sure I understand the point about newbie mistakes though. I just noticed that a lot of errors from new users that I've helped come from having the wrong function signatures, either when imposing initial or boundary conditions or forcings. With standardized ""3D"" function calls it makes it easier to catch. My fear is that making things less standardized (i.e. adding more possibilities), it'll be harder to spot these mistakes. But I guess your hope is that this will decrease the number of mistakes in the first place since the signatures hopefully will become more intuitive?. > I think the scripts read better with this change. Agreed.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3285#issuecomment-1777364648
Usability,intuit,intuitive,"> > I personally think it's nice to have all IC signatures, etc., the same independently of grid topology. It makes it easy to catch newbie mistakes when reviewing code.; > ; > I do agree that this change means that more changes are required to port a script from having a `Flat` direction to being fully three-dimensional. I'm not sure I understand the point about newbie mistakes though. I just noticed that a lot of errors from new users that I've helped come from having the wrong function signatures, either when imposing initial or boundary conditions or forcings. With standardized ""3D"" function calls it makes it easier to catch. My fear is that making things less standardized (i.e. adding more possibilities), it'll be harder to spot these mistakes. But I guess your hope is that this will decrease the number of mistakes in the first place since the signatures hopefully will become more intuitive?. > I think the scripts read better with this change. Agreed.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3285#issuecomment-1777364648
Usability,intuit,intuitive,"> But I guess your hope is that this will decrease the number of mistakes in the first place since the signatures hopefully will become more intuitive?. It will make the function signatures more specific to the problem at hand, which broadly speaking eliminates more bugs. For example, in a one dimensional problem there is only one function argument, completely eliminating the possibility of mix up between two coordinates. But I think the main advantage is making the scripts more readable. I don't think there's much of a change to how ""intuitive"" the API is.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3285#issuecomment-1777710858
Usability,simpl,simply,It may be the answer to several conundrums. Or simply not many use fields for BCs?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3286#issuecomment-1735856663
Deployability,integrat,integrated,"The movies don't play for me. But it seems like a vertically-integrated component (a constant) is missing from the hydrostatic pressure anomaly in the case of a vertically-periodic domain?. https://github.com/CliMA/Oceananigans.jl/blob/e16cdc6cfb67703df9e29368017868331f68b1c0/src/Models/NonhydrostaticModels/update_hydrostatic_pressure.jl#L12-L20. Actually, maybe it's the other way around -- the vertically-integrated component needs to be subtracted when the domain is vertically periodic? This is effectively what occurs here for example:. https://github.com/CliMA/Oceananigans.jl/blob/e16cdc6cfb67703df9e29368017868331f68b1c0/src/Solvers/fft_based_poisson_solver.jl#L111. However this is not enforced for the hydrostatic pressure. The tridiagonal solvers are also incorrect for vertically-periodic domains, I think (well, now that we have x- and y- tridiagonal solvers I believe they are also incorrect for x- and y- periodic if using an x-tridiagonal or y-tridiagonal solver). Either way it does seem like the simplest solution is to eliminate the pressure decomposition. Interested what @simone-silvestri and @xkykai think.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3290#issuecomment-1734536074
Integrability,integrat,integrated,"The movies don't play for me. But it seems like a vertically-integrated component (a constant) is missing from the hydrostatic pressure anomaly in the case of a vertically-periodic domain?. https://github.com/CliMA/Oceananigans.jl/blob/e16cdc6cfb67703df9e29368017868331f68b1c0/src/Models/NonhydrostaticModels/update_hydrostatic_pressure.jl#L12-L20. Actually, maybe it's the other way around -- the vertically-integrated component needs to be subtracted when the domain is vertically periodic? This is effectively what occurs here for example:. https://github.com/CliMA/Oceananigans.jl/blob/e16cdc6cfb67703df9e29368017868331f68b1c0/src/Solvers/fft_based_poisson_solver.jl#L111. However this is not enforced for the hydrostatic pressure. The tridiagonal solvers are also incorrect for vertically-periodic domains, I think (well, now that we have x- and y- tridiagonal solvers I believe they are also incorrect for x- and y- periodic if using an x-tridiagonal or y-tridiagonal solver). Either way it does seem like the simplest solution is to eliminate the pressure decomposition. Interested what @simone-silvestri and @xkykai think.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3290#issuecomment-1734536074
Usability,simpl,simplest,"The movies don't play for me. But it seems like a vertically-integrated component (a constant) is missing from the hydrostatic pressure anomaly in the case of a vertically-periodic domain?. https://github.com/CliMA/Oceananigans.jl/blob/e16cdc6cfb67703df9e29368017868331f68b1c0/src/Models/NonhydrostaticModels/update_hydrostatic_pressure.jl#L12-L20. Actually, maybe it's the other way around -- the vertically-integrated component needs to be subtracted when the domain is vertically periodic? This is effectively what occurs here for example:. https://github.com/CliMA/Oceananigans.jl/blob/e16cdc6cfb67703df9e29368017868331f68b1c0/src/Solvers/fft_based_poisson_solver.jl#L111. However this is not enforced for the hydrostatic pressure. The tridiagonal solvers are also incorrect for vertically-periodic domains, I think (well, now that we have x- and y- tridiagonal solvers I believe they are also incorrect for x- and y- periodic if using an x-tridiagonal or y-tridiagonal solver). Either way it does seem like the simplest solution is to eliminate the pressure decomposition. Interested what @simone-silvestri and @xkykai think.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3290#issuecomment-1734536074
Usability,clear,clear,"> The movies don't play for me. Weird, they're playing for me on two different browsers... not sure what to do about that. > The tridiagonal solvers are also incorrect for vertically-periodic domains, I think (well, now that we have x- and y- tridiagonal solvers I believe they are also incorrect for x- and y- periodic if using an x-tridiagonal or y-tridiagonal solver). True, but just to be clear, these simulations don't use any stretched grid direction, so I believe they don't use the tridiagonal solver, correct?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3290#issuecomment-1734543228
Testability,test,test,"> > The movies don't play for me.; > ; > Weird, they're playing for me on two different browsers... not sure what to do about that. There's nothing for you to do, I was on plane internet! I can see it now. I was just letting you know... > > The tridiagonal solvers are also incorrect for vertically-periodic domains, I think (well, now that we have x- and y- tridiagonal solvers I believe they are also incorrect for x- and y- periodic if using an x-tridiagonal or y-tridiagonal solver).; > ; > True, but just to be clear, these simulations don't use any stretched grid direction, so I believe they don't use the tridiagonal solver, correct?. Correct --- I just wanted to issue that warning in case there was more interest in vertically-periodic simulations (we basically don't test that situation, but it wouldn't be unreasonable to work on that).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3290#issuecomment-1734754117
Usability,clear,clear,"> > The movies don't play for me.; > ; > Weird, they're playing for me on two different browsers... not sure what to do about that. There's nothing for you to do, I was on plane internet! I can see it now. I was just letting you know... > > The tridiagonal solvers are also incorrect for vertically-periodic domains, I think (well, now that we have x- and y- tridiagonal solvers I believe they are also incorrect for x- and y- periodic if using an x-tridiagonal or y-tridiagonal solver).; > ; > True, but just to be clear, these simulations don't use any stretched grid direction, so I believe they don't use the tridiagonal solver, correct?. Correct --- I just wanted to issue that warning in case there was more interest in vertically-periodic simulations (we basically don't test that situation, but it wouldn't be unreasonable to work on that).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3290#issuecomment-1734754117
Usability,simpl,simpler,"I'm trying to debug the situation and the code hangs long time at model construction. Is this happening for you @siddharthabishnu?. Even this simpler:. ```Julia; using Oceananigans. grid = ConformalCubedSphereGrid(; panel_size = (10, 10, 2),; z = (-1, 0),; horizontal_direction_halo = 3). model = HydrostaticFreeSurfaceModel(; grid, momentum_advection = VectorInvariant()); ```. took 10 min to run.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3302#issuecomment-1742744955
Usability,simpl,simpler,"> I'm trying to debug the situation and the code hangs long time at model construction. Is this happening for you @siddharthabishnu?; > ; > Even this simpler:; > ; > ```julia; > using Oceananigans; > ; > grid = ConformalCubedSphereGrid(; panel_size = (10, 10, 2),; > z = (-1, 0),; > horizontal_direction_halo = 3); > ; > model = HydrostaticFreeSurfaceModel(; grid, momentum_advection = VectorInvariant()); > ```; > ; > took 10 min to run. Yes, it happened for me too.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3302#issuecomment-1742939924
Security,validat,validation,"@siddharthabishnu, perhaps it's simpler to try explicit free surface. Have a look, e.g., at . https://github.com/CliMA/Oceananigans.jl/blob/c9aa1b3b90c9775e4f3a98b7c67f916727830aee/validation/multi_region/cubed_sphere_momentum_dynamics.jl#L63",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3302#issuecomment-1747351924
Usability,simpl,simpler,"@siddharthabishnu, perhaps it's simpler to try explicit free surface. Have a look, e.g., at . https://github.com/CliMA/Oceananigans.jl/blob/c9aa1b3b90c9775e4f3a98b7c67f916727830aee/validation/multi_region/cubed_sphere_momentum_dynamics.jl#L63",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3302#issuecomment-1747351924
Security,validat,validation,"> @siddharthabishnu, perhaps it's simpler to try explicit free surface. Have a look, e.g., at; > ; > https://github.com/CliMA/Oceananigans.jl/blob/c9aa1b3b90c9775e4f3a98b7c67f916727830aee/validation/multi_region/cubed_sphere_momentum_dynamics.jl#L63. Thanks @navidcy. Switching to fully explicit free surface from the default implicit one resolved the boundary condition issue I mentioned in the beginning of this conversation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3302#issuecomment-1747675234
Usability,simpl,simpler,"> @siddharthabishnu, perhaps it's simpler to try explicit free surface. Have a look, e.g., at; > ; > https://github.com/CliMA/Oceananigans.jl/blob/c9aa1b3b90c9775e4f3a98b7c67f916727830aee/validation/multi_region/cubed_sphere_momentum_dynamics.jl#L63. Thanks @navidcy. Switching to fully explicit free surface from the default implicit one resolved the boundary condition issue I mentioned in the beginning of this conversation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3302#issuecomment-1747675234
Testability,test,test,"Probably the quickest way to start is simply to add the ""holes"" manually after calling `compute!`. The reason this test is failing is not because `compute!` doesn't work, right? Getting `compute!` to work is just visualization.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3306#issuecomment-1758655160
Usability,simpl,simply,"Probably the quickest way to start is simply to add the ""holes"" manually after calling `compute!`. The reason this test is failing is not because `compute!` doesn't work, right? Getting `compute!` to work is just visualization.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3306#issuecomment-1758655160
Testability,test,test,"> Probably the quickest way to start is simply to add the ""holes"" manually after calling `compute!`.; > ; > The reason this test is failing is not because `compute!` doesn't work, right? Getting `compute!` to work is just visualization. We need to be able to compute the vorticity in those points as well as those points are involved in the $\zeta \hat{\boldsymbol{k}} \times \boldsymbol{u}$ term. So I think the dynamics test is blowing up because of that, but I'm not 100% sure.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3306#issuecomment-1759433251
Usability,simpl,simply,"> Probably the quickest way to start is simply to add the ""holes"" manually after calling `compute!`.; > ; > The reason this test is failing is not because `compute!` doesn't work, right? Getting `compute!` to work is just visualization. We need to be able to compute the vorticity in those points as well as those points are involved in the $\zeta \hat{\boldsymbol{k}} \times \boldsymbol{u}$ term. So I think the dynamics test is blowing up because of that, but I'm not 100% sure.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3306#issuecomment-1759433251
Modifiability,extend,extend,"> > Probably the quickest way to start is simply to add the ""holes"" manually after calling `compute!`.; > > The reason this test is failing is not because `compute!` doesn't work, right? Getting `compute!` to work is just visualization.; > ; > We need to be able to compute the vorticity in those points as well as those points are involved in the ζk^×u term. So I think the dynamics test is blowing up because of that, but I'm not 100% sure. But I think the problem here is just that the kernel launched by `compute!` does not extend to all the points where zeta is defined. On the other hand, when zeta is used during time-stepping, we compute it for the u- and v- tendency kernels. In those kernels, all relevant grid points are touched.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3306#issuecomment-1759751128
Testability,test,test,"> > Probably the quickest way to start is simply to add the ""holes"" manually after calling `compute!`.; > > The reason this test is failing is not because `compute!` doesn't work, right? Getting `compute!` to work is just visualization.; > ; > We need to be able to compute the vorticity in those points as well as those points are involved in the ζk^×u term. So I think the dynamics test is blowing up because of that, but I'm not 100% sure. But I think the problem here is just that the kernel launched by `compute!` does not extend to all the points where zeta is defined. On the other hand, when zeta is used during time-stepping, we compute it for the u- and v- tendency kernels. In those kernels, all relevant grid points are touched.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3306#issuecomment-1759751128
Usability,simpl,simply,"> > Probably the quickest way to start is simply to add the ""holes"" manually after calling `compute!`.; > > The reason this test is failing is not because `compute!` doesn't work, right? Getting `compute!` to work is just visualization.; > ; > We need to be able to compute the vorticity in those points as well as those points are involved in the ζk^×u term. So I think the dynamics test is blowing up because of that, but I'm not 100% sure. But I think the problem here is just that the kernel launched by `compute!` does not extend to all the points where zeta is defined. On the other hand, when zeta is used during time-stepping, we compute it for the u- and v- tendency kernels. In those kernels, all relevant grid points are touched.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3306#issuecomment-1759751128
Integrability,wrap,wrap,We should wrap up this PR. Let's discuss what's needed. The most important thing is modifying src and test to reflect what we learned.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3306#issuecomment-1970727232
Testability,test,test,We should wrap up this PR. Let's discuss what's needed. The most important thing is modifying src and test to reflect what we learned.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3306#issuecomment-1970727232
Usability,learn,learned,We should wrap up this PR. Let's discuss what's needed. The most important thing is modifying src and test to reflect what we learned.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3306#issuecomment-1970727232
Availability,error,errors,"When running the script on a CPU with `--check-bounds=yes`, the script can be finished without errors:; ```; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (112.172 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (3.376 seconds).; [ Info: Simulation is stopping after running for 7.945 seconds.; [ Info: Model iteration 200 equals or exceeds stop iteration 200.; ```. I should make it clear that `CFL=10` is not large enough to make particles move out of the domain. `CFL` should be larger than `Nx`, because the distance at which a particle moves in one time step needs to larger than the domain size \(not the grid size\). That means $u \Delta t > L_x$, which is equivalent to `CFL > Nx`. Using a `CFL` of `51` (`Nx = 50` in this case) reproduces the error on a CPU:; ```; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (108.842 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (3.303 seconds).; ERROR: LoadError: BoundsError: attempt to access 56×56×56 OffsetArray(::Array{Float64, 3}, -2:53, -2:53, -2:53) with eltype Float64 with indices -2:53×-2:53×-2:53 at index [54, 49, 1]; Stacktrace:; [1] throw_boundserror(A::OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, I::Tuple{Int64, Int64, Int64}); @ Base ./abstractarray.jl:744; [2] checkbounds; @ ./abstractarray.jl:709 [inlined]; [3] getindex; @ ~/.julia/packages/OffsetArrays/0MOrf/src/OffsetArrays.jl:420 [inlined]; [4] getindex; @ ~/Documents/IdealizedOceanWorlds.jl/OceananigansMemeoryIssue.jl/dev/Oceananigans/src/Fields/field.jl:399 [inlined]; [5] getindex; @ ~/Documents/IdealizedOceanWorlds.jl/OceananigansMemeoryIssue.jl/dev/Oceananigans/src/Utils/sum_of_arrays.jl:23 [inlined]; [6] _interpolate; @ ~/Documents/IdealizedOceanWorlds.jl/OceananigansMemeoryIssue.jl/dev/Oceananigans/src/Fields/interpolate.jl:148 [inlined]; [7] interpolate; @ ~/Documents/IdealizedOceanWorlds.jl/Oceananig",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1773032135
Integrability,message,message,"s).; ERROR: LoadError: BoundsError: attempt to access 56×56×56 OffsetArray(::Array{Float64, 3}, -2:53, -2:53, -2:53) with eltype Float64 with indices -2:53×-2:53×-2:53 at index [54, 49, 1]; Stacktrace:; [1] throw_boundserror(A::OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, I::Tuple{Int64, Int64, Int64}); @ Base ./abstractarray.jl:744; [2] checkbounds; @ ./abstractarray.jl:709 [inlined]; [3] getindex; @ ~/.julia/packages/OffsetArrays/0MOrf/src/OffsetArrays.jl:420 [inlined]; [4] getindex; @ ~/Documents/IdealizedOceanWorlds.jl/OceananigansMemeoryIssue.jl/dev/Oceananigans/src/Fields/field.jl:399 [inlined]; [5] getindex; @ ~/Documents/IdealizedOceanWorlds.jl/OceananigansMemeoryIssue.jl/dev/Oceananigans/src/Utils/sum_of_arrays.jl:23 [inlined]; [6] _interpolate; @ ~/Documents/IdealizedOceanWorlds.jl/OceananigansMemeoryIssue.jl/dev/Oceananigans/src/Fields/interpolate.jl:148 [inlined]; [7] interpolate; @ ~/Documents/IdealizedOceanWorlds.jl/OceananigansMemeoryIssue.jl/dev/Oceananigans/src/Fields/interpolate.jl:197 [inlined]; [8] advect_particle; @ ~/Documents/IdealizedOceanWorlds.jl/OceananigansMemeoryIssue.jl/dev/Oceananigans/src/Models/LagrangianParticleTracking/lagrangian_particle_advection.jl:83 [inlined]; [9] macro expansion; @ ~/Documents/IdealizedOceanWorlds.jl/OceananigansMemeoryIssue.jl/dev/Oceananigans/src/Models/LagrangianParticleTracking/lagrangian_particle_advection.jl:145 [inlined]; [10] cpu__advect_particles!; @ ~/.julia/packages/KernelAbstractions/cWlFz/src/macros.jl:276 [inlined]; ...; ```. I do not see why viscosity/Coriolis/buoyancy is required for shear instability. Anyway, I found another way to reproduce the error on CPU, while keeping `CFL = 10`, is to introduce a small perturbation to the initial velocity field:; ```Julia; function initial_u(x::R, y::R, z::R) where {R<:Real}; ϵ = 1e-7; return (max_velocity / Lx) * y + ϵ * max_velocity * sin(6π * x / Lx); end; ```. The output error message is the same as the previous one, in which `CFL = 51`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1773032135
Security,access,access,"imulation initialization complete (112.172 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (3.376 seconds).; [ Info: Simulation is stopping after running for 7.945 seconds.; [ Info: Model iteration 200 equals or exceeds stop iteration 200.; ```. I should make it clear that `CFL=10` is not large enough to make particles move out of the domain. `CFL` should be larger than `Nx`, because the distance at which a particle moves in one time step needs to larger than the domain size \(not the grid size\). That means $u \Delta t > L_x$, which is equivalent to `CFL > Nx`. Using a `CFL` of `51` (`Nx = 50` in this case) reproduces the error on a CPU:; ```; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (108.842 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (3.303 seconds).; ERROR: LoadError: BoundsError: attempt to access 56×56×56 OffsetArray(::Array{Float64, 3}, -2:53, -2:53, -2:53) with eltype Float64 with indices -2:53×-2:53×-2:53 at index [54, 49, 1]; Stacktrace:; [1] throw_boundserror(A::OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, I::Tuple{Int64, Int64, Int64}); @ Base ./abstractarray.jl:744; [2] checkbounds; @ ./abstractarray.jl:709 [inlined]; [3] getindex; @ ~/.julia/packages/OffsetArrays/0MOrf/src/OffsetArrays.jl:420 [inlined]; [4] getindex; @ ~/Documents/IdealizedOceanWorlds.jl/OceananigansMemeoryIssue.jl/dev/Oceananigans/src/Fields/field.jl:399 [inlined]; [5] getindex; @ ~/Documents/IdealizedOceanWorlds.jl/OceananigansMemeoryIssue.jl/dev/Oceananigans/src/Utils/sum_of_arrays.jl:23 [inlined]; [6] _interpolate; @ ~/Documents/IdealizedOceanWorlds.jl/OceananigansMemeoryIssue.jl/dev/Oceananigans/src/Fields/interpolate.jl:148 [inlined]; [7] interpolate; @ ~/Documents/IdealizedOceanWorlds.jl/OceananigansMemeoryIssue.jl/dev/Oceananigans/src/Fields/interpolate.jl:197 [inlined]; [8] advect_particle; @ ~/Documents/IdealizedOceanWorlds.jl/OceananigansMemeoryIs",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1773032135
Usability,clear,clear,"When running the script on a CPU with `--check-bounds=yes`, the script can be finished without errors:; ```; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (112.172 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (3.376 seconds).; [ Info: Simulation is stopping after running for 7.945 seconds.; [ Info: Model iteration 200 equals or exceeds stop iteration 200.; ```. I should make it clear that `CFL=10` is not large enough to make particles move out of the domain. `CFL` should be larger than `Nx`, because the distance at which a particle moves in one time step needs to larger than the domain size \(not the grid size\). That means $u \Delta t > L_x$, which is equivalent to `CFL > Nx`. Using a `CFL` of `51` (`Nx = 50` in this case) reproduces the error on a CPU:; ```; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (108.842 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (3.303 seconds).; ERROR: LoadError: BoundsError: attempt to access 56×56×56 OffsetArray(::Array{Float64, 3}, -2:53, -2:53, -2:53) with eltype Float64 with indices -2:53×-2:53×-2:53 at index [54, 49, 1]; Stacktrace:; [1] throw_boundserror(A::OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, I::Tuple{Int64, Int64, Int64}); @ Base ./abstractarray.jl:744; [2] checkbounds; @ ./abstractarray.jl:709 [inlined]; [3] getindex; @ ~/.julia/packages/OffsetArrays/0MOrf/src/OffsetArrays.jl:420 [inlined]; [4] getindex; @ ~/Documents/IdealizedOceanWorlds.jl/OceananigansMemeoryIssue.jl/dev/Oceananigans/src/Fields/field.jl:399 [inlined]; [5] getindex; @ ~/Documents/IdealizedOceanWorlds.jl/OceananigansMemeoryIssue.jl/dev/Oceananigans/src/Utils/sum_of_arrays.jl:23 [inlined]; [6] _interpolate; @ ~/Documents/IdealizedOceanWorlds.jl/OceananigansMemeoryIssue.jl/dev/Oceananigans/src/Fields/interpolate.jl:148 [inlined]; [7] interpolate; @ ~/Documents/IdealizedOceanWorlds.jl/Oceananig",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1773032135
Integrability,depend,dependant,"> > I've just thought, in the same vein as using total velocities, should `fields(model)` not always return sums of prognostic and background fields?; > > For example if you have a function that is dependant on temperature and a background temperature, it should be given the sum.; > ; > Thought more about this and I think it might be quite complicated to change to this so I will leave for now. That isn't what `fields` means right now (in fact, it doesn't have much of a concrete meaning at all and is defined rather vaguely, as it arbitrary omits some model fields while including others). Possibly, there is scope for another utility that returns something like ""prognostic + background fields, and selected auxiliary fields). Perhaps `forcing_fields` or something. However, I would pause a moment to consider whether this is the most useful abstraction for users. It may actually prove more limiting than helpful from the user perspective, as it is typically the case that a forcing function (such as a sponge layer) should depend only on perturbation fields rather than a ""total"" field representing perturbation + background...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3323#issuecomment-1758058255
Usability,pause,pause,"> > I've just thought, in the same vein as using total velocities, should `fields(model)` not always return sums of prognostic and background fields?; > > For example if you have a function that is dependant on temperature and a background temperature, it should be given the sum.; > ; > Thought more about this and I think it might be quite complicated to change to this so I will leave for now. That isn't what `fields` means right now (in fact, it doesn't have much of a concrete meaning at all and is defined rather vaguely, as it arbitrary omits some model fields while including others). Possibly, there is scope for another utility that returns something like ""prognostic + background fields, and selected auxiliary fields). Perhaps `forcing_fields` or something. However, I would pause a moment to consider whether this is the most useful abstraction for users. It may actually prove more limiting than helpful from the user perspective, as it is typically the case that a forcing function (such as a sponge layer) should depend only on perturbation fields rather than a ""total"" field representing perturbation + background...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3323#issuecomment-1758058255
Energy Efficiency,reduce,reduced,"**Final Commit Details**. Remove 4/3 factor, && --> &, ζ=NaN where undefined. 1. Remove 4/3 Factor in Vorticity Computation: The 4/3 factor was initially introduced in the vorticity calculation at the corners because the area used to divide the circulation (in the denominator) was reduced to three-quarters of its original value. However, it turns out that by adopting the Haversine formula for calculating the quadrilateral area on a sphere---which simplifies to a triangle when two points coincide---the 4/3 factor is inherently accounted for. Therefore, the explicit inclusion of this factor is no longer necessary. 2. Replace Short-Circuiting && with Logical &: Changed the short-circuiting && operator to the logical & operator to ensure compatibility with GPU operations. 3. Set Circulation Γ and Vorticity ζ to NaN when Undefined: Updated the code to assign NaN (Not a Number) to circulation Γ and vorticity ζ in cases where they are undefined. @glwagner, @navidcy, could one of you please review this PR once the tests pass, so I can proceed with merging? Thanks!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3325#issuecomment-2394511543
Testability,log,logical,"**Final Commit Details**. Remove 4/3 factor, && --> &, ζ=NaN where undefined. 1. Remove 4/3 Factor in Vorticity Computation: The 4/3 factor was initially introduced in the vorticity calculation at the corners because the area used to divide the circulation (in the denominator) was reduced to three-quarters of its original value. However, it turns out that by adopting the Haversine formula for calculating the quadrilateral area on a sphere---which simplifies to a triangle when two points coincide---the 4/3 factor is inherently accounted for. Therefore, the explicit inclusion of this factor is no longer necessary. 2. Replace Short-Circuiting && with Logical &: Changed the short-circuiting && operator to the logical & operator to ensure compatibility with GPU operations. 3. Set Circulation Γ and Vorticity ζ to NaN when Undefined: Updated the code to assign NaN (Not a Number) to circulation Γ and vorticity ζ in cases where they are undefined. @glwagner, @navidcy, could one of you please review this PR once the tests pass, so I can proceed with merging? Thanks!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3325#issuecomment-2394511543
Usability,simpl,simplifies,"**Final Commit Details**. Remove 4/3 factor, && --> &, ζ=NaN where undefined. 1. Remove 4/3 Factor in Vorticity Computation: The 4/3 factor was initially introduced in the vorticity calculation at the corners because the area used to divide the circulation (in the denominator) was reduced to three-quarters of its original value. However, it turns out that by adopting the Haversine formula for calculating the quadrilateral area on a sphere---which simplifies to a triangle when two points coincide---the 4/3 factor is inherently accounted for. Therefore, the explicit inclusion of this factor is no longer necessary. 2. Replace Short-Circuiting && with Logical &: Changed the short-circuiting && operator to the logical & operator to ensure compatibility with GPU operations. 3. Set Circulation Γ and Vorticity ζ to NaN when Undefined: Updated the code to assign NaN (Not a Number) to circulation Γ and vorticity ζ in cases where they are undefined. @glwagner, @navidcy, could one of you please review this PR once the tests pass, so I can proceed with merging? Thanks!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3325#issuecomment-2394511543
Usability,clear,clearly,Can you explain how topology was removed? I was under the impression this was necessary for determining connectivity (or something like that) but clearly this is wrong. A detailed explanation would be helpful...,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3328#issuecomment-1758077354
Energy Efficiency,reduce,reduce,"I do love tests but I think it might make sense to simplify / reduce the lines added for testing compared to what's in the PR now. Typically we find that maintaining tests is a significant fraction of developer time so it's best to make them as minimal and simple as possible. Awesome PR, thank you!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3329#issuecomment-1758036970
Testability,test,tests,"I do love tests but I think it might make sense to simplify / reduce the lines added for testing compared to what's in the PR now. Typically we find that maintaining tests is a significant fraction of developer time so it's best to make them as minimal and simple as possible. Awesome PR, thank you!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3329#issuecomment-1758036970
Usability,simpl,simplify,"I do love tests but I think it might make sense to simplify / reduce the lines added for testing compared to what's in the PR now. Typically we find that maintaining tests is a significant fraction of developer time so it's best to make them as minimal and simple as possible. Awesome PR, thank you!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3329#issuecomment-1758036970
Availability,error,error,"@glwagner I have simplified the test script (good idea as it was clunky for me to sieve through and I wrote it..) and the new tests pass on both `CPU()` and `GPU()`. ~~The error from the docs build does not look related to this PR as far as I can tell! The docs built on a previous version and I do not think I changed any code related to the docstring.~~. This PR is already likely enough but one thing that could be done is to move `src/Buoyancy/buoyancy_field.jl`. ```julia; # TODO: move to Models; buoyancy(model) = buoyancy(model.buoyancy, model.grid, model.tracers); buoyancy(b, grid, tracers) = KernelFunctionOperation{Center, Center, Center}(buoyancy_perturbationᶜᶜᶜ, grid, b.model, tracers); BuoyancyField(model) = Field(buoyancy(model)); ```. to `Oceananigans.Models` and alter this so instead of returning `BuoyancyField` it returns the `KernelFunctionOperation`. ```julia; sewater_buoyancy_perturbation(model) = sewater_buoyancy_perturbation(model.buoyancy, model.grid, model.tracers); sewater_buoyancy_perturbation(b, grid, tracers) = KernelFunctionOperation{Center, Center, Center}(buoyancy_perturbationᶜᶜᶜ, grid, b.model, tracers); SewaterBuoyancyPerturbation(model) = sewater_buoyancy_perturbation(model); ```. to match the behaviour of `SeawaterDensity`.; Likely better to do another day but if you think it worth doing in this PR let me know.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3329#issuecomment-1758784047
Testability,test,test,"@glwagner I have simplified the test script (good idea as it was clunky for me to sieve through and I wrote it..) and the new tests pass on both `CPU()` and `GPU()`. ~~The error from the docs build does not look related to this PR as far as I can tell! The docs built on a previous version and I do not think I changed any code related to the docstring.~~. This PR is already likely enough but one thing that could be done is to move `src/Buoyancy/buoyancy_field.jl`. ```julia; # TODO: move to Models; buoyancy(model) = buoyancy(model.buoyancy, model.grid, model.tracers); buoyancy(b, grid, tracers) = KernelFunctionOperation{Center, Center, Center}(buoyancy_perturbationᶜᶜᶜ, grid, b.model, tracers); BuoyancyField(model) = Field(buoyancy(model)); ```. to `Oceananigans.Models` and alter this so instead of returning `BuoyancyField` it returns the `KernelFunctionOperation`. ```julia; sewater_buoyancy_perturbation(model) = sewater_buoyancy_perturbation(model.buoyancy, model.grid, model.tracers); sewater_buoyancy_perturbation(b, grid, tracers) = KernelFunctionOperation{Center, Center, Center}(buoyancy_perturbationᶜᶜᶜ, grid, b.model, tracers); SewaterBuoyancyPerturbation(model) = sewater_buoyancy_perturbation(model); ```. to match the behaviour of `SeawaterDensity`.; Likely better to do another day but if you think it worth doing in this PR let me know.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3329#issuecomment-1758784047
Usability,simpl,simplified,"@glwagner I have simplified the test script (good idea as it was clunky for me to sieve through and I wrote it..) and the new tests pass on both `CPU()` and `GPU()`. ~~The error from the docs build does not look related to this PR as far as I can tell! The docs built on a previous version and I do not think I changed any code related to the docstring.~~. This PR is already likely enough but one thing that could be done is to move `src/Buoyancy/buoyancy_field.jl`. ```julia; # TODO: move to Models; buoyancy(model) = buoyancy(model.buoyancy, model.grid, model.tracers); buoyancy(b, grid, tracers) = KernelFunctionOperation{Center, Center, Center}(buoyancy_perturbationᶜᶜᶜ, grid, b.model, tracers); BuoyancyField(model) = Field(buoyancy(model)); ```. to `Oceananigans.Models` and alter this so instead of returning `BuoyancyField` it returns the `KernelFunctionOperation`. ```julia; sewater_buoyancy_perturbation(model) = sewater_buoyancy_perturbation(model.buoyancy, model.grid, model.tracers); sewater_buoyancy_perturbation(b, grid, tracers) = KernelFunctionOperation{Center, Center, Center}(buoyancy_perturbationᶜᶜᶜ, grid, b.model, tracers); SewaterBuoyancyPerturbation(model) = sewater_buoyancy_perturbation(model); ```. to match the behaviour of `SeawaterDensity`.; Likely better to do another day but if you think it worth doing in this PR let me know.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3329#issuecomment-1758784047
Modifiability,extend,extends,"> This PR tweaks the API to simplify non-uniform partitioning which should already be supported by the algorithm.; > ; > This PR also extends the tests to include non-uniform distributed partitioning; > ; > The proposal of this PR (up to discussion and tweaking) is to allow calling; > ; > ```julia; > arch = Distributed(CPU(); partition = Partition(Rx = [0.3, 0.1, 0.6]); > ```; > ; > which allows to distributed the domain over 3 workers which hold 30%, 10% and 60% of the computation, respectively. How would one manually specify the grid points on each rank with this API? This is a little non-standard since most of our APIs use words rather than symbols (ie it's not clear what `Rx` means just from reading the code).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3339#issuecomment-1762126912
Testability,test,tests,"> This PR tweaks the API to simplify non-uniform partitioning which should already be supported by the algorithm.; > ; > This PR also extends the tests to include non-uniform distributed partitioning; > ; > The proposal of this PR (up to discussion and tweaking) is to allow calling; > ; > ```julia; > arch = Distributed(CPU(); partition = Partition(Rx = [0.3, 0.1, 0.6]); > ```; > ; > which allows to distributed the domain over 3 workers which hold 30%, 10% and 60% of the computation, respectively. How would one manually specify the grid points on each rank with this API? This is a little non-standard since most of our APIs use words rather than symbols (ie it's not clear what `Rx` means just from reading the code).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3339#issuecomment-1762126912
Usability,simpl,simplify,"> This PR tweaks the API to simplify non-uniform partitioning which should already be supported by the algorithm.; > ; > This PR also extends the tests to include non-uniform distributed partitioning; > ; > The proposal of this PR (up to discussion and tweaking) is to allow calling; > ; > ```julia; > arch = Distributed(CPU(); partition = Partition(Rx = [0.3, 0.1, 0.6]); > ```; > ; > which allows to distributed the domain over 3 workers which hold 30%, 10% and 60% of the computation, respectively. How would one manually specify the grid points on each rank with this API? This is a little non-standard since most of our APIs use words rather than symbols (ie it's not clear what `Rx` means just from reading the code).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3339#issuecomment-1762126912
Performance,perform,performance,"Should we also try things like. ```julia; node(i, j, k, grid, ::Nothing, ℓy, ℓz) = _node(i, j, k, grid, nothing, ℓy, ℓz)[1:2]; ```. I think we determined there could be a tiny performance loss but it would make the code a little simpler and also easier to read since we don't have to define every combination of locations for `_node`. I still want to clean up and streamline `xspacings` and `xnodes` (etc) so that they use `xnode` directly (rather than ""re-implementing"" the nodes) but that'll have to wait for another PR I think.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3355#issuecomment-1775504750
Usability,simpl,simpler,"Should we also try things like. ```julia; node(i, j, k, grid, ::Nothing, ℓy, ℓz) = _node(i, j, k, grid, nothing, ℓy, ℓz)[1:2]; ```. I think we determined there could be a tiny performance loss but it would make the code a little simpler and also easier to read since we don't have to define every combination of locations for `_node`. I still want to clean up and streamline `xspacings` and `xnodes` (etc) so that they use `xnode` directly (rather than ""re-implementing"" the nodes) but that'll have to wait for another PR I think.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3355#issuecomment-1775504750
Performance,perform,performance,"> Should we also try things like; > ; > ```julia; > node(i, j, k, grid, ::Nothing, ℓy, ℓz) = _node(i, j, k, grid, nothing, ℓy, ℓz)[1:2]; > ```; > ; > I think we determined there could be a tiny performance loss but it would make the code a little simpler and also easier to read since we don't have to define every combination of locations for `_node`. Hmm this is more annoying than I thought so I'll leave it for later.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3355#issuecomment-1775509960
Usability,simpl,simpler,"> Should we also try things like; > ; > ```julia; > node(i, j, k, grid, ::Nothing, ℓy, ℓz) = _node(i, j, k, grid, nothing, ℓy, ℓz)[1:2]; > ```; > ; > I think we determined there could be a tiny performance loss but it would make the code a little simpler and also easier to read since we don't have to define every combination of locations for `_node`. Hmm this is more annoying than I thought so I'll leave it for later.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3355#issuecomment-1775509960
Usability,simpl,simply,"> That’s a good point. Unfortunately, we don’t know how to do that unfortunately. We tried bunch of things. I’ll give it a go. Can't we simply revert the commit/PR that introduced the issue for the time being?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3355#issuecomment-1785633451
Performance,perform,performance,I'm not sure if we've tested but I've assumed there is a performance benefit to the simpler version for regularly spaced grids rather than using the binary search. It would probably be sensible to change the differentiation between the methods to just `fractional_index` though.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3356#issuecomment-1775532157
Testability,test,tested,I'm not sure if we've tested but I've assumed there is a performance benefit to the simpler version for regularly spaced grids rather than using the binary search. It would probably be sensible to change the differentiation between the methods to just `fractional_index` though.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3356#issuecomment-1775532157
Usability,simpl,simpler,I'm not sure if we've tested but I've assumed there is a performance benefit to the simpler version for regularly spaced grids rather than using the binary search. It would probably be sensible to change the differentiation between the methods to just `fractional_index` though.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3356#issuecomment-1775532157
Performance,perform,performance,> I'm not sure if we've tested but I've assumed there is a performance benefit to the simpler version for regularly spaced grids rather than using the binary search. @simone-silvestri have you ever benchmarked this?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3356#issuecomment-1775545546
Testability,test,tested,> I'm not sure if we've tested but I've assumed there is a performance benefit to the simpler version for regularly spaced grids rather than using the binary search. @simone-silvestri have you ever benchmarked this?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3356#issuecomment-1775545546
Usability,simpl,simpler,> I'm not sure if we've tested but I've assumed there is a performance benefit to the simpler version for regularly spaced grids rather than using the binary search. @simone-silvestri have you ever benchmarked this?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3356#issuecomment-1775545546
Availability,error,error,"Latest error:. ```julia; ERROR: LoadError: task switch not allowed from inside staged nor pure functions; Stacktrace:; [1] try_yieldto(undo::typeof(Base.ensure_rescheduled)); @ Base ./task.jl:921; [2] wait(); @ Base ./task.jl:995; [3] uv_write(s::Base.TTY, p::Ptr{UInt8}, n::UInt64); @ Base ./stream.jl:1048; [4] unsafe_write(s::Base.TTY, p::Ptr{UInt8}, n::UInt64); @ Base ./stream.jl:1120; [5] write; @ Base ./strings/io.jl:248 [inlined]; [6] print; @ Base ./strings/io.jl:250 [inlined]; [7] print(::Base.TTY, ::String, ::String, ::Vararg{String}); @ Base ./strings/io.jl:46; [8] println(::Base.TTY, ::String, ::Vararg{String}); @ Base ./strings/io.jl:75; [9] println(::String, ::String); @ Base ./coreio.jl:4; [10] calling_conv_fixup(builder::LLVM.IRBuilder, val::LLVM.AddrSpaceCastInst, tape::LLVM.PointerType, prev::LLVM.UndefValue, lidxs::Vector{…}, ridxs::Vector{…}); @ Enzyme.Compiler ~/Projects/Enzyme.jl/src/compiler/utils.jl:270; [11] calling_conv_fixup (repeats 2 times); @ Enzyme.Compiler ~/Projects/Enzyme.jl/src/compiler/utils.jl:183 [inlined]; [12] calling_conv_fixup(builder::LLVM.IRBuilder, val::LLVM.AddrSpaceCastInst, tape::LLVM.PointerType); @ Enzyme.Compiler ~/Projects/Enzyme.jl/src/compiler/utils.jl:183; [13] enzyme_custom_common_rev(forward::Bool, B::LLVM.IRBuilder, orig::LLVM.CallInst, gutils::Enzyme.Compiler.GradientUtils, normalR::Ptr{…}, shadowR::Ptr{…}, tape::LLVM.ExtractValueInst); @ Enzyme.Compiler ~/Projects/Enzyme.jl/src/compiler.jl:4610; [14] enzyme_custom_rev(B::LLVM.IRBuilder, orig::LLVM.CallInst, gutils::Enzyme.Compiler.GradientUtils, tape::LLVM.ExtractValueInst); @ Enzyme.Compiler ~/Projects/Enzyme.jl/src/compiler.jl:4770; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3360#issuecomment-1786194570
Usability,undo,undo,"Latest error:. ```julia; ERROR: LoadError: task switch not allowed from inside staged nor pure functions; Stacktrace:; [1] try_yieldto(undo::typeof(Base.ensure_rescheduled)); @ Base ./task.jl:921; [2] wait(); @ Base ./task.jl:995; [3] uv_write(s::Base.TTY, p::Ptr{UInt8}, n::UInt64); @ Base ./stream.jl:1048; [4] unsafe_write(s::Base.TTY, p::Ptr{UInt8}, n::UInt64); @ Base ./stream.jl:1120; [5] write; @ Base ./strings/io.jl:248 [inlined]; [6] print; @ Base ./strings/io.jl:250 [inlined]; [7] print(::Base.TTY, ::String, ::String, ::Vararg{String}); @ Base ./strings/io.jl:46; [8] println(::Base.TTY, ::String, ::Vararg{String}); @ Base ./strings/io.jl:75; [9] println(::String, ::String); @ Base ./coreio.jl:4; [10] calling_conv_fixup(builder::LLVM.IRBuilder, val::LLVM.AddrSpaceCastInst, tape::LLVM.PointerType, prev::LLVM.UndefValue, lidxs::Vector{…}, ridxs::Vector{…}); @ Enzyme.Compiler ~/Projects/Enzyme.jl/src/compiler/utils.jl:270; [11] calling_conv_fixup (repeats 2 times); @ Enzyme.Compiler ~/Projects/Enzyme.jl/src/compiler/utils.jl:183 [inlined]; [12] calling_conv_fixup(builder::LLVM.IRBuilder, val::LLVM.AddrSpaceCastInst, tape::LLVM.PointerType); @ Enzyme.Compiler ~/Projects/Enzyme.jl/src/compiler/utils.jl:183; [13] enzyme_custom_common_rev(forward::Bool, B::LLVM.IRBuilder, orig::LLVM.CallInst, gutils::Enzyme.Compiler.GradientUtils, normalR::Ptr{…}, shadowR::Ptr{…}, tape::LLVM.ExtractValueInst); @ Enzyme.Compiler ~/Projects/Enzyme.jl/src/compiler.jl:4610; [14] enzyme_custom_rev(B::LLVM.IRBuilder, orig::LLVM.CallInst, gutils::Enzyme.Compiler.GradientUtils, tape::LLVM.ExtractValueInst); @ Enzyme.Compiler ~/Projects/Enzyme.jl/src/compiler.jl:4770; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3360#issuecomment-1786194570
Availability,error,error,"> Hmm. What is; > ; > ```julia; > view(u[region_W], 1, Nc+1-Hc:Nc, k); > ```; > ; > is this a `Field`? Next question, what is; > ; > ```julia; > reverse(view(u[region_W], 1, Nc+1-Hc:Nc, k)); > ```; > ; > If the former is a `Field` I don't think we've defined `reverse` on `Field`. But you could do that... @glwagner, yes, `view(u[region_W], 1, Nc+1-Hc:Nc, k)` is a `WindowedField`, on which `reverse` is not defined yet. But `reverse(view(u[region_W], 1, Nc+1-Hc:Nc, k).data)` is a valid operation. However, simply typing ; ```julia; u[region][1, Nc+1:Nc+Hc, k] .= reverse(view(u[region_W], 1, Nc+1-Hc:Nc, k).data) * plmn; u[region][Nc+1, 1-Hc:0, k] .= reverse(view(u[region_E], 2:Hc+1, 1, k)); ```; might throw the above-mentioned error due to a dimension mismatch or fill the LHS with junk or incorrect values. So, a safe solution is ; ```julia; view(u[region], 1, Nc+1:Nc+Hc, k).data .= reshape(reverse(view(u[region_W], 1, Nc+1-Hc:Nc, k).data) * plmn, 1:1, Nc+1:Nc+Hc, k:k); view(u[region], Nc+1, 1-Hc:0, k).data .= reshape(reverse(view(u[region_E], 2:Hc+1, 1, k).data), Nc+1:Nc+1, 1-Hc:0, k:k); ```; @glwagner, @navidcy, if you guys are fine with this fix, I will close the issue.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3361#issuecomment-2033319769
Safety,safe,safe,"> Hmm. What is; > ; > ```julia; > view(u[region_W], 1, Nc+1-Hc:Nc, k); > ```; > ; > is this a `Field`? Next question, what is; > ; > ```julia; > reverse(view(u[region_W], 1, Nc+1-Hc:Nc, k)); > ```; > ; > If the former is a `Field` I don't think we've defined `reverse` on `Field`. But you could do that... @glwagner, yes, `view(u[region_W], 1, Nc+1-Hc:Nc, k)` is a `WindowedField`, on which `reverse` is not defined yet. But `reverse(view(u[region_W], 1, Nc+1-Hc:Nc, k).data)` is a valid operation. However, simply typing ; ```julia; u[region][1, Nc+1:Nc+Hc, k] .= reverse(view(u[region_W], 1, Nc+1-Hc:Nc, k).data) * plmn; u[region][Nc+1, 1-Hc:0, k] .= reverse(view(u[region_E], 2:Hc+1, 1, k)); ```; might throw the above-mentioned error due to a dimension mismatch or fill the LHS with junk or incorrect values. So, a safe solution is ; ```julia; view(u[region], 1, Nc+1:Nc+Hc, k).data .= reshape(reverse(view(u[region_W], 1, Nc+1-Hc:Nc, k).data) * plmn, 1:1, Nc+1:Nc+Hc, k:k); view(u[region], Nc+1, 1-Hc:0, k).data .= reshape(reverse(view(u[region_E], 2:Hc+1, 1, k).data), Nc+1:Nc+1, 1-Hc:0, k:k); ```; @glwagner, @navidcy, if you guys are fine with this fix, I will close the issue.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3361#issuecomment-2033319769
Usability,simpl,simply,"> Hmm. What is; > ; > ```julia; > view(u[region_W], 1, Nc+1-Hc:Nc, k); > ```; > ; > is this a `Field`? Next question, what is; > ; > ```julia; > reverse(view(u[region_W], 1, Nc+1-Hc:Nc, k)); > ```; > ; > If the former is a `Field` I don't think we've defined `reverse` on `Field`. But you could do that... @glwagner, yes, `view(u[region_W], 1, Nc+1-Hc:Nc, k)` is a `WindowedField`, on which `reverse` is not defined yet. But `reverse(view(u[region_W], 1, Nc+1-Hc:Nc, k).data)` is a valid operation. However, simply typing ; ```julia; u[region][1, Nc+1:Nc+Hc, k] .= reverse(view(u[region_W], 1, Nc+1-Hc:Nc, k).data) * plmn; u[region][Nc+1, 1-Hc:0, k] .= reverse(view(u[region_E], 2:Hc+1, 1, k)); ```; might throw the above-mentioned error due to a dimension mismatch or fill the LHS with junk or incorrect values. So, a safe solution is ; ```julia; view(u[region], 1, Nc+1:Nc+Hc, k).data .= reshape(reverse(view(u[region_W], 1, Nc+1-Hc:Nc, k).data) * plmn, 1:1, Nc+1:Nc+Hc, k:k); view(u[region], Nc+1, 1-Hc:0, k).data .= reshape(reverse(view(u[region_E], 2:Hc+1, 1, k).data), Nc+1:Nc+1, 1-Hc:0, k:k); ```; @glwagner, @navidcy, if you guys are fine with this fix, I will close the issue.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3361#issuecomment-2033319769
Availability,error,error,"Probably not the best use of time to try to get `reverse` to work. But if someone is interested in looking further, we can see that `reverse` starts by building a new object with `copymutable`:. https://github.com/JuliaLang/julia/blob/d7dc9a8cc8f2aebf04d5cecc8625be250169644b/base/arraymath.jl#L59-L60. `copymutable` works correctly because it relies on 1) `similar` and 2) `copyto!`, both of which we define for `Field`. So that's nice, showing the power of extending those functions. The error that @siddharthabishnu finds occurs because we haven't defined `view` for `CartesianIndices`. This is used by `_reverse`:. https://github.com/JuliaLang/julia/blob/d7dc9a8cc8f2aebf04d5cecc8625be250169644b/base/arraymath.jl#L95. The fix is pretty easy I think. We simply need to extend `reverse!`:. ```julia; Base.reverse!(f::Field; dims=:) = reverse!(parent(f); dims); ```. This seems to work as expected:. ```julia; julia> reverse!(parent(c)); interior(c)[:]; 6-element Vector{Float64}:; -0.14945052605940137; -0.25420686637327716; 0.36399517922432356; -0.03994475992128757; 0.018968176930285508; -0.5607261175546058. julia> reverse!(parent(c)); interior(c)[:]; 6-element Vector{Float64}:; -0.5607261175546058; 0.018968176930285508; -0.03994475992128757; 0.36399517922432356; -0.25420686637327716; -0.14945052605940137; ```. But again I don't know why we want reverse for `Field`. Do we?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3361#issuecomment-2035345965
Energy Efficiency,power,power,"Probably not the best use of time to try to get `reverse` to work. But if someone is interested in looking further, we can see that `reverse` starts by building a new object with `copymutable`:. https://github.com/JuliaLang/julia/blob/d7dc9a8cc8f2aebf04d5cecc8625be250169644b/base/arraymath.jl#L59-L60. `copymutable` works correctly because it relies on 1) `similar` and 2) `copyto!`, both of which we define for `Field`. So that's nice, showing the power of extending those functions. The error that @siddharthabishnu finds occurs because we haven't defined `view` for `CartesianIndices`. This is used by `_reverse`:. https://github.com/JuliaLang/julia/blob/d7dc9a8cc8f2aebf04d5cecc8625be250169644b/base/arraymath.jl#L95. The fix is pretty easy I think. We simply need to extend `reverse!`:. ```julia; Base.reverse!(f::Field; dims=:) = reverse!(parent(f); dims); ```. This seems to work as expected:. ```julia; julia> reverse!(parent(c)); interior(c)[:]; 6-element Vector{Float64}:; -0.14945052605940137; -0.25420686637327716; 0.36399517922432356; -0.03994475992128757; 0.018968176930285508; -0.5607261175546058. julia> reverse!(parent(c)); interior(c)[:]; 6-element Vector{Float64}:; -0.5607261175546058; 0.018968176930285508; -0.03994475992128757; 0.36399517922432356; -0.25420686637327716; -0.14945052605940137; ```. But again I don't know why we want reverse for `Field`. Do we?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3361#issuecomment-2035345965
Modifiability,extend,extending,"Probably not the best use of time to try to get `reverse` to work. But if someone is interested in looking further, we can see that `reverse` starts by building a new object with `copymutable`:. https://github.com/JuliaLang/julia/blob/d7dc9a8cc8f2aebf04d5cecc8625be250169644b/base/arraymath.jl#L59-L60. `copymutable` works correctly because it relies on 1) `similar` and 2) `copyto!`, both of which we define for `Field`. So that's nice, showing the power of extending those functions. The error that @siddharthabishnu finds occurs because we haven't defined `view` for `CartesianIndices`. This is used by `_reverse`:. https://github.com/JuliaLang/julia/blob/d7dc9a8cc8f2aebf04d5cecc8625be250169644b/base/arraymath.jl#L95. The fix is pretty easy I think. We simply need to extend `reverse!`:. ```julia; Base.reverse!(f::Field; dims=:) = reverse!(parent(f); dims); ```. This seems to work as expected:. ```julia; julia> reverse!(parent(c)); interior(c)[:]; 6-element Vector{Float64}:; -0.14945052605940137; -0.25420686637327716; 0.36399517922432356; -0.03994475992128757; 0.018968176930285508; -0.5607261175546058. julia> reverse!(parent(c)); interior(c)[:]; 6-element Vector{Float64}:; -0.5607261175546058; 0.018968176930285508; -0.03994475992128757; 0.36399517922432356; -0.25420686637327716; -0.14945052605940137; ```. But again I don't know why we want reverse for `Field`. Do we?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3361#issuecomment-2035345965
Usability,simpl,simply,"Probably not the best use of time to try to get `reverse` to work. But if someone is interested in looking further, we can see that `reverse` starts by building a new object with `copymutable`:. https://github.com/JuliaLang/julia/blob/d7dc9a8cc8f2aebf04d5cecc8625be250169644b/base/arraymath.jl#L59-L60. `copymutable` works correctly because it relies on 1) `similar` and 2) `copyto!`, both of which we define for `Field`. So that's nice, showing the power of extending those functions. The error that @siddharthabishnu finds occurs because we haven't defined `view` for `CartesianIndices`. This is used by `_reverse`:. https://github.com/JuliaLang/julia/blob/d7dc9a8cc8f2aebf04d5cecc8625be250169644b/base/arraymath.jl#L95. The fix is pretty easy I think. We simply need to extend `reverse!`:. ```julia; Base.reverse!(f::Field; dims=:) = reverse!(parent(f); dims); ```. This seems to work as expected:. ```julia; julia> reverse!(parent(c)); interior(c)[:]; 6-element Vector{Float64}:; -0.14945052605940137; -0.25420686637327716; 0.36399517922432356; -0.03994475992128757; 0.018968176930285508; -0.5607261175546058. julia> reverse!(parent(c)); interior(c)[:]; 6-element Vector{Float64}:; -0.5607261175546058; 0.018968176930285508; -0.03994475992128757; 0.36399517922432356; -0.25420686637327716; -0.14945052605940137; ```. But again I don't know why we want reverse for `Field`. Do we?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3361#issuecomment-2035345965
Availability,down,down,"Rather than working in the complicated setting of a multiregion grid, it might be better to have a simpler context to look at the issue. Here's an MWE:. ```julia; julia> grid = RectilinearGrid(size=(3, 3, 3), x=(0, 1), y=(0, 1), z=(0, 1));. julia> c = CenterField(grid); set!(c, (x, y, z) -> randn()); 3×3×3 Field{Center, Center, Center} on RectilinearGrid on CPU; ├── grid: 3×3×3 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; └── data: 9×9×9 OffsetArray(::Array{Float64, 3}, -2:6, -2:6, -2:6) with eltype Float64 with indices -2:6×-2:6×-2:6; └── max=2.47269, min=-2.49748, mean=-0.0773234. julia> a = rand(3, 3, 3); b = rand(3, 3, 3);; ```. Now we can illustrate how `Field` does not behave like `Array`. This works:. ```julia; julia> view(a, :, 1, 1) .= view(b, 1, :, 1); 3-element view(::Array{Float64, 3}, :, 1, 1) with eltype Float64:; 0.23703924592859704; 0.02820508483630202; 0.7546236569353038; ```. but this does not:. ```julia; julia> view(a, :, 1, 1) .= view(c, 1, :, 1); ```. and instead throws `DimensionMismatch`. Does that boil down the issue @siddharthabishnu ?. Actually, it is curious that for some reason things do work out correctly if setting to a `Field`:. ```julia; julia> d = CenterField(grid);. julia> view(d, :, 1, 1) .= view(c, 1, :, 1);. julia> interior(d, :, 1, 1); 3-element view(::Array{Float64, 3}, 4:6, 4, 4) with eltype Float64:; 0.06779701769558852; -1.1932513091536738; -1.1239966299690682. julia> interior(c, 1, :, 1); 3-element view(::Array{Float64, 3}, 4, 4:6, 4) with eltype Float64:; 0.06779701769558852; -0.5935171905074843; 1.399692772040493; ```. No idea why that works...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3361#issuecomment-2038161718
Usability,simpl,simpler,"Rather than working in the complicated setting of a multiregion grid, it might be better to have a simpler context to look at the issue. Here's an MWE:. ```julia; julia> grid = RectilinearGrid(size=(3, 3, 3), x=(0, 1), y=(0, 1), z=(0, 1));. julia> c = CenterField(grid); set!(c, (x, y, z) -> randn()); 3×3×3 Field{Center, Center, Center} on RectilinearGrid on CPU; ├── grid: 3×3×3 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; └── data: 9×9×9 OffsetArray(::Array{Float64, 3}, -2:6, -2:6, -2:6) with eltype Float64 with indices -2:6×-2:6×-2:6; └── max=2.47269, min=-2.49748, mean=-0.0773234. julia> a = rand(3, 3, 3); b = rand(3, 3, 3);; ```. Now we can illustrate how `Field` does not behave like `Array`. This works:. ```julia; julia> view(a, :, 1, 1) .= view(b, 1, :, 1); 3-element view(::Array{Float64, 3}, :, 1, 1) with eltype Float64:; 0.23703924592859704; 0.02820508483630202; 0.7546236569353038; ```. but this does not:. ```julia; julia> view(a, :, 1, 1) .= view(c, 1, :, 1); ```. and instead throws `DimensionMismatch`. Does that boil down the issue @siddharthabishnu ?. Actually, it is curious that for some reason things do work out correctly if setting to a `Field`:. ```julia; julia> d = CenterField(grid);. julia> view(d, :, 1, 1) .= view(c, 1, :, 1);. julia> interior(d, :, 1, 1); 3-element view(::Array{Float64, 3}, 4:6, 4, 4) with eltype Float64:; 0.06779701769558852; -1.1932513091536738; -1.1239966299690682. julia> interior(c, 1, :, 1); 3-element view(::Array{Float64, 3}, 4, 4:6, 4) with eltype Float64:; 0.06779701769558852; -0.5935171905074843; 1.399692772040493; ```. No idea why that works...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3361#issuecomment-2038161718
Availability,down,downside,"> > This is the issue that described what I was seeing: #3290; > > @johnryantaylor does that looks like what you're seeing?; > > If so, the two workarounds that I have come up with are; > > ; > > * to run on branch [Don't separate the pressure into hydrostatic and nonhydrostatic in `NonhydrostaticModel` #3080](https://github.com/CliMA/Oceananigans.jl/pull/3080) like @glwagner suggested (downside here is that this branch is kinda out-of-date and apparently stale); > > * Make the `x` (or `y`) directions periodic (seems like `x`already is in your case) and tilt the domain accordingly. (The second video in [Having a domain that's periodic in the ""gravity"" direction doesn't work for `gravity_unit_vector = NegativeZDirection()` #3290](https://github.com/CliMA/Oceananigans.jl/issues/3290) illustrates that); > > ; > > If that's not your issue, do you mind posting the animatino you're generating?; > ; > And just to confirm @tomchor those issues are not associated with BackgroundField, right?. If it's the same issue as the one I pointed out in #3290 (which is not 100% clear atm), then you're right, they're not associated with `BackgroundField`. They have to do with trying to enforce a periodic pressure when the hydrostatic pressure is aperiodic on `z` due to the fact that it comes from a `b` integral in `z`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3364#issuecomment-1782233834
Usability,clear,clear,"> > This is the issue that described what I was seeing: #3290; > > @johnryantaylor does that looks like what you're seeing?; > > If so, the two workarounds that I have come up with are; > > ; > > * to run on branch [Don't separate the pressure into hydrostatic and nonhydrostatic in `NonhydrostaticModel` #3080](https://github.com/CliMA/Oceananigans.jl/pull/3080) like @glwagner suggested (downside here is that this branch is kinda out-of-date and apparently stale); > > * Make the `x` (or `y`) directions periodic (seems like `x`already is in your case) and tilt the domain accordingly. (The second video in [Having a domain that's periodic in the ""gravity"" direction doesn't work for `gravity_unit_vector = NegativeZDirection()` #3290](https://github.com/CliMA/Oceananigans.jl/issues/3290) illustrates that); > > ; > > If that's not your issue, do you mind posting the animatino you're generating?; > ; > And just to confirm @tomchor those issues are not associated with BackgroundField, right?. If it's the same issue as the one I pointed out in #3290 (which is not 100% clear atm), then you're right, they're not associated with `BackgroundField`. They have to do with trying to enforce a periodic pressure when the hydrostatic pressure is aperiodic on `z` due to the fact that it comes from a `b` integral in `z`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3364#issuecomment-1782233834
Integrability,interface,interface,"Thanks for running these tests, @glwagner. They really do look like the issue in https://github.com/CliMA/Oceananigans.jl/issues/3290. > The easiest fix is to eliminate the pressure separation. Since we're waiting for the IBM-aware pressure solve, we could also just add an option to eliminate the pressure separation that would be `false` by default. That should be pretty easy. And then in the future when we're confident about the new algorithm we can eliminate the pressure separation completely (along with user interface an code simplifications that are possible with no pressure separation). > Another solution is to fix the hydrostatic pressure algorithm. Does it need fixing in this case though? The way I see it this is just a consequence of how the hydrostatic pressure is defined: a vertical integral of `b`, which doesn't play well with the assumption of a vertically-periodic domain. > We should also note that the vertical tridiagonal solve is not correct for vertically-periodic domains. But this is easily solvable (and the above 2 are as well). Cool! We should probably do that as well :)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3364#issuecomment-1782238151
Testability,test,tests,"Thanks for running these tests, @glwagner. They really do look like the issue in https://github.com/CliMA/Oceananigans.jl/issues/3290. > The easiest fix is to eliminate the pressure separation. Since we're waiting for the IBM-aware pressure solve, we could also just add an option to eliminate the pressure separation that would be `false` by default. That should be pretty easy. And then in the future when we're confident about the new algorithm we can eliminate the pressure separation completely (along with user interface an code simplifications that are possible with no pressure separation). > Another solution is to fix the hydrostatic pressure algorithm. Does it need fixing in this case though? The way I see it this is just a consequence of how the hydrostatic pressure is defined: a vertical integral of `b`, which doesn't play well with the assumption of a vertically-periodic domain. > We should also note that the vertical tridiagonal solve is not correct for vertically-periodic domains. But this is easily solvable (and the above 2 are as well). Cool! We should probably do that as well :)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3364#issuecomment-1782238151
Usability,simpl,simplifications,"Thanks for running these tests, @glwagner. They really do look like the issue in https://github.com/CliMA/Oceananigans.jl/issues/3290. > The easiest fix is to eliminate the pressure separation. Since we're waiting for the IBM-aware pressure solve, we could also just add an option to eliminate the pressure separation that would be `false` by default. That should be pretty easy. And then in the future when we're confident about the new algorithm we can eliminate the pressure separation completely (along with user interface an code simplifications that are possible with no pressure separation). > Another solution is to fix the hydrostatic pressure algorithm. Does it need fixing in this case though? The way I see it this is just a consequence of how the hydrostatic pressure is defined: a vertical integral of `b`, which doesn't play well with the assumption of a vertically-periodic domain. > We should also note that the vertical tridiagonal solve is not correct for vertically-periodic domains. But this is easily solvable (and the above 2 are as well). Cool! We should probably do that as well :)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3364#issuecomment-1782238151
Safety,safe,safe,"Hi both, Thanks for the quick replies on this. I agree that it seems like it is likely coming from the background gradient and lack of periodicity when applied to the hydrostatic presssure. As far as I can tell there aren't any problems for passive scalars which supports that interpretation. As an aside, I think that there are also boundary artifacts in the internal_wave.jl example (although you need to run the simulation longer and you can't see them with the default contouring of the plots). . A solution that should work is to implicitly cancel the hydrostatic pressure gradient associated with the background field with the buoyancy term. This is what we do in Diablo (although we don't decompose the pressure into hydrostatic and nonhydrostatic components). Implementing this is simple since you just don't include the background gradient when calculating the hydrostatic pressure. The only trouble that I see is figuring out when to do this. In other contexts you want to keep this term. E.g. in the geostrophic adjustment problem, the hydrostatic pressure gradient is needed to drive the flow. Maybe it would be safe to exclude the background buoyancy field in the calculation of the hydrostatic pressure anytime when the topology is periodic in the vertical direction?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3364#issuecomment-1783557267
Usability,simpl,simple,"Hi both, Thanks for the quick replies on this. I agree that it seems like it is likely coming from the background gradient and lack of periodicity when applied to the hydrostatic presssure. As far as I can tell there aren't any problems for passive scalars which supports that interpretation. As an aside, I think that there are also boundary artifacts in the internal_wave.jl example (although you need to run the simulation longer and you can't see them with the default contouring of the plots). . A solution that should work is to implicitly cancel the hydrostatic pressure gradient associated with the background field with the buoyancy term. This is what we do in Diablo (although we don't decompose the pressure into hydrostatic and nonhydrostatic components). Implementing this is simple since you just don't include the background gradient when calculating the hydrostatic pressure. The only trouble that I see is figuring out when to do this. In other contexts you want to keep this term. E.g. in the geostrophic adjustment problem, the hydrostatic pressure gradient is needed to drive the flow. Maybe it would be safe to exclude the background buoyancy field in the calculation of the hydrostatic pressure anytime when the topology is periodic in the vertical direction?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3364#issuecomment-1783557267
Usability,simpl,simply,"> Any place where the loop limits are not types, it's wrong. It only works if the limits are known via types (so they are known at compile time rather than runtime). Typically this would require uusing `Val{N}` or `Val{H}` but even then it can fail sometimes. Do you simply mean that. ```Julia; @unroll for j in 1:4; do_this(); end; ```; is OK but; ```Julia; N=4; @unroll for j in 1:N; do_this(); end; ```; is not?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3374#issuecomment-1874467696
Usability,simpl,simply,"> > Any place where the loop limits are not types, it's wrong. It only works if the limits are known via types (so they are known at compile time rather than runtime). Typically this would require uusing `Val{N}` or `Val{H}` but even then it can fail sometimes.; > ; > Do you simply mean that; > ; > ```julia; > @unroll for j in 1:4; do_this(); end; > ```; > ; > is OK but; > ; > ```julia; > N=4; > @unroll for j in 1:N; do_this(); end; > ```; > ; > is not?. Both are fine the way you have written them, because even in the second case the compiler is able to infer that `N` is always `4`, the way you've written it. But `@unroll for i = 1:grid.Nx` is not fine because `grid.Nx` is not known at compile time, it is passed into the function as a property of the `grid`. At compile time, only the type of the grid is known, and not the values that are contained in it. If one is careful to pass the limits of the loop as _compile-time information_, then we can pass information into a function. Typically this is done with objects like like `Val(N)` which have type signature `::Val{N}`. Since here `N` is type information it is known to the compiler.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3374#issuecomment-1877550519
Usability,clear,clear,"> Can you give an example that's OK and one that's not?. The example that is ok is when the limit of the loop `N` is passed in via an argument with _type_ `Val{N}`. Then `N` is known to the compiler. This is what I tried to indicate, sorry for not being clear.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3374#issuecomment-1877552215
Testability,test,test,I think you should add a simple test so this doesn't regress again,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3388#issuecomment-1809340514
Usability,simpl,simple,I think you should add a simple test so this doesn't regress again,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3388#issuecomment-1809340514
Usability,clear,clear,"Ah well I retract my comments about the validity of theory, based on this new information! We are good to go --- provided that the Stokes drift we use is the solenoidal Stokes drift. In that case, we can cope with rapid horizontal variation of the Stokes drift it seems, and still model a non-divergence Lagrangian-mean flow. But we should be clear about this in the documentation for this new type StokesDrift. > Also, based on your last comment should we just remove the vertical component of Stokes drift? It only appears in the Stokes-related forcing through its horizontal derivatives. I think we _need_ the vertical component to retain consistency in the case of modulated waves.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3392#issuecomment-1813278220
Integrability,interface,interface,"This is not a horrible interface, except for the name ""particle_advective_forcing_w""... But this deviates from the other interfaces we provide. It might make more sense to build an interface based on `LagrangianParticles`. You may want. ```julia; struct ParticleAdvectionForcing; x; y; z; parameters; end; ```. then a property called `forcing` to `LagrangianParticles`. And a simple way to specify particle sinking. Since the forcing should depend on `particle`, users _also_ have the option to dispatch on it. I wasn't sure what `p` was in the above. We just need `forcing(particle)` or `forcing(particle, parameters)` right? The `particle` contains all relevant information.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1817092592
Usability,simpl,simple,"This is not a horrible interface, except for the name ""particle_advective_forcing_w""... But this deviates from the other interfaces we provide. It might make more sense to build an interface based on `LagrangianParticles`. You may want. ```julia; struct ParticleAdvectionForcing; x; y; z; parameters; end; ```. then a property called `forcing` to `LagrangianParticles`. And a simple way to specify particle sinking. Since the forcing should depend on `particle`, users _also_ have the option to dispatch on it. I wasn't sure what `p` was in the above. We just need `forcing(particle)` or `forcing(particle, parameters)` right? The `particle` contains all relevant information.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1817092592
Deployability,integrat,integrated,"> But this deviates from the other interfaces we provide.; > . I think we kind of have a difference in the interface between particles and body forces. For tracers etc we always launch a kernel over every cell, get the arguments for the forcing at that point, and pass that to forcing functions. But for particles, the only way to add forcings (without making custom structs) is through the `custom_dynamics` where we just give the users forcing function all of the particles together and leave them to e.g. launch a kernel over all of them. . It might be helpful to add this kind of forcing more similar to the first interface and ask users to define slip velocity functions with arbitrary arguments e.g. `w(x, y, z, t, $\rho$, d)`, and then we make the inside of the lagrangian particle advection kernel pass the correct particle properties to the function. I don't think it would be as simple to generalise particle forcings because we don't know what users want to do with the properties and in the current setup couldn't assume that they want every particle property integrated from some tendency function.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1819282470
Integrability,interface,interfaces,"> But this deviates from the other interfaces we provide.; > . I think we kind of have a difference in the interface between particles and body forces. For tracers etc we always launch a kernel over every cell, get the arguments for the forcing at that point, and pass that to forcing functions. But for particles, the only way to add forcings (without making custom structs) is through the `custom_dynamics` where we just give the users forcing function all of the particles together and leave them to e.g. launch a kernel over all of them. . It might be helpful to add this kind of forcing more similar to the first interface and ask users to define slip velocity functions with arbitrary arguments e.g. `w(x, y, z, t, $\rho$, d)`, and then we make the inside of the lagrangian particle advection kernel pass the correct particle properties to the function. I don't think it would be as simple to generalise particle forcings because we don't know what users want to do with the properties and in the current setup couldn't assume that they want every particle property integrated from some tendency function.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1819282470
Usability,simpl,simple,"> But this deviates from the other interfaces we provide.; > . I think we kind of have a difference in the interface between particles and body forces. For tracers etc we always launch a kernel over every cell, get the arguments for the forcing at that point, and pass that to forcing functions. But for particles, the only way to add forcings (without making custom structs) is through the `custom_dynamics` where we just give the users forcing function all of the particles together and leave them to e.g. launch a kernel over all of them. . It might be helpful to add this kind of forcing more similar to the first interface and ask users to define slip velocity functions with arbitrary arguments e.g. `w(x, y, z, t, $\rho$, d)`, and then we make the inside of the lagrangian particle advection kernel pass the correct particle properties to the function. I don't think it would be as simple to generalise particle forcings because we don't know what users want to do with the properties and in the current setup couldn't assume that they want every particle property integrated from some tendency function.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1819282470
Deployability,integrat,integrated,"> I think we kind of have a difference in the interface between particles and body forces. For tracers etc we always launch a kernel over every cell, get the arguments for the forcing at that point, and pass that to forcing functions. But for particles, the only way to add forcings (without making custom structs) is through the `custom_dynamics` where we just give the users forcing function all of the particles together and leave them to e.g. launch a kernel over all of them. Agree, but what point are you trying to make? I don't understand. > ; > It might be helpful to add this kind of forcing more similar to the first interface and ask users to define slip velocity functions with arbitrary arguments e.g. `w(x, y, z, t, $\rho$, d)`, and then we make the inside of the lagrangian particle advection kernel pass the correct particle properties to the function. This is basically what I was suggesting. > ; > I don't think it would be as simple to generalise particle forcings because we don't know what users want to do with the properties and in the current setup couldn't assume that they want every particle property integrated from some tendency function. I don't understand what you're trying to say. Can you elaborate or give an example?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1819351891
Integrability,interface,interface,"> I think we kind of have a difference in the interface between particles and body forces. For tracers etc we always launch a kernel over every cell, get the arguments for the forcing at that point, and pass that to forcing functions. But for particles, the only way to add forcings (without making custom structs) is through the `custom_dynamics` where we just give the users forcing function all of the particles together and leave them to e.g. launch a kernel over all of them. Agree, but what point are you trying to make? I don't understand. > ; > It might be helpful to add this kind of forcing more similar to the first interface and ask users to define slip velocity functions with arbitrary arguments e.g. `w(x, y, z, t, $\rho$, d)`, and then we make the inside of the lagrangian particle advection kernel pass the correct particle properties to the function. This is basically what I was suggesting. > ; > I don't think it would be as simple to generalise particle forcings because we don't know what users want to do with the properties and in the current setup couldn't assume that they want every particle property integrated from some tendency function. I don't understand what you're trying to say. Can you elaborate or give an example?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1819351891
Usability,simpl,simple,"> I think we kind of have a difference in the interface between particles and body forces. For tracers etc we always launch a kernel over every cell, get the arguments for the forcing at that point, and pass that to forcing functions. But for particles, the only way to add forcings (without making custom structs) is through the `custom_dynamics` where we just give the users forcing function all of the particles together and leave them to e.g. launch a kernel over all of them. Agree, but what point are you trying to make? I don't understand. > ; > It might be helpful to add this kind of forcing more similar to the first interface and ask users to define slip velocity functions with arbitrary arguments e.g. `w(x, y, z, t, $\rho$, d)`, and then we make the inside of the lagrangian particle advection kernel pass the correct particle properties to the function. This is basically what I was suggesting. > ; > I don't think it would be as simple to generalise particle forcings because we don't know what users want to do with the properties and in the current setup couldn't assume that they want every particle property integrated from some tendency function. I don't understand what you're trying to say. Can you elaborate or give an example?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1819351891
Availability,avail,available,"> right, sorry I confused `i, j, k` with particle position, I meant we have to pass the particle position `x, y, z`. Ah ok, that makes more sense!. The particle position is available via. ```julia; x = particles[p].x; ```. etc right?. We should implement a helper function,. ```julia; position(p) = (p.x, p.y, p.z); ```. Note that particles are also annoying on `Flat` grids. One needs to beware the particle position in the `Flat` direction, but they shouldn't have to. The same issue will affect `interpolate` once we merge #3395 . EDIT: even better would simply be to extend `interpolate` to work with the particle as an argument, eg something like. ```julia; up = interpolate(particles[p], u, u_loc, grid); ``` . I think ultimately it would be nice to push this under the hood with some nice user interface for `ParticleVelocity` or whatever",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1854245876
Integrability,interface,interface,"> right, sorry I confused `i, j, k` with particle position, I meant we have to pass the particle position `x, y, z`. Ah ok, that makes more sense!. The particle position is available via. ```julia; x = particles[p].x; ```. etc right?. We should implement a helper function,. ```julia; position(p) = (p.x, p.y, p.z); ```. Note that particles are also annoying on `Flat` grids. One needs to beware the particle position in the `Flat` direction, but they shouldn't have to. The same issue will affect `interpolate` once we merge #3395 . EDIT: even better would simply be to extend `interpolate` to work with the particle as an argument, eg something like. ```julia; up = interpolate(particles[p], u, u_loc, grid); ``` . I think ultimately it would be nice to push this under the hood with some nice user interface for `ParticleVelocity` or whatever",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1854245876
Modifiability,extend,extend,"> right, sorry I confused `i, j, k` with particle position, I meant we have to pass the particle position `x, y, z`. Ah ok, that makes more sense!. The particle position is available via. ```julia; x = particles[p].x; ```. etc right?. We should implement a helper function,. ```julia; position(p) = (p.x, p.y, p.z); ```. Note that particles are also annoying on `Flat` grids. One needs to beware the particle position in the `Flat` direction, but they shouldn't have to. The same issue will affect `interpolate` once we merge #3395 . EDIT: even better would simply be to extend `interpolate` to work with the particle as an argument, eg something like. ```julia; up = interpolate(particles[p], u, u_loc, grid); ``` . I think ultimately it would be nice to push this under the hood with some nice user interface for `ParticleVelocity` or whatever",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1854245876
Usability,simpl,simply,"> right, sorry I confused `i, j, k` with particle position, I meant we have to pass the particle position `x, y, z`. Ah ok, that makes more sense!. The particle position is available via. ```julia; x = particles[p].x; ```. etc right?. We should implement a helper function,. ```julia; position(p) = (p.x, p.y, p.z); ```. Note that particles are also annoying on `Flat` grids. One needs to beware the particle position in the `Flat` direction, but they shouldn't have to. The same issue will affect `interpolate` once we merge #3395 . EDIT: even better would simply be to extend `interpolate` to work with the particle as an argument, eg something like. ```julia; up = interpolate(particles[p], u, u_loc, grid); ``` . I think ultimately it would be nice to push this under the hood with some nice user interface for `ParticleVelocity` or whatever",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1854245876
Deployability,update,updated,"I've updated the code to `ParticleVelocities` and changed the function signature to . ```julia; @inline particle_u_velocity(x, y, z, u_fluid, particles, p, advective_velocity::ParticleVelocities, grid, clock, Δt, model_fields) = advective_velocity.u(x, y, z, u_fluid, particles, p, grid, clock, Δt, model_fields); ```. I also swapped around `advect_lagrangian_particles!` and `dynamics`, so now the particles are advected before the `dynamics` function is applied. I found this to be easier when implementing an example with the drag. I've implemented a simple example with a drag in the form of $\frac{d \boldsymbol{v}}{dt} = \frac{C_d}{\tau}(\boldsymbol{u} - \boldsymbol{v})$.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1871616229
Usability,simpl,simple,"I've updated the code to `ParticleVelocities` and changed the function signature to . ```julia; @inline particle_u_velocity(x, y, z, u_fluid, particles, p, advective_velocity::ParticleVelocities, grid, clock, Δt, model_fields) = advective_velocity.u(x, y, z, u_fluid, particles, p, grid, clock, Δt, model_fields); ```. I also swapped around `advect_lagrangian_particles!` and `dynamics`, so now the particles are advected before the `dynamics` function is applied. I found this to be easier when implementing an example with the drag. I've implemented a simple example with a drag in the form of $\frac{d \boldsymbol{v}}{dt} = \frac{C_d}{\tau}(\boldsymbol{u} - \boldsymbol{v})$.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1871616229
Availability,checkpoint,checkpoint,"The intended user experience is that only one line should need to be changed: `pickup=false` to `pickup=true` in `run!`. Therefore, users should not have to manually specify the ""part"" that they want to pick up from. I don't like option 2 above. I think that fixing this problem may become much easier if we can ""delay"" the creation of the output file. Right now, the output file is created when we build the output writer. But at that point, we have no way of knowing whether we are going to pick up or not. I've long wanted to implement this ""delay"" but more pressing matters have intervened... The basic thing we need to do is to add an `initialize!(output_writer, sim)` utility, which will create the output file. That function then will know whether the simulation is starting fresh (because `iteration(sim) == 0`, or whether it is ""continuing""). One huge feature this will enable is the ability to avoid overwriting an existing file when it represents the output from the current continuing run. That's a huge problem with the current interface, is that you have to be really careful about `overwrite_existing` if you are trying to pickup from a checkpoint. And I think that's a big problem. With that feature I think we can also figure out how to handle output that is split into multiple files --- because we know if a simulation is continuing that we will have to figure out which `part` to use (if any). > continues writing into the most recent output file once it catches up to the latest unsaved iteration. This is a separate feature from what I was talking about, but I think it's also a great idea! There also may be a clue how to solve a roundoff error issue, where two outputs are written one iteration separate from one another, but at virtually identical times (eg distinguished only by machine epsilon). PS: I simplified the example a bit to help me understand it",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3399#issuecomment-1837211221
Integrability,interface,interface,"The intended user experience is that only one line should need to be changed: `pickup=false` to `pickup=true` in `run!`. Therefore, users should not have to manually specify the ""part"" that they want to pick up from. I don't like option 2 above. I think that fixing this problem may become much easier if we can ""delay"" the creation of the output file. Right now, the output file is created when we build the output writer. But at that point, we have no way of knowing whether we are going to pick up or not. I've long wanted to implement this ""delay"" but more pressing matters have intervened... The basic thing we need to do is to add an `initialize!(output_writer, sim)` utility, which will create the output file. That function then will know whether the simulation is starting fresh (because `iteration(sim) == 0`, or whether it is ""continuing""). One huge feature this will enable is the ability to avoid overwriting an existing file when it represents the output from the current continuing run. That's a huge problem with the current interface, is that you have to be really careful about `overwrite_existing` if you are trying to pickup from a checkpoint. And I think that's a big problem. With that feature I think we can also figure out how to handle output that is split into multiple files --- because we know if a simulation is continuing that we will have to figure out which `part` to use (if any). > continues writing into the most recent output file once it catches up to the latest unsaved iteration. This is a separate feature from what I was talking about, but I think it's also a great idea! There also may be a clue how to solve a roundoff error issue, where two outputs are written one iteration separate from one another, but at virtually identical times (eg distinguished only by machine epsilon). PS: I simplified the example a bit to help me understand it",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3399#issuecomment-1837211221
Safety,avoid,avoid,"The intended user experience is that only one line should need to be changed: `pickup=false` to `pickup=true` in `run!`. Therefore, users should not have to manually specify the ""part"" that they want to pick up from. I don't like option 2 above. I think that fixing this problem may become much easier if we can ""delay"" the creation of the output file. Right now, the output file is created when we build the output writer. But at that point, we have no way of knowing whether we are going to pick up or not. I've long wanted to implement this ""delay"" but more pressing matters have intervened... The basic thing we need to do is to add an `initialize!(output_writer, sim)` utility, which will create the output file. That function then will know whether the simulation is starting fresh (because `iteration(sim) == 0`, or whether it is ""continuing""). One huge feature this will enable is the ability to avoid overwriting an existing file when it represents the output from the current continuing run. That's a huge problem with the current interface, is that you have to be really careful about `overwrite_existing` if you are trying to pickup from a checkpoint. And I think that's a big problem. With that feature I think we can also figure out how to handle output that is split into multiple files --- because we know if a simulation is continuing that we will have to figure out which `part` to use (if any). > continues writing into the most recent output file once it catches up to the latest unsaved iteration. This is a separate feature from what I was talking about, but I think it's also a great idea! There also may be a clue how to solve a roundoff error issue, where two outputs are written one iteration separate from one another, but at virtually identical times (eg distinguished only by machine epsilon). PS: I simplified the example a bit to help me understand it",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3399#issuecomment-1837211221
Usability,user experience,user experience,"The intended user experience is that only one line should need to be changed: `pickup=false` to `pickup=true` in `run!`. Therefore, users should not have to manually specify the ""part"" that they want to pick up from. I don't like option 2 above. I think that fixing this problem may become much easier if we can ""delay"" the creation of the output file. Right now, the output file is created when we build the output writer. But at that point, we have no way of knowing whether we are going to pick up or not. I've long wanted to implement this ""delay"" but more pressing matters have intervened... The basic thing we need to do is to add an `initialize!(output_writer, sim)` utility, which will create the output file. That function then will know whether the simulation is starting fresh (because `iteration(sim) == 0`, or whether it is ""continuing""). One huge feature this will enable is the ability to avoid overwriting an existing file when it represents the output from the current continuing run. That's a huge problem with the current interface, is that you have to be really careful about `overwrite_existing` if you are trying to pickup from a checkpoint. And I think that's a big problem. With that feature I think we can also figure out how to handle output that is split into multiple files --- because we know if a simulation is continuing that we will have to figure out which `part` to use (if any). > continues writing into the most recent output file once it catches up to the latest unsaved iteration. This is a separate feature from what I was talking about, but I think it's also a great idea! There also may be a clue how to solve a roundoff error issue, where two outputs are written one iteration separate from one another, but at virtually identical times (eg distinguished only by machine epsilon). PS: I simplified the example a bit to help me understand it",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3399#issuecomment-1837211221
Deployability,update,updated,"@simone-silvestri discussed a bit the user interface for building models with a z* vertical coordinate. Here's a prototype design we came up with:. ```julia; reference_levels = exponential_z_faces(Nz=40, depth=6000). Nx = 1440; Ny = 600; Nz = length(reference_levels) - 1. grid = LatitudeLongitudeGrid(arch;; size = (Nx, Ny, Nz),; halo = (7, 7, 7),; z = ZStarVerticalCoordinate(reference_levels),; latitude = (-75, 75),; longitude = (0, 360)); ```. We like this because with z*, the znodes, and zspacings are always changing. We think this makes that semantically clear. Note there are some challenges for output that we have to solve, because the grid has to be updated to do computations. But I think we can solve these with `FieldTimeSeries`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3411#issuecomment-2400477009
Integrability,interface,interface,"@simone-silvestri discussed a bit the user interface for building models with a z* vertical coordinate. Here's a prototype design we came up with:. ```julia; reference_levels = exponential_z_faces(Nz=40, depth=6000). Nx = 1440; Ny = 600; Nz = length(reference_levels) - 1. grid = LatitudeLongitudeGrid(arch;; size = (Nx, Ny, Nz),; halo = (7, 7, 7),; z = ZStarVerticalCoordinate(reference_levels),; latitude = (-75, 75),; longitude = (0, 360)); ```. We like this because with z*, the znodes, and zspacings are always changing. We think this makes that semantically clear. Note there are some challenges for output that we have to solve, because the grid has to be updated to do computations. But I think we can solve these with `FieldTimeSeries`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3411#issuecomment-2400477009
Usability,clear,clear,"@simone-silvestri discussed a bit the user interface for building models with a z* vertical coordinate. Here's a prototype design we came up with:. ```julia; reference_levels = exponential_z_faces(Nz=40, depth=6000). Nx = 1440; Ny = 600; Nz = length(reference_levels) - 1. grid = LatitudeLongitudeGrid(arch;; size = (Nx, Ny, Nz),; halo = (7, 7, 7),; z = ZStarVerticalCoordinate(reference_levels),; latitude = (-75, 75),; longitude = (0, 360)); ```. We like this because with z*, the znodes, and zspacings are always changing. We think this makes that semantically clear. Note there are some challenges for output that we have to solve, because the grid has to be updated to do computations. But I think we can solve these with `FieldTimeSeries`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3411#issuecomment-2400477009
Usability,clear,clear,Can you change the first post so merging this issue closes #3415 (and makes the connection clear),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3416#issuecomment-2179816144
Testability,log,log,Well `sum` definitely won't work (it has to be a simple single-argument transformation) but you could try a function like. ```julia; square(x) = x * x; ```. or `log` if you want to be adventurous,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3427#issuecomment-1995001753
Usability,simpl,simple,Well `sum` definitely won't work (it has to be a simple single-argument transformation) but you could try a function like. ```julia; square(x) = x * x; ```. or `log` if you want to be adventurous,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3427#issuecomment-1995001753
Usability,clear,clear,"Just to be clear: our goal is to develop an API for distributed simulations that require a ""minimum"" of changes to the same script applied to a non-distributed simulation. The point of this goal is to make it easy to scale simulations from single-process to multi-process.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1894652800
Availability,error,errors,"> I don't want to initialize MPI when importing the module because you might import the module but not use MPI routines. This might lead to errors/confusion. For example, the initialization is implicit when constructing the architecture which hasd to use MPI routines (for example `MPI.Comm_rank(MPI.COMM_WORLD)`; > ; > If you want to explicitly use MPI routines in the script (as the example above), it makes sense you initialize MPI and not hide the initialization somewhere else.; > ; > If you want you can introduce an API for calculating the rank and the size that internally initializes MPI, although I don't really deem it necessary to have our own take on MPI as MPI is already very standardized. But why do we need to calculate the rank and size? That's the root issue. I'm not suggesting that we build an API to emit the rank and size. I'm suggesting that we design the code so that kind of calculation is not necessary. Consider: rank and size do not exist for non-distributed simulations. So no matter how it is done, if your code needs to calculate the rank and size, then it is not ""agnostic"" to being distributed vs serial. That is distributed-explicit code. Make it very clear: the objective is to provide a codebase that permits distributed simulations with _minimal_ code changes to serial scripts. If you find that users are constantly writing distributed-specific code, then a rethink is needed. Agree that we should not initialize when importing the module! It doesn't make sense, `DistributedComputations` is always imported but rarely used.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1894895038
Integrability,rout,routines,"> I don't want to initialize MPI when importing the module because you might import the module but not use MPI routines. This might lead to errors/confusion. For example, the initialization is implicit when constructing the architecture which hasd to use MPI routines (for example `MPI.Comm_rank(MPI.COMM_WORLD)`; > ; > If you want to explicitly use MPI routines in the script (as the example above), it makes sense you initialize MPI and not hide the initialization somewhere else.; > ; > If you want you can introduce an API for calculating the rank and the size that internally initializes MPI, although I don't really deem it necessary to have our own take on MPI as MPI is already very standardized. But why do we need to calculate the rank and size? That's the root issue. I'm not suggesting that we build an API to emit the rank and size. I'm suggesting that we design the code so that kind of calculation is not necessary. Consider: rank and size do not exist for non-distributed simulations. So no matter how it is done, if your code needs to calculate the rank and size, then it is not ""agnostic"" to being distributed vs serial. That is distributed-explicit code. Make it very clear: the objective is to provide a codebase that permits distributed simulations with _minimal_ code changes to serial scripts. If you find that users are constantly writing distributed-specific code, then a rethink is needed. Agree that we should not initialize when importing the module! It doesn't make sense, `DistributedComputations` is always imported but rarely used.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1894895038
Usability,clear,clear,"> I don't want to initialize MPI when importing the module because you might import the module but not use MPI routines. This might lead to errors/confusion. For example, the initialization is implicit when constructing the architecture which hasd to use MPI routines (for example `MPI.Comm_rank(MPI.COMM_WORLD)`; > ; > If you want to explicitly use MPI routines in the script (as the example above), it makes sense you initialize MPI and not hide the initialization somewhere else.; > ; > If you want you can introduce an API for calculating the rank and the size that internally initializes MPI, although I don't really deem it necessary to have our own take on MPI as MPI is already very standardized. But why do we need to calculate the rank and size? That's the root issue. I'm not suggesting that we build an API to emit the rank and size. I'm suggesting that we design the code so that kind of calculation is not necessary. Consider: rank and size do not exist for non-distributed simulations. So no matter how it is done, if your code needs to calculate the rank and size, then it is not ""agnostic"" to being distributed vs serial. That is distributed-explicit code. Make it very clear: the objective is to provide a codebase that permits distributed simulations with _minimal_ code changes to serial scripts. If you find that users are constantly writing distributed-specific code, then a rethink is needed. Agree that we should not initialize when importing the module! It doesn't make sense, `DistributedComputations` is always imported but rarely used.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1894895038
Usability,simpl,simple,"Sure, that is just how we are doing it now (the difference would be just inserting the rank behind the scenes). @iuryt if you want to have a go at it in this PR, that should be quite simple to implement (the rank is held in the architecture in `arch.local_rank`) and make sure that the the correct partitioning is taken into account (x partitioning vs y partitioning vs x-y). This API ""problem"" does not exhaust the IO issue though. The problem I was referring to is having split files. I still believe that distributed IO is necessary to have a fully functioning distributed code.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1896032607
Energy Efficiency,efficient,efficient,"> Sure, that is just how we are doing it now (the difference would be just inserting the rank behind the scenes). @iuryt if you want to have a go at it in this PR, that should be quite simple to implement (the rank is held in the architecture in `arch.local_rank`) and make sure that the the correct partitioning is taken into account (x partitioning vs y partitioning vs x-y); > ; > This API ""problem"" does not exhaust the IO issue though. The problem I was referring to is having split files. I still believe that distributed IO is necessary to have a fully functioning distributed code. What's the problem with split files?. Combining data into JLD2 files is not always possible is it? It would require the entirety of the output field to fit into the memory of one node. It also may not be efficient. Correct me if you think otherwise, but it seems we will always want to support split output, even if we also support combined output for distributed simulations.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1896412530
Usability,simpl,simple,"> Sure, that is just how we are doing it now (the difference would be just inserting the rank behind the scenes). @iuryt if you want to have a go at it in this PR, that should be quite simple to implement (the rank is held in the architecture in `arch.local_rank`) and make sure that the the correct partitioning is taken into account (x partitioning vs y partitioning vs x-y); > ; > This API ""problem"" does not exhaust the IO issue though. The problem I was referring to is having split files. I still believe that distributed IO is necessary to have a fully functioning distributed code. What's the problem with split files?. Combining data into JLD2 files is not always possible is it? It would require the entirety of the output field to fit into the memory of one node. It also may not be efficient. Correct me if you think otherwise, but it seems we will always want to support split output, even if we also support combined output for distributed simulations.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1896412530
Energy Efficiency,adapt,adapts,@simone-silvestri can probably contribute a simple script (maybe something that adapts a baroclinic adjustment case) for `Distributed`,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-2085674244
Modifiability,adapt,adapts,@simone-silvestri can probably contribute a simple script (maybe something that adapts a baroclinic adjustment case) for `Distributed`,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-2085674244
Usability,simpl,simple,@simone-silvestri can probably contribute a simple script (maybe something that adapts a baroclinic adjustment case) for `Distributed`,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-2085674244
Deployability,configurat,configuration,"I have introduced the option to iterate as well an option to use the formulation that assumes infinite iterations (`iterations = nothing`). If you want to give it a try for a simple configuration that would be nice!. example:; ```julia; grid = RectilinearGrid(size = (10, 10, 10), extent = (1, 1, 1)). advection = MPData(grid; iterations = 1) # equivalent to UpwindBiased(; order = 1); advection = MPData(grid; iterations = 3) # 3 corrective iterations; advection = MPData(grid; iterations = nothing) # ∞ iterations (a little more expensive); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3434#issuecomment-1942023450
Modifiability,config,configuration,"I have introduced the option to iterate as well an option to use the formulation that assumes infinite iterations (`iterations = nothing`). If you want to give it a try for a simple configuration that would be nice!. example:; ```julia; grid = RectilinearGrid(size = (10, 10, 10), extent = (1, 1, 1)). advection = MPData(grid; iterations = 1) # equivalent to UpwindBiased(; order = 1); advection = MPData(grid; iterations = 3) # 3 corrective iterations; advection = MPData(grid; iterations = nothing) # ∞ iterations (a little more expensive); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3434#issuecomment-1942023450
Usability,simpl,simple,"I have introduced the option to iterate as well an option to use the formulation that assumes infinite iterations (`iterations = nothing`). If you want to give it a try for a simple configuration that would be nice!. example:; ```julia; grid = RectilinearGrid(size = (10, 10, 10), extent = (1, 1, 1)). advection = MPData(grid; iterations = 1) # equivalent to UpwindBiased(; order = 1); advection = MPData(grid; iterations = 3) # 3 corrective iterations; advection = MPData(grid; iterations = nothing) # ∞ iterations (a little more expensive); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3434#issuecomment-1942023450
Performance,perform,performing,"Some thoughts:. The first case (`N=100`) doesn't look great but it shows that the MPData schemes do not differ very much whether we have 2 or 5 iteractions, and they are somewhere between 1st and 3rd order upwinding. The second case (`N=200`) looks better and I can't really see any difference between 2 and 5 iterations. The third case (`N=400`) has all the schemes performing well, even first order upwinding. Again we can't differentiate between the two MPData schemes and it's even hard to differentiate between 3rd and 5th order upwinding. I lesson that I learned from here is to use as much spatial resolution as we can as this does much more compared to the number of iterations. . @simone-silvestri : do you think we should do a similar comparison for 2D advection?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3434#issuecomment-1954430883
Usability,learn,learned,"Some thoughts:. The first case (`N=100`) doesn't look great but it shows that the MPData schemes do not differ very much whether we have 2 or 5 iteractions, and they are somewhere between 1st and 3rd order upwinding. The second case (`N=200`) looks better and I can't really see any difference between 2 and 5 iterations. The third case (`N=400`) has all the schemes performing well, even first order upwinding. Again we can't differentiate between the two MPData schemes and it's even hard to differentiate between 3rd and 5th order upwinding. I lesson that I learned from here is to use as much spatial resolution as we can as this does much more compared to the number of iterations. . @simone-silvestri : do you think we should do a similar comparison for 2D advection?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3434#issuecomment-1954430883
Performance,perform,performs,Thanks for running these tests. It would be nice to see how MPData performs in a 2D flow. . It's interesting that tweaking the number of iterations doesn't seem to make much difference. I'm a bit skeptical about this scheme though; it seems pretty diffusive and doesn't even beat third-order upwind which is way simpler. I might have introduced a bug although I went through the code again and it looks correct to me. Another possibility is that the high diffusivity is the trade-off for keeping the scheme positivity-preserving?; Godunov's theorem sets some tough standards -- it's not possible to obtain monotonic advection with a linear scheme beyond first order.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3434#issuecomment-1954700946
Testability,test,tests,Thanks for running these tests. It would be nice to see how MPData performs in a 2D flow. . It's interesting that tweaking the number of iterations doesn't seem to make much difference. I'm a bit skeptical about this scheme though; it seems pretty diffusive and doesn't even beat third-order upwind which is way simpler. I might have introduced a bug although I went through the code again and it looks correct to me. Another possibility is that the high diffusivity is the trade-off for keeping the scheme positivity-preserving?; Godunov's theorem sets some tough standards -- it's not possible to obtain monotonic advection with a linear scheme beyond first order.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3434#issuecomment-1954700946
Usability,simpl,simpler,Thanks for running these tests. It would be nice to see how MPData performs in a 2D flow. . It's interesting that tweaking the number of iterations doesn't seem to make much difference. I'm a bit skeptical about this scheme though; it seems pretty diffusive and doesn't even beat third-order upwind which is way simpler. I might have introduced a bug although I went through the code again and it looks correct to me. Another possibility is that the high diffusivity is the trade-off for keeping the scheme positivity-preserving?; Godunov's theorem sets some tough standards -- it's not possible to obtain monotonic advection with a linear scheme beyond first order.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3434#issuecomment-1954700946
Testability,test,test,Thanks @glwagner. Sorry I didn't test before but I assumed that since we never reached that warning it couldn't cause problems. I'll close this issue since it's clearly out of the scope for Oceananigans,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3438#issuecomment-1911238491
Usability,clear,clearly,Thanks @glwagner. Sorry I didn't test before but I assumed that since we never reached that warning it couldn't cause problems. I'll close this issue since it's clearly out of the scope for Oceananigans,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3438#issuecomment-1911238491
Availability,mask,mask,"The extra function you need looks like this. https://github.com/CliMA/Oceananigans.jl/blob/1c2a6f8752b6425bf30d856f8ba0aa681c0ab818/src/AbstractOperations/conditional_operations.jl#L108-L111. It should be added here:; https://github.com/CliMA/Oceananigans.jl/blob/1c2a6f8752b6425bf30d856f8ba0aa681c0ab818/src/ImmersedBoundaries/immersed_reductions.jl#L22. and should specifically be. ```julia; @inline function condition_operand(func::Function, operand::IF, condition::AbstractArray, mask) ; condition = arch_array(architecture(operand.grid), condition) ; return ConditionalOperation(operand; func, condition, mask) ; end ; ```. using the const `IF` defined above that. I guess this is a convenience for users who build CPU-based conditional and want to use them on the GPU. > since it fails if I simply set condition=boundary_node_ccf. I'm interested in seeing the error so we can fix that.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3439#issuecomment-1904976682
Usability,simpl,simply,"The extra function you need looks like this. https://github.com/CliMA/Oceananigans.jl/blob/1c2a6f8752b6425bf30d856f8ba0aa681c0ab818/src/AbstractOperations/conditional_operations.jl#L108-L111. It should be added here:; https://github.com/CliMA/Oceananigans.jl/blob/1c2a6f8752b6425bf30d856f8ba0aa681c0ab818/src/ImmersedBoundaries/immersed_reductions.jl#L22. and should specifically be. ```julia; @inline function condition_operand(func::Function, operand::IF, condition::AbstractArray, mask) ; condition = arch_array(architecture(operand.grid), condition) ; return ConditionalOperation(operand; func, condition, mask) ; end ; ```. using the const `IF` defined above that. I guess this is a convenience for users who build CPU-based conditional and want to use them on the GPU. > since it fails if I simply set condition=boundary_node_ccf. I'm interested in seeing the error so we can fix that.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3439#issuecomment-1904976682
Safety,avoid,avoid,I'm having trouble following your example. Can you come up with a simpler illustration of the issue and avoid constructions with many operations on a line?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3455#issuecomment-1926176837
Usability,simpl,simpler,I'm having trouble following your example. Can you come up with a simpler illustration of the issue and avoid constructions with many operations on a line?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3455#issuecomment-1926176837
Usability,simpl,simple,"Something I see that needs to be fixed right away is that the ""mean"" and ""prime"" terms have to be precomputed _outside_ a kernel. For example,. ```julia; @kernel function calculate_pressure_source_term_fft_based_solver_rapid!(rhs, grid, Δt, U★); i, j, k = @index(Global, NTuple); U = Field(Average(U★.u, dims=(1, 2))); V = Field(Average(U★.v, dims=(1, 2))); W = Field(Average(U★.w, dims=(1, 2))); ```. probably won't work. The other issue is that we have to call `compute!` to precompute these fields, which is not being done. Also, just as a matter of approach, I would suggest not changing the source code to do this problem but instead using the solvers directly to compute the solution to this new Poisson problem. That will allow you to more quickly compare the pressure computed by the native algorithm to the ""new"" pressure that is computed offline. The first step towards solving this problem is to show that you can solve Poisson's equation correctly using `FFTBasedPoissonSolver`! (This is the solver that will work for grids that are regularly spaced in all directions.) Once you have code that can solve the Poisson equation for a simple RHS, then I suggest building up the RHS terms that you have piece by piece. When you add a new term to the RHS, plot the term to make sure it looks right. Then solve Poisson's equation with the new term, and make sure the solution looks good. Keep adding terms ensuring that each time you build up the complexity the result is as expected and you don't get NaNs.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3459#issuecomment-1930108162
Usability,guid,guidance,"Thanks for putting your thoughts about this together Zheng! I support Greg's suggestion of moving this to the discussion section. In response to your BC question: since I don't yet understand the nuances of the Oceananigans pressure solver and time stepping, I would follow Greg's guidance with the aim of writing code that calculates all of the individual pressure components using the existing /default Oceananigans homogeneous Neumann BC implementation for each term. Once you have confidence that your code works and is using the correct RHS for each pressure component, I would check the residual (how much of the total non-hydrostatic pressure is explained by the sum of the pressure components). If the residual is very small I do not think it would be necessary to delve into the BC details. If the residual is large, you probably need to look at the BC implementation in more detail.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3459#issuecomment-1931379047
Usability,simpl,simple,"""regridding"" is conservative, ie the volume integral of the target field should be the same as the source field. However because of that, we can only regrid in one direction at a time right now. If you want to regrid in multiple directions, you need to form intermediate fields. General conservative is actually possible, just a bit more difficult. `interpolate!` does not conserve global integrals. It's just simple linear interpolation. Usually `interpolate!` is good enough.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3460#issuecomment-1946394580
Energy Efficiency,schedul,schedule,"Just for reference, I created the MWE example below of a column model with a sheared `u` that evolves in time, where I write both the full `u` and an interpolated `u` to half the original resolution. What I'm doing here is creating a coarse grid, coarse model, and coarse field that takes the interpolated `u`. I use a `Callback` to keep interpolating `u` into `coarse_u` and then it's only a matter of setting up a coarse `NetCDFWriter` with `coarse_model`. ```julia; using Oceananigans. grid = RectilinearGrid(size = (1, 1, 8), extent = (1,1,1));; model = NonhydrostaticModel(; grid, closure = ScalarDiffusivity(ν=1e-2)). set!(model, u=(x, y, z,) -> z). simulation = Simulation(model,; Δt=0.5*maximum(zspacings(grid, Center())) / maximum(abs, model.velocities.u),; stop_time=20); # Create regular output; simulation.output_writers[:fullfields] = NetCDFOutputWriter(model, (; model.velocities.u),; filename = ""fullfields.nc"",; schedule = TimeInterval(5),; overwrite_existing = true,). # Create interpolated u on coarse grid; coarse_grid = RectilinearGrid(size = (grid.Nx, grid.Ny, grid.Nz÷2), extent = (grid.Lx, grid.Ly, grid.Lz)); coarse_model = NonhydrostaticModel(; grid=coarse_grid, closure = ScalarDiffusivity(ν=1e-2)); coarse_u = Field{Face, Center, Center}(coarse_grid). using Oceananigans.Fields: interpolate!; update_coarse_u(simulation) = interpolate!(coarse_u, simulation.model.velocities.u); simulation.callbacks[:update_interp] = Callback(update_coarse_u). # Create coarse output; simulation.output_writers[:coarsefields] = NetCDFOutputWriter(coarse_model, (; coarse_u,),; filename=""coarsefields.nc"",; schedule=TimeInterval(5),; overwrite_existing=true,). run!(simulation); ```. This seems to be working. In the figure below the lines and triangles come from the full res output, while the cirlces come from the coarse (interpolated) output:. ![image](https://github.com/CliMA/Oceananigans.jl/assets/13205162/1a72237a-67ac-4804-9230-9d766e71b353). You can definitely take nicer/fancier a",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3460#issuecomment-2090846777
Modifiability,evolve,evolves,"Just for reference, I created the MWE example below of a column model with a sheared `u` that evolves in time, where I write both the full `u` and an interpolated `u` to half the original resolution. What I'm doing here is creating a coarse grid, coarse model, and coarse field that takes the interpolated `u`. I use a `Callback` to keep interpolating `u` into `coarse_u` and then it's only a matter of setting up a coarse `NetCDFWriter` with `coarse_model`. ```julia; using Oceananigans. grid = RectilinearGrid(size = (1, 1, 8), extent = (1,1,1));; model = NonhydrostaticModel(; grid, closure = ScalarDiffusivity(ν=1e-2)). set!(model, u=(x, y, z,) -> z). simulation = Simulation(model,; Δt=0.5*maximum(zspacings(grid, Center())) / maximum(abs, model.velocities.u),; stop_time=20); # Create regular output; simulation.output_writers[:fullfields] = NetCDFOutputWriter(model, (; model.velocities.u),; filename = ""fullfields.nc"",; schedule = TimeInterval(5),; overwrite_existing = true,). # Create interpolated u on coarse grid; coarse_grid = RectilinearGrid(size = (grid.Nx, grid.Ny, grid.Nz÷2), extent = (grid.Lx, grid.Ly, grid.Lz)); coarse_model = NonhydrostaticModel(; grid=coarse_grid, closure = ScalarDiffusivity(ν=1e-2)); coarse_u = Field{Face, Center, Center}(coarse_grid). using Oceananigans.Fields: interpolate!; update_coarse_u(simulation) = interpolate!(coarse_u, simulation.model.velocities.u); simulation.callbacks[:update_interp] = Callback(update_coarse_u). # Create coarse output; simulation.output_writers[:coarsefields] = NetCDFOutputWriter(coarse_model, (; coarse_u,),; filename=""coarsefields.nc"",; schedule=TimeInterval(5),; overwrite_existing=true,). run!(simulation); ```. This seems to be working. In the figure below the lines and triangles come from the full res output, while the cirlces come from the coarse (interpolated) output:. ![image](https://github.com/CliMA/Oceananigans.jl/assets/13205162/1a72237a-67ac-4804-9230-9d766e71b353). You can definitely take nicer/fancier a",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3460#issuecomment-2090846777
Usability,simpl,simple,"1,1));; model = NonhydrostaticModel(; grid, closure = ScalarDiffusivity(ν=1e-2)). set!(model, u=(x, y, z,) -> z). simulation = Simulation(model,; Δt=0.5*maximum(zspacings(grid, Center())) / maximum(abs, model.velocities.u),; stop_time=20); # Create regular output; simulation.output_writers[:fullfields] = NetCDFOutputWriter(model, (; model.velocities.u),; filename = ""fullfields.nc"",; schedule = TimeInterval(5),; overwrite_existing = true,). # Create interpolated u on coarse grid; coarse_grid = RectilinearGrid(size = (grid.Nx, grid.Ny, grid.Nz÷2), extent = (grid.Lx, grid.Ly, grid.Lz)); coarse_model = NonhydrostaticModel(; grid=coarse_grid, closure = ScalarDiffusivity(ν=1e-2)); coarse_u = Field{Face, Center, Center}(coarse_grid). using Oceananigans.Fields: interpolate!; update_coarse_u(simulation) = interpolate!(coarse_u, simulation.model.velocities.u); simulation.callbacks[:update_interp] = Callback(update_coarse_u). # Create coarse output; simulation.output_writers[:coarsefields] = NetCDFOutputWriter(coarse_model, (; coarse_u,),; filename=""coarsefields.nc"",; schedule=TimeInterval(5),; overwrite_existing=true,). run!(simulation); ```. This seems to be working. In the figure below the lines and triangles come from the full res output, while the cirlces come from the coarse (interpolated) output:. ![image](https://github.com/CliMA/Oceananigans.jl/assets/13205162/1a72237a-67ac-4804-9230-9d766e71b353). You can definitely take nicer/fancier approaches that scale much more easily (@glwagner mentioned a few options), but I feel like this is very simple to understand and can be scaled up to a list of outputs reasonably easily; you just gotta create the list of coarsened outputs based on the original list of outputs and interpolate the list in the `Callback`. @iuryt is this good enough for your purposes?. Also a quick note: if you want outputs at levels that aren't equally spaced from each other, you can set-up `coarse_grid` using an array of depths as the vertical coordinate.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3460#issuecomment-2090846777
Energy Efficiency,schedul,schedule,"Thanks, @tomchor ! ; Is that a reason why you define the closure for the coarse_model?. Until now, what I was doing was something like this. ```julia; for i = 1:10:model.Nz; key = Symbol(""xy"", i) # Create the dictionary key dynamically; fname = ""vxy_z$(@sprintf(""%05d"", i)).nc""; simulation.output_writers[key] = NetCDFOutputWriter(model, output_fields,; schedule = TimeInterval(output_interval),; filename = fname,; indices = (:,:,i),; with_halos = false,; overwrite_existing = overwrite_existing,; array_type = Array{Float32}); end; ```; Which creates a file for each subset level. While I think that @tomchor solution is the best because it is more general and can be for any arbitrary new grid, I still think we should also be able to simply pass the indices to `NetCDFOutputWriter`. For example, this should work. ```julia; using Oceananigans. grid = RectilinearGrid(size = (1, 1, 8), extent = (1,1,1));; model = NonhydrostaticModel(; grid, closure = ScalarDiffusivity(ν=1e-2)). set!(model, u=(x, y, z,) -> z). simulation = Simulation(model,; Δt=0.5*maximum(zspacings(grid, Center())) / maximum(abs, model.velocities.u),; stop_time=20); # Create regular output; simulation.output_writers[:fullfields] = NetCDFOutputWriter(model, (; model.velocities.u),; filename = ""fullfields.nc"",; schedule = TimeInterval(5),; overwrite_existing = true,). # Create coarse output; simulation.output_writers[:coarsefields] = NetCDFOutputWriter(model, (; model.velocities.u),; filename=""coarsefields.nc"",; schedule=TimeInterval(5),; indices = (:,:,1:10:model.Nz),; overwrite_existing=true,). run!(simulation); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3460#issuecomment-2091084470
Usability,simpl,simply,"Thanks, @tomchor ! ; Is that a reason why you define the closure for the coarse_model?. Until now, what I was doing was something like this. ```julia; for i = 1:10:model.Nz; key = Symbol(""xy"", i) # Create the dictionary key dynamically; fname = ""vxy_z$(@sprintf(""%05d"", i)).nc""; simulation.output_writers[key] = NetCDFOutputWriter(model, output_fields,; schedule = TimeInterval(output_interval),; filename = fname,; indices = (:,:,i),; with_halos = false,; overwrite_existing = overwrite_existing,; array_type = Array{Float32}); end; ```; Which creates a file for each subset level. While I think that @tomchor solution is the best because it is more general and can be for any arbitrary new grid, I still think we should also be able to simply pass the indices to `NetCDFOutputWriter`. For example, this should work. ```julia; using Oceananigans. grid = RectilinearGrid(size = (1, 1, 8), extent = (1,1,1));; model = NonhydrostaticModel(; grid, closure = ScalarDiffusivity(ν=1e-2)). set!(model, u=(x, y, z,) -> z). simulation = Simulation(model,; Δt=0.5*maximum(zspacings(grid, Center())) / maximum(abs, model.velocities.u),; stop_time=20); # Create regular output; simulation.output_writers[:fullfields] = NetCDFOutputWriter(model, (; model.velocities.u),; filename = ""fullfields.nc"",; schedule = TimeInterval(5),; overwrite_existing = true,). # Create coarse output; simulation.output_writers[:coarsefields] = NetCDFOutputWriter(model, (; model.velocities.u),; filename=""coarsefields.nc"",; schedule=TimeInterval(5),; indices = (:,:,1:10:model.Nz),; overwrite_existing=true,). run!(simulation); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3460#issuecomment-2091084470
Safety,avoid,avoid,"> Is that a reason why you define the closure for the coarse_model?. There reason is that at the moment `NetCDFWriter` needs it to get some info on the `grid`. But as @glwagner and I pointed out, it's probably pretty easy to change `NetCDFWriter` to avoid that. I might try a PR soon that makes the simplest change possible and see it tests pass.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3460#issuecomment-2091121584
Testability,test,tests,"> Is that a reason why you define the closure for the coarse_model?. There reason is that at the moment `NetCDFWriter` needs it to get some info on the `grid`. But as @glwagner and I pointed out, it's probably pretty easy to change `NetCDFWriter` to avoid that. I might try a PR soon that makes the simplest change possible and see it tests pass.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3460#issuecomment-2091121584
Usability,simpl,simplest,"> Is that a reason why you define the closure for the coarse_model?. There reason is that at the moment `NetCDFWriter` needs it to get some info on the `grid`. But as @glwagner and I pointed out, it's probably pretty easy to change `NetCDFWriter` to avoid that. I might try a PR soon that makes the simplest change possible and see it tests pass.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3460#issuecomment-2091121584
Usability,simpl,simply,"> For example, this should work. You can probably make this work pretty easily for precomputed fields. It's no different from simply calling `Array(view(field, indices...))`. So you just have to add some stuff to `view(f::Field, i, j, k)` to special-case `StepRange` indices. It's more work / requires more ingenuity and cleverness to get that working with AbstractOperations and allocating the right amount of memory, etc, plus index gymnastics. That said I don't see any issue. Just some coding and arithmetic.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3460#issuecomment-2091162179
Testability,benchmark,benchmark,"> I'm game to try. Should we modify the baroclinic adjustment problem or is there another benchmark you have in mind?. I think it makes sense to keep going with the baroclinic adjustment case!. To change the free surface you'll use. ```julia; free_surface = SplitExplicitFreeSurface(grid); ```. as a keyword argument in the model constructor. I think the default parameters for it make sense but @simone-silvestri can confirm. We can also try with `ExplicitFreeSurface()` which is even simpler, but in that case we'll have to modify `gravitational_acceleration` and the time step to get something that can complete in a reasonable amount of time. Btw if you paste the baroclinic adjustment script you are working with we can also check to make sure it's GPU compatible and possibly help simplify it further.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3475#issuecomment-1950274069
Usability,simpl,simpler,"> I'm game to try. Should we modify the baroclinic adjustment problem or is there another benchmark you have in mind?. I think it makes sense to keep going with the baroclinic adjustment case!. To change the free surface you'll use. ```julia; free_surface = SplitExplicitFreeSurface(grid); ```. as a keyword argument in the model constructor. I think the default parameters for it make sense but @simone-silvestri can confirm. We can also try with `ExplicitFreeSurface()` which is even simpler, but in that case we'll have to modify `gravitational_acceleration` and the time step to get something that can complete in a reasonable amount of time. Btw if you paste the baroclinic adjustment script you are working with we can also check to make sure it's GPU compatible and possibly help simplify it further.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3475#issuecomment-1950274069
Testability,test,test,It'd be best if you guys can take a look at the conflicts in `src/Architectures.jl`; it's not clear to me what some decisions would influence elsewhere in the code - quite a bit has changed that you are probably more aware of. I'm happy to test the code once conflicts are resolved.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3475#issuecomment-1997670821
Usability,clear,clear,It'd be best if you guys can take a look at the conflicts in `src/Architectures.jl`; it's not clear to me what some decisions would influence elsewhere in the code - quite a bit has changed that you are probably more aware of. I'm happy to test the code once conflicts are resolved.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3475#issuecomment-1997670821
Availability,down,down,Let's do a simple test of CPU performance to make sure we won't have to revert this soon given the change to splatting (which was implemented to solve a 100x slow down a few months ago),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3480#issuecomment-2137702684
Performance,perform,performance,Let's do a simple test of CPU performance to make sure we won't have to revert this soon given the change to splatting (which was implemented to solve a 100x slow down a few months ago),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3480#issuecomment-2137702684
Testability,test,test,Let's do a simple test of CPU performance to make sure we won't have to revert this soon given the change to splatting (which was implemented to solve a 100x slow down a few months ago),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3480#issuecomment-2137702684
Usability,simpl,simple,Let's do a simple test of CPU performance to make sure we won't have to revert this soon given the change to splatting (which was implemented to solve a 100x slow down a few months ago),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3480#issuecomment-2137702684
Performance,perform,performance,"> Billy mentioned it in some other comments but while we do splat args for some of the function calls, the function definitions use Varargs instead. This should avoid the catastrophic slowdown we saw with splatting earlier, but I agree that it should be tested. Do you have any good CPU performance tests set up @glwagner ?. Any simple test will do, for example one of the examples",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3480#issuecomment-2150416681
Safety,avoid,avoid,"> Billy mentioned it in some other comments but while we do splat args for some of the function calls, the function definitions use Varargs instead. This should avoid the catastrophic slowdown we saw with splatting earlier, but I agree that it should be tested. Do you have any good CPU performance tests set up @glwagner ?. Any simple test will do, for example one of the examples",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3480#issuecomment-2150416681
Testability,test,tested,"> Billy mentioned it in some other comments but while we do splat args for some of the function calls, the function definitions use Varargs instead. This should avoid the catastrophic slowdown we saw with splatting earlier, but I agree that it should be tested. Do you have any good CPU performance tests set up @glwagner ?. Any simple test will do, for example one of the examples",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3480#issuecomment-2150416681
Usability,simpl,simple,"> Billy mentioned it in some other comments but while we do splat args for some of the function calls, the function definitions use Varargs instead. This should avoid the catastrophic slowdown we saw with splatting earlier, but I agree that it should be tested. Do you have any good CPU performance tests set up @glwagner ?. Any simple test will do, for example one of the examples",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3480#issuecomment-2150416681
Integrability,interface,interfaces,"It's as @simone-silvestri said, more broadly it seems that we need to think of boundary conditions differently between `Face` fields and `Center` fields. `Face` fields have nodes on the boundary (sometimes we call those ""peripheral nodes""), so we simply impose boundary values to satisfy boundary conditions, eg for determining wall-normal velocities. `Center` fields have nodes within and outside, but not on the boundary. This is the core of the discussion @simone-silvestri and I had about tracer boundary conditions: we can choose either to set the tracer halos to produce a result when tracers are reconstructed _on_ the boundary (that's how `Value` and `Gradient` boundary conditions work -- the halos are determined by extrapolation). Or, we can set the tracer halos as if the halo region is part of some other prognostic state (which is what I envisioned `Open` should do). Finally as @simone-silvestri says the tracer halos are `0, N+1` while wall-normal velocity points _on_ the boundary are `1` and `N+1`. I think its fine to pass additional arguments to `fill_halo_regions!`, and use these for open boundary conditions. In fact, `DiscreteBoundaryCondition` and `ContinuousBoundaryCondition` appear to already be designed to accomodate additional arguments that are unused by those user interfaces (note the `args...`):. https://github.com/CliMA/Oceananigans.jl/blob/643b484e81e0aeb038b3038266912ad051bce9b8/src/BoundaryConditions/discrete_boundary_function.jl#L45 . https://github.com/CliMA/Oceananigans.jl/blob/643b484e81e0aeb038b3038266912ad051bce9b8/src/BoundaryConditions/continuous_boundary_function.jl#L136-L137",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1972507075
Usability,simpl,simply,"It's as @simone-silvestri said, more broadly it seems that we need to think of boundary conditions differently between `Face` fields and `Center` fields. `Face` fields have nodes on the boundary (sometimes we call those ""peripheral nodes""), so we simply impose boundary values to satisfy boundary conditions, eg for determining wall-normal velocities. `Center` fields have nodes within and outside, but not on the boundary. This is the core of the discussion @simone-silvestri and I had about tracer boundary conditions: we can choose either to set the tracer halos to produce a result when tracers are reconstructed _on_ the boundary (that's how `Value` and `Gradient` boundary conditions work -- the halos are determined by extrapolation). Or, we can set the tracer halos as if the halo region is part of some other prognostic state (which is what I envisioned `Open` should do). Finally as @simone-silvestri says the tracer halos are `0, N+1` while wall-normal velocity points _on_ the boundary are `1` and `N+1`. I think its fine to pass additional arguments to `fill_halo_regions!`, and use these for open boundary conditions. In fact, `DiscreteBoundaryCondition` and `ContinuousBoundaryCondition` appear to already be designed to accomodate additional arguments that are unused by those user interfaces (note the `args...`):. https://github.com/CliMA/Oceananigans.jl/blob/643b484e81e0aeb038b3038266912ad051bce9b8/src/BoundaryConditions/discrete_boundary_function.jl#L45 . https://github.com/CliMA/Oceananigans.jl/blob/643b484e81e0aeb038b3038266912ad051bce9b8/src/BoundaryConditions/continuous_boundary_function.jl#L136-L137",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1972507075
Usability,simpl,simple,But can we do one thing at a time? I feel a lot of non-trivial changes are making their way in at the same time. Why don't we first ensure that we are happy with simple open boundary conditions where the outflow and/or inflow velocities are prescribed? Then we can work on getting the code together for cases where the boundary velocities are computed by some rule.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1977653215
Deployability,update,update,"Yeah okay, both of those suggestions make sense and adding a line in update state is probably the most general solution too. Once I've cleaned up a bit I guess the only the last we would need to settle on for the simplest case is how we specify the form of $\phi^{n+1}$ (and how I've written the fill_bulk_outflow_halo file). Currently, it is hardcoded that it is upwinded when there is an outflow and relaxed to an external solution when it inflows as:. `(1 - Ūᵇ - 1/τ̄) * ϕⁿ + Ūᵇ * ϕᵢ₋₁ + ϕᵉ / τ̄`,. where $0 < U^b < 1 $, but conceivably it could be something along the lines of unwinding both ways like:. `(1 - Ūᵇ) * ϕⁿ + max(0, Ūᵇ) * ϕᵢ₋₁ - min(0, Ūᵇ) * ϕᵉ`. Perhaps if we change to:; ```julia; struct BulkOutflow{IS, OS} <: AbstractBoundaryConditionClassification; inflow_speed :: IS; outflow_speed :: OS; end; ```; then we can make it the general form:. $\phi^{n+1} _i = (1 - U_i - U_o) \phi^n + U_i \phi^e + U_o \phi^n _{i-1}$. with $0 < U_i, U_o < 1$ and only $U_i$ or $U_o$ can be non-zero.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1978821684
Usability,simpl,simplest,"Yeah okay, both of those suggestions make sense and adding a line in update state is probably the most general solution too. Once I've cleaned up a bit I guess the only the last we would need to settle on for the simplest case is how we specify the form of $\phi^{n+1}$ (and how I've written the fill_bulk_outflow_halo file). Currently, it is hardcoded that it is upwinded when there is an outflow and relaxed to an external solution when it inflows as:. `(1 - Ūᵇ - 1/τ̄) * ϕⁿ + Ūᵇ * ϕᵢ₋₁ + ϕᵉ / τ̄`,. where $0 < U^b < 1 $, but conceivably it could be something along the lines of unwinding both ways like:. `(1 - Ūᵇ) * ϕⁿ + max(0, Ūᵇ) * ϕᵢ₋₁ - min(0, Ūᵇ) * ϕᵉ`. Perhaps if we change to:; ```julia; struct BulkOutflow{IS, OS} <: AbstractBoundaryConditionClassification; inflow_speed :: IS; outflow_speed :: OS; end; ```; then we can make it the general form:. $\phi^{n+1} _i = (1 - U_i - U_o) \phi^n + U_i \phi^e + U_o \phi^n _{i-1}$. with $0 < U_i, U_o < 1$ and only $U_i$ or $U_o$ can be non-zero.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1978821684
Deployability,update,update,"> Yeah okay, both of those suggestions make sense and adding a line in update state is probably the most general solution too.; > ; > Once I've cleaned up a bit I guess the only the last we would need to settle on for the simplest case is how we specify the form of ϕn+1 (and how I've written the fill_bulk_outflow_halo file). Currently, it is hardcoded that it is upwinded when there is an outflow and relaxed to an external solution when it inflows as:; > ; > `(1 - Ūᵇ - 1/τ̄) * ϕⁿ + Ūᵇ * ϕᵢ₋₁ + ϕᵉ / τ̄`,; > ; > where 0<Ub<1, but conceivably it could be something along the lines of unwinding both ways like:; > ; > `(1 - Ūᵇ) * ϕⁿ + max(0, Ūᵇ) * ϕᵢ₋₁ - min(0, Ūᵇ) * ϕᵉ`; > ; > Perhaps if we change to:; > ; > ```julia; > struct BulkOutflow{IS, OS} <: AbstractBoundaryConditionClassification; > inflow_speed :: IS; > outflow_speed :: OS; > end; > ```; > ; > then we can make it the general form:; > ; > ϕin+1=(1−Ui−Uo)ϕn+Uiϕe+Uoϕi−1n; > ; > with 0<Ui,Uo<1 and only Ui or Uo can be non-zero. Could this be formulated as a condition, using the `Open` classification?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1979243985
Usability,simpl,simplest,"> Yeah okay, both of those suggestions make sense and adding a line in update state is probably the most general solution too.; > ; > Once I've cleaned up a bit I guess the only the last we would need to settle on for the simplest case is how we specify the form of ϕn+1 (and how I've written the fill_bulk_outflow_halo file). Currently, it is hardcoded that it is upwinded when there is an outflow and relaxed to an external solution when it inflows as:; > ; > `(1 - Ūᵇ - 1/τ̄) * ϕⁿ + Ūᵇ * ϕᵢ₋₁ + ϕᵉ / τ̄`,; > ; > where 0<Ub<1, but conceivably it could be something along the lines of unwinding both ways like:; > ; > `(1 - Ūᵇ) * ϕⁿ + max(0, Ūᵇ) * ϕᵢ₋₁ - min(0, Ūᵇ) * ϕᵉ`; > ; > Perhaps if we change to:; > ; > ```julia; > struct BulkOutflow{IS, OS} <: AbstractBoundaryConditionClassification; > inflow_speed :: IS; > outflow_speed :: OS; > end; > ```; > ; > then we can make it the general form:; > ; > ϕin+1=(1−Ui−Uo)ϕn+Uiϕe+Uoϕi−1n; > ; > with 0<Ui,Uo<1 and only Ui or Uo can be non-zero. Could this be formulated as a condition, using the `Open` classification?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1979243985
Testability,log,logical,"> I'm not sure since I've been putting the external value as the condition which is kind of the same as e.g. when we specify a `Gradient` classification that the `condition` is then the value of the gradient and so the boundary point is some function of the `condition`.; > ; > This differs from `Open` as the `condition` doesn't directly specify the boundary value but instead is some function of it. I guess it would be more traditional to call this `Radiating` but I don't think that really explains what is going on.; > ; > It would be _possible_ to write a condition that did this, but I think it would make user specification of exterior values more complicated. I don't really see why it makes user specification more complicated. The discussion is purely about how the user API communicates and organizes information. I would argue that it's logical or clear to ""classify"" a radiating boundary condition as an ""open boundary condition"", because radiating boundary conditions imply that there is a non-trivial external state outside the prognostic domain. This differs from `Value` or `Gradient` which communicate the notion of either a solid wall or fixed external state. The alternative propose is to get rid of `Open` entirely, which we could do. That would be a ""flatter"" design. I think that a possible user workflow might involve 1) deciding what boundary conditions are ""Open"" versus not, and _then_ 2) deciding how to treat the open boundary numerically / physically. For example we might write ""we specify an open boundary with X method"". To me that implies including the word ""Open"" in the user API is important.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1979898600
Usability,clear,clear,"> I'm not sure since I've been putting the external value as the condition which is kind of the same as e.g. when we specify a `Gradient` classification that the `condition` is then the value of the gradient and so the boundary point is some function of the `condition`.; > ; > This differs from `Open` as the `condition` doesn't directly specify the boundary value but instead is some function of it. I guess it would be more traditional to call this `Radiating` but I don't think that really explains what is going on.; > ; > It would be _possible_ to write a condition that did this, but I think it would make user specification of exterior values more complicated. I don't really see why it makes user specification more complicated. The discussion is purely about how the user API communicates and organizes information. I would argue that it's logical or clear to ""classify"" a radiating boundary condition as an ""open boundary condition"", because radiating boundary conditions imply that there is a non-trivial external state outside the prognostic domain. This differs from `Value` or `Gradient` which communicate the notion of either a solid wall or fixed external state. The alternative propose is to get rid of `Open` entirely, which we could do. That would be a ""flatter"" design. I think that a possible user workflow might involve 1) deciding what boundary conditions are ""Open"" versus not, and _then_ 2) deciding how to treat the open boundary numerically / physically. For example we might write ""we specify an open boundary with X method"". To me that implies including the word ""Open"" in the user API is important.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1979898600
Usability,simpl,simply,"The `Open` classification was designed for boundaries that have a prescribed external state. If the current English description of `Open` does not adequately express this idea then we should simply change the description. I don't think a docstring written long ago motivates code design. We have to design this whole thing from the ground up. It sounds like any `Open` boundary requires two pieces of information:. 1. The external state that is prescribed.; 2. A (numerical) method for coping with the fact that the internal state inevitably deviates from the external state. One choice is simply to do nothing (use the prescribed external state), but this may have issues. There seem to be a diversity of other options, as well.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1981228442
Usability,simpl,simply,"> ; > It sounds like any `Open` boundary requires two pieces of information:; > ; > 1. The external state that is prescribed.; > ; > 2. A (numerical) method for coping with the fact that the internal state inevitably deviates from the external state. One choice is simply to do nothing (use the prescribed external state), but this may have issues. There seem to be a diversity of other options, as well. I suppose so except that sometimes (e.g. in the channels above) there is no known external state. Maybe we can make `Open` have properties something like `outflow` and `inflow` since there are different combinations of methods for both. Then the defaults (e.g. setting them to `nothing`) are the current behaviour but then we can add methods for 2.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1981543399
Availability,avail,available,"> Yeah yeah, that makes sense now.; > ; > I think storing them together would be a lot harder when the infrastructure for arbitrary external states is already set up for conditions, so I'm not sure it's worth the tradeoff. It's kind of the same principle as gradient boundary conditions where the `condition` is some external information, and then `Gradient` specifies what is done with it to set the boundary point. But yeah I would be interested in what @simone-silvestri has to say. I really fail to understand how either decision makes things harder. From my point of view it's simply about how the code reads. Whenever we use a boundary condition, we have all the information available to us. Can you please explain why you think that this decision would affect what we are able to achieve?. Consider that this is the only difference between the two options:. ```julia; # option 1; bc.classification.matching_scheme. # option 2; bc.condition.matching_scheme; ```. How is it possible for this to affect how we achieve anything? We never have the `condition` separate from the `classification`. We always have them together.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1986572918
Usability,simpl,simply,"> Yeah yeah, that makes sense now.; > ; > I think storing them together would be a lot harder when the infrastructure for arbitrary external states is already set up for conditions, so I'm not sure it's worth the tradeoff. It's kind of the same principle as gradient boundary conditions where the `condition` is some external information, and then `Gradient` specifies what is done with it to set the boundary point. But yeah I would be interested in what @simone-silvestri has to say. I really fail to understand how either decision makes things harder. From my point of view it's simply about how the code reads. Whenever we use a boundary condition, we have all the information available to us. Can you please explain why you think that this decision would affect what we are able to achieve?. Consider that this is the only difference between the two options:. ```julia; # option 1; bc.classification.matching_scheme. # option 2; bc.condition.matching_scheme; ```. How is it possible for this to affect how we achieve anything? We never have the `condition` separate from the `classification`. We always have them together.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1986572918
Modifiability,rewrite,rewrite,"> then we'd have to rewrite loads of stuff to make it so the user can specify whatever they want for the external state. I think see your point (I'm not sure I grasp the totality of it). Is your point that we are able to _re-use_ more existing code if we allow `ContinuousBoundaryFunction` and `DiscreteBoundaryFunction` as `condition`? I didn't understand this previously so thank you for clarifying. To re-use that code with a new `condition`, we can use a nesting technique:. ```julia; function getbc(open_bc::OpenBoundaryCondition, ...); state_value = getbc(open_bc.condition.external_state, ...); # other stuff related to matching; end; ```. This means that we don't have to rewrite anything, we just add new functionality for open boundary conditions on top. You could make the point that we have less _new_ code to write though, if we implement a design that allows conditions to be the same. And for users, this could be clearer, so I see the advantage of that. On the flip side, the advantage of making a new `OpenCondition` is that `getbc` retains its meaning as ""the function that returns the boundary condition value"". When we have an external state + matching scheme, the boundary condition values are not exactly the external state and are modified by the matching scheme. So I see pros and cons to both, but the good news is that we can actually talk coherently about the pros and cons. And if there are other pros and cons please mention them.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1988781194
Performance,load,loads,"> then we'd have to rewrite loads of stuff to make it so the user can specify whatever they want for the external state. I think see your point (I'm not sure I grasp the totality of it). Is your point that we are able to _re-use_ more existing code if we allow `ContinuousBoundaryFunction` and `DiscreteBoundaryFunction` as `condition`? I didn't understand this previously so thank you for clarifying. To re-use that code with a new `condition`, we can use a nesting technique:. ```julia; function getbc(open_bc::OpenBoundaryCondition, ...); state_value = getbc(open_bc.condition.external_state, ...); # other stuff related to matching; end; ```. This means that we don't have to rewrite anything, we just add new functionality for open boundary conditions on top. You could make the point that we have less _new_ code to write though, if we implement a design that allows conditions to be the same. And for users, this could be clearer, so I see the advantage of that. On the flip side, the advantage of making a new `OpenCondition` is that `getbc` retains its meaning as ""the function that returns the boundary condition value"". When we have an external state + matching scheme, the boundary condition values are not exactly the external state and are modified by the matching scheme. So I see pros and cons to both, but the good news is that we can actually talk coherently about the pros and cons. And if there are other pros and cons please mention them.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1988781194
Usability,clear,clearer,"> then we'd have to rewrite loads of stuff to make it so the user can specify whatever they want for the external state. I think see your point (I'm not sure I grasp the totality of it). Is your point that we are able to _re-use_ more existing code if we allow `ContinuousBoundaryFunction` and `DiscreteBoundaryFunction` as `condition`? I didn't understand this previously so thank you for clarifying. To re-use that code with a new `condition`, we can use a nesting technique:. ```julia; function getbc(open_bc::OpenBoundaryCondition, ...); state_value = getbc(open_bc.condition.external_state, ...); # other stuff related to matching; end; ```. This means that we don't have to rewrite anything, we just add new functionality for open boundary conditions on top. You could make the point that we have less _new_ code to write though, if we implement a design that allows conditions to be the same. And for users, this could be clearer, so I see the advantage of that. On the flip side, the advantage of making a new `OpenCondition` is that `getbc` retains its meaning as ""the function that returns the boundary condition value"". When we have an external state + matching scheme, the boundary condition values are not exactly the external state and are modified by the matching scheme. So I see pros and cons to both, but the good news is that we can actually talk coherently about the pros and cons. And if there are other pros and cons please mention them.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1988781194
Modifiability,rewrite,rewrite,"> I think see your point (I'm not sure I grasp the totality of it). Is your point that we are able to _re-use_ more existing code if we allow `ContinuousBoundaryFunction` and `DiscreteBoundaryFunction` as `condition`? I didn't understand this previously so thank you for clarifying. Sorry I wasn't clearer before. > To re-use that code with a new `condition`, we can use a nesting technique:; > ; > ```julia; > function getbc(open_bc::OpenBoundaryCondition, ...); > state_value = getbc(open_bc.condition.external_state, ...); > # other stuff related to matching; > end; > ```; > ; > This means that we don't have to rewrite anything, we just add new functionality for open boundary conditions on top. I can see how this could work. As it currently is `getbc` expects a full `BoundaryCondition` so we would need to-do some rewriting of that to unpack like `getbc(bc::BoundaryCondition, ...) = getbc(bc.condition, ...)` and then modify all of the existing `getbc` methods. > On the flip side, the advantage of making a new `OpenCondition` is that `getbc` retains its meaning as ""the function that returns the boundary condition value"". When we have an external state + matching scheme, the boundary condition values are not exactly the external state and are modified by the matching scheme. I see your point. For e.g. gradient boundary conditions it feels like the ""boundary condition value"" being the gradient at the boundary has about as much meaning as the boundary condition value for an open boundary condition being the external state and then we do some matching to get the internal solution to approximate it. But its quite unclear since an open boundary isn't mathematically defined like the other conditions so I think whatever we settle on is really equally as valid. . `getbc` is also not part of the API right? So if in the new code we say `external_value = getbc(...)` it should be clear enough to a future developer how it's being used and we shouldn't need to worry that a user would be",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1991781582
Usability,clear,clearer,"> I think see your point (I'm not sure I grasp the totality of it). Is your point that we are able to _re-use_ more existing code if we allow `ContinuousBoundaryFunction` and `DiscreteBoundaryFunction` as `condition`? I didn't understand this previously so thank you for clarifying. Sorry I wasn't clearer before. > To re-use that code with a new `condition`, we can use a nesting technique:; > ; > ```julia; > function getbc(open_bc::OpenBoundaryCondition, ...); > state_value = getbc(open_bc.condition.external_state, ...); > # other stuff related to matching; > end; > ```; > ; > This means that we don't have to rewrite anything, we just add new functionality for open boundary conditions on top. I can see how this could work. As it currently is `getbc` expects a full `BoundaryCondition` so we would need to-do some rewriting of that to unpack like `getbc(bc::BoundaryCondition, ...) = getbc(bc.condition, ...)` and then modify all of the existing `getbc` methods. > On the flip side, the advantage of making a new `OpenCondition` is that `getbc` retains its meaning as ""the function that returns the boundary condition value"". When we have an external state + matching scheme, the boundary condition values are not exactly the external state and are modified by the matching scheme. I see your point. For e.g. gradient boundary conditions it feels like the ""boundary condition value"" being the gradient at the boundary has about as much meaning as the boundary condition value for an open boundary condition being the external state and then we do some matching to get the internal solution to approximate it. But its quite unclear since an open boundary isn't mathematically defined like the other conditions so I think whatever we settle on is really equally as valid. . `getbc` is also not part of the API right? So if in the new code we say `external_value = getbc(...)` it should be clear enough to a future developer how it's being used and we shouldn't need to worry that a user would be",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1991781582
Performance,perform,performed,"ed to-do some rewriting of that to unpack like `getbc(bc::BoundaryCondition, ...) = getbc(bc.condition, ...)` and then modify all of the existing `getbc` methods. We can also either i) materialize whatever the user provides into a full boundary condition or ii) build `BoundaryCondition` on the fly inside the kernel (it would get compiled away probably anyways). We don't need to modify the existing `getbc` methods. > For e.g. gradient boundary conditions it feels like the ""boundary condition value"" being the gradient at the boundary has about as much meaning as the boundary condition value for an open boundary condition being the external state and then we do some matching to get the internal solution to approximate it. I agree, I think it's acceptable if the `condition` corresponds to the prescribed external state only, and the halo regions are determined by a calculation that additionally involves a scheme + the internal state. The main difference is where the matching calculation is performed --- either in `getbc`, or in `fill_halo_regions`. I don't think either choice is ""harder"" than the other. The difference and points to consider regard code clarity. That said, I see the advantages of generalizing `Open` rather than adding a new classification. Where does that put us? It looks like this PR has more code than we need (19 files changed?), if all we need to do is generalize `Open`. To generalize `Open`, we should only need to change a few files. Should we close this PR and start over? . I'd suggest starting from the very simple place of showing that one can provide a non-trivial external state, with no ""matching scheme"" (or whatever we want to call it), using a sponge layer. I think having that example will be very useful for demonstrating the advantage of different schemes. We may want two examples --- perhaps one constant inflow / constant outflow, and another example with a time-varying inflow/outflow. For the second example, a nice case might be to use an anal",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1992386703
Usability,simpl,simple,"ondition, ...) = getbc(bc.condition, ...)` and then modify all of the existing `getbc` methods. We can also either i) materialize whatever the user provides into a full boundary condition or ii) build `BoundaryCondition` on the fly inside the kernel (it would get compiled away probably anyways). We don't need to modify the existing `getbc` methods. > For e.g. gradient boundary conditions it feels like the ""boundary condition value"" being the gradient at the boundary has about as much meaning as the boundary condition value for an open boundary condition being the external state and then we do some matching to get the internal solution to approximate it. I agree, I think it's acceptable if the `condition` corresponds to the prescribed external state only, and the halo regions are determined by a calculation that additionally involves a scheme + the internal state. The main difference is where the matching calculation is performed --- either in `getbc`, or in `fill_halo_regions`. I don't think either choice is ""harder"" than the other. The difference and points to consider regard code clarity. That said, I see the advantages of generalizing `Open` rather than adding a new classification. Where does that put us? It looks like this PR has more code than we need (19 files changed?), if all we need to do is generalize `Open`. To generalize `Open`, we should only need to change a few files. Should we close this PR and start over? . I'd suggest starting from the very simple place of showing that one can provide a non-trivial external state, with no ""matching scheme"" (or whatever we want to call it), using a sponge layer. I think having that example will be very useful for demonstrating the advantage of different schemes. We may want two examples --- perhaps one constant inflow / constant outflow, and another example with a time-varying inflow/outflow. For the second example, a nice case might be to use an analytical solution like a mode-1 internal wave as the external state.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1992386703
Usability,simpl,simple,"> Where does that put us? It looks like this PR has more code than we need (19 files changed?), if all we need to do is generalize `Open`. To generalize `Open`, we should only need to change a few files. Should we close this PR and start over?. Yeah I think it would be easiest to start from a clean PR. Most of the code changes were to get the timestep in but adding it to the clock like you've suggested does seem like the most straightforward way too it. Are you happy for both of these to be one PR?. > I'd suggest starting from the very simple place of showing that one can provide a non-trivial external state, with no ""matching scheme"" (or whatever we want to call it), using a sponge layer. I think having that example will be very useful for demonstrating the advantage of different schemes. We may want two examples --- perhaps one constant inflow / constant outflow, and another example with a time-varying inflow/outflow. For the second example, a nice case might be to use an analytical solution like a mode-1 internal wave as the external state. This sounds sensible. . To keep the conversation linked I'll reset this branch to main and then add the changes again.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1994671401
Usability,simpl,simple,"It could make sense to have a separate PR for the change to `Clock` since it's pretty simple. Should it be called ""previous"" dt in the Clock perhaps? (Not sure ""previous_"" is the best name either, it could also be ""last_dt"" or something)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1994999546
Availability,error,error,"I've got the mode-1 internal wave case working now. Axes are in units of depth (h) and k is set to $\pi$/h, top panel is `u`, middle is `w`, and bottom is `b`. First the periodic case:. https://github.com/CliMA/Oceananigans.jl/assets/26657828/324a7a29-097e-4732-b324-afce808b752e. As expected numerical error reflects off the boundary if we just prescribe the boundary values:. https://github.com/CliMA/Oceananigans.jl/assets/26657828/738bd33f-b813-45f7-b96a-74a25dd631cb. And with quite a small sponge (red lines in top plot) this is pretty much resolved:. https://github.com/CliMA/Oceananigans.jl/assets/26657828/d1af93fb-8efc-47a3-abdc-463224e366db. Note/update:. Following discussion with @johnryantaylor we noticed that it seems the energy increases in all three of these (the velocity clips the colormap which is set to the analytical amplitudes) before it decays. I've checked and this is timestep length dependant and goes away with a small timestep. I guess this is a shortfall of the CFL analysis when there are fast waves. We also noticed that there is an error growing from the top and bottom boundaries, particularly clearly in the buoyancy. We think this is a spatial resolution dependant numerical error which is suppressed by increased vertical resolution.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2004485794
Deployability,update,update,"I've got the mode-1 internal wave case working now. Axes are in units of depth (h) and k is set to $\pi$/h, top panel is `u`, middle is `w`, and bottom is `b`. First the periodic case:. https://github.com/CliMA/Oceananigans.jl/assets/26657828/324a7a29-097e-4732-b324-afce808b752e. As expected numerical error reflects off the boundary if we just prescribe the boundary values:. https://github.com/CliMA/Oceananigans.jl/assets/26657828/738bd33f-b813-45f7-b96a-74a25dd631cb. And with quite a small sponge (red lines in top plot) this is pretty much resolved:. https://github.com/CliMA/Oceananigans.jl/assets/26657828/d1af93fb-8efc-47a3-abdc-463224e366db. Note/update:. Following discussion with @johnryantaylor we noticed that it seems the energy increases in all three of these (the velocity clips the colormap which is set to the analytical amplitudes) before it decays. I've checked and this is timestep length dependant and goes away with a small timestep. I guess this is a shortfall of the CFL analysis when there are fast waves. We also noticed that there is an error growing from the top and bottom boundaries, particularly clearly in the buoyancy. We think this is a spatial resolution dependant numerical error which is suppressed by increased vertical resolution.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2004485794
Energy Efficiency,energy,energy,"I've got the mode-1 internal wave case working now. Axes are in units of depth (h) and k is set to $\pi$/h, top panel is `u`, middle is `w`, and bottom is `b`. First the periodic case:. https://github.com/CliMA/Oceananigans.jl/assets/26657828/324a7a29-097e-4732-b324-afce808b752e. As expected numerical error reflects off the boundary if we just prescribe the boundary values:. https://github.com/CliMA/Oceananigans.jl/assets/26657828/738bd33f-b813-45f7-b96a-74a25dd631cb. And with quite a small sponge (red lines in top plot) this is pretty much resolved:. https://github.com/CliMA/Oceananigans.jl/assets/26657828/d1af93fb-8efc-47a3-abdc-463224e366db. Note/update:. Following discussion with @johnryantaylor we noticed that it seems the energy increases in all three of these (the velocity clips the colormap which is set to the analytical amplitudes) before it decays. I've checked and this is timestep length dependant and goes away with a small timestep. I guess this is a shortfall of the CFL analysis when there are fast waves. We also noticed that there is an error growing from the top and bottom boundaries, particularly clearly in the buoyancy. We think this is a spatial resolution dependant numerical error which is suppressed by increased vertical resolution.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2004485794
Integrability,depend,dependant,"I've got the mode-1 internal wave case working now. Axes are in units of depth (h) and k is set to $\pi$/h, top panel is `u`, middle is `w`, and bottom is `b`. First the periodic case:. https://github.com/CliMA/Oceananigans.jl/assets/26657828/324a7a29-097e-4732-b324-afce808b752e. As expected numerical error reflects off the boundary if we just prescribe the boundary values:. https://github.com/CliMA/Oceananigans.jl/assets/26657828/738bd33f-b813-45f7-b96a-74a25dd631cb. And with quite a small sponge (red lines in top plot) this is pretty much resolved:. https://github.com/CliMA/Oceananigans.jl/assets/26657828/d1af93fb-8efc-47a3-abdc-463224e366db. Note/update:. Following discussion with @johnryantaylor we noticed that it seems the energy increases in all three of these (the velocity clips the colormap which is set to the analytical amplitudes) before it decays. I've checked and this is timestep length dependant and goes away with a small timestep. I guess this is a shortfall of the CFL analysis when there are fast waves. We also noticed that there is an error growing from the top and bottom boundaries, particularly clearly in the buoyancy. We think this is a spatial resolution dependant numerical error which is suppressed by increased vertical resolution.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2004485794
Usability,clear,clearly,"I've got the mode-1 internal wave case working now. Axes are in units of depth (h) and k is set to $\pi$/h, top panel is `u`, middle is `w`, and bottom is `b`. First the periodic case:. https://github.com/CliMA/Oceananigans.jl/assets/26657828/324a7a29-097e-4732-b324-afce808b752e. As expected numerical error reflects off the boundary if we just prescribe the boundary values:. https://github.com/CliMA/Oceananigans.jl/assets/26657828/738bd33f-b813-45f7-b96a-74a25dd631cb. And with quite a small sponge (red lines in top plot) this is pretty much resolved:. https://github.com/CliMA/Oceananigans.jl/assets/26657828/d1af93fb-8efc-47a3-abdc-463224e366db. Note/update:. Following discussion with @johnryantaylor we noticed that it seems the energy increases in all three of these (the velocity clips the colormap which is set to the analytical amplitudes) before it decays. I've checked and this is timestep length dependant and goes away with a small timestep. I guess this is a shortfall of the CFL analysis when there are fast waves. We also noticed that there is an error growing from the top and bottom boundaries, particularly clearly in the buoyancy. We think this is a spatial resolution dependant numerical error which is suppressed by increased vertical resolution.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2004485794
Usability,simpl,simple,Yeah we don't use it here. I could add a simple choice e.g. boundary `value = (external state-internal state)/relaxing` time as an example?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2020691320
Security,validat,validation,"> Yeah we don't use it here. I could add a simple choice e.g. boundary `value = (external state-internal state)/relaxing` time as an example?. Right. The validation is interesting. It shows that the code currently supports open boundaries. Presumably, the algorithms / matching schemes you have looked into serve some purpose. What is that purpose? Do they make the size of the sponge layer smaller?. Now that you have a basic example that illustrates an open boundary condition implementation with no matching scheme, you are in a position to implement a non-trivial matching scheme, and demonstrate its benefit. If the matching scheme has some benefit, then we are motivated to support it by adding source code and tests...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2021435396
Testability,test,tests,"> Yeah we don't use it here. I could add a simple choice e.g. boundary `value = (external state-internal state)/relaxing` time as an example?. Right. The validation is interesting. It shows that the code currently supports open boundaries. Presumably, the algorithms / matching schemes you have looked into serve some purpose. What is that purpose? Do they make the size of the sponge layer smaller?. Now that you have a basic example that illustrates an open boundary condition implementation with no matching scheme, you are in a position to implement a non-trivial matching scheme, and demonstrate its benefit. If the matching scheme has some benefit, then we are motivated to support it by adding source code and tests...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2021435396
Usability,simpl,simple,"> Yeah we don't use it here. I could add a simple choice e.g. boundary `value = (external state-internal state)/relaxing` time as an example?. Right. The validation is interesting. It shows that the code currently supports open boundaries. Presumably, the algorithms / matching schemes you have looked into serve some purpose. What is that purpose? Do they make the size of the sponge layer smaller?. Now that you have a basic example that illustrates an open boundary condition implementation with no matching scheme, you are in a position to implement a non-trivial matching scheme, and demonstrate its benefit. If the matching scheme has some benefit, then we are motivated to support it by adding source code and tests...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2021435396
Availability,error,error,"> And with quite a small sponge (red lines in top plot) this is pretty much resolved:; > ; > internal_wave_sponge.mp4 ; > Note/update:; > ; > Following discussion with @johnryantaylor we noticed that it seems the energy increases in all three of these (the velocity clips the colormap which is set to the analytical amplitudes) before it decays. I've checked and this is timestep length dependant and goes away with a small timestep. I guess this is a shortfall of the CFL analysis when there are fast waves. We also noticed that there is an error growing from the top and bottom boundaries, particularly clearly in the buoyancy. We think this is a spatial resolution dependant numerical error which is suppressed by increased vertical resolution. @jagoosw sorry to be dropping into this discussion a bit late, but I don't quite understand why the sponge is needed at the inflow in the example above. Shouldn't the prescribed inflow BC be enough?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2025531336
Deployability,update,update,"> And with quite a small sponge (red lines in top plot) this is pretty much resolved:; > ; > internal_wave_sponge.mp4 ; > Note/update:; > ; > Following discussion with @johnryantaylor we noticed that it seems the energy increases in all three of these (the velocity clips the colormap which is set to the analytical amplitudes) before it decays. I've checked and this is timestep length dependant and goes away with a small timestep. I guess this is a shortfall of the CFL analysis when there are fast waves. We also noticed that there is an error growing from the top and bottom boundaries, particularly clearly in the buoyancy. We think this is a spatial resolution dependant numerical error which is suppressed by increased vertical resolution. @jagoosw sorry to be dropping into this discussion a bit late, but I don't quite understand why the sponge is needed at the inflow in the example above. Shouldn't the prescribed inflow BC be enough?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2025531336
Energy Efficiency,energy,energy,"> And with quite a small sponge (red lines in top plot) this is pretty much resolved:; > ; > internal_wave_sponge.mp4 ; > Note/update:; > ; > Following discussion with @johnryantaylor we noticed that it seems the energy increases in all three of these (the velocity clips the colormap which is set to the analytical amplitudes) before it decays. I've checked and this is timestep length dependant and goes away with a small timestep. I guess this is a shortfall of the CFL analysis when there are fast waves. We also noticed that there is an error growing from the top and bottom boundaries, particularly clearly in the buoyancy. We think this is a spatial resolution dependant numerical error which is suppressed by increased vertical resolution. @jagoosw sorry to be dropping into this discussion a bit late, but I don't quite understand why the sponge is needed at the inflow in the example above. Shouldn't the prescribed inflow BC be enough?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2025531336
Integrability,depend,dependant,"> And with quite a small sponge (red lines in top plot) this is pretty much resolved:; > ; > internal_wave_sponge.mp4 ; > Note/update:; > ; > Following discussion with @johnryantaylor we noticed that it seems the energy increases in all three of these (the velocity clips the colormap which is set to the analytical amplitudes) before it decays. I've checked and this is timestep length dependant and goes away with a small timestep. I guess this is a shortfall of the CFL analysis when there are fast waves. We also noticed that there is an error growing from the top and bottom boundaries, particularly clearly in the buoyancy. We think this is a spatial resolution dependant numerical error which is suppressed by increased vertical resolution. @jagoosw sorry to be dropping into this discussion a bit late, but I don't quite understand why the sponge is needed at the inflow in the example above. Shouldn't the prescribed inflow BC be enough?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2025531336
Usability,clear,clearly,"> And with quite a small sponge (red lines in top plot) this is pretty much resolved:; > ; > internal_wave_sponge.mp4 ; > Note/update:; > ; > Following discussion with @johnryantaylor we noticed that it seems the energy increases in all three of these (the velocity clips the colormap which is set to the analytical amplitudes) before it decays. I've checked and this is timestep length dependant and goes away with a small timestep. I guess this is a shortfall of the CFL analysis when there are fast waves. We also noticed that there is an error growing from the top and bottom boundaries, particularly clearly in the buoyancy. We think this is a spatial resolution dependant numerical error which is suppressed by increased vertical resolution. @jagoosw sorry to be dropping into this discussion a bit late, but I don't quite understand why the sponge is needed at the inflow in the example above. Shouldn't the prescribed inflow BC be enough?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2025531336
Testability,test,test,"I've been thinking about open boundaries more and have some things I want to test, but they're more questions about the numerics and I don't think this is the place for it. . From the last examples I sent + other experiments I've done with it I think matching schemes are justified because even in the nested case we don't want the boundary value to modify the outflow to modify the internal solution as in the cylinder example. For example, in a nested case, this would prevent higher resolution eddies from exiting the domain without un-physically modifying the upstream solution. To resolve this PR I could tidy up a simple matching scheme where we compute the mean outflow on the boundary and do a 1D advection for the boundary point, or relax to the external state if there is inflow. I think this shows how to use all parts of the new infrastructure, and is a satisfactory boundary condition for some cases. Would this be okay?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2032715863
Usability,simpl,simple,"I've been thinking about open boundaries more and have some things I want to test, but they're more questions about the numerics and I don't think this is the place for it. . From the last examples I sent + other experiments I've done with it I think matching schemes are justified because even in the nested case we don't want the boundary value to modify the outflow to modify the internal solution as in the cylinder example. For example, in a nested case, this would prevent higher resolution eddies from exiting the domain without un-physically modifying the upstream solution. To resolve this PR I could tidy up a simple matching scheme where we compute the mean outflow on the boundary and do a 1D advection for the boundary point, or relax to the external state if there is inflow. I think this shows how to use all parts of the new infrastructure, and is a satisfactory boundary condition for some cases. Would this be okay?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2032715863
Energy Efficiency,reduce,reduce," great place to start to justify changing the `Open` classification. > For example, in a nested case, this would prevent higher resolution eddies from exiting the domain without un-physically modifying the upstream solution. I apologize if this is just a problem with communication style, but I don't think this statement can possibly be correct. The above example seems to demonstrate, for example, that the cylinder wake can be represented well by _either_ making the domain large enough (with sponge layers), _or_ by using a better numerical method with a smaller domain. Basically this allows us to exclude statements like ""we can't model X flow"". The question is not whether or not we can represent the physics of a flow. The question is rather about representing the flow in a domain that is as small as possible / with optimal computational expense. We're pursuing performance optimization. Our language has to take the form ""this scheme allows us to reduce the sponge layer thickness by XX%"", or ""this scheme reduces the width of the near-boundary region where the interior physics are modified"". The statement ""this scheme does not unphysically modify the solution"" makes no sense to me. The presence of the open boundary is unphysical by definition... I personally don't need much convincing that a matching scheme of some kind is needed. I'm just confused about how all of the different pieces that seem to enter into nesting interact with one another --- sponge layers, matching scheme, and also the particular physics of the flow in question (idealized in and outflows vs true nesting). With so many degrees of freedom and complexity I think a systematic approach is absolutely essential. I really hope that the outcome of this work are a set of solid recommendations for nesting (better yet, a recipe that does not have to be changed --- a recommended matching scheme, or a combination of matching scheme and sponge layer) which is supported by unequivocal and rationally presented evide",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2033120291
Modifiability,layers,layers,"ution using Oceananigans, and then illustrate embedding a high resolution domain inside that solution. A two-dimensional turbulent case would be sufficient. > To resolve this PR I could tidy up a simple matching scheme where we compute the mean outflow on the boundary and do a 1D advection for the boundary point, or relax to the external state if there is inflow. I think this shows how to use all parts of the new infrastructure, and is a satisfactory boundary condition for some cases. Would this be okay?. A simple matching scheme is a great place to start to justify changing the `Open` classification. > For example, in a nested case, this would prevent higher resolution eddies from exiting the domain without un-physically modifying the upstream solution. I apologize if this is just a problem with communication style, but I don't think this statement can possibly be correct. The above example seems to demonstrate, for example, that the cylinder wake can be represented well by _either_ making the domain large enough (with sponge layers), _or_ by using a better numerical method with a smaller domain. Basically this allows us to exclude statements like ""we can't model X flow"". The question is not whether or not we can represent the physics of a flow. The question is rather about representing the flow in a domain that is as small as possible / with optimal computational expense. We're pursuing performance optimization. Our language has to take the form ""this scheme allows us to reduce the sponge layer thickness by XX%"", or ""this scheme reduces the width of the near-boundary region where the interior physics are modified"". The statement ""this scheme does not unphysically modify the solution"" makes no sense to me. The presence of the open boundary is unphysical by definition... I personally don't need much convincing that a matching scheme of some kind is needed. I'm just confused about how all of the different pieces that seem to enter into nesting interact with one anoth",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2033120291
Performance,perform,performance," infrastructure, and is a satisfactory boundary condition for some cases. Would this be okay?. A simple matching scheme is a great place to start to justify changing the `Open` classification. > For example, in a nested case, this would prevent higher resolution eddies from exiting the domain without un-physically modifying the upstream solution. I apologize if this is just a problem with communication style, but I don't think this statement can possibly be correct. The above example seems to demonstrate, for example, that the cylinder wake can be represented well by _either_ making the domain large enough (with sponge layers), _or_ by using a better numerical method with a smaller domain. Basically this allows us to exclude statements like ""we can't model X flow"". The question is not whether or not we can represent the physics of a flow. The question is rather about representing the flow in a domain that is as small as possible / with optimal computational expense. We're pursuing performance optimization. Our language has to take the form ""this scheme allows us to reduce the sponge layer thickness by XX%"", or ""this scheme reduces the width of the near-boundary region where the interior physics are modified"". The statement ""this scheme does not unphysically modify the solution"" makes no sense to me. The presence of the open boundary is unphysical by definition... I personally don't need much convincing that a matching scheme of some kind is needed. I'm just confused about how all of the different pieces that seem to enter into nesting interact with one another --- sponge layers, matching scheme, and also the particular physics of the flow in question (idealized in and outflows vs true nesting). With so many degrees of freedom and complexity I think a systematic approach is absolutely essential. I really hope that the outcome of this work are a set of solid recommendations for nesting (better yet, a recipe that does not have to be changed --- a recommended matching sc",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2033120291
Usability,simpl,simple,"> I also think that we should consider also another example problem like a flow around a cylinder. Please consider as many different cases as possible or as you need. I think a real nesting case would be even better --- for example, generate a turbulent solution using Oceananigans, and then illustrate embedding a high resolution domain inside that solution. A two-dimensional turbulent case would be sufficient. > To resolve this PR I could tidy up a simple matching scheme where we compute the mean outflow on the boundary and do a 1D advection for the boundary point, or relax to the external state if there is inflow. I think this shows how to use all parts of the new infrastructure, and is a satisfactory boundary condition for some cases. Would this be okay?. A simple matching scheme is a great place to start to justify changing the `Open` classification. > For example, in a nested case, this would prevent higher resolution eddies from exiting the domain without un-physically modifying the upstream solution. I apologize if this is just a problem with communication style, but I don't think this statement can possibly be correct. The above example seems to demonstrate, for example, that the cylinder wake can be represented well by _either_ making the domain large enough (with sponge layers), _or_ by using a better numerical method with a smaller domain. Basically this allows us to exclude statements like ""we can't model X flow"". The question is not whether or not we can represent the physics of a flow. The question is rather about representing the flow in a domain that is as small as possible / with optimal computational expense. We're pursuing performance optimization. Our language has to take the form ""this scheme allows us to reduce the sponge layer thickness by XX%"", or ""this scheme reduces the width of the near-boundary region where the interior physics are modified"". The statement ""this scheme does not unphysically modify the solution"" makes no sense to me. The pre",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2033120291
Modifiability,layers,layers,"> I apologize if this is just a problem with communication style, but I don't think this statement can possibly be correct. The above example seems to demonstrate, for example, that the cylinder wake can be represented well by _either_ making the domain large enough (with sponge layers), _or_ by using a better numerical method with a smaller domain.; > . Yeah sorry, that was very imprecise of me. I more mean that that case was a good demonstration of a situation where we need a very large domain to not effect the interior solution in the area we are interested in, or have a matching scheme. > I really hope that the outcome of this work are a set of solid recommendations for nesting (better yet, a recipe that does not have to be changed --- a recommended matching scheme, or a combination of matching scheme and sponge layer) which is supported by unequivocal and rationally presented evidence. That sounds good in the long term. Do you want that all for this PR or can we merge this part after I've implemented a simple matching scheme as a demonstration and then work on the rest elsewhere?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2037435373
Usability,simpl,simple,"> I apologize if this is just a problem with communication style, but I don't think this statement can possibly be correct. The above example seems to demonstrate, for example, that the cylinder wake can be represented well by _either_ making the domain large enough (with sponge layers), _or_ by using a better numerical method with a smaller domain.; > . Yeah sorry, that was very imprecise of me. I more mean that that case was a good demonstration of a situation where we need a very large domain to not effect the interior solution in the area we are interested in, or have a matching scheme. > I really hope that the outcome of this work are a set of solid recommendations for nesting (better yet, a recipe that does not have to be changed --- a recommended matching scheme, or a combination of matching scheme and sponge layer) which is supported by unequivocal and rationally presented evidence. That sounds good in the long term. Do you want that all for this PR or can we merge this part after I've implemented a simple matching scheme as a demonstration and then work on the rest elsewhere?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2037435373
Safety,risk,risk,"> Do you want that all for this PR or can we merge this part after I've implemented a simple matching scheme as a demonstration and then work on the rest elsewhere?. That's up to you. Smaller PRs can be easier because you will have less risk of merge conflicts. However you should make sure that the code in any individual PR is motivated and tested (ie if you implement a new type then it'd be best to have a use case for it, plus a test).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2038114155
Testability,test,tested,"> Do you want that all for this PR or can we merge this part after I've implemented a simple matching scheme as a demonstration and then work on the rest elsewhere?. That's up to you. Smaller PRs can be easier because you will have less risk of merge conflicts. However you should make sure that the code in any individual PR is motivated and tested (ie if you implement a new type then it'd be best to have a use case for it, plus a test).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2038114155
Usability,simpl,simple,"> Do you want that all for this PR or can we merge this part after I've implemented a simple matching scheme as a demonstration and then work on the rest elsewhere?. That's up to you. Smaller PRs can be easier because you will have less risk of merge conflicts. However you should make sure that the code in any individual PR is motivated and tested (ie if you implement a new type then it'd be best to have a use case for it, plus a test).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2038114155
Usability,simpl,simplified,"> Also, I can't find the docs previews, do they still get made so I can check the new bits? . I think we don't push the previews anymore (I think to save space?). You can ofc compile them locally. I just clicked ""view file"" on GitHub, which shows a simplified markdown preview.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2200789820
Deployability,update,update,"> But I do have one question: how are we supposed to treat open boundaries for quantities located at cell centers? I don't see any specific new code dealing with that. I see you used `GradientBoundaryCondition(0)` in your validation codes but, for example, for buoyancy that's not gonna cut it and will lead to reflections. The majority of the new code here deals with the fact that you can't update the boundary condition on wall normal velocities after the pressure correction step and maintain the interior domain to be physical and divergence-free, so we have a new function `_fill_X_open_halo!`, but there is nothing stopping you from also defining new methods for `_fill_west_halo!` which still acts before both the predictor and correct step and is what you would need to write for centre field OBCs. The reason I used `GradientBoundaryCondition(0)` in the validation case is that the literature suggests that it doesn't make much of a difference for the non-wall normal velocity component what boundary condition you use (e.g. https://doi.org/10.1002/fld.1650181006 ""(iii)&plat + Vacp/dn = 0, where V is ‘user-specified’, but cannot be zero, and should be positive if fluid is leaving the domain. (The average normal velocity through the boundary is a reasonable candidate.) This OBC may be gaining in popularity over acp/an = 0 for reasons which are not entirely clear to us.""), but I guess the reflection might be reduced by something else.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2263595729
Energy Efficiency,reduce,reduced,"> But I do have one question: how are we supposed to treat open boundaries for quantities located at cell centers? I don't see any specific new code dealing with that. I see you used `GradientBoundaryCondition(0)` in your validation codes but, for example, for buoyancy that's not gonna cut it and will lead to reflections. The majority of the new code here deals with the fact that you can't update the boundary condition on wall normal velocities after the pressure correction step and maintain the interior domain to be physical and divergence-free, so we have a new function `_fill_X_open_halo!`, but there is nothing stopping you from also defining new methods for `_fill_west_halo!` which still acts before both the predictor and correct step and is what you would need to write for centre field OBCs. The reason I used `GradientBoundaryCondition(0)` in the validation case is that the literature suggests that it doesn't make much of a difference for the non-wall normal velocity component what boundary condition you use (e.g. https://doi.org/10.1002/fld.1650181006 ""(iii)&plat + Vacp/dn = 0, where V is ‘user-specified’, but cannot be zero, and should be positive if fluid is leaving the domain. (The average normal velocity through the boundary is a reasonable candidate.) This OBC may be gaining in popularity over acp/an = 0 for reasons which are not entirely clear to us.""), but I guess the reflection might be reduced by something else.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2263595729
Safety,predict,predictor,"> But I do have one question: how are we supposed to treat open boundaries for quantities located at cell centers? I don't see any specific new code dealing with that. I see you used `GradientBoundaryCondition(0)` in your validation codes but, for example, for buoyancy that's not gonna cut it and will lead to reflections. The majority of the new code here deals with the fact that you can't update the boundary condition on wall normal velocities after the pressure correction step and maintain the interior domain to be physical and divergence-free, so we have a new function `_fill_X_open_halo!`, but there is nothing stopping you from also defining new methods for `_fill_west_halo!` which still acts before both the predictor and correct step and is what you would need to write for centre field OBCs. The reason I used `GradientBoundaryCondition(0)` in the validation case is that the literature suggests that it doesn't make much of a difference for the non-wall normal velocity component what boundary condition you use (e.g. https://doi.org/10.1002/fld.1650181006 ""(iii)&plat + Vacp/dn = 0, where V is ‘user-specified’, but cannot be zero, and should be positive if fluid is leaving the domain. (The average normal velocity through the boundary is a reasonable candidate.) This OBC may be gaining in popularity over acp/an = 0 for reasons which are not entirely clear to us.""), but I guess the reflection might be reduced by something else.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2263595729
Security,validat,validation,"> But I do have one question: how are we supposed to treat open boundaries for quantities located at cell centers? I don't see any specific new code dealing with that. I see you used `GradientBoundaryCondition(0)` in your validation codes but, for example, for buoyancy that's not gonna cut it and will lead to reflections. The majority of the new code here deals with the fact that you can't update the boundary condition on wall normal velocities after the pressure correction step and maintain the interior domain to be physical and divergence-free, so we have a new function `_fill_X_open_halo!`, but there is nothing stopping you from also defining new methods for `_fill_west_halo!` which still acts before both the predictor and correct step and is what you would need to write for centre field OBCs. The reason I used `GradientBoundaryCondition(0)` in the validation case is that the literature suggests that it doesn't make much of a difference for the non-wall normal velocity component what boundary condition you use (e.g. https://doi.org/10.1002/fld.1650181006 ""(iii)&plat + Vacp/dn = 0, where V is ‘user-specified’, but cannot be zero, and should be positive if fluid is leaving the domain. (The average normal velocity through the boundary is a reasonable candidate.) This OBC may be gaining in popularity over acp/an = 0 for reasons which are not entirely clear to us.""), but I guess the reflection might be reduced by something else.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2263595729
Usability,clear,clear,"> But I do have one question: how are we supposed to treat open boundaries for quantities located at cell centers? I don't see any specific new code dealing with that. I see you used `GradientBoundaryCondition(0)` in your validation codes but, for example, for buoyancy that's not gonna cut it and will lead to reflections. The majority of the new code here deals with the fact that you can't update the boundary condition on wall normal velocities after the pressure correction step and maintain the interior domain to be physical and divergence-free, so we have a new function `_fill_X_open_halo!`, but there is nothing stopping you from also defining new methods for `_fill_west_halo!` which still acts before both the predictor and correct step and is what you would need to write for centre field OBCs. The reason I used `GradientBoundaryCondition(0)` in the validation case is that the literature suggests that it doesn't make much of a difference for the non-wall normal velocity component what boundary condition you use (e.g. https://doi.org/10.1002/fld.1650181006 ""(iii)&plat + Vacp/dn = 0, where V is ‘user-specified’, but cannot be zero, and should be positive if fluid is leaving the domain. (The average normal velocity through the boundary is a reasonable candidate.) This OBC may be gaining in popularity over acp/an = 0 for reasons which are not entirely clear to us.""), but I guess the reflection might be reduced by something else.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2263595729
Deployability,configurat,configuration,"I remember there is a problematic issue with initialisation and bathymetry. You need to be extra careful to put initial condition that is consistent with the bathymetry. We should actually fix that because it was so counterintuitive. That’s what I was trying to understand back in the day and fix but I lost steam. I couldn’t set up very simple things, let alone global configuration.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3486#issuecomment-1973413973
Modifiability,config,configuration,"I remember there is a problematic issue with initialisation and bathymetry. You need to be extra careful to put initial condition that is consistent with the bathymetry. We should actually fix that because it was so counterintuitive. That’s what I was trying to understand back in the day and fix but I lost steam. I couldn’t set up very simple things, let alone global configuration.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3486#issuecomment-1973413973
Usability,simpl,simple,"I remember there is a problematic issue with initialisation and bathymetry. You need to be extra careful to put initial condition that is consistent with the bathymetry. We should actually fix that because it was so counterintuitive. That’s what I was trying to understand back in the day and fix but I lost steam. I couldn’t set up very simple things, let alone global configuration.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3486#issuecomment-1973413973
Usability,simpl,simple,"Very good point @navidcy!. Instead of trying to do this first, it makes more sense to include simple topography. I'll start with the example and include the affect of shelflike topography, as Glenn and I did in this paper. It should be easy to set up and will teach us how to include topography in a much simpler setting. https://journals.ametsoc.org/view/journals/phoc/35/5/jpo2719.1.xml?tab_body=abstract-display",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3486#issuecomment-1973422544
Deployability,configurat,configuration,There must be a simple bug to fix. I remember the simulation was quite stable. I think it has to do with how bathymetry is defined in the code. A simple configuration might snoop out the issue,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3486#issuecomment-1973873627
Modifiability,config,configuration,There must be a simple bug to fix. I remember the simulation was quite stable. I think it has to do with how bathymetry is defined in the code. A simple configuration might snoop out the issue,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3486#issuecomment-1973873627
Usability,simpl,simple,There must be a simple bug to fix. I remember the simulation was quite stable. I think it has to do with how bathymetry is defined in the code. A simple configuration might snoop out the issue,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3486#issuecomment-1973873627
Modifiability,evolve,evolves,> > I have created a new validation script called `shallow_jet_topography.jl` that evolves the barotropically unstable jet (like in the shallow water example) but now over a shelflike topography. It can be found in `valiation/shallow_water`.; > ; > I don't see it; did you push?. Sorry! I have added it now. https://github.com/CliMA/Oceananigans.jl/blob/fp-ss/shallow-water-version2/validation/shallow_water_model/shallow_water_jet_topography.jl. One of my mitakes is that I didn't define the bathymetry. I need to figure out how to do that. Thanks for the very helpful feedback!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3486#issuecomment-1975142954
Security,validat,validation,> > I have created a new validation script called `shallow_jet_topography.jl` that evolves the barotropically unstable jet (like in the shallow water example) but now over a shelflike topography. It can be found in `valiation/shallow_water`.; > ; > I don't see it; did you push?. Sorry! I have added it now. https://github.com/CliMA/Oceananigans.jl/blob/fp-ss/shallow-water-version2/validation/shallow_water_model/shallow_water_jet_topography.jl. One of my mitakes is that I didn't define the bathymetry. I need to figure out how to do that. Thanks for the very helpful feedback!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3486#issuecomment-1975142954
Usability,feedback,feedback,> > I have created a new validation script called `shallow_jet_topography.jl` that evolves the barotropically unstable jet (like in the shallow water example) but now over a shelflike topography. It can be found in `valiation/shallow_water`.; > ; > I don't see it; did you push?. Sorry! I have added it now. https://github.com/CliMA/Oceananigans.jl/blob/fp-ss/shallow-water-version2/validation/shallow_water_model/shallow_water_jet_topography.jl. One of my mitakes is that I didn't define the bathymetry. I need to figure out how to do that. Thanks for the very helpful feedback!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3486#issuecomment-1975142954
Security,validat,validation,I am happy to say that the `VectorInvariant` formulation yields similar growth rates `0.144` and `0.123`. Given the numerical methods are different I'm not bothered by this difference. They should converge with increased resolution. Any more questions/concerns on this simple validation problem before I return to the global one?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3486#issuecomment-1976904533
Usability,simpl,simple,I am happy to say that the `VectorInvariant` formulation yields similar growth rates `0.144` and `0.123`. Given the numerical methods are different I'm not bothered by this difference. They should converge with increased resolution. Any more questions/concerns on this simple validation problem before I return to the global one?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3486#issuecomment-1976904533
Security,validat,validation,"Thanks everyone for the feedback. I did some debugging and I'm happy to say that bathymetry is now specified as we expected, no negative sign, and it gives results that are consistent with previous findings: prograde is more unstable and retrograde is more stable. . You can see the code [here](https://github.com/CliMA/Oceananigans.jl/blob/fp-ss/shallow-water-version2/validation/shallow_water_model/shallow_water_jet_topography.jl). . Any other thoughts on this before I move on to the global model?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3486#issuecomment-1978912794
Usability,feedback,feedback,"Thanks everyone for the feedback. I did some debugging and I'm happy to say that bathymetry is now specified as we expected, no negative sign, and it gives results that are consistent with previous findings: prograde is more unstable and retrograde is more stable. . You can see the code [here](https://github.com/CliMA/Oceananigans.jl/blob/fp-ss/shallow-water-version2/validation/shallow_water_model/shallow_water_jet_topography.jl). . Any other thoughts on this before I move on to the global model?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3486#issuecomment-1978912794
Usability,learn,learned,"Thanks @glwagner for merging main into this branch. I have returned to the global simulations and have learned something. Using all the same parameters as before, I get `NaNs` after just over an hour. Upon closer inspection, I see that the height becomes negative after 56 minutes or so. I have tried reducing the time step by a factor of 20 and that didn't help. . Do you think I should play around with other advection schemes, say some high order upwinding schemes?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3486#issuecomment-1981111211
Usability,learn,learned,"> Thanks @glwagner for merging main into this branch.; > ; > I have returned to the global simulations and have learned something.; > ; > Using all the same parameters as before, I get `NaNs` after just over an hour.; > ; > Upon closer inspection, I see that the height becomes negative after 56 minutes or so. I have tried reducing the time step by a factor of 20 and that didn't help.; > ; > Do you think I should play around with other advection schemes, say some high order upwinding schemes?. Seems to me (but I don't know for sure) that the problem is more basic than the advection scheme...; You sure that the initial condition is consistent with bathymetry?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3486#issuecomment-1981129225
Usability,learn,learned,"> Thanks @glwagner for merging main into this branch.; > ; > I have returned to the global simulations and have learned something.; > ; > Using all the same parameters as before, I get `NaNs` after just over an hour.; > ; > Upon closer inspection, I see that the height becomes negative after 56 minutes or so. I have tried reducing the time step by a factor of 20 and that didn't help.; > ; > Do you think I should play around with other advection schemes, say some high order upwinding schemes?. You need to make sure that `h` is never zero, that will give you a `NaN` because the forcing is divided by `h`. It is kind of annoying but you have to set a ""minimum height"" in the initial conditions (cannot start with `h = 0` somewhere). I remember setting `hmin = 10` was enough to get a stable simulation",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3486#issuecomment-1981243847
Security,validat,validation,"> > Thanks @glwagner for merging main into this branch.; > > I have returned to the global simulations and have learned something.; > > Using all the same parameters as before, I get `NaNs` after just over an hour.; > > Upon closer inspection, I see that the height becomes negative after 56 minutes or so. I have tried reducing the time step by a factor of 20 and that didn't help.; > > Do you think I should play around with other advection schemes, say some high order upwinding schemes?; > ; > You need to make sure that `h` is never zero, that will give you a `NaN` because the forcing is divided by `h`. It is kind of annoying but you have to set a ""minimum height"" in the initial conditions (cannot start with `h = 0` somewhere). I remember setting `hmin = 10` was enough to get a stable simulation. Thanks @simone-silvestri. . The validation script was set up with `hmin = 10` and that did go unstable. I tried `20` and `30` and they both go unstable. I'm tring `40` and it seems better. I thought if this at least runs, and shows us the ACC going on the right direction, thsi would be a big leap forward. Then we can worry abou thow to minimize the minimum h, if we like. . I will keep you posted. Update: 50 is still unstable after just under 3 hours. I'm now going to try 100. It seems like a pretty big cushion but I am curious what it takes. . And 100 yields negative height after less than 4 hours. Not good.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3486#issuecomment-1981444163
Usability,learn,learned,"> > Thanks @glwagner for merging main into this branch.; > > I have returned to the global simulations and have learned something.; > > Using all the same parameters as before, I get `NaNs` after just over an hour.; > > Upon closer inspection, I see that the height becomes negative after 56 minutes or so. I have tried reducing the time step by a factor of 20 and that didn't help.; > > Do you think I should play around with other advection schemes, say some high order upwinding schemes?; > ; > You need to make sure that `h` is never zero, that will give you a `NaN` because the forcing is divided by `h`. It is kind of annoying but you have to set a ""minimum height"" in the initial conditions (cannot start with `h = 0` somewhere). I remember setting `hmin = 10` was enough to get a stable simulation. Thanks @simone-silvestri. . The validation script was set up with `hmin = 10` and that did go unstable. I tried `20` and `30` and they both go unstable. I'm tring `40` and it seems better. I thought if this at least runs, and shows us the ACC going on the right direction, thsi would be a big leap forward. Then we can worry abou thow to minimize the minimum h, if we like. . I will keep you posted. Update: 50 is still unstable after just under 3 hours. I'm now going to try 100. It seems like a pretty big cushion but I am curious what it takes. . And 100 yields negative height after less than 4 hours. Not good.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3486#issuecomment-1981444163
Deployability,patch,patch,"> Are we also deprecating `arch_array`? This would break a lot of existing code, but could be a positive change. Or we can deprecate sometime in the future (maybe we can issue a deprecation warning). I'm more in favor of deleting `arch_array` and bumping a patch release so that other packages can have a compat requirement or force to update their code. It's a simple replacement of `arch_array(` -> `on_architecture(` anyway. What do you think?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3490#issuecomment-1978963083
Usability,simpl,simple,"> Are we also deprecating `arch_array`? This would break a lot of existing code, but could be a positive change. Or we can deprecate sometime in the future (maybe we can issue a deprecation warning). I'm more in favor of deleting `arch_array` and bumping a patch release so that other packages can have a compat requirement or force to update their code. It's a simple replacement of `arch_array(` -> `on_architecture(` anyway. What do you think?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3490#issuecomment-1978963083
Deployability,update,update,"I would keep the benchmarks simple and avoid a near-global ocean setup. The setups have to be maintained so its best if they are simple and easy to update when syntax changes. Also just for the purpose of setting up the pipeline, you probably only need one or two setups. Then we can incrementally build them up after we have observed that the pipeline is useful for at least a few days (if launching nightly). Hopefully the benchmarks will be efficient enough to run nightly.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3492#issuecomment-1973858990
Energy Efficiency,efficient,efficient,"I would keep the benchmarks simple and avoid a near-global ocean setup. The setups have to be maintained so its best if they are simple and easy to update when syntax changes. Also just for the purpose of setting up the pipeline, you probably only need one or two setups. Then we can incrementally build them up after we have observed that the pipeline is useful for at least a few days (if launching nightly). Hopefully the benchmarks will be efficient enough to run nightly.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3492#issuecomment-1973858990
Safety,avoid,avoid,"I would keep the benchmarks simple and avoid a near-global ocean setup. The setups have to be maintained so its best if they are simple and easy to update when syntax changes. Also just for the purpose of setting up the pipeline, you probably only need one or two setups. Then we can incrementally build them up after we have observed that the pipeline is useful for at least a few days (if launching nightly). Hopefully the benchmarks will be efficient enough to run nightly.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3492#issuecomment-1973858990
Testability,benchmark,benchmarks,"I would keep the benchmarks simple and avoid a near-global ocean setup. The setups have to be maintained so its best if they are simple and easy to update when syntax changes. Also just for the purpose of setting up the pipeline, you probably only need one or two setups. Then we can incrementally build them up after we have observed that the pipeline is useful for at least a few days (if launching nightly). Hopefully the benchmarks will be efficient enough to run nightly.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3492#issuecomment-1973858990
Usability,simpl,simple,"I would keep the benchmarks simple and avoid a near-global ocean setup. The setups have to be maintained so its best if they are simple and easy to update when syntax changes. Also just for the purpose of setting up the pipeline, you probably only need one or two setups. Then we can incrementally build them up after we have observed that the pipeline is useful for at least a few days (if launching nightly). Hopefully the benchmarks will be efficient enough to run nightly.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3492#issuecomment-1973858990
Usability,simpl,simple,Gotcha; Oh... I misunderstood then the first comment of the PR.; So forcing wasn't even working for simple constant Fields???,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3498#issuecomment-1989184197
Usability,simpl,simple,> Gotcha Oh... I misunderstood then the first comment of the PR. So forcing wasn't even working for simple constant Fields???. I don't think so.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3498#issuecomment-1989221909
Availability,error,error,"@simone-silvestri Unfortunately, my run died just before 20 days. I guess the simple advection scheme that I was using without viscosity wasn't stable enough. . Could you help me to set up the one you suggested on the previous PR? I tried was you suggested but got an error, which is copied above.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3502#issuecomment-1988340134
Usability,simpl,simple,"@simone-silvestri Unfortunately, my run died just before 20 days. I guess the simple advection scheme that I was using without viscosity wasn't stable enough. . Could you help me to set up the one you suggested on the previous PR? I tried was you suggested but got an error, which is copied above.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3502#issuecomment-1988340134
Usability,clear,clearly,"Thanks @simone-silvestri for the observations. I will think about that tomorrow. Today I also tried to do a flat bottom run, just to see what would happen with no bathymetry. I added the last line below, which I thought would set the bottom of the ocean to 5km below the free-surface. Unfortunately, when I ran the simulation nothing happened after even a year.; ```; bat = file_bathymetry[""bathymetry""]; boundary = Int.(bat .> 0); bat[ bat .> 0 ] .= 0 ; bat = -bat; bat = 0*bat .- 5e3; ```; This clearly didn't work. Any observations as to what I did wrong?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3502#issuecomment-1992825789
Usability,clear,clearly,"I tried the simulation commenting out the line `bat = - bat` and that become unstable in a few hours, so clearly not correct. I also put this line back in and forced the minimum dept to be 50 m instead of 10 m, and that became unstable after 53 days instead of 52 days. Not much of a difference.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3502#issuecomment-1994922908
Deployability,update,updated,@simone-silvestri . This is a result from our updated code that shows the free-surface height restricted to 9.9 and 10.1. You can clearly see that the instabilities happend around three particular regions. https://github.com/CliMA/Oceananigans.jl/assets/8239041/af15615a-7194-4ffc-88aa-69276b2e4c9a,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3502#issuecomment-2007643399
Usability,clear,clearly,@simone-silvestri . This is a result from our updated code that shows the free-surface height restricted to 9.9 and 10.1. You can clearly see that the instabilities happend around three particular regions. https://github.com/CliMA/Oceananigans.jl/assets/8239041/af15615a-7194-4ffc-88aa-69276b2e4c9a,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3502#issuecomment-2007643399
Testability,test,test,"> Ok, closing in! The last test is without an immersed boundary but with a bathymetry (you need to cap the bathymetry to something like -50m); > ; > If this works then we can focus all the attention to the immersed boundary. Just to be clear, the test I posted today was with an immersed boundary (continents) and a flat bottom. The previous test, what we called aquaplanet, was with no immersed boundary and boring flat topography. Could you clarify as to what you are suggesting? I was using the immersed boundary and am a bit confused. Sorry.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3502#issuecomment-2073142216
Usability,clear,clear,"> Ok, closing in! The last test is without an immersed boundary but with a bathymetry (you need to cap the bathymetry to something like -50m); > ; > If this works then we can focus all the attention to the immersed boundary. Just to be clear, the test I posted today was with an immersed boundary (continents) and a flat bottom. The previous test, what we called aquaplanet, was with no immersed boundary and boring flat topography. Could you clarify as to what you are suggesting? I was using the immersed boundary and am a bit confused. Sorry.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3502#issuecomment-2073142216
Security,access,access,"Thanks @glwagner . . Yes, I am trying to get the same winds that the hydrostatic model uses. This used to be done on Oceananigans but now done in ClimaOcean.jl. However, that doesn't work either as the data has been removed. I don't think this is essential to store here, but if we can find another way to access realistic winds that would certainly help me and others that are trying to use realistic winds. I have not used JRA-55 before but h appy to use that. If anyone has any sample scripts that they use in the hydrostatic model, I would be happy to see that and learna how to do the same.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3502#issuecomment-2181190344
Usability,learn,learna,"Thanks @glwagner . . Yes, I am trying to get the same winds that the hydrostatic model uses. This used to be done on Oceananigans but now done in ClimaOcean.jl. However, that doesn't work either as the data has been removed. I don't think this is essential to store here, but if we can find another way to access realistic winds that would certainly help me and others that are trying to use realistic winds. I have not used JRA-55 before but h appy to use that. If anyone has any sample scripts that they use in the hydrostatic model, I would be happy to see that and learna how to do the same.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3502#issuecomment-2181190344
Integrability,depend,depend,"> Thanks @glwagner .; > ; > Yes, I am trying to get the same winds that the hydrostatic model uses. This used to be done on Oceananigans but now done in ClimaOcean.jl. However, that doesn't work either as the data has been removed.; > ; > I don't think this is essential to store here, but if we can find another way to access realistic winds that would certainly help me and others that are trying to use realistic winds. I have not used JRA-55 before but h appy to use that. If anyone has any sample scripts that they use in the hydrostatic model, I would be happy to see that and learna how to do the same. Ok but there is no ""one"" hydrostatic model. Also note that you are prescribing fluxes here, not wind. These are different because bulk formula typically use relative winds, and also because momentum fluxes depend on buoyancy fluxes. Can you state more clearly what you would like to do? It sounds like you want to run two simulations --- one hydrostatic, and one shallow water, which are forced similarly. Is that right? We have to set both of those up then.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3502#issuecomment-2181263938
Security,access,access,"> Thanks @glwagner .; > ; > Yes, I am trying to get the same winds that the hydrostatic model uses. This used to be done on Oceananigans but now done in ClimaOcean.jl. However, that doesn't work either as the data has been removed.; > ; > I don't think this is essential to store here, but if we can find another way to access realistic winds that would certainly help me and others that are trying to use realistic winds. I have not used JRA-55 before but h appy to use that. If anyone has any sample scripts that they use in the hydrostatic model, I would be happy to see that and learna how to do the same. Ok but there is no ""one"" hydrostatic model. Also note that you are prescribing fluxes here, not wind. These are different because bulk formula typically use relative winds, and also because momentum fluxes depend on buoyancy fluxes. Can you state more clearly what you would like to do? It sounds like you want to run two simulations --- one hydrostatic, and one shallow water, which are forced similarly. Is that right? We have to set both of those up then.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3502#issuecomment-2181263938
Usability,learn,learna,"> Thanks @glwagner .; > ; > Yes, I am trying to get the same winds that the hydrostatic model uses. This used to be done on Oceananigans but now done in ClimaOcean.jl. However, that doesn't work either as the data has been removed.; > ; > I don't think this is essential to store here, but if we can find another way to access realistic winds that would certainly help me and others that are trying to use realistic winds. I have not used JRA-55 before but h appy to use that. If anyone has any sample scripts that they use in the hydrostatic model, I would be happy to see that and learna how to do the same. Ok but there is no ""one"" hydrostatic model. Also note that you are prescribing fluxes here, not wind. These are different because bulk formula typically use relative winds, and also because momentum fluxes depend on buoyancy fluxes. Can you state more clearly what you would like to do? It sounds like you want to run two simulations --- one hydrostatic, and one shallow water, which are forced similarly. Is that right? We have to set both of those up then.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3502#issuecomment-2181263938
Usability,clear,clear,"> Okay, so I've got a way we could do this. When a user specifies an `AbstractTime` we can then use the type they've given to set the timestep type like:; > ; > ```julia; > clock = Clock{eltype(grid)}(time = DateTime(2020)); > ```. I think it'll work a little differently, because we will want the time-step to also be a period rather than a floating point. We don't support it yet, but we will have to convert the time-step to a floating point somewhere internally. It does look like this will affect the code you are about to write! But don't worry too much --- as long as you write clear, concise code we will be able to change it approprately in the future!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3508#issuecomment-1996014097
Usability,simpl,simple,"Won't this prevent us from doing simple stuff like creating a grid with size (1, 1, 1) that has the default halos -- (3, 3, 3)?. It's better to use `map` than broadcasting btw",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3516#issuecomment-2002553157
Usability,simpl,simple,"> Won't this prevent us from doing simple stuff like creating a grid with size (1, 1, 1) that has the default halos -- (3, 3, 3)?; > ; > It's better to use `map` than broadcasting btw. How can I use map?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3516#issuecomment-2002638223
Availability,error,error,"Awesome! And to be more clear, I think the reason we want it to work is so that we can also reuse all the other schedules. Another reason to use it is because we may need to change `TimeInterval` in the future if we support different time types (for example `DateTime`, or other time types that solve the annoying problem of rounding error). So in all those cases it will be nice not to have to worry about different implementations of time interval schedules.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3523#issuecomment-2023010994
Energy Efficiency,schedul,schedules,"Awesome! And to be more clear, I think the reason we want it to work is so that we can also reuse all the other schedules. Another reason to use it is because we may need to change `TimeInterval` in the future if we support different time types (for example `DateTime`, or other time types that solve the annoying problem of rounding error). So in all those cases it will be nice not to have to worry about different implementations of time interval schedules.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3523#issuecomment-2023010994
Usability,clear,clear,"Awesome! And to be more clear, I think the reason we want it to work is so that we can also reuse all the other schedules. Another reason to use it is because we may need to change `TimeInterval` in the future if we support different time types (for example `DateTime`, or other time types that solve the annoying problem of rounding error). So in all those cases it will be nice not to have to worry about different implementations of time interval schedules.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3523#issuecomment-2023010994
Availability,mask,masking,"This kind of feature can't be implemented directly in `Forcing`, because all explicit tendency terms are evaluated in the same kernel. So we have to evaluate `forcing` in every cell that requires a tendency. It is possible to expose a feature that allows kernels to be launched over some subset of cells. Then users could implement this kind of optimization in their script by using an array to represent the forcing, and then by precomputing the forcing into that array using a kernel that only evaluates some subset of all the cells in a callback. Or something like that. If forcing functions are expensive there may be simpler ways to do performance optimization though. For example, we can recommend piecewise linear masking functions for sponge layers instead of tanh or exp.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3525#issuecomment-2028469830
Modifiability,layers,layers,"This kind of feature can't be implemented directly in `Forcing`, because all explicit tendency terms are evaluated in the same kernel. So we have to evaluate `forcing` in every cell that requires a tendency. It is possible to expose a feature that allows kernels to be launched over some subset of cells. Then users could implement this kind of optimization in their script by using an array to represent the forcing, and then by precomputing the forcing into that array using a kernel that only evaluates some subset of all the cells in a callback. Or something like that. If forcing functions are expensive there may be simpler ways to do performance optimization though. For example, we can recommend piecewise linear masking functions for sponge layers instead of tanh or exp.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3525#issuecomment-2028469830
Performance,optimiz,optimization,"This kind of feature can't be implemented directly in `Forcing`, because all explicit tendency terms are evaluated in the same kernel. So we have to evaluate `forcing` in every cell that requires a tendency. It is possible to expose a feature that allows kernels to be launched over some subset of cells. Then users could implement this kind of optimization in their script by using an array to represent the forcing, and then by precomputing the forcing into that array using a kernel that only evaluates some subset of all the cells in a callback. Or something like that. If forcing functions are expensive there may be simpler ways to do performance optimization though. For example, we can recommend piecewise linear masking functions for sponge layers instead of tanh or exp.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3525#issuecomment-2028469830
Security,expose,expose,"This kind of feature can't be implemented directly in `Forcing`, because all explicit tendency terms are evaluated in the same kernel. So we have to evaluate `forcing` in every cell that requires a tendency. It is possible to expose a feature that allows kernels to be launched over some subset of cells. Then users could implement this kind of optimization in their script by using an array to represent the forcing, and then by precomputing the forcing into that array using a kernel that only evaluates some subset of all the cells in a callback. Or something like that. If forcing functions are expensive there may be simpler ways to do performance optimization though. For example, we can recommend piecewise linear masking functions for sponge layers instead of tanh or exp.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3525#issuecomment-2028469830
Usability,simpl,simpler,"This kind of feature can't be implemented directly in `Forcing`, because all explicit tendency terms are evaluated in the same kernel. So we have to evaluate `forcing` in every cell that requires a tendency. It is possible to expose a feature that allows kernels to be launched over some subset of cells. Then users could implement this kind of optimization in their script by using an array to represent the forcing, and then by precomputing the forcing into that array using a kernel that only evaluates some subset of all the cells in a callback. Or something like that. If forcing functions are expensive there may be simpler ways to do performance optimization though. For example, we can recommend piecewise linear masking functions for sponge layers instead of tanh or exp.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3525#issuecomment-2028469830
Availability,mask,masking,"> If forcing functions are expensive there may be simpler ways to do performance optimization though. For example, we can recommend piecewise linear masking functions for sponge layers instead of tanh or exp. From my tests I think this optimization can shave off 10% of time on the CPU and 25% on the GPU. This isn't bad, but I anticipate launching `Forcing` only where necessary would shave of much more in the situations I mentioned. Although when I originally posted the issue I thought it could be directly implemented in `Forcing`, but you make a good point that it can't, so it might not be worth the effort (at least not right now). I'll close this for now but feel free to re-open it if you think it's worth discussing.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3525#issuecomment-2033489092
Modifiability,layers,layers,"> If forcing functions are expensive there may be simpler ways to do performance optimization though. For example, we can recommend piecewise linear masking functions for sponge layers instead of tanh or exp. From my tests I think this optimization can shave off 10% of time on the CPU and 25% on the GPU. This isn't bad, but I anticipate launching `Forcing` only where necessary would shave of much more in the situations I mentioned. Although when I originally posted the issue I thought it could be directly implemented in `Forcing`, but you make a good point that it can't, so it might not be worth the effort (at least not right now). I'll close this for now but feel free to re-open it if you think it's worth discussing.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3525#issuecomment-2033489092
Performance,perform,performance,"> If forcing functions are expensive there may be simpler ways to do performance optimization though. For example, we can recommend piecewise linear masking functions for sponge layers instead of tanh or exp. From my tests I think this optimization can shave off 10% of time on the CPU and 25% on the GPU. This isn't bad, but I anticipate launching `Forcing` only where necessary would shave of much more in the situations I mentioned. Although when I originally posted the issue I thought it could be directly implemented in `Forcing`, but you make a good point that it can't, so it might not be worth the effort (at least not right now). I'll close this for now but feel free to re-open it if you think it's worth discussing.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3525#issuecomment-2033489092
Testability,test,tests,"> If forcing functions are expensive there may be simpler ways to do performance optimization though. For example, we can recommend piecewise linear masking functions for sponge layers instead of tanh or exp. From my tests I think this optimization can shave off 10% of time on the CPU and 25% on the GPU. This isn't bad, but I anticipate launching `Forcing` only where necessary would shave of much more in the situations I mentioned. Although when I originally posted the issue I thought it could be directly implemented in `Forcing`, but you make a good point that it can't, so it might not be worth the effort (at least not right now). I'll close this for now but feel free to re-open it if you think it's worth discussing.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3525#issuecomment-2033489092
Usability,simpl,simpler,"> If forcing functions are expensive there may be simpler ways to do performance optimization though. For example, we can recommend piecewise linear masking functions for sponge layers instead of tanh or exp. From my tests I think this optimization can shave off 10% of time on the CPU and 25% on the GPU. This isn't bad, but I anticipate launching `Forcing` only where necessary would shave of much more in the situations I mentioned. Although when I originally posted the issue I thought it could be directly implemented in `Forcing`, but you make a good point that it can't, so it might not be worth the effort (at least not right now). I'll close this for now but feel free to re-open it if you think it's worth discussing.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3525#issuecomment-2033489092
Deployability,update,updates,"I started tackling this issue in ClimaAtmos last week. I wrote a module, `OutputPathGenerator`, in a separate utilities package ([documentation](https://clima.github.io/ClimaUtilities.jl/dev/outputpathgenerator/)). This module defines an object, `OutputPathGenerator` that can be extended with different `OutputPathGeneratorStyle`s. ; The `OutputPathGenerator` is used in a `generate_output_path` function that takes the base output dir and the style.; The simplest of such styles is ""overwrite"". . The style that is currently being used in Atmos is `ActiveLinkStyle`. Citing from the docs:; > This style provides a more convenient and non-destructive approach. It manages a sequence of subfolders within the base directory specified by `output_path`. It also creates a symbolic link named `output_active` that points to the current active subfolder. This allows you to easily access the latest simulation results with a predictable path. > Example:; > Let's assume your output_path is set to data.; > If data doesn't exist, the module creates it and returns data/output_active. This link points to the newly created subfolder data/output_0000.; > If data exists and contains an output_active link pointing to data/output_0005, the module creates a new subfolder data/output_0006 and updates output_active to point to it.; > If data exists with or without an output_active link, the module checks for existing subfolders named data/output_XXXX (with XXXX a number). If none are found, it creates data/output_0000 and a link data/output_active pointing to it. Atmos uses `OutputPathGenerator` internally. My vision is that end users would be providing the base path and possibly choosing a `Style` if they don't want the default behavior (which is the ActiveLinkStyle). `Styles` are Julia objects and new ones can be defined in scripts by implementing a method for the function `generate_output_path`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3543#issuecomment-2041168662
Modifiability,extend,extended,"I started tackling this issue in ClimaAtmos last week. I wrote a module, `OutputPathGenerator`, in a separate utilities package ([documentation](https://clima.github.io/ClimaUtilities.jl/dev/outputpathgenerator/)). This module defines an object, `OutputPathGenerator` that can be extended with different `OutputPathGeneratorStyle`s. ; The `OutputPathGenerator` is used in a `generate_output_path` function that takes the base output dir and the style.; The simplest of such styles is ""overwrite"". . The style that is currently being used in Atmos is `ActiveLinkStyle`. Citing from the docs:; > This style provides a more convenient and non-destructive approach. It manages a sequence of subfolders within the base directory specified by `output_path`. It also creates a symbolic link named `output_active` that points to the current active subfolder. This allows you to easily access the latest simulation results with a predictable path. > Example:; > Let's assume your output_path is set to data.; > If data doesn't exist, the module creates it and returns data/output_active. This link points to the newly created subfolder data/output_0000.; > If data exists and contains an output_active link pointing to data/output_0005, the module creates a new subfolder data/output_0006 and updates output_active to point to it.; > If data exists with or without an output_active link, the module checks for existing subfolders named data/output_XXXX (with XXXX a number). If none are found, it creates data/output_0000 and a link data/output_active pointing to it. Atmos uses `OutputPathGenerator` internally. My vision is that end users would be providing the base path and possibly choosing a `Style` if they don't want the default behavior (which is the ActiveLinkStyle). `Styles` are Julia objects and new ones can be defined in scripts by implementing a method for the function `generate_output_path`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3543#issuecomment-2041168662
Safety,predict,predictable,"I started tackling this issue in ClimaAtmos last week. I wrote a module, `OutputPathGenerator`, in a separate utilities package ([documentation](https://clima.github.io/ClimaUtilities.jl/dev/outputpathgenerator/)). This module defines an object, `OutputPathGenerator` that can be extended with different `OutputPathGeneratorStyle`s. ; The `OutputPathGenerator` is used in a `generate_output_path` function that takes the base output dir and the style.; The simplest of such styles is ""overwrite"". . The style that is currently being used in Atmos is `ActiveLinkStyle`. Citing from the docs:; > This style provides a more convenient and non-destructive approach. It manages a sequence of subfolders within the base directory specified by `output_path`. It also creates a symbolic link named `output_active` that points to the current active subfolder. This allows you to easily access the latest simulation results with a predictable path. > Example:; > Let's assume your output_path is set to data.; > If data doesn't exist, the module creates it and returns data/output_active. This link points to the newly created subfolder data/output_0000.; > If data exists and contains an output_active link pointing to data/output_0005, the module creates a new subfolder data/output_0006 and updates output_active to point to it.; > If data exists with or without an output_active link, the module checks for existing subfolders named data/output_XXXX (with XXXX a number). If none are found, it creates data/output_0000 and a link data/output_active pointing to it. Atmos uses `OutputPathGenerator` internally. My vision is that end users would be providing the base path and possibly choosing a `Style` if they don't want the default behavior (which is the ActiveLinkStyle). `Styles` are Julia objects and new ones can be defined in scripts by implementing a method for the function `generate_output_path`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3543#issuecomment-2041168662
Security,access,access,"I started tackling this issue in ClimaAtmos last week. I wrote a module, `OutputPathGenerator`, in a separate utilities package ([documentation](https://clima.github.io/ClimaUtilities.jl/dev/outputpathgenerator/)). This module defines an object, `OutputPathGenerator` that can be extended with different `OutputPathGeneratorStyle`s. ; The `OutputPathGenerator` is used in a `generate_output_path` function that takes the base output dir and the style.; The simplest of such styles is ""overwrite"". . The style that is currently being used in Atmos is `ActiveLinkStyle`. Citing from the docs:; > This style provides a more convenient and non-destructive approach. It manages a sequence of subfolders within the base directory specified by `output_path`. It also creates a symbolic link named `output_active` that points to the current active subfolder. This allows you to easily access the latest simulation results with a predictable path. > Example:; > Let's assume your output_path is set to data.; > If data doesn't exist, the module creates it and returns data/output_active. This link points to the newly created subfolder data/output_0000.; > If data exists and contains an output_active link pointing to data/output_0005, the module creates a new subfolder data/output_0006 and updates output_active to point to it.; > If data exists with or without an output_active link, the module checks for existing subfolders named data/output_XXXX (with XXXX a number). If none are found, it creates data/output_0000 and a link data/output_active pointing to it. Atmos uses `OutputPathGenerator` internally. My vision is that end users would be providing the base path and possibly choosing a `Style` if they don't want the default behavior (which is the ActiveLinkStyle). `Styles` are Julia objects and new ones can be defined in scripts by implementing a method for the function `generate_output_path`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3543#issuecomment-2041168662
Usability,simpl,simplest,"I started tackling this issue in ClimaAtmos last week. I wrote a module, `OutputPathGenerator`, in a separate utilities package ([documentation](https://clima.github.io/ClimaUtilities.jl/dev/outputpathgenerator/)). This module defines an object, `OutputPathGenerator` that can be extended with different `OutputPathGeneratorStyle`s. ; The `OutputPathGenerator` is used in a `generate_output_path` function that takes the base output dir and the style.; The simplest of such styles is ""overwrite"". . The style that is currently being used in Atmos is `ActiveLinkStyle`. Citing from the docs:; > This style provides a more convenient and non-destructive approach. It manages a sequence of subfolders within the base directory specified by `output_path`. It also creates a symbolic link named `output_active` that points to the current active subfolder. This allows you to easily access the latest simulation results with a predictable path. > Example:; > Let's assume your output_path is set to data.; > If data doesn't exist, the module creates it and returns data/output_active. This link points to the newly created subfolder data/output_0000.; > If data exists and contains an output_active link pointing to data/output_0005, the module creates a new subfolder data/output_0006 and updates output_active to point to it.; > If data exists with or without an output_active link, the module checks for existing subfolders named data/output_XXXX (with XXXX a number). If none are found, it creates data/output_0000 and a link data/output_active pointing to it. Atmos uses `OutputPathGenerator` internally. My vision is that end users would be providing the base path and possibly choosing a `Style` if they don't want the default behavior (which is the ActiveLinkStyle). `Styles` are Julia objects and new ones can be defined in scripts by implementing a method for the function `generate_output_path`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3543#issuecomment-2041168662
Availability,down,down,"I add a bit of context here:. @Yixiao-Zhang is doing a non-hydrostatic simulation with an immersed boundary and he finds that the code crashes with the PCG solver. That is not necessarily connected with the PCG solver but it might be caused by simulation setup or other issues. Since the pressure solver used is experimental (from [this branch](https://github.com/CliMA/Oceananigans.jl/tree/glw-xk/divergence-free-immersed-velocity-field)), as a way to assess where the crashing comes from, I suggested using another method to see if the crash would also happen, which would validate or not the experimental pressure solver. @Yixiao-Zhang, optimizing GPU preconditioners is a quite difficult task as demonstrated by the preconditioners slowing down the simulation, and probably not a good use of time of trying to figure out a way to speed up these solvers that we are not sure we want to use. ; Since this simple attempt to have a simulation that runs (with another _correct_ solver) up to the crashing point does not work, I would suggest to just trying to use a (slightly non-correct) FFT pressure solver to see if the simulation still crashes.; If not, then we can assume the crashing occurs due to the PCG solver and try to catch the bug. ; This will probably be a better way to ""optimize"" the solver since we know that the PCG preconditioned with FFT is faster than these other methods.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3552#issuecomment-2052606749
Performance,optimiz,optimizing,"I add a bit of context here:. @Yixiao-Zhang is doing a non-hydrostatic simulation with an immersed boundary and he finds that the code crashes with the PCG solver. That is not necessarily connected with the PCG solver but it might be caused by simulation setup or other issues. Since the pressure solver used is experimental (from [this branch](https://github.com/CliMA/Oceananigans.jl/tree/glw-xk/divergence-free-immersed-velocity-field)), as a way to assess where the crashing comes from, I suggested using another method to see if the crash would also happen, which would validate or not the experimental pressure solver. @Yixiao-Zhang, optimizing GPU preconditioners is a quite difficult task as demonstrated by the preconditioners slowing down the simulation, and probably not a good use of time of trying to figure out a way to speed up these solvers that we are not sure we want to use. ; Since this simple attempt to have a simulation that runs (with another _correct_ solver) up to the crashing point does not work, I would suggest to just trying to use a (slightly non-correct) FFT pressure solver to see if the simulation still crashes.; If not, then we can assume the crashing occurs due to the PCG solver and try to catch the bug. ; This will probably be a better way to ""optimize"" the solver since we know that the PCG preconditioned with FFT is faster than these other methods.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3552#issuecomment-2052606749
Security,validat,validate,"I add a bit of context here:. @Yixiao-Zhang is doing a non-hydrostatic simulation with an immersed boundary and he finds that the code crashes with the PCG solver. That is not necessarily connected with the PCG solver but it might be caused by simulation setup or other issues. Since the pressure solver used is experimental (from [this branch](https://github.com/CliMA/Oceananigans.jl/tree/glw-xk/divergence-free-immersed-velocity-field)), as a way to assess where the crashing comes from, I suggested using another method to see if the crash would also happen, which would validate or not the experimental pressure solver. @Yixiao-Zhang, optimizing GPU preconditioners is a quite difficult task as demonstrated by the preconditioners slowing down the simulation, and probably not a good use of time of trying to figure out a way to speed up these solvers that we are not sure we want to use. ; Since this simple attempt to have a simulation that runs (with another _correct_ solver) up to the crashing point does not work, I would suggest to just trying to use a (slightly non-correct) FFT pressure solver to see if the simulation still crashes.; If not, then we can assume the crashing occurs due to the PCG solver and try to catch the bug. ; This will probably be a better way to ""optimize"" the solver since we know that the PCG preconditioned with FFT is faster than these other methods.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3552#issuecomment-2052606749
Usability,simpl,simple,"I add a bit of context here:. @Yixiao-Zhang is doing a non-hydrostatic simulation with an immersed boundary and he finds that the code crashes with the PCG solver. That is not necessarily connected with the PCG solver but it might be caused by simulation setup or other issues. Since the pressure solver used is experimental (from [this branch](https://github.com/CliMA/Oceananigans.jl/tree/glw-xk/divergence-free-immersed-velocity-field)), as a way to assess where the crashing comes from, I suggested using another method to see if the crash would also happen, which would validate or not the experimental pressure solver. @Yixiao-Zhang, optimizing GPU preconditioners is a quite difficult task as demonstrated by the preconditioners slowing down the simulation, and probably not a good use of time of trying to figure out a way to speed up these solvers that we are not sure we want to use. ; Since this simple attempt to have a simulation that runs (with another _correct_ solver) up to the crashing point does not work, I would suggest to just trying to use a (slightly non-correct) FFT pressure solver to see if the simulation still crashes.; If not, then we can assume the crashing occurs due to the PCG solver and try to catch the bug. ; This will probably be a better way to ""optimize"" the solver since we know that the PCG preconditioned with FFT is faster than these other methods.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3552#issuecomment-2052606749
Energy Efficiency,schedul,schedule,"e function b_initial(x::R, y::R, z::R) where {R<:Real}; ϵ = 100 * eps(R); return (Δb / Ly) * y + randn() * ϵ; end. # ---------------------------------------------------------------------- #; # Define the Simulation. # Grid; ib_grid = begin; underlying_grid = RectilinearGrid(; arch,; size = (Nx, Ny, Nz),; x = (-Lx / 2, Lx / 2),; y = (0.0, Ly),; z = (0.0, Lz),; topology = (Periodic, Bounded, Bounded),; halo = (4, 4, 4),; ). @inline function is_ib(x::R, y::R, z::R) where {R<:Real}; return z > z_top(y); end. ImmersedBoundaryGrid(; underlying_grid,; GridFittedBoundary(is_ib); ); end. # Coriolis; coriolis = FPlane(f₀). # Buoyancy; buoyancy = BuoyancyTracer(). # Closure; closure = ScalarDiffusivity(ν = viscosity, κ = diffusivity). # Pressure Solver; pressure_solver = ImmersedPoissonSolver(; ib_grid,; solver_method = :HeptadiagonalIterativeSolver,; reltol = 1e-8,; verbose = false; ). # Model; model = NonhydrostaticModel(;; grid = ib_grid,; timestepper = time_stepper,; advection = advection,; tracers = (:b, ),; coriolis = coriolis,; buoyancy = buoyancy,; closure = closure,; pressure_solver = pressure_solver,; ). # Initial Value; set!(model, b = b_initial). # Simulation; simulation = Simulation(model; Δt = Δt, stop_iteration = 1000). # Set Output; output_fields = merge(model.velocities, model.tracers). simulation.output_writers[:output_3d] = NetCDFOutputWriter(; model,; output_fields,; filename = ""output.nc"",; schedule = IterationInterval(output_interval),; overwrite_existing = true,; deflatelevel = deflatelevel,; ). # Set Progress Function; function print_simulation_progress(simulation). model = simulation.model; i, t = model.clock.iteration, model.clock.time. @info Printf.@sprintf(""Iteration: %d, Time: %.2f Earth Days"", i, t / 86400.0). return nothing; end. simulation.callbacks[:progress] = Callback(; print_simulation_progress,; IterationInterval(100),; ). # ---------------------------------------------------------------------- #; # Run the Simulation; run!(simulation); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3552#issuecomment-2070993577
Testability,test,testing,"I made a simple script for testing, and it takes 3 minutes to run on my PC \(on either CPU or GPU\). This is a 2D simulation initialized with a lateral buoyancy gradient. The top is tilted. The figure shows the comparison between the default solver and the `HeptadiagonalIterativeSolver`. The default FFT solver produces pixelated patterns near the top boundary and deep zonal jets in the ocean interior. Besides, I tired the `HeptadiagonalIterativeSolver` with the FFT-based solver as a preconditioner. It did not crash for this script and produced almost the same as the `HeptadiagonalIterativeSolver` with no preconditioner. ![u](https://github.com/CliMA/Oceananigans.jl/assets/49335616/104a8b9b-4b09-4d36-a24d-64625320e0ba). ```Julia; using Printf; using Oceananigans; using Oceananigans.Models.NonhydrostaticModels: ImmersedPoissonSolver. # ---------------------------------------------------------------------- #; # Define Parameters. # Numerical Technic; const arch = CPU(); const time_stepper = :RungeKutta3; const advection = WENO(). # Grid; const Nx = 1; const Ny = 200; const Nz = 50; const Lx = 100.0e3; const Ly = 200.0e3; const Lz = 50.0e3. const Δz = Lz / 2 # elevation difference at the top. # Time Stepping; const Δt = 1800.0. # Physical Parameters; const diffusivity = 1.0e-4; const Pr = 1.0; const f₀ = 1.0e-4; const Δb = 1.0e-6 # buoyancy difference at the top. # Output; const output_interval = 1; const deflatelevel = 4. # ---------------------------------------------------------------------- #; # Define Utils. # Height at Top; @inline function z_top(y::R) where {R<:Real}; return Lz - (Δz / Ly) * y; end. # Viscosity; const viscosity = Pr * diffusivity. # Initial Fields; @inline function b_initial(x::R, y::R, z::R) where {R<:Real}; ϵ = 100 * eps(R); return (Δb / Ly) * y + randn() * ϵ; end. # ---------------------------------------------------------------------- #; # Define the Simulation. # Grid; ib_grid = begin; underlying_grid = RectilinearGrid(; arch,; size = (Nx, Ny",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3552#issuecomment-2070993577
Usability,simpl,simple,"I made a simple script for testing, and it takes 3 minutes to run on my PC \(on either CPU or GPU\). This is a 2D simulation initialized with a lateral buoyancy gradient. The top is tilted. The figure shows the comparison between the default solver and the `HeptadiagonalIterativeSolver`. The default FFT solver produces pixelated patterns near the top boundary and deep zonal jets in the ocean interior. Besides, I tired the `HeptadiagonalIterativeSolver` with the FFT-based solver as a preconditioner. It did not crash for this script and produced almost the same as the `HeptadiagonalIterativeSolver` with no preconditioner. ![u](https://github.com/CliMA/Oceananigans.jl/assets/49335616/104a8b9b-4b09-4d36-a24d-64625320e0ba). ```Julia; using Printf; using Oceananigans; using Oceananigans.Models.NonhydrostaticModels: ImmersedPoissonSolver. # ---------------------------------------------------------------------- #; # Define Parameters. # Numerical Technic; const arch = CPU(); const time_stepper = :RungeKutta3; const advection = WENO(). # Grid; const Nx = 1; const Ny = 200; const Nz = 50; const Lx = 100.0e3; const Ly = 200.0e3; const Lz = 50.0e3. const Δz = Lz / 2 # elevation difference at the top. # Time Stepping; const Δt = 1800.0. # Physical Parameters; const diffusivity = 1.0e-4; const Pr = 1.0; const f₀ = 1.0e-4; const Δb = 1.0e-6 # buoyancy difference at the top. # Output; const output_interval = 1; const deflatelevel = 4. # ---------------------------------------------------------------------- #; # Define Utils. # Height at Top; @inline function z_top(y::R) where {R<:Real}; return Lz - (Δz / Ly) * y; end. # Viscosity; const viscosity = Pr * diffusivity. # Initial Fields; @inline function b_initial(x::R, y::R, z::R) where {R<:Real}; ϵ = 100 * eps(R); return (Δb / Ly) * y + randn() * ϵ; end. # ---------------------------------------------------------------------- #; # Define the Simulation. # Grid; ib_grid = begin; underlying_grid = RectilinearGrid(; arch,; size = (Nx, Ny",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3552#issuecomment-2070993577
Energy Efficiency,adapt,adaptive,"Thank you for reply, @glwagner!. > Can you clarify --- is the simulation on the right with the FFT-based _direct_ solver, or is it with a preconditioned conjugate gradient solver that use an FFT as a preconditioner?. On the left is FFT-based direct solver. On the right is the PCG solver with the FFT-based solver as a preconditioner. > My suggestion is to use a preconditioned conjugate gradient solver, with the FFT-based solver as a _preconditioner_ (not as the direct solver). It is what the right panel shows, if I am not mistaken. But the simulation crashed after thousands of iterations. I heard that the PCG solver in Oceananigans has not been widely tested, so that is why I turned to the `HeptadiagonalIterativeSolver`. > As for blow up I think the problem happens for very small time-steps? Perhaps try it without adaptive time-stepping for now and also cap the `max_iterations` as a small number. I am doing more testing on this. It is a different issue though. I will open a new issue if I can find a simple way to reproduce the blow up.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3552#issuecomment-2071006297
Modifiability,adapt,adaptive,"Thank you for reply, @glwagner!. > Can you clarify --- is the simulation on the right with the FFT-based _direct_ solver, or is it with a preconditioned conjugate gradient solver that use an FFT as a preconditioner?. On the left is FFT-based direct solver. On the right is the PCG solver with the FFT-based solver as a preconditioner. > My suggestion is to use a preconditioned conjugate gradient solver, with the FFT-based solver as a _preconditioner_ (not as the direct solver). It is what the right panel shows, if I am not mistaken. But the simulation crashed after thousands of iterations. I heard that the PCG solver in Oceananigans has not been widely tested, so that is why I turned to the `HeptadiagonalIterativeSolver`. > As for blow up I think the problem happens for very small time-steps? Perhaps try it without adaptive time-stepping for now and also cap the `max_iterations` as a small number. I am doing more testing on this. It is a different issue though. I will open a new issue if I can find a simple way to reproduce the blow up.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3552#issuecomment-2071006297
Testability,test,tested,"Thank you for reply, @glwagner!. > Can you clarify --- is the simulation on the right with the FFT-based _direct_ solver, or is it with a preconditioned conjugate gradient solver that use an FFT as a preconditioner?. On the left is FFT-based direct solver. On the right is the PCG solver with the FFT-based solver as a preconditioner. > My suggestion is to use a preconditioned conjugate gradient solver, with the FFT-based solver as a _preconditioner_ (not as the direct solver). It is what the right panel shows, if I am not mistaken. But the simulation crashed after thousands of iterations. I heard that the PCG solver in Oceananigans has not been widely tested, so that is why I turned to the `HeptadiagonalIterativeSolver`. > As for blow up I think the problem happens for very small time-steps? Perhaps try it without adaptive time-stepping for now and also cap the `max_iterations` as a small number. I am doing more testing on this. It is a different issue though. I will open a new issue if I can find a simple way to reproduce the blow up.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3552#issuecomment-2071006297
Usability,simpl,simple,"Thank you for reply, @glwagner!. > Can you clarify --- is the simulation on the right with the FFT-based _direct_ solver, or is it with a preconditioned conjugate gradient solver that use an FFT as a preconditioner?. On the left is FFT-based direct solver. On the right is the PCG solver with the FFT-based solver as a preconditioner. > My suggestion is to use a preconditioned conjugate gradient solver, with the FFT-based solver as a _preconditioner_ (not as the direct solver). It is what the right panel shows, if I am not mistaken. But the simulation crashed after thousands of iterations. I heard that the PCG solver in Oceananigans has not been widely tested, so that is why I turned to the `HeptadiagonalIterativeSolver`. > As for blow up I think the problem happens for very small time-steps? Perhaps try it without adaptive time-stepping for now and also cap the `max_iterations` as a small number. I am doing more testing on this. It is a different issue though. I will open a new issue if I can find a simple way to reproduce the blow up.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3552#issuecomment-2071006297
Usability,clear,clear,I couldn't find any other `@eval` inside functions so I think we are clear. ; @vchuravy can you confirm?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3556#issuecomment-2111362174
Availability,recover,recovered,"consider the tilted bottom boundary layer example: https://clima.github.io/OceananigansDocumentation/stable/literated/tilted_bottom_boundary_layer/. In this problem, the buoyancy is decomposed ($b=\bar{b} + b^{\prime}$) into a background component $\bar{b} = N^{2} \hat{z}$ (where $\hat{z}$ is positive in the direction opposite the gravitational vector) and the remaining perturbation. The current example script applies no boundary conditions to the perturbation buoyancy, which I believe defaults to a no-normal-flux condition at the top and bottom boundary. Because no boundary conditions are applied to the background field, there is an implied diffusive flux $\hat{\mathbf{n}} \cdot (-\kappa \nabla \bar{b}) = ±\kappa N^{2} \cos{\theta}$ across these boundaries. This means that the boundary condition on the total buoyancy is a non-zero flux across the seafloor, which does not make much sense for this problem. The normal way of implementing this problem is to apply a gradient boundary condition, $\frac{\partial b^{\prime}}{\partial z} = -N^{2}\cos{\theta}$, at the bottom, to impose the no-flux condition. (In my MITgcm configurations, I verified that implementing the boundary condition this way recovered the classical analytical solutions of [Garrett et al. 1993](https://www.annualreviews.org/doi/10.1146/annurev.fl.25.010193.001451). Here is [another example using Dedalus](https://github.com/hdrake/bmli-linear/blob/main/examples/evp_replicate_Wenegrat2018_growth_rates.ipynb) to replicate some of Jacob Wenegrat's results, where I also include a non-zero gradient boundary condition on the perturbation buoyancy to impose no flux on the total buoyancy.). I understand why one might want background fields to be constructed a certain way for idealized problems, but it should be communicated clearly (and consistently) to the user exactly how this works. Is the tilted bottom boundary layer example incorrectly implemented or do I still not understand how the background fields work?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3568#issuecomment-2083158198
Deployability,configurat,configurations,"consider the tilted bottom boundary layer example: https://clima.github.io/OceananigansDocumentation/stable/literated/tilted_bottom_boundary_layer/. In this problem, the buoyancy is decomposed ($b=\bar{b} + b^{\prime}$) into a background component $\bar{b} = N^{2} \hat{z}$ (where $\hat{z}$ is positive in the direction opposite the gravitational vector) and the remaining perturbation. The current example script applies no boundary conditions to the perturbation buoyancy, which I believe defaults to a no-normal-flux condition at the top and bottom boundary. Because no boundary conditions are applied to the background field, there is an implied diffusive flux $\hat{\mathbf{n}} \cdot (-\kappa \nabla \bar{b}) = ±\kappa N^{2} \cos{\theta}$ across these boundaries. This means that the boundary condition on the total buoyancy is a non-zero flux across the seafloor, which does not make much sense for this problem. The normal way of implementing this problem is to apply a gradient boundary condition, $\frac{\partial b^{\prime}}{\partial z} = -N^{2}\cos{\theta}$, at the bottom, to impose the no-flux condition. (In my MITgcm configurations, I verified that implementing the boundary condition this way recovered the classical analytical solutions of [Garrett et al. 1993](https://www.annualreviews.org/doi/10.1146/annurev.fl.25.010193.001451). Here is [another example using Dedalus](https://github.com/hdrake/bmli-linear/blob/main/examples/evp_replicate_Wenegrat2018_growth_rates.ipynb) to replicate some of Jacob Wenegrat's results, where I also include a non-zero gradient boundary condition on the perturbation buoyancy to impose no flux on the total buoyancy.). I understand why one might want background fields to be constructed a certain way for idealized problems, but it should be communicated clearly (and consistently) to the user exactly how this works. Is the tilted bottom boundary layer example incorrectly implemented or do I still not understand how the background fields work?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3568#issuecomment-2083158198
Modifiability,config,configurations,"consider the tilted bottom boundary layer example: https://clima.github.io/OceananigansDocumentation/stable/literated/tilted_bottom_boundary_layer/. In this problem, the buoyancy is decomposed ($b=\bar{b} + b^{\prime}$) into a background component $\bar{b} = N^{2} \hat{z}$ (where $\hat{z}$ is positive in the direction opposite the gravitational vector) and the remaining perturbation. The current example script applies no boundary conditions to the perturbation buoyancy, which I believe defaults to a no-normal-flux condition at the top and bottom boundary. Because no boundary conditions are applied to the background field, there is an implied diffusive flux $\hat{\mathbf{n}} \cdot (-\kappa \nabla \bar{b}) = ±\kappa N^{2} \cos{\theta}$ across these boundaries. This means that the boundary condition on the total buoyancy is a non-zero flux across the seafloor, which does not make much sense for this problem. The normal way of implementing this problem is to apply a gradient boundary condition, $\frac{\partial b^{\prime}}{\partial z} = -N^{2}\cos{\theta}$, at the bottom, to impose the no-flux condition. (In my MITgcm configurations, I verified that implementing the boundary condition this way recovered the classical analytical solutions of [Garrett et al. 1993](https://www.annualreviews.org/doi/10.1146/annurev.fl.25.010193.001451). Here is [another example using Dedalus](https://github.com/hdrake/bmli-linear/blob/main/examples/evp_replicate_Wenegrat2018_growth_rates.ipynb) to replicate some of Jacob Wenegrat's results, where I also include a non-zero gradient boundary condition on the perturbation buoyancy to impose no flux on the total buoyancy.). I understand why one might want background fields to be constructed a certain way for idealized problems, but it should be communicated clearly (and consistently) to the user exactly how this works. Is the tilted bottom boundary layer example incorrectly implemented or do I still not understand how the background fields work?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3568#issuecomment-2083158198
Safety,recover,recovered,"consider the tilted bottom boundary layer example: https://clima.github.io/OceananigansDocumentation/stable/literated/tilted_bottom_boundary_layer/. In this problem, the buoyancy is decomposed ($b=\bar{b} + b^{\prime}$) into a background component $\bar{b} = N^{2} \hat{z}$ (where $\hat{z}$ is positive in the direction opposite the gravitational vector) and the remaining perturbation. The current example script applies no boundary conditions to the perturbation buoyancy, which I believe defaults to a no-normal-flux condition at the top and bottom boundary. Because no boundary conditions are applied to the background field, there is an implied diffusive flux $\hat{\mathbf{n}} \cdot (-\kappa \nabla \bar{b}) = ±\kappa N^{2} \cos{\theta}$ across these boundaries. This means that the boundary condition on the total buoyancy is a non-zero flux across the seafloor, which does not make much sense for this problem. The normal way of implementing this problem is to apply a gradient boundary condition, $\frac{\partial b^{\prime}}{\partial z} = -N^{2}\cos{\theta}$, at the bottom, to impose the no-flux condition. (In my MITgcm configurations, I verified that implementing the boundary condition this way recovered the classical analytical solutions of [Garrett et al. 1993](https://www.annualreviews.org/doi/10.1146/annurev.fl.25.010193.001451). Here is [another example using Dedalus](https://github.com/hdrake/bmli-linear/blob/main/examples/evp_replicate_Wenegrat2018_growth_rates.ipynb) to replicate some of Jacob Wenegrat's results, where I also include a non-zero gradient boundary condition on the perturbation buoyancy to impose no flux on the total buoyancy.). I understand why one might want background fields to be constructed a certain way for idealized problems, but it should be communicated clearly (and consistently) to the user exactly how this works. Is the tilted bottom boundary layer example incorrectly implemented or do I still not understand how the background fields work?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3568#issuecomment-2083158198
Usability,clear,clearly,"consider the tilted bottom boundary layer example: https://clima.github.io/OceananigansDocumentation/stable/literated/tilted_bottom_boundary_layer/. In this problem, the buoyancy is decomposed ($b=\bar{b} + b^{\prime}$) into a background component $\bar{b} = N^{2} \hat{z}$ (where $\hat{z}$ is positive in the direction opposite the gravitational vector) and the remaining perturbation. The current example script applies no boundary conditions to the perturbation buoyancy, which I believe defaults to a no-normal-flux condition at the top and bottom boundary. Because no boundary conditions are applied to the background field, there is an implied diffusive flux $\hat{\mathbf{n}} \cdot (-\kappa \nabla \bar{b}) = ±\kappa N^{2} \cos{\theta}$ across these boundaries. This means that the boundary condition on the total buoyancy is a non-zero flux across the seafloor, which does not make much sense for this problem. The normal way of implementing this problem is to apply a gradient boundary condition, $\frac{\partial b^{\prime}}{\partial z} = -N^{2}\cos{\theta}$, at the bottom, to impose the no-flux condition. (In my MITgcm configurations, I verified that implementing the boundary condition this way recovered the classical analytical solutions of [Garrett et al. 1993](https://www.annualreviews.org/doi/10.1146/annurev.fl.25.010193.001451). Here is [another example using Dedalus](https://github.com/hdrake/bmli-linear/blob/main/examples/evp_replicate_Wenegrat2018_growth_rates.ipynb) to replicate some of Jacob Wenegrat's results, where I also include a non-zero gradient boundary condition on the perturbation buoyancy to impose no flux on the total buoyancy.). I understand why one might want background fields to be constructed a certain way for idealized problems, but it should be communicated clearly (and consistently) to the user exactly how this works. Is the tilted bottom boundary layer example incorrectly implemented or do I still not understand how the background fields work?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3568#issuecomment-2083158198
Usability,clear,clearly,"> I understand why one might want background fields to be constructed a certain way for idealized problems, but it should be communicated clearly (and consistently) to the user exactly how this works. This doesn't really need to be said! Of course, we want to be both clear, and consistent. Otherwise what are we doing here?. I'm not sure where the communication is inconsistent but please fix anything that's wrong. As for clarity, we can add a line to the page on background fields:. https://clima.github.io/OceananigansDocumentation/stable/model_setup/background_fields/. that says something like ""note that boundary conditions apply to the perturbation fields"". As for a convenience feature that applies boundary conditions to the _total_ rather than the perturbation fields: this would be a bit of work. It has seemed to me unnecessary, since if you know what the background fields are, you can apply any boundary condition you like to the perturbations. But convenience is laudable and friendly of course so we can consider it. I think we have to pass the background fields deep into `fill_halo_regions!` so that, eventually when halos are computed for `Gradient` or `Value` boundary conditions, the contribution of the background field can be included.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3568#issuecomment-2083499387
Usability,clear,clearer,"> > As for clarity, we can add a line to the page on background fields:; > > https://clima.github.io/OceananigansDocumentation/stable/model_setup/background_fields/; > > that says something like ""note that boundary conditions apply to the perturbation fields"".; > ; > Yes, I think that would suffice (even though it might be obvious to some). Very little is obvious I think. This is a great addition. Just to give a little context --- background fields were easy to add, so I put them in! But I don't use them for my work. I wrote up some basic documentation, but it is not meant to be the Final World by any means. Please feel free to contribute docs. I think an example could be pretty helpful too, showing the decomposition of a field into background and perturbation, then deriving boundary conditions on the perturbation and implementing that. That would be an awesome pedagogical example for the docs. The tilted bottom boundary layer example should also be made clearer if that's possible. We can also change the functionality, ie how boundary conditions work. But some feature additions might be really invasive to the source code, so there's always a balance to be weighed. It seems at the end of the day it's always pretty important to be hyperintentional about setting up a particular problem, studying the docs and studying the equations you are trying to solve in order to make sure that the simulated problem is what's intended.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3568#issuecomment-2083752113
Modifiability,evolve,evolves,"Hmm, I think perhaps the mean buoyancy actually has to include an additional component that evolves (in addition to the static background component) which is independent of $x$ (upslope coordinate) but maybe varies in $z$ (slope-normal coordinate), right?. It sounds like what that example needs is to include a derivation of the equations we want to solve + boundary conditions, and then to impose intended boundary conditions (whatever those need to be) consistent with the boundary conditions that we'd like to impose on the total (non-decomposed) problem?. Edit: I noticed that you suggested modifying the boundary conditions in the tilted bottom boundary layer problem. My only suggestion is to also include a write up of the equations and a reference to the docs equations, that will make it clear the precise connection between the ""original"" equations and the perturbation equations that have to be solved by Oceananigans to achieve the desired goal.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3568#issuecomment-2083765467
Usability,clear,clear,"Hmm, I think perhaps the mean buoyancy actually has to include an additional component that evolves (in addition to the static background component) which is independent of $x$ (upslope coordinate) but maybe varies in $z$ (slope-normal coordinate), right?. It sounds like what that example needs is to include a derivation of the equations we want to solve + boundary conditions, and then to impose intended boundary conditions (whatever those need to be) consistent with the boundary conditions that we'd like to impose on the total (non-decomposed) problem?. Edit: I noticed that you suggested modifying the boundary conditions in the tilted bottom boundary layer problem. My only suggestion is to also include a write up of the equations and a reference to the docs equations, that will make it clear the precise connection between the ""original"" equations and the perturbation equations that have to be solved by Oceananigans to achieve the desired goal.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3568#issuecomment-2083765467
Usability,simpl,simple,"> I propose two changes:; > ; > 1. An example that re-implements the existing 1D diffusion example but with a background field (modifying the boundary conditions on the perturbations to make the two exactly equivalent). @liuchihl, this would be a great first contribution for you; > 2. Correction to the boundary condition in the present tilted geometry example. I am working on this now. Do we need both of those examples? I only ask because examples are a little expensive, both computationally (they have to run in CI) and also because they have to be maintained. So we want every ""example"" to present significant value... . An alternative is to put the 1D example somewhere else, perhaps just a very simple illustration in the docs for background field (that could just be a short write up, then, rather than a full blown example). The 1D and 2D cases are basically the same in terms of boundary conditions right?. Open to various things but just wanted to raise that point since we have tried to be very selective about examples in the past (and we are still very short on examples for they hydrostatic model + immersed boundaries). I also want to build out a much larger selection of simulation examples here: https://github.com/glwagner/AwesomeOceananigans but progress is slow...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3568#issuecomment-2083782941
Usability,simpl,simple,Good point. A simple illustration in the docs for background field will suffice.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3568#issuecomment-2083918174
Usability,simpl,simpler,"@navidcy, the title's been fixed and the issue identified with @glwagner. It's been resolved in commit [bbfc656](https://github.com/CliMA/Oceananigans.jl/pull/3573/commits/bbfc656582689e35256f0f3f8f93e98c2479c810). Regarding your earlier query, the output of `Hc, Nc, Nz = grid.Hx, grid.Nx, grid.Nz` should be `(3, 3, 1)` rather than `(2, 4, 1)`. Initially, I used a `ConformalCubedSphereGrid` with `panel_size = (4, 4, 1)` and `horizontal_direction_halo = 2`, but later switched to a simpler `RectilinearGrid` with `size = (3, 3, 1)` and overlooked updating the line you referenced in the MWE.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3572#issuecomment-2088808432
Usability,learn,learnt,"> @siddharthabishnu, just copy-paste the input and output from the REPL directly. Don't edit the code snippet otherwise there is the danger of making a typo/mistake. Agreed. I learnt that the hard way. I won't do it in the future.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3572#issuecomment-2090630395
Modifiability,extend,extend-parent-indices,"Might be good to add a test (or more than just one) for windowed fields. Even a simple one like. ```julia; windowed_field = CenterField(grid, indices=(:, :, 1:1)); @test view(windowed_field, :, :, 1:1) isa AbstractArray; ```. or something. @siddharthabishnu can you add that? Pretty basic test so probably belongs in `test_field.jl`:. https://github.com/CliMA/Oceananigans.jl/blob/sb/extend-parent-indices/test/test_field.jl",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3573#issuecomment-2088811397
Testability,test,test,"Might be good to add a test (or more than just one) for windowed fields. Even a simple one like. ```julia; windowed_field = CenterField(grid, indices=(:, :, 1:1)); @test view(windowed_field, :, :, 1:1) isa AbstractArray; ```. or something. @siddharthabishnu can you add that? Pretty basic test so probably belongs in `test_field.jl`:. https://github.com/CliMA/Oceananigans.jl/blob/sb/extend-parent-indices/test/test_field.jl",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3573#issuecomment-2088811397
Usability,simpl,simple,"Might be good to add a test (or more than just one) for windowed fields. Even a simple one like. ```julia; windowed_field = CenterField(grid, indices=(:, :, 1:1)); @test view(windowed_field, :, :, 1:1) isa AbstractArray; ```. or something. @siddharthabishnu can you add that? Pretty basic test so probably belongs in `test_field.jl`:. https://github.com/CliMA/Oceananigans.jl/blob/sb/extend-parent-indices/test/test_field.jl",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3573#issuecomment-2088811397
Availability,error,error,"@siddharthabishnu could you help by adding some simple unit tests for views of views? It'd be nice to test correctness, I think something like this would work:. ```julia; grid = RectilinearGrid(size=(1, 1, 3), x=(0, 1), y=(0, 1), z=(0, 1)); c = CenterField(grid); set!(c, (x, y, z) -> rand()). # First test that regular view is right; cv = view(c, :, :, 2:3); @test c[1, 1, 2] == cv[1, 1, 2]; @test c[1, 1, 3] == cv[1, 1, 3]. # Now test views of views; cvv = view(cv, :, :, 3); @test cv[1, 1, 3] == cvv[1, 1, 3]; ```. We may also want to test that things error correctly like. ```julia; julia> view(cv, :, :, 1); ERROR: ArgumentError: view indices (Colon(), Colon(), 1) do not intersect field indices (Colon(), Colon(), 2:3); Stacktrace:; [1] view(f::Field{…}, i::Function, j::Function, k::Int64); @ Oceananigans.Fields ~/Projects/dev/Oceananigans.jl/src/Fields/field.jl:315; [2] top-level scope; @ REPL[25]:1; Some type information was truncated. Use `show(err)` to see complete types.; ```. Maybe. ```julia; @test_throws ArgumentError view(cv, :, :, 1); ```. Not sure what else we might want maybe @navidcy has ideas.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3573#issuecomment-2091009630
Testability,test,tests,"@siddharthabishnu could you help by adding some simple unit tests for views of views? It'd be nice to test correctness, I think something like this would work:. ```julia; grid = RectilinearGrid(size=(1, 1, 3), x=(0, 1), y=(0, 1), z=(0, 1)); c = CenterField(grid); set!(c, (x, y, z) -> rand()). # First test that regular view is right; cv = view(c, :, :, 2:3); @test c[1, 1, 2] == cv[1, 1, 2]; @test c[1, 1, 3] == cv[1, 1, 3]. # Now test views of views; cvv = view(cv, :, :, 3); @test cv[1, 1, 3] == cvv[1, 1, 3]; ```. We may also want to test that things error correctly like. ```julia; julia> view(cv, :, :, 1); ERROR: ArgumentError: view indices (Colon(), Colon(), 1) do not intersect field indices (Colon(), Colon(), 2:3); Stacktrace:; [1] view(f::Field{…}, i::Function, j::Function, k::Int64); @ Oceananigans.Fields ~/Projects/dev/Oceananigans.jl/src/Fields/field.jl:315; [2] top-level scope; @ REPL[25]:1; Some type information was truncated. Use `show(err)` to see complete types.; ```. Maybe. ```julia; @test_throws ArgumentError view(cv, :, :, 1); ```. Not sure what else we might want maybe @navidcy has ideas.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3573#issuecomment-2091009630
Usability,simpl,simple,"@siddharthabishnu could you help by adding some simple unit tests for views of views? It'd be nice to test correctness, I think something like this would work:. ```julia; grid = RectilinearGrid(size=(1, 1, 3), x=(0, 1), y=(0, 1), z=(0, 1)); c = CenterField(grid); set!(c, (x, y, z) -> rand()). # First test that regular view is right; cv = view(c, :, :, 2:3); @test c[1, 1, 2] == cv[1, 1, 2]; @test c[1, 1, 3] == cv[1, 1, 3]. # Now test views of views; cvv = view(cv, :, :, 3); @test cv[1, 1, 3] == cvv[1, 1, 3]; ```. We may also want to test that things error correctly like. ```julia; julia> view(cv, :, :, 1); ERROR: ArgumentError: view indices (Colon(), Colon(), 1) do not intersect field indices (Colon(), Colon(), 2:3); Stacktrace:; [1] view(f::Field{…}, i::Function, j::Function, k::Int64); @ Oceananigans.Fields ~/Projects/dev/Oceananigans.jl/src/Fields/field.jl:315; [2] top-level scope; @ REPL[25]:1; Some type information was truncated. Use `show(err)` to see complete types.; ```. Maybe. ```julia; @test_throws ArgumentError view(cv, :, :, 1); ```. Not sure what else we might want maybe @navidcy has ideas.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3573#issuecomment-2091009630
Usability,intuit,intuitive,"This is looking pretty good! My only comment is that it's not intuitive for a given user to figure out how to opt for a hydrostatic pressure separation. A flag called `separate_hydrostatic_pressure` that takes `true`/`false` would be much more intuitive, although we'd need a little more code. Should we prioritize user-friendliness here?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3574#issuecomment-2088669067
Modifiability,flexible,flexible,"> This is looking pretty good! My only comment is that it's not intuitive for a given user to figure out how to opt for a hydrostatic pressure separation. A flag called `separate_hydrostatic_pressure` that takes `true`/`false` would be much more intuitive, although we'd need a little more code. Should we prioritize user-friendliness here?. This is more flexible, because sometimes users want to have access to the pressure field prior to model construction. If we use a flag, then we either can't support that or have to put some annoying logic in the constructor. Since I feel it'll be rare that people want to change this kwarg, I think the trade-offs work out that its better to have a simpler constructor even if those rare users that want to separate hydrostatic pressure have to build `CenterField`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3574#issuecomment-2088676711
Security,access,access,"> This is looking pretty good! My only comment is that it's not intuitive for a given user to figure out how to opt for a hydrostatic pressure separation. A flag called `separate_hydrostatic_pressure` that takes `true`/`false` would be much more intuitive, although we'd need a little more code. Should we prioritize user-friendliness here?. This is more flexible, because sometimes users want to have access to the pressure field prior to model construction. If we use a flag, then we either can't support that or have to put some annoying logic in the constructor. Since I feel it'll be rare that people want to change this kwarg, I think the trade-offs work out that its better to have a simpler constructor even if those rare users that want to separate hydrostatic pressure have to build `CenterField`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3574#issuecomment-2088676711
Testability,log,logic,"> This is looking pretty good! My only comment is that it's not intuitive for a given user to figure out how to opt for a hydrostatic pressure separation. A flag called `separate_hydrostatic_pressure` that takes `true`/`false` would be much more intuitive, although we'd need a little more code. Should we prioritize user-friendliness here?. This is more flexible, because sometimes users want to have access to the pressure field prior to model construction. If we use a flag, then we either can't support that or have to put some annoying logic in the constructor. Since I feel it'll be rare that people want to change this kwarg, I think the trade-offs work out that its better to have a simpler constructor even if those rare users that want to separate hydrostatic pressure have to build `CenterField`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3574#issuecomment-2088676711
Usability,intuit,intuitive,"> This is looking pretty good! My only comment is that it's not intuitive for a given user to figure out how to opt for a hydrostatic pressure separation. A flag called `separate_hydrostatic_pressure` that takes `true`/`false` would be much more intuitive, although we'd need a little more code. Should we prioritize user-friendliness here?. This is more flexible, because sometimes users want to have access to the pressure field prior to model construction. If we use a flag, then we either can't support that or have to put some annoying logic in the constructor. Since I feel it'll be rare that people want to change this kwarg, I think the trade-offs work out that its better to have a simpler constructor even if those rare users that want to separate hydrostatic pressure have to build `CenterField`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3574#issuecomment-2088676711
Availability,error,error,"> > This is looking pretty good! My only comment is that it's not intuitive for a given user to figure out how to opt for a hydrostatic pressure separation. A flag called `separate_hydrostatic_pressure` that takes `true`/`false` would be much more intuitive, although we'd need a little more code. Should we prioritize user-friendliness here?; > ; > This is more flexible, because sometimes users want to have access to the pressure field prior to model construction. If we use a flag, then we either can't support that or have to put some annoying logic in the constructor. Since I feel it'll be rare that people want to change this kwarg, I think the trade-offs work out that its better to have a simpler constructor even if those rare users that want to separate hydrostatic pressure have to build `CenterField`. Got it! Agreed. Should we test that `hydrostatic_pressure_anomaly` is either `CenterField(grid)` or `nothing` and throw a helpful error otherwise?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3574#issuecomment-2088696540
Modifiability,flexible,flexible,"> > This is looking pretty good! My only comment is that it's not intuitive for a given user to figure out how to opt for a hydrostatic pressure separation. A flag called `separate_hydrostatic_pressure` that takes `true`/`false` would be much more intuitive, although we'd need a little more code. Should we prioritize user-friendliness here?; > ; > This is more flexible, because sometimes users want to have access to the pressure field prior to model construction. If we use a flag, then we either can't support that or have to put some annoying logic in the constructor. Since I feel it'll be rare that people want to change this kwarg, I think the trade-offs work out that its better to have a simpler constructor even if those rare users that want to separate hydrostatic pressure have to build `CenterField`. Got it! Agreed. Should we test that `hydrostatic_pressure_anomaly` is either `CenterField(grid)` or `nothing` and throw a helpful error otherwise?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3574#issuecomment-2088696540
Security,access,access,"> > This is looking pretty good! My only comment is that it's not intuitive for a given user to figure out how to opt for a hydrostatic pressure separation. A flag called `separate_hydrostatic_pressure` that takes `true`/`false` would be much more intuitive, although we'd need a little more code. Should we prioritize user-friendliness here?; > ; > This is more flexible, because sometimes users want to have access to the pressure field prior to model construction. If we use a flag, then we either can't support that or have to put some annoying logic in the constructor. Since I feel it'll be rare that people want to change this kwarg, I think the trade-offs work out that its better to have a simpler constructor even if those rare users that want to separate hydrostatic pressure have to build `CenterField`. Got it! Agreed. Should we test that `hydrostatic_pressure_anomaly` is either `CenterField(grid)` or `nothing` and throw a helpful error otherwise?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3574#issuecomment-2088696540
Testability,log,logic,"> > This is looking pretty good! My only comment is that it's not intuitive for a given user to figure out how to opt for a hydrostatic pressure separation. A flag called `separate_hydrostatic_pressure` that takes `true`/`false` would be much more intuitive, although we'd need a little more code. Should we prioritize user-friendliness here?; > ; > This is more flexible, because sometimes users want to have access to the pressure field prior to model construction. If we use a flag, then we either can't support that or have to put some annoying logic in the constructor. Since I feel it'll be rare that people want to change this kwarg, I think the trade-offs work out that its better to have a simpler constructor even if those rare users that want to separate hydrostatic pressure have to build `CenterField`. Got it! Agreed. Should we test that `hydrostatic_pressure_anomaly` is either `CenterField(grid)` or `nothing` and throw a helpful error otherwise?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3574#issuecomment-2088696540
Usability,intuit,intuitive,"> > This is looking pretty good! My only comment is that it's not intuitive for a given user to figure out how to opt for a hydrostatic pressure separation. A flag called `separate_hydrostatic_pressure` that takes `true`/`false` would be much more intuitive, although we'd need a little more code. Should we prioritize user-friendliness here?; > ; > This is more flexible, because sometimes users want to have access to the pressure field prior to model construction. If we use a flag, then we either can't support that or have to put some annoying logic in the constructor. Since I feel it'll be rare that people want to change this kwarg, I think the trade-offs work out that its better to have a simpler constructor even if those rare users that want to separate hydrostatic pressure have to build `CenterField`. Got it! Agreed. Should we test that `hydrostatic_pressure_anomaly` is either `CenterField(grid)` or `nothing` and throw a helpful error otherwise?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3574#issuecomment-2088696540
Availability,error,error,"> > > This is looking pretty good! My only comment is that it's not intuitive for a given user to figure out how to opt for a hydrostatic pressure separation. A flag called `separate_hydrostatic_pressure` that takes `true`/`false` would be much more intuitive, although we'd need a little more code. Should we prioritize user-friendliness here?; > > ; > > ; > > This is more flexible, because sometimes users want to have access to the pressure field prior to model construction. If we use a flag, then we either can't support that or have to put some annoying logic in the constructor. Since I feel it'll be rare that people want to change this kwarg, I think the trade-offs work out that its better to have a simpler constructor even if those rare users that want to separate hydrostatic pressure have to build `CenterField`.; > ; > Got it! Agreed. Should we test that `hydrostatic_pressure_anomaly` is either `CenterField(grid)` or `nothing` and throw a helpful error otherwise?. Sure.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3574#issuecomment-2088747422
Modifiability,flexible,flexible,"> > > This is looking pretty good! My only comment is that it's not intuitive for a given user to figure out how to opt for a hydrostatic pressure separation. A flag called `separate_hydrostatic_pressure` that takes `true`/`false` would be much more intuitive, although we'd need a little more code. Should we prioritize user-friendliness here?; > > ; > > ; > > This is more flexible, because sometimes users want to have access to the pressure field prior to model construction. If we use a flag, then we either can't support that or have to put some annoying logic in the constructor. Since I feel it'll be rare that people want to change this kwarg, I think the trade-offs work out that its better to have a simpler constructor even if those rare users that want to separate hydrostatic pressure have to build `CenterField`.; > ; > Got it! Agreed. Should we test that `hydrostatic_pressure_anomaly` is either `CenterField(grid)` or `nothing` and throw a helpful error otherwise?. Sure.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3574#issuecomment-2088747422
Security,access,access,"> > > This is looking pretty good! My only comment is that it's not intuitive for a given user to figure out how to opt for a hydrostatic pressure separation. A flag called `separate_hydrostatic_pressure` that takes `true`/`false` would be much more intuitive, although we'd need a little more code. Should we prioritize user-friendliness here?; > > ; > > ; > > This is more flexible, because sometimes users want to have access to the pressure field prior to model construction. If we use a flag, then we either can't support that or have to put some annoying logic in the constructor. Since I feel it'll be rare that people want to change this kwarg, I think the trade-offs work out that its better to have a simpler constructor even if those rare users that want to separate hydrostatic pressure have to build `CenterField`.; > ; > Got it! Agreed. Should we test that `hydrostatic_pressure_anomaly` is either `CenterField(grid)` or `nothing` and throw a helpful error otherwise?. Sure.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3574#issuecomment-2088747422
Testability,log,logic,"> > > This is looking pretty good! My only comment is that it's not intuitive for a given user to figure out how to opt for a hydrostatic pressure separation. A flag called `separate_hydrostatic_pressure` that takes `true`/`false` would be much more intuitive, although we'd need a little more code. Should we prioritize user-friendliness here?; > > ; > > ; > > This is more flexible, because sometimes users want to have access to the pressure field prior to model construction. If we use a flag, then we either can't support that or have to put some annoying logic in the constructor. Since I feel it'll be rare that people want to change this kwarg, I think the trade-offs work out that its better to have a simpler constructor even if those rare users that want to separate hydrostatic pressure have to build `CenterField`.; > ; > Got it! Agreed. Should we test that `hydrostatic_pressure_anomaly` is either `CenterField(grid)` or `nothing` and throw a helpful error otherwise?. Sure.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3574#issuecomment-2088747422
Usability,intuit,intuitive,"> > > This is looking pretty good! My only comment is that it's not intuitive for a given user to figure out how to opt for a hydrostatic pressure separation. A flag called `separate_hydrostatic_pressure` that takes `true`/`false` would be much more intuitive, although we'd need a little more code. Should we prioritize user-friendliness here?; > > ; > > ; > > This is more flexible, because sometimes users want to have access to the pressure field prior to model construction. If we use a flag, then we either can't support that or have to put some annoying logic in the constructor. Since I feel it'll be rare that people want to change this kwarg, I think the trade-offs work out that its better to have a simpler constructor even if those rare users that want to separate hydrostatic pressure have to build `CenterField`.; > ; > Got it! Agreed. Should we test that `hydrostatic_pressure_anomaly` is either `CenterField(grid)` or `nothing` and throw a helpful error otherwise?. Sure.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3574#issuecomment-2088747422
Modifiability,refactor,refactor,"> I wasn't specific about time because I wasn't sure. I often find myself spending way longer on PRs than I initially anticipate so I'm generally not very good at assessing these things lol. ok ok! Here's a rule of thumb: a bugfix or refactor is the least committment, because you can get away with no new tests or docs. A new _feature_ takes more time because of documentation. One should expect to spend most of their time on docs and tests. If you're spending a lot of time implementing a feature, then either the feature is very complicated / hard, or your workflow can use some improvement. Among new features, different types of features require different amount of effort. This case is one of the easier cases --- it's extending functionality without changing existing functionality, also its fairly niche (at this point) so simple documentation will suffice. The work required to test the feature also has already been partially completed (the script you posted). Other features, like adding new _physics_ will take much longer, because often you'll have to run a full validation case + analysis to assess whether things work as expected. So even if the source code change is small to implement new physics, the validation will take a while and dominate the development effort. If a new feature also requires changing existing functionality / refactoring, that's going to take the most amount of time, because you will probably also have to change existing tests. And many tests are poorly written, so updating test code is a potential rabbit hole.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3576#issuecomment-2093480258
Security,validat,validation,"> I wasn't specific about time because I wasn't sure. I often find myself spending way longer on PRs than I initially anticipate so I'm generally not very good at assessing these things lol. ok ok! Here's a rule of thumb: a bugfix or refactor is the least committment, because you can get away with no new tests or docs. A new _feature_ takes more time because of documentation. One should expect to spend most of their time on docs and tests. If you're spending a lot of time implementing a feature, then either the feature is very complicated / hard, or your workflow can use some improvement. Among new features, different types of features require different amount of effort. This case is one of the easier cases --- it's extending functionality without changing existing functionality, also its fairly niche (at this point) so simple documentation will suffice. The work required to test the feature also has already been partially completed (the script you posted). Other features, like adding new _physics_ will take much longer, because often you'll have to run a full validation case + analysis to assess whether things work as expected. So even if the source code change is small to implement new physics, the validation will take a while and dominate the development effort. If a new feature also requires changing existing functionality / refactoring, that's going to take the most amount of time, because you will probably also have to change existing tests. And many tests are poorly written, so updating test code is a potential rabbit hole.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3576#issuecomment-2093480258
Testability,test,tests,"> I wasn't specific about time because I wasn't sure. I often find myself spending way longer on PRs than I initially anticipate so I'm generally not very good at assessing these things lol. ok ok! Here's a rule of thumb: a bugfix or refactor is the least committment, because you can get away with no new tests or docs. A new _feature_ takes more time because of documentation. One should expect to spend most of their time on docs and tests. If you're spending a lot of time implementing a feature, then either the feature is very complicated / hard, or your workflow can use some improvement. Among new features, different types of features require different amount of effort. This case is one of the easier cases --- it's extending functionality without changing existing functionality, also its fairly niche (at this point) so simple documentation will suffice. The work required to test the feature also has already been partially completed (the script you posted). Other features, like adding new _physics_ will take much longer, because often you'll have to run a full validation case + analysis to assess whether things work as expected. So even if the source code change is small to implement new physics, the validation will take a while and dominate the development effort. If a new feature also requires changing existing functionality / refactoring, that's going to take the most amount of time, because you will probably also have to change existing tests. And many tests are poorly written, so updating test code is a potential rabbit hole.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3576#issuecomment-2093480258
Usability,simpl,simple,"> I wasn't specific about time because I wasn't sure. I often find myself spending way longer on PRs than I initially anticipate so I'm generally not very good at assessing these things lol. ok ok! Here's a rule of thumb: a bugfix or refactor is the least committment, because you can get away with no new tests or docs. A new _feature_ takes more time because of documentation. One should expect to spend most of their time on docs and tests. If you're spending a lot of time implementing a feature, then either the feature is very complicated / hard, or your workflow can use some improvement. Among new features, different types of features require different amount of effort. This case is one of the easier cases --- it's extending functionality without changing existing functionality, also its fairly niche (at this point) so simple documentation will suffice. The work required to test the feature also has already been partially completed (the script you posted). Other features, like adding new _physics_ will take much longer, because often you'll have to run a full validation case + analysis to assess whether things work as expected. So even if the source code change is small to implement new physics, the validation will take a while and dominate the development effort. If a new feature also requires changing existing functionality / refactoring, that's going to take the most amount of time, because you will probably also have to change existing tests. And many tests are poorly written, so updating test code is a potential rabbit hole.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3576#issuecomment-2093480258
Availability,down,down,"he source code. As for the source code and the topic of this issue, I think it will be generally impossible to include the diffusivity fields in the model fields. First of all, closures and diffusivity fields can be user defined. We want people to be free to do creative things in closure design without having to worry about whether trying to merge the diffusivity fields into `model_fields` will cause their model to fail to compile, preventing them from doing work. However, it might be possible to ""whitelist"" some fields when the situation calls for it, like the eddy diffusivities in LES closures. For that we need to introduce a new function, something like `nonhydrostatic_fields` (mirroring the `hydrostatic_fields` we have now for the `HydrostaticFreeSurfaceModel`) which, unlike `fields`, is more low-level and not user facing. Then this function can be designed to take `closure` as an argument to support the inclusion of diffusivity fields where appropriate, something like. ```julia; @inline nonhydrostatic_model_fields(closure, velocities, tracers, aux_fields, diffusivity_fields) =; merge(velocities, tracers, aux_fields) # fallback. @inline nonhydrostatic_model_fields(::SmagorinskyLilly, velocities, tracers, aux_fields, diffusivity_fields) =; merge(velocities, tracers, aux_fields, (; νₑ=diffusivity_fields.νₑ)) # desired behavior; ```. then we can use that in the tendency kernel functions. I think this would probably succeed because we can simply omit the closures with too-complex diffusivity fields. It might require a bit more work for closure tuples though. It's an interesting idea for a contribution. But note that the current ways to solve this problem (creating a new field for the forcing, and then utilizing callbacks to compute the needed field during time stepping) are fairly straightforward and also generalize to much more complex situations that I'm not sure it makes sense to go down the rabbit hole of extending `model_fields` to cover more exotic situations.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3582#issuecomment-2095180262
Modifiability,extend,extending,"he source code. As for the source code and the topic of this issue, I think it will be generally impossible to include the diffusivity fields in the model fields. First of all, closures and diffusivity fields can be user defined. We want people to be free to do creative things in closure design without having to worry about whether trying to merge the diffusivity fields into `model_fields` will cause their model to fail to compile, preventing them from doing work. However, it might be possible to ""whitelist"" some fields when the situation calls for it, like the eddy diffusivities in LES closures. For that we need to introduce a new function, something like `nonhydrostatic_fields` (mirroring the `hydrostatic_fields` we have now for the `HydrostaticFreeSurfaceModel`) which, unlike `fields`, is more low-level and not user facing. Then this function can be designed to take `closure` as an argument to support the inclusion of diffusivity fields where appropriate, something like. ```julia; @inline nonhydrostatic_model_fields(closure, velocities, tracers, aux_fields, diffusivity_fields) =; merge(velocities, tracers, aux_fields) # fallback. @inline nonhydrostatic_model_fields(::SmagorinskyLilly, velocities, tracers, aux_fields, diffusivity_fields) =; merge(velocities, tracers, aux_fields, (; νₑ=diffusivity_fields.νₑ)) # desired behavior; ```. then we can use that in the tendency kernel functions. I think this would probably succeed because we can simply omit the closures with too-complex diffusivity fields. It might require a bit more work for closure tuples though. It's an interesting idea for a contribution. But note that the current ways to solve this problem (creating a new field for the forcing, and then utilizing callbacks to compute the needed field during time stepping) are fairly straightforward and also generalize to much more complex situations that I'm not sure it makes sense to go down the rabbit hole of extending `model_fields` to cover more exotic situations.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3582#issuecomment-2095180262
Usability,simpl,simply,"he source code. As for the source code and the topic of this issue, I think it will be generally impossible to include the diffusivity fields in the model fields. First of all, closures and diffusivity fields can be user defined. We want people to be free to do creative things in closure design without having to worry about whether trying to merge the diffusivity fields into `model_fields` will cause their model to fail to compile, preventing them from doing work. However, it might be possible to ""whitelist"" some fields when the situation calls for it, like the eddy diffusivities in LES closures. For that we need to introduce a new function, something like `nonhydrostatic_fields` (mirroring the `hydrostatic_fields` we have now for the `HydrostaticFreeSurfaceModel`) which, unlike `fields`, is more low-level and not user facing. Then this function can be designed to take `closure` as an argument to support the inclusion of diffusivity fields where appropriate, something like. ```julia; @inline nonhydrostatic_model_fields(closure, velocities, tracers, aux_fields, diffusivity_fields) =; merge(velocities, tracers, aux_fields) # fallback. @inline nonhydrostatic_model_fields(::SmagorinskyLilly, velocities, tracers, aux_fields, diffusivity_fields) =; merge(velocities, tracers, aux_fields, (; νₑ=diffusivity_fields.νₑ)) # desired behavior; ```. then we can use that in the tendency kernel functions. I think this would probably succeed because we can simply omit the closures with too-complex diffusivity fields. It might require a bit more work for closure tuples though. It's an interesting idea for a contribution. But note that the current ways to solve this problem (creating a new field for the forcing, and then utilizing callbacks to compute the needed field during time stepping) are fairly straightforward and also generalize to much more complex situations that I'm not sure it makes sense to go down the rabbit hole of extending `model_fields` to cover more exotic situations.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3582#issuecomment-2095180262
Energy Efficiency,reduce,reduced,"The problem is not with the reduction but with derivatives that act on reduced fields.; The reductions are not an issue, because by performing a reduction we know what operation leads us to a reduced field, so we can perform the reduction accordingly (for example we exclude immersed cells from reductions). . When performing a derivative we use all three indices regardless of the field being reduced or not. ; In this case we get a funky result where we are trying to evaluate a derivative at `k == 1` for a reduced field that does not necessarily live at `k == 1`. In other words, the assumption that the field lives at `k == 1` is wrong for a reduced field; the right solution, on the other hand, is not so clear cut:. If we assume that reduced fields ""lives"" nowhere in the reduced direction, then we can remove the k index and just perform an ""immersed-boundary-unaware"" derivative. On the other hand, if the reduced field lives on the whole reduced column (like for example an integral) then we need to be aware of the ""immersed column"", because if the whole column is immersed then the derivative should return a zero.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3588#issuecomment-2097124708
Performance,perform,performing,"The problem is not with the reduction but with derivatives that act on reduced fields.; The reductions are not an issue, because by performing a reduction we know what operation leads us to a reduced field, so we can perform the reduction accordingly (for example we exclude immersed cells from reductions). . When performing a derivative we use all three indices regardless of the field being reduced or not. ; In this case we get a funky result where we are trying to evaluate a derivative at `k == 1` for a reduced field that does not necessarily live at `k == 1`. In other words, the assumption that the field lives at `k == 1` is wrong for a reduced field; the right solution, on the other hand, is not so clear cut:. If we assume that reduced fields ""lives"" nowhere in the reduced direction, then we can remove the k index and just perform an ""immersed-boundary-unaware"" derivative. On the other hand, if the reduced field lives on the whole reduced column (like for example an integral) then we need to be aware of the ""immersed column"", because if the whole column is immersed then the derivative should return a zero.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3588#issuecomment-2097124708
Usability,clear,clear,"The problem is not with the reduction but with derivatives that act on reduced fields.; The reductions are not an issue, because by performing a reduction we know what operation leads us to a reduced field, so we can perform the reduction accordingly (for example we exclude immersed cells from reductions). . When performing a derivative we use all three indices regardless of the field being reduced or not. ; In this case we get a funky result where we are trying to evaluate a derivative at `k == 1` for a reduced field that does not necessarily live at `k == 1`. In other words, the assumption that the field lives at `k == 1` is wrong for a reduced field; the right solution, on the other hand, is not so clear cut:. If we assume that reduced fields ""lives"" nowhere in the reduced direction, then we can remove the k index and just perform an ""immersed-boundary-unaware"" derivative. On the other hand, if the reduced field lives on the whole reduced column (like for example an integral) then we need to be aware of the ""immersed column"", because if the whole column is immersed then the derivative should return a zero.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3588#issuecomment-2097124708
Deployability,integrat,integration,"Isn't that a way to obtain the reverse cumulative integration by simply adding something?; Something like `cumint[end] - cumint + cumint[1]` ; I don't remember exactly, but I think that there is a way to do it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3590#issuecomment-2099027343
Integrability,integrat,integration,"Isn't that a way to obtain the reverse cumulative integration by simply adding something?; Something like `cumint[end] - cumint + cumint[1]` ; I don't remember exactly, but I think that there is a way to do it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3590#issuecomment-2099027343
Usability,simpl,simply,"Isn't that a way to obtain the reverse cumulative integration by simply adding something?; Something like `cumint[end] - cumint + cumint[1]` ; I don't remember exactly, but I think that there is a way to do it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3590#issuecomment-2099027343
Energy Efficiency,reduce,reduced,"Ok here's an idea: replace `Scan` with `Accumulation`. I think a sum can be thought of as ""accumulating"" without any leaps. We then would have _reducing_ accumulations (intermediate accumulations are not stored), and _cumulative_ accumulations (where the result is not reduced). We then have the mapping:. * `Scan` to `Accumulation`; * `Accumulation` to `Cumulation` (but we only really need the cumulative sum / integral anyways probably, so this need not be user facing anyways); * `Accumulating` to `Cumulating`. Honestly discussing this, the phrase ""cumulative sum"" is not the most clear, either. But, history.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3590#issuecomment-2104552538
Usability,clear,clear,"Ok here's an idea: replace `Scan` with `Accumulation`. I think a sum can be thought of as ""accumulating"" without any leaps. We then would have _reducing_ accumulations (intermediate accumulations are not stored), and _cumulative_ accumulations (where the result is not reduced). We then have the mapping:. * `Scan` to `Accumulation`; * `Accumulation` to `Cumulation` (but we only really need the cumulative sum / integral anyways probably, so this need not be user facing anyways); * `Accumulating` to `Cumulating`. Honestly discussing this, the phrase ""cumulative sum"" is not the most clear, either. But, history.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3590#issuecomment-2104552538
Availability,redundant,redundant,"I am not very familiar with this use of scan, and despite ""cumulative sum"" sounding redundant, it express to me better the idea that I am not simply summing all values of a series. I think that this is the reason why `cumsum` is so common.; I agree that we might not find a perfect word for that... haha; However, I was thinking that `CumulativeScan` also works. Scan gives this idea of an action moving through the series and Cumulative suggests that we are summing terms as we move through.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3590#issuecomment-2105535912
Safety,redund,redundant,"I am not very familiar with this use of scan, and despite ""cumulative sum"" sounding redundant, it express to me better the idea that I am not simply summing all values of a series. I think that this is the reason why `cumsum` is so common.; I agree that we might not find a perfect word for that... haha; However, I was thinking that `CumulativeScan` also works. Scan gives this idea of an action moving through the series and Cumulative suggests that we are summing terms as we move through.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3590#issuecomment-2105535912
Usability,simpl,simply,"I am not very familiar with this use of scan, and despite ""cumulative sum"" sounding redundant, it express to me better the idea that I am not simply summing all values of a series. I think that this is the reason why `cumsum` is so common.; I agree that we might not find a perfect word for that... haha; However, I was thinking that `CumulativeScan` also works. Scan gives this idea of an action moving through the series and Cumulative suggests that we are summing terms as we move through.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3590#issuecomment-2105535912
Usability,clear,clear,"Well to be clear, the name we are searching for is something that can describe _both_ reductions like sum, maximum, minimum (and average and integral, which are similar to sum but involve grid metrics) --- _and_ operations like cumsum. The things these have in common (in contrast to local operations like derivative, plus, minus, etc) is that they involve a loop over one or more dimensions (which is why they have a `dims` property) and therefore cannot be evaluated locally, they have to be precomputed. For example, we could envision also supporting `sort!` through the `Scan` abstraction... The key property of a reduction is that its output is _also_ lower dimensionality than the input, the `dims` are collapsed. On the other hand `sort!` and `cumsum!` have output with the same dimension as the input. So we need a few things to build the abstraction. First we need a name that encompasses reductions, plus cumsum and sort. Second, we need another pair of names that express the distinction between a ""reduction"" and a non-dimensionality-changing-yet-still-scanning operation like cumsum and sort. I meant the term ""scan"" simply to mean literally that we are going to traverse one or more dimensions (eg scanning the dimension). No doubt it can be improved but the improvement needs to be sufficiently general. that's the whole challenge",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3590#issuecomment-2108741773
Usability,clear,clearly,"> Interesting. You are plotting the pressure above. Is it possible to plot the components of the gradient of pressure?; > ; > The perssure is determined to within a constant and I am very curious to see of the pressure gradient also changes a lot. Yup, my first thought was that of the constant also. But as you can see in the snapshots, the gradient is also changing by a lot. Plus if it was only the constant that were changing, the std would remain the same, but it's clearly varying over many order of magnitude, which is why I didn't bother plotting the gradient in order to simplify diagnostics. In any case, here is dp/dx for the same simulation for future reference:. ![image](https://github.com/CliMA/Oceananigans.jl/assets/13205162/fab112af-795b-45f4-a788-3886227c3ff2)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3593#issuecomment-2102979711
Availability,error,error,"> > Does it have to do with output? Do you know what the time-step is when this happens?I'm wondering if it has to do with using a very small time-step, leading to a round-off error issue. That would also explain why it doesn't affect dynamics, because huge pressure gradient integrated over a machine epsilon duration may not have an impact.; > ; > Are you referring to the fact that sometimes `model` has to use a very tiny time-step to bridge the gap between the current time and the output time? If so, that's an interesting possibility that I hadn't considered. Although in the example above I'm fixing the time-step at `25`, while the output time interval is `200`, so I wouldn't expect any issues there. Can you check just to be sure? Because having an output interval that's some multiple of the time step is exactly when we expect to see miniscule time-steps due to round off error. The pressure source term is the divergence of the predictor velocity divided by time-step. As the time-step vanishes, the divergence of the predictor velocity also vanishes (because the flow has not evolved from its previous, non-divergent solution). We get a situation tending to 0/0. I think there's a few things we could do to solve this. First of all if we take a very small time-step, I think we can actually just re-set the model time rather than taking a time-step. Second I am wondering if we want to implement a time type that has finite resolution (ie there is a smallest time increment one can take). For example, datetimes have a smallest unit (micro or nanoseconds). A non-dimensional or dimensional-agnostic time type could also be designed analogously (eg every time is the multiple of an integer by the fundamental unit). This would eliminate round off error but it's a bit of work and also we have to put some thought into how best to accomplish it. There might also be a simpler solution by adjusting how we increment time. I'm not sure. > Also wouldn't that also affect simulations with `bu",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3593#issuecomment-2103013025
Deployability,integrat,integrated,"> > Does it have to do with output? Do you know what the time-step is when this happens?I'm wondering if it has to do with using a very small time-step, leading to a round-off error issue. That would also explain why it doesn't affect dynamics, because huge pressure gradient integrated over a machine epsilon duration may not have an impact.; > ; > Are you referring to the fact that sometimes `model` has to use a very tiny time-step to bridge the gap between the current time and the output time? If so, that's an interesting possibility that I hadn't considered. Although in the example above I'm fixing the time-step at `25`, while the output time interval is `200`, so I wouldn't expect any issues there. Can you check just to be sure? Because having an output interval that's some multiple of the time step is exactly when we expect to see miniscule time-steps due to round off error. The pressure source term is the divergence of the predictor velocity divided by time-step. As the time-step vanishes, the divergence of the predictor velocity also vanishes (because the flow has not evolved from its previous, non-divergent solution). We get a situation tending to 0/0. I think there's a few things we could do to solve this. First of all if we take a very small time-step, I think we can actually just re-set the model time rather than taking a time-step. Second I am wondering if we want to implement a time type that has finite resolution (ie there is a smallest time increment one can take). For example, datetimes have a smallest unit (micro or nanoseconds). A non-dimensional or dimensional-agnostic time type could also be designed analogously (eg every time is the multiple of an integer by the fundamental unit). This would eliminate round off error but it's a bit of work and also we have to put some thought into how best to accomplish it. There might also be a simpler solution by adjusting how we increment time. I'm not sure. > Also wouldn't that also affect simulations with `bu",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3593#issuecomment-2103013025
Integrability,integrat,integrated,"> > Does it have to do with output? Do you know what the time-step is when this happens?I'm wondering if it has to do with using a very small time-step, leading to a round-off error issue. That would also explain why it doesn't affect dynamics, because huge pressure gradient integrated over a machine epsilon duration may not have an impact.; > ; > Are you referring to the fact that sometimes `model` has to use a very tiny time-step to bridge the gap between the current time and the output time? If so, that's an interesting possibility that I hadn't considered. Although in the example above I'm fixing the time-step at `25`, while the output time interval is `200`, so I wouldn't expect any issues there. Can you check just to be sure? Because having an output interval that's some multiple of the time step is exactly when we expect to see miniscule time-steps due to round off error. The pressure source term is the divergence of the predictor velocity divided by time-step. As the time-step vanishes, the divergence of the predictor velocity also vanishes (because the flow has not evolved from its previous, non-divergent solution). We get a situation tending to 0/0. I think there's a few things we could do to solve this. First of all if we take a very small time-step, I think we can actually just re-set the model time rather than taking a time-step. Second I am wondering if we want to implement a time type that has finite resolution (ie there is a smallest time increment one can take). For example, datetimes have a smallest unit (micro or nanoseconds). A non-dimensional or dimensional-agnostic time type could also be designed analogously (eg every time is the multiple of an integer by the fundamental unit). This would eliminate round off error but it's a bit of work and also we have to put some thought into how best to accomplish it. There might also be a simpler solution by adjusting how we increment time. I'm not sure. > Also wouldn't that also affect simulations with `bu",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3593#issuecomment-2103013025
Modifiability,evolve,evolved,"step is when this happens?I'm wondering if it has to do with using a very small time-step, leading to a round-off error issue. That would also explain why it doesn't affect dynamics, because huge pressure gradient integrated over a machine epsilon duration may not have an impact.; > ; > Are you referring to the fact that sometimes `model` has to use a very tiny time-step to bridge the gap between the current time and the output time? If so, that's an interesting possibility that I hadn't considered. Although in the example above I'm fixing the time-step at `25`, while the output time interval is `200`, so I wouldn't expect any issues there. Can you check just to be sure? Because having an output interval that's some multiple of the time step is exactly when we expect to see miniscule time-steps due to round off error. The pressure source term is the divergence of the predictor velocity divided by time-step. As the time-step vanishes, the divergence of the predictor velocity also vanishes (because the flow has not evolved from its previous, non-divergent solution). We get a situation tending to 0/0. I think there's a few things we could do to solve this. First of all if we take a very small time-step, I think we can actually just re-set the model time rather than taking a time-step. Second I am wondering if we want to implement a time type that has finite resolution (ie there is a smallest time increment one can take). For example, datetimes have a smallest unit (micro or nanoseconds). A non-dimensional or dimensional-agnostic time type could also be designed analogously (eg every time is the multiple of an integer by the fundamental unit). This would eliminate round off error but it's a bit of work and also we have to put some thought into how best to accomplish it. There might also be a simpler solution by adjusting how we increment time. I'm not sure. > Also wouldn't that also affect simulations with `buoyancy=nothing` if the pre-output time-step were to blame?. I",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3593#issuecomment-2103013025
Safety,predict,predictor,"> > Does it have to do with output? Do you know what the time-step is when this happens?I'm wondering if it has to do with using a very small time-step, leading to a round-off error issue. That would also explain why it doesn't affect dynamics, because huge pressure gradient integrated over a machine epsilon duration may not have an impact.; > ; > Are you referring to the fact that sometimes `model` has to use a very tiny time-step to bridge the gap between the current time and the output time? If so, that's an interesting possibility that I hadn't considered. Although in the example above I'm fixing the time-step at `25`, while the output time interval is `200`, so I wouldn't expect any issues there. Can you check just to be sure? Because having an output interval that's some multiple of the time step is exactly when we expect to see miniscule time-steps due to round off error. The pressure source term is the divergence of the predictor velocity divided by time-step. As the time-step vanishes, the divergence of the predictor velocity also vanishes (because the flow has not evolved from its previous, non-divergent solution). We get a situation tending to 0/0. I think there's a few things we could do to solve this. First of all if we take a very small time-step, I think we can actually just re-set the model time rather than taking a time-step. Second I am wondering if we want to implement a time type that has finite resolution (ie there is a smallest time increment one can take). For example, datetimes have a smallest unit (micro or nanoseconds). A non-dimensional or dimensional-agnostic time type could also be designed analogously (eg every time is the multiple of an integer by the fundamental unit). This would eliminate round off error but it's a bit of work and also we have to put some thought into how best to accomplish it. There might also be a simpler solution by adjusting how we increment time. I'm not sure. > Also wouldn't that also affect simulations with `bu",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3593#issuecomment-2103013025
Usability,simpl,simpler,"hat sometimes `model` has to use a very tiny time-step to bridge the gap between the current time and the output time? If so, that's an interesting possibility that I hadn't considered. Although in the example above I'm fixing the time-step at `25`, while the output time interval is `200`, so I wouldn't expect any issues there. Can you check just to be sure? Because having an output interval that's some multiple of the time step is exactly when we expect to see miniscule time-steps due to round off error. The pressure source term is the divergence of the predictor velocity divided by time-step. As the time-step vanishes, the divergence of the predictor velocity also vanishes (because the flow has not evolved from its previous, non-divergent solution). We get a situation tending to 0/0. I think there's a few things we could do to solve this. First of all if we take a very small time-step, I think we can actually just re-set the model time rather than taking a time-step. Second I am wondering if we want to implement a time type that has finite resolution (ie there is a smallest time increment one can take). For example, datetimes have a smallest unit (micro or nanoseconds). A non-dimensional or dimensional-agnostic time type could also be designed analogously (eg every time is the multiple of an integer by the fundamental unit). This would eliminate round off error but it's a bit of work and also we have to put some thought into how best to accomplish it. There might also be a simpler solution by adjusting how we increment time. I'm not sure. > Also wouldn't that also affect simulations with `buoyancy=nothing` if the pre-output time-step were to blame?. I think so, but I also don't think that you can guarantee this problem won't ever occur. The presence of the buoyancy does somehow impact the divergence that accumulates during a time-step / the pressure correction that has to be applied. So it's possible that the buoyancy configuration affects these results. Not sure.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3593#issuecomment-2103013025
Availability,error,error,"> > > Does it have to do with output? Do you know what the time-step is when this happens?I'm wondering if it has to do with using a very small time-step, leading to a round-off error issue. That would also explain why it doesn't affect dynamics, because huge pressure gradient integrated over a machine epsilon duration may not have an impact.; > > ; > > ; > > Are you referring to the fact that sometimes `model` has to use a very tiny time-step to bridge the gap between the current time and the output time? If so, that's an interesting possibility that I hadn't considered. Although in the example above I'm fixing the time-step at `25`, while the output time interval is `200`, so I wouldn't expect any issues there.; > ; > Can you check just to be sure? Because having an output interval that's some multiple of the time step is exactly when we expect to see miniscule time-steps due to round off error. Good point. > > Also wouldn't that also affect simulations with `buoyancy=nothing` if the pre-output time-step were to blame?; > ; > I think so, but I also don't think that you can guarantee this problem won't ever occur. The presence of the buoyancy does somehow impact the divergence that accumulates during a time-step / the pressure correction that has to be applied. So it's possible that the buoyancy configuration affects these results. Not sure. Yeah I see your point. I'll check `model.last_Δt` and report soon. I think it'll be good news if this is the culprit because it seems like we'd have fairly simple options to fix it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3593#issuecomment-2103036352
Deployability,integrat,integrated,"> > > Does it have to do with output? Do you know what the time-step is when this happens?I'm wondering if it has to do with using a very small time-step, leading to a round-off error issue. That would also explain why it doesn't affect dynamics, because huge pressure gradient integrated over a machine epsilon duration may not have an impact.; > > ; > > ; > > Are you referring to the fact that sometimes `model` has to use a very tiny time-step to bridge the gap between the current time and the output time? If so, that's an interesting possibility that I hadn't considered. Although in the example above I'm fixing the time-step at `25`, while the output time interval is `200`, so I wouldn't expect any issues there.; > ; > Can you check just to be sure? Because having an output interval that's some multiple of the time step is exactly when we expect to see miniscule time-steps due to round off error. Good point. > > Also wouldn't that also affect simulations with `buoyancy=nothing` if the pre-output time-step were to blame?; > ; > I think so, but I also don't think that you can guarantee this problem won't ever occur. The presence of the buoyancy does somehow impact the divergence that accumulates during a time-step / the pressure correction that has to be applied. So it's possible that the buoyancy configuration affects these results. Not sure. Yeah I see your point. I'll check `model.last_Δt` and report soon. I think it'll be good news if this is the culprit because it seems like we'd have fairly simple options to fix it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3593#issuecomment-2103036352
Integrability,integrat,integrated,"> > > Does it have to do with output? Do you know what the time-step is when this happens?I'm wondering if it has to do with using a very small time-step, leading to a round-off error issue. That would also explain why it doesn't affect dynamics, because huge pressure gradient integrated over a machine epsilon duration may not have an impact.; > > ; > > ; > > Are you referring to the fact that sometimes `model` has to use a very tiny time-step to bridge the gap between the current time and the output time? If so, that's an interesting possibility that I hadn't considered. Although in the example above I'm fixing the time-step at `25`, while the output time interval is `200`, so I wouldn't expect any issues there.; > ; > Can you check just to be sure? Because having an output interval that's some multiple of the time step is exactly when we expect to see miniscule time-steps due to round off error. Good point. > > Also wouldn't that also affect simulations with `buoyancy=nothing` if the pre-output time-step were to blame?; > ; > I think so, but I also don't think that you can guarantee this problem won't ever occur. The presence of the buoyancy does somehow impact the divergence that accumulates during a time-step / the pressure correction that has to be applied. So it's possible that the buoyancy configuration affects these results. Not sure. Yeah I see your point. I'll check `model.last_Δt` and report soon. I think it'll be good news if this is the culprit because it seems like we'd have fairly simple options to fix it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3593#issuecomment-2103036352
Modifiability,config,configuration,"> > > Does it have to do with output? Do you know what the time-step is when this happens?I'm wondering if it has to do with using a very small time-step, leading to a round-off error issue. That would also explain why it doesn't affect dynamics, because huge pressure gradient integrated over a machine epsilon duration may not have an impact.; > > ; > > ; > > Are you referring to the fact that sometimes `model` has to use a very tiny time-step to bridge the gap between the current time and the output time? If so, that's an interesting possibility that I hadn't considered. Although in the example above I'm fixing the time-step at `25`, while the output time interval is `200`, so I wouldn't expect any issues there.; > ; > Can you check just to be sure? Because having an output interval that's some multiple of the time step is exactly when we expect to see miniscule time-steps due to round off error. Good point. > > Also wouldn't that also affect simulations with `buoyancy=nothing` if the pre-output time-step were to blame?; > ; > I think so, but I also don't think that you can guarantee this problem won't ever occur. The presence of the buoyancy does somehow impact the divergence that accumulates during a time-step / the pressure correction that has to be applied. So it's possible that the buoyancy configuration affects these results. Not sure. Yeah I see your point. I'll check `model.last_Δt` and report soon. I think it'll be good news if this is the culprit because it seems like we'd have fairly simple options to fix it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3593#issuecomment-2103036352
Usability,simpl,simple,"> > > Does it have to do with output? Do you know what the time-step is when this happens?I'm wondering if it has to do with using a very small time-step, leading to a round-off error issue. That would also explain why it doesn't affect dynamics, because huge pressure gradient integrated over a machine epsilon duration may not have an impact.; > > ; > > ; > > Are you referring to the fact that sometimes `model` has to use a very tiny time-step to bridge the gap between the current time and the output time? If so, that's an interesting possibility that I hadn't considered. Although in the example above I'm fixing the time-step at `25`, while the output time interval is `200`, so I wouldn't expect any issues there.; > ; > Can you check just to be sure? Because having an output interval that's some multiple of the time step is exactly when we expect to see miniscule time-steps due to round off error. Good point. > > Also wouldn't that also affect simulations with `buoyancy=nothing` if the pre-output time-step were to blame?; > ; > I think so, but I also don't think that you can guarantee this problem won't ever occur. The presence of the buoyancy does somehow impact the divergence that accumulates during a time-step / the pressure correction that has to be applied. So it's possible that the buoyancy configuration affects these results. Not sure. Yeah I see your point. I'll check `model.last_Δt` and report soon. I think it'll be good news if this is the culprit because it seems like we'd have fairly simple options to fix it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3593#issuecomment-2103036352
Availability,error,error,"Ok, here's a multi-pronged strategy to address this:. 1. Rather than computing the next time step directly based on the schedules, compute the nearest _action time_ (either output or callback or the simulation is stopping). Then compute the time-step like we have been and as suggested by @tomchor for RK3, by taking the differences between the next action time and the current time.; 2. Change `TimeInterval` so that, rather than accumulating `previous_actuation_time`, we instead compute something like the `initialization_time` and `actuation_index`. Then we can compute the next actuation time with `t0 + T * (i + 1)` --- will this reduce round off error when computing the actuation time?; 3. Fix RK3 so it also uses differences to accumulate the substep times as suggested by @tomchor. We can also manually ensure that after the subtseps are complete the the clock time is in fact the current time plus the time-step.; 4. Should we also add a feature to the nonhydrostaticmodel, something like the minimum time step? If the time-step is below that minimum, then rather than doing a time-step + pressure correction, we simply advance the model clock. I wonder if, after all these changes, whether we still need a ""discretized time"" like I was suggesting or not.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3593#issuecomment-2103328247
Energy Efficiency,schedul,schedules,"Ok, here's a multi-pronged strategy to address this:. 1. Rather than computing the next time step directly based on the schedules, compute the nearest _action time_ (either output or callback or the simulation is stopping). Then compute the time-step like we have been and as suggested by @tomchor for RK3, by taking the differences between the next action time and the current time.; 2. Change `TimeInterval` so that, rather than accumulating `previous_actuation_time`, we instead compute something like the `initialization_time` and `actuation_index`. Then we can compute the next actuation time with `t0 + T * (i + 1)` --- will this reduce round off error when computing the actuation time?; 3. Fix RK3 so it also uses differences to accumulate the substep times as suggested by @tomchor. We can also manually ensure that after the subtseps are complete the the clock time is in fact the current time plus the time-step.; 4. Should we also add a feature to the nonhydrostaticmodel, something like the minimum time step? If the time-step is below that minimum, then rather than doing a time-step + pressure correction, we simply advance the model clock. I wonder if, after all these changes, whether we still need a ""discretized time"" like I was suggesting or not.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3593#issuecomment-2103328247
Usability,simpl,simply,"Ok, here's a multi-pronged strategy to address this:. 1. Rather than computing the next time step directly based on the schedules, compute the nearest _action time_ (either output or callback or the simulation is stopping). Then compute the time-step like we have been and as suggested by @tomchor for RK3, by taking the differences between the next action time and the current time.; 2. Change `TimeInterval` so that, rather than accumulating `previous_actuation_time`, we instead compute something like the `initialization_time` and `actuation_index`. Then we can compute the next actuation time with `t0 + T * (i + 1)` --- will this reduce round off error when computing the actuation time?; 3. Fix RK3 so it also uses differences to accumulate the substep times as suggested by @tomchor. We can also manually ensure that after the subtseps are complete the the clock time is in fact the current time plus the time-step.; 4. Should we also add a feature to the nonhydrostaticmodel, something like the minimum time step? If the time-step is below that minimum, then rather than doing a time-step + pressure correction, we simply advance the model clock. I wonder if, after all these changes, whether we still need a ""discretized time"" like I was suggesting or not.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3593#issuecomment-2103328247
Availability,error,error,"> Ok, here's a multi-pronged strategy to address this:; > ; > 1. Rather than computing the next time step directly based on the schedules, compute the nearest _action time_ (either output or callback or the simulation is stopping). Then compute the time-step like we have been and as suggested by @tomchor for RK3, by taking the differences between the next action time and the current time.; > ; > 2. Change `TimeInterval` so that, rather than accumulating `previous_actuation_time`, we instead compute something like the `initialization_time` and `actuation_index`. Then we can compute the next actuation time with `t0 + T * (i + 1)` --- will this reduce round off error when computing the actuation time?. I'm confused as to what `T` would be here. It feels like it should be `simulation.Δt`, but that wouldn't work for variable `Δt`. > 3. Fix RK3 so it also uses differences to accumulate the substep times as suggested by @tomchor. We can also manually ensure that after the subtseps are complete the the clock time is in fact the current time plus the time-step.; > ; > 4. Should we also add a feature to the nonhydrostaticmodel, something like the minimum time step? If the time-step is below that minimum, then rather than doing a time-step + pressure correction, we simply advance the model clock. I think this could work. We probably would need to discuss how that would interact with `min_Δt` from the `TimeStepWizard`, no? Since they're putting two different lower boundaries (I think the one in `NonhydrostaticModel` would be more ""powerful"", correct?); ; > I wonder if, after all these changes, whether we still need a ""discretized time"" like I was suggesting or not. If we discretize time do we even need the stuff above?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3593#issuecomment-2104566106
Energy Efficiency,schedul,schedules,"> Ok, here's a multi-pronged strategy to address this:; > ; > 1. Rather than computing the next time step directly based on the schedules, compute the nearest _action time_ (either output or callback or the simulation is stopping). Then compute the time-step like we have been and as suggested by @tomchor for RK3, by taking the differences between the next action time and the current time.; > ; > 2. Change `TimeInterval` so that, rather than accumulating `previous_actuation_time`, we instead compute something like the `initialization_time` and `actuation_index`. Then we can compute the next actuation time with `t0 + T * (i + 1)` --- will this reduce round off error when computing the actuation time?. I'm confused as to what `T` would be here. It feels like it should be `simulation.Δt`, but that wouldn't work for variable `Δt`. > 3. Fix RK3 so it also uses differences to accumulate the substep times as suggested by @tomchor. We can also manually ensure that after the subtseps are complete the the clock time is in fact the current time plus the time-step.; > ; > 4. Should we also add a feature to the nonhydrostaticmodel, something like the minimum time step? If the time-step is below that minimum, then rather than doing a time-step + pressure correction, we simply advance the model clock. I think this could work. We probably would need to discuss how that would interact with `min_Δt` from the `TimeStepWizard`, no? Since they're putting two different lower boundaries (I think the one in `NonhydrostaticModel` would be more ""powerful"", correct?); ; > I wonder if, after all these changes, whether we still need a ""discretized time"" like I was suggesting or not. If we discretize time do we even need the stuff above?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3593#issuecomment-2104566106
Modifiability,variab,variable,"> Ok, here's a multi-pronged strategy to address this:; > ; > 1. Rather than computing the next time step directly based on the schedules, compute the nearest _action time_ (either output or callback or the simulation is stopping). Then compute the time-step like we have been and as suggested by @tomchor for RK3, by taking the differences between the next action time and the current time.; > ; > 2. Change `TimeInterval` so that, rather than accumulating `previous_actuation_time`, we instead compute something like the `initialization_time` and `actuation_index`. Then we can compute the next actuation time with `t0 + T * (i + 1)` --- will this reduce round off error when computing the actuation time?. I'm confused as to what `T` would be here. It feels like it should be `simulation.Δt`, but that wouldn't work for variable `Δt`. > 3. Fix RK3 so it also uses differences to accumulate the substep times as suggested by @tomchor. We can also manually ensure that after the subtseps are complete the the clock time is in fact the current time plus the time-step.; > ; > 4. Should we also add a feature to the nonhydrostaticmodel, something like the minimum time step? If the time-step is below that minimum, then rather than doing a time-step + pressure correction, we simply advance the model clock. I think this could work. We probably would need to discuss how that would interact with `min_Δt` from the `TimeStepWizard`, no? Since they're putting two different lower boundaries (I think the one in `NonhydrostaticModel` would be more ""powerful"", correct?); ; > I wonder if, after all these changes, whether we still need a ""discretized time"" like I was suggesting or not. If we discretize time do we even need the stuff above?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3593#issuecomment-2104566106
Usability,simpl,simply,"> Ok, here's a multi-pronged strategy to address this:; > ; > 1. Rather than computing the next time step directly based on the schedules, compute the nearest _action time_ (either output or callback or the simulation is stopping). Then compute the time-step like we have been and as suggested by @tomchor for RK3, by taking the differences between the next action time and the current time.; > ; > 2. Change `TimeInterval` so that, rather than accumulating `previous_actuation_time`, we instead compute something like the `initialization_time` and `actuation_index`. Then we can compute the next actuation time with `t0 + T * (i + 1)` --- will this reduce round off error when computing the actuation time?. I'm confused as to what `T` would be here. It feels like it should be `simulation.Δt`, but that wouldn't work for variable `Δt`. > 3. Fix RK3 so it also uses differences to accumulate the substep times as suggested by @tomchor. We can also manually ensure that after the subtseps are complete the the clock time is in fact the current time plus the time-step.; > ; > 4. Should we also add a feature to the nonhydrostaticmodel, something like the minimum time step? If the time-step is below that minimum, then rather than doing a time-step + pressure correction, we simply advance the model clock. I think this could work. We probably would need to discuss how that would interact with `min_Δt` from the `TimeStepWizard`, no? Since they're putting two different lower boundaries (I think the one in `NonhydrostaticModel` would be more ""powerful"", correct?); ; > I wonder if, after all these changes, whether we still need a ""discretized time"" like I was suggesting or not. If we discretize time do we even need the stuff above?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3593#issuecomment-2104566106
Usability,simpl,simply,"> Do we not want the substep length rather than the total time step length? For example on the cases where we're explicitly stepping a boundary condition they're getting stepped every substep. It's not a question of having one or the other. The _question_ is whether ""`last_Δt`"" means ""last time step"". We need to save the previous time step for various reasons --- for AB2 it's needed to decide whether to re-initialize with an Euler step. If we need the previous substep that was taken during RK3 multi-stage stepping, that's fine. It's the road to insanity if `last_Δt` means ""last substep"" in some cases, and ""last time step"" in others. Given the choice, why deliberately drive ourselves insane when we can simply save both the substep and the total time step?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3595#issuecomment-2104881794
Deployability,update,updates,"> There was a bug in some recent updates to KernelAbstractions.jl that caused Enzyme to break on broadcasting arrays in Oceananigans. This PR includes a test to make sure this bug doesn't occur again. Interesting! I think it's ok to add a broadcasting test. But it will be confusing to future developers if the test is explained / written as somehow testing a bug in _another_ package. If there's a bug somewhere else, we need a test in that packge (presumably that has been added). . This test also seems a little complicated. Why not just write a simple function that does a broadcast, and then try to autodiff that? Why do we need initial conditions, models, etc?. For example. ```julia; function times_c!(a, b, c); a .= b .* c # c is a number; return sum(a) # or whatever we gotta return; end. grid = RectilinearGrid(arch, size=(1, 1, 1), extent=(1, 1, 1)); a = CenterField(grid); b = CenterField(grid); c = 2; @test try ; autodiff(times_c!, a, b, c... # or something); true; catch; false; end; ```. It's super important for tests to be as short and easy to understand as possible, because maintaining test code is one of the main bottlenecks on development.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3598#issuecomment-2105014020
Performance,bottleneck,bottlenecks,"> There was a bug in some recent updates to KernelAbstractions.jl that caused Enzyme to break on broadcasting arrays in Oceananigans. This PR includes a test to make sure this bug doesn't occur again. Interesting! I think it's ok to add a broadcasting test. But it will be confusing to future developers if the test is explained / written as somehow testing a bug in _another_ package. If there's a bug somewhere else, we need a test in that packge (presumably that has been added). . This test also seems a little complicated. Why not just write a simple function that does a broadcast, and then try to autodiff that? Why do we need initial conditions, models, etc?. For example. ```julia; function times_c!(a, b, c); a .= b .* c # c is a number; return sum(a) # or whatever we gotta return; end. grid = RectilinearGrid(arch, size=(1, 1, 1), extent=(1, 1, 1)); a = CenterField(grid); b = CenterField(grid); c = 2; @test try ; autodiff(times_c!, a, b, c... # or something); true; catch; false; end; ```. It's super important for tests to be as short and easy to understand as possible, because maintaining test code is one of the main bottlenecks on development.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3598#issuecomment-2105014020
Testability,test,test,"> There was a bug in some recent updates to KernelAbstractions.jl that caused Enzyme to break on broadcasting arrays in Oceananigans. This PR includes a test to make sure this bug doesn't occur again. Interesting! I think it's ok to add a broadcasting test. But it will be confusing to future developers if the test is explained / written as somehow testing a bug in _another_ package. If there's a bug somewhere else, we need a test in that packge (presumably that has been added). . This test also seems a little complicated. Why not just write a simple function that does a broadcast, and then try to autodiff that? Why do we need initial conditions, models, etc?. For example. ```julia; function times_c!(a, b, c); a .= b .* c # c is a number; return sum(a) # or whatever we gotta return; end. grid = RectilinearGrid(arch, size=(1, 1, 1), extent=(1, 1, 1)); a = CenterField(grid); b = CenterField(grid); c = 2; @test try ; autodiff(times_c!, a, b, c... # or something); true; catch; false; end; ```. It's super important for tests to be as short and easy to understand as possible, because maintaining test code is one of the main bottlenecks on development.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3598#issuecomment-2105014020
Usability,simpl,simple,"> There was a bug in some recent updates to KernelAbstractions.jl that caused Enzyme to break on broadcasting arrays in Oceananigans. This PR includes a test to make sure this bug doesn't occur again. Interesting! I think it's ok to add a broadcasting test. But it will be confusing to future developers if the test is explained / written as somehow testing a bug in _another_ package. If there's a bug somewhere else, we need a test in that packge (presumably that has been added). . This test also seems a little complicated. Why not just write a simple function that does a broadcast, and then try to autodiff that? Why do we need initial conditions, models, etc?. For example. ```julia; function times_c!(a, b, c); a .= b .* c # c is a number; return sum(a) # or whatever we gotta return; end. grid = RectilinearGrid(arch, size=(1, 1, 1), extent=(1, 1, 1)); a = CenterField(grid); b = CenterField(grid); c = 2; @test try ; autodiff(times_c!, a, b, c... # or something); true; catch; false; end; ```. It's super important for tests to be as short and easy to understand as possible, because maintaining test code is one of the main bottlenecks on development.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3598#issuecomment-2105014020
Testability,test,tests,"@glwagner I've modified the PR to make clear that this is providing unit tests of the Oceananigans setting utility/broadcast functionality, at at increasingly high level",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3598#issuecomment-2106057500
Usability,clear,clear,"@glwagner I've modified the PR to make clear that this is providing unit tests of the Oceananigans setting utility/broadcast functionality, at at increasingly high level",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3598#issuecomment-2106057500
Usability,simpl,simple,@glwagner are you okay if I just add `min_Δt` as a property of `NonhydrostaticModel` and maintain the strategy of skipping the timestep is Δt is smaller than that? I think that's a reasonable and simple way to fix this.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3606#issuecomment-2150443883
Availability,error,errors,> I think we should fix the problem once. Otherwise we'll end up with unnecessary code somewhere that has to be deleted. @glwagner Can you please be clearer? Does that mean adding `min_Δt` to `Simulation` is an acceptable solution? Or should we try to avoid these round-off errors to even happen in the first place?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3606#issuecomment-2150576412
Safety,avoid,avoid,> I think we should fix the problem once. Otherwise we'll end up with unnecessary code somewhere that has to be deleted. @glwagner Can you please be clearer? Does that mean adding `min_Δt` to `Simulation` is an acceptable solution? Or should we try to avoid these round-off errors to even happen in the first place?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3606#issuecomment-2150576412
Usability,clear,clearer,> I think we should fix the problem once. Otherwise we'll end up with unnecessary code somewhere that has to be deleted. @glwagner Can you please be clearer? Does that mean adding `min_Δt` to `Simulation` is an acceptable solution? Or should we try to avoid these round-off errors to even happen in the first place?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3606#issuecomment-2150576412
Availability,toler,tolerance,"I think the solution discussed here, where the time-step _change_ associated with `TimeInterval` schedules is restricted by a sort of relative tolerance criteria, is acceptable if we can't tease out the underlying issue (or its unsolvable). If we could indeed solve the problem simply by eliminating round off error, then this would almost certainly be preferred since it might be much simpler (eg just fixing an floating-point-unstable arithmetic operation by rearranging terms). That could be really easy. @Sbozzolo might be able to help because I believe they do something special to avoid round off issues in `ClimaAtmos`. I would hesitate to establish an absolute `min_Δt` that's independent of the units being used, unless the default is `0`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3606#issuecomment-2152027136
Energy Efficiency,schedul,schedules,"I think the solution discussed here, where the time-step _change_ associated with `TimeInterval` schedules is restricted by a sort of relative tolerance criteria, is acceptable if we can't tease out the underlying issue (or its unsolvable). If we could indeed solve the problem simply by eliminating round off error, then this would almost certainly be preferred since it might be much simpler (eg just fixing an floating-point-unstable arithmetic operation by rearranging terms). That could be really easy. @Sbozzolo might be able to help because I believe they do something special to avoid round off issues in `ClimaAtmos`. I would hesitate to establish an absolute `min_Δt` that's independent of the units being used, unless the default is `0`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3606#issuecomment-2152027136
Safety,avoid,avoid,"I think the solution discussed here, where the time-step _change_ associated with `TimeInterval` schedules is restricted by a sort of relative tolerance criteria, is acceptable if we can't tease out the underlying issue (or its unsolvable). If we could indeed solve the problem simply by eliminating round off error, then this would almost certainly be preferred since it might be much simpler (eg just fixing an floating-point-unstable arithmetic operation by rearranging terms). That could be really easy. @Sbozzolo might be able to help because I believe they do something special to avoid round off issues in `ClimaAtmos`. I would hesitate to establish an absolute `min_Δt` that's independent of the units being used, unless the default is `0`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3606#issuecomment-2152027136
Usability,simpl,simply,"I think the solution discussed here, where the time-step _change_ associated with `TimeInterval` schedules is restricted by a sort of relative tolerance criteria, is acceptable if we can't tease out the underlying issue (or its unsolvable). If we could indeed solve the problem simply by eliminating round off error, then this would almost certainly be preferred since it might be much simpler (eg just fixing an floating-point-unstable arithmetic operation by rearranging terms). That could be really easy. @Sbozzolo might be able to help because I believe they do something special to avoid round off issues in `ClimaAtmos`. I would hesitate to establish an absolute `min_Δt` that's independent of the units being used, unless the default is `0`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3606#issuecomment-2152027136
Availability,error,errors,"Ok getting closer maybe... I think this problem is generic and cannot be solved in general for arbitrary time steps. Here's a few thoughts:. - Reading about [Kahan summation](https://en.wikipedia.org/wiki/Kahan_summation_algorithm) makes it clear that we simply cannot avoid errors if we would like to add a small floating point number (the time step) to a very large number (the model time). . - I think the issue with the time-step is whether or not we can compute the RHS of the pressure Poisson equation accurately --- which is `div(u') / Δt`, where `u' = u + Δt * Gu` is the predictor velocity and `div` is the divergence. This is interesting, because I could not figure out why we would ever find large `div(u')` with small `Δt` even in this MWE. But now I realize that because of the status of the immersed Poisson solver, the velocity along the boundary is divergent, strongly so. So, `div(u')` is large along the boundary. And when we divide by `Δt` we get something huge. The magnitude of `div(u')` also somehow seems to depend on the time step (as does the magnitude of the spurious circulation). The correct solution to this case remains at rest of course. (An aside is that this problem _could_ be avoided by separately computing the hydrostatic pressure, and then using a special horizontal gradient operators that avoid computing a hydrostatic pressure gradient across an immersed boundary. However, this would only be correct for no-flux boundary conditions on buoyancy on side walls). Anyways, apparently because of this issue with the immersed pressure solver, it seems that `div(u')` is large (because `div(u)` is large) even when `Δt = O(1e-14)`... - As a result of all of this I am confused about whether this MWE is actually reliable for debugging the issue. I guess we should expect to see problems simply when `Δt = O(eps)` because this is when `div(u') / Δt` cannot be reliably computed, I think. This leads to a fairly simple criteria for the time step that's compatible with",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3606#issuecomment-2153020136
Integrability,depend,depend,"lem is generic and cannot be solved in general for arbitrary time steps. Here's a few thoughts:. - Reading about [Kahan summation](https://en.wikipedia.org/wiki/Kahan_summation_algorithm) makes it clear that we simply cannot avoid errors if we would like to add a small floating point number (the time step) to a very large number (the model time). . - I think the issue with the time-step is whether or not we can compute the RHS of the pressure Poisson equation accurately --- which is `div(u') / Δt`, where `u' = u + Δt * Gu` is the predictor velocity and `div` is the divergence. This is interesting, because I could not figure out why we would ever find large `div(u')` with small `Δt` even in this MWE. But now I realize that because of the status of the immersed Poisson solver, the velocity along the boundary is divergent, strongly so. So, `div(u')` is large along the boundary. And when we divide by `Δt` we get something huge. The magnitude of `div(u')` also somehow seems to depend on the time step (as does the magnitude of the spurious circulation). The correct solution to this case remains at rest of course. (An aside is that this problem _could_ be avoided by separately computing the hydrostatic pressure, and then using a special horizontal gradient operators that avoid computing a hydrostatic pressure gradient across an immersed boundary. However, this would only be correct for no-flux boundary conditions on buoyancy on side walls). Anyways, apparently because of this issue with the immersed pressure solver, it seems that `div(u')` is large (because `div(u)` is large) even when `Δt = O(1e-14)`... - As a result of all of this I am confused about whether this MWE is actually reliable for debugging the issue. I guess we should expect to see problems simply when `Δt = O(eps)` because this is when `div(u') / Δt` cannot be reliably computed, I think. This leads to a fairly simple criteria for the time step that's compatible with the pressure correction. But as noted in t",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3606#issuecomment-2153020136
Safety,avoid,avoid,"Ok getting closer maybe... I think this problem is generic and cannot be solved in general for arbitrary time steps. Here's a few thoughts:. - Reading about [Kahan summation](https://en.wikipedia.org/wiki/Kahan_summation_algorithm) makes it clear that we simply cannot avoid errors if we would like to add a small floating point number (the time step) to a very large number (the model time). . - I think the issue with the time-step is whether or not we can compute the RHS of the pressure Poisson equation accurately --- which is `div(u') / Δt`, where `u' = u + Δt * Gu` is the predictor velocity and `div` is the divergence. This is interesting, because I could not figure out why we would ever find large `div(u')` with small `Δt` even in this MWE. But now I realize that because of the status of the immersed Poisson solver, the velocity along the boundary is divergent, strongly so. So, `div(u')` is large along the boundary. And when we divide by `Δt` we get something huge. The magnitude of `div(u')` also somehow seems to depend on the time step (as does the magnitude of the spurious circulation). The correct solution to this case remains at rest of course. (An aside is that this problem _could_ be avoided by separately computing the hydrostatic pressure, and then using a special horizontal gradient operators that avoid computing a hydrostatic pressure gradient across an immersed boundary. However, this would only be correct for no-flux boundary conditions on buoyancy on side walls). Anyways, apparently because of this issue with the immersed pressure solver, it seems that `div(u')` is large (because `div(u)` is large) even when `Δt = O(1e-14)`... - As a result of all of this I am confused about whether this MWE is actually reliable for debugging the issue. I guess we should expect to see problems simply when `Δt = O(eps)` because this is when `div(u') / Δt` cannot be reliably computed, I think. This leads to a fairly simple criteria for the time step that's compatible with",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3606#issuecomment-2153020136
Usability,clear,clear,"Ok getting closer maybe... I think this problem is generic and cannot be solved in general for arbitrary time steps. Here's a few thoughts:. - Reading about [Kahan summation](https://en.wikipedia.org/wiki/Kahan_summation_algorithm) makes it clear that we simply cannot avoid errors if we would like to add a small floating point number (the time step) to a very large number (the model time). . - I think the issue with the time-step is whether or not we can compute the RHS of the pressure Poisson equation accurately --- which is `div(u') / Δt`, where `u' = u + Δt * Gu` is the predictor velocity and `div` is the divergence. This is interesting, because I could not figure out why we would ever find large `div(u')` with small `Δt` even in this MWE. But now I realize that because of the status of the immersed Poisson solver, the velocity along the boundary is divergent, strongly so. So, `div(u')` is large along the boundary. And when we divide by `Δt` we get something huge. The magnitude of `div(u')` also somehow seems to depend on the time step (as does the magnitude of the spurious circulation). The correct solution to this case remains at rest of course. (An aside is that this problem _could_ be avoided by separately computing the hydrostatic pressure, and then using a special horizontal gradient operators that avoid computing a hydrostatic pressure gradient across an immersed boundary. However, this would only be correct for no-flux boundary conditions on buoyancy on side walls). Anyways, apparently because of this issue with the immersed pressure solver, it seems that `div(u')` is large (because `div(u)` is large) even when `Δt = O(1e-14)`... - As a result of all of this I am confused about whether this MWE is actually reliable for debugging the issue. I guess we should expect to see problems simply when `Δt = O(eps)` because this is when `div(u') / Δt` cannot be reliably computed, I think. This leads to a fairly simple criteria for the time step that's compatible with",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3606#issuecomment-2153020136
Integrability,depend,depends,"You need to use `Open` to set boundary-normal velocities. However, what you're trying to do may not be supported. @jagoosw may know more. Can you please provide more detail about the setup you are trying to run?. > Then, i have another question. i want to output wind stress (top flux boundary condition) to jld2 or netcdf. But i cannot save or find wind stress (top flux boundary condition) from model. So, which field or variable can i set to save wind stress. Is there a simple example?. This depends on how you are setting the wind stress --- are you using a function or array? If you provide more details we can figure it out. I converted this to a discussion because we are not trying to change the source code (as far as I can tell).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3612#issuecomment-2148897056
Modifiability,variab,variable,"You need to use `Open` to set boundary-normal velocities. However, what you're trying to do may not be supported. @jagoosw may know more. Can you please provide more detail about the setup you are trying to run?. > Then, i have another question. i want to output wind stress (top flux boundary condition) to jld2 or netcdf. But i cannot save or find wind stress (top flux boundary condition) from model. So, which field or variable can i set to save wind stress. Is there a simple example?. This depends on how you are setting the wind stress --- are you using a function or array? If you provide more details we can figure it out. I converted this to a discussion because we are not trying to change the source code (as far as I can tell).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3612#issuecomment-2148897056
Usability,simpl,simple,"You need to use `Open` to set boundary-normal velocities. However, what you're trying to do may not be supported. @jagoosw may know more. Can you please provide more detail about the setup you are trying to run?. > Then, i have another question. i want to output wind stress (top flux boundary condition) to jld2 or netcdf. But i cannot save or find wind stress (top flux boundary condition) from model. So, which field or variable can i set to save wind stress. Is there a simple example?. This depends on how you are setting the wind stress --- are you using a function or array? If you provide more details we can figure it out. I converted this to a discussion because we are not trying to change the source code (as far as I can tell).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3612#issuecomment-2148897056
Energy Efficiency,adapt,adaptive,"@mncrowe it sounds like this happened when you weren't using adaptive time-stepping --- which is nice because it will help us construct an MWE more easily. Do you think you can help with that? We just need a very simple simulation that reproduces the issue, hopefully something 0D with no dynamics that runs fast.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3614#issuecomment-2150474033
Modifiability,adapt,adaptive,"@mncrowe it sounds like this happened when you weren't using adaptive time-stepping --- which is nice because it will help us construct an MWE more easily. Do you think you can help with that? We just need a very simple simulation that reproduces the issue, hopefully something 0D with no dynamics that runs fast.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3614#issuecomment-2150474033
Usability,simpl,simple,"@mncrowe it sounds like this happened when you weren't using adaptive time-stepping --- which is nice because it will help us construct an MWE more easily. Do you think you can help with that? We just need a very simple simulation that reproduces the issue, hopefully something 0D with no dynamics that runs fast.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3614#issuecomment-2150474033
Usability,simpl,simple,I don't think the MWE even requires saving output. Can't we also achieve an MWE using a simple `Callback`?. This issue should be independent of whether you are using the CPU or GPU.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3614#issuecomment-2152008883
Usability,simpl,simple,"seems simple enough, just a few cosmetic comments. Does `shadowp` stand for ""`primal_shadow`""?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3618#issuecomment-2166579371
Usability,intuit,intuition,"OK, I think I understand the issue mentioned here but the terminology intrinsic and extrinsic is not self-explanatory (for my intuition at least). . I'm not trying to argue against the names, I just want to understand exactly what's been discussed. I think something in this spirit @siddharthabishnu bumped into in trying to set initial conditions or surface forcing on a ConformalCubedSphereGrid..?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3625#issuecomment-2185341516
Usability,clear,clear,"The words do actually mean that for me as well, i.e. ""belonging to a thing by its very nature"" or ""originating from the outside"". But because I've never before heard them in the context of coordinate systems it was not totally obvious to me what their meaning in this context was _from just by seeing the name_. But it did became clear soon!. I think it's ok that some of the names aren't 100% self explanatory just by reading the name and you need to read a bit the docstring or something to understand 100% what these objects/methods are.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3625#issuecomment-2190774936
Usability,feedback,feedback,@navidcy curious to have your feedback on this proposed API,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3626#issuecomment-2177152344
Integrability,depend,depend,"> > or in general, coming up with a system that makes sure that the API is compatible with the choice of complex BCs For example, in a script people should not be allowed to do; > > ```julia; > > u, v, w = model.velocities; > > fill_halo_regions!((u, v, w)); > > ```; > ; > I understand the first part, but can you explain why the latter isn't desirable and why it would be hard to come up with something? The way I see it, if we set in stone that `fill_halo_regions!()` needs to have `clock` and `fields(model)` passed, then can't we just remove the method that would make `fill_halo_regions!((u, v, w))` possible?. No, we definitely don't want that. That would make it impossible to use `Fields` without a model. We want simple / default boundary conditions to work without an entire model state. One has to understand the additional arguments to `fill_halo_regions!` as part of a system to support _additional_ features for fields, such as boundary conditions that depend on other parts of the model state. There's a circular depedancy issue: when field boundary conditions depend on other fields, the entire system of fields must be created simultaneously for the computation to work properly. We don't have a _general_ system for this. We just support it within the context of a model, like the hydrostatic or nonhydrostatic model. This works because whenever we fill halo regions _within_ the model time-stepping algorithm, we can indeed incorporate the whole model state.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3628#issuecomment-2179182260
Usability,simpl,simple,"> > or in general, coming up with a system that makes sure that the API is compatible with the choice of complex BCs For example, in a script people should not be allowed to do; > > ```julia; > > u, v, w = model.velocities; > > fill_halo_regions!((u, v, w)); > > ```; > ; > I understand the first part, but can you explain why the latter isn't desirable and why it would be hard to come up with something? The way I see it, if we set in stone that `fill_halo_regions!()` needs to have `clock` and `fields(model)` passed, then can't we just remove the method that would make `fill_halo_regions!((u, v, w))` possible?. No, we definitely don't want that. That would make it impossible to use `Fields` without a model. We want simple / default boundary conditions to work without an entire model state. One has to understand the additional arguments to `fill_halo_regions!` as part of a system to support _additional_ features for fields, such as boundary conditions that depend on other parts of the model state. There's a circular depedancy issue: when field boundary conditions depend on other fields, the entire system of fields must be created simultaneously for the computation to work properly. We don't have a _general_ system for this. We just support it within the context of a model, like the hydrostatic or nonhydrostatic model. This works because whenever we fill halo regions _within_ the model time-stepping algorithm, we can indeed incorporate the whole model state.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3628#issuecomment-2179182260
Usability,simpl,simple,"> if you do it like that (allow a function bc to be applied by filling the halos rather than as an additional tendency), then a field initialized in a model with a function bc (like a velocity for example) will always expect additional signatures for `fill_halo_regions!` and computing within an abstract operation would be impossible if not passing the additional arguments.; > ; > I am suggesting to treat all complex BCs like we treat `Flux` so that the API will not need drastic changes but we can incorporate the feature that @tomchor is talking about. No that's not true --- that's how it works now. The arguments are propagated via `args...`. If the bc is not a function, the args are thrown away:. https://github.com/CliMA/Oceananigans.jl/blob/d4bcc095be66c7b5c98a462106285a6f6d341fe1/src/BoundaryConditions/boundary_condition.jl#L121-L122. if you use a function then you get:. https://github.com/CliMA/Oceananigans.jl/blob/d4bcc095be66c7b5c98a462106285a6f6d341fe1/src/BoundaryConditions/boundary_condition.jl#L115. it's actually fairly simple to understand",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3628#issuecomment-2179195098
Usability,simpl,simple,"> Not sure if I am missing something but first I think the user can just write; > ; > ```julia; > averaging=(1, 2); > ```. I considered taking that approach but I felt it made it a bit awkward to implement Lagrangian averaging in the future. That said, I do agree that my currently implementation is probably unnecessarily verbose. I think your suggestion below of `DimensionAveraging(dims=(1, 2))` is a good compromise. > ; > which would mean average over xy. Or if you want to be more verbose then; > ; > ```julia; > averaging=DimensionAveraging(dims=(1, 2)); > ```; > ; > or something.; > ; > Next for the average itself it seems you need; > ; > ```julia; > LM_op = KernelFunctionOperation{Center, Center, Center}(LᵢⱼMᵢⱼ_ccc, grid, u, v, w); > LM_avg = Field(Average(LM_op, averaging.dims)); > ```; > ; > In the constructor. Then you can just call `compute!(LM_avg)` without needing lots of additional dispatch. Ah, that's so simple! I'll implement that.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3642#issuecomment-2197150047
Integrability,depend,dependent,"Obukhov-compliant bottom drag. I couldn't reproduce the simulation perfectly (for example, they use a pseudo-spectral scheme in the horizontal directions, force their drag with a horizontal average, and modify the `SmagLilly` constant slightly) so the results are a bit different from what's in their paper, but I think that's okay. Let me know if anyone thinks otherwise. Importantly, the `ScaleInvSmag` shows an improvement over the `SmagLilly`, with the later being expectedly overly diffusive and pretty much killing any turbulence at this resolution:. https://github.com/user-attachments/assets/6440450d-52f4-43ef-9ad5-0f8fcd9993d5. For reference, this is what similar plots from the paper look like (the equivalent for us here would be SMAG and PASI):. ![image](https://github.com/user-attachments/assets/5607d340-d4b4-4405-a0a6-67ed43bfd274). Some quick notes:. - Many tests are failing become I made an ad-hoc modification for now which passes the velocities to `DiffusivityFields()`. I did that because otherwise it was hard to make the model performant and simulations were taking way too long. We can (and should) review this and either come up with a better way to construct the `diffusivity_fields` or make this change separately in another PR, which will require changing the other models too.; - I'm updating the dynamic model once every 5 time steps only (this is user-defined). This is common practice for dynamic models since their cost is significantly higher than that of constant Smag or even AMD. With that practice, the dynamic model is taking about 3 times longer to run than the constant Smagorinsky. It does take significantly longer to compile (I haven't timed it). I believe there might be some optimizations still on the table though.; - I also found that the precise value of the Smag coefficient calculated via the dynamic procedure is dependent on the advection scheme, with WENO generally leading to smaller values. In hindsight, I think that's not surprising though.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3642#issuecomment-2417879667
Performance,perform,performant,"Obukhov-compliant bottom drag. I couldn't reproduce the simulation perfectly (for example, they use a pseudo-spectral scheme in the horizontal directions, force their drag with a horizontal average, and modify the `SmagLilly` constant slightly) so the results are a bit different from what's in their paper, but I think that's okay. Let me know if anyone thinks otherwise. Importantly, the `ScaleInvSmag` shows an improvement over the `SmagLilly`, with the later being expectedly overly diffusive and pretty much killing any turbulence at this resolution:. https://github.com/user-attachments/assets/6440450d-52f4-43ef-9ad5-0f8fcd9993d5. For reference, this is what similar plots from the paper look like (the equivalent for us here would be SMAG and PASI):. ![image](https://github.com/user-attachments/assets/5607d340-d4b4-4405-a0a6-67ed43bfd274). Some quick notes:. - Many tests are failing become I made an ad-hoc modification for now which passes the velocities to `DiffusivityFields()`. I did that because otherwise it was hard to make the model performant and simulations were taking way too long. We can (and should) review this and either come up with a better way to construct the `diffusivity_fields` or make this change separately in another PR, which will require changing the other models too.; - I'm updating the dynamic model once every 5 time steps only (this is user-defined). This is common practice for dynamic models since their cost is significantly higher than that of constant Smag or even AMD. With that practice, the dynamic model is taking about 3 times longer to run than the constant Smagorinsky. It does take significantly longer to compile (I haven't timed it). I believe there might be some optimizations still on the table though.; - I also found that the precise value of the Smag coefficient calculated via the dynamic procedure is dependent on the advection scheme, with WENO generally leading to smaller values. In hindsight, I think that's not surprising though.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3642#issuecomment-2417879667
Security,validat,validation,"I wrote some validation scripts and I think the model is working, but I'd appreciate some feedback. First, this animation shows two 3D decaying turbulence simulations, one with `SmagorinskyLilly` and another with the `ScaleInvSmag`. I'm also plotting the value of the Smagorinsky constant from the dynamic model. For similar conditions (3D homogeneous tubrulence), Lilly assumed a sharp spectral filter in the inertial subrange, matched the SGS dissipation rate to the TKE dissipation rate and obtained the theoretical value of the Smag constant of $c_s$ ≈ 0.165. I think these assumptions should be roughly valid in this validation script, and indeed the value that we obtain for $c_s$ is kinda close:. https://github.com/user-attachments/assets/f210d18b-82bf-4e9e-bb26-58bbd4251820. Although to be honest I expected the value to be closer. That said, I believe Lilly also assumed a _stationary_ turbulent flow (although I'd have to double check that), which is not the case here and may be affecting the coefficient value. Btw, I had posted a similar video before but I made some modifications to the model since then. I also reproduced the first test simulation in the original Bou-Zeid (2005) paper: namely a channel flow forced by a pressure gradient, with a Monin-Obukhov-compliant bottom drag. I couldn't reproduce the simulation perfectly (for example, they use a pseudo-spectral scheme in the horizontal directions, force their drag with a horizontal average, and modify the `SmagLilly` constant slightly) so the results are a bit different from what's in their paper, but I think that's okay. Let me know if anyone thinks otherwise. Importantly, the `ScaleInvSmag` shows an improvement over the `SmagLilly`, with the later being expectedly overly diffusive and pretty much killing any turbulence at this resolution:. https://github.com/user-attachments/assets/6440450d-52f4-43ef-9ad5-0f8fcd9993d5. For reference, this is what similar plots from the paper look like (the equivalent for us her",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3642#issuecomment-2417879667
Testability,test,test,"th the `ScaleInvSmag`. I'm also plotting the value of the Smagorinsky constant from the dynamic model. For similar conditions (3D homogeneous tubrulence), Lilly assumed a sharp spectral filter in the inertial subrange, matched the SGS dissipation rate to the TKE dissipation rate and obtained the theoretical value of the Smag constant of $c_s$ ≈ 0.165. I think these assumptions should be roughly valid in this validation script, and indeed the value that we obtain for $c_s$ is kinda close:. https://github.com/user-attachments/assets/f210d18b-82bf-4e9e-bb26-58bbd4251820. Although to be honest I expected the value to be closer. That said, I believe Lilly also assumed a _stationary_ turbulent flow (although I'd have to double check that), which is not the case here and may be affecting the coefficient value. Btw, I had posted a similar video before but I made some modifications to the model since then. I also reproduced the first test simulation in the original Bou-Zeid (2005) paper: namely a channel flow forced by a pressure gradient, with a Monin-Obukhov-compliant bottom drag. I couldn't reproduce the simulation perfectly (for example, they use a pseudo-spectral scheme in the horizontal directions, force their drag with a horizontal average, and modify the `SmagLilly` constant slightly) so the results are a bit different from what's in their paper, but I think that's okay. Let me know if anyone thinks otherwise. Importantly, the `ScaleInvSmag` shows an improvement over the `SmagLilly`, with the later being expectedly overly diffusive and pretty much killing any turbulence at this resolution:. https://github.com/user-attachments/assets/6440450d-52f4-43ef-9ad5-0f8fcd9993d5. For reference, this is what similar plots from the paper look like (the equivalent for us here would be SMAG and PASI):. ![image](https://github.com/user-attachments/assets/5607d340-d4b4-4405-a0a6-67ed43bfd274). Some quick notes:. - Many tests are failing become I made an ad-hoc modification for now w",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3642#issuecomment-2417879667
Usability,feedback,feedback,"I wrote some validation scripts and I think the model is working, but I'd appreciate some feedback. First, this animation shows two 3D decaying turbulence simulations, one with `SmagorinskyLilly` and another with the `ScaleInvSmag`. I'm also plotting the value of the Smagorinsky constant from the dynamic model. For similar conditions (3D homogeneous tubrulence), Lilly assumed a sharp spectral filter in the inertial subrange, matched the SGS dissipation rate to the TKE dissipation rate and obtained the theoretical value of the Smag constant of $c_s$ ≈ 0.165. I think these assumptions should be roughly valid in this validation script, and indeed the value that we obtain for $c_s$ is kinda close:. https://github.com/user-attachments/assets/f210d18b-82bf-4e9e-bb26-58bbd4251820. Although to be honest I expected the value to be closer. That said, I believe Lilly also assumed a _stationary_ turbulent flow (although I'd have to double check that), which is not the case here and may be affecting the coefficient value. Btw, I had posted a similar video before but I made some modifications to the model since then. I also reproduced the first test simulation in the original Bou-Zeid (2005) paper: namely a channel flow forced by a pressure gradient, with a Monin-Obukhov-compliant bottom drag. I couldn't reproduce the simulation perfectly (for example, they use a pseudo-spectral scheme in the horizontal directions, force their drag with a horizontal average, and modify the `SmagLilly` constant slightly) so the results are a bit different from what's in their paper, but I think that's okay. Let me know if anyone thinks otherwise. Importantly, the `ScaleInvSmag` shows an improvement over the `SmagLilly`, with the later being expectedly overly diffusive and pretty much killing any turbulence at this resolution:. https://github.com/user-attachments/assets/6440450d-52f4-43ef-9ad5-0f8fcd9993d5. For reference, this is what similar plots from the paper look like (the equivalent for us her",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3642#issuecomment-2417879667
Integrability,depend,dependence,"Interesting. I disagree that fig 1 does not have an obvious trend, the trend is quite clear away from the wall:. <img width=""391"" alt=""image"" src=""https://github.com/user-attachments/assets/b1bc556f-4a82-47b3-acd8-c27e83c32591"">. Both Lagrangian schemes have larger coefficients than their planar-averaged counter parts. Also scale dependence increases the Lagrangian coefficient. But still, I was referring to the eddy viscosity, not the coefficient. It would be interesting to me if the Lagrangian scheme was consistently more diffusive. But that might actually also be consistent with convergence at lower resolution, perhaps.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3642#issuecomment-2448751069
Usability,clear,clear,"Interesting. I disagree that fig 1 does not have an obvious trend, the trend is quite clear away from the wall:. <img width=""391"" alt=""image"" src=""https://github.com/user-attachments/assets/b1bc556f-4a82-47b3-acd8-c27e83c32591"">. Both Lagrangian schemes have larger coefficients than their planar-averaged counter parts. Also scale dependence increases the Lagrangian coefficient. But still, I was referring to the eddy viscosity, not the coefficient. It would be interesting to me if the Lagrangian scheme was consistently more diffusive. But that might actually also be consistent with convergence at lower resolution, perhaps.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3642#issuecomment-2448751069
Integrability,depend,dependence,"> I disagree that fig 1 does not have an obvious trend, the trend is quite clear away from the wall:; >; > Both Lagrangian schemes have larger coefficients than their planar-averaged counter parts. Also scale dependence increases the Lagrangian coefficient. I agree that far from the wall there is a clear trend. But I'm not sure that's a fair way to look at it. > But still, I was referring to the eddy viscosity, not the coefficient. It would be interesting to me if the Lagrangian scheme was consistently more diffusive. But that might actually also be consistent with convergence at lower resolution, perhaps. That said, good point that the coefficient doesn't necessarily translate into the eddy viscosity. I'll check the eddy viscosity later and see what comes up as I am now curious :)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3642#issuecomment-2449535803
Usability,clear,clear,"> I disagree that fig 1 does not have an obvious trend, the trend is quite clear away from the wall:; >; > Both Lagrangian schemes have larger coefficients than their planar-averaged counter parts. Also scale dependence increases the Lagrangian coefficient. I agree that far from the wall there is a clear trend. But I'm not sure that's a fair way to look at it. > But still, I was referring to the eddy viscosity, not the coefficient. It would be interesting to me if the Lagrangian scheme was consistently more diffusive. But that might actually also be consistent with convergence at lower resolution, perhaps. That said, good point that the coefficient doesn't necessarily translate into the eddy viscosity. I'll check the eddy viscosity later and see what comes up as I am now curious :)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3642#issuecomment-2449535803
Safety,avoid,avoided,"Interesting. We have deliberately avoided operations for field time series but we can consider it. How does this work for operations that involve both a Field and a FieldTimeSeries? I'm worried this will be a bit brittle and potentially lead to some wasted time for users, since it may only work for the simplest cases. Another issue is that we don't have a time derivative operator. Another way to implement a time series computation is to make a new/empty FieldTimeSeries, and then loop over the time-index to compute each field in the time series. Is this PR merely a convenience to avoid that loop? Are there other solutions / syntax we could think about supporting that might be more useful / generalize better for users?. Note I think for big feature changes like this it's best to discuss in an issue first before having a PR, but we can discuss here.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3644#issuecomment-2198635393
Usability,simpl,simplest,"Interesting. We have deliberately avoided operations for field time series but we can consider it. How does this work for operations that involve both a Field and a FieldTimeSeries? I'm worried this will be a bit brittle and potentially lead to some wasted time for users, since it may only work for the simplest cases. Another issue is that we don't have a time derivative operator. Another way to implement a time series computation is to make a new/empty FieldTimeSeries, and then loop over the time-index to compute each field in the time series. Is this PR merely a convenience to avoid that loop? Are there other solutions / syntax we could think about supporting that might be more useful / generalize better for users?. Note I think for big feature changes like this it's best to discuss in an issue first before having a PR, but we can discuss here.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3644#issuecomment-2198635393
Usability,simpl,simple,"My main concern is that if it doesn't work for most cases (only simple ones) then we won't really want to document / advertise the new feature. Right now this is what users have to do I think:. ```julia; u10 = FieldTimeSeries(""atmosphere.jld2"", ""u10""). tau = FieldTimeSeries{Face, Center, Nothing}(grid, u10.times). for n = 1:length(tau); u10n = u10[n]; tau[n] .= - ρₐ / ρₒ * cᴰ * u10n * abs(u10n); end; ```. collapsing this to fewer lines and also potentially making it faster (by launching a 4D kernel that computes over time as well as space could be a significant advantage but I think we probably need to be able to mix `Field`s into the computation)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3644#issuecomment-2200448875
Testability,test,tests,"@glwagner Thanks for implementing the total tracer diffusive flux at a high level. After running several tests, I found it to work exceptionally well! I conducted a series of tests: 1) comparing 1D vs 3D, 2) with and without the Coriolis force, and 3) with and without the immersed boundary. Everything looks great! Here are some simple examples on a rotated coordinate:. - 1D test with a small f: . https://github.com/CliMA/Oceananigans.jl/assets/68127124/63272997-5998-4d1c-8d9e-5e735a8731f8. - 3D simulation with immersed grids: . https://github.com/CliMA/Oceananigans.jl/assets/68127124/11dd0ee4-4e0a-4052-a65a-61f628ca1fef. The only caveat mentioned by @hdrake is that `GradientBoundaryCondition` is only being applied to the perturbation fluxes at the boundaries, i.e., `GradientBoundaryCondition(-N^2*cos(θ))` is needed to make the total buoyancy gradient to be 0.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2211254101
Usability,simpl,simple,"@glwagner Thanks for implementing the total tracer diffusive flux at a high level. After running several tests, I found it to work exceptionally well! I conducted a series of tests: 1) comparing 1D vs 3D, 2) with and without the Coriolis force, and 3) with and without the immersed boundary. Everything looks great! Here are some simple examples on a rotated coordinate:. - 1D test with a small f: . https://github.com/CliMA/Oceananigans.jl/assets/68127124/63272997-5998-4d1c-8d9e-5e735a8731f8. - 3D simulation with immersed grids: . https://github.com/CliMA/Oceananigans.jl/assets/68127124/11dd0ee4-4e0a-4052-a65a-61f628ca1fef. The only caveat mentioned by @hdrake is that `GradientBoundaryCondition` is only being applied to the perturbation fluxes at the boundaries, i.e., `GradientBoundaryCondition(-N^2*cos(θ))` is needed to make the total buoyancy gradient to be 0.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2211254101
Integrability,depend,depend,"> Additionally can you help me understand why you are using `GradientBoundaryCondition` at all? [- @glwagner]. Flux boundary conditions are both conceptually and practically easier to implement when the boundary fluxes are zero or constant. They can be trickier when they depend on interior flow variables. In our case, for example, the boundary condition on the perturbation variable $b'$ (the buoyancy tracer in Oceananigans) is that the *total* diffusive flux should vanish, which means the *perturbation* diffusive flux needs to be minus the *background* diffusive flux. . ![image](https://github.com/CliMA/Oceananigans.jl/assets/12971166/d5eae1d6-4aa8-438e-870b-0ff17352dcea). Imposing a flux boundary condition requires knowing the diffusivity $\kappa$ right at the boundary. It is obvious how to implement this if the diffusivity is a constant, because the background diffusive flux is also a known constant, but less obvious how to do it when using a subgrid turbulence closure that yields a diffusivity that varies in space and time. @tomchor pointed out to use that we can sidestep this complexity if we just divide both sides of the boundary condition by $\kappa$, because then the boundary condition simply becomes that the buoyancy gradient across the boundary should just be equal to minus the background buoyancy gradient—a known constant in our problem.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2211446146
Modifiability,variab,variables,"> Additionally can you help me understand why you are using `GradientBoundaryCondition` at all? [- @glwagner]. Flux boundary conditions are both conceptually and practically easier to implement when the boundary fluxes are zero or constant. They can be trickier when they depend on interior flow variables. In our case, for example, the boundary condition on the perturbation variable $b'$ (the buoyancy tracer in Oceananigans) is that the *total* diffusive flux should vanish, which means the *perturbation* diffusive flux needs to be minus the *background* diffusive flux. . ![image](https://github.com/CliMA/Oceananigans.jl/assets/12971166/d5eae1d6-4aa8-438e-870b-0ff17352dcea). Imposing a flux boundary condition requires knowing the diffusivity $\kappa$ right at the boundary. It is obvious how to implement this if the diffusivity is a constant, because the background diffusive flux is also a known constant, but less obvious how to do it when using a subgrid turbulence closure that yields a diffusivity that varies in space and time. @tomchor pointed out to use that we can sidestep this complexity if we just divide both sides of the boundary condition by $\kappa$, because then the boundary condition simply becomes that the buoyancy gradient across the boundary should just be equal to minus the background buoyancy gradient—a known constant in our problem.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2211446146
Usability,simpl,simply,"> Additionally can you help me understand why you are using `GradientBoundaryCondition` at all? [- @glwagner]. Flux boundary conditions are both conceptually and practically easier to implement when the boundary fluxes are zero or constant. They can be trickier when they depend on interior flow variables. In our case, for example, the boundary condition on the perturbation variable $b'$ (the buoyancy tracer in Oceananigans) is that the *total* diffusive flux should vanish, which means the *perturbation* diffusive flux needs to be minus the *background* diffusive flux. . ![image](https://github.com/CliMA/Oceananigans.jl/assets/12971166/d5eae1d6-4aa8-438e-870b-0ff17352dcea). Imposing a flux boundary condition requires knowing the diffusivity $\kappa$ right at the boundary. It is obvious how to implement this if the diffusivity is a constant, because the background diffusive flux is also a known constant, but less obvious how to do it when using a subgrid turbulence closure that yields a diffusivity that varies in space and time. @tomchor pointed out to use that we can sidestep this complexity if we just divide both sides of the boundary condition by $\kappa$, because then the boundary condition simply becomes that the buoyancy gradient across the boundary should just be equal to minus the background buoyancy gradient—a known constant in our problem.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2211446146
Availability,down,downgradient,"> > I don't know exactly what it means for a gradient to be applied to the field. Can you please clarify?; > ; > I just meant where in the code the gradient boundary conditions get imposed, which you've shown us is in the calculation of the gradients that feed into the downgradient diffusive fluxes that are used in the diffusive flux divergence contribution to the tracer tendencies. Thanks!. Okay great. I would only add, I think it's clearer to think of the gradient as being _used_ to diagnose the cross-boundary flux (rather than imposed). I guess the point here is that there is actually an apparent flux of tracer into the perturbation field because of the presence of the background. So we are imagining that the background is being maintained by some large scale circulation which is ultimately the source of this apparent flux. `FluxBoundaryCondition` can be used if you know the diffusivity a priori but otherwise it does look like it will be simpler to use `GradientBoundaryCondition` to add this apparent flux contribution to the evolution of the perturbation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2212615516
Usability,clear,clearer,"> > I don't know exactly what it means for a gradient to be applied to the field. Can you please clarify?; > ; > I just meant where in the code the gradient boundary conditions get imposed, which you've shown us is in the calculation of the gradients that feed into the downgradient diffusive fluxes that are used in the diffusive flux divergence contribution to the tracer tendencies. Thanks!. Okay great. I would only add, I think it's clearer to think of the gradient as being _used_ to diagnose the cross-boundary flux (rather than imposed). I guess the point here is that there is actually an apparent flux of tracer into the perturbation field because of the presence of the background. So we are imagining that the background is being maintained by some large scale circulation which is ultimately the source of this apparent flux. `FluxBoundaryCondition` can be used if you know the diffusivity a priori but otherwise it does look like it will be simpler to use `GradientBoundaryCondition` to add this apparent flux contribution to the evolution of the perturbation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2212615516
Testability,test,tests,"> @glwagner Thanks for implementing the total tracer diffusive flux at a high level. After running several tests, I found it to work exceptionally well! I conducted a series of tests: 1) comparing 1D vs 3D, 2) with and without the Coriolis force, and 3) with and without the immersed boundary. Everything looks great! Here are some simple examples on a rotated coordinate:; > ; > * 1D test with a small f:; > ; > nonconstantdiffusivity250days-theta.0.002_Nx4_Ny4_smallf_zlargerf.mp4 ; > * 3D simulation with immersed grids:; > ; > nonconstantdiffusivity8days-theta.0.2_Nx4_Ny4_immersed_3Dfields_withcrossflux.mp4 ; > The only caveat mentioned by @hdrake is that `GradientBoundaryCondition` is only being applied to the perturbation fluxes at the boundaries, i.e., `GradientBoundaryCondition(-N^2*cos(θ))` is needed to make the total buoyancy gradient to be 0. Thanks @liuchihl !",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2212615821
Usability,simpl,simple,"> @glwagner Thanks for implementing the total tracer diffusive flux at a high level. After running several tests, I found it to work exceptionally well! I conducted a series of tests: 1) comparing 1D vs 3D, 2) with and without the Coriolis force, and 3) with and without the immersed boundary. Everything looks great! Here are some simple examples on a rotated coordinate:; > ; > * 1D test with a small f:; > ; > nonconstantdiffusivity250days-theta.0.002_Nx4_Ny4_smallf_zlargerf.mp4 ; > * 3D simulation with immersed grids:; > ; > nonconstantdiffusivity8days-theta.0.2_Nx4_Ny4_immersed_3Dfields_withcrossflux.mp4 ; > The only caveat mentioned by @hdrake is that `GradientBoundaryCondition` is only being applied to the perturbation fluxes at the boundaries, i.e., `GradientBoundaryCondition(-N^2*cos(θ))` is needed to make the total buoyancy gradient to be 0. Thanks @liuchihl !",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2212615821
Testability,test,tests,"> Yeah, I've done some tests here: [#3646 (comment)](https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2211254101); > The 1D test is consistent with the analytical solution, which works great!. @liuchihl, I think @navidcy is asking about smaller unit tests that could be run in Continuous Integration (CI) to automatically test the package whenever any changes get made. The simplest test would be a 1D simulation with a background linear tracer profile with boundary conditions of $\text{Flux} = - \kappa \partial_{z} c$ at the top and bottom. The correct solution would be that nothing happens when the simulation is time-stepped.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2287291950
Usability,simpl,simplest,"> Yeah, I've done some tests here: [#3646 (comment)](https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2211254101); > The 1D test is consistent with the analytical solution, which works great!. @liuchihl, I think @navidcy is asking about smaller unit tests that could be run in Continuous Integration (CI) to automatically test the package whenever any changes get made. The simplest test would be a 1D simulation with a background linear tracer profile with boundary conditions of $\text{Flux} = - \kappa \partial_{z} c$ at the top and bottom. The correct solution would be that nothing happens when the simulation is time-stepped.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2287291950
Availability,error,error,"@liuchihl I think the best way forward is to write a simple test that illustrates the error. Then I can help fix the error to make the test pass. Once that is done, we may be ready to merge this PR. What do you think?. PS it is always best to work with minimal examples, and to paste code directly into a discussion stream (rather than providing links). This will help us keep up an efficient workflow.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2433044270
Energy Efficiency,efficient,efficient,"@liuchihl I think the best way forward is to write a simple test that illustrates the error. Then I can help fix the error to make the test pass. Once that is done, we may be ready to merge this PR. What do you think?. PS it is always best to work with minimal examples, and to paste code directly into a discussion stream (rather than providing links). This will help us keep up an efficient workflow.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2433044270
Testability,test,test,"@liuchihl I think the best way forward is to write a simple test that illustrates the error. Then I can help fix the error to make the test pass. Once that is done, we may be ready to merge this PR. What do you think?. PS it is always best to work with minimal examples, and to paste code directly into a discussion stream (rather than providing links). This will help us keep up an efficient workflow.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2433044270
Usability,simpl,simple,"@liuchihl I think the best way forward is to write a simple test that illustrates the error. Then I can help fix the error to make the test pass. Once that is done, we may be ready to merge this PR. What do you think?. PS it is always best to work with minimal examples, and to paste code directly into a discussion stream (rather than providing links). This will help us keep up an efficient workflow.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2433044270
Availability,error,error,"> @liuchihl I think the best way forward is to write a simple test that illustrates the error. Then I can help fix the error to make the test pass. Once that is done, we may be ready to merge this PR. What do you think?. Sure, I agree with that! I will work on that and let you know how it goes. . > PS it is always best to work with minimal examples, and to paste code directly into a discussion stream (rather than providing links). This will help us keep up an efficient workflow. For sure, sorry about that, I haven't been able to create an MWE for this specific issue because I don't understand the problem yet.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2433226812
Energy Efficiency,efficient,efficient,"> @liuchihl I think the best way forward is to write a simple test that illustrates the error. Then I can help fix the error to make the test pass. Once that is done, we may be ready to merge this PR. What do you think?. Sure, I agree with that! I will work on that and let you know how it goes. . > PS it is always best to work with minimal examples, and to paste code directly into a discussion stream (rather than providing links). This will help us keep up an efficient workflow. For sure, sorry about that, I haven't been able to create an MWE for this specific issue because I don't understand the problem yet.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2433226812
Testability,test,test,"> @liuchihl I think the best way forward is to write a simple test that illustrates the error. Then I can help fix the error to make the test pass. Once that is done, we may be ready to merge this PR. What do you think?. Sure, I agree with that! I will work on that and let you know how it goes. . > PS it is always best to work with minimal examples, and to paste code directly into a discussion stream (rather than providing links). This will help us keep up an efficient workflow. For sure, sorry about that, I haven't been able to create an MWE for this specific issue because I don't understand the problem yet.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2433226812
Usability,simpl,simple,"> @liuchihl I think the best way forward is to write a simple test that illustrates the error. Then I can help fix the error to make the test pass. Once that is done, we may be ready to merge this PR. What do you think?. Sure, I agree with that! I will work on that and let you know how it goes. . > PS it is always best to work with minimal examples, and to paste code directly into a discussion stream (rather than providing links). This will help us keep up an efficient workflow. For sure, sorry about that, I haven't been able to create an MWE for this specific issue because I don't understand the problem yet.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2433226812
Availability,error,error,"This does it:. ```julia; using Oceananigans; grid = RectilinearGrid(size=1, x=(0, 1), topology=(Periodic, Flat, Flat)); B(args...) = 0; background_fields = Oceananigans.BackgroundFields(; background_closure_fluxes=true, b=B); model = NonhydrostaticModel(; grid, background_fields); ```. You can use this in a test, something like. ```julia; B(args...) = 0; function time_step_background_fields_with_closure_fluxes(arch); grid = RectilinearGrid(arch, size=1, x=(0, 1), topology=(Periodic, Flat, Flat)); background_fields = Oceananigans.BackgroundFields(; background_closure_fluxes=true, b=B); model = NonhydrostaticModel(; grid, background_fields); time_step!(model, 1); return true; end. @test time_step_background_fields_with_closure_fluxes(arch); ```. If it throws an error, the test fails. This is a basic unit test which is always a good idea to write first. The next step is to write a test that confirms the functionality works _correctly_. This is an example of a hierarchy of tests proceeding from simple to complex.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2433253320
Testability,test,test,"This does it:. ```julia; using Oceananigans; grid = RectilinearGrid(size=1, x=(0, 1), topology=(Periodic, Flat, Flat)); B(args...) = 0; background_fields = Oceananigans.BackgroundFields(; background_closure_fluxes=true, b=B); model = NonhydrostaticModel(; grid, background_fields); ```. You can use this in a test, something like. ```julia; B(args...) = 0; function time_step_background_fields_with_closure_fluxes(arch); grid = RectilinearGrid(arch, size=1, x=(0, 1), topology=(Periodic, Flat, Flat)); background_fields = Oceananigans.BackgroundFields(; background_closure_fluxes=true, b=B); model = NonhydrostaticModel(; grid, background_fields); time_step!(model, 1); return true; end. @test time_step_background_fields_with_closure_fluxes(arch); ```. If it throws an error, the test fails. This is a basic unit test which is always a good idea to write first. The next step is to write a test that confirms the functionality works _correctly_. This is an example of a hierarchy of tests proceeding from simple to complex.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2433253320
Usability,simpl,simple,"This does it:. ```julia; using Oceananigans; grid = RectilinearGrid(size=1, x=(0, 1), topology=(Periodic, Flat, Flat)); B(args...) = 0; background_fields = Oceananigans.BackgroundFields(; background_closure_fluxes=true, b=B); model = NonhydrostaticModel(; grid, background_fields); ```. You can use this in a test, something like. ```julia; B(args...) = 0; function time_step_background_fields_with_closure_fluxes(arch); grid = RectilinearGrid(arch, size=1, x=(0, 1), topology=(Periodic, Flat, Flat)); background_fields = Oceananigans.BackgroundFields(; background_closure_fluxes=true, b=B); model = NonhydrostaticModel(; grid, background_fields); time_step!(model, 1); return true; end. @test time_step_background_fields_with_closure_fluxes(arch); ```. If it throws an error, the test fails. This is a basic unit test which is always a good idea to write first. The next step is to write a test that confirms the functionality works _correctly_. This is an example of a hierarchy of tests proceeding from simple to complex.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2433253320
Testability,test,tests,"To summarize where we're at: we need at least two unit tests:; - a functionality test, like as proposed and implemented by @glwagner [here]:(https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2433253320); ```julia; B(args...) = 0; function time_step_background_fields_with_closure_fluxes(arch); grid = RectilinearGrid(arch, size=1, x=(0, 1), topology=(Periodic, Flat, Flat)); background_fields = Oceananigans.BackgroundFields(; background_closure_fluxes=true, b=B); model = NonhydrostaticModel(; grid, background_fields); time_step!(model, 1); return true; end; ```. @test time_step_background_fields_with_closure_fluxes(arch). - a correctness test, like the 1D diffusion example I proposed [here](https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2287291950) but have not yet implemented:; > The simplest test would be a 1D simulation with a background linear tracer profile with boundary conditions of Flux = − κ ∂ z c at the top and bottom. The correct solution would be that nothing happens when the simulation is time-stepped.; ; @liuchihl, can you create a PR into [Greg's branch](https://github.com/CliMA/Oceananigans.jl/tree/glw/background-flux-divergence) that adds both of these tests to the test suite?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2433768523
Usability,simpl,simplest,"To summarize where we're at: we need at least two unit tests:; - a functionality test, like as proposed and implemented by @glwagner [here]:(https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2433253320); ```julia; B(args...) = 0; function time_step_background_fields_with_closure_fluxes(arch); grid = RectilinearGrid(arch, size=1, x=(0, 1), topology=(Periodic, Flat, Flat)); background_fields = Oceananigans.BackgroundFields(; background_closure_fluxes=true, b=B); model = NonhydrostaticModel(; grid, background_fields); time_step!(model, 1); return true; end; ```. @test time_step_background_fields_with_closure_fluxes(arch). - a correctness test, like the 1D diffusion example I proposed [here](https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2287291950) but have not yet implemented:; > The simplest test would be a 1D simulation with a background linear tracer profile with boundary conditions of Flux = − κ ∂ z c at the top and bottom. The correct solution would be that nothing happens when the simulation is time-stepped.; ; @liuchihl, can you create a PR into [Greg's branch](https://github.com/CliMA/Oceananigans.jl/tree/glw/background-flux-divergence) that adds both of these tests to the test suite?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2433768523
Testability,test,test,"And note that we only really need a unit test to merge this, same for many things. Correctness is a high bar and it's ok if we can't come up wtih someone right away. Sometimes we don't really have a way to do correctness and our best option is something like a regression test (eg we verified it worked at one point, so we just make sure that it keeps returning that same result). . One way to go partway towards functional test but not all the way to ""correctness"" is to simply test that a simple set up returns a different result when closure fluxes are included vs not (for example).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2433794044
Usability,simpl,simply,"And note that we only really need a unit test to merge this, same for many things. Correctness is a high bar and it's ok if we can't come up wtih someone right away. Sometimes we don't really have a way to do correctness and our best option is something like a regression test (eg we verified it worked at one point, so we just make sure that it keeps returning that same result). . One way to go partway towards functional test but not all the way to ""correctness"" is to simply test that a simple set up returns a different result when closure fluxes are included vs not (for example).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2433794044
Availability,error,error,"Update: I have been able to reduce the error to be a procompiling error in oceananigans.jl:; ```; ERROR: LoadError: Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to ""/glade/u/home/knudsenl/.julia/compiled/v1.9/Oceananigans/jl_AMNEzH"".; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::IO, internal_stdout::IO, keep_loaded_modules::Bool); @ Base ./loading.jl:2300; [3] compilecache; @ ./loading.jl:2167 [inlined]; [4] _require(pkg::Base.PkgId, env::String); @ Base ./loading.jl:1805; [5] _require_prelocked(uuidkey::Base.PkgId, env::String); @ Base ./loading.jl:1660; [6] macro expansion; @ ./loading.jl:1648 [inlined]; [7] macro expansion; @ ./lock.jl:267 [inlined]; [8] require(into::Module, mod::Symbol); @ Base ./loading.jl:1611; in expression starting at /glade/derecho/scratch/knudsenl/BottomBoundaryLayer/testcode.jl:1; ```; I have been trying to make sure that everything is up to date, and I am running on Julia version 1.9.2. My code is just; ```; using Oceananingans; ```; as I have been trying to get the library to load properly. Does anyone have any experience with this error or does it make things any clearer?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2233710372
Energy Efficiency,reduce,reduce,"Update: I have been able to reduce the error to be a procompiling error in oceananigans.jl:; ```; ERROR: LoadError: Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to ""/glade/u/home/knudsenl/.julia/compiled/v1.9/Oceananigans/jl_AMNEzH"".; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::IO, internal_stdout::IO, keep_loaded_modules::Bool); @ Base ./loading.jl:2300; [3] compilecache; @ ./loading.jl:2167 [inlined]; [4] _require(pkg::Base.PkgId, env::String); @ Base ./loading.jl:1805; [5] _require_prelocked(uuidkey::Base.PkgId, env::String); @ Base ./loading.jl:1660; [6] macro expansion; @ ./loading.jl:1648 [inlined]; [7] macro expansion; @ ./lock.jl:267 [inlined]; [8] require(into::Module, mod::Symbol); @ Base ./loading.jl:1611; in expression starting at /glade/derecho/scratch/knudsenl/BottomBoundaryLayer/testcode.jl:1; ```; I have been trying to make sure that everything is up to date, and I am running on Julia version 1.9.2. My code is just; ```; using Oceananingans; ```; as I have been trying to get the library to load properly. Does anyone have any experience with this error or does it make things any clearer?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2233710372
Performance,load,loading,"Update: I have been able to reduce the error to be a procompiling error in oceananigans.jl:; ```; ERROR: LoadError: Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to ""/glade/u/home/knudsenl/.julia/compiled/v1.9/Oceananigans/jl_AMNEzH"".; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::IO, internal_stdout::IO, keep_loaded_modules::Bool); @ Base ./loading.jl:2300; [3] compilecache; @ ./loading.jl:2167 [inlined]; [4] _require(pkg::Base.PkgId, env::String); @ Base ./loading.jl:1805; [5] _require_prelocked(uuidkey::Base.PkgId, env::String); @ Base ./loading.jl:1660; [6] macro expansion; @ ./loading.jl:1648 [inlined]; [7] macro expansion; @ ./lock.jl:267 [inlined]; [8] require(into::Module, mod::Symbol); @ Base ./loading.jl:1611; in expression starting at /glade/derecho/scratch/knudsenl/BottomBoundaryLayer/testcode.jl:1; ```; I have been trying to make sure that everything is up to date, and I am running on Julia version 1.9.2. My code is just; ```; using Oceananingans; ```; as I have been trying to get the library to load properly. Does anyone have any experience with this error or does it make things any clearer?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2233710372
Testability,test,testcode,"Update: I have been able to reduce the error to be a procompiling error in oceananigans.jl:; ```; ERROR: LoadError: Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to ""/glade/u/home/knudsenl/.julia/compiled/v1.9/Oceananigans/jl_AMNEzH"".; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::IO, internal_stdout::IO, keep_loaded_modules::Bool); @ Base ./loading.jl:2300; [3] compilecache; @ ./loading.jl:2167 [inlined]; [4] _require(pkg::Base.PkgId, env::String); @ Base ./loading.jl:1805; [5] _require_prelocked(uuidkey::Base.PkgId, env::String); @ Base ./loading.jl:1660; [6] macro expansion; @ ./loading.jl:1648 [inlined]; [7] macro expansion; @ ./lock.jl:267 [inlined]; [8] require(into::Module, mod::Symbol); @ Base ./loading.jl:1611; in expression starting at /glade/derecho/scratch/knudsenl/BottomBoundaryLayer/testcode.jl:1; ```; I have been trying to make sure that everything is up to date, and I am running on Julia version 1.9.2. My code is just; ```; using Oceananingans; ```; as I have been trying to get the library to load properly. Does anyone have any experience with this error or does it make things any clearer?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2233710372
Usability,clear,clearer,"Update: I have been able to reduce the error to be a procompiling error in oceananigans.jl:; ```; ERROR: LoadError: Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to ""/glade/u/home/knudsenl/.julia/compiled/v1.9/Oceananigans/jl_AMNEzH"".; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::IO, internal_stdout::IO, keep_loaded_modules::Bool); @ Base ./loading.jl:2300; [3] compilecache; @ ./loading.jl:2167 [inlined]; [4] _require(pkg::Base.PkgId, env::String); @ Base ./loading.jl:1805; [5] _require_prelocked(uuidkey::Base.PkgId, env::String); @ Base ./loading.jl:1660; [6] macro expansion; @ ./loading.jl:1648 [inlined]; [7] macro expansion; @ ./lock.jl:267 [inlined]; [8] require(into::Module, mod::Symbol); @ Base ./loading.jl:1611; in expression starting at /glade/derecho/scratch/knudsenl/BottomBoundaryLayer/testcode.jl:1; ```; I have been trying to make sure that everything is up to date, and I am running on Julia version 1.9.2. My code is just; ```; using Oceananingans; ```; as I have been trying to get the library to load properly. Does anyone have any experience with this error or does it make things any clearer?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2233710372
Availability,fault,fault,"Can you tell us a bit more about your system?. What is `versioninfo(verbose=true)` and `] status -m`?. Was there anything more printed above the message that precompilation; failed?. One thing you might want to try is using Julia 1.10, instead of 1.9, but; right now I don't have information to pinpoint what is causing the; segmentation fault. On Wed, Jul 17, 2024, 12:23 Logan Knudsen ***@***.***> wrote:. > Update: I have been able to reduce the error to be a procompiling error in; > oceananigans.jl:; >; > ERROR: LoadError: Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to ""/glade/u/home/knudsenl/.julia/compiled/v1.9/Oceananigans/jl_AMNEzH"".; > Stacktrace:; > [1] error(s::String); > @ Base ./error.jl:35; > [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::IO, internal_stdout::IO, keep_loaded_modules::Bool); > @ Base ./loading.jl:2300; > [3] compilecache; > @ ./loading.jl:2167 [inlined]; > [4] _require(pkg::Base.PkgId, env::String); > @ Base ./loading.jl:1805; > [5] _require_prelocked(uuidkey::Base.PkgId, env::String); > @ Base ./loading.jl:1660; > [6] macro expansion; > @ ./loading.jl:1648 [inlined]; > [7] macro expansion; > @ ./lock.jl:267 [inlined]; > [8] require(into::Module, mod::Symbol); > @ Base ./loading.jl:1611; > in expression starting at /glade/derecho/scratch/knudsenl/BottomBoundaryLayer/testcode.jl:1; >; > I have been trying to make sure that everything is up to date, and I am; > running on Julia version 1.9.2. My code is just; >; > using Oceananingans; >; > as I have been trying to get the library to loas properly. Does anyone; > have any experience with this error or does it make things any clearer?; >; > —; > Reply to this email directly, view it on GitHub; > <https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2233710372>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/AABDO2XAIMUIHCDCBIJA4NLZM2K75AVCNFSM6AAAAABK643UJWVHI2DSMVQWIX3LMV43OSLTON2WKQ3PNVWWK3TUHMZDEMZTG4YTAMZXGI",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2233731098
Energy Efficiency,reduce,reduce,"Can you tell us a bit more about your system?. What is `versioninfo(verbose=true)` and `] status -m`?. Was there anything more printed above the message that precompilation; failed?. One thing you might want to try is using Julia 1.10, instead of 1.9, but; right now I don't have information to pinpoint what is causing the; segmentation fault. On Wed, Jul 17, 2024, 12:23 Logan Knudsen ***@***.***> wrote:. > Update: I have been able to reduce the error to be a procompiling error in; > oceananigans.jl:; >; > ERROR: LoadError: Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to ""/glade/u/home/knudsenl/.julia/compiled/v1.9/Oceananigans/jl_AMNEzH"".; > Stacktrace:; > [1] error(s::String); > @ Base ./error.jl:35; > [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::IO, internal_stdout::IO, keep_loaded_modules::Bool); > @ Base ./loading.jl:2300; > [3] compilecache; > @ ./loading.jl:2167 [inlined]; > [4] _require(pkg::Base.PkgId, env::String); > @ Base ./loading.jl:1805; > [5] _require_prelocked(uuidkey::Base.PkgId, env::String); > @ Base ./loading.jl:1660; > [6] macro expansion; > @ ./loading.jl:1648 [inlined]; > [7] macro expansion; > @ ./lock.jl:267 [inlined]; > [8] require(into::Module, mod::Symbol); > @ Base ./loading.jl:1611; > in expression starting at /glade/derecho/scratch/knudsenl/BottomBoundaryLayer/testcode.jl:1; >; > I have been trying to make sure that everything is up to date, and I am; > running on Julia version 1.9.2. My code is just; >; > using Oceananingans; >; > as I have been trying to get the library to loas properly. Does anyone; > have any experience with this error or does it make things any clearer?; >; > —; > Reply to this email directly, view it on GitHub; > <https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2233710372>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/AABDO2XAIMUIHCDCBIJA4NLZM2K75AVCNFSM6AAAAABK643UJWVHI2DSMVQWIX3LMV43OSLTON2WKQ3PNVWWK3TUHMZDEMZTG4YTAMZXGI",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2233731098
Integrability,message,message,"Can you tell us a bit more about your system?. What is `versioninfo(verbose=true)` and `] status -m`?. Was there anything more printed above the message that precompilation; failed?. One thing you might want to try is using Julia 1.10, instead of 1.9, but; right now I don't have information to pinpoint what is causing the; segmentation fault. On Wed, Jul 17, 2024, 12:23 Logan Knudsen ***@***.***> wrote:. > Update: I have been able to reduce the error to be a procompiling error in; > oceananigans.jl:; >; > ERROR: LoadError: Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to ""/glade/u/home/knudsenl/.julia/compiled/v1.9/Oceananigans/jl_AMNEzH"".; > Stacktrace:; > [1] error(s::String); > @ Base ./error.jl:35; > [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::IO, internal_stdout::IO, keep_loaded_modules::Bool); > @ Base ./loading.jl:2300; > [3] compilecache; > @ ./loading.jl:2167 [inlined]; > [4] _require(pkg::Base.PkgId, env::String); > @ Base ./loading.jl:1805; > [5] _require_prelocked(uuidkey::Base.PkgId, env::String); > @ Base ./loading.jl:1660; > [6] macro expansion; > @ ./loading.jl:1648 [inlined]; > [7] macro expansion; > @ ./lock.jl:267 [inlined]; > [8] require(into::Module, mod::Symbol); > @ Base ./loading.jl:1611; > in expression starting at /glade/derecho/scratch/knudsenl/BottomBoundaryLayer/testcode.jl:1; >; > I have been trying to make sure that everything is up to date, and I am; > running on Julia version 1.9.2. My code is just; >; > using Oceananingans; >; > as I have been trying to get the library to loas properly. Does anyone; > have any experience with this error or does it make things any clearer?; >; > —; > Reply to this email directly, view it on GitHub; > <https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2233710372>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/AABDO2XAIMUIHCDCBIJA4NLZM2K75AVCNFSM6AAAAABK643UJWVHI2DSMVQWIX3LMV43OSLTON2WKQ3PNVWWK3TUHMZDEMZTG4YTAMZXGI",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2233731098
Performance,load,loading,"Can you tell us a bit more about your system?. What is `versioninfo(verbose=true)` and `] status -m`?. Was there anything more printed above the message that precompilation; failed?. One thing you might want to try is using Julia 1.10, instead of 1.9, but; right now I don't have information to pinpoint what is causing the; segmentation fault. On Wed, Jul 17, 2024, 12:23 Logan Knudsen ***@***.***> wrote:. > Update: I have been able to reduce the error to be a procompiling error in; > oceananigans.jl:; >; > ERROR: LoadError: Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to ""/glade/u/home/knudsenl/.julia/compiled/v1.9/Oceananigans/jl_AMNEzH"".; > Stacktrace:; > [1] error(s::String); > @ Base ./error.jl:35; > [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::IO, internal_stdout::IO, keep_loaded_modules::Bool); > @ Base ./loading.jl:2300; > [3] compilecache; > @ ./loading.jl:2167 [inlined]; > [4] _require(pkg::Base.PkgId, env::String); > @ Base ./loading.jl:1805; > [5] _require_prelocked(uuidkey::Base.PkgId, env::String); > @ Base ./loading.jl:1660; > [6] macro expansion; > @ ./loading.jl:1648 [inlined]; > [7] macro expansion; > @ ./lock.jl:267 [inlined]; > [8] require(into::Module, mod::Symbol); > @ Base ./loading.jl:1611; > in expression starting at /glade/derecho/scratch/knudsenl/BottomBoundaryLayer/testcode.jl:1; >; > I have been trying to make sure that everything is up to date, and I am; > running on Julia version 1.9.2. My code is just; >; > using Oceananingans; >; > as I have been trying to get the library to loas properly. Does anyone; > have any experience with this error or does it make things any clearer?; >; > —; > Reply to this email directly, view it on GitHub; > <https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2233710372>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/AABDO2XAIMUIHCDCBIJA4NLZM2K75AVCNFSM6AAAAABK643UJWVHI2DSMVQWIX3LMV43OSLTON2WKQ3PNVWWK3TUHMZDEMZTG4YTAMZXGI",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2233731098
Testability,test,testcode," `] status -m`?. Was there anything more printed above the message that precompilation; failed?. One thing you might want to try is using Julia 1.10, instead of 1.9, but; right now I don't have information to pinpoint what is causing the; segmentation fault. On Wed, Jul 17, 2024, 12:23 Logan Knudsen ***@***.***> wrote:. > Update: I have been able to reduce the error to be a procompiling error in; > oceananigans.jl:; >; > ERROR: LoadError: Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to ""/glade/u/home/knudsenl/.julia/compiled/v1.9/Oceananigans/jl_AMNEzH"".; > Stacktrace:; > [1] error(s::String); > @ Base ./error.jl:35; > [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::IO, internal_stdout::IO, keep_loaded_modules::Bool); > @ Base ./loading.jl:2300; > [3] compilecache; > @ ./loading.jl:2167 [inlined]; > [4] _require(pkg::Base.PkgId, env::String); > @ Base ./loading.jl:1805; > [5] _require_prelocked(uuidkey::Base.PkgId, env::String); > @ Base ./loading.jl:1660; > [6] macro expansion; > @ ./loading.jl:1648 [inlined]; > [7] macro expansion; > @ ./lock.jl:267 [inlined]; > [8] require(into::Module, mod::Symbol); > @ Base ./loading.jl:1611; > in expression starting at /glade/derecho/scratch/knudsenl/BottomBoundaryLayer/testcode.jl:1; >; > I have been trying to make sure that everything is up to date, and I am; > running on Julia version 1.9.2. My code is just; >; > using Oceananingans; >; > as I have been trying to get the library to loas properly. Does anyone; > have any experience with this error or does it make things any clearer?; >; > —; > Reply to this email directly, view it on GitHub; > <https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2233710372>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/AABDO2XAIMUIHCDCBIJA4NLZM2K75AVCNFSM6AAAAABK643UJWVHI2DSMVQWIX3LMV43OSLTON2WKQ3PNVWWK3TUHMZDEMZTG4YTAMZXGI>; > .; > You are receiving this because you commented.Message ID:; > ***@***.***>; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2233731098
Usability,clear,clearer," `] status -m`?. Was there anything more printed above the message that precompilation; failed?. One thing you might want to try is using Julia 1.10, instead of 1.9, but; right now I don't have information to pinpoint what is causing the; segmentation fault. On Wed, Jul 17, 2024, 12:23 Logan Knudsen ***@***.***> wrote:. > Update: I have been able to reduce the error to be a procompiling error in; > oceananigans.jl:; >; > ERROR: LoadError: Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to ""/glade/u/home/knudsenl/.julia/compiled/v1.9/Oceananigans/jl_AMNEzH"".; > Stacktrace:; > [1] error(s::String); > @ Base ./error.jl:35; > [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::IO, internal_stdout::IO, keep_loaded_modules::Bool); > @ Base ./loading.jl:2300; > [3] compilecache; > @ ./loading.jl:2167 [inlined]; > [4] _require(pkg::Base.PkgId, env::String); > @ Base ./loading.jl:1805; > [5] _require_prelocked(uuidkey::Base.PkgId, env::String); > @ Base ./loading.jl:1660; > [6] macro expansion; > @ ./loading.jl:1648 [inlined]; > [7] macro expansion; > @ ./lock.jl:267 [inlined]; > [8] require(into::Module, mod::Symbol); > @ Base ./loading.jl:1611; > in expression starting at /glade/derecho/scratch/knudsenl/BottomBoundaryLayer/testcode.jl:1; >; > I have been trying to make sure that everything is up to date, and I am; > running on Julia version 1.9.2. My code is just; >; > using Oceananingans; >; > as I have been trying to get the library to loas properly. Does anyone; > have any experience with this error or does it make things any clearer?; >; > —; > Reply to this email directly, view it on GitHub; > <https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2233710372>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/AABDO2XAIMUIHCDCBIJA4NLZM2K75AVCNFSM6AAAAABK643UJWVHI2DSMVQWIX3LMV43OSLTON2WKQ3PNVWWK3TUHMZDEMZTG4YTAMZXGI>; > .; > You are receiving this because you commented.Message ID:; > ***@***.***>; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2233731098
Availability,error,error,"I don't know if this helps to make the issue clearer, but I just re-ran the code for just ; ```; using Oceananigans ; ```; and it executed without error. I ran it again to see if it was just a fluke and I got the following error:; ```. The following have been reloaded with a version change:; 1) cuda/12.2.1 => cuda/11.8.0. [59837] signal (11.1): Segmentation fault; in expression starting at /glade/derecho/scratch/knudsenl/BottomBoundaryLayer/testcode.jl:1; Allocations: 605144 (Pool: 604223; Big: 921); GC: 1; /var/spool/pbs/mom_priv/jobs/1741845.casper-pbs.SC: line 31: 59837 Segmentation fault (core dumped) julia --project testcode.jl /glade/derecho/scratch/knudsenl/BottomBoundaryLayer/; ```; Could it be an issue with the computer loading Oceananigans.jl with a bunch of extra functions?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2237133645
Performance,load,loading,"I don't know if this helps to make the issue clearer, but I just re-ran the code for just ; ```; using Oceananigans ; ```; and it executed without error. I ran it again to see if it was just a fluke and I got the following error:; ```. The following have been reloaded with a version change:; 1) cuda/12.2.1 => cuda/11.8.0. [59837] signal (11.1): Segmentation fault; in expression starting at /glade/derecho/scratch/knudsenl/BottomBoundaryLayer/testcode.jl:1; Allocations: 605144 (Pool: 604223; Big: 921); GC: 1; /var/spool/pbs/mom_priv/jobs/1741845.casper-pbs.SC: line 31: 59837 Segmentation fault (core dumped) julia --project testcode.jl /glade/derecho/scratch/knudsenl/BottomBoundaryLayer/; ```; Could it be an issue with the computer loading Oceananigans.jl with a bunch of extra functions?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2237133645
Testability,test,testcode,"I don't know if this helps to make the issue clearer, but I just re-ran the code for just ; ```; using Oceananigans ; ```; and it executed without error. I ran it again to see if it was just a fluke and I got the following error:; ```. The following have been reloaded with a version change:; 1) cuda/12.2.1 => cuda/11.8.0. [59837] signal (11.1): Segmentation fault; in expression starting at /glade/derecho/scratch/knudsenl/BottomBoundaryLayer/testcode.jl:1; Allocations: 605144 (Pool: 604223; Big: 921); GC: 1; /var/spool/pbs/mom_priv/jobs/1741845.casper-pbs.SC: line 31: 59837 Segmentation fault (core dumped) julia --project testcode.jl /glade/derecho/scratch/knudsenl/BottomBoundaryLayer/; ```; Could it be an issue with the computer loading Oceananigans.jl with a bunch of extra functions?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2237133645
Usability,clear,clearer,"I don't know if this helps to make the issue clearer, but I just re-ran the code for just ; ```; using Oceananigans ; ```; and it executed without error. I ran it again to see if it was just a fluke and I got the following error:; ```. The following have been reloaded with a version change:; 1) cuda/12.2.1 => cuda/11.8.0. [59837] signal (11.1): Segmentation fault; in expression starting at /glade/derecho/scratch/knudsenl/BottomBoundaryLayer/testcode.jl:1; Allocations: 605144 (Pool: 604223; Big: 921); GC: 1; /var/spool/pbs/mom_priv/jobs/1741845.casper-pbs.SC: line 31: 59837 Segmentation fault (core dumped) julia --project testcode.jl /glade/derecho/scratch/knudsenl/BottomBoundaryLayer/; ```; Could it be an issue with the computer loading Oceananigans.jl with a bunch of extra functions?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2237133645
Availability,error,error,"Just to clarify things a bit for you @loganpknudsen --- your error says. > ERROR: LoadError: Failed to precompile Oceananigans. this means that the segmentation fault occurs during precompilation of `Oceananigans`, which occurs before any code you have written executes. That's why the error comes from ""line 1"" of your script (is that where you write `using Oceananigans`?). Another clue is the text. > [52922] signal (11.1): Segmentation fault; > in expression starting at /glade/u/home/knudsenl/.julia/packages/Oceananigans/M82LU/src/Oceananigans.jl:129. That says the error comes from line 129 in the file `src/Oceananigans.jl`. Going to that line on `main` branch we find:. https://github.com/CliMA/Oceananigans.jl/blob/d6e63e53e795272378b7657c4a6f32da2d62d6f9/src/Oceananigans.jl#L129. so there's something wrong with your CUDA / how it's loaded. The best course of action is probably to update to julia 1.10 first of all rather than using julia 1.9.2. Next, see if you can simply write `using CUDA` rather than trying to run your whole script. If you can get that to work (better yet if you can use some of `CUDA.jl` on a GPU on derecho then move on to simply writing `using Oceananigans` and trying to build a grid on the GPU. If that succeeds move on to your script.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2240940342
Deployability,update,update,"Just to clarify things a bit for you @loganpknudsen --- your error says. > ERROR: LoadError: Failed to precompile Oceananigans. this means that the segmentation fault occurs during precompilation of `Oceananigans`, which occurs before any code you have written executes. That's why the error comes from ""line 1"" of your script (is that where you write `using Oceananigans`?). Another clue is the text. > [52922] signal (11.1): Segmentation fault; > in expression starting at /glade/u/home/knudsenl/.julia/packages/Oceananigans/M82LU/src/Oceananigans.jl:129. That says the error comes from line 129 in the file `src/Oceananigans.jl`. Going to that line on `main` branch we find:. https://github.com/CliMA/Oceananigans.jl/blob/d6e63e53e795272378b7657c4a6f32da2d62d6f9/src/Oceananigans.jl#L129. so there's something wrong with your CUDA / how it's loaded. The best course of action is probably to update to julia 1.10 first of all rather than using julia 1.9.2. Next, see if you can simply write `using CUDA` rather than trying to run your whole script. If you can get that to work (better yet if you can use some of `CUDA.jl` on a GPU on derecho then move on to simply writing `using Oceananigans` and trying to build a grid on the GPU. If that succeeds move on to your script.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2240940342
Performance,load,loaded,"Just to clarify things a bit for you @loganpknudsen --- your error says. > ERROR: LoadError: Failed to precompile Oceananigans. this means that the segmentation fault occurs during precompilation of `Oceananigans`, which occurs before any code you have written executes. That's why the error comes from ""line 1"" of your script (is that where you write `using Oceananigans`?). Another clue is the text. > [52922] signal (11.1): Segmentation fault; > in expression starting at /glade/u/home/knudsenl/.julia/packages/Oceananigans/M82LU/src/Oceananigans.jl:129. That says the error comes from line 129 in the file `src/Oceananigans.jl`. Going to that line on `main` branch we find:. https://github.com/CliMA/Oceananigans.jl/blob/d6e63e53e795272378b7657c4a6f32da2d62d6f9/src/Oceananigans.jl#L129. so there's something wrong with your CUDA / how it's loaded. The best course of action is probably to update to julia 1.10 first of all rather than using julia 1.9.2. Next, see if you can simply write `using CUDA` rather than trying to run your whole script. If you can get that to work (better yet if you can use some of `CUDA.jl` on a GPU on derecho then move on to simply writing `using Oceananigans` and trying to build a grid on the GPU. If that succeeds move on to your script.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2240940342
Testability,log,loganpknudsen,"Just to clarify things a bit for you @loganpknudsen --- your error says. > ERROR: LoadError: Failed to precompile Oceananigans. this means that the segmentation fault occurs during precompilation of `Oceananigans`, which occurs before any code you have written executes. That's why the error comes from ""line 1"" of your script (is that where you write `using Oceananigans`?). Another clue is the text. > [52922] signal (11.1): Segmentation fault; > in expression starting at /glade/u/home/knudsenl/.julia/packages/Oceananigans/M82LU/src/Oceananigans.jl:129. That says the error comes from line 129 in the file `src/Oceananigans.jl`. Going to that line on `main` branch we find:. https://github.com/CliMA/Oceananigans.jl/blob/d6e63e53e795272378b7657c4a6f32da2d62d6f9/src/Oceananigans.jl#L129. so there's something wrong with your CUDA / how it's loaded. The best course of action is probably to update to julia 1.10 first of all rather than using julia 1.9.2. Next, see if you can simply write `using CUDA` rather than trying to run your whole script. If you can get that to work (better yet if you can use some of `CUDA.jl` on a GPU on derecho then move on to simply writing `using Oceananigans` and trying to build a grid on the GPU. If that succeeds move on to your script.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2240940342
Usability,simpl,simply,"Just to clarify things a bit for you @loganpknudsen --- your error says. > ERROR: LoadError: Failed to precompile Oceananigans. this means that the segmentation fault occurs during precompilation of `Oceananigans`, which occurs before any code you have written executes. That's why the error comes from ""line 1"" of your script (is that where you write `using Oceananigans`?). Another clue is the text. > [52922] signal (11.1): Segmentation fault; > in expression starting at /glade/u/home/knudsenl/.julia/packages/Oceananigans/M82LU/src/Oceananigans.jl:129. That says the error comes from line 129 in the file `src/Oceananigans.jl`. Going to that line on `main` branch we find:. https://github.com/CliMA/Oceananigans.jl/blob/d6e63e53e795272378b7657c4a6f32da2d62d6f9/src/Oceananigans.jl#L129. so there's something wrong with your CUDA / how it's loaded. The best course of action is probably to update to julia 1.10 first of all rather than using julia 1.9.2. Next, see if you can simply write `using CUDA` rather than trying to run your whole script. If you can get that to work (better yet if you can use some of `CUDA.jl` on a GPU on derecho then move on to simply writing `using Oceananigans` and trying to build a grid on the GPU. If that succeeds move on to your script.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2240940342
Deployability,install,installing,"Okay interesting!. I'm not sure why you would need `gcc`. Have you tried omitting that?. Also, did you try installing julia yourself? There could be some benefit in using the system Julia via `module load julia/1.9.2`, but this would mostly have to do with compilation speed (not execution speed) I think. If you have found discrepancy between the system Julia vs your own Julia install that'd be interesting to hear about... You could also let julia handle netcdf --- again, I'm not sure if this would have performance implications or not, but it might provide faster way to get up and running if you are simply trying to run scripts. Julia's package manager should be able to automatically detect and install netcdf appropriate for the system, I think.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2258884823
Performance,load,load,"Okay interesting!. I'm not sure why you would need `gcc`. Have you tried omitting that?. Also, did you try installing julia yourself? There could be some benefit in using the system Julia via `module load julia/1.9.2`, but this would mostly have to do with compilation speed (not execution speed) I think. If you have found discrepancy between the system Julia vs your own Julia install that'd be interesting to hear about... You could also let julia handle netcdf --- again, I'm not sure if this would have performance implications or not, but it might provide faster way to get up and running if you are simply trying to run scripts. Julia's package manager should be able to automatically detect and install netcdf appropriate for the system, I think.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2258884823
Safety,detect,detect,"Okay interesting!. I'm not sure why you would need `gcc`. Have you tried omitting that?. Also, did you try installing julia yourself? There could be some benefit in using the system Julia via `module load julia/1.9.2`, but this would mostly have to do with compilation speed (not execution speed) I think. If you have found discrepancy between the system Julia vs your own Julia install that'd be interesting to hear about... You could also let julia handle netcdf --- again, I'm not sure if this would have performance implications or not, but it might provide faster way to get up and running if you are simply trying to run scripts. Julia's package manager should be able to automatically detect and install netcdf appropriate for the system, I think.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2258884823
Usability,simpl,simply,"Okay interesting!. I'm not sure why you would need `gcc`. Have you tried omitting that?. Also, did you try installing julia yourself? There could be some benefit in using the system Julia via `module load julia/1.9.2`, but this would mostly have to do with compilation speed (not execution speed) I think. If you have found discrepancy between the system Julia vs your own Julia install that'd be interesting to hear about... You could also let julia handle netcdf --- again, I'm not sure if this would have performance implications or not, but it might provide faster way to get up and running if you are simply trying to run scripts. Julia's package manager should be able to automatically detect and install netcdf appropriate for the system, I think.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2258884823
Availability,checkpoint,checkpoint,"I attempted to reproduce the issue using the 1D diffusion example in the same environment, but I was unable to do so. After picking up the checkpoint, the output saving interval looked normal (not saving every iteration). The simple example is demonstrated as follows: [here](https://github.com/liuchihl/internal-tide-mixing/blob/3D-realtopo-delta-glw-background-flux-div/oneD_diffusion_checkpoint_test.jl). . Our initial guess is that it might be related to #3056. However, after conducting some tests, such as avoiding setting intervals to transcendental numbers, the output saving interval after picking up the checkpoint is still 1 iteration for a while (which is not the desired behavior). I noticed that when I use `IterationInterval` instead of `TimeInterval`, the problem is resolved.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3657#issuecomment-2244122542
Safety,avoid,avoiding,"I attempted to reproduce the issue using the 1D diffusion example in the same environment, but I was unable to do so. After picking up the checkpoint, the output saving interval looked normal (not saving every iteration). The simple example is demonstrated as follows: [here](https://github.com/liuchihl/internal-tide-mixing/blob/3D-realtopo-delta-glw-background-flux-div/oneD_diffusion_checkpoint_test.jl). . Our initial guess is that it might be related to #3056. However, after conducting some tests, such as avoiding setting intervals to transcendental numbers, the output saving interval after picking up the checkpoint is still 1 iteration for a while (which is not the desired behavior). I noticed that when I use `IterationInterval` instead of `TimeInterval`, the problem is resolved.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3657#issuecomment-2244122542
Testability,test,tests,"I attempted to reproduce the issue using the 1D diffusion example in the same environment, but I was unable to do so. After picking up the checkpoint, the output saving interval looked normal (not saving every iteration). The simple example is demonstrated as follows: [here](https://github.com/liuchihl/internal-tide-mixing/blob/3D-realtopo-delta-glw-background-flux-div/oneD_diffusion_checkpoint_test.jl). . Our initial guess is that it might be related to #3056. However, after conducting some tests, such as avoiding setting intervals to transcendental numbers, the output saving interval after picking up the checkpoint is still 1 iteration for a while (which is not the desired behavior). I noticed that when I use `IterationInterval` instead of `TimeInterval`, the problem is resolved.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3657#issuecomment-2244122542
Usability,simpl,simple,"I attempted to reproduce the issue using the 1D diffusion example in the same environment, but I was unable to do so. After picking up the checkpoint, the output saving interval looked normal (not saving every iteration). The simple example is demonstrated as follows: [here](https://github.com/liuchihl/internal-tide-mixing/blob/3D-realtopo-delta-glw-background-flux-div/oneD_diffusion_checkpoint_test.jl). . Our initial guess is that it might be related to #3056. However, after conducting some tests, such as avoiding setting intervals to transcendental numbers, the output saving interval after picking up the checkpoint is still 1 iteration for a while (which is not the desired behavior). I noticed that when I use `IterationInterval` instead of `TimeInterval`, the problem is resolved.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3657#issuecomment-2244122542
Availability,checkpoint,checkpoint,"Okay, here's my MWE which includes running the first simulation to generate the checkpoint file:. ```julia; using Oceananigans; using Printf. """""" Set up a simple simulation to test picking up from a checkpoint. """"""; function test_simulation(stop_time, Δt, δt); grid = RectilinearGrid(size=(), topology=(Flat, Flat, Flat)); model = NonhydrostaticModel(; grid); simulation = Simulation(model; Δt, stop_time). progress_message(sim) = @info string(""Iter: "", iteration(sim), "", time: "", prettytime(sim)); simulation.callbacks[:progress] = Callback(progress_message, TimeInterval(δt)). checkpointer = Checkpointer(model,; schedule = TimeInterval(stop_time),; prefix = ""test"",; cleanup = false). simulation.output_writers[:checkpointer] = checkpointer. return simulation; end. rm(""test_iteration*.jld2"", force=true). Δt = 1 # timestep (s); T1 = 4 # first simulation stop time (s); T2 = 2T1 # second simulation stop time (s); δt = 2 # progress message frequency. # Run a simulation that saves data to a checkpoint; simulation = test_simulation(T1, Δt, δt); run!(simulation). # Now try again, but picking up from the previous checkpoint; N = iteration(simulation); checkpoint = ""test_iteration$N.jld2""; simulation = test_simulation(T2, Δt, δt); run!(simulation, pickup=checkpoint); ```. This reproduces the issue because I get. ```julia; julia> include(""test.jl""); [ Info: Initializing simulation...; [ Info: Iter: 0, time: 0 seconds; [ Info: ... simulation initialization complete (2.697 seconds); [ Info: Executing initial time step...; [ Info: ... initial time step complete (5.721 seconds).; [ Info: Iter: 2, time: 2 seconds; [ Info: Simulation is stopping after running for 8.786 seconds.; [ Info: Simulation time 4 seconds equals or exceeds stop time 4 seconds.; [ Info: Iter: 4, time: 4 seconds; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (529.973 μs); [ Info: Executing initial time step...; [ Info: ... initial time step complete (575.447 μs).; [ Info: Iter: 5,",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3657#issuecomment-2246064310
Energy Efficiency,schedul,schedule,"Okay, here's my MWE which includes running the first simulation to generate the checkpoint file:. ```julia; using Oceananigans; using Printf. """""" Set up a simple simulation to test picking up from a checkpoint. """"""; function test_simulation(stop_time, Δt, δt); grid = RectilinearGrid(size=(), topology=(Flat, Flat, Flat)); model = NonhydrostaticModel(; grid); simulation = Simulation(model; Δt, stop_time). progress_message(sim) = @info string(""Iter: "", iteration(sim), "", time: "", prettytime(sim)); simulation.callbacks[:progress] = Callback(progress_message, TimeInterval(δt)). checkpointer = Checkpointer(model,; schedule = TimeInterval(stop_time),; prefix = ""test"",; cleanup = false). simulation.output_writers[:checkpointer] = checkpointer. return simulation; end. rm(""test_iteration*.jld2"", force=true). Δt = 1 # timestep (s); T1 = 4 # first simulation stop time (s); T2 = 2T1 # second simulation stop time (s); δt = 2 # progress message frequency. # Run a simulation that saves data to a checkpoint; simulation = test_simulation(T1, Δt, δt); run!(simulation). # Now try again, but picking up from the previous checkpoint; N = iteration(simulation); checkpoint = ""test_iteration$N.jld2""; simulation = test_simulation(T2, Δt, δt); run!(simulation, pickup=checkpoint); ```. This reproduces the issue because I get. ```julia; julia> include(""test.jl""); [ Info: Initializing simulation...; [ Info: Iter: 0, time: 0 seconds; [ Info: ... simulation initialization complete (2.697 seconds); [ Info: Executing initial time step...; [ Info: ... initial time step complete (5.721 seconds).; [ Info: Iter: 2, time: 2 seconds; [ Info: Simulation is stopping after running for 8.786 seconds.; [ Info: Simulation time 4 seconds equals or exceeds stop time 4 seconds.; [ Info: Iter: 4, time: 4 seconds; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (529.973 μs); [ Info: Executing initial time step...; [ Info: ... initial time step complete (575.447 μs).; [ Info: Iter: 5,",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3657#issuecomment-2246064310
Integrability,message,message,"Okay, here's my MWE which includes running the first simulation to generate the checkpoint file:. ```julia; using Oceananigans; using Printf. """""" Set up a simple simulation to test picking up from a checkpoint. """"""; function test_simulation(stop_time, Δt, δt); grid = RectilinearGrid(size=(), topology=(Flat, Flat, Flat)); model = NonhydrostaticModel(; grid); simulation = Simulation(model; Δt, stop_time). progress_message(sim) = @info string(""Iter: "", iteration(sim), "", time: "", prettytime(sim)); simulation.callbacks[:progress] = Callback(progress_message, TimeInterval(δt)). checkpointer = Checkpointer(model,; schedule = TimeInterval(stop_time),; prefix = ""test"",; cleanup = false). simulation.output_writers[:checkpointer] = checkpointer. return simulation; end. rm(""test_iteration*.jld2"", force=true). Δt = 1 # timestep (s); T1 = 4 # first simulation stop time (s); T2 = 2T1 # second simulation stop time (s); δt = 2 # progress message frequency. # Run a simulation that saves data to a checkpoint; simulation = test_simulation(T1, Δt, δt); run!(simulation). # Now try again, but picking up from the previous checkpoint; N = iteration(simulation); checkpoint = ""test_iteration$N.jld2""; simulation = test_simulation(T2, Δt, δt); run!(simulation, pickup=checkpoint); ```. This reproduces the issue because I get. ```julia; julia> include(""test.jl""); [ Info: Initializing simulation...; [ Info: Iter: 0, time: 0 seconds; [ Info: ... simulation initialization complete (2.697 seconds); [ Info: Executing initial time step...; [ Info: ... initial time step complete (5.721 seconds).; [ Info: Iter: 2, time: 2 seconds; [ Info: Simulation is stopping after running for 8.786 seconds.; [ Info: Simulation time 4 seconds equals or exceeds stop time 4 seconds.; [ Info: Iter: 4, time: 4 seconds; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (529.973 μs); [ Info: Executing initial time step...; [ Info: ... initial time step complete (575.447 μs).; [ Info: Iter: 5,",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3657#issuecomment-2246064310
Testability,test,test,"Okay, here's my MWE which includes running the first simulation to generate the checkpoint file:. ```julia; using Oceananigans; using Printf. """""" Set up a simple simulation to test picking up from a checkpoint. """"""; function test_simulation(stop_time, Δt, δt); grid = RectilinearGrid(size=(), topology=(Flat, Flat, Flat)); model = NonhydrostaticModel(; grid); simulation = Simulation(model; Δt, stop_time). progress_message(sim) = @info string(""Iter: "", iteration(sim), "", time: "", prettytime(sim)); simulation.callbacks[:progress] = Callback(progress_message, TimeInterval(δt)). checkpointer = Checkpointer(model,; schedule = TimeInterval(stop_time),; prefix = ""test"",; cleanup = false). simulation.output_writers[:checkpointer] = checkpointer. return simulation; end. rm(""test_iteration*.jld2"", force=true). Δt = 1 # timestep (s); T1 = 4 # first simulation stop time (s); T2 = 2T1 # second simulation stop time (s); δt = 2 # progress message frequency. # Run a simulation that saves data to a checkpoint; simulation = test_simulation(T1, Δt, δt); run!(simulation). # Now try again, but picking up from the previous checkpoint; N = iteration(simulation); checkpoint = ""test_iteration$N.jld2""; simulation = test_simulation(T2, Δt, δt); run!(simulation, pickup=checkpoint); ```. This reproduces the issue because I get. ```julia; julia> include(""test.jl""); [ Info: Initializing simulation...; [ Info: Iter: 0, time: 0 seconds; [ Info: ... simulation initialization complete (2.697 seconds); [ Info: Executing initial time step...; [ Info: ... initial time step complete (5.721 seconds).; [ Info: Iter: 2, time: 2 seconds; [ Info: Simulation is stopping after running for 8.786 seconds.; [ Info: Simulation time 4 seconds equals or exceeds stop time 4 seconds.; [ Info: Iter: 4, time: 4 seconds; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (529.973 μs); [ Info: Executing initial time step...; [ Info: ... initial time step complete (575.447 μs).; [ Info: Iter: 5,",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3657#issuecomment-2246064310
Usability,simpl,simple,"Okay, here's my MWE which includes running the first simulation to generate the checkpoint file:. ```julia; using Oceananigans; using Printf. """""" Set up a simple simulation to test picking up from a checkpoint. """"""; function test_simulation(stop_time, Δt, δt); grid = RectilinearGrid(size=(), topology=(Flat, Flat, Flat)); model = NonhydrostaticModel(; grid); simulation = Simulation(model; Δt, stop_time). progress_message(sim) = @info string(""Iter: "", iteration(sim), "", time: "", prettytime(sim)); simulation.callbacks[:progress] = Callback(progress_message, TimeInterval(δt)). checkpointer = Checkpointer(model,; schedule = TimeInterval(stop_time),; prefix = ""test"",; cleanup = false). simulation.output_writers[:checkpointer] = checkpointer. return simulation; end. rm(""test_iteration*.jld2"", force=true). Δt = 1 # timestep (s); T1 = 4 # first simulation stop time (s); T2 = 2T1 # second simulation stop time (s); δt = 2 # progress message frequency. # Run a simulation that saves data to a checkpoint; simulation = test_simulation(T1, Δt, δt); run!(simulation). # Now try again, but picking up from the previous checkpoint; N = iteration(simulation); checkpoint = ""test_iteration$N.jld2""; simulation = test_simulation(T2, Δt, δt); run!(simulation, pickup=checkpoint); ```. This reproduces the issue because I get. ```julia; julia> include(""test.jl""); [ Info: Initializing simulation...; [ Info: Iter: 0, time: 0 seconds; [ Info: ... simulation initialization complete (2.697 seconds); [ Info: Executing initial time step...; [ Info: ... initial time step complete (5.721 seconds).; [ Info: Iter: 2, time: 2 seconds; [ Info: Simulation is stopping after running for 8.786 seconds.; [ Info: Simulation time 4 seconds equals or exceeds stop time 4 seconds.; [ Info: Iter: 4, time: 4 seconds; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (529.973 μs); [ Info: Executing initial time step...; [ Info: ... initial time step complete (575.447 μs).; [ Info: Iter: 5,",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3657#issuecomment-2246064310
Availability,checkpoint,checkpoint,"I think the problem is basically that the schedules are not saved to the checkpoint. Actually, the output themselves are also not saved to checkpoint which is also an issue for time averages. I believe this wasn't previously an issue but recent changes to `TimeInterval` in #3616 may have created the problem... Likely we can find some simple way to fix `TimeInterval` but let's keep in mind that there are some broader challenges to be solved for checkpointing that basically will require a feature that can save callback and output writer states.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3657#issuecomment-2246084467
Energy Efficiency,schedul,schedules,"I think the problem is basically that the schedules are not saved to the checkpoint. Actually, the output themselves are also not saved to checkpoint which is also an issue for time averages. I believe this wasn't previously an issue but recent changes to `TimeInterval` in #3616 may have created the problem... Likely we can find some simple way to fix `TimeInterval` but let's keep in mind that there are some broader challenges to be solved for checkpointing that basically will require a feature that can save callback and output writer states.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3657#issuecomment-2246084467
Usability,simpl,simple,"I think the problem is basically that the schedules are not saved to the checkpoint. Actually, the output themselves are also not saved to checkpoint which is also an issue for time averages. I believe this wasn't previously an issue but recent changes to `TimeInterval` in #3616 may have created the problem... Likely we can find some simple way to fix `TimeInterval` but let's keep in mind that there are some broader challenges to be solved for checkpointing that basically will require a feature that can save callback and output writer states.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3657#issuecomment-2246084467
Availability,checkpoint,checkpoint,"Here's an even simpler MWE that illustrates the fundamental issue:. ```julia; using Oceananigans; using Printf. grid = RectilinearGrid(size=(), topology=(Flat, Flat, Flat)); model = NonhydrostaticModel(; grid); simulation = Simulation(model; Δt=1, stop_time=6). progress_message(sim) = @info string(""Iter: "", iteration(sim), "", time: "", prettytime(sim)); simulation.callbacks[:progress] = Callback(progress_message, TimeInterval(2)). # Run a simulation that saves data to a checkpoint; model.clock.iteration = 1 # we want to start here for some reason; run!(simulation); ```. which produces. ```julia; julia> include(""test2.jl""); [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (383.622 μs); [ Info: Executing initial time step...; [ Info: ... initial time step complete (620.680 μs).; [ Info: Iter: 2, time: 1 second; [ Info: Iter: 3, time: 2 seconds; [ Info: Iter: 5, time: 4 seconds; [ Info: Iter: 7, time: 6 seconds; [ Info: Simulation is stopping after running for 25.701 ms.; [ Info: Simulation time 8 seconds equals or exceeds stop time 8 seconds.; [ Info: Iter: 9, time: 8 seconds; ```. Basically here there is a ""spurious actuation"" at the first iteration (here iteration 2, because we started from iteration 1). This fixes the issue:. ```julia; using Oceananigans; using Printf. grid = RectilinearGrid(size=(), topology=(Flat, Flat, Flat)); model = NonhydrostaticModel(; grid); simulation = Simulation(model; Δt=1, stop_time=6). progress_message(sim) = @info string(""Iter: "", iteration(sim), "", time: "", prettytime(sim)); progress_cb = Callback(progress_message, TimeInterval(2)); simulation.callbacks[:progress] = progress_cb. # Run a simulation that saves data to a checkpoint; model.clock.iteration = 1 # we want to start here for some reason; progress_cb.schedule.actuations = 1; run!(simulation); ```. producing. ```julia; julia> include(""test2.jl""); [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (595.408 μs); [ I",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3657#issuecomment-2246123947
Energy Efficiency,schedul,schedule,": "", prettytime(sim)); simulation.callbacks[:progress] = Callback(progress_message, TimeInterval(2)). # Run a simulation that saves data to a checkpoint; model.clock.iteration = 1 # we want to start here for some reason; run!(simulation); ```. which produces. ```julia; julia> include(""test2.jl""); [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (383.622 μs); [ Info: Executing initial time step...; [ Info: ... initial time step complete (620.680 μs).; [ Info: Iter: 2, time: 1 second; [ Info: Iter: 3, time: 2 seconds; [ Info: Iter: 5, time: 4 seconds; [ Info: Iter: 7, time: 6 seconds; [ Info: Simulation is stopping after running for 25.701 ms.; [ Info: Simulation time 8 seconds equals or exceeds stop time 8 seconds.; [ Info: Iter: 9, time: 8 seconds; ```. Basically here there is a ""spurious actuation"" at the first iteration (here iteration 2, because we started from iteration 1). This fixes the issue:. ```julia; using Oceananigans; using Printf. grid = RectilinearGrid(size=(), topology=(Flat, Flat, Flat)); model = NonhydrostaticModel(; grid); simulation = Simulation(model; Δt=1, stop_time=6). progress_message(sim) = @info string(""Iter: "", iteration(sim), "", time: "", prettytime(sim)); progress_cb = Callback(progress_message, TimeInterval(2)); simulation.callbacks[:progress] = progress_cb. # Run a simulation that saves data to a checkpoint; model.clock.iteration = 1 # we want to start here for some reason; progress_cb.schedule.actuations = 1; run!(simulation); ```. producing. ```julia; julia> include(""test2.jl""); [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (595.408 μs); [ Info: Executing initial time step...; [ Info: ... initial time step complete (876.240 μs).; [ Info: Iter: 3, time: 2 seconds; [ Info: Iter: 5, time: 4 seconds; [ Info: Simulation is stopping after running for 51.452 ms.; [ Info: Simulation time 6 seconds equals or exceeds stop time 6 seconds.; [ Info: Iter: 7, time: 6 seconds; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3657#issuecomment-2246123947
Usability,simpl,simpler,"Here's an even simpler MWE that illustrates the fundamental issue:. ```julia; using Oceananigans; using Printf. grid = RectilinearGrid(size=(), topology=(Flat, Flat, Flat)); model = NonhydrostaticModel(; grid); simulation = Simulation(model; Δt=1, stop_time=6). progress_message(sim) = @info string(""Iter: "", iteration(sim), "", time: "", prettytime(sim)); simulation.callbacks[:progress] = Callback(progress_message, TimeInterval(2)). # Run a simulation that saves data to a checkpoint; model.clock.iteration = 1 # we want to start here for some reason; run!(simulation); ```. which produces. ```julia; julia> include(""test2.jl""); [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (383.622 μs); [ Info: Executing initial time step...; [ Info: ... initial time step complete (620.680 μs).; [ Info: Iter: 2, time: 1 second; [ Info: Iter: 3, time: 2 seconds; [ Info: Iter: 5, time: 4 seconds; [ Info: Iter: 7, time: 6 seconds; [ Info: Simulation is stopping after running for 25.701 ms.; [ Info: Simulation time 8 seconds equals or exceeds stop time 8 seconds.; [ Info: Iter: 9, time: 8 seconds; ```. Basically here there is a ""spurious actuation"" at the first iteration (here iteration 2, because we started from iteration 1). This fixes the issue:. ```julia; using Oceananigans; using Printf. grid = RectilinearGrid(size=(), topology=(Flat, Flat, Flat)); model = NonhydrostaticModel(; grid); simulation = Simulation(model; Δt=1, stop_time=6). progress_message(sim) = @info string(""Iter: "", iteration(sim), "", time: "", prettytime(sim)); progress_cb = Callback(progress_message, TimeInterval(2)); simulation.callbacks[:progress] = progress_cb. # Run a simulation that saves data to a checkpoint; model.clock.iteration = 1 # we want to start here for some reason; progress_cb.schedule.actuations = 1; run!(simulation); ```. producing. ```julia; julia> include(""test2.jl""); [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (595.408 μs); [ I",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3657#issuecomment-2246123947
Safety,avoid,avoid,"I can approve this but I am concerned about the benchmarking being contained in another package. What's the reason for this? For example, we already have a `benchmark` directory in the code, which not only has some custom source code in `benchmark/src` but many benchmarking scripts. It seems that rather than address the issue with this code (which has a lot of stale stuff) we are trying to skirt / avoid the problem by creating another repo. Ultimately though this just leads to lower quality code across the board since its not clear whether we are supposed to continue to maintain `benchmark` or move to `NESAPOceananigans`. Eventually _somebody_ will have to address this, right? Who will do that?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3658#issuecomment-2246632050
Testability,benchmark,benchmarking,"I can approve this but I am concerned about the benchmarking being contained in another package. What's the reason for this? For example, we already have a `benchmark` directory in the code, which not only has some custom source code in `benchmark/src` but many benchmarking scripts. It seems that rather than address the issue with this code (which has a lot of stale stuff) we are trying to skirt / avoid the problem by creating another repo. Ultimately though this just leads to lower quality code across the board since its not clear whether we are supposed to continue to maintain `benchmark` or move to `NESAPOceananigans`. Eventually _somebody_ will have to address this, right? Who will do that?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3658#issuecomment-2246632050
Usability,clear,clear,"I can approve this but I am concerned about the benchmarking being contained in another package. What's the reason for this? For example, we already have a `benchmark` directory in the code, which not only has some custom source code in `benchmark/src` but many benchmarking scripts. It seems that rather than address the issue with this code (which has a lot of stale stuff) we are trying to skirt / avoid the problem by creating another repo. Ultimately though this just leads to lower quality code across the board since its not clear whether we are supposed to continue to maintain `benchmark` or move to `NESAPOceananigans`. Eventually _somebody_ will have to address this, right? Who will do that?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3658#issuecomment-2246632050
Availability,checkpoint,checkpoint,"Sure, I ran a simple test using the MWE above without picking up a checkpoint and set:. ```julia; Δt = .01 # timestep (s); T1 = 5 # first simulation stop time (s); δt = .03 # progress message interval and output saving interval; # Run a simulation; simulation = test_simulation(T1, Δt, δt, true); run!(simulation); ```; I've noticed that this strange behavior occurs when δt is smaller than or equal to 0.03, but it disappears when δt is greater than 0.03 (even at 0.031). It seems there is a cutoff value of δt below which the error emerges.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3670#issuecomment-2260950870
Integrability,message,message,"Sure, I ran a simple test using the MWE above without picking up a checkpoint and set:. ```julia; Δt = .01 # timestep (s); T1 = 5 # first simulation stop time (s); δt = .03 # progress message interval and output saving interval; # Run a simulation; simulation = test_simulation(T1, Δt, δt, true); run!(simulation); ```; I've noticed that this strange behavior occurs when δt is smaller than or equal to 0.03, but it disappears when δt is greater than 0.03 (even at 0.031). It seems there is a cutoff value of δt below which the error emerges.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3670#issuecomment-2260950870
Testability,test,test,"Sure, I ran a simple test using the MWE above without picking up a checkpoint and set:. ```julia; Δt = .01 # timestep (s); T1 = 5 # first simulation stop time (s); δt = .03 # progress message interval and output saving interval; # Run a simulation; simulation = test_simulation(T1, Δt, δt, true); run!(simulation); ```; I've noticed that this strange behavior occurs when δt is smaller than or equal to 0.03, but it disappears when δt is greater than 0.03 (even at 0.031). It seems there is a cutoff value of δt below which the error emerges.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3670#issuecomment-2260950870
Usability,simpl,simple,"Sure, I ran a simple test using the MWE above without picking up a checkpoint and set:. ```julia; Δt = .01 # timestep (s); T1 = 5 # first simulation stop time (s); δt = .03 # progress message interval and output saving interval; # Run a simulation; simulation = test_simulation(T1, Δt, δt, true); run!(simulation); ```; I've noticed that this strange behavior occurs when δt is smaller than or equal to 0.03, but it disappears when δt is greater than 0.03 (even at 0.031). It seems there is a cutoff value of δt below which the error emerges.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3670#issuecomment-2260950870
Availability,error,errors,"I'm also doubtful small round off errors in the timestep would be related, unless there a place in the code where the scheduled times for outputting / checkpointing need to exactly match some value. In the MWE, the problematic values look like they're all zeros. In our more complicated example, where the averaging interval is a large (decimal) multiple of the timestep, it's not clear if the values are underestimated because the velocities are of both signs so a biased average could go either way.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3670#issuecomment-2263839595
Energy Efficiency,schedul,scheduled,"I'm also doubtful small round off errors in the timestep would be related, unless there a place in the code where the scheduled times for outputting / checkpointing need to exactly match some value. In the MWE, the problematic values look like they're all zeros. In our more complicated example, where the averaging interval is a large (decimal) multiple of the timestep, it's not clear if the values are underestimated because the velocities are of both signs so a biased average could go either way.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3670#issuecomment-2263839595
Usability,clear,clear,"I'm also doubtful small round off errors in the timestep would be related, unless there a place in the code where the scheduled times for outputting / checkpointing need to exactly match some value. In the MWE, the problematic values look like they're all zeros. In our more complicated example, where the averaging interval is a large (decimal) multiple of the timestep, it's not clear if the values are underestimated because the velocities are of both signs so a biased average could go either way.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3670#issuecomment-2263839595
Usability,clear,clear,"yes, it makes sense to me now! Thanks for the clear explanation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3670#issuecomment-2286695648
Usability,simpl,simpler,"> but I think even at this point we're trusting developers that use it to make sure that the sum is valid (i.e. on the same grid and location), and to only put fields in it where the rest of the code would expect fields right?. Well no --- we don't trust developers to do that. We only use it inside a kernel and in a case we know it is used correctly. This PR does something different, it introduces ""support"" for `SumOfArrays` that implies to users that it is suitable for representing a sum of fields (not just a low-level utility for sums of arrays), but doesn't implement any other facilities that correspond to such support. We want users to be able to trust the code we write so I feel this isn't the most helpful thing to do. It is interesting to consider putting together an abstraction that represents a sum of fields (though note we already have this through `MultiaryOperation`, but maybe there is a reason you would like something different?). It wouldn't be very much effort and we can indeed check that the fields all share a location and grid. Such a utility could even be used within abstract operations, as a simpler alternative to `MultiaryOperation` (which additionally can sum fields that have different locations, but perhaps is too complicated for your use case?)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3676#issuecomment-2265955109
Usability,simpl,simple,"There are a few ways it could be implemented. One simple way is. ```julia; function mask_immersed_field(bop::BinaryOperation, value=zero(b.grid)); mask_immersed_field(bop.a, value); mask_immersed_field(bop.b, value); return nothing; end; ```. One could also be more specific, eg. ```julia; const FieldBinaryOperation = BinaryOperation{<:Any, <:Any, <:Any, <:Any, <:Field, <:Field}; ```. Then we are sure its a binary operation between two fields. And the operation can be restricted to addition as well. Just some ideas...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3676#issuecomment-2269866889
Testability,test,test,Another test that reveals a problem with non-separated pressure is a simple horizontal wall in a 2D setup.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3677#issuecomment-2270149062
Usability,simpl,simple,Another test that reveals a problem with non-separated pressure is a simple horizontal wall in a 2D setup.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3677#issuecomment-2270149062
Usability,simpl,simply,"I'm not sure this is a bug by the way. The code is correct -- it may simply be that the pressure solver numerical method itself is wrong (or ""approximate"" if you want to be generous). A pressure solver that is at least theoretically correct for complex domains is/was being developed here: https://github.com/CliMA/Oceananigans.jl/pull/3188",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3677#issuecomment-2270149898
Energy Efficiency,adapt,adapt,"`PartialCellBottom` has a couple of bugs in the implementation that make it crash in simple cases like the `internal_tide.jl` example. @jm-c is working on fixing the implementation and should open a PR soon to fix the bugs.; However, it is indeed a problem in the adapt. ; I can it in a PR, still if you use PartialCellBottom know that probably it will lead to a crashing simulation",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3681#issuecomment-2269880138
Modifiability,adapt,adapt,"`PartialCellBottom` has a couple of bugs in the implementation that make it crash in simple cases like the `internal_tide.jl` example. @jm-c is working on fixing the implementation and should open a PR soon to fix the bugs.; However, it is indeed a problem in the adapt. ; I can it in a PR, still if you use PartialCellBottom know that probably it will lead to a crashing simulation",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3681#issuecomment-2269880138
Usability,simpl,simple,"`PartialCellBottom` has a couple of bugs in the implementation that make it crash in simple cases like the `internal_tide.jl` example. @jm-c is working on fixing the implementation and should open a PR soon to fix the bugs.; However, it is indeed a problem in the adapt. ; I can it in a PR, still if you use PartialCellBottom know that probably it will lead to a crashing simulation",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3681#issuecomment-2269880138
Usability,simpl,simplify,It'd be easy as an intermediate step to discontinue GPU support only I suppose. Depends how much we want to simplify the code... Also this is a reason not to eliminate `LatitudeLongitudeGrid` because it seems like it will always have fewer parameters than `OrthogonalSphericalShellGrid`.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3693#issuecomment-2276886031
Availability,error,error,"We need an MPI tips / wiki section... been working on getting distributed simulations running on Engaging since yesterday (we need people to be able to start running distributed simulations immediately with minimal start up time). Here are a few things I learned:. * Remember to load a system MPI on your HPC, eg `module load openmpi`; * MPI may have to be installed / configured carefully --- after loading a system MPI. `MPIPreferences` can help:. ```julia; using MPIPreferences; MPIPreferences.use_system_binary(); ```. https://juliaparallel.org/MPI.jl/stable/configuration/. * Configuring SLURM correctly may also require some trial and error, because the documentation is unclear and there are a huge number of options. I can't figure out if the documentation is wrong, in fact, or if instead the engaging cluster does not support some options. Either way, a small test script like. ```julia; using MPI. MPI.Init(); @show MPI.Comm_rank(MPI.COMM_WORLD); @show MPI.Comm_size(MPI.COMM_WORLD); ```. Is helpful for debugging. Also, I recommend first trying to start jobs interactively before using `sbatch`. Interactive jobs launch faster, so we get a faster trial-error iteration. I'm still working on things, but it seems like another point may be salient:. * Initialize / precompile outside of a parallel job before trying to launch a parallel job via `mpiexec`. Here are some notes that may be specific to engaging:. I'm using `srun` to get a 4-GPU node to use interactively:. ```; srun -p my_partition --tasks-per-node=4 --cpus-per-task=32 --gres=gpu:4 --gpus-per-node=4 --mem=0 -t 01:00:00 -N 1; ```. it seems we have to use the option `gpus-per-node`, rather than setting the total number of GPUs. Also we redundantly also have to specify `gres=gpu:4` (`gres` stands for ""generalized resource""). Why `gres` can't tell what `gpus-per-node` is, I don't know. `-N 1` means 1 node. Finally we also have to specify ``--tasks-per-node=4` (matching `gres` _and_ the number of GPUs per node), otherwise",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3698#issuecomment-2389107436
Deployability,install,installed,"We need an MPI tips / wiki section... been working on getting distributed simulations running on Engaging since yesterday (we need people to be able to start running distributed simulations immediately with minimal start up time). Here are a few things I learned:. * Remember to load a system MPI on your HPC, eg `module load openmpi`; * MPI may have to be installed / configured carefully --- after loading a system MPI. `MPIPreferences` can help:. ```julia; using MPIPreferences; MPIPreferences.use_system_binary(); ```. https://juliaparallel.org/MPI.jl/stable/configuration/. * Configuring SLURM correctly may also require some trial and error, because the documentation is unclear and there are a huge number of options. I can't figure out if the documentation is wrong, in fact, or if instead the engaging cluster does not support some options. Either way, a small test script like. ```julia; using MPI. MPI.Init(); @show MPI.Comm_rank(MPI.COMM_WORLD); @show MPI.Comm_size(MPI.COMM_WORLD); ```. Is helpful for debugging. Also, I recommend first trying to start jobs interactively before using `sbatch`. Interactive jobs launch faster, so we get a faster trial-error iteration. I'm still working on things, but it seems like another point may be salient:. * Initialize / precompile outside of a parallel job before trying to launch a parallel job via `mpiexec`. Here are some notes that may be specific to engaging:. I'm using `srun` to get a 4-GPU node to use interactively:. ```; srun -p my_partition --tasks-per-node=4 --cpus-per-task=32 --gres=gpu:4 --gpus-per-node=4 --mem=0 -t 01:00:00 -N 1; ```. it seems we have to use the option `gpus-per-node`, rather than setting the total number of GPUs. Also we redundantly also have to specify `gres=gpu:4` (`gres` stands for ""generalized resource""). Why `gres` can't tell what `gpus-per-node` is, I don't know. `-N 1` means 1 node. Finally we also have to specify ``--tasks-per-node=4` (matching `gres` _and_ the number of GPUs per node), otherwise",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3698#issuecomment-2389107436
Energy Efficiency,adapt,adapt,"iguration/. * Configuring SLURM correctly may also require some trial and error, because the documentation is unclear and there are a huge number of options. I can't figure out if the documentation is wrong, in fact, or if instead the engaging cluster does not support some options. Either way, a small test script like. ```julia; using MPI. MPI.Init(); @show MPI.Comm_rank(MPI.COMM_WORLD); @show MPI.Comm_size(MPI.COMM_WORLD); ```. Is helpful for debugging. Also, I recommend first trying to start jobs interactively before using `sbatch`. Interactive jobs launch faster, so we get a faster trial-error iteration. I'm still working on things, but it seems like another point may be salient:. * Initialize / precompile outside of a parallel job before trying to launch a parallel job via `mpiexec`. Here are some notes that may be specific to engaging:. I'm using `srun` to get a 4-GPU node to use interactively:. ```; srun -p my_partition --tasks-per-node=4 --cpus-per-task=32 --gres=gpu:4 --gpus-per-node=4 --mem=0 -t 01:00:00 -N 1; ```. it seems we have to use the option `gpus-per-node`, rather than setting the total number of GPUs. Also we redundantly also have to specify `gres=gpu:4` (`gres` stands for ""generalized resource""). Why `gres` can't tell what `gpus-per-node` is, I don't know. `-N 1` means 1 node. Finally we also have to specify ``--tasks-per-node=4` (matching `gres` _and_ the number of GPUs per node), otherwise we cannot launch `mpiexec` with 4 tasks (1 for each GPU). It's helpful to have the maximum number of CPUs for precompilation. Otherwise precompilation is very slow. I also set. ```; export JULIA_NUM_PRECOMPILE_TASKS=64; ```. (half the total) --- adapt for your system. Here is also a small test script for debuggin Oceananigans:. ```julia; using Oceananigans; arch = Distributed(GPU()); @show arch; ```. as a side note, it would be nice if we could print to the screen from different ranks without them talking over one another. It makes it hard to read the output.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3698#issuecomment-2389107436
Modifiability,config,configured,"We need an MPI tips / wiki section... been working on getting distributed simulations running on Engaging since yesterday (we need people to be able to start running distributed simulations immediately with minimal start up time). Here are a few things I learned:. * Remember to load a system MPI on your HPC, eg `module load openmpi`; * MPI may have to be installed / configured carefully --- after loading a system MPI. `MPIPreferences` can help:. ```julia; using MPIPreferences; MPIPreferences.use_system_binary(); ```. https://juliaparallel.org/MPI.jl/stable/configuration/. * Configuring SLURM correctly may also require some trial and error, because the documentation is unclear and there are a huge number of options. I can't figure out if the documentation is wrong, in fact, or if instead the engaging cluster does not support some options. Either way, a small test script like. ```julia; using MPI. MPI.Init(); @show MPI.Comm_rank(MPI.COMM_WORLD); @show MPI.Comm_size(MPI.COMM_WORLD); ```. Is helpful for debugging. Also, I recommend first trying to start jobs interactively before using `sbatch`. Interactive jobs launch faster, so we get a faster trial-error iteration. I'm still working on things, but it seems like another point may be salient:. * Initialize / precompile outside of a parallel job before trying to launch a parallel job via `mpiexec`. Here are some notes that may be specific to engaging:. I'm using `srun` to get a 4-GPU node to use interactively:. ```; srun -p my_partition --tasks-per-node=4 --cpus-per-task=32 --gres=gpu:4 --gpus-per-node=4 --mem=0 -t 01:00:00 -N 1; ```. it seems we have to use the option `gpus-per-node`, rather than setting the total number of GPUs. Also we redundantly also have to specify `gres=gpu:4` (`gres` stands for ""generalized resource""). Why `gres` can't tell what `gpus-per-node` is, I don't know. `-N 1` means 1 node. Finally we also have to specify ``--tasks-per-node=4` (matching `gres` _and_ the number of GPUs per node), otherwise",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3698#issuecomment-2389107436
Performance,load,load,"We need an MPI tips / wiki section... been working on getting distributed simulations running on Engaging since yesterday (we need people to be able to start running distributed simulations immediately with minimal start up time). Here are a few things I learned:. * Remember to load a system MPI on your HPC, eg `module load openmpi`; * MPI may have to be installed / configured carefully --- after loading a system MPI. `MPIPreferences` can help:. ```julia; using MPIPreferences; MPIPreferences.use_system_binary(); ```. https://juliaparallel.org/MPI.jl/stable/configuration/. * Configuring SLURM correctly may also require some trial and error, because the documentation is unclear and there are a huge number of options. I can't figure out if the documentation is wrong, in fact, or if instead the engaging cluster does not support some options. Either way, a small test script like. ```julia; using MPI. MPI.Init(); @show MPI.Comm_rank(MPI.COMM_WORLD); @show MPI.Comm_size(MPI.COMM_WORLD); ```. Is helpful for debugging. Also, I recommend first trying to start jobs interactively before using `sbatch`. Interactive jobs launch faster, so we get a faster trial-error iteration. I'm still working on things, but it seems like another point may be salient:. * Initialize / precompile outside of a parallel job before trying to launch a parallel job via `mpiexec`. Here are some notes that may be specific to engaging:. I'm using `srun` to get a 4-GPU node to use interactively:. ```; srun -p my_partition --tasks-per-node=4 --cpus-per-task=32 --gres=gpu:4 --gpus-per-node=4 --mem=0 -t 01:00:00 -N 1; ```. it seems we have to use the option `gpus-per-node`, rather than setting the total number of GPUs. Also we redundantly also have to specify `gres=gpu:4` (`gres` stands for ""generalized resource""). Why `gres` can't tell what `gpus-per-node` is, I don't know. `-N 1` means 1 node. Finally we also have to specify ``--tasks-per-node=4` (matching `gres` _and_ the number of GPUs per node), otherwise",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3698#issuecomment-2389107436
Safety,redund,redundantly,"iguration/. * Configuring SLURM correctly may also require some trial and error, because the documentation is unclear and there are a huge number of options. I can't figure out if the documentation is wrong, in fact, or if instead the engaging cluster does not support some options. Either way, a small test script like. ```julia; using MPI. MPI.Init(); @show MPI.Comm_rank(MPI.COMM_WORLD); @show MPI.Comm_size(MPI.COMM_WORLD); ```. Is helpful for debugging. Also, I recommend first trying to start jobs interactively before using `sbatch`. Interactive jobs launch faster, so we get a faster trial-error iteration. I'm still working on things, but it seems like another point may be salient:. * Initialize / precompile outside of a parallel job before trying to launch a parallel job via `mpiexec`. Here are some notes that may be specific to engaging:. I'm using `srun` to get a 4-GPU node to use interactively:. ```; srun -p my_partition --tasks-per-node=4 --cpus-per-task=32 --gres=gpu:4 --gpus-per-node=4 --mem=0 -t 01:00:00 -N 1; ```. it seems we have to use the option `gpus-per-node`, rather than setting the total number of GPUs. Also we redundantly also have to specify `gres=gpu:4` (`gres` stands for ""generalized resource""). Why `gres` can't tell what `gpus-per-node` is, I don't know. `-N 1` means 1 node. Finally we also have to specify ``--tasks-per-node=4` (matching `gres` _and_ the number of GPUs per node), otherwise we cannot launch `mpiexec` with 4 tasks (1 for each GPU). It's helpful to have the maximum number of CPUs for precompilation. Otherwise precompilation is very slow. I also set. ```; export JULIA_NUM_PRECOMPILE_TASKS=64; ```. (half the total) --- adapt for your system. Here is also a small test script for debuggin Oceananigans:. ```julia; using Oceananigans; arch = Distributed(GPU()); @show arch; ```. as a side note, it would be nice if we could print to the screen from different ranks without them talking over one another. It makes it hard to read the output.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3698#issuecomment-2389107436
Testability,test,test,"We need an MPI tips / wiki section... been working on getting distributed simulations running on Engaging since yesterday (we need people to be able to start running distributed simulations immediately with minimal start up time). Here are a few things I learned:. * Remember to load a system MPI on your HPC, eg `module load openmpi`; * MPI may have to be installed / configured carefully --- after loading a system MPI. `MPIPreferences` can help:. ```julia; using MPIPreferences; MPIPreferences.use_system_binary(); ```. https://juliaparallel.org/MPI.jl/stable/configuration/. * Configuring SLURM correctly may also require some trial and error, because the documentation is unclear and there are a huge number of options. I can't figure out if the documentation is wrong, in fact, or if instead the engaging cluster does not support some options. Either way, a small test script like. ```julia; using MPI. MPI.Init(); @show MPI.Comm_rank(MPI.COMM_WORLD); @show MPI.Comm_size(MPI.COMM_WORLD); ```. Is helpful for debugging. Also, I recommend first trying to start jobs interactively before using `sbatch`. Interactive jobs launch faster, so we get a faster trial-error iteration. I'm still working on things, but it seems like another point may be salient:. * Initialize / precompile outside of a parallel job before trying to launch a parallel job via `mpiexec`. Here are some notes that may be specific to engaging:. I'm using `srun` to get a 4-GPU node to use interactively:. ```; srun -p my_partition --tasks-per-node=4 --cpus-per-task=32 --gres=gpu:4 --gpus-per-node=4 --mem=0 -t 01:00:00 -N 1; ```. it seems we have to use the option `gpus-per-node`, rather than setting the total number of GPUs. Also we redundantly also have to specify `gres=gpu:4` (`gres` stands for ""generalized resource""). Why `gres` can't tell what `gpus-per-node` is, I don't know. `-N 1` means 1 node. Finally we also have to specify ``--tasks-per-node=4` (matching `gres` _and_ the number of GPUs per node), otherwise",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3698#issuecomment-2389107436
Usability,learn,learned,"We need an MPI tips / wiki section... been working on getting distributed simulations running on Engaging since yesterday (we need people to be able to start running distributed simulations immediately with minimal start up time). Here are a few things I learned:. * Remember to load a system MPI on your HPC, eg `module load openmpi`; * MPI may have to be installed / configured carefully --- after loading a system MPI. `MPIPreferences` can help:. ```julia; using MPIPreferences; MPIPreferences.use_system_binary(); ```. https://juliaparallel.org/MPI.jl/stable/configuration/. * Configuring SLURM correctly may also require some trial and error, because the documentation is unclear and there are a huge number of options. I can't figure out if the documentation is wrong, in fact, or if instead the engaging cluster does not support some options. Either way, a small test script like. ```julia; using MPI. MPI.Init(); @show MPI.Comm_rank(MPI.COMM_WORLD); @show MPI.Comm_size(MPI.COMM_WORLD); ```. Is helpful for debugging. Also, I recommend first trying to start jobs interactively before using `sbatch`. Interactive jobs launch faster, so we get a faster trial-error iteration. I'm still working on things, but it seems like another point may be salient:. * Initialize / precompile outside of a parallel job before trying to launch a parallel job via `mpiexec`. Here are some notes that may be specific to engaging:. I'm using `srun` to get a 4-GPU node to use interactively:. ```; srun -p my_partition --tasks-per-node=4 --cpus-per-task=32 --gres=gpu:4 --gpus-per-node=4 --mem=0 -t 01:00:00 -N 1; ```. it seems we have to use the option `gpus-per-node`, rather than setting the total number of GPUs. Also we redundantly also have to specify `gres=gpu:4` (`gres` stands for ""generalized resource""). Why `gres` can't tell what `gpus-per-node` is, I don't know. `-N 1` means 1 node. Finally we also have to specify ``--tasks-per-node=4` (matching `gres` _and_ the number of GPUs per node), otherwise",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3698#issuecomment-2389107436
Usability,clear,clear,> I think it's still working. I found an instance of it still being used here:. I meant for the specific instance that this issue refers to. > It matches the last line of the warning because that's the only line that changes from run to run. In particular the part tartarus-16 could be different it it ends up running on a different node:. My question is: why does matching the last line of the warning act to remove the whole warning? I am not asking about the intention of the filter. The intention is clear.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3705#issuecomment-2287767916
Usability,simpl,simply,"Maybe more specifically I don't understand the motivation for this:. https://github.com/CliMA/Oceananigans.jl/blob/315e66bb330b44acc2a0daf74ae357ee66e801d1/src/DistributedComputations/halo_communication.jl#L44-L48. This is a kind of abstraction for a send/recv event, but its super implicit just consisting of integers, rather than simply recording this information as symbols or strings (is a number the only way to generate a unique ID for a field?). I can't figure out why we would record the Z location, this seems random. Why not record the 3D location directly (not use a digit)? Otherwise this code is seemingly more specific than it needs to be. It would be annoying to debug this too since you'd have to be constantly computing these codes.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3714#issuecomment-2294426510
Availability,down,down,"> > You're gonna want to implement a struct that's someting like; > > ```julia; > > struct HaloFillingEvent; > > location; > > z_indices; > > from_side; > > to_side; > > field_id; > > end; > > ```; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > and then a function; > > ```julia; > > mpi_tag(hfe::HaloFillingEvent) = # number; > > ```; > ; > I am not sure about this solution. The tag is used immediately (and only) where created, not recorded, and automatically destroyed by MPI after the communication is complete, so I do not immediately see the immediate utility of extra steps, or to save something in memory. A function that, given architecture, location, and side, spits out a unique tag seems sufficient for interpretability without having to record the output somewhere (it's a bit like a hash function, if you have function and inputs you have everything you need). There are a few purposes:. - Make it easier for a future developer to understand the code by using words rather than a digit code; - Make debugging possible; - Replace this:. ```; arch.active_requests[] += 1; ```. with an actual list of the active requests (rather than simply counting them --- eg `push!(active_events, new_event)`, and `pop!(active_events, finished_event)`. The objective is not to write the minimal code that will work, but to create a system that is human understandable. While a minimal functionality can be debugged and made to work once, it will be very brittle because if it breaks, it could shut down the whole system and prevent future development. Also `active_requests` used to be called `mpi_tag` and I don't understand the relationship between those two concepts.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3714#issuecomment-2298985401
Security,hash,hash,"> > You're gonna want to implement a struct that's someting like; > > ```julia; > > struct HaloFillingEvent; > > location; > > z_indices; > > from_side; > > to_side; > > field_id; > > end; > > ```; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > and then a function; > > ```julia; > > mpi_tag(hfe::HaloFillingEvent) = # number; > > ```; > ; > I am not sure about this solution. The tag is used immediately (and only) where created, not recorded, and automatically destroyed by MPI after the communication is complete, so I do not immediately see the immediate utility of extra steps, or to save something in memory. A function that, given architecture, location, and side, spits out a unique tag seems sufficient for interpretability without having to record the output somewhere (it's a bit like a hash function, if you have function and inputs you have everything you need). There are a few purposes:. - Make it easier for a future developer to understand the code by using words rather than a digit code; - Make debugging possible; - Replace this:. ```; arch.active_requests[] += 1; ```. with an actual list of the active requests (rather than simply counting them --- eg `push!(active_events, new_event)`, and `pop!(active_events, finished_event)`. The objective is not to write the minimal code that will work, but to create a system that is human understandable. While a minimal functionality can be debugged and made to work once, it will be very brittle because if it breaks, it could shut down the whole system and prevent future development. Also `active_requests` used to be called `mpi_tag` and I don't understand the relationship between those two concepts.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3714#issuecomment-2298985401
Usability,simpl,simply,"> > You're gonna want to implement a struct that's someting like; > > ```julia; > > struct HaloFillingEvent; > > location; > > z_indices; > > from_side; > > to_side; > > field_id; > > end; > > ```; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > and then a function; > > ```julia; > > mpi_tag(hfe::HaloFillingEvent) = # number; > > ```; > ; > I am not sure about this solution. The tag is used immediately (and only) where created, not recorded, and automatically destroyed by MPI after the communication is complete, so I do not immediately see the immediate utility of extra steps, or to save something in memory. A function that, given architecture, location, and side, spits out a unique tag seems sufficient for interpretability without having to record the output somewhere (it's a bit like a hash function, if you have function and inputs you have everything you need). There are a few purposes:. - Make it easier for a future developer to understand the code by using words rather than a digit code; - Make debugging possible; - Replace this:. ```; arch.active_requests[] += 1; ```. with an actual list of the active requests (rather than simply counting them --- eg `push!(active_events, new_event)`, and `pop!(active_events, finished_event)`. The objective is not to write the minimal code that will work, but to create a system that is human understandable. While a minimal functionality can be debugged and made to work once, it will be very brittle because if it breaks, it could shut down the whole system and prevent future development. Also `active_requests` used to be called `mpi_tag` and I don't understand the relationship between those two concepts.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3714#issuecomment-2298985401
Security,hash,hash,"> Maybe (for debugging purposes) a function, which reverses the hash, i.e. given the tag spits out the inputs can be usefull. Yes but since the object I'm suggesting is even smaller in memory than an integer (almost 0 in size except for `field_id` and possibly `z_indices`), why would you skip the intermediate abstraction? You're thinking that an integer is ""simple"" but its not.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3714#issuecomment-2298991416
Usability,simpl,simple,"> Maybe (for debugging purposes) a function, which reverses the hash, i.e. given the tag spits out the inputs can be usefull. Yes but since the object I'm suggesting is even smaller in memory than an integer (almost 0 in size except for `field_id` and possibly `z_indices`), why would you skip the intermediate abstraction? You're thinking that an integer is ""simple"" but its not.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3714#issuecomment-2298991416
Usability,simpl,simply,"If you can demonstrate that this code can be implemented in a way that encourages debugging, inspection at the REPL, etc, without the abstraction, then that can be accepted. I just think that creating the abstraction is not only helpful for future people but will also help _you_ organize your ideas. I would start with that and in the end if you find its not useful, eliminate it. But I wouldn't start by designing code without it and ""seeing what happens"". The objective here is not simply to ""make things work"".",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3714#issuecomment-2299014618
Usability,simpl,simply,"> an active counter that keeps track of how many communications are active. Why would you not simply keep track of the communications themselves, rather than just the _number_? There's no price to keeping a list of the events versus the number of them active so I don't understand why you throw away that info.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3714#issuecomment-2299019160
Integrability,rout,routine,"> We could do that, in fact the requests are stored in the `arch.mpi_requests` vector. The problem with using the length of that vector for inferring a `field_id` is that is not unique for different ranks. For example, a slab decomposition on a bounded domain will lead to 2 requests for the rank adjacent to boundaries (RightConnected or LeftConnected) and 4 for ranks connected on both sides. In this way, the counter is incremented globally when one field is sent, the side is inferred from the `fill_halo_side!` routine so this, combined to a location, leads to a unique tag.; > ; > What about changing the `mpi_tag` name to `active_comm_counter` and add an inverse function to extract the inputs from the tag? Then it is quite easy to inspect the tag and understand what communication we are looking at. I don't follow. You have all of that information if you simply store the `HaloFillEvents` in a vector. Maybe you can't use the ""length"" but surely you can compute the number needed, which is currently stored as a ""counter"". You can also store the pointer to the field itself rather than an ""id"" / number.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3714#issuecomment-2299132287
Usability,simpl,simply,"> We could do that, in fact the requests are stored in the `arch.mpi_requests` vector. The problem with using the length of that vector for inferring a `field_id` is that is not unique for different ranks. For example, a slab decomposition on a bounded domain will lead to 2 requests for the rank adjacent to boundaries (RightConnected or LeftConnected) and 4 for ranks connected on both sides. In this way, the counter is incremented globally when one field is sent, the side is inferred from the `fill_halo_side!` routine so this, combined to a location, leads to a unique tag.; > ; > What about changing the `mpi_tag` name to `active_comm_counter` and add an inverse function to extract the inputs from the tag? Then it is quite easy to inspect the tag and understand what communication we are looking at. I don't follow. You have all of that information if you simply store the `HaloFillEvents` in a vector. Maybe you can't use the ""length"" but surely you can compute the number needed, which is currently stored as a ""counter"". You can also store the pointer to the field itself rather than an ""id"" / number.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3714#issuecomment-2299132287
Usability,simpl,simple,Ah yeah. I didn't put `view` in the example just to keep it simple but the point of all of this is to support all fields. `view` returns a `Field` so should be supported.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3715#issuecomment-2296888889
Usability,intuit,intuitive,Seeing this I wonder two things:. 1. We could always return `CPU` or `GPU` from `architecture` and then define a different function that would return `Distributed` for a distributed simulation. Probably we shouldn't do this because we want `architecture(grid)` to correspond to `grid.architecture`. But its a thought. 2. `child_architecture` seems weird and not super intuitive. Maybe `device_architecture` or something would make more sense?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3716#issuecomment-2294417925
Availability,checkpoint,checkpoint,"@liuchihl, thanks for cleaning up these changes by separating them from the [background flux PR](https://github.com/CliMA/Oceananigans.jl/pull/3646)—it's much clearer now. Consolidating @glwagner and @navidcy's earlier comments, it seems there are three things that need to be done before this can be merged:; 1) Review the [the existing OutputWriter tests](https://github.com/CliMA/Oceananigans.jl/blob/main/test/test_output_writers.jl) and verify that they still pass with the new implementation in this PR; 2) Create a new, more rigorous, test that is capable of flagging the bizarre behavior you found in [your issue](https://github.com/CliMA/Oceananigans.jl/issues/3670) but (hopefully) now passes thanks to the changes in this branch.; 3) Add some warnings to let users know that `TimeInterval` and `AveragedTimeInterval` (and probably other diagnostic schedules) are currently broken and give incorrect results after picking up from a checkpoint whenever the checkpoint interval is not an integer multiple of the scheduled time interval.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3721#issuecomment-2302951223
Energy Efficiency,schedul,schedules,"@liuchihl, thanks for cleaning up these changes by separating them from the [background flux PR](https://github.com/CliMA/Oceananigans.jl/pull/3646)—it's much clearer now. Consolidating @glwagner and @navidcy's earlier comments, it seems there are three things that need to be done before this can be merged:; 1) Review the [the existing OutputWriter tests](https://github.com/CliMA/Oceananigans.jl/blob/main/test/test_output_writers.jl) and verify that they still pass with the new implementation in this PR; 2) Create a new, more rigorous, test that is capable of flagging the bizarre behavior you found in [your issue](https://github.com/CliMA/Oceananigans.jl/issues/3670) but (hopefully) now passes thanks to the changes in this branch.; 3) Add some warnings to let users know that `TimeInterval` and `AveragedTimeInterval` (and probably other diagnostic schedules) are currently broken and give incorrect results after picking up from a checkpoint whenever the checkpoint interval is not an integer multiple of the scheduled time interval.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3721#issuecomment-2302951223
Testability,test,tests,"@liuchihl, thanks for cleaning up these changes by separating them from the [background flux PR](https://github.com/CliMA/Oceananigans.jl/pull/3646)—it's much clearer now. Consolidating @glwagner and @navidcy's earlier comments, it seems there are three things that need to be done before this can be merged:; 1) Review the [the existing OutputWriter tests](https://github.com/CliMA/Oceananigans.jl/blob/main/test/test_output_writers.jl) and verify that they still pass with the new implementation in this PR; 2) Create a new, more rigorous, test that is capable of flagging the bizarre behavior you found in [your issue](https://github.com/CliMA/Oceananigans.jl/issues/3670) but (hopefully) now passes thanks to the changes in this branch.; 3) Add some warnings to let users know that `TimeInterval` and `AveragedTimeInterval` (and probably other diagnostic schedules) are currently broken and give incorrect results after picking up from a checkpoint whenever the checkpoint interval is not an integer multiple of the scheduled time interval.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3721#issuecomment-2302951223
Usability,clear,clearer,"@liuchihl, thanks for cleaning up these changes by separating them from the [background flux PR](https://github.com/CliMA/Oceananigans.jl/pull/3646)—it's much clearer now. Consolidating @glwagner and @navidcy's earlier comments, it seems there are three things that need to be done before this can be merged:; 1) Review the [the existing OutputWriter tests](https://github.com/CliMA/Oceananigans.jl/blob/main/test/test_output_writers.jl) and verify that they still pass with the new implementation in this PR; 2) Create a new, more rigorous, test that is capable of flagging the bizarre behavior you found in [your issue](https://github.com/CliMA/Oceananigans.jl/issues/3670) but (hopefully) now passes thanks to the changes in this branch.; 3) Add some warnings to let users know that `TimeInterval` and `AveragedTimeInterval` (and probably other diagnostic schedules) are currently broken and give incorrect results after picking up from a checkpoint whenever the checkpoint interval is not an integer multiple of the scheduled time interval.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3721#issuecomment-2302951223
Availability,checkpoint,checkpointer,"> > I think the majority of simulations do not use a Checkpointer so the warning would be irrelevant in most cases.; > ; > I don't get this. How are people not using a Checkpointer? Is no one else limited by HPC wall times or running long simulations? It seems like one of the most fundamental capabilities of any time-stepped numerical model.; > ; > But yes, this warning should only be issued if a Checkpointer is used (and maybe also when a simulation picks up from an existing Checkpoint). I think for sophisticated research Checkpointing is common, but for simpler classroom and LES applications the checkpointer is used less. After all, probably the most simulations are actually run in our examples on CI -- and there are no examples with a checkpointer! (It would be nice to change that). I can't speak for others, but for boundary layer parameterization work the LES typically run in less than 24 hours of wall time. We also only utilize very simple diagnostics, like the horizontally-averaged solution at the final time step. So in those rare cases that we need a checkpointer (I have used a handful of times) barebones checkpointing is sufficient. Of course we are currently working on building a OMIP simulation and that will require much longer runs, so we will definitely need more sophisticated checkpointing very soon. @simone-silvestri and @tomchor might have more to add. Or @sandreza, what do you use for the neverworld work?. I'm not saying we don't want to develop this, I'm just providing some context about why this hasn't been resolved / developed yet. In an ideal world the simulations would run fast enough that we wouldn't need checkpointing, after all 😄",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3721#issuecomment-2305131230
Modifiability,parameteriz,parameterization,"> > I think the majority of simulations do not use a Checkpointer so the warning would be irrelevant in most cases.; > ; > I don't get this. How are people not using a Checkpointer? Is no one else limited by HPC wall times or running long simulations? It seems like one of the most fundamental capabilities of any time-stepped numerical model.; > ; > But yes, this warning should only be issued if a Checkpointer is used (and maybe also when a simulation picks up from an existing Checkpoint). I think for sophisticated research Checkpointing is common, but for simpler classroom and LES applications the checkpointer is used less. After all, probably the most simulations are actually run in our examples on CI -- and there are no examples with a checkpointer! (It would be nice to change that). I can't speak for others, but for boundary layer parameterization work the LES typically run in less than 24 hours of wall time. We also only utilize very simple diagnostics, like the horizontally-averaged solution at the final time step. So in those rare cases that we need a checkpointer (I have used a handful of times) barebones checkpointing is sufficient. Of course we are currently working on building a OMIP simulation and that will require much longer runs, so we will definitely need more sophisticated checkpointing very soon. @simone-silvestri and @tomchor might have more to add. Or @sandreza, what do you use for the neverworld work?. I'm not saying we don't want to develop this, I'm just providing some context about why this hasn't been resolved / developed yet. In an ideal world the simulations would run fast enough that we wouldn't need checkpointing, after all 😄",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3721#issuecomment-2305131230
Usability,simpl,simpler,"> > I think the majority of simulations do not use a Checkpointer so the warning would be irrelevant in most cases.; > ; > I don't get this. How are people not using a Checkpointer? Is no one else limited by HPC wall times or running long simulations? It seems like one of the most fundamental capabilities of any time-stepped numerical model.; > ; > But yes, this warning should only be issued if a Checkpointer is used (and maybe also when a simulation picks up from an existing Checkpoint). I think for sophisticated research Checkpointing is common, but for simpler classroom and LES applications the checkpointer is used less. After all, probably the most simulations are actually run in our examples on CI -- and there are no examples with a checkpointer! (It would be nice to change that). I can't speak for others, but for boundary layer parameterization work the LES typically run in less than 24 hours of wall time. We also only utilize very simple diagnostics, like the horizontally-averaged solution at the final time step. So in those rare cases that we need a checkpointer (I have used a handful of times) barebones checkpointing is sufficient. Of course we are currently working on building a OMIP simulation and that will require much longer runs, so we will definitely need more sophisticated checkpointing very soon. @simone-silvestri and @tomchor might have more to add. Or @sandreza, what do you use for the neverworld work?. I'm not saying we don't want to develop this, I'm just providing some context about why this hasn't been resolved / developed yet. In an ideal world the simulations would run fast enough that we wouldn't need checkpointing, after all 😄",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3721#issuecomment-2305131230
Availability,checkpoint,checkpointer,"> I think for sophisticated research Checkpointing is common, but for simpler classroom and LES applications the checkpointer is used less. After all, probably the most simulations are actually run in our examples on CI -- and there are no examples with a checkpointer! (It would be nice to change that). Agreed!. > I can't speak for others, but for boundary layer parameterization work the LES typically run in less than 24 hours of wall time. We also only utilize very simple diagnostics, like the horizontally-averaged solution at the final time step. So in those rare cases that we need a checkpointer (I have used a handful of times) barebones checkpointing is sufficient.; > ; > Of course we are currently working on building a OMIP simulation and that will require much longer runs, so we will definitely need more sophisticated checkpointing very soon.; > ; > @simone-silvestri and @tomchor might have more to add. Or @sandreza, what do you use for the neverworld work?. For context, 100% of my simulations have used checkpoints. As far as I know, 100% of the simulations from others in my group also use checkpoints. The only exceptions for my case are very early scripts still in the development phase, and still with very coarse grids. As soon as I try to get more serious with it, I need checkpoints. So this a PR I'm very much looking forward to seeing merged ;)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3721#issuecomment-2305164720
Modifiability,parameteriz,parameterization,"> I think for sophisticated research Checkpointing is common, but for simpler classroom and LES applications the checkpointer is used less. After all, probably the most simulations are actually run in our examples on CI -- and there are no examples with a checkpointer! (It would be nice to change that). Agreed!. > I can't speak for others, but for boundary layer parameterization work the LES typically run in less than 24 hours of wall time. We also only utilize very simple diagnostics, like the horizontally-averaged solution at the final time step. So in those rare cases that we need a checkpointer (I have used a handful of times) barebones checkpointing is sufficient.; > ; > Of course we are currently working on building a OMIP simulation and that will require much longer runs, so we will definitely need more sophisticated checkpointing very soon.; > ; > @simone-silvestri and @tomchor might have more to add. Or @sandreza, what do you use for the neverworld work?. For context, 100% of my simulations have used checkpoints. As far as I know, 100% of the simulations from others in my group also use checkpoints. The only exceptions for my case are very early scripts still in the development phase, and still with very coarse grids. As soon as I try to get more serious with it, I need checkpoints. So this a PR I'm very much looking forward to seeing merged ;)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3721#issuecomment-2305164720
Usability,simpl,simpler,"> I think for sophisticated research Checkpointing is common, but for simpler classroom and LES applications the checkpointer is used less. After all, probably the most simulations are actually run in our examples on CI -- and there are no examples with a checkpointer! (It would be nice to change that). Agreed!. > I can't speak for others, but for boundary layer parameterization work the LES typically run in less than 24 hours of wall time. We also only utilize very simple diagnostics, like the horizontally-averaged solution at the final time step. So in those rare cases that we need a checkpointer (I have used a handful of times) barebones checkpointing is sufficient.; > ; > Of course we are currently working on building a OMIP simulation and that will require much longer runs, so we will definitely need more sophisticated checkpointing very soon.; > ; > @simone-silvestri and @tomchor might have more to add. Or @sandreza, what do you use for the neverworld work?. For context, 100% of my simulations have used checkpoints. As far as I know, 100% of the simulations from others in my group also use checkpoints. The only exceptions for my case are very early scripts still in the development phase, and still with very coarse grids. As soon as I try to get more serious with it, I need checkpoints. So this a PR I'm very much looking forward to seeing merged ;)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3721#issuecomment-2305164720
Usability,clear,clear,"For sure, we are happy to merge any improvement no matter how small. PRs only have to push the project forward, they don't have to be ""big"" or ""important"". Independent of that, it'd be good to have a clear conclusion about whether a redesign really is needed too because we are in a good position to make that judgment now.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3721#issuecomment-2379750613
Availability,checkpoint,checkpointing,"> I think that should be revisited when we decide to take on the more challenging issue of checkpointing partially-accumulated time-averages so that windowed_time_average always works as intended when picking up from checkpoints. good point!. There is a possibility that it is not very hard. It will require reshuffling code (which I can do), but with Julia we can serialize objects to disk and then load them back seamlessly in a single line... which might be all we need. The only limitation of serialization is that we haven't yet figured out how to serialize _methods_ (eg functions) which prevents us from serializing entire models. When functions are not involved things can be pretty simple.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3721#issuecomment-2379890956
Performance,load,load,"> I think that should be revisited when we decide to take on the more challenging issue of checkpointing partially-accumulated time-averages so that windowed_time_average always works as intended when picking up from checkpoints. good point!. There is a possibility that it is not very hard. It will require reshuffling code (which I can do), but with Julia we can serialize objects to disk and then load them back seamlessly in a single line... which might be all we need. The only limitation of serialization is that we haven't yet figured out how to serialize _methods_ (eg functions) which prevents us from serializing entire models. When functions are not involved things can be pretty simple.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3721#issuecomment-2379890956
Usability,simpl,simple,"> I think that should be revisited when we decide to take on the more challenging issue of checkpointing partially-accumulated time-averages so that windowed_time_average always works as intended when picking up from checkpoints. good point!. There is a possibility that it is not very hard. It will require reshuffling code (which I can do), but with Julia we can serialize objects to disk and then load them back seamlessly in a single line... which might be all we need. The only limitation of serialization is that we haven't yet figured out how to serialize _methods_ (eg functions) which prevents us from serializing entire models. When functions are not involved things can be pretty simple.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3721#issuecomment-2379890956
Availability,checkpoint,checkpoint,"Our earlier [tests](https://github.com/liuchihl/Oceananigans.jl/pull/1#issuecomment-2295354459) with a simple sine function indicate that when the checkpoint interval is an integer multiple of the `AveragedTimeInterval`, the results after the checkpoint seem reasonable. However, I’ve noticed this isn't the case with the following parameter settings, for instance:. ```julia; Δt = .01 # timestep; T1 = 6Δt # first simulation stop time; T2 = 2T1 # second simulation stop time; window_nΔt = 2 # window interval: 2Δt; interval_nΔt = 2 # time average saving interval: 2Δt; stride = 1; ```; The averaged values are clearly off after the checkpoint (t>6Δt):; <img width=""587"" alt=""image"" src=""https://github.com/user-attachments/assets/24c0238d-3723-435d-bca2-4b4a2be83e71"">. This issue does not only occur in the existing MWE (decaying function); it also occurs in our [MWE](https://github.com/liuchihl/Oceananigans.jl/pull/1#issuecomment-2295343588) using the exact same parameters mentioned above. The dashed curve and steps indicate `TimeInterval` and `AveragedTimeInterval` outputs, respectively, shown in the figure below. It is unclear to me as to why spurious zero appears in this case.; <img width=""892"" alt=""image"" src=""https://github.com/user-attachments/assets/5e78add8-7b29-45f3-8123-156cf6ae38d3"">. The point of these tests is to show that even when the checkpoint interval is an integer multiple of the `AveragedTimeInterval`, issues can still arise. . Here is the MWE with the decaying function for reference: ; ```julia; using Oceananigans; using Plots; using NCDatasets; using Test; if isfile(""single_decay_windowed_time_average_test.nc""); rm(""single_decay_windowed_time_average_test.nc""); end; run(`sh -c ""rm test_iteration*.jld2""`). function test_simulation(stop_time, Δt, window_nΔt, interval_nΔt, stride, overwrite). arch = CPU(); topo = (Periodic, Periodic, Periodic); domain = (x=(0, 1), y=(0, 1), z=(0, 1)); grid = RectilinearGrid(arch, topology=topo, size=(4, 4, 4); domain...). λ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3721#issuecomment-2380652629
Energy Efficiency,schedul,schedule," c1_forcing = Forcing(Fc1, field_dependencies=:c1); c2_forcing = Forcing(Fc2, field_dependencies=:c2). model = NonhydrostaticModel(; grid,; timestepper = :RungeKutta3,; tracers = (:c1, :c2),; forcing = (c1=c1_forcing, c2=c2_forcing)). set!(model, c1=1, c2=1); simulation = Simulation(model, Δt=Δt, stop_time=stop_time). ∫c1_dxdy = Field(Average(model.tracers.c1, dims=(1, 2))); ∫c2_dxdy = Field(Average(model.tracers.c2, dims=(1, 2))); ; nc_outputs = Dict(""c1"" => ∫c1_dxdy, ""c2"" => ∫c2_dxdy); nc_dimensions = Dict(""c1"" => (""zC"",), ""c2"" => (""zC"",)). single_time_average_nc_filepath = ""single_decay_windowed_time_average_test.nc""; ; window = window_nΔt*Δt; interval = interval_nΔt*Δt. single_nc_output = Dict(""c1"" => ∫c1_dxdy); single_nc_dimension = Dict(""c1"" => (""zC"",)). simulation.output_writers[:single_output_time_average] =; NetCDFOutputWriter(model, single_nc_output,; array_type = Array{Float64},; verbose = true,; filename = single_time_average_nc_filepath,; schedule = AveragedTimeInterval(interval, window = window, stride = stride),; dimensions = single_nc_dimension,; overwrite_existing = overwrite); checkpointer = Checkpointer(model,; schedule = TimeInterval(stop_time),; prefix = ""test"",; cleanup = true). simulation.output_writers[:checkpointer] = checkpointer. return simulation. end; ; Δt = .01 #1/64 # Nice floating-point number; T1 = 6Δt # first simulation stop time (s); T2 = 2T1 # second simulation stop time (s); window_nΔt = 2; interval_nΔt = 2; stride = 1; # Run a simulation that saves data to a checkpoint; simulation = test_simulation(T1, Δt, window_nΔt, interval_nΔt, stride, true); run!(simulation). # Now try again, but picking up from the previous checkpoint; N = iteration(simulation); checkpoint = ""test_iteration$N.jld2""; simulation = test_simulation(T2, Δt, window_nΔt, interval_nΔt, stride, false); run!(simulation, pickup=checkpoint). ##### For each λ, horizontal average should evaluate to; #####; ##### c̄(z, t) = ∫₀¹ ∫₀¹ exp{- λ(x, y, z) * t} dx dy; ##### = 1 /",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3721#issuecomment-2380652629
Testability,test,tests,"Our earlier [tests](https://github.com/liuchihl/Oceananigans.jl/pull/1#issuecomment-2295354459) with a simple sine function indicate that when the checkpoint interval is an integer multiple of the `AveragedTimeInterval`, the results after the checkpoint seem reasonable. However, I’ve noticed this isn't the case with the following parameter settings, for instance:. ```julia; Δt = .01 # timestep; T1 = 6Δt # first simulation stop time; T2 = 2T1 # second simulation stop time; window_nΔt = 2 # window interval: 2Δt; interval_nΔt = 2 # time average saving interval: 2Δt; stride = 1; ```; The averaged values are clearly off after the checkpoint (t>6Δt):; <img width=""587"" alt=""image"" src=""https://github.com/user-attachments/assets/24c0238d-3723-435d-bca2-4b4a2be83e71"">. This issue does not only occur in the existing MWE (decaying function); it also occurs in our [MWE](https://github.com/liuchihl/Oceananigans.jl/pull/1#issuecomment-2295343588) using the exact same parameters mentioned above. The dashed curve and steps indicate `TimeInterval` and `AveragedTimeInterval` outputs, respectively, shown in the figure below. It is unclear to me as to why spurious zero appears in this case.; <img width=""892"" alt=""image"" src=""https://github.com/user-attachments/assets/5e78add8-7b29-45f3-8123-156cf6ae38d3"">. The point of these tests is to show that even when the checkpoint interval is an integer multiple of the `AveragedTimeInterval`, issues can still arise. . Here is the MWE with the decaying function for reference: ; ```julia; using Oceananigans; using Plots; using NCDatasets; using Test; if isfile(""single_decay_windowed_time_average_test.nc""); rm(""single_decay_windowed_time_average_test.nc""); end; run(`sh -c ""rm test_iteration*.jld2""`). function test_simulation(stop_time, Δt, window_nΔt, interval_nΔt, stride, overwrite). arch = CPU(); topo = (Periodic, Periodic, Periodic); domain = (x=(0, 1), y=(0, 1), z=(0, 1)); grid = RectilinearGrid(arch, topology=topo, size=(4, 4, 4); domain...). λ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3721#issuecomment-2380652629
Usability,simpl,simple,"Our earlier [tests](https://github.com/liuchihl/Oceananigans.jl/pull/1#issuecomment-2295354459) with a simple sine function indicate that when the checkpoint interval is an integer multiple of the `AveragedTimeInterval`, the results after the checkpoint seem reasonable. However, I’ve noticed this isn't the case with the following parameter settings, for instance:. ```julia; Δt = .01 # timestep; T1 = 6Δt # first simulation stop time; T2 = 2T1 # second simulation stop time; window_nΔt = 2 # window interval: 2Δt; interval_nΔt = 2 # time average saving interval: 2Δt; stride = 1; ```; The averaged values are clearly off after the checkpoint (t>6Δt):; <img width=""587"" alt=""image"" src=""https://github.com/user-attachments/assets/24c0238d-3723-435d-bca2-4b4a2be83e71"">. This issue does not only occur in the existing MWE (decaying function); it also occurs in our [MWE](https://github.com/liuchihl/Oceananigans.jl/pull/1#issuecomment-2295343588) using the exact same parameters mentioned above. The dashed curve and steps indicate `TimeInterval` and `AveragedTimeInterval` outputs, respectively, shown in the figure below. It is unclear to me as to why spurious zero appears in this case.; <img width=""892"" alt=""image"" src=""https://github.com/user-attachments/assets/5e78add8-7b29-45f3-8123-156cf6ae38d3"">. The point of these tests is to show that even when the checkpoint interval is an integer multiple of the `AveragedTimeInterval`, issues can still arise. . Here is the MWE with the decaying function for reference: ; ```julia; using Oceananigans; using Plots; using NCDatasets; using Test; if isfile(""single_decay_windowed_time_average_test.nc""); rm(""single_decay_windowed_time_average_test.nc""); end; run(`sh -c ""rm test_iteration*.jld2""`). function test_simulation(stop_time, Δt, window_nΔt, interval_nΔt, stride, overwrite). arch = CPU(); topo = (Periodic, Periodic, Periodic); domain = (x=(0, 1), y=(0, 1), z=(0, 1)); grid = RectilinearGrid(arch, topology=topo, size=(4, 4, 4); domain...). λ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3721#issuecomment-2380652629
Availability,mask,masks,"> we could be calling it within flattened_cpu_interior but the method name doesn't suggest that... if you think of a way to improve do it!. Good idea. Find a new name for the function! What it does:. 1. Drops singleton dimensions; 2. Converts from CPU to GPU; 3. masks immersed regions with NaN. Perhaps simple `convert_field`, because in the context of the extension ""convert"" means to change an argument from the input into something plottable. Or perhaps `make_plottable_field(f)`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3725#issuecomment-2308633068
Usability,simpl,simple,"> we could be calling it within flattened_cpu_interior but the method name doesn't suggest that... if you think of a way to improve do it!. Good idea. Find a new name for the function! What it does:. 1. Drops singleton dimensions; 2. Converts from CPU to GPU; 3. masks immersed regions with NaN. Perhaps simple `convert_field`, because in the context of the extension ""convert"" means to change an argument from the input into something plottable. Or perhaps `make_plottable_field(f)`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3725#issuecomment-2308633068
Energy Efficiency,schedul,schedule,"One simple solution would be to host the GitHub action on the `OceananigansDocumentation` and have it so that it runs on a schedule (e.g., weekly).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3726#issuecomment-2308611712
Usability,simpl,simple,"One simple solution would be to host the GitHub action on the `OceananigansDocumentation` and have it so that it runs on a schedule (e.g., weekly).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3726#issuecomment-2308611712
Energy Efficiency,schedul,schedule,"You mean have a GitHub action in the Docs repo and every week clear up all accumulated previews?; That's great! That would work amazingly. Do you know how to do this weekly schedule?; (Then we can also do it for ClimaOcean Docs repo, etc!)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3726#issuecomment-2308648418
Usability,clear,clear,"You mean have a GitHub action in the Docs repo and every week clear up all accumulated previews?; That's great! That would work amazingly. Do you know how to do this weekly schedule?; (Then we can also do it for ClimaOcean Docs repo, etc!)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3726#issuecomment-2308648418
Energy Efficiency,schedul,schedule,"> You mean have a GitHub action in the Docs repo and every week clear up all accumulated previews? That's great! That would work amazingly. Do you know how to do this weekly schedule? (Then we can also do it for ClimaOcean Docs repo, etc!). Yes, have a look [here](https://docs.github.com/en/actions/writing-workflows/choosing-when-your-workflow-runs/events-that-trigger-workflows#schedule) to learn how to run a GitHub action on a schedule",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3726#issuecomment-2308892652
Usability,clear,clear,"> You mean have a GitHub action in the Docs repo and every week clear up all accumulated previews? That's great! That would work amazingly. Do you know how to do this weekly schedule? (Then we can also do it for ClimaOcean Docs repo, etc!). Yes, have a look [here](https://docs.github.com/en/actions/writing-workflows/choosing-when-your-workflow-runs/events-that-trigger-workflows#schedule) to learn how to run a GitHub action on a schedule",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3726#issuecomment-2308892652
Usability,simpl,simple,"I think I figured it out, basically there is a function `args_preferred_axis` that determines which Axis type to use (when it's not specified), and because `Field isa AbstractArray{3}` it ends up choosing `LScene`. So the simple fix here is just to say that `Field` does not have a preferred axis type. As a result, when the axis is not provided, it is determined later on (by the converted arguments, rather than the un-converted `Field`). We could in the future attempt to figure out the ""effective dimensionality"" of a `Field` and then use that to determine whether it has a preferred axis type.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3727#issuecomment-2309347163
Testability,test,test,#3733 introduces a very simple test for interpolation on field time series (testing trivial interpolation),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3731#issuecomment-2310580405
Usability,simpl,simple,#3733 introduces a very simple test for interpolation on field time series (testing trivial interpolation),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3731#issuecomment-2310580405
Modifiability,variab,variable,"Out of curiousity, how much work is it to implement RK3 for `HydrostaticFreeSurfaceModel`?. Seems like fixing AB2 for variable time steps isn't too difficult if it's just changing how $G^{n+1}$ is computed though. > Why don't we answer this once and for all, there are not two answers to this question. I thought this was answered quite clearly, albeit for a very idealized case, here: https://github.com/CliMA/Oceananigans.jl/pull/945#issuecomment-692706814 Is AB2 still technically only first-order accurate?. I know it's quite difficult to extrapolate from the convergence test to global simulations, but my experience has been that RK3 beats out AB2 for non-hydrostatic simulations. That said, it's probably still good to have AB2 especially if it can support variable time steps.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3738#issuecomment-2418029947
Testability,test,test,"Out of curiousity, how much work is it to implement RK3 for `HydrostaticFreeSurfaceModel`?. Seems like fixing AB2 for variable time steps isn't too difficult if it's just changing how $G^{n+1}$ is computed though. > Why don't we answer this once and for all, there are not two answers to this question. I thought this was answered quite clearly, albeit for a very idealized case, here: https://github.com/CliMA/Oceananigans.jl/pull/945#issuecomment-692706814 Is AB2 still technically only first-order accurate?. I know it's quite difficult to extrapolate from the convergence test to global simulations, but my experience has been that RK3 beats out AB2 for non-hydrostatic simulations. That said, it's probably still good to have AB2 especially if it can support variable time steps.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3738#issuecomment-2418029947
Usability,clear,clearly,"Out of curiousity, how much work is it to implement RK3 for `HydrostaticFreeSurfaceModel`?. Seems like fixing AB2 for variable time steps isn't too difficult if it's just changing how $G^{n+1}$ is computed though. > Why don't we answer this once and for all, there are not two answers to this question. I thought this was answered quite clearly, albeit for a very idealized case, here: https://github.com/CliMA/Oceananigans.jl/pull/945#issuecomment-692706814 Is AB2 still technically only first-order accurate?. I know it's quite difficult to extrapolate from the convergence test to global simulations, but my experience has been that RK3 beats out AB2 for non-hydrostatic simulations. That said, it's probably still good to have AB2 especially if it can support variable time steps.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3738#issuecomment-2418029947
Availability,error,errors,"> I thought this was answered quite clearly, albeit for a very idealized case, here: https://github.com/CliMA/Oceananigans.jl/pull/945#issuecomment-692706814 Is AB2 still technically only first-order accurate?. True, that PR does demonstrate convergence with time step! However we seem to rarely concern ourselves with time-stepping errors (apart from catastrophic instability), which I think is justified since spatial errors dominate in our simulations that are typically marginally-resolved in space by design. The stickier and harder question regards _time to solution_, which is what we really care about. It's stickier because it is fundamentally heuristic. For example since RK3 is a 3-stage time-stepper and AB2 is 1-stage, we need to be able to take time-steps that are 3 times longer with RK3. Theoretically, [AB2 is stable up to CFL=0.5](https://mitgcm.org/public/r2_manual/final/online_documents/node310.html) while RK3 is stable up to CFL=sqrt(3)=1.7 --- just barely achieving the ""3x"" needed for RK3 to be superior. But that's just in theory. In practice we find that solutions become unstable at lower CFL, and caution warrants a bit of buffer. It seems like we usually use CFL=0.1-0.2 for AB2 but CFL=0.5-1 for RK3. So at the lower end for AB2, RK3 is indeed providing a decent speed up for time to solution. And I agree with you @ali-ramadhan that I have found in practice that I prefer RK3 for LES. There is more to the story --- RK3 also has superior stability properties for diffusion. Where there is some interesting room for further research is also to understand how much more stable RK3 might make a turbulence closure scheme like CATKE or k-epsilon. We do find that these can impose stricter time-step restrictions than advection, especially on grids with very fine vertical resolution near the surface. RK3 also has the crucial advantage that it is self-starting. This means we can change the time-step at will (without resolving this issue I guess) and we don't need tendenc",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3738#issuecomment-2418061394
Energy Efficiency,adapt,adapt,"3x"" needed for RK3 to be superior. But that's just in theory. In practice we find that solutions become unstable at lower CFL, and caution warrants a bit of buffer. It seems like we usually use CFL=0.1-0.2 for AB2 but CFL=0.5-1 for RK3. So at the lower end for AB2, RK3 is indeed providing a decent speed up for time to solution. And I agree with you @ali-ramadhan that I have found in practice that I prefer RK3 for LES. There is more to the story --- RK3 also has superior stability properties for diffusion. Where there is some interesting room for further research is also to understand how much more stable RK3 might make a turbulence closure scheme like CATKE or k-epsilon. We do find that these can impose stricter time-step restrictions than advection, especially on grids with very fine vertical resolution near the surface. RK3 also has the crucial advantage that it is self-starting. This means we can change the time-step at will (without resolving this issue I guess) and we don't need tendencies to checkpoint. Also of course RK3 is actually 3rd order whereas QAB2 is first order. Note that the advantages of RK3 have historically not been useful for ocean simulations because at coarse (non-eddy-resolving) resolutions the momentum time-step is limited by Coriolis, not by CFL / advection. In that case a one-stage time-stepper might be preferred. > Out of curiousity, how much work is it to implement RK3 for HydrostaticFreeSurfaceModel?. It may be a research project to adapt the split-explicit free surface. It's little unclear because naively, we may be able to advance the split-explicit free surface each stage and therefore use the same algorithm we use for AB2. But there has been some work to implement an algorithm that resembles Le and Moin 1991 where the free surface is advanced to the end of the time-step, while baroclinic variables are advanced in stages. That would yield even more speed up. @simone-silvestri has thought about this a bit and might have more to add...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3738#issuecomment-2418061394
Modifiability,adapt,adapt,"3x"" needed for RK3 to be superior. But that's just in theory. In practice we find that solutions become unstable at lower CFL, and caution warrants a bit of buffer. It seems like we usually use CFL=0.1-0.2 for AB2 but CFL=0.5-1 for RK3. So at the lower end for AB2, RK3 is indeed providing a decent speed up for time to solution. And I agree with you @ali-ramadhan that I have found in practice that I prefer RK3 for LES. There is more to the story --- RK3 also has superior stability properties for diffusion. Where there is some interesting room for further research is also to understand how much more stable RK3 might make a turbulence closure scheme like CATKE or k-epsilon. We do find that these can impose stricter time-step restrictions than advection, especially on grids with very fine vertical resolution near the surface. RK3 also has the crucial advantage that it is self-starting. This means we can change the time-step at will (without resolving this issue I guess) and we don't need tendencies to checkpoint. Also of course RK3 is actually 3rd order whereas QAB2 is first order. Note that the advantages of RK3 have historically not been useful for ocean simulations because at coarse (non-eddy-resolving) resolutions the momentum time-step is limited by Coriolis, not by CFL / advection. In that case a one-stage time-stepper might be preferred. > Out of curiousity, how much work is it to implement RK3 for HydrostaticFreeSurfaceModel?. It may be a research project to adapt the split-explicit free surface. It's little unclear because naively, we may be able to advance the split-explicit free surface each stage and therefore use the same algorithm we use for AB2. But there has been some work to implement an algorithm that resembles Le and Moin 1991 where the free surface is advanced to the end of the time-step, while baroclinic variables are advanced in stages. That would yield even more speed up. @simone-silvestri has thought about this a bit and might have more to add...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3738#issuecomment-2418061394
Usability,clear,clearly,"> I thought this was answered quite clearly, albeit for a very idealized case, here: https://github.com/CliMA/Oceananigans.jl/pull/945#issuecomment-692706814 Is AB2 still technically only first-order accurate?. True, that PR does demonstrate convergence with time step! However we seem to rarely concern ourselves with time-stepping errors (apart from catastrophic instability), which I think is justified since spatial errors dominate in our simulations that are typically marginally-resolved in space by design. The stickier and harder question regards _time to solution_, which is what we really care about. It's stickier because it is fundamentally heuristic. For example since RK3 is a 3-stage time-stepper and AB2 is 1-stage, we need to be able to take time-steps that are 3 times longer with RK3. Theoretically, [AB2 is stable up to CFL=0.5](https://mitgcm.org/public/r2_manual/final/online_documents/node310.html) while RK3 is stable up to CFL=sqrt(3)=1.7 --- just barely achieving the ""3x"" needed for RK3 to be superior. But that's just in theory. In practice we find that solutions become unstable at lower CFL, and caution warrants a bit of buffer. It seems like we usually use CFL=0.1-0.2 for AB2 but CFL=0.5-1 for RK3. So at the lower end for AB2, RK3 is indeed providing a decent speed up for time to solution. And I agree with you @ali-ramadhan that I have found in practice that I prefer RK3 for LES. There is more to the story --- RK3 also has superior stability properties for diffusion. Where there is some interesting room for further research is also to understand how much more stable RK3 might make a turbulence closure scheme like CATKE or k-epsilon. We do find that these can impose stricter time-step restrictions than advection, especially on grids with very fine vertical resolution near the surface. RK3 also has the crucial advantage that it is self-starting. This means we can change the time-step at will (without resolving this issue I guess) and we don't need tendenc",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3738#issuecomment-2418061394
Modifiability,extend,extended,"Right `InMemory` is more like a `nothing` backend, there's nothing back there. . On ClimaOcean there's an example how we extended this infrastructure to a particular kind of NetCDF backend: https://github.com/CliMA/ClimaOcean.jl/blob/dd9148a8f702699ddf2947d3a1a094adddbd9bb1/src/DataWrangling/JRA55.jl#L218. The implementation in this PR seems simple enough though. @ali-ramadhan maybe can you provide a little syntax example how you expect this to be used? @navidcy take a look and see what you think",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3739#issuecomment-2314147354
Usability,simpl,simple,"Right `InMemory` is more like a `nothing` backend, there's nothing back there. . On ClimaOcean there's an example how we extended this infrastructure to a particular kind of NetCDF backend: https://github.com/CliMA/ClimaOcean.jl/blob/dd9148a8f702699ddf2947d3a1a094adddbd9bb1/src/DataWrangling/JRA55.jl#L218. The implementation in this PR seems simple enough though. @ali-ramadhan maybe can you provide a little syntax example how you expect this to be used? @navidcy take a look and see what you think",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3739#issuecomment-2314147354
Usability,clear,clear,"I do agree that `backend_kw` is maybe not the best name for this. I think I named it so out of the discussion in https://github.com/CliMA/Oceananigans.jl/issues/3680 around ""storing the kwargs in the backend"". But yeah there's a backend where the data is stored, e.g. in memory or on disk, but there's also how the data is read, e.g. JLD2 or NetCDF. ""Backend kwargs"" should go into the call to `OnDisk` for example. So `reader_kwargs` makes sense to me (or `reader_kw` if we want to be consistent with `JLD2OutputWriter` property names). Maybe the better names will become clear once `FieldTimeSeries` supports reading from NetCDF (something I'm interested in working on).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3739#issuecomment-2441835962
Testability,test,test,"Perhaps we don't have this, but can we rotate a `LatitudeLongitudeGrid` by a certain angle, and then test that the vectors are rotated exactly by that angle? This would provide a simple deterministic test. This could work for a very small grid on the equator, for example...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3744#issuecomment-2315768430
Usability,simpl,simple,"Perhaps we don't have this, but can we rotate a `LatitudeLongitudeGrid` by a certain angle, and then test that the vectors are rotated exactly by that angle? This would provide a simple deterministic test. This could work for a very small grid on the equator, for example...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3744#issuecomment-2315768430
Availability,error,error,"Something is not right again. There is a method `validate_closure`; seems like that's the place to put the error message?. My argument is just based on intuition from the method's name. This error seems part of the validation, right?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3753#issuecomment-2325594749
Integrability,message,message,"Something is not right again. There is a method `validate_closure`; seems like that's the place to put the error message?. My argument is just based on intuition from the method's name. This error seems part of the validation, right?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3753#issuecomment-2325594749
Security,validat,validation,"Something is not right again. There is a method `validate_closure`; seems like that's the place to put the error message?. My argument is just based on intuition from the method's name. This error seems part of the validation, right?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3753#issuecomment-2325594749
Usability,intuit,intuition,"Something is not right again. There is a method `validate_closure`; seems like that's the place to put the error message?. My argument is just based on intuition from the method's name. This error seems part of the validation, right?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3753#issuecomment-2325594749
Availability,error,error,"> Something is not right again.; > ; > There is a method `validate_closure`; seems like that's the place to put the error message?; > ; > My argument is just based on intuition from the method's name. This error seems part of the validation, right?. True, this would work for `NonhydrostaticModel`. https://github.com/CliMA/Oceananigans.jl/blob/b121003ef43e04d5792c6f0ca13cccc05f3d9385/src/Models/NonhydrostaticModels/nonhydrostatic_model.jl#L168. but we have to make some changes to make this work for `HydrostaticFreeSurfaceModel` because `with_tracers` is called first. https://github.com/CliMA/Oceananigans.jl/blob/3c95e7ee6772a2597e206ae35202500be1ef5b32/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_model.jl#L163-L166. so either we need to call `validate_closure` first, or we need to put in a fallback for `with_tracers`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3753#issuecomment-2327079994
Integrability,message,message,"> Something is not right again.; > ; > There is a method `validate_closure`; seems like that's the place to put the error message?; > ; > My argument is just based on intuition from the method's name. This error seems part of the validation, right?. True, this would work for `NonhydrostaticModel`. https://github.com/CliMA/Oceananigans.jl/blob/b121003ef43e04d5792c6f0ca13cccc05f3d9385/src/Models/NonhydrostaticModels/nonhydrostatic_model.jl#L168. but we have to make some changes to make this work for `HydrostaticFreeSurfaceModel` because `with_tracers` is called first. https://github.com/CliMA/Oceananigans.jl/blob/3c95e7ee6772a2597e206ae35202500be1ef5b32/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_model.jl#L163-L166. so either we need to call `validate_closure` first, or we need to put in a fallback for `with_tracers`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3753#issuecomment-2327079994
Security,validat,validation,"> Something is not right again.; > ; > There is a method `validate_closure`; seems like that's the place to put the error message?; > ; > My argument is just based on intuition from the method's name. This error seems part of the validation, right?. True, this would work for `NonhydrostaticModel`. https://github.com/CliMA/Oceananigans.jl/blob/b121003ef43e04d5792c6f0ca13cccc05f3d9385/src/Models/NonhydrostaticModels/nonhydrostatic_model.jl#L168. but we have to make some changes to make this work for `HydrostaticFreeSurfaceModel` because `with_tracers` is called first. https://github.com/CliMA/Oceananigans.jl/blob/3c95e7ee6772a2597e206ae35202500be1ef5b32/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_model.jl#L163-L166. so either we need to call `validate_closure` first, or we need to put in a fallback for `with_tracers`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3753#issuecomment-2327079994
Usability,intuit,intuition,"> Something is not right again.; > ; > There is a method `validate_closure`; seems like that's the place to put the error message?; > ; > My argument is just based on intuition from the method's name. This error seems part of the validation, right?. True, this would work for `NonhydrostaticModel`. https://github.com/CliMA/Oceananigans.jl/blob/b121003ef43e04d5792c6f0ca13cccc05f3d9385/src/Models/NonhydrostaticModels/nonhydrostatic_model.jl#L168. but we have to make some changes to make this work for `HydrostaticFreeSurfaceModel` because `with_tracers` is called first. https://github.com/CliMA/Oceananigans.jl/blob/3c95e7ee6772a2597e206ae35202500be1ef5b32/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_model.jl#L163-L166. so either we need to call `validate_closure` first, or we need to put in a fallback for `with_tracers`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3753#issuecomment-2327079994
Testability,test,tested,"This looks very much like a bug. We have used particle tracking on immersed grids many times in the past. That kernel should work for both immersed and not-immersed grids, the fix should be simple. It looks like this feature is not tested, so; it would be nice to add a test, (something simple like a particle bouncing off a wall in a 1D domain with an immersed boundary compared to a Bounded domain). @tomchor do you want (or have time) to tackle this?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3761#issuecomment-2332079749
Usability,simpl,simple,"This looks very much like a bug. We have used particle tracking on immersed grids many times in the past. That kernel should work for both immersed and not-immersed grids, the fix should be simple. It looks like this feature is not tested, so; it would be nice to add a test, (something simple like a particle bouncing off a wall in a 1D domain with an immersed boundary compared to a Bounded domain). @tomchor do you want (or have time) to tackle this?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3761#issuecomment-2332079749
Availability,error,error,"Well, it looks like this PR does not completely solve the problem, and the jury is out perhaps on whether it helps or not. I did learn a few things. It seems the race condition originates from an attempt to ""re-resolve"" the manifest during the test:. https://buildkite.com/clima/oceananigans/builds/17516#01920c32-4e89-4654-a4a8-9b077e51e87c/39-221. The puzzling part is how to solve the problem. I thought at first we could solve it by preventing the Manifest from being ""re-resolved"" --- perhaps by resolving it correctly during initialization? But actually, this isn't possible, since the problematic manifest in question is a temporary run that is created only for the tests (and its different from the project's manifest, because it also includes the test dependencies). This temporary test manifest can't be initialized as far as I can tell and is created independently for each test. Finally, it seems that some race conditions happen in a print statement (this is just from reading the error message). It all boils down eventually to these two lines:. https://github.com/JuliaLang/Pkg.jl/blob/5fbfa125045ce3e68ce10bf9fc1727bb3232c123/src/Operations.jl#L799-L800. The command its trying to run is. ```julia; ERROR: failed process: Process(`/net/ocean/home/data44/data5/glwagner/julia-1.10.5/bin/julia -C native -J/net/ocean/home/data44/data5/glwagner/julia-1.10.5/lib/julia/sys.so -O0 -g1 --color=yes -O0 --color=no --history-file=no --startup-file=no --project=/tmp/jl_f9Z8t1/Project.toml --eval 'append!(empty!(Base.DEPOT_PATH), [""/data5/glwagner/.julia-17516""]); --;   | append!(empty!(Base.DL_LOAD_PATH), String[]). cd(""/data5/glwagner/.julia-17516/packages/CUDA_Runtime_jll/YgJCI/.pkg""); --;   | include(""/data5/glwagner/.julia-17516/packages/CUDA_Runtime_jll/YgJCI/.pkg/select_artifacts.jl"");   | ' -t1 --startup-file=no x86_64-linux-gnu-libgfortran5-cxx11-julia_version+1.10.5`, ProcessSignaled(11)) [0]; ```. and supposedly the issue arises within the `select_artifacts.jl` call in `CUD",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3783#issuecomment-2362378199
Integrability,depend,dependencies,"Well, it looks like this PR does not completely solve the problem, and the jury is out perhaps on whether it helps or not. I did learn a few things. It seems the race condition originates from an attempt to ""re-resolve"" the manifest during the test:. https://buildkite.com/clima/oceananigans/builds/17516#01920c32-4e89-4654-a4a8-9b077e51e87c/39-221. The puzzling part is how to solve the problem. I thought at first we could solve it by preventing the Manifest from being ""re-resolved"" --- perhaps by resolving it correctly during initialization? But actually, this isn't possible, since the problematic manifest in question is a temporary run that is created only for the tests (and its different from the project's manifest, because it also includes the test dependencies). This temporary test manifest can't be initialized as far as I can tell and is created independently for each test. Finally, it seems that some race conditions happen in a print statement (this is just from reading the error message). It all boils down eventually to these two lines:. https://github.com/JuliaLang/Pkg.jl/blob/5fbfa125045ce3e68ce10bf9fc1727bb3232c123/src/Operations.jl#L799-L800. The command its trying to run is. ```julia; ERROR: failed process: Process(`/net/ocean/home/data44/data5/glwagner/julia-1.10.5/bin/julia -C native -J/net/ocean/home/data44/data5/glwagner/julia-1.10.5/lib/julia/sys.so -O0 -g1 --color=yes -O0 --color=no --history-file=no --startup-file=no --project=/tmp/jl_f9Z8t1/Project.toml --eval 'append!(empty!(Base.DEPOT_PATH), [""/data5/glwagner/.julia-17516""]); --;   | append!(empty!(Base.DL_LOAD_PATH), String[]). cd(""/data5/glwagner/.julia-17516/packages/CUDA_Runtime_jll/YgJCI/.pkg""); --;   | include(""/data5/glwagner/.julia-17516/packages/CUDA_Runtime_jll/YgJCI/.pkg/select_artifacts.jl"");   | ' -t1 --startup-file=no x86_64-linux-gnu-libgfortran5-cxx11-julia_version+1.10.5`, ProcessSignaled(11)) [0]; ```. and supposedly the issue arises within the `select_artifacts.jl` call in `CUD",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3783#issuecomment-2362378199
Performance,race condition,race condition,"Well, it looks like this PR does not completely solve the problem, and the jury is out perhaps on whether it helps or not. I did learn a few things. It seems the race condition originates from an attempt to ""re-resolve"" the manifest during the test:. https://buildkite.com/clima/oceananigans/builds/17516#01920c32-4e89-4654-a4a8-9b077e51e87c/39-221. The puzzling part is how to solve the problem. I thought at first we could solve it by preventing the Manifest from being ""re-resolved"" --- perhaps by resolving it correctly during initialization? But actually, this isn't possible, since the problematic manifest in question is a temporary run that is created only for the tests (and its different from the project's manifest, because it also includes the test dependencies). This temporary test manifest can't be initialized as far as I can tell and is created independently for each test. Finally, it seems that some race conditions happen in a print statement (this is just from reading the error message). It all boils down eventually to these two lines:. https://github.com/JuliaLang/Pkg.jl/blob/5fbfa125045ce3e68ce10bf9fc1727bb3232c123/src/Operations.jl#L799-L800. The command its trying to run is. ```julia; ERROR: failed process: Process(`/net/ocean/home/data44/data5/glwagner/julia-1.10.5/bin/julia -C native -J/net/ocean/home/data44/data5/glwagner/julia-1.10.5/lib/julia/sys.so -O0 -g1 --color=yes -O0 --color=no --history-file=no --startup-file=no --project=/tmp/jl_f9Z8t1/Project.toml --eval 'append!(empty!(Base.DEPOT_PATH), [""/data5/glwagner/.julia-17516""]); --;   | append!(empty!(Base.DL_LOAD_PATH), String[]). cd(""/data5/glwagner/.julia-17516/packages/CUDA_Runtime_jll/YgJCI/.pkg""); --;   | include(""/data5/glwagner/.julia-17516/packages/CUDA_Runtime_jll/YgJCI/.pkg/select_artifacts.jl"");   | ' -t1 --startup-file=no x86_64-linux-gnu-libgfortran5-cxx11-julia_version+1.10.5`, ProcessSignaled(11)) [0]; ```. and supposedly the issue arises within the `select_artifacts.jl` call in `CUD",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3783#issuecomment-2362378199
Testability,test,test,"Well, it looks like this PR does not completely solve the problem, and the jury is out perhaps on whether it helps or not. I did learn a few things. It seems the race condition originates from an attempt to ""re-resolve"" the manifest during the test:. https://buildkite.com/clima/oceananigans/builds/17516#01920c32-4e89-4654-a4a8-9b077e51e87c/39-221. The puzzling part is how to solve the problem. I thought at first we could solve it by preventing the Manifest from being ""re-resolved"" --- perhaps by resolving it correctly during initialization? But actually, this isn't possible, since the problematic manifest in question is a temporary run that is created only for the tests (and its different from the project's manifest, because it also includes the test dependencies). This temporary test manifest can't be initialized as far as I can tell and is created independently for each test. Finally, it seems that some race conditions happen in a print statement (this is just from reading the error message). It all boils down eventually to these two lines:. https://github.com/JuliaLang/Pkg.jl/blob/5fbfa125045ce3e68ce10bf9fc1727bb3232c123/src/Operations.jl#L799-L800. The command its trying to run is. ```julia; ERROR: failed process: Process(`/net/ocean/home/data44/data5/glwagner/julia-1.10.5/bin/julia -C native -J/net/ocean/home/data44/data5/glwagner/julia-1.10.5/lib/julia/sys.so -O0 -g1 --color=yes -O0 --color=no --history-file=no --startup-file=no --project=/tmp/jl_f9Z8t1/Project.toml --eval 'append!(empty!(Base.DEPOT_PATH), [""/data5/glwagner/.julia-17516""]); --;   | append!(empty!(Base.DL_LOAD_PATH), String[]). cd(""/data5/glwagner/.julia-17516/packages/CUDA_Runtime_jll/YgJCI/.pkg""); --;   | include(""/data5/glwagner/.julia-17516/packages/CUDA_Runtime_jll/YgJCI/.pkg/select_artifacts.jl"");   | ' -t1 --startup-file=no x86_64-linux-gnu-libgfortran5-cxx11-julia_version+1.10.5`, ProcessSignaled(11)) [0]; ```. and supposedly the issue arises within the `select_artifacts.jl` call in `CUD",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3783#issuecomment-2362378199
Usability,learn,learn,"Well, it looks like this PR does not completely solve the problem, and the jury is out perhaps on whether it helps or not. I did learn a few things. It seems the race condition originates from an attempt to ""re-resolve"" the manifest during the test:. https://buildkite.com/clima/oceananigans/builds/17516#01920c32-4e89-4654-a4a8-9b077e51e87c/39-221. The puzzling part is how to solve the problem. I thought at first we could solve it by preventing the Manifest from being ""re-resolved"" --- perhaps by resolving it correctly during initialization? But actually, this isn't possible, since the problematic manifest in question is a temporary run that is created only for the tests (and its different from the project's manifest, because it also includes the test dependencies). This temporary test manifest can't be initialized as far as I can tell and is created independently for each test. Finally, it seems that some race conditions happen in a print statement (this is just from reading the error message). It all boils down eventually to these two lines:. https://github.com/JuliaLang/Pkg.jl/blob/5fbfa125045ce3e68ce10bf9fc1727bb3232c123/src/Operations.jl#L799-L800. The command its trying to run is. ```julia; ERROR: failed process: Process(`/net/ocean/home/data44/data5/glwagner/julia-1.10.5/bin/julia -C native -J/net/ocean/home/data44/data5/glwagner/julia-1.10.5/lib/julia/sys.so -O0 -g1 --color=yes -O0 --color=no --history-file=no --startup-file=no --project=/tmp/jl_f9Z8t1/Project.toml --eval 'append!(empty!(Base.DEPOT_PATH), [""/data5/glwagner/.julia-17516""]); --;   | append!(empty!(Base.DL_LOAD_PATH), String[]). cd(""/data5/glwagner/.julia-17516/packages/CUDA_Runtime_jll/YgJCI/.pkg""); --;   | include(""/data5/glwagner/.julia-17516/packages/CUDA_Runtime_jll/YgJCI/.pkg/select_artifacts.jl"");   | ' -t1 --startup-file=no x86_64-linux-gnu-libgfortran5-cxx11-julia_version+1.10.5`, ProcessSignaled(11)) [0]; ```. and supposedly the issue arises within the `select_artifacts.jl` call in `CUD",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3783#issuecomment-2362378199
Energy Efficiency,schedul,schedule,"ally subsequent calls to `add_output_writers!` with `JLD2Format()` and `NetCDFFormat()` would add both.; 3. Would definitely support extending this to NetCDF as well!. > First, we need to default `with_halos=true` for JLD2OutputWriter. The time has come because `FieldTimeSeries` is mature. We do, in fact, want halos. Sounds good! Will be nice for derivatives to work by default. Although `FieldTimeSeries` could do with a bit more maturing, e.g. issues #3144 and #3750. > The other conundrum is `overwrite_existing` which is discussed on #3543. In short I am wondering whether the best course of action is simply to make default `overwrite_existing=true` and solve so much boilerplate. Is the ""so much boilerplate"" just the extra one line `overwrite_existing = true` for each output writer? Maybe I'm too conservative here but I think the default should be `overwrite_existing = false` just because the cost of overwriting and losing data can be very high. But I really like the suggestions in #3543 of having the option to save output in unique directories be easily specifiable. If we want an easy default, then maybe it could do some version of the unique directories? Or maybe have `overwrite_existing = false` (the default) just rename existing files?. I'm not sure of the best approach but as someone who's conservative about overwriting by default I'm tempted to err on the side of caution. > Another abstraction I think would be useful is a utility for building multiple outputs. Imagine this:; > ; > ```julia; > indices = (xy=(:, :, k), xz=(:, 1, :), yz=(1, :, :)); > sliced_outputs!(simulation, outputs, indices; schedule=TimeInterval(1), filename=""sliced""); > ```; > ; > this would append `filename` with the keys of `indices`, eg we would get 3 outputs titled `""sliced_xy""`, `""sliced_xz""`, and `""sliced_yz""`. Love this idea! Hoping that you can also pass e.g. `(surface=(:, :, k), zonal=(:, 1, :), meridional=(1, :, :))` to get `sliced_surface`, `sliced_zonal`, and `sliced_meridional`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3793#issuecomment-2375865875
Modifiability,flexible,flexible,"> I'd love to hear feedback about this design.; ; Maybe I'm personally quite picky about specifying outputs and output file names, so I might always end up with verbose boilerplate for output writing (and I'm personally fine with that). But I'd support reducing boilerplate and maybe just a bit of flexibility would work even for picky people! I remember having this conversation in #1171 actually!. One-line flexible output writing would be especially great for examples, new user friendliness, and quick iteration. Some thoughts:; 1. I think the name `output!` is a bit vague in what it does. Does it just output the current state of the simulation? Would `add_output_writers!` be clearer and align more closely with existing Oceananigans nomenclature? For the same reason, I'd suggest keeping `add_callback!` over renaming to `callback!`.; 2. I frequently output both JLD2 and NetCDF versions of the exact same data. So ideally subsequent calls to `add_output_writers!` with `JLD2Format()` and `NetCDFFormat()` would add both.; 3. Would definitely support extending this to NetCDF as well!. > First, we need to default `with_halos=true` for JLD2OutputWriter. The time has come because `FieldTimeSeries` is mature. We do, in fact, want halos. Sounds good! Will be nice for derivatives to work by default. Although `FieldTimeSeries` could do with a bit more maturing, e.g. issues #3144 and #3750. > The other conundrum is `overwrite_existing` which is discussed on #3543. In short I am wondering whether the best course of action is simply to make default `overwrite_existing=true` and solve so much boilerplate. Is the ""so much boilerplate"" just the extra one line `overwrite_existing = true` for each output writer? Maybe I'm too conservative here but I think the default should be `overwrite_existing = false` just because the cost of overwriting and losing data can be very high. But I really like the suggestions in #3543 of having the option to save output in unique directories be easily speci",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3793#issuecomment-2375865875
Usability,feedback,feedback,"> I'd love to hear feedback about this design.; ; Maybe I'm personally quite picky about specifying outputs and output file names, so I might always end up with verbose boilerplate for output writing (and I'm personally fine with that). But I'd support reducing boilerplate and maybe just a bit of flexibility would work even for picky people! I remember having this conversation in #1171 actually!. One-line flexible output writing would be especially great for examples, new user friendliness, and quick iteration. Some thoughts:; 1. I think the name `output!` is a bit vague in what it does. Does it just output the current state of the simulation? Would `add_output_writers!` be clearer and align more closely with existing Oceananigans nomenclature? For the same reason, I'd suggest keeping `add_callback!` over renaming to `callback!`.; 2. I frequently output both JLD2 and NetCDF versions of the exact same data. So ideally subsequent calls to `add_output_writers!` with `JLD2Format()` and `NetCDFFormat()` would add both.; 3. Would definitely support extending this to NetCDF as well!. > First, we need to default `with_halos=true` for JLD2OutputWriter. The time has come because `FieldTimeSeries` is mature. We do, in fact, want halos. Sounds good! Will be nice for derivatives to work by default. Although `FieldTimeSeries` could do with a bit more maturing, e.g. issues #3144 and #3750. > The other conundrum is `overwrite_existing` which is discussed on #3543. In short I am wondering whether the best course of action is simply to make default `overwrite_existing=true` and solve so much boilerplate. Is the ""so much boilerplate"" just the extra one line `overwrite_existing = true` for each output writer? Maybe I'm too conservative here but I think the default should be `overwrite_existing = false` just because the cost of overwriting and losing data can be very high. But I really like the suggestions in #3543 of having the option to save output in unique directories be easily speci",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3793#issuecomment-2375865875
Energy Efficiency,schedul,schedule,"t always end up with verbose boilerplate for output writing. Totally and to be clear, when we think about the economy of an interface, we are thinking about prototyping, illustrating, testing, not necessarily ""production"". I think ""production"" places fewer demands on the user interface and what we have now is ok for production. This PR mainly improves the small stuff. Also arguably it's more helpful for experienced than new users. > I think the name output! is a bit vague in what it does. Does it just output the current state of the simulation? Would add_output_writers! be clearer and align more closely with existing Oceananigans nomenclature? For the same reason, I'd suggest keeping add_callback! over renaming to callback!. I agree that with ""add"" and ""writer"" the meaning is cemented. I think it's important to recognize trade-offs though, because there is a limit to the benefit of being explicit (when things become hard to read or understand). I think in this case I accept that `output_writer!` is probably better than `ouput!`. I think prepending `add_` has a more marginal benefit (and is a little ugly) and that context is really what drives understanding of `callback!` / `add_callback!` (eg a schedule, etc). But this is certainly open for discussion. > Love this idea! Hoping that you can also pass e.g. (surface=(:, :, k), zonal=(:, 1, :), meridional=(1, :, :)) to get sliced_surface, sliced_zonal, and sliced_meridional. Yes for sure! In that example the keys ""xy"", ""xz"", etc would be names appended to the filename prefix. . > I think the default should be overwrite_existing = false just because the cost of overwriting and losing data can be very high. Do you run with this option? Curious because I never use it. I think the cost of losing data is actually usually very small, it's only in a small 1% of cases that the data is valuable. I think that's actually the key insight behind the default, that expensive simulations are rare so it doesn't make sense to default it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3793#issuecomment-2376911364
Integrability,interface,interface,"> Maybe I'm personally quite picky about specifying outputs and output file names, so I might always end up with verbose boilerplate for output writing. Totally and to be clear, when we think about the economy of an interface, we are thinking about prototyping, illustrating, testing, not necessarily ""production"". I think ""production"" places fewer demands on the user interface and what we have now is ok for production. This PR mainly improves the small stuff. Also arguably it's more helpful for experienced than new users. > I think the name output! is a bit vague in what it does. Does it just output the current state of the simulation? Would add_output_writers! be clearer and align more closely with existing Oceananigans nomenclature? For the same reason, I'd suggest keeping add_callback! over renaming to callback!. I agree that with ""add"" and ""writer"" the meaning is cemented. I think it's important to recognize trade-offs though, because there is a limit to the benefit of being explicit (when things become hard to read or understand). I think in this case I accept that `output_writer!` is probably better than `ouput!`. I think prepending `add_` has a more marginal benefit (and is a little ugly) and that context is really what drives understanding of `callback!` / `add_callback!` (eg a schedule, etc). But this is certainly open for discussion. > Love this idea! Hoping that you can also pass e.g. (surface=(:, :, k), zonal=(:, 1, :), meridional=(1, :, :)) to get sliced_surface, sliced_zonal, and sliced_meridional. Yes for sure! In that example the keys ""xy"", ""xz"", etc would be names appended to the filename prefix. . > I think the default should be overwrite_existing = false just because the cost of overwriting and losing data can be very high. Do you run with this option? Curious because I never use it. I think the cost of losing data is actually usually very small, it's only in a small 1% of cases that the data is valuable. I think that's actually the key insight behi",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3793#issuecomment-2376911364
Testability,test,testing,"> Maybe I'm personally quite picky about specifying outputs and output file names, so I might always end up with verbose boilerplate for output writing. Totally and to be clear, when we think about the economy of an interface, we are thinking about prototyping, illustrating, testing, not necessarily ""production"". I think ""production"" places fewer demands on the user interface and what we have now is ok for production. This PR mainly improves the small stuff. Also arguably it's more helpful for experienced than new users. > I think the name output! is a bit vague in what it does. Does it just output the current state of the simulation? Would add_output_writers! be clearer and align more closely with existing Oceananigans nomenclature? For the same reason, I'd suggest keeping add_callback! over renaming to callback!. I agree that with ""add"" and ""writer"" the meaning is cemented. I think it's important to recognize trade-offs though, because there is a limit to the benefit of being explicit (when things become hard to read or understand). I think in this case I accept that `output_writer!` is probably better than `ouput!`. I think prepending `add_` has a more marginal benefit (and is a little ugly) and that context is really what drives understanding of `callback!` / `add_callback!` (eg a schedule, etc). But this is certainly open for discussion. > Love this idea! Hoping that you can also pass e.g. (surface=(:, :, k), zonal=(:, 1, :), meridional=(1, :, :)) to get sliced_surface, sliced_zonal, and sliced_meridional. Yes for sure! In that example the keys ""xy"", ""xz"", etc would be names appended to the filename prefix. . > I think the default should be overwrite_existing = false just because the cost of overwriting and losing data can be very high. Do you run with this option? Curious because I never use it. I think the cost of losing data is actually usually very small, it's only in a small 1% of cases that the data is valuable. I think that's actually the key insight behi",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3793#issuecomment-2376911364
Usability,clear,clear,"> Maybe I'm personally quite picky about specifying outputs and output file names, so I might always end up with verbose boilerplate for output writing. Totally and to be clear, when we think about the economy of an interface, we are thinking about prototyping, illustrating, testing, not necessarily ""production"". I think ""production"" places fewer demands on the user interface and what we have now is ok for production. This PR mainly improves the small stuff. Also arguably it's more helpful for experienced than new users. > I think the name output! is a bit vague in what it does. Does it just output the current state of the simulation? Would add_output_writers! be clearer and align more closely with existing Oceananigans nomenclature? For the same reason, I'd suggest keeping add_callback! over renaming to callback!. I agree that with ""add"" and ""writer"" the meaning is cemented. I think it's important to recognize trade-offs though, because there is a limit to the benefit of being explicit (when things become hard to read or understand). I think in this case I accept that `output_writer!` is probably better than `ouput!`. I think prepending `add_` has a more marginal benefit (and is a little ugly) and that context is really what drives understanding of `callback!` / `add_callback!` (eg a schedule, etc). But this is certainly open for discussion. > Love this idea! Hoping that you can also pass e.g. (surface=(:, :, k), zonal=(:, 1, :), meridional=(1, :, :)) to get sliced_surface, sliced_zonal, and sliced_meridional. Yes for sure! In that example the keys ""xy"", ""xz"", etc would be names appended to the filename prefix. . > I think the default should be overwrite_existing = false just because the cost of overwriting and losing data can be very high. Do you run with this option? Curious because I never use it. I think the cost of losing data is actually usually very small, it's only in a small 1% of cases that the data is valuable. I think that's actually the key insight behi",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3793#issuecomment-2376911364
Usability,feedback,feedback,@navidcy any thoughts?. I think the main feedback is to keep `add_callback!` and use `add_output_writer!` instead. I think it's not very pretty but I am ok with it. It's utilitarian 🤖 .,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3793#issuecomment-2385598115
Usability,intuit,intuitive,"> I'm starting to feel that it's better with ""add""... following the precept that functions are verbs and objects are nouns. I find `add_output!(simulation)` to be more intuitive in terms of creating the output and `output!(simulation)` actually outputs. (Thus, in the latter ""output"" is the verb, not the noun.)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3793#issuecomment-2414843995
Energy Efficiency,schedul,schedule,"Apart from `overwrite_existing` default, it seems like we have consensus that we should use `add_output_writer!` for this PR. I'll make that change and switch over the examples as well. I'll open an issue to discuss the `outputinfo` utility. I also think that an `output!` function would be useful, which simply writes the current state. Recently I have been found myself wanting only the final state of the simulation. It's a little convoluted to have to set up an output writer with a schedule for that task, it'd be easier to write. ```julia; run!(simulation); output!(""cool_stuff.jld2"", simulation); ```. in the above, the filename goes first because that's the thing being ""modified"" (similar to how `save` works)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3793#issuecomment-2433135341
Usability,simpl,simply,"Apart from `overwrite_existing` default, it seems like we have consensus that we should use `add_output_writer!` for this PR. I'll make that change and switch over the examples as well. I'll open an issue to discuss the `outputinfo` utility. I also think that an `output!` function would be useful, which simply writes the current state. Recently I have been found myself wanting only the final state of the simulation. It's a little convoluted to have to set up an output writer with a schedule for that task, it'd be easier to write. ```julia; run!(simulation); output!(""cool_stuff.jld2"", simulation); ```. in the above, the filename goes first because that's the thing being ""modified"" (similar to how `save` works)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3793#issuecomment-2433135341
Availability,error,error,"As a user, I prefer an internal ""settings"" dictionary over an environment variable. Actually, I think it would be better to define a function `Oceananigans.set_default_number_type(FT)` for users to access the ""setting"" dictionary. One reason is that an error will be thrown when the user makes a typo. Another option is to pass `FT=Float32` to the model and then let the constructor convert related components to `Float32` \(or `Float64` if `FT=Float64` is passed\). I feel it might be the most user-friendly interface. But obviously it will lots of efforts to implement.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3800#issuecomment-2389733644
Integrability,interface,interface,"As a user, I prefer an internal ""settings"" dictionary over an environment variable. Actually, I think it would be better to define a function `Oceananigans.set_default_number_type(FT)` for users to access the ""setting"" dictionary. One reason is that an error will be thrown when the user makes a typo. Another option is to pass `FT=Float32` to the model and then let the constructor convert related components to `Float32` \(or `Float64` if `FT=Float64` is passed\). I feel it might be the most user-friendly interface. But obviously it will lots of efforts to implement.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3800#issuecomment-2389733644
Modifiability,variab,variable,"As a user, I prefer an internal ""settings"" dictionary over an environment variable. Actually, I think it would be better to define a function `Oceananigans.set_default_number_type(FT)` for users to access the ""setting"" dictionary. One reason is that an error will be thrown when the user makes a typo. Another option is to pass `FT=Float32` to the model and then let the constructor convert related components to `Float32` \(or `Float64` if `FT=Float64` is passed\). I feel it might be the most user-friendly interface. But obviously it will lots of efforts to implement.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3800#issuecomment-2389733644
Security,access,access,"As a user, I prefer an internal ""settings"" dictionary over an environment variable. Actually, I think it would be better to define a function `Oceananigans.set_default_number_type(FT)` for users to access the ""setting"" dictionary. One reason is that an error will be thrown when the user makes a typo. Another option is to pass `FT=Float32` to the model and then let the constructor convert related components to `Float32` \(or `Float64` if `FT=Float64` is passed\). I feel it might be the most user-friendly interface. But obviously it will lots of efforts to implement.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3800#issuecomment-2389733644
Usability,user-friendly,user-friendly,"As a user, I prefer an internal ""settings"" dictionary over an environment variable. Actually, I think it would be better to define a function `Oceananigans.set_default_number_type(FT)` for users to access the ""setting"" dictionary. One reason is that an error will be thrown when the user makes a typo. Another option is to pass `FT=Float32` to the model and then let the constructor convert related components to `Float32` \(or `Float64` if `FT=Float64` is passed\). I feel it might be the most user-friendly interface. But obviously it will lots of efforts to implement.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3800#issuecomment-2389733644
Availability,error,error,"> Another option is to pass FT=Float32 to the model and then let the constructor convert related components to Float32 (or Float64 if FT=Float64 is passed). I feel it might be the most user-friendly interface. But obviously it will lots of efforts to implement. This could work but I'm wary of converting in general. When we convert, then identity is lost between whatever the `component` in the user script and `model.component`. This is an especially major problem for `grid`. But even if we implement this feature via the grid, there would be many other types like `FPlane(f=1)` for example which have the incorrect type. We can tell users that this is possible so they always need to use `model.coriolis`. But broadly I think this kind of design is a bit brittle; too easy for things to go wrong. > Actually, I think it would be better to define a function Oceananigans.set_default_number_type(FT) for users to access the ""setting"" dictionary. One reason is that an error will be thrown when the user makes a typo. I think that's a nice idea. It's also maybe more sensible syntax right now since there is only one default.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3800#issuecomment-2389771263
Integrability,interface,interface,"> Another option is to pass FT=Float32 to the model and then let the constructor convert related components to Float32 (or Float64 if FT=Float64 is passed). I feel it might be the most user-friendly interface. But obviously it will lots of efforts to implement. This could work but I'm wary of converting in general. When we convert, then identity is lost between whatever the `component` in the user script and `model.component`. This is an especially major problem for `grid`. But even if we implement this feature via the grid, there would be many other types like `FPlane(f=1)` for example which have the incorrect type. We can tell users that this is possible so they always need to use `model.coriolis`. But broadly I think this kind of design is a bit brittle; too easy for things to go wrong. > Actually, I think it would be better to define a function Oceananigans.set_default_number_type(FT) for users to access the ""setting"" dictionary. One reason is that an error will be thrown when the user makes a typo. I think that's a nice idea. It's also maybe more sensible syntax right now since there is only one default.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3800#issuecomment-2389771263
Security,access,access,"> Another option is to pass FT=Float32 to the model and then let the constructor convert related components to Float32 (or Float64 if FT=Float64 is passed). I feel it might be the most user-friendly interface. But obviously it will lots of efforts to implement. This could work but I'm wary of converting in general. When we convert, then identity is lost between whatever the `component` in the user script and `model.component`. This is an especially major problem for `grid`. But even if we implement this feature via the grid, there would be many other types like `FPlane(f=1)` for example which have the incorrect type. We can tell users that this is possible so they always need to use `model.coriolis`. But broadly I think this kind of design is a bit brittle; too easy for things to go wrong. > Actually, I think it would be better to define a function Oceananigans.set_default_number_type(FT) for users to access the ""setting"" dictionary. One reason is that an error will be thrown when the user makes a typo. I think that's a nice idea. It's also maybe more sensible syntax right now since there is only one default.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3800#issuecomment-2389771263
Usability,user-friendly,user-friendly,"> Another option is to pass FT=Float32 to the model and then let the constructor convert related components to Float32 (or Float64 if FT=Float64 is passed). I feel it might be the most user-friendly interface. But obviously it will lots of efforts to implement. This could work but I'm wary of converting in general. When we convert, then identity is lost between whatever the `component` in the user script and `model.component`. This is an especially major problem for `grid`. But even if we implement this feature via the grid, there would be many other types like `FPlane(f=1)` for example which have the incorrect type. We can tell users that this is possible so they always need to use `model.coriolis`. But broadly I think this kind of design is a bit brittle; too easy for things to go wrong. > Actually, I think it would be better to define a function Oceananigans.set_default_number_type(FT) for users to access the ""setting"" dictionary. One reason is that an error will be thrown when the user makes a typo. I think that's a nice idea. It's also maybe more sensible syntax right now since there is only one default.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3800#issuecomment-2389771263
Energy Efficiency,power,power,"> Glad you brought this up! Definitely a use case for an expert/power user but I can think of a few use cases (e.g. nested simulations) that would be good to support. It's also crucial for the semantics of `set_default_number_type!` versus simply ""set_number_type!"", ie we want to preserve independent settability for all parameters. We've been intentionally disciplined / conservative about ""no global settings"", so this would represent an adventure away from that philosophy. It seems well-motivated in this case. The only other parameter that can possibly appear more than once in Oceananigans (as far as I know) is gravitational acceleration (free surface and buoyancy). Good points about environment variables and portability.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3800#issuecomment-2397234167
Modifiability,variab,variables,"> Glad you brought this up! Definitely a use case for an expert/power user but I can think of a few use cases (e.g. nested simulations) that would be good to support. It's also crucial for the semantics of `set_default_number_type!` versus simply ""set_number_type!"", ie we want to preserve independent settability for all parameters. We've been intentionally disciplined / conservative about ""no global settings"", so this would represent an adventure away from that philosophy. It seems well-motivated in this case. The only other parameter that can possibly appear more than once in Oceananigans (as far as I know) is gravitational acceleration (free surface and buoyancy). Good points about environment variables and portability.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3800#issuecomment-2397234167
Usability,simpl,simply,"> Glad you brought this up! Definitely a use case for an expert/power user but I can think of a few use cases (e.g. nested simulations) that would be good to support. It's also crucial for the semantics of `set_default_number_type!` versus simply ""set_number_type!"", ie we want to preserve independent settability for all parameters. We've been intentionally disciplined / conservative about ""no global settings"", so this would represent an adventure away from that philosophy. It seems well-motivated in this case. The only other parameter that can possibly appear more than once in Oceananigans (as far as I know) is gravitational acceleration (free surface and buoyancy). Good points about environment variables and portability.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3800#issuecomment-2397234167
Deployability,continuous,continuous,"volume of the domain, $N = N_x N_y N_z$ is the total number of elements in the 3D discretization of $\phi$, and $\bar \phi$ denotes the mean over the volume. In other words, the product $e^T \phi$ is proportional to the volume-mean of $\phi$. We write the Poisson equation. $$ \nabla^2 \phi = R $$. where $R$ is some right hand side. As we well understand, $\bar \phi$ is undetermined from this equation. Physically, pressure in an incompressible system is indeterminant up to a constant; only the pressure gradient enters the equations of motion. We thus require an additional condition to close the system which determines $\bar \phi$, and usually we pick $\bar \phi = 0$. This constraint is implemented in this PR. Another way to close the system is to change the Poisson equation. Written discretely the proposal is to use. $$ \big ( \underbrace{A + \delta e e^T}_{\equiv \tilde A} \big ) \phi = R $$. where $\delta$ is a constant. I was a bit confused about this form until I understood that $e^T \phi = N \bar \phi$, so that in continuous from this would read. $$ \Bigg ( \underbrace{\nabla^2 + \frac{\delta N}{V} \int \mathrm{d} V}_{\tilde L} \Bigg ) \phi = \nabla^2 \phi + \delta N \bar \phi = R $$. where $\tilde L$ is the ""regularized Laplacian operator"". $\tilde L$ is regularized because taking the mean is well-defined:. $$ \overline{\tilde L \phi} = \delta N \bar \phi = \bar R $$. unlike the unregularized Poisson equation when $\bar R \ne 0$. In terms of implementation, this is simply implemented by defining a new linear operator that adds the additional term, eg. https://github.com/CliMA/Oceananigans.jl/blob/4f6ffd71933fc3dd55df8a6093fd52d420b06b1d/src/Solvers/conjugate_gradient_poisson_solver.jl#L47-L51. Here are a few more loose ends:. 1. I am wondering whether this perturbation or shifting of the Laplacian is independent of the preconditioner. For example, the FFT-based preconditioner _also_ applies a gauge condition:. https://github.com/CliMA/Oceananigans.jl/blob/efb8b7",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3802#issuecomment-2417152665
Usability,simpl,simply,"rs the equations of motion. We thus require an additional condition to close the system which determines $\bar \phi$, and usually we pick $\bar \phi = 0$. This constraint is implemented in this PR. Another way to close the system is to change the Poisson equation. Written discretely the proposal is to use. $$ \big ( \underbrace{A + \delta e e^T}_{\equiv \tilde A} \big ) \phi = R $$. where $\delta$ is a constant. I was a bit confused about this form until I understood that $e^T \phi = N \bar \phi$, so that in continuous from this would read. $$ \Bigg ( \underbrace{\nabla^2 + \frac{\delta N}{V} \int \mathrm{d} V}_{\tilde L} \Bigg ) \phi = \nabla^2 \phi + \delta N \bar \phi = R $$. where $\tilde L$ is the ""regularized Laplacian operator"". $\tilde L$ is regularized because taking the mean is well-defined:. $$ \overline{\tilde L \phi} = \delta N \bar \phi = \bar R $$. unlike the unregularized Poisson equation when $\bar R \ne 0$. In terms of implementation, this is simply implemented by defining a new linear operator that adds the additional term, eg. https://github.com/CliMA/Oceananigans.jl/blob/4f6ffd71933fc3dd55df8a6093fd52d420b06b1d/src/Solvers/conjugate_gradient_poisson_solver.jl#L47-L51. Here are a few more loose ends:. 1. I am wondering whether this perturbation or shifting of the Laplacian is independent of the preconditioner. For example, the FFT-based preconditioner _also_ applies a gauge condition:. https://github.com/CliMA/Oceananigans.jl/blob/efb8b712c7541ba377af10f04795e542092565f0/src/Solvers/fft_based_poisson_solver.jl#L109-L115. Therefore it is unclear to me whether additionally solving the regularized Poisson equation is necessary or valid when we already have a linear constraint embedded in the preconditioner. Also, note that the constrained implemented in this PR is simply a shifting of the constraint embedded in the FFT-based preconditioner. While the FFT preconditioner zeros out the mean pressure over the whole domain, the constraint in this PR take",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3802#issuecomment-2417152665
Energy Efficiency,efficient,efficient,"In my implementation \(https://github.com/Yixiao-Zhang/Oceananigans.jl/commit/c7983b8002b91cd5939018a7c999eae77e2105ac\), the preconditioner is also perturbed. The goal is to solve the following equation in an immersed boundary grid. $$\nabla^2 \phi + \delta N \bar \phi = R $$. The perturbed preconditioner solves this equation in a regular grid:. $$ \phi = L_\mathrm{FFT}R + \frac{1}{\delta N}\overline{R}$$. where $L_\mathrm{FFT}$ is the FFT-based Poisson solver. Due to the gauge condition of $L_\mathrm{FFT}$,. $$\nabla^2L_\mathrm{FFT}R = R - \overline{R}$$. $$\overline{L_\mathrm{FFT}R} = 0$$. for a random $R$ whose mean is not necessarily zero. The latter is simply the gauge condition; the former means that $L_\mathrm{FFT}$ ignores the mean component of $R$ \(which can be understood as $\frac{1}{N}ee^TR$\). It is easy to verify that the preconditioner gives the exact solution in a regular grid. Besides, in my implementation \(https://github.com/Yixiao-Zhang/Oceananigans.jl/commit/c7983b8002b91cd5939018a7c999eae77e2105ac\), I perturb the preconditioner directly by adding the mean of the input vector. However, a more efficient solution is to a new parameter to the FFT-based Poisson solver, so that it solves. $$\nabla^2 \phi + m \phi - \mu \overline{\phi} = r $$. where $\mu$ represents the role of $\delta$ or $c$ in previous comments.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3802#issuecomment-2417544874
Usability,simpl,simply,"In my implementation \(https://github.com/Yixiao-Zhang/Oceananigans.jl/commit/c7983b8002b91cd5939018a7c999eae77e2105ac\), the preconditioner is also perturbed. The goal is to solve the following equation in an immersed boundary grid. $$\nabla^2 \phi + \delta N \bar \phi = R $$. The perturbed preconditioner solves this equation in a regular grid:. $$ \phi = L_\mathrm{FFT}R + \frac{1}{\delta N}\overline{R}$$. where $L_\mathrm{FFT}$ is the FFT-based Poisson solver. Due to the gauge condition of $L_\mathrm{FFT}$,. $$\nabla^2L_\mathrm{FFT}R = R - \overline{R}$$. $$\overline{L_\mathrm{FFT}R} = 0$$. for a random $R$ whose mean is not necessarily zero. The latter is simply the gauge condition; the former means that $L_\mathrm{FFT}$ ignores the mean component of $R$ \(which can be understood as $\frac{1}{N}ee^TR$\). It is easy to verify that the preconditioner gives the exact solution in a regular grid. Besides, in my implementation \(https://github.com/Yixiao-Zhang/Oceananigans.jl/commit/c7983b8002b91cd5939018a7c999eae77e2105ac\), I perturb the preconditioner directly by adding the mean of the input vector. However, a more efficient solution is to a new parameter to the FFT-based Poisson solver, so that it solves. $$\nabla^2 \phi + m \phi - \mu \overline{\phi} = r $$. where $\mu$ represents the role of $\delta$ or $c$ in previous comments.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3802#issuecomment-2417544874
Energy Efficiency,efficient,efficient,"> However, a more efficient solution is to a new parameter to the FFT-based Poisson solver. Isn't this simply setting $\bar \phi = \bar r / \mu$ in the FFT solver, rather than $\bar \phi = 0$ as we do currently? Why does this help? (I'm not implying that it doesn't help, I just don't understand why trading one constraint for another is advantageous). Also given the ease of implementing such a change, did you test it?. Also if we set $\bar r = 0$ after computing the RHS here:. https://github.com/CliMA/Oceananigans.jl/blob/efb8b712c7541ba377af10f04795e542092565f0/src/Models/NonhydrostaticModels/solve_for_pressure.jl#L88-L89. then I suppose we would have $\bar \phi = \bar r / \mu = 0$ (I tested this briefly though and it didn't seem to improve the problems observed on #3831 / #3848, but we could keep trying).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3802#issuecomment-2418066050
Testability,test,test,"> However, a more efficient solution is to a new parameter to the FFT-based Poisson solver. Isn't this simply setting $\bar \phi = \bar r / \mu$ in the FFT solver, rather than $\bar \phi = 0$ as we do currently? Why does this help? (I'm not implying that it doesn't help, I just don't understand why trading one constraint for another is advantageous). Also given the ease of implementing such a change, did you test it?. Also if we set $\bar r = 0$ after computing the RHS here:. https://github.com/CliMA/Oceananigans.jl/blob/efb8b712c7541ba377af10f04795e542092565f0/src/Models/NonhydrostaticModels/solve_for_pressure.jl#L88-L89. then I suppose we would have $\bar \phi = \bar r / \mu = 0$ (I tested this briefly though and it didn't seem to improve the problems observed on #3831 / #3848, but we could keep trying).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3802#issuecomment-2418066050
Usability,simpl,simply,"> However, a more efficient solution is to a new parameter to the FFT-based Poisson solver. Isn't this simply setting $\bar \phi = \bar r / \mu$ in the FFT solver, rather than $\bar \phi = 0$ as we do currently? Why does this help? (I'm not implying that it doesn't help, I just don't understand why trading one constraint for another is advantageous). Also given the ease of implementing such a change, did you test it?. Also if we set $\bar r = 0$ after computing the RHS here:. https://github.com/CliMA/Oceananigans.jl/blob/efb8b712c7541ba377af10f04795e542092565f0/src/Models/NonhydrostaticModels/solve_for_pressure.jl#L88-L89. then I suppose we would have $\bar \phi = \bar r / \mu = 0$ (I tested this briefly though and it didn't seem to improve the problems observed on #3831 / #3848, but we could keep trying).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3802#issuecomment-2418066050
Usability,simpl,simple,"We'll also write a simple script that solves a problem:. ```julia; using Oceananigans; using Krylov. # make a grid; # choose a preconditioner; solver = Oceananigans.Solvers.KrylovPoissonSolver(grid; preconditioner=cool_preconditioner). x = CenterField(grid); b = CenterField(grid); set!(b, rand(size(grid)...)); solve!(x, solver, b); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3803#issuecomment-2383598140
Usability,simpl,simply,"All Krylov solvers in `Krylov.jl` can take an operator as input, so if your operator-vector products can use multiple GPUs, it will already be faster.; We can develop a specific array type to limit communication and also use multiple GPUs on less expensive operations (norm, dot, axpy, ...), but simply using multiple GPUs for the most expensive part (operator-vector/operator-matrix products) will already lead to a significant speed-up. ref: https://github.com/JuliaSmoothOptimizers/Krylov.jl/issues/441",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3803#issuecomment-2386710918
Performance,bottleneck,bottleneck,"> This is super exciting! Out of curiosity is there any/which Krylov solver is compatible on multiple GPUs? Seems to be an important bottleneck for our current `PreconditionedConjugateGradientSolver` approach. Also to be clear about what this can do --- with Krylov, we can still use the FFT preconditioner. When we do that the parallelism issues are identical to the issues with our current CG solver, it's just that tweaking the solver method might allow us to do fewer iterations. So there are two things going on in this discussion which are independent. First is whether conjugate gradient is optimal or whether we should use a different method. The second issue is the preconditioner, which is the more uncertain part but where we might have more gains.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3803#issuecomment-2387264231
Usability,clear,clear,"> This is super exciting! Out of curiosity is there any/which Krylov solver is compatible on multiple GPUs? Seems to be an important bottleneck for our current `PreconditionedConjugateGradientSolver` approach. Also to be clear about what this can do --- with Krylov, we can still use the FFT preconditioner. When we do that the parallelism issues are identical to the issues with our current CG solver, it's just that tweaking the solver method might allow us to do fewer iterations. So there are two things going on in this discussion which are independent. First is whether conjugate gradient is optimal or whether we should use a different method. The second issue is the preconditioner, which is the more uncertain part but where we might have more gains.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3803#issuecomment-2387264231
Integrability,interface,interface,"Hmm yes. We can implement a custom constructor. Or we can capture the additional info needed for the ""constructor"" `S` in a closure. We can also add constructors to `Krylov` with a more generic interface based on `similar` or `deepcopy` with a ""template array"". We do this for our solvers to achieve some generality even within the concept of `Field` (Field requires not only the size, but also ""locations"" on the staggered grid). https://github.com/CliMA/Oceananigans.jl/blob/45838a57dd5ebc1153c2c827f83cb848d20e4c92/src/Solvers/conjugate_gradient_solver.jl#L87-L89. I think using a closure is simpler though.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3803#issuecomment-2388817436
Usability,simpl,simpler,"Hmm yes. We can implement a custom constructor. Or we can capture the additional info needed for the ""constructor"" `S` in a closure. We can also add constructors to `Krylov` with a more generic interface based on `similar` or `deepcopy` with a ""template array"". We do this for our solvers to achieve some generality even within the concept of `Field` (Field requires not only the size, but also ""locations"" on the staggered grid). https://github.com/CliMA/Oceananigans.jl/blob/45838a57dd5ebc1153c2c827f83cb848d20e4c92/src/Solvers/conjugate_gradient_solver.jl#L87-L89. I think using a closure is simpler though.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3803#issuecomment-2388817436
Testability,test,test,"I'm amazed though - do we not have a test for building HydrostaticFreeSurfaceModel in this simplest case? It seems we need quite a few more tests for the TripolarGrid. We need to test various combination of model inputs and make sure that all of the ones we intent to support are working (free surfaces, advection schemes, coriolis, closures, etc).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3806#issuecomment-2397268979
Usability,simpl,simplest,"I'm amazed though - do we not have a test for building HydrostaticFreeSurfaceModel in this simplest case? It seems we need quite a few more tests for the TripolarGrid. We need to test various combination of model inputs and make sure that all of the ones we intent to support are working (free surfaces, advection schemes, coriolis, closures, etc).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3806#issuecomment-2397268979
Testability,test,tested,"This sounds really useful! . I kept reusing some code for wall (just with a flat-bottomed domain) and wind stress so I put some bits together in [this package](https://github.com/jagoosw/Walrus.jl) and I came to the same conclusion of having functions that make the boundary conditions so I could just write:. ```julia; stress_boundary_conditions = WallStressBoundaryConditions(). boundary_conditions = (u = FieldBoundaryConditions(bottom = stress_boundary_conditions.u),; v = FieldBoundaryConditions(bottom = stress_boundary_conditions.v)); ```. The way I did it was to make a type for `WindStress` which could have different models for the drag coefficient and parameters. The only other thing I learned from doing it was that it was very useful to precompute roughness lengths for different speeds rather than compute them on the fly since they're well behaved functions that I could interpolate easily. (There is some inefficiency in the code that I did the wind and wall stress separately, even though they're basically the same thing, but a kind of merge of how I did each would probably be the most general way todo it because I put more work into the wind stress and just have the very simple flat bottomed law of the wall wall stress. Also, the code is not well-tested and probably won't work on non-rectilinear grids).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3807#issuecomment-2385865288
Usability,learn,learned,"This sounds really useful! . I kept reusing some code for wall (just with a flat-bottomed domain) and wind stress so I put some bits together in [this package](https://github.com/jagoosw/Walrus.jl) and I came to the same conclusion of having functions that make the boundary conditions so I could just write:. ```julia; stress_boundary_conditions = WallStressBoundaryConditions(). boundary_conditions = (u = FieldBoundaryConditions(bottom = stress_boundary_conditions.u),; v = FieldBoundaryConditions(bottom = stress_boundary_conditions.v)); ```. The way I did it was to make a type for `WindStress` which could have different models for the drag coefficient and parameters. The only other thing I learned from doing it was that it was very useful to precompute roughness lengths for different speeds rather than compute them on the fly since they're well behaved functions that I could interpolate easily. (There is some inefficiency in the code that I did the wind and wall stress separately, even though they're basically the same thing, but a kind of merge of how I did each would probably be the most general way todo it because I put more work into the wind stress and just have the very simple flat bottomed law of the wall wall stress. Also, the code is not well-tested and probably won't work on non-rectilinear grids).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3807#issuecomment-2385865288
Integrability,interface,interface,"> (There is some inefficiency in the code that I did the wind and wall stress separately, even though they're basically the same thing, but a kind of merge of how I did each would probably be the most general way todo it because I put more work into the wind stress and just have the very simple flat bottomed law of the wall wall stress. Do you mean computational inefficiency, or inefficiency in terms of code length? For flat surfaces, we've designed an interface in ClimaOcean that depends on a roughness length callable object. This allows one to implement new models for the roughness length (which limit to wavy surface or smooth walls, combinations of the two, or other models). More generally our intent is definitely to encapsulate the parts that are not worth repeating elsewhere, and let users / external packages proliferate to do the interesting parts like designing new roughness lengths. Was that your vision too?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3807#issuecomment-2386534371
Usability,simpl,simple,"> (There is some inefficiency in the code that I did the wind and wall stress separately, even though they're basically the same thing, but a kind of merge of how I did each would probably be the most general way todo it because I put more work into the wind stress and just have the very simple flat bottomed law of the wall wall stress. Do you mean computational inefficiency, or inefficiency in terms of code length? For flat surfaces, we've designed an interface in ClimaOcean that depends on a roughness length callable object. This allows one to implement new models for the roughness length (which limit to wavy surface or smooth walls, combinations of the two, or other models). More generally our intent is definitely to encapsulate the parts that are not worth repeating elsewhere, and let users / external packages proliferate to do the interesting parts like designing new roughness lengths. Was that your vision too?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3807#issuecomment-2386534371
Availability,down,down,"That's right. Purely for simplicity we launch all the tendency kernels from 1:N, though for Face-fields in Bounded directions, we only require 2:N. In fact using tendencies only from 2:N could allow an optimization where we don't need to ""enforce"" no-penetration boundary conditions. It'd be hard to achieve this optimization though because users can write things like `parent(u) .= 1` so I'm not sure we can get away with this being guaranteed correct. This has never been a problem because we simply overwrite the boundary velocity and therefore simply discard the tendency at index 1. > The problem is if we try to integrate something like a radiation condition. Can you point me to where in the code this goes down?. > On bounded topology I don't think we ever want to integrate the tendency right? But it might be more complicated to do that. I think that's right that we don't need the tendency. This has been part of the algorithm since time immemorial and back in the mists of time it was indeed more complicated than worthwhile. The complication is that KernelAbstractions assumes indices start at 1... However, we now have a way of offsetting indices in kernels via our `KernelParameters`. So it's not very hard to do this anymore. I can give it a start. If we make this change, we also want to take a step back and look at all the kernels we are launching currently to make sure everything makes sense. For example, here is a question: while we don't want to integrate the velocity tendencies on boundaries, what do we do about diagnostics? Do we want to compute vorticity on the boundary, for example, if we are computing a vorticity diagnostic? It seems simpler if we don't, that way we don't have special cases...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3810#issuecomment-2388758985
Deployability,integrat,integrate,"That's right. Purely for simplicity we launch all the tendency kernels from 1:N, though for Face-fields in Bounded directions, we only require 2:N. In fact using tendencies only from 2:N could allow an optimization where we don't need to ""enforce"" no-penetration boundary conditions. It'd be hard to achieve this optimization though because users can write things like `parent(u) .= 1` so I'm not sure we can get away with this being guaranteed correct. This has never been a problem because we simply overwrite the boundary velocity and therefore simply discard the tendency at index 1. > The problem is if we try to integrate something like a radiation condition. Can you point me to where in the code this goes down?. > On bounded topology I don't think we ever want to integrate the tendency right? But it might be more complicated to do that. I think that's right that we don't need the tendency. This has been part of the algorithm since time immemorial and back in the mists of time it was indeed more complicated than worthwhile. The complication is that KernelAbstractions assumes indices start at 1... However, we now have a way of offsetting indices in kernels via our `KernelParameters`. So it's not very hard to do this anymore. I can give it a start. If we make this change, we also want to take a step back and look at all the kernels we are launching currently to make sure everything makes sense. For example, here is a question: while we don't want to integrate the velocity tendencies on boundaries, what do we do about diagnostics? Do we want to compute vorticity on the boundary, for example, if we are computing a vorticity diagnostic? It seems simpler if we don't, that way we don't have special cases...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3810#issuecomment-2388758985
Integrability,integrat,integrate,"That's right. Purely for simplicity we launch all the tendency kernels from 1:N, though for Face-fields in Bounded directions, we only require 2:N. In fact using tendencies only from 2:N could allow an optimization where we don't need to ""enforce"" no-penetration boundary conditions. It'd be hard to achieve this optimization though because users can write things like `parent(u) .= 1` so I'm not sure we can get away with this being guaranteed correct. This has never been a problem because we simply overwrite the boundary velocity and therefore simply discard the tendency at index 1. > The problem is if we try to integrate something like a radiation condition. Can you point me to where in the code this goes down?. > On bounded topology I don't think we ever want to integrate the tendency right? But it might be more complicated to do that. I think that's right that we don't need the tendency. This has been part of the algorithm since time immemorial and back in the mists of time it was indeed more complicated than worthwhile. The complication is that KernelAbstractions assumes indices start at 1... However, we now have a way of offsetting indices in kernels via our `KernelParameters`. So it's not very hard to do this anymore. I can give it a start. If we make this change, we also want to take a step back and look at all the kernels we are launching currently to make sure everything makes sense. For example, here is a question: while we don't want to integrate the velocity tendencies on boundaries, what do we do about diagnostics? Do we want to compute vorticity on the boundary, for example, if we are computing a vorticity diagnostic? It seems simpler if we don't, that way we don't have special cases...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3810#issuecomment-2388758985
Performance,optimiz,optimization,"That's right. Purely for simplicity we launch all the tendency kernels from 1:N, though for Face-fields in Bounded directions, we only require 2:N. In fact using tendencies only from 2:N could allow an optimization where we don't need to ""enforce"" no-penetration boundary conditions. It'd be hard to achieve this optimization though because users can write things like `parent(u) .= 1` so I'm not sure we can get away with this being guaranteed correct. This has never been a problem because we simply overwrite the boundary velocity and therefore simply discard the tendency at index 1. > The problem is if we try to integrate something like a radiation condition. Can you point me to where in the code this goes down?. > On bounded topology I don't think we ever want to integrate the tendency right? But it might be more complicated to do that. I think that's right that we don't need the tendency. This has been part of the algorithm since time immemorial and back in the mists of time it was indeed more complicated than worthwhile. The complication is that KernelAbstractions assumes indices start at 1... However, we now have a way of offsetting indices in kernels via our `KernelParameters`. So it's not very hard to do this anymore. I can give it a start. If we make this change, we also want to take a step back and look at all the kernels we are launching currently to make sure everything makes sense. For example, here is a question: while we don't want to integrate the velocity tendencies on boundaries, what do we do about diagnostics? Do we want to compute vorticity on the boundary, for example, if we are computing a vorticity diagnostic? It seems simpler if we don't, that way we don't have special cases...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3810#issuecomment-2388758985
Usability,simpl,simplicity,"That's right. Purely for simplicity we launch all the tendency kernels from 1:N, though for Face-fields in Bounded directions, we only require 2:N. In fact using tendencies only from 2:N could allow an optimization where we don't need to ""enforce"" no-penetration boundary conditions. It'd be hard to achieve this optimization though because users can write things like `parent(u) .= 1` so I'm not sure we can get away with this being guaranteed correct. This has never been a problem because we simply overwrite the boundary velocity and therefore simply discard the tendency at index 1. > The problem is if we try to integrate something like a radiation condition. Can you point me to where in the code this goes down?. > On bounded topology I don't think we ever want to integrate the tendency right? But it might be more complicated to do that. I think that's right that we don't need the tendency. This has been part of the algorithm since time immemorial and back in the mists of time it was indeed more complicated than worthwhile. The complication is that KernelAbstractions assumes indices start at 1... However, we now have a way of offsetting indices in kernels via our `KernelParameters`. So it's not very hard to do this anymore. I can give it a start. If we make this change, we also want to take a step back and look at all the kernels we are launching currently to make sure everything makes sense. For example, here is a question: while we don't want to integrate the velocity tendencies on boundaries, what do we do about diagnostics? Do we want to compute vorticity on the boundary, for example, if we are computing a vorticity diagnostic? It seems simpler if we don't, that way we don't have special cases...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3810#issuecomment-2388758985
Usability,simpl,simplest,Do you mean when we're computing a diagnostic like vorticity should the kernel include the boundary point? It does seem the simplest would be that anything on a bounded face only launches over 2:N,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3810#issuecomment-2389135623
Usability,simpl,simplest,> Do you mean when we're computing a diagnostic like vorticity should the kernel include the boundary point? It does seem the simplest would be that anything on a bounded face only launches over 2:N. That's right.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3810#issuecomment-2389163957
Usability,simpl,simpler,"#3814 is one approach. Another approach which is a lot simpler actually would be to multiply the tendencies by `!peripheral_node(i, j, k, grid, loc...)`. Let's see how #3814 turns out and we can try that instead if we want.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3810#issuecomment-2389213503
Usability,simpl,simplification,"> Where is the halo filling code?. Something like:; ```julia; @inline function _fill_west_open_halo!(j, k, grid, u, bc::PAOBC, loc, clock, model_fields); Δt = clock.last_stage_Δt. Δt = ifelse(isinf(Δt), 0, Δt). Δx = xspacing(1, j, k, grid, Face(), Center(), Center()). C = getbc(bc, j, k, grid, clock model_fields). u₀ⁿ = @inbounds u[0, j, k]; u₁ⁿ⁺¹ = @inbounds u[2, j, k]. C = min(0, max(1, Δt / Δx * C)). @inbounds u[1, j, k] = (u₀ⁿ - C * u₁ⁿ⁺¹) / (1 - C); end; ```. This is a simplification (won't work if the flow is inwards) but I'll link when I put it on GH.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3810#issuecomment-2389512033
Deployability,integrat,integrates,We only put the no normal gradient matching scheme in the source code which just overwrites the boundary point so this wasn't a problem. I though we weren't going to put lots of matching schemes in the source code since its not clear what is the best/correct. We could put in a simple scheme that integrates the boundary point if that would be better?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3810#issuecomment-2391286794
Integrability,integrat,integrates,We only put the no normal gradient matching scheme in the source code which just overwrites the boundary point so this wasn't a problem. I though we weren't going to put lots of matching schemes in the source code since its not clear what is the best/correct. We could put in a simple scheme that integrates the boundary point if that would be better?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3810#issuecomment-2391286794
Usability,clear,clear,We only put the no normal gradient matching scheme in the source code which just overwrites the boundary point so this wasn't a problem. I though we weren't going to put lots of matching schemes in the source code since its not clear what is the best/correct. We could put in a simple scheme that integrates the boundary point if that would be better?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3810#issuecomment-2391286794
Testability,log,logically,"I remember discussing a strategy for working on the _design_ of open boundary conditions, and for that I advocated for finding a simple scheme to implement and focusing on the overall design. The purpose of that is to allow us to think clearly and logically about the software design without getting tangled up in numerics. Once we have a good design (I'm not sure that we do unfortunately...) then the door is open to work on numerics, hopefully without being hindered too much (the point of a good design). Then we can make rapid progress. But this sort of strategy to focus on ""one thing at a time"" is not a comment about whether we should put numerics in the source code or not. It's a strategy for software development, not a comment about package organization.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3810#issuecomment-2391355404
Usability,simpl,simple,"I remember discussing a strategy for working on the _design_ of open boundary conditions, and for that I advocated for finding a simple scheme to implement and focusing on the overall design. The purpose of that is to allow us to think clearly and logically about the software design without getting tangled up in numerics. Once we have a good design (I'm not sure that we do unfortunately...) then the door is open to work on numerics, hopefully without being hindered too much (the point of a good design). Then we can make rapid progress. But this sort of strategy to focus on ""one thing at a time"" is not a comment about whether we should put numerics in the source code or not. It's a strategy for software development, not a comment about package organization.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3810#issuecomment-2391355404
Availability,error,error,"> If a user makes a mistake and provides a matrix with one column instead of a vector, it will fail internally with an unfriendly error message. Ah for sure. I was just remarking that if you need the eltype, you can use `AbstractArray{FT}` (or you can simply call `eltype`, which is preferred by [YASGuide](https://github.com/jrevels/YASGuide) --- type parameters should be used for dispatch only). I think it's ok if you keep `AbstractVector`. We can create a wrapper for Krylov.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3812#issuecomment-2416855962
Integrability,message,message,"> If a user makes a mistake and provides a matrix with one column instead of a vector, it will fail internally with an unfriendly error message. Ah for sure. I was just remarking that if you need the eltype, you can use `AbstractArray{FT}` (or you can simply call `eltype`, which is preferred by [YASGuide](https://github.com/jrevels/YASGuide) --- type parameters should be used for dispatch only). I think it's ok if you keep `AbstractVector`. We can create a wrapper for Krylov.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3812#issuecomment-2416855962
Usability,simpl,simply,"> If a user makes a mistake and provides a matrix with one column instead of a vector, it will fail internally with an unfriendly error message. Ah for sure. I was just remarking that if you need the eltype, you can use `AbstractArray{FT}` (or you can simply call `eltype`, which is preferred by [YASGuide](https://github.com/jrevels/YASGuide) --- type parameters should be used for dispatch only). I think it's ok if you keep `AbstractVector`. We can create a wrapper for Krylov.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3812#issuecomment-2416855962
Safety,avoid,avoid,"I can create a separate issue to address this, but perhaps more importantly, I don't see the interior velocity `V∞` being added anywhere there except in the BCs. Usually we add it as a background field to avoid inertial oscillations, and indeed it used to be done like that in [older versions of the docs](https://clima.github.io/OceananigansDocumentation/v0.73.8/generated/tilted_bottom_boundary_layer/), but at some point this was changed and I don't really understand why (nor can I pinpoint where). I think it's okay to run the example without adding it as a background field, but then we're solving the problem in a reference frame that's moving with the interior flow and that should be made explicit, and I don't see that explanation there. Personally, I'm in favor of including `V∞` as a background field because it's simpler. CC @hdrake @glwagner who were in https://github.com/CliMA/Oceananigans.jl/pull/3581",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3813#issuecomment-2388670415
Usability,simpl,simpler,"I can create a separate issue to address this, but perhaps more importantly, I don't see the interior velocity `V∞` being added anywhere there except in the BCs. Usually we add it as a background field to avoid inertial oscillations, and indeed it used to be done like that in [older versions of the docs](https://clima.github.io/OceananigansDocumentation/v0.73.8/generated/tilted_bottom_boundary_layer/), but at some point this was changed and I don't really understand why (nor can I pinpoint where). I think it's okay to run the example without adding it as a background field, but then we're solving the problem in a reference frame that's moving with the interior flow and that should be made explicit, and I don't see that explanation there. Personally, I'm in favor of including `V∞` as a background field because it's simpler. CC @hdrake @glwagner who were in https://github.com/CliMA/Oceananigans.jl/pull/3581",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3813#issuecomment-2388670415
Safety,avoid,avoid,"> I can create a separate issue to address this, but perhaps more importantly, I don't see the interior velocity `V∞` being added anywhere there except in the BCs. Usually we add it as a background field to avoid inertial oscillations, and indeed it used to be done like that in [older versions of the docs](https://clima.github.io/OceananigansDocumentation/v0.73.8/generated/tilted_bottom_boundary_layer/), but at some point this was changed and I don't really understand why (nor can I pinpoint where).; > ; > I think it's okay to run the example without adding it as a background field, but then we're solving the problem in a reference frame that's moving with the interior flow and that should be made explicit, and I don't see that explanation there. Personally, I'm in favor of including `V∞` as a background field because it's simpler.; > ; > CC @hdrake @glwagner who were in #3581. What's the problem with adding it back?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3813#issuecomment-2388706841
Usability,simpl,simpler,"> I can create a separate issue to address this, but perhaps more importantly, I don't see the interior velocity `V∞` being added anywhere there except in the BCs. Usually we add it as a background field to avoid inertial oscillations, and indeed it used to be done like that in [older versions of the docs](https://clima.github.io/OceananigansDocumentation/v0.73.8/generated/tilted_bottom_boundary_layer/), but at some point this was changed and I don't really understand why (nor can I pinpoint where).; > ; > I think it's okay to run the example without adding it as a background field, but then we're solving the problem in a reference frame that's moving with the interior flow and that should be made explicit, and I don't see that explanation there. Personally, I'm in favor of including `V∞` as a background field because it's simpler.; > ; > CC @hdrake @glwagner who were in #3581. What's the problem with adding it back?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3813#issuecomment-2388706841
Safety,avoid,avoid,"> > I can create a separate issue to address this, but perhaps more importantly, I don't see the interior velocity `V∞` being added anywhere there except in the BCs. Usually we add it as a background field to avoid inertial oscillations, and indeed it used to be done like that in [older versions of the docs](https://clima.github.io/OceananigansDocumentation/v0.73.8/generated/tilted_bottom_boundary_layer/), but at some point this was changed and I don't really understand why (nor can I pinpoint where).; > > I think it's okay to run the example without adding it as a background field, but then we're solving the problem in a reference frame that's moving with the interior flow and that should be made explicit, and I don't see that explanation there. Personally, I'm in favor of including `V∞` as a background field because it's simpler.; > > CC @hdrake @glwagner who were in #3581; > ; > What's the problem with adding it back?. No problem at all, and in my opinion that's what we should do. I'm just checking with the community first since it might have been removed for some reason I'm not aware of. Are you okay if I add it back?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3813#issuecomment-2388736091
Usability,simpl,simpler,"> > I can create a separate issue to address this, but perhaps more importantly, I don't see the interior velocity `V∞` being added anywhere there except in the BCs. Usually we add it as a background field to avoid inertial oscillations, and indeed it used to be done like that in [older versions of the docs](https://clima.github.io/OceananigansDocumentation/v0.73.8/generated/tilted_bottom_boundary_layer/), but at some point this was changed and I don't really understand why (nor can I pinpoint where).; > > I think it's okay to run the example without adding it as a background field, but then we're solving the problem in a reference frame that's moving with the interior flow and that should be made explicit, and I don't see that explanation there. Personally, I'm in favor of including `V∞` as a background field because it's simpler.; > > CC @hdrake @glwagner who were in #3581; > ; > What's the problem with adding it back?. No problem at all, and in my opinion that's what we should do. I'm just checking with the community first since it might have been removed for some reason I'm not aware of. Are you okay if I add it back?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3813#issuecomment-2388736091
Deployability,integrat,integrate,"> I am not sure about the purpose of this PR. What is the reason we do not want to calculate the periphery in the nonhydrostatic model tendencies?; > ; > If there is a specific reason, does this solution also apply to immersed boundaries with active cell map? It seems like nothing changed for that case. Because some open boundary conditions integrate an alternative PDE on the boundaries (eg for radiation conditions). In other words the algorithm we are using is only valid for simple open boundary conditions (we designed it for impenetrable condition). More generally, the algorithm is wrong. There are two other benefits. First, we do not use the tendencies on the periphery. So this increases the clarity of the code. Previously, it might not be obvious that even though we compute tendencies on the boundary, we overwrite the field values in `fill_halo_regions!`. It saves a little bit of computation as well...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3814#issuecomment-2397256988
Integrability,integrat,integrate,"> I am not sure about the purpose of this PR. What is the reason we do not want to calculate the periphery in the nonhydrostatic model tendencies?; > ; > If there is a specific reason, does this solution also apply to immersed boundaries with active cell map? It seems like nothing changed for that case. Because some open boundary conditions integrate an alternative PDE on the boundaries (eg for radiation conditions). In other words the algorithm we are using is only valid for simple open boundary conditions (we designed it for impenetrable condition). More generally, the algorithm is wrong. There are two other benefits. First, we do not use the tendencies on the periphery. So this increases the clarity of the code. Previously, it might not be obvious that even though we compute tendencies on the boundary, we overwrite the field values in `fill_halo_regions!`. It saves a little bit of computation as well...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3814#issuecomment-2397256988
Usability,simpl,simple,"> I am not sure about the purpose of this PR. What is the reason we do not want to calculate the periphery in the nonhydrostatic model tendencies?; > ; > If there is a specific reason, does this solution also apply to immersed boundaries with active cell map? It seems like nothing changed for that case. Because some open boundary conditions integrate an alternative PDE on the boundaries (eg for radiation conditions). In other words the algorithm we are using is only valid for simple open boundary conditions (we designed it for impenetrable condition). More generally, the algorithm is wrong. There are two other benefits. First, we do not use the tendencies on the periphery. So this increases the clarity of the code. Previously, it might not be obvious that even though we compute tendencies on the boundary, we overwrite the field values in `fill_halo_regions!`. It saves a little bit of computation as well...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3814#issuecomment-2397256988
Integrability,depend,dependent,"> Also I am not sure about renaming to `buffer`. What is called `buffer` here is not really a buffer but a `halo-dependent` region of the active domain. What about calling it `compute_halo_dependent_tendencies!`?. This PR _defines_ the ""buffer"" as the halo dependent region of the domain. Before this PR there was no definition of this region at all, so this PR simply introduces one possible name. I am ok with a different name, but I think we should do it in another PR.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3814#issuecomment-2397258056
Usability,simpl,simply,"> Also I am not sure about renaming to `buffer`. What is called `buffer` here is not really a buffer but a `halo-dependent` region of the active domain. What about calling it `compute_halo_dependent_tendencies!`?. This PR _defines_ the ""buffer"" as the halo dependent region of the domain. Before this PR there was no definition of this region at all, so this PR simply introduces one possible name. I am ok with a different name, but I think we should do it in another PR.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3814#issuecomment-2397258056
Integrability,depend,dependent,"> > Also I am not sure about renaming to `buffer`. What is called `buffer` here is not really a buffer but a `halo-dependent` region of the active domain. What about calling it `compute_halo_dependent_tendencies!`?; > ; > This PR _defines_ the ""buffer"" as the halo dependent region of the domain.; > ; > Before this PR there was no definition of this region at all, so this PR simply introduces one possible name. I am ok with a different name, but I think we should do it in another PR. Ok, can we leave the refactoring to another PR than to clean up this one?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3814#issuecomment-2398015122
Modifiability,refactor,refactoring,"> > Also I am not sure about renaming to `buffer`. What is called `buffer` here is not really a buffer but a `halo-dependent` region of the active domain. What about calling it `compute_halo_dependent_tendencies!`?; > ; > This PR _defines_ the ""buffer"" as the halo dependent region of the domain.; > ; > Before this PR there was no definition of this region at all, so this PR simply introduces one possible name. I am ok with a different name, but I think we should do it in another PR. Ok, can we leave the refactoring to another PR than to clean up this one?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3814#issuecomment-2398015122
Usability,simpl,simply,"> > Also I am not sure about renaming to `buffer`. What is called `buffer` here is not really a buffer but a `halo-dependent` region of the active domain. What about calling it `compute_halo_dependent_tendencies!`?; > ; > This PR _defines_ the ""buffer"" as the halo dependent region of the domain.; > ; > Before this PR there was no definition of this region at all, so this PR simply introduces one possible name. I am ok with a different name, but I think we should do it in another PR. Ok, can we leave the refactoring to another PR than to clean up this one?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3814#issuecomment-2398015122
Testability,test,test,I think we should test this independently of an example. Examples change but it'd be nice to make sure this functionality still works. I'll add something simple and then we can iterate.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3815#issuecomment-2389128694
Usability,simpl,simple,I think we should test this independently of an example. Examples change but it'd be nice to make sure this functionality still works. I'll add something simple and then we can iterate.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3815#issuecomment-2389128694
Availability,checkpoint,checkpoints,"I see the interest of creating a handler of all the outputs of the model. Is the idea to make a wrapper depending on parsing a preexisting writers i.e. `NetCDFOutputWriter`, `JLD2OutputWriter`, and `Checkpointer`. Or do you plan to make a new structure that handles all of them? . I agree that keeping a simple way to create `Checkpointer`s and `OutputWriter`s should be a priority, particularly in the case when the user needs to restart the simulation multiple times in an HPC, keeping in mind manageable file sizes, wall times, and chunks. Currently, this can be handle by the user creating unique output folders or changing the name of the output file for each resubmission of the simulation. Unfortunately, this makes more complex the processing of the output. I think the best solution with outputs and checkpoints will be to automatically append to the last output file from the previous simulation resubmission (currently not supported). I agree that the initialisation of the writer should not create a file, I find that quite confusing. I believe it will be simple to change by only executting the `initialize_nc_file!` and `initialize_jld2_file!` once the model is running, instead of two times, once the writers are initialised and in run time (`write_output!`). . Despite the implementation of this, I still see value in having a flag `overwrite_existing`, likely set up to `false` as default (I will comment in the discussion about this), and ensure that we do not change this flag on run time, since it may result in issues and data loss. . Regarding my changes in this PR, the function `is_output_splitted!` may still be useful, since it returns the last file to then append the output, necessary to handle file splitting in a general output function.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3818#issuecomment-2391694283
Integrability,wrap,wrapper,"I see the interest of creating a handler of all the outputs of the model. Is the idea to make a wrapper depending on parsing a preexisting writers i.e. `NetCDFOutputWriter`, `JLD2OutputWriter`, and `Checkpointer`. Or do you plan to make a new structure that handles all of them? . I agree that keeping a simple way to create `Checkpointer`s and `OutputWriter`s should be a priority, particularly in the case when the user needs to restart the simulation multiple times in an HPC, keeping in mind manageable file sizes, wall times, and chunks. Currently, this can be handle by the user creating unique output folders or changing the name of the output file for each resubmission of the simulation. Unfortunately, this makes more complex the processing of the output. I think the best solution with outputs and checkpoints will be to automatically append to the last output file from the previous simulation resubmission (currently not supported). I agree that the initialisation of the writer should not create a file, I find that quite confusing. I believe it will be simple to change by only executting the `initialize_nc_file!` and `initialize_jld2_file!` once the model is running, instead of two times, once the writers are initialised and in run time (`write_output!`). . Despite the implementation of this, I still see value in having a flag `overwrite_existing`, likely set up to `false` as default (I will comment in the discussion about this), and ensure that we do not change this flag on run time, since it may result in issues and data loss. . Regarding my changes in this PR, the function `is_output_splitted!` may still be useful, since it returns the last file to then append the output, necessary to handle file splitting in a general output function.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3818#issuecomment-2391694283
Usability,simpl,simple,"I see the interest of creating a handler of all the outputs of the model. Is the idea to make a wrapper depending on parsing a preexisting writers i.e. `NetCDFOutputWriter`, `JLD2OutputWriter`, and `Checkpointer`. Or do you plan to make a new structure that handles all of them? . I agree that keeping a simple way to create `Checkpointer`s and `OutputWriter`s should be a priority, particularly in the case when the user needs to restart the simulation multiple times in an HPC, keeping in mind manageable file sizes, wall times, and chunks. Currently, this can be handle by the user creating unique output folders or changing the name of the output file for each resubmission of the simulation. Unfortunately, this makes more complex the processing of the output. I think the best solution with outputs and checkpoints will be to automatically append to the last output file from the previous simulation resubmission (currently not supported). I agree that the initialisation of the writer should not create a file, I find that quite confusing. I believe it will be simple to change by only executting the `initialize_nc_file!` and `initialize_jld2_file!` once the model is running, instead of two times, once the writers are initialised and in run time (`write_output!`). . Despite the implementation of this, I still see value in having a flag `overwrite_existing`, likely set up to `false` as default (I will comment in the discussion about this), and ensure that we do not change this flag on run time, since it may result in issues and data loss. . Regarding my changes in this PR, the function `is_output_splitted!` may still be useful, since it returns the last file to then append the output, necessary to handle file splitting in a general output function.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3818#issuecomment-2391694283
Integrability,wrap,wrapper,"> I see the interest of creating a handler of all the outputs of the model. Is the idea to make a wrapper depending on parsing a preexisting writers i.e. NetCDFOutputWriter, JLD2OutputWriter. If you are referring to #3793 my intent is just to introduce an additional wrapper on top of the existing writers. It's merely an alternative to adding output writers manually to `simulation.output_writers`, which I find inelegant. > I believe it will be simple to change by only executting the initialize_nc_file! and initialize_jld2_file! once the model is running, instead of two times, once the writers are initialised and in run time (write_output!). I agree that it's simple to design. > Despite the implementation of this, I still see value in having a flag overwrite_existing, likely set up to false as default (I will comment in the discussion about this), and ensure that we do not change this flag on run time, since it may result in issues and data loss. Why would it result in (unintended) data loss? Because its common to mistakenly re-run a simulation? . > Regarding my changes in this PR, the function is_output_splitted! may still be useful, since it returns the last file to then append the output, necessary to handle file splitting in a general output function. Okay, I'll take a look.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3818#issuecomment-2391732954
Usability,simpl,simple,"> I see the interest of creating a handler of all the outputs of the model. Is the idea to make a wrapper depending on parsing a preexisting writers i.e. NetCDFOutputWriter, JLD2OutputWriter. If you are referring to #3793 my intent is just to introduce an additional wrapper on top of the existing writers. It's merely an alternative to adding output writers manually to `simulation.output_writers`, which I find inelegant. > I believe it will be simple to change by only executting the initialize_nc_file! and initialize_jld2_file! once the model is running, instead of two times, once the writers are initialised and in run time (write_output!). I agree that it's simple to design. > Despite the implementation of this, I still see value in having a flag overwrite_existing, likely set up to false as default (I will comment in the discussion about this), and ensure that we do not change this flag on run time, since it may result in issues and data loss. Why would it result in (unintended) data loss? Because its common to mistakenly re-run a simulation? . > Regarding my changes in this PR, the function is_output_splitted! may still be useful, since it returns the last file to then append the output, necessary to handle file splitting in a general output function. Okay, I'll take a look.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3818#issuecomment-2391732954
Modifiability,variab,variable,"Currently in my workflow, I define an environment variable that contains an string like `$init_$end.nc`, where `init` is the initial time and `end` is the `stop_time` of the simulation. In the first instantiation of the model for 60 days, this string will be appended to my output filename e.g.`vel_field_`, resulting on something like `vel_field_0_60.nc`. For the next pickup the filename will be changed to `vel_field_60_120.nc`. This works well when the files are not split, i.e. `file_splitting = NoFileSplitting()`. However when splitting the file, e.g. `file_splitting = TimeInterval(30days)`, the first instantiation will result in the following files:; ```; vel_fields_0_60_part1.nc vel_fields_0_60_part2.nc vel_fields_0_60_part3.nc; ```; then the next pickup will result in files: ; ```; vel_fields_60_120_part1.nc vel_fields_60_120_part3.nc vel_fields_60_120_part5.nc; vel_fields_60_120_part2.nc vel_fields_60_120_part4.nc; ```; of this files, the first 2 parts (`vel_fields_60_120_part1.nc` and `vel_fields_60_120_part2.nc`) are empty, and the `vel_fields_60_120_part3.nc` contains data from the day 61 until 91. This makes the loading of the data for post-processing a bit tricky, since some of they are empty and the disk storage will make more difficult chunking data. . If I don't change the name each time I pickup, with the `overwrite_existing=false` it crashes, and with `overwrite_existing=true` it rewrites all the files. . Another workflow will be to create a new folder for each pickup keeping the same filename, but splitting the files will result in the same issue of file duplication. . I hope this description of the workflow is clearer.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3818#issuecomment-2391946301
Performance,load,loading,"Currently in my workflow, I define an environment variable that contains an string like `$init_$end.nc`, where `init` is the initial time and `end` is the `stop_time` of the simulation. In the first instantiation of the model for 60 days, this string will be appended to my output filename e.g.`vel_field_`, resulting on something like `vel_field_0_60.nc`. For the next pickup the filename will be changed to `vel_field_60_120.nc`. This works well when the files are not split, i.e. `file_splitting = NoFileSplitting()`. However when splitting the file, e.g. `file_splitting = TimeInterval(30days)`, the first instantiation will result in the following files:; ```; vel_fields_0_60_part1.nc vel_fields_0_60_part2.nc vel_fields_0_60_part3.nc; ```; then the next pickup will result in files: ; ```; vel_fields_60_120_part1.nc vel_fields_60_120_part3.nc vel_fields_60_120_part5.nc; vel_fields_60_120_part2.nc vel_fields_60_120_part4.nc; ```; of this files, the first 2 parts (`vel_fields_60_120_part1.nc` and `vel_fields_60_120_part2.nc`) are empty, and the `vel_fields_60_120_part3.nc` contains data from the day 61 until 91. This makes the loading of the data for post-processing a bit tricky, since some of they are empty and the disk storage will make more difficult chunking data. . If I don't change the name each time I pickup, with the `overwrite_existing=false` it crashes, and with `overwrite_existing=true` it rewrites all the files. . Another workflow will be to create a new folder for each pickup keeping the same filename, but splitting the files will result in the same issue of file duplication. . I hope this description of the workflow is clearer.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3818#issuecomment-2391946301
Usability,clear,clearer,"Currently in my workflow, I define an environment variable that contains an string like `$init_$end.nc`, where `init` is the initial time and `end` is the `stop_time` of the simulation. In the first instantiation of the model for 60 days, this string will be appended to my output filename e.g.`vel_field_`, resulting on something like `vel_field_0_60.nc`. For the next pickup the filename will be changed to `vel_field_60_120.nc`. This works well when the files are not split, i.e. `file_splitting = NoFileSplitting()`. However when splitting the file, e.g. `file_splitting = TimeInterval(30days)`, the first instantiation will result in the following files:; ```; vel_fields_0_60_part1.nc vel_fields_0_60_part2.nc vel_fields_0_60_part3.nc; ```; then the next pickup will result in files: ; ```; vel_fields_60_120_part1.nc vel_fields_60_120_part3.nc vel_fields_60_120_part5.nc; vel_fields_60_120_part2.nc vel_fields_60_120_part4.nc; ```; of this files, the first 2 parts (`vel_fields_60_120_part1.nc` and `vel_fields_60_120_part2.nc`) are empty, and the `vel_fields_60_120_part3.nc` contains data from the day 61 until 91. This makes the loading of the data for post-processing a bit tricky, since some of they are empty and the disk storage will make more difficult chunking data. . If I don't change the name each time I pickup, with the `overwrite_existing=false` it crashes, and with `overwrite_existing=true` it rewrites all the files. . Another workflow will be to create a new folder for each pickup keeping the same filename, but splitting the files will result in the same issue of file duplication. . I hope this description of the workflow is clearer.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3818#issuecomment-2391946301
Availability,checkpoint,checkpoints,"> I hope this description of the workflow is clearer. It's clear!. > I thought the optimal implementation is to append to the previous existing file when using checkpoints. Of course I agree with this. I think our basic principle should be that there is no difference in workflow, either for running or analysis, between scripts for checkpointing or not. Also, I think that `overwrite_existing` should not delete your files if you are picking up from a checkpoint (regardless of what it is set to). Do you agree?. > If I don't change the name each time I pickup, with the overwrite_existing=false it crashes, and with overwrite_existing=true it rewrites all the files. If we have a system that does not overwrite files when picking up from a checkpoint, do you think that it will be necessary to have `overwrite_existing=false` by default? In this case, the only time we risk overwriting files is when we _re-run_ a simulation from the beginning. Assume for the following discussion that the ""overwriting issue"" is solved for checkpointing:. In my experience, I typically set up a script with `overwrite_existing=true` from the very beginning. This is because when we first write a script, we are prototyping. I have never then gone back and changed `overwrite_existing=false` because of some concern about overwriting data. It's inconvenient, in fact, to set `overwrite_existing=false`. My thought is that it makes more sense to ask people to intentionally request `overwrite_existing=false` in the _rare_ case that this is desired. The key insight is that we spend the vast majority of time prototyping. I would even argue from an economic standpoint that the productivity saved from this setting outweights any rare instances of lost data, if they actually would ever occur due to changing the default. Also, even for this purpose I don't really want a ""non-overwriting guarantee"" as a feature. I would prefer something like ""unique_filenames = true"" or something, which I could then ""turn on"" if I",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3818#issuecomment-2392162201
Modifiability,rewrite,rewrites,"> I hope this description of the workflow is clearer. It's clear!. > I thought the optimal implementation is to append to the previous existing file when using checkpoints. Of course I agree with this. I think our basic principle should be that there is no difference in workflow, either for running or analysis, between scripts for checkpointing or not. Also, I think that `overwrite_existing` should not delete your files if you are picking up from a checkpoint (regardless of what it is set to). Do you agree?. > If I don't change the name each time I pickup, with the overwrite_existing=false it crashes, and with overwrite_existing=true it rewrites all the files. If we have a system that does not overwrite files when picking up from a checkpoint, do you think that it will be necessary to have `overwrite_existing=false` by default? In this case, the only time we risk overwriting files is when we _re-run_ a simulation from the beginning. Assume for the following discussion that the ""overwriting issue"" is solved for checkpointing:. In my experience, I typically set up a script with `overwrite_existing=true` from the very beginning. This is because when we first write a script, we are prototyping. I have never then gone back and changed `overwrite_existing=false` because of some concern about overwriting data. It's inconvenient, in fact, to set `overwrite_existing=false`. My thought is that it makes more sense to ask people to intentionally request `overwrite_existing=false` in the _rare_ case that this is desired. The key insight is that we spend the vast majority of time prototyping. I would even argue from an economic standpoint that the productivity saved from this setting outweights any rare instances of lost data, if they actually would ever occur due to changing the default. Also, even for this purpose I don't really want a ""non-overwriting guarantee"" as a feature. I would prefer something like ""unique_filenames = true"" or something, which I could then ""turn on"" if I",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3818#issuecomment-2392162201
Safety,risk,risk,"> I hope this description of the workflow is clearer. It's clear!. > I thought the optimal implementation is to append to the previous existing file when using checkpoints. Of course I agree with this. I think our basic principle should be that there is no difference in workflow, either for running or analysis, between scripts for checkpointing or not. Also, I think that `overwrite_existing` should not delete your files if you are picking up from a checkpoint (regardless of what it is set to). Do you agree?. > If I don't change the name each time I pickup, with the overwrite_existing=false it crashes, and with overwrite_existing=true it rewrites all the files. If we have a system that does not overwrite files when picking up from a checkpoint, do you think that it will be necessary to have `overwrite_existing=false` by default? In this case, the only time we risk overwriting files is when we _re-run_ a simulation from the beginning. Assume for the following discussion that the ""overwriting issue"" is solved for checkpointing:. In my experience, I typically set up a script with `overwrite_existing=true` from the very beginning. This is because when we first write a script, we are prototyping. I have never then gone back and changed `overwrite_existing=false` because of some concern about overwriting data. It's inconvenient, in fact, to set `overwrite_existing=false`. My thought is that it makes more sense to ask people to intentionally request `overwrite_existing=false` in the _rare_ case that this is desired. The key insight is that we spend the vast majority of time prototyping. I would even argue from an economic standpoint that the productivity saved from this setting outweights any rare instances of lost data, if they actually would ever occur due to changing the default. Also, even for this purpose I don't really want a ""non-overwriting guarantee"" as a feature. I would prefer something like ""unique_filenames = true"" or something, which I could then ""turn on"" if I",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3818#issuecomment-2392162201
Usability,clear,clearer,"> I hope this description of the workflow is clearer. It's clear!. > I thought the optimal implementation is to append to the previous existing file when using checkpoints. Of course I agree with this. I think our basic principle should be that there is no difference in workflow, either for running or analysis, between scripts for checkpointing or not. Also, I think that `overwrite_existing` should not delete your files if you are picking up from a checkpoint (regardless of what it is set to). Do you agree?. > If I don't change the name each time I pickup, with the overwrite_existing=false it crashes, and with overwrite_existing=true it rewrites all the files. If we have a system that does not overwrite files when picking up from a checkpoint, do you think that it will be necessary to have `overwrite_existing=false` by default? In this case, the only time we risk overwriting files is when we _re-run_ a simulation from the beginning. Assume for the following discussion that the ""overwriting issue"" is solved for checkpointing:. In my experience, I typically set up a script with `overwrite_existing=true` from the very beginning. This is because when we first write a script, we are prototyping. I have never then gone back and changed `overwrite_existing=false` because of some concern about overwriting data. It's inconvenient, in fact, to set `overwrite_existing=false`. My thought is that it makes more sense to ask people to intentionally request `overwrite_existing=false` in the _rare_ case that this is desired. The key insight is that we spend the vast majority of time prototyping. I would even argue from an economic standpoint that the productivity saved from this setting outweights any rare instances of lost data, if they actually would ever occur due to changing the default. Also, even for this purpose I don't really want a ""non-overwriting guarantee"" as a feature. I would prefer something like ""unique_filenames = true"" or something, which I could then ""turn on"" if I",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3818#issuecomment-2392162201
Availability,checkpoint,checkpointing,"> Of course I agree with this. I think our basic principle should be that there is no difference in workflow, either for running or analysis, between scripts for checkpointing or not. Also, I think that overwrite_existing should not delete your files if you are picking up from a checkpoint (regardless of what it is set to). Do you agree?. Yes, I completely agree, if the simulation picks up from a checkpoint it should not delete data. >Assume for the following discussion that the ""overwriting issue"" is solved for checkpointing:; >; >In my experience, I typically set up a script with overwrite_existing=true from the very beginning. This is because when we first write a script, we are prototyping. I have never then gone back and changed overwrite_existing=false because of some concern about overwriting data. It's inconvenient, in fact, to set overwrite_existing=false.; >; >My thought is that it makes more sense to ask people to intentionally request overwrite_existing=false in the rare case that this is desired. The key insight is that we spend the vast majority of time prototyping. I would even argue from an economic standpoint that the productivity saved from this setting outweights any rare instances of lost data, if they actually would ever occur due to changing the default. Now it is clear. If we handle properly picking up simulations, I completely agree with you that best option is for the user to manually change `overwrite_existing=false` to ensure their own data. I also follow the same workflow when creating a simulation in which I rely on the `overwrite_existing=true` until I reach the ""production"" phase of the simulation. > Also curious --- do you split files to make them easier to download? . I mostly do it to keep a consistent size and chunks across files for post-processing, but supporting both things will make the user workflow more flexible, particularly when running long simulations with multiple pickups. It's likely that the post-processing you suggest ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3818#issuecomment-2393101043
Modifiability,flexible,flexible,"ckpointing or not. Also, I think that overwrite_existing should not delete your files if you are picking up from a checkpoint (regardless of what it is set to). Do you agree?. Yes, I completely agree, if the simulation picks up from a checkpoint it should not delete data. >Assume for the following discussion that the ""overwriting issue"" is solved for checkpointing:; >; >In my experience, I typically set up a script with overwrite_existing=true from the very beginning. This is because when we first write a script, we are prototyping. I have never then gone back and changed overwrite_existing=false because of some concern about overwriting data. It's inconvenient, in fact, to set overwrite_existing=false.; >; >My thought is that it makes more sense to ask people to intentionally request overwrite_existing=false in the rare case that this is desired. The key insight is that we spend the vast majority of time prototyping. I would even argue from an economic standpoint that the productivity saved from this setting outweights any rare instances of lost data, if they actually would ever occur due to changing the default. Now it is clear. If we handle properly picking up simulations, I completely agree with you that best option is for the user to manually change `overwrite_existing=false` to ensure their own data. I also follow the same workflow when creating a simulation in which I rely on the `overwrite_existing=true` until I reach the ""production"" phase of the simulation. > Also curious --- do you split files to make them easier to download? . I mostly do it to keep a consistent size and chunks across files for post-processing, but supporting both things will make the user workflow more flexible, particularly when running long simulations with multiple pickups. It's likely that the post-processing you suggest will be useful, but in that case it may be more useful to include support to zarr files within the possible simulation outputs (https://github.com/JuliaIO/Zarr.jl).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3818#issuecomment-2393101043
Usability,clear,clear,"ckpointing or not. Also, I think that overwrite_existing should not delete your files if you are picking up from a checkpoint (regardless of what it is set to). Do you agree?. Yes, I completely agree, if the simulation picks up from a checkpoint it should not delete data. >Assume for the following discussion that the ""overwriting issue"" is solved for checkpointing:; >; >In my experience, I typically set up a script with overwrite_existing=true from the very beginning. This is because when we first write a script, we are prototyping. I have never then gone back and changed overwrite_existing=false because of some concern about overwriting data. It's inconvenient, in fact, to set overwrite_existing=false.; >; >My thought is that it makes more sense to ask people to intentionally request overwrite_existing=false in the rare case that this is desired. The key insight is that we spend the vast majority of time prototyping. I would even argue from an economic standpoint that the productivity saved from this setting outweights any rare instances of lost data, if they actually would ever occur due to changing the default. Now it is clear. If we handle properly picking up simulations, I completely agree with you that best option is for the user to manually change `overwrite_existing=false` to ensure their own data. I also follow the same workflow when creating a simulation in which I rely on the `overwrite_existing=true` until I reach the ""production"" phase of the simulation. > Also curious --- do you split files to make them easier to download? . I mostly do it to keep a consistent size and chunks across files for post-processing, but supporting both things will make the user workflow more flexible, particularly when running long simulations with multiple pickups. It's likely that the post-processing you suggest will be useful, but in that case it may be more useful to include support to zarr files within the possible simulation outputs (https://github.com/JuliaIO/Zarr.jl).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3818#issuecomment-2393101043
Usability,clear,clear,"Ok, now that this is clear, I clone and modify the PR #3793.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3818#issuecomment-2393108337
Availability,checkpoint,checkpointer,"Thanks for working on this @josuemtzmo! I do tend to avoid file splitting since one file, even if it is huge, simplifies data analysis. And most of the time, the data analysis can be done on the fly alleviating the need for huge outputs. > Do we test this?. I don't think so. Definitely a good idea to do so since a wrong implementation can result in data loss. Usually Julia would stop then re-run the entire script so would a test look something like: set up a simulation with a checkpointer, run it for a some iterations with some file splitting output, then set up the exact same simulation (copy paste) and run it for some more iterations and more file splitting, then check that the output is all correct?. There may be some edge cases too, e.g. zero or only one output actuation after picking up, or before the initial simulation ends.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3818#issuecomment-2397594302
Safety,avoid,avoid,"Thanks for working on this @josuemtzmo! I do tend to avoid file splitting since one file, even if it is huge, simplifies data analysis. And most of the time, the data analysis can be done on the fly alleviating the need for huge outputs. > Do we test this?. I don't think so. Definitely a good idea to do so since a wrong implementation can result in data loss. Usually Julia would stop then re-run the entire script so would a test look something like: set up a simulation with a checkpointer, run it for a some iterations with some file splitting output, then set up the exact same simulation (copy paste) and run it for some more iterations and more file splitting, then check that the output is all correct?. There may be some edge cases too, e.g. zero or only one output actuation after picking up, or before the initial simulation ends.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3818#issuecomment-2397594302
Testability,test,test,"Thanks for working on this @josuemtzmo! I do tend to avoid file splitting since one file, even if it is huge, simplifies data analysis. And most of the time, the data analysis can be done on the fly alleviating the need for huge outputs. > Do we test this?. I don't think so. Definitely a good idea to do so since a wrong implementation can result in data loss. Usually Julia would stop then re-run the entire script so would a test look something like: set up a simulation with a checkpointer, run it for a some iterations with some file splitting output, then set up the exact same simulation (copy paste) and run it for some more iterations and more file splitting, then check that the output is all correct?. There may be some edge cases too, e.g. zero or only one output actuation after picking up, or before the initial simulation ends.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3818#issuecomment-2397594302
Usability,simpl,simplifies,"Thanks for working on this @josuemtzmo! I do tend to avoid file splitting since one file, even if it is huge, simplifies data analysis. And most of the time, the data analysis can be done on the fly alleviating the need for huge outputs. > Do we test this?. I don't think so. Definitely a good idea to do so since a wrong implementation can result in data loss. Usually Julia would stop then re-run the entire script so would a test look something like: set up a simulation with a checkpointer, run it for a some iterations with some file splitting output, then set up the exact same simulation (copy paste) and run it for some more iterations and more file splitting, then check that the output is all correct?. There may be some edge cases too, e.g. zero or only one output actuation after picking up, or before the initial simulation ends.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3818#issuecomment-2397594302
Usability,simpl,simply,"Hmm well in terms of code design, if the operators enforce homogeneous boundary conditions, it should be possible to simply manually add the inhomogeneous part in a separate step. I don't think inhomogeneity has to be ""baked"" into operations. Eg the difference between:. ```julia; a = b + c + d; ```. and . ```julia; a = b + c; a += d; ```. We just need to have the inhomogeneous boundary conditions passed into the kernel and an appropriate ifelse statement.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3828#issuecomment-2398248032
Usability,clear,clear,"I'm saying, we can put boundary conditions in the kernels. I just don't think they should go into the _operators_. I'm not sure I am being clear. Can you please let me know if you understand what I'm saying.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3828#issuecomment-2400251817
Integrability,depend,depending,"I don't think I understand how this is ill-posed? It is over specified so will not produce physical results but I thought that without a radiating condition this should still not NaN straight away there should just be a lot of reflections from the boundaries?. Here is a simplified version of my code: https://github.com/jagoosw/OpenBoundaries.jl/blob/main/validation/bug_mwe.jl. I am using a matching scheme that advects the perturbation component (defined as the boundary adjacent minus imposed velocity) out of the domain, and relaxes to the imposed velocity at different rates depending on if it is an inflow or outflow (for the v component the timescale is Inf for outflows to allow it to maximally transmit information out). I can run it with no matching scheme but it needs tiny timesteps because the noise at the boundaries becomes massive. When I use the default pressure solver it kind of works. There are some bugs, for example, there is this weird jet generation on the southern inflowing boundary. I think these would be solved with relaxing regions. . https://github.com/user-attachments/assets/a85e66e2-3da7-402a-b546-57a3860cef9c. If I run with the CG solver it NaNs ""immediately"" and is doing ~800 iterations. If I restrict the iterations it doesn't NaN as fast, but generates very high velocities in a random place:. https://github.com/user-attachments/assets/d7ea836e-f69c-4f3a-9559-c64216e95cb0. I think there is also an issue with my model that its not respecting when a boundary adjacent cell is immersed so I'll fix that and get back to you. Perhaps the ""immediate"" NaNs are actually just from the timestep not being small enough as the reflections and bathymetry interactions make some very high velocities (in my case ~40x higher than the inflows)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3831#issuecomment-2411422283
Security,validat,validation,"I don't think I understand how this is ill-posed? It is over specified so will not produce physical results but I thought that without a radiating condition this should still not NaN straight away there should just be a lot of reflections from the boundaries?. Here is a simplified version of my code: https://github.com/jagoosw/OpenBoundaries.jl/blob/main/validation/bug_mwe.jl. I am using a matching scheme that advects the perturbation component (defined as the boundary adjacent minus imposed velocity) out of the domain, and relaxes to the imposed velocity at different rates depending on if it is an inflow or outflow (for the v component the timescale is Inf for outflows to allow it to maximally transmit information out). I can run it with no matching scheme but it needs tiny timesteps because the noise at the boundaries becomes massive. When I use the default pressure solver it kind of works. There are some bugs, for example, there is this weird jet generation on the southern inflowing boundary. I think these would be solved with relaxing regions. . https://github.com/user-attachments/assets/a85e66e2-3da7-402a-b546-57a3860cef9c. If I run with the CG solver it NaNs ""immediately"" and is doing ~800 iterations. If I restrict the iterations it doesn't NaN as fast, but generates very high velocities in a random place:. https://github.com/user-attachments/assets/d7ea836e-f69c-4f3a-9559-c64216e95cb0. I think there is also an issue with my model that its not respecting when a boundary adjacent cell is immersed so I'll fix that and get back to you. Perhaps the ""immediate"" NaNs are actually just from the timestep not being small enough as the reflections and bathymetry interactions make some very high velocities (in my case ~40x higher than the inflows)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3831#issuecomment-2411422283
Usability,simpl,simplified,"I don't think I understand how this is ill-posed? It is over specified so will not produce physical results but I thought that without a radiating condition this should still not NaN straight away there should just be a lot of reflections from the boundaries?. Here is a simplified version of my code: https://github.com/jagoosw/OpenBoundaries.jl/blob/main/validation/bug_mwe.jl. I am using a matching scheme that advects the perturbation component (defined as the boundary adjacent minus imposed velocity) out of the domain, and relaxes to the imposed velocity at different rates depending on if it is an inflow or outflow (for the v component the timescale is Inf for outflows to allow it to maximally transmit information out). I can run it with no matching scheme but it needs tiny timesteps because the noise at the boundaries becomes massive. When I use the default pressure solver it kind of works. There are some bugs, for example, there is this weird jet generation on the southern inflowing boundary. I think these would be solved with relaxing regions. . https://github.com/user-attachments/assets/a85e66e2-3da7-402a-b546-57a3860cef9c. If I run with the CG solver it NaNs ""immediately"" and is doing ~800 iterations. If I restrict the iterations it doesn't NaN as fast, but generates very high velocities in a random place:. https://github.com/user-attachments/assets/d7ea836e-f69c-4f3a-9559-c64216e95cb0. I think there is also an issue with my model that its not respecting when a boundary adjacent cell is immersed so I'll fix that and get back to you. Perhaps the ""immediate"" NaNs are actually just from the timestep not being small enough as the reflections and bathymetry interactions make some very high velocities (in my case ~40x higher than the inflows)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3831#issuecomment-2411422283
Security,validat,validation,> Here is a simplified version of my code: https://github.com/jagoosw/OpenBoundaries.jl/blob/main/validation/bug_mwe.jl. Was curious to have a look but I think the link might be dead?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3831#issuecomment-2412518929
Usability,simpl,simplified,> Here is a simplified version of my code: https://github.com/jagoosw/OpenBoundaries.jl/blob/main/validation/bug_mwe.jl. Was curious to have a look but I think the link might be dead?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3831#issuecomment-2412518929
Security,validat,validation,"> > Here is a simplified version of my code: https://github.com/jagoosw/OpenBoundaries.jl/blob/main/validation/bug_mwe.jl; > ; > Was curious to have a look but I think the link might be dead?. I forgot to make the repo public, it should work now",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3831#issuecomment-2414305318
Usability,simpl,simplified,"> > Here is a simplified version of my code: https://github.com/jagoosw/OpenBoundaries.jl/blob/main/validation/bug_mwe.jl; > ; > Was curious to have a look but I think the link might be dead?. I forgot to make the repo public, it should work now",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3831#issuecomment-2414305318
Availability,error,errors,"I also want to drop another optimization that can be used here --- using a `Float32` grid with the preconditioner. This will speed things up a bit. Eg:. ```julia; using Oceananigans.Grids: with_number_type. reduced_precision_grid = with_number_type(Float32, underlying_grid). pressure_solver = ConjugateGradientPoissonSolver(grid;; preconditioner = fft_poisson_solver(reduced_precision_grid),; maxiter = 10; ); ```. I also suggest plotting the divergence to get a handle on how the solver is working. A well-converged solution seems to have isotropically-distributed divergence errors. With looser tolerances, the divergence may be concentrated around the bathymetry (and of course with the naive FFT solver it has a thin layer adjacent to the bathymetry). I also think it would be nice if setting `maxiter=0` had a similar effect as simply using the FFT-based preconditioner. It's not the case right now, I think because we do not apply the preconditioner to the pressure initially before doing the CG iteration. It might not work (I believe I experimented briefly with that to no avail).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3831#issuecomment-2414308611
Performance,optimiz,optimization,"I also want to drop another optimization that can be used here --- using a `Float32` grid with the preconditioner. This will speed things up a bit. Eg:. ```julia; using Oceananigans.Grids: with_number_type. reduced_precision_grid = with_number_type(Float32, underlying_grid). pressure_solver = ConjugateGradientPoissonSolver(grid;; preconditioner = fft_poisson_solver(reduced_precision_grid),; maxiter = 10; ); ```. I also suggest plotting the divergence to get a handle on how the solver is working. A well-converged solution seems to have isotropically-distributed divergence errors. With looser tolerances, the divergence may be concentrated around the bathymetry (and of course with the naive FFT solver it has a thin layer adjacent to the bathymetry). I also think it would be nice if setting `maxiter=0` had a similar effect as simply using the FFT-based preconditioner. It's not the case right now, I think because we do not apply the preconditioner to the pressure initially before doing the CG iteration. It might not work (I believe I experimented briefly with that to no avail).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3831#issuecomment-2414308611
Usability,simpl,simply,"I also want to drop another optimization that can be used here --- using a `Float32` grid with the preconditioner. This will speed things up a bit. Eg:. ```julia; using Oceananigans.Grids: with_number_type. reduced_precision_grid = with_number_type(Float32, underlying_grid). pressure_solver = ConjugateGradientPoissonSolver(grid;; preconditioner = fft_poisson_solver(reduced_precision_grid),; maxiter = 10; ); ```. I also suggest plotting the divergence to get a handle on how the solver is working. A well-converged solution seems to have isotropically-distributed divergence errors. With looser tolerances, the divergence may be concentrated around the bathymetry (and of course with the naive FFT solver it has a thin layer adjacent to the bathymetry). I also think it would be nice if setting `maxiter=0` had a similar effect as simply using the FFT-based preconditioner. It's not the case right now, I think because we do not apply the preconditioner to the pressure initially before doing the CG iteration. It might not work (I believe I experimented briefly with that to no avail).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3831#issuecomment-2414308611
Energy Efficiency,adapt,adapted,", 2, 3...`.; * With `maxiter=100`, the problem is stable with `OpenBoundaryCondition` on west and east. At late times, the solver converges very quickly, in 1-5 iterations. I'd like to analyze the divergence more, but it seems that it is substantially higher with `FlatExtrapolationOpenBoundaryCondition`. I would also like to understand the convergence rate, which seems slower than with a prescribed outflow. From these results we see that `maxiter` should probably be set right now as a matter of practice. I think that even a handful of CG iterations is probably preferred to simply using the FFT solver naively with no CG iteration. There's also future work to understand the interaction of the solver with open boundary conditions. Finally I would like to point out that there is probably little to gain, from a computational point of view, in using the FFT-based solver with 100+ CG iterations. If we are using 100+ iterations, we might as well use a faster preconditioner. My script adapted from @ali-ramadhan's:. ```julia; using Printf; using Statistics; using Oceananigans; using Oceananigans.Grids: with_number_type; using Oceananigans.BoundaryConditions: FlatExtrapolationOpenBoundaryCondition; using Oceananigans.Solvers: ConjugateGradientPoissonSolver, fft_poisson_solver; using Oceananigans.Utils: prettytime. N = 16; h, w = 50, 20; H, L = 100, 100; x = y = (-L/2, L/2); z = (-H, 0). grid = RectilinearGrid(size=(N, N, N); x, y, z, halo=(2, 2, 2), topology=(Bounded, Periodic, Bounded)). mount(x, y=0) = h * exp(-(x^2 + y^2) / 2w^2); bottom(x, y=0) = -H + mount(x, y); grid = ImmersedBoundaryGrid(grid, GridFittedBottom(bottom)). prescribed_flow = OpenBoundaryCondition(0.01); extrapolation_bc = FlatExtrapolationOpenBoundaryCondition(); u_bcs = FieldBoundaryConditions(west = prescribed_flow,; east = extrapolation_bc); #east = prescribed_flow). boundary_conditions = (; u=u_bcs); reduced_precision_grid = with_number_type(Float32, grid.underlying_grid); preconditioner = fft_poisson_s",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3831#issuecomment-2415367426
Modifiability,adapt,adapted,", 2, 3...`.; * With `maxiter=100`, the problem is stable with `OpenBoundaryCondition` on west and east. At late times, the solver converges very quickly, in 1-5 iterations. I'd like to analyze the divergence more, but it seems that it is substantially higher with `FlatExtrapolationOpenBoundaryCondition`. I would also like to understand the convergence rate, which seems slower than with a prescribed outflow. From these results we see that `maxiter` should probably be set right now as a matter of practice. I think that even a handful of CG iterations is probably preferred to simply using the FFT solver naively with no CG iteration. There's also future work to understand the interaction of the solver with open boundary conditions. Finally I would like to point out that there is probably little to gain, from a computational point of view, in using the FFT-based solver with 100+ CG iterations. If we are using 100+ iterations, we might as well use a faster preconditioner. My script adapted from @ali-ramadhan's:. ```julia; using Printf; using Statistics; using Oceananigans; using Oceananigans.Grids: with_number_type; using Oceananigans.BoundaryConditions: FlatExtrapolationOpenBoundaryCondition; using Oceananigans.Solvers: ConjugateGradientPoissonSolver, fft_poisson_solver; using Oceananigans.Utils: prettytime. N = 16; h, w = 50, 20; H, L = 100, 100; x = y = (-L/2, L/2); z = (-H, 0). grid = RectilinearGrid(size=(N, N, N); x, y, z, halo=(2, 2, 2), topology=(Bounded, Periodic, Bounded)). mount(x, y=0) = h * exp(-(x^2 + y^2) / 2w^2); bottom(x, y=0) = -H + mount(x, y); grid = ImmersedBoundaryGrid(grid, GridFittedBottom(bottom)). prescribed_flow = OpenBoundaryCondition(0.01); extrapolation_bc = FlatExtrapolationOpenBoundaryCondition(); u_bcs = FieldBoundaryConditions(west = prescribed_flow,; east = extrapolation_bc); #east = prescribed_flow). boundary_conditions = (; u=u_bcs); reduced_precision_grid = with_number_type(Float32, grid.underlying_grid); preconditioner = fft_poisson_s",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3831#issuecomment-2415367426
Usability,simpl,simply,"Ok I did a bit of investigation and found the following (script pasted below):. * Using the default `maxiter = prod(size(grid))` allows the solver to go unstable at the first iteration; * With `maxiter=50` or greater, I get instability with `FlatExtrapolationOpenBoundaryCondition` eventually. However with `maxiter=10` the simulation completes. It's also stable with `maxiter=1, 2, 3...`.; * With `maxiter=100`, the problem is stable with `OpenBoundaryCondition` on west and east. At late times, the solver converges very quickly, in 1-5 iterations. I'd like to analyze the divergence more, but it seems that it is substantially higher with `FlatExtrapolationOpenBoundaryCondition`. I would also like to understand the convergence rate, which seems slower than with a prescribed outflow. From these results we see that `maxiter` should probably be set right now as a matter of practice. I think that even a handful of CG iterations is probably preferred to simply using the FFT solver naively with no CG iteration. There's also future work to understand the interaction of the solver with open boundary conditions. Finally I would like to point out that there is probably little to gain, from a computational point of view, in using the FFT-based solver with 100+ CG iterations. If we are using 100+ iterations, we might as well use a faster preconditioner. My script adapted from @ali-ramadhan's:. ```julia; using Printf; using Statistics; using Oceananigans; using Oceananigans.Grids: with_number_type; using Oceananigans.BoundaryConditions: FlatExtrapolationOpenBoundaryCondition; using Oceananigans.Solvers: ConjugateGradientPoissonSolver, fft_poisson_solver; using Oceananigans.Utils: prettytime. N = 16; h, w = 50, 20; H, L = 100, 100; x = y = (-L/2, L/2); z = (-H, 0). grid = RectilinearGrid(size=(N, N, N); x, y, z, halo=(2, 2, 2), topology=(Bounded, Periodic, Bounded)). mount(x, y=0) = h * exp(-(x^2 + y^2) / 2w^2); bottom(x, y=0) = -H + mount(x, y); grid = ImmersedBoundaryGrid(grid, GridF",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3831#issuecomment-2415367426
Testability,test,test,"> I encountered similar issues months ago when using the CG Poisson solver. I fixed my code by slightly modifying the algorithm ([Yixiao-Zhang@c7983b8/\](https://github.com/Yixiao-Zhang/Oceananigans.jl/commit/c7983b8002b91cd5939018a7c999eae77e2105ac/\)). The reason is that the CG method can be numerically unstably for positive (or negative) semi-definite matrices. Did you encounter the same issue whereby the simulation would _immediately_ NaN (rather than intermittently)? I'd be curious to see your setup in order to have more than one working example to test with. I've made a little progress with regularizing the solver (vs the simpler technique of setting the mean directly). The issue is that while regularization does seem to be able to stabilize the solver, we still experience extremely slow convergence with `FlatExtrapolationOpenBoundaryCondition` to the point that it's basically unusable practically, I think (at least if the same convergence rate is experienced at higher resolution / with better physics). It's unclear whether these issues are generic to the solver or specific to this boundary condition, so having another unstable case would be useful.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3831#issuecomment-2418133864
Usability,simpl,simpler,"> I encountered similar issues months ago when using the CG Poisson solver. I fixed my code by slightly modifying the algorithm ([Yixiao-Zhang@c7983b8/\](https://github.com/Yixiao-Zhang/Oceananigans.jl/commit/c7983b8002b91cd5939018a7c999eae77e2105ac/\)). The reason is that the CG method can be numerically unstably for positive (or negative) semi-definite matrices. Did you encounter the same issue whereby the simulation would _immediately_ NaN (rather than intermittently)? I'd be curious to see your setup in order to have more than one working example to test with. I've made a little progress with regularizing the solver (vs the simpler technique of setting the mean directly). The issue is that while regularization does seem to be able to stabilize the solver, we still experience extremely slow convergence with `FlatExtrapolationOpenBoundaryCondition` to the point that it's basically unusable practically, I think (at least if the same convergence rate is experienced at higher resolution / with better physics). It's unclear whether these issues are generic to the solver or specific to this boundary condition, so having another unstable case would be useful.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3831#issuecomment-2418133864
Integrability,interface,interface,"> I proposed `domain_depth` to distinguish it from the already existing `depth` interface that tracks the `depth` as a function of `k` which is used in the turbulence closure module. I think `domain_depth` communicates the idea of a total static depth. Ok, that makes sense, so `d = depth(i, j, k)` is 3D. What about `column_depth(i, j)`? Just want to have a discussion about it rather than simply deciding. Any other ideas besides ""column"", ""domain"", and ""total""?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3841#issuecomment-2419921844
Usability,simpl,simply,"> I proposed `domain_depth` to distinguish it from the already existing `depth` interface that tracks the `depth` as a function of `k` which is used in the turbulence closure module. I think `domain_depth` communicates the idea of a total static depth. Ok, that makes sense, so `d = depth(i, j, k)` is 3D. What about `column_depth(i, j)`? Just want to have a discussion about it rather than simply deciding. Any other ideas besides ""column"", ""domain"", and ""total""?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3841#issuecomment-2419921844
Usability,clear,clearer,Yeah I should have been clearer. I meant that it could increase compile times.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3851#issuecomment-2429566787
Usability,clear,clearer,"> > @jagoosw, I'm curious to hear your take on the artifacts that appear at the edges of the right `x` boundary. If I plot `v` and `w` those artifacts are also there (also on the ""right"" side), so I think this a general ""issue"" with the algorithm, rather than something wrong with the `x` direction specifically. Do you have any idea of what this is?; > ; > I'm not sure I'm seeing what you mean? Do you mean the corner points being different?. Yes that's what I mean. To be even clearer, these:. ![image](https://github.com/user-attachments/assets/651d18d7-3fe6-46b0-9e88-89ba7b4d1c42). The zero points in `u` being the cause of similar weirdness in the calculations of vorticity. Do you know what's going on there?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3854#issuecomment-2437512264
Integrability,interface,interface,"I've been wanting to clean up this interface a bit but haven't gotten to do it. ; The `grid` argument is used to compute coefficients for stretched advection; if it is not passed, we use uniform spacing coefficients. ; Some time ago, we disabled using stretched coefficients for `Centered` and `Upwind` because it seemed they would make the simulation less stable, but there was no rigorous study to check this. The grid is a kwarg to allow doing stuff like ; ```; WENO(); ```. I think the idea is to move to an interface where every element requires the grid as a positional argument so if this is the idea, we could introduce a keyword argument like `stretched_coefficients` which would make the interface clearer",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3857#issuecomment-2432769529
Usability,clear,clearer,"I've been wanting to clean up this interface a bit but haven't gotten to do it. ; The `grid` argument is used to compute coefficients for stretched advection; if it is not passed, we use uniform spacing coefficients. ; Some time ago, we disabled using stretched coefficients for `Centered` and `Upwind` because it seemed they would make the simulation less stable, but there was no rigorous study to check this. The grid is a kwarg to allow doing stuff like ; ```; WENO(); ```. I think the idea is to move to an interface where every element requires the grid as a positional argument so if this is the idea, we could introduce a keyword argument like `stretched_coefficients` which would make the interface clearer",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3857#issuecomment-2432769529
Usability,learn,learning,"@glwagner, is that what you were intending? We're still learning the ropes on collaborative development via git here...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3862#issuecomment-2433708209
Safety,avoid,avoiding,"It's coming from this annoying function:. https://github.com/CliMA/Oceananigans.jl/blob/30e3e05fe661cb5f7a0db37ab6c3f42ac8c5f80e/src/Fields/field_tuples.jl#L56-L83. which we can certainly simplify. We can also play around this avoiding hitting this line altogether, at least for a certain class of models.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3867#issuecomment-2436404214
Usability,simpl,simplify,"It's coming from this annoying function:. https://github.com/CliMA/Oceananigans.jl/blob/30e3e05fe661cb5f7a0db37ab6c3f42ac8c5f80e/src/Fields/field_tuples.jl#L56-L83. which we can certainly simplify. We can also play around this avoiding hitting this line altogether, at least for a certain class of models.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3867#issuecomment-2436404214
Usability,simpl,simple,"Just as a simple counterargument, when `FT=Float64`, we are not getting precision / promotion issues. This is specific to `Float32`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3870#issuecomment-2445644828
Energy Efficiency,adapt,adapt,"I agree that it always returns a `Float32`. However, `@cuprintln` was clearly showing depths that were `Float64` inside the GPU kernels. Outside any kernel, I was not able to call `znode` and get back a `Float64`. . So I think your right that it might just be a GPU issue and maybe we just need to adapt `StepRangeLen` for the GPU to use `Float32`?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3870#issuecomment-2445709565
Modifiability,adapt,adapt,"I agree that it always returns a `Float32`. However, `@cuprintln` was clearly showing depths that were `Float64` inside the GPU kernels. Outside any kernel, I was not able to call `znode` and get back a `Float64`. . So I think your right that it might just be a GPU issue and maybe we just need to adapt `StepRangeLen` for the GPU to use `Float32`?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3870#issuecomment-2445709565
Usability,clear,clearly,"I agree that it always returns a `Float32`. However, `@cuprintln` was clearly showing depths that were `Float64` inside the GPU kernels. Outside any kernel, I was not able to call `znode` and get back a `Float64`. . So I think your right that it might just be a GPU issue and maybe we just need to adapt `StepRangeLen` for the GPU to use `Float32`?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3870#issuecomment-2445709565
Availability,checkpoint,checkpointing,"Perhaps worth stating here that I think RK3 is vastly superior to AB2 not only because of the faster time-to-solution but also because it is ""self-starting"" (does not depend on tendencies from previous time-steps), checkpointing is cheaper and simplified, and the chance of bugs (which cost us nearly 6 months during parameterization development in the past) wherein ""restarted"" simulations can fail when the prior tendencies have NaN _even_ if we attempt to start with an Euler time-step. So RK3 is both faster _and_ simpler.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3874#issuecomment-2441607679
Integrability,depend,depend,"Perhaps worth stating here that I think RK3 is vastly superior to AB2 not only because of the faster time-to-solution but also because it is ""self-starting"" (does not depend on tendencies from previous time-steps), checkpointing is cheaper and simplified, and the chance of bugs (which cost us nearly 6 months during parameterization development in the past) wherein ""restarted"" simulations can fail when the prior tendencies have NaN _even_ if we attempt to start with an Euler time-step. So RK3 is both faster _and_ simpler.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3874#issuecomment-2441607679
Modifiability,parameteriz,parameterization,"Perhaps worth stating here that I think RK3 is vastly superior to AB2 not only because of the faster time-to-solution but also because it is ""self-starting"" (does not depend on tendencies from previous time-steps), checkpointing is cheaper and simplified, and the chance of bugs (which cost us nearly 6 months during parameterization development in the past) wherein ""restarted"" simulations can fail when the prior tendencies have NaN _even_ if we attempt to start with an Euler time-step. So RK3 is both faster _and_ simpler.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3874#issuecomment-2441607679
Usability,simpl,simplified,"Perhaps worth stating here that I think RK3 is vastly superior to AB2 not only because of the faster time-to-solution but also because it is ""self-starting"" (does not depend on tendencies from previous time-steps), checkpointing is cheaper and simplified, and the chance of bugs (which cost us nearly 6 months during parameterization development in the past) wherein ""restarted"" simulations can fail when the prior tendencies have NaN _even_ if we attempt to start with an Euler time-step. So RK3 is both faster _and_ simpler.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3874#issuecomment-2441607679
Testability,test,tests,"Adding the Manifest won't help for the tests because the test environment generates a new manifest every time, I learned",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3880#issuecomment-2457661193
Usability,learn,learned,"Adding the Manifest won't help for the tests because the test environment generates a new manifest every time, I learned",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3880#issuecomment-2457661193
Testability,test,tested,"Note there is already substepping implemented for CATKEVerticalDiffusivity and TKEDissipationVerticalDiffusivity. What are the challenges? For the closures this feature was relatively straightforward to implement. But this PR seems quite large. For many reasons it is often better to open the PR _first_ (better yet, an issue that defines the problem, so we can discuss designs), rather than at a late stage where feedback is difficult to manifest. Also, rather than supporting this generally for all time-steppers, I would argue that the correct approach is to implement this for just one model and one time-stepper. Once the proof of concept is well developed and tested, it can be applied more broadly in a separate PR.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3888#issuecomment-2450582918
Usability,feedback,feedback,"Note there is already substepping implemented for CATKEVerticalDiffusivity and TKEDissipationVerticalDiffusivity. What are the challenges? For the closures this feature was relatively straightforward to implement. But this PR seems quite large. For many reasons it is often better to open the PR _first_ (better yet, an issue that defines the problem, so we can discuss designs), rather than at a late stage where feedback is difficult to manifest. Also, rather than supporting this generally for all time-steppers, I would argue that the correct approach is to implement this for just one model and one time-stepper. Once the proof of concept is well developed and tested, it can be applied more broadly in a separate PR.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3888#issuecomment-2450582918
Testability,test,tested,"> Note there is already substepping implemented for CATKEVerticalDiffusivity and TKEDissipationVerticalDiffusivity. I hadn't realised that, I'll look into it before I work on this again. > What are the challenges? For the closures this feature was relatively straightforward to implement. But this PR seems quite large. Most of the changes are separating the bgc transitions from the rest of the tendencies which isn't that hard but is just quite a lot of lines. > For many reasons it is often better to open the PR _first_ (better yet, an issue that defines the problem, so we can discuss designs), rather than at a late stage where feedback is difficult to manifest.; > ; > Also, rather than supporting this generally for all time-steppers, I would argue that the correct approach is to implement this for just one model and one time-stepper. Once the proof of concept is well developed and tested, it can be applied more broadly in a separate PR. Yeah, this makes sense, when I started doing this I thought it would be relatively simple, but then realised it's not. I would probably advocate for us to take this as a first draft and start again after discussion if this is something we go forward with.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3888#issuecomment-2451830235
Usability,feedback,feedback,"> Note there is already substepping implemented for CATKEVerticalDiffusivity and TKEDissipationVerticalDiffusivity. I hadn't realised that, I'll look into it before I work on this again. > What are the challenges? For the closures this feature was relatively straightforward to implement. But this PR seems quite large. Most of the changes are separating the bgc transitions from the rest of the tendencies which isn't that hard but is just quite a lot of lines. > For many reasons it is often better to open the PR _first_ (better yet, an issue that defines the problem, so we can discuss designs), rather than at a late stage where feedback is difficult to manifest.; > ; > Also, rather than supporting this generally for all time-steppers, I would argue that the correct approach is to implement this for just one model and one time-stepper. Once the proof of concept is well developed and tested, it can be applied more broadly in a separate PR. Yeah, this makes sense, when I started doing this I thought it would be relatively simple, but then realised it's not. I would probably advocate for us to take this as a first draft and start again after discussion if this is something we go forward with.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3888#issuecomment-2451830235
Deployability,update,update,"s (like the models implemented in OceanBioME) to ""opt-in"" to a substepping scheme. In this design, there's no need to change the existing ""slow"" kernels I don't think. However, we could consider changing the name of them. For example, all that's needed is for the _implementation_ to know when to return a slow source term vs fast source term. > this is where I had to make some more changes to the existing code (and probably the messiest part of what I did), because the code often expects the tendencies to live at timestepper.G / $G^-$, so I made functions that dispatched on the timestepper and usually returned that, but for the new timestepepr returned timestepper.physics.G etc. I'm not sure that new tendencies are needed for substepping. The substepping scheme for CATKE manages to avoid allocating any additional tendencies by preserving the ""slow"" source term:. https://github.com/CliMA/Oceananigans.jl/blob/6c40d7e225c2127051b2703b9c62a8b18260e3a5/src/TurbulenceClosures/turbulence_closure_implementations/TKEBasedVerticalDiffusivities/time_step_catke_equation.jl#L167-L171. The only change that is needed within Oceananigans (in principle) --- as far as I can tell --- is to skip the tracer update for certain tracers (like we do for CATKE and TKEDissipation):. https://github.com/CliMA/Oceananigans.jl/blob/6c40d7e225c2127051b2703b9c62a8b18260e3a5/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_ab2_step.jl#L78-L85. Then the implementer of the BGC model has to perform the substepping inside `update_biogeochemical_state!`:. https://github.com/CliMA/Oceananigans.jl/blob/6c40d7e225c2127051b2703b9c62a8b18260e3a5/src/Models/HydrostaticFreeSurfaceModels/update_hydrostatic_free_surface_model_state.jl#L49. Possibly we can go further and define an interface that does the substepping automatically though. I think that an effort like this would be good not to go so far, and first test ideas in a ""minimal"" implementation that simply uses `update_biogeochemical_state!`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3888#issuecomment-2455670851
Integrability,interface,interface,"Thank you for the written explanation! Here are my comments:. > to split the bgc tendencies from the rest I needed a way to turn them off in the normal tendency computation, I did this by passing a keyword all the way through to biogeochemical_transitions - when I did it this way the intention was to touch as little of the existing code as possible, but it might not be the cleanest/most maintainable. I don't think we need to change anything in the existing kernels code. Instead, we can design an interface that allows biogeochemical models (like the models implemented in OceanBioME) to ""opt-in"" to a substepping scheme. In this design, there's no need to change the existing ""slow"" kernels I don't think. However, we could consider changing the name of them. For example, all that's needed is for the _implementation_ to know when to return a slow source term vs fast source term. > this is where I had to make some more changes to the existing code (and probably the messiest part of what I did), because the code often expects the tendencies to live at timestepper.G / $G^-$, so I made functions that dispatched on the timestepper and usually returned that, but for the new timestepepr returned timestepper.physics.G etc. I'm not sure that new tendencies are needed for substepping. The substepping scheme for CATKE manages to avoid allocating any additional tendencies by preserving the ""slow"" source term:. https://github.com/CliMA/Oceananigans.jl/blob/6c40d7e225c2127051b2703b9c62a8b18260e3a5/src/TurbulenceClosures/turbulence_closure_implementations/TKEBasedVerticalDiffusivities/time_step_catke_equation.jl#L167-L171. The only change that is needed within Oceananigans (in principle) --- as far as I can tell --- is to skip the tracer update for certain tracers (like we do for CATKE and TKEDissipation):. https://github.com/CliMA/Oceananigans.jl/blob/6c40d7e225c2127051b2703b9c62a8b18260e3a5/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_ab2_step.jl#L78-L85. Then the ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3888#issuecomment-2455670851
Modifiability,maintainab,maintainable,"Thank you for the written explanation! Here are my comments:. > to split the bgc tendencies from the rest I needed a way to turn them off in the normal tendency computation, I did this by passing a keyword all the way through to biogeochemical_transitions - when I did it this way the intention was to touch as little of the existing code as possible, but it might not be the cleanest/most maintainable. I don't think we need to change anything in the existing kernels code. Instead, we can design an interface that allows biogeochemical models (like the models implemented in OceanBioME) to ""opt-in"" to a substepping scheme. In this design, there's no need to change the existing ""slow"" kernels I don't think. However, we could consider changing the name of them. For example, all that's needed is for the _implementation_ to know when to return a slow source term vs fast source term. > this is where I had to make some more changes to the existing code (and probably the messiest part of what I did), because the code often expects the tendencies to live at timestepper.G / $G^-$, so I made functions that dispatched on the timestepper and usually returned that, but for the new timestepepr returned timestepper.physics.G etc. I'm not sure that new tendencies are needed for substepping. The substepping scheme for CATKE manages to avoid allocating any additional tendencies by preserving the ""slow"" source term:. https://github.com/CliMA/Oceananigans.jl/blob/6c40d7e225c2127051b2703b9c62a8b18260e3a5/src/TurbulenceClosures/turbulence_closure_implementations/TKEBasedVerticalDiffusivities/time_step_catke_equation.jl#L167-L171. The only change that is needed within Oceananigans (in principle) --- as far as I can tell --- is to skip the tracer update for certain tracers (like we do for CATKE and TKEDissipation):. https://github.com/CliMA/Oceananigans.jl/blob/6c40d7e225c2127051b2703b9c62a8b18260e3a5/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_ab2_step.jl#L78-L85. Then the ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3888#issuecomment-2455670851
Performance,perform,perform,"s (like the models implemented in OceanBioME) to ""opt-in"" to a substepping scheme. In this design, there's no need to change the existing ""slow"" kernels I don't think. However, we could consider changing the name of them. For example, all that's needed is for the _implementation_ to know when to return a slow source term vs fast source term. > this is where I had to make some more changes to the existing code (and probably the messiest part of what I did), because the code often expects the tendencies to live at timestepper.G / $G^-$, so I made functions that dispatched on the timestepper and usually returned that, but for the new timestepepr returned timestepper.physics.G etc. I'm not sure that new tendencies are needed for substepping. The substepping scheme for CATKE manages to avoid allocating any additional tendencies by preserving the ""slow"" source term:. https://github.com/CliMA/Oceananigans.jl/blob/6c40d7e225c2127051b2703b9c62a8b18260e3a5/src/TurbulenceClosures/turbulence_closure_implementations/TKEBasedVerticalDiffusivities/time_step_catke_equation.jl#L167-L171. The only change that is needed within Oceananigans (in principle) --- as far as I can tell --- is to skip the tracer update for certain tracers (like we do for CATKE and TKEDissipation):. https://github.com/CliMA/Oceananigans.jl/blob/6c40d7e225c2127051b2703b9c62a8b18260e3a5/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_ab2_step.jl#L78-L85. Then the implementer of the BGC model has to perform the substepping inside `update_biogeochemical_state!`:. https://github.com/CliMA/Oceananigans.jl/blob/6c40d7e225c2127051b2703b9c62a8b18260e3a5/src/Models/HydrostaticFreeSurfaceModels/update_hydrostatic_free_surface_model_state.jl#L49. Possibly we can go further and define an interface that does the substepping automatically though. I think that an effort like this would be good not to go so far, and first test ideas in a ""minimal"" implementation that simply uses `update_biogeochemical_state!`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3888#issuecomment-2455670851
Safety,avoid,avoid,"ut it might not be the cleanest/most maintainable. I don't think we need to change anything in the existing kernels code. Instead, we can design an interface that allows biogeochemical models (like the models implemented in OceanBioME) to ""opt-in"" to a substepping scheme. In this design, there's no need to change the existing ""slow"" kernels I don't think. However, we could consider changing the name of them. For example, all that's needed is for the _implementation_ to know when to return a slow source term vs fast source term. > this is where I had to make some more changes to the existing code (and probably the messiest part of what I did), because the code often expects the tendencies to live at timestepper.G / $G^-$, so I made functions that dispatched on the timestepper and usually returned that, but for the new timestepepr returned timestepper.physics.G etc. I'm not sure that new tendencies are needed for substepping. The substepping scheme for CATKE manages to avoid allocating any additional tendencies by preserving the ""slow"" source term:. https://github.com/CliMA/Oceananigans.jl/blob/6c40d7e225c2127051b2703b9c62a8b18260e3a5/src/TurbulenceClosures/turbulence_closure_implementations/TKEBasedVerticalDiffusivities/time_step_catke_equation.jl#L167-L171. The only change that is needed within Oceananigans (in principle) --- as far as I can tell --- is to skip the tracer update for certain tracers (like we do for CATKE and TKEDissipation):. https://github.com/CliMA/Oceananigans.jl/blob/6c40d7e225c2127051b2703b9c62a8b18260e3a5/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_ab2_step.jl#L78-L85. Then the implementer of the BGC model has to perform the substepping inside `update_biogeochemical_state!`:. https://github.com/CliMA/Oceananigans.jl/blob/6c40d7e225c2127051b2703b9c62a8b18260e3a5/src/Models/HydrostaticFreeSurfaceModels/update_hydrostatic_free_surface_model_state.jl#L49. Possibly we can go further and define an interface that does the substepp",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3888#issuecomment-2455670851
Testability,test,test,"s (like the models implemented in OceanBioME) to ""opt-in"" to a substepping scheme. In this design, there's no need to change the existing ""slow"" kernels I don't think. However, we could consider changing the name of them. For example, all that's needed is for the _implementation_ to know when to return a slow source term vs fast source term. > this is where I had to make some more changes to the existing code (and probably the messiest part of what I did), because the code often expects the tendencies to live at timestepper.G / $G^-$, so I made functions that dispatched on the timestepper and usually returned that, but for the new timestepepr returned timestepper.physics.G etc. I'm not sure that new tendencies are needed for substepping. The substepping scheme for CATKE manages to avoid allocating any additional tendencies by preserving the ""slow"" source term:. https://github.com/CliMA/Oceananigans.jl/blob/6c40d7e225c2127051b2703b9c62a8b18260e3a5/src/TurbulenceClosures/turbulence_closure_implementations/TKEBasedVerticalDiffusivities/time_step_catke_equation.jl#L167-L171. The only change that is needed within Oceananigans (in principle) --- as far as I can tell --- is to skip the tracer update for certain tracers (like we do for CATKE and TKEDissipation):. https://github.com/CliMA/Oceananigans.jl/blob/6c40d7e225c2127051b2703b9c62a8b18260e3a5/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_ab2_step.jl#L78-L85. Then the implementer of the BGC model has to perform the substepping inside `update_biogeochemical_state!`:. https://github.com/CliMA/Oceananigans.jl/blob/6c40d7e225c2127051b2703b9c62a8b18260e3a5/src/Models/HydrostaticFreeSurfaceModels/update_hydrostatic_free_surface_model_state.jl#L49. Possibly we can go further and define an interface that does the substepping automatically though. I think that an effort like this would be good not to go so far, and first test ideas in a ""minimal"" implementation that simply uses `update_biogeochemical_state!`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3888#issuecomment-2455670851
Usability,simpl,simply,"s (like the models implemented in OceanBioME) to ""opt-in"" to a substepping scheme. In this design, there's no need to change the existing ""slow"" kernels I don't think. However, we could consider changing the name of them. For example, all that's needed is for the _implementation_ to know when to return a slow source term vs fast source term. > this is where I had to make some more changes to the existing code (and probably the messiest part of what I did), because the code often expects the tendencies to live at timestepper.G / $G^-$, so I made functions that dispatched on the timestepper and usually returned that, but for the new timestepepr returned timestepper.physics.G etc. I'm not sure that new tendencies are needed for substepping. The substepping scheme for CATKE manages to avoid allocating any additional tendencies by preserving the ""slow"" source term:. https://github.com/CliMA/Oceananigans.jl/blob/6c40d7e225c2127051b2703b9c62a8b18260e3a5/src/TurbulenceClosures/turbulence_closure_implementations/TKEBasedVerticalDiffusivities/time_step_catke_equation.jl#L167-L171. The only change that is needed within Oceananigans (in principle) --- as far as I can tell --- is to skip the tracer update for certain tracers (like we do for CATKE and TKEDissipation):. https://github.com/CliMA/Oceananigans.jl/blob/6c40d7e225c2127051b2703b9c62a8b18260e3a5/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_ab2_step.jl#L78-L85. Then the implementer of the BGC model has to perform the substepping inside `update_biogeochemical_state!`:. https://github.com/CliMA/Oceananigans.jl/blob/6c40d7e225c2127051b2703b9c62a8b18260e3a5/src/Models/HydrostaticFreeSurfaceModels/update_hydrostatic_free_surface_model_state.jl#L49. Possibly we can go further and define an interface that does the substepping automatically though. I think that an effort like this would be good not to go so far, and first test ideas in a ""minimal"" implementation that simply uses `update_biogeochemical_state!`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3888#issuecomment-2455670851
Deployability,update,update,"So in summary, a future effort should take these steps:. 1. Write a function like `substepped_tracers(bgc::AbstractBiogeochemistry)` that can be extended by a hypothetical substepping BGC implementation.; 2. Prototype this concept by implementing a new (hopefully simple, one tracer) BGC model, and prototype the time-stepping algorithm that substeps the tracer forward during `update_biogeocemical_state!`. This should be easy to merge since it only requires defining the one new function `substepped_tracers` for skipping the tracer update. Furthermore, the prototype will demonstrate that the substepping is useful for a stiff problem, and will also develop a substepping scheme. Next, we can consider building an interface for doing the substepping itself, much like we have an interface for doing ordinary time-stepping. That will require a bit more design, but I think the initial prototype will give us a lot of information about the best way to go about it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3888#issuecomment-2455678251
Integrability,interface,interface,"So in summary, a future effort should take these steps:. 1. Write a function like `substepped_tracers(bgc::AbstractBiogeochemistry)` that can be extended by a hypothetical substepping BGC implementation.; 2. Prototype this concept by implementing a new (hopefully simple, one tracer) BGC model, and prototype the time-stepping algorithm that substeps the tracer forward during `update_biogeocemical_state!`. This should be easy to merge since it only requires defining the one new function `substepped_tracers` for skipping the tracer update. Furthermore, the prototype will demonstrate that the substepping is useful for a stiff problem, and will also develop a substepping scheme. Next, we can consider building an interface for doing the substepping itself, much like we have an interface for doing ordinary time-stepping. That will require a bit more design, but I think the initial prototype will give us a lot of information about the best way to go about it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3888#issuecomment-2455678251
Modifiability,extend,extended,"So in summary, a future effort should take these steps:. 1. Write a function like `substepped_tracers(bgc::AbstractBiogeochemistry)` that can be extended by a hypothetical substepping BGC implementation.; 2. Prototype this concept by implementing a new (hopefully simple, one tracer) BGC model, and prototype the time-stepping algorithm that substeps the tracer forward during `update_biogeocemical_state!`. This should be easy to merge since it only requires defining the one new function `substepped_tracers` for skipping the tracer update. Furthermore, the prototype will demonstrate that the substepping is useful for a stiff problem, and will also develop a substepping scheme. Next, we can consider building an interface for doing the substepping itself, much like we have an interface for doing ordinary time-stepping. That will require a bit more design, but I think the initial prototype will give us a lot of information about the best way to go about it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3888#issuecomment-2455678251
Usability,simpl,simple,"So in summary, a future effort should take these steps:. 1. Write a function like `substepped_tracers(bgc::AbstractBiogeochemistry)` that can be extended by a hypothetical substepping BGC implementation.; 2. Prototype this concept by implementing a new (hopefully simple, one tracer) BGC model, and prototype the time-stepping algorithm that substeps the tracer forward during `update_biogeocemical_state!`. This should be easy to merge since it only requires defining the one new function `substepped_tracers` for skipping the tracer update. Furthermore, the prototype will demonstrate that the substepping is useful for a stiff problem, and will also develop a substepping scheme. Next, we can consider building an interface for doing the substepping itself, much like we have an interface for doing ordinary time-stepping. That will require a bit more design, but I think the initial prototype will give us a lot of information about the best way to go about it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3888#issuecomment-2455678251
Testability,test,test,"@liuchihl check out the similarity between the simple test that I added and the MWE on #3889. I just copy-pasted the MWE code into the test (and made a few generalizations). It should be ready to merge, and it all only took a few minutes.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3890#issuecomment-2450966049
Usability,simpl,simple,"@liuchihl check out the similarity between the simple test that I added and the MWE on #3889. I just copy-pasted the MWE code into the test (and made a few generalizations). It should be ready to merge, and it all only took a few minutes.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3890#issuecomment-2450966049
